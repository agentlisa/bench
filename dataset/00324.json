{
  "Title": "M-1: Rewards can be allocated for less than minimal reward period with the help of bogus proposal",
  "Content": "# Issue M-1: Rewards can be allocated for less than minimal reward period with the help of bogus proposal \n\nSource: https://github.com/sherlock-audit/2024-03-nouns-dao-2-judging/issues/32 \n\n## Found by \nhyh\n## Summary\n\nAnyone controlling more than `proposalThresholdBPS` share of votes can ignore the minimum reward period to allocate the rewards for the proposal they benefit from.\n\n## Vulnerability Detail\n\nThe `minimumRewardPeriod` check can be surpassed with the help of any bogus proposal since the check comes before proposal eligibility control. I.e. once current `block.timestamp` is big enough an attacker can just create a proposal only to get past the check by later using that proposal as a anchor for reward distribution call.\n\nThis proposal doesn't have to be eligible (can be heavily voted against, can even be vetoed), the only requirement is that it should have ended (`require(block.number > endBlock, ...` check), i.e. the attacker needs to create it beforehand, but the timing is exact and is known in advance, so this can be done all the times. Note that `objectionPeriodEndBlock` is activated only for flipped proposals, which is higly unlikely for bogus ones, so `endBlock = max(proposals[i].endBlock, proposals[i].objectionPeriodEndBlock) = proposals[i].endBlock`, which is known as of time of proposal creation.\n\n## Impact\n\nThe attack can be carried deterministically, there are no direct prerequisites, while the total cost is additional proposal creation gas cost only (it's not compensated). Surpassing the `minimumRewardPeriod` check can be used for gaming reward allocation, i.e. placing good auctions to the proposal attacker benefit ahead of other proposals, who have to wait for the period to expire.\n\nI.e. in a situation when there are only few active proposals that are about to end, while attacker's one is ended, `$.params.numProposalsEnoughForReward` isn't met, while current auctions have good revenue, the attacker can steal the rewards from other proposals by not waiting for them with the help of the anchor bogus one. Overall, this setup has medium probability of occurring, while the reward loss can be material, so the impact can be estimated as medium as well.\n\nLikelihood: Medium + Impact: Medium = Severity: Medium.\n\n## Code Snippet\n\n`t.lastProposal.creationTimestamp` comes from user supplied `lastProposalId`:\n\nhttps://github.com/sherlock-audit/2024-03-nouns-dao-2/blob/main/nouns-monorepo/packages/nouns-contracts/contracts/client-incentives/Rewards.sol#L370-L383\n\n```solidity\n        //// Check that distribution is allowed:\n        //// 1. At least one eligible proposal.\n        //// 2. One of the two conditions must be true:\n        //// 2.a. Number of eligible proposals is at least `numProposalsEnoughForReward`.\n        //// 2.b. At least `minimumRewardPeriod` seconds have passed since the last update.\n\n        require(t.numEligibleProposals > 0, 'at least one eligible proposal');\n        if (t.numEligibleProposals < $.params.numProposalsEnoughForReward) {\n            require(\n>>              t.lastProposal.creationTimestamp > $.lastProposalRewardsUpdate + $.params.minimumRewardPeriod,\n                'not enough time passed'\n            );\n        }\n        $.lastProposalRewardsUpdate = uint40(t.lastProposal.creationTimestamp);\n```\n\nWith the only checks being `nounsDAO.proposalCount() >= lastProposalId >= t.nextProposalIdToReward`, since `proposalDataForRewards` doesn't filter the proposals, returning all the results sequentially:\n\nhttps://github.com/sherlock-audit/2024-03-nouns-dao-2/blob/main/nouns-monorepo/packages/nouns-contracts/contracts/client-incentives/Rewards.sol#L319-L330\n\n```solidity\n>>      require(lastProposalId <= nounsDAO.proposalCount(), 'bad lastProposalId');\n>>      require(lastProposalId >= t.nextProposalIdToReward, 'bad lastProposalId');\n        require(isSortedAndNoDuplicates(votingClientIds), 'must be sorted & unique');\n\n>>      NounsDAOTypes.ProposalForRewards[] memory proposals = nounsDAO.proposalDataForRewards(\n            t.nextProposalIdToReward,\n            lastProposalId,\n            votingClientIds\n        );\n        $.nextProposalIdToReward = lastProposalId + 1;\n\n>>      t.lastProposal = proposals[proposals.length - 1];\n```\n\nUser that can create proposals can also anyhow time the bogus one:\n\nhttps://github.com/sherlock-audit/2024-03-nouns-dao-2/blob/main/nouns-monorepo/packages/nouns-contracts/contracts/governance/NounsDAOProposals.sol#L871-L881\n\n```solidity\n    function createNewProposal(\n        ...\n    ) internal returns (NounsDAOTypes.Proposal storage newProposal) {\n        uint64 updatePeriodEndBlock = SafeCast.toUint64(block.number + ds.proposalUpdatablePeriodInBlocks);\n        uint256 startBlock = updatePeriodEndBlock + ds.votingDelay;\n>>      uint256 endBlock = startBlock + ds.votingPeriod;\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider basing the check on the last eligible proposal, not just the user supplied one, e.g. by filtering them out in `proposalDataForRewards()`, which isn't used outside reward logic:\n\nhttps://github.com/sherlock-audit/2024-03-nouns-dao-2/blob/main/nouns-monorepo/packages/nouns-contracts/contracts/governance/NounsDAOProposals.sol#L719-L737\n\n```diff\n    function proposalDataForRewards(\n        NounsDAOTypes.Storage storage ds,\n        uint256 firstProposalId,\n        uint256 lastProposalId,\n+       uint16 proposalEligibilityQuorumBps,\n        uint32[] calldata votingClientIds\n    ) internal view returns (NounsDAOTypes.ProposalForRewards[] memory) {\n        require(lastProposalId >= firstProposalId, 'lastProposalId >= firstProposalId');\n        uint256 numProposals = lastProposalId - firstProposalId + 1;\n        NounsDAOTypes.ProposalForRewards[] memory data = new NounsDAOTypes.ProposalForRewards[](numProposals);\n\n        NounsDAOTypes.Proposal storage proposal;\n        uint256 i;\n        for (uint256 pid = firstProposalId; pid <= lastProposalId; ++pid) {\n            proposal = ds._proposals[pid];\n+           if (proposal.canceled || proposals.forVotes < (proposals.totalSupply * proposalEligibilityQuorumBps) / 10_000) continue;\n\n            NounsDAOTypes.ClientVoteData[] memory c = new NounsDAOTypes.ClientVoteData[](votingClientIds.length);\n            for (uint256 j; j < votingClientIds.length; ++j) {\n                c[j] = proposal.voteClients[votingClientIds[j]];\n            }\n```\n\nIn order to minimize the changes this suggestion is shared with another issues.\n\n\n\n## Discussion\n\n**eladmallel**\n\nThanks for for bringing this up! This issue's fix will probably be the same as #46, with better proposal filtering.\n\n**dmitriia**\n\nThis and #46 have the same fix, which is included in the #51 recommendation (3rd code snippet).\n\nI.e. for #32, #46 and #51 set please use the fix from #51 as it covers them all.\n\n**WangSecurity**\n\n@dmitriia want to confirm that these three issues are not dups, even though they have the same fix?\n\n**dmitriia**\n\n@WangSecurity They are different: 32 is for the avoidance of minimal reward period, 46 is for extending auction revenue span, while 51 is for manipulation with the help of proposal canceling. \n\nThey can have different fixes, but the recommendation is just unified to minimize code changes. Although, the base recommendation for 51 by itself doesn't include the 32 and 46 fixes, but there is an expanded write up of the cumulative change put there, that includes some logic optimization along with these fixes. \n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/nounsDAO/nouns-monorepo/pull/839\n\n\n**dmitriia**\n\nFix looks ok.\n\n**sherlock-admin4**\n\nThe Lead Senior Watson signed off on the fix.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/202",
  "Code": [
    {
      "filename": "nouns-monorepo/packages/nouns-contracts/contracts/client-incentives/Rewards.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/// @title The client incentives rewards logic\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\npragma solidity ^0.8.19;\n\nimport { INounsDAOLogic } from '../interfaces/INounsDAOLogic.sol';\nimport { INounsAuctionHouseV2 } from '../interfaces/INounsAuctionHouseV2.sol';\nimport { NounsDAOTypes } from '../governance/NounsDAOInterfaces.sol';\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { UUPSUpgradeable } from '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport { SafeERC20 } from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport { PausableUpgradeable } from '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\nimport { ClientRewardsMemoryMapping } from '../libs/ClientRewardsMemoryMapping.sol';\nimport { GasRefund } from '../libs/GasRefund.sol';\nimport { INounsClientTokenDescriptor } from './INounsClientTokenDescriptor.sol';\nimport { INounsClientTokenTypes } from './INounsClientTokenTypes.sol';\nimport { OwnableUpgradeable } from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport { ERC721Upgradeable } from '@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol';\nimport { SafeCast } from '@openzeppelin/contracts/utils/math/SafeCast.sol';\n\ncontract Rewards is\n    UUPSUpgradeable,\n    PausableUpgradeable,\n    OwnableUpgradeable,\n    ERC721Upgradeable,\n    INounsClientTokenTypes\n{\n    using SafeERC20 for IERC20;\n    using ClientRewardsMemoryMapping for ClientRewardsMemoryMapping.Mapping;\n\n    /**\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     *   EVENTS\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     */\n\n    event ClientRegistered(uint32 indexed clientId, string name, string description);\n    event ClientUpdated(uint32 indexed clientId, string name, string description);\n    event ClientRewarded(uint32 indexed clientId, uint256 amount);\n    event ClientBalanceWithdrawal(uint32 indexed clientId, uint256 amount, address to);\n    event AuctionRewardsUpdated(uint256 firstAuctionId, uint256 lastAuctionId);\n    event ProposalRewardsUpdated(\n        uint32 firstProposalId,\n        uint32 lastProposalId,\n        uint256 firstAuctionIdForRevenue,\n        uint256 lastAuctionIdForRevenue,\n        uint256 auctionRevenue,\n        uint256 rewardPerProposal,\n        uint256 rewardPerVote\n    );\n    event ClientApprovalSet(uint32 indexed clientId, bool approved);\n\n    /**\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     *   IMMUTABLES\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     */\n\n    INounsDAOLogic public immutable nounsDAO;\n\n    INounsAuctionHouseV2 public immutable auctionHouse;\n\n    /**\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     *   STORAGE VARIABLES\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     */\n\n    struct RewardParams {\n        /// @dev Used for proposal rewards\n        /// @dev The minimum reward period for proposal updates if number of proposals is below `numProposalsEnoughForReward`\n        uint32 minimumRewardPeriod;\n        /// @dev The number of proposals required for an update before `minimumRewardPeriod` has passed\n        uint8 numProposalsEnoughForReward;\n        /// @dev How much bips out of the auction revenue during this period to use for rewarding proposal creation\n        uint16 proposalRewardBps;\n        /// @dev How much bips out of the auction revenue during this period to use for rewarding proposal voting\n        uint16 votingRewardBps;\n        /// @dev How many (in bips) FOR votes out of total votes are required for a proposal to be eligible for rewards\n        uint16 proposalEligibilityQuorumBps;\n        /// @dev Used for auction rewards\n        /// @dev How much bips out of auction revnue to use for rewarding auction bidding\n        uint16 auctionRewardBps;\n        /// @dev Minimum number of auctions between updates. Zero means 1 auction is enough.\n        uint8 minimumAuctionsBetweenUpdates;\n    }\n\n    /// @custom:storage-location erc7201:nouns.rewards\n    struct RewardsStorage {\n        /// @dev The next client token id to be minted\n        uint32 nextTokenId;\n        /// @dev Used for auction rewards state\n        uint32 nextAuctionIdToReward;\n        /// @dev Used for proposal rewards state\n        uint32 nextProposalIdToReward;\n        /// @dev The first auction id to consider for revenue tracking on the next proposal rewards update\n        uint32 nextProposalRewardFirstAuctionId;\n        /// @dev Last time the proposal rewards update was performed\n        uint40 lastProposalRewardsUpdate;\n        /// @dev Params for both auction & rewards\n        RewardParams params;\n        /// @dev An ETH pegged ERC20 token to use for rewarding\n        IERC20 ethToken;\n        /// @dev admin account able to pause/unpause the contract in case of a quick response is needed\n        address admin;\n        /// @dev client metadata per clientId, including rewards balances, name, description\n        mapping(uint32 clientId => ClientMetadata) _clientMetadata;\n        /// @dev The client NFT descriptor\n        address descriptor;\n    }\n\n    /// @dev This is a ERC-7201 storage location, calculated using:\n    /// @dev keccak256(abi.encode(uint256(keccak256(\"nouns.rewards\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 public constant RewardsStorageLocation = 0x9a06af3161ac5b0c3de4e6c981ab9d9f60b530386f5eaae00d541393fbecd700;\n\n    function _getRewardsStorage() private pure returns (RewardsStorage storage $) {\n        assembly {\n            $.slot := RewardsStorageLocation\n        }\n    }\n\n    /**\n     * @dev Reverts if called by any account other than the owner or admin.\n     */\n    modifier onlyOwnerOrAdmin() {\n        RewardsStorage storage $ = _getRewardsStorage();\n        require(owner() == _msgSender() || $.admin == _msgSender(), 'Caller must be owner or admin');\n        _;\n    }\n\n    constructor(address nounsDAO_, address auctionHouse_) initializer {\n        nounsDAO = INounsDAOLogic(nounsDAO_);\n        auctionHouse = INounsAuctionHouseV2(auctionHouse_);\n    }\n\n    function initialize(\n        address owner,\n        address admin_,\n        address ethToken_,\n        uint32 nextProposalIdToReward_,\n        uint32 nextAuctionIdToReward_,\n        uint32 nextProposalRewardFirstAuctionId_,\n        RewardParams memory rewardParams,\n        address descriptor_\n    ) public initializer {\n        __Pausable_init_unchained();\n        __ERC721_init('Nouns Client Token', 'NOUNSCLIENT');\n\n        RewardsStorage storage $ = _getRewardsStorage();\n        $.nextTokenId = 1;\n        $.lastProposalRewardsUpdate = uint40(block.timestamp);\n\n        _transferOwnership(owner);\n        $.admin = admin_;\n        $.ethToken = IERC20(ethToken_);\n        $.nextProposalIdToReward = nextProposalIdToReward_;\n        $.nextAuctionIdToReward = nextAuctionIdToReward_;\n        $.nextProposalRewardFirstAuctionId = nextProposalRewardFirstAuctionId_;\n        $.params = rewardParams;\n        $.descriptor = descriptor_;\n    }\n\n    /**\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     *   PUBLIC WRITE\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     */\n\n    /**\n     * @notice Register a client, mints an NFT and assigns a clientId\n     * @return uint32 the newly assigned clientId\n     */\n    function registerClient(string calldata name, string calldata description) external whenNotPaused returns (uint32) {\n        RewardsStorage storage $ = _getRewardsStorage();\n\n        uint32 tokenId = $.nextTokenId;\n        $.nextTokenId = tokenId + 1;\n        _mint(msg.sender, tokenId);\n\n        ClientMetadata storage md = $._clientMetadata[tokenId];\n        md.name = name;\n        md.description = description;\n\n        emit ClientRegistered(tokenId, name, description);\n\n        return tokenId;\n    }\n\n    /**\n     * @notice Update the metadata of a client\n     * @dev Only the owner of the client token can update the metadata.\n     * @param tokenId The token ID of the client\n     * @param name The new name of the client\n     * @param description The new description of the client\n     */\n    function updateClientMetadata(uint32 tokenId, string calldata name, string calldata description) external {\n        RewardsStorage storage $ = _getRewardsStorage();\n\n        require(ownerOf(tokenId) == msg.sender, 'NounsClientToken: not owner');\n        ClientMetadata storage md = $._clientMetadata[tokenId];\n        md.name = name;\n        md.description = description;\n\n        emit ClientUpdated(tokenId, name, description);\n    }\n\n    /**\n     * @notice Distribute rewards for auction bidding since the last update until auction with id `lastNounId`\n     * If an auction's winning bid was called with a clientId, that client will be reward with `params.auctionRewardBps`\n     * bips of the auction's settlement amount.\n     * At least `minimumAuctionsBetweenUpdates` must happen between updates.\n     * Gas spent is refunded in `ethToken`.\n     * @param lastNounId the last auction id to reward client for. must be already settled.\n     * @dev Gas is refunded if at least one auction was rewarded\n     */\n    function updateRewardsForAuctions(uint32 lastNounId) public whenNotPaused {\n        uint256 startGas = gasleft();\n        RewardsStorage storage $ = _getRewardsStorage();\n\n        bool sawValidClientId = false;\n        uint256 nextAuctionIdToReward_ = $.nextAuctionIdToReward;\n        require(\n            lastNounId >= nextAuctionIdToReward_ + $.params.minimumAuctionsBetweenUpdates,\n            'lastNounId must be higher'\n        );\n        $.nextAuctionIdToReward = lastNounId + 1;\n\n        INounsAuctionHouseV2.Settlement[] memory settlements = auctionHouse.getSettlements(\n            nextAuctionIdToReward_,\n            lastNounId + 1,\n            true\n        );\n        INounsAuctionHouseV2.Settlement memory lastSettlement = settlements[settlements.length - 1];\n        require(lastSettlement.nounId == lastNounId && lastSettlement.blockTimestamp > 1, 'lastNounId must be settled');\n\n        uint32 maxClientId = nextTokenId() - 1;\n        ClientRewardsMemoryMapping.Mapping memory m = ClientRewardsMemoryMapping.createMapping({\n            maxClientId: maxClientId\n        });\n\n        for (uint256 i; i < settlements.length; ++i) {\n            INounsAuctionHouseV2.Settlement memory settlement = settlements[i];\n            if (settlement.clientId != 0 && settlement.clientId <= maxClientId) {\n                sawValidClientId = true;\n                m.inc(settlement.clientId, settlement.amount);\n            }\n        }\n\n        uint16 auctionRewardBps = $.params.auctionRewardBps;\n        uint256 numValues = m.numValues();\n        for (uint32 i = 0; i < numValues; ++i) {\n            ClientRewardsMemoryMapping.ClientBalance memory cb = m.getValue(i);\n            uint256 reward = (cb.balance * auctionRewardBps) / 10_000;\n            $._clientMetadata[cb.clientId].rewarded += SafeCast.toUint96(reward);\n\n            emit ClientRewarded(cb.clientId, reward);\n        }\n\n        emit AuctionRewardsUpdated(nextAuctionIdToReward_, lastNounId);\n\n        if (sawValidClientId) {\n            // refund gas only if we're actually rewarding a client, not just moving the pointer\n            GasRefund.refundGas($.ethToken, startGas);\n        }\n    }\n\n    /// @dev struct used to avoid stack-too-deep errors\n    struct Temp {\n        uint32 maxClientId;\n        uint256 numEligibleVotes;\n        uint256 numEligibleProposals;\n        uint256 rewardPerProposal;\n        uint256 rewardPerVote;\n        uint256 proposalRewardForPeriod;\n        uint256 votingRewardForPeriod;\n        uint32 nextProposalIdToReward;\n        uint256 firstAuctionIdForRevenue;\n        NounsDAOTypes.ProposalForRewards lastProposal;\n    }\n\n    /**\n     * @notice Distribute rewards for proposal creation and voting from the last update until `lastProposalId`.\n     * A proposal is eligible for rewards if for-votes/total-votes >= params.proposalEligibilityQuorumBps.\n     * Rewards are calculated by the auctions revenue during the period between the creation time of last proposal in\n     * the previous update until the current last proposal with id `lastProposalId`.\n     * Gas spent is refunded in `ethToken`.\n     * @param lastProposalId id of the last proposal to include in the rewards distribution. all proposals up to and\n     * including this id must have ended voting.\n     * @param votingClientIds array of sorted client ids that were used to vote on the eligible proposals in\n     * this rewards distribution. reverts if contains duplicates. reverts if not sorted. reverts if a clientId had zero votes.\n     * You may use `getVotingClientIds` as a convenience function to get the correct `votingClientIds`.\n     */\n    function updateRewardsForProposalWritingAndVoting(\n        uint32 lastProposalId,\n        uint32[] calldata votingClientIds\n    ) public whenNotPaused {\n        uint256 startGas = gasleft();\n        RewardsStorage storage $ = _getRewardsStorage();\n\n        Temp memory t;\n\n        t.maxClientId = nextTokenId() - 1;\n        t.nextProposalIdToReward = $.nextProposalIdToReward;\n\n        require(lastProposalId <= nounsDAO.proposalCount(), 'bad lastProposalId');\n        require(lastProposalId >= t.nextProposalIdToReward, 'bad lastProposalId');\n        require(isSortedAndNoDuplicates(votingClientIds), 'must be sorted & unique');\n\n        NounsDAOTypes.ProposalForRewards[] memory proposals = nounsDAO.proposalDataForRewards(\n            t.nextProposalIdToReward,\n            lastProposalId,\n            votingClientIds\n        );\n        $.nextProposalIdToReward = lastProposalId + 1;\n\n        t.lastProposal = proposals[proposals.length - 1];\n\n        t.firstAuctionIdForRevenue = $.nextProposalRewardFirstAuctionId;\n        (uint256 auctionRevenue, uint256 lastAuctionIdForRevenue) = getAuctionRevenue({\n            firstNounId: t.firstAuctionIdForRevenue,\n            endTimestamp: t.lastProposal.creationTimestamp\n        });\n        $.nextProposalRewardFirstAuctionId = uint32(lastAuctionIdForRevenue) + 1;\n\n        require(auctionRevenue > 0, 'auctionRevenue must be > 0');\n\n        t.proposalRewardForPeriod = (auctionRevenue * $.params.proposalRewardBps) / 10_000;\n        t.votingRewardForPeriod = (auctionRevenue * $.params.votingRewardBps) / 10_000;\n\n        uint16 proposalEligibilityQuorumBps_ = $.params.proposalEligibilityQuorumBps;\n\n        //// First loop over the proposals:\n        //// 1. Make sure all proposals have finished voting.\n        //// 2. Delete (zero out) proposals that are non elgibile (i.e. not enough For votes).\n        //// 3. Count the number of eligible proposals.\n        //// 4. Count the number of votes in eligible proposals.\n\n        for (uint256 i; i < proposals.length; ++i) {\n            // make sure proposal finished voting\n            uint endBlock = max(proposals[i].endBlock, proposals[i].objectionPeriodEndBlock);\n            require(block.number > endBlock, 'all proposals must be done with voting');\n\n            // skip non eligible proposals\n            if (proposals[i].forVotes < (proposals[i].totalSupply * proposalEligibilityQuorumBps_) / 10_000) {\n                delete proposals[i];\n                continue;\n            }\n\n            // proposal is eligible for reward\n            ++t.numEligibleProposals;\n\n            uint256 votesInProposal = proposals[i].forVotes + proposals[i].againstVotes + proposals[i].abstainVotes;\n            t.numEligibleVotes += votesInProposal;\n        }\n\n        //// Check that distribution is allowed:\n        //// 1. At least one eligible proposal.\n        //// 2. One of the two conditions must be true:\n        //// 2.a. Number of eligible proposals is at least `numProposalsEnoughForReward`.\n        //// 2.b. At least `minimumRewardPeriod` seconds have passed since the last update.\n\n        require(t.numEligibleProposals > 0, 'at least one eligible proposal');\n        if (t.numEligibleProposals < $.params.numProposalsEnoughForReward) {\n            require(\n                t.lastProposal.creationTimestamp > $.lastProposalRewardsUpdate + $.params.minimumRewardPeriod,\n                'not enough time passed'\n            );\n        }\n        $.lastProposalRewardsUpdate = uint40(t.lastProposal.creationTimestamp);\n\n        // Calculate the reward per proposal and per vote\n        t.rewardPerProposal = t.proposalRewardForPeriod / t.numEligibleProposals;\n        t.rewardPerVote = t.votingRewardForPeriod / t.numEligibleVotes;\n\n        emit ProposalRewardsUpdated(\n            t.nextProposalIdToReward,\n            lastProposalId,\n            t.firstAuctionIdForRevenue,\n            lastAuctionIdForRevenue,\n            auctionRevenue,\n            t.rewardPerProposal,\n            t.rewardPerVote\n        );\n\n        //// Second loop over the proposals:\n        //// 1. Skip proposals that were deleted for non eligibility.\n        //// 2. Reward proposal's clientId.\n        //// 3. Reward the clientIds that faciliated voting.\n        //// 4. Make sure all voting clientIds were included. This is meant to avoid griefing. Otherwises one could pass\n        ////    a large array of votingClientIds, spend a lot of gas, and have that gas refunded.\n\n        ClientRewardsMemoryMapping.Mapping memory m = ClientRewardsMemoryMapping.createMapping({\n            maxClientId: t.maxClientId\n        });\n        bool[] memory didClientIdHaveVotes = new bool[](votingClientIds.length);\n\n        for (uint256 i; i < proposals.length; ++i) {\n            // skip non eligible deleted proposals\n            if (proposals[i].endBlock == 0) continue;\n\n            uint32 clientId = proposals[i].clientId;\n            if (clientId != 0 && clientId <= t.maxClientId) {\n                m.inc(clientId, t.rewardPerProposal);\n            }\n\n            uint256 votesInProposal;\n            NounsDAOTypes.ClientVoteData[] memory voteData = proposals[i].voteData;\n            for (uint256 j; j < votingClientIds.length; ++j) {\n                clientId = votingClientIds[j];\n                uint256 votes = voteData[j].votes;\n                didClientIdHaveVotes[j] = didClientIdHaveVotes[j] || votes > 0;\n                if (clientId != 0 && clientId <= t.maxClientId) {\n                    m.inc(clientId, votes * t.rewardPerVote);\n                }\n                votesInProposal += votes;\n            }\n            require(\n                votesInProposal == proposals[i].forVotes + proposals[i].againstVotes + proposals[i].abstainVotes,\n                'not all votes accounted'\n            );\n        }\n\n        for (uint256 i = 0; i < didClientIdHaveVotes.length; ++i) {\n            require(didClientIdHaveVotes[i], 'all clientId must have votes');\n        }\n\n        uint256 numValues = m.numValues();\n        for (uint32 i = 0; i < numValues; ++i) {\n            ClientRewardsMemoryMapping.ClientBalance memory cb = m.getValue(i);\n            $._clientMetadata[cb.clientId].rewarded += SafeCast.toUint96(cb.balance);\n            emit ClientRewarded(cb.clientId, cb.balance);\n        }\n\n        GasRefund.refundGas($.ethToken, startGas);\n    }\n\n    /**\n     * @notice Withdraws the balance of a client\n     * @dev The caller must be the owner of the NFT with id `clientId` and the client must be approved by the DAO.\n     * @param clientId Which client balance to withdraw\n     * @param to the address to withdraw to\n     * @param amount amount to withdraw\n     */\n    function withdrawClientBalance(uint32 clientId, address to, uint96 amount) public whenNotPaused {\n        RewardsStorage storage $ = _getRewardsStorage();\n        ClientMetadata storage md = $._clientMetadata[clientId];\n\n        require(ownerOf(clientId) == msg.sender, 'must be client NFT owner');\n        require(md.approved, 'client not approved');\n\n        uint96 withdrawnCache = md.withdrawn;\n        require(amount <= md.rewarded - withdrawnCache, 'amount too large');\n\n        md.withdrawn = withdrawnCache + amount;\n\n        emit ClientBalanceWithdrawal(clientId, amount, to);\n\n        $.ethToken.safeTransfer(to, amount);\n    }\n\n    /**\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     *   PUBLIC READ\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     */\n\n    /**\n     * @notice Returns the withdrawable balance of client with id `clientId`\n     */\n    function clientBalance(uint32 clientId) public view returns (uint96) {\n        RewardsStorage storage $ = _getRewardsStorage();\n        ClientMetadata storage md = $._clientMetadata[clientId];\n        return md.rewarded - md.withdrawn;\n    }\n\n    /**\n     * @notice Returns the clientIds that are needed to be passed as a parameter to updateRewardsForProposalWritingAndVoting\n     * @dev This is not meant to be called onchain because it may be very gas intensive.\n     */\n    function getVotingClientIds(uint32 lastProposalId) public view returns (uint32[] memory) {\n        RewardsStorage storage $ = _getRewardsStorage();\n\n        uint256 numClientIds = nextTokenId();\n        uint32[] memory allClientIds = new uint32[](numClientIds);\n        for (uint32 i; i < numClientIds; ++i) {\n            allClientIds[i] = i;\n        }\n        NounsDAOTypes.ProposalForRewards[] memory proposals = nounsDAO.proposalDataForRewards(\n            $.nextProposalIdToReward,\n            lastProposalId,\n            allClientIds\n        );\n\n        uint32[] memory sumVotes = new uint32[](numClientIds);\n        for (uint256 i; i < proposals.length; ++i) {\n            for (uint256 j; j < numClientIds; ++j) {\n                sumVotes[j] += proposals[i].voteData[j].votes;\n            }\n        }\n\n        uint256 idx;\n        uint32[] memory nonZeroClientIds = new uint32[](numClientIds);\n        for (uint32 i; i < numClientIds; ++i) {\n            if (sumVotes[i] > 0) nonZeroClientIds[idx++] = i;\n        }\n\n        assembly {\n            mstore(nonZeroClientIds, idx)\n        }\n\n        return nonZeroClientIds;\n    }\n\n    /**\n     * Returns the sum of revenue via auctions from auctioning noun with id `firstNounId` until timestamp of `endTimestamp\n     */\n    function getAuctionRevenue(\n        uint256 firstNounId,\n        uint256 endTimestamp\n    ) public view returns (uint256 sumRevenue, uint256 lastAuctionId) {\n        INounsAuctionHouseV2.Settlement[] memory s = auctionHouse.getSettlementsFromIdtoTimestamp(\n            firstNounId,\n            endTimestamp,\n            true\n        );\n        sumRevenue = sumAuctions(s);\n        lastAuctionId = s[s.length - 1].nounId;\n    }\n\n    /**\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     *   PUBLIC READ - STORAGE GETTERS\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     */\n\n    function nextAuctionIdToReward() public view returns (uint256) {\n        RewardsStorage storage $ = _getRewardsStorage();\n        return $.nextAuctionIdToReward;\n    }\n\n    function nextProposalIdToReward() public view returns (uint32) {\n        RewardsStorage storage $ = _getRewardsStorage();\n        return $.nextProposalIdToReward;\n    }\n\n    function nextProposalRewardFirstAuctionId() public view returns (uint256) {\n        RewardsStorage storage $ = _getRewardsStorage();\n        return $.nextProposalRewardFirstAuctionId;\n    }\n\n    function lastProposalRewardsUpdate() public view returns (uint256) {\n        RewardsStorage storage $ = _getRewardsStorage();\n        return $.lastProposalRewardsUpdate;\n    }\n\n    function getParams() public view returns (RewardParams memory) {\n        RewardsStorage storage $ = _getRewardsStorage();\n        return $.params;\n    }\n\n    function ethToken() public view returns (IERC20) {\n        RewardsStorage storage $ = _getRewardsStorage();\n        return $.ethToken;\n    }\n\n    function admin() public view returns (address) {\n        RewardsStorage storage $ = _getRewardsStorage();\n        return $.admin;\n    }\n\n    /**\n     * @notice Get the metadata of a client\n     */\n    function clientMetadata(uint32 tokenId) public view returns (ClientMetadata memory) {\n        RewardsStorage storage $ = _getRewardsStorage();\n        return $._clientMetadata[tokenId];\n    }\n\n    /**\n     * @notice Get the URI of a client token\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        RewardsStorage storage $ = _getRewardsStorage();\n        return INounsClientTokenDescriptor($.descriptor).tokenURI(tokenId, $._clientMetadata[uint32(tokenId)]);\n    }\n\n    /**\n     * @notice Get the descriptor for the client token\n     */\n    function descriptor() public view returns (address) {\n        RewardsStorage storage $ = _getRewardsStorage();\n        return $.descriptor;\n    }\n\n    /**\n     * @notice Get the next token ID\n     */\n    function nextTokenId() public view returns (uint32) {\n        RewardsStorage storage $ = _getRewardsStorage();\n        return $.nextTokenId;\n    }\n\n    /**\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     *   ADMIN\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     */\n\n    /**\n     * @notice Set whether the client is approved to withdraw their reward balance.\n     * Anyone can mint a client NFT and start earning rewards, but only approved clients can withdraw.\n     * This way the DAO helps mitigate abuse.\n     * @dev Only `owner` can call this function\n     */\n    function setClientApproval(uint32 clientId, bool approved) public onlyOwner {\n        RewardsStorage storage $ = _getRewardsStorage();\n        $._clientMetadata[clientId].approved = approved;\n        emit ClientApprovalSet(clientId, approved);\n    }\n\n    /**\n     * @dev Only `owner` can call this function\n     */\n    function setParams(RewardParams calldata newParams) public onlyOwner {\n        RewardsStorage storage $ = _getRewardsStorage();\n        $.params = newParams;\n    }\n\n    /**\n     * @dev Only `owner` can call this function\n     */\n    function setAdmin(address newAdmin) public onlyOwner {\n        RewardsStorage storage $ = _getRewardsStorage();\n        $.admin = newAdmin;\n    }\n\n    /**\n     * @dev Only `owner` can call this function\n     */\n    function setETHToken(address newToken) public onlyOwner {\n        RewardsStorage storage $ = _getRewardsStorage();\n        $.ethToken = IERC20(newToken);\n    }\n\n    /**\n     * @dev Only `owner` can call this function\n     */\n    function withdrawToken(address token, address to, uint256 amount) public onlyOwner {\n        IERC20(token).safeTransfer(to, amount);\n    }\n\n    /**\n     * @dev Only `owner` or `admin` can call this function\n     */\n    function pause() public onlyOwnerOrAdmin {\n        _pause();\n    }\n\n    /**\n     * @dev Only `owner` or `admin` can call this function\n     */\n    function unpause() public onlyOwnerOrAdmin {\n        _unpause();\n    }\n\n    /**\n     * @notice Set the descriptor for the client token\n     */\n    function setDescriptor(address descriptor_) public onlyOwner {\n        RewardsStorage storage $ = _getRewardsStorage();\n        $.descriptor = descriptor_;\n    }\n\n    /**\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     *   INTERNAL\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     */\n\n    function sumAuctions(INounsAuctionHouseV2.Settlement[] memory s) internal pure returns (uint256 sum) {\n        for (uint256 i = 0; i < s.length; ++i) {\n            sum += s[i].amount;\n        }\n    }\n\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev returns true if ids is an array of increasing unique values, i.e. sorted ascending and no duplicates\n     */\n    function isSortedAndNoDuplicates(uint32[] memory ids) internal pure returns (bool) {\n        uint256 len = ids.length;\n        uint32 prevValue = ids[0];\n        for (uint256 i = 1; i < len; ++i) {\n            uint32 nextValue = ids[i];\n            if (nextValue <= prevValue) return false;\n            prevValue = nextValue;\n        }\n        return true;\n    }\n\n    /**\n     * Only `owner` can perform an upgrade\n     */\n    function _authorizeUpgrade(address) internal view override onlyOwner {}\n}"
    },
    {
      "filename": "nouns-monorepo/packages/nouns-contracts/contracts/client-incentives/Rewards.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/// @title The client incentives rewards logic\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\npragma solidity ^0.8.19;\n\nimport { INounsDAOLogic } from '../interfaces/INounsDAOLogic.sol';\nimport { INounsAuctionHouseV2 } from '../interfaces/INounsAuctionHouseV2.sol';\nimport { NounsDAOTypes } from '../governance/NounsDAOInterfaces.sol';\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { UUPSUpgradeable } from '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport { SafeERC20 } from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport { PausableUpgradeable } from '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\nimport { ClientRewardsMemoryMapping } from '../libs/ClientRewardsMemoryMapping.sol';\nimport { GasRefund } from '../libs/GasRefund.sol';\nimport { INounsClientTokenDescriptor } from './INounsClientTokenDescriptor.sol';\nimport { INounsClientTokenTypes } from './INounsClientTokenTypes.sol';\nimport { OwnableUpgradeable } from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport { ERC721Upgradeable } from '@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol';\nimport { SafeCast } from '@openzeppelin/contracts/utils/math/SafeCast.sol';\n\ncontract Rewards is\n    UUPSUpgradeable,\n    PausableUpgradeable,\n    OwnableUpgradeable,\n    ERC721Upgradeable,\n    INounsClientTokenTypes\n{\n    using SafeERC20 for IERC20;\n    using ClientRewardsMemoryMapping for ClientRewardsMemoryMapping.Mapping;\n\n    /**\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     *   EVENTS\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     */\n\n    event ClientRegistered(uint32 indexed clientId, string name, string description);\n    event ClientUpdated(uint32 indexed clientId, string name, string description);\n    event ClientRewarded(uint32 indexed clientId, uint256 amount);\n    event ClientBalanceWithdrawal(uint32 indexed clientId, uint256 amount, address to);\n    event AuctionRewardsUpdated(uint256 firstAuctionId, uint256 lastAuctionId);\n    event ProposalRewardsUpdated(\n        uint32 firstProposalId,\n        uint32 lastProposalId,\n        uint256 firstAuctionIdForRevenue,\n        uint256 lastAuctionIdForRevenue,\n        uint256 auctionRevenue,\n        uint256 rewardPerProposal,\n        uint256 rewardPerVote\n    );\n    event ClientApprovalSet(uint32 indexed clientId, bool approved);\n\n    /**\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     *   IMMUTABLES\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     */\n\n    INounsDAOLogic public immutable nounsDAO;\n\n    INounsAuctionHouseV2 public immutable auctionHouse;\n\n    /**\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     *   STORAGE VARIABLES\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     */\n\n    struct RewardParams {\n        /// @dev Used for proposal rewards\n        /// @dev The minimum reward period for proposal updates if number of proposals is below `numProposalsEnoughForReward`\n        uint32 minimumRewardPeriod;\n        /// @dev The number of proposals required for an update before `minimumRewardPeriod` has passed\n        uint8 numProposalsEnoughForReward;\n        /// @dev How much bips out of the auction revenue during this period to use for rewarding proposal creation\n        uint16 proposalRewardBps;\n        /// @dev How much bips out of the auction revenue during this period to use for rewarding proposal voting\n        uint16 votingRewardBps;\n        /// @dev How many (in bips) FOR votes out of total votes are required for a proposal to be eligible for rewards\n        uint16 proposalEligibilityQuorumBps;\n        /// @dev Used for auction rewards\n        /// @dev How much bips out of auction revnue to use for rewarding auction bidding\n        uint16 auctionRewardBps;\n        /// @dev Minimum number of auctions between updates. Zero means 1 auction is enough.\n        uint8 minimumAuctionsBetweenUpdates;\n    }\n\n    /// @custom:storage-location erc7201:nouns.rewards\n    struct RewardsStorage {\n        /// @dev The next client token id to be minted\n        u"
    }
  ]
}