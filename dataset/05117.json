{
  "Title": "[G-11] Caching the length of calldata increases gas cost instead of reducing it",
  "Content": "\n### Proof of Concept\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ncontract CacheCallDataLength {\n    \n\n    function calculateTotal(uint256[5] memory numbers) public pure returns(uint256 total) {\n        uint256 len = numbers.length;\n\n        for(uint i; i < len; ++i) {\n            total += numbers[i];\n        }\n\n    }\n}\n```\n\n```\ntest for test/CacheCallDataLength.t.sol:CacheCallDataLengthTest\n[PASS] test_calculateTotal() (gas: 1633)\n```\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\ncontract NoCacheCallDataLength {\n    \n\n    function calculateTotal(uint256[5] memory numbers) public pure returns(uint256 total) {\n\n        for(uint i; i < numbers.length; ++i) {\n            total += numbers[i];\n        }\n        \n    }\n}\n```\n\n```\ntest for test/NoCacheCallDataLength.t.sol:NoCacheCallDataLengthTest\n[PASS] test_calculateTotal() (gas: 1628)\n```\n\n**Instance 1:**\n\nReduce gas cost of `FeeManager.setBeneficial()` function by not caching the length of calldata variable `_feeTokens`.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L546\n\n```solidity\nfile: contracts/FeeManager/FeeManager.sol\n\n538:    function setBeneficial(\n539:        address _user,\n540:        address[] calldata _feeTokens\n541:    )\n542:        external\n543:        onlyMaster\n544:    {\n545:        uint256 i;\n546:        uint256 l = _feeTokens.length;  //@audit don't cache calldata length\n547:\n548:        while (i < l) {\n549:            _setAllowedTokens(\n550:                _user,\n551:                _feeTokens[i],\n552:                true\n553:            );\n554:\n555:            unchecked {\n556:                ++i;\n557:            }\n.\n.\n.\n565:    }\n```\n\n```diff\ndiff --git a/contracts/FeeManager/FeeManager.sol b/contracts/FeeManager/FeeManager.sol\nindex f176113..9e78788 100644\n--- a/contracts/FeeManager/FeeManager.sol\n+++ b/contracts/FeeManager/FeeManager.sol\n@@ -543,9 +543,8 @@ contract FeeManager is FeeManagerHelper {\n         onlyMaster\n     {\n         uint256 i;\n-        uint256 l = _feeTokens.length;\n\n-        while (i < l) {\n+        while (i < _feeTokens.length) {\n             _setAllowedTokens(\n                 _user,\n                 _feeTokens[i],\n```\n\n**Instance 2:**\n\nReduce gas cost of `FeeManager.setBeneficial()` function by not caching the length of calldata variable `_feeTokens`.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseOracleHub/WiseOracleHub.sol#L293\n\n```solidity\nfile: contracts/WiseOracleHub/WiseOracleHub.sol\n\n266:    function addTwapOracleDerivative(\n267:        address _tokenAddress,\n268:        address _partnerTokenAddress,\n269:        address[2] calldata _uniPools,\n270:        address[2] calldata _token0Array,\n271:        address[2] calldata _token1Array,\n272:        uint24[2] calldata _feeArray\n273:    )\n274:        external\n275:        onlyMaster\n276:    {\n.\n.\n.\n291:        uint256 i;\n292:        address pool;\n293:        uint256 length = _uniPools.length;  //@audit don't cache calldata length\n294:\n295:        while (i < length) {\n296:            pool = _getPool(\n297:                _token0Array[i],\n298:                _token1Array[i],\n299:                _feeArray[i]\n300:            );\n301:\n302:            _validatePoolAddress(\n303:                pool,\n304:                _uniPools[i]\n305:            );\n306:\n307:            unchecked {\n308:                ++i;\n309:            }\n310:        }\n.\n.\n.\n321:    }\n```\n\n```diff\ndiff --git a/contracts/WiseOracleHub/WiseOracleHub.sol b/contracts/WiseOracleHub/WiseOracleHub.sol\nindex 12fe0c8..f105337 100644\n--- a/contracts/WiseOracleHub/WiseOracleHub.sol\n+++ b/contracts/WiseOracleHub/WiseOracleHub.sol\n@@ -290,9 +290,8 @@ contract WiseOracleHub is OracleHelper {\n\n         uint256 i;\n         address pool;\n-        uint256 length = _uniPools.length;\n\n-        while (i < length) {\n+        while (i < _uniPools.length) {\n             pool = _getPool(\n                 _token0Array[i],\n                 _token1Array[i],\n```\n\n**Instance 3:**\n\nReduce gas cost of `WiseOracleHub.addOracleBulk()` function by not caching the length of calldata variable `_tokenAddresses`.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseOracleHub/WiseOracleHub.sol#L388\n\n```solidity\nfile: contracts/WiseOracleHub/WiseOracleHub.sol\n\n379:    function addOracleBulk(\n380:        address[] calldata _tokenAddresses,\n381:        IPriceFeed[] calldata _priceFeedAddresses,\n382:        address[][] calldata _underlyingFeedTokens\n383:    )\n384:        external\n385:        onlyMaster\n386:    {\n387:        uint256 i;\n388:        uint256 l = _tokenAddresses.length;\n389:\n390:        while (i < l) {\n391:            _addOracle(\n392:                _tokenAddresses[i],\n393:                _priceFeedAddresses[i],\n394:                _underlyingFeedTokens[i]\n395:            );\n396:\n397:            unchecked {\n398:                ++i;\n399:            }\n400:        }\n401:    }\n```\n\n```diff\ndiff --git a/contracts/WiseOracleHub/WiseOracleHub.sol b/contracts/WiseOracleHub/WiseOracleHub.sol\nindex 12fe0c8..ecc8e55 100644\n--- a/contracts/WiseOracleHub/WiseOracleHub.sol\n+++ b/contracts/WiseOracleHub/WiseOracleHub.sol\n@@ -385,9 +385,8 @@ contract WiseOracleHub is OracleHelper {\n         onlyMaster\n     {\n         uint256 i;\n-        uint256 l = _tokenAddresses.length;\n\n-        while (i < l) {\n+        while (i < _tokenAddresses.length) {\n             _addOracle(\n                 _tokenAddresses[i],\n                 _priceFeedAddresses[i],\n```\n\n**Instance 4:**\n\nReduce gas cost of `WiseOracleHub.recalibrateBulk()` function by not caching the length of calldata variable `_tokenAddresses`.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseOracleHub/WiseOracleHub.sol#L507\n\n```solidity\nfile: contracts/WiseOracleHub/WiseOracleHub.sol\n\n501:    function recalibrateBulk(\n502:        address[] calldata _tokenAddresses\n503:    )\n504:        external\n505:    {\n506:        uint256 i;\n507:        uint256 l = _tokenAddresses.length;\n508:\n509:        while (i < l) {\n510:            _recalibrate(\n511:                _tokenAddresses[i]\n512:            );\n513:\n514:            unchecked {\n515:                ++i;\n516:            }\n517:        }\n518:    }\n```\n\n```diff\ndiff --git a/contracts/WiseOracleHub/WiseOracleHub.sol b/contracts/WiseOracleHub/WiseOracleHub.sol\nindex 12fe0c8..169243e 100644\n--- a/contracts/WiseOracleHub/WiseOracleHub.sol\n+++ b/contracts/WiseOracleHub/WiseOracleHub.sol\n@@ -504,9 +504,8 @@ contract WiseOracleHub is OracleHelper {\n         external\n     {\n         uint256 i;\n-        uint256 l = _tokenAddresses.length;\n\n-        while (i < l) {\n+        while (i < _tokenAddresses.length) {\n             _recalibrate(\n                 _tokenAddresses[i]\n             );\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-02-wise-lending",
  "Code": [
    {
      "filename": "contracts/FeeManager/FeeManager.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\n/**\n * @author Christoph Krpoun\n * @author René Hochmuth\n * @author Vitally Marinchenko\n */\n\nimport \"./FeeManagerHelper.sol\";\n\n/**\n * @dev Purpose of this contract is to organize fee distribution from wiseLending.\n * The feeManager aquires fee token in form of shares from each pool and can call them\n * with \"claimWiseFees()\" for each pool.\n *\n * Furthermore, this contracts has two different incentive\n * structures which can be used to bootstrap the WISE ecosystem (beneficial and incnetiveOwner roles).\n *\n * Additionally, this contract keeps track of the bad debt of each postion and has a simple mechanism\n * to pay them back via incentives. The incentive amount is funded by the gathered fees.\n */\n\ncontract FeeManager is FeeManagerHelper {\n\n    constructor(\n        address _master,\n        address _aaveAddress,\n        address _wiseLendingAddress,\n        address _oracleHubAddress,\n        address _wiseSecurityAddress,\n        address _positionNFTAddress\n    )\n        DeclarationsFeeManager(\n            _master,\n            _aaveAddress,\n            _wiseLendingAddress,\n            _oracleHubAddress,\n            _wiseSecurityAddress,\n            _positionNFTAddress\n        )\n    {}\n\n    /**\n     * @dev Allows to adjust the paid out incentive\n     * percentage for user to reduce bad debt.\n     */\n    function setRepayBadDebtIncentive(\n        uint256 _percent\n    )\n        external\n        onlyMaster\n    {\n        _checkValue(\n            _percent\n        );\n\n        paybackIncentive = _percent;\n    }\n\n    /**\n     * @dev Maps underlying token with corresponding aToken.\n     * Sets bool to identify pool token as aToken.\n     */\n    function setAaveFlag(\n        address _poolToken,\n        address _underlyingToken\n    )\n        external\n        onlyMaster\n    {\n        _setAaveFlag(\n            _poolToken,\n            _underlyingToken\n        );\n    }\n\n    /**\n     * @dev Bulk function for setting aave flag for multiple pools.\n     */\n    function setAaveFlagBulk(\n        address[] calldata _poolTokens,\n        address[] calldata _underlyingTokens\n    )\n        external\n        onlyMaster\n    {\n        uint256 i;\n        uint256 l = _poolTokens.length;\n\n        while (i < l) {\n            _setAaveFlag(\n                _poolTokens[i],\n                _underlyingTokens[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Function to adjust pool fee. Fee can not be greater than 100%\n     * or lower than 1%. Can be adjusted for each pool individually.\n     */\n    function setPoolFee(\n        address _poolToken,\n        uint256 _newFee\n    )\n        external\n        onlyMaster\n    {\n        _checkValue(\n            _newFee\n        );\n\n        WISE_LENDING.setPoolFee(\n            _poolToken,\n            _newFee\n        );\n\n        emit PoolFeeChanged(\n            _poolToken,\n            _newFee,\n            block.timestamp\n        );\n    }\n\n    /**\n    * @dev Function to adjust pool fees in bulk. Fee for each pool can not be\n    * greater than 100% or lower than 1%. Can be adjusted for each pool individually.\n    */\n    function setPoolFeeBulk(\n        address[] calldata _poolTokens,\n        uint256[] calldata _newFees\n    )\n        external\n        onlyMaster\n    {\n        uint256 i;\n        uint256 l = _poolTokens.length;\n\n        while (i < l) {\n\n            _checkValue(\n                _newFees[i]\n            );\n\n            WISE_LENDING.setPoolFee(\n                _poolTokens[i],\n                _newFees[i]\n            );\n\n            emit PoolFeeChanged(\n                _poolTokens[i],\n                _newFees[i],\n                block.timestamp\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Function to propose new incentive master. This role can increase\n     * the incentive amount for both incentive mappings. These are two roles\n     * for incentivising external persons e.g. developers.\n     */\n    function proposeIncentiveMaster(\n        address _proposedIncentiveMaster\n    )\n        external\n        onlyIncentiveMaster\n    {\n        if (_proposedIncentiveMaster == ZERO_ADDRESS) {\n            revert ZeroAddress();\n        }\n\n        proposedIncentiveMaster = _proposedIncentiveMaster;\n\n        emit IncentiveMasterProposed(\n            _proposedIncentiveMaster,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Claim proposed incentive master by proposed entity.\n     */\n    function claimOwnershipIncentiveMaster()\n        external\n    {\n        if (msg.sender != proposedIncentiveMaster) {\n            revert NotAllowed();\n        }\n\n        incentiveMaster = proposedIncentiveMaster;\n        proposedIncentiveMaster = ZERO_ADDRESS;\n\n        emit ClaimedOwnershipIncentiveMaster(\n            incentiveMaster,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Increase function for increasing incentive amount for entity A.\n     * Only callable by incentive master.\n     */\n    function increaseIncentiveA(\n        uint256 _value\n    )\n        external\n        onlyIncentiveMaster\n    {\n        incentiveUSD[incentiveOwnerA] += _value;\n\n        emit IncentiveIncreasedA(\n            _value,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Increase function for increasing incentive amount for entity B.\n     * Only callable by incentive master.\n     */\n    function increaseIncentiveB(\n        uint256 _value\n    )\n        external\n        onlyIncentiveMaster\n    {\n        incentiveUSD[incentiveOwnerB] += _value;\n\n        emit IncentiveIncreasedB(\n            _value,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function to claim all gathered incetives.\n     */\n    function claimIncentivesBulk()\n        external\n    {\n        address tokenAddress;\n\n        uint256 i;\n        uint256 l = getPoolTokenAddressesLength();\n\n        while (i < l) {\n\n            tokenAddress = poolTokenAddresses[i];\n\n            if (isAaveToken[tokenAddress] == true) {\n                tokenAddress = underlyingToken[\n                    tokenAddress\n                ];\n            }\n\n            claimIncentives(\n                tokenAddress\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ClaimedIncentivesBulk(\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Claims gathered incentives for a specific token.\n     */\n    function claimIncentives(\n        address _feeToken\n    )\n        public\n    {\n        uint256 amount = gatheredIncentiveToken[msg.sender][_feeToken];\n\n        if (amount == 0) {\n            revert NoIncentive();\n        }\n\n        delete gatheredIncentiveToken[msg.sender][_feeToken];\n\n        emit ClaimedIncentives(\n            msg.sender,\n            _feeToken,\n            amount,\n            block.timestamp\n        );\n\n        _safeTransfer(\n            _feeToken,\n            msg.sender,\n            amount\n        );\n    }\n\n    /**\n     * @dev Function changing incentiveOwnerA! Only callable by\n     * incentiveOwnerA.\n     */\n    function changeIncentiveUSDA(\n        address _newOwner\n    )\n        external\n    {\n        if (msg.sender != incentiveOwnerA) {\n            revert NotAllowed();\n        }\n\n        if (_newOwner == incentiveOwnerA) {\n            revert NotAllowed();\n        }\n\n        if (_newOwner == incentiveOwnerB) {\n            revert NotAllowed();\n        }\n\n        incentiveUSD[_newOwner] = incentiveUSD[\n            incentiveOwnerA\n        ];\n\n        delete incentiveUSD[\n            incentiveOwnerA\n        ];\n\n        incentiveOwnerA = _newOwner;\n\n        emit IncentiveOwnerAChanged(\n            _newOwner,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function changing incentiveOwnerB! Only callable by\n     * incentiveOwnerB.\n     */\n    function changeIncentiveUSDB(\n        address _newOwner\n    )\n        external\n    {\n        if (msg.sender != incentiveOwnerB) {\n            revert NotAllowed();\n        }\n\n        if (_newOwner == incentiveOwnerA) {\n            revert NotAllowed();\n        }\n\n        if (_newOwner == incentiveOwnerB) {\n            revert NotAllowed();\n        }\n\n        incentiveUSD[_newOwner] = incentiveUSD[\n            incentiveOwnerB\n        ];\n\n        delete incentiveUSD[\n            incentiveOwnerB\n        ];\n\n        incentiveOwnerB = _newOwner;\n\n        emit IncentiveOwnerBChanged(\n            _newOwner,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function adding new pool token to pool token list.\n     * Called during pool creation and only callable by wiseLending\n     * contract.\n     */\n    function addPoolTokenAddress(\n        address _poolToken\n    )\n        external\n        onlyWiseLending\n    {\n        poolTokenAddresses.push(\n            _poolToken\n        );\n\n        poolTokenAdded[_poolToken] = true;\n\n        emit PoolTokenAdded(\n            _poolToken,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function to add pool token manualy. Only\n     * callable by feeManager master.\n     */\n    function addPoolTokenAddressManual(\n        address _poolToken\n    )\n        external\n        onlyMaster\n    {\n        if (poolTokenAdded[_poolToken] == true) {\n            revert PoolAlreadyAdded();\n        }\n\n        poolTokenAddresses.push(\n            _poolToken\n        );\n\n        poolTokenAdded[_poolToken] = true;\n\n        emit PoolTokenAdded(\n            _poolToken,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function to remove pool token manualy from pool\n     * token list. Only callable by feeManager master.\n     */\n    function removePoolTokenManual(\n        address _poolToken\n    )\n        external\n        onlyMaster\n    {\n        uint256 i;\n        uint256 len = getPoolTokenAddressesLength();\n        uint256 lastEntry = len - 1;\n        bool found;\n\n        if (poolTokenAdded[_poolToken] == false) {\n            revert PoolNotPresent();\n        }\n\n        while (i < len) {\n\n            if (_poolToken != poolTokenAddresses[i]) {\n\n                unchecked {\n                    ++i;\n                }\n\n                continue;\n            }\n\n            found = true;\n\n            if (i != lastEntry) {\n                poolTokenAddresses[i] = poolTokenAddresses[lastEntry];\n            }\n\n            break;\n        }\n\n        if (found == true) {\n\n            poolTokenAddresses.pop();\n            poolTokenAdded[_poolToken] = false;\n\n            emit PoolTokenRemoved(\n                _poolToken,\n                block.timestamp\n            );\n\n            return;\n        }\n\n        revert PoolNotPresent();\n    }\n\n    /**\n     * @dev Increase function for total bad debt of\n     * wiseLending. Only callable by wiseSecurity contract\n     * during liquidation.\n     */\n    function increaseTotalBadDebtLiquidation(\n        uint256 _amount\n    )\n        external\n        onlyWiseSecurity\n    {\n        _increaseTotalBadDebt(\n            _amount\n        );\n\n        emit BadDebtIncreasedLiquidation(\n            _amount,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Increase function for bad debt of a position.\n     * Only callable by wiseSecurity contract during liquidation.\n     */\n    function setBadDebtUserLiquidation(\n        uint256 _nftId,\n        uint256 _amount\n    )\n        external\n        onlyWiseSecurity\n    {\n        _setBadDebtPosition(\n            _nftId,\n            _amount\n        );\n\n        emit SetBadDebtPosition(\n            _nftId,\n            _amount,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Set function to declare an address as beneficial for\n     * a fee token. Address can claim gathered fee token as long as\n     * it is declared as beneficial. Only setable by master.\n     */\n    function setBeneficial(\n        address _user,\n        address[] calldata _feeTokens\n    )\n        external\n        onlyMaster\n    {\n        uint256 i;\n        uint256 l = _feeTokens.length;\n\n        while (i < l) {\n            _setAllowedTokens(\n                _user,\n                _feeTokens[i],\n                true\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit SetBeneficial(\n            _user,\n            _feeTokens,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Set function to remove an address as beneficial for\n     * a fee token. Only setable by master.\n     */\n    function revokeBeneficial(\n        address _user,\n        address[] memory _feeTokens\n    )\n        external\n        onlyMaster\n    {\n        uint256 i;\n        uint256 l = _feeTokens.length;\n\n        while (i < l) {\n            _setAllowedTokens(\n                _user,\n                _feeTokens[i],\n                false\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit RevokeBeneficial(\n            _user,\n            _feeTokens,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Claim all fees from wiseLending and send them to feeManager.\n     */\n    function claimWiseFeesBulk()\n        external\n    {\n        uint256 i;\n        uint256 l = getPoolTokenAddressesLength();\n\n        while (i < l) {\n            claimWiseFees(\n                poolTokenAddresses[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ClaimedFeesWiseBulk(\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Claim fees from wiseLending and send them to feeManager for\n     * a specific pool.\n     */\n    function claimWiseFees(\n        address _poolToken\n    )\n        public\n    {\n        address underlyingTokenAddress = _poolToken;\n\n        uint256 shares = WISE_LENDING.getPositionLendingShares(\n            FEE_MANAGER_NFT,\n            _poolToken\n        );\n\n        if (shares == 0) {\n            return;\n        }\n\n        uint256 tokenAmount = WISE_LENDING.withdrawExactShares(\n            FEE_MANAGER_NFT,\n            _poolToken,\n            shares\n        );\n\n        if (isAaveToken[_poolToken] == true) {\n\n            underlyingTokenAddress = underlyingToken[\n                _poolToken\n            ];\n\n            tokenAmount = AAVE.withdraw(\n                underlyingTokenAddress,\n                tokenAmount,\n                address(this)\n            );\n        }\n\n        if (totalBadDebtETH == 0) {\n\n            tokenAmount = _distributeIncentives(\n                tokenAmount,\n                _poolToken,\n                underlyingTokenAddress\n            );\n        }\n\n        _increaseFeeTokens(\n            underlyingTokenAddress,\n            tokenAmount\n        );\n\n        emit ClaimedFeesWise(\n            underlyingTokenAddress,\n            tokenAmount,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function for beneficial to claim gathered fees. Can only\n     * claim fees for which the beneficial is allowed. Can only claim\n     * token which are inside the feeManager.\n     */\n    function claimFeesBeneficial(\n        address _feeToken,\n        uint256 _amount\n    )\n        external\n    {\n        address caller = msg.sender;\n\n        if (totalBadDebtETH > 0) {\n            revert ExistingBadDebt();\n        }\n\n        if (allowedTokens[caller][_feeToken] == false) {\n            revert NotAllowed();\n        }\n\n        _decreaseFeeTokens(\n            _feeToken,\n            _amount\n        );\n\n        _safeTransfer(\n            _feeToken,\n            caller,\n            _amount\n        );\n\n        emit ClaimedFeesBeneficial(\n            caller,\n            _feeToken,\n            _amount,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function for paying back bad debt of a position. Caller\n     * chooses postion, token and receive token. Only gathered fee token\n     * can be distributed as receive token. Caller gets 5% more\n     * in ETH value as incentive.\n     */\n    function paybackBadDebtForToken(\n        uint256 _nftId,\n        address _paybackToken,\n        address _receivingToken,\n        uint256 _shares\n    )\n        external\n        returns (\n            uint256 paybackAmount,\n            uint256 receivingAmount\n        )\n    {\n        updatePositionCurrentBadDebt(\n            _nftId\n        );\n\n        if (badDebtPosition[_nftId] == 0) {\n            return (\n                0,\n                0\n            );\n        }\n\n        if (WISE_LENDING.getTotalDepositShares(_receivingToken) == 0) {\n            revert PoolNotActive();\n        }\n\n        if (WISE_LENDING.getTotalDepositShares(_paybackToken) == 0) {\n            revert PoolNotActive();\n        }\n\n        paybackAmount = WISE_LENDING.paybackAmount(\n            _paybackToken,\n            _shares\n        );\n\n        WISE_LENDING.corePaybackFeeManager(\n            _paybackToken,\n            _nftId,\n            paybackAmount,\n            _shares\n        );\n\n        _updateUserBadDebt(\n            _nftId\n        );\n\n        receivingAmount = getReceivingToken(\n            _paybackToken,\n            _receivingToken,\n            paybackAmount\n        );\n\n        _decreaseFeeTokens(\n            _receivingToken,\n            receivingAmount\n        );\n\n        _safeTransferFrom(\n            _paybackToken,\n            msg.sender,\n            address(WISE_LENDING),\n            paybackAmount\n        );\n\n        _safeTransfer(\n            _receivingToken,\n            msg.sender,\n            receivingAmount\n        );\n\n        emit PayedBackBadDebt(\n            _nftId,\n            msg.sender,\n            _paybackToken,\n            _receivingToken,\n            paybackAmount,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function for paying back bad debt of a position. Caller\n     * chooses postion, token and receive token. Caller gets no\n     * receive token!\n     */\n    function paybackBadDebtNoReward(\n        uint256 _nftId,\n        address _paybackToken,\n        uint256 _shares\n    )\n        external\n        returns (uint256 paybackAmount)\n    {\n        updatePositionCurrentBadDebt(\n            _nftId\n        );\n\n        if (badDebtPosition[_nftId] == 0) {\n            return 0;\n        }\n\n        if (WISE_LENDING.getTotalDepositShares(_paybackToken) == 0) {\n            revert PoolNotActive();\n        }\n\n        paybackAmount = WISE_LENDING.paybackAmount(\n            _paybackToken,\n            _shares\n        );\n\n        WISE_LENDING.corePaybackFeeManager(\n            _paybackToken,\n            _nftId,\n            paybackAmount,\n            _shares\n        );\n\n        _updateUserBadDebt(\n            _nftId\n        );\n\n        emit PayedBackBadDebtFree(\n            _nftId,\n            msg.sender,\n            _paybackToken,\n            paybackAmount,\n            block.timestamp\n        );\n\n        _safeTransferFrom(\n            _paybackToken,\n            msg.sender,\n            address(WISE_LENDING),\n            paybackAmount\n        );\n    }\n\n    /**\n     * @dev Returning the number of pool token\n     * addresses saved inside the feeManager.\n     */\n    function getPoolTokenAddressesLength()\n        public\n        view\n        returns (uint256)\n    {\n        return poolTokenAddresses.length;\n    }\n\n    /**\n     * @dev Returns the pool token address\n     * at the _index postion of the array.\n     */\n    function getPoolTokenAdressesByIndex(\n        uint256 _index\n    )\n        external\n        view\n        returns (address)\n    {\n        return poolTokenAddresses[_index];\n    }\n\n    /**\n     * @dev Bulk function for updating pools - loops through\n     * all pools saved inside the poolTokenAddresses array.\n     */\n    function syncAllPools()\n        external\n    {\n        uint256 i;\n        uint256 l = poolTokenAddresses.length;\n\n        while (i < l) {\n            WISE_LENDING.syncManually(\n                poolTokenAddresses[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/WiseOracleHub/WiseOracleHub.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\n/**\n * @author René Hochmuth\n * @author Christoph Krpoun\n * @author Vitally Marinchenko\n */\n\nimport \"./OracleHelper.sol\";\n\n/**\n * @dev WiseOracleHub is an onchain extension for price feeds (chainLink or others).\n * The master address is owned by a timelock contract which itself is secured by a\n * multisig. Only the master can add new price feed <-> address pairs to the contract.\n *\n * One advantage is the linking of price feeds to their underlying token address.\n * Therefore, users can get the current ETH value of a token by just knowing the token\n * address when calling {latestResolver}. It takes the answer from {latestRoundData}\n * for chainLink oracles as recommended from chainLink.\n *\n * NOTE: If you want to propose adding an own developed price feed it is\n * mandatory to wrap its answer into a function mimicking {latestRoundData}\n * (See {latestResolver} implementation).\n *\n * Additionally, the oracleHub provides so called heartbeat checks if a token gets\n * still updated in expected time interval.\n */\n\ncontract WiseOracleHub is OracleHelper {\n\n    constructor(\n        address _wethAddrss,\n        address _ethPricingFeed,\n        address _uniswapFactoryV3\n    )\n        Declarations(\n            _wethAddrss,\n            _ethPricingFeed,\n            _uniswapFactoryV3\n        )\n    {\n        ETH_USD_PLACEHOLDER = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            \"ETH_USD_PLACEHOLDER\"\n                        )\n                    )\n                )\n            )\n        );\n\n        priceFeed[ETH_USD_PLACEHOLDER] = ETH_PRICE_FEED;\n        _tokenDecimals[ETH_USD_PLACEHOLDER] = _decimalsETH;\n        underlyingFeedTokens[ETH_USD_PLACEHOLDER] = new address[](0);\n\n        heartBeat[ETH_USD_PLACEHOLDER] = _recalibratePreview(\n            ETH_USD_PLACEHOLDER\n        );\n    }\n\n    /**\n     * @dev Returns priceFeed latest ETH value\n     * by passing the underlying token address.\n     */\n    function latestResolver(\n        address _tokenAddress\n    )\n        public\n        view\n        returns (uint256)\n    {\n        if (chainLinkIsDead(_tokenAddress) == true) {\n            revert OracleIsDead();\n        }\n\n        return _validateAnswer(\n            _tokenAddress\n        );\n    }\n\n    function getTokenDecimals(\n        address _tokenAddress\n    )\n        external\n        view\n        returns (uint8)\n    {\n        return _tokenDecimals[_tokenAddress];\n    }\n\n    // @TODO: Delete later, keep for backward compatibility\n    function getTokensInUSD(\n        address _tokenAddress,\n        uint256 _tokenAmount\n    )\n        external\n        view\n        returns (uint256)\n    {\n        uint8 tokenDecimals = _tokenDecimals[\n            _tokenAddress\n        ];\n\n        return _decimalsETH < tokenDecimals\n            ? _tokenAmount\n                * latestResolver(_tokenAddress)\n                / 10 ** decimals(_tokenAddress)\n                / 10 ** (tokenDecimals - _decimalsETH)\n            : _tokenAmount\n                * 10 ** (_decimalsETH - tokenDecimals)\n                * latestResolver(_tokenAddress)\n                / 10 ** decimals(_tokenAddress);\n    }\n\n    /**\n     * @dev Returns USD value of a given token\n     * amount in order of 1E18 decimal precision.\n     */\n    function getTokensPriceInUSD(\n        address _tokenAddress,\n        uint256 _tokenAmount\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return getTokensInETH(\n            _tokenAddress,\n            _tokenAmount\n        )\n            * getETHPriceInUSD()\n            / 10 ** _decimalsUSD;\n    }\n\n    /**\n     * @dev Returns ETH value of a given token\n     * amount in order of 1E18 decimal precision.\n     */\n    function getTokensInETH(\n        address _tokenAddress,\n        uint256 _tokenAmount\n    )\n        public\n        view\n        returns (uint256)\n    {\n        if (_tokenAddress == WETH_ADDRESS) {\n            return _tokenAmount;\n        }\n\n        uint8 tokenDecimals = _tokenDecimals[\n            _tokenAddress\n        ];\n\n        return _decimalsETH < tokenDecimals\n            ? _tokenAmount\n                * latestResolver(_tokenAddress)\n                / 10 ** decimals(_tokenAddress)\n                / 10 ** (tokenDecimals - _decimalsETH)\n            : _tokenAmount\n                * 10 ** (_decimalsETH - tokenDecimals)\n                * latestResolver(_tokenAddress)\n                / 10 ** decimals(_tokenAddress);\n    }\n\n    // @TODO: Delete later, keep for backward compatibility\n    function getTokensFromUSD(\n        address _tokenAddress,\n        uint256 _usdValue\n    )\n        external\n        view\n        returns (uint256)\n    {\n        uint8 tokenDecimals = _tokenDecimals[\n            _tokenAddress\n        ];\n\n        return _decimalsETH < tokenDecimals\n            ? _usdValue\n                * 10 ** (tokenDecimals - _decimalsETH)\n                * 10 ** decimals(_tokenAddress)\n                / latestResolver(_tokenAddress)\n            : _usdValue\n                * 10 ** decimals(_tokenAddress)\n                / latestResolver(_tokenAddress)\n                / 10 ** (_decimalsETH - tokenDecimals);\n    }\n\n    /**\n     * @dev Converts USD value of a token into token amount with a\n     * current price. The order of the argument _usdValue is 1E18.\n     */\n    function getTokensPriceFromUSD(\n        address _tokenAddress,\n        uint256 _usdValue\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return getTokensFromETH(\n            _tokenAddress,\n            _usdValue\n                * 10 ** _decimalsUSD\n                / getETHPriceInUSD()\n        );\n    }\n\n    /**\n     * @dev Adds a new token address to the oracleHub Twap.\n     * Can't overwrite existing mappings.\n     */\n    function addTwapOracle(\n        address _tokenAddress,\n        address _uniPoolAddress,\n        address _token0,\n        address _token1,\n        uint24 _fee\n    )\n        external\n        onlyMaster\n    {\n        address pool = _getPool(\n            _token0,\n            _token1,\n            _fee\n        );\n\n        _validateTokenAddress(\n            _tokenAddress,\n            _token0,\n            _token1\n        );\n\n        _validateTwapOracle(\n            _tokenAddress\n        );\n\n        _validatePoolAddress(\n            pool,\n            _uniPoolAddress\n        );\n\n        _validatePriceFeed(\n            _tokenAddress\n        );\n\n        _writeUniTwapPoolInfoStruct(\n            {\n                _tokenAddress: _tokenAddress,\n                _oracle: pool,\n                _isUniPool: true\n            }\n        );\n    }\n\n    /**\n     * @dev Adds a new token address to TWAP as derivative.\n     * Not permitted to overwrite existing mappings.\n     */\n    function addTwapOracleDerivative(\n        address _tokenAddress,\n        address _partnerTokenAddress,\n        address[2] calldata _uniPools,\n        address[2] calldata _token0Array,\n        address[2] calldata _token1Array,\n        uint24[2] calldata _feeArray\n    )\n        external\n        onlyMaster\n    {\n        _validatePriceFeed(\n            _tokenAddress\n        );\n\n        _validateTwapOracle(\n            _tokenAddress\n        );\n\n        _validateTokenAddress(\n            _tokenAddress,\n            _token0Array[1],\n            _token1Array[1]\n        );\n\n        uint256 i;\n        address pool;\n        uint256 length = _uniPools.length;\n\n        while (i < length) {\n            pool = _getPool(\n                _token0Array[i],\n                _token1Array[i],\n                _feeArray[i]\n            );\n\n            _validatePoolAddress(\n                pool,\n                _uniPools[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        _writeUniTwapPoolInfoStructDerivative(\n            {\n                _tokenAddress: _tokenAddress,\n                _partnerTokenAddress: _partnerTokenAddress,\n                _oracleAddress: _uniPools[0],\n                _partnerOracleAddress: _uniPools[1],\n                _isUniPool: false\n            }\n        );\n    }\n\n    /**\n     * @dev Converts ETH value of a token into token amount with a\n     * current price. The order of the argument _ethAmount is 1E18.\n     */\n    function getTokensFromETH(\n        address _tokenAddress,\n        uint256 _ethAmount\n    )\n        public\n        view\n        returns (uint256)\n    {\n        if (_tokenAddress == WETH_ADDRESS) {\n            return _ethAmount;\n        }\n\n        uint8 tokenDecimals = _tokenDecimals[\n            _tokenAddress\n        ];\n\n        return _decimalsETH < tokenDecimals\n            ? _ethAmount\n                * 10 ** (tokenDecimals - _decimalsETH)\n                * 10 ** decimals(_tokenAddress)\n                / latestResolver(_tokenAddress)\n            : _ethAmount\n                * 10 ** decimals(_tokenAddress)\n                / latestResolver(_tokenAddress)\n                / 10 ** (_decimalsETH - tokenDecimals);\n    }\n\n    /**\n     * @dev Adds priceFeed for a token.\n     * Can't overwrite existing mappings.\n     * Master is a timelock contract.\n     */\n    function addOracle(\n        address _tokenAddress,\n        IPriceFeed _priceFeedAddress,\n        address[] calldata _underlyingFeedTokens\n    )\n        external\n        onlyMaster\n    {\n        _addOracle(\n            _tokenAddress,\n            _priceFeedAddress,\n            _underlyingFeedTokens\n        );\n    }\n\n    /**\n     * @dev Adds priceFeeds for tokens.\n     * Can't overwrite existing mappings.\n     * Master is a timelock contract.\n     */\n    function addOracleBulk(\n        address[] calldata _tokenAddresses,\n        IPriceFeed[] calldata _priceFeedAddresses,\n        address[][] calldata _underlyingFeedTokens\n    )\n        external\n        onlyMaster\n    {\n        uint256 i;\n        uint256 l = _tokenAddresses.length;\n\n        while (i < l) {\n            _addOracle(\n                _tokenAddresses[i],\n                _priceFeedAddresses[i],\n                _underlyingFeedTokens[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function addAggregator(\n        address _tokenAddress\n    )\n        external\n        onlyMaster\n    {\n        _addAggregator(\n            _tokenAddress\n        );\n    }\n\n    /**\n     * @dev Looks at the maximal last 50 rounds and\n     * takes second highest value to avoid counting\n     * offline time of chainlink as valid heartbeat.\n     */\n    function recalibratePreview(\n        address _tokenAddress\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _recalibratePreview(\n            _tokenAddress\n        );\n    }\n\n    /**\n     * @dev Check if chainLink feed was\n     * updated within expected timeFrame.\n     * If length of {underlyingFeedTokens}\n     * is greater than zero it checks the\n     * heartbeat of all base feeds of the\n     * derivate oracle.\n     */\n    function chainLinkIsDead(\n        address _tokenAddress\n    )\n        public\n        view\n        returns (bool state)\n    {\n        uint256 i;\n        uint256 length = underlyingFeedTokens[\n            _tokenAddress\n        ].length;\n\n        if (sequencerIsDead() == true) {\n            return true;\n        }\n\n        if (length == 0) {\n            return _chainLinkIsDead(\n                _tokenAddress\n            );\n        }\n\n        while (i < length) {\n\n            state = _chainLinkIsDead(\n                underlyingFeedTokens[_tokenAddress][i]\n            );\n\n            _validateAnswer(\n                underlyingFeedTokens[_tokenAddress][i]\n            );\n\n            unchecked {\n                ++i;\n            }\n\n            if (state == true) {\n                break;\n            }\n        }\n\n        return state;\n    }\n\n    /**\n     * @dev Recalibrates expected\n     * heartbeat for a pricing feed.\n     */\n    function recalibrate(\n        address _tokenAddress\n    )\n        external\n    {\n        _recalibrate(\n            _tokenAddress\n        );\n    }\n\n    /**\n     * @dev Bulk function to recalibrate\n     * the heartbeat for several tokens.\n     */\n    function recalibrateBulk(\n        address[] calldata _tokenAddresses\n    )\n        external\n    {\n        uint256 i;\n        uint256 l = _tokenAddresses.length;\n\n        while (i < l) {\n            _recalibrate(\n                _tokenAddresses[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/WiseOracleHub/WiseOracleHub.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\n/**\n * @author René Hochmuth\n * @author Chris"
    }
  ]
}