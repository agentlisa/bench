{
  "Title": "[H-01] Gas issuance is inflated and will halt the chain or lead to incorrect base fee",
  "Content": "\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L2/TaikoL2.sol#L140-L143> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L2/TaikoL2.sol#L262-L293> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L2/TaikoL2.sol#L145-L152> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L2/TaikoL2.sol#L140-L143>\n\nThe base fee calculation in the `anchor()` function is incorrect. Issuance is over inflated and will either lead to the chain halting or a severely deflated base fee.\n\n### Proof of Concept\n\nWe calculate the 1559 base fee and compare it to `block.basefee` <br><https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L2/TaikoL2.sol#L140-L143>\n\n```solidity\n        (basefee, gasExcess) = _calc1559BaseFee(config, _l1BlockId, _parentGasUsed);\n        if (!skipFeeCheck() && block.basefee != basefee) {\n            revert L2_BASEFEE_MISMATCH();\n        \n```\n\nBut the calculation is incorrect:\n\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L2/TaikoL2.sol#L262-L293>\n\n```solidity\n        if (gasExcess > 0) {\n            // We always add the gas used by parent block to the gas excess\n            // value as this has already happened\n            uint256 excess = uint256(gasExcess) + _parentGasUsed;\n\n            // Calculate how much more gas to issue to offset gas excess.\n            // after each L1 block time, config.gasTarget more gas is issued,\n            // the gas excess will be reduced accordingly.\n            // Note that when lastSyncedBlock is zero, we skip this step\n            // because that means this is the first time calculating the basefee\n            // and the difference between the L1 height would be extremely big,\n            // reverting the initial gas excess value back to 0.\n            uint256 numL1Blocks;\n            if (lastSyncedBlock > 0 && _l1BlockId > lastSyncedBlock) {\n                numL1Blocks = _l1BlockId - lastSyncedBlock;\n            }\n\n            if (numL1Blocks > 0) {\n                uint256 issuance = numL1Blocks * _config.gasTargetPerL1Block;\n                excess = excess > issuance ? excess - issuance : 1;\n            }\n\n            gasExcess_ = uint64(excess.min(type(uint64).max));\n\n            // The base fee per gas used by this block is the spot price at the\n            // bonding curve, regardless the actual amount of gas used by this\n            // block, however, this block's gas used will affect the next\n            // block's base fee.\n            basefee_ = Lib1559Math.basefee(\n                gasExcess_, uint256(_config.basefeeAdjustmentQuotient) * _config.gasTargetPerL1Block\n            );\n        }\n```\n\nInstead of issuing `_config.gasTargetPerL1Block` for each L1 block we end up issuing `uint256 issuance = (_l1BlockOd - lastSyncedBlock) * _config.gasTargetPerL1Block`.\n\n`lastSyncedBlock` is only updated every 5 blocks.\n\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L2/TaikoL2.sol#L145-L152>\n\n```solidity\n        if (_l1BlockId > lastSyncedBlock + BLOCK_SYNC_THRESHOLD) {\n            // Store the L1's state root as a signal to the local signal service to\n            // allow for multi-hop bridging.\n            ISignalService(resolve(\"signal_service\", false)).syncChainData(\n                ownerChainId, LibSignals.STATE_ROOT, _l1BlockId, _l1StateRoot\n            );\n            lastSyncedBlock = _l1BlockId;\n        }\n```\n\nIf `anchor()` is called on 5 consecutive blocks we end up issuing\nin total `15 * _config.gasTargetPerL1Block` instead of `5 * _config.gasTargetPerL1Block`.\n\nWhen the calculated base fee is compared to the `block.basefee` the following happens:\n\n*   If `block.basefee`reports the correct base fee this will end up halting the chain since they will not match.\n\n*   If `block.basefee` is using the same flawed calculation the chain continues but with a severely reduced and incorrect base fee.\n\nHere is a simple POC showing the actual issuance compared to the expected issuance. Paste the code into TaikoL1LibProvingWithTiers.t.sol and run `forge test --match-test testIssuance -vv`.\n\n<details>\n\n```solidity\n    struct Config {\n        uint32 gasTargetPerL1Block;\n        uint8 basefeeAdjustmentQuotient;\n    }\n\n    function getConfig() public view virtual returns (Config memory config_) {\n        config_.gasTargetPerL1Block = 15 * 1e6 * 4;\n        config_.basefeeAdjustmentQuotient = 8;\n    }\n\n    uint256 lastSyncedBlock = 1;\n    uint256 gasExcess = 10;\n    function _calc1559BaseFee(\n        Config memory _config,\n        uint64 _l1BlockId,\n        uint32 _parentGasUsed\n    )\n        private\n        view\n        returns (uint256 issuance, uint64 gasExcess_)\n    {\n        if (gasExcess > 0) {\n            uint256 excess = uint256(gasExcess) + _parentGasUsed;\n\n            uint256 numL1Blocks;\n            if (lastSyncedBlock > 0 && _l1BlockId > lastSyncedBlock) {\n                numL1Blocks = _l1BlockId - lastSyncedBlock;\n            }\n\n            if (numL1Blocks > 0) {\n                issuance = numL1Blocks * _config.gasTargetPerL1Block;\n                excess = excess > issuance ? excess - issuance : 1;\n            }\n\t\t\t// I have commented out the below basefee calculation\n\t\t\t// and return issuance instead to show the actual\n\t\t\t// accumulated issuance over 5 L1 blocks.\n\t\t\t// nothing else is changed\n\t\t\n            //gasExcess_ = uint64(excess.min(type(uint64).max));\n\t\t\t\n            //basefee_ = Lib1559Math.basefee(\n            //    gasExcess_, uint256(_config.basefeeAdjustmentQuotient) * _config.gasTargetPerL1Block\n            //);\n        }\n\n        //if (basefee_ == 0) basefee_ = 1;\n    }\n        \n    function testIssuance() external {\n        uint256 issuance;\n        uint256 issuanceAdded;\n        Config memory config = getConfig();\n        for (uint64 x=2; x <= 6 ;x++){\n            \n            (issuanceAdded ,) = _calc1559BaseFee(config, x, 0);\n            issuance += issuanceAdded;\n            console2.log(\"added\", issuanceAdded);\n        }\n\n        uint256 expectedIssuance = config.gasTargetPerL1Block*5;\n        console2.log(\"Issuance\", issuance);\n        console2.log(\"Expected Issuance\", expectedIssuance);\n        \n        assertEq(expectedIssuance*3, issuance);\n\n```\n\n</details>\n\n### Tools Used\n\nFoundry, VScode\n\n### Recommended Mitigation Steps\n\nIssue exactly `config.gasTargetPerL1Block` for each L1 block.\n\n**[dantaik (Taiko) confirmed and commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/276#issuecomment-2031033625):**\n > This is a valid bug report. Fixed in this PR: https://github.com/taikoxyz/taiko-mono/pull/16543\n\n**[0xean (Judge) commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/276#issuecomment-2045139998):**\n > I don't see a direct loss of funds here and believe M is the correct severity.\n> > 2 — Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> \n> > 3 — High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).\n\n**[0xmonrel (Warden) commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/276#issuecomment-2049465072):**\n > A halted chain leads to frozen funds. The chain will progress for a minimum of 2 blocks since the calculation is correct when `lastSyncedBlock =0` and when `_l1BlockID-lastSyncedBlock=1`\n> \n> After the second block the base fee will still be correct as long as `excess < issuance` for both the inflated and correct calculating since both result in `excess=1`\n> https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L2/TaikoL2.sol#L279-L282\n> \n> ```solidity\n>             if (numL1Blocks > 0) {\n>                 uint256 issuance = numL1Blocks * _config.gasTargetPerL1Block;\n>                 excess = excess > issuance ? excess - issuance : 1;\n>             }\n> ```\n> \n> At the block where the base fee is incorrect the chain is halted and funds are locked since the anchor now reverts in perpetuity.\n> \n> In practice Taiko can easily release all funds by upgrading the contracts but I believe such an intervention should not be considered when evaluating the severity of an issue. From [C4 Supreme Court session, Fall 2023](https://docs.code4rena.com/awarding/judging-criteria/supreme-court-decisions-fall-2023)\n> \n> >Contract upgradability should never be used as a severity mitigation, i.e. we assume contracts are non-upgradable.\n> \n> I therefore believe a High is fair here.\n\n\n**[0xean (Judge) commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/276#issuecomment-2049679633):**\n > I don't entirely agree since the chain would be halted so soon in its existence, that being said, some amount of funds, albeit small, would likely be lost.  @dantaik / @adaki2004 any last comments before leaving as H severity?\n\n**[adaki2004 (Taiko) commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/276#issuecomment-2049949706):**\n> Agreed, can do!\n\n**[0xean (Judge) commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/276#issuecomment-2051543094):**\n > Awarding as H, final decision. \n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-03-taiko",
  "Code": [
    {
      "filename": "packages/protocol/contracts/L2/TaikoL2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libs/LibAddress.sol\";\nimport \"../libs/LibMath.sol\";\nimport \"../signal/ISignalService.sol\";\nimport \"../signal/LibSignals.sol\";\nimport \"./Lib1559Math.sol\";\nimport \"./CrossChainOwned.sol\";\n\n/// @title TaikoL2\n/// @notice Taiko L2 is a smart contract that handles cross-layer message\n/// verification and manages EIP-1559 gas pricing for Layer 2 (L2) operations.\n/// It is used to anchor the latest L1 block details to L2 for cross-layer\n/// communication, manage EIP-1559 parameters for gas pricing, and store\n/// verified L1 block information.\n/// @custom:security-contact security@taiko.xyz\ncontract TaikoL2 is CrossChainOwned {\n    using LibAddress for address;\n    using LibMath for uint256;\n    using SafeERC20 for IERC20;\n\n    struct Config {\n        uint32 gasTargetPerL1Block;\n        uint8 basefeeAdjustmentQuotient;\n    }\n\n    /// @notice Golden touch address is the only address that can do the anchor transaction.\n    address public constant GOLDEN_TOUCH_ADDRESS = 0x0000777735367b36bC9B61C50022d9D0700dB4Ec;\n\n    /// @notice The number of L2 blocks to wait before syncing L1 block details.\n    uint8 public constant BLOCK_SYNC_THRESHOLD = 5;\n\n    /// @notice Mapping from L2 block numbers to their block hashes. All L2 block hashes will\n    /// be saved in this mapping.\n    mapping(uint256 blockId => bytes32 blockHash) public l2Hashes;\n\n    /// @notice A hash to check the integrity of public inputs.\n    /// @dev Slot 2.\n    bytes32 public publicInputHash;\n\n    /// @notice The gas excess value used to calculate the base fee.\n    /// @dev Slot 3.\n    uint64 public gasExcess;\n\n    /// @notice The last synced L1 block height.\n    uint64 public lastSyncedBlock;\n\n    uint256[47] private __gap;\n\n    /// @notice Emitted when the latest L1 block details are anchored to L2.\n    /// @param parentHash The hash of the parent block.\n    /// @param gasExcess The gas excess value used to calculate the base fee.\n    event Anchored(bytes32 parentHash, uint64 gasExcess);\n\n    error L2_BASEFEE_MISMATCH();\n    error L2_INVALID_CHAIN_ID();\n    error L2_INVALID_PARAM();\n    error L2_INVALID_SENDER();\n    error L2_PUBLIC_INPUT_HASH_MISMATCH();\n    error L2_TOO_LATE();\n\n    /// @notice Initializes the contract.\n    /// @param _owner The owner of this contract. msg.sender will be used if this value is zero.\n    /// @param _addressManager The address of the {AddressManager} contract.\n    /// @param _l1ChainId The ID of the base layer.\n    /// @param _gasExcess The initial gasExcess.\n    function init(\n        address _owner,\n        address _addressManager,\n        uint64 _l1ChainId,\n        uint64 _gasExcess\n    )\n        external\n        initializer\n    {\n        __CrossChainOwned_init(_owner, _addressManager, _l1ChainId);\n\n        if (block.chainid <= 1 || block.chainid > type(uint64).max) {\n            revert L2_INVALID_CHAIN_ID();\n        }\n\n        if (block.number == 0) {\n            // This is the case in real L2 genesis\n        } else if (block.number == 1) {\n            // This is the case in tests\n            uint256 parentHeight = block.number - 1;\n            l2Hashes[parentHeight] = blockhash(parentHeight);\n        } else {\n            revert L2_TOO_LATE();\n        }\n\n        gasExcess = _gasExcess;\n        (publicInputHash,) = _calcPublicInputHash(block.number);\n    }\n\n    /// @notice Anchors the latest L1 block details to L2 for cross-layer\n    /// message verification.\n    /// @param _l1BlockHash The latest L1 block hash when this block was\n    /// proposed.\n    /// @param _l1StateRoot The latest L1 block's state root.\n    /// @param _l1BlockId The latest L1 block height when this block was proposed.\n    /// @param _parentGasUsed The gas used in the parent block.\n    function anchor(\n        bytes32 _l1BlockHash,\n        bytes32 _l1StateRoot,\n        uint64 _l1BlockId,\n        uint32 _parentGasUsed\n    )\n        external\n        nonReentrant\n    {\n        if (\n            _l1BlockHash == 0 || _l1StateRoot == 0 || _l1BlockId == 0\n                || (block.number != 1 && _parentGasUsed == 0)\n        ) {\n            revert L2_INVALID_PARAM();\n        }\n\n        if (msg.sender != GOLDEN_TOUCH_ADDRESS) revert L2_INVALID_SENDER();\n\n        uint256 parentId;\n        unchecked {\n            parentId = block.number - 1;\n        }\n\n        // Verify ancestor hashes\n        (bytes32 publicInputHashOld, bytes32 publicInputHashNew) = _calcPublicInputHash(parentId);\n        if (publicInputHash != publicInputHashOld) {\n            revert L2_PUBLIC_INPUT_HASH_MISMATCH();\n        }\n\n        Config memory config = getConfig();\n\n        // Verify the base fee per gas is correct\n        uint256 basefee;\n        (basefee, gasExcess) = _calc1559BaseFee(config, _l1BlockId, _parentGasUsed);\n        if (!skipFeeCheck() && block.basefee != basefee) {\n            revert L2_BASEFEE_MISMATCH();\n        }\n\n        if (_l1BlockId > lastSyncedBlock + BLOCK_SYNC_THRESHOLD) {\n            // Store the L1's state root as a signal to the local signal service to\n            // allow for multi-hop bridging.\n            ISignalService(resolve(\"signal_service\", false)).syncChainData(\n                ownerChainId, LibSignals.STATE_ROOT, _l1BlockId, _l1StateRoot\n            );\n            lastSyncedBlock = _l1BlockId;\n        }\n        // Update state variables\n        l2Hashes[parentId] = blockhash(parentId);\n        publicInputHash = publicInputHashNew;\n\n        emit Anchored(blockhash(parentId), gasExcess);\n    }\n\n    /// @notice Withdraw token or Ether from this address\n    /// @param _token Token address or address(0) if Ether.\n    /// @param _to Withdraw to address.\n    function withdraw(\n        address _token,\n        address _to\n    )\n        external\n        onlyFromOwnerOrNamed(\"withdrawer\")\n        nonReentrant\n        whenNotPaused\n    {\n        if (_to == address(0)) revert L2_INVALID_PARAM();\n        if (_token == address(0)) {\n            _to.sendEther(address(this).balance);\n        } else {\n            IERC20(_token).safeTransfer(_to, IERC20(_token).balanceOf(address(this)));\n        }\n    }\n\n    /// @notice Gets the basefee and gas excess using EIP-1559 configuration for\n    /// the given parameters.\n    /// @param _l1BlockId The synced L1 height in the next Taiko block\n    /// @param _parentGasUsed Gas used in the parent block.\n    /// @return basefee_ The calculated EIP-1559 base fee per gas.\n    function getBasefee(\n        uint64 _l1BlockId,\n        uint32 _parentGasUsed\n    )\n        public\n        view\n        returns (uint256 basefee_)\n    {\n        (basefee_,) = _calc1559BaseFee(getConfig(), _l1BlockId, _parentGasUsed);\n    }\n\n    /// @notice Retrieves the block hash for the given L2 block number.\n    /// @param _blockId The L2 block number to retrieve the block hash for.\n    /// @return The block hash for the specified L2 block id, or zero if the\n    /// block id is greater than or equal to the current block number.\n    function getBlockHash(uint64 _blockId) public view returns (bytes32) {\n        if (_blockId >= block.number) return 0;\n        if (_blockId + 256 >= block.number) return blockhash(_blockId);\n        return l2Hashes[_blockId];\n    }\n\n    /// @notice Returns EIP1559 related configurations.\n    /// @return config_ struct containing configuration parameters.\n    function getConfig() public view virtual returns (Config memory config_) {\n        // 4x Ethereum gas target, if we assume most of the time, L2 block time\n        // is 3s, and each block is full (gasUsed is 15_000_000), then its\n        // ~60_000_000, if the  network is congester than that, the base fee\n        // will increase.\n        config_.gasTargetPerL1Block = 15 * 1e6 * 4;\n        config_.basefeeAdjustmentQuotient = 8;\n    }\n\n    /// @notice Tells if we need to validate basefee (for simulation).\n    /// @return Returns true to skip checking basefee mismatch.\n    function skipFeeCheck() public pure virtual returns (bool) {\n        return false;\n    }\n\n    function _calcPublicInputHash(uint256 _blockId)\n        private\n        view\n        returns (bytes32 publicInputHashOld, bytes32 publicInputHashNew)\n    {\n        bytes32[256] memory inputs;\n\n        // Unchecked is safe because it cannot overflow.\n        unchecked {\n            // Put the previous 255 blockhashes (excluding the parent's) into a\n            // ring buffer.\n            for (uint256 i; i < 255 && _blockId >= i + 1; ++i) {\n                uint256 j = _blockId - i - 1;\n                inputs[j % 255] = blockhash(j);\n            }\n        }\n\n        inputs[255] = bytes32(block.chainid);\n\n        assembly {\n            publicInputHashOld := keccak256(inputs, 8192 /*mul(256, 32)*/ )\n        }\n\n        inputs[_blockId % 255] = blockhash(_blockId);\n        assembly {\n            publicInputHashNew := keccak256(inputs, 8192 /*mul(256, 32)*/ )\n        }\n    }\n\n    function _calc1559BaseFee(\n        Config memory _config,\n        uint64 _l1BlockId,\n        uint32 _parentGasUsed\n    )\n        private\n        view\n        returns (uint256 basefee_, uint64 gasExcess_)\n    {\n        // gasExcess being 0 indicate the dynamic 1559 base fee is disabled.\n        if (gasExcess > 0) {\n            // We always add the gas used by parent block to the gas excess\n            // value as this has already happened\n            uint256 excess = uint256(gasExcess) + _parentGasUsed;\n\n            // Calculate how much more gas to issue to offset gas excess.\n            // after each L1 block time, config.gasTarget more gas is issued,\n            // the gas excess will be reduced accordingly.\n            // Note that when lastSyncedBlock is zero, we skip this step\n            // because that means this is the first time calculating the basefee\n            // and the difference between the L1 height would be extremely big,\n            // reverting the initial gas excess value back to 0.\n            uint256 numL1Blocks;\n            if (lastSyncedBlock > 0 && _l1BlockId > lastSyncedBlock) {\n                numL1Blocks = _l1BlockId - lastSyncedBlock;\n            }\n\n            if (numL1Blocks > 0) {\n                uint256 issuance = numL1Blocks * _config.gasTargetPerL1Block;\n                excess = excess > issuance ? excess - issuance : 1;\n            }\n\n            gasExcess_ = uint64(excess.min(type(uint64).max));\n\n            // The base fee per gas used by this block is the spot price at the\n            // bonding curve, regardless the actual amount of gas used by this\n            // block, however, this block's gas used will affect the next\n            // block's base fee.\n            basefee_ = Lib1559Math.basefee(\n                gasExcess_, uint256(_config.basefeeAdjustmentQuotient) * _config.gasTargetPerL1Block\n            );\n        }\n\n        // Always make sure basefee is nonzero, this is required by the node.\n        if (basefee_ == 0) basefee_ = 1;\n    }\n}"
    },
    {
      "filename": "packages/protocol/contracts/L2/TaikoL2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libs/LibAddress.sol\";\nimport \"../libs/LibMath.sol\";\nimport \"../signal/ISignalService.sol\";\nimport \"../signal/LibSignals.sol\";\nimport \"./Lib1559Math.sol\";\nimport \"./CrossChainOwned.sol\";\n\n/// @title TaikoL2\n/// @notice Taiko L2 is a smart contract that handles cross-layer message\n/// verification and manages EIP-1559 gas pricing for Layer 2 (L2) operations.\n/// It is used to anchor the latest L1 block details to L2 for cross-layer\n/// communication, manage EIP-1559 parameters for gas pricing, and store\n/// verified L1 block information.\n/// @custom:security-contact security@taiko.xyz\ncontract TaikoL2 is CrossChainOwned {\n    using LibAddress for address;\n    using LibMath for uint256;\n    using SafeERC20 for IERC20;\n\n    struct Config {\n        uint32 gasTargetPerL1Block;\n        uint8 basefeeAdjustmentQuotient;\n    }\n\n    /// @notice Golden touch address is the only address that can do the anchor transaction.\n    address public constant GOLDEN_TOUCH_ADDRESS = 0x0000777735367b36bC9B61C50022d9D0700dB4Ec;\n\n    /// @notice The number of L2 blocks to wait before syncing L1 block details.\n    uint8 public constant BLOCK_SYNC_THRESHOLD = 5;\n\n    /// @notice Mapping from L2 block numbers to their block hashes. All L2 block hashes will\n    /// be saved in this mapping.\n    mapping(uint256 blockId => bytes32 blockHash) public l2Hashes;\n\n    /// @notice A hash to check the integrity of public inputs.\n    /// @dev Slot 2.\n    bytes32 public publicInputHash;\n\n    /// @notice The gas excess value used to calculate the base fee.\n    /// @dev Slot 3.\n    uint64 public gasExcess;\n\n    /// @notice The last synced L1 block height.\n    uint64 public lastSyncedBlock;\n\n    uint256[47] private __gap;\n\n    /// @notice Emitted when the latest L1 block details are anchored to L2.\n    /// @param parentHash The hash of the parent block.\n    /// @param gasExcess The gas excess value used to calculate the base fee.\n    event Anchored(bytes32 parentHash, uint64 gasExcess);\n\n    error L2_BASEFEE_MISMATCH();\n    error L2_INVALID_CHAIN_ID();\n    error L2_INVALID_PARAM();\n    error L2_INVALID_SENDER();\n    error L2_PUBLIC_INPUT_HASH_MISMATCH();\n    error L2_TOO_LATE();\n\n    /// @notice Initializes the contract.\n    /// @param _owner The owner of this contract. msg.sender will be used if this value is zero.\n    /// @param _addressManager The address of the {AddressManager} contract.\n    /// @param _l1ChainId The ID of the base layer.\n    /// @param _gasExcess The initial gasExcess.\n    function init(\n        address _owner,\n        address _addressManager,\n        uint64 _l1ChainId,\n        uint64 _gasExcess\n    )\n        external\n        initializer\n    {\n        __CrossChainOwned_init(_owner, _addressManager, _l1ChainId);\n\n        if (block.chainid <= 1 || block.chainid > type(uint64).max) {\n            revert L2_INVALID_CHAIN_ID();\n        }\n\n        if (block.number == 0) {\n            // This is the case in real L2 genesis\n        } else if (block.number == 1) {\n            // This is the case in tests\n            uint256 parentHeight = block.number - 1;\n            l2Hashes[parentHeight] = blockhash(parentHeight);\n        } else {\n            revert L2_TOO_LATE();\n        }\n\n        gasExcess = _gasExcess;\n        (publicInputHash,) = _calcPublicInputHash(block.number);\n    }\n\n    /// @notice Anchors the latest L1 block details to L2 for cross-layer\n    /// message verification.\n    /// @param _l1BlockHash The latest L1 block hash when this block was\n    /// proposed.\n    /// @param _l1StateRoot The latest L1 block's state root.\n    /// @param _l1BlockId The latest L1 block height when this block was proposed.\n    /// @param _parentGasUsed The gas used in the parent block.\n    function anchor(\n        bytes32 _l1BlockHash,\n        bytes32 _l1StateRoot,\n        uint64 _l1BlockId,\n        uint32 _parentGasUsed\n    )\n        external\n        nonReentrant\n    {\n        if (\n            _l1BlockHash == 0 || _l1StateRoot == 0 || _l1BlockId == 0\n                || (block.number != 1 && _parentGasUsed == 0)\n        ) {\n            revert L2_INVALID_PARAM();\n        }\n\n        if (msg.sender != GOLDEN_TOUCH_ADDRESS) revert L2_INVALID_SENDER();\n\n        uint256 parentId;\n        unchecked {\n            parentId = block.number - 1;\n        }\n\n        // Verify ancestor hashes\n        (bytes32 publicInputHashOld, bytes32 publicInputHashNew) = _calcPublicInputHash(parentId);\n        if (publicInputHash != publicInputHashOld) {\n            revert L2_PUBLIC_INPUT_HASH_MISMATCH();\n        }\n\n        Config memory config = getConfig();\n\n        // Verify the base fee per gas is correct\n        uint256 basefee;\n        (basefee, gasExcess) = _calc1559BaseFee(config, _l1BlockId, _parentGasUsed);\n        if (!skipFeeCheck() && block.basefee != basefee) {\n            revert L2_BASEFEE_MISMATCH();\n        }\n\n        if (_l1BlockId > lastSyncedBlock + BLOCK_SYNC_THRESHOLD) {\n            // Store the L1's state root as a signal to the local signal service to\n            // allow for multi-hop bridging.\n            ISignalService(resolve(\"signal_service\", false)).syncChainData(\n                ownerChainId, LibSignals.STATE_ROOT, _l1BlockId, _l1StateRoot\n            );\n            lastSyncedBlock = _l1BlockId;\n        }\n        // Update state variables\n        l2Hashes[parentId] = blockhash(parentId);\n        publicInputHash = publicInputHashNew;\n\n        emit Anchored(blockhash(parentId), gasExcess);\n    }\n\n    /// @notice Withdraw token or Ether from this address\n    /// @param _token Token address or address(0) if Ether.\n    /// @param _to Withdraw to address.\n    function withdraw(\n        address _token,\n        address _to\n    )\n        external\n        onlyFromOwnerOrNamed(\"withdrawer\")\n        nonReentrant\n        whenNotPaused\n    {\n        if (_to == address(0)) revert L2_INVALID_PARAM();\n        if (_token == address(0)) {\n            _to.sendEther(address(this).balance);\n        } else {\n            IERC20(_token).safeTransfer(_to, IERC20(_token).balanceOf(address(this)));\n        }\n    }\n\n    /// @notice Gets the basefee and gas excess using EIP-1559 configuration for\n    /// the given parameters.\n    /// @param _l1BlockId The synced L1 height in the next Taiko block\n    /// @param _parentGasUsed Gas used in the parent block.\n    /// @return basefee_ The calculated EIP-1559 base fee per gas.\n    function getBasefee(\n        uint64 _l1BlockId,\n        uint32 _parentGasUsed\n    )\n        public\n        view\n        returns (uint256 basefee_)\n    {\n        (basefee_,) = _calc1559BaseFee(getConfig(), _l1BlockId, _parentGasUsed);\n    }\n\n    /// @notice Retrieves the block hash for the given L2 block number.\n    /// @param _blockId The L2 block number to retrieve the block hash for.\n    /// @return The block hash for the specified L2 block id, or zero if the\n    /// block id is greater than or equal to the current block number.\n    function getBlockHash(uint64 _blockId) public view returns (bytes32) {\n        if (_blockId >= block.number) return 0;\n        if (_blockId + 256 >= block.number) return blockhash(_blockId);\n        return l2Hashes[_blockId];\n    }\n\n    /// @notice Returns EIP1559 related configurations.\n    /// @return config_ struct containing configuration parameters.\n    function getConfig() public view virtual returns (Config memory config_) {\n        // 4x Ethereum gas target, if we assume most of the time, L2 block time\n        // is 3s, and each block is full (gasUsed is 15_000_000), then its\n        // ~60_000_000, if the  network is congester than that, the base fee\n        // will increase.\n        config_.gasTargetPerL1Block = 15 * 1e6 * 4;\n        config_.basefeeAdjustmentQuotient = 8;\n    }\n\n    /// @notice Tells if we need to validate basefee (for simulation).\n    /// @return Returns true to skip checking basefee mismatch.\n    function skipFeeCheck() public pure virtual returns (bool) {\n        return false;\n    }\n\n    function _calcPublicInputHash(uint256 _blockId)\n        private\n        view\n        returns (bytes32 publicInputHashOld, bytes32 publicInputHashNew)\n    {\n        bytes32[256] memory inputs;\n\n        // Unchecked is safe because it cannot overflow.\n        unchecked {\n            // Put the previous 255 blockhashes (excluding the parent's) into a\n            // ring buffer.\n            for (uint256 i; i < 255 && _blockId >= i + 1; ++i) {\n                uint256 j = _blockId - i - 1;\n                inputs[j % 255] = blockhash(j);\n            }\n        }\n\n        inputs[255] = bytes32(block.chainid);\n\n        assembly {\n            publicInputHashOld := keccak256(inputs, 8192 /*mul(256, 32)*/ )\n        }\n\n        inputs[_blockId % 255] = blockhash(_blockId);\n        assembly {\n            publicInputHashNew := keccak256(inputs, 8192 /*mul(256, 32)*/ )\n        }\n    }\n\n    function _calc1559BaseFee(\n        Config memory _config,\n        uint64 _l1BlockId,\n        uint32 _parentGasUsed\n    )\n        private\n        view\n        returns (uint256 basefee_, uint64 gasExcess_)\n    {\n        // gasExcess being 0 indicate the dynamic 1559 base fee is disabled.\n        if (gasExcess > 0) {\n            // We always add the gas used by parent block to the gas excess\n            // value as this has already happened\n            uint256 excess = uint256(gasExcess) + _parentGasUsed;\n\n            // Calculate how much more gas to issue to offset gas excess.\n            // after each L1 block time, config.gasTarget more gas is issued,\n            // the gas excess will be reduced accordingly.\n            // Note that when lastSyncedBlock is zero, we skip this step\n            // because that means this is the first time calculating the basefee\n            // and the difference between the L1 height would be extremely big,\n            // reverting the initial gas excess value back to 0.\n            uint256 numL1Blocks;\n            if (lastSyncedBlock > 0 && _l1BlockId > lastSyncedBlock) {\n                numL1Blocks = _l1BlockId - lastSyncedBlock;\n            }\n\n            if (numL1Blocks > 0) {\n                uint256 issuance = numL1Blocks * _config.gasTargetPerL1Block;\n                excess = excess > issuance ? excess - issuance : 1;\n            }\n\n            gasExcess_ = uint64(excess.min(type(uint64).max));\n\n            // The base fee per gas used by this block is the spot price at the\n            // bonding curve, regardless the actual amount of gas used by this\n            // block, however, this block's gas used will affect the next\n            // block's base fee.\n            basefee_ = Lib1559Math.basefee(\n                gasExcess_, uint256(_config.basefeeAdjustmentQuotient) * _config.gasTargetPerL1Block\n            );\n        }\n\n        // Always make sure basefee is nonzero, this is required by the node.\n        if (basefee_ == 0) basefee_ = 1;\n    }\n}"
    },
    {
      "filename": "packages/protocol/contracts/L2/TaikoL2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libs/LibAddress.sol\";\nimport \"../libs/LibMath.sol\";\nimport \"../signal/ISignalService.sol\";\nimport \"../signal/LibSignals.sol\";\nimport \"./Lib1559Math.sol\";\nimport \"./CrossChainOwned.sol\";\n\n/// @title TaikoL2\n/// @notice Taiko L2 is a smart contract that handles cross-layer message\n/// verification and manages EIP-1559 gas pricing for Layer 2 (L2) operations.\n/// It is used to anchor the latest L1 block details to L2 for cross-layer\n/// communication, manage EIP-1559 parameters for gas pricing, and store\n/// verified L1 block information.\n/// @custom:security-contact security@taiko.xyz\ncontract TaikoL2 is CrossChainOwned {\n    using LibAddress for address;\n    using LibMath for uint256;\n    using SafeERC20 for IERC20;\n\n    struct Config {\n        uint32 gasTargetPerL1Block;\n        uint8 basefeeAdjustmentQuotient;\n    }\n\n    /// @notice Golden touch address is the only address that can do the anchor transaction.\n    address public constant GOLDEN_TOUCH_ADDRESS = 0x0000777735367b36bC9B61C50022d9D0700dB4Ec;\n\n    /// @notice The number of L2 blocks to wait before syncing L1 block details.\n    uint8 public constant BLOCK_SYNC_THRESHOLD = 5;\n\n    /// @notice Mapping from L2 block numbers to their block hashes. All L2 block hashes will\n    /// be saved in this mapping.\n    mapping(uint256 blockId => bytes32 blockHash) public l2Hashes;\n\n    /// @notice A hash to check the integrity of public inputs.\n    /// @dev Slot 2.\n    bytes32 public publicInputHash;\n\n    /// @notice The gas excess value used to calculate the base fee.\n    /// @dev Slot 3.\n    uint64 public gasExcess;\n\n    /// @notice The last synced L1 block height.\n    uint64 public lastSyncedBlock;\n\n    uint256[47] private __gap;\n\n    /// @notice Emitted when the latest L1 block details are anchored to L2.\n    /// @param parentHash The hash of the parent block.\n    /// @param gasExcess The gas excess value used to calculate the base fee.\n    event Anchored(bytes32 parentHash, uint64 gasExcess);\n\n    error L2_BASEFEE_MISMATCH();\n    error L2_INVALID_CHAIN_ID();\n    error L2_INVALID_PARAM();\n    error L2_INVALID_SENDER();\n    error L2_PUBLIC_INPUT_HASH_MISMATCH();\n    error L2_TOO_LATE();\n\n    /// @notice Initializes the contract.\n    /// @param _owner The owner of this contract. msg.sender will be used if this value is zero.\n    /// @param _addressManager The address of the {AddressManager} contract.\n    /// @param _l1ChainId The ID of the base layer.\n    /// @param _gasExcess The initial gasExcess.\n    function init(\n        address _owner,\n        address _addressManager,\n        uint64 _l1ChainId,\n        uint64 _gasExcess\n    )\n        external\n        initializer\n    {\n        __CrossChainOwned_init(_owner, _addressManager, _l1ChainId);\n\n        if (block.chainid <= 1 || block.chainid > type(uint64).max) {\n            revert L2_INVALID_CHAIN_ID();\n        }\n\n        if (block.number == 0) {\n            // This is the case in real L2 genesis\n        } else if (block.number == 1) {\n            // This is the case in tests\n            uint256 parentHeight = block.number - 1;\n            l2Hashes[parentHeight] = blockhash(parentHeight);\n        } else {\n            revert L2_TOO_LATE();\n        }\n\n        gasExcess = _gasExcess;\n        (publicInputHash,) = _calcPublicInputHash(block.number);\n    }\n\n    /// @notice Anchors the latest L1 block details to L2 for cross-layer\n    /// message verification.\n    /// @param _l1BlockHash The latest L1 block hash when this block was\n    /// proposed.\n    /// @param _l1StateRoot The latest L1 block's state root.\n    /// @param _l1BlockId The latest L1 block height when this block was proposed.\n    /// @param _parentGasUsed The gas used in the parent block.\n    function anchor(\n        bytes32 _l1BlockHash,\n        bytes32 _l1StateRoot,\n        uint64 _l1BlockId,\n        uint32 _parentGasUsed\n    )\n        external\n        nonReentrant\n    {\n        if (\n            _l1BlockHash == 0 || _l1StateRoot == 0 || _l1BlockId == 0\n                || (block.number != 1 && _parentGasUsed == 0)\n        ) {\n            revert L2_INVALID_PARAM();\n        }\n\n        if (msg.sender != GOLDEN_TOUCH_ADDRESS) revert L2_INVALID_SENDER();\n\n        uint256 parentId;\n        unchecked {\n            parentId = block.number - 1;\n        }\n\n        // Verify ancestor hashes\n        (bytes32 publicInputHashOld, bytes32 publicInputHashNew) = _calcPublicInputHash(parentId);\n        if (publicInputHash != publicInputHashOld) {\n            revert L2_PUBLIC_INPUT_HASH_MISMATCH();\n        }\n\n        Config memory config = getConfig();\n\n        // Verify the base fee per gas is correct\n        uint256 basefee;\n        (basefee, gasExcess) = _calc1559BaseFee(config, _l1BlockId, _parentGasUsed);\n        if (!skipFeeCheck() && block.basefee != basefee) {\n            revert L2_BASEFEE_MISMATCH();\n        }\n\n        if (_l1BlockId > lastSyncedBlock + BLOCK_SYNC_THRESHOLD) {\n            // Store the L1's state root as a signal to the local signal service to\n            // allow for multi-hop bridging.\n            ISignalService(resolve(\"signal_service\", false)).syncChainData(\n                ownerChainId, LibSignals.STATE_ROOT, _l1BlockId, _l1StateRoot\n            );\n            lastSyncedBlock = _l1BlockId;\n        }\n        // Update state variables\n        l2Hashes[parentId] = blockhash(parentId);\n        publicInputHash = publicInputHashNew;\n\n        emit Anchored(blockhash(parentId), gasExcess);\n    }\n\n    /// @notice Withdraw token or Ether from this address\n    /// @param _token Token address or address(0) if Ether.\n    /// @param _to Withdraw to address.\n    function withdraw(\n        address _token,\n        address _to\n    )\n        external\n        onlyFromOwnerOrNamed(\"withdrawer\")\n        nonReentrant\n        whenNotPaused\n    {\n        if (_to == address(0)) revert L2_INVALID_PARAM();\n        if (_token == address(0)) {\n            _to.sendEther(address(this).balance);\n        } else {\n            IERC20(_token).safeTransfer(_to, IERC20(_token).balanceOf(address(this)));\n        }\n    }\n\n    /// @notice Gets the basefee and gas excess using EIP-1559 configuration for\n    /// the given parameters.\n    /// @param _l1BlockId The synced L1 height in the next Taiko block\n    /// @param _parentGasUsed Gas used in the parent block.\n    /// @return basefee_ The calculated EIP-1559 base fee per gas.\n    function getBasefee(\n        uint64 _l1BlockId,\n        uint32 _parentGasUsed\n    )\n        public\n        view\n        returns (uint256 basefee_)\n    {\n        (basefee_,) = _calc1559BaseFee(getConfig(), _l1BlockId, _parentGasUsed);\n    }\n\n    /// @notice Retrieves the block hash for the given L2 block number.\n    /// @param _blockId The L2 block number to retrieve the block hash for.\n    /// @return The block hash for the specified L2 block id, or zero if the\n    /// block id is greater than or equal to the current block number.\n    function getBlockHash(uint64 _blockId) public view returns (bytes32) {\n        if (_blockId >= block.number) return 0;\n        if (_blockId + 256 >= block.number) return blockhash(_blockId);\n        return l2Hashes[_blockId];\n    }\n\n    /// @notice Returns EIP1559 related configurations.\n    /// @return config_ struct containing configuration parameters.\n    function getConfig() public view virtual returns (Config memory config_) {\n        // 4x Ethereum gas target, if we assume most of the time, L2 block time\n        // is 3s, and each block is full (gasUsed is 15_000_000), then its\n        // ~60_000_000, if the  network is congester than that, the base fee\n        // will increase.\n        config_.gasTargetPerL1Block = 15 * 1e6 * 4;\n        config_.basefeeAdjustmentQuotient = 8;\n    }\n\n    /// @notice Tells if we need to validate basefee (for simulation).\n    /// @return Returns true to skip checking basefee mismatch.\n    function skipFeeCheck() public pure virtual returns (bool) {\n        return false;\n    }\n\n    function _calcPublicInputHash(uint256 _blockId)\n        private\n        view\n        returns (bytes32 publicInputHashOld, bytes32 publicInputHashNew)\n    {\n        bytes32[256] memory inputs;\n\n        // Unchecked is safe because it cannot overflow.\n        unchecked {\n            // Put the previous 255 blockhashes (excluding the parent's) into a\n            // ring buffer.\n            for (uint256 i; i < 255 && _blockId >= i + 1; ++i) {\n                uint256 j = _blockId - i - 1;\n                inputs[j % 255] = blockhash(j);\n            }\n        }\n\n        inputs[255] = bytes32(block.chainid);\n\n        assembly {\n            publicInputHashOld := keccak256(inputs, 8192 /*mul(256, 32)*/ )\n        }\n\n        inputs[_blockId % 255] = blockhash(_blockId);\n        assembly {\n            publicInputHashNew := keccak256(inputs, 8192 /*mul(256, 32)*/ )\n        }\n    }\n\n    function _calc1559BaseFee(\n        Config memory _config,\n        uint64 _l1BlockId,\n        uint32 _parentGasUsed\n    )\n        private\n        view\n        returns (uint256 basefee_, uint64 gasExcess_)\n    {\n        // gasExcess being 0 indicate the dynamic 1559 base fee is disabled.\n        if (gasExcess > 0) {\n            // We always add the gas used by parent block to the gas excess\n            // value as this has already happened\n            uint256 excess = uint256(gasExcess) + _parentGasUsed;\n\n            // Calculate how much more gas to issue to offset gas excess.\n            // after each L1 block time, config.gasTarget more gas is issued,\n            // the gas excess will be reduced accordingly.\n            // Note that when lastSyncedBlock is zero, we skip this step\n            // because that means this is the first time calculating the basefee\n            // and the difference between the L1 height would be extremely big,\n            // reverting the initial gas excess value back to 0.\n            uint256 numL1Blocks;\n            if (lastSyncedBlock > 0 && _l1BlockId > lastSyncedBlock) {\n                numL1Blocks = _l1BlockId - lastSyncedBlock;\n            }\n\n            if (numL1Blocks > 0) {\n                uint256 issuance = numL1Blocks * _config.gasTargetPerL1Block;\n                excess = excess > issuance ? excess - issuance : 1;\n            }\n\n            gasExcess_ = uint64(excess.min(type(uint64).max));\n\n            // The base fee pe"
    }
  ]
}