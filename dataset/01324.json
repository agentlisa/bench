{
  "Title": "Missing allowance in `CurveFacet`",
  "Content": "**Description:** When liquidity is added to a Curve pool via `CurveFacet::addLiquidity`, the Beanstalk Diamond first [receives tokens](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/farm/CurveFacet.sol#L112-L116) from the caller and then [sets approvals](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/farm/CurveFacet.sol#L117) to allow the pool to pull these tokens via `ERC20::transferFrom`. Currently, in `CurveFacet::removeLiquidity`, there is no logic for setting allowances on LP tokens before [calling the pool `remove_liquidity` function](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/farm/CurveFacet.sol#L180-L183) as typically the pool and LP token addresses are the same, which means that the relevant burn function can be called internally; however, some pools such as 3CRV and Tri-Crypto (which are already handled differently within a [conditional block](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/farm/CurveFacet.sol#L175)) require an allowance to call `ERC20::burnFrom` given that the pool and LP token addresses differ in these cases.\n\n**Impact:** Callers of the `CurveFacet` may be unable to remove liquidity from the 3CRV and Tri-Crypto pools via Beanstalk.\n\n**Recommended Mitigation:** Unless an infinite approval is already set by the Beanstalk Diamond on these pools, which does not appear to be the case and in any case is not recommended, logic to approve the corresponding pools for these LP tokens should be added to `CurveFacet::removeLiquidity` before the actual call to remove liquidity.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/beanstalk/farm/CurveFacet.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\n// import {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"contracts/C.sol\";\nimport \"contracts/interfaces/ICurve.sol\";\nimport \"contracts/libraries/Token/LibTransfer.sol\";\nimport \"contracts/libraries/Token/LibApprove.sol\";\nimport \"contracts/beanstalk/ReentrancyGuard.sol\";\n\n/**\n * @author Publius\n * @title Curve handles swapping and\n **/\ncontract CurveFacet is ReentrancyGuard {\n    address private constant STABLE_REGISTRY = 0xB9fC157394Af804a3578134A6585C0dc9cc990d4;\n    address private constant CURVE_REGISTRY = 0x90E00ACe148ca3b23Ac1bC8C240C2a7Dd9c2d7f5;\n    address private constant CRYPTO_REGISTRY = 0x8F942C20D02bEfc377D41445793068908E2250D0;\n\n    uint256 private constant MAX_COINS = 8;\n    int128 private constant MAX_COINS_128 = 8;\n\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using LibTransfer for IERC20;\n    using LibBalance for address payable;\n    using LibApprove for IERC20;\n\n    function exchange(\n        address pool,\n        address registry,\n        address fromToken,\n        address toToken,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        LibTransfer.From fromMode,\n        LibTransfer.To toMode\n    ) external payable nonReentrant {\n        (int128 i, int128 j) = getIandJ(fromToken, toToken, pool, registry);\n        amountIn = IERC20(fromToken).receiveToken(\n            amountIn,\n            msg.sender,\n            fromMode\n        );\n        IERC20(fromToken).approveToken(pool, amountIn);\n\n        if (toMode == LibTransfer.To.EXTERNAL && isStable(registry)) {\n            ICurvePoolR(pool).exchange(i, j, amountIn, minAmountOut, msg.sender);\n        } else {\n            uint256 amountOut;\n            if (hasNoReturnValue(pool)) {\n                uint256 beforeBalance = IERC20(toToken).balanceOf(address(this));\n                if (is3Pool(pool)) ICurvePoolNoReturn128(pool).exchange(i, j, amountIn, minAmountOut);\n                else ICurvePoolNoReturn(pool).exchange(uint256(i), uint256(j), amountIn, minAmountOut);\n                amountOut = IERC20(toToken).balanceOf(address(this)).sub(beforeBalance);\n            } else {\n                if (isStable(registry)) amountOut = ICurvePool(pool).exchange(i, j, amountIn, minAmountOut);\n                else amountOut = ICurvePoolC(pool).exchange(uint256(i), uint256(j), amountIn, minAmountOut);\n            }\n            LibTransfer.sendToken(IERC20(toToken), amountOut, msg.sender, toMode);\n        }\n    }\n\n    function exchangeUnderlying(\n        address pool,\n        address fromToken,\n        address toToken,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        LibTransfer.From fromMode,\n        LibTransfer.To toMode\n    ) external payable nonReentrant {\n        (int128 i, int128 j) = getUnderlyingIandJ(fromToken, toToken, pool);\n        amountIn = IERC20(fromToken).receiveToken(amountIn, msg.sender, fromMode);\n        IERC20(fromToken).approveToken(pool, amountIn);\n\n        if (toMode == LibTransfer.To.EXTERNAL) {\n            ICurvePoolR(pool).exchange_underlying(\n                i,\n                j,\n                amountIn,\n                minAmountOut,\n                msg.sender\n            );\n        } else {\n            uint256 amountOut = ICurvePool(pool).exchange_underlying(\n                i,\n                j,\n                amountIn,\n                minAmountOut\n            );\n            msg.sender.increaseInternalBalance(IERC20(toToken), amountOut);\n        }\n    }\n\n    function addLiquidity(\n        address pool,\n        address registry,\n        uint256[] memory amounts,\n        uint256 minAmountOut,\n        LibTransfer.From fromMode,\n        LibTransfer.To toMode\n    ) external payable nonReentrant {\n        address[8] memory coins = getCoins(pool, registry);\n        uint256 nCoins = amounts.length;\n        for (uint256 i; i < nCoins; ++i) {\n            if (amounts[i] > 0) {\n                amounts[i] = IERC20(coins[i]).receiveToken(\n                    amounts[i],\n                    msg.sender,\n                    fromMode\n                );\n                IERC20(coins[i]).approveToken(pool, amounts[i]);\n            }\n        }\n\n        uint256 amountOut;\n        if (hasNoReturnValue(pool)) {\n            IERC20 lpToken = IERC20(tokenForPool(pool));\n            uint256 beforeBalance = lpToken.balanceOf(address(this));\n            ICurvePoolNoReturn(pool).add_liquidity(\n                [amounts[0], amounts[1], amounts[2]],\n                minAmountOut\n            );\n            amountOut = lpToken.balanceOf(address(this)).sub(beforeBalance);\n            LibTransfer.sendToken(lpToken, amountOut, msg.sender, toMode);\n            return;\n        }\n        address to = toMode == LibTransfer.To.EXTERNAL\n            ? msg.sender\n            : address(this);\n        if (nCoins == 2) {\n            amountOut = ICurvePool2R(pool).add_liquidity(\n                [amounts[0], amounts[1]],\n                minAmountOut,\n                to\n            );\n        } else if (nCoins == 3) {\n            amountOut = ICurvePool3R(pool).add_liquidity(\n                [amounts[0], amounts[1], amounts[2]],\n                minAmountOut,\n                to\n            );\n        } else {\n            amountOut = ICurvePool4R(pool).add_liquidity(\n                [amounts[0], amounts[1], amounts[2], amounts[3]],\n                minAmountOut,\n                to\n            );\n        }\n        if (toMode == LibTransfer.To.INTERNAL)\n            msg.sender.increaseInternalBalance(IERC20(pool), amountOut);\n    }\n\n    function removeLiquidity(\n        address pool,\n        address registry,\n        uint256 amountIn,\n        uint256[] calldata minAmountsOut,\n        LibTransfer.From fromMode,\n        LibTransfer.To toMode\n    ) external payable nonReentrant {\n        IERC20 token = tokenForPool(pool);\n        amountIn = token.receiveToken(amountIn, msg.sender, fromMode);\n\n        uint256 nCoins = minAmountsOut.length;\n\n        // 3Pool and Tri-Crypto pools do not return the resulting value,\n        // Thus, we need to call the balanceOf function to determine\n        // how many tokens were received.\n        if (hasNoReturnValue(pool)) {\n            uint256 amountOut;\n            address[8] memory coins = getCoins(pool, registry);\n            uint256[] memory beforeAmounts = new uint256[](nCoins);\n            for (uint256 i; i < nCoins; ++i) beforeAmounts[i] = IERC20(coins[i]).balanceOf(address(this));\n            ICurvePoolNoReturn(pool).remove_liquidity(\n                amountIn,\n                [minAmountsOut[0], minAmountsOut[1], minAmountsOut[2]]\n            );\n            for (uint256 i; i < nCoins; ++i) {\n                amountOut = IERC20(coins[i]).balanceOf(address(this)).sub(beforeAmounts[i]);\n                if (amountOut > 0) LibTransfer.sendToken(IERC20(coins[i]), amountOut, msg.sender, toMode);\n            }\n            return;\n        }\n\n        address to = toMode == LibTransfer.To.EXTERNAL\n            ? msg.sender\n            : address(this);\n        uint256[] memory amounts = new uint256[](nCoins);\n\n        if (nCoins == 2) {\n            uint256[2] memory amountsOut = ICurvePool2R(pool).remove_liquidity(\n                amountIn,\n                [minAmountsOut[0], minAmountsOut[1]],\n                to\n            );\n            for (uint256 i; i < nCoins; ++i) amounts[i] = amountsOut[i];\n        } else if (nCoins == 3) {\n            uint256[3] memory amountsOut = ICurvePool3R(pool).remove_liquidity(\n                amountIn,\n                [minAmountsOut[0], minAmountsOut[1], minAmountsOut[2]],\n                to\n            );\n            for (uint256 i; i < nCoins; ++i) amounts[i] = amountsOut[i];\n        } else {\n            uint256[4] memory amountsOut = ICurvePool4R(pool).remove_liquidity(\n                amountIn,\n                [\n                    minAmountsOut[0],\n                    minAmountsOut[1],\n                    minAmountsOut[2],\n                    minAmountsOut[3]\n                ],\n                to\n            );\n            for (uint256 i; i < nCoins; ++i) amounts[i] = amountsOut[i];\n        }\n        if (toMode == LibTransfer.To.INTERNAL) {\n            address[8] memory coins = getCoins(pool, registry);\n            for (uint256 i; i < nCoins; ++i) {\n                if (amounts[i] > 0) {\n                    msg.sender.increaseInternalBalance(\n                        IERC20(coins[i]),\n                        amounts[i]\n                    );\n                }\n            }\n        }\n    }\n\nfunction removeLiquidityImbalance(\n    address pool,\n    address registry,\n    uint256[] calldata amountsOut,\n    uint256 maxAmountIn,\n    LibTransfer.From fromMode,\n    LibTransfer.To toMode\n) external payable nonReentrant {\n        IERC20 token = tokenForPool(pool);\n        maxAmountIn = token.receiveToken(maxAmountIn, msg.sender, fromMode);\n        uint256 nCoins = amountsOut.length;\n        uint256 amountIn;\n\n        // 3Pool and Tri-Crypto pools do not return the resulting value,\n        // Thus, we need to call the balanceOf function to determine\n        // how many tokens were received.\n        if (hasNoReturnValue(pool)) {\n            require(is3Pool(pool), \"Curve: tri-crypto not supported\");\n            address[8] memory coins = getCoins(pool, registry);\n            IERC20 lpToken = IERC20(tokenForPool(pool));\n            uint256 beforeBalance = lpToken.balanceOf(address(this));\n            ICurvePoolNoReturn(pool).remove_liquidity_imbalance(\n                [amountsOut[0], amountsOut[1], amountsOut[2]],\n                maxAmountIn\n            );\n            for (uint256 i; i < nCoins; ++i) {\n                if (amountsOut[i] > 0) {\n                    LibTransfer.sendToken(IERC20(coins[i]), amountsOut[i], msg.sender, toMode);\n                }\n            }\n            amountIn = beforeBalance.sub(lpToken.balanceOf(address(this)));\n            refundUnusedLPTokens(token, maxAmountIn, amountIn, fromMode);\n            return;\n        }\n\n        address to = toMode == LibTransfer.To.EXTERNAL\n            ? msg.sender\n            : address(this);\n        if (nCoins == 2)\n            amountIn = ICurvePool2R(pool).remove_liquidity_imbalance(\n                [amountsOut[0], amountsOut[1]],\n                maxAmountIn,\n                to\n            );\n        else if (nCoins == 3)\n            amountIn = ICurvePool3R(pool).remove_liquidity_imbalance(\n                [amountsOut[0], amountsOut[1], amountsOut[2]],\n                maxAmountIn,\n                to\n            );\n        else\n            amountIn = ICurvePool4R(pool).remove_liquidity_imbalance(\n                [amountsOut[0], amountsOut[1], amountsOut[2], amountsOut[3]],\n                maxAmountIn,\n                to\n            );\n        refundUnusedLPTokens(token, maxAmountIn, amountIn, fromMode);\n        if (toMode == LibTransfer.To.INTERNAL) {\n            address[8] memory coins = getCoins(pool, registry);\n            for (uint256 i; i < nCoins; ++i) {\n                if (amountsOut[i] > 0) {\n                    msg.sender.increaseInternalBalance(\n                        IERC20(coins[i]),\n                        amountsOut[i]\n                    );\n                }\n            }\n        }\n    }\n\n    function removeLiquidityOneToken(\n        address pool,\n        address registry,\n        address toToken,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        LibTransfer.From fromMode,\n        LibTransfer.To toMode\n    ) external payable nonReentrant {\n        IERC20 fromToken = tokenForPool(pool);\n        amountIn = fromToken.receiveToken(amountIn, msg.sender, fromMode);\n        int128 i = getI(toToken, pool, registry);\n\n        if (hasNoReturnValue(pool)) {\n            uint256 beforeBalance = IERC20(toToken).balanceOf(address(this));\n            if (is3Pool(pool)) {\n                ICurvePoolNoReturn128(pool).remove_liquidity_one_coin(\n                    amountIn,\n                    i,\n                    minAmountOut\n                );\n            } else {\n                ICurvePoolNoReturn(pool).remove_liquidity_one_coin(\n                    amountIn,\n                    uint256(i),\n                    minAmountOut\n                );\n            }\n            uint256 amountOut = IERC20(toToken).balanceOf(address(this)).sub(beforeBalance);\n            LibTransfer.sendToken(IERC20(toToken), amountOut, msg.sender, toMode);\n            return;\n        }\n\n        if (toMode == LibTransfer.To.EXTERNAL) {\n            ICurvePoolR(pool).remove_liquidity_one_coin(\n                amountIn,\n                i,\n                minAmountOut,\n                msg.sender\n            );\n        } else {\n            uint256 amountOut = ICurvePool(pool).remove_liquidity_one_coin(\n                amountIn,\n                i,\n                minAmountOut\n            );\n            msg.sender.increaseInternalBalance(IERC20(toToken), amountOut);\n        }\n    }\n\n    function getUnderlyingIandJ(\n        address from,\n        address to,\n        address pool\n    ) private view returns (int128 i, int128 j) {\n        address[MAX_COINS] memory coins = ICurveFactory(STABLE_REGISTRY)\n            .get_underlying_coins(pool);\n        i = MAX_COINS_128;\n        j = MAX_COINS_128;\n        for (uint256 _i = 0; _i < MAX_COINS; ++_i) {\n            if (coins[_i] == from) i = int128(_i);\n            else if (coins[_i] == to) j = int128(_i);\n            else if (coins[_i] == address(0)) break;\n        }\n        require(i < MAX_COINS_128 && j < MAX_COINS_128, \"Curve: Tokens not in pool\");\n    }\n\n    function getIandJ(\n        address from,\n        address to,\n        address pool,\n        address registry\n    ) private view returns (int128 i, int128 j) {\n        address[MAX_COINS] memory coins = getCoins(pool, registry);\n        i = MAX_COINS_128;\n        j = MAX_COINS_128;\n        for (uint256 _i = 0; _i < MAX_COINS; ++_i) {\n            if (coins[_i] == from) i = int128(_i);\n            else if (coins[_i] == to) j = int128(_i);\n            else if (coins[_i] == address(0)) break;\n        }\n        require(i < MAX_COINS_128 && j < MAX_COINS_128, \"Curve: Tokens not in pool\");\n    }\n\n    function getI(\n        address token,\n        address pool,\n        address registry\n    ) private view returns (int128 i) {\n        address[MAX_COINS] memory coins = getCoins(pool, registry);\n        i = MAX_COINS_128;\n        for (uint256 _i = 0; _i < MAX_COINS; ++_i) {\n            if (coins[_i] == token) i = int128(_i);\n            else if (coins[_i] == address(0)) break;\n        }\n        require(i < MAX_COINS_128, \"Curve: Tokens not in pool\");\n    }\n\n    function tokenForPool(address pool) private pure returns (IERC20 token) {\n        if (pool == C.curve3PoolAddress()) return C.threeCrv();\n        if (pool == C.triCryptoPoolAddress()) return C.triCrypto();\n        return IERC20(pool);\n    }\n\n    function getCoins(address pool, address registry)\n        private\n        view\n        returns (address[8] memory)\n    {\n        if (registry == STABLE_REGISTRY) {\n            address[4] memory coins =  ICurveFactory(registry).get_coins(pool);\n            return [coins[0], coins[1], coins[2], coins[3], address(0), address(0), address(0), address(0)];\n        }\n        require(registry == CURVE_REGISTRY ||\n                registry == CRYPTO_REGISTRY,\n                \"Curve: Not valid registry\"\n        );\n        return ICurveCryptoFactory(registry)\n            .get_coins(pool);\n    }\n\n    function isStable(address registry) private pure returns (bool) {\n        return registry == STABLE_REGISTRY;\n    }\n\n    function hasNoReturnValue(address pool) private pure returns (bool) {\n        return pool == C.triCryptoPoolAddress() || pool == C.curve3PoolAddress();\n    }\n\n        function is3Pool(address pool) private pure returns (bool) {\n        return pool == C.curve3PoolAddress();\n    }\n\n    function refundUnusedLPTokens(IERC20 token, uint256 maxAmountIn, uint256 amountIn, LibTransfer.From fromMode) private {\n        if (amountIn < maxAmountIn) {\n            LibTransfer.To refundMode = (\n                fromMode == LibTransfer.From.EXTERNAL\n                    ? LibTransfer.To.EXTERNAL\n                    : LibTransfer.To.INTERNAL\n            );\n            token.sendToken(maxAmountIn - amountIn, msg.sender, refundMode);\n        }\n    }\n}"
    }
  ]
}