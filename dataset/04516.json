{
  "Title": "Unsafe arithmetic operations in Airdrop contract",
  "Content": "The `Airdrop` contract contains a series of arithmetic operations which are not being addressed with caution (in lines [30](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L30) , [39](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L39) , [56](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L56) , [58](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L58) , [64](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L64) and [65](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L65) ) , leading to attempts to store numbers outside the range of the data types of their target variables. There are in particular two situations which could potentially cause integer overflows/underflows.\n\n\nThe first case is related to an assignment to a storage variable inside a loop in the [`addManyUsers`](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L45) function. This function iterates through a `_recipients`array of `addresses` and a paired `_amounts` array of `uint256`‘s. In each iteration, the function [`addUser`](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L27) is called, which adds the respective user amount to the storage variable `totalBonus`, in charge of accumulating the sum. For an extremely large list of users and amounts, the variable `totalBonus` may reach its maximum possible value and finally overflow (*i.e.* start again from 0). In this scenario, an inconsistency between the total bonus sum and each user’s bonus amount would be reached.\n\n\nIn the second case, an unsafe math operation in the [`payManyUsers`](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L61) function could lead to an integer underflow. After the contract is deployed, the storage variable [`nextUserToBePaid`](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L11) equals 0. When calling [`payManyUsers`](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L61) , if 0 was passed as the value of the `batchSize` variable (or the function was externally called without parameters) , the unsigned variable `idTo` would be assigned the result of the operation 0 + 0 – 1, resulting in an underflow and a stored value of 2²⁵⁶ – – While in this case the [immediately followin](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L65)  [`if`](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L65) [`clause`](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L65) would prevent something unexpected to happen, this approach is error-prone and not advised.\n\n\nConsider using [OpenZeppelin’s](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v1.12.0/contracts/math/SafeMath.sol)  [`SafeMath`](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v1.12.0/contracts/math/SafeMath.sol) library to avoid underflows/overflows when doing mathematical operations.\n\n\n***Update:** the `SafeMath` library is now being used throughout.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Airdrop.sol",
      "content": "pragma solidity ^0.4.0;\npragma experimental \"v0.5.0\";\n\nimport \"../node_modules/openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\nimport \"../node_modules/openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\ncontract AirDrop is Ownable {\n    address public renderTokenAddress;\n    bool public listFinalized = false;\n    uint256 public totalBonus;\n    uint256 public nextUserToBePaid = 0;\n\n    mapping (address => uint256) public bonusAmounts;\n    address[] public bonusAddresses;\n\n    event AddedUser(address userAddress, uint256 userIndex, uint256 bonusAmount);\n    event PaidUser(address userAddress, uint256 userIndex, uint256 amountPaid);\n\n    constructor(address _renderTokenAddress) public {\n        renderTokenAddress = _renderTokenAddress;\n    }\n    \n    function getUserCount() public view returns (uint256) {\n        return bonusAddresses.length;\n    }\n    \n    function addUser(address _userAddress, uint256 _amount) internal {\n        require (bonusAmounts[_userAddress] == 0, \"User bonus shouldn't exist before adding\");\n        bonusAmounts[_userAddress] = _amount;\n        totalBonus += _amount;\n        emit AddedUser(_userAddress, bonusAddresses.push(_userAddress) - 1, _amount);\n    }\n\n    function payUser(uint256 _id) internal returns(uint256 amount) {\n        amount = bonusAmounts[bonusAddresses[_id]];\n\n        if (amount > 0) { // If bonus hasn't been paid yet\n            bonusAmounts[bonusAddresses[_id]] = 0;\n            totalBonus -= amount;\n            ERC20(renderTokenAddress).transfer(bonusAddresses[_id], amount);\n            emit PaidUser(bonusAddresses[_id], _id, amount);\n        }\n    }\n\n    function addManyUsers(address[] _recipients, uint256[] _amounts) public onlyOwner {\n        require(!listFinalized, \"Adding users allowed only when list isn't finalized\");\n        for (uint i = 0; i < _recipients.length; i++) {\n            addUser(_recipients[i], _amounts[i]);\n        }\n    }\n    \n    function payUserRange(uint256 _idFrom, uint256 _idTo) internal returns(uint256 totalPaid) {\n        require(_idTo < bonusAddresses.length, \"idTo should be less than user count\");\n        require(_idFrom <= _idTo, \"idFrom shouldn't be greater than idTo\");\n        for (uint i = _idFrom; i <= _idTo; i++) { // idTo included\n            totalPaid += payUser(i);\n        }\n        nextUserToBePaid = _idTo + 1;\n    }\n    \n    function payManyUsers(uint256 batchSize) public onlyOwner returns(uint256 totalPaid) {\n        require(listFinalized, \"Payment can be called only after list is finalized\");\n        uint256 idFrom = nextUserToBePaid;\n        uint256 idTo = idFrom + batchSize - 1;\n        if (idTo >= bonusAddresses.length) idTo = bonusAddresses.length - 1;\n        return payUserRange(idFrom, idTo);\n    }\n\n    function finalizeList() public onlyOwner {\n        require(!listFinalized, \"Can be called only if list isn't finalized\");\n        listFinalized = true;\n    }\n    \n    function returnTokens() public onlyOwner {\n        uint256 amount = ERC20(renderTokenAddress).balanceOf(address(this));\n        ERC20(renderTokenAddress).transfer(owner, amount);\n    }\n}"
    },
    {
      "filename": "contracts/Airdrop.sol",
      "content": "pragma solidity ^0.4.0;\npragma experimental \"v0.5.0\";\n\nimport \"../node_modules/openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\nimport \"../node_modules/openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\ncontract AirDrop is Ownable {\n    address public renderTokenAddress;\n    bool public listFinalized = false;\n    uint256 public totalBonus;\n    uint256 public nextUserToBePaid = 0;\n\n    mapping (address => uint256) public bonusAmounts;\n    address[] public bonusAddresses;\n\n    event AddedUser(address userAddress, uint256 userIndex, uint256 bonusAmount);\n    event PaidUser(address userAddress, uint256 userIndex, uint256 amountPaid);\n\n    constructor(address _renderTokenAddress) public {\n        renderTokenAddress = _renderTokenAddress;\n    }\n    \n    function getUserCount() public view returns (uint256) {\n        return bonusAddresses.length;\n    }\n    \n    function addUser(address _userAddress, uint256 _amount) internal {\n        require (bonusAmounts[_userAddress] == 0, \"User bonus shouldn't exist before adding\");\n        bonusAmounts[_userAddress] = _amount;\n        totalBonus += _amount;\n        emit AddedUser(_userAddress, bonusAddresses.push(_userAddress) - 1, _amount);\n    }\n\n    function payUser(uint256 _id) internal returns(uint256 amount) {\n        amount = bonusAmounts[bonusAddresses[_id]];\n\n        if (amount > 0) { // If bonus hasn't been paid yet\n            bonusAmounts[bonusAddresses[_id]] = 0;\n            totalBonus -= amount;\n            ERC20(renderTokenAddress).transfer(bonusAddresses[_id], amount);\n            emit PaidUser(bonusAddresses[_id], _id, amount);\n        }\n    }\n\n    function addManyUsers(address[] _recipients, uint256[] _amounts) public onlyOwner {\n        require(!listFinalized, \"Adding users allowed only when list isn't finalized\");\n        for (uint i = 0; i < _recipients.length; i++) {\n            addUser(_recipients[i], _amounts[i]);\n        }\n    }\n    \n    function payUserRange(uint256 _idFrom, uint256 _idTo) internal returns(uint256 totalPaid) {\n        require(_idTo < bonusAddresses.length, \"idTo should be less than user count\");\n        require(_idFrom <= _idTo, \"idFrom shouldn't be greater than idTo\");\n        for (uint i = _idFrom; i <= _idTo; i++) { // idTo included\n            totalPaid += payUser(i);\n        }\n        nextUserToBePaid = _idTo + 1;\n    }\n    \n    function payManyUsers(uint256 batchSize) public onlyOwner returns(uint256 totalPaid) {\n        require(listFinalized, \"Payment can be called only after list is finalized\");\n        uint256 idFrom = nextUserToBePaid;\n        uint256 idTo = idFrom + batchSize - 1;\n        if (idTo >= bonusAddresses.length) idTo = bonusAddresses.length - 1;\n        return payUserRange(idFrom, idTo);\n    }\n\n    function finalizeList() public onlyOwner {\n        require(!listFinalized, \"Can be called only if list isn't finalized\");\n        listFinalized = true;\n    }\n    \n    function returnTokens() public onlyOwner {\n        uint256 amount = ERC20(renderTokenAddress).balanceOf(address(this));\n        ERC20(renderTokenAddress).transfer(owner, amount);\n    }\n}"
    },
    {
      "filename": "contracts/Airdrop.sol",
      "content": "pragma solidity ^0.4.0;\npragma experimental \"v0.5.0\";\n\nimport \"../node_modules/openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\nimport \"../node_modules/openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\ncontract AirDrop is Ownable {\n    address public renderTokenAddress;\n    bool public listFinalized = false;\n    uint256 public totalBonus;\n    uint256 public nextUserToBePaid = 0;\n\n    mapping (address => uint256) public bonusAmounts;\n    address[] public bonusAddresses;\n\n    event AddedUser(address userAddress, uint256 userIndex, uint256 bonusAmount);\n    event PaidUser(address userAddress, uint256 userIndex, uint256 amountPaid);\n\n    constructor(address _renderTokenAddress) public {\n        renderTokenAddress = _renderTokenAddress;\n    }\n    \n    function getUserCount() public view returns (uint256) {\n        return bonusAddresses.length;\n    }\n    \n    function addUser(address _userAddress, uint256 _amount) internal {\n        require (bonusAmounts[_userAddress] == 0, \"User bonus shouldn't exist before adding\");\n        bonusAmounts[_userAddress] = _amount;\n        totalBonus += _amount;\n        emit AddedUser(_userAddress, bonusAddresses.push(_userAddress) - 1, _amount);\n    }\n\n    function payUser(uint256 _id) internal returns(uint256 amount) {\n        amount = bonusAmounts[bonusAddresses[_id]];\n\n        if (amount > 0) { // If bonus hasn't been paid yet\n            bonusAmounts[bonusAddresses[_id]] = 0;\n            totalBonus -= amount;\n            ERC20(renderTokenAddress).transfer(bonusAddresses[_id], amount);\n            emit PaidUser(bonusAddresses[_id], _id, amount);\n        }\n    }\n\n    function addManyUsers(address[] _recipients, uint256[] _amounts) public onlyOwner {\n        require(!listFinalized, \"Adding users allowed only when list isn't finalized\");\n        for (uint i = 0; i < _recipients.length; i++) {\n            addUser(_recipients[i], _amounts[i]);\n        }\n    }\n    \n    function payUserRange(uint256 _idFrom, uint256 _idTo) internal returns(uint256 totalPaid) {\n        require(_idTo < bonusAddresses.length, \"idTo should be less than user count\");\n        require(_idFrom <= _idTo, \"idFrom shouldn't be greater than idTo\");\n        for (uint i = _idFrom; i <= _idTo; i++) { // idTo included\n            totalPaid += payUser(i);\n        }\n        nextUserToBePaid = _idTo + 1;\n    }\n    \n    function payManyUsers(uint256 batchSize) public onlyOwner returns(uint256 totalPaid) {\n        require(listFinalized, \"Payment can be called only after list is finalized\");\n        uint256 idFrom = nextUserToBePaid;\n        uint256 idTo = idFrom + batchSize - 1;\n        if (idTo >= bonusAddresses.length) idTo = bonusAddresses.length - 1;\n        return payUserRange(idFrom, idTo);\n    }\n\n    function finalizeList() public onlyOwner {\n        require(!listFinalized, \"Can be called only if list isn't finalized\");\n        listFinalized = true;\n    }\n    \n    function returnTokens() public onlyOwner {\n        uint256 amount = ERC20(renderTokenAddress).balanceOf(address(this));\n        ERC20(renderTokenAddress).transfer(owner, amount);\n    }\n}"
    }
  ]
}