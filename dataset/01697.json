{
  "Title": "M-2: The fees are incorrectly updated in the `_deposit` and `_withdraw` functions, which allows the attacker to break the protocol fees",
  "Content": "# Issue M-2: The fees are incorrectly updated in the `_deposit` and `_withdraw` functions, which allows the attacker to break the protocol fees \n\nSource: https://github.com/sherlock-audit/2023-06-real-wagmi-judging/issues/52 \n\n## Found by \nduc\n## Summary\nIn `_deposit` and `_withdraw` function of Multipool contract, `fee0` and `fee1` are calculated from the accrued fee amounts to update feeGrowth of contract and send the protocol fee to the owner. However, these calculations are incorrect and do not align with the collected fees from the positions. It allows attacker break the protocol fees.\n## Vulnerability Detail\nIn function `withdraw`, all accrued fees from Uniswap V3 pool will be collected (`tokensOwed0After` and `tokensOwed1After`). However, `fee0` and `fee1` are updated by `tokensOwed0After - tokensOwed0Before` and `tokensOwed1After - tokensOwed1Before`.\n```solidity=\n///https://github.com/sherlock-audit/2023-06-real-wagmi/blob/main/concentrator/contracts/Multipool.sol#L509-L536\n(, , , uint128 tokensOwed0Before, uint128 tokensOwed1Before) = IUniswapV3Pool(\n    position.poolAddress\n).positions(position.positionKey);\n\nIUniswapV3Pool(position.poolAddress).mint(\n    address(this), //recipient\n    position.lowerTick,\n    position.upperTick,\n    liquidity,\n    abi.encode(position.poolFeeAmt)\n);\n\n(, , , uint128 tokensOwed0After, uint128 tokensOwed1After) = IUniswapV3Pool(\n    position.poolAddress\n).positions(position.positionKey);\n\nfee0 += tokensOwed0After - tokensOwed0Before;\nfee1 += tokensOwed1After - tokensOwed1Before;\n\nIUniswapV3Pool(position.poolAddress).collect(\n    address(this),\n    position.lowerTick,\n    position.upperTick,\n    type(uint128).max,\n    type(uint128).max\n);\n```\nIt is incorrect because in cases where `tokensOwed0Before > 0` or `tokensOwed1Before` > 0, `fee0` and `fee1` end up being smaller than the collected fees. Consequently, when `_upFeesGrowth` is executed, it will send smaller protocol fees than expected.\n\nTherefore, an attacker can exploit this vulnerability and undermine the protocol fees by minting minuscule amounts to all positions within the Multipool contract. This is possible since anyone can mint for any positions in UniSwapV3 pools (the owner of position is recipient). This causes the fees of each position to be accrued beforehand, resulting in `tokensOwed0Before` and `tokensOwed1Before` becoming close to `tokensOwed0After` and `tokensOwed1After`. Then the majority of protocol fees will be lost (solvent in the reserve).\n\nScenario:\n1. Attacker mints minuscule amounts to all positions within the Multipool contract to accrue fees for these positions.\n2. The attacker then calls the `earn()` function to collect and update fees. In this scenario, `tokensOwed0Before` and `tokensOwed1Before` become equal to `tokensOwed0After` and `tokensOwed1After` (withdrawing 0 liquidity). As a result, `fee0` and `fee1` become 0, leading to the loss of these protocol fees.\n\nSimilar to `_deposit` function.\n## Impact\nProtocol will lose its fees.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-06-real-wagmi/blob/main/concentrator/contracts/Multipool.sol#L509-L536\nhttps://github.com/sherlock-audit/2023-06-real-wagmi/blob/main/concentrator/contracts/Multipool.sol#L381-L406\n## Tool used\nManual review\n\n## Recommendation\n`fee0` and `fee1` in `_deposit` and `_withdraw` function should be equal to the collected fee amounts (`tokensOwed0After` and `tokensOwed1After`)\n\n\n\n## Discussion\n\n**huuducsc**\n\nEscalate\n\nThis issue pertains to the incorrect updating of fees, resulting in a significant loss of the protocol fee. The explanation is clear enough if you have knowledge about UniswapV3.\nHere are my detailed explanations:\n1. The fee from the UniswapV3 pool is accumulated into the data of a position when that position is updated (by adding liquidity or removing liquidity ...). This allows anyone to mint minuscule amounts for the positions of Multipool to accrue the fee for them into position data.\nhttps://github.com/Uniswap/v3-core/blob/main/contracts/UniswapV3Pool.sol#L442\nhttps://github.com/Uniswap/v3-core/blob/main/contracts/libraries/Position.sol#L79-L85\n2. In the function [`_withdraw`](https://github.com/sherlock-audit/2023-06-real-wagmi/blob/main/concentrator/contracts/Multipool.sol#L488-L544) of the Multipool contract, `tokensOwed0Before` and `tokensOwed1Before` are the current collectible amounts of this position (the current accrued fee). `amount0` and `amount1` are the amount from burning liquidity. \nTherefore, `(tokensOwed0After - amount0) - tokensOwed0Before` is only equal to the fee from the burn call (which is very small) and doesn't include the accrued fee mentioned above. However, the contract has collected all the collectible amounts of each position, which means the accrued fee has been collected but is not accumulated in `fee0` and `fee1`.\n    ```solidity=\n    (, , , uint128 tokensOwed0Before, uint128 tokensOwed1Before) = IUniswapV3Pool(\n      position.poolAddress\n    ).positions(position.positionKey);\n    \n    (uint256 amount0, uint256 amount1) = IUniswapV3Pool(position.poolAddress).burn(\n      position.lowerTick,\n      position.upperTick,\n      liquidityToWithdraw\n    );\n    \n    withdrawnAmount0 += amount0;\n    withdrawnAmount1 += amount1;\n\n    (, , , uint128 tokensOwed0After, uint128 tokensOwed1After) = IUniswapV3Pool(\n        position.poolAddress\n    ).positions(position.positionKey);\n  \n    fee0 += (tokensOwed0After - amount0) - tokensOwed0Before;\n    fee1 += (tokensOwed1After - amount1) - tokensOwed1Before;\n    ```\n3. The `_withdraw` function will trigger [`_upFeesGrowth`](https://github.com/sherlock-audit/2023-06-real-wagmi/blob/main/concentrator/contracts/Multipool.sol#L328-L358) function with incorrect `fee0` and `fee1`. They don't include the accrued fee of this position before. This will result in the protocol losing a significant protocol fee.\n\n\n**sherlock-admin**\n\n > Escalate\n> \n> This issue pertains to the incorrect updating of fees, resulting in a significant loss of the protocol fee. The explanation is clear enough if you have knowledge about UniswapV3.\n> Here are my detailed explanations:\n> 1. The fee from the UniswapV3 pool is accumulated into the data of a position when that position is updated (by adding liquidity or removing liquidity ...). This allows anyone to mint minuscule amounts for the positions of Multipool to accrue the fee for them into position data.\n> https://github.com/Uniswap/v3-core/blob/main/contracts/UniswapV3Pool.sol#L442\n> https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/Position.sol#L79-L85\n> 2. In the function [`_withdraw`](https://github.com/sherlock-audit/2023-06-real-wagmi/blob/main/concentrator/contracts/Multipool.sol#L488-L544) of the Multipool contract, `tokensOwed0Before` and `tokensOwed1Before` are the current collectible amounts of this position (the current accrued fee). `amount0` and `amount1` are the amount from burning liquidity. \n> Therefore, `(tokensOwed0After - amount0) - tokensOwed0Before` is only equal to the fee from the burn call (which is very small) and doesn't include the accrued fee mentioned above. However, the contract has collected all the collectible amounts of each position, which means the accrued fee has been collected but is not accumulated in `fee0` and `fee1`.\n>     ```solidity=\n>     (, , , uint128 tokensOwed0Before, uint128 tokensOwed1Before) = IUniswapV3Pool(\n>       position.poolAddress\n>     ).positions(position.positionKey);\n>     \n>     (uint256 amount0, uint256 amount1) = IUniswapV3Pool(position.poolAddress).burn(\n>       position.lowerTick,\n>       position.upperTick,\n>       liquidityToWithdraw\n>     );\n>     \n>     withdrawnAmount0 += amount0;\n>     withdrawnAmount1 += amount1;\n> \n>     (, , , uint128 tokensOwed0After, uint128 tokensOwed1After) = IUniswapV3Pool(\n>         position.poolAddress\n>     ).positions(position.positionKey);\n>   \n>     fee0 += (tokensOwed0After - amount0) - tokensOwed0Before;\n>     fee1 += (tokensOwed1After - amount1) - tokensOwed1Before;\n>     ```\n> 3. The `_withdraw` function will trigger [`_upFeesGrowth`](https://github.com/sherlock-audit/2023-06-real-wagmi/blob/main/concentrator/contracts/Multipool.sol#L328-L358) function with incorrect `fee0` and `fee1`. They don't include the accrued fee of this position before. This will result in the protocol losing a significant protocol fee.\n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nThis seems like a medium, recommend bring sponsor for review\n\n**hrishibhat**\n\n@huuducsc \nSponsor comment:\n> It doesn't make sense and does not matter what small position the user will mint. The Uniswap positions are common for all users. The Uniswap positions are owned by the multipool and fees will be collected on the entire liquidity of the multitool for each withdrawal or deposit.\n\n\n**huuducsc**\n\n> @huuducsc Sponsor comment:\n> \n> > It doesn't make sense and does not matter what small position the user will mint. The Uniswap positions are common for all users. The Uniswap positions are owned by the multipool and fees will be collected on the entire liquidity of the multitool for each withdrawal or deposit.\n\nI agree that fees will be collected on the entire liquidity of the multitool for each withdrawal or deposit, but it is not related to this issue. This issue is about the protocol fee, which is derived from the total fees collected from Multipool's positions, and it may be compromised. The protocol fee is only charged in the `_deposit` and `_withdraw` functions. If the fees from Multipool's positions were to be collected without using `_deposit` and `_withdraw` (for example, by adding a small amount of liquidity directly), the protocol fee would not increase during the next `_deposit` or `_withdraw` action. As a result, an attacker would be able to manipulate the protocol fee by front-running these functions.\n\n**fann95**\n\nFIXED: https://github.com/RealWagmi/concentrator/commit/9036fe43b0de2694a0c5e18cfe821d40ce17a9b8\n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nConsidering this issue a valid medium\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [huuducsc](https://github.com/sherlock-audit/2023-06-real-wagmi-judging/issues/52/#issuecomment-1632859059): accepted\n\n**0xffff11**\n\nFixed by deleting the subtraction of `tokensOwed0Before` and accounting for the collected fee amounts \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/88",
  "Code": [
    {
      "filename": "concentrator/contracts/Multipool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@uniswap/v3-core/contracts/libraries/FixedPoint128.sol\";\nimport { IUniswapV3Pool } from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport { Babylonian } from \"./vendor0.8/uniswap/Babylonian.sol\";\nimport { FullMath, LiquidityAmounts } from \"./vendor0.8/uniswap/LiquidityAmounts.sol\";\nimport { TickMath } from \"./vendor0.8/uniswap/TickMath.sol\";\nimport { PositionKey } from \"@uniswap/v3-periphery/contracts/libraries/PositionKey.sol\";\nimport { ErrLib } from \"./libraries/ErrLib.sol\";\nimport { IMultiStrategy } from \"./interfaces/IMultiStrategy.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\n\n// import \"hardhat/console.sol\";\n\ncontract Multipool is Ownable, ERC20 {\n    error InvalidManaging();\n    error InvalidFee(uint24 fee);\n\n    enum MANAGING {\n        MAXTOTALSUPPLY,\n        PROTOCOLFEEWEIGHT,\n        OPERATOR,\n        TWAPDURATION,\n        MAXTWAPDEVIATION\n    }\n\n    struct Slot0Data {\n        int24 tick;\n        uint160 currentSqrtRatioX96;\n    }\n\n    struct PositionInfo {\n        int24 lowerTick;\n        int24 upperTick;\n        uint24 poolFeeAmt;\n        uint256 weight;\n        address poolAddress;\n        bytes32 positionKey;\n    }\n\n    struct RebalanceParams {\n        // The direction of the swap, true for token0 to token1, false for token1 to token0\n        bool zeroForOne;\n        // Aggregator's router address\n        address swapTarget;\n        // The amount of the swap\n        uint amountIn;\n        // Aggregator's data that stores pathes and amounts swap through\n        bytes swapData;\n    }\n\n    struct UnderlyingPool {\n        int24 tickSpacing;\n        address poolAddress;\n    }\n\n    struct FeeGrowth {\n        uint256 accPerShare0;\n        uint256 accPerShare1;\n        uint256 gmiAccPerShare0;\n        uint256 gmiAccPerShare1;\n    }\n\n    IUniswapV3Factory public immutable underlyingV3Factory;\n    uint24[] public fees;\n    bool private entered;\n    address private constant burnAddress = 0x000000000000000000000000000000000000dEaD;\n    IMultiStrategy public immutable strategy;\n    uint256 public constant MAX_WEIGHT_UINT256 = 10000;\n    uint256 public constant MINIMUM_LIQUIDITY = 1000;\n    uint256 public constant MINIMUM_AMOUNT = 1000_000;\n    address public immutable multiFactory;\n    address public immutable token0;\n    address public immutable token1;\n\n    address operator;\n\n    uint256 public protocolFeeWeightMax = 2000; //20 %\n    uint256 public protocolFeeWeight = 2000;\n\n    uint256 public maxTotalSupply = 1e20;\n\n    uint256 public maxTwapDeviation = 100; // 1%\n\n    uint32 public twapDuration = 150;\n    /**\n     * @dev The accumulated fee per share of liquidity multiplied by FixedPoint128.Q128.\n     * Tthe amount of pending fees per share should be added to the userRewardDebt variable.\n     */\n    FeeGrowth public feesGrowthInsideLastX128;\n\n    //      fee =>poolAddress\n    mapping(uint24 => UnderlyingPool) public underlyingTrustedPools;\n\n    mapping(address => bool) public approvedTargets;\n\n    PositionInfo[] public multiPosition;\n\n    event Deposit(address user, uint256 amount0, uint256 amount1, uint256 liquidity);\n    event Withdraw(address user, uint256 amount0, uint256 amount1, uint256 liquidity);\n    event Rebalance(\n        uint256 reserve0Before,\n        uint256 reserve1Before,\n        uint256 reserve0,\n        uint256 reserve1,\n        uint256 swappedOut\n    );\n    event SwapTargetApproved(address indexed target, bool approved);\n    event ParamChanged(MANAGING managing, uint param);\n    event TrustedPoolAdded(uint24 fee, address poolAddress);\n\n    constructor(\n        address _token0,\n        address _token1,\n        address manager,\n        address _underlyingV3Factory,\n        IMultiStrategy _strategy,\n        string memory _name,\n        string memory _symbol,\n        uint24[] memory _fees\n    ) ERC20(_name, _symbol) {\n        IUniswapV3Factory factory = IUniswapV3Factory(_underlyingV3Factory);\n\n        for (uint256 i = 0; i < _fees.length; ) {\n            _addUnderlyingPool(_fees[i], _token0, _token1, factory);\n            unchecked {\n                ++i;\n            }\n        }\n        underlyingV3Factory = factory;\n\n        multiFactory = msg.sender;\n\n        strategy = _strategy;\n        token0 = _token0;\n        token1 = _token1;\n\n        _transferOwnership(manager);\n        operator = manager;\n    }\n\n    modifier nonReentrant() {\n        require(!entered, \"RC\");\n        entered = true;\n        _;\n        entered = false;\n    }\n\n    function addUnderlyingPool(uint24 fee) external onlyOwner {\n        _addUnderlyingPool(fee, token0, token1, underlyingV3Factory);\n    }\n\n    function _addUnderlyingPool(\n        uint24 _fee,\n        address _token0,\n        address _token1,\n        IUniswapV3Factory _factory\n    ) private {\n        address poolAddress = _factory.getPool(_token0, _token1, _fee);\n\n        if (poolAddress == address(0)) {\n            revert InvalidFee(_fee);\n        }\n        underlyingTrustedPools[_fee] = UnderlyingPool({\n            tickSpacing: IUniswapV3Pool(poolAddress).tickSpacing(),\n            poolAddress: poolAddress\n        });\n        fees.push(_fee);\n        emit TrustedPoolAdded(_fee, poolAddress);\n    }\n\n    function _safeTransfer(address token, address to, uint256 value) private {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20.transfer.selector, to, value)\n        );\n        ErrLib.requirement(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            ErrLib.ErrorCode.ERC20_TRANSFER_DID_NOT_SUCCEED\n        );\n    }\n\n    function _safeTransferFrom(address token, address from, address to, uint256 value) private {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value)\n        );\n        ErrLib.requirement(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            ErrLib.ErrorCode.ERC20_TRANSFER_FROM_DID_NOT_SUCCEED\n        );\n    }\n\n    function _safeApprove(address token, address spender, uint256 amount) private {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20.approve.selector, spender, amount)\n        );\n        ErrLib.requirement(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            ErrLib.ErrorCode.ERC20_APPROVE_DID_NOT_SUCCEED\n        );\n    }\n\n    /**\n     * @dev Takes a snapshot of current state and returns various information related to multi pool.\n     * @return reserve0 Amount of token0 in the reserve\n     * @return reserve1 Amount of token1 in the reserve\n     * @return feesGrow A structure containing fee growth information\n     * @return _totalSupply Total number of LP tokens minted\n     */\n    function snapshot()\n        external\n        returns (\n            uint256 reserve0,\n            uint256 reserve1,\n            FeeGrowth memory feesGrow,\n            uint256 _totalSupply\n        )\n    {\n        _totalSupply = totalSupply();\n        _earn(_totalSupply);\n        Slot0Data[] memory slots = getSlots();\n        (reserve0, reserve1, , ) = _getReserves(slots);\n        feesGrow = feesGrowthInsideLastX128;\n    }\n\n    /**\n     * @notice This function collects fees from the liquidity pool and updates the fee growth inside both Vaults per share\n     *         based on the amount of fees collected. It then returns the updated fee growth values.\n     * @dev When called, this function updates the fee growth inside each Vault according to the realised fees in the current block,\n     *      adding them to the `feesGrowthInsideLastX128` struct member variable of the contract.\n     */\n    function earn() external {\n        uint256 _totalSupply = totalSupply();\n        _earn(_totalSupply);\n    }\n\n    function _earn(uint256 _totalSupply) private {\n        if (_totalSupply > 0) {\n            _withdraw(0, _totalSupply);\n        }\n    }\n\n    function _checkTicks(int24 tickLower, int24 tickUpper, int24 _tickSpacing) private pure {\n        ErrLib.requirement(tickLower < tickUpper, ErrLib.ErrorCode.LOWER_SHOULD_BE_LESS_UPPER);\n        ErrLib.requirement(tickLower >= TickMath.MIN_TICK, ErrLib.ErrorCode.LOWER_TOO_SMALL);\n        ErrLib.requirement(tickUpper <= TickMath.MAX_TICK, ErrLib.ErrorCode.UPPER_TOO_BIG);\n        ErrLib.requirement(tickLower % _tickSpacing == 0, ErrLib.ErrorCode.TICKLOWER_IS_NOT_SPACED);\n        ErrLib.requirement(tickUpper % _tickSpacing == 0, ErrLib.ErrorCode.TICKUPPER_IS_NOT_SPACED);\n    }\n\n    function _getTicksForPosition(\n        int24 tick,\n        int24 positionRange,\n        int24 tickSpacingOffset,\n        int24 tickSpacing\n    ) private pure returns (int24 lowerTick, int24 upperTick) {\n        int24 floorTick = (tick / tickSpacing) * tickSpacing;\n        if (tickSpacingOffset == 0) {\n            lowerTick = floorTick - (positionRange - tickSpacing) / 2;\n            upperTick = floorTick + (positionRange + tickSpacing) / 2;\n        } else if (tickSpacingOffset > 0) {\n            lowerTick = floorTick + tickSpacing * tickSpacingOffset;\n            upperTick = lowerTick + positionRange;\n        } else {\n            upperTick = floorTick + tickSpacing * tickSpacingOffset;\n            lowerTick = upperTick - positionRange;\n        }\n    }\n\n    function _initializeStrategy() private returns (Slot0Data[] memory) {\n        uint256 positionsNum = strategy.strategySize();\n        ErrLib.requirement(positionsNum > 0, ErrLib.ErrorCode.STRATEGY_DOES_NOT_EXIST);\n        delete multiPosition;\n        PositionInfo memory position;\n        int24 upperTick;\n        int24 lowerTick;\n        Slot0Data[] memory slots = new Slot0Data[](positionsNum);\n\n        for (uint256 i = 0; i < positionsNum; ) {\n            IMultiStrategy.Strategy memory sPosition = strategy.getStrategyAt(i);\n            UnderlyingPool memory uPool = underlyingTrustedPools[sPosition.poolFeeAmt];\n            position.poolFeeAmt = sPosition.poolFeeAmt;\n            position.weight = sPosition.weight;\n            position.poolAddress = uPool.poolAddress;\n            (slots[i].currentSqrtRatioX96, slots[i].tick, , , , , ) = IUniswapV3Pool(\n                uPool.poolAddress\n            ).slot0();\n            (lowerTick, upperTick) = _getTicksForPosition(\n                slots[i].tick,\n                sPosition.positionRange,\n                sPosition.tickSpacingOffset,\n                uPool.tickSpacing\n            );\n            _checkTicks(lowerTick, upperTick, uPool.tickSpacing);\n            position.upperTick = upperTick;\n            position.lowerTick = lowerTick;\n            position.positionKey = PositionKey.compute(\n                address(this),\n                position.lowerTick,\n                position.upperTick\n            );\n\n            multiPosition.push(position);\n            unchecked {\n                ++i;\n            }\n        }\n        return slots;\n    }\n\n    function _calcLiquidityAmountToDeposit(\n        uint160 currentSqrtRatioX96,\n        PositionInfo memory position,\n        uint256 amount0Desired,\n        uint256 amount1Desired\n    ) private pure returns (uint128 liquidity) {\n        liquidity = LiquidityAmounts.getLiquidityForAmounts(\n            currentSqrtRatioX96,\n            TickMath.getSqrtRatioAtTick(position.lowerTick),\n            TickMath.getSqrtRatioAtTick(position.upperTick),\n            (amount0Desired * position.weight) / MAX_WEIGHT_UINT256,\n            (amount1Desired * position.weight) / MAX_WEIGHT_UINT256\n        );\n    }\n\n    function _upFeesGrowth(uint256 fee0, uint256 fee1, uint256 _totalSupply) private {\n        feesGrowthInsideLastX128.gmiAccPerShare0 += FullMath.mulDiv(\n            fee0,\n            FixedPoint128.Q128,\n            _totalSupply\n        );\n\n        feesGrowthInsideLastX128.gmiAccPerShare1 += FullMath.mulDiv(\n            fee1,\n            FixedPoint128.Q128,\n            _totalSupply\n        );\n        uint256 feeGrowthWeight = MAX_WEIGHT_UINT256 - protocolFeeWeight;\n        uint256 fee0WPF = (fee0 * feeGrowthWeight) / MAX_WEIGHT_UINT256;\n        uint256 fee1WPF = (fee1 * feeGrowthWeight) / MAX_WEIGHT_UINT256;\n\n        feesGrowthInsideLastX128.accPerShare0 += FullMath.mulDiv(\n            fee0WPF,\n            FixedPoint128.Q128,\n            _totalSupply\n        );\n\n        feesGrowthInsideLastX128.accPerShare1 += FullMath.mulDiv(\n            fee1WPF,\n            FixedPoint128.Q128,\n            _totalSupply\n        );\n\n        _pay(token0, address(this), owner(), fee0 - fee0WPF);\n        _pay(token1, address(this), owner(), fee1 - fee1WPF);\n    }\n\n    function _deposit(\n        uint256 amount0Desired,\n        uint256 amount1Desired,\n        uint256 _totalSupply,\n        Slot0Data[] memory slots\n    ) private {\n        uint128 liquidity;\n        uint256 fee0;\n        uint256 fee1;\n        uint256 posNum = multiPosition.length;\n        PositionInfo memory position;\n        for (uint256 i = 0; i < posNum; ) {\n            position = multiPosition[i];\n\n            liquidity = _calcLiquidityAmountToDeposit(\n                slots[i].currentSqrtRatioX96,\n                position,\n                amount0Desired,\n                amount1Desired\n            );\n            if (liquidity > 0) {\n                (, , , uint128 tokensOwed0Before, uint128 tokensOwed1Before) = IUniswapV3Pool(\n                    position.poolAddress\n                ).positions(position.positionKey);\n\n                IUniswapV3Pool(position.poolAddress).mint(\n                    address(this), //recipient\n                    position.lowerTick,\n                    position.upperTick,\n                    liquidity,\n                    abi.encode(position.poolFeeAmt)\n                );\n\n                (, , , uint128 tokensOwed0After, uint128 tokensOwed1After) = IUniswapV3Pool(\n                    position.poolAddress\n                ).positions(position.positionKey);\n\n                fee0 += tokensOwed0After - tokensOwed0Before;\n                fee1 += tokensOwed1After - tokensOwed1Before;\n\n                IUniswapV3Pool(position.poolAddress).collect(\n                    address(this),\n                    position.lowerTick,\n                    position.upperTick,\n                    type(uint128).max,\n                    type(uint128).max\n                );\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (_totalSupply > 0) {\n            _upFeesGrowth(fee0, fee1, _totalSupply);\n        }\n    }\n\n    /**\n     * @notice Deposit function for adding liquidity to the pool\n     * @dev This function allows a user to deposit `amount0Desired` and `amount1Desired` amounts of token0 and token1\n     *      respectively into the liquidity pool and receive `lpAmount` amount of corresponding liquidity pool tokens in return.\n     *      It first checks if the pool has been initialized, meaning there's already liquidity added in it. If not,\n     *      then it requires that the first deposit be made by the owner address. If initialized, the optimal amount of token\n     *      to be deposited is calculated based on existing reserves and minimums specified. Then, the amount of LP tokens\n     *      to be minted is calculated, and the tokens are transferred accordingly from the caller to the contract. Finally,\n     *      the deposit function is called internally, which uses Uniswap V3's mint function to add the liquidity to the pool.\n     * @param amount0Desired The amount of token0 desired to deposit.\n     * @param amount1Desired The amount of token1 desired to deposit.\n     * @param amount0Min The minimum amount of token0 required to be deposited.\n     * @param amount1Min The minimum amount of token1 required to be deposited.\n     * @return lpAmount Returns the amount of liquidity tokens created.\n     */\n    function deposit(\n        // TODO:  PAUSED + Max CAPS\n        uint256 amount0Desired,\n        uint256 amount1Desired,\n        uint256 amount0Min,\n        uint256 amount1Min\n    ) external returns (uint256 lpAmount) {\n        ErrLib.requirement(\n            amount0Desired > MINIMUM_AMOUNT && amount1Desired > MINIMUM_AMOUNT,\n            ErrLib.ErrorCode.AMOUNT_TOO_SMALL\n        );\n        uint256 _totalSupply = totalSupply();\n        Slot0Data[] memory slots;\n\n        if (_totalSupply == 0) {\n            ErrLib.requirement(\n                msg.sender == owner(),\n                ErrLib.ErrorCode.FIRST_DEPOSIT_SHOULD_BE_MAKE_BY_OWNER\n            );\n            // fetched from Uniswap codebase\n            lpAmount = Babylonian.sqrt(amount0Desired * amount1Desired) - MINIMUM_LIQUIDITY;\n            _mint(burnAddress, MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n            slots = _initializeStrategy();\n        } else {\n            slots = getSlots();\n            (uint256 reserve0, uint256 reserve1, , ) = _getReserves(slots);\n            (amount0Desired, amount1Desired) = _optimizeAmounts(\n                amount0Desired,\n                amount1Desired,\n                amount0Min,\n                amount1Min,\n                reserve0,\n                reserve1\n            );\n            // MINIMUM\n            uint256 l0 = (amount0Desired * _totalSupply) / reserve0;\n            uint256 l1 = (amount1Desired * _totalSupply) / reserve1;\n            lpAmount = l0 < l1 ? l0 : l1;\n        }\n\n        ErrLib.requirement(lpAmount > 0, ErrLib.ErrorCode.INSUFFICIENT_LIQUIDITY_MINTED);\n        ErrLib.requirement(\n            maxTotalSupply >= _totalSupply + lpAmount,\n            ErrLib.ErrorCode.MAX_TOTAL_SUPPLY_REACHED\n        );\n        _pay(token0, msg.sender, address(this), amount0Desired);\n        _pay(token1, msg.sender, address(this), amount1Desired);\n\n        _deposit(amount0Desired, amount1Desired, _totalSupply, slots);\n\n        _mint(msg.sender, lpAmount);\n\n        emit Deposit(msg.sender, amount0Desired, amount1Desired, lpAmount);\n    }\n\n    function _withdraw(\n        uint256 lpAmount,\n        uint256 _totalSupply\n    ) private returns (uint256 withdrawnAmount0, uint256 withdrawnAmount1) {\n        assert(_totalSupply > 0);\n        PositionInfo memory position;\n        uint256 posNum = multiPosition.length;\n        uint256 fee0;\n        uint256 fee1;\n        for (uint256 i = 0; i < posNum; ) {\n            position = multiPosition[i];\n\n            {\n                (uint128 liquidity, , , , ) = IUniswapV3Pool(position.poolAddress).positions(\n                    position.positionKey\n                );\n\n                uint128 liquidityToWithdraw = uint128(\n                    (uint256(liquidity) * lpAmount) / _totalSupply\n                );\n\n                (, , , uint128 tokensOwed0Before, uint128 tokensOwed1Before) = IUniswapV3Pool(\n                    position.poolAddress\n                ).positions(position.positionKey);\n\n                (uint256 amount0, uint256 amount1) = IUniswapV3Pool(position.poolAddress).burn(\n                    position.lowerTick,\n                    position.upperTick,\n                    liquidityToWithdraw\n                );\n\n                withdrawnAmount0 += amount0;\n                withdrawnAmount1 += amount1;\n\n                (, , , uint128 tokensOwed0After, uint128 tokensOwed1After) = IUniswapV3Pool(\n                    position.poolAddress\n                ).positions(position.positionKey);\n\n                fee0 += (tokensOwed0After - amount0) - tokensOwed0Before;\n                fee1 += (tokensOwed1After - amount1) - tokensOwed1Before;\n            }\n\n            IUniswapV3Pool(position.poolAddress).collect(\n                address(this),\n                position.lowerTick,\n                position.upperTick,\n                type(uint128).max,\n                type(uint128).max\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        _upFeesGrowth(fee0, fee1, _totalSupply);\n    }\n\n    /**\n     * @notice Allows the caller to withdraw their liquidity from the pool and receive the underlying tokens.\n     * @param lpAmount The amount of liquidity pool tokens to withdraw.\n     * @param amount0OutMin The minimum amount of token0 that the caller must receive on withdrawal.\n     * @param amount1OutMin The minimum amount of token1 that the caller must receive on withdrawal.\n     * @dev This function transfers the withdrawn liquidity proportional to the caller's share of the total liquidity pool. It then collects\n     *      the accumulated fees for the position before burning and withdrawing liquidity. Finally, it transfers the withdrawn tokens\n     *      to the caller and emits the Withdraw event.\n     * @return withdrawnAmount0 The amount of token0 received by the caller after the withdrawal.\n     * @return withdrawnAmount1 The amount of token1 received by the caller after the withdrawal.\n     */\n    function withdraw(\n        uint256 lpAmount,\n        uint256 amount0OutMin,\n        uint256 amount1OutMin\n    ) external returns (uint256 withdrawnAmount0, uint256 withdrawnAmount1) {\n        uint256 _totalSupply = totalSupply();\n\n        (withdrawnAmount0, withdrawnAmount1) = _withdraw(lpAmount, _totalSupply);\n\n        if (lpAmount > 0) {\n            withdrawnAmount0 +=\n                ((IERC20(token0).balanceOf(address(this)) - withdrawnAmount0) * lpAmount) /\n                _totalSupply;\n            withdrawnAmount1 +=\n                ((IERC20(token1).balanceOf(address(this)) - withdrawnAmount1) * lpAmount) /\n                _totalSupply;\n\n            ErrLib.requirement(\n                withdrawnAmount0 >= amount0OutMin && withdrawnAmount1 >= amount1OutMin,\n                ErrLib.ErrorCode.PRICE_SLIPPAGE_CHECK\n            );\n\n            _burn(msg.sender, lpAmount);\n            _pay(token0, address(this), msg.sender, withdrawnAmount0);\n            _pay(token1, address(this), msg.sender, withdrawnAmount1);\n            emit Withdraw(msg.sender, withdrawnAmount0, withdrawnAmount1, lpAmount);\n        }\n    }\n\n    /**\n     * @dev This function returns the current sqrt price and tick from every opened position\n     */\n    function getSlots() public view returns (Slot0Data[] memory) {\n        uint256 posNum = multiPosition.length;\n        Slot0Data[] memory slots = new Slot0Data[](posNum);\n        for (uint256 i = 0; i < posNum; ) {\n            PositionInfo memory position = multiPosition[i];\n            (slots[i].currentSqrtRatioX96, slots[i].tick, , , , , ) = IUniswapV3Pool(\n                position.poolAddress\n            ).slot0();\n            unchecked {\n                ++i;\n            }\n        }\n        return slots;\n    }\n\n    /**\n     * @dev This function is called after a underlying pool is minted.\n     * It pays the underlying pool their owed amounts of token0 and token1 taking into account slippage, if any.\n     * In order to verify that the correct pool has minted, it decodes the `data` parameter to get the pool\n     * fee and uses it to check against a trusted underlying pool.\n     * @param amount0Owed The amount of token0 owed to the underlying pool\n     * @param amount1Owed The amount of token1 owed to the underlying pool\n     * @param data Additional data provided during the minting process.\n     * The function decodes a `poolFee` variable from the `data` parameter, which is used to validate\n     * if the call comes from a trusted underlying pool.\n     * The function then checks if the call is made by the trusted underlying pool,\n     * otherwise it throws an error with a custom message.\n     * Finally, the function transfers the owed amounts of token0 and token1 to the underlying pool,\n     * taking into account slippage.\n     */\n    function uniswapV3MintCallback(\n        uint256 amount0Owed,\n        uint256 amount1Owed,\n        bytes calldata data\n    ) external {\n        // a fee as unique pool key\n        uint24 poolFee = abi.decode(data, (uint24));\n        ErrLib.requirement(\n            msg.sender == underlyingTrustedPools[poolFee].poolAddress,\n            ErrLib.ErrorCode.FORBIDDEN\n        );\n\n        // the depositor(if it is not a current contract) must approve the contract, taking into account slippage.\n        _pay(token0, address(this), msg.sender, amount0Owed);\n        _pay(token1, address(this), msg.sender, amount1Owed);\n    }\n\n    function _pay(address token, address payer, address recipient, uint256 value) private {\n        if (value > 0) {\n            if (payer == address(this)) {\n                _safeTransfer(token, recipient, value);\n            } else {\n                _safeTransferFrom(token, payer, recipient, value);\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the current reserves for token0 and token1.\n     * @return reserve0 The current reserve of token0\n     * @return reserve1 The current reserve of token1\n     * @return pendingFee0 The amount of fees accrued but not yet claimed in token0\n     * @return pendingFee1 The amount of fees accrued but not yet claimed in token1\n     */\n    function getReserves()\n        external\n        view\n        returns (uint256 reserve0, uint256 reserve1, uint256 pendingFee0, uint256 pendingFee1)\n    {\n        Slot0Data[] memory slots = getSlots();\n        (reserve0, reserve1, pendingFee0, pendingFee1) = _getReserves(slots);\n    }\n\n    function _getFeeGrowthInside(\n        IUniswapV3Pool pool,\n        int24 tickCurrent,\n        int24 tickLower,\n        int24 tickUpper\n    ) private view returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) {\n        (, , uint256 lowerFeeGrowthOutside0X128, uint256 lowerFeeGrowthOutside1X128, , , , ) = pool\n            .ticks(tickLower);\n        (, , uint256 upperFeeGrowthOutside0X128, uint256 upperFeeGrowthOutside1X128, , , , ) = pool\n            .ticks(tickUpper);\n\n        if (tickCurrent < tickLower) {\n            feeGrowthInside0X128 = lowerFeeGrowthOutside0X128 - upperFeeGrowthOutside0X128;\n            feeGrowthInside1X128 = lowerFeeGrowthOutside1X128 - upperFeeGrowthOutside1X128;\n        } else if (tickCurrent < tickUpper) {\n            uint256 feeGrowthGlobal0X128 = pool.feeGrowthGlobal0X128();\n            uint256 feeGrowthGlobal1X128 = pool.feeGrowthGlobal1X128();\n            feeGrowthInside0X128 =\n                feeGrowthGlobal0X128 -\n                lowerFeeGrowthOutside0X128 -\n                upperFeeGrowthOutside0X128;\n            feeGrowthInside1X128 =\n                feeGrowthGlobal1X128 -\n                lowerFeeGrowthOutside1X128 -\n                upperFeeGrowthOutside1X128;\n        } else {\n            feeGrowthInside0X128 = upperFeeGrowthOutside0X128 - lowerFeeGrowthOutside0X128;\n            feeGrowthInside1X128 = upperFeeGrowthOutside1X128 - lowerFeeGrowthOutside1X128;\n        }\n    }\n\n    function _getReserves(\n        Slot0Data[] memory slots\n    )\n        private\n        view\n        returns (uint256 reserve0, uint256 reserve1, uint256 pendingFee0, uint256 pendingFee1)\n    {\n        reserve0 = IERC20(token0).balanceOf(address(this));\n        reserve1 = IERC20(token1).balanceOf(address(this));\n\n        uint256 posNum = multiPosition.length;\n        for (uint256 i = 0; i < posNum; ) {\n            PositionInfo memory position = multiPosition[i];\n            uint128 liquidity;\n            uint256 feeGrowthInside0LastX128;\n            uint256 feeGrowthInside1LastX128;\n            {\n                uint128 tokensOwed0;\n                uint128 tokensOwed1;\n                (\n                    liquidity,\n                    feeGrowthInside0LastX128,\n                    feeGrowthInside1LastX128,\n                    tokensOwed0,\n                    tokensOwed1\n                ) = IUniswapV3Pool(position.poolAddress).positions(position.positionKey);\n                reserve0 += tokensOwed0;\n                reserve1 += tokensOwed1;\n            }\n            if (liquidity > 0) {\n                (\n                    uint256 feeGrowthInside0X128Pending,\n                    uint256 feeGrowthInside1X128Pending\n                ) = _getFeeGrowthInside(\n                        IUniswapV3Pool(position.poolAddress),\n                        slots[i].tick,\n                        position.lowerTick,\n                        position.upperTick\n                    );\n                pendingFee0 += uint128(\n                    FullMath.mulDiv(\n                        feeGrowthInside0X128Pending - feeGrowthInside0LastX128,\n                        liquidity,\n                        FixedPoint128.Q128\n                    )\n                );\n                pendingFee1 += uint128(\n                    FullMath.mulDiv(\n                        feeGrowthInside1X128Pending - feeGrowthInside1LastX128,\n                        liquidity,\n                        FixedPoint128.Q128\n                    )\n                );\n            }\n\n            (uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity(\n                slots[i].currentSqrtRatioX96,\n                TickMath.getSqrtRatioAtTick(position.lowerTick),\n                TickMath.getSqrtRatioAtTick(position.upperTick),\n                liquidity\n            );\n            reserve0 += amount0;\n            reserve1 += amount1;\n\n            unchecked {\n                ++i;\n            }\n        }\n        // take away protocol fee\n        uint256 feeGrowthWeight = MAX_WEIGHT_UINT256 - protocolFeeWeight;\n        pendingFee0 = (pendingFee0 * feeGrowthWeight) / MAX_WEIGHT_UINT256;\n        pendingFee1 = (pendingFee1 * feeGrowthWeight) / MAX_WEIGHT_UINT256;\n\n        reserve0 += pendingFee0;\n        reserve1 += pendingFee1;\n    }\n\n    function _quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) private pure returns (uint256 amountB) {\n        ErrLib.requirement(amountA > 0, ErrLib.ErrorCode.INSUFFICIENT_AMOUNT);\n        ErrLib.requirement(reserveA > 0 && reserveB > 0, ErrLib.ErrorCode.INSUFFICIENT_LIQUIDITY);\n        amountB = (amountA * reserveB) / reserveA;\n    }\n\n    function _optimizeAmounts(\n        uint256 amount0Desired,\n        uint256 amount1Desired,\n        uint256 amount0Min,\n        uint256 amount1Min,\n        uint256 reserve0,\n        uint256 reserve1\n    ) private pure returns (uint256 amount0, uint256 amount1) {\n        if (reserve0 == 0 && reserve1 == 0) {\n            (amount0, amount1) = (amount0Desired, amount1Desired);\n        } else {\n            uint256 amount1Optimal = _quote(amount0Desired, reserve0, reserve1);\n            if (amount1Optimal <= amount1Desired) {\n                ErrLib.requirement(\n                    amount1Optimal >= amount1Min,\n                    ErrLib.ErrorCode.INSUFFICIENT_1_AMOUNT\n                );\n                (amount0, amount1) = (amount0Desired, amount1Optimal);\n            } else {\n                uint256 amount0Optimal = _quote(amount1Desired, reserve1, reserve0);\n                assert(amount0Optimal <= amount0Desired);\n                ErrLib.requirement(\n                    amount0Optimal >= amount0Min,\n                    ErrLib.ErrorCode.INSUFFICIENT_0_AMOUNT\n                );\n                (amount0, amount1) = (amount0Optimal, amount1Desired);\n            }\n        }\n    }\n\n    /**\n     * @notice Calculates the estimated amount of token that will be received as output with the specified input amount and current price.\n     * @param zeroForOne A boolean to specify if token0(true) or token1(false) is the input currency.\n     * @param amountIn The input amount of the token to swap.\n     * @return swappedOut The estimated output amount of tokens that will be received based on the current price.\n     */\n    function getAmountOut(\n        bool zeroForOne,\n        uint256 amountIn\n    ) public view returns (uint256 swappedOut) {\n        uint32[] memory secondsAgo = new uint32[](2);\n        secondsAgo[0] = twapDuration;\n        secondsAgo[1] = 0;\n        (int56[] memory tickCumulatives, ) = IUniswapV3Pool(underlyingTrustedPools[500].poolAddress)\n            .observe(secondsAgo);\n        int24 avarageTick = int24((tickCumulatives[1] - tickCumulatives[0]) / int32(twapDuration));\n        uint160 sqrtPriceX96 = TickMath.getSqrtRatioAtTick(avarageTick);\n        if (sqrtPriceX96 <= type(uint128).max) {\n            uint256 ratioX192 = uint256(sqrtPriceX96) * sqrtPriceX96;\n            swappedOut = zeroForOne\n                ? FullMath.mulDiv(ratioX192, amountIn, 1 << 192)\n                : FullMath.mulDiv(1 << 192, amountIn, ratioX192);\n        } else {\n            uint256 ratioX128 = FullMath.mulDiv(sqrtPriceX96, sqrtPriceX96, 1 << 64);\n            swappedOut = zeroForOne\n                ? FullMath.mulDiv(ratioX128, amountIn, 1 << 128)\n                : FullMath.mulDiv(1 << 128, amountIn, ra"
    }
  ]
}