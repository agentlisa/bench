{
  "Title": "[H-05] `USDMPegRecovery` Risk of fund locked, due to discrepancy between curveLP token value against internal contract math",
  "Content": "_Submitted by Alex the Entreprenerd, also found by gzeon, IllIllI, and leastwood_\n\n[USDMPegRecovery.sol#L90](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L90)<br>\n[USDMPegRecovery.sol#L110](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L110)<br>\n[USDMPegRecovery.sol#L73](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L73)<br>\n[USDMPegRecovery.sol#L84](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L84)<br>\n\nIn `USDMPegRecovery` `deposit` and `withdraw` allow for direct deposits of a specific token (3crv or usdm).\n\nThe balances are directly changed and tracked in storage.\n\n`provide` seems to be using the real balances (not the ones store) to provide liquidity.<br>\nBecause of how curve works, you'll be able (first deposit) to provide exactly matching liquidity.<br>\nBut after (even just 1 or) multiple swaps, the pool will be slightly imbalanced, adding or removing liquidity at that point will drastically change the balances in the contract from the ones tracked in storage.\n\nEventually users won't be able to withdraw the exact amounts they deposited.\n\nThis will culminate with real balances not matching user deposits, sometimes to user advantage and other times to user disadvantage, ultimately to the protocol dismay.\n\n### Proof of Concept\n\nDeposit equal usdm and 3crv<br>\nLP<br>\nDo one trade on CRV<br>\nWithdraw the LP\n\nThe real balances are not matching the balances in storage.\n\nUser tries to withdraw all their balances, inevitable revert.\n\n### Recommended Mitigation Steps\n\nEither find a way to price the user contribution based on the LP tokens (use virtual_price)<br>\nOr simply have people deposit the LP token directly (avoiding the IL math which is a massive headache)\n\n**[leekt (Concur) confirmed](https://github.com/code-423n4/2022-02-concur-findings/issues/70)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-02-concur-findings/issues/70#issuecomment-1097330571):**\n > I'm forfeitting winnings as I am judging the contest.\n> \n> The sponsor confirmed.\n> \n> I believe the closest findings are [#191](https://github.com/code-423n4/2022-02-concur-findings/issues/191) and [#94](https://github.com/code-423n4/2022-02-concur-findings/issues/94) these both focus on the provide aspect.<br>\n> However, this finding shows how the Curve LP Math will cause the internal balances to break after just one LP provision.\n> \n> Because this breaks accounting of the protocol and will cause funds to be stuck I believe High Severity to be appropriate.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-02-concur-finance-contest",
  "Code": [
    {
      "filename": "contracts/USDMPegRecovery.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ICurveMetaPool } from \"./external/CurveInterfaces.sol\";\n\ncontract USDMPegRecovery is Ownable {\n\n    using SafeERC20 for IERC20; \n\n    IERC20 public immutable usdm;\n\n    IERC20 public immutable pool3;\n\n    ICurveMetaPool public immutable usdm3crv;\n\n    address public immutable kpiOracle;\n\n    uint256 public step;\n\n    uint256 public startLiquidity;\n\n    struct Liquidity {\n        uint128 usdm;\n        uint128 pool3;\n    }\n\n    event Deposit(address indexed depositor, Liquidity deposits);\n\n    event Withdraw(address indexed withdrawer, Liquidity withdrawals);\n\n    Liquidity public totalLiquidity;\n\n    mapping(address => Liquidity) public userLiquidity;\n\n    mapping(address => bool) public isGuardian;\n\n    bool public unlockable;\n\n    modifier onlyGuardian() {\n        require(isGuardian[msg.sender], \"!guardian\");\n        _;\n    }\n\n    constructor(\n        uint256 _startLiquidity,\n        address _kpiOracle\n    ) Ownable() {\n        startLiquidity = _startLiquidity;\n        usdm = IERC20(0x31d4Eb09a216e181eC8a43ce79226A487D6F0BA9);\n        pool3 = IERC20(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);\n        usdm3crv = ICurveMetaPool(0x5B3b5DF2BF2B6543f78e053bD91C4Bdd820929f1);\n        step = 250000e18;\n        kpiOracle = _kpiOracle;\n    }\n\n    function addGuardian(address _guardian) external onlyOwner {\n        isGuardian[_guardian] = true;\n    }\n\n    function removeGuardian(address _guardian) external onlyOwner {\n        isGuardian[_guardian] = false;\n    }\n\n    function enableUnlock() external {\n        require(msg.sender == kpiOracle, \"!oracle\");\n        unlockable = true;\n    }\n\n    function provide(uint256 _minimumLP) external onlyGuardian {\n        require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, \"<liquidity\");\n        // truncate amounts under step\n        uint256 addingLiquidity = (usdm.balanceOf(address(this)) / step) * step;\n        // match usdm : pool3 = 1 : 1\n        uint256[2] memory amounts = [addingLiquidity, addingLiquidity];\n        usdm.approve(address(usdm3crv), addingLiquidity);\n        pool3.approve(address(usdm3crv), addingLiquidity);\n        usdm3crv.add_liquidity(amounts, _minimumLP);\n    }\n\n    function removeLiquidity(uint256 _steps, uint256 _burningLPs) external onlyGuardian {\n        uint256 removingLiquidity = _steps * step;\n        uint256[2] memory amounts = [removingLiquidity, removingLiquidity];\n        usdm3crv.remove_liquidity(_burningLPs, amounts);\n    }\n\n    function deposit(Liquidity calldata _deposits) external {\n        Liquidity memory total = totalLiquidity;\n        Liquidity memory user = userLiquidity[msg.sender];\n        if(_deposits.usdm > 0) {\n            usdm.safeTransferFrom(msg.sender, address(this), uint256(_deposits.usdm));\n            total.usdm += _deposits.usdm;\n            user.usdm += _deposits.usdm;\n        }\n\n        if(_deposits.pool3 > 0) {\n            require(totalLiquidity.usdm > 4000000e18, \"usdm low\");\n            pool3.safeTransferFrom(msg.sender, address(this), uint256(_deposits.pool3));\n            total.pool3 += _deposits.pool3;\n            user.pool3 += _deposits.pool3;\n        }\n        totalLiquidity = total;\n        userLiquidity[msg.sender] = user;\n        emit Deposit(msg.sender, _deposits);\n    }\n\n    function withdraw(Liquidity calldata _withdrawal) external {\n        Liquidity memory total = totalLiquidity;\n        Liquidity memory user = userLiquidity[msg.sender];\n        if(_withdrawal.usdm > 0) {\n            require(unlockable, \"!unlock usdm\");\n            usdm.safeTransfer(msg.sender, uint256(_withdrawal.usdm));\n            total.usdm -= _withdrawal.usdm;\n            user.usdm -= _withdrawal.usdm;\n        }\n\n        if(_withdrawal.pool3 > 0) {\n            pool3.safeTransfer(msg.sender, uint256(_withdrawal.pool3));\n            total.pool3 -= _withdrawal.pool3;\n            user.pool3 -= _withdrawal.pool3;\n        }\n        totalLiquidity = total;\n        userLiquidity[msg.sender] = user;\n        emit Withdraw(msg.sender, _withdrawal);\n    }\n}"
    },
    {
      "filename": "contracts/USDMPegRecovery.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ICurveMetaPool } from \"./external/CurveInterfaces.sol\";\n\ncontract USDMPegRecovery is Ownable {\n\n    using SafeERC20 for IERC20; \n\n    IERC20 public immutable usdm;\n\n    IERC20 public immutable pool3;\n\n    ICurveMetaPool public immutable usdm3crv;\n\n    address public immutable kpiOracle;\n\n    uint256 public step;\n\n    uint256 public startLiquidity;\n\n    struct Liquidity {\n        uint128 usdm;\n        uint128 pool3;\n    }\n\n    event Deposit(address indexed depositor, Liquidity deposits);\n\n    event Withdraw(address indexed withdrawer, Liquidity withdrawals);\n\n    Liquidity public totalLiquidity;\n\n    mapping(address => Liquidity) public userLiquidity;\n\n    mapping(address => bool) public isGuardian;\n\n    bool public unlockable;\n\n    modifier onlyGuardian() {\n        require(isGuardian[msg.sender], \"!guardian\");\n        _;\n    }\n\n    constructor(\n        uint256 _startLiquidity,\n        address _kpiOracle\n    ) Ownable() {\n        startLiquidity = _startLiquidity;\n        usdm = IERC20(0x31d4Eb09a216e181eC8a43ce79226A487D6F0BA9);\n        pool3 = IERC20(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);\n        usdm3crv = ICurveMetaPool(0x5B3b5DF2BF2B6543f78e053bD91C4Bdd820929f1);\n        step = 250000e18;\n        kpiOracle = _kpiOracle;\n    }\n\n    function addGuardian(address _guardian) external onlyOwner {\n        isGuardian[_guardian] = true;\n    }\n\n    function removeGuardian(address _guardian) external onlyOwner {\n        isGuardian[_guardian] = false;\n    }\n\n    function enableUnlock() external {\n        require(msg.sender == kpiOracle, \"!oracle\");\n        unlockable = true;\n    }\n\n    function provide(uint256 _minimumLP) external onlyGuardian {\n        require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, \"<liquidity\");\n        // truncate amounts under step\n        uint256 addingLiquidity = (usdm.balanceOf(address(this)) / step) * step;\n        // match usdm : pool3 = 1 : 1\n        uint256[2] memory amounts = [addingLiquidity, addingLiquidity];\n        usdm.approve(address(usdm3crv), addingLiquidity);\n        pool3.approve(address(usdm3crv), addingLiquidity);\n        usdm3crv.add_liquidity(amounts, _minimumLP);\n    }\n\n    function removeLiquidity(uint256 _steps, uint256 _burningLPs) external onlyGuardian {\n        uint256 removingLiquidity = _steps * step;\n        uint256[2] memory amounts = [removingLiquidity, removingLiquidity];\n        usdm3crv.remove_liquidity(_burningLPs, amounts);\n    }\n\n    function deposit(Liquidity calldata _deposits) external {\n        Liquidity memory total = totalLiquidity;\n        Liquidity memory user = userLiquidity[msg.sender];\n        if(_deposits.usdm > 0) {\n            usdm.safeTransferFrom(msg.sender, address(this), uint256(_deposits.usdm));\n            total.usdm += _deposits.usdm;\n            user.usdm += _deposits.usdm;\n        }\n\n        if(_deposits.pool3 > 0) {\n            require(totalLiquidity.usdm > 4000000e18, \"usdm low\");\n            pool3.safeTransferFrom(msg.sender, address(this), uint256(_deposits.pool3));\n            total.pool3 += _deposits.pool3;\n            user.pool3 += _deposits.pool3;\n        }\n        totalLiquidity = total;\n        userLiquidity[msg.sender] = user;\n        emit Deposit(msg.sender, _deposits);\n    }\n\n    function withdraw(Liquidity calldata _withdrawal) external {\n        Liquidity memory total = totalLiquidity;\n        Liquidity memory user = userLiquidity[msg.sender];\n        if(_withdrawal.usdm > 0) {\n            require(unlockable, \"!unlock usdm\");\n            usdm.safeTransfer(msg.sender, uint256(_withdrawal.usdm));\n            total.usdm -= _withdrawal.usdm;\n            user.usdm -= _withdrawal.usdm;\n        }\n\n        if(_withdrawal.pool3 > 0) {\n            pool3.safeTransfer(msg.sender, uint256(_withdrawal.pool3));\n            total.pool3 -= _withdrawal.pool3;\n            user.pool3 -= _withdrawal.pool3;\n        }\n        totalLiquidity = total;\n        userLiquidity[msg.sender] = user;\n        emit Withdraw(msg.sender, _withdrawal);\n    }\n}"
    },
    {
      "filename": "contracts/USDMPegRecovery.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ICurveMetaPool } from \"./external/CurveInterfaces.sol\";\n\ncontract USDMPegRecovery is Ownable {\n\n    using SafeERC20 for IERC20; \n\n    IERC20 public immutable usdm;\n\n    IERC20 public immutable pool3;\n\n    ICurveMetaPool public immutable usdm3crv;\n\n    address public immutable kpiOracle;\n\n    uint256 public step;\n\n    uint256 public startLiquidity;\n\n    struct Liquidity {\n        uint128 usdm;\n        uint128 pool3;\n    }\n\n    event Deposit(address indexed depositor, Liquidity deposits);\n\n    event Withdraw(address indexed withdrawer, Liquidity withdrawals);\n\n    Liquidity public totalLiquidity;\n\n    mapping(address => Liquidity) public userLiquidity;\n\n    mapping(address => bool) public isGuardian;\n\n    bool public unlockable;\n\n    modifier onlyGuardian() {\n        require(isGuardian[msg.sender], \"!guardian\");\n        _;\n    }\n\n    constructor(\n        uint256 _startLiquidity,\n        address _kpiOracle\n    ) Ownable() {\n        startLiquidity = _startLiquidity;\n        usdm = IERC20(0x31d4Eb09a216e181eC8a43ce79226A487D6F0BA9);\n        pool3 = IERC20(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);\n        usdm3crv = ICurveMetaPool(0x5B3b5DF2BF2B6543f78e053bD91C4Bdd820929f1);\n        step = 250000e18;\n        kpiOracle = _kpiOracle;\n    }\n\n    function addGuardian(address _guardian) external onlyOwner {\n        isGuardian[_guardian] = true;\n    }\n\n    function removeGuardian(address _guardian) external onlyOwner {\n        isGuardian[_guardian] = false;\n    }\n\n    function enableUnlock() external {\n        require(msg.sender == kpiOracle, \"!oracle\");\n        unlockable = true;\n    }\n\n    function provide(uint256 _minimumLP) external onlyGuardian {\n        require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, \"<liquidity\");\n        // truncate amounts under step\n        uint256 addingLiquidity = (usdm.balanceOf(address(this)) / step) * step;\n        // match usdm : pool3 = 1 : 1\n        uint256[2] memory amounts = [addingLiquidity, addingLiquidity];\n        usdm.approve(address(usdm3crv), addingLiquidity);\n        pool3.approve(address(usdm3crv), addingLiquidity);\n        usdm3crv.add_liquidity(amounts, _minimumLP);\n    }\n\n    function removeLiquidity(uint256 _steps, uint256 _burningLPs) external onlyGuardian {\n        uint256 removingLiquidity = _steps * step;\n        uint256[2] memory amounts = [removingLiquidity, removingLiquidity];\n        usdm3crv.remove_liquidity(_burningLPs, amounts);\n    }\n\n    function deposit(Liquidity calldata _deposits) external {\n        Liquidity memory total = totalLiquidity;\n        Liquidity memory user = userLiquidity[msg.sender];\n        if(_deposits.usdm > 0) {\n            usdm.safeTransferFrom(msg.sender, address(this), uint256(_deposits.usdm));\n            total.usdm += _deposits.usdm;\n            user.usdm += _deposits.usdm;\n        }\n\n        if(_deposits.pool3 > 0) {\n            require(totalLiquidity.usdm > 4000000e18, \"usdm low\");\n            pool3.safeTransferFrom(msg.sender, address(this), uint256(_deposits.pool3));\n            total.pool3 += _deposits.pool3;\n            user.pool3 += _deposits.pool3;\n        }\n        totalLiquidity = total;\n        userLiquidity[msg.sender] = user;\n        emit Deposit(msg.sender, _deposits);\n    }\n\n    function withdraw(Liquidity calldata _withdrawal) external {\n        Liquidity memory total = totalLiquidity;\n        Liquidity memory user = userLiquidity[msg.sender];\n        if(_withdrawal.usdm > 0) {\n            require(unlockable, \"!unlock usdm\");\n            usdm.safeTransfer(msg.sender, uint256(_withdrawal.usdm));\n            total.usdm -= _withdrawal.usdm;\n            user.usdm -= _withdrawal.usdm;\n        }\n\n        if(_withdrawal.pool3 > 0) {\n            pool3.safeTransfer(msg.sender, uint256(_withdrawal.pool3));\n            total.pool3 -= _withdrawal.pool3;\n            user.pool3 -= _withdrawal.pool3;\n        }\n        totalLiquidity = total;\n        userLiquidity[msg.sender] = user;\n        emit Withdraw(msg.sender, _withdrawal);\n    }\n}"
    },
    {
      "filename": "contracts/USDMPegRecovery.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ICurveMetaPool } from \"./external/CurveInterfaces.sol\";\n\ncontract USDMPegRecovery is Ownable {\n\n    using SafeERC20 for IERC20; \n\n    IERC20 public immutable usdm;\n\n    IERC20 public immutable pool3;\n\n    ICurveMetaPool public immutable usdm3crv;\n\n    address public immutable kpiOracle;\n\n    uint256 public step;\n\n    uint256 public startLiquidity;\n\n    struct Liquidity {\n        uint128 usdm;\n        uint128 pool3;\n    }\n\n    event Deposit(address indexed depositor, Liquidity deposits);\n\n    event Withdraw(address indexed withdrawer, Liquidity withdrawals);\n\n    Liquidity public totalLiquidity;\n\n    mapping(address => Liquidity) public userLiquidity;\n\n    mapping(address => bool) public isGuardian;\n\n    bool public unlockable;\n\n    modifier onlyGuardian() {\n        require(isGuardian[msg.sender], \"!guardian\");\n        _;\n    }\n\n    constructor(\n        uint256 _startLiquidity,\n        address _kpiOracle\n    ) Ownable() {\n        startLiquidity = _startLiquidity;\n        usdm = IERC20(0x31d4Eb09a216e181eC8a43ce79226A487D6F0BA9);\n        pool3 = IERC20(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);\n        usdm3crv = ICurveMetaPool(0x5B3b5DF2BF2B6543f78e053bD91C4Bdd820929f1);\n        step = 250000e18;\n        kpiOracle = _kpiOracle;\n    }\n\n    function addGuardian(address _guardian) external onlyOwner {\n        isGuardian[_guardian] = true;\n    }\n\n    function removeGuardian(address _guardian) external onlyOwner {\n        isGuardian[_guardian] = false;\n    }\n\n    function enableUnlock() external {\n        require(msg.sender == kpiOracle, \"!oracle\");\n        unlockable = true;\n    }\n\n    function provide(uint256 _minimumLP) external onlyGuardian {\n        require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, \"<liquidity\");\n        // truncate amounts under step\n        uint256 addingLiquidity = (usdm.balanceOf(address(this)) / step) * step;\n        // match usdm : pool3 = 1 : 1\n        uint256[2] memory amounts = [addingLiquidity, addingLiquidity];\n        usdm.approve(address(usdm3crv), addingLiquidity);\n        pool3.approve(address(usdm3crv), addingLiquidity);\n        usdm3crv.add_liquidity(amounts, _minimumLP);\n    }\n\n    function removeLiquidity(uint256 _steps, uint256 _burningLPs) external onlyGuardian {\n        uint256 removingLiquidity = _steps * step;\n        uint256[2] memory amounts = [removingLiquidity, removingLiquidity];\n        usdm3crv.remove_liquidity(_burningLPs, amounts);\n    }\n\n    function deposit(Liquidity calldata _deposits) external {\n        Liquidity memory total = totalLiquidity;\n        Liquidity memory user = userLiquidity[msg.sender];\n        if(_deposits.usdm > 0) {\n            usdm.safeTransferFrom(msg.sender, address(this), uint256(_deposits.usdm));\n            total.usdm += _deposits.usdm;\n            user.usdm += _deposits.usdm;\n        }\n\n        if(_deposits.pool3 > 0) {\n            require(totalLiquidity.usdm > 4000000e18, \"usdm low\");\n            pool3.safeTransferFrom(msg.sender, address(this), uint256(_deposits.pool3));\n            total.pool3 += _deposits.pool3;\n            user.pool3 += _deposits.pool3;\n        }\n        totalLiquidity = total;\n        userLiquidity[msg.sender] = user;\n        emit Deposit(msg.sender, _deposits);\n    }\n\n    function withdraw(Liquidity calldata _withdrawal) external {\n        Liquidity memory total = totalLiquidity;\n        Liquidity memory user = userLiquidity[msg.sender];\n        if(_withdrawal.usdm > 0) {\n            require(unlockable, \"!unlock usdm\");\n            usdm.safeTransfer(msg.sender, uint256(_withdrawal.usdm));\n            total.usdm -= _withdrawal.usdm;\n            user.usdm -= _withdrawal.usdm;\n        }\n\n        if(_withdrawal.pool3 > 0) {\n            pool3.safeTransfer(msg.sender, uint256(_withdrawal.pool3));\n            total.pool3 -= _withdrawal.pool3;\n            user.pool3 -= _withdrawal.pool3;\n        }\n        totalLiquidity = total;\n        userLiquidity[msg.sender] = user;\n        emit Withdraw(msg.sender, _withdrawal);\n    }\n}"
    }
  ]
}