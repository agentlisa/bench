{
  "Title": "[M-10] `OperatorProposal.sol`: Leftover ETH is not refunded to the `msg.sender`",
  "Content": "\nThe [`OperatorProposal`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/OperatorProposal.sol#L7-L63) contract is a type of proposal that allows to execute operations on contracts that implement the [`IOperator`](https://github.com/code-423n4/2023-04-party/blob/main/contracts/operators/IOperator.sol) interface.\n\nUpon execution of the proposal it might be necessary that the `executor` provides ETH.\n\nThis is true especially when `allowOperatorsToSpendPartyEth=false`, i.e. when ETH cannot be spent from the Party's balance. So it must be provided by the `executor`.\n\nThe amount of ETH that is needed to execute the operation is sent to the operator contract:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/OperatorProposal.sol#L45)\n\n```solidity\ndata.operator.execute{ value: data.operatorValue }(data.operatorData, executionData);\n```\n\nThe operator contract then spends whatever amount of ETH is actually necessary and returns the remaining ETH.\n\nFor example the [`CollectionBatchBuyOperator`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/operators/CollectionBatchBuyOperator.sol#L14-L224) contract may not spend all of the ETH because the actual purchases that are made are not necessarily known at the time the proposal is created. Also not all purchases may succeed.\n\nSo it is clear that some of the ETH may be returned from the `operator` to the `OperatorProposal` contract.\n\nThe issue is that the remaining ETH is not refunded to the `executor` and therefore this results in a direct loss of funds for the `executor`.\n\nI discussed this issue with the sponsor and it is clear that the remaining ETH needs to be refunded when `allowOperatorsToSpendPartyEth=false`.\n\nHowever it is not clear what to do when `allowOperatorsToSpendPartyEth=true`. In this case ETH can be spent from the party's balance. So there should be limited use cases for the `executor` providing additional ETH.\n\nBut if the `executor` provides additional ETH what should happen?\n\nShould the ETH be taken from the `executor` first? Or should it be taken from the Party balance first?\n\nThe sponsor mentioned that since there are limited use cases for the `executor` providing additional ETH it may be ok to not refund ETH at all.\n\nI disagree with this. Even when `allowOperatorsToSpendPartyEth=true` there should be a policy for refunds. I.e. the necessary ETH should either be taken from the Party's balance or from the `executor` first and any remaining funds from the `executor` should be returned.\n\nHowever since it is not clear how to proceed in this case and since it is less important compared to the case where `allowOperatorsToSpendPartyEth=false` I will only make a suggestion for the case where `allowOperatorsToSpendPartyEth=false`.\n\nThe sponsor should decide what to do in the other case and make the appropriate changes.\n\n### Proof of Concept\n\nWhen the `executor` executes an `OperatorProposal`, `operatorValue` amount of ETH is sent to the `operator` contract (when `allowOperatorsToSpendPartyEth=false` all of these funds must come from the `msg.value`):\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/OperatorProposal.sol#L40-L45)\n\n```solidity\nif (!allowOperatorsToSpendPartyEth && data.operatorValue > msg.value) {\n    revert NotEnoughEthError(data.operatorValue, msg.value);\n}\n\n\n// Execute the operation.\ndata.operator.execute{ value: data.operatorValue }(data.operatorData, executionData);\n```\n\nCurrently the only `operator` contract that is implemented is the `CollectionBatchBuyOperator` and as explained above not all of the funds may be used so the funds are sent back to the Party:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/operators/CollectionBatchBuyOperator.sol#L191-L192)\n\n```solidity\nuint256 unusedEth = msg.value - totalEthUsed;\nif (unusedEth > 0) payable(msg.sender).transferEth(unusedEth);\n```\n\nHowever after calling the `operator` contract, the `OperatorProposal` contract just returns without sending back the unused funds to the `executor` (`msg.sender`).\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/OperatorProposal.sol#L47-L48)\n\n```solidity\n// Nothing left to do.\nreturn \"\";\n```\n\nSo there is a loss of funds for the `executor`. The leftover funds are effectively transferred to the Party.\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nAs mentioned before, this is only a fix for the case when `allowOperatorsToSpendPartyEth=false`.\n\nFix:\n\n```diff\ndiff --git a/contracts/proposals/OperatorProposal.sol b/contracts/proposals/OperatorProposal.sol\nindex 23e2897..507e0d5 100644\n--- a/contracts/proposals/OperatorProposal.sol\n+++ b/contracts/proposals/OperatorProposal.sol\n@@ -4,7 +4,11 @@ pragma solidity 0.8.17;\n import \"./IProposalExecutionEngine.sol\";\n import \"../operators/IOperator.sol\";\n \n+import \"../utils/LibAddress.sol\";\n+\n contract OperatorProposal {\n+    using LibAddress for address payable;\n+    \n     struct OperatorProposalData {\n         // Addresses that are allowed to execute the proposal and decide what\n         // calldata used by the operator proposal at the time of execution.\n@@ -41,9 +45,17 @@ contract OperatorProposal {\n             revert NotEnoughEthError(data.operatorValue, msg.value);\n         }\n \n+        uint256 partyBalanceBefore = address(this).balance - msg.value;\n+\n         // Execute the operation.\n         data.operator.execute{ value: data.operatorValue }(data.operatorData, executionData);\n \n+        if (!allowOperatorsToSpendPartyEth) {\n+            if (address(this).balance - partyBalanceBefore > 0) {\n+                payable(msg.sender).transferEth(address(this).balance - partyBalanceBefore);\n+            }\n+        }\n+\n         // Nothing left to do.\n         return \"\";\n     }\n```\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-04-party-findings/issues/5#issuecomment-1509854381):**\n > Looking forward to sponsor comment on this. As described in my comment on [`#30`](https://github.com/code-423n4/2023-04-party-findings/issues/30#issuecomment-1509847694), I am not entirely sure that this qualifies as Medium based on the fact that the caller presumably is able to call with the correct value. QA may be more appropriate.\n\n**[HollaDieWaldfee (warden) commented](https://github.com/code-423n4/2023-04-party-findings/issues/5#issuecomment-1509855041):**\n > @0xean - It is not true that the caller can just use the function with the correct value:\n> \n> > \"For example the [CollectionBatchBuyOperator](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/operators/CollectionBatchBuyOperator.sol#L14-L224) contract may not spend all of the ETH because the actual purchases that are made are not necessarily known at the time the proposal is created. Also not all purchases may succeed.\"\n\n**[0xble (Party) confirmed and commented](https://github.com/code-423n4/2023-04-party-findings/issues/5#issuecomment-1511998345):**\n > @HollaDieWaldfee is right, there is at least one case with the `CollectionBatchBuyOperator` where it may not use all the ETH and the user may expect to be refunded. I think marking as Medium is valid.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-04-party",
  "Code": [
    {
      "filename": "contracts/proposals/OperatorProposal.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./IProposalExecutionEngine.sol\";\nimport \"../operators/IOperator.sol\";\n\ncontract OperatorProposal {\n    struct OperatorProposalData {\n        // Addresses that are allowed to execute the proposal and decide what\n        // calldata used by the operator proposal at the time of execution.\n        address[] allowedExecutors;\n        // The operator contract that will be used to execute the proposal.\n        IOperator operator;\n        // Amount of ETH to send to the operator contract for executing the proposal.\n        uint96 operatorValue;\n        // The calldata that will be used by the operator contract to execute the proposal.\n        bytes operatorData;\n    }\n\n    event OperationExecuted(address executor);\n\n    error NotAllowedToExecute(address executor, address[] allowedExecutors);\n    error NotEnoughEthError(uint256 operatorValue, uint256 ethAvailable);\n\n    function _executeOperation(\n        IProposalExecutionEngine.ExecuteProposalParams memory params,\n        bool allowOperatorsToSpendPartyEth\n    ) internal returns (bytes memory nextProgressData) {\n        // Decode the proposal data.\n        OperatorProposalData memory data = abi.decode(params.proposalData, (OperatorProposalData));\n        (uint256 allowedExecutorsIndex, bytes memory executionData) = abi.decode(\n            params.extraData,\n            (uint256, bytes)\n        );\n\n        // Check that the caller is an allowed executor.\n        _assertCallerIsAllowedToExecute(msg.sender, data.allowedExecutors, allowedExecutorsIndex);\n\n        // Check whether operator can spend party's ETH balance.\n        if (!allowOperatorsToSpendPartyEth && data.operatorValue > msg.value) {\n            revert NotEnoughEthError(data.operatorValue, msg.value);\n        }\n\n        // Execute the operation.\n        data.operator.execute{ value: data.operatorValue }(data.operatorData, executionData);\n\n        // Nothing left to do.\n        return \"\";\n    }\n\n    function _assertCallerIsAllowedToExecute(\n        address caller,\n        address[] memory allowedExecutors,\n        uint256 allowedExecutorsIndex\n    ) private pure {\n        // If there are no allowed executors, then anyone can execute.\n        if (allowedExecutors.length == 0) return;\n\n        // Check if the caller is an allowed executor.\n        if (caller != allowedExecutors[allowedExecutorsIndex])\n            revert NotAllowedToExecute(caller, allowedExecutors);\n    }\n}"
    },
    {
      "filename": "contracts/proposals/OperatorProposal.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./IProposalExecutionEngine.sol\";\nimport \"../operators/IOperator.sol\";\n\ncontract OperatorProposal {\n    struct OperatorProposalData {\n        // Addresses that are allowed to execute the proposal and decide what\n        // calldata used by the operator proposal at the time of execution.\n        address[] allowedExecutors;\n        // The operator contract that will be used to execute the proposal.\n        IOperator operator;\n        // Amount of ETH to send to the operator contract for executing the proposal.\n        uint96 operatorValue;\n        // The calldata that will be used by the operator contract to execute the proposal.\n        bytes operatorData;\n    }\n\n    event OperationExecuted(address executor);\n\n    error NotAllowedToExecute(address executor, address[] allowedExecutors);\n    error NotEnoughEthError(uint256 operatorValue, uint256 ethAvailable);\n\n    function _executeOperation(\n        IProposalExecutionEngine.ExecuteProposalParams memory params,\n        bool allowOperatorsToSpendPartyEth\n    ) internal returns (bytes memory nextProgressData) {\n        // Decode the proposal data.\n        OperatorProposalData memory data = abi.decode(params.proposalData, (OperatorProposalData));\n        (uint256 allowedExecutorsIndex, bytes memory executionData) = abi.decode(\n            params.extraData,\n            (uint256, bytes)\n        );\n\n        // Check that the caller is an allowed executor.\n        _assertCallerIsAllowedToExecute(msg.sender, data.allowedExecutors, allowedExecutorsIndex);\n\n        // Check whether operator can spend party's ETH balance.\n        if (!allowOperatorsToSpendPartyEth && data.operatorValue > msg.value) {\n            revert NotEnoughEthError(data.operatorValue, msg.value);\n        }\n\n        // Execute the operation.\n        data.operator.execute{ value: data.operatorValue }(data.operatorData, executionData);\n\n        // Nothing left to do.\n        return \"\";\n    }\n\n    function _assertCallerIsAllowedToExecute(\n        address caller,\n        address[] memory allowedExecutors,\n        uint256 allowedExecutorsIndex\n    ) private pure {\n        // If there are no allowed executors, then anyone can execute.\n        if (allowedExecutors.length == 0) return;\n\n        // Check if the caller is an allowed executor.\n        if (caller != allowedExecutors[allowedExecutorsIndex])\n            revert NotAllowedToExecute(caller, allowedExecutors);\n    }\n}"
    },
    {
      "filename": "contracts/operators/CollectionBatchBuyOperator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./IOperator.sol\";\nimport \"../party/Party.sol\";\nimport \"../tokens/IERC721.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibAddress.sol\";\nimport \"../utils/LibSafeERC721.sol\";\nimport \"openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\n/// @notice A crowdfund that purchases a specific NFT (i.e., with a known token\n///         ID) listing for a known price.\ncontract CollectionBatchBuyOperator is IOperator {\n    using LibRawResult for bytes;\n    using LibSafeERC721 for IERC721;\n    using LibAddress for address payable;\n\n    struct CollectionBatchBuyOperationData {\n        /// The contract of NFTs to buy.\n        IERC721 nftContract;\n        /// The merkle root of the token IDs that can be bought. If null,\n        /// allow any token ID in the collection can be bought.\n        bytes32 nftTokenIdsMerkleRoot;\n        // Maximum amount this crowdfund will pay for an NFT.\n        uint256 maximumPrice;\n        // Minimum number of tokens that must be purchased. If this limit is\n        // not reached, the batch buy will fail.\n        uint256 minTokensBought;\n        // Minimum amount of ETH that must be used to buy the tokens. If this\n        // amount is not reached, the batch buy will fail.\n        uint256 minTotalEthUsed;\n    }\n\n    struct TokenToBuy {\n        // The token ID of the NFT to buy.\n        uint256 tokenId;\n        // The price of the token. This cannot be greater than `maximumPrice`.\n        uint96 price;\n        // The proof needed to verify that the token ID is included in the\n        // `nftTokenIdsMerkleRoot` (if it is not null).\n        bytes32[] proof;\n    }\n\n    struct BuyCall {\n        // The contract to call to buy the NFTs in `tokensToBuy`.\n        address payable target;\n        // The calldata to call `target` with to buy the NFTs in `tokensToBuy`.\n        bytes data;\n        // The tokens to try buying with this call.\n        TokenToBuy[] tokensToBuy;\n    }\n\n    struct CollectionBatchBuyExecutionData {\n        // The calls made to buy the NFTs. Each call has a target, data, and\n        // the tokens to buy in that call.\n        BuyCall[] calls;\n        // The total number of tokens that can be bought in this batch buy. This\n        // should be equal to the sum of the each `tokensToBuy` in `calls`.\n        uint256 numOfTokens;\n    }\n\n    event CollectionBatchBuyOperationExecuted(\n        Party party,\n        IERC721 token,\n        uint256[] tokenIdsBought,\n        uint256 totalEthUsed\n    );\n\n    error NothingBoughtError();\n    error InvalidMinTokensBoughtError(uint256 minTokensBought);\n    error InvalidTokenIdError();\n    error NotEnoughTokensBoughtError(uint256 tokensBought, uint256 minTokensBought);\n    error NotEnoughEthUsedError(uint256 ethUsed, uint256 minTotalEthUsed);\n    error MaximumPriceError(uint256 callValue, uint256 maximumPrice);\n    error CallProhibitedError(address target, bytes data);\n    error NumOfTokensCannotBeLessThanMin(uint256 numOfTokens, uint256 min);\n    error EthUsedForFailedBuyError(uint256 expectedEthUsed, uint256 actualEthUsed);\n\n    function execute(bytes memory operatorData, bytes memory executionData) external payable {\n        // Decode the operator data.\n        CollectionBatchBuyOperationData memory op = abi.decode(\n            operatorData,\n            (CollectionBatchBuyOperationData)\n        );\n\n        // Decode the execution data.\n        CollectionBatchBuyExecutionData memory ex = abi.decode(\n            executionData,\n            (CollectionBatchBuyExecutionData)\n        );\n\n        if (op.minTokensBought == 0) {\n            // Must buy at least one token.\n            revert InvalidMinTokensBoughtError(0);\n        }\n\n        if (ex.numOfTokens < op.minTokensBought) {\n            // The number of tokens to buy must be greater than or equal to the\n            // minimum number of tokens to buy.\n            revert NumOfTokensCannotBeLessThanMin(ex.numOfTokens, op.minTokensBought);\n        }\n\n        // Lengths of arrays are updated at the end.\n        uint256[] memory tokenIds = new uint256[](ex.numOfTokens);\n\n        uint96 totalEthUsed;\n        uint256 tokensBought;\n        for (uint256 i; i < ex.calls.length; ++i) {\n            BuyCall memory call = ex.calls[i];\n\n            uint96 callValue;\n            for (uint256 j; j < call.tokensToBuy.length; ++j) {\n                TokenToBuy memory tokenToBuy = call.tokensToBuy[j];\n\n                if (op.nftTokenIdsMerkleRoot != bytes32(0)) {\n                    // Verify the token ID is in the merkle tree.\n                    _verifyTokenId(tokenToBuy.tokenId, op.nftTokenIdsMerkleRoot, tokenToBuy.proof);\n                }\n\n                // Check that the call value is under the maximum price.\n                uint96 price = tokenToBuy.price;\n                if (price > op.maximumPrice) {\n                    revert MaximumPriceError(price, op.maximumPrice);\n                }\n\n                // Add the price to the total value used for the call.\n                callValue += price;\n            }\n\n            uint256 balanceBefore = address(this).balance;\n            {\n                // Execute the call to buy the NFT.\n                (bool success, ) = _buy(call.target, callValue, call.data);\n\n                if (!success) continue;\n            }\n\n            {\n                uint96 ethUsed;\n                for (uint256 j; j < call.tokensToBuy.length; ++j) {\n                    uint256 tokenId = call.tokensToBuy[j].tokenId;\n                    uint96 price = call.tokensToBuy[j].price;\n\n                    // Check whether the NFT was successfully bought.\n                    if (op.nftContract.safeOwnerOf(tokenId) == address(this)) {\n                        ethUsed += price;\n                        ++tokensBought;\n\n                        // Add the token to the list of tokens to finalize.\n                        tokenIds[tokensBought - 1] = tokenId;\n                    }\n                }\n\n                // Check ETH spent for call is what was expected.\n                uint256 actualEthUsed = balanceBefore - address(this).balance;\n                if (ethUsed != actualEthUsed) {\n                    revert EthUsedForFailedBuyError(ethUsed, actualEthUsed);\n                }\n\n                totalEthUsed += ethUsed;\n            }\n        }\n\n        // This is to prevent this crowdfund from finalizing a loss if nothing\n        // was attempted to be bought (ie. `tokenIds` is empty) or all NFTs were\n        // bought for free.\n        if (totalEthUsed == 0) revert NothingBoughtError();\n\n        // Check number of tokens bought is not less than the minimum.\n        if (tokensBought < op.minTokensBought) {\n            revert NotEnoughTokensBoughtError(tokensBought, op.minTokensBought);\n        }\n\n        // Check total ETH used is not less than the minimum.\n        if (totalEthUsed < op.minTotalEthUsed) {\n            revert NotEnoughEthUsedError(totalEthUsed, op.minTotalEthUsed);\n        }\n\n        assembly {\n            // Update length of `tokenIds`\n            mstore(mload(ex), tokensBought)\n        }\n\n        // Transfer the NFTs to the party.\n        for (uint256 i; i < tokenIds.length; ++i) {\n            op.nftContract.safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n        }\n\n        // Transfer unused ETH to the party.\n        uint256 unusedEth = msg.value - totalEthUsed;\n        if (unusedEth > 0) payable(msg.sender).transferEth(unusedEth);\n\n        emit CollectionBatchBuyOperationExecuted(\n            Party(payable(msg.sender)),\n            op.nftContract,\n            tokenIds,\n            totalEthUsed\n        );\n    }\n\n    function _buy(\n        address payable callTarget,\n        uint96 callValue,\n        bytes memory callData\n    ) private returns (bool success, bytes memory revertData) {\n        // Check that call is not re-entering.\n        if (callTarget == address(this)) {\n            revert CallProhibitedError(callTarget, callData);\n        }\n        // Execute the call to buy the NFT.\n        (success, revertData) = callTarget.call{ value: callValue }(callData);\n    }\n\n    function _verifyTokenId(uint256 tokenId, bytes32 root, bytes32[] memory proof) private pure {\n        bytes32 leaf;\n        assembly {\n            mstore(0x00, tokenId)\n            leaf := keccak256(0x00, 0x20)\n        }\n\n        if (!MerkleProof.verify(proof, root, leaf)) revert InvalidTokenIdError();\n    }\n}"
    },
    {
      "filename": "contracts/proposals/OperatorProposal.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./IProposalExecutionEngine.sol\";\nimport \"../operators/IOperator.sol\";\n\ncontract OperatorProposal {\n    struct OperatorProposalData {\n        // Addresses that are allowed to execute the proposal and decide what\n        // calldata used by the operator proposal at the time of execution.\n        address[] allowedExecutors;\n        // The operator contract that will be used to execute the proposal.\n        IOperator operator;\n        // Amount of ETH to send to the operator contract for executing the proposal.\n        uint96 operatorValue;\n        // The calldata that will be used by the operator contract to execute the proposal.\n        bytes operatorData;\n    }\n\n    event OperationExecuted(address executor);\n\n    error NotAllowedToExecute(address executor, address[] allowedExecutors);\n    error NotEnoughEthError(uint256 operatorValue, uint256 ethAvailable);\n\n    function _executeOperation(\n        IProposalExecutionEngine.ExecuteProposalParams memory params,\n        bool allowOperatorsToSpendPartyEth\n    ) internal returns (bytes memory nextProgressData) {\n        // Decode the proposal data.\n        OperatorProposalData memory data = abi.decode(params.proposalData, (OperatorProposalData));\n        (uint256 allowedExecutorsIndex, bytes memory executionData) = abi.decode(\n            params.extraData,\n            (uint256, bytes)\n        );\n\n        // Check that the caller is an allowed executor.\n        _assertCallerIsAllowedToExecute(msg.sender, data.allowedExecutors, allowedExecutorsIndex);\n\n        // Check whether operator can spend party's ETH balance.\n        if (!allowOperatorsToSpendPartyEth && data.operatorValue > msg.value) {\n            revert NotEnoughEthError(data.operatorValue, msg.value);\n        }\n\n        // Execute the operation.\n        data.operator.execute{ value: data.operatorValue }(data.operatorData, executionData);\n\n        // Nothing left to do.\n        return \"\";\n    }\n\n    function _assertCallerIsAllowedToExecute(\n        address caller,\n        address[] memory allowedExecutors,\n        uint256 allowedExecutorsIndex\n    ) private pure {\n        // If there are no allowed executors, then anyone can execute.\n        if (allowedExecutors.length == 0) return;\n\n        // Check if the caller is an allowed executor.\n        if (caller != allowedExecutors[allowedExecutorsIndex])\n            revert NotAllowedToExecute(caller, allowedExecutors);\n    }\n}"
    },
    {
      "filename": "contracts/operators/CollectionBatchBuyOperator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./IOperator.sol\";\nimport \"../party/Party.sol\";\nimport \"../tokens/IERC721.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibAddress.sol\";\nimport \"../utils/LibSafeERC721.sol\";\nimport \"openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\n/// @notice A crowdfund that purchases a specific NFT (i.e., with a known token\n///         ID) listing for a known price.\ncontract CollectionBatchBuyOperator is IOperator {\n    using LibRawResult for bytes;\n    using LibSafeERC721 for IERC721;\n    using LibAddress for address payable;\n\n    struct CollectionBatchBuyOperationData {\n        /// The contract of NFTs to buy.\n        IERC721 nftContract;\n        /// The merkle root of the token IDs that can be bought. If null,\n        /// allow any token ID in the collection can be bought.\n        bytes32 nftTokenIdsMerkleRoot;\n        // Maximum amount this crowdfund will pay for an NFT.\n        uint256 maximumPrice;\n        // Minimum number of tokens that must be purchased. If this limit is\n        // not reached, the batch buy will fail.\n        uint256 minTokensBought;\n        // Minimum amount of ETH that must be used to buy the tokens. If this\n        // amount is not reached, the batch buy will fail.\n        uint256 minTotalEthUsed;\n    }\n\n    struct TokenToBuy {\n        // The token ID of the NFT to buy.\n        uint256 tokenId;\n        // The price of the token. This cannot be greater than `maximumPrice`.\n        uint96 price;\n        // The proof needed to verify that the token ID is included in the\n        // `nftTokenIdsMerkleRoot` (if it is not null).\n        bytes32[] proof;\n    }\n\n    struct BuyCall {\n        // The contract to call to buy the NFTs in `tokensToBuy`.\n        address payable target;\n        // The calldata to call `target` with to buy the NFTs in `tokensToBuy`.\n        bytes data;\n        // The tokens to try buying with this call.\n        TokenToBuy[] tokensToBuy;\n    }\n\n    struct CollectionBatchBuyExecutionData {\n        // The calls made to buy the NFTs. Each call has a target, data, and\n        // the tokens to buy in that call.\n        BuyCall[] calls;\n        // The total number of tokens that can be bought in this batch buy. This\n        // should be equal to the sum of the each `tokensToBuy` in `calls`.\n        uint256 numOfTokens;\n    }\n\n    event CollectionBatchBuyOperationExecuted(\n        Party party,\n        IERC721 token,\n        uint256[] tokenIdsBought,\n        uint256 totalEthUsed\n    );\n\n    error NothingBoughtError();\n    error InvalidMinTokensBoughtError(uint256 minTokensBought);\n    error InvalidTokenIdError();\n    error NotEnoughTokensBoughtError(uint256 tokensBought, uint256 minTokensBought);\n    error NotEnoughEthUsedError(uint256 ethUsed, uint256 minTotalEthUsed);\n    error MaximumPriceError(uint256 callValue, uint256 maximumPrice);\n    error CallProhibitedError(address target, bytes data);\n    error NumOfTokensCannotBeLessThanMin(uint256 numOfTokens, uint256 min);\n    error EthUsedForFailedBuyError(uint256 expectedEthUsed, uint256 actualEthUsed);\n\n    function execute(bytes memory operatorData, bytes memory executionData) external payable {\n        // Decode the operator data.\n        CollectionBatchBuyOperationData memory op = abi.decode(\n            operatorData,\n            (CollectionBatchBuyOperationData)\n        );\n\n        // Decode the execution data.\n        CollectionBatchBuyExecutionData memory ex = abi.decode(\n            executionData,\n            (CollectionBatchBuyExecutionData)\n        );\n\n        if (op.minTokensBought == 0) {\n            // Must buy at least one token.\n            revert InvalidMinTokensBoughtError(0);\n        }\n\n        if (ex.numOfTokens < op.minTokensBought) {\n            // The number of tokens to buy must be greater than or equal to the\n            // minimum number of tokens to buy.\n            revert NumOfTokensCannotBeLessThanMin(ex.numOfTokens, op.minTokensBought);\n        }\n\n        // Lengths of arrays are updated at the end.\n        uint256[] memory tokenIds = new uint256[](ex.numOfTokens);\n\n        uint96 totalEthUsed;\n        uint256 tokensBought;\n        for (uint256 i; i < ex.calls.length; ++i) {\n            BuyCall memory call = ex.calls[i];\n\n            uint96 callValue;\n            for (uint256 j; j < call.tokensToBuy.length; ++j) {\n                TokenToBuy memory tokenToBuy = call.tokensToBuy[j];\n\n                if (op.nftTokenIdsMerkleRoot != bytes32(0)) {\n                    // Verify the token ID is in the merkle tree.\n                    _verifyTokenId(tokenToBuy.tokenId, op.nftTokenIdsMerkleRoot, tokenToBuy.proof);\n                }\n\n                // Check that the call value is under the maximum price.\n                uint96 price = tokenToBuy.price;\n                if (price > op.maximumPrice) {\n                    revert MaximumPriceError(price, op.maximumPrice);\n                }\n\n                // Add the price to the total value used for the call.\n                callValue += price;\n            }\n\n            uint256 balanceBefore = address(this).balance;\n            {\n                // Execute the call to buy the NFT.\n                (bool success, ) = _buy(call.target, callValue, call.data);\n\n                if (!success) continue;\n            }\n\n            {\n                uint96 ethUsed;\n                for (uint256 j; j < call.tokensToBuy.length; ++j) {\n                    uint256 tokenId = call.tokensToBuy[j].tokenId;\n                    uint96 price = call.tokensToBuy[j].price;\n\n                    // Check whether the NFT was successfully bought.\n                    if (op.nftContract.safeOwnerOf(tokenId) == address(this)) {\n                        ethUsed += price;\n                        ++tokensBought;\n\n                        // Add the token to the list of tokens to finalize.\n                        tokenIds[tokensBought - 1] = tokenId;\n                    }\n                }\n\n                // Check ETH spent for call is what was expected.\n                uint256 actualEthUsed = balanceBefore - address(this).balance;\n                if (ethUsed != actualEthUsed) {\n                    revert EthUsedForFailedBuyError(ethUsed, actualEthUsed);\n                }\n\n                totalEthUsed += ethUsed;\n            }\n        }\n\n        // This is to prevent this crowdfund from finalizing a loss if nothing\n        // was attempted to be bought (ie. `tokenIds` is empty) or all NFTs were\n        // bought for free.\n        if (totalEthUsed == 0) revert NothingBoughtError();\n\n        // Check number of tokens bought is not less than the minimum.\n        if (tokensBought < op.minTokensBought) {\n            revert NotEnoughTokensBoughtError(tokensBought, op.minTokensBought);\n        }\n\n        // Check total ETH used is not less than the minimum.\n        if (totalEthUsed < op.minTotalEthUsed) {\n            revert NotEnoughEthUsedError(totalEthUsed, op.minTotalEthUsed);\n        }\n\n        assembly {\n            // Update length of `tokenIds`\n            mstore(mload(ex), tokensBought)\n        }\n\n        // Transfer the NFTs to the party.\n        for (uint256 i; i < tokenIds.length; ++i) {\n            op.nftContract.safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n        }\n\n        // Transfer unused ETH to the party.\n        uint256 unusedEth = msg.value - totalEthUsed;\n        if (unusedEth > 0) payable(msg.sender).transferEth(unusedEth);\n\n        emit CollectionBatchBuyOperationExecuted(\n            Party(payable(msg.sender)),\n            op.nftContract,\n            tokenIds,\n            totalEthUsed\n        );\n    }\n\n    function _buy(\n        address payable callTarget,\n        uint96 callValue,\n        bytes memory callData\n    ) private returns (bool success, bytes memory revertData) {\n        // Check that call is not re-entering.\n        if (callTarget == address(this)) {\n            revert CallProhibitedError(callTarget, callData);\n        }\n        // Execute the call to buy the NFT.\n        (success, revertData) = callTarget.call{ value: callValue }(callData);\n    }\n\n    function _verifyTokenId(uint256 tokenId, bytes32 root, bytes32[] memory proof) private pure {\n        bytes32 leaf;\n        assembly {\n            mstore(0x00, tokenId)\n            leaf := keccak256(0x00, 0x20)\n        }\n\n        if (!MerkleProof.verify(proof, root, leaf)) revert InvalidTokenIdError();\n    }\n}"
    },
    {
      "filename": "contracts/proposals/OperatorProposal.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./IProposalExecutionEngine.sol\";\nimport \"../operators/IOperator.sol\";\n\ncontract OperatorProposal {\n    struct OperatorProposalData {\n        // Addresses that are allowed to execute the proposal and decide what\n        // calldata used by the operator proposal at the time of execution.\n        address[] allowedExecutors;\n        // The operator contract that will be used to execute the proposal.\n        IOperator operator;\n        // Amount of ETH to send to the operator contract for executing the proposal.\n        uint96 operatorValue;\n        // The calldata that will be used by the operator contract to execute the proposal.\n        bytes operatorData;\n    }\n\n    event OperationExecuted(address executor);\n\n    error NotAllowedToExecute(address executor, address[] allowedExecutors);\n    error NotEnoughEthError(uint256 operatorValue, uint256 ethAvailable);\n\n    function _executeOperation(\n        IProposalExecutionEngine.ExecuteProposalParams memory params,\n        bool allowOperatorsToSpendPartyEth\n    ) internal returns (bytes memory nextProgressData) {\n        // Decode the proposal data.\n        OperatorProposalData memory data = abi.decode(params.proposalData, (OperatorProposalData));\n        (uint256 allowedExecutorsIndex, bytes memory executionData) = abi.decode(\n            params.extraData,\n            (uint256, bytes)\n        );\n\n        // Check that the caller is an allowed executor.\n        _assertCallerIsAllowedToExecute(msg.sender, data.allowedExecutors, allowedExecutorsIndex);\n\n        // Check whether operator can spend party's ETH balance.\n        if (!allowOperatorsToSpendPartyEth && data.operatorValue > msg.value) {\n            revert NotEnoughEthError(data.operatorValue, msg.value);\n        }\n\n        // Execute the operation.\n        data.operator.execute{ value: data.operatorValue }(data.operatorData, executionData);\n\n        // Nothing left to do.\n        return \"\";\n    }\n\n    function _assertCallerIsAllowedToExecute(\n        address caller,\n        address[] memory allowedExecutors,\n        uint256 allowedExecutorsIndex\n    ) private pure {\n        // If there are no allowed executors, then anyone can execute.\n        if (allowedExecutors.length == 0) return;\n\n        // Check if the caller is an allowed executor.\n        if (caller != allowedExecutors[allowedExecutorsIndex])\n            revert NotAllowedToExecute(caller, allowedExecutors);\n    }\n}"
    },
    {
      "filename": "contracts/operators/CollectionBatchBuyOperator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./IOperator.sol\";\nimport \"../party/Party.sol\";\nimport \"../tokens/IERC721.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibAddress.sol\";\nimport \"../utils/LibSafeERC721.sol\";\nimport \"openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\n/// @notice A crowdfund that purchases a specific NFT (i.e., with a known token\n///         ID) listing for a known price.\ncontract CollectionBatchBuyOperator is IOperator {\n    using LibRawResult for bytes;\n    using LibSafeERC721 for IERC721;\n    using LibAddress for address payable;\n\n    struct CollectionBatchBuyOperationData {\n        /// The contract of NFTs to buy.\n        IERC721 nftContract;\n        /// The merkle root of the token IDs that can be bought. If null,\n        /// allow any token ID in the collection can be bought.\n        bytes32 nftTokenIdsMerkleRoot;\n        // Maximum amount this crowdfund will pay for an NFT.\n        uint256 maximumPrice;\n        // Minimum number of tokens that must be purchased. If this limit is\n        // not reached, the batch buy will fail.\n        uint256 minTokensBought;\n        // Minimum amount of ETH that must be used to buy the tokens. If this\n        // amount is not reached, the batch buy will fail.\n        uint256 minTotalEthUsed;\n    }\n\n    struct TokenToBuy {\n        // The token ID of the NFT to buy.\n        uint256 tokenId;\n        // The price of the token. This cannot be greater than `maximumPrice`.\n        uint96 price;\n        // The proof needed to verify that the token ID is included in the\n        // `nftTokenIdsMerkleRoot` (if it is not null).\n        bytes32[] proof;\n    }\n\n    struct BuyCall {\n        // The contract to call to buy the NFTs in `tokensToBuy`.\n        address payable target;\n        // The calldata to call `target` with to buy the NFTs in `tokensToBuy`.\n        bytes data;\n        // The tokens to try buying with this call.\n        TokenToBuy[] tokensToBuy;\n    }\n\n    struct CollectionBatchBuyExecutionData {\n        // The calls made to buy the NFTs. Each call has a target, data, and\n        // the tokens to buy in that call.\n        BuyCall[] calls;\n        // The total number of tokens that can be bought in this batch buy. This\n        // should be equal to the sum of the each `tokensToBuy` in `calls`.\n        uint256 numOfTokens;\n    }\n\n    event CollectionBatchBuyOperationExecuted(\n        Party party,\n        IERC721 token,\n        uint256[] tokenIdsBought,\n        uint256 totalEthUsed\n    );\n\n    error NothingBoughtError();\n    error InvalidMinTokensBoughtError(uint256 minTokensBought);\n    error InvalidTokenIdError();\n    error NotEnoughTokensBoughtError(uint256 tokensBought, uint256 minTokensBought);\n    error NotEnoughEthUsedError(uint256 ethUsed, uint256 minTotalEthUsed);\n    error MaximumPriceError(uint256 callValue, uint256 maximumPrice);\n    error CallProhibitedError(address target, bytes data);\n    error NumOfTokensCannotBeLessThanMin(uint256 numOfTokens, uint256 min);\n    error EthUsedForFailedBuyError(uint256 expectedEthUsed, uint256 actualEthUsed);\n\n    function execute(bytes memory operatorData, bytes memory executionData) external payable {\n        // Decode the operator data.\n        CollectionBatchBuyOperationData memory op = abi.decode(\n            operatorData,\n            (CollectionBatchBuyOperationData)\n        );\n\n        // Decode the execution data.\n        CollectionBatchBuyExecutionData memory ex = abi.decode(\n            executionData,\n            (CollectionBatchBuyExecutionData)\n        );\n\n        if (op.minTokensBought == 0) {\n            // Must buy at least one token.\n            revert InvalidMinTokensBoughtError(0);\n        }\n\n        if (ex.numOfTokens < op.minTokensBought) {\n            // The number of tokens to buy must be greater than or equal to the\n            // minimum number of tokens to buy.\n            revert NumOfTokensCannotBeLessThanMin(ex.numOfTokens, op.minTokensBought);\n        }\n\n        // Lengths of arrays are updated at the end.\n        uint256[] memory tokenIds = new uint256[](ex.numOfTokens);\n\n        uint96 totalEthUsed;\n        uint256 tokensBought;\n        for (uint256 i; i < ex.calls.length; ++i) {\n            BuyCall memory call = ex.calls[i];\n\n            uint96 callValue;\n            for (uint256 j; j < call.tokensToBuy.length; ++j) {\n                TokenToBuy memory tokenToBuy = call.tokensToBuy[j];\n\n                if (op.nftTokenIdsMerkleRoot != bytes32(0)) {\n                    // Verify the token ID is in the merkle tree.\n                    _verifyTokenId(tokenToBuy.tokenId, op.nftTokenIdsMerkleRoot, tokenToBuy.proof);\n                }\n\n                // Check that the call value is under the maximum price.\n                uint96 price = tokenToBuy.price;\n                if (price > op.maximumPrice) {\n                    revert MaximumPriceError(price, op.maximumPrice);\n                }\n\n                // Add the price to the total value used for the call.\n                callValue += price;\n            }\n\n            uint256 balanceBefore = address(this).balance;\n            {\n                // Execute the call to buy the NFT.\n                (bool success, ) = _buy(call.target, callValue, call.data);\n\n                if (!success) continue;\n            }\n\n            {\n                uint96 ethUsed;\n                for (uint256 j; j < call.tokensToBuy.length; ++j) {\n                    uint256 tokenId = call.tokensToBuy[j].tokenId;"
    }
  ]
}