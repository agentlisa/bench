{
  "Title": "Reduce gas cost",
  "Content": "##### Description\nReduce gas cost for some functions:\nhttps://github.com/1inch/solidity-utils/blob/eec6b523860af5215a8dd196fe3aff3a4d252fc9/contracts/libraries/UniERC20.sol#L99\n\n##### Recommendation\nWe recommend adding `unchecked block` for `len++`.\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/libraries/UniERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./RevertReasonForwarder.sol\";\nimport \"./SafeERC20.sol\";\nimport \"./StringUtil.sol\";\n\nlibrary UniERC20 {\n    using SafeERC20 for IERC20;\n\n    error ApproveCalledOnETH();\n    error NotEnoughValue();\n    error FromIsNotSender();\n    error ToIsNotThis();\n    error ERC20OperationFailed();\n\n    IERC20 private constant _ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n    IERC20 private constant _ZERO_ADDRESS = IERC20(address(0));\n\n    function isETH(IERC20 token) internal pure returns (bool) {\n        return (token == _ZERO_ADDRESS || token == _ETH_ADDRESS);\n    }\n\n    function uniBalanceOf(IERC20 token, address account) internal view returns (uint256) {\n        if (isETH(token)) {\n            return account.balance;\n        } else {\n            return token.balanceOf(account);\n        }\n    }\n\n    function uniTransfer(IERC20 token, address payable to, uint256 amount) internal {\n        if (amount > 0) {\n            if (isETH(token)) {\n                to.transfer(amount);\n            } else {\n                token.safeTransfer(to, amount);\n            }\n        }\n    }\n\n    function uniTransferFrom(IERC20 token, address payable from, address to, uint256 amount) internal {\n        if (amount > 0) {\n            if (isETH(token)) {\n                if (msg.value < amount) revert NotEnoughValue();\n                if (from != msg.sender) revert FromIsNotSender();\n                if (to != address(this)) revert ToIsNotThis();\n                if (msg.value > amount) {\n                    // Return remainder if exist\n                    unchecked { from.transfer(msg.value - amount); }\n                }\n            } else {\n                token.safeTransferFrom(from, to, amount);\n            }\n        }\n    }\n\n    function uniSymbol(IERC20 token) internal view returns(string memory) {\n        return _uniDecode(token, \"symbol()\", \"SYBMOL()\");\n    }\n\n    function uniName(IERC20 token) internal view returns(string memory) {\n        return _uniDecode(token, \"name()\", \"NAME()\");\n    }\n\n    function uniApprove(IERC20 token, address to, uint256 amount) internal {\n        if (isETH(token)) revert ApproveCalledOnETH();\n\n        token.forceApprove(to, amount);\n    }\n\n    function _uniDecode(IERC20 token, string memory lowerCaseSignature, string memory upperCaseSignature) private view returns(string memory) {\n        if (isETH(token)) {\n            return \"ETH\";\n        }\n\n        (bool success, bytes memory data) = address(token).staticcall{ gas: 20000 }(\n            abi.encodeWithSignature(lowerCaseSignature)\n        );\n        if (!success) {\n            (success, data) = address(token).staticcall{ gas: 20000 }(\n                abi.encodeWithSignature(upperCaseSignature)\n            );\n        }\n\n        if (success && data.length >= 96) {\n            (uint256 offset, uint256 len) = abi.decode(data, (uint256, uint256));\n            if (offset == 0x20 && len > 0 && len <= 256) {\n                return abi.decode(data, (string));\n            }\n        }\n\n        if (success && data.length == 32) {\n            uint256 len = 0;\n            while (len < data.length && data[len] >= 0x20 && data[len] <= 0x7E) {\n                len++;\n            }\n\n            if (len > 0) {\n                assembly { // solhint-disable-line no-inline-assembly\n                    mstore(data, len)\n                }\n                return string(data);\n            }\n        }\n\n        return StringUtil.toHex(address(token));\n    }\n}"
    }
  ]
}