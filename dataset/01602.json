{
  "Title": "M-11: User will be forced liquidated",
  "Content": "# Issue M-11: User will be forced liquidated \n\nSource: https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/234 \n\n## Found by \nBugBusters\n## Summary\nThe `addMargin` function have a vulnerability that can potentially lead to issues when the contract is paused. Users are unable to add margin during the paused state, which can leave them vulnerable to liquidation if their collateral value falls below the required threshold. Additionally, after the contract is unpaused, users can be subject to frontrunning, where their margin addition transactions can be exploited by other users.\n\n## Vulnerability Detail\nTo better understand how this  vulnerabilities could be exploited, let's consider a scenario:\n\n1): The contract owner pauses the contract due to some unforeseen circumstances or for maintenance purposes.\n\n2): During the paused state, User A wants to add margin to their account. However, they are unable to do so since the contract prohibits margin addition while paused.\n\n3): Meanwhile, the price of the collateral supporting User A's account experiences significant fluctuations, causing the value of their collateral to fall below the required threshold for maintenance.\n\n4): While the contract is still paused, User A's account becomes eligible for liquidation.\n\n5): After some time, the contract owner decides to unpause the contract, allowing normal operations to resume.\n\n6): User A tries to add margin to their account after the contract is unpaused. However, before their transaction is processed, User B, who has been monitoring the pending transactions, notices User A's margin addition transaction and quickly frontruns it by submitting a higher gas price transaction to liquidate User A's account instead.\n\nNow userA will be forcefully liquidated even tho he wants to add the margin.\n\nYou can read more from [this link](https://dacian.me/lending-borrowing-defi-attacks#heading-borrower-immediately-liquidated-after-repayments-resume)\n\n## Impact\n\nThe identified impact could be\n\n1): Unfair Liquidations: Users can be unfairly liquidated if their margin addition transactions are frontrun by other users after the contract is unpaused. This can result in the loss of their collateral.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/MarginAccount.sol#L136-L156\n\n## Tool used\n\nManual Review\n\n## Recommendation\nImplement a Fair Liquidation Mechanism: Introduce a delay or waiting period before executing liquidation transactions. This waiting period should provide sufficient time for users to address their collateral issues or add margin. \n\n\n\n## Discussion\n\n**Nabeel-javaid**\n\nescalate for 10 USDC\n\nI think this issue should be considered as valid. The validity of issue should be accepted. The report clearly shows how a protocol owner actions (pause) will result in unfair liquidations causing loss of funds to users.\n\nAlso it is unlikely that on unpause human users will be able to secure their positions before MEV/liquidation bots capture the available profit. Hence the loss is certain.\n\nFor reference, similar issues were consider valid in the recent contests on sherlock, you can check it [here](https://github.com/sherlock-audit/2023-03-notional-judging/issues/203) and [here](https://github.com/sherlock-audit/2023-05-perennial-judging/issues/190). Maintaining a consistent valid/invalid classification standard will be ideal here.\n\n**sherlock-admin2**\n\n > escalate for 10 USDC\n> \n> I think this issue should be considered as valid. The validity of issue should be accepted. The report clearly shows how a protocol owner actions (pause) will result in unfair liquidations causing loss of funds to users.\n> \n> Also it is unlikely that on unpause human users will be able to secure their positions before MEV/liquidation bots capture the available profit. Hence the loss is certain.\n> \n> For reference, similar issues were consider valid in the recent contests on sherlock, you can check it [here](https://github.com/sherlock-audit/2023-03-notional-judging/issues/203) and [here](https://github.com/sherlock-audit/2023-05-perennial-judging/issues/190). Maintaining a consistent valid/invalid classification standard will be ideal here.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nI mean if the liquidation cannot be paused then clearly a medium (there are similar past finding)\n\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/1f9a5ed0ca8f6004bbb7b099ecbb8ae796557849/hubble-protocol/contracts/MarginAccount.sol#L322\n\n```solidity\n    function liquidateExactRepay(address trader, uint repay, uint idx, uint minSeizeAmount) external whenNotPaused {\n```\n\nBut The liquidation is paused as well\n\nso recommend severity is low\n\na optional fix is adding a grace period for user to add margin when unpause the liquidation and addMargin\n\n\n**Nabeel-javaid**\n\nHey @ctf-sec \nAdding more context, the problem is not that the liquidation functions can be paused or not, it is more of a front-running problem.\n\nLiquidation functions cannot be paused individually, whole contract is paused which means that other functions with the whenNotPaused modifier cannot be accessed either.\n\nSo when the contract is un-paused, a user can be front-run before making the position healthy and is unfairly liquidated. For more reference see the following issue that are exactly the same .\n\n[Perrenial Contest Issue 190](https://github.com/sherlock-audit/2023-05-perennial-judging/issues/190)\n[Notional Contest Issue 203](https://github.com/sherlock-audit/2023-03-notional-judging/issues/203)\n\nI hope that added context will further help in judging.\n\n**hrishibhat**\n\n@ctf-sec \nI understand this is how it is design but there is a loss due front-run during unpause. \n\n**ctf-sec**\n\nhttps://github.com/sherlock-audit/2023-04-blueberry-judging/issues/118\n\nseems like this issue has been historically judged as a medium\n\nthen a medium is fine\n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nAfter further discussions with Lead Watson and Sponsor, considering this a valid medium based on the above comments\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [Nabeel-javaid](https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/234/#issuecomment-1642504725): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/72",
  "Code": [
    {
      "filename": "hubble-protocol/contracts/MarginAccount.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport { MetaHubbleBase } from \"./legos/HubbleBase.sol\";\nimport {\n    ERC20Detailed,\n    IClearingHouse,\n    IInsuranceFund,\n    IOracle,\n    IRegistry,\n    IMarginAccount,\n    IERC20FlexibleSupply,\n    IWAVAX,\n    IOrderBook\n} from \"./Interfaces.sol\";\nimport { IHubbleBibliophile } from \"./precompiles/IHubbleBibliophile.sol\";\n\n/**\n* @title This contract is used for posting margin (collateral), realizing PnL etc.\n* @notice Most notable operations include addMargin, removeMargin and liquidations\n*/\ncontract MarginAccount is IMarginAccount, MetaHubbleBase, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    // Hubble vUSD is necessitated to be the first whitelisted collateral\n    uint constant VUSD_IDX = 0;\n    uint constant WAVAX_IDX = 1; // assumes wavax index = 1\n\n    // used for all usd based values\n    uint constant PRECISION = 1e6;\n\n    error NOT_LIQUIDATABLE(IMarginAccount.LiquidationStatus);\n\n    /**\n    * @dev This is only used to group variables to avoid a solidity stack too deep error\n    *   incentivePerDollar How many $ liquidator gets for each $ they repay e.g. they might get $1.05 for every $1 liquidation. >= PRECISION\n    *   repayAble The maximum debt that can be settled for an account undergoing a liquidation\n    *   priceCollateral Most recent oracle price (chainlink) of the collateral that is being seized for an account undergoing a liquidation\n    *   decimals Decimals for the collateral being seized\n    */\n    struct LiquidationBuffer {\n        LiquidationStatus status;\n        uint8 decimals;\n        uint incentivePerDollar;\n        uint repayAble;\n        uint priceCollateral;\n    }\n\n    /* ****************** */\n    /*       Storage      */\n    /* ****************** */\n\n    IClearingHouse public clearingHouse;\n    IOrderBook public orderBook;\n    IOracle public oracle;\n    IInsuranceFund public insuranceFund;\n    IERC20FlexibleSupply public vusd;\n    uint public credit;\n\n    /// @notice Array of supported collateral\n    Collateral[] public supportedCollateral;\n\n    /**\n    * @notice How many $ liquidator gets for each $ they repay e.g. they might get $1.05 for every $1 liquidation\n    * @dev In the above scenario, this value will be %0.05 i.e. 5 cents incentive per dollar repayed\n    */\n    uint public liquidationIncentive;\n\n    /**\n    * @notice Maps index in supportedCollateral => trader => balance\n    * @dev equivalent to margin(uint idx, address user)\n    */\n    mapping(uint => mapping(address => int)) override public margin; // SLOT_10 !!! used in precompile !!!\n\n    /**\n    * @notice Maps trader => reserved margin for open orders\n    */\n    mapping(address => uint) public reservedMargin;\n    uint public minAllowableMargin;\n    address public marginAccountHelper;\n    IHubbleBibliophile public bibliophile;\n\n    uint256[50] private __gap;\n\n    modifier onlyClearingHouse() {\n        require(_msgSender() == address(clearingHouse), \"Only clearingHouse\");\n        _;\n    }\n\n    modifier onlyOrderBook() {\n        require(_msgSender() == address(orderBook), \"Only orderBook\");\n        _;\n    }\n\n    modifier onlyMarginAccountHelper() {\n        require(_msgSender() == marginAccountHelper, \"Only marginAccountHelper\");\n        _;\n    }\n\n    constructor(address _trustedForwarder) MetaHubbleBase(_trustedForwarder) {}\n\n    function initialize(\n        address _governance,\n        address _vusd\n    ) external\n      initializer\n    {\n        _setGovernace(_governance);\n        _addCollateral(_vusd, PRECISION); // weight = 1 * PRECISION\n        vusd = IERC20FlexibleSupply(_vusd);\n    }\n\n    receive() external payable {\n        // only accept AVAX via fallback from the WAVAX contract\n        assert(_msgSender() == address(supportedCollateral[WAVAX_IDX].token));\n    }\n\n    /* ****************** */\n    /*       Margin       */\n    /* ****************** */\n\n    /**\n    * @notice Post margin\n    * @param idx Index of the supported collateral\n    * @param amount Amount to deposit (scaled same as the asset)\n    */\n    function addMargin(uint idx, uint amount) override external whenNotPaused {\n        addMarginFor(idx, amount, _msgSender());\n    }\n\n    /**\n    * @notice Post margin for another account\n    * @param idx Index of the supported collateral\n    * @param amount Amount to deposit (scaled same as the asset)\n    * @param to Account to post margin for\n    */\n    function addMarginFor(uint idx, uint amount, address to) override public whenNotPaused {\n        require(amount > 0, \"Add non-zero margin\");\n        // will revert for idx >= supportedCollateral.length\n        if (idx == VUSD_IDX) {\n            _transferInVusd(_msgSender(), amount);\n        } else {\n            supportedCollateral[idx].token.safeTransferFrom(_msgSender(), address(this), amount);\n        }\n        margin[idx][to] += amount.toInt256();\n        emit MarginAdded(to, idx, amount, _blockTimestamp());\n    }\n\n    /**\n    * @notice Withdraw margin.\n    *   Collateral can not be withdrawn if vUSD balance is < 0.\n    * @dev If the contract has insufficient vUSD balance, a loan is taken from the vUSD contract.\n    * @param idx Index of the supported collateral\n    * @param amount Amount to withdraw (scaled same as the asset)\n    */\n    function removeMargin(uint idx, uint256 amount) override external whenNotPaused {\n        address trader = _msgSender();\n        _removeMarginFor(idx, amount, trader, trader);\n    }\n\n    /**\n     * @notice Priviliged withdraw function used by the MarginAccountHelper contract to unwrap the tokens before sending it to the user\n    */\n    function removeMarginFor(uint idx, uint amount, address trader) override external whenNotPaused onlyMarginAccountHelper {\n        _removeMarginFor(idx, amount, trader, marginAccountHelper);\n    }\n\n    /**\n    * @notice Invoked to realize PnL, credit/debit funding payments, pay trade and liquidation fee\n    * @dev Will only make a change to VUSD balance.\n    *   only clearingHouse is authorized to call.\n    * @param trader Account to realize PnL for\n    * @param realizedPnl Amount to credit/debit\n    */\n    function realizePnL(address trader, int256 realizedPnl)\n        override\n        external\n        onlyClearingHouse\n    {\n        // -ve PnL will reduce balance\n        if (realizedPnl != 0) {\n            margin[VUSD_IDX][trader] += realizedPnl;\n            emit PnLRealized(trader, realizedPnl, _blockTimestamp());\n        }\n    }\n\n    function transferOutVusd(address recipient, uint amount)\n        override\n        external\n        onlyClearingHouse\n    {\n        _transferOutVusd(recipient, amount);\n    }\n\n    function reserveMargin(address trader, uint amount)\n        override\n        external\n        onlyOrderBook\n    {\n        require(getAvailableMargin(trader) >= amount.toInt256(), \"MA_reserveMargin: Insufficient margin\");\n        reservedMargin[trader] += amount;\n        emit MarginReserved(trader, amount);\n    }\n\n    function releaseMargin(address trader, uint amount)\n        override\n        external\n        onlyOrderBook\n    {\n        require(reservedMargin[trader] >= amount, \"MA_releaseMargin: Insufficient reserved margin\");\n        reservedMargin[trader] -= amount;\n        emit MarginReleased(trader, amount);\n    }\n\n    /**\n     * @notice Determine the \"free\" margin of a trader.\n     * This is evaluated as follows: margin - unrealizedFunding - unrealizedPnL - utilizedMargin - reservedMargin\n     * utilizedMargin: the margin amount that would be used to maintain currently open positions at max leverage\n     * This is also the amount of margin that can be withdrawn\n     * @param trader trader to check\n     * @return availableMargin the amount of free/available margin\n    */\n    function getAvailableMargin(address trader) public view override returns (int availableMargin) {\n        // return value _margin from the call to getNotionalPositionAndMargin _margin includes both the unrealizedFunding and unrealizedPnL\n        int256 _margin;\n        uint256 notionalPosition;\n        if (address(bibliophile) != address(0x0)) {\n            // precompile magic allows us to execute this for a fixed 1k gas\n            (notionalPosition, _margin) = bibliophile.getNotionalPositionAndMargin(trader, true /* includeFundingPayments */, uint8(IClearingHouse.Mode.Min_Allowable_Margin));\n        } else {\n            // folowing is the fallback code if precompile is not available. Precompile is intended to perform the same computation as the following code\n            (notionalPosition, _margin) = clearingHouse.getNotionalPositionAndMargin(trader, true /* includeFundingPayments */, IClearingHouse.Mode.Min_Allowable_Margin);\n        }\n        uint utilizedMargin = notionalPosition * minAllowableMargin / PRECISION;\n        availableMargin = _margin - utilizedMargin.toInt256() - reservedMargin[trader].toInt256();\n    }\n\n    /* ****************** */\n    /*    Liquidations    */\n    /* ****************** */\n\n    /**\n    * @notice Determines if a trader's margin account can be liquidated now\n    * @param trader Account to check liquidation status for\n    * @param includeFunding whether to include funding payments before checking liquidation status\n    * @return _isLiquidatable Whether the account can be liquidated; reason if not\n    * @return repayAmount Trader's debt i.e. the max amount that they can be liquidated for\n    * @return incentivePerDollar How many $ liquidator gets for each $ they repay\n    *   e.g. they might get $1.05 for every $1 that is repayed.\n    */\n    function isLiquidatable(address trader, bool includeFunding)\n        override\n        public\n        view\n        returns(IMarginAccount.LiquidationStatus _isLiquidatable, uint repayAmount, uint incentivePerDollar)\n    {\n        int vusdBal = margin[VUSD_IDX][trader];\n        if (includeFunding) {\n            vusdBal -= clearingHouse.getTotalFunding(trader);\n        }\n        if (vusdBal >= 0) { // nothing to liquidate\n            return (IMarginAccount.LiquidationStatus.NO_DEBT, 0, 0);\n        }\n\n        (uint256 notionalPosition,) = clearingHouse.getTotalNotionalPositionAndUnrealizedPnl(trader, 0, IClearingHouse.Mode.Min_Allowable_Margin); // last two arguments are irrelevent as we are checking only for zero/non-zero notional position in next step\n        if (notionalPosition != 0) { // Liquidate positions before liquidating margin account\n            return (IMarginAccount.LiquidationStatus.OPEN_POSITIONS, 0, 0);\n        }\n\n        (int256 weighted, int256 spot) = weightedAndSpotCollateral(trader);\n        if (weighted >= 0) {\n            return (IMarginAccount.LiquidationStatus.ABOVE_THRESHOLD, 0, 0);\n        }\n\n        // _isLiquidatable = IMarginAccount.LiquidationStatus.IS_LIQUIDATABLE;\n        repayAmount = (-vusdBal).toUint256();\n        incentivePerDollar = PRECISION; // get atleast $1 worth of collateral for every $1 paid\n\n        if (spot > 0) {\n            /**\n                Liquidation scenario B, where Cw < |vUSD| < Cusd\n                => Cw - |vUSD| < 0\n                => Cw + vUSD (=weighted) < 0; since vUSD < 0\n                Max possible liquidationIncentive (for repaying |vUSD|) is Cusd\n            */\n            incentivePerDollar += _min(\n                liquidationIncentive, // incentivePerDollar = PRECISION + liquidationIncentive <= 1.1\n                // divide up all the extra dollars in proportion to repay amount\n                // note that spot value here is inclusive of the -ve vUSD value\n                spot.toUint256() * PRECISION / repayAmount\n            );\n        } /* else {\n            Since the protocol is already in deficit we don't have any money to give out as liquidationIncentive\n            Liquidation scenario C, where Cusd <= |vUSD|\n            => Cusd - |vUSD| <= 0\n            => Cusd + vUSD (=spot) <= 0; since vUSD < 0\n\n            @todo consider providing some incentive from insurance fund to execute a liquidation in this scenario.\n            That fee is basically provided so that insurance fund has to settle a lower bad debt and seize lesser amount of assets.\n            (because seized assets then need to sold/auctioned off, so that's extra work)\n        } */\n    }\n\n    /**\n    * @notice Liquidate a trader while mentioning the exact repay amount while capping \"slippage\" on the seized collateral\n    *   This maybe be considered as a \"swapExactInput\" operation.\n    *   It's required that trader has no open positions.\n    * @param trader Account to liquidate\n    * @param repay Amount to repay\n    * @param idx Index of the collateral to seize\n    * @param minSeizeAmount Min collateral output amount\n    */\n    function liquidateExactRepay(address trader, uint repay, uint idx, uint minSeizeAmount) external whenNotPaused {\n        clearingHouse.updatePositions(trader); // credits/debits funding\n        LiquidationBuffer memory buffer = _getLiquidationInfo(trader, idx);\n        if (buffer.status != IMarginAccount.LiquidationStatus.IS_LIQUIDATABLE) {\n            revert NOT_LIQUIDATABLE(buffer.status);\n        }\n        _liquidateExactRepay(buffer, trader, repay, idx, minSeizeAmount);\n    }\n\n    /**\n    * @notice Liquidate a trader while mentioning the exact collateral amount to be seized while capping \"slippage\" on the repay amount.\n    *   This maybe be considered as a \"swapExactOutput\" operation.\n    *   It's required that trader has no open positions.\n    * @param trader Account to liquidate\n    * @param maxRepay Max vUSD input amount\n    * @param idx Index of the collateral to seize\n    * @param seize Exact collateral amount desired to be seized\n    */\n    function liquidateExactSeize(address trader, uint maxRepay, uint idx, uint seize) external whenNotPaused {\n        clearingHouse.updatePositions(trader); // credits/debits funding\n        LiquidationBuffer memory buffer = _getLiquidationInfo(trader, idx);\n        if (buffer.status != IMarginAccount.LiquidationStatus.IS_LIQUIDATABLE) {\n            revert NOT_LIQUIDATABLE(buffer.status);\n        }\n        _liquidateExactSeize(buffer, trader, maxRepay, idx, seize);\n    }\n\n    /**\n    * @notice Either seize all available collateral\n    *   OR settle debt completely with (most likely) left over collateral.\n    *   It's required that trader has no open positions.\n    *   Seized collateral at it's current oracle price (+ incentive) should be acceptable to the liquidator.\n    * @param trader Account to liquidate\n    * @param maxRepay Max vUSD input amount\n    * @param idxs Indices of the collateral to seize\n    */\n    function liquidateFlexible(address trader, uint maxRepay, uint[] calldata idxs) external whenNotPaused {\n        clearingHouse.updatePositions(trader); // credits/debits funding\n        uint repayed;\n        for (uint i; i < idxs.length; i++) {\n            LiquidationBuffer memory buffer = _getLiquidationInfo(trader, idxs[i]);\n            // revert if trader has open positions\n            if (buffer.status == IMarginAccount.LiquidationStatus.OPEN_POSITIONS) {\n                revert NOT_LIQUIDATABLE(buffer.status);\n            }\n            if (buffer.status != IMarginAccount.LiquidationStatus.IS_LIQUIDATABLE) {\n                break;\n            }\n            repayed = _liquidateFlexible(trader, maxRepay, idxs[i]);\n            maxRepay -= repayed;\n        }\n    }\n\n    /**\n    * @notice Invoke a bad debt settlement using the insurance fund.\n    *   It's required that trader has no open positions when settling bad debt.\n    * @dev Debt is said to be bad when the spot value of user's collateral is not enough to cover their -ve vUSD balance\n    *   Since there are no open positions, debit/credit funding payments is not required.\n    * @param trader Account for which the bad debt needs to be settled\n    */\n    function settleBadDebt(address trader) external whenNotPaused {\n        (uint256 notionalPosition,) = clearingHouse.getTotalNotionalPositionAndUnrealizedPnl(trader, 0, IClearingHouse.Mode.Min_Allowable_Margin); // last two arguments are irrelevent as we are checking only for zero/non-zero notional position in next step\n        require(notionalPosition == 0, \"Liquidate positions before settling bad debt\");\n\n        // The spot value of their collateral minus their vUSD obligation is a negative value\n        require(getSpotCollateralValue(trader) < 0, \"Above bad debt threshold\");\n\n        int vusdBal = margin[VUSD_IDX][trader];\n\n        // this check is not strictly required because getSpotCollateralValue(trader) < 0 is a stronger assertion\n        require(vusdBal < 0, \"Nothing to repay\");\n\n        uint badDebt = (-vusdBal).toUint256();\n        Collateral[] memory assets = supportedCollateral;\n\n        // This pulls the obligation\n        insuranceFund.seizeBadDebt(badDebt);\n        margin[VUSD_IDX][trader] = 0;\n\n        // Insurance fund gets all the available collateral\n        uint[] memory seized = new uint[](assets.length);\n        for (uint i = 1 /* skip vusd */; i < assets.length; i++) {\n            int amount = margin[i][trader];\n            if (amount > 0) {\n                margin[i][trader] = 0;\n                assets[i].token.safeTransfer(address(insuranceFund), amount.toUint256());\n                seized[i] = amount.toUint256();\n                insuranceFund.startAuction(address(assets[i].token));\n            }\n        }\n        emit SettledBadDebt(trader, seized, badDebt, _blockTimestamp());\n    }\n\n    /* ********************* */\n    /* Liquidations Internal */\n    /* ********************* */\n\n    /**\n    * @dev This function wil either seize all available collateral of type idx\n    * OR settle debt completely with (most likely) left over collateral\n    * @return Debt repayed <= repayble i.e. user's max debt\n    */\n    function _liquidateFlexible(address trader, uint maxRepay, uint idx) internal whenNotPaused returns(uint /* repayed */) {\n        LiquidationBuffer memory buffer = _getLiquidationInfo(trader, idx);\n\n        // Q. Can user's margin cover the entire debt?\n        uint repay = _seizeToRepay(buffer, margin[idx][trader].toUint256());\n\n        // A.1 Yes, it can cover the entire debt. Settle repayAble\n        if (repay >= buffer.repayAble) {\n            _liquidateExactRepay(\n                buffer,\n                trader,\n                buffer.repayAble, // exact repay amount\n                idx,\n                0 // minSeizeAmount=0 implies accept whatever the oracle price is\n            );\n            return buffer.repayAble; // repayed exactly repayAble and 0 is left to repay now\n        }\n\n        // A.2 No, collateral can not cover the entire debt. Seize all of it.\n        return _liquidateExactSeize(\n            buffer,\n            trader,\n            maxRepay,\n            idx,\n            margin[idx][trader].toUint256()\n        );\n    }\n\n    function _liquidateExactRepay(\n        LiquidationBuffer memory buffer,\n        address trader,\n        uint repay,\n        uint idx,\n        uint minSeizeAmount\n    )\n        internal\n        returns (uint seized)\n    {\n        // determine the seizable collateral amount on the basis of the most recent chainlink price feed\n        seized = _min(\n            _scaleDecimals(repay * buffer.incentivePerDollar, buffer.decimals - 6) / buffer.priceCollateral,\n            // can't seize more than available\n            // this also protects the liquidator in the scenario that they were front-run and only a small seize isn't worth it for them\n            margin[idx][trader].toUint256()\n        );\n        require(seized >= minSeizeAmount, \"Not seizing enough\");\n        _executeLiquidation(trader, repay, idx, seized, buffer.repayAble);\n    }\n\n    function _liquidateExactSeize(\n        LiquidationBuffer memory buffer,\n        address trader,\n        uint maxRepay,\n        uint idx,\n        uint seize\n    )\n        internal\n        returns (uint repay)\n    {\n        repay = _seizeToRepay(buffer, seize);\n        require(repay <= maxRepay, \"Need to repay more to seize that much\");\n        _executeLiquidation(trader, repay, idx, seize, buffer.repayAble);\n    }\n\n    /**\n    * @dev reverts if margin account is not liquidatable\n    */\n    function _getLiquidationInfo(address trader, uint idx) internal view returns (LiquidationBuffer memory buffer) {\n        require(idx > VUSD_IDX && idx < supportedCollateral.length, \"collateral not seizable\");\n        (buffer.status, buffer.repayAble, buffer.incentivePerDollar) = isLiquidatable(trader, false);\n        if (buffer.status == IMarginAccount.LiquidationStatus.IS_LIQUIDATABLE) {\n            Collateral memory coll = supportedCollateral[idx];\n            buffer.priceCollateral = oracle.getUnderlyingPrice(address(coll.token)).toUint256();\n            buffer.decimals = coll.decimals;\n        }\n    }\n\n    /**\n    * @dev Peform the actual liquidation.\n    *   1. Pull the repay amount from liquidator's account and credit trader's VUSD margin\n    *   2. Debit the seize amount and transfer to liquidator\n    * @return The debt that is leftover to be paid\n    */\n    function _executeLiquidation(address trader, uint repay, uint idx, uint seize, uint repayAble)\n        internal\n        returns (uint /* left over repayable */)\n    {\n        if (repay == 0 || seize == 0) { // provides more flexibility, so prefer not reverting\n            return repayAble;\n        }\n\n        _transferInVusd(_msgSender(), repay);\n        margin[VUSD_IDX][trader] += repay.toInt256();\n\n        margin[idx][trader] -= seize.toInt256();\n        supportedCollateral[idx].token.safeTransfer(_msgSender(), seize);\n\n        emit MarginAccountLiquidated(trader, idx, seize, repay, _blockTimestamp());\n        return repayAble - repay; // will ensure that the liquidator isn't repaying more than user's debt (and seizing a bigger amount of their collateral)\n    }\n\n    function _seizeToRepay(LiquidationBuffer memory buffer, uint seize) internal pure returns (uint repay) {\n        repay = seize * buffer.priceCollateral / (10 ** buffer.decimals);\n        if (buffer.incentivePerDollar > 0) {\n            repay = repay * PRECISION / buffer.incentivePerDollar;\n        }\n    }\n\n    /* ****************** */\n    /*        View        */\n    /* ****************** */\n\n    function getSpotCollateralValue(address trader) override public view returns(int256 spot) {\n        (,spot) = weightedAndSpotCollateral(trader);\n    }\n\n    function getNormalizedMargin(address trader) override public view returns(int256 weighted) {\n        (weighted,) = weightedAndSpotCollateral(trader);\n    }\n\n    function weightedAndSpotCollateral(address trader)\n        public\n        view\n        returns (int256 weighted, int256 spot)\n    {\n        Collateral[] memory assets = supportedCollateral;\n        Collateral memory _collateral;\n\n        for (uint i; i < assets.length; i++) {\n            if (margin[i][trader] == 0) continue;\n            _collateral = assets[i];\n\n            int numerator = margin[i][trader] * oracle.getUnderlyingPrice(address(assets[i].token));\n            uint denomDecimals = _collateral.decimals;\n\n            spot += (numerator / int(10 ** denomDecimals));\n            weighted += (numerator * _collateral.weight.toInt256() / int(10 ** (denomDecimals + 6)));\n        }\n    }\n\n    /* ****************** */\n    /*     UI Helpers     */\n    /* ****************** */\n\n    function supportedAssets() external view override returns (Collateral[] memory) {\n        return supportedCollateral;\n    }\n\n    function supportedAssetsLen() override external view returns (uint) {\n        return supportedCollateral.length;\n    }\n\n    /* ****************** */\n    /*    Misc Internal   */\n    /* ****************** */\n\n    function _addCollateral(address _coin, uint _weight) internal {\n        require(_weight <= PRECISION, \"weight > 1e6\");\n\n        Collateral[] memory _collaterals = supportedCollateral;\n        for (uint i; i < _collaterals.length; i++) {\n            require(address(_collaterals[i].token) != _coin, \"collateral exists\");\n        }\n        supportedCollateral.push(\n            Collateral({\n                token: IERC20(_coin),\n                weight: _weight,\n                decimals: ERC20Detailed(_coin).decimals() // will fail if .decimals() is not defined on the contract\n            })\n        );\n    }\n\n    function _scaleDecimals(uint256 amount, uint8 decimals) internal pure returns(uint256) {\n        return amount * (10 ** decimals);\n    }\n\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function _removeMarginFor(uint idx, uint amount, address trader, address receiver) internal {\n        _validateRemoveMargin(idx, amount, trader);\n\n        if (idx == VUSD_IDX) {\n            _transferOutVusd(receiver, amount);\n        } else {\n            supportedCollateral[idx].token.safeTransfer(receiver, amount);\n        }\n        emit MarginRemoved(trader, idx, amount, _blockTimestamp());\n    }\n\n    function _transferInVusd(address from, uint amount) internal {\n        IERC20(address(vusd)).safeTransferFrom(from, address(this), amount);\n        if (credit > 0) {\n            uint toBurn = Math.min(vusd.balanceOf(address(this)), credit);\n            credit -= toBurn;\n            vusd.burn(toBurn);\n        }\n    }\n\n    function _transferOutVusd(address recipient, uint amount) internal {\n        uint bal = vusd.balanceOf(address(this));\n        if (bal < amount) {\n            // Say there are 2 traders, Alice and Bob.\n            // Alice has a profitable position and realizes their PnL in form of vusd margin.\n            // But bob has not yet realized their -ve PnL.\n            // In that case we'll take a credit from vusd contract, which will eventually be returned when Bob pays their debt back.\n            uint _credit = amount - bal;\n            credit += _credit;\n            vusd.mint(address(this), _credit);\n        }\n        IERC20(address(vusd)).safeTransfer(recipient, amount);\n    }\n\n    function _validateRemoveMargin(uint idx, uint256 amount, address trader) internal {\n        require(amount != 0, 'Remove non-zero margin');\n\n        // credit funding payments\n        clearingHouse.updatePositions(trader);\n        // Consider unrealized PnL only when removing VUSD margin\n        (,int unrealizedPnl) = clearingHouse.getTotalNotionalPositionAndUnrealizedPnl(\n            trader,\n            getNormalizedMargin(trader),\n            IClearingHouse.Mode.Min_Allowable_Margin\n        );\n\n        if (idx == VUSD_IDX) {\n            require(margin[VUSD_IDX][trader] + unrealizedPnl >= amount.toInt256(), \"Insufficient balance\");\n        } else {\n            require(margin[idx][trader] >= amount.toInt256(), \"Insufficient balance\");\n        }\n        margin[idx][trader] -= amount.toInt256();\n\n        // assert that available margin > 0 after removing margin, this will ensure that user's pending orders are fillable after withdrawal\n        require(getAvailableMargin(trader) >= 0, \"MA: available margin < 0, withdrawing too much\");\n\n        // Check minimum margin requirement after withdrawal\n        clearingHouse.assertMarginRequirement(trader);\n    }\n\n    /* ****************** */\n    /*     Governance     */\n    /* ****************** */\n\n    function syncDeps(address _registry, uint _liquidationIncentive) public onlyGovernance {\n        // protecting against setting a very high liquidation incentive. Max 10%\n        require(_liquidationIncentive <= PRECISION / 10, \"MA.syncDeps.LI_GT_10_percent\");\n        IRegistry registry = IRegistry(_registry);\n        require(registry.marginAccount() == address(this), \"Incorrect setup\");\n\n        clearingHouse = IClearingHouse(registry.clearingHouse());\n        orderBook = IOrderBook(registry.orderBook());\n        oracle = IOracle(registry.oracle());\n        insuranceFund = IInsuranceFund(registry.insuranceFund());\n        liquidationIncentive = _liquidationIncentive;\n        marginAccountHelper = registry.marginAccountHelper();\n    }\n\n    function whitelistCollateral(address _coin, uint _weight) external onlyGovernance {\n        _addCollateral(_coin, _weight);\n    }\n\n    // function to change weight of an asset\n    function changeCollateralWeight(uint idx, uint _weight) external onlyGovernance {\n        require(_weight <= PRECISION, \"weight > 1e6\");\n        require(idx < supportedCollateral.length, \"Collateral not supported\");\n        supportedCollateral[idx].weight = _weight;\n    }\n\n    function setBibliophile(address _bibliophile) external onlyGovernance {\n        bibliophile = IHubbleBibliophile(_bibliophile);\n    }\n\n    function updateParams(uint _minAllowableMargin) external onlyClearingHouse {\n        minAllowableMargin = _minAllowableMargin;\n    }\n}"
    },
    {
      "filename": "hubble-protocol/contracts/MarginAccount.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport { MetaHubbleBase } from \"./legos/HubbleBase.sol\";\nimport {\n    ERC20Detailed,\n    IClearingHouse,\n    IInsuranceFund,\n    IOracle,\n    IRegistry,\n    IMarginAccount,\n    IERC20FlexibleSupply,\n    IWAVAX,\n    IOrderBook\n} from \"./Interfaces.sol\";\nimport { IHubbleBibliophile } from \"./precompiles/IHubbleBibliophile.sol\";\n\n/**\n* @title This contract is used for posting margin (collateral), realizing PnL etc.\n* @notice Most notable operations include addMargin, removeMargin and liquidations\n*/\ncontract MarginAccount is IMarginAccount, MetaHubbleBase, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    // Hubble vUSD is necessitated to be the first whitelisted collateral\n    uint constant VUSD_IDX = 0;\n    uint constant WAVAX_IDX = 1; // assumes wavax index = 1\n\n    // used for all usd based values\n    uint constant PRECISION = 1e6;\n\n    error NOT_LIQUIDATABLE(IMarginAccount.LiquidationStatus);\n\n    /**\n    * @dev This is only used to group variables to avoid a solidity stack too deep error\n    *   incentivePerDollar How many $ liquidator gets for each $ they repay e.g. they might get $1.05 for every $1 liquidation. >= PRECISION\n    *   repayAble The maximum debt that can be settled for an account undergoing a liquidation\n    *   priceCollateral Most recent oracle price (chainlink) of the collateral that is being seized for an account undergoing a liquidation\n    *   decimals Decimals for the collateral being seized\n    */\n    struct LiquidationBuffer {\n        LiquidationStatus status;\n        uint8 decimals;\n        uint incentivePerDollar;\n        uint repayAble;\n        uint priceCollateral;\n    }\n\n    /* ****************** */\n    /*       Storage      */\n    /* ****************** */\n\n    IClearingHouse public clearingHouse;\n    IOrderBook public orderBook;\n    IOracle public oracle;\n    IInsuranceFund public insuranceFund;\n    IERC20FlexibleSupply public vusd;\n    uint public credit;\n\n    /// @notice Array of supported collateral\n    Collateral[] public supportedCollateral;\n\n    /**\n    * @notice How many $ liquidator gets for each $ they repay e.g. they might get $1.05 for every $1 liquidation\n    * @dev In the above scenario, this value will be %0.05 i.e. 5 cents incentive per dollar repayed\n    */\n    uint public liquidationIncentive;\n\n    /**\n    * @notice Maps index in supportedCollateral => trader => balance\n    * @dev equivalent to margin(uint idx, address user)\n    */\n    mapping(uint => mapping(address => int)) override public margin; // SLOT_10 !!! used in precompile !!!\n\n    /**\n    * @notice Maps trader => reserved margin for open orders\n    */\n    mapping(address => uint) public reservedMargin;\n    uint public minAllowableMargin;\n    address public marginAccountHelper;\n    IHubbleBibliophile public bibliophile;\n\n    uint256[50] private __gap;\n\n    modifier onlyClearingHouse() {\n        require(_msgSender() == address(clearingHouse), \"Only clearingHouse\");\n        _;\n    }\n\n    modifier onlyOrderBook() {\n        require(_msgSender() == address(orderBook"
    }
  ]
}