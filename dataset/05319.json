{
  "Title": "[G-08]  State variables should be cached in stack variables rather than re-reading them from storage",
  "Content": "The instances below point to the second+ access of a state variable within a function. Caching of a state variable replaces each Gwarmaccess (100 gas) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variables.\n\n### 5 Instances\n\n1. ### Refactor `Admin.requestPermissions()`  to avoid 6 `SLOAD(Gwarmaccess)`\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L74-#L81\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L83-#L86\n\nWe can reduce the gas cost of the `requestPermissions()` function by reducing the number of storage reads (`SLOAD`) for the state variables `STORE` and `ESCRW`. The value of the `STORE` and `ESCRW` state variables should be cached stack variables then the stack variables be used for subsequent reads of the `STORE` and `ESCRW` state variable. In implementing this we replace 6 `SLOAD`s(cold acess) `100` gas units with  much cheaper 6 `MLOAD` `18` gas units: The diff below shows how the code could be refactored:\n\n<details>\n\n```solidity\nfile: src/policies/Admin.sol\n\n64:    function requestPermissions()\n65:        external\n66:        view\n67:        override\n68:        onlyKernel\n69:        returns (Permissions[] memory requests)\n70:    {\n71:        requests = new Permissions[](8);\n72:        requests[0] = Permissions(\n73:            toKeycode(\"STORE\"),\n74:            STORE.toggleWhitelistExtension.selector  //@audit STORE 1st SLOAD\n75:        );\n76:        requests[1] = Permissions(\n77:            toKeycode(\"STORE\"),\n78:            STORE.toggleWhitelistDelegate.selector  //@audit STORE 2nd SLOAD\n79:        );\n80:        requests[2] = Permissions(toKeycode(\"STORE\"), STORE.upgrade.selector);  //@audit STORE 3rd SLOAD\n81:        requests[3] = Permissions(toKeycode(\"STORE\"), STORE.freeze.selector);  //@audit STORE 4th SLOAD\n82:\n83:        requests[4] = Permissions(toKeycode(\"ESCRW\"), ESCRW.skim.selector);  //@audit ESCRW 1st SLOAD\n84:        requests[5] = Permissions(toKeycode(\"ESCRW\"), ESCRW.setFee.selector);  //@audit ESCRW 2nd SLOAD\n85:        requests[6] = Permissions(toKeycode(\"ESCRW\"), ESCRW.upgrade.selector);  //@audit ESCRW 3rd SLOAD\n86:        requests[7] = Permissions(toKeycode(\"ESCRW\"), ESCRW.freeze.selector);  //@audit ESCRW 4th SLOAD\n87:    }\n```\n```diff\ndiff --git a/src/policies/Admin.sol b/src/policies/Admin.sol\nindex b37d47f..4e277f7 100644\n--- a/src/policies/Admin.sol\n+++ b/src/policies/Admin.sol\n@@ -69,21 +69,23 @@ contract Admin is Policy {\n         returns (Permissions[] memory requests)\n     {\n         requests = new Permissions[](8);\n+        Storage _store = STORE;\n+        PaymentEscrow _escrw = ESCRW;\n         requests[0] = Permissions(\n             toKeycode(\"STORE\"),\n-            STORE.toggleWhitelistExtension.selector\n+            _store.toggleWhitelistExtension.selector\n         );\n         requests[1] = Permissions(\n             toKeycode(\"STORE\"),\n-            STORE.toggleWhitelistDelegate.selector\n+            _store.toggleWhitelistDelegate.selector\n         );\n-        requests[2] = Permissions(toKeycode(\"STORE\"), STORE.upgrade.selector);\n-        requests[3] = Permissions(toKeycode(\"STORE\"), STORE.freeze.selector);\n+        requests[2] = Permissions(toKeycode(\"STORE\"), _store.upgrade.selector);\n+        requests[3] = Permissions(toKeycode(\"STORE\"), _store.freeze.selector);\n\n-        requests[4] = Permissions(toKeycode(\"ESCRW\"), ESCRW.skim.selector);\n-        requests[5] = Permissions(toKeycode(\"ESCRW\"), ESCRW.setFee.selector);\n-        requests[6] = Permissions(toKeycode(\"ESCRW\"), ESCRW.upgrade.selector);\n-        requests[7] = Permissions(toKeycode(\"ESCRW\"), ESCRW.freeze.selector);\n+        requests[4] = Permissions(toKeycode(\"ESCRW\"), _escrw.skim.selector);\n+        requests[5] = Permissions(toKeycode(\"ESCRW\"), _escrw.setFee.selector);\n+        requests[6] = Permissions(toKeycode(\"ESCRW\"), _escrw.upgrade.selector);\n+        requests[7] = Permissions(toKeycode(\"ESCRW\"), _escrw.freeze.selector);\n     }\n```\n```\nEstimated gas saved: 582 gas units\n```\n\n</details>\n\n2. ### Refactor `Factory.deployRentalSafe()`  to avoid 1 `SLOAD(Gwarmaccess)`\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L189\n\nWe can reduce the gas cost of the `deployRentalSafe()` function by reducing the number of storage reads (`SLOAD`) for the state variable `STORE`. The value of the `STORE` state variable should be cached in a stack variable then the stack variable be used for subsequent reads of the `STORE` state variable. In implementing this we replace 1 `SLOAD`s(cold acess) `100` gas units with  much cheaper 1 `MLOAD` `3` gas units: The diff below shows how the code could be refactored:\n\n<details>\n\n```solidity\nfile: src/policies/Factory.sol\n\n138:    function deployRentalSafe(\n139:        address[] calldata owners,\n140:        uint256 threshold\n141:    ) external returns (address safe) {\n142:        // Require that the threshold is valid.\n143:        if (threshold == 0 || threshold > owners.length) {\n144:            revert Errors.FactoryPolicy_InvalidSafeThreshold(threshold, owners.length);\n145:        }\n.\n.\n.\n180:        safe = address(\n181:            safeProxyFactory.createProxyWithNonce(\n182:                address(safeSingleton),\n183:                initializerPayload,\n184:                uint256(keccak256(abi.encode(STORE.totalSafes() + 1, block.chainid)))  //@audit STORE 1st SLOAD\n185:            )\n186:        );\n187:\n188:        // Store the deployed safe.\n189:        STORE.addRentalSafe(safe);  //@audit STORE 2nd SLOAD\n190:\n191:        // Emit the event.\n192:        emit Events.RentalSafeDeployment(safe, owners, threshold);\n193:    }\n```\n```diff\ndiff --git a/src/policies/Factory.sol b/src/policies/Factory.sol\nindex 8401ad7..f019f3c 100644\n--- a/src/policies/Factory.sol\n+++ b/src/policies/Factory.sol\n@@ -174,6 +174,7 @@ contract Factory is Policy {\n             )\n         );\n\n+        Storage _store = STORE;\n         // Deploy a safe proxy using initializer values for the Safe.setup() call\n         // with a salt nonce that is unique to each chain to guarantee cross-chain\n         // unique safe addresses.\n@@ -181,12 +182,12 @@ contract Factory is Policy {\n             safeProxyFactory.createProxyWithNonce(\n                 address(safeSingleton),\n                 initializerPayload,\n-                uint256(keccak256(abi.encode(STORE.totalSafes() + 1, block.chainid)))\n+                uint256(keccak256(abi.encode(_store.totalSafes() + 1, block.chainid)))\n             )\n         );\n\n         // Store the deployed safe.\n-        STORE.addRentalSafe(safe);\n+        _store.addRentalSafe(safe);\n\n         // Emit the event.\n         emit Events.RentalSafeDeployment(safe, owners, threshold);\n```\n```\nEstimated gas saved: 97\n```\n\n</details>\n\n3. ### Refactor `Guard.requestPermissions()`  to avoid 1 `SLOAD(Gwarmaccess)`\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L93\n\nWe can reduce the gas cost of the `requestPermissions()` function by reducing the number of storage reads (`SLOAD`) for the state variable `STORE`. The value of the `STORE` state variable should be cached in a stack variable then the stack variable be used for subsequent reads of the `STORE` state variable. In implementing this we replace 1 `SLOAD`s(cold acess) `100` gas units with  much cheaper 1 `MLOAD` `3` gas units: The diff below shows how the code could be refactored:\n\n<details>\n\n```solidity\nfile: src/policies/Guard.sol\n\n84:    function requestPermissions()\n85:        external\n86:        view\n87:        override\n88:        onlyKernel\n89:        returns (Permissions[] memory requests)\n90:    {\n91:        requests = new Permissions[](2);\n92:        requests[0] = Permissions(toKeycode(\"STORE\"), STORE.updateHookPath.selector);  //@audit STORE 1st SLOAD\n93:        requests[1] = Permissions(toKeycode(\"STORE\"), STORE.updateHookStatus.selector);  //@audit STORE 2nd SLOAD\n94:    }\n```\n\n```diff\ndiff --git a/src/policies/Guard.sol b/src/policies/Guard.sol\nindex a0a565a..053e45e 100644\n--- a/src/policies/Guard.sol\n+++ b/src/policies/Guard.sol\n@@ -88,9 +88,10 @@ contract Guard is Policy, BaseGuard {\n         onlyKernel\n         returns (Permissions[] memory requests)\n     {\n+        Storage _store = STORE;\n         requests = new Permissions[](2);\n-        requests[0] = Permissions(toKeycode(\"STORE\"), STORE.updateHookPath.selector);\n-        requests[1] = Permissions(toKeycode(\"STORE\"), STORE.updateHookStatus.selector);\n+        requests[0] = Permissions(toKeycode(\"STORE\"), _store.updateHookPath.selector);\n+        requests[1] = Permissions(toKeycode(\"STORE\"), _store.updateHookStatus.selector);\n     }\n\n     /////////////////////////////////////////////////////////////////////////////////\n```\n```\nEstimated gas saved: 97 gas units\n```\n</details\n\n4. ### Refactor `Guard.checkTransaction()`  to avoid 2 `SLOAD(Gwarmaccess)`\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L335\n\nWe can reduce the gas cost of the `checkTransaction()` function by reducing the number of storage reads (`SLOAD`) for the state variable `STORE`. The value of the `STORE` state variable should be cached in a stack variable then the stack variable be used for subsequent reads of the `STORE` state variable. In implementing this we replace 2 `SLOAD`s(cold acess) `200` gas units with  much cheaper 2 `MLOAD` `6` gas units: The diff below shows how the code could be refactored:\n\n<details>\n\n```solidity\nfile: src/policies/Guard.sol\n\n309:    function checkTransaction(\n310:        address to,\n311:        uint256 value,\n312:        bytes memory data,\n313:        Enum.Operation operation,\n314:        uint256,\n315:        uint256,\n316:        uint256,\n317:        address,\n318:       address payable,\n319:        bytes memory,\n320:        address\n321:    ) external override {\n322:        // Disallow transactions that use delegate call, unless explicitly\n323:        // permitted by the protocol.\n324:        if (operation == Enum.Operation.DelegateCall && !STORE.whitelistedDelegates(to)) {  //@audit STORE 1st SLOAD\n325:            revert Errors.GuardPolicy_UnauthorizedDelegateCall(to);\n326:        }\n327:\n328:        // Require that a function selector exists.\n329:        if (data.length < 4) {\n330:            revert Errors.GuardPolicy_FunctionSelectorRequired();\n331:        }\n332:\n333:        // Fetch the hook to interact with for this transaction.\n334:        address hook = STORE.contractToHook(to);  //@audit STORE 2nd SLOAD\n335:        bool isActive = STORE.hookOnTransaction(hook);  //@audit STORE 3rd SLOAD\n.\n.\n.\n345:    }\n```\n\n```diff\ndiff --git a/src/policies/Guard.sol b/src/policies/Guard.sol\nindex a0a565a..c24619f 100644\n--- a/src/policies/Guard.sol\n+++ b/src/policies/Guard.sol\n@@ -319,9 +319,11 @@ contract Guard is Policy, BaseGuard {\n         bytes memory,\n         address\n     ) external override {\n+\n+        Storage _store = STORE;\n         // Disallow transactions that use delegate call, unless explicitly\n         // permitted by the protocol.\n-        if (operation == Enum.Operation.DelegateCall && !STORE.whitelistedDelegates(to)) {\n+        if (operation == Enum.Operation.DelegateCall && !_store.whitelistedDelegates(to)) {\n             revert Errors.GuardPolicy_UnauthorizedDelegateCall(to);\n         }\n\n@@ -331,8 +333,8 @@ contract Guard is Policy, BaseGuard {\n         }\n\n         // Fetch the hook to interact with for this transaction.\n-        address hook = STORE.contractToHook(to);\n-        bool isActive = STORE.hookOnTransaction(hook);\n+        address hook = _store.contractToHook(to);\n+        bool isActive = _store.hookOnTransaction(hook);\n\n         // If a hook exists and is enabled, forward the control flow to the hook.\n         if (hook != address(0) && isActive) {\n```\n```\nEstimated gas saved: 194 gas units saved\n```\n</details>\n\n\n5. ### Refactor `Stop.requestPermissions()`  to avoid 2 `SLOAD(Gwarmaccess)`\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L96\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L98\n\nWe can reduce the gas cost of the `requestPermissions()` function by reducing the number of storage reads (`SLOAD`) for the state variables `STORE` and `ESCRW`. The value of the `STORE` and `ESCRW` state variables should be cached stack variables then the stack variables be used for subsequent reads of the `STORE` and `ESCRW` state variable. In implementing this we replace 2 `SLOAD`s(cold acess) `200` gas units with  much cheaper 2 `MLOAD` `6` gas units: The diff below shows how the code could be refactored:\n\n<details>\n\n```solidity\nfile: src/policies/Stop.sol\n\n87:    function requestPermissions()\n88:        external\n89:        view\n90:        override\n91:        onlyKernel\n92:        returns (Permissions[] memory requests)\n93:    {\n94:        requests = new Permissions[](4);\n95:        requests[0] = Permissions(toKeycode(\"STORE\"), STORE.removeRentals.selector);  //@audit STORE 1st SLOAD\n96:        requests[1] = Permissions(toKeycode(\"STORE\"), STORE.removeRentalsBatch.selector);  //@audit STORE 2nd SLOAD\n97:        requests[2] = Permissions(toKeycode(\"ESCRW\"), ESCRW.settlePayment.selector);  //@audit ESCRW 1st SLOAD\n98:        requests[3] = Permissions(toKeycode(\"ESCRW\"), ESCRW.settlePaymentBatch.selector);  //@audit ESCRW 2nd SLOAD\n99:    }\n```\n\n```diff\ndiff --git a/src/policies/Stop.sol b/src/policies/Stop.sol\nindex ab240ba..ad7cee5 100644\n--- a/src/policies/Stop.sol\n+++ b/src/policies/Stop.sol\n@@ -92,10 +92,13 @@ contract Stop is Policy, Signer, Reclaimer, Accumulator {\n         returns (Permissions[] memory requests)\n     {\n         requests = new Permissions[](4);\n-        requests[0] = Permissions(toKeycode(\"STORE\"), STORE.removeRentals.selector);\n-        requests[1] = Permissions(toKeycode(\"STORE\"), STORE.removeRentalsBatch.selector);\n-        requests[2] = Permissions(toKeycode(\"ESCRW\"), ESCRW.settlePayment.selector);\n-        requests[3] = Permissions(toKeycode(\"ESCRW\"), ESCRW.settlePaymentBatch.selector);\n+        Storage _store = STORE;\n+        PaymentEscrow _escrw = ESCRW;\n+\n+        requests[0] = Permissions(toKeycode(\"STORE\"), _store.removeRentals.selector);\n+        requests[1] = Permissions(toKeycode(\"STORE\"), _store.removeRentalsBatch.selector);\n+        requests[2] = Permissions(toKeycode(\"ESCRW\"), _escrw.settlePayment.selector);\n+        requests[3] = Permissions(toKeycode(\"ESCRW\"), _escrw.settlePaymentBatch.selector);\n     }\n```\n```\nEstimated gas saved: 194 gas units\n```\n\n</details>\n\n## Conclusion\nAs you embark on incorporating the recommended optimizations, we want to emphasize the utmost importance of proceeding with vigilance and dedicating thorough efforts to comprehensive testing. It is of paramount significance to ensure that the proposed alterations do not inadvertently introduce fresh vulnerabilities, while also successfully achieving the anticipated enhancements in performance.\n\nWe strongly advise conducting a meticulous and exhaustive evaluation of the modifications made to the codebase. This rigorous scrutiny and exhaustive assessment will play a pivotal role in affirming both the security and efficacy of the refactored code. Your careful attention to detail, coupled with the implementation of a robust testing framework, will provide the necessary assurance that the refined code aligns with your security objectives and effectively fulfills the intended performance optimizations.\n\n**[Alec1017 (reNFT) confirmed](https://github.com/code-423n4/2024-01-renft-findings/issues/560#issuecomment-1910731385)**\n\n***\n\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-01-renft",
  "Code": [
    {
      "filename": "src/policies/Admin.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\";\nimport {toKeycode} from \"@src/libraries/KernelUtils.sol\";\nimport {Storage} from \"@src/modules/Storage.sol\";\nimport {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\n\n/**\n * @title Admin\n * @notice Acts as an interface for all behavior in the protocol related\n *         admin logic. Admin duties include fee management, proxy management,\n *         and whitelist management.\n */\ncontract Admin is Policy {\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Modules that the policy depends on.\n    Storage public STORE;\n    PaymentEscrow public ESCRW;\n\n    /**\n     * @dev Instantiate this contract as a policy.\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) Policy(kernel_) {}\n\n    /**\n     * @notice Upon policy activation, configures the modules that the policy depends on.\n     *         If a module is ever upgraded that this policy depends on, the kernel will\n     *         call this function again to ensure this policy has the current address\n     *         of the module.\n     *\n     * @return dependencies Array of keycodes which represent modules that\n     *                      this policy depends on.\n     */\n    function configureDependencies()\n        external\n        override\n        onlyKernel\n        returns (Keycode[] memory dependencies)\n    {\n        dependencies = new Keycode[](2);\n\n        dependencies[0] = toKeycode(\"STORE\");\n        STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n\n        dependencies[1] = toKeycode(\"ESCRW\");\n        ESCRW = PaymentEscrow(getModuleAddress(toKeycode(\"ESCRW\")));\n    }\n\n    /**\n     * @notice Upon policy activation, permissions are requested from the kernel to access\n     *         particular keycode <> function selector pairs. Once these permissions are\n     *         granted, they do not change and can only be revoked when the policy is\n     *         deactivated by the kernel.\n     *\n     * @return requests Array of keycode <> function selector pairs which represent\n     *                  permissions for the policy.\n     */\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](8);\n        requests[0] = Permissions(\n            toKeycode(\"STORE\"),\n            STORE.toggleWhitelistExtension.selector\n        );\n        requests[1] = Permissions(\n            toKeycode(\"STORE\"),\n            STORE.toggleWhitelistDelegate.selector\n        );\n        requests[2] = Permissions(toKeycode(\"STORE\"), STORE.upgrade.selector);\n        requests[3] = Permissions(toKeycode(\"STORE\"), STORE.freeze.selector);\n\n        requests[4] = Permissions(toKeycode(\"ESCRW\"), ESCRW.skim.selector);\n        requests[5] = Permissions(toKeycode(\"ESCRW\"), ESCRW.setFee.selector);\n        requests[6] = Permissions(toKeycode(\"ESCRW\"), ESCRW.upgrade.selector);\n        requests[7] = Permissions(toKeycode(\"ESCRW\"), ESCRW.freeze.selector);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            External Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Toggle whether an address can be delegate called by a rental safe.\n     *\n     * @param delegate  Target address for the delegate call.\n     * @param isEnabled Whether the address can be delegate called.\n     */\n    function toggleWhitelistDelegate(\n        address delegate,\n        bool isEnabled\n    ) external onlyRole(\"ADMIN_ADMIN\") {\n        STORE.toggleWhitelistDelegate(delegate, isEnabled);\n    }\n\n    /**\n     * @notice Toggle whether an extension is whitelisted. An extension is any contract\n     *         which can be added to a rental safe as a Safe module.\n     *\n     * @param extension Extension which can be added to a safe.\n     * @param isEnabled Whether the extension is enabled.\n     */\n    function toggleWhitelistExtension(\n        address extension,\n        bool isEnabled\n    ) external onlyRole(\"ADMIN_ADMIN\") {\n        STORE.toggleWhitelistExtension(extension, isEnabled);\n    }\n\n    /**\n     * @notice Upgrades the storage module to a newer implementation. The new\n     *         implementation contract must adhere to ERC-1822.\n     *\n     * @param newImplementation Address of the new implemention.\n     */\n    function upgradeStorage(address newImplementation) external onlyRole(\"ADMIN_ADMIN\") {\n        STORE.upgrade(newImplementation);\n    }\n\n    /**\n     * @notice Freezes the storage module so that no proxy upgrades can take place. This\n     *         action is non-reversible.\n     */\n    function freezeStorage() external onlyRole(\"ADMIN_ADMIN\") {\n        STORE.freeze();\n    }\n\n    /**\n     * @notice Upgrades the payment escrow module to a newer implementation.\n     *         The new implementation contract must adhere to ERC-1822.\n     *\n     * @param newImplementation Address of the new implemention.\n     */\n    function upgradePaymentEscrow(\n        address newImplementation\n    ) external onlyRole(\"ADMIN_ADMIN\") {\n        ESCRW.upgrade(newImplementation);\n    }\n\n    /**\n     * @notice Freezes the payment escrow module so that no proxy upgrades can take\n     *         place. This action is non-reversible.\n     */\n    function freezePaymentEscrow() external onlyRole(\"ADMIN_ADMIN\") {\n        ESCRW.freeze();\n    }\n\n    /**\n     * @notice Skims all protocol fees from the escrow module to the target address.\n     *\n     * @param token Token address which denominates the fee.\n     * @param to    Destination address to send the tokens.\n     */\n    function skim(address token, address to) external onlyRole(\"ADMIN_ADMIN\") {\n        ESCRW.skim(token, to);\n    }\n\n    /**\n     * @notice Sets the protocol fee numerator. Numerator cannot be greater than 10,000.\n     *\n     * @param feeNumerator Numerator for the fee.\n     */\n    function setFee(uint256 feeNumerator) external onlyRole(\"ADMIN_ADMIN\") {\n        ESCRW.setFee(feeNumerator);\n    }\n}"
    },
    {
      "filename": "src/policies/Admin.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\";\nimport {toKeycode} from \"@src/libraries/KernelUtils.sol\";\nimport {Storage} from \"@src/modules/Storage.sol\";\nimport {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\n\n/**\n * @title Admin\n * @notice Acts as an interface for all behavior in the protocol related\n *         admin logic. Admin duties include fee management, proxy management,\n *         and whitelist management.\n */\ncontract Admin is Policy {\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Modules that the policy depends on.\n    Storage public STORE;\n    PaymentEscrow public ESCRW;\n\n    /**\n     * @dev Instantiate this contract as a policy.\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) Policy(kernel_) {}\n\n    /**\n     * @notice Upon policy activation, configures the modules that the policy depends on.\n     *         If a module is ever upgraded that this policy depends on, the kernel will\n     *         call this function again to ensure this policy has the current address\n     *         of the module.\n     *\n     * @return dependencies Array of keycodes which represent modules that\n     *                      this policy depends on.\n     */\n    function configureDependencies()\n        external\n        override\n        onlyKernel\n        returns (Keycode[] memory dependencies)\n    {\n        dependencies = new Keycode[](2);\n\n        dependencies[0] = toKeycode(\"STORE\");\n        STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n\n        dependencies[1] = toKeycode(\"ESCRW\");\n        ESCRW = PaymentEscrow(getModuleAddress(toKeycode(\"ESCRW\")));\n    }\n\n    /**\n     * @notice Upon policy activation, permissions are requested from the kernel to access\n     *         particular keycode <> function selector pairs. Once these permissions are\n     *         granted, they do not change and can only be revoked when the policy is\n     *         deactivated by the kernel.\n     *\n     * @return requests Array of keycode <> function selector pairs which represent\n     *                  permissions for the policy.\n     */\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](8);\n        requests[0] = Permissions(\n            toKeycode(\"STORE\"),\n            STORE.toggleWhitelistExtension.selector\n        );\n        requests[1] = Permissions(\n            toKeycode(\"STORE\"),\n            STORE.toggleWhitelistDelegate.selector\n        );\n        requests[2] = Permissions(toKeycode(\"STORE\"), STORE.upgrade.selector);\n        requests[3] = Permissions(toKeycode(\"STORE\"), STORE.freeze.selector);\n\n        requests[4] = Permissions(toKeycode(\"ESCRW\"), ESCRW.skim.selector);\n        requests[5] = Permissions(toKeycode(\"ESCRW\"), ESCRW.setFee.selector);\n        requests[6] = Permissions(toKeycode(\"ESCRW\"), ESCRW.upgrade.selector);\n        requests[7] = Permissions(toKeycode(\"ESCRW\"), ESCRW.freeze.selector);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            External Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Toggle whether an address can be delegate called by a rental safe.\n     *\n     * @param delegate  Target address for the delegate call.\n     * @param isEnabled Whether the address can be delegate called.\n     */\n    function toggleWhitelistDelegate(\n        address delegate,\n        bool isEnabled\n    ) external onlyRole(\"ADMIN_ADMIN\") {\n        STORE.toggleWhitelistDelegate(delegate, isEnabled);\n    }\n\n    /**\n     * @notice Toggle whether an extension is whitelisted. An extension is any contract\n     *         which can be added to a rental safe as a Safe module.\n     *\n     * @param extension Extension which can be added to a safe.\n     * @param isEnabled Whether the extension is enabled.\n     */\n    function toggleWhitelistExtension(\n        address extension,\n        bool isEnabled\n    ) external onlyRole(\"ADMIN_ADMIN\") {\n        STORE.toggleWhitelistExtension(extension, isEnabled);\n    }\n\n    /**\n     * @notice Upgrades the storage module to a newer implementation. The new\n     *         implementation contract must adhere to ERC-1822.\n     *\n     * @param newImplementation Address of the new implemention.\n     */\n    function upgradeStorage(address newImplementation) external onlyRole(\"ADMIN_ADMIN\") {\n        STORE.upgrade(newImplementation);\n    }\n\n    /**\n     * @notice Freezes the storage module so that no proxy upgrades can take place. This\n     *         action is non-reversible.\n     */\n    function freezeStorage() external onlyRole(\"ADMIN_ADMIN\") {\n        STORE.freeze();\n    }\n\n    /**\n     * @notice Upgrades the payment escrow module to a newer implementation.\n     *         The new implementation contract must adhere to ERC-1822.\n     *\n     * @param newImplementation Address of the new implemention.\n     */\n    function upgradePaymentEscrow(\n        address newImplementation\n    ) external onlyRole(\"ADMIN_ADMIN\") {\n        ESCRW.upgrade(newImplementation);\n    }\n\n    /**\n     * @notice Freezes the payment escrow module so that no proxy upgrades can take\n     *         place. This action is non-reversible.\n     */\n    function freezePaymentEscrow() external onlyRole(\"ADMIN_ADMIN\") {\n        ESCRW.freeze();\n    }\n\n    /**\n     * @notice Skims all protocol fees from the escrow module to the target address.\n     *\n     * @param token Token address which denominates the fee.\n     * @param to    Destination address to send the tokens.\n     */\n    function skim(address token, address to) external onlyRole(\"ADMIN_ADMIN\") {\n        ESCRW.skim(token, to);\n    }\n\n    /**\n     * @notice Sets the protocol fee numerator. Numerator cannot be greater than 10,000.\n     *\n     * @param feeNumerator Numerator for the fee.\n     */\n    function setFee(uint256 feeNumerator) external onlyRole(\"ADMIN_ADMIN\") {\n        ESCRW.setFee(feeNumerator);\n    }\n}"
    },
    {
      "filename": "src/policies/Factory.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {SafeL2} from \"@safe-contracts/SafeL2.sol\";\nimport {SafeProxyFactory} from \"@safe-contracts/proxies/SafeProxyFactory.sol\";\nimport {TokenCallbackHandler} from \"@safe-contracts/handler/TokenCallbackHandler.sol\";\n\nimport {ISafe} from \"@src/interfaces/ISafe.sol\";\n\nimport {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\";\nimport {toKeycode} from \"@src/libraries/KernelUtils.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\nimport {Events} from \"@src/libraries/Events.sol\";\nimport {Storage} from \"@src/modules/Storage.sol\";\nimport {Stop} from \"@src/policies/Stop.sol\";\nimport {Guard} from \"@src/policies/Guard.sol\";\n\n/**\n * @title Factory\n * @notice Acts as an interface for all behavior related to deploying rental safes.\n */\ncontract Factory is Policy {\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Modules that the policy depends on.\n    Storage public STORE;\n\n    // policies.\n    Stop public immutable stopPolicy;\n    Guard public immutable guardPolicy;\n\n    // External contracts.\n    TokenCallbackHandler public immutable fallbackHandler;\n    SafeProxyFactory public immutable safeProxyFactory;\n    SafeL2 public immutable safeSingleton;\n\n    /**\n     * @dev Instantiate this contract as a policy.\n     *\n     * @param kernel_           Address of the kernel contract.\n     * @param stopPolicy_       Address of the stop policy.\n     * @param guardPolicy_      Address of the guard policy.\n     * @param fallbackHandler_  Gnosis safe fallback handler address.\n     * @param safeProxyFactory_ Gnosis safe proxy factory address.\n     * @param safeSingleton_    Gnosis safe logic contract address.\n     */\n    constructor(\n        Kernel kernel_,\n        Stop stopPolicy_,\n        Guard guardPolicy_,\n        TokenCallbackHandler fallbackHandler_,\n        SafeProxyFactory safeProxyFactory_,\n        SafeL2 safeSingleton_\n    ) Policy(kernel_) {\n        stopPolicy = stopPolicy_;\n        guardPolicy = guardPolicy_;\n        fallbackHandler = fallbackHandler_;\n        safeProxyFactory = safeProxyFactory_;\n        safeSingleton = safeSingleton_;\n    }\n\n    /**\n     * @notice Upon policy activation, configures the modules that the policy depends on.\n     *         If a module is ever upgraded that this policy depends on, the kernel will\n     *         call this function again to ensure this policy has the current address\n     *         of the module.\n     *\n     * @return dependencies Array of keycodes which represent modules that\n     *                      this policy depends on.\n     */\n    function configureDependencies()\n        external\n        override\n        onlyKernel\n        returns (Keycode[] memory dependencies)\n    {\n        dependencies = new Keycode[](1);\n\n        dependencies[0] = toKeycode(\"STORE\");\n        STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n    }\n\n    /**\n     * @notice Upon policy activation, permissions are requested from the kernel to access\n     *         particular keycode <> function selector pairs. Once these permissions are\n     *         granted, they do not change and can only be revoked when the policy is\n     *         deactivated by the kernel.\n     *\n     * @return requests Array of keycode <> function selector pairs which represent\n     *                  permissions for the policy.\n     */\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](1);\n        requests[0] = Permissions(toKeycode(\"STORE\"), STORE.addRentalSafe.selector);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            External Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Initializes a rental safe by setting it up with the stop policy and\n     *         rental guard during deployment.\n     *\n     *          Warning: This function assumes the invariant that delegate call will be\n     *          disabled or restricted by the guard policy. If delegate call were to be\n     *          freely allowed, then a safe could call this function after deployment\n     *          and change the module/guard contacts which would allow transferring\n     *          of rented assets out of the safe.\n     *\n     * @param _stopPolicy  Address of the stop policy to add as a module to the safe.\n     * @param _guardPolicy Address of the guard policy to add as a guard on the safe.\n     */\n    function initializeRentalSafe(address _stopPolicy, address _guardPolicy) external {\n        // Enable the module.\n        ISafe(address(this)).enableModule(_stopPolicy);\n\n        // Set the guard.\n        ISafe(address(this)).setGuard(_guardPolicy);\n    }\n\n    /**\n     * @notice Deploys and initializes a rental safe.\n     *\n     * @param owners    Array of owner addresses which will have the ability to sign\n     *                  transactions for the safe.\n     * @param threshold Number of signatures required to executed a transaction\n     *                  on the safe.\n     */\n    function deployRentalSafe(\n        address[] calldata owners,\n        uint256 threshold\n    ) external returns (address safe) {\n        // Require that the threshold is valid.\n        if (threshold == 0 || threshold > owners.length) {\n            revert Errors.FactoryPolicy_InvalidSafeThreshold(threshold, owners.length);\n        }\n\n        // Delegate call from the safe so that the rental manager module can be enabled\n        // right after the safe is deployed.\n        bytes memory data = abi.encodeCall(\n            Factory.initializeRentalSafe,\n            (address(stopPolicy), address(guardPolicy))\n        );\n\n        // Create gnosis initializer payload.\n        bytes memory initializerPayload = abi.encodeCall(\n            ISafe.setup,\n            (\n                // owners array.\n                owners,\n                // number of signatures needed to execute transactions.\n                threshold,\n                // Address to direct the payload to.\n                address(this),\n                // Encoded call to execute.\n                data,\n                // Fallback manager address.\n                address(fallbackHandler),\n                // Payment token.\n                address(0),\n                // Payment amount.\n                0,\n                // Payment receiver\n                payable(address(0))\n            )\n        );\n\n        // Deploy a safe proxy using initializer values for the Safe.setup() call\n        // with a salt nonce that is unique to each chain to guarantee cross-chain\n        // unique safe addresses.\n        safe = address(\n            safeProxyFactory.createProxyWithNonce(\n                address(safeSingleton),\n                initializerPayload,\n                uint256(keccak256(abi.encode(STORE.totalSafes() + 1, block.chainid)))\n            )\n        );\n\n        // Store the deployed safe.\n        STORE.addRentalSafe(safe);\n\n        // Emit the event.\n        emit Events.RentalSafeDeployment(safe, owners, threshold);\n    }\n}"
    },
    {
      "filename": "src/policies/Guard.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {BaseGuard} from \"@safe-contracts/base/GuardManager.sol\";\nimport {Enum} from \"@safe-contracts/common/Enum.sol\";\nimport {LibString} from \"@solady/utils/LibString.sol\";\n\nimport {IHook} from \"@src/interfaces/IHook.sol\";\nimport {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\";\nimport {toKeycode} from \"@src/libraries/KernelUtils.sol\";\nimport {Storage} from \"@src/modules/Storage.sol\";\nimport {\n    shared_set_approval_for_all_selector,\n    e721_approve_selector,\n    e721_safe_transfer_from_1_selector,\n    e721_safe_transfer_from_2_selector,\n    e721_transfer_from_selector,\n    e721_approve_token_id_offset,\n    e721_safe_transfer_from_1_token_id_offset,\n    e721_safe_transfer_from_2_token_id_offset,\n    e721_transfer_from_token_id_offset,\n    e1155_safe_transfer_from_selector,\n    e1155_safe_batch_transfer_from_selector,\n    e1155_safe_transfer_from_token_id_offset,\n    e1155_safe_batch_transfer_from_token_id_offset,\n    gnosis_safe_set_guard_selector,\n    gnosis_safe_enable_module_selector,\n    gnosis_safe_disable_module_selector,\n    gnosis_safe_enable_module_offset,\n    gnosis_safe_disable_module_offset\n} from \"@src/libraries/RentalConstants.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\n\n/**\n * @title Guard\n * @notice Acts as an interface for all behavior related to guarding transactions\n *         that originate from a rental wallet.\n */\ncontract Guard is Policy, BaseGuard {\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Modules that the policy depends on.\n    Storage public STORE;\n\n    /**\n     * @dev Instantiate this contract as a policy.\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) Policy(kernel_) {}\n\n    /**\n     * @notice Upon policy activation, configures the modules that the policy depends on.\n     *         If a module is ever upgraded that this policy depends on, the kernel will\n     *         call this function again to ensure this policy has the current address\n     *         of the module.\n     *\n     * @return dependencies Array of keycodes which represent modules that\n     *                      this policy depends on.\n     */\n    function configureDependencies()\n        external\n        override\n        onlyKernel\n        returns (Keycode[] memory dependencies)\n    {\n        dependencies = new Keycode[](1);\n\n        dependencies[0] = toKeycode(\"STORE\");\n        STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n    }\n\n    /**\n     * @notice Upon policy activation, permissions are requested from the kernel to access\n     *         particular keycode <> function selector pairs. Once these permissions are\n     *         granted, they do not change and can only be revoked when the policy is\n     *         deactivated by the kernel.\n     *\n     * @return requests Array of keycode <> function selector pairs which represent\n     *                  permissions for the policy.\n     */\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](2);\n        requests[0] = Permissions(toKeycode(\"STORE\"), STORE.updateHookPath.selector);\n        requests[1] = Permissions(toKeycode(\"STORE\"), STORE.updateHookStatus.selector);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            Internal Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Loads a `bytes32` value from calldata.\n     *\n     * @param data   Calldata of the transaction to execute.\n     * @param offset Byte offset where the value starts.\n     *\n     * @return value The value retrieved from the data.\n     */\n    function _loadValueFromCalldata(\n        bytes memory data,\n        uint256 offset\n    ) private pure returns (bytes32 value) {\n        // Load the `uint256` from calldata at the offset.\n        assembly {\n            value := mload(add(data, offset))\n        }\n    }\n\n    /**\n     * @dev Reverts if the token is actively rented.\n     *\n     * @param selector Function selector which cannot be called\n     * @param safe     Address of the safe that originated the call\n     * @param token    Address of the token which is actively rented.\n     * @param tokenId  ID of the token which is actively rented.\n     */\n    function _revertSelectorOnActiveRental(\n        bytes4 selector,\n        address safe,\n        address token,\n        uint256 tokenId\n    ) private view {\n        // Check if the selector is allowed.\n        if (STORE.isRentedOut(safe, token, tokenId)) {\n            revert Errors.GuardPolicy_UnauthorizedSelector(selector);\n        }\n    }\n\n    /**\n     * @dev Reverts if the extension is not whitelisted.\n     *\n     * @param extension Address of the extension.\n     */\n    function _revertNonWhitelistedExtension(address extension) private view {\n        // Check if the extension is whitelisted.\n        if (!STORE.whitelistedExtensions(extension)) {\n            revert Errors.GuardPolicy_UnauthorizedExtension(extension);\n        }\n    }\n\n    /**\n     * @dev Forwards a gnosis safe call to a hook contract for further processing.\n     *\n     * @param hook  Address of the hook contract.\n     * @param safe  Address of the rental wallet that originated the call.\n     * @param to    Address that the call is directed to.\n     * @param value Value of ether sent with the call.\n     * @param data  Calldata to execute.\n     */\n    function _forwardToHook(\n        address hook,\n        address safe,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) private {\n        // Call the `onTransaction` hook function.\n        try IHook(hook).onTransaction(safe, to, value, data) {} catch Error(\n            string memory revertReason\n        ) {\n            // Revert with reason given.\n            revert Errors.Shared_HookFailString(revertReason);\n        } catch Panic(uint256 errorCode) {\n            // Convert solidity panic code to string.\n            string memory stringErrorCode = LibString.toString(errorCode);\n\n            // Revert with panic code.\n            revert Errors.Shared_HookFailString(\n                string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n            );\n        } catch (bytes memory revertData) {\n            // Fallback to an error that returns the byte data.\n            revert Errors.Shared_HookFailBytes(revertData);\n        }\n    }\n\n    /**\n     * @dev Prevent transactions that involve transferring an ERC721 or ERC1155 in any\n     *      way, and prevent transactions that involve changing the modules or the\n     *      guard contract.\n     *\n     * @param from Rental safe address that initiated the transaction.\n     * @param to Address that the data is targetted to.\n     * @param data Calldata of the transaction.\n     */\n    function _checkTransaction(address from, address to, bytes memory data) private view {\n        bytes4 selector;\n\n        // Load in the function selector.\n        assembly {\n            selector := mload(add(data, 0x20))\n        }\n\n        if (selector == e721_safe_transfer_from_1_selector) {\n            // Load the token ID from calldata.\n            uint256 tokenId = uint256(\n                _loadValueFromCalldata(data, e721_safe_transfer_from_1_token_id_offset)\n            );\n\n            // Check if the selector is allowed.\n            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n        } else if (selector == e721_safe_transfer_from_2_selector) {\n            // Load the token ID from calldata.\n            uint256 tokenId = uint256(\n                _loadValueFromCalldata(data, e721_safe_transfer_from_2_token_id_offset)\n            );\n\n            // Check if the selector is allowed.\n            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n        } else if (selector == e721_transfer_from_selector) {\n            // Load the token ID from calldata.\n            uint256 tokenId = uint256(\n                _loadValueFromCalldata(data, e721_transfer_from_token_id_offset)\n            );\n\n            // Check if the selector is allowed.\n            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n        } else if (selector == e721_approve_selector) {\n            // Load the token ID from calldata.\n            uint256 tokenId = uint256(\n                _loadValueFromCalldata(data, e721_approve_token_id_offset)\n            );\n\n            // Check if the selector is allowed.\n            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n        } else if (selector == e1155_safe_transfer_from_selector) {\n            // Load the token ID from calldata.\n            uint256 tokenId = uint256(\n                _loadValueFromCalldata(data, e1155_safe_transfer_from_token_id_offset)\n            );\n\n            // Check if the selector is allowed.\n            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n        } else if (selector == gnosis_safe_enable_module_selector) {\n            // Load the extension address from calldata.\n            address extension = address(\n                uint160(\n                    uint256(\n                        _loadValueFromCalldata(data, gnosis_safe_enable_module_offset)\n                    )\n                )\n            );\n\n            // Check if the extension is whitelisted.\n            _revertNonWhitelistedExtension(extension);\n        } else if (selector == gnosis_safe_disable_module_selector) {\n            // Load the extension address from calldata.\n            address extension = address(\n                uint160(\n                    uint256(\n                        _loadValueFromCalldata(data, gnosis_safe_disable_module_offset)\n                    )\n                )\n            );\n\n            // Check if the extension is whitelisted.\n            _revertNonWhitelistedExtension(extension);\n        } else {\n            // Revert if the `setApprovalForAll` selector is specified. This selector is\n            // shared between ERC721 and ERC1155 tokens.\n            if (selector == shared_set_approval_for_all_selector) {\n                revert Errors.GuardPolicy_UnauthorizedSelector(\n                    shared_set_approval_for_all_selector\n                );\n            }\n\n            // Revert if the `safeBatchTransferFrom` selector is specified. There's no\n            // cheap way to check if individual items in the batch are rented out.\n            // Each token ID would require a call to the storage contract to check\n            // its rental status.\n            if (selector == e1155_safe_batch_transfer_from_selector) {\n                revert Errors.GuardPolicy_UnauthorizedSelector(\n                    e1155_safe_batch_transfer_from_selector\n                );\n            }\n\n            // Revert if the `setGuard` selector is specified.\n            if (selector == gnosis_safe_set_guard_selector) {\n                revert Errors.GuardPolicy_UnauthorizedSelector(\n                    gnosis_safe_set_guard_selector\n                );\n            }\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            External Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /** @notice Checks a transaction initiated by a rental safe to decide whether\n     *          it can be allowed or not. During this check, execution control flow\n     *          will be passed to an external hook contract if one exists for the\n     *          target contract.\n     *\n     * @param to             Destination address of Safe transaction.\n     * @param value          Ether value of Safe transaction.\n     * @param data           Data payload of Safe transaction.\n     * @param operation      Operation type of Safe transaction.\n     */\n    function checkTransaction(\n        address to,\n        uint25"
    }
  ]
}