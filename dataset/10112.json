{
  "Title": "[H-01] The formula of number of prizes for a degree is wrong",
  "Content": "_Submitted by WatchPug, also found by cmichel_.\n\nThe formula of the number of prizes for a degree per the document: <https://v4.docs.pooltogether.com/protocol/concepts/prize-distribution/#splitting-the-prizes> is:\n\n    Number of prizes for a degree = (2^bit range)^degree - (2^bit range)^(degree-1) - (2^bit range)^(degree-2) - ...\n\nShould be changed to:\n\n    Number of prizes for a degree = (2^bit range)^degree - (2^bit range)^(degree-1)\n\nor\n\n    Number of prizes for a degree = 2^(bit range * degree) - 2^(bit range * (degree-1))\n\n##### Impact\n\nPer the document:\n\n> prize for a degree = total prize \\* degree percentage / number of prizes for a degree\n\nDue to the miscalculation of `number of prizes for a degree`, it will be smaller than expected, as a result, `prize for a degree` will be larger than expected. Making the protocol giving out more prizes than designed.\n\n##### Proof\n\n> We will use `f(bitRange, degree)` to represent `numberOfPrizesForDegree(bitRangeSize, degree)`.\n\n###### Proof: (method 1)\n\n```tex\n2 ^ {bitRange \\times n} = f(bitRange, n) + f(bitRange, n-1) + f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0)\nf(bitRange, n) = 2 ^ {bitRange \\times n} - ( f(bitRange, n-1) + f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0) )\nf(bitRange, n) = 2 ^ {bitRange \\times n} - f(bitRange, n-1) - ( f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0) )\n\nBecause:\n\n2 ^ {bitRange \\times (n-1)} = f(bitRange, n-1) + f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0)\n2 ^ {bitRange \\times (n-1)} - f(bitRange, n-1) = f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0)\n\nTherefore:\n\nf(bitRange, n) = 2 ^ {bitRange \\times n} - f(bitRange, n-1) - ( 2 ^ {bitRange \\times (n-1)} - f(bitRange, n-1) )\nf(bitRange, n) = 2 ^ {bitRange \\times n} - f(bitRange, n-1) - 2 ^ {bitRange \\times (n-1)} + f(bitRange, n-1)\nf(bitRange, n) = 2 ^ {bitRange \\times n} - 2 ^ {bitRange \\times (n-1)}\n```\n\nBecause `2^x = 1 << x`\n\nTherefore, when `n > 0`:\n\n    f(bitRange, n) = ( 1 << bitRange * n ) - ( 1 << bitRange * (n - 1) )\n\nQED.\n\n###### Proof: (method 2)\n\nBy definition, `degree n` is constructed by 3 chunks:\n\n*   The first N numbers, must equal the matching numbers. Number of possible values: `1`;\n*   The N-th number, must not equal the N-th matching number. Number of possible values: `2^bitRange - 1`\n*   From N (not include) until the end. Number of possible values: `2 ^ (bitRange * (n-1))`\n\nTherefore, total `numberOfPrizesForDegree` will be:\n\n```tex\nf(bitRange, n) = (2 ^ {bitRange} - 1) \\times 2 ^ {bitRange \\times (n - 1)}\nf(bitRange, n) = 2 ^ {bitRange} \\times 2 ^ {bitRange \\times (n - 1)} - 2 ^ {bitRange \\times (n - 1)}\nf(bitRange, n) = 2 ^ {bitRange + bitRange \\times (n - 1)} - 2 ^ {bitRange \\times (n - 1)}\nf(bitRange, n) = 2 ^ {bitRange + bitRange \\times n - bitRange} - 2 ^ {bitRange \\times (n - 1)}\nf(bitRange, n) = 2 ^ {bitRange \\times n} - 2 ^ {bitRange \\times (n - 1)}\n```\n\nQED.\n\n##### Recommendation\n\n<https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/DrawCalculator.sol#L423-L431>\n\n```solidity\n/**\n    * @notice Calculates the number of prizes for a given prizeDistributionIndex\n    * @param _bitRangeSize Bit range size for Draw\n    * @param _prizeTierIndex Index of the prize tier array to calculate\n    * @return returns the fraction of the total prize (base 1e18)\n    */\nfunction _numberOfPrizesForIndex(uint8 _bitRangeSize, uint256 _prizeTierIndex)\n    internal\n    pure\n    returns (uint256)\n{\n    uint256 bitRangeDecimal = 2**uint256(_bitRangeSize);\n    uint256 numberOfPrizesForIndex = bitRangeDecimal**_prizeTierIndex;\n\n    while (_prizeTierIndex > 0) {\n        numberOfPrizesForIndex -= bitRangeDecimal**(_prizeTierIndex - 1);\n        _prizeTierIndex--;\n    }\n\n    return numberOfPrizesForIndex;\n}\n```\n\nL423-431 should change to:\n\n```solidity\nif (_prizeTierIndex > 0) {\n    return ( 1 << _bitRangeSize * _prizeTierIndex ) - ( 1 << _bitRangeSize * (_prizeTierIndex - 1) );\n} else {\n    return 1;\n}\n```\n\nBTW, the comment on L416 is wrong:\n\n*   seems like it's copied from `\\_calculatePrizeTierFraction()`\n*   plus, it's not base 1e18 but base 1e9\n\n**[PierrickGT (PoolTogether) confirmed and patched](https://github.com/code-423n4/2021-10-pooltogether-findings/issues/33#issuecomment-943604800):**\n > PR: https://github.com/pooltogether/v4-core/pull/242\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-10-pooltogether-findings/issues/33#issuecomment-943845472):**\n > The warden found the usage of an incorrect formula that would cause the protocol to give out larger prizes than expected, the sponsor has mitigated in a following PR\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2021-10-pooltogether",
  "Code": [
    {
      "filename": "contracts/DrawCalculator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.6;\n\nimport \"@pooltogether/owner-manager-contracts/contracts/Ownable.sol\";\n\nimport \"./PrizeDistributor.sol\";\n\nimport \"./interfaces/IDrawCalculator.sol\";\nimport \"./interfaces/ITicket.sol\";\nimport \"./interfaces/IDrawBuffer.sol\";\nimport \"./interfaces/IPrizeDistributionBuffer.sol\";\nimport \"./interfaces/IDrawBeacon.sol\";\nimport \"./libraries/DrawRingBufferLib.sol\";\n\n/**\n  * @title  PoolTogether V4 DrawCalculator\n  * @author PoolTogether Inc Team\n  * @notice The DrawCalculator calculates a user's prize by matching a winning random number against\n            their picks. A users picks are generated deterministically based on their address and balance\n            of tickets held. Prize payouts are divided into multiple tiers: grand prize, second place, etc...\n            A user with a higher average weighted balance (during each draw period) will be given a large number of\n            picks to choose from, and thus a higher chance to match the winning numbers.\n*/\ncontract DrawCalculator is IDrawCalculator, Ownable {\n\n    /// @notice DrawBuffer address\n    IDrawBuffer public immutable drawBuffer;\n\n    /// @notice Ticket associated with DrawCalculator\n    ITicket public immutable ticket;\n\n    /// @notice The stored history of draw settings.  Stored as ring buffer.\n    IPrizeDistributionBuffer public immutable prizeDistributionBuffer;\n\n    /// @notice The tiers array length\n    uint8 public constant TIERS_LENGTH = 16;\n\n    /* ============ Constructor ============ */\n\n    /// @notice Constructor for DrawCalculator\n    /// @param _owner Address of the DrawCalculator owner\n    /// @param _ticket Ticket associated with this DrawCalculator\n    /// @param _drawBuffer The address of the draw buffer to push draws to\n    /// @param _prizeDistributionBuffer PrizeDistributionBuffer address\n    constructor(\n        address _owner,\n        ITicket _ticket,\n        IDrawBuffer _drawBuffer,\n        IPrizeDistributionBuffer _prizeDistributionBuffer\n    ) Ownable(_owner) {\n        require(address(_ticket) != address(0), \"DrawCalc/ticket-not-zero\");\n        require(address(_prizeDistributionBuffer) != address(0), \"DrawCalc/pdb-not-zero\");\n        require(address(_drawBuffer) != address(0), \"DrawCalc/dh-not-zero\");\n\n        ticket = _ticket;\n        drawBuffer = _drawBuffer;\n        prizeDistributionBuffer = _prizeDistributionBuffer;\n\n        emit Deployed(_ticket, _drawBuffer, _prizeDistributionBuffer);\n    }\n\n    /* ============ External Functions ============ */\n\n    /// @inheritdoc IDrawCalculator\n    function calculate(\n        address _user,\n        uint32[] calldata _drawIds,\n        bytes calldata _pickIndicesForDraws\n    ) external view override returns (uint256[] memory, bytes memory) {\n        uint64[][] memory pickIndices = abi.decode(_pickIndicesForDraws, (uint64 [][]));\n        require(pickIndices.length == _drawIds.length, \"DrawCalc/invalid-pick-indices-length\");\n\n        // READ list of IDrawBeacon.Draw using the drawIds from drawBuffer\n        IDrawBeacon.Draw[] memory draws = drawBuffer.getDraws(_drawIds);\n\n        // READ list of IPrizeDistributionBuffer.PrizeDistribution using the drawIds\n        IPrizeDistributionBuffer.PrizeDistribution[] memory _prizeDistributions = prizeDistributionBuffer\n            .getPrizeDistributions(_drawIds);\n\n        // The userBalances are fractions representing their portion of the liquidity for a draw.\n        uint256[] memory userBalances = _getNormalizedBalancesAt(_user, draws, _prizeDistributions);\n\n        // The users address is hashed once.\n        bytes32 _userRandomNumber = keccak256(abi.encodePacked(_user));\n\n        return _calculatePrizesAwardable(\n                userBalances,\n                _userRandomNumber,\n                draws,\n                pickIndices,\n                _prizeDistributions\n            );\n    }\n\n    /// @inheritdoc IDrawCalculator\n    function getDrawBuffer() external view override returns (IDrawBuffer) {\n        return drawBuffer;\n    }\n\n    /// @inheritdoc IDrawCalculator\n    function getPrizeDistributionBuffer()\n        external\n        view\n        override\n        returns (IPrizeDistributionBuffer)\n    {\n        return prizeDistributionBuffer;\n    }\n\n    /// @inheritdoc IDrawCalculator\n    function getNormalizedBalancesForDrawIds(address _user, uint32[] calldata _drawIds)\n        external\n        view\n        override\n        returns (uint256[] memory)\n    {\n        IDrawBeacon.Draw[] memory _draws = drawBuffer.getDraws(_drawIds);\n        IPrizeDistributionBuffer.PrizeDistribution[] memory _prizeDistributions = prizeDistributionBuffer\n            .getPrizeDistributions(_drawIds);\n\n        return _getNormalizedBalancesAt(_user, _draws, _prizeDistributions);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @notice Calculates the prizes awardable for each Draw passed.\n     * @param _normalizedUserBalances Fractions representing the user's portion of the liquidity for each draw.\n     * @param _userRandomNumber       Random number of the user to consider over draws\n     * @param _draws                  List of Draws\n     * @param _pickIndicesForDraws    Pick indices for each Draw\n     * @param _prizeDistributions     PrizeDistribution for each Draw\n\n     */\n    function _calculatePrizesAwardable(\n        uint256[] memory _normalizedUserBalances,\n        bytes32 _userRandomNumber,\n        IDrawBeacon.Draw[] memory _draws,\n        uint64[][] memory _pickIndicesForDraws,\n        IPrizeDistributionBuffer.PrizeDistribution[] memory _prizeDistributions\n    ) internal pure returns (uint256[] memory prizesAwardable, bytes memory prizeCounts) {\n        \n        uint256[] memory _prizesAwardable = new uint256[](_normalizedUserBalances.length);\n        uint256[][] memory _prizeCounts = new uint256[][](_normalizedUserBalances.length);\n\n        // calculate prizes awardable for each Draw passed\n        for (uint32 drawIndex = 0; drawIndex < _draws.length; drawIndex++) {\n            uint64 totalUserPicks = _calculateNumberOfUserPicks(\n                _prizeDistributions[drawIndex],\n                _normalizedUserBalances[drawIndex]\n            );\n\n            (_prizesAwardable[drawIndex], _prizeCounts[drawIndex]) = _calculate(\n                _draws[drawIndex].winningRandomNumber,\n                totalUserPicks,\n                _userRandomNumber,\n                _pickIndicesForDraws[drawIndex],\n                _prizeDistributions[drawIndex]\n            );\n        }\n        prizeCounts = abi.encode(_prizeCounts);\n        prizesAwardable = _prizesAwardable;\n    }\n\n    /**\n     * @notice Calculates the number of picks a user gets for a Draw, considering the normalized user balance and the PrizeDistribution.\n     * @dev Divided by 1e18 since the normalized user balance is stored as a fixed point 18 number\n     * @param _prizeDistribution The PrizeDistribution to consider\n     * @param _normalizedUserBalance The normalized user balances to consider\n     * @return The number of picks a user gets for a Draw\n     */\n    function _calculateNumberOfUserPicks(\n        IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution,\n        uint256 _normalizedUserBalance\n    ) internal pure returns (uint64) {\n        return uint64((_normalizedUserBalance * _prizeDistribution.numberOfPicks) / 1 ether);\n    }\n\n    /**\n     * @notice Calculates the normalized balance of a user against the total supply for timestamps\n     * @param _user The user to consider\n     * @param _draws The draws we are looking at\n     * @param _prizeDistributions The prize tiers to consider (needed for draw timestamp offsets)\n     * @return An array of normalized balances\n     */\n    function _getNormalizedBalancesAt(\n        address _user,\n        IDrawBeacon.Draw[] memory _draws,\n        IPrizeDistributionBuffer.PrizeDistribution[] memory _prizeDistributions\n    ) internal view returns (uint256[] memory) {\n        uint64[] memory _timestampsWithStartCutoffTimes = new uint64[](_draws.length);\n        uint64[] memory _timestampsWithEndCutoffTimes = new uint64[](_draws.length);\n\n        // generate timestamps with draw cutoff offsets included\n        for (uint32 i = 0; i < _draws.length; i++) {\n            unchecked {\n                _timestampsWithStartCutoffTimes[i] =\n                    _draws[i].timestamp - _prizeDistributions[i].startTimestampOffset;\n                _timestampsWithEndCutoffTimes[i] =\n                    _draws[i].timestamp - _prizeDistributions[i].endTimestampOffset;\n            }\n        }\n\n        uint256[] memory balances = ticket.getAverageBalancesBetween(\n            _user,\n            _timestampsWithStartCutoffTimes,\n            _timestampsWithEndCutoffTimes\n        );\n\n        uint256[] memory totalSupplies = ticket.getAverageTotalSuppliesBetween(\n            _timestampsWithStartCutoffTimes,\n            _timestampsWithEndCutoffTimes\n        );\n\n        uint256[] memory normalizedBalances = new uint256[](_draws.length);\n\n        // divide balances by total supplies (normalize)\n        for (uint256 i = 0; i < _draws.length; i++) {\n            if(totalSupplies[i] == 0){\n                normalizedBalances[i] = 0;\n            }\n            else {\n                normalizedBalances[i] = (balances[i] * 1 ether) / totalSupplies[i];\n            }\n        }\n\n        return normalizedBalances;\n    }\n\n    /**\n     * @notice Calculates the prize amount for a PrizeDistribution over given picks\n     * @param _winningRandomNumber Draw's winningRandomNumber\n     * @param _totalUserPicks      number of picks the user gets for the Draw\n     * @param _userRandomNumber    users randomNumber for that draw\n     * @param _picks               users picks for that draw\n     * @param _prizeDistribution   PrizeDistribution for that draw\n     * @return prize (if any), prizeCounts (if any)\n     */\n    function _calculate(\n        uint256 _winningRandomNumber,\n        uint256 _totalUserPicks,\n        bytes32 _userRandomNumber,\n        uint64[] memory _picks,\n        IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution\n    ) internal pure returns (uint256 prize, uint256[] memory prizeCounts) {\n        \n        // create bitmasks for the PrizeDistribution\n        uint256[] memory masks = _createBitMasks(_prizeDistribution);\n        uint32 picksLength = uint32(_picks.length);\n        uint256[] memory _prizeCounts = new uint256[](_prizeDistribution.tiers.length);\n\n        uint8 maxWinningTierIndex = 0;\n\n        require(\n            picksLength <= _prizeDistribution.maxPicksPerUser,\n            \"DrawCalc/exceeds-max-user-picks\"\n        );\n\n        // for each pick, find number of matching numbers and calculate prize distributions index\n        for (uint32 index = 0; index < picksLength; index++) {\n            require(_picks[index] < _totalUserPicks, \"DrawCalc/insufficient-user-picks\");\n\n            if (index > 0) {\n                require(_picks[index] > _picks[index - 1], \"DrawCalc/picks-ascending\");\n            }\n\n            // hash the user random number with the pick value\n            uint256 randomNumberThisPick = uint256(\n                keccak256(abi.encode(_userRandomNumber, _picks[index]))\n            );\n\n            uint8 tiersIndex = _calculateTierIndex(\n                randomNumberThisPick,\n                _winningRandomNumber,\n                masks\n            );\n\n            // there is prize for this tier index\n            if (tiersIndex < TIERS_LENGTH) {\n                if (tiersIndex > maxWinningTierIndex) {\n                    maxWinningTierIndex = tiersIndex;\n                }\n                _prizeCounts[tiersIndex]++;\n            }\n        }\n\n        // now calculate prizeFraction given prizeCounts\n        uint256 prizeFraction = 0;\n        uint256[] memory prizeTiersFractions = _calculatePrizeTierFractions(\n            _prizeDistribution,\n            maxWinningTierIndex\n        );\n\n        // multiple the fractions by the prizeCounts and add them up\n        for (\n            uint256 prizeCountIndex = 0;\n            prizeCountIndex <= maxWinningTierIndex;\n            prizeCountIndex++\n        ) {\n            if (_prizeCounts[prizeCountIndex] > 0) {\n                prizeFraction +=\n                    prizeTiersFractions[prizeCountIndex] *\n                    _prizeCounts[prizeCountIndex];\n            }\n        }\n\n        // return the absolute amount of prize awardable\n        // div by 1e9 as prize tiers are base 1e9\n        prize = (prizeFraction * _prizeDistribution.prize) / 1e9; \n        prizeCounts = _prizeCounts;\n    }\n\n    ///@notice Calculates the tier index given the random numbers and masks\n    ///@param _randomNumberThisPick users random number for this Pick\n    ///@param _winningRandomNumber The winning number for this draw\n    ///@param _masks The pre-calculate bitmasks for the prizeDistributions\n    ///@return The position within the prize tier array (0 = top prize, 1 = runner-up prize, etc)\n    function _calculateTierIndex(\n        uint256 _randomNumberThisPick,\n        uint256 _winningRandomNumber,\n        uint256[] memory _masks\n    ) internal pure returns (uint8) {\n        uint8 numberOfMatches = 0;\n        uint8 masksLength = uint8(_masks.length);\n\n        // main number matching loop\n        for (uint8 matchIndex = 0; matchIndex < masksLength; matchIndex++) {\n            uint256 mask = _masks[matchIndex];\n\n            if ((_randomNumberThisPick & mask) != (_winningRandomNumber & mask)) {\n                // there are no more sequential matches since this comparison is not a match\n                return masksLength - numberOfMatches;\n            }\n\n            // else there was a match\n            numberOfMatches++;\n        }\n\n        return masksLength - numberOfMatches;\n    }\n\n    /**\n     * @notice Create an array of bitmasks equal to the PrizeDistribution.matchCardinality length\n     * @param _prizeDistribution The PrizeDistribution to use to calculate the masks\n     * @return An array of bitmasks\n     */\n    function _createBitMasks(IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution)\n        internal\n        pure\n        returns (uint256[] memory)\n    {\n        uint256[] memory masks = new uint256[](_prizeDistribution.matchCardinality);\n        uint256 _bitRangeMaskValue = (2**_prizeDistribution.bitRangeSize) - 1; // get a decimal representation of bitRangeSize\n\n        for (uint8 maskIndex = 0; maskIndex < _prizeDistribution.matchCardinality; maskIndex++) {\n            // create mask of width bitRangeSize bits at index\n            uint256 _matchIndexOffset = uint256(maskIndex) * uint256(_prizeDistribution.bitRangeSize);\n            // shift mask bits to correct position and insert in result mask array\n            masks[maskIndex] = _bitRangeMaskValue << _matchIndexOffset;\n        }\n\n        return masks;\n    }\n\n    /**\n     * @notice Calculates the expected prize fraction per PrizeDistributions and distributionIndex\n     * @param _prizeDistribution prizeDistribution struct for Draw\n     * @param _prizeTierIndex Index of the prize tiers array to calculate\n     * @return returns the fraction of the total prize (base 1e18)\n     */\n    function _calculatePrizeTierFraction(\n        IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution,\n        uint256 _prizeTierIndex\n    ) internal pure returns (uint256) {\n         // get the prize fraction at that index\n        uint256 prizeFraction = _prizeDistribution.tiers[_prizeTierIndex];\n\n        // calculate number of prizes for that index\n        uint256 numberOfPrizesForIndex = _numberOfPrizesForIndex(\n            _prizeDistribution.bitRangeSize,\n            _prizeTierIndex\n        );\n\n        return prizeFraction / numberOfPrizesForIndex;\n    }\n\n    /**\n     * @notice Generates an array of prize tiers fractions\n     * @param _prizeDistribution prizeDistribution struct for Draw\n     * @param maxWinningTierIndex Max length of the prize tiers array\n     * @return returns an array of prize tiers fractions\n     */\n    function _calculatePrizeTierFractions(\n        IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution,\n        uint8 maxWinningTierIndex\n    ) internal pure returns (uint256[] memory) {\n        uint256[] memory prizeDistributionFractions = new uint256[](\n            maxWinningTierIndex + 1\n        );\n\n        for (uint8 i = 0; i <= maxWinningTierIndex; i++) {\n            prizeDistributionFractions[i] = _calculatePrizeTierFraction(\n                _prizeDistribution,\n                i\n            );\n        }\n\n        return prizeDistributionFractions;\n    }\n\n    /**\n     * @notice Calculates the number of prizes for a given prizeDistributionIndex\n     * @param _bitRangeSize Bit range size for Draw\n     * @param _prizeTierIndex Index of the prize tier array to calculate\n     * @return returns the fraction of the total prize (base 1e18)\n     */\n    function _numberOfPrizesForIndex(uint8 _bitRangeSize, uint256 _prizeTierIndex)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 bitRangeDecimal = 2**uint256(_bitRangeSize);\n        uint256 numberOfPrizesForIndex = bitRangeDecimal**_prizeTierIndex;\n\n        while (_prizeTierIndex > 0) {\n            numberOfPrizesForIndex -= bitRangeDecimal**(_prizeTierIndex - 1);\n            _prizeTierIndex--;\n        }\n\n        return numberOfPrizesForIndex;\n    }\n}"
    }
  ]
}