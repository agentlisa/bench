{
  "Title": "Decreasing and increasing a short's collateral potentially uses an outdated asset price to calculate the collateral ratio",
  "Content": "# Decreasing and increasing a short's collateral potentially uses an outdated asset price to calculate the collateral ratio\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/ShortRecordFacet.sol#L94\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/ShortRecordFacet.sol#L94</a>\n\n\n## Summary\n\nThe `decreaseCollateral` and `increaseCollateral` functions in the `ShortRecordFacet` contract calculate the short's collateral ratio based on the cached asset price, which may be outdated, leading to a divergence between the actual collateral ratio (based on the asset spot price) and the calculated collateral ratio.\n\n## Vulnerability Details\n\nAccording to the [conditions for updating the oracle](https://dittoeth.com/technical/oracles#conditions-for-updating-oracle), decreasing the short's collateral via the `ShortRecordFacet.decreaseCollateral` function should update the oracle price if the oracle price is older than **15 minutes**.\n\nHowever, in the current implementation of the `decreaseCollateral` function, the short's collateral ratio, `cRatio`, is calculated by [calling the `getCollateralRatio` function in line 94](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/ShortRecordFacet.sol#L94):\n\n```solidity\n082: function decreaseCollateral(address asset, uint8 id, uint88 amount)\n083:     external\n084:     isNotFrozen(asset)\n085:     nonReentrant\n086:     onlyValidShortRecord(asset, msg.sender, id)\n087: {\n088:     STypes.ShortRecord storage short = s.shortRecords[asset][msg.sender][id];\n089:     short.updateErcDebt(asset);\n090:     if (amount > short.collateral) revert Errors.InsufficientCollateral();\n091:\n092:     short.collateral -= amount;\n093:\n094: ‚ùå  uint256 cRatio = short.getCollateralRatio(asset);\n095:     if (cRatio < LibAsset.initialMargin(asset)) {\n096:         revert Errors.CollateralLowerThanMin();\n097:     }\n098:\n099:     uint256 vault = s.asset[asset].vault;\n100:     s.vaultUser[vault][msg.sender].ethEscrowed += amount;\n101:\n102:     LibShortRecord.disburseCollateral(\n103:         asset, msg.sender, amount, short.zethYieldRate, short.updatedAt\n104:     );\n105:     emit Events.DecreaseCollateral(asset, msg.sender, id, amount);\n106: }\n```\n\nThe called [`getCollateralRatio` function uses the `LibOracle.getPrice` function](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibShortRecord.sol#L27) to calculate the collateral ratio:\n\n```solidity\n22: function getCollateralRatio(STypes.ShortRecord memory short, address asset)\n23:     internal\n24:     view\n25:     returns (uint256 cRatio)\n26: {\n27:     return short.collateral.div(short.ercDebt.mul(LibOracle.getPrice(asset)));\n28: }\n```\n\nThe [`LibOracle.getPrice` function returns the currently cached asset price](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibOracle.sol#L149), which potentially is older than **15 minutes**.\n\n```solidity\n147: function getPrice(address asset) internal view returns (uint80 oraclePrice) {\n148:     AppStorage storage s = appStorage();\n149:     return uint80(s.bids[asset][Constants.HEAD].ercAmount);\n150: }\n```\n\nConsequently, the calculated `cRatio` in line 94 of the `decreaseCollateral` function is based on the potentially outdated asset price, resulting in the collateral ratio being inaccurate and diverging from the actual collateral ratio based on the current asset spot price.\n\nA short owner can exploit this by decreasing the short's collateral up to the point where the [resulting collateral ratio is equal to the initial margin](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/ShortRecordFacet.sol#L95-L97) (i.e., 500%). As the collateral ratio, `cRatio`, is calculated in line 94 based on the outdated cached oracle price, the short owner can withdraw more collateral than the actual collateral ratio (based on the asset spot price) would allow.\n\nSimilarly, the `increaseCollateral` function is [affected as well](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/ShortRecordFacet.sol#L55-L61).\n\n## Impact\n\nShort-position owners can withdraw more collateral than eligible, negatively affecting the overall asset's collateral ratio.\n\n## Tools Used\n\nManual Review\n\n## Recommendations\n\nConsider using the `LibOracle.getSavedOrSpotOraclePrice` function together with the `getCollateralRatioSpotPrice` function to calculate the collateral ratio based on the current asset price.\n",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/facets/ShortRecordFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U80, U88} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {STypes, MTypes} from \"contracts/libraries/DataTypes.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract ShortRecordFacet is Modifiers {\n    using LibShortRecord for STypes.ShortRecord;\n    using U256 for uint256;\n    using U80 for uint80;\n    using U88 for uint88;\n\n    address private immutable cusd;\n\n    constructor(address _cusd) {\n        cusd = _cusd;\n    }\n\n    /**\n     * @notice Increases collateral of an active short\n     *\n     * @param asset The market that will be impacted\n     * @param id Id of short\n     * @param amount Eth amount to increase collateral by\n     *\n     */\n\n    function increaseCollateral(address asset, uint8 id, uint88 amount)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, msg.sender, id)\n    {\n        STypes.Asset storage Asset = s.asset[asset];\n        uint256 vault = Asset.vault;\n        STypes.Vault storage Vault = s.vault[vault];\n        STypes.VaultUser storage VaultUser = s.vaultUser[vault][msg.sender];\n        if (VaultUser.ethEscrowed < amount) revert Errors.InsufficientETHEscrowed();\n\n        STypes.ShortRecord storage short = s.shortRecords[asset][msg.sender][id];\n        short.updateErcDebt(asset);\n        uint256 yield = short.collateral.mul(short.zethYieldRate);\n        short.collateral += amount;\n\n        uint256 cRatio = short.getCollateralRatio(asset);\n        if (cRatio >= Constants.CRATIO_MAX) revert Errors.CollateralHigherThanMax();\n\n        //@dev reset flag info if new cratio is above primaryLiquidationCR\n        if (cRatio >= LibAsset.primaryLiquidationCR(asset)) {\n            short.resetFlag();\n        }\n\n        yield += amount.mul(Vault.zethYieldRate);\n        short.zethYieldRate = yield.divU80(short.collateral);\n\n        VaultUser.ethEscrowed -= amount;\n        Vault.zethCollateral += amount;\n        Asset.zethCollateral += amount;\n        emit Events.IncreaseCollateral(asset, msg.sender, id, amount);\n    }\n\n    /**\n     * @notice Decrease collateral of an active short\n     * @dev Cannot decrease below initial margin\n     *\n     * @param asset The market that will be impacted\n     * @param id Id of short\n     * @param amount Eth amount to decrease collateral by\n     *\n     */\n\n    function decreaseCollateral(address asset, uint8 id, uint88 amount)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, msg.sender, id)\n    {\n        STypes.ShortRecord storage short = s.shortRecords[asset][msg.sender][id];\n        short.updateErcDebt(asset);\n        if (amount > short.collateral) revert Errors.InsufficientCollateral();\n\n        short.collateral -= amount;\n\n        uint256 cRatio = short.getCollateralRatio(asset);\n        if (cRatio < LibAsset.initialMargin(asset)) {\n            revert Errors.CollateralLowerThanMin();\n        }\n\n        uint256 vault = s.asset[asset].vault;\n        s.vaultUser[vault][msg.sender].ethEscrowed += amount;\n\n        LibShortRecord.disburseCollateral(\n            asset, msg.sender, amount, short.zethYieldRate, short.updatedAt\n        );\n        emit Events.DecreaseCollateral(asset, msg.sender, id, amount);\n    }\n\n    /**\n     * @notice Combine active shorts into one short\n     * @dev If any shorts are flagged the resulting short must have c-ratio > primaryLiquidationCR\n     *\n     * @param asset The market that will be impacted\n     * @param ids Array of short ids to be combined\n     *\n     */\n\n    function combineShorts(address asset, uint8[] memory ids)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, msg.sender, ids[0])\n    {\n        if (ids.length < 2) revert Errors.InsufficientNumberOfShorts();\n        // First short in the array\n        STypes.ShortRecord storage firstShort = s.shortRecords[asset][msg.sender][ids[0]];\n        // @dev Load initial short elements in struct to avoid stack too deep\n        MTypes.CombineShorts memory c;\n        c.shortFlagExists = firstShort.flaggerId != 0;\n        c.shortUpdatedAt = firstShort.updatedAt;\n\n        address _asset = asset;\n        uint88 collateral;\n        uint88 ercDebt;\n        uint256 yield;\n        uint256 ercDebtSocialized;\n        for (uint256 i = ids.length - 1; i > 0; i--) {\n            uint8 _id = ids[i];\n            _onlyValidShortRecord(_asset, msg.sender, _id);\n            STypes.ShortRecord storage currentShort =\n                s.shortRecords[_asset][msg.sender][_id];\n            // See if there is at least one flagged short\n            if (!c.shortFlagExists) {\n                if (currentShort.flaggerId != 0) {\n                    c.shortFlagExists = true;\n                }\n            }\n\n            //@dev Take latest time when combining shorts (prevent flash loan)\n            if (currentShort.updatedAt > c.shortUpdatedAt) {\n                c.shortUpdatedAt = currentShort.updatedAt;\n            }\n\n            {\n                uint88 currentShortCollateral = currentShort.collateral;\n                uint88 currentShortErcDebt = currentShort.ercDebt;\n                collateral += currentShortCollateral;\n                ercDebt += currentShortErcDebt;\n                yield += currentShortCollateral.mul(currentShort.zethYieldRate);\n                ercDebtSocialized += currentShortErcDebt.mul(currentShort.ercDebtRate);\n            }\n\n            if (currentShort.tokenId != 0) {\n                //@dev First short needs to have NFT so there isn't a need to burn and re-mint\n                if (firstShort.tokenId == 0) {\n                    revert Errors.FirstShortMustBeNFT();\n                }\n\n                LibShortRecord.burnNFT(currentShort.tokenId);\n            }\n\n            // Cancel this short and combine with short in ids[0]\n            LibShortRecord.deleteShortRecord(_asset, msg.sender, _id);\n        }\n\n        // Merge all short records into the short at position id[0]\n        firstShort.merge(ercDebt, ercDebtSocialized, collateral, yield, c.shortUpdatedAt);\n\n        // If at least one short was flagged, ensure resulting c-ratio > primaryLiquidationCR\n        if (c.shortFlagExists) {\n            if (\n                firstShort.getCollateralRatioSpotPrice(\n                    LibOracle.getSavedOrSpotOraclePrice(_asset)\n                ) < LibAsset.primaryLiquidationCR(_asset)\n            ) revert Errors.InsufficientCollateral();\n            // Resulting combined short has sufficient c-ratio to remove flag\n            firstShort.resetFlag();\n        }\n        emit Events.CombineShorts(asset, msg.sender, ids);\n    }\n}"
    },
    {
      "filename": "contracts/facets/ShortRecordFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U80, U88} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {STypes, MTypes} from \"contracts/libraries/DataTypes.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract ShortRecordFacet is Modifiers {\n    using LibShortRecord for STypes.ShortRecord;\n    using U256 for uint256;\n    using U80 for uint80;\n    using U88 for uint88;\n\n    address private immutable cusd;\n\n    constructor(address _cusd) {\n        cusd = _cusd;\n    }\n\n    /**\n     * @notice Increases collateral of an active short\n     *\n     * @param asset The market that will be impacted\n     * @param id Id of short\n     * @param amount Eth amount to increase collateral by\n     *\n     */\n\n    function increaseCollateral(address asset, uint8 id, uint88 amount)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, msg.sender, id)\n    {\n        STypes.Asset storage Asset = s.asset[asset];\n        uint256 vault = Asset.vault;\n        STypes.Vault storage Vault = s.vault[vault];\n        STypes.VaultUser storage VaultUser = s.vaultUser[vault][msg.sender];\n        if (VaultUser.ethEscrowed < amount) revert Errors.InsufficientETHEscrowed();\n\n        STypes.ShortRecord storage short = s.shortRecords[asset][msg.sender][id];\n        short.updateErcDebt(asset);\n        uint256 yield = short.collateral.mul(short.zethYieldRate);\n        short.collateral += amount;\n\n        uint256 cRatio = short.getCollateralRatio(asset);\n        if (cRatio >= Constants.CRATIO_MAX) revert Errors.CollateralHigherThanMax();\n\n        //@dev reset flag info if new cratio is above primaryLiquidationCR\n        if (cRatio >= LibAsset.primaryLiquidationCR(asset)) {\n            short.resetFlag();\n        }\n\n        yield += amount.mul(Vault.zethYieldRate);\n        short.zethYieldRate = yield.divU80(short.collateral);\n\n        VaultUser.ethEscrowed -= amount;\n        Vault.zethCollateral += amount;\n        Asset.zethCollateral += amount;\n        emit Events.IncreaseCollateral(asset, msg.sender, id, amount);\n    }\n\n    /**\n     * @notice Decrease collateral of an active short\n     * @dev Cannot decrease below initial margin\n     *\n     * @param asset The market that will be impacted\n     * @param id Id of short\n     * @param amount Eth amount to decrease collateral by\n     *\n     */\n\n    function decreaseCollateral(address asset, uint8 id, uint88 amount)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, msg.sender, id)\n    {\n        STypes.ShortRecord storage short = s.shortRecords[asset][msg.sender][id];\n        short.updateErcDebt(asset);\n        if (amount > short.collateral) revert Errors.InsufficientCollateral();\n\n        short.collateral -= amount;\n\n        uint256 cRatio = short.getCollateralRatio(asset);\n        if (cRatio < LibAsset.initialMargin(asset)) {\n            revert Errors.CollateralLowerThanMin();\n        }\n\n        uint256 vault = s.asset[asset].vault;\n        s.vaultUser[vault][msg.sender].ethEscrowed += amount;\n\n        LibShortRecord.disburseCollateral(\n            asset, msg.sender, amount, short.zethYieldRate, short.updatedAt\n        );\n        emit Events.DecreaseCollateral(asset, msg.sender, id, amount);\n    }\n\n    /**\n     * @notice Combine active shorts into one short\n     * @dev If any shorts are flagged the resulting short must have c-ratio > primaryLiquidationCR\n     *\n     * @param asset The market that will be impacted\n     * @param ids Array of short ids to be combined\n     *\n     */\n\n    function combineShorts(address asset, uint8[] memory ids)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, msg.sender, ids[0])\n    {\n        if (ids.length < 2) revert Errors.InsufficientNumberOfShorts();\n        // First short in the array\n        STypes.ShortRecord storage firstShort = s.shortRecords[asset][msg.sender][ids[0]];\n        // @dev Load initial short elements in struct to avoid stack too deep\n        MTypes.CombineShorts memory c;\n        c.shortFlagExists = firstShort.flaggerId != 0;\n        c.shortUpdatedAt = firstShort.updatedAt;\n\n        address _asset = asset;\n        uint88 collateral;\n        uint88 ercDebt;\n        uint256 yield;\n        uint256 ercDebtSocialized;\n        for (uint256 i = ids.length - 1; i > 0; i--) {\n            uint8 _id = ids[i];\n            _onlyValidShortRecord(_asset, msg.sender, _id);\n            STypes.ShortRecord storage currentShort =\n                s.shortRecords[_asset][msg.sender][_id];\n            // See if there is at least one flagged short\n            if (!c.shortFlagExists) {\n                if (currentShort.flaggerId != 0) {\n                    c.shortFlagExists = true;\n                }\n            }\n\n            //@dev Take latest time when combining shorts (prevent flash loan)\n            if (currentShort.updatedAt > c.shortUpdatedAt) {\n                c.shortUpdatedAt = currentShort.updatedAt;\n            }\n\n            {\n                uint88 currentShortCollateral = currentShort.collateral;\n                uint88 currentShortErcDebt = currentShort.ercDebt;\n                collateral += currentShortCollateral;\n                ercDebt += currentShortErcDebt;\n                yield += currentShortCollateral.mul(currentShort.zethYieldRate);\n                ercDebtSocialized += currentShortErcDebt.mul(currentShort.ercDebtRate);\n            }\n\n            if (currentShort.tokenId != 0) {\n                //@dev First short needs to have NFT so there isn't a need to burn and re-mint\n                if (firstShort.tokenId == 0) {\n                    revert Errors.FirstShortMustBeNFT();\n                }\n\n                LibShortRecord.burnNFT(currentShort.tokenId);\n            }\n\n            // Cancel this short and combine with short in ids[0]\n            LibShortRecord.deleteShortRecord(_asset, msg.sender, _id);\n        }\n\n        // Merge all short records into the short at position id[0]\n        firstShort.merge(ercDebt, ercDebtSocialized, collateral, yield, c.shortUpdatedAt);\n\n        // If at least one short was flagged, ensure resulting c-ratio > primaryLiquidationCR\n        if (c.shortFlagExists) {\n            if (\n                firstShort.getCollateralRatioSpotPrice(\n                    LibOracle.getSavedOrSpotOraclePrice(_asset)\n                ) < LibAsset.primaryLiquidationCR(_asset)\n            ) revert Errors.InsufficientCollateral();\n            // Resulting combined short has sufficient c-ratio to remove flag\n            firstShort.resetFlag();\n        }\n        emit Events.CombineShorts(asset, msg.sender, ids);\n    }\n}"
    },
    {
      "filename": "contracts/libraries/LibShortRecord.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {STypes, SR} from \"contracts/libraries/DataTypes.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\nlibrary LibShortRecord {\n    using U256 for uint256;\n    using U88 for uint88;\n    using U80 for uint80;\n\n    function getCollateralRatio(STypes.ShortRecord memory short, address asset)\n        internal\n        view\n        returns (uint256 cRatio)\n    {\n        return short.collateral.div(short.ercDebt.mul(LibOracle.getPrice(asset)));\n    }\n\n    function getCollateralRatioSpotPrice(\n        STypes.ShortRecord memory short,\n        uint256 oraclePrice\n    ) internal pure returns (uint256 cRatio) {\n        return short.collateral.div(short.ercDebt.mul(oraclePrice));\n    }\n\n    /**\n     * @notice Returns number of active shortRecords\n     *\n     * @param asset The market that will be impacted\n     * @param shorter Shorter address\n     *\n     * @return shortRecordCount\n     */\n    function getShortRecordCount(address asset, address shorter)\n        internal\n        view\n        returns (uint256 shortRecordCount)\n    {\n        AppStorage storage s = appStorage();\n\n        // Retrieve first non-HEAD short\n        uint8 id = s.shortRecords[asset][shorter][Constants.HEAD].nextId;\n        if (id <= Constants.HEAD) {\n            return 0;\n        }\n\n        while (true) {\n            shortRecordCount++;\n            // One short of one shorter in this order book\n            STypes.ShortRecord storage currentShort = s.shortRecords[asset][shorter][id];\n            // Move to next short unless this is the last one\n            if (currentShort.nextId > Constants.HEAD) {\n                id = currentShort.nextId;\n            } else {\n                return shortRecordCount;\n            }\n        }\n    }\n\n    function createShortRecord(\n        address asset,\n        address shorter,\n        SR status,\n        uint88 collateral,\n        uint88 ercAmount,\n        uint64 ercDebtRate,\n        uint80 zethYieldRate,\n        uint40 tokenId\n    ) internal returns (uint8 id) {\n        AppStorage storage s = appStorage();\n\n        // ensure the tokenId can be downcasted to 40 bits\n        if (tokenId > type(uint40).max) revert Errors.InvalidTokenId();\n\n        uint8 nextId;\n        (id, nextId) = setShortRecordIds(asset, shorter);\n\n        if (id <= Constants.SHORT_MAX_ID) {\n            s.shortRecords[asset][shorter][id] = STypes.ShortRecord({\n                prevId: Constants.HEAD,\n                id: id,\n                nextId: nextId,\n                status: status,\n                collateral: collateral,\n                ercDebt: ercAmount,\n                ercDebtRate: ercDebtRate,\n                zethYieldRate: zethYieldRate,\n                flaggerId: 0,\n                tokenId: tokenId,\n                updatedAt: LibOrders.getOffsetTimeHours()\n            });\n            emit Events.CreateShortRecord(asset, shorter, id);\n        } else {\n            // All shortRecordIds used, combine into max shortRecordId\n            id = Constants.SHORT_MAX_ID;\n            fillShortRecord(\n                asset,\n                shorter,\n                id,\n                status,\n                collateral,\n                ercAmount,\n                ercDebtRate,\n                zethYieldRate\n            );\n        }\n    }\n\n    function transferShortRecord(\n        address asset,\n        address from,\n        address to,\n        uint40 tokenId,\n        STypes.NFT memory nft\n    ) internal {\n        AppStorage storage s = appStorage();\n        STypes.ShortRecord storage short = s.shortRecords[asset][from][nft.shortRecordId];\n        if (short.status == SR.Cancelled) revert Errors.OriginalShortRecordCancelled();\n        if (short.flaggerId != 0) revert Errors.CannotTransferFlaggedShort();\n\n        deleteShortRecord(asset, from, nft.shortRecordId);\n\n        uint8 id = createShortRecord(\n            asset,\n            to,\n            SR.FullyFilled,\n            short.collateral,\n            short.ercDebt,\n            short.ercDebtRate,\n            short.zethYieldRate,\n            tokenId\n        );\n\n        if (id == Constants.SHORT_MAX_ID) {\n            revert Errors.ReceiverExceededShortRecordLimit();\n        }\n\n        s.nftMapping[tokenId].owner = to;\n        s.nftMapping[tokenId].shortRecordId = id;\n    }\n\n    function fillShortRecord(\n        address asset,\n        address shorter,\n        uint8 shortId,\n        SR status,\n        uint88 collateral,\n        uint88 ercAmount,\n        uint256 ercDebtRate,\n        uint256 zethYieldRate\n    ) internal {\n        AppStorage storage s = appStorage();\n\n        uint256 ercDebtSocialized = ercAmount.mul(ercDebtRate);\n        uint256 yield = collateral.mul(zethYieldRate);\n\n        STypes.ShortRecord storage short = s.shortRecords[asset][shorter][shortId];\n        if (short.status == SR.Cancelled) {\n            short.ercDebt = short.collateral = 0;\n        }\n\n        short.status = status;\n        LibShortRecord.merge(\n            short,\n            ercAmount,\n            ercDebtSocialized,\n            collateral,\n            yield,\n            LibOrders.getOffsetTimeHours()\n        );\n    }\n\n    function deleteShortRecord(address asset, address shorter, uint8 id) internal {\n        AppStorage storage s = appStorage();\n\n        STypes.ShortRecord storage shortRecord = s.shortRecords[asset][shorter][id];\n        // Because of the onlyValidShortRecord modifier, only cancelShort can pass SR.Cancelled\n        // Don't recycle shortRecord id 254 so it can be used for all overflow uint8 ids\n        if (shortRecord.status != SR.PartialFill && id < Constants.SHORT_MAX_ID) {\n            // remove the links of ID in the market\n            // @dev (ID) is exiting, [ID] is inserted\n            // BEFORE: PREV <-> (ID) <-> NEXT\n            // AFTER : PREV <----------> NEXT\n            s.shortRecords[asset][shorter][shortRecord.prevId].nextId = shortRecord.nextId;\n            if (shortRecord.nextId != Constants.HEAD) {\n                s.shortRecords[asset][shorter][shortRecord.nextId].prevId =\n                    shortRecord.prevId;\n            }\n            // Make reuseable for future short records\n            uint8 prevHEAD = s.shortRecords[asset][shorter][Constants.HEAD].prevId;\n            s.shortRecords[asset][shorter][Constants.HEAD].prevId = id;\n            // Move the cancelled ID behind HEAD to re-use it\n            // note: C_IDs (cancelled ids) only need to point back (set prevId, can retain nextId)\n            // BEFORE: .. C_ID2 <- C_ID1 <--------- HEAD <-> ... [ID]\n            // AFTER1: .. C_ID2 <- C_ID1 <- [ID] <- HEAD <-> ...\n            if (prevHEAD > Constants.HEAD) {\n                shortRecord.prevId = prevHEAD;\n            } else {\n                // if this is the first ID cancelled\n                // HEAD.prevId needs to be HEAD\n                // and one of the cancelled id.prevID should point to HEAD\n                // BEFORE: HEAD <--------- HEAD <-> ... [ID]\n                // AFTER1: HEAD <- [ID] <- HEAD <-> ...\n                shortRecord.prevId = Constants.HEAD;\n            }\n\n            //Event for delete SR is emitted here and not at the top level because\n            //SR may be cancelled, but there might tied to an active short order\n            //The code above is hit when that SR id is ready for reuse\n            emit Events.DeleteShortRecord(asset, shorter, id);\n        }\n\n        shortRecord.status = SR.Cancelled;\n    }\n\n    function setShortRecordIds(address asset, address shorter)\n        private\n        returns (uint8 id, uint8 nextId)\n    {\n        AppStorage storage s = appStorage();\n\n        STypes.ShortRecord storage guard = s.shortRecords[asset][shorter][Constants.HEAD];\n        STypes.AssetUser storage AssetUser = s.assetUser[asset][shorter];\n        // Initialize HEAD in case of first short createShortRecord\n        if (AssetUser.shortRecordId == 0) {\n            AssetUser.shortRecordId = Constants.SHORT_STARTING_ID;\n            guard.prevId = Constants.HEAD;\n            guard.nextId = Constants.HEAD;\n        }\n        // BEFORE: HEAD <-> .. <-> PREV <--------------> NEXT\n        // AFTER1: HEAD <-> .. <-> PREV <-> (NEW ID) <-> NEXT\n        // place created short next to HEAD\n        nextId = guard.nextId;\n        uint8 canceledId = guard.prevId;\n        // @dev (ID) is exiting, [ID] is inserted\n        // in this case, the protocol re-uses (ID) and moves it to [ID]\n        // check if a previously closed short exists\n        if (canceledId > Constants.HEAD) {\n            // BEFORE: CancelledID <- (ID) <- HEAD <-> .. <-> PREV <----------> NEXT\n            // AFTER1: CancelledID <--------- HEAD <-> .. <-> PREV <-> [ID] <-> NEXT\n            uint8 prevCanceledId = s.shortRecords[asset][shorter][canceledId].prevId;\n            if (prevCanceledId > Constants.HEAD) {\n                guard.prevId = prevCanceledId;\n            } else {\n                // BEFORE: HEAD <- (ID) <- HEAD <-> .. <-> PREV <----------> NEXT\n                // AFTER1: HEAD <--------- HEAD <-> .. <-> PREV <-> [ID] <-> NEXT\n                guard.prevId = Constants.HEAD;\n            }\n            // re-use the previous order's id\n            id = canceledId;\n        } else {\n            // BEFORE: HEAD <-> .. <-> PREV <--------------> NEXT\n            // AFTER1: HEAD <-> .. <-> PREV <-> (NEW ID) <-> NEXT\n            // otherwise just increment to a new short record id\n            // and the short record grows in height/size\n            id = AssetUser.shortRecordId;\n            // Avoids overflow revert, prevents DOS on uint8\n            if (id < type(uint8).max) {\n                AssetUser.shortRecordId += 1;\n            } else {\n                // If max id reached, match into max shortRecordId\n                return (id, nextId);\n            }\n        }\n\n        if (nextId > Constants.HEAD) {\n            s.shortRecords[asset][shorter][nextId].prevId = id;\n        }\n        guard.nextId = id;\n    }\n\n    function updateErcDebt(address asset, address shorter, uint8 shortId) internal {\n        AppStorage storage s = appStorage();\n\n        STypes.ShortRecord storage short = s.shortRecords[asset][shorter][shortId];\n\n        // Distribute ercDebt\n        uint64 ercDebtRate = s.asset[asset].ercDebtRate;\n        uint88 ercDebt = short.ercDebt.mulU88(ercDebtRate - short.ercDebtRate);\n\n        if (ercDebt > 0) {\n            short.ercDebt += ercDebt;\n            short.ercDebtRate = ercDebtRate;\n        }\n    }\n\n    function updateErcDebt(STypes.ShortRecord storage short, address asset) internal {\n        AppStorage storage s = appStorage();\n\n        // Distribute ercDebt\n        uint64 ercDebtRate = s.asset[asset].ercDebtRate;\n        uint88 ercDebt = short.ercDebt.mulU88(ercDebtRate - short.ercDebtRate);\n\n        if (ercDebt > 0) {\n            short.ercDebt += ercDebt;\n            short.ercDebtRate = ercDebtRate;\n        }\n    }\n\n    function merge(\n        STypes.ShortRecord storage short,\n        uint88 ercDebt,\n        uint256 ercDebtSocialized,\n        uint88 collateral,\n        uint256 yield,\n        uint24 creationTime\n    ) internal {\n        // Resolve ercDebt\n        ercDebtSocialized += short.ercDebt.mul(short.ercDebtRate);\n        short.ercDebt += ercDebt;\n        short.ercDebtRate = ercDebtSocialized.divU64(short.ercDebt);\n        // Resolve zethCollateral\n        yield += short.collateral.mul(short.zethYieldRate);\n        short.collateral += collateral;\n        short.zethYieldRate = yield.divU80(short.collateral);\n        // Assign updatedAt\n        short.updatedAt = creationTime;\n    }\n\n    function disburseCollateral(\n        address asset,\n        address shorter,\n        uint88 collateral,\n        uint256 zethYieldRate,\n        uint24 updatedAt\n    ) internal {\n        AppStorage storage s = appStorage();\n\n        STypes.Asset storage Asset = s.asset[asset];\n        uint256 vault = Asset.vault;\n        STypes.Vault storage Vault = s.vault[vault];\n\n        Vault.zethCollateral -= collateral;\n        Asset.zethCollateral -= collateral;\n        // Distribute yield\n        uint88 yield = collateral.mulU88(Vault.zethYieldRate - zethYieldRate);\n        if (yield > 0) {\n            /*\n            @dev If somebody exits a short, gets margin called, decreases their collateral before YIELD_DELAY_HOURS duration is up,\n            they lose their yield to the TAPP\n            */\n            bool isNotRecentlyModified =\n                LibOrders.getOffsetTimeHours() - updatedAt > Constants.YIELD_DELAY_HOURS;\n            if (isNotRecentlyModified) {\n                s.vaultUser[vault][shorter].ethEscrowed += yield;\n            } else {\n                s.vaultUser[vault][address(this)].ethEscrowed += yield;\n            }\n        }\n    }\n\n    function burnNFT(uint256 tokenId) internal {\n        //@dev No need to check downcast tokenId because it is handled in function that calls burnNFT\n        AppStorage storage s = appStorage();\n        STypes.NFT storage nft = s.nftMapping[tokenId];\n        if (nft.owner == address(0)) revert Errors.NotMinted();\n        address asset = s.assetMapping[nft.assetId];\n        STypes.ShortRecord storage short =\n            s.shortRecords[asset][nft.owner][nft.shortRecordId];\n        delete s.nftMapping[tokenId];\n        delete s.getApproved[tokenId];\n        delete short.tokenId;\n        emit Events.Transfer(nft.owner, address(0), tokenId);\n    }\n\n    function setFlagger(\n        STypes.ShortRecord storage short,\n        address cusd,\n        uint16 flaggerHint\n    ) internal {\n        AppStorage storage s = appStorage();\n        STypes.AssetUser storage flagStorage = s.assetUser[cusd][msg.sender];\n\n        //@dev Whenever a new flagger flags, use the flaggerIdCounter.\n        if (flagStorage.g_flaggerId == 0) {\n            address flaggerToReplace = s.flagMapping[flaggerHint];\n\n            uint256 timeDiff = flaggerToReplace != address(0)\n                ? LibOrders.getOffsetTimeHours()\n                    - s.assetUser[cusd][flaggerToReplace].g_updatedAt\n                : 0;\n            //@dev re-use an inactive flaggerId\n            if (timeDiff > LibAsset.firstLiquidationTime(cusd)) {\n                delete s.assetUser[cusd][flaggerToReplace].g_flaggerId;\n                short.flaggerId = flagStorage.g_flaggerId = flaggerHint;\n            } else if (s.flaggerIdCounter < type(uint16).max) {\n                //@dev generate brand new flaggerId\n                short.flaggerId = flagStorage.g_flaggerId = s.flaggerIdCounter;\n                s.flaggerIdCounter++;\n            } else {\n                revert Errors.InvalidFlaggerHint();\n            }\n            s.flagMapping[short.flaggerId] = msg.sender;\n        } else {\n            //@dev re-use flaggerId if flagger has an existing one\n            short.flaggerId = flagStorage.g_flaggerId;\n        }\n        short.updatedAt = flagStorage.g_updatedAt = LibOrders.getOffsetTimeHours();\n    }\n\n    //@dev reset flag info if new cratio is above primaryLiquidationCR\n    function maybeResetFlag(STypes.ShortRecord storage short, address asset) internal {\n        if (short.flaggerId != 0) {\n            if (\n                LibShortRecord.getCollateralRatio(short, asset)\n                    >= LibAsset.primaryLiquidationCR(asset)\n            ) {\n                LibShortRecord.resetFlag(short);\n            }\n        }\n    }\n\n    function resetFlag(STypes.ShortRecord storage shortRecord) internal {\n        delete shortRecord.flaggerId;\n        shortRecord.updatedAt = LibOrders.getOffsetTimeHours();\n    }\n}"
    },
    {
      "filename": "contracts/libraries/LibOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {AggregatorV3Interface} from\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IDiamond} from \"interfaces/IDiamond.sol\";\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\nlibrary LibOracle {\n    using U256 for uint256;\n\n    function getOraclePrice(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        AggregatorV3Interface baseOracle = AggregatorV3Interface(s.baseOracle);\n        uint256 protocolPrice = getPrice(asset);\n        // prettier-ignore\n        (\n            uint80 baseRoundID,\n            int256 basePrice,\n            /*uint256 baseStartedAt*/\n            ,\n            uint256 baseTimeStamp,\n            /*uint80 baseAnsweredInRound*/\n        ) = baseOracle.latestRoundData();\n\n        AggregatorV3Interface oracle = AggregatorV3Interface(s.asset[asset].oracle);\n        if (address(oracle) == address(0)) revert Errors.InvalidAsset();\n\n        if (oracle == baseOracle) {\n            //@dev multiply base oracle by 10**10 to give it 18 decimals of precision\n            uint256 basePriceInEth = basePrice > 0\n                ? uint256(basePrice * Constants.BASE_ORACLE_DECIMALS).inv()\n                : 0;\n            basePriceInEth = baseOracleCircuitBreaker(\n                protocolPrice, baseRoundID, basePrice, baseTimeStamp, basePriceInEth\n            );\n            return basePriceInEth;\n        } else {\n            // prettier-ignore\n            (\n                uint80 roundID,\n                int256 price,\n                /*uint256 startedAt*/\n                ,\n                uint256 timeStamp,\n                /*uint80 answeredInRound*/\n            ) = oracle.latestRoundData();\n            uint256 priceInEth = uint256(price).div(uint256(basePrice));\n            oracleCircuitBreaker("
    }
  ]
}