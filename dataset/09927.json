{
  "Title": "[G-07] Cache array length in for loops can save gas",
  "Content": "\n_Note: suggested optimation, save a decent amount of gas without compromising readability._\n\nReading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.\n\nCaching the array length in the stack saves around 3 gas per iteration.\n\nInstances include:\n\n[TokemakBribe.sol#L147-L152](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L147-L152)\n\n[BribeVault.sol#L261-L275](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L261-L275)\n\n[RewardDistributor.sol#L80-L82](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/RewardDistributor.sol#L80-L82)\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-02-redacted-cartel-contest",
  "Code": [
    {
      "filename": "contracts/TokemakBribe.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ninterface IBribeVault {\n    function depositBribeERC20(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address token,\n        uint256 amount,\n        address briber\n    ) external;\n\n    function getBribe(bytes32 bribeIdentifier)\n        external\n        view\n        returns (address token, uint256 amount);\n\n    function depositBribe(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address briber\n    ) external payable;\n}\n\ncontract TokemakBribe is AccessControl {\n    address public bribeVault;\n\n    // Used for generating the bribe and reward identifiers\n    string public constant protocol = \"TOKEMAK\";\n    uint256 private _round;\n\n    // Proposal addresses mapped to deadlines by which bribers can deposit\n    mapping(address => uint256) public proposalDeadlines;\n\n    // Voter addresses mapped to addresses which will claim rewards on their behalf\n    mapping(address => address) public rewardForwarding;\n\n    bytes32 public constant TEAM_ROLE = keccak256(\"TEAM_ROLE\");\n\n    event GrantTeamRole(address teamMember);\n    event RevokeTeamRole(address teamMember);\n    event SetProposal(\n        address indexed proposal,\n        uint256 deadline,\n        uint256 indexed round\n    );\n    event SetProposals(address[] proposals, uint256[] deadlines, uint256 round);\n    event DepositBribe(\n        address indexed proposal,\n        uint256 indexed round,\n        address indexed token,\n        uint256 amount,\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier\n    );\n    event SetRewardForwarding(address from, address to);\n\n    constructor(address _bribeVault) {\n        require(_bribeVault != address(0), \"Invalid bribeVault\");\n        bribeVault = _bribeVault;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    modifier onlyAuthorized() {\n        require(\n            hasRole(DEFAULT_ADMIN_ROLE, msg.sender) ||\n                hasRole(TEAM_ROLE, msg.sender),\n            \"Not authorized\"\n        );\n        _;\n    }\n\n    /**\n        @notice Grant the team role to an address\n        @param  teamMember  address  Address to grant the teamMember role\n     */\n    function grantTeamRole(address teamMember)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(teamMember != address(0), \"Invalid teamMember\");\n        _grantRole(TEAM_ROLE, teamMember);\n\n        emit GrantTeamRole(teamMember);\n    }\n\n    /**\n        @notice Revoke the team role from an address\n        @param  teamMember  address  Address to revoke the teamMember role\n     */\n    function revokeTeamRole(address teamMember)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(hasRole(TEAM_ROLE, teamMember), \"Invalid teamMember\");\n        _revokeRole(TEAM_ROLE, teamMember);\n\n        emit RevokeTeamRole(teamMember);\n    }\n\n    /**\n        @notice Set a new voting round\n        @param  _newRound uint256 The new round number\n     */\n    function setRound(uint256 _newRound) external onlyAuthorized {\n        _round = _newRound;\n    }\n\n    /**\n        @notice Set a new voting round\n        @return round uint256 The current round number\n     */\n    function getRound() external view returns (uint256) {\n        return _round;\n    }\n\n    /**\n        @notice Set a single proposal\n        @param  proposal  addresss Proposal address\n        @param  deadline  uint256  Proposal deadline\n     */\n    function setProposal(address proposal, uint256 deadline)\n        public\n        onlyAuthorized\n    {\n        require(proposal != address(0), \"Invalid proposal\");\n        require(deadline >= block.timestamp, \"Deadline must be in the future\");\n\n        proposalDeadlines[proposal] = deadline;\n\n        emit SetProposal(proposal, deadline, _round);\n    }\n\n    /**\n        @notice Set multiple proposals\n        @param  proposals  address[]  Proposal addresses\n        @param  deadlines  uint256[]  Proposal deadlines\n     */\n    function setProposals(\n        address[] calldata proposals,\n        uint256[] calldata deadlines\n    ) external onlyAuthorized {\n        require(proposals.length > 0, \"Need at least 1 proposal\");\n        require(\n            proposals.length == deadlines.length,\n            \"Must be equal # of proposals and deadlines\"\n        );\n\n        for (uint256 i = 0; i < proposals.length; i += 1) {\n            setProposal(proposals[i], deadlines[i]);\n        }\n\n        emit SetProposals(proposals, deadlines, _round);\n    }\n\n    /**\n        @notice Generate the BribeVault identifier based on a scheme\n        @param  proposal    address  Proposal\n        @param  round       uint256  Voting round\n        @param  token       address  Token\n        @return identifier  bytes32  BribeVault identifier\n     */\n    function generateBribeVaultIdentifier(\n        address proposal,\n        uint256 round,\n        address token\n    ) internal pure returns (bytes32 identifier) {\n        return keccak256(abi.encodePacked(protocol, proposal, round, token));\n    }\n\n    /**\n        @notice Generate the reward identifier based on a scheme\n        @param  round       uint256  Round\n        @param  token       address  Token\n        @return identifier  bytes32  Reward identifier\n     */\n    function generateRewardIdentifier(uint256 round, address token)\n        internal\n        pure\n        returns (bytes32 identifier)\n    {\n        return keccak256(abi.encodePacked(protocol, round, token));\n    }\n\n    /**\n        @notice Get bribe from BribeVault\n        @param  proposal            address  Proposal\n        @param  token               address  Token\n        @return bribeToken          address  Token address\n        @return bribeAmount         address  Token address\n     */\n    function getBribe(\n        address proposal,\n        uint256 round,\n        address token\n    ) external view returns (address bribeToken, uint256 bribeAmount) {\n        return\n            IBribeVault(bribeVault).getBribe(\n                generateBribeVaultIdentifier(proposal, round, token)\n            );\n    }\n\n    /**\n        @notice Deposit bribe for a proposal (ERC20 tokens only)\n        @param  proposal  address  Proposal\n        @param  token     address  Token\n        @param  amount    uint256  Token amount\n     */\n    function depositBribeERC20(\n        address proposal,\n        address token,\n        uint256 amount\n    ) external {\n        uint256 currentRound = _round;\n        require(\n            proposalDeadlines[proposal] > block.timestamp,\n            \"Proposal deadline has passed\"\n        );\n        require(token != address(0), \"Invalid token\");\n        require(amount > 0, \"Bribe amount must be greater than 0\");\n\n        bytes32 bribeIdentifier = generateBribeVaultIdentifier(\n            proposal,\n            currentRound,\n            token\n        );\n        bytes32 rewardIdentifier = generateRewardIdentifier(\n            currentRound,\n            token\n        );\n\n        IBribeVault(bribeVault).depositBribeERC20(\n            bribeIdentifier,\n            rewardIdentifier,\n            token,\n            amount,\n            msg.sender\n        );\n\n        emit DepositBribe(\n            proposal,\n            currentRound,\n            token,\n            amount,\n            bribeIdentifier,\n            rewardIdentifier\n        );\n    }\n\n    /**\n        @notice Deposit bribe for a proposal (native token only)\n        @param  proposal  address  Proposal\n     */\n    function depositBribe(address proposal) external payable {\n        uint256 currentRound = _round;\n        require(\n            proposalDeadlines[proposal] > block.timestamp,\n            \"Proposal deadline has passed\"\n        );\n        require(msg.value > 0, \"Bribe amount must be greater than 0\");\n\n        bytes32 bribeIdentifier = generateBribeVaultIdentifier(\n            proposal,\n            currentRound,\n            bribeVault\n        );\n        bytes32 rewardIdentifier = generateRewardIdentifier(\n            currentRound,\n            bribeVault\n        );\n\n        IBribeVault(bribeVault).depositBribe{value: msg.value}(\n            // NOTE: Native token bribes have bribeVault set as the address\n            bribeIdentifier,\n            rewardIdentifier,\n            msg.sender\n        );\n\n        emit DepositBribe(\n            proposal,\n            currentRound,\n            bribeVault,\n            msg.value,\n            bribeIdentifier,\n            rewardIdentifier\n        );\n    }\n\n    /**\n        @notice Voters can opt in or out of reward-forwarding\n        @notice Opt-in: A voter sets another address to forward rewards to\n        @notice Opt-out: A voter sets their own address or the zero address\n        @param  to  address  Account that rewards will be sent to\n     */\n    function setRewardForwarding(address to) public {\n        rewardForwarding[msg.sender] = to;\n\n        emit SetRewardForwarding(msg.sender, to);\n    }\n}"
    },
    {
      "filename": "contracts/BribeVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Common} from \"./libraries/Common.sol\";\n\ninterface IRewardDistributor {\n    function updateRewardsMetadata(\n        Common.Distribution[] calldata _distributions\n    ) external;\n}\n\ncontract BribeVault is AccessControl {\n    using SafeERC20 for IERC20;\n\n    struct Bribe {\n        address token;\n        uint256 amount;\n    }\n\n    uint256 public fee; // 5000 = 0.5%\n    address public feeRecipient; // Protocol treasury\n    address public distributor; // RewardDistributor contract\n    uint256 public constant feeDivisor = 1000000;\n    bytes32 public constant DEPOSITOR_ROLE = keccak256(\"DEPOSITOR_ROLE\");\n\n    // Bribe identifiers mapped to Bribe structs\n    // A bribe identifier is composed of different info (e.g. protocol, voting round, etc.)\n    mapping(bytes32 => Bribe) public bribes;\n\n    // Protocol-specific reward identifiers mapped to bribe identifiers\n    // Allows us to group bribes by reward tokens (one token may be used across many bribes)\n    mapping(bytes32 => bytes32[]) public rewardToBribes;\n\n    event GrantDepositorRole(address depositor);\n    event RevokeDepositorRole(address depositor);\n    event SetFee(uint256 _fee);\n    event SetFeeRecipient(address _feeRecipient);\n    event SetDistributor(address _distributor);\n    event DepositBribe(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address token,\n        uint256 amount,\n        uint256 totalAmount,\n        address briber\n    );\n    event TransferBribe(\n        bytes32 rewardIdentifier,\n        address token,\n        bytes32 proof,\n        uint256 feeAmount,\n        uint256 distributorAmount\n    );\n    event EmergencyWithdrawal(address token, uint256 amount, address admin);\n\n    constructor(\n        uint256 _fee,\n        address _feeRecipient,\n        address _distributor\n    ) {\n        require(_fee <= feeDivisor, \"Invalid fee\");\n        fee = _fee;\n\n        require(_feeRecipient != address(0), \"Invalid feeRecipient\");\n        feeRecipient = _feeRecipient;\n\n        require(_distributor != address(0), \"Invalid distributor\");\n        distributor = _distributor;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /**\n        @notice Grant the depositor role to an address\n        @param  depositor  address  Address to grant the depositor role\n     */\n    function grantDepositorRole(address depositor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(depositor != address(0), \"Invalid depositor\");\n        _grantRole(DEPOSITOR_ROLE, depositor);\n\n        emit GrantDepositorRole(depositor);\n    }\n\n    /**\n        @notice Revoke the depositor role from an address\n        @param  depositor  address  Address to revoke the depositor role\n     */\n    function revokeDepositorRole(address depositor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(hasRole(DEPOSITOR_ROLE, depositor), \"Invalid depositor\");\n        _revokeRole(DEPOSITOR_ROLE, depositor);\n\n        emit RevokeDepositorRole(depositor);\n    }\n\n    /**\n        @notice Set the fee collected by the protocol\n        @param  _fee  uint256  Fee\n     */\n    function setFee(uint256 _fee) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_fee <= feeDivisor, \"Invalid _fee\");\n        fee = _fee;\n\n        emit SetFee(_fee);\n    }\n\n    /**\n        @notice Set the protocol address where fees will be transferred\n        @param  _feeRecipient  address  Fee recipient\n     */\n    function setFeeRecipient(address _feeRecipient)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_feeRecipient != address(0), \"Invalid feeRecipient\");\n        feeRecipient = _feeRecipient;\n\n        emit SetFeeRecipient(_feeRecipient);\n    }\n\n    /**\n        @notice Set the RewardDistributor contract address\n        @param  _distributor  address  Distributor\n     */\n    function setDistributor(address _distributor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_distributor != address(0), \"Invalid distributor\");\n        distributor = _distributor;\n\n        emit SetDistributor(_distributor);\n    }\n\n    /**\n        @notice Get bribe information based on the specified identifier\n        @param  bribeIdentifier  bytes32  The specified bribe identifier\n     */\n    function getBribe(bytes32 bribeIdentifier)\n        external\n        view\n        returns (address token, uint256 amount)\n    {\n        Bribe memory b = bribes[bribeIdentifier];\n        return (b.token, b.amount);\n    }\n\n    /**\n        @notice Deposit bribe (ERC20 only)\n        @param  bribeIdentifier   bytes32  Unique identifier related to bribe\n        @param  rewardIdentifier  bytes32  Unique identifier related to reward\n        @param  token             address  Bribe token\n        @param  amount            uint256  Bribe token amount\n        @param  briber            address  Address that originally called the depositor contract\n     */\n    function depositBribeERC20(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address token,\n        uint256 amount,\n        address briber\n    ) external onlyRole(DEPOSITOR_ROLE) {\n        require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");\n        require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");\n        require(token != address(0), \"Invalid token\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(briber != address(0), \"Invalid briber\");\n\n        Bribe storage b = bribes[bribeIdentifier];\n        address currentToken = b.token;\n        require(\n            // If bribers want to bribe with a different token they need a new identifier\n            currentToken == address(0) || currentToken == token,\n            \"Cannot change token\"\n        );\n\n        // Since this method is called by a depositor contract, we must transfer from the account\n        // that called the depositor contract - amount must be approved beforehand\n        IERC20(token).safeTransferFrom(briber, address(this), amount);\n\n        b.amount += amount; // Allow bribers to increase bribe\n\n        // Only set the token address and update the reward-to-bribe mapping if not yet set\n        if (currentToken == address(0)) {\n            b.token = token;\n            rewardToBribes[rewardIdentifier].push(bribeIdentifier);\n        }\n\n        emit DepositBribe(\n            bribeIdentifier,\n            rewardIdentifier,\n            token,\n            amount,\n            b.amount,\n            briber\n        );\n    }\n\n    /**\n        @notice Deposit bribe (native token only)\n        @param  bribeIdentifier   bytes32 Unique identifier related to bribe\n        @param  rewardIdentifier  bytes32 Unique identifier related to reward\n        @param  briber            address  Address that originally called the depositor contract\n     */\n    function depositBribe(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address briber\n    ) external payable onlyRole(DEPOSITOR_ROLE) {\n        require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");\n        require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");\n        require(briber != address(0), \"Invalid briber\");\n        require(msg.value > 0, \"Value must be greater than 0\");\n\n        Bribe storage b = bribes[bribeIdentifier];\n        address currentToken = b.token;\n        require(\n            // For native tokens, the token address is set to this contract to prevent\n            // overwriting storage - the address can be anything but address(this) safer\n            currentToken == address(0) || currentToken == address(this),\n            \"Cannot change token\"\n        );\n\n        b.amount += msg.value; // Allow bribers to increase bribe\n\n        // Only set the token address and update the reward-to-bribe mapping if not yet set\n        if (currentToken == address(0)) {\n            b.token = address(this);\n            rewardToBribes[rewardIdentifier].push(bribeIdentifier);\n        }\n\n        emit DepositBribe(\n            bribeIdentifier,\n            rewardIdentifier,\n            b.token,\n            msg.value,\n            b.amount,\n            briber\n        );\n    }\n\n    /**\n        @notice Transfer fees to fee recipient and bribes to distributor and update rewards metadata\n        @param  distributions    Distribution[] List of distribution details\n        @param  amounts          uint256[] List of amounts for distributor\n        @param  fees             uint256[] List of fee amounts for fee recipient\n     */\n    function transferBribes(\n        Common.Distribution[] calldata distributions,\n        uint256[] calldata amounts,\n        uint256[] calldata fees\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(distributions.length > 0, \"Invalid distributions\");\n        require(\n            distributions.length == amounts.length &&\n                distributions.length == fees.length,\n            \"Distributions, amounts, and fees must contain the same # of elements\"\n        );\n\n        // Transfer the bribe funds to fee recipient and reward distributor\n        for (uint256 i = 0; i < distributions.length; i++) {\n            bytes32 rewardIdentifier = distributions[i].rewardIdentifier;\n            uint256 distributorAmount = amounts[i];\n            uint256 feeAmount = fees[i];\n            address token = distributions[i].token;\n            require(\n                rewardToBribes[rewardIdentifier].length > 0,\n                \"Invalid reward identifier\"\n            );\n            require(token != address(0), \"Invalid token address\");\n            require(distributorAmount > 0, \"Invalid pending reward amount\");\n\n            // Check whether it's a native token reward\n            if (token == address(this)) {\n                (bool sentFeeRecipient, ) = feeRecipient.call{value: feeAmount}(\n                    \"\"\n                );\n                require(\n                    sentFeeRecipient,\n                    \"Failed to transfer to fee recipient\"\n                );\n\n                (bool sentDistributor, ) = distributor.call{\n                    value: distributorAmount\n                }(\"\");\n                require(sentDistributor, \"Failed to transfer to distributor\");\n            } else {\n                IERC20(token).transfer(feeRecipient, feeAmount);\n                IERC20(token).transfer(distributor, distributorAmount);\n            }\n\n            emit TransferBribe(\n                rewardIdentifier,\n                token,\n                distributions[i].proof,\n                feeAmount,\n                distributorAmount\n            );\n        }\n\n        // Update the rewards' metadata\n        IRewardDistributor(distributor).updateRewardsMetadata(distributions);\n    }\n\n    /**\n        @notice Update the rewards metadata of the specified identifiers (only if absolutely needed)\n        @param  distributions    Distribution[] List of distribution details\n     */\n    function updateRewardsMetadata(Common.Distribution[] calldata distributions)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(distributions.length > 0, \"Invalid distributions\");\n        IRewardDistributor(distributor).updateRewardsMetadata(distributions);\n    }\n\n    /**\n        @notice Withdraw ERC20 tokens to the admin address\n        @param  token   address  Token address\n        @param  amount  uint256  Token amount\n     */\n    function emergencyWithdrawERC20(address token, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(token != address(0), \"Invalid token\");\n        require(amount > 0, \"Invalid amount\");\n\n        IERC20(token).transfer(msg.sender, amount);\n\n        emit EmergencyWithdrawal(token, amount, msg.sender);\n    }\n\n    /**\n        @notice Withdraw native tokens to the admin address\n        @param  amount  uint256  Token amount\n     */\n    function emergencyWithdraw(uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(amount > 0, \"Invalid amount\");\n\n        (bool sentAdmin, ) = msg.sender.call{value: amount}(\"\");\n        require(sentAdmin, \"Failed to withdraw\");\n\n        emit EmergencyWithdrawal(address(this), amount, msg.sender);\n    }\n}"
    },
    {
      "filename": "contracts/RewardDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport {Common} from \"./libraries/Common.sol\";\n\ncontract RewardDistributor is AccessControl, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    struct Reward {\n        address token;\n        bytes32 merkleRoot;\n        bytes32 proof;\n        uint256 updateCount;\n    }\n\n    struct Claim {\n        bytes32 identifier;\n        address account;\n        uint256 index;\n        uint256 amount;\n        bytes32[] merkleProof;\n    }\n\n    address public bribeVault;\n    mapping(bytes32 => Reward) public rewards; // Maps each of the reward identifier to its metadata\n    mapping(bytes32 => mapping(uint256 => mapping(uint256 => uint256)))\n        private claimed; // Tracks whether a specific reward claim has been done\n\n    event SetBribeVault(address _bribeVault);\n    event RewardClaimed(\n        bytes32 indexed identifier,\n        address indexed tokenAddress,\n        address indexed account,\n        uint256 updateCount,\n        uint256 index,\n        uint256 amount\n    );\n    event RewardMetadataUpdated(\n        bytes32 indexed identifier,\n        address indexed token,\n        bytes32 merkleRoot,\n        bytes32 proof,\n        uint256 indexed updateCount\n    );\n\n    constructor(address _bribeVault) {\n        require(_bribeVault != address(0), \"Invalid bribeVault\");\n        bribeVault = _bribeVault;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    // Enables BribeVault to transfer native tokens\n    receive() external payable {}\n\n    /**\n        @notice Set bribe vault\n        @param  _bribeVault address New address of the bribe vault\n     */\n    function setBribeVault(address _bribeVault)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_bribeVault != address(0), \"Invalid bribeVault\");\n        bribeVault = _bribeVault;\n\n        emit SetBribeVault(bribeVault);\n    }\n\n    /**\n        @notice Claim rewards based on the specified metadata\n        @param  _claims   Claim[] List of claim metadata\n     */\n    function claim(Claim[] calldata _claims) external nonReentrant {\n        require(_claims.length > 0, \"Invalid _claims\");\n\n        for (uint256 i = 0; i < _claims.length; i++) {\n            _claim(\n                _claims[i].identifier,\n                _claims[i].index,\n                _claims[i].account,\n                _claims[i].amount,\n                _claims[i].merkleProof\n            );\n        }\n    }\n\n    /**\n        @notice Update the overall metadata of the specified reward identifiers\n        @param  _distributions    Distribution[] List of reward distribution details\n     */\n    function updateRewardsMetadata(\n        Common.Distribution[] calldata _distributions\n    ) external {\n        require(msg.sender == bribeVault, \"Invalid access\");\n        require(_distributions.length > 0, \"Invalid _distributions\");\n\n        for (uint256 i = 0; i < _distributions.length; i++) {\n            // Update the metadata and also increment the update to reset the claimed tracker\n            Reward storage reward = rewards[_distributions[i].rewardIdentifier];\n            reward.token = _distributions[i].token;\n            reward.merkleRoot = _distributions[i].merkleRoot;\n            reward.proof = _distributions[i].proof;\n            reward.updateCount += 1;\n\n            emit RewardMetadataUpdated(\n                _distributions[i].rewardIdentifier,\n                _distributions[i].token,\n                _distributions[i].merkleRoot,\n                _distributions[i].proof,\n                reward.updateCount\n            );\n        }\n    }\n\n    /**\n        @notice Check if the reward on the specified identifier and index has been claimed\n        @param  _identifier    bytes32 The specified identifier\n        @param  _index         bytes32 The specified index\n        @return  claimed       bool    Whether reward has been claimed\n     */\n    function isRewardClaimed(bytes32 _identifier, uint256 _index)\n        public\n        view\n        returns (bool)\n    {\n        // Get the group index for the specified index along with the bit index\n        // and check if the corresponding bit index is flipped\n        Reward memory reward = rewards[_identifier];\n        uint256 claimedGroup = _index / 256;\n        uint256 claimedIndex = _index % 256;\n        uint256 claimedGroupState = claimed[_identifier][reward.updateCount][\n            claimedGroup\n        ];\n        uint256 mask = (1 << claimedIndex);\n        return claimedGroupState & mask == mask;\n    }\n\n    /**\n        @notice Claim a reward\n        @param  _rewardIdentifier  bytes32    Reward identifier\n        @param  _index             uint256    Node index\n        @param  _account           address    Eligible user account\n        @param  _amount            bytes32    Reward amount\n        @param  _merkleProof       bytes32[]  Merkle proof\n     */\n    function _claim(\n        bytes32 _rewardIdentifier,\n        uint256 _index,\n        address _account,\n        uint256 _amount,\n        bytes32[] calldata _merkleProof\n    ) internal {\n        Reward memory reward = rewards[_rewardIdentifier];\n        require(reward.merkleRoot != 0, \"Distribution not enabled\");\n        require(\n            !isRewardClaimed(_rewardIdentifier, _index),\n            \"Reward already claimed\"\n        );\n\n        // Verify the merkle proof\n        bytes32 node = keccak256(abi.encodePacked(_index, _account, _amount));\n        require(\n            MerkleProof.verify(_merkleProof, reward.merkleRoot, node),\n            \"Invalid proof\"\n        );\n\n        _setClaimed(_rewardIdentifier, _index);\n\n        // Check whether the reward is in the form of native tokens or ERC20\n        // by checking if the token address is set to the bribe vault or not\n        address token = reward.token;\n        if (token != bribeVault) {\n            IERC20(token).safeTransfer(_account, _amount);\n        } else {\n            payable(_account).transfer(_amount);\n        }\n\n        emit RewardClaimed(\n            _rewardIdentifier,\n            token,\n            _account,\n            reward.updateCount,\n            _index,\n            _amount\n        );\n    }\n\n    /**\n        @notice Set a reward as claimed\n        @param  _identifier  bytes32    Reward identifier\n        @param  _index       uint256    Node index\n     */\n    function _setClaimed(bytes32 _identifier, uint256 _index) internal {\n        Reward memory reward = rewards[_identifier];\n        uint256 claimedGroup = _index / 256;\n        uint256 claimedIndex = _index % 256;\n\n        // Flip the bit state to mark the corresponding index as claimed\n        claimed[_identifier][reward.updateCount][claimedGroup] =\n            claimed[_identifier][reward.updateCount][claimedGroup] |\n            (1 << claimedIndex);\n    }\n}"
    }
  ]
}