{
  "Title": "Potentially Stuck ETH from Incorrect Data Parameter",
  "Content": "The protocol allows users to bridge their assets to the L2 rollup and back through the `L1ScrollMessenger` and the `L2ScrollMessenger`. When bridging from L1 to L2, the [`_executeMessage`](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/L2/L2ScrollMessenger.sol#L182) will be called. On [line 198](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/L2/L2ScrollMessenger.sol#L198) of this function, the `_to` address is called and the `_message` is passed to this function. If a user accidentally sets a value in the `_message` field, but either the `_to` address is an EOA, the message is in an incorrect format, or the address is a contract that does not support the data in this field, the user's assets will be stuck on L1, as the L1 transaction has succeeded but the L2 transaction will fail.\n\n\nThe replaying of this message will not help, as the `_message` field cannot be changed for a replay, and assuming that the transaction was not skipped, [`dropMessage`](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/L1/L1ScrollMessenger.sol#L241) cannot be called to get a refund.\n\n\nTo avoid funds being lost when bridging, consider adding a way for users to be refunded when the bridging transaction cannot be completed (for example when the transaction reverts or is skipped), and when the gas limit exceeds the gas effectively consumed.\n\n\n***Update:** Acknowledged, will resolve. The Scroll team stated that they will resolve the issue:*\n\n\n\n> *This will be resolved if we implement the refund feature.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/L2/L2ScrollMessenger.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.16;\n\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport {IL2ScrollMessenger} from \"./IL2ScrollMessenger.sol\";\nimport {L2MessageQueue} from \"./predeploys/L2MessageQueue.sol\";\nimport {IL1BlockContainer} from \"./predeploys/IL1BlockContainer.sol\";\nimport {IL1GasPriceOracle} from \"./predeploys/IL1GasPriceOracle.sol\";\n\nimport {PatriciaMerkleTrieVerifier} from \"../libraries/verifier/PatriciaMerkleTrieVerifier.sol\";\nimport {ScrollConstants} from \"../libraries/constants/ScrollConstants.sol\";\nimport {AddressAliasHelper} from \"../libraries/common/AddressAliasHelper.sol\";\nimport {IScrollMessenger} from \"../libraries/IScrollMessenger.sol\";\nimport {ScrollMessengerBase} from \"../libraries/ScrollMessengerBase.sol\";\n\n// solhint-disable reason-string\n\n/// @title L2ScrollMessenger\n/// @notice The `L2ScrollMessenger` contract can:\n///\n/// 1. send messages from layer 2 to layer 1;\n/// 2. relay messages from layer 1 layer 2;\n/// 3. drop expired message due to sequencer problems.\n///\n/// @dev It should be a predeployed contract in layer 2 and should hold infinite amount\n/// of Ether (Specifically, `uint256(-1)`), which can be initialized in Genesis Block.\ncontract L2ScrollMessenger is ScrollMessengerBase, PausableUpgradeable, IL2ScrollMessenger {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the maximum number of times each message can fail in L2 is updated.\n    /// @param maxFailedExecutionTimes The new maximum number of times each message can fail in L2.\n    event UpdateMaxFailedExecutionTimes(uint256 maxFailedExecutionTimes);\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The address of L2MessageQueue.\n    address public immutable messageQueue;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from L2 message hash to sent status.\n    mapping(bytes32 => bool) public isL2MessageSent;\n\n    /// @notice Mapping from L1 message hash to a boolean value indicating if the message has been successfully executed.\n    mapping(bytes32 => bool) public isL1MessageExecuted;\n\n    /// @notice Mapping from L1 message hash to the number of failure times.\n    mapping(bytes32 => uint256) public l1MessageFailedTimes;\n\n    /// @notice The maximum number of times each L1 message can fail on L2.\n    uint256 public maxFailedExecutionTimes;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(address _messageQueue) {\n        _disableInitializers();\n\n        messageQueue = _messageQueue;\n    }\n\n    function initialize(address _counterpart, address _feeVault) external initializer {\n        PausableUpgradeable.__Pausable_init();\n        ScrollMessengerBase._initialize(_counterpart, _feeVault);\n\n        maxFailedExecutionTimes = 3;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit);\n    }\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes calldata _message,\n        uint256 _gasLimit,\n        address\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit);\n    }\n\n    /// @inheritdoc IL2ScrollMessenger\n    function relayMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _nonce,\n        bytes memory _message\n    ) external override whenNotPaused {\n        // It is impossible to deploy a contract with the same address, reentrance is prevented in nature.\n        require(AddressAliasHelper.undoL1ToL2Alias(msg.sender) == counterpart, \"Caller is not L1ScrollMessenger\");\n\n        bytes32 _xDomainCalldataHash = keccak256(_encodeXDomainCalldata(_from, _to, _value, _nonce, _message));\n\n        require(!isL1MessageExecuted[_xDomainCalldataHash], \"Message was already successfully executed\");\n\n        _executeMessage(_from, _to, _value, _message, _xDomainCalldataHash);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Pause the contract\n    /// @dev This function can only called by contract owner.\n    /// @param _status The pause status to update.\n    function setPause(bool _status) external onlyOwner {\n        if (_status) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    /// @notice Update max failed execution times.\n    /// @dev This function can only called by contract owner.\n    /// @param _maxFailedExecutionTimes The new max failed execution times.\n    function updateMaxFailedExecutionTimes(uint256 _maxFailedExecutionTimes) external onlyOwner {\n        require(_maxFailedExecutionTimes > 0, \"maxFailedExecutionTimes cannot be zero\");\n\n        maxFailedExecutionTimes = _maxFailedExecutionTimes;\n\n        emit UpdateMaxFailedExecutionTimes(_maxFailedExecutionTimes);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to send cross domain message.\n    /// @param _to The address of account who receive the message.\n    /// @param _value The amount of ether passed when call target contract.\n    /// @param _message The content of the message.\n    /// @param _gasLimit Optional gas limit to complete the message relay on corresponding chain.\n    function _sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit\n    ) internal nonReentrant {\n        require(msg.value == _value, \"msg.value mismatch\");\n\n        uint256 _nonce = L2MessageQueue(messageQueue).nextMessageIndex();\n        bytes32 _xDomainCalldataHash = keccak256(_encodeXDomainCalldata(msg.sender, _to, _value, _nonce, _message));\n\n        // normally this won't happen, since each message has different nonce, but just in case.\n        require(!isL2MessageSent[_xDomainCalldataHash], \"Duplicated message\");\n        isL2MessageSent[_xDomainCalldataHash] = true;\n\n        L2MessageQueue(messageQueue).appendMessage(_xDomainCalldataHash);\n\n        emit SentMessage(msg.sender, _to, _value, _nonce, _gasLimit, _message);\n    }\n\n    /// @dev Internal function to execute a L1 => L2 message.\n    /// @param _from The address of the sender of the message.\n    /// @param _to The address of the recipient of the message.\n    /// @param _value The msg.value passed to the message call.\n    /// @param _message The content of the message.\n    /// @param _xDomainCalldataHash The hash of the message.\n    function _executeMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        bytes32 _xDomainCalldataHash\n    ) internal {\n        // @note check more `_to` address to avoid attack in the future when we add more gateways.\n        require(_to != messageQueue, \"Forbid to call message queue\");\n        require(_to != address(this), \"Forbid to call self\");\n\n        // @note This usually will never happen, just in case.\n        require(_from != xDomainMessageSender, \"Invalid message sender\");\n\n        xDomainMessageSender = _from;\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = _to.call{value: _value}(_message);\n        // reset value to refund gas.\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n\n        if (success) {\n            isL1MessageExecuted[_xDomainCalldataHash] = true;\n            emit RelayedMessage(_xDomainCalldataHash);\n        } else {\n            unchecked {\n                uint256 _failedTimes = l1MessageFailedTimes[_xDomainCalldataHash] + 1;\n                require(_failedTimes <= maxFailedExecutionTimes, \"Exceed maximum failure times\");\n                l1MessageFailedTimes[_xDomainCalldataHash] = _failedTimes;\n            }\n            emit FailedRelayedMessage(_xDomainCalldataHash);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/src/L1/L1ScrollMessenger.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.16;\n\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport {IScrollChain} from \"./rollup/IScrollChain.sol\";\nimport {IL1MessageQueue} from \"./rollup/IL1MessageQueue.sol\";\nimport {IL1ScrollMessenger} from \"./IL1ScrollMessenger.sol\";\nimport {ScrollConstants} from \"../libraries/constants/ScrollConstants.sol\";\nimport {IScrollMessenger} from \"../libraries/IScrollMessenger.sol\";\nimport {ScrollMessengerBase} from \"../libraries/ScrollMessengerBase.sol\";\nimport {AddressAliasHelper} from \"../libraries/common/AddressAliasHelper.sol\";\nimport {WithdrawTrieVerifier} from \"../libraries/verifier/WithdrawTrieVerifier.sol\";\n\nimport {IMessageDropCallback} from \"../libraries/callbacks/IMessageDropCallback.sol\";\n\n// solhint-disable avoid-low-level-calls\n// solhint-disable reason-string\n\n/// @title L1ScrollMessenger\n/// @notice The `L1ScrollMessenger` contract can:\n///\n/// 1. send messages from layer 1 to layer 2;\n/// 2. relay messages from layer 2 layer 1;\n/// 3. replay failed message by replacing the gas limit;\n/// 4. drop expired message due to sequencer problems.\n///\n/// @dev All deposited Ether (including `WETH` deposited throng `L1WETHGateway`) will locked in\n/// this contract.\ncontract L1ScrollMessenger is PausableUpgradeable, ScrollMessengerBase, IL1ScrollMessenger {\n    /***********\n     * Structs *\n     ***********/\n\n    struct ReplayState {\n        // The number of replayed times.\n        uint128 times;\n        // The queue index of lastest replayed one. If it is zero, it means the message has not been replayed.\n        uint128 lastIndex;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from L1 message hash to sent status.\n    mapping(bytes32 => bool) public isL1MessageSent;\n\n    /// @notice Mapping from L2 message hash to a boolean value indicating if the message has been successfully executed.\n    mapping(bytes32 => bool) public isL2MessageExecuted;\n\n    /// @notice Mapping from L1 message hash to drop status.\n    mapping(bytes32 => bool) public isL1MessageDropped;\n\n    /// @notice The address of Rollup contract.\n    address public rollup;\n\n    /// @notice The address of L1MessageQueue contract.\n    address public messageQueue;\n\n    /// @notice The maximum number of times each L1 message can be replayed.\n    uint256 public maxReplayTimes;\n\n    /// @notice Mapping from L1 message hash to replay state.\n    mapping(bytes32 => ReplayState) public replayStates;\n\n    /// @notice Mapping from queue index to previous replay queue index.\n    ///\n    /// @dev If a message `x` was replayed 3 times with index `q1`, `q2` and `q3`, the\n    /// value of `prevReplayIndex` and `replayStates` will be `replayStates[hash(x)].lastIndex = q3`,\n    /// `replayStates[hash(x)].times = 3`, `prevReplayIndex[q3] = q2`, `prevReplayIndex[q2] = q1`,\n    /// `prevReplayIndex[q1] = x` and `prevReplayIndex[x]=nil`.\n    ///\n    /// @dev The index `x` that `prevReplayIndex[x]=nil` is used as the termination of the list.\n    /// Usually we use `0` to represent `nil`, but we cannot distinguish it with the first message\n    /// with index zero. So a nonzero offset `1` is added to the value of `prevReplayIndex[x]` to\n    /// avoid such situation.\n    mapping(uint256 => uint256) public prevReplayIndex;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the storage of L1ScrollMessenger.\n    /// @param _counterpart The address of L2ScrollMessenger contract in L2.\n    /// @param _feeVault The address of fee vault, which will be used to collect relayer fee.\n    /// @param _rollup The address of ScrollChain contract.\n    /// @param _messageQueue The address of L1MessageQueue contract.\n    function initialize(\n        address _counterpart,\n        address _feeVault,\n        address _rollup,\n        address _messageQueue\n    ) public initializer {\n        PausableUpgradeable.__Pausable_init();\n        ScrollMessengerBase._initialize(_counterpart, _feeVault);\n\n        rollup = _rollup;\n        messageQueue = _messageQueue;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, msg.sender);\n    }\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes calldata _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, _refundAddress);\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function relayMessageWithProof(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _nonce,\n        bytes memory _message,\n        L2MessageProof memory _proof\n    ) external override whenNotPaused notInExecution {\n        bytes32 _xDomainCalldataHash = keccak256(_encodeXDomainCalldata(_from, _to, _value, _nonce, _message));\n        require(!isL2MessageExecuted[_xDomainCalldataHash], \"Message was already successfully executed\");\n\n        {\n            address _rollup = rollup;\n            require(IScrollChain(_rollup).isBatchFinalized(_proof.batchIndex), \"Batch is not finalized\");\n            bytes32 _messageRoot = IScrollChain(_rollup).withdrawRoots(_proof.batchIndex);\n            require(\n                WithdrawTrieVerifier.verifyMerkleProof(_messageRoot, _xDomainCalldataHash, _nonce, _proof.merkleProof),\n                \"Invalid proof\"\n            );\n        }\n\n        // @note check more `_to` address to avoid attack in the future when we add more gateways.\n        require(_to != messageQueue, \"Forbid to call message queue\");\n        require(_to != address(this), \"Forbid to call self\");\n\n        // @note This usually will never happen, just in case.\n        require(_from != xDomainMessageSender, \"Invalid message sender\");\n\n        xDomainMessageSender = _from;\n        (bool success, ) = _to.call{value: _value}(_message);\n        // reset value to refund gas.\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n\n        if (success) {\n            isL2MessageExecuted[_xDomainCalldataHash] = true;\n            emit RelayedMessage(_xDomainCalldataHash);\n        } else {\n            emit FailedRelayedMessage(_xDomainCalldataHash);\n        }\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function replayMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message,\n        uint32 _newGasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused notInExecution {\n        // We will use a different `queueIndex` for the replaced message. However, the original `queueIndex` or `nonce`\n        // is encoded in the `_message`. We will check the `xDomainCalldata` in layer 2 to avoid duplicated execution.\n        // So, only one message will succeed in layer 2. If one of the message is executed successfully, the other one\n        // will revert with \"Message was already successfully executed\".\n        address _messageQueue = messageQueue;\n        address _counterpart = counterpart;\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_from, _to, _value, _messageNonce, _message);\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        require(isL1MessageSent[_xDomainCalldataHash], \"Provided message has not been enqueued\");\n        // cannot replay dropped message\n        require(!isL1MessageDropped[_xDomainCalldataHash], \"Message already dropped\");\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(_messageQueue).estimateCrossDomainMessageFee(_newGasLimit);\n\n        // charge relayer fee\n        require(msg.value >= _fee, \"Insufficient msg.value for fee\");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}(\"\");\n            require(_success, \"Failed to deduct the fee\");\n        }\n\n        // enqueue the new transaction\n        uint256 _nextQueueIndex = IL1MessageQueue(_messageQueue).nextCrossDomainMessageIndex();\n        IL1MessageQueue(_messageQueue).appendCrossDomainMessage(_counterpart, _newGasLimit, _xDomainCalldata);\n\n        ReplayState memory _replayState = replayStates[_xDomainCalldataHash];\n        // update the replayed message chain.\n        unchecked {\n            if (_replayState.lastIndex == 0) {\n                // the message has not been replayed before.\n                prevReplayIndex[_nextQueueIndex] = _messageNonce + 1;\n            } else {\n                prevReplayIndex[_nextQueueIndex] = _replayState.lastIndex + 1;\n            }\n        }\n        _replayState.lastIndex = uint128(_nextQueueIndex);\n\n        // update replay times\n        require(_replayState.times < maxReplayTimes, \"Exceed maximum replay times\");\n        unchecked {\n            _replayState.times += 1;\n        }\n        replayStates[_xDomainCalldataHash] = _replayState;\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}(\"\");\n                require(_success, \"Failed to refund the fee\");\n            }\n        }\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function dropMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message\n    ) external override whenNotPaused notInExecution {\n        // The criteria for dropping a message:\n        // 1. The message is a L1 message.\n        // 2. The message has not been dropped before.\n        // 3. the message and all of its replacement are finalized in L1.\n        // 4. the message and all of its replacement are skipped.\n        //\n        // Possible denial of service attack:\n        // + replayMessage is called every time someone want to drop the message.\n        // + replayMessage is called so many times for a skipped message, thus results a long list.\n        //\n        // We limit the number of `replayMessage` calls of each message, which may solve the above problem.\n\n        address _messageQueue = messageQueue;\n\n        // check message exists\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_from, _to, _value, _messageNonce, _message);\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n        require(isL1MessageSent[_xDomainCalldataHash], \"Provided message has not been enqueued\");\n\n        // check message not dropped\n        require(!isL1MessageDropped[_xDomainCalldataHash], \"Message already dropped\");\n\n        // check message is finalized\n        uint256 _lastIndex = replayStates[_xDomainCalldataHash].lastIndex;\n        if (_lastIndex == 0) _lastIndex = _messageNonce;\n\n        // check message is skipped and drop it.\n        // @note If the list is very long, the message may never be dropped.\n        while (true) {\n            IL1MessageQueue(_messageQueue).dropCrossDomainMessage(_lastIndex);\n            _lastIndex = prevReplayIndex[_lastIndex];\n            if (_lastIndex == 0) break;\n            unchecked {\n                _lastIndex = _lastIndex - 1;\n            }\n        }\n\n        isL1MessageDropped[_xDomainCalldataHash] = true;\n\n        // set execution context\n        xDomainMessageSender = ScrollConstants.DROP_XDOMAIN_MESSAGE_SENDER;\n        IMessageDropCallback(_from).onDropMessage{value: _value}(_message);\n        // clear execution context\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Pause the contract\n    /// @dev This function can only called by contract owner.\n    /// @param _status The pause status to update.\n    function setPause(bool _status) external onlyOwner {\n        if (_status) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    /// @notice Update max replay times.\n    /// @dev This function can only called by contract owner.\n    /// @param _maxReplayTimes The new max replay times.\n    function updateMaxReplayTimes(uint256 _maxReplayTimes) external onlyOwner {\n        maxReplayTimes = _maxReplayTimes;\n\n        emit UpdateMaxReplayTimes(_maxReplayTimes);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function _sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) internal nonReentrant {\n        address _messageQueue = messageQueue; // gas saving\n        address _counterpart = counterpart; // gas saving\n\n        // compute the actual cross domain message calldata.\n        uint256 _messageNonce = IL1MessageQueue(_messageQueue).nextCrossDomainMessageIndex();\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(msg.sender, _to, _value, _messageNonce, _message);\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(_messageQueue).estimateCrossDomainMessageFee(_gasLimit);\n        require(msg.value >= _fee + _value, \"Insufficient msg.value\");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}(\"\");\n            require(_success, \"Failed to deduct the fee\");\n        }\n\n        // append message to L1MessageQueue\n        IL1MessageQueue(_messageQueue).appendCrossDomainMessage(_counterpart, _gasLimit, _xDomainCalldata);\n\n        // record the message hash for future use.\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        // normally this won't happen, since each message has different nonce, but just in case.\n        require(!isL1MessageSent[_xDomainCalldataHash], \"Duplicated message\");\n        isL1MessageSent[_xDomainCalldataHash] = true;\n\n        emit SentMessage(msg.sender, _to, _value, _messageNonce, _gasLimit, _message);\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee - _value;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}(\"\");\n                require(_success, \"Failed to refund the fee\");\n            }\n        }\n    }\n}"
    }
  ]
}