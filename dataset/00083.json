{
  "Title": "Missing Docstrings",
  "Content": "Throughout the [codebase](https://github.com/euler-xyz/euler-vault-kit/tree/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src), there are multiple code instances that do not have docstrings:\n\n\n* The entire [`BeaconProxy` contract](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/GenericFactory/BeaconProxy.sol#L5-L77) in `BeaconProxy.sol`\n* The [`onFlashLoan` function](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/modules/Borrowing.sol#L17) in `Borrowing.sol`\n* The entire [`DToken` contract](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/DToken.sol#L12-L70) in `DToken.sol`\n* The entire [`Dispatch` contract](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/Dispatch.sol#L21-L157) in `Dispatch.sol`\n* The entire [`EVault` contract](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/EVault.sol#L11-L240) in `EVault.sol`\n* The [`IComponent` interface](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/GenericFactory/GenericFactory.sol#L8-L10) and the entire [`GenericFactory` contract](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/GenericFactory/GenericFactory.sol#L12-L138) in `GenericFactory.sol`\n* The [events](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/modules/Governance.sol#L26-L37) in `Governance` contract in `Governance.sol`\n* The [`IIRM` interface](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/InterestRateModels/IIRM.sol#L5-L10) in `IIRM.sol`\n* The entire [`IPermit2` interface](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/interfaces/IPermit2.sol#L5-L7) in `IPermit2.sol`\n* The entire [`IPriceOracle` interface](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/interfaces/IPriceOracle.sol#L5-L18) in `IPriceOracle.sol`\n* The [`IProtocolConfig` interface](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/ProtocolConfig/IProtocolConfig.sol#L5-L29) in `IProtocolConfig.sol`\n* The entire [`IRMLinearKink` contract](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/InterestRateModels/IRMLinearKink.sol#L7-L58) in `IRMLinearKink.sol`\n* The [events](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/ProtocolConfig/ProtocolConfig.sol#L43-L48) defined in `ProtocolConfig` contract in `ProtocolConfig.sol`\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/latest/natspec-format.html) (NatSpec).\n\n\n***Update:** Resolved in [pull request #149](https://github.com/euler-xyz/euler-vault-kit/pull/149).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/GenericFactory/BeaconProxy.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\ncontract BeaconProxy {\n    // ERC-1967 beacon address slot. bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)\n    bytes32 constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    // Beacon implementation() selector\n    bytes32 constant IMPLEMENTATION_SELECTOR = 0x5c60da1b00000000000000000000000000000000000000000000000000000000;\n    // Max trailing data length, 4 immutable slots\n    uint256 constant MAX_TRAILING_DATA_LENGTH = 128;\n\n    address immutable beacon;\n    uint256 immutable metadataLength;\n    bytes32 immutable metadata0;\n    bytes32 immutable metadata1;\n    bytes32 immutable metadata2;\n    bytes32 immutable metadata3;\n\n    event Genesis();\n\n    constructor(bytes memory trailingData) {\n        emit Genesis();\n\n        require(trailingData.length <= MAX_TRAILING_DATA_LENGTH, \"trailing data too long\");\n\n        // Beacon is always the proxy creator; store it in immutable\n        beacon = msg.sender;\n\n        // Store the beacon address in ERC-1967 slot for compatibility with block explorers\n        assembly {\n            sstore(BEACON_SLOT, caller())\n        }\n\n        // Record length as immutable\n        metadataLength = trailingData.length;\n\n        // Pad length with uninitialized memory so the decode will succeed\n        assembly {\n            mstore(trailingData, 128)\n        }\n        (metadata0, metadata1, metadata2, metadata3) = abi.decode(trailingData, (bytes32, bytes32, bytes32, bytes32));\n    }\n\n    fallback() external payable {\n        address beacon_ = beacon;\n        uint256 metadataLength_ = metadataLength;\n        bytes32 metadata0_ = metadata0;\n        bytes32 metadata1_ = metadata1;\n        bytes32 metadata2_ = metadata2;\n        bytes32 metadata3_ = metadata3;\n\n        assembly {\n            // Fetch implementation address from the beacon\n            mstore(0, IMPLEMENTATION_SELECTOR)\n            let result := staticcall(gas(), beacon_, 0, 4, 0, 32)\n            if iszero(result) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n            let implementation := mload(0)\n\n            // delegatecall to the implementation with trailing metadata\n            calldatacopy(0, 0, calldatasize())\n            mstore(calldatasize(), metadata0_)\n            mstore(add(32, calldatasize()), metadata1_)\n            mstore(add(64, calldatasize()), metadata2_)\n            mstore(add(96, calldatasize()), metadata3_)\n            result := delegatecall(gas(), implementation, 0, add(metadataLength_, calldatasize()), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n}"
    },
    {
      "filename": "src/EVault/modules/Borrowing.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {IBorrowing} from \"../IEVault.sol\";\nimport {Base} from \"../shared/Base.sol\";\nimport {BalanceUtils} from \"../shared/BalanceUtils.sol\";\nimport {LiquidityUtils} from \"../shared/LiquidityUtils.sol\";\nimport {AssetTransfers} from \"../shared/AssetTransfers.sol\";\nimport {SafeERC20Lib} from \"../shared/lib/SafeERC20Lib.sol\";\nimport {ProxyUtils} from \"../shared/lib/ProxyUtils.sol\";\n\nimport \"../shared/types/Types.sol\";\n\n/// @notice Definition of callback method that flashLoan will invoke on your contract\ninterface IFlashLoan {\n    function onFlashLoan(bytes memory data) external;\n}\n\n/// @title BorrowingModule\n/// @author Euler Labs (https://www.eulerlabs.com/)\n/// @notice An EVault module handling borrowing and repaying of vault assets\nabstract contract BorrowingModule is IBorrowing, Base, AssetTransfers, BalanceUtils, LiquidityUtils {\n    using TypesLib for uint256;\n    using SafeERC20Lib for IERC20;\n\n    /// @inheritdoc IBorrowing\n    function totalBorrows() public view virtual nonReentrantView returns (uint256) {\n        return loadVault().totalBorrows.toAssetsUp().toUint();\n    }\n\n    /// @inheritdoc IBorrowing\n    function totalBorrowsExact() public view virtual nonReentrantView returns (uint256) {\n        return loadVault().totalBorrows.toUint();\n    }\n\n    /// @inheritdoc IBorrowing\n    function cash() public view virtual nonReentrantView returns (uint256) {\n        return vaultStorage.cash.toUint();\n    }\n\n    /// @inheritdoc IBorrowing\n    function debtOf(address account) public view virtual nonReentrantView returns (uint256) {\n        return getCurrentOwed(loadVault(), account).toAssetsUp().toUint();\n    }\n\n    /// @inheritdoc IBorrowing\n    function debtOfExact(address account) public view virtual nonReentrantView returns (uint256) {\n        return getCurrentOwed(loadVault(), account).toUint();\n    }\n\n    /// @inheritdoc IBorrowing\n    function interestRate() public view virtual nonReentrantView returns (uint256) {\n        return computeInterestRateView(loadVault());\n    }\n\n    /// @inheritdoc IBorrowing\n    function interestAccumulator() public view virtual nonReentrantView returns (uint256) {\n        return loadVault().interestAccumulator;\n    }\n\n    /// @inheritdoc IBorrowing\n    function dToken() public view virtual reentrantOK returns (address) {\n        return calculateDTokenAddress();\n    }\n\n    /// @inheritdoc IBorrowing\n    function borrow(uint256 amount, address receiver) public virtual nonReentrant returns (uint256) {\n        (VaultCache memory vaultCache, address account) = initOperation(OP_BORROW, CHECKACCOUNT_CALLER);\n\n        Assets assets = amount == type(uint256).max ? vaultCache.cash : amount.toAssets();\n        if (assets.isZero()) return 0;\n\n        if (assets > vaultCache.cash) revert E_InsufficientCash();\n\n        increaseBorrow(vaultCache, account, assets);\n\n        pushAssets(vaultCache, receiver, assets);\n\n        return assets.toUint();\n    }\n\n    /// @inheritdoc IBorrowing\n    function repay(uint256 amount, address receiver) public virtual nonReentrant returns (uint256) {\n        (VaultCache memory vaultCache, address account) = initOperation(OP_REPAY, CHECKACCOUNT_NONE);\n\n        uint256 owed = getCurrentOwed(vaultCache, receiver).toAssetsUp().toUint();\n\n        Assets assets = (amount == type(uint256).max ? owed : amount).toAssets();\n        if (assets.isZero()) return 0;\n\n        pullAssets(vaultCache, account, assets);\n\n        decreaseBorrow(vaultCache, receiver, assets);\n\n        return assets.toUint();\n    }\n\n    /// @inheritdoc IBorrowing\n    function loop(uint256 amount, address sharesReceiver) public virtual nonReentrant returns (uint256) {\n        (VaultCache memory vaultCache, address account) = initOperation(OP_LOOP, CHECKACCOUNT_CALLER);\n\n        Assets assets = amount.toAssets();\n        if (assets.isZero()) return 0;\n        Shares shares = assets.toSharesUp(vaultCache);\n        assets = shares.toAssetsUp(vaultCache);\n\n        // Mint DTokens\n        increaseBorrow(vaultCache, account, assets);\n\n        // Mint ETokens\n        increaseBalance(vaultCache, sharesReceiver, account, shares, assets);\n\n        return shares.toUint();\n    }\n\n    /// @inheritdoc IBorrowing\n    function deloop(uint256 amount, address debtFrom) public virtual nonReentrant returns (uint256) {\n        (VaultCache memory vaultCache, address account) = initOperation(OP_DELOOP, CHECKACCOUNT_CALLER);\n\n        Assets owed = getCurrentOwed(vaultCache, debtFrom).toAssetsUp();\n        if (owed.isZero()) return 0;\n\n        Assets assets;\n        Shares shares;\n\n        if (amount == type(uint256).max) {\n            shares = vaultStorage.users[account].getBalance();\n            assets = shares.toAssetsDown(vaultCache);\n        } else {\n            assets = amount.toAssets();\n            shares = assets.toSharesUp(vaultCache);\n        }\n\n        if (assets.isZero()) return 0;\n\n        if (assets > owed) {\n            assets = owed;\n            shares = assets.toSharesUp(vaultCache);\n        }\n\n        // Burn ETokens\n        decreaseBalance(vaultCache, account, account, account, shares, assets);\n\n        // Burn DTokens\n        decreaseBorrow(vaultCache, debtFrom, assets);\n\n        return shares.toUint();\n    }\n\n    /// @inheritdoc IBorrowing\n    function pullDebt(uint256 amount, address from) public virtual nonReentrant returns (uint256) {\n        (VaultCache memory vaultCache, address account) = initOperation(OP_PULL_DEBT, CHECKACCOUNT_CALLER);\n\n        if (from == account) revert E_SelfTransfer();\n\n        Assets assets = amount == type(uint256).max ? getCurrentOwed(vaultCache, from).toAssetsUp() : amount.toAssets();\n\n        if (assets.isZero()) return 0;\n        transferBorrow(vaultCache, from, account, assets);\n\n        return assets.toUint();\n    }\n\n    /// @inheritdoc IBorrowing\n    function flashLoan(uint256 amount, bytes calldata data) public virtual nonReentrant {\n        address account = EVCAuthenticate();\n        callHook(vaultStorage.hookedOps, OP_FLASHLOAN, account);\n\n        (IERC20 asset,,) = ProxyUtils.metadata();\n\n        uint256 origBalance = asset.balanceOf(address(this));\n\n        asset.safeTransfer(account, amount);\n\n        IFlashLoan(account).onFlashLoan(data);\n\n        if (asset.balanceOf(address(this)) < origBalance) revert E_FlashLoanNotRepaid();\n    }\n\n    /// @inheritdoc IBorrowing\n    function touch() public virtual nonReentrant {\n        initOperation(OP_TOUCH, CHECKACCOUNT_NONE);\n    }\n}\n\n/// @dev Deployable module contract\ncontract Borrowing is BorrowingModule {\n    constructor(Integrations memory integrations) Base(integrations) {}\n}"
    },
    {
      "filename": "src/EVault/DToken.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {Errors} from \"./shared/Errors.sol\";\nimport {Events} from \"./shared/Events.sol\";\nimport {IERC20, IEVault} from \"./IEVault.sol\";\n\n/// @title DToken\n/// @author Euler Labs (https://www.eulerlabs.com/)\n/// @notice Contract implements read only ERC20 interface, and `Transfer` events, for EVault's debt\ncontract DToken is IERC20, Errors, Events {\n    address public immutable eVault;\n\n    constructor() {\n        eVault = msg.sender;\n    }\n\n    // ERC20 interface\n\n    function name() external view returns (string memory) {\n        return string.concat(\"Debt token of \", IEVault(eVault).name());\n    }\n\n    function symbol() external view returns (string memory) {\n        return string.concat(IEVault(eVault).symbol(), \"-DEBT\");\n    }\n\n    function decimals() external view returns (uint8) {\n        return IEVault(eVault).decimals();\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return IEVault(eVault).totalBorrows();\n    }\n\n    function balanceOf(address owner) external view returns (uint256) {\n        return IEVault(eVault).debtOf(owner);\n    }\n\n    function allowance(address, address) external pure returns (uint256) {\n        return 0;\n    }\n\n    function approve(address, uint256) external pure returns (bool) {\n        revert E_NotSupported();\n    }\n\n    function transfer(address, uint256) external pure returns (bool) {\n        revert E_NotSupported();\n    }\n\n    function transferFrom(address, address, uint256) external pure returns (bool) {\n        revert E_NotSupported();\n    }\n\n    // Events\n\n    function emitTransfer(address from, address to, uint256 value) external {\n        if (msg.sender != eVault) revert E_Unauthorized();\n\n        emit Transfer(from, to, value);\n    }\n\n    // Helpers\n\n    function asset() external view returns (address) {\n        return IEVault(eVault).asset();\n    }\n}"
    },
    {
      "filename": "src/EVault/Dispatch.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {Base} from \"./shared/Base.sol\";\n\nimport {TokenModule} from \"./modules/Token.sol\";\nimport {VaultModule} from \"./modules/Vault.sol\";\nimport {BorrowingModule} from \"./modules/Borrowing.sol\";\nimport {LiquidationModule} from \"./modules/Liquidation.sol\";\nimport {InitializeModule} from \"./modules/Initialize.sol\";\nimport {BalanceForwarderModule} from \"./modules/BalanceForwarder.sol\";\nimport {GovernanceModule} from \"./modules/Governance.sol\";\nimport {RiskManagerModule} from \"./modules/RiskManager.sol\";\n\nimport \"./shared/Constants.sol\";\n\n/// @title Dispatch\n/// @author Euler Labs (https://www.eulerlabs.com/)\n/// @notice Contract which ties in the EVault modules and provides utilities for routing calls to modules and the EVC\nabstract contract Dispatch is\n    Base,\n    InitializeModule,\n    TokenModule,\n    VaultModule,\n    BorrowingModule,\n    LiquidationModule,\n    RiskManagerModule,\n    BalanceForwarderModule,\n    GovernanceModule\n{\n    address public immutable MODULE_INITIALIZE;\n    address public immutable MODULE_TOKEN;\n    address public immutable MODULE_VAULT;\n    address public immutable MODULE_BORROWING;\n    address public immutable MODULE_LIQUIDATION;\n    address public immutable MODULE_RISKMANAGER;\n    address public immutable MODULE_BALANCE_FORWARDER;\n    address public immutable MODULE_GOVERNANCE;\n\n    struct DeployedModules {\n        address initialize;\n        address token;\n        address vault;\n        address borrowing;\n        address liquidation;\n        address riskManager;\n        address balanceForwarder;\n        address governance;\n    }\n\n    constructor(Integrations memory integrations, DeployedModules memory modules) Base(integrations) {\n        MODULE_INITIALIZE = modules.initialize;\n        MODULE_TOKEN = modules.token;\n        MODULE_VAULT = modules.vault;\n        MODULE_BORROWING = modules.borrowing;\n        MODULE_LIQUIDATION = modules.liquidation;\n        MODULE_RISKMANAGER = modules.riskManager;\n        MODULE_BALANCE_FORWARDER = modules.balanceForwarder;\n        MODULE_GOVERNANCE = modules.governance;\n    }\n\n    // Modifier proxies the function call to a module and low-level returns the result\n    modifier use(address module) {\n        _; // when using the modifier, it is assumed the function body is empty and no code will run before delegating to module.\n        delegateToModule(module);\n    }\n\n    // Delegate call can't be used in a view function. To work around this limitation,\n    // static call `this.viewDelegate()` function, which in turn will delegate the payload to a module.\n    modifier useView(address module) {\n        _; // when using the modifier, it is assumed the function body is empty and no code will run before delegating to module.\n        delegateToModuleView(module);\n    }\n\n    modifier callThroughEVC() {\n        if (msg.sender == address(evc)) {\n            _;\n        } else {\n            callThroughEVCInternal();\n        }\n    }\n\n    // External function which is only callable by the EVault itself. Its purpose is to be static called by `delegateToModuleView`\n    // which allows view functions to be implemented in modules, even though delegatecall cannot be directly used within\n    // view functions.\n    function viewDelegate() external {\n        if (msg.sender != address(this)) revert E_Unauthorized();\n\n        assembly {\n            let size := sub(calldatasize(), 36)\n            calldatacopy(0, 36, size)\n            let result := delegatecall(gas(), calldataload(4), 0, size, 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n\n    function delegateToModule(address module) private {\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), module, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n\n    function delegateToModuleView(address module) private view {\n        assembly {\n            // Construct optimized custom call data for `this.viewDelegate()`\n            // [selector 4B][module address 32B][calldata with stripped proxy metadata][caller address 32B]\n            // Proxy metadata will be appended back by the proxy on staticcall\n            mstore(0, 0x1fe8b95300000000000000000000000000000000000000000000000000000000)\n            mstore(4, module)\n            let strippedCalldataSize := sub(calldatasize(), PROXY_METADATA_LENGTH)\n            calldatacopy(36, 0, strippedCalldataSize)\n            mstore(add(36, strippedCalldataSize), caller())\n            // insize: stripped calldatasize + 36 (signature and module address) + 32 (caller address)\n            let result := staticcall(gas(), address(), 0, add(strippedCalldataSize, 68), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n\n    // Modifier ensures, that the body of the function is always executed from the EVC call.\n    // It is accomplished by intercepting calls incoming directly to the vault and passing them\n    // to the EVC.call function. EVC calls the vault back with original calldata. As a result, the account\n    // and vault status checks are always executed in the checks deferral frame, at the end of the call,\n    // outside of the vault's re-entrancy protections.\n    // The modifier is applied to all functions which schedule account or vault status checks.\n    function callThroughEVCInternal() private {\n        address _evc = address(evc);\n        assembly {\n            let mainCalldataLength := sub(calldatasize(), PROXY_METADATA_LENGTH)\n\n            mstore(0, 0x1f8b521500000000000000000000000000000000000000000000000000000000) // EVC.call signature\n            mstore(4, address()) // EVC.call 1st argument - address(this)\n            mstore(36, caller()) // EVC.call 2nd argument - msg.sender\n            mstore(68, callvalue()) // EVC.call 3rd argument - msg.value\n            mstore(100, 128) // EVC.call 4th argument - msg.data, offset to the start of encoding - 128 bytes\n            mstore(132, mainCalldataLength) // msg.data length without proxy metadata\n            calldatacopy(164, 0, mainCalldataLength) // original calldata\n            let result := call(gas(), _evc, callvalue(), 0, add(164, mainCalldataLength), 0, 0)\n\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 { revert(0, returndatasize()) }\n            default { return(64, sub(returndatasize(), 64)) } // strip bytes encoding from call return\n        }\n    }\n}"
    },
    {
      "filename": "src/EVault/EVault.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {Dispatch} from \"./Dispatch.sol\";\n\n/// @title EVault\n/// @author Euler Labs (https://www.eulerlabs.com/)\n/// @notice This contract implements an EVC enabled lending vault\n/// @dev The responsibility of this contract is call routing. Select functions are embedded, while most are delegated to the modules.\ncontract EVault is Dispatch {\n    constructor(Integrations memory integrations, DeployedModules memory modules) Dispatch(integrations, modules) {}\n\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n    //                                     INITIALIZATION                                        //\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n\n    function initialize(address proxyCreator) public virtual override use(MODULE_INITIALIZE) {}\n\n\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n    //                                         TOKEN                                             //\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n\n    function name() public view virtual override useView(MODULE_TOKEN) returns (string memory) {}\n\n    function symbol() public view virtual override useView(MODULE_TOKEN) returns (string memory) {}\n\n    function decimals() public view virtual override returns (uint8) { return super.decimals(); }\n\n    function totalSupply() public view virtual override useView(MODULE_TOKEN) returns (uint256) {}\n\n    function balanceOf(address account) public view virtual override returns (uint256) { return super.balanceOf(account); }\n\n    function allowance(address holder, address spender) public view virtual override returns (uint256) { return super.allowance(holder, spender); }\n\n\n    function transfer(address to, uint256 amount) public virtual override callThroughEVC returns (bool) { return super.transfer(to, amount); }\n\n    function transferFrom(address from, address to, uint256 amount) public virtual override callThroughEVC returns (bool) { return super.transferFrom(from, to, amount); }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) { return super.approve(spender, amount); }\n\n    function transferFromMax(address from, address to) public virtual override callThroughEVC returns (bool) { return super.transferFromMax(from, to); }\n\n\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n    //                                         VAULT                                             //\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n\n    function asset() public view virtual override returns (address) { return super.asset(); }\n\n    function totalAssets() public view virtual override useView(MODULE_VAULT) returns (uint256) {}\n\n    function convertToAssets(uint256 shares) public view virtual override returns (uint256) { return super.convertToAssets(shares); }\n\n    function convertToShares(uint256 assets) public view virtual override returns (uint256) { return super.convertToShares(assets); }\n\n    function maxDeposit(address account) public view virtual override useView(MODULE_VAULT) returns (uint256) {}\n\n    function previewDeposit(uint256 assets) public view virtual override useView(MODULE_VAULT) returns (uint256) {}\n\n    function maxMint(address account) public view virtual override useView(MODULE_VAULT) returns (uint256) {}\n\n    function previewMint(uint256 shares) public view virtual override useView(MODULE_VAULT) returns (uint256) {}\n\n    function maxWithdraw(address owner) public view virtual override useView(MODULE_VAULT) returns (uint256) {}\n\n    function previewWithdraw(uint256 assets) public view virtual override useView(MODULE_VAULT) returns (uint256) {}\n\n    function maxRedeem(address owner) public view virtual override useView(MODULE_VAULT) returns (uint256) {}\n\n    function previewRedeem(uint256 shares) public view virtual override useView(MODULE_VAULT) returns (uint256) {}\n\n    function accumulatedFees() public view virtual override returns (uint256) { return super.accumulatedFees(); }\n\n    function accumulatedFeesAssets() public view virtual override returns (uint256) { return super.accumulatedFeesAssets(); }\n\n    function creator() public view virtual override useView(MODULE_VAULT) returns (address) {}\n\n\n    function deposit(uint256 amount, address receiver) public virtual override callThroughEVC returns (uint256) { return super.deposit(amount, receiver); }\n\n    function mint(uint256 amount, address receiver) public virtual override callThroughEVC use(MODULE_VAULT) returns (uint256) {}\n\n    function withdraw(uint256 amount, address receiver, address owner) public virtual override callThroughEVC use(MODULE_VAULT) returns (uint256) {}\n\n    function redeem(uint256 amount, address receiver, address owner) public virtual override callThroughEVC use(MODULE_VAULT) returns (uint256) {}\n\n    function skim(uint256 amount, address receiver) public virtual override callThroughEVC use(MODULE_VAULT) returns (uint256) {}\n\n\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n    //                                        BORROWING                                          //\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n\n    function totalBorrows() public view virtual override useView(MODULE_BORROWING) returns (uint256) {}\n\n    function totalBorrowsExact() public view virtual override useView(MODULE_BORROWING) returns (uint256) {}\n\n    function cash() public view virtual override useView(MODULE_BORROWING) returns (uint256) {}\n\n    function debtOf(address account) public view virtual override returns (uint256) { return super.debtOf(account); }\n\n    function debtOfExact(address account) public view virtual override useView(MODULE_BORROWING) returns (uint256) {}\n\n    function interestRate() public view virtual override returns (uint256) { return super.interestRate(); }\n\n    function interestAccumulator() public view virtual override useView(MODULE_BORROWING) returns (uint256) {}\n\n    function dToken() public view virtual override useView(MODULE_BORROWING) returns (address) {}\n\n\n    function borrow(uint256 amount, address receiver) public virtual override callThroughEVC use(MODULE_BORROWING) returns (uint256) {}\n\n    function repay(uint256 amount, address receiver) public virtual override callThroughEVC use(MODULE_BORROWING) returns (uint256) {}\n\n    function loop(uint256 amount, address sharesReceiver) public virtual override callThroughEVC use(MODULE_BORROWING) returns (uint256) {}\n\n    function deloop(uint256 amount, address debtFrom) public virtual override callThroughEVC use(MODULE_BORROWING) returns (uint256) {}\n\n    function pullDebt(uint256 amount, address from) public virtual override callThroughEVC use(MODULE_BORROWING) returns (uint256) {}\n\n    function flashLoan(uint256 amount, bytes calldata data) public virtual override use(MODULE_BORROWING) {}\n\n    function touch() public virtual override callThroughEVC use(MODULE_BORROWING) {}\n\n\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n    //                                     LIQUIDATION                                           //\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n\n    function checkLiquidation(address liquidator, address violator, address collateral) public view virtual override useView(MODULE_LIQUIDATION) returns (uint256 maxRepay, uint256 maxYield) {}\n\n    function liquidate(address violator, address collateral, uint256 repayAssets, uint256 minYieldBalance) public virtual override callThroughEVC use(MODULE_LIQUIDATION) {}\n\n\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n    //                                    RISK MANAGEMENT                                        //\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n\n    function accountLiquidity(address account, bool liquidation) public view virtual override useView(MODULE_RISKMANAGER) returns (uint256 collateralValue, uint256 liabilityValue) {}\n\n    function accountLiquidityFull(address account, bool liquidation) public view virtual override useView(MODULE_RISKMANAGER) returns (address[] memory collaterals, uint256[] memory collateralValues, uint256 liabilityValue) {}\n\n\n    function disableController() public virtual override use(MODULE_RISKMANAGER) {}\n\n    function checkAccountStatus(address account, address[] calldata collaterals) public virtual override returns (bytes4) { return super.checkAccountStatus(account, collaterals); }\n\n    function checkVaultStatus() public virtual override returns (bytes4) { return super.checkVaultStatus(); }\n\n\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n    //                                   BALANCE TRACKING                                        //\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n\n    function balanceTrackerAddress() public view virtual override useView(MODULE_BALANCE_FORWARDER) returns (address) {}\n\n    function balanceForwarderEnabled(address account) public view virtual override useView(MODULE_BALANCE_FORWARDER) returns (bool) {}\n\n\n    function enableBalanceForwarder() public virtual override use(MODULE_BALANCE_FORWARDER) {}\n\n    function disableBalanceForwarder() public virtual override use(MODULE_BALANCE_FORWARDER) {}\n\n\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n    //                                     GOVERNANCE                                            //\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n\n    function governorAdmin() public view virtual override useView(MODULE_GOVERNANCE) returns (address) {}\n\n    function feeReceiver() public view virtual override useView(MODULE_GOVERNANCE) returns (address) {}\n\n    function interestFee() public view virtual override returns (uint16) { return super.interestFee(); }\n\n    function interestRateModel() public view virtual override useView(MODULE_GOVERNANCE) returns (address) {}\n\n    function protocolConfigAddress() public view virtual override useView(MODULE_GOVERNANCE) returns (address) {}\n\n    function protocolFeeShare() public view virtual override useView(MODULE_GOVERNANCE) returns (uint256) {}\n\n    function protocolFeeReceiver() public view virtual override useView(MODULE_GOVERNANCE) returns (address) {}\n\n    function caps() public view virtual override useView(MODULE_GOVERNANCE) returns (uint16 supplyCap, uint16 borrowCap) {}\n\n    function borrowingLTV(address collateral) public view virtual override useView(MODULE_GOVERNANCE) returns (uint16) {}\n\n    function liquidationLTV(address collateral) public view virtual override useView(MODULE_GOVERNANCE) returns (uint16) {}\n\n    function LTVFull(address collateral) public view virtual override useView(MODULE_GOVERNANCE) returns (uint48 targetTimestamp, uint16 targetLTV, uint32 rampDuration, uint16 originalLTV) {}\n\n    function LTVList() public view virtual override useView(MODULE_GOVERNANCE) returns (address[] memory) {}\n\n    function hookConfig() public view virtual override useView(MODULE_GOVERNANCE) returns (address, uint32) {}\n\n    function configFlags() public view virtual override useView(MODULE_GOVERNANCE) returns (uint32) {}\n\n    function EVC() public view virtual override useView(MODULE_GOVERNANCE) returns (address) {}\n\n    function unitOfAccount() public view virtual override useView(MODULE_GOVERNANCE) returns (address) {}\n\n    function oracle() public view virtual override useView(MODULE_GOVERNANCE) returns (address) {}\n\n    function permit2Address() public view virtual override useView(MODULE_GOVERNANCE) returns (address) {}\n\n\n    function convertFees() public virtual override callThroughEVC use(MODULE_GOVERNANCE) {}\n\n    function setName(string calldata newName) public virtual override use(MODULE_GOVERNANCE) {}\n\n    function setSymbol(string calldata newSymbol) public virtual override use(MODULE_GOVERNANCE) {}\n\n    function setGovernorAdmin(address newGovernorAdmin) public virtual override use(MODULE_GOVERNANCE) {}\n\n    function setFeeReceiver(address newFeeReceiver) public virtual override use(MODULE_GOVERNANCE) {}\n\n    function setHookConfig(address newHookTarget, uint32 newHookedOps) public virtual override use(MODULE_GOVERNANCE) {}\n\n    function setLTV(address collateral, uint16 ltv, uint32 rampDuration) public virtual override use(MODULE_GOVERNANCE) {}\n\n    function clearLTV(address collateral) public virtual override use(MODULE_GOVERNANCE) {}\n\n    function setInterestRateModel(address newModel) public virtual override use(MODULE_GOVERNANCE) {}\n\n    function setConfigFlags(uint32 newConfigFlags) public virtual override use(MODULE_GOVERNANCE) {}\n\n    function setCaps(uint16 supplyCap, uint16 borrowCap) public virtual override use(MODULE_GOVERNANCE) {}\n\n    function setInterestFee(uint16 newFee) public virtual override use(MODULE_GOVERNANCE) {}\n}"
    },
    {
      "filename": "src/GenericFactory/GenericFactory.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {BeaconProxy} from \"./BeaconProxy.sol\";\nimport {MetaProxyDeployer} from \"./MetaProxyDeployer.sol\";\n\ninterface IComponent {\n    function initialize(address creator) external;\n}\n\ncontract GenericFactory is MetaProxyDeployer {\n    // Constants\n\n    uint256 constant REENTRANCYLOCK__UNLOCKED = 1;\n    uint256 constant REENTRANCYLOCK__LOCKED = 2;\n\n    // State\n\n    struct ProxyConfig {\n        bool upgradeable;\n        address implementation; // may be an out-of-date value, if upgradeable (handled by getProxyConfig)\n        bytes trailingData;\n    }\n\n    uint256 private reentrancyLock;\n\n    address public upgradeAdmin;\n    address public implementation;"
    }
  ]
}