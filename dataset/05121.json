{
  "Title": "[M-01] Tickets can be entered after prizes for current round have partially been distributed",
  "Content": "\nThe `ThrusterTreasure` contract is designed to facilitate a lottery game where users can enter tickets to win prizes based on entropy. The contract includes mechanisms for entering tickets into rounds (`enterTickets()`), setting prizes for rounds (`setPrize()`), and claiming prizes (`claimPrizesForRound()`). A critical aspect of the game's integrity is ensuring each ticket has an equal chance to win every prize.\n\nHowever, there is a significant flaw in `enterTickets()`. The function checks if winning tickets for the prize index 0 have been set by verifying that `winningTickets[currentRound_][0].length == 0`. This check is intended to prevent users from entering tickets after prizes have begun to be distributed, but it does not account for prizes with higher indices that may already have been distributed. As a result, users can still enter tickets after some prizes have been distributed, but these late-entered tickets will not have a chance to win the already distributed prizes:\n[ThrusterTreasure.sol#L83-L96](https://github.com/code-423n4/2024-02-thruster/blob/3896779349f90a44b46f2646094cb34fffd7f66e/thruster-protocol/thruster-treasure/contracts/ThrusterTreasure.sol#L83-L96)\n\n```solidity\nfunction enterTickets(uint256 _amount, bytes32[] calldata _proof) external {\n    ...\n    require(winningTickets[currentRound_][0].length == 0, \"ET\");\n    ...\n}\n```\n\n### Proof of Concept\n\n1.  The contract owner sets up a new round with multiple prizes.\n2.  User A enters tickets early in the round.\n3.  The contract owner distributes prizes for index 1.\n4.  User B enters tickets into the round.\n5.  Due to the flawed logic in `enterTickets()`, User B's tickets are accepted, even though the prizes for indices 1 and above have already been distributed. User B's tickets, therefore, have no chance of winning those prizes and are worth less than user A's, but the system incorrectly allows their participation for the undistributed prize at index 0.\n\n### Recommended Mitigation Steps\n\nFreeze ticket entry for the current round once any prize has been set.\n\n**[jooleseth (Thruster) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2024-02-thruster-findings/issues/28#issuecomment-1963623821):**\n > This is an issue reported in a few other Medium's as well\n> \n> - Rewards should be set atomically in the same transaction call by an admin script. The expectation is that if the 0 index is set, then all should be set for the round, hence the check for the zero index.\n> \n> We also use this zero index check in the `claimPrizesForRound` call.\n> \n> I would consider this a Quality Assurance to improve the require check, or Medium at most, as reported by [issue 17](https://github.com/code-423n4/2024-02-thruster-findings/issues/17).\n\n**[0xleastwood (judge) decreased severity to Low/Non-Critical and commented](https://github.com/code-423n4/2024-02-thruster-findings/issues/28#issuecomment-1998952936):**\n > It seems to me that users would have to intentionally be negligible and enter tickets into a round that they are not eligible for. Downgrading to QA.\n\n**[EV\\_om (warden) commented](https://github.com/code-423n4/2024-02-thruster-findings/issues/28#issuecomment-2001925516):**\n > @0xleastwood - all users are eligible for prizes as long as they have valid tickets. The user cannot know that prizes have already been set - even if they checked before entering their tickets, an owner call to [`setWinningTickets()`](https://github.com/code-423n4/2024-02-thruster/blob/3896779349f90a44b46f2646094cb34fffd7f66e/thruster-protocol/thruster-treasure/contracts/ThrusterTreasure.sol#L269) may end up being included in a block before their transaction.\n> \n> Setting rewards atomically via a script addresses the issue, but it is an OOS mitigation. Considering that setting them non-atomically in both ascending and descending order is problematic and that this was not documented, Medium severity seems reasonable.\n\n**[0xleastwood (judge) increased severity to Medium and commented](https://github.com/code-423n4/2024-02-thruster-findings/issues/28#issuecomment-2005544628):**\n > Understandably, this issue would not be mitigated by having all prizes set at the same time because any tickets entered prior would not be eligible for any reward. There needs to be some clear distinction at which a round ends and when prizes are distributed to prevent this from happening. Would typically class front-running issues as QA but this leads to users spending funds with no expected return.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-thruster",
  "Code": [
    {
      "filename": "thruster-protocol/thruster-treasure/contracts/ThrusterTreasure.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.23;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@pythnetwork/entropy-sdk-solidity/IEntropy.sol\";\n\nimport \"interfaces/IERC20Rebasing.sol\";\nimport \"interfaces/IThrusterTreasure.sol\";\nimport \"interfaces/IBlast.sol\";\n\n/**\n * @title ThrusterTreasure\n * @notice Contract for Thruster Treasure, a lottery game that uses entropy to determine winners\n */\ncontract ThrusterTreasure is Ownable, IThrusterTreasure {\n    struct Round {\n        uint256 ticketStart; // Inclusive\n        uint256 ticketEnd; // Not inclusive\n        uint256 round;\n    }\n\n    struct Prize {\n        uint256 amountWETH;\n        uint256 amountUSDB;\n        uint64 numWinners;\n        uint64 prizeIndex;\n        uint64 round;\n    }\n\n    uint256 public constant MAX_ROUND_TIME = 30 days; // Time at most 30 days from when round is first initiated, not when winning tickets are drawn\n\n    IBlast public immutable BLAST;\n    IERC20Rebasing public immutable WETH;\n    IERC20Rebasing public immutable USDB;\n\n    IEntropy private entropy;\n    address private entropyProvider;\n\n    bytes32 public root;\n    uint256 public currentRound; // Increments by 1 every time the root is updated\n    uint256 public currentTickets; // Resets to 0 every time the root is updated\n    uint256 public maxPrizeCount;\n    mapping(uint256 => uint256) public roundStart;\n    mapping(address => uint256) public cumulativeTickets;\n    mapping(address => mapping(uint256 => Round)) public entered; // Address => RoundIndex => Round\n    mapping(uint256 => mapping(uint256 => Prize)) public prizes; // Need to keep track of prizes for each round. RoundIndex => PrizeIndex => Prize\n    mapping(uint256 => mapping(uint256 => uint256[])) public winningTickets; // Need to keep track of winning tickets for each round. RoundIndex => PrizeIndex => WinningTickets\n    mapping(uint64 => address) private requestedRandomNumber;\n\n    /**\n     *\n     * @param _entropy - The address of the Entropy contract\n     * @param _entropyProvider - The address of the entropy provider\n     * @param _weth - The address of the WETH contract\n     * @param _usdb - The address of the USDB contract\n     */\n    constructor(\n        address _entropy,\n        address _entropyProvider,\n        address _blast,\n        address _weth,\n        address _usdb,\n        uint256 _maxPrizeCount\n    ) Ownable(msg.sender) {\n        entropy = IEntropy(_entropy);\n        entropyProvider = _entropyProvider;\n        maxPrizeCount = _maxPrizeCount;\n        BLAST = IBlast(_blast);\n        WETH = IERC20Rebasing(_weth);\n        USDB = IERC20Rebasing(_usdb);\n        BLAST.configureAutomaticYield();\n        BLAST.configureClaimableGas();\n        WETH.configure(YieldMode.CLAIMABLE);\n        USDB.configure(YieldMode.CLAIMABLE);\n    }\n\n    /**\n     * Enter tickets into the current active round of Thruster Treasure.\n     * @param _amount The amount of cumulative tickets the user has earned over time, based on merkle proof\n     * @param _proof The Merkle proof to verify the user's tickets\n     */\n    function enterTickets(uint256 _amount, bytes32[] calldata _proof) external {\n        uint256 currentRound_ = currentRound;\n        require(winningTickets[currentRound_][0].length == 0, \"ET\");\n        bytes32 node = keccak256(abi.encodePacked(msg.sender, _amount));\n        require(MerkleProof.verify(_proof, root, node), \"IP\");\n        uint256 ticketsToEnter = _amount - cumulativeTickets[msg.sender];\n        require(ticketsToEnter > 0, \"NTE\");\n        uint256 currentTickets_ = currentTickets;\n        Round memory round = Round(currentTickets_, currentTickets_ + ticketsToEnter, currentRound_);\n        entered[msg.sender][currentRound_] = round;\n        cumulativeTickets[msg.sender] = _amount; // Ensure user can only enter tickets once, no partials\n        currentTickets += ticketsToEnter;\n        emit EnteredTickets(msg.sender, currentTickets_, currentTickets_ + ticketsToEnter, currentRound_);\n    }\n\n    /**\n     * Claim prizes for a round\n     * @param roundToClaim - The round to claim prizes for\n     */\n    function claimPrizesForRound(uint256 roundToClaim) external {\n        require(roundStart[roundToClaim] + MAX_ROUND_TIME >= block.timestamp, \"ICT\");\n        require(winningTickets[roundToClaim][0].length > 0, \"NWT\");\n        Round memory round = entered[msg.sender][roundToClaim];\n        require(round.ticketEnd > round.ticketStart, \"NTE\");\n        uint256 maxPrizeCount_ = maxPrizeCount;\n        for (uint256 i = 0; i < maxPrizeCount_; i++) {\n            Prize memory prize = prizes[roundToClaim][i];\n            uint256[] memory winningTicketsRoundPrize = winningTickets[roundToClaim][i];\n            for (uint256 j = 0; j < winningTicketsRoundPrize.length; j++) {\n                uint256 winningTicket = winningTicketsRoundPrize[j];\n                if (round.ticketStart <= winningTicket && round.ticketEnd > winningTicket) {\n                    _claimPrize(prize, msg.sender, winningTicket);\n                }\n            }\n        }\n        entered[msg.sender][roundToClaim] = Round(0, 0, roundToClaim); // Clear user's tickets for the round\n        emit CheckedPrizesForRound(msg.sender, roundToClaim);\n    }\n\n    /**\n     * Claims the prize for a user\n     * @param _prize - The prize to claim\n     * @param _winningTicket - The winning ticket number\n     */\n    function _claimPrize(Prize memory _prize, address _receiver, uint256 _winningTicket) internal {\n        uint256 amountETH = _prize.amountWETH;\n        uint256 amountUSDB = _prize.amountUSDB;\n        WETH.transfer(_receiver, amountETH);\n        USDB.transfer(_receiver, amountUSDB);\n        emit ClaimedPrize(_receiver, _prize.round, _prize.prizeIndex, amountETH, amountUSDB, _winningTicket);\n    }\n\n    /**\n     * Sets the maximum prize count\n     * @param _maxPrizeCount - The new max prize count\n     */\n    function setMaxPrizeCount(uint256 _maxPrizeCount) external onlyOwner {\n        maxPrizeCount = _maxPrizeCount;\n        emit SetMaxPrizeCount(_maxPrizeCount);\n    }\n\n    /**\n     * Claims the Blast native yield\n     * @param _recipient - The address to claim the yield to\n     * @param _amountWETH - The amount of WETH to claim\n     * @param _amountUSDB - The amount of USDB to claim\n     */\n    function claimYield(address _recipient, uint256 _amountWETH, uint256 _amountUSDB) external onlyOwner {\n        WETH.claim(_recipient, _amountWETH);\n        USDB.claim(_recipient, _amountUSDB);\n    }\n\n    /**\n     * Sets the prize for a round\n     * @param _round - The round to set the prize for\n     * @param _prizeIndex - The index of the prize to set\n     * @param _amountWETH - The amount of WETH to set\n     * @param _amountUSDB - The amount of USDB to set\n     * @param _numWinners - The number of winners for the prize\n     */\n    function setPrize(uint256 _round, uint64 _prizeIndex, uint256 _amountWETH, uint256 _amountUSDB, uint64 _numWinners)\n        external\n        onlyOwner\n    {\n        require(_round >= currentRound, \"ICR\");\n        require(_prizeIndex < maxPrizeCount, \"IPC\");\n        depositPrize(msg.sender, _amountWETH, _amountUSDB);\n        prizes[_round][_prizeIndex] = Prize(_amountWETH, _amountUSDB, _numWinners, _prizeIndex, uint64(_round));\n    }\n\n    /**\n     * Deposits the prize amounts determined in setPrize\n     *\n     * @param _from - The address who should deposit the prize\n     * @param _amountWETH - The amount of WETH\n     * @param _amountUSDB - The amount of USDB\n     */\n    function depositPrize(address _from, uint256 _amountWETH, uint256 _amountUSDB) internal {\n        WETH.transferFrom(_from, address(this), _amountWETH);\n        USDB.transferFrom(_from, address(this), _amountUSDB);\n        emit DepositedPrizes(_amountWETH, _amountUSDB);\n    }\n\n    /**\n     * Retrieve tokens from the contract\n     * @param _recipient - The address to retrieve the tokens to\n     * @param _token - The address of the token to retrieve\n     * @param _amount - The amount of tokens to retrieve\n     */\n    function retrieveTokens(address _recipient, address _token, uint256 _amount) external onlyOwner {\n        IERC20Rebasing token = IERC20Rebasing(_token);\n        if (_amount == 0) {\n            _amount = token.balanceOf(address(this));\n        }\n        token.transfer(_recipient, _amount);\n        emit WithdrawPrizes(_recipient, _token, _amount);\n    }\n\n    /**\n     * Retrieve ETH from the contract\n     * @param _recipient - The address to retrieve the ETH to\n     * @param _amount - The amount of ETH to retrieve\n     */\n    function retrieveETH(address payable _recipient, uint256 _amount) external onlyOwner {\n        if (_amount == 0) {\n            _amount = address(this).balance;\n        }\n        _recipient.transfer(_amount);\n        emit WithdrawPrizes(_recipient, address(0), _amount);\n    }\n\n    /**\n     * Request many random numbers using Pyth Entropy\n     * @param userCommitments - The user's commitments\n     */\n    function requestRandomNumberMany(bytes32[] calldata userCommitments)\n        external\n        payable\n        onlyOwner\n        returns (uint64[] memory seqNums)\n    {\n        uint256 fee = entropy.getFee(entropyProvider);\n        require(address(this).balance >= fee * userCommitments.length, \"IF\");\n        for (uint256 i = 0; i < userCommitments.length; i++) {\n            uint64 sequenceNumber = entropy.request{value: fee}(entropyProvider, userCommitments[i], true);\n            seqNums[i] = sequenceNumber;\n            requestedRandomNumber[sequenceNumber] = msg.sender;\n            emit RandomNumberRequest(sequenceNumber, userCommitments[i]);\n        }\n    }\n\n    /**\n     * Request a random number using Pyth Entropy\n     * @param userCommitment - The user's commitment\n     */\n    function requestRandomNumber(bytes32 userCommitment) external payable onlyOwner returns (uint64) {\n        uint256 fee = entropy.getFee(entropyProvider);\n        require(address(this).balance > fee, \"IF\");\n\n        uint64 sequenceNumber = entropy.request{value: fee}(entropyProvider, userCommitment, true);\n        requestedRandomNumber[sequenceNumber] = msg.sender;\n\n        emit RandomNumberRequest(sequenceNumber, userCommitment);\n        return sequenceNumber;\n    }\n\n    /**\n     * Sets the merkle root for the current round of Thruster Treasure\n     * @param _root - The new root to set\n     */\n    function setRoot(bytes32 _root) external onlyOwner {\n        root = _root;\n        currentRound += 1;\n        roundStart[currentRound] = block.timestamp;\n        currentTickets = 0;\n        emit NewRound(_root, currentRound);\n    }\n\n    /**\n     *\n     * @param _round - The round to claim the prize for\n     * @param _prizeIndex - The index of the prize to claim\n     * @param sequenceNumbers - The sequence numbers of the random number requests\n     * @param userRandoms - The user random numbers\n     * @param providerRandoms - The provider random numbers\n     */\n    function setWinningTickets(\n        uint256 _round,\n        uint256 _prizeIndex,\n        uint64[] calldata sequenceNumbers,\n        bytes32[] calldata userRandoms,\n        bytes32[] calldata providerRandoms\n    ) external onlyOwner {\n        require(roundStart[_round] + MAX_ROUND_TIME >= block.timestamp, \"ICT\");\n        require(winningTickets[_round][_prizeIndex].length == 0, \"WTS\");\n        Prize memory prize_ = prizes[_round][_prizeIndex];\n        uint256 numWinners = prize_.numWinners;\n        require(\n            sequenceNumbers.length == numWinners && userRandoms.length == numWinners\n                && providerRandoms.length == numWinners,\n            \"WL\"\n        );\n        uint256[] memory _winningTickets = new uint256[](numWinners);\n        for (uint256 i = 0; i < numWinners; i++) {\n            _winningTickets[i] = revealRandomNumber(sequenceNumbers[i], userRandoms[i], providerRandoms[i]);\n            emit SetWinningTicket(_round, _prizeIndex, _winningTickets[i], i);\n        }\n        winningTickets[_round][_prizeIndex] = _winningTickets;\n        require(_winningTickets.length == numWinners, \"WTL\");\n    }\n\n    /**\n     * Reveals the random number using Pyth Entropy.\n     *\n     * @param sequenceNumber - The sequence number of the random number request\n     * @param userRandom - The user's random number\n     * @param providerRandom - The provider's random number\n     */\n    function revealRandomNumber(uint64 sequenceNumber, bytes32 userRandom, bytes32 providerRandom)\n        public\n        onlyOwner\n        returns (uint256)\n    {\n        require(currentTickets > 0, \"NCT\");\n        // Reveal the random number. This call reverts if the provided values fail to match the commitments\n        // from the request phase. If the call returns, randomNumber is a uniformly distributed bytes32.\n        bytes32 randomNumber = entropy.reveal(entropyProvider, sequenceNumber, userRandom, providerRandom);\n        uint256 randomTicket_ = uint256(randomNumber) % currentTickets;\n\n        emit RandomNumberResult(randomTicket_, sequenceNumber);\n        return randomTicket_;\n    }\n\n    /**\n     * Claims the gas from the BLAST contract\n     * @param _recipient - The address to claim the yield to\n     * @param _minClaimRateBips - The minimum claim rate in bips\n     */\n    function claimGas(address _recipient, uint256 _minClaimRateBips) external onlyOwner returns (uint256 amount) {\n        if (_minClaimRateBips == 0) {\n            amount = BLAST.claimMaxGas(address(this), _recipient);\n        } else {\n            amount = BLAST.claimGasAtMinClaimRate(address(this), _recipient, _minClaimRateBips);\n        }\n        emit ClaimGas(_recipient, amount);\n    }\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "thruster-protocol/thruster-treasure/contracts/ThrusterTreasure.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.23;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@pythnetwork/entropy-sdk-solidity/IEntropy.sol\";\n\nimport \"interfaces/IERC20Rebasing.sol\";\nimport \"interfaces/IThrusterTreasure.sol\";\nimport \"interfaces/IBlast.sol\";\n\n/**\n * @title ThrusterTreasure\n * @notice Contract for Thruster Treasure, a lottery game that uses entropy to determine winners\n */\ncontract ThrusterTreasure is Ownable, IThrusterTreasure {\n    struct Round {\n        uint256 ticketStart; // Inclusive\n        uint256 ticketEnd; // Not inclusive\n        uint256 round;\n    }\n\n    struct Prize {\n        uint256 amountWETH;\n        uint256 amountUSDB;\n        uint64 numWinners;\n        uint64 prizeIndex;\n        uint64 round;\n    }\n\n    uint256 public constant MAX_ROUND_TIME = 30 days; // Time at most 30 days from when round is first initiated, not when winning tickets are drawn\n\n    IBlast public immutable BLAST;\n    IERC20Rebasing public immutable WETH;\n    IERC20Rebasing public immutable USDB;\n\n    IEntropy private entropy;\n    address private entropyProvider;\n\n    bytes32 public root;\n    uint256 public currentRound; // Increments by 1 every time the root is updated\n    uint256 public currentTickets; // Resets to 0 every time the root is updated\n    uint256 public maxPrizeCount;\n    mapping(uint256 => uint256) public roundStart;\n    mapping(address => uint256) public cumulativeTickets;\n    mapping(address => mapping(uint256 => Round)) public entered; // Address => RoundIndex => Round\n    mapping(uint256 => mapping(uint256 => Prize)) public prizes; // Need to keep track of prizes for each round. RoundIndex => PrizeIndex => Prize\n    mapping(uint256 => mapping(uint256 => uint256[])) public winningTickets; // Need to keep track of winning tickets for each round. RoundIndex => PrizeIndex => WinningTickets\n    mapping(uint64 => address) private requestedRandomNumber;\n\n    /**\n     *\n     * @param _entropy - The address of the Entropy contract\n     * @param _entropyProvider - The address of the entropy provider\n     * @param _weth - The address of the WETH contract\n     * @param _usdb - The address of the USDB contract\n     */\n    constructor(\n        address _entropy,\n        address _entropyProvider,\n        address _blast,\n        address _weth,\n        address _usdb,\n        uint256 _maxPrizeCount\n    ) Ownable(msg.sender) {\n        entropy = IEntropy(_entropy);\n        entropyProvider = _entropyProvider;\n        maxPrizeCount = _maxPrizeCount;\n        BLAST = IBlast(_blast);\n        WETH = IERC20Rebasing(_weth);\n        USDB = IERC20Rebasing(_usdb);\n        BLAST.configureAutomaticYield();\n        BLAST.configureClaimableGas();\n        WETH.configure(YieldMode.CLAIMABLE);\n        USDB.configure(YieldMode.CLAIMABLE);\n    }\n\n    /**\n     * Enter tickets into the current active round of Thruster Treasure.\n     * @param _amount The amount of cumulative tickets the user has earned over time, based on merkle proof\n     * @param _proof The Merkle proof to verify the user's tickets\n     */\n    function enterTickets(uint256 _amount, bytes32[] calldata _proof) external {\n        uint256 currentRound_ = currentRound;\n        require(winningTickets[currentRound_][0].length == 0, \"ET\");\n        bytes32 node = keccak256(abi.encodePacked(msg.sender, _amount));\n        require(MerkleProof.verify(_proof, root, node), \"IP\");\n        uint256 ticketsToEnter = _amount - cumulativeTickets[msg.sender];\n        require(ticketsToEnter > 0, \"NTE\");\n        uint256 currentTickets_ = currentTickets;\n        Round memory round = Round(currentTickets_, currentTickets_ + ticketsToEnter, currentRound_);\n        entered[msg.sender][currentRound_] = round;\n        cumulativeTickets[msg.sender] = _amount; // Ensure user can only enter tickets once, no partials\n        currentTickets += ticketsToEnter;\n        emit EnteredTickets(msg.sender, currentTickets_, currentTickets_ + ticketsToEnter, currentRound_);\n    }\n\n    /**\n     * Claim prizes for a round\n     * @param roundToClaim - The round to claim prizes for\n     */\n    function claimPrizesForRound(uint256 roundToClaim) external {\n        require(roundStart[roundToClaim] + MAX_ROUND_TIME >= block.timestamp, \"ICT\");\n        require(winningTickets[roundToClaim][0].length > 0, \"NWT\");\n        Round memory round = entered[msg.sender][roundToClaim];\n        require(round.ticketEnd > round.ticketStart, \"NTE\");\n        uint256 maxPrizeCount_ = maxPrizeCount;\n        for (uint256 i = 0; i < maxPrizeCount_; i++) {\n            Prize memory prize = prizes[roundToClaim][i];\n            uint256[] memory winningTicketsRoundPrize = winningTickets[roundToClaim][i];\n            for (uint256 j = 0; j < winningTicketsRoundPrize.length; j++) {\n                uint256 winningTicket = winningTicketsRoundPrize[j];\n                if (round.ticketStart <= winningTicket && round.ticketEnd > winningTicket) {\n                    _claimPrize(prize, msg.sender, winningTicket);\n                }\n            }\n        }\n        entered[msg.sender][roundToClaim] = Round(0, 0, roundToClaim); // Clear user's tickets for the round\n        emit CheckedPrizesForRound(msg.sender, roundToClaim);\n    }\n\n    /**\n     * Claims the prize for a user\n     * @param _prize - The prize to claim\n     * @param _winningTicket - The winning ticket number\n     */\n    function _claimPrize(Prize memory _prize, address _receiver, uint256 _winningTicket) internal {\n        uint256 amountETH = _prize.amountWETH;\n        uint256 amountUSDB = _prize.amountUSDB;\n        WETH.transfer(_receiver, amountETH);\n        USDB.transfer(_receiver, amountUSDB);\n        emit ClaimedPrize(_receiver, _prize.round, _prize.prizeIndex, amountETH, amountUSDB, _winningTicket);\n    }\n\n    /**\n     * Sets the maximum prize count\n     * @param _maxPrizeCount - The new max prize count\n     */\n    function setMaxPrizeCount(uint256 _maxPrizeCount) external onlyOwner {\n        maxPrizeCount = _maxPrizeCount;\n        emit SetMaxPrizeCount(_maxPrizeCount);\n    }\n\n    /**\n     * Claims the Blast native yield\n     * @param _recipient - The address to claim the yield to\n     * @param _amountWETH - The amount of WETH to claim\n     * @param _amountUSDB - The amount of USDB to claim\n     */\n    function claimYield(address _recipient, uint256 _amountWETH, uint256 _amountUSDB) external onlyOwner {\n        WETH.claim(_recipient, _amountWETH);\n        USDB.claim(_recipient, _amountUSDB);\n    }\n\n    /**\n     * Sets the prize for a round\n     * @param _round - The round to set the prize for\n     * @param _prizeIndex - The index of the prize to set\n     * @param _amountWETH - The amount of WETH to set\n     * @param _amountUSDB - The amount of USDB to set\n     * @param _numWinners - The number of winners for the prize\n     */\n    function setPrize(uint256 _round, uint64 _prizeIndex, uint256 _amountWETH, uint256 _amountUSDB, uint64 _numWinners)\n        external\n        onlyOwner\n    {\n        require(_round >= currentRound, \"ICR\");\n        require(_prizeIndex < maxPrizeCount, \"IPC\");\n        depositPrize(msg.sender, _amountWETH, _amountUSDB);\n        prizes[_round][_prizeIndex] = Prize(_amountWETH, _amountUSDB, _numWinners, _prizeIndex, uint64(_round));\n    }\n\n    /**\n     * Deposits the prize amounts determined in setPrize\n     *\n     * @param _from - The address who should deposit the prize\n     * @param _amountWETH - The amount of WETH\n     * @param _amountUSDB - The amount of USDB\n     */\n    function depositPrize(address _from, uint256 _amountWETH, uint256 _amountUSDB) internal {\n        WETH.transferFrom(_from, address(this), _amountWETH);\n        USDB.transferFrom(_from, address(this), _amountUSDB);\n        emit DepositedPrizes(_amountWETH, _amountUSDB);\n    }\n\n    /**\n     * Retrieve tokens from the contract\n     * @param _recipient - The address to retrieve the tokens to\n     * @param _token - The address of the token to retrieve\n     * @param _amount - The amount of tokens to retrieve\n     */\n    function retrieveTokens(address _recipient, address _token, uint256 _amount) external onlyOwner {\n        IERC20Rebasing token = IERC20Rebasing(_token);\n        if (_amount == 0) {\n            _amount = token.balanceOf(address(this));\n        }\n        token.transfer(_recipient, _amount);\n        emit WithdrawPrizes(_recipient, _token, _amount);\n    }\n\n    /**\n     * Retrieve ETH from the contract\n     * @param _recipient - The address to retrieve the ETH to\n     * @param _amount - The amount of ETH to retrieve\n     */\n    function retrieveETH(address payable _recipient, uint256 _amount) external onlyOwner {\n        if (_amount == 0) {\n            _amount = address(this).balance;\n        }\n        _recipient.transfer(_amount);\n        emit WithdrawPrizes(_recipient, address(0), _amount);\n    }\n\n    /**\n     * Request many random numbers using Pyth Entropy\n     * @param userCommitments - The user's commitments\n     */\n    function requestRandomNumberMany(bytes32[] calldata userCommitments)\n        external\n        payable\n        onlyOwner\n        returns (uint64[] memory seqNums)\n    {\n        uint256 fee = entropy.getFee(entropyProvider);\n        require(address(this).balance >= fee * userCommitments.length, \"IF\");\n        for (uint256 i = 0; i < userCommitments.length; i++) {\n            uint64 sequenceNumber = entropy.request{value: fee}(entropyProvider, userCommitments[i], true);\n            seqNums[i] = sequenceNumber;\n            requestedRandomNumber[sequenceNumber] = msg.sender;\n            emit RandomNumberRequest(sequenceNumber, userCommitments[i]);\n        }\n    }\n\n    /**\n     * Request a random number using Pyth Entropy\n     * @param userCommitment - The user's commitment\n     */\n    function requestRandomNumber(bytes32 userCommitment) external payable onlyOwner returns (uint64) {\n        uint256 fee = entropy.getFee(entropyProvider);\n        require(address(this).balance > fee, \"IF\");\n\n        uint64 sequenceNumber = entropy.request{value: fee}(entropyProvider, userCommitment, true);\n        requestedRandomNumber[sequenceNumber] = msg.sender;\n\n        emit RandomNumberRequest(sequenceNumber, userCommitment);\n        return sequenceNumber;\n    }\n\n    /**\n     * Sets the merkle root for the current round of Thruster Treasure\n     * @param _root - The new root to set\n     */\n    function setRoot(bytes32 _root) external onlyOwner {\n        root = _root;\n        currentRound += 1;\n        roundStart[currentRound] = block.timestamp;\n        currentTickets = 0;\n        emit NewRound(_root, currentRound);\n    }\n\n    /**\n     *\n     * @param _round - The round to claim the prize for\n     * @param _prizeIndex - The index of the prize to claim\n     * @param sequenceNumbers - The sequence numbers of the random number requests\n     * @param userRandoms - The user random numbers\n     * @param providerRandoms - The provider random numbers\n     */\n    function setWinningTickets(\n        uint256 _round,\n        uint256 _prizeIndex,\n        uint64[] calldata sequenceNumbers,\n        bytes32[] calldata userRandoms,\n        bytes32[] calldata providerRandoms\n    ) external onlyOwner {\n        require(roundStart[_round] + MAX_ROUND_TIME >= block.timestamp, \"ICT\");\n        require(winningTickets[_round][_prizeIndex].length == 0, \"WTS\");\n        Prize memory prize_ = prizes[_round][_prizeIndex];\n        uint256 numWinners = prize_.numWinners;\n        require(\n            sequenceNumbers.length == numWinners && userRandoms.length == numWinners\n                && providerRandoms.length == numWinners,\n            \"WL\"\n        );\n        uint256[] memory _winningTickets = new uint256[](numWinners);\n        for (uint256 i = 0; i < numWinners; i++) {\n            _winningTickets[i] = revealRandomNumber(sequenceNumbers[i], userRandoms[i], providerRandoms[i]);\n            emit SetWinningTicket(_round, _prizeIndex, _winningTickets[i], i);\n        }\n        winningTickets[_round][_prizeIndex] = _winningTickets;\n        require(_winningTickets.length == numWinners, \"WTL\");\n    }\n\n    /**\n     * Reveals the random number using Pyth Entropy.\n     *\n     * @param sequenceNumber - The sequence number of the random number request\n     * @param userRandom - The user's random number\n     * @param providerRandom - The provider's random number\n     */\n    function revealRandomNumber(uint64 sequenceNumber, bytes32 userRandom, bytes32 providerRandom)\n        public\n        onlyOwner\n        returns (uint256)\n    {\n        require(currentTickets > 0, \"NCT\");\n        // Reveal the random number. This call reverts if the provided values fail to match the commitments\n        // from the request phase. If the call returns, randomNumber is a uniformly distributed bytes32.\n        bytes32 randomNumber = entropy.reveal(entropyProvider, sequenceNumber, userRandom, providerRandom);\n        uint256 randomTicket_ = uint256(randomNumber) % currentTickets;\n\n        emit RandomNumberResult(randomTicket_, sequenceNumber);\n        return randomTicket_;\n    }\n\n    /**\n     * Claims the gas from the BLAST contract\n     * @param _recipient - The address to claim the yield to\n     * @param _minClaimRateBips - The minimum claim rate in bips\n     */\n    function claimGas(address _recipient, uint256 _minClaimRateBips) external onlyOwner returns (uint256 amount) {\n        if (_minClaimRateBips == 0) {\n            amount = BLAST.claimMaxGas(address(this), _recipient);\n        } else {\n            amount = BLAST.claimGasAtMinClaimRate(address(this), _recipient, _minClaimRateBips);\n        }\n        emit ClaimGas(_recipient, amount);\n    }\n\n    receive() external payable {}\n}"
    }
  ]
}