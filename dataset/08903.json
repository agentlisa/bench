{
  "Title": "[10] `<array>.length` should not be looked up in every loop of a `for`-loop",
  "Content": "The overheads outlined below are _PER LOOP_, excluding the first loop\n* storage arrays incur a Gwarmaccess (**100 gas**)\n* memory arrays use `MLOAD` (**3 gas**)\n* calldata arrays use `CALLDATALOAD` (**3 gas**)\n\nCaching the length changes each of these to a `DUP<N>` (**3 gas**), and gets rid of the extra `DUP<N>` needed to store the stack offset\n\n*There are 8 instances of this issue:*\n```solidity\nFile: protocol/contracts/StakerVault.sol\n\n259:          for (uint256 i; i < actions.length; i = i.uncheckedInc()) {\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L259\n\n```solidity\nFile: protocol/contracts/zaps/PoolMigrationZap.sol\n\n22:           for (uint256 i; i < newPools_.length; ++i) {\n\n39:           for (uint256 i; i < oldPoolAddresses_.length; ) {\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L22\n\n```solidity\nFile: protocol/contracts/RewardHandler.sol\n\n42:           for (uint256 i; i < pools.length; i = i.uncheckedInc()) {\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L42\n\n```solidity\nFile: protocol/contracts/tokenomics/InflationManager.sol\n\n116:          for (uint256 i; i < stakerVaults.length; i = i.uncheckedInc()) {\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L116\n\n```solidity\nFile: protocol/contracts/tokenomics/VestedEscrow.sol\n\n94:           for (uint256 i; i < amounts.length; i = i.uncheckedInc()) {\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L94\n\n```solidity\nFile: protocol/contracts/tokenomics/FeeBurner.sol\n\n56:           for (uint256 i; i < tokens_.length; i = i.uncheckedInc()) {\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L56\n\n```solidity\nFile: protocol/contracts/access/RoleManager.sol\n\n82:           for (uint256 i; i < roles.length; i = i.uncheckedInc()) {\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L82\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-05-backd",
  "Code": [
    {
      "filename": "protocol/contracts/StakerVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"../libraries/ScaledMath.sol\";\nimport \"../libraries/Errors.sol\";\nimport \"../libraries/AddressProviderHelpers.sol\";\nimport \"../libraries/UncheckedMath.sol\";\n\nimport \"../interfaces/IStakerVault.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/tokenomics/IRewardsGauge.sol\";\nimport \"../interfaces/tokenomics/IInflationManager.sol\";\nimport \"../interfaces/pool/ILiquidityPool.sol\";\nimport \"../interfaces/tokenomics/ILpGauge.sol\";\nimport \"../interfaces/IERC20Full.sol\";\n\nimport \"./utils/Preparable.sol\";\nimport \"./Controller.sol\";\nimport \"./pool/LiquidityPool.sol\";\nimport \"./access/Authorization.sol\";\nimport \"./utils/Pausable.sol\";\n\n/**\n * @notice This contract handles staked tokens from Backd pools\n * However, note that this is NOT an ERC-20 compliant contract and these\n * tokens should never be integrated with any protocol assuming ERC-20 compliant\n * tokens\n * @dev When paused, allows only withdraw/unstake\n */\ncontract StakerVault is IStakerVault, Authorization, Pausable, Initializable, Preparable {\n    using AddressProviderHelpers for IAddressProvider;\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using UncheckedMath for uint256;\n\n    bytes32 internal constant _LP_GAUGE = \"lpGauge\";\n\n    IController public immutable controller;\n\n    IInflationManager public immutable inflationManager;\n    IAddressProvider public immutable addressProvider;\n\n    address public token;\n\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public actionLockedBalances;\n\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    // All the data fields required for the staking tracking\n    uint256 private _poolTotalStaked;\n\n    mapping(address => bool) public strategies;\n    uint256 public strategiesTotalStaked;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        IInflationManager inflationManager_ = controller.inflationManager();\n        require(address(inflationManager_) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        inflationManager = inflationManager_;\n        addressProvider = _controller.addressProvider();\n    }\n\n    function initialize(address _token) external override initializer {\n        token = _token;\n    }\n\n    function initializeLpGauge(address _lpGauge) external override onlyGovernance returns (bool) {\n        require(currentAddresses[_LP_GAUGE] == address(0), Error.ROLE_EXISTS);\n        _setConfig(_LP_GAUGE, _lpGauge);\n        inflationManager.addGaugeForVault(token);\n        return true;\n    }\n\n    function prepareLpGauge(address _lpGauge) external override onlyGovernance returns (bool) {\n        _prepare(_LP_GAUGE, _lpGauge);\n        return true;\n    }\n\n    function executeLpGauge() external override onlyGovernance returns (bool) {\n        _executeAddress(_LP_GAUGE);\n        inflationManager.addGaugeForVault(token);\n        return true;\n    }\n\n    /**\n     * @notice Registers an address as a strategy to be excluded from token accumulation.\n     * @dev This should be used if a strategy deposits into a stakerVault and should not get gov. tokens.\n     * @return `true` if success.\n     */\n    function addStrategy(address strategy) external override returns (bool) {\n        require(msg.sender == address(inflationManager), Error.UNAUTHORIZED_ACCESS);\n        strategies[strategy] = true;\n        return true;\n    }\n\n    /**\n     * @notice Transfer staked tokens to an account.\n     * @dev This is not an ERC20 transfer, as tokens are still owned by this contract, but fees get updated in the LP pool.\n     * @param account Address to transfer to.\n     * @param amount Amount to transfer.\n     * @return `true` if success.\n     */\n    function transfer(address account, uint256 amount) external override notPaused returns (bool) {\n        require(msg.sender != account, Error.SELF_TRANSFER_NOT_ALLOWED);\n        require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE);\n\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        pool.handleLpTokenTransfer(msg.sender, account, amount);\n\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(msg.sender);\n            ILpGauge(lpGauge).userCheckpoint(account);\n        }\n\n        balances[msg.sender] -= amount;\n        balances[account] += amount;\n\n        emit Transfer(msg.sender, account, amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer staked tokens from src to dst.\n     * @dev This is not an ERC20 transfer, as tokens are still owned by this contract, but fees get updated in the LP pool.\n     * @param src Address to transfer from.\n     * @param dst Address to transfer to.\n     * @param amount Amount to transfer.\n     * @return `true` if success.\n     */\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external override notPaused returns (bool) {\n        /* Do not allow self transfers */\n        require(src != dst, Error.SAME_ADDRESS_NOT_ALLOWED);\n\n        /* Get the allowance, infinite for the account owner */\n        uint256 startingAllowance;\n        if (msg.sender == src) {\n            startingAllowance = type(uint256).max;\n        } else {\n            startingAllowance = _allowances[src][msg.sender];\n        }\n        require(startingAllowance >= amount, Error.INSUFFICIENT_ALLOWANCE);\n\n        uint256 srcTokens = balances[src];\n        require(srcTokens >= amount, Error.INSUFFICIENT_BALANCE);\n\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(src);\n            ILpGauge(lpGauge).userCheckpoint(dst);\n        }\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        pool.handleLpTokenTransfer(src, dst, amount);\n\n        /* Update token balances */\n        balances[src] = srcTokens.uncheckedSub(amount);\n        balances[dst] = balances[dst] + amount;\n\n        /* Update allowance if necessary */\n        if (startingAllowance != type(uint256).max) {\n            _allowances[src][msg.sender] = startingAllowance.uncheckedSub(amount);\n        }\n        emit Transfer(src, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Approve staked tokens for spender.\n     * @param spender Address to approve tokens for.\n     * @param amount Amount to approve.\n     * @return `true` if success.\n     */\n    function approve(address spender, uint256 amount) external override notPaused returns (bool) {\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice If an action is registered and stakes funds, this updates the actionLockedBalances for the user.\n     * @param account Address that registered the action.\n     * @param amount Amount staked by the action.\n     * @return `true` if success.\n     */\n    function increaseActionLockedBalance(address account, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        require(addressProvider.isAction(msg.sender), Error.UNAUTHORIZED_ACCESS);\n\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(account);\n        }\n        actionLockedBalances[account] += amount;\n        return true;\n    }\n\n    /**\n     * @notice If an action is executed/reset, this updates the actionLockedBalances for the user.\n     * @param account Address that registered the action.\n     * @param amount Amount executed/reset by the action.\n     * @return `true` if success.\n     */\n    function decreaseActionLockedBalance(address account, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        require(addressProvider.isAction(msg.sender), Error.UNAUTHORIZED_ACCESS);\n\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(account);\n        }\n        if (actionLockedBalances[account] > amount) {\n            actionLockedBalances[account] = actionLockedBalances[account].uncheckedSub(amount);\n        } else {\n            actionLockedBalances[account] = 0;\n        }\n        return true;\n    }\n\n    function poolCheckpoint() external override returns (bool) {\n        if (currentAddresses[_LP_GAUGE] != address(0)) {\n            return ILpGauge(currentAddresses[_LP_GAUGE]).poolCheckpoint();\n        }\n        return false;\n    }\n\n    function getLpGauge() external view override returns (address) {\n        return currentAddresses[_LP_GAUGE];\n    }\n\n    function isStrategy(address user) external view override returns (bool) {\n        return strategies[user];\n    }\n\n    /**\n     * @notice Get the total amount of tokens that are staked by actions\n     * @return Total amount staked by actions\n     */\n    function getStakedByActions() external view override returns (uint256) {\n        address[] memory actions = addressProvider.allActions();\n        uint256 total;\n        for (uint256 i; i < actions.length; i = i.uncheckedInc()) {\n            total += balances[actions[i]];\n        }\n        return total;\n    }\n\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function balanceOf(address account) external view override returns (uint256) {\n        return balances[account];\n    }\n\n    function getPoolTotalStaked() external view override returns (uint256) {\n        return _poolTotalStaked;\n    }\n\n    /**\n     * @notice Returns the total balance in the staker vault, including that locked in positions.\n     * @param account Account to query balance for.\n     * @return Total balance in staker vault for account.\n     */\n    function stakedAndActionLockedBalanceOf(address account)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return balances[account] + actionLockedBalances[account];\n    }\n\n    function actionLockedBalanceOf(address account) external view override returns (uint256) {\n        return actionLockedBalances[account];\n    }\n\n    function decimals() external view override returns (uint8) {\n        return IERC20Full(token).decimals();\n    }\n\n    function getToken() external view override returns (address) {\n        return token;\n    }\n\n    function unstake(uint256 amount) public override returns (bool) {\n        return unstakeFor(msg.sender, msg.sender, amount);\n    }\n\n    /**\n     * @notice Stake an amount of vault tokens.\n     * @param amount Amount of token to stake.\n     * @return `true` if success.\n     */\n    function stake(uint256 amount) public override returns (bool) {\n        return stakeFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Stake amount of vault token on behalf of another account.\n     * @param account Account for which tokens will be staked.\n     * @param amount Amount of token to stake.\n     * @return `true` if success.\n     */\n    function stakeFor(address account, uint256 amount) public override notPaused returns (bool) {\n        require(IERC20(token).balanceOf(msg.sender) >= amount, Error.INSUFFICIENT_BALANCE);\n\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(account);\n        }\n\n        uint256 oldBal = IERC20(token).balanceOf(address(this));\n\n        if (msg.sender != account) {\n            ILiquidityPool pool = addressProvider.getPoolForToken(token);\n            pool.handleLpTokenTransfer(msg.sender, account, amount);\n        }\n\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 staked = IERC20(token).balanceOf(address(this)) - oldBal;\n        require(staked == amount, Error.INVALID_AMOUNT);\n        balances[account] += staked;\n\n        if (strategies[account]) {\n            strategiesTotalStaked += staked;\n        } else {\n            _poolTotalStaked += staked;\n        }\n        emit Staked(account, amount);\n        return true;\n    }\n\n    /**\n     * @notice Unstake tokens on behalf of another account.\n     * @dev Needs to be approved.\n     * @param src Account for which tokens will be unstaked.\n     * @param dst Account receiving the tokens.\n     * @param amount Amount of token to unstake/receive.\n     * @return `true` if success.\n     */\n    function unstakeFor(\n        address src,\n        address dst,\n        uint256 amount\n    ) public override returns (bool) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        uint256 allowance_ = _allowances[src][msg.sender];\n        require(\n            src == msg.sender || allowance_ >= amount || address(pool) == msg.sender,\n            Error.UNAUTHORIZED_ACCESS\n        );\n        require(balances[src] >= amount, Error.INSUFFICIENT_BALANCE);\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(src);\n        }\n        uint256 oldBal = IERC20(token).balanceOf(address(this));\n\n        if (src != dst) {\n            pool.handleLpTokenTransfer(src, dst, amount);\n        }\n\n        IERC20(token).safeTransfer(dst, amount);\n\n        uint256 unstaked = oldBal.uncheckedSub(IERC20(token).balanceOf(address(this)));\n\n        if (src != msg.sender && allowance_ != type(uint256).max && address(pool) != msg.sender) {\n            // update allowance\n            _allowances[src][msg.sender] -= unstaked;\n        }\n        balances[src] -= unstaked;\n\n        if (strategies[src]) {\n            strategiesTotalStaked -= unstaked;\n        } else {\n            _poolTotalStaked -= unstaked;\n        }\n        emit Unstaked(src, amount);\n        return true;\n    }\n\n    function _isAuthorizedToPause(address account) internal view override returns (bool) {\n        return _roleManager().hasRole(Roles.GOVERNANCE, account);\n    }\n}"
    },
    {
      "filename": "protocol/contracts/zaps/PoolMigrationZap.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../interfaces/zaps/IPoolMigrationZap.sol\";\nimport \"../../interfaces/IAddressProvider.sol\";\nimport \"../../interfaces/pool/ILiquidityPool.sol\";\n\n/**\n * This is a Zap contract to assist in the migration from the V1 Backd Pools to the new Backd Pools.\n */\ncontract PoolMigrationZap is IPoolMigrationZap {\n    using SafeERC20 for IERC20;\n\n    mapping(address => ILiquidityPool) internal _underlyingNewPools; // A mapping from underlyings to new pools\n\n    event Migrated(address user, address oldPool, address newPool, uint256 lpTokenAmount); // Emitted when a migration is completed\n\n    constructor(address newAddressProviderAddress_) {\n        address[] memory newPools_ = IAddressProvider(newAddressProviderAddress_).allPools();\n        for (uint256 i; i < newPools_.length; ++i) {\n            ILiquidityPool newPool_ = ILiquidityPool(newPools_[i]);\n            address underlying_ = newPool_.getUnderlying();\n            _underlyingNewPools[underlying_] = newPool_;\n            if (underlying_ == address(0)) continue;\n            IERC20(underlying_).safeApprove(address(newPool_), type(uint256).max);\n        }\n    }\n\n    receive() external payable {}\n\n    /**\n     * @notice Migrates all of a users balance from the old pools to the new pools.\n     * @dev The user must have balance in all pools given, otherwise transaction will revert.\n     * @param oldPoolAddresses_ The list of old pools to migrate for the user.\n     */\n    function migrateAll(address[] calldata oldPoolAddresses_) external override {\n        for (uint256 i; i < oldPoolAddresses_.length; ) {\n            migrate(oldPoolAddresses_[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Migrates a users balance from an old pool to a new pool.\n     * @dev The user must have balance in the pool given, otherwise transaction will revert.\n     * @param oldPoolAddress_ The old pool to migrate for the user.\n     */\n    function migrate(address oldPoolAddress_) public override {\n        ILiquidityPool oldPool_ = ILiquidityPool(oldPoolAddress_);\n        IERC20 lpToken_ = IERC20(oldPool_.getLpToken());\n        uint256 lpTokenAmount_ = lpToken_.balanceOf(msg.sender);\n        require(lpTokenAmount_ != 0, \"No LP Tokens\");\n        require(oldPool_.getWithdrawalFee(msg.sender, lpTokenAmount_) == 0, \"withdrawal fee not 0\");\n        lpToken_.safeTransferFrom(msg.sender, address(this), lpTokenAmount_);\n        uint256 underlyingAmount_ = oldPool_.redeem(lpTokenAmount_);\n        address underlying_ = oldPool_.getUnderlying();\n        ILiquidityPool newPool_ = _underlyingNewPools[underlying_];\n        uint256 ethValue_ = underlying_ == address(0) ? underlyingAmount_ : 0;\n        newPool_.depositFor{value: ethValue_}(msg.sender, underlyingAmount_);\n        emit Migrated(msg.sender, address(oldPool_), address(newPool_), lpTokenAmount_);\n    }\n}"
    },
    {
      "filename": "protocol/contracts/RewardHandler.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/IFeeBurner.sol\";\nimport \"../interfaces/IBkdLocker.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\nimport \"../interfaces/IRewardHandler.sol\";\nimport \"./utils/Preparable.sol\";\nimport \"./access/Authorization.sol\";\nimport \"../libraries/AddressProviderHelpers.sol\";\nimport \"../libraries/UncheckedMath.sol\";\n\ncontract RewardHandler is IRewardHandler, Preparable, Authorization {\n    using UncheckedMath for uint256;\n    using SafeERC20 for IERC20;\n    using AddressProviderHelpers for IAddressProvider;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = IAddressProvider(controller.addressProvider());\n    }\n\n    receive() external payable {}\n\n    /**\n     * @notice Burns all accumulated fees and pays these out to the BKD locker.\n     */\n    function burnFees() external override {\n        IBkdLocker bkdLocker = IBkdLocker(addressProvider.getBKDLocker());\n        IFeeBurner feeBurner = addressProvider.getFeeBurner();\n        address targetLpToken = bkdLocker.rewardToken();\n        address[] memory pools = addressProvider.allPools();\n        uint256 ethBalance = address(this).balance;\n        address[] memory tokens = new address[](pools.length);\n        for (uint256 i; i < pools.length; i = i.uncheckedInc()) {\n            ILiquidityPool pool = ILiquidityPool(pools[i]);\n            address underlying = pool.getUnderlying();\n            if (underlying != address(0)) {\n                _approve(underlying, address(feeBurner));\n            }\n            tokens[i] = underlying;\n        }\n        feeBurner.burnToTarget{value: ethBalance}(tokens, targetLpToken);\n        uint256 burnedAmount = IERC20(targetLpToken).balanceOf(address(this));\n        IERC20(targetLpToken).safeApprove(address(bkdLocker), burnedAmount);\n        bkdLocker.depositFees(burnedAmount);\n        emit Burned(targetLpToken, burnedAmount);\n    }\n\n    /**\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     */\n    function _approve(address token, address spender) internal {\n        if (IERC20(token).allowance(address(this), spender) > 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n}"
    },
    {
      "filename": "protocol/contracts/tokenomics/InflationManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"../../interfaces/IStakerVault.sol\";\nimport \"../../interfaces/tokenomics/IInflationManager.sol\";\nimport \"../../interfaces/tokenomics/IKeeperGauge.sol\";\nimport \"../../interfaces/tokenomics/IAmmGauge.sol\";\n\nimport \"../../libraries/EnumerableMapping.sol\";\nimport \"../../libraries/EnumerableExtensions.sol\";\nimport \"../../libraries/AddressProviderHelpers.sol\";\nimport \"../../libraries/UncheckedMath.sol\";\n\nimport \"./Minter.sol\";\nimport \"../utils/Preparable.sol\";\nimport \"../access/Authorization.sol\";\n\ncontract InflationManager is Authorization, IInflationManager, Preparable {\n    using UncheckedMath for uint256;\n    using EnumerableMapping for EnumerableMapping.AddressToAddressMap;\n    using EnumerableExtensions for EnumerableMapping.AddressToAddressMap;\n    using AddressProviderHelpers for IAddressProvider;\n\n    IAddressProvider public immutable addressProvider;\n\n    bytes32 internal constant _KEEPER_WEIGHT_KEY = \"keeperWeight\";\n    bytes32 internal constant _AMM_WEIGHT_KEY = \"ammWeight\";\n    bytes32 internal constant _LP_WEIGHT_KEY = \"lpWeight\";\n\n    address public minter;\n    bool public weightBasedKeeperDistributionDeactivated;\n    uint256 public totalKeeperPoolWeight;\n    uint256 public totalLpPoolWeight;\n    uint256 public totalAmmTokenWeight;\n\n    // Pool -> keeperGauge\n    EnumerableMapping.AddressToAddressMap private _keeperGauges;\n    // AMM token -> ammGauge\n    EnumerableMapping.AddressToAddressMap private _ammGauges;\n\n    mapping(address => bool) public gauges;\n\n    event NewKeeperWeight(address indexed pool, uint256 newWeight);\n    event NewLpWeight(address indexed pool, uint256 newWeight);\n    event NewAmmTokenWeight(address indexed token, uint256 newWeight);\n\n    modifier onlyGauge() {\n        require(gauges[msg.sender], Error.UNAUTHORIZED_ACCESS);\n        _;\n    }\n\n    constructor(IAddressProvider _addressProvider)\n        Authorization(_addressProvider.getRoleManager())\n    {\n        addressProvider = _addressProvider;\n    }\n\n    function setMinter(address _minter) external override onlyGovernance returns (bool) {\n        require(minter == address(0), Error.ADDRESS_ALREADY_SET);\n        require(_minter != address(0), Error.INVALID_MINTER);\n        minter = _minter;\n        return true;\n    }\n\n    /**\n     * @notice Advance the keeper gauge for a pool by on epoch.\n     * @param pool Pool for which the keeper gauge is advanced.\n     * @return `true` if successful.\n     */\n    function advanceKeeperGaugeEpoch(address pool) external override onlyGovernance returns (bool) {\n        IKeeperGauge(_keeperGauges.get(pool)).advanceEpoch();\n        return true;\n    }\n\n    /**\n     * @notice Mints BKD tokens.\n     * @param beneficiary Address to receive the tokens.\n     * @param amount Amount of tokens to mint.\n     */\n    function mintRewards(address beneficiary, uint256 amount) external override onlyGauge {\n        Minter(minter).mint(beneficiary, amount);\n    }\n\n    /**\n     * @notice Deactivates the weight-based distribution of keeper inflation.\n     * @dev This can only be done once, when the keeper inflation mechanism is altered.\n     * @return `true` if successful.\n     */\n    function deactivateWeightBasedKeeperDistribution()\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        require(!weightBasedKeeperDistributionDeactivated, \"Weight-based dist. deactivated.\");\n        address[] memory liquidityPools = addressProvider.allPools();\n        uint256 length = liquidityPools.length;\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            _removeKeeperGauge(address(liquidityPools[i]));\n        }\n        weightBasedKeeperDistributionDeactivated = true;\n        return true;\n    }\n\n    /**\n     * @notice Checkpoints all gauges.\n     * @dev This is mostly used upon inflation rate updates.\n     * @return `true` if successful.\n     */\n    function checkpointAllGauges() external override returns (bool) {\n        uint256 length = _keeperGauges.length();\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            IKeeperGauge(_keeperGauges.valueAt(i)).poolCheckpoint();\n        }\n        address[] memory stakerVaults = addressProvider.allStakerVaults();\n        for (uint256 i; i < stakerVaults.length; i = i.uncheckedInc()) {\n            IStakerVault(stakerVaults[i]).poolCheckpoint();\n        }\n\n        length = _ammGauges.length();\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            IAmmGauge(_ammGauges.valueAt(i)).poolCheckpoint();\n        }\n        return true;\n    }\n\n    /**\n     * @notice Prepare update of a keeper pool weight (with time delay enforced).\n     * @param pool Pool to update the keeper weight for.\n     * @param newPoolWeight New weight for the keeper inflation for the pool.\n     * @return `true` if successful.\n     */\n    function prepareKeeperPoolWeight(address pool, uint256 newPoolWeight)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        require(_keeperGauges.contains(pool), Error.INVALID_ARGUMENT);\n        bytes32 key = _getKeeperGaugeKey(pool);\n        _prepare(key, newPoolWeight);\n        return true;\n    }\n\n    /**\n     * @notice Execute update of keeper pool weight (with time delay enforced).\n     * @param pool Pool to execute the keeper weight update for.\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return New keeper pool weight.\n     */\n    function executeKeeperPoolWeight(address pool) external override returns (uint256) {\n        bytes32 key = _getKeeperGaugeKey(pool);\n        _executeKeeperPoolWeight(key, pool, isInflationWeightManager(msg.sender));\n        return currentUInts256[key];\n    }\n\n    /**\n     * @notice Prepare update of a batch of keeperGauge weights (with time delay enforced).\n     * @dev Each entry in the pools array corresponds to an entry in the weights array.\n     * @param pools Pools to update the keeper weight for.\n     * @param weights New weights for the keeper inflation for the pools.\n     * @return `true` if successful.\n     */\n    function batchPrepareKeeperPoolWeights(address[] calldata pools, uint256[] calldata weights)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        uint256 length = pools.length;\n        require(length == weights.length, Error.INVALID_ARGUMENT);\n        bytes32 key;\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            require(_keeperGauges.contains(pools[i]), Error.INVALID_ARGUMENT);\n            key = _getKeeperGaugeKey(pools[i]);\n            _prepare(key, weights[i]);\n        }\n        return true;\n    }\n\n    function whitelistGauge(address gauge) external override onlyRole(Roles.CONTROLLER) {\n        gauges[gauge] = true;\n    }\n\n    /**\n     * @notice Execute weight updates for a batch of _keeperGauges.\n     * @param pools Pools to execute the keeper weight updates for.\n     * @return `true` if successful.\n     */\n    function batchExecuteKeeperPoolWeights(address[] calldata pools)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)\n        returns (bool)\n    {\n        uint256 length = pools.length;\n        bytes32 key;\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            key = _getKeeperGaugeKey(pools[i]);\n            _executeKeeperPoolWeight(key, pools[i], isInflationWeightManager(msg.sender));\n        }\n        return true;\n    }\n\n    function removeStakerVaultFromInflation(address stakerVault, address lpToken)\n        external\n        override\n        onlyRole(Roles.CONTROLLER)\n    {\n        bytes32 key = _getLpStakerVaultKey(stakerVault);\n        _prepare(key, 0);\n        _executeLpPoolWeight(key, lpToken, stakerVault, true);\n    }\n\n    /**\n     * @notice Prepare update of a lp pool weight (with time delay enforced).\n     * @param lpToken LP token to update the weight for.\n     * @param newPoolWeight New LP inflation weight.\n     * @return `true` if successful.\n     */\n    function prepareLpPoolWeight(address lpToken, uint256 newPoolWeight)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)\n        returns (bool)\n    {\n        address stakerVault = addressProvider.getStakerVault(lpToken);\n        // Require both that gauge is registered and that pool is still in action\n        require(gauges[IStakerVault(stakerVault).getLpGauge()], Error.GAUGE_DOES_NOT_EXIST);\n        _ensurePoolExists(lpToken);\n        bytes32 key = _getLpStakerVaultKey(stakerVault);\n        _prepare(key, newPoolWeight);\n        return true;\n    }\n\n    /**\n     * @notice Execute update of lp pool weight (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return New lp pool weight.\n     */\n    function executeLpPoolWeight(address lpToken) external override returns (uint256) {\n        address stakerVault = addressProvider.getStakerVault(lpToken);\n        // Require both that gauge is registered and that pool is still in action\n        require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND);\n        _ensurePoolExists(lpToken);\n        bytes32 key = _getLpStakerVaultKey(stakerVault);\n        _executeLpPoolWeight(key, lpToken, stakerVault, isInflationWeightManager(msg.sender));\n        return currentUInts256[key];\n    }\n\n    /**\n     * @notice Prepare update of a batch of LP token weights (with time delay enforced).\n     * @dev Each entry in the lpTokens array corresponds to an entry in the weights array.\n     * @param lpTokens LpTokens to update the inflation weight for.\n     * @param weights New weights for the inflation for the LpTokens.\n     * @return `true` if successful.\n     */\n    function batchPrepareLpPoolWeights(address[] calldata lpTokens, uint256[] calldata weights)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)\n        returns (bool)\n    {\n        uint256 length = lpTokens.length;\n        require(length == weights.length, \"Invalid length of arguments\");\n        bytes32 key;\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            address stakerVault = addressProvider.getStakerVault(lpTokens[i]);\n            // Require both that gauge is registered and that pool is still in action\n            require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND);\n            _ensurePoolExists(lpTokens[i]);\n            key = _getLpStakerVaultKey(stakerVault);\n            _prepare(key, weights[i]);\n        }\n        return true;\n    }\n\n    /**\n     * @notice Execute weight updates for a batch of LpTokens.\n     * @dev If this is called by the INFLATION_MANAGER role address, no time delay is enforced.\n     * @param lpTokens LpTokens to execute the weight updates for.\n     * @return `true` if successful.\n     */\n    function batchExecuteLpPoolWeights(address[] calldata lpTokens)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)\n        returns (bool)\n    {\n        uint256 length = lpTokens.length;\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            address lpToken = lpTokens[i];\n            address stakerVault = addressProvider.getStakerVault(lpToken);\n            // Require both that gauge is registered and that pool is still in action\n            require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND);\n            _ensurePoolExists(lpToken);\n            bytes32 key = _getLpStakerVaultKey(stakerVault);\n            _executeLpPoolWeight(key, lpToken, stakerVault, isInflationWeightManager(msg.sender));\n        }\n        return true;\n    }\n\n    /**\n     * @notice Prepare an inflation weight update for an AMM token (with time delay enforced).\n     * @param token AMM token to update the weight for.\n     * @param newTokenWeight New AMM token inflation weight.\n     * @return `true` if successful.\n     */\n    function prepareAmmTokenWeight(address token, uint256 newTokenWeight)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)\n        returns (bool)\n    {\n        require(_ammGauges.contains(token), \"amm gauge not found\");\n        bytes32 key = _getAmmGaugeKey(token);\n        _prepare(key, newTokenWeight);\n        return true;\n    }\n\n    /**\n     * @notice Execute update of lp pool weight (with time delay enforced).\n     *"
    }
  ]
}