{
  "Title": "[G-19]  Don't use `_msgSender()` if not supporting EIP-2771",
  "Content": "Use `msg.sender` if the code does not implement [EIP-2771 trusted forwarder](https://eips.ethereum.org/EIPS/eip-2771) support.\n\n*There are 7 instances of this issue.*\n\n___\n\n## Excluded Findings\nThese findings are excluded from awards calculations because there are publicly-available automated tools that find them. The valid ones appear here for completeness.\n\n### Gas Optimizations\n| |Issue|Instances|Total Gas Saved|\n|-|:-|:-:|:-:|\n| [G&#x2011;20] | Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas | 34 | 4080 |\n| [G&#x2011;21] | State variables should be cached in stack variables rather than re-reading them from storage | 1 | 97 |\n| [G&#x2011;22] | `<array>.length` should not be looked up in every loop of a `for`-loop | 41 | 123 |\n| [G&#x2011;23] | Using `bool`s for storage incurs overhead | 1 | 17100 |\n| [G&#x2011;24] | Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement | 1 | 6 |\n| [G&#x2011;25] | `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too) | 57 | 285 |\n| [G&#x2011;26] | Using `private` rather than `public` for constants, saves gas | 8 | - |\n| [G&#x2011;27] | Division by two should use bit shifting | 2 | 40 |\n| [G&#x2011;28] | Use custom errors rather than `revert()`/`require()` strings to save gas | 15 | - |\n\nTotal: 160 instances over 9 issues with **21731 gas** saved\n\nGas totals use lower bounds of ranges and count two iterations of each `for`-loop. All values above are runtime, not deployment, values; deployment values are listed in the individual issue descriptions.\n\n### [G&#x2011;20]  Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas\nWhen a function with a `memory` array is called externally, the `abi.decode()` step has to use a for-loop to copy each index of the `calldata` to the `memory` index. **Each iteration of this for-loop costs at least 60 gas** (i.e. `60 * <mem_array>.length`). Using `calldata` directly, obliviates the need for such a loop in the contract code and runtime execution. Note that even if an interface defines a function as having `memory` arguments, it's still valid for implementation contracs to use `calldata` arguments instead. \n\nIf the array is passed to an `internal` function which passes the array to another internal function where the array is modified and therefore `memory` is used in the `external` call, it's still more gass-efficient to use `calldata` when the `external` function uses modifiers, since the modifiers may prevent the internal functions from being called. Structs have the same overhead as an array of length one.\n\nNote that I've also flagged instances where the function is `public` but can be marked as `external` since it's not called by the contract, and cases where a constructor is involved.\n\n*There are 34 instances of this issue.*\n\n### [G&#x2011;21]  State variables should be cached in stack variables rather than re-reading them from storage\nThe instances below point to the second+ access of a state variable within a function. Caching of a state variable replaces each Gwarmaccess (**100 gas**) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: paraspace-core/contracts/misc/NFTFloorOracle.sol\n\n/// @audit assetPriceMap[_asset].twap on line 405 - (valid but excluded finding)\n426:              return (false, assetPriceMap[_asset].twap);\n\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L426\n\n### [G&#x2011;22]  `<array>.length` should not be looked up in every loop of a `for`-loop\nThe overheads outlined below are _PER LOOP_, excluding the first loop\n* storage arrays incur a Gwarmaccess (**100 gas**)\n* memory arrays use `MLOAD` (**3 gas**)\n* calldata arrays use `CALLDATALOAD` (**3 gas**)\n\nCaching the length changes each of these to a `DUP<N>` (**3 gas**), and gets rid of the extra `DUP<N>` needed to store the stack offset\n\n*There are 41 instances of this issue.*\n\n### [G&#x2011;23]  Using `bool`s for storage incurs overhead\n```solidity\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n```\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27\n\nUse `uint256(1)` and `uint256(2)` for true/false to avoid a Gwarmaccess (**[100 gas](https://gist.github.com/IllIllI000/1b70014db712f8572a72378321250058)**) for the extra SLOAD, and to avoid Gsset (**20000 gas**) when changing from `false` to `true`, after having been `true` in the past\n\n*There is 1 instance of this issue:*\n```solidity\nFile: paraspace-core/contracts/protocol/tokenization/base/MintableIncentivizedERC721.sol\n\n/// @audit (valid but excluded finding)\n73:       bool public immutable ATOMIC_PRICING;\n\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/tokenization/base/MintableIncentivizedERC721.sol#L73\n\n### [G&#x2011;24]  Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement\nThis change saves **[6 gas](https://aws1.discourse-cdn.com/business6/uploads/zeppelin/original/2X/3/363a367d6d68851f27d2679d10706cd16d788b96.png)** per instance. The optimization works until solidity version [0.8.13](https://gist.github.com/IllIllI000/bf2c3120f24a69e489f12b3213c06c94) where there is a regression in gas costs.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: paraspace-core/contracts/misc/NFTFloorOracle.sol\n\n/// @audit (valid but excluded finding)\n356:          require(_twap > 0, \"NFTOracle: price should be more than 0\");\n\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L356\n\n### [G&#x2011;25]  `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too)\nSaves **5 gas per loop**.\n\n*There are 57 instances of this issue.*\n\n### [G&#x2011;26]  Using `private` rather than `public` for constants, saves gas\nIf needed, the values can be read from the verified contract source code, or if there are multiple values there can be a single getter function that [returns a tuple](https://github.com/code-423n4/2022-08-frax/blob/90f55a9ce4e25bceed3a74290b854341d8de6afa/src/contracts/FraxlendPair.sol#L156-L178) of the values of all currently-public constants. Saves **3406-3606 gas** in deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table.\n\n*There are 8 instances of this issue.*\n\n### [G&#x2011;27]  Division by two should use bit shifting\n`<x> / 2` is the same as `<x> >> 1`. While the compiler uses the `SHR` opcode to accomplish both, the version that uses division incurs an overhead of [**20 gas**](https://gist.github.com/IllIllI000/ec0e4e6c4f52a6bca158f137a3afd4ff) due to `JUMP`s to and from a compiler utility function that introduces checks which can be avoided by using `unchecked {}` around the division by two.\n\n*There are 2 instances of this issue.*\n\n### [G&#x2011;28]  Use custom errors rather than `revert()`/`require()` strings to save gas\nCustom errors are available from solidity version 0.8.4. Custom errors save [**~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hit by [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas.\n\n*There are 15 instances of this issue.*\n\n\n\n***\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-11-paraspace",
  "Code": [
    {
      "filename": "paraspace-core/contracts/misc/NFTFloorOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"../dependencies/openzeppelin/contracts/AccessControl.sol\";\nimport \"../dependencies/openzeppelin/upgradeability/Initializable.sol\";\nimport \"./interfaces/INFTFloorOracle.sol\";\n\n//we need to deploy 3 oracles at least\nuint8 constant MIN_ORACLES_NUM = 3;\n//expirationPeriod at least the interval of client to feed data(currently 6h=21600s/12=1800 in mainnet)\n//we do not accept price lags behind to much\nuint128 constant EXPIRATION_PERIOD = 1800;\n//reject when price increase/decrease 1.5 times more than original value\nuint128 constant MAX_DEVIATION_RATE = 150;\n\nstruct OracleConfig {\n    // Expiration Period for each feed price\n    uint128 expirationPeriod;\n    // Maximum deviation allowed between two consecutive oracle prices\n    uint128 maxPriceDeviation;\n}\n\nstruct PriceInformation {\n    // last reported floor price(offchain twap)\n    uint256 twap;\n    // last updated blocknumber\n    uint256 updatedAt;\n    // last updated timestamp\n    uint256 updatedTimestamp;\n}\n\nstruct FeederRegistrar {\n    // if asset registered or not\n    bool registered;\n    // index in asset list\n    uint8 index;\n    // if asset paused,reject the price\n    bool paused;\n    // feeder -> PriceInformation\n    mapping(address => PriceInformation) feederPrice;\n}\n\nstruct FeederPosition {\n    // if feeder registered or not\n    bool registered;\n    // index in feeder list\n    uint8 index;\n}\n\n/// @title A simple on-chain price oracle mechanism\n/// @author github.com/drbh,github.com/yrong\n/// @notice Offchain clients can update the prices in this contract. The public can read prices\n/// aggeregate prices which are not expired from different feeders, if number of valid/unexpired prices\n/// not enough, we do not aggeregate and just use previous price\ncontract NFTFloorOracle is Initializable, AccessControl, INFTFloorOracle {\n    event AssetAdded(address indexed asset);\n    event AssetRemoved(address indexed asset);\n    event AssetPaused(address indexed asset, bool paused);\n\n    event FeederAdded(address indexed feeder);\n    event FeederRemoved(address indexed feeder);\n\n    event OracleConfigSet(uint128 expirationPeriod, uint128 maxPriceDeviation);\n    event AssetDataSet(\n        address indexed asset,\n        uint256 twap,\n        uint256 lastUpdatedBlock\n    );\n\n    bytes32 public constant UPDATER_ROLE = keccak256(\"UPDATER_ROLE\");\n\n    /// @dev Aggregated price with address\n    // the NFT contract -> latest price information\n    mapping(address => PriceInformation) public assetPriceMap;\n\n    /// @dev All feeders\n    address[] public feeders;\n\n    /// @dev feeder map\n    // feeder address -> index in feeder list\n    mapping(address => FeederPosition) private feederPositionMap;\n\n    /// @dev All asset list\n    address[] public assets;\n\n    /// @dev Original raw value to aggregate with\n    // the NFT contract address -> FeederRegistrar which contains price from each feeder\n    mapping(address => FeederRegistrar) public assetFeederMap;\n\n    /// @dev storage for oracle configurations\n    OracleConfig public config;\n\n    /// @notice Allow contract creator to set admin and updaters\n    /// @param _admin The admin who can change roles\n    /// @param _feeders The initial updaters\n    /// @param _assets The initial nft assets\n    function initialize(\n        address _admin,\n        address[] memory _feeders,\n        address[] memory _assets\n    ) public initializer {\n        _addAssets(_assets);\n        _addFeeders(_feeders);\n        _setupRole(DEFAULT_ADMIN_ROLE, _admin);\n        //still need to grant update_role to admin for emergency call\n        _setupRole(UPDATER_ROLE, _admin);\n        _setConfig(EXPIRATION_PERIOD, MAX_DEVIATION_RATE);\n    }\n\n    modifier whenNotPaused(address _asset) {\n        if (!hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n            _whenNotPaused(_asset);\n        }\n        _;\n    }\n\n    modifier onlyWhenAssetExisted(address _asset) {\n        require(_isAssetExisted(_asset), \"NFTOracle: asset not existed\");\n        _;\n    }\n\n    modifier onlyWhenAssetNotExisted(address _asset) {\n        require(!_isAssetExisted(_asset), \"NFTOracle: asset existed\");\n        _;\n    }\n\n    modifier onlyWhenFeederExisted(address _feeder) {\n        require(_isFeederExisted(_feeder), \"NFTOracle: feeder not existed\");\n        _;\n    }\n\n    modifier onlyWhenFeederNotExisted(address _feeder) {\n        require(!_isFeederExisted(_feeder), \"NFTOracle: feeder existed\");\n        _;\n    }\n\n    /// @notice Allows owner to add assets.\n    /// @param _assets assets to add\n    function addAssets(address[] calldata _assets)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        _addAssets(_assets);\n    }\n\n    /// @notice Allows owner to remove asset.\n    /// @param _asset asset to remove\n    function removeAsset(address _asset)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyWhenAssetExisted(_asset)\n    {\n        _removeAsset(_asset);\n    }\n\n    /// @notice Allows owner to add feeders.\n    /// @param _feeders feeders to add\n    function addFeeders(address[] calldata _feeders)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        _addFeeders(_feeders);\n    }\n\n    /// @notice Allows owner to remove feeder.\n    /// @param _feeder feeder to remove\n    function removeFeeder(address _feeder)\n        external\n        onlyWhenFeederExisted(_feeder)\n    {\n        _removeFeeder(_feeder);\n    }\n\n    /// @notice Allows owner to update oracle configs\n    function setConfig(uint128 expirationPeriod, uint128 maxPriceDeviation)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        _setConfig(expirationPeriod, maxPriceDeviation);\n    }\n\n    /// @notice Allows owner to pause asset\n    function setPause(address _asset, bool _flag)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        assetFeederMap[_asset].paused = _flag;\n        emit AssetPaused(_asset, _flag);\n    }\n\n    /// @notice Allows updater to set new price on PriceInformation and updates the\n    /// internal Median cumulativePrice.\n    /// @param _asset The nft contract to set a floor price for\n    /// @param _twap The last floor twap\n    function setPrice(address _asset, uint256 _twap)\n        public\n        onlyRole(UPDATER_ROLE)\n        onlyWhenAssetExisted(_asset)\n        whenNotPaused(_asset)\n    {\n        bool dataValidity = false;\n        if (hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n            _finalizePrice(_asset, _twap);\n            return;\n        }\n        dataValidity = _checkValidity(_asset, _twap);\n        require(dataValidity, \"NFTOracle: invalid price data\");\n        // add price to raw feeder storage\n        _addRawValue(_asset, _twap);\n        uint256 medianPrice;\n        // set twap price only when median value is valid\n        (dataValidity, medianPrice) = _combine(_asset, _twap);\n        if (dataValidity) {\n            _finalizePrice(_asset, medianPrice);\n        }\n    }\n\n    /// @notice Allows owner to set new price on PriceInformation and updates the\n    /// internal Median cumulativePrice.\n    /// @param _assets The nft contract to set a floor price for\n    function setMultiplePrices(\n        address[] calldata _assets,\n        uint256[] calldata _twaps\n    ) external onlyRole(UPDATER_ROLE) {\n        require(\n            _assets.length == _twaps.length,\n            \"NFTOracle: Tokens and price length differ\"\n        );\n        for (uint256 i = 0; i < _assets.length; i++) {\n            setPrice(_assets[i], _twaps[i]);\n        }\n    }\n\n    /// @param _asset The nft contract\n    /// @return price The most recent price on chain\n    function getPrice(address _asset)\n        external\n        view\n        override\n        returns (uint256 price)\n    {\n        uint256 updatedAt = assetPriceMap[_asset].updatedAt;\n        require(\n            (block.number - updatedAt) <= config.expirationPeriod,\n            \"NFTOracle: asset price expired\"\n        );\n        return assetPriceMap[_asset].twap;\n    }\n\n    /// @param _asset The nft contract\n    /// @return timestamp The timestamp of the last update for an asset\n    function getLastUpdateTime(address _asset)\n        external\n        view\n        override\n        returns (uint256 timestamp)\n    {\n        return assetPriceMap[_asset].updatedTimestamp;\n    }\n\n    function getFeederSize() public view returns (uint256) {\n        return feeders.length;\n    }\n\n    function _whenNotPaused(address _asset) internal view {\n        bool _paused = assetFeederMap[_asset].paused;\n        require(!_paused, \"NFTOracle: nft price feed paused\");\n    }\n\n    function _isAssetExisted(address _asset) internal view returns (bool) {\n        return assetFeederMap[_asset].registered;\n    }\n\n    function _isFeederExisted(address _feeder) internal view returns (bool) {\n        return feederPositionMap[_feeder].registered;\n    }\n\n    function _addAsset(address _asset)\n        internal\n        onlyWhenAssetNotExisted(_asset)\n    {\n        assetFeederMap[_asset].registered = true;\n        assets.push(_asset);\n        assetFeederMap[_asset].index = uint8(assets.length - 1);\n        emit AssetAdded(_asset);\n    }\n\n    /// @notice add nft assets.\n    /// @param _assets assets to add\n    function _addAssets(address[] memory _assets) internal {\n        for (uint256 i = 0; i < _assets.length; i++) {\n            _addAsset(_assets[i]);\n        }\n    }\n\n    function _removeAsset(address _asset)\n        internal\n        onlyWhenAssetExisted(_asset)\n    {\n        uint8 assetIndex = assetFeederMap[_asset].index;\n        delete assets[assetIndex];\n        delete assetPriceMap[_asset];\n        delete assetFeederMap[_asset];\n        emit AssetRemoved(_asset);\n    }\n\n    function _addFeeder(address _feeder)\n        internal\n        onlyWhenFeederNotExisted(_feeder)\n    {\n        feeders.push(_feeder);\n        feederPositionMap[_feeder].index = uint8(feeders.length - 1);\n        feederPositionMap[_feeder].registered = true;\n        _setupRole(UPDATER_ROLE, _feeder);\n        emit FeederAdded(_feeder);\n    }\n\n    /// @notice set feeders.\n    /// @param _feeders feeders to set\n    function _addFeeders(address[] memory _feeders) internal {\n        for (uint256 i = 0; i < _feeders.length; i++) {\n            _addFeeder(_feeders[i]);\n        }\n    }\n\n    function _removeFeeder(address _feeder)\n        internal\n        onlyWhenFeederExisted(_feeder)\n    {\n        uint8 feederIndex = feederPositionMap[_feeder].index;\n        if (feederIndex >= 0 && feeders[feederIndex] == _feeder) {\n            feeders[feederIndex] = feeders[feeders.length - 1];\n            feeders.pop();\n        }\n        delete feederPositionMap[_feeder];\n        revokeRole(UPDATER_ROLE, _feeder);\n        emit FeederRemoved(_feeder);\n    }\n\n    /// @notice set oracle configs\n    /// @param _expirationPeriod only prices not expired will be aggregated with\n    /// @param _maxPriceDeviation use to reject when price increase/decrease rate more than this value\n    function _setConfig(uint128 _expirationPeriod, uint128 _maxPriceDeviation)\n        internal\n    {\n        config.expirationPeriod = _expirationPeriod;\n        config.maxPriceDeviation = _maxPriceDeviation;\n        emit OracleConfigSet(_expirationPeriod, _maxPriceDeviation);\n    }\n\n    function _checkValidity(address _asset, uint256 _twap)\n        internal\n        view\n        returns (bool)\n    {\n        require(_twap > 0, \"NFTOracle: price should be more than 0\");\n        PriceInformation memory assetPriceMapEntry = assetPriceMap[_asset];\n        uint256 _priorTwap = assetPriceMapEntry.twap;\n        uint256 _updatedAt = assetPriceMapEntry.updatedAt;\n        uint256 priceDeviation;\n        //first price is always valid\n        if (_priorTwap == 0 || _updatedAt == 0) {\n            return true;\n        }\n        priceDeviation = _twap > _priorTwap\n            ? (_twap * 100) / _priorTwap\n            : (_priorTwap * 100) / _twap;\n\n        // config maxPriceDeviation as multiple directly(not percent) for simplicity\n        if (priceDeviation >= config.maxPriceDeviation) {\n            return false;\n        }\n        return true;\n    }\n\n    function _finalizePrice(address _asset, uint256 _twap) internal {\n        PriceInformation storage assetPriceMapEntry = assetPriceMap[_asset];\n        assetPriceMapEntry.twap = _twap;\n        assetPriceMapEntry.updatedAt = block.number;\n        assetPriceMapEntry.updatedTimestamp = block.timestamp;\n        emit AssetDataSet(\n            _asset,\n            assetPriceMapEntry.twap,\n            assetPriceMapEntry.updatedAt\n        );\n    }\n\n    function _addRawValue(address _asset, uint256 _twap) internal {\n        FeederRegistrar storage feederRegistrar = assetFeederMap[_asset];\n        PriceInformation storage priceInfo = feederRegistrar.feederPrice[\n            msg.sender\n        ];\n        priceInfo.twap = _twap;\n        priceInfo.updatedAt = block.number;\n    }\n\n    function _combine(address _asset, uint256 _twap)\n        internal\n        view\n        returns (bool, uint256)\n    {\n        FeederRegistrar storage feederRegistrar = assetFeederMap[_asset];\n        uint256 currentBlock = block.number;\n        //first time just use the feeding value\n        if (assetPriceMap[_asset].twap == 0) {\n            return (true, _twap);\n        }\n        //use memory here so allocate with maximum length\n        uint256 feederSize = feeders.length;\n        uint256[] memory validPriceList = new uint256[](feederSize);\n        uint256 validNum = 0;\n        //aggeregate with price from all feeders\n        for (uint256 i = 0; i < feederSize; i++) {\n            PriceInformation memory priceInfo = feederRegistrar.feederPrice[\n                feeders[i]\n            ];\n            if (priceInfo.updatedAt > 0) {\n                uint256 diffBlock = currentBlock - priceInfo.updatedAt;\n                if (diffBlock <= config.expirationPeriod) {\n                    validPriceList[validNum] = priceInfo.twap;\n                    validNum++;\n                }\n            }\n        }\n        if (validNum < MIN_ORACLES_NUM) {\n            return (false, assetPriceMap[_asset].twap);\n        }\n        _quickSort(validPriceList, 0, int256(validNum - 1));\n        return (true, validPriceList[validNum / 2]);\n    }\n\n    function _quickSort(\n        uint256[] memory arr,\n        int256 left,\n        int256 right\n    ) internal pure {\n        int256 i = left;\n        int256 j = right;\n        if (i == j) return;\n        uint256 pivot = arr[uint256(left + (right - left) / 2)];\n        while (i <= j) {\n            while (arr[uint256(i)] < pivot) i++;\n            while (pivot < arr[uint256(j)]) j--;\n            if (i <= j) {\n                (arr[uint256(i)], arr[uint256(j)]) = (\n                    arr[uint256(j)],\n                    arr[uint256(i)]\n                );\n                i++;\n                j--;\n            }\n        }\n        if (left < j) _quickSort(arr, left, j);\n        if (i < right) _quickSort(arr, i, right);\n    }\n}"
    },
    {
      "filename": "contracts/security/ReentrancyGuard.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}"
    },
    {
      "filename": "paraspace-core/contracts/protocol/tokenization/base/MintableIncentivizedERC721.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {Context} from \"../../../dependencies/openzeppelin/contracts/Context.sol\";\nimport {Strings} from \"../../../dependencies/openzeppelin/contracts/Strings.sol\";\nimport {Address} from \"../../../dependencies/openzeppelin/contracts/Address.sol\";\nimport {IERC165} from \"../../../dependencies/openzeppelin/contracts/IERC165.sol\";\nimport {IERC721Metadata} from \"../../../dependencies/openzeppelin/contracts/IERC721Metadata.sol\";\nimport {IERC721Receiver} from \"../../../dependencies/openzeppelin/contracts/IERC721Receiver.sol\";\nimport {IERC721Enumerable} from \"../../../dependencies/openzeppelin/contracts/IERC721Enumerable.sol\";\nimport {ICollateralizableERC721} from \"../../../interfaces/ICollateralizableERC721.sol\";\nimport {IAuctionableERC721} from \"../../../interfaces/IAuctionableERC721.sol\";\nimport {SafeCast} from \"../../../dependencies/openzeppelin/contracts/SafeCast.sol\";\nimport {WadRayMath} from \"../../libraries/math/WadRayMath.sol\";\nimport {Errors} from \"../../libraries/helpers/Errors.sol\";\nimport {IRewardController} from \"../../../interfaces/IRewardController.sol\";\nimport {IPoolAddressesProvider} from \"../../../interfaces/IPoolAddressesProvider.sol\";\nimport {IPool} from \"../../../interfaces/IPool.sol\";\nimport {IACLManager} from \"../../../interfaces/IACLManager.sol\";\nimport {DataTypes} from \"../../libraries/types/DataTypes.sol\";\nimport {ReentrancyGuard} from \"../../../dependencies/openzeppelin/contracts/ReentrancyGuard.sol\";\nimport {MintableERC721Logic, UserState, MintableERC721Data} from \"../libraries/MintableERC721Logic.sol\";\n\n/**\n * @title MintableIncentivizedERC721\n * , inspired by the Openzeppelin ERC721 implementation\n * @notice Basic ERC721 implementation\n **/\nabstract contract MintableIncentivizedERC721 is\n    ReentrancyGuard,\n    ICollateralizableERC721,\n    IAuctionableERC721,\n    Context,\n    IERC721Metadata,\n    IERC721Enumerable,\n    IERC165\n{\n    using Address for address;\n\n    MintableERC721Data internal _ERC721Data;\n\n    /**\n     * @dev Only pool admin can call functions marked by this modifier.\n     **/\n    modifier onlyPoolAdmin() {\n        IACLManager aclManager = IACLManager(\n            _addressesProvider.getACLManager()\n        );\n        require(\n            aclManager.isPoolAdmin(msg.sender),\n            Errors.CALLER_NOT_POOL_ADMIN\n        );\n        _;\n    }\n\n    /**\n     * @dev Only pool can call functions marked by this modifier.\n     **/\n    modifier onlyPool() {\n        require(_msgSender() == address(POOL), Errors.CALLER_MUST_BE_POOL);\n        _;\n    }\n\n    /**\n     * @dev UserState - additionalData is a flexible field.\n     * PTokens and VariableDebtTokens use this field store the index of the\n     * user's last supply/withdrawal/borrow/repayment. StableDebtTokens use\n     * this field to store the user's stable rate.\n     */\n\n    IPoolAddressesProvider internal immutable _addressesProvider;\n    IPool public immutable POOL;\n    bool public immutable ATOMIC_PRICING;\n\n    address internal _underlyingAsset;\n\n    /**\n     * @dev Constructor.\n     * @param pool The reference to the main Pool contract\n     * @param name_ The name of the token\n     * @param symbol_ The symbol of the token\n     */\n    constructor(\n        IPool pool,\n        string memory name_,\n        string memory symbol_,\n        bool atomic_pricing\n    ) {\n        _addressesProvider = pool.ADDRESSES_PROVIDER();\n        _ERC721Data.name = name_;\n        _ERC721Data.symbol = symbol_;\n        POOL = pool;\n        ATOMIC_PRICING = atomic_pricing;\n    }\n\n    function name() public view override returns (string memory) {\n        return _ERC721Data.name;\n    }\n\n    function symbol() external view override returns (string memory) {\n        return _ERC721Data.symbol;\n    }\n\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _ERC721Data.userState[account].balance;\n    }\n\n    /**\n     * @notice Returns the address of the Incentives Controller contract\n     * @return The address of the Incentives Controller\n     **/\n    function getIncentivesController()\n        external\n        view\n        virtual\n        returns (IRewardController)\n    {\n        return _ERC721Data.rewardController;\n    }\n\n    /**\n     * @notice Sets a new Incentives Controller\n     * @param controller the new Incentives controller\n     **/\n    function setIncentivesController(IRewardController controller)\n        external\n        onlyPoolAdmin\n    {\n        _ERC721Data.rewardController = controller;\n    }\n\n    /**\n     * @notice Sets new Balance Limit\n     * @param limit the new Balance Limit\n     **/\n    function setBalanceLimit(uint64 limit) external onlyPoolAdmin {\n        _ERC721Data.balanceLimit = limit;\n    }\n\n    /**\n     * @notice Update the name of the token\n     * @param newName The new name for the token\n     */\n    function _setName(string memory newName) internal {\n        _ERC721Data.name = newName;\n    }\n\n    /**\n     * @notice Update the symbol for the token\n     * @param newSymbol The new symbol for the token\n     */\n    function _setSymbol(string memory newSymbol) internal {\n        _ERC721Data.symbol = newSymbol;\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (address)\n    {\n        return _ERC721Data.owners[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256)\n        external\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) external virtual override {\n        address owner = ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to old owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        MintableERC721Logic.executeApprove(_ERC721Data, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (address)\n    {\n        require(\n            _exists(tokenId),\n            \"ERC721: approved query for nonexistent token\"\n        );\n\n        return _ERC721Data.tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved)\n        external\n        virtual\n        override\n    {\n        MintableERC721Logic.executeApprovalForAll(\n            _ERC721Data,\n            _msgSender(),\n            operator,\n            approved\n        );\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return _ERC721Data.operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external virtual override nonReentrant {\n        //solhint-disable-next-line max-line-length\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenId),\n            \"ERC721: transfer caller is not owner nor approved\"\n        );\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external virtual override nonReentrant {\n        _safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) external virtual override nonReentrant {\n        _safeTransferFrom(from, to, tokenId, _data);\n    }\n\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal {\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenId),\n            \"ERC721: transfer caller is not owner nor approved\"\n        );\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ERC721Data.owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        require(\n            _exists(tokenId),\n            \"ERC721: operator query for nonexistent token\"\n        );\n        address owner = ownerOf(tokenId);\n        return (spender == owner ||\n            isApprovedForAll(owner, spender) ||\n            getApproved(tokenId) == spender);\n    }\n\n    function _mintMultiple(\n        address to,\n        DataTypes.ERC721SupplyParams[] calldata tokenData\n    )\n        internal\n        virtual\n        returns (\n            uint64 oldCollateralizedBalance,\n            uint64 newCollateralizedBalance\n        )\n    {\n        return\n            MintableERC721Logic.executeMintMultiple(\n                _ERC721Data,\n                ATOMIC_PRICING,\n                to,\n                tokenData\n            );\n    }\n\n    function _burnMultiple(address user, uint256[] calldata tokenIds)\n        internal\n        virtual\n        returns (\n            uint64 oldCollateralizedBalance,\n            uint64 newCollateralizedBalance\n        )\n    {\n        return\n            MintableERC721Logic.executeBurnMultiple(\n                _ERC721Data,\n                POOL,\n                user,\n                tokenIds\n            );\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        MintableERC721Logic.executeTransfer(\n            _ERC721Data,\n            POOL,\n            ATOMIC_PRICING,\n            from,\n            to,\n            tokenId\n        );\n    }\n\n    /**\n     * @dev update collateral information on transfer\n     */\n    function _transferCollateralizable(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual returns (bool isUsedAsCollateral_) {\n        isUsedAsCollateral_ = MintableERC721Logic\n            .executeTransferCollateralizable(\n                _ERC721Data,\n                POOL,\n                ATOMIC_PRICING,\n                from,\n                to,\n                tokenId\n            );\n    }\n\n    /// @inheritdoc ICollateralizableERC721\n    function collateralizedBalanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _ERC721Data.userState[account].collateralizedBalance;\n    }\n\n    /// @inheritdoc ICollateralizableERC721\n    function setIsUsedAsCollateral(\n        uint256 tokenId,\n        bool useAsCollateral,\n        address sender\n    ) external virtual override onlyPool nonReentrant returns (bool) {\n        return\n            MintableERC721Logic.executeSetIsUsedAsCollateral(\n                _ERC721Data,\n                POOL,\n                tokenId,\n                useAsCollateral,\n                sender\n            );\n    }\n\n    /// @inheritdoc ICollateralizableERC721\n    function batchSetIsUsedAsCollateral(\n        uint256[] calldata tokenIds,\n        bool useAsCollateral,\n        address sender\n    )\n        external\n        virtual\n        override\n        onlyPool\n        nonReentrant\n        returns (\n            uint256 oldCollateralizedBalance,\n            uint256 newCollateralizedBalance\n        )\n    {\n        oldCollateralizedBalance = _ERC721Data\n            .userState[sender]\n            .collateralizedBalance;\n\n        for (uint256 index = 0; index < tokenIds.length; index++) {\n            MintableERC721Logic.executeSetIsUsedAsCollateral(\n                _ERC721Data,\n                POOL,\n                tokenIds[index],\n                useAsCollateral,\n                sender\n            );\n        }\n\n        newCollateralizedBalance = _ERC721Data\n            .userState[sender]\n            .collateralizedBalance;\n    }\n\n    /// @inheritdoc ICollateralizableERC721\n    function isUsedAsCollateral(uint256 tokenId)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _ERC721Data.isUsedAsCollateral[tokenId];\n    }\n\n    /// @inheritdoc IAuctionableERC721\n    function isAuctioned(uint256 tokenId)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return MintableERC721Logic.isAuctioned(_ERC721Data, POOL, tokenId);\n    }\n\n    /// @inheritdoc IAuctionableERC721\n    function startAuction(uint256 tokenId)\n        external\n        virtual\n        override\n        onlyPool\n        nonReentrant\n    {\n        MintableERC721Logic.executeStartAuction(_ERC721Data, POOL, tokenId);\n    }\n\n    /// @inheritdoc IAuctionableERC721\n    function endAuction(uint256 tokenId)\n        external\n        virtual"
    }
  ]
}