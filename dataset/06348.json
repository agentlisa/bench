{
  "Title": "[G-05] `uint256` variable initialization to default value of `0` can be omitted",
  "Content": "\nThere is no need to initialize variables to their default values during declaration, since they are any way initialized to default value once declared.\n\nhttps://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/transmuter/facets/Redeemer.sol#L199\n\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-01-dev-test-repo",
  "Code": [
    {
      "filename": "contracts/transmuter/facets/Redeemer.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.19;\n\nimport { IERC20 } from \"oz/token/ERC20/IERC20.sol\";\nimport { SafeCast } from \"oz/utils/math/SafeCast.sol\";\nimport { SafeERC20 } from \"oz/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"oz/utils/math/Math.sol\";\n\nimport { IAgToken } from \"interfaces/IAgToken.sol\";\nimport { IRedeemer } from \"interfaces/IRedeemer.sol\";\n\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\nimport { LibHelpers } from \"../libraries/LibHelpers.sol\";\nimport { LibGetters } from \"../libraries/LibGetters.sol\";\nimport { LibManager } from \"../libraries/LibManager.sol\";\nimport { LibStorage as s } from \"../libraries/LibStorage.sol\";\nimport { LibWhitelist } from \"../libraries/LibWhitelist.sol\";\n\nimport \"../../utils/Constants.sol\";\nimport \"../../utils/Errors.sol\";\nimport \"../Storage.sol\";\n\n/// @title Redeemer\n/// @author Angle Labs, Inc.\ncontract Redeemer is IRedeemer {\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n    using SafeCast for uint256;\n\n    event Redeemed(\n        uint256 amount,\n        address[] tokens,\n        uint256[] amounts,\n        address[] forfeitTokens,\n        address indexed from,\n        address indexed to\n    );\n    event NormalizerUpdated(uint256 newNormalizerValue);\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                   EXTERNAL ACTIONS                                                 \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRedeemer\n    /// @dev The `minAmountOuts` list must reflect or be longer than the amount of `tokens` returned\n    /// @dev In normal conditions, the amount of tokens outputted by this function should be the amount\n    /// of collateral assets supported by the system, following their order in the `collateralList`.\n    /// @dev If one collateral has its liquidity managed through strategies, then it's possible that this asset\n    /// has sub-collaterals with it. In this situation, these sub-collaterals may be sent during the redemption\n    /// process and the `minAmountOuts` will be bigger than the `collateralList` length. If there are 3 collateral\n    /// assets and the 2nd collateral asset in the list (at index 1) consists of 3 sub-collaterals, then the ordering\n    /// of the token list will be as follows:\n    /// `[collat 1, sub-collat 1 of collat 2, sub-collat 2 of collat 2, sub-collat 3 of collat 2, collat 3]`\n    /// @dev The list of tokens outputted (and hence the minimum length of the `minAmountOuts` list) can be obtained\n    /// by calling the `quoteRedemptionCurve` function\n    /// @dev Tokens requiring a whitelist must be forfeited if the redemption is to an address that is not in the\n    /// whitelist, otherwise this function reverts\n    /// @dev No approval is needed before calling this function\n    function redeem(\n        uint256 amount,\n        address receiver,\n        uint256 deadline,\n        uint256[] memory minAmountOuts\n    ) external returns (address[] memory tokens, uint256[] memory amounts) {\n        return _redeem(amount, receiver, deadline, minAmountOuts, new address[](0));\n    }\n\n    /// @inheritdoc IRedeemer\n    /// @dev Beware that if a token is given in the `forfeitTokens` list, the redemption will not try to send token\n    /// even if it has enough immediately available to send the amount\n    function redeemWithForfeit(\n        uint256 amount,\n        address receiver,\n        uint256 deadline,\n        uint256[] memory minAmountOuts,\n        address[] memory forfeitTokens\n    ) external returns (address[] memory tokens, uint256[] memory amounts) {\n        return _redeem(amount, receiver, deadline, minAmountOuts, forfeitTokens);\n    }\n\n    /// @inheritdoc IRedeemer\n    /// @dev This function may be called by trusted addresses: these could be for instance savings contract\n    /// minting stablecoins when they notice a profit\n    function updateNormalizer(uint256 amount, bool increase) external returns (uint256) {\n        if (!LibDiamond.isGovernor(msg.sender) && s.transmuterStorage().isTrusted[msg.sender] == 0) revert NotTrusted();\n        return _updateNormalizer(amount, increase);\n    }\n\n    /// @inheritdoc IRedeemer\n    function quoteRedemptionCurve(\n        uint256 amount\n    ) external view returns (address[] memory tokens, uint256[] memory amounts) {\n        (tokens, amounts, ) = _quoteRedemptionCurve(amount);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                   INTERNAL HELPERS                                                 \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Internal function of the `redeem` function in the `Redeemer` contract\n    function _redeem(\n        uint256 amount,\n        address to,\n        uint256 deadline,\n        uint256[] memory minAmountOuts,\n        address[] memory forfeitTokens\n    ) internal returns (address[] memory tokens, uint256[] memory amounts) {\n        TransmuterStorage storage ts = s.transmuterStorage();\n        if (ts.isRedemptionLive == 0) revert Paused();\n        if (block.timestamp > deadline) revert TooLate();\n        uint256[] memory subCollateralsTracker;\n        (tokens, amounts, subCollateralsTracker) = _quoteRedemptionCurve(amount);\n        // Updating the normalizer enables to simultaneously and proportionally reduce the amount\n        // of stablecoins issued from each collateral without having to loop through each of them\n        _updateNormalizer(amount, false);\n\n        IAgToken(ts.agToken).burnSelf(amount, msg.sender);\n\n        address[] memory collateralListMem = ts.collateralList;\n        uint256 indexCollateral;\n        for (uint256 i; i < amounts.length; ++i) {\n            if (amounts[i] < minAmountOuts[i]) revert TooSmallAmountOut();\n            // If a token is in the `forfeitTokens` list, then it is not sent as part of the redemption process\n            if (amounts[i] > 0 && LibHelpers.checkList(tokens[i], forfeitTokens) < 0) {\n                Collateral storage collatInfo = ts.collaterals[collateralListMem[indexCollateral]];\n                if (collatInfo.onlyWhitelisted > 0 && !LibWhitelist.checkWhitelist(collatInfo.whitelistData, to))\n                    revert NotWhitelisted();\n                if (collatInfo.isManaged > 0)\n                    LibManager.release(tokens[i], to, amounts[i], collatInfo.managerData.config);\n                else IERC20(tokens[i]).safeTransfer(to, amounts[i]);\n            }\n            if (subCollateralsTracker[indexCollateral] - 1 <= i) ++indexCollateral;\n        }\n        emit Redeemed(amount, tokens, amounts, forfeitTokens, msg.sender, to);\n    }\n\n    /// @dev This function reverts if `stablecoinsIssued==0`, which is expected behavior as there is nothing to redeem\n    /// anyway in this case, or if the `amountBurnt` is greater than `stablecoinsIssued`\n    function _quoteRedemptionCurve(\n        uint256 amountBurnt\n    )\n        internal\n        view\n        returns (address[] memory tokens, uint256[] memory balances, uint256[] memory subCollateralsTracker)\n    {\n        TransmuterStorage storage ts = s.transmuterStorage();\n        uint64 collatRatio;\n        uint256 stablecoinsIssued;\n        (collatRatio, stablecoinsIssued, tokens, balances, subCollateralsTracker) = LibGetters.getCollateralRatio();\n        if (amountBurnt > stablecoinsIssued) revert TooBigAmountIn();\n        int64[] memory yRedemptionCurveMem = ts.yRedemptionCurve;\n        uint64 penaltyFactor;\n        // If the protocol is under-collateralized, a penalty factor is applied to the returned amount of each asset\n        if (collatRatio < BASE_9) {\n            uint64[] memory xRedemptionCurveMem = ts.xRedemptionCurve;\n            penaltyFactor = uint64(LibHelpers.piecewiseLinear(collatRatio, xRedemptionCurveMem, yRedemptionCurveMem));\n        }\n\n        uint256 balancesLength = balances.length;\n        for (uint256 i; i < balancesLength; ++i) {\n            // The amount given for each token in reserves does not depend on the price of the tokens in reserve:\n            // it is a proportion of the balance for each token computed as the ratio between the stablecoins\n            // burnt relative to the amount of stablecoins issued.\n            // If the protocol is over-collateralized, the amount of each token given is inversely proportional\n            // to the collateral ratio.\n            balances[i] = collatRatio >= BASE_9\n                ? (amountBurnt * balances[i] * (uint64(yRedemptionCurveMem[yRedemptionCurveMem.length - 1]))) /\n                    (stablecoinsIssued * collatRatio)\n                : (amountBurnt * balances[i] * penaltyFactor) / (stablecoinsIssued * BASE_9);\n        }\n    }\n\n    /// @notice Updates the `normalizer` variable used to track stablecoins issued from each asset and globally\n    function _updateNormalizer(uint256 amount, bool increase) internal returns (uint256 newNormalizerValue) {\n        TransmuterStorage storage ts = s.transmuterStorage();\n        uint256 _normalizer = ts.normalizer;\n        uint256 _normalizedStables = ts.normalizedStables;\n        // In case of an increase, the update formula used is the simplified version of the formula below:\n        /*\n            _normalizer * (BASE_27 + BASE_27 * amount / stablecoinsIssued) / BASE_27\n             = _normalizer + (_normalizer * BASE_27 * amount * (BASE_27 / (_normalizedStables * normalizer))) / BASE_27\n             = _normalizer + BASE_27 * amount / _normalizedStables\n        */\n        if (increase) {\n            newNormalizerValue = _normalizer + (amount * BASE_27) / _normalizedStables;\n        } else {\n            newNormalizerValue = _normalizer - (amount * BASE_27) / _normalizedStables;\n        }\n        // If the `normalizer` gets too small or too big, it must be renormalized to later avoid the propagation of\n        // rounding errors, as well as overflows. In this case, the function has to iterate through all the\n        // supported collateral assets\n        if (newNormalizerValue <= BASE_18 || newNormalizerValue >= BASE_36) {\n            address[] memory collateralListMem = ts.collateralList;\n            uint256 collateralListLength = collateralListMem.length;\n            // For each asset, we store the actual amount of stablecoins issued based on the `newNormalizerValue`\n            // (and not a normalized value)\n            // We ensure to preserve the invariant `sum(collateralNewNormalizedStables) = normalizedStables`\n            uint128 newNormalizedStables = 0;\n            for (uint256 i; i < collateralListLength; ++i) {\n                uint128 newCollateralNormalizedStable = ((uint256(\n                    ts.collaterals[collateralListMem[i]].normalizedStables\n                ) * newNormalizerValue) / BASE_27).toUint128();\n                newNormalizedStables += newCollateralNormalizedStable;\n                ts.collaterals[collateralListMem[i]].normalizedStables = uint216(newCollateralNormalizedStable);\n            }\n            ts.normalizedStables = newNormalizedStables;\n            newNormalizerValue = BASE_27;\n        }\n        ts.normalizer = newNormalizerValue.toUint128();\n        emit NormalizerUpdated(newNormalizerValue);\n    }\n}"
    }
  ]
}