{
  "Title": "[L10] Lack of validation consistency",
  "Content": "The functions [`addRegisteredContract`](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/common/TransferWhitelist.sol#L38-L45) and [`setRegisteredContracts`](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/common/TransferWhitelist.sol#L67-L69) of the [`TransferWhitelist` contract](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/common/TransferWhitelist.sol) are in charge of assigning the values of `registeredContracts`.\n\n\nWhile the `addRegisteredContract` function [validates that the parameter being added to `registeredContracts` is not `address(0)`](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/common/TransferWhitelist.sol#L39-L42), the `setRegisteredContracts` function does not perform any validation.\n\n\nConsider validating that none of the elements passed into `setRegisteredContracts` are `address(0)`.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/common/TransferWhitelist.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"./UsingRegistry.sol\";\n\n/**\n * @title Holds a whitelist of addresses for which transfers should not be\n * frozen so that network initialization can take place.\n */\ncontract TransferWhitelist is Ownable, UsingRegistry {\n  using SafeMath for uint256;\n\n  address[] public whitelist;\n  bytes32[] public registeredContracts;\n\n  event WhitelistedAddress(address addr);\n  event WhitelistedRegistryId(bytes32 registryId);\n\n  constructor(address registryAddress) public {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n  }\n\n  /**\n   * @notice Add an address to the whitelist.\n   * @param newAddress The address to add.\n   */\n  function addAddress(address newAddress) external onlyOwner {\n    whitelist.push(newAddress);\n    emit WhitelistedAddress(newAddress);\n  }\n\n  /**\n   * @notice Adds the registry id of a whitelisted contract.\n   * @param registryId The id of the contract to be added.\n   */\n  function addRegisteredContract(bytes32 registryId) external onlyOwner {\n    require(\n      registry.getAddressFor(registryId) != address(0),\n      \"registryId does not corespond to a registered address\"\n    );\n    registeredContracts.push(registryId);\n    emit WhitelistedRegistryId(registryId);\n  }\n\n  /**\n   * @notice Gets the number of registered contracts\n   * @return The length of registeredContracts\n   */\n  function getRegisteredContractsLength() external view returns (uint256 length) {\n    return registeredContracts.length;\n  }\n\n  /**\n   * @notice Set the whitelist of addresses.\n   * @param  _whitelist The new whitelist of addresses.\n   */\n  function setWhitelist(address[] calldata _whitelist) external onlyOwner {\n    whitelist = _whitelist;\n  }\n\n  /**\n   * @notice Set the whitelist of registered contracts.\n   * @param  _registeredContracts The new whitelist of registered contract ids.\n   */\n  function setRegisteredContracts(bytes32[] calldata _registeredContracts) external onlyOwner {\n    registeredContracts = _registeredContracts;\n  }\n\n  /**\n   * @notice Appends the addresses of registered contracts to the\n   * whitelist before returning the list.\n   * @dev If a registry id is not yet registered, the null address\n   * will be appended to the list instead.\n   * @return  The full whitelist of addresses.\n   */\n  function getWhitelist() external view returns (address[] memory) {\n    uint256 len = whitelist.length.add(registeredContracts.length);\n    address[] memory _whitelist = new address[](len);\n    uint256 i = 0;\n    while (i < whitelist.length) {\n      _whitelist[i] = whitelist[i];\n      i = i.add(1);\n    }\n    for (uint256 j = 0; j < registeredContracts.length; j = j.add(1)) {\n      _whitelist[i] = registry.getAddressFor(registeredContracts[j]);\n      i = i.add(1);\n    }\n    return _whitelist;\n  }\n\n  /**\n   * @notice Clears all data (storage and bytecode) at this contract's address.\n   * @dev The balance of this contract is returned to the owner.\n   */\n  function selfDestruct() external onlyOwner {\n    selfdestruct(msg.sender);\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/common/TransferWhitelist.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"./UsingRegistry.sol\";\n\n/**\n * @title Holds a whitelist of addresses for which transfers should not be\n * frozen so that network initialization can take place.\n */\ncontract TransferWhitelist is Ownable, UsingRegistry {\n  using SafeMath for uint256;\n\n  address[] public whitelist;\n  bytes32[] public registeredContracts;\n\n  event WhitelistedAddress(address addr);\n  event WhitelistedRegistryId(bytes32 registryId);\n\n  constructor(address registryAddress) public {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n  }\n\n  /**\n   * @notice Add an address to the whitelist.\n   * @param newAddress The address to add.\n   */\n  function addAddress(address newAddress) external onlyOwner {\n    whitelist.push(newAddress);\n    emit WhitelistedAddress(newAddress);\n  }\n\n  /**\n   * @notice Adds the registry id of a whitelisted contract.\n   * @param registryId The id of the contract to be added.\n   */\n  function addRegisteredContract(bytes32 registryId) external onlyOwner {\n    require(\n      registry.getAddressFor(registryId) != address(0),\n      \"registryId does not corespond to a registered address\"\n    );\n    registeredContracts.push(registryId);\n    emit WhitelistedRegistryId(registryId);\n  }\n\n  /**\n   * @notice Gets the number of registered contracts\n   * @return The length of registeredContracts\n   */\n  function getRegisteredContractsLength() external view returns (uint256 length) {\n    return registeredContracts.length;\n  }\n\n  /**\n   * @notice Set the whitelist of addresses.\n   * @param  _whitelist The new whitelist of addresses.\n   */\n  function setWhitelist(address[] calldata _whitelist) external onlyOwner {\n    whitelist = _whitelist;\n  }\n\n  /**\n   * @notice Set the whitelist of registered contracts.\n   * @param  _registeredContracts The new whitelist of registered contract ids.\n   */\n  function setRegisteredContracts(bytes32[] calldata _registeredContracts) external onlyOwner {\n    registeredContracts = _registeredContracts;\n  }\n\n  /**\n   * @notice Appends the addresses of registered contracts to the\n   * whitelist before returning the list.\n   * @dev If a registry id is not yet registered, the null address\n   * will be appended to the list instead.\n   * @return  The full whitelist of addresses.\n   */\n  function getWhitelist() external view returns (address[] memory) {\n    uint256 len = whitelist.length.add(registeredContracts.length);\n    address[] memory _whitelist = new address[](len);\n    uint256 i = 0;\n    while (i < whitelist.length) {\n      _whitelist[i] = whitelist[i];\n      i = i.add(1);\n    }\n    for (uint256 j = 0; j < registeredContracts.length; j = j.add(1)) {\n      _whitelist[i] = registry.getAddressFor(registeredContracts[j]);\n      i = i.add(1);\n    }\n    return _whitelist;\n  }\n\n  /**\n   * @notice Clears all data (storage and bytecode) at this contract's address.\n   * @dev The balance of this contract is returned to the owner.\n   */\n  function selfDestruct() external onlyOwner {\n    selfdestruct(msg.sender);\n  }\n}"
    }
  ]
}