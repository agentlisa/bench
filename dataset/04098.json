{
  "Title": "`maxCap` can go under `totalSupply`",
  "Content": "##### Description\nIf the supply is bigger than new `maxCap`: https://github.com/pie-dao/ExperiPie/blob/0.0.2/contracts/facets/Basket/BasketFacet.sol#L242\n\n##### Recommendation\nWe recommend to add `require(totalSupply <= _maxCap, '...')`.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/facets/Basket/BasketFacet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../../interfaces/IBasketFacet.sol\";\nimport \"../ERC20/LibERC20Storage.sol\";\nimport \"../ERC20/LibERC20.sol\";\nimport \"../shared/Reentry/ReentryProtection.sol\";\nimport \"../shared/Access/CallProtection.sol\";\nimport \"./LibBasketStorage.sol\";\n\ncontract BasketFacet is ReentryProtection, CallProtection, IBasketFacet {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public constant MIN_AMOUNT = 10**6;\n    uint256 public constant MAX_ENTRY_FEE = 10**17; // 10%\n    uint256 public constant MAX_EXIT_FEE = 10**17; // 10%\n    uint256 public constant MAX_ANNUAL_FEE = 10**17; // 10%\n\n    \n\n    function addToken(address _token) external override protectedCall {\n        LibBasketStorage.BasketStorage storage bs = LibBasketStorage.basketStorage();\n        require(!bs.inPool[_token], \"TOKEN_ALREADY_IN_POOL\");\n        // Enforce minimum to avoid rounding errors; (Minimum value is the same as in Balancer)\n        require(balance(_token) >= MIN_AMOUNT, \"BALANCE_TOO_SMALL\");\n\n        bs.inPool[_token] = true;\n        bs.tokens.push(IERC20(_token));\n\n        emit TokenAdded(_token);\n    }\n\n    function removeToken(address _token) external override protectedCall {\n        LibBasketStorage.BasketStorage storage bs = LibBasketStorage.basketStorage();\n\n        require(bs.inPool[_token], \"TOKEN_NOT_IN_POOL\");\n\n        bs.inPool[_token] = false;\n\n        // remove token from array\n        // TODO consider limiting max amount of tokens to mitigate running out of gas.\n        for(uint256 i; i < bs.tokens.length; i ++) {\n            if(address(bs.tokens[i]) == _token) {\n                bs.tokens[i] = bs.tokens[bs.tokens.length - 1];\n                bs.tokens.pop();\n\n                break;\n            }\n        }\n\n        emit TokenRemoved(_token);\n    }\n\n    function setEntryFee(uint256 _fee) external override protectedCall {\n        require(_fee <= MAX_ENTRY_FEE, \"FEE_TOO_BIG\");\n        LibBasketStorage.basketStorage().entryFee = _fee;\n        emit EntryFeeSet(_fee);\n    }\n\n    function getEntryFee() external view override returns(uint256) {\n        return LibBasketStorage.basketStorage().entryFee;\n    }\n\n    function setExitFee(uint256 _fee) external override protectedCall {\n        require(_fee <= MAX_EXIT_FEE, \"FEE_TOO_BIG\");\n        LibBasketStorage.basketStorage().exitFee = _fee;\n        emit ExitFeeSet(_fee);\n    }\n\n    function getExitFee() external view override returns(uint256) {\n        return LibBasketStorage.basketStorage().exitFee;\n    }\n\n    function setAnnualizedFee(uint256 _fee) external override protectedCall {\n        require(_fee <= MAX_ANNUAL_FEE, \"FEE_TOO_BIG\");\n        LibBasketStorage.basketStorage().annualizedFee = _fee;\n        emit AnnualizedFeeSet(_fee);\n    }\n\n    function getAnnualizedFee() external view override returns(uint256) {\n        return LibBasketStorage.basketStorage().annualizedFee;\n    }\n\n    function setFeeBeneficiary(address _beneficiary) external override protectedCall {\n        LibBasketStorage.basketStorage().feeBeneficiary = _beneficiary;\n        emit FeeBeneficiarySet(_beneficiary);\n    }\n\n    function getFeeBeneficiary() external view override returns(address) {\n        return LibBasketStorage.basketStorage().feeBeneficiary;\n    }\n\n    function setEntryFeeBeneficiaryShare(uint256 _share) external override protectedCall {\n        require(_share <= 10**18, \"FEE_SHARE_TOO_BIG\");\n        LibBasketStorage.basketStorage().entryFeeBeneficiaryShare = _share;\n        emit EntryFeeBeneficiaryShareSet(_share);\n    }\n\n    function getEntryFeeBeneficiaryShare() external view override returns(uint256) {\n        return LibBasketStorage.basketStorage().entryFeeBeneficiaryShare;\n    }\n\n    function setExitFeeBeneficiaryShare(uint256 _share) external override protectedCall {\n        require(_share <= 10**18, \"FEE_SHARE_TOO_BIG\");\n        LibBasketStorage.basketStorage().exitFeeBeneficiaryShare = _share;\n        emit ExitFeeBeneficiaryShareSet(_share);\n    }\n\n    function getExitFeeBeneficiaryShare() external view override returns(uint256) {\n        return LibBasketStorage.basketStorage().exitFeeBeneficiaryShare;\n    }\n\n\n    function joinPool(uint256 _amount) external override noReentry {\n        require(!this.getLock(), \"POOL_LOCKED\");\n        chargeOutstandingAnnualizedFee();\n        LibBasketStorage.BasketStorage storage bs = LibBasketStorage.basketStorage();\n        uint256 totalSupply = LibERC20Storage.erc20Storage().totalSupply;\n        require(totalSupply.add(_amount) < this.getCap(), \"MAX_POOL_CAP_REACHED\");\n\n        uint256 feeAmount = _amount.mul(bs.entryFee).div(10**18);\n\n        for(uint256 i; i < bs.tokens.length; i ++) {\n            IERC20 token = bs.tokens[i];\n            uint256 tokenAmount = balance(address(token)).mul(_amount.add(feeAmount)).div(totalSupply);\n            require(tokenAmount != 0, \"AMOUNT_TOO_SMALL\");\n            token.safeTransferFrom(msg.sender, address(this), tokenAmount);\n        }\n\n        // If there is any fee that should go to the beneficiary mint it\n        if(\n            feeAmount != 0 &&\n            bs.entryFeeBeneficiaryShare != 0 &&\n            bs.feeBeneficiary != address(0)\n        ) {\n            uint256 feeBeneficiaryShare = feeAmount.mul(bs.entryFeeBeneficiaryShare).div(10**18);\n            if(feeBeneficiaryShare != 0) {\n                LibERC20.mint(bs.feeBeneficiary, feeBeneficiaryShare);\n            }\n        }\n\n        LibERC20.mint(msg.sender, _amount);\n        emit PoolJoined(msg.sender, _amount);\n    }\n\n    // Must be overwritten to withdraw from strategies\n    function exitPool(uint256 _amount) external override virtual noReentry {\n        require(!this.getLock(), \"POOL_LOCKED\");\n        chargeOutstandingAnnualizedFee();\n        LibBasketStorage.BasketStorage storage bs = LibBasketStorage.basketStorage();\n        uint256 totalSupply = LibERC20Storage.erc20Storage().totalSupply;\n\n        uint256 feeAmount = _amount.mul(bs.exitFee).div(10**18);\n\n        for(uint256 i; i < bs.tokens.length; i ++) {\n            IERC20 token = bs.tokens[i];\n            uint256 tokenBalance = balance(address(token));\n            // redeem less tokens if there is an exit fee\n            uint256 tokenAmount = tokenBalance.mul(_amount.sub(feeAmount)).div(totalSupply);\n            require(tokenBalance.sub(tokenAmount) >= MIN_AMOUNT, \"TOKEN_BALANCE_TOO_LOW\");\n            token.safeTransfer(msg.sender, tokenAmount);\n        }\n\n         // If there is any fee that should go to the beneficiary mint it\n        if(\n            feeAmount != 0 &&\n            bs.exitFeeBeneficiaryShare != 0 &&\n            bs.feeBeneficiary != address(0)\n        ) {\n            uint256 feeBeneficiaryShare = feeAmount.mul(bs.exitFeeBeneficiaryShare).div(10**18);\n            if(feeBeneficiaryShare != 0) {\n                LibERC20.mint(bs.feeBeneficiary, feeBeneficiaryShare);\n            }\n        }\n\n        require(totalSupply.sub(_amount) >= MIN_AMOUNT, \"POOL_TOKEN_BALANCE_TOO_LOW\");\n        LibERC20.burn(msg.sender, _amount);\n        emit PoolExited(msg.sender, _amount);\n    }\n\n\n    function calcOutStandingAnnualizedFee() public view override returns(uint256) {\n        LibBasketStorage.BasketStorage storage bs = LibBasketStorage.basketStorage();\n        uint256 totalSupply = LibERC20Storage.erc20Storage().totalSupply;\n\n        uint256 lastFeeClaimed = bs.lastAnnualizedFeeClaimed;\n        uint256 annualizedFee = bs.annualizedFee;\n\n        if(\n            annualizedFee == 0 ||\n            bs.feeBeneficiary == address(0) ||\n            lastFeeClaimed == 0\n        ) {\n            return 0;\n        }\n\n        uint256 timePassed = block.timestamp.sub(lastFeeClaimed);\n\n        return totalSupply.mul(annualizedFee).div(10**18).mul(timePassed).div(365 days);\n    }\n\n    function chargeOutstandingAnnualizedFee() public override {\n        uint256 outStandingFee = calcOutStandingAnnualizedFee();\n        LibBasketStorage.BasketStorage storage bs = LibBasketStorage.basketStorage();\n\n        bs.lastAnnualizedFeeClaimed = block.timestamp;\n\n        // if there is any fee to mint and the beneficiary is set\n        // note: feeBeneficiary is already checked in calc function\n        if(\n            outStandingFee != 0\n        ) {\n            LibERC20.mint(bs.feeBeneficiary, outStandingFee);\n        }\n\n        emit FeeCharged(outStandingFee);\n    }\n\n    // returns true when locked\n    function getLock() external view override returns(bool) {\n        LibBasketStorage.BasketStorage storage bs = LibBasketStorage.basketStorage();\n        return bs.lockBlock == 0 || bs.lockBlock >= block.number;\n    }\n\n    function getTokenInPool(address _token) external view override returns(bool) {\n        return LibBasketStorage.basketStorage().inPool[_token];\n    }\n\n    function getLockBlock() external view override returns(uint256) {\n        return LibBasketStorage.basketStorage().lockBlock;\n    }\n\n    // lock up to and including _lock blocknumber\n    function setLock(uint256 _lock) external override protectedCall {\n        LibBasketStorage.basketStorage().lockBlock = _lock;\n        emit LockSet(_lock);\n    }\n\n    function setCap(uint256 _maxCap) external override protectedCall {\n        LibBasketStorage.basketStorage().maxCap = _maxCap;\n        emit CapSet(_maxCap);\n    }\n\n    // Seperated balance function to allow yearn like strategies to be hooked up by inheriting from this contract and overriding\n    function balance(address _token) public view override returns(uint256) {\n        return IERC20(_token).balanceOf(address(this));\n    }\n\n    function getTokens() external view override returns (address[] memory) {\n        IERC20[] memory tokens = LibBasketStorage.basketStorage().tokens;\n        address[] memory result = new address[](tokens.length);\n\n        for(uint256 i = 0; i < tokens.length; i ++) {\n            result[i] = address(tokens[i]);\n        }\n\n        return(result);\n    }\n\n    function getCap() external view override returns(uint256){\n        return LibBasketStorage.basketStorage().maxCap;\n    }\n\n    function calcTokensForAmount(uint256 _amount) external view override returns (address[] memory tokens, uint256[] memory amounts) {\n        LibBasketStorage.BasketStorage storage bs = LibBasketStorage.basketStorage();\n        uint256 totalSupply = LibERC20Storage.erc20Storage().totalSupply.add(calcOutStandingAnnualizedFee());\n\n        tokens = new address[](bs.tokens.length);\n        amounts = new uint256[](bs.tokens.length);\n\n        for(uint256 i; i < bs.tokens.length; i ++) {\n            IERC20 token = bs.tokens[i];\n            uint256 tokenBalance = balance(address(token));\n            uint256 tokenAmount = tokenBalance.mul(_amount).div(totalSupply);\n            // Add entry fee\n            tokenAmount = tokenAmount.add(tokenAmount.mul(bs.entryFee).div(10**18));\n\n            tokens[i] = address(token);\n            amounts[i] = tokenAmount;\n        }\n\n        return(tokens, amounts);\n    }\n\n    function calcTokensForAmountExit(uint256 _amount) external view override returns (address[] memory tokens, uint256[] memory amounts) {\n        LibBasketStorage.BasketStorage storage bs = LibBasketStorage.basketStorage();\n        uint256 feeAmount = _amount.mul(bs.exitFee).div(10**18);\n        uint256 totalSupply = LibERC20Storage.erc20Storage().totalSupply.add(calcOutStandingAnnualizedFee());\n\n        tokens = new address[](bs.tokens.length);\n        amounts = new uint256[](bs.tokens.length);\n\n        for(uint256 i; i < bs.tokens.length; i ++) {\n            IERC20 token = bs.tokens[i];\n            uint256 tokenBalance = balance(address(token));\n            uint256 tokenAmount = tokenBalance.mul(_amount.sub(feeAmount)).div(totalSupply);\n\n            tokens[i] = address(token);\n            amounts[i] = tokenAmount;\n        }\n\n        return(tokens, amounts);\n    }\n}"
    }
  ]
}