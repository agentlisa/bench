{
  "Title": "M-4: Wrong Price will be Returned When Asset is PToken for WstETH",
  "Content": "# Issue M-4: Wrong Price will be Returned When Asset is PToken for WstETH \n\nSource: https://github.com/sherlock-audit/2023-05-ironbank-judging/issues/220 \n\n## Found by \nbranch\\_indigo\n## Summary\nIron Bank allows a PToken market to be created for an underlying asset in addition to a lending market. PTokens can be counted as user collaterals and their price is fetched based on their underlying tokens. However, wrong price will return when PToken's underlying asset is WstETH.\n## Vulnerability Detail\nRetrieving price for WstETH is a 2 step process. WstETH needs to be converted to stETH first, then converted to ETH/USD. This is properly implemented when the market is WstETH through checking `if (asset==wsteth)`. But when PToken market is created for WstETH, this check will by bypassed because PToken contract address will be different from wsteth address.\n\nPToken market price is set through `_setAggregators()` in PriceOracle.sol where base and quote token address are set and tested before writing into `aggregators` array. And note that quote token address can either be ETH or USD. When asset price is accessed through `getPrice()`, if the input asset is not `wsteth` address, `aggregators` is directly pulled to get chainlink price denominated in ETH or USD. \n\n```solidity\n//PriceOracle.sol\n//_setAggregators()\n                require(\n                    aggrs[i].quote == Denominations.ETH ||\n                        aggrs[i].quote == Denominations.USD,\n                    \"unsupported quote\"\n                );\n```\n```solidity\n//PriceOracle.sol\n    function getPrice(address asset) external view returns (uint256) {\n        if (asset == wsteth) {\n            uint256 stEthPrice = getPriceFromChainlink(\n                steth,\n                Denominations.USD\n            );\n            uint256 stEthPerToken = WstEthInterface(wsteth).stEthPerToken();\n            uint256 wstEthPrice = (stEthPrice * stEthPerToken) / 1e18;\n            return getNormalizedPrice(wstEthPrice, asset);\n        }\n        AggregatorInfo memory aggregatorInfo = aggregators[asset];\n        uint256 price = getPriceFromChainlink(\n            aggregatorInfo.base,\n            aggregatorInfo.quote\n        );\n       ...\n```\nThis creates a problem for PToken for WstETH, because `if (asset==wsteth)` will be bypassed and chainlink aggregator price will be returned. And chainlink doesn't have a direct price quote of WstETH/ETH or WstETH/USD, only WstETH/stETH or stETH/USD. This means most likely aggregator price for stETH/USD will be returned as price for WstETH. \n\nSince stETH is a rebasing token, and WstETH:stETH is not 1 to 1, this will create a wrong valuation for users holding PToken for WstETH as collaterals. \n## Impact\nSince users holding PToken for WstETH will have wrong valuation, this potentially creates opportunities for malicious over-borrowing or unfair liquidations, putting the protocol at risk.\n## Code Snippet\n[https://github.com/sherlock-audit/2023-05-ironbank/blob/main/ib-v2/src/protocol/oracle/PriceOracle.sol#L43](https://github.com/sherlock-audit/2023-05-ironbank/blob/main/ib-v2/src/protocol/oracle/PriceOracle.sol#L43)\n## Tool used\n\nManual Review\n\n## Recommendation\nIn `getPrice()`, consider adding another check whether the asset is PToken and its underlying asset is WstETH. If true, use the same bypass for pricing.\n\n\n\n## Discussion\n\n**bzpassersby**\n\nEscalate for 10 USDC\nI think this is wrongly excluded. The report describes a clear vulnerability that the current Oracle implementation doesn't take into account PToken for WstETH. stETH is a rebasing token ,which is correctly factored in oracle implementation when the market asset is for WstETH. However, when a PToken is created for WstETH, `if(asset==wsteth)` will be bypassed.  Since chainlink doesn't have a direct feed for WstETH/ETH or WstETH/USD. Wrong price will be returned. \n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> I think this is wrongly excluded. The report describes a clear vulnerability that the current Oracle implementation doesn't take into account PToken for WstETH. stETH is a rebasing token ,which is correctly factored in oracle implementation when the market asset is for WstETH. However, when a PToken is created for WstETH, `if(asset==wsteth)` will be bypassed.  Since chainlink doesn't have a direct feed for WstETH/ETH or WstETH/USD. Wrong price will be returned. \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**0xffff11**\n\nIssue seems valid to me. I would judge it as a med because seems that it is for a only a specific pair, quite an edgecases. Thoughts @ibsunhub ?\n\n**ibsunhub**\n\nWe're ok with med.\n\nAlthough we don't decide that if we will support wstETH's PToken, it's our oversight to handle of the price of wstETH's PToken in the price oracle.\n\n**ibsunhub**\n\nfix: https://github.com/ibdotxyz/ib-v2/pull/57\n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nConsidering this issue a valid medium based on the above comments.\n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [bzpassersby](https://github.com/sherlock-audit/2023-05-ironbank-judging/issues/220/#issuecomment-1608105417): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/84",
  "Code": [
    {
      "filename": "ib-v2/src/protocol/oracle/PriceOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"chainlink/contracts/src/v0.8/interfaces/FeedRegistryInterface.sol\";\nimport \"chainlink/contracts/src/v0.8/Denominations.sol\";\nimport \"openzeppelin-contracts/contracts/access/Ownable2Step.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../../extensions/interfaces/WstEthInterface.sol\";\nimport \"../../interfaces/PriceOracleInterface.sol\";\n\ncontract PriceOracle is Ownable2Step, PriceOracleInterface {\n    /// @notice The Chainlink feed registry\n    FeedRegistryInterface public immutable registry;\n\n    /// @notice The address of Lido staked ETH\n    address public immutable steth;\n\n    /// @notice The address of Lido wrapped staked ETH\n    address public immutable wsteth;\n\n    struct AggregatorInfo {\n        address base;\n        address quote;\n    }\n\n    /// @notice The mapping from asset to aggregator\n    mapping(address => AggregatorInfo) public aggregators;\n\n    constructor(address registry_, address steth_, address wsteth_) {\n        registry = FeedRegistryInterface(registry_);\n        steth = steth_;\n        wsteth = wsteth_;\n    }\n\n    /**\n     * @notice Get the price of an asset in USD.\n     * @dev The price returned will be normalized by asset's decimals.\n     * @param asset The asset to get the price of\n     * @return The price of the asset in USD\n     */\n    function getPrice(address asset) external view returns (uint256) {\n        if (asset == wsteth) {\n            uint256 stEthPrice = getPriceFromChainlink(steth, Denominations.USD);\n            uint256 stEthPerToken = WstEthInterface(wsteth).stEthPerToken();\n            uint256 wstEthPrice = (stEthPrice * stEthPerToken) / 1e18;\n            return getNormalizedPrice(wstEthPrice, asset);\n        }\n\n        AggregatorInfo memory aggregatorInfo = aggregators[asset];\n        uint256 price = getPriceFromChainlink(aggregatorInfo.base, aggregatorInfo.quote);\n        if (aggregatorInfo.quote == Denominations.ETH) {\n            // Convert the price to USD based if it's ETH based.\n            uint256 ethUsdPrice = getPriceFromChainlink(Denominations.ETH, Denominations.USD);\n            price = (price * ethUsdPrice) / 1e18;\n        }\n        return getNormalizedPrice(price, asset);\n    }\n\n    /**\n     * @notice Get price from Chainlink.\n     * @param base The base asset\n     * @param quote The quote asset\n     * @return The price\n     */\n    function getPriceFromChainlink(address base, address quote) internal view returns (uint256) {\n        (, int256 price,,,) = registry.latestRoundData(base, quote);\n        require(price > 0, \"invalid price\");\n\n        // Extend the decimals to 1e18.\n        return uint256(price) * 10 ** (18 - uint256(registry.decimals(base, quote)));\n    }\n\n    /**\n     * @dev Get the normalized price.\n     * @param price The price\n     * @param asset The asset\n     * @return The normalized price\n     */\n    function getNormalizedPrice(uint256 price, address asset) internal view returns (uint256) {\n        uint8 decimals = IERC20Metadata(asset).decimals();\n        return price * 10 ** (18 - decimals);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    struct Aggregator {\n        address asset;\n        address base;\n        address quote;\n    }\n\n    /**\n     * @notice Set the aggregators.\n     * @param aggrs The aggregators\n     */\n    function _setAggregators(Aggregator[] calldata aggrs) external onlyOwner {\n        uint256 length = aggrs.length;\n        for (uint256 i = 0; i < length;) {\n            if (aggrs[i].base != address(0)) {\n                require(aggrs[i].quote == Denominations.ETH || aggrs[i].quote == Denominations.USD, \"unsupported quote\");\n\n                // Make sure the aggregator works.\n                address aggregator = address(registry.getFeed(aggrs[i].base, aggrs[i].quote));\n                require(registry.isFeedEnabled(aggregator), \"aggregator not enabled\");\n\n                (, int256 price,,,) = registry.latestRoundData(aggrs[i].base, aggrs[i].quote);\n                require(price > 0, \"invalid price\");\n            }\n            aggregators[aggrs[i].asset] = AggregatorInfo({base: aggrs[i].base, quote: aggrs[i].quote});\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n}"
    }
  ]
}