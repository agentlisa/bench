{
  "Title": "[G-22] Operations capped by `totalSupply` in `L2BaseToken` can be unchecked",
  "Content": "\n**File:** `L2BaseToken.sol`\n\n[File: code/system-contracts/contracts/L2BaseToken.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/L2BaseToken.sol#L64)\n```solidity\n64:     function mint(address _account, uint256 _amount) external override onlyCallFromBootloader {\n65:         totalSupply += _amount;\n66:         balance[_account] += _amount;\n67:         emit Mint(_account, _amount);\n68:     }\n```\nUser's balance is capped by `totalSupply`. When `totalSupply += _amount` won't revert (due to overflow) - we can be sure, that `balance[_account] += _amount` won't overflow either, thus line 66 can be unchecked.\nImportant - please notice, that only line 66: `balance[_account] += _amount` can be unchecked.\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/system-contracts/contracts/L2BaseToken.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {IBaseToken} from \"./interfaces/IBaseToken.sol\";\nimport {ISystemContract} from \"./interfaces/ISystemContract.sol\";\nimport {MSG_VALUE_SYSTEM_CONTRACT, DEPLOYER_SYSTEM_CONTRACT, BOOTLOADER_FORMAL_ADDRESS, L1_MESSENGER_CONTRACT} from \"./Constants.sol\";\nimport {IMailbox} from \"./interfaces/IMailbox.sol\";\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice Native ETH contract.\n * @dev It does NOT provide interfaces for personal interaction with tokens like `transfer`, `approve`, and `transferFrom`.\n * Instead, this contract is used by the bootloader and `MsgValueSimulator`/`ContractDeployer` system contracts\n * to perform the balance changes while simulating the `msg.value` Ethereum behavior.\n */\ncontract L2BaseToken is IBaseToken, ISystemContract {\n    /// @notice The balances of the users.\n    mapping(address account => uint256 balance) internal balance;\n\n    /// @notice The total amount of tokens that have been minted.\n    uint256 public override totalSupply;\n\n    /// @notice Transfer tokens from one address to another.\n    /// @param _from The address to transfer the ETH from.\n    /// @param _to The address to transfer the ETH to.\n    /// @param _amount The amount of ETH in wei being transferred.\n    /// @dev This function can be called only by trusted system contracts.\n    /// @dev This function also emits \"Transfer\" event, which might be removed\n    /// later on.\n    function transferFromTo(address _from, address _to, uint256 _amount) external override {\n        require(\n            msg.sender == MSG_VALUE_SYSTEM_CONTRACT ||\n                msg.sender == address(DEPLOYER_SYSTEM_CONTRACT) ||\n                msg.sender == BOOTLOADER_FORMAL_ADDRESS,\n            \"Only system contracts with special access can call this method\"\n        );\n\n        uint256 fromBalance = balance[_from];\n        require(fromBalance >= _amount, \"Transfer amount exceeds balance\");\n        unchecked {\n            balance[_from] = fromBalance - _amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            balance[_to] += _amount;\n        }\n\n        emit Transfer(_from, _to, _amount);\n    }\n\n    /// @notice Returns ETH balance of an account\n    /// @dev It takes `uint256` as an argument to be able to properly simulate the behaviour of the\n    /// Ethereum's `BALANCE` opcode that accepts uint256 as an argument and truncates any upper bits\n    /// @param _account The address of the account to return the balance of.\n    function balanceOf(uint256 _account) external view override returns (uint256) {\n        return balance[address(uint160(_account))];\n    }\n\n    /// @notice Increase the total supply of tokens and balance of the receiver.\n    /// @dev This method is only callable by the bootloader.\n    /// @param _account The address which to mint the funds to.\n    /// @param _amount The amount of ETH in wei to be minted.\n    function mint(address _account, uint256 _amount) external override onlyCallFromBootloader {\n        totalSupply += _amount;\n        balance[_account] += _amount;\n        emit Mint(_account, _amount);\n    }\n\n    /// @notice Initiate the ETH withdrawal, funds will be available to claim on L1 `finalizeEthWithdrawal` method.\n    /// @param _l1Receiver The address on L1 to receive the funds.\n    function withdraw(address _l1Receiver) external payable override {\n        uint256 amount = _burnMsgValue();\n\n        // Send the L2 log, a user could use it as proof of the withdrawal\n        bytes memory message = _getL1WithdrawMessage(_l1Receiver, amount);\n        L1_MESSENGER_CONTRACT.sendToL1(message);\n\n        emit Withdrawal(msg.sender, _l1Receiver, amount);\n    }\n\n    /// @notice Initiate the ETH withdrawal, with the sent message. The funds will be available to claim on L1 `finalizeEthWithdrawal` method.\n    /// @param _l1Receiver The address on L1 to receive the funds.\n    /// @param _additionalData Additional data to be sent to L1 with the withdrawal.\n    function withdrawWithMessage(address _l1Receiver, bytes memory _additionalData) external payable override {\n        uint256 amount = _burnMsgValue();\n\n        // Send the L2 log, a user could use it as proof of the withdrawal\n        bytes memory message = _getExtendedWithdrawMessage(_l1Receiver, amount, msg.sender, _additionalData);\n        L1_MESSENGER_CONTRACT.sendToL1(message);\n\n        emit WithdrawalWithMessage(msg.sender, _l1Receiver, amount, _additionalData);\n    }\n\n    /// @dev The function burn the sent `msg.value`.\n    /// NOTE: Since this contract holds the mapping of all ether balances of the system,\n    /// the sent `msg.value` is added to the `this` balance before the call.\n    /// So the balance of `address(this)` is always bigger or equal to the `msg.value`!\n    function _burnMsgValue() internal returns (uint256 amount) {\n        amount = msg.value;\n\n        // Silent burning of the ether\n        unchecked {\n            // This is safe, since this contract holds the ether balances, and if user\n            // send a `msg.value` it will be added to the contract (`this`) balance.\n            balance[address(this)] -= amount;\n            totalSupply -= amount;\n        }\n    }\n\n    /// @dev Get the message to be sent to L1 to initiate a withdrawal.\n    function _getL1WithdrawMessage(address _to, uint256 _amount) internal pure returns (bytes memory) {\n        return abi.encodePacked(IMailbox.finalizeEthWithdrawal.selector, _to, _amount);\n    }\n\n    /// @dev Get the message to be sent to L1 to initiate a withdrawal.\n    function _getExtendedWithdrawMessage(\n        address _to,\n        uint256 _amount,\n        address _sender,\n        bytes memory _additionalData\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(IMailbox.finalizeEthWithdrawal.selector, _to, _amount, _sender, _additionalData);\n    }\n\n    /// @dev This method has not been stabilized and might be\n    /// removed later on.\n    function name() external pure override returns (string memory) {\n        return \"Ether\";\n    }\n\n    /// @dev This method has not been stabilized and might be\n    /// removed later on.\n    function symbol() external pure override returns (string memory) {\n        return \"ETH\";\n    }\n\n    /// @dev This method has not been stabilized and might be\n    /// removed later on.\n    function decimals() external pure override returns (uint8) {\n        return 18;\n    }\n}"
    }
  ]
}