{
  "Title": "[G-06] Use the existing Local variable/global variable when equal to a state variable to avoid reading from state",
  "Content": "\n### Local variable `_escrow` should be used instead of reading `escrow`\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/token/NounsTokenFork.sol#L131-L137\n\n**Gas benchmarks**\n\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 211357    | 224893   | 211357 | 255180 |\n| After  | 211339    | 224875   | 211339 | 255162 |\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/fork/newdao/token/NounsTokenFork.sol\n131:        escrow = _escrow;\n        \n137:        NounsTokenFork originalToken = NounsTokenFork(address(escrow.nounsToken()));\n```\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/fork/newdao/token/NounsTokenFork.sol b/packages/nouns-contracts/contracts/governance/fork/newdao/token/NounsT\nokenFork.sol\nindex a1f9d6d3..fea6fad8 100644\n--- a/packages/nouns-contracts/contracts/governance/fork/newdao/token/NounsTokenFork.sol\n+++ b/packages/nouns-contracts/contracts/governance/fork/newdao/token/NounsTokenFork.sol\n@@ -134,7 +134,7 @@ contract NounsTokenFork is INounsTokenFork, OwnableUpgradeable, ERC721Checkpoint\n         remainingTokensToClaim = tokensToClaim;\n         forkingPeriodEndTimestamp = _forkingPeriodEndTimestamp;\n\n-        NounsTokenFork originalToken = NounsTokenFork(address(escrow.nounsToken()));\n+        NounsTokenFork originalToken = NounsTokenFork(address(_escrow.nounsToken()));\n         descriptor = originalToken.descriptor();\n         seeder = originalToken.seeder();\n     }\n```\n\n### Global variable `msg.sender` should be used instead of reading state (Save 128 gas on average)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L240-L260\n\n**Gas benchmarks**\n\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 13546    | 439476   | 380456 | 947962 |\n| After  | 13456    | 439348   | 380323 | 947829 |\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n240:        Proposal storage newProposal = _proposals[proposalCount];\n\n242:        newProposal.proposer = msg.sender;\n\n260:        latestProposalIds[newProposal.proposer] = newProposal.id;\n```\nWe are setting `newProposal.proposer` to be equal to `msg.sender`. As `newProposal.proposer` is a state variable, it's a bit expensive to read, we can instead read `msg.sender` which is a global variable, thus more cheaper to read.\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\nindex ff426a81..9328d9ce 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n@@ -257,7 +257,7 @@ contract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n         newProposal.totalSupply = temp.totalSupply;\n         newProposal.creationBlock = block.number;\n\n-        latestProposalIds[newProposal.proposer] = newProposal.id;\n+        latestProposalIds[msg.sender] = newProposal.id;\n\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-07-nounsdao",
  "Code": [
    {
      "filename": "packages/nouns-contracts/contracts/governance/fork/newdao/token/NounsTokenFork.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/// @title The Nouns ERC-721 token, adjusted for forks\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\npragma solidity ^0.8.19;\n\nimport { OwnableUpgradeable } from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport { ERC721CheckpointableUpgradeable } from './base/ERC721CheckpointableUpgradeable.sol';\nimport { INounsDescriptorMinimal } from '../../../../interfaces/INounsDescriptorMinimal.sol';\nimport { INounsSeeder } from '../../../../interfaces/INounsSeeder.sol';\nimport { INounsTokenFork } from './INounsTokenFork.sol';\nimport { IERC721 } from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport { UUPSUpgradeable } from '@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol';\nimport { INounsDAOForkEscrow } from '../../../NounsDAOInterfaces.sol';\n\n/**\n * @dev This contract is a fork of NounsToken, with the following changes:\n * - Added upgradeablity via UUPSUpgradeable.\n * - Inheriting from an unmodified ERC721, so that the double Transfer event emission that\n *   NounsToken performs is gone, in favor of the standard single event.\n * - Added functions to claim tokens from a Nouns Fork escrow, or during the forking period.\n * - Removed the proxyRegistry feature that whitelisted OpenSea.\n * - Removed `noundersDAO` and the founder reward every 10 mints.\n * For additional context see `ERC721CheckpointableUpgradeable`.\n */\ncontract NounsTokenFork is INounsTokenFork, OwnableUpgradeable, ERC721CheckpointableUpgradeable, UUPSUpgradeable {\n    error OnlyOwner();\n    error OnlyTokenOwnerCanClaim();\n    error OnlyOriginalDAO();\n    error NoundersCannotBeAddressZero();\n    error OnlyDuringForkingPeriod();\n\n    string public constant NAME = 'NounsTokenFork';\n\n    /// @notice  An address who has permissions to mint Nouns\n    address public minter;\n\n    /// @notice The Nouns token URI descriptor\n    INounsDescriptorMinimal public descriptor;\n\n    /// @notice The Nouns token seeder\n    INounsSeeder public seeder;\n\n    /// @notice The escrow contract used to verify ownership of the original Nouns in the post-fork claiming process\n    INounsDAOForkEscrow public escrow;\n\n    /// @notice The fork ID, used when querying the escrow for token ownership\n    uint32 public forkId;\n\n    /// @notice How many tokens are still available to be claimed by Nouners who put their original Nouns in escrow\n    uint256 public remainingTokensToClaim;\n\n    /// @notice The forking period expiration timestamp, after which new tokens cannot be claimed by the original DAO\n    uint256 public forkingPeriodEndTimestamp;\n\n    /// @notice Whether the minter can be updated\n    bool public isMinterLocked;\n\n    /// @notice Whether the descriptor can be updated\n    bool public isDescriptorLocked;\n\n    /// @notice Whether the seeder can be updated\n    bool public isSeederLocked;\n\n    /// @notice The noun seeds\n    mapping(uint256 => INounsSeeder.Seed) public seeds;\n\n    /// @notice The internal noun ID tracker\n    uint256 private _currentNounId;\n\n    /// @notice IPFS content hash of contract-level metadata\n    string private _contractURIHash = 'QmZi1n79FqWt2tTLwCqiy6nLM6xLGRsEPQ5JmReJQKNNzX';\n\n    /**\n     * @notice Require that the minter has not been locked.\n     */\n    modifier whenMinterNotLocked() {\n        require(!isMinterLocked, 'Minter is locked');\n        _;\n    }\n\n    /**\n     * @notice Require that the descriptor has not been locked.\n     */\n    modifier whenDescriptorNotLocked() {\n        require(!isDescriptorLocked, 'Descriptor is locked');\n        _;\n    }\n\n    /**\n     * @notice Require that the seeder has not been locked.\n     */\n    modifier whenSeederNotLocked() {\n        require(!isSeederLocked, 'Seeder is locked');\n        _;\n    }\n\n    /**\n     * @notice Require that the sender is the minter.\n     */\n    modifier onlyMinter() {\n        require(msg.sender == minter, 'Sender is not the minter');\n        _;\n    }\n\n    function initialize(\n        address _owner,\n        address _minter,\n        INounsDAOForkEscrow _escrow,\n        uint32 _forkId,\n        uint256 startNounId,\n        uint256 tokensToClaim,\n        uint256 _forkingPeriodEndTimestamp\n    ) external initializer {\n        __ERC721_init('Nouns', 'NOUN');\n        _transferOwnership(_owner);\n        minter = _minter;\n        escrow = _escrow;\n        forkId = _forkId;\n        _currentNounId = startNounId;\n        remainingTokensToClaim = tokensToClaim;\n        forkingPeriodEndTimestamp = _forkingPeriodEndTimestamp;\n\n        NounsTokenFork originalToken = NounsTokenFork(address(escrow.nounsToken()));\n        descriptor = originalToken.descriptor();\n        seeder = originalToken.seeder();\n    }\n\n    /**\n     * @notice Claim new tokens if you escrowed original Nouns and forked into a new DAO governed by holders of this\n     * token.\n     * @dev Reverts if the sender is not the owner of the escrowed token.\n     * @param tokenIds The token IDs to claim\n     */\n    function claimFromEscrow(uint256[] calldata tokenIds) external {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            uint256 nounId = tokenIds[i];\n            if (escrow.ownerOfEscrowedToken(forkId, nounId) != msg.sender) revert OnlyTokenOwnerCanClaim();\n\n            _mintWithOriginalSeed(msg.sender, nounId);\n        }\n\n        remainingTokensToClaim -= tokenIds.length;\n    }\n\n    /**\n     * @notice The original DAO can claim tokens during the forking period, on behalf of Nouners who choose to join\n     * a new fork DAO. Does not allow the original DAO to claim once the forking period has ended.\n     * @dev Assumes the original DAO is honest during the forking period.\n     * @param to The recipient of the tokens\n     * @param tokenIds The token IDs to claim\n     */\n    function claimDuringForkPeriod(address to, uint256[] calldata tokenIds) external {\n        uint256 currentNounId = _currentNounId;\n        uint256 maxNounId = 0;\n        if (msg.sender != escrow.dao()) revert OnlyOriginalDAO();\n        if (block.timestamp >= forkingPeriodEndTimestamp) revert OnlyDuringForkingPeriod();\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            uint256 nounId = tokenIds[i];\n            _mintWithOriginalSeed(to, nounId);\n\n            if (tokenIds[i] > maxNounId) maxNounId = tokenIds[i];\n        }\n\n        // This treats an important case:\n        // During a forking period, people can buy new Nouns on auction, with a higher ID than the auction ID at forking\n        // They can then join the fork with those IDs\n        // If we don't increment currentNounId, unpausing the fork auction house would revert\n        // Since it would attempt to mint a noun with an ID that already exists\n        if (maxNounId >= currentNounId) _currentNounId = maxNounId + 1;\n    }\n\n    /**\n     * @notice The IPFS URI of contract-level metadata.\n     */\n    function contractURI() public view returns (string memory) {\n        return string(abi.encodePacked('ipfs://', _contractURIHash));\n    }\n\n    /**\n     * @notice Set the _contractURIHash.\n     * @dev Only callable by the owner.\n     */\n    function setContractURIHash(string memory newContractURIHash) external onlyOwner {\n        _contractURIHash = newContractURIHash;\n    }\n\n    /**\n     * @notice Mint a Noun to the minter\n     * @dev Call _mintTo with the to address(es).\n     */\n    function mint() public override onlyMinter returns (uint256) {\n        return _mintTo(minter, _currentNounId++);\n    }\n\n    /**\n     * @notice Burn a noun.\n     */\n    function burn(uint256 nounId) public override onlyMinter {\n        _burn(nounId);\n        emit NounBurned(nounId);\n    }\n\n    /**\n     * @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        require(_exists(tokenId), 'NounsToken: URI query for nonexistent token');\n        return descriptor.tokenURI(tokenId, seeds[tokenId]);\n    }\n\n    /**\n     * @notice Similar to `tokenURI`, but always serves a base64 encoded data URI\n     * with the JSON contents directly inlined.\n     */\n    function dataURI(uint256 tokenId) public view override returns (string memory) {\n        require(_exists(tokenId), 'NounsToken: URI query for nonexistent token');\n        return descriptor.dataURI(tokenId, seeds[tokenId]);\n    }\n\n    /**\n     * @notice Set the token minter.\n     * @dev Only callable by the owner when not locked.\n     */\n    function setMinter(address _minter) external override onlyOwner whenMinterNotLocked {\n        minter = _minter;\n\n        emit MinterUpdated(_minter);\n    }\n\n    /**\n     * @notice Lock the minter.\n     * @dev This cannot be reversed and is only callable by the owner when not locked.\n     */\n    function lockMinter() external override onlyOwner whenMinterNotLocked {\n        isMinterLocked = true;\n\n        emit MinterLocked();\n    }\n\n    /**\n     * @notice Set the token URI descriptor.\n     * @dev Only callable by the owner when not locked.\n     */\n    function setDescriptor(INounsDescriptorMinimal _descriptor) external override onlyOwner whenDescriptorNotLocked {\n        descriptor = _descriptor;\n\n        emit DescriptorUpdated(_descriptor);\n    }\n\n    /**\n     * @notice Lock the descriptor.\n     * @dev This cannot be reversed and is only callable by the owner when not locked.\n     */\n    function lockDescriptor() external override onlyOwner whenDescriptorNotLocked {\n        isDescriptorLocked = true;\n\n        emit DescriptorLocked();\n    }\n\n    /**\n     * @notice Set the token seeder.\n     * @dev Only callable by the owner when not locked.\n     */\n    function setSeeder(INounsSeeder _seeder) external override onlyOwner whenSeederNotLocked {\n        seeder = _seeder;\n\n        emit SeederUpdated(_seeder);\n    }\n\n    /**\n     * @notice Lock the seeder.\n     * @dev This cannot be reversed and is only callable by the owner when not locked.\n     */\n    function lockSeeder() external override onlyOwner whenSeederNotLocked {\n        isSeederLocked = true;\n\n        emit SeederLocked();\n    }\n\n    /**\n     * @notice Mint a Noun with `nounId` to the provided `to` address.\n     */\n    function _mintTo(address to, uint256 nounId) internal returns (uint256) {\n        INounsSeeder.Seed memory seed = seeds[nounId] = seeder.generateSeed(nounId, descriptor);\n\n        _mint(to, nounId);\n        emit NounCreated(nounId, seed);\n\n        return nounId;\n    }\n\n    /**\n     * @notice Mint a new token using the original Nouns seed.\n     */\n    function _mintWithOriginalSeed(address to, uint256 nounId) internal {\n        (uint48 background, uint48 body, uint48 accessory, uint48 head, uint48 glasses) = NounsTokenFork(\n            address(escrow.nounsToken())\n        ).seeds(nounId);\n        INounsSeeder.Seed memory seed = INounsSeeder.Seed(background, body, accessory, head, glasses);\n\n        seeds[nounId] = seed;\n        _mint(to, nounId);\n\n        emit NounCreated(nounId, seed);\n    }\n\n    /**\n     * @dev Reverts when `msg.sender` is not the owner of this contract; in the case of Noun DAOs it should be the\n     * DAO's treasury contract.\n     */\n    function _authorizeUpgrade(address) internal view override onlyOwner {}\n}"
    },
    {
      "filename": "packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\n/// @title The Nouns DAO logic version 2\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\n// LICENSE\n// NounsDAOLogicV2.sol is a modified version of Compound Lab's GovernorBravoDelegate.sol:\n// https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/Governance/GovernorBravoDelegate.sol\n//\n// GovernorBravoDelegate.sol source code Copyright 2020 Compound Labs, Inc. licensed under the BSD-3-Clause license.\n// With modifications by Nounders DAO.\n//\n// Additional conditions of BSD-3-Clause can be found here: https://opensource.org/licenses/BSD-3-Clause\n//\n// MODIFICATIONS\n// See NounsDAOLogicV1 for initial GovernorBravoDelegate modifications.\n\n// NounsDAOLogicV2 adds:\n// - `quorumParamsCheckpoints`, which store dynamic quorum parameters checkpoints\n// to be used when calculating the dynamic quorum.\n// - `_setDynamicQuorumParams(DynamicQuorumParams memory params)`, which allows the\n// DAO to update the dynamic quorum parameters' values.\n// - `getDynamicQuorumParamsAt(uint256 blockNumber_)`\n// - Individual setters of the DynamicQuorumParams members:\n//    - `_setMinQuorumVotesBPS(uint16 newMinQuorumVotesBPS)`\n//    - `_setMaxQuorumVotesBPS(uint16 newMaxQuorumVotesBPS)`\n//    - `_setQuorumCoefficient(uint32 newQuorumCoefficient)`\n// - `minQuorumVotes` and `maxQuorumVotes`, which returns the current min and\n// max quorum votes using the current Noun supply.\n// - New `Proposal` struct member:\n//    - `totalSupply` used in dynamic quorum calculation.\n//    - `creationBlock` used for retrieving checkpoints of votes and dynamic quorum params. This now\n// allows changing `votingDelay` without affecting the checkpoints lookup.\n// - `quorumVotes(uint256 proposalId)`, which calculates and returns the dynamic\n// quorum for a specific proposal.\n// - `proposals(uint256 proposalId)` instead of the implicit getter, to avoid stack-too-deep error\n//\n// NounsDAOLogicV2 removes:\n// - `quorumVotes()` has been replaced by `quorumVotes(uint256 proposalId)`.\n\npragma solidity ^0.8.6;\n\nimport './NounsDAOInterfaces.sol';\n\ncontract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n    /// @notice The name of this contract\n    string public constant name = 'Nouns DAO';\n\n    /// @notice The minimum setable proposal threshold\n    uint256 public constant MIN_PROPOSAL_THRESHOLD_BPS = 1; // 1 basis point or 0.01%\n\n    /// @notice The maximum setable proposal threshold\n    uint256 public constant MAX_PROPOSAL_THRESHOLD_BPS = 1_000; // 1,000 basis points or 10%\n\n    /// @notice The minimum setable voting period\n    uint256 public constant MIN_VOTING_PERIOD = 5_760; // About 24 hours\n\n    /// @notice The max setable voting period\n    uint256 public constant MAX_VOTING_PERIOD = 80_640; // About 2 weeks\n\n    /// @notice The min setable voting delay\n    uint256 public constant MIN_VOTING_DELAY = 1;\n\n    /// @notice The max setable voting delay\n    uint256 public constant MAX_VOTING_DELAY = 40_320; // About 1 week\n\n    /// @notice The lower bound of minimum quorum votes basis points\n    uint256 public constant MIN_QUORUM_VOTES_BPS_LOWER_BOUND = 200; // 200 basis points or 2%\n\n    /// @notice The upper bound of minimum quorum votes basis points\n    uint256 public constant MIN_QUORUM_VOTES_BPS_UPPER_BOUND = 2_000; // 2,000 basis points or 20%\n\n    /// @notice The upper bound of maximum quorum votes basis points\n    uint256 public constant MAX_QUORUM_VOTES_BPS_UPPER_BOUND = 6_000; // 4,000 basis points or 60%\n\n    /// @notice The maximum setable quorum votes basis points\n    uint256 public constant MAX_QUORUM_VOTES_BPS = 2_000; // 2,000 basis points or 20%\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    uint256 public constant proposalMaxOperations = 10; // 10 actions\n\n    /// @notice The maximum priority fee used to cap gas refunds in `castRefundableVote`\n    uint256 public constant MAX_REFUND_PRIORITY_FEE = 2 gwei;\n\n    /// @notice The vote refund gas overhead, including 7K for ETH transfer and 29K for general transaction overhead\n    uint256 public constant REFUND_BASE_GAS = 36000;\n\n    /// @notice The maximum gas units the DAO will refund voters on; supports about 9,190 characters\n    uint256 public constant MAX_REFUND_GAS_USED = 200_000;\n\n    /// @notice The maximum basefee the DAO will refund voters on\n    uint256 public constant MAX_REFUND_BASE_FEE = 200 gwei;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\n\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256('Ballot(uint256 proposalId,uint8 support)');\n\n    /// @dev Introduced these errors to reduce contract size, to avoid deployment failure\n    error AdminOnly();\n    error InvalidMinQuorumVotesBPS();\n    error InvalidMaxQuorumVotesBPS();\n    error MinQuorumBPSGreaterThanMaxQuorumBPS();\n    error UnsafeUint16Cast();\n    error VetoerOnly();\n    error PendingVetoerOnly();\n    error VetoerBurned();\n    error CantVetoExecutedProposal();\n    error CantCancelExecutedProposal();\n\n    /**\n     * @notice Used to initialize the contract during delegator contructor\n     * @param timelock_ The address of the NounsDAOExecutor\n     * @param nouns_ The address of the NOUN tokens\n     * @param vetoer_ The address allowed to unilaterally veto proposals\n     * @param votingPeriod_ The initial voting period\n     * @param votingDelay_ The initial voting delay\n     * @param proposalThresholdBPS_ The initial proposal threshold in basis points\n     * @param dynamicQuorumParams_ The initial dynamic quorum parameters\n     */\n    function initialize(\n        address timelock_,\n        address nouns_,\n        address vetoer_,\n        uint256 votingPeriod_,\n        uint256 votingDelay_,\n        uint256 proposalThresholdBPS_,\n        DynamicQuorumParams calldata dynamicQuorumParams_\n    ) public virtual {\n        require(address(timelock) == address(0), 'NounsDAO::initialize: can only initialize once');\n        if (msg.sender != admin) {\n            revert AdminOnly();\n        }\n        require(timelock_ != address(0), 'NounsDAO::initialize: invalid timelock address');\n        require(nouns_ != address(0), 'NounsDAO::initialize: invalid nouns address');\n        require(\n            votingPeriod_ >= MIN_VOTING_PERIOD && votingPeriod_ <= MAX_VOTING_PERIOD,\n            'NounsDAO::initialize: invalid voting period'\n        );\n        require(\n            votingDelay_ >= MIN_VOTING_DELAY && votingDelay_ <= MAX_VOTING_DELAY,\n            'NounsDAO::initialize: invalid voting delay'\n        );\n        require(\n            proposalThresholdBPS_ >= MIN_PROPOSAL_THRESHOLD_BPS && proposalThresholdBPS_ <= MAX_PROPOSAL_THRESHOLD_BPS,\n            'NounsDAO::initialize: invalid proposal threshold bps'\n        );\n\n        emit VotingPeriodSet(votingPeriod, votingPeriod_);\n        emit VotingDelaySet(votingDelay, votingDelay_);\n        emit ProposalThresholdBPSSet(proposalThresholdBPS, proposalThresholdBPS_);\n\n        timelock = INounsDAOExecutor(timelock_);\n        nouns = NounsTokenLike(nouns_);\n        vetoer = vetoer_;\n        votingPeriod = votingPeriod_;\n        votingDelay = votingDelay_;\n        proposalThresholdBPS = proposalThresholdBPS_;\n        _setDynamicQuorumParams(\n            dynamicQuorumParams_.minQuorumVotesBPS,\n            dynamicQuorumParams_.maxQuorumVotesBPS,\n            dynamicQuorumParams_.quorumCoefficient\n        );\n    }\n\n    struct ProposalTemp {\n        uint256 totalSupply;\n        uint256 proposalThreshold;\n        uint256 latestProposalId;\n        uint256 startBlock;\n        uint256 endBlock;\n    }\n\n    /**\n     * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold\n     * @param targets Target addresses for proposal calls\n     * @param values Eth values for proposal calls\n     * @param signatures Function signatures for proposal calls\n     * @param calldatas Calldatas for proposal calls\n     * @param description String description of the proposal\n     * @return Proposal id of new proposal\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) public returns (uint256) {\n        ProposalTemp memory temp;\n\n        temp.totalSupply = nouns.totalSupply();\n\n        temp.proposalThreshold = bps2Uint(proposalThresholdBPS, temp.totalSupply);\n\n        require(\n            nouns.getPriorVotes(msg.sender, block.number - 1) > temp.proposalThreshold,\n            'NounsDAO::propose: proposer votes below proposal threshold'\n        );\n        require(\n            targets.length == values.length &&\n                targets.length == signatures.length &&\n                targets.length == calldatas.length,\n            'NounsDAO::propose: proposal function information arity mismatch'\n        );\n        require(targets.length != 0, 'NounsDAO::propose: must provide actions');\n        require(targets.length <= proposalMaxOperations, 'NounsDAO::propose: too many actions');\n\n        temp.latestProposalId = latestProposalIds[msg.sender];\n        if (temp.latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(temp.latestProposalId);\n            require(\n                proposersLatestProposalState != ProposalState.Active,\n                'NounsDAO::propose: one live proposal per proposer, found an already active proposal'\n            );\n            require(\n                proposersLatestProposalState != ProposalState.Pending,\n                'NounsDAO::propose: one live proposal per proposer, found an already pending proposal'\n            );\n        }\n\n        temp.startBlock = block.number + votingDelay;\n        temp.endBlock = temp.startBlock + votingPeriod;\n\n        proposalCount++;\n        Proposal storage newProposal = _proposals[proposalCount];\n        newProposal.id = proposalCount;\n        newProposal.proposer = msg.sender;\n        newProposal.proposalThreshold = temp.proposalThreshold;\n        newProposal.eta = 0;\n        newProposal.targets = targets;\n        newProposal.values = values;\n        newProposal.signatures = signatures;\n        newProposal.calldatas = calldatas;\n        newProposal.startBlock = temp.startBlock;\n        newProposal.endBlock = temp.endBlock;\n        newProposal.forVotes = 0;\n        newProposal.againstVotes = 0;\n        newProposal.abstainVotes = 0;\n        newProposal.canceled = false;\n        newProposal.executed = false;\n        newProposal.vetoed = false;\n        newProposal.totalSupply = temp.totalSupply;\n        newProposal.creationBlock = block.number;\n\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        /// @notice Maintains backwards compatibility with GovernorBravo events\n        emit ProposalCreated(\n            newProposal.id,\n            msg.sender,\n            targets,\n            values,\n            signatures,\n            calldatas,\n            newProposal.startBlock,\n            newProposal.endBlock,\n            description\n        );\n\n        /// @notice Updated event with `proposalThreshold` and `minQuorumVotes`\n        /// @notice `minQuorumVotes` is always zero since V2 introduces dynamic quorum with checkpoints\n        emit ProposalCreatedWithRequirements(\n            newProposal.id,\n            msg.sender,\n            targets,\n            values,\n            signatures,\n            calldatas,\n            newProposal.startBlock,\n            newProposal.endBlock,\n            newProposal.proposalThreshold,\n            minQuorumVotes(),\n            description\n        );\n\n        return newProposal.id;\n    }\n\n    /**\n     * @notice Queues a proposal of state succeeded\n     * @param proposalId The id of the proposal to queue\n     */\n    function queue(uint256 proposalId) external {\n        require(\n            state(proposalId) == ProposalState.Succeeded,\n            'NounsDAO::queue: proposal can only be queued if it is succeeded'\n        );\n        Proposal storage proposal = _proposals[proposalId];\n        uint256 eta = block.timestamp + timelock.delay();\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            queueOrRevertInternal(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                eta\n            );\n        }\n        proposal.eta = eta;\n        emit ProposalQueued(proposalId, eta);\n    }\n\n    function queueOrRevertInternal(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        require(\n            !timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))),\n            'NounsDAO::queueOrRevertInternal: identical proposal action already queued at eta'\n        );\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\n    /**\n     * @notice Executes a queued proposal if eta has passed\n     * @param proposalId The id of the proposal to execute\n     */\n    function execute(uint256 proposalId) external {\n        require(\n            state(proposalId) == ProposalState.Queued,\n            'NounsDAO::execute: proposal can only be executed if it is queued'\n        );\n        Proposal storage proposal = _proposals[proposalId];\n        proposal.executed = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.executeTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n        emit ProposalExecuted(proposalId);\n    }\n\n    /**\n     * @notice Cancels a proposal only if sender is the proposer, or proposer delegates dropped below proposal threshold\n     * @param proposalId The id of the proposal to cancel\n     */\n    function cancel(uint256 proposalId) external {\n        if (state(proposalId) == ProposalState.Executed) {\n            revert CantCancelExecutedProposal();\n        }\n\n        Proposal storage proposal = _proposals[proposalId];\n        require(\n            msg.sender == proposal.proposer ||\n                nouns.getPriorVotes(proposal.proposer, block.number - 1) <= proposal.proposalThreshold,\n            'NounsDAO::cancel: proposer above threshold'\n        );\n\n        proposal.canceled = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.cancelTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n\n        emit ProposalCanceled(proposalId);\n    }\n\n    /**\n     * @notice Vetoes a proposal only if sender is the vetoer and the proposal has not been executed.\n     * @param proposalId The id of the proposal to veto\n     */\n    function veto(uint256 proposalId) external {\n        if (vetoer == address(0)) {\n            revert VetoerBurned();\n        }\n\n        if (msg.sender != vetoer) {\n            revert VetoerOnly();\n        }\n\n        if (state(proposalId) == ProposalState.Executed) {\n            revert CantVetoExecutedProposal();\n        }\n\n        Proposal storage proposal = _proposals[proposalId];\n\n        proposal.vetoed = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.cancelTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n\n        emit ProposalVetoed(proposalId);\n    }\n\n    /**\n     * @notice Gets actions of a proposal\n     * @param proposalId the id of the proposal\n     * @return targets\n     * @return values\n     * @return signatures\n     * @return calldatas\n     */\n    function getActions(uint256 proposalId)\n        external\n        view\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        )\n    {\n        Proposal storage p = _proposals[proposalId];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    }\n\n    /**\n     * @notice Gets the receipt for a voter on a given proposal\n     * @param proposalId the id of proposal\n     * @param voter The address of the voter\n     * @return The voting receipt\n     */\n    function getReceipt(uint256 proposalId, address voter) external view returns (Receipt memory) {\n        return _proposals[proposalId].receipts[voter];\n    }\n\n    /**\n     * @notice Gets the state of a proposal\n     * @param proposalId The id of the proposal\n     * @return Proposal state\n     */\n    function state(uint256 proposalId) public view returns (ProposalState) {\n        require(proposalCount >= proposalId, 'NounsDAO::state: invalid proposal id');\n        Proposal storage proposal = _proposals[proposalId];\n        if (proposal.vetoed) {\n            return ProposalState.Vetoed;\n        } else if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (block.number <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (block.number <= proposal.endBlock) {\n            return ProposalState.Active;\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes(proposal.id)) {\n            return ProposalState.Defeated;\n        } else if (proposal.eta == 0) {\n            return ProposalState.Succeeded;\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= proposal.eta + timelock.GRACE_PERIOD()) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    /**\n     * @notice Returns the proposal details given a proposal id.\n     *     The `quorumVotes` member holds the *current* quorum, given the current votes.\n     * @param proposalId the proposal id to get the data for\n     * @return A `ProposalCondensed` struct with the proposal data\n     */\n    function proposals(uint256 proposalId) external view returns (ProposalCondensed memory) {\n        Proposal storage proposal = _proposals[proposalId];\n        return\n            ProposalCondensed({\n                id: proposal.id,\n                proposer: proposal.proposer,\n                proposalThreshold: proposal.proposalThreshold,\n                quorumVotes: quorumVotes(proposal.id),\n                eta: proposal.eta,\n                startBlock: proposal.startBlock,\n                endBlock: proposal.endBlock,\n                forVotes: proposal.forVotes,\n                againstVotes: proposal.againstVotes,\n                abstainVotes: proposal.abstainVotes,\n                canceled: proposal.canceled,\n                vetoed: proposal.vetoed,\n                executed: proposal.executed,\n                totalSupply: proposal.totalSupply,\n                creationBlock: proposal.creationBlock\n            });\n    }\n\n    /**\n     * @notice Cast a vote for a proposal\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     */\n    function castVote(uint256 proposalId, uint8 support) external {\n        emit VoteCast(msg.sender, proposalId, support, castVoteInternal(msg.sender, proposalId, support), '');\n    }\n\n    /**\n     * @notice Cast a vote for a proposal, asking the DAO to refund gas costs.\n     * Users with > 0 votes receive refunds. Refunds are partial when using a gas priority fee higher than the DAO's cap.\n     * Refunds are partial when the DAO's balance is insufficient.\n     * No refund is sent when the DAO's balance is empty. No refund is sent to users with no votes.\n     * Voting takes place regardless of refund success.\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @dev Reentrancy is defended against in `castVoteInternal` at the `receipt.hasVoted == false` require statement.\n     */\n    function castRefundableVote(uint256 proposalId, uint8 support) external {\n        castRefundableVoteInt"
    }
  ]
}