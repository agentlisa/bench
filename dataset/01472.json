{
  "Title": "H-1: Stable BPT valuation is incorrect and can be exploited to cause protocol insolvency",
  "Content": "# Issue H-1: Stable BPT valuation is incorrect and can be exploited to cause protocol insolvency \n\nSource: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/97 \n\n## Found by \n0x52\n\nThe current methodology for valuing Stable BPT is incorrect and can lead to significant over valuation of the stable BPT.\n\n## Vulnerability Detail\n\n[StableBPTOracle.sol#L48-L53](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/oracle/StableBPTOracle.sol#L48-L53)\n\n        uint256 minPrice = base.getPrice(tokens[0]);\n        for(uint256 i = 1; i != length; ++i) {\n            uint256 price = base.getPrice(tokens[i]);\n            minPrice = (price < minPrice) ? price : minPrice;\n        }\n        return minPrice.mulWadDown(pool.getRate());\n\nThe above block is used to calculate the price. Finding the min price of all assets in the pool then multiplying by the current rate of the pool. This is nearly identical to how stable curve LP is priced. Balancer pools are a bit different and this methodology is incorrect for them. Lets look at a current mainnet pool to see the problem. Take the wstETH/aETHc pool. Currently getRate() = 1.006. The lowest price is aETHc at 2,073.23. This values the LP at 2,085.66. The issue is that the LPs actual value is 1,870.67 (nearly 12% overvalued) which can be checked [here](https://app.apy.vision/pools/balancerv2_eth-wstETH-ankrETH-0xdfe6e7e18f6cc65fa13c8d8966013d4fda74b6ba).\n\nOvervaluing the LP as such can cause protocol insolvency as the borrower can overborrow against the LP, leaving the protocol with bad debt.\n\n## Impact\n\nProtocol insolvency due to overborrowing\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/oracle/StableBPTOracle.sol#L37-L54\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nStable BPT oracles need to use a new pricing methodology\n\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**0xyPhilic** commented:\n> invalid because there is no sufficient data/explanations to support the explained issue\n\n**Kral01** commented:\n> only an issue if the protocol uses this LP pair\n\n\n\n**IAm0x52**\n\nEscalate\n\nThis is not a dupe of #100. Though it focuses on a similar area of the code, the underlying issue is completely different. StableBPT is value highly incorrectly for some pools and it will cause significant damage to the protocol.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This is not a dupe of #100. Though it focuses on a similar area of the code, the underlying issue is completely different. StableBPT is value highly incorrectly for some pools and it will cause significant damage to the protocol.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Shogoki**\n\n> ing the LP as such can cause protocol insolvency as the borrower can overborrow against the LP, leaving the protocol with bad debt.\n\nYes, not a duplicate of #100 \n@Gornutz can you take a look at this?\n\n**Gornutz**\n\nConfirm this is not a duplicate of #100  \n\n**hrishibhat**\n\nResult:\nHigh \nUnique\nConsidering this a valid high issue as the wrong price is calculated and returned\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [IAm0x52](https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/97/#issuecomment-1694746948): accepted\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/104",
  "Code": [
    {
      "filename": "blueberry-core/contracts/oracle/StableBPTOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"./UsingBaseOracle.sol\";\nimport \"../interfaces/IBaseOracle.sol\";\nimport \"../interfaces/balancer/IBalancerPool.sol\";\nimport \"../interfaces/balancer/IBalancerVault.sol\";\nimport \"../libraries/FixedPointMathLib.sol\";\n\n/// @title Stable Balancer LP Oracle\n/// @author BlueberryProtocol\n/// @notice Oracle contract which privides price feeds of Stable Balancer LP tokens\ncontract StableBPTOracle is UsingBaseOracle, IBaseOracle {\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    constructor(IBaseOracle _base) UsingBaseOracle(_base) {}\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Return the USD value of given Balancer Lp, with 18 decimals of precision.\n    /// @param token The ERC-20 token to check the value.\n    function getPrice(address token) external override returns (uint256) {\n        IBalancerPool pool = IBalancerPool(token);\n        IBalancerVault vault = IBalancerVault(pool.getVault());\n\n        // Reentrancy guard to prevent flashloan attack\n        checkReentrancy(vault);\n\n        (address[] memory tokens, , ) = vault\n            .getPoolTokens(pool.getPoolId());\n\n        uint256 length = tokens.length;\n        uint256 minPrice = base.getPrice(tokens[0]);\n        for(uint256 i = 1; i != length; ++i) {\n            uint256 price = base.getPrice(tokens[i]);\n            minPrice = (price < minPrice) ? price : minPrice;\n        }\n        return minPrice.mulWadDown(pool.getRate());\n    }\n\n    /// @dev Checks for reentrancy by calling a no-op function on the Balancer Vault.\n    ///      This is a preventative measure against potential reentrancy attacks.\n    /// @param vault The Balancer Vault contract instance.\n    function checkReentrancy(IBalancerVault vault) internal {\n        vault.manageUserBalance(new IBalancerVault.UserBalanceOp[](0));\n    }\n}"
    },
    {
      "filename": "blueberry-core/contracts/oracle/StableBPTOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"./UsingBaseOracle.sol\";\nimport \"../interfaces/IBaseOracle.sol\";\nimport \"../interfaces/balancer/IBalancerPool.sol\";\nimport \"../interfaces/balancer/IBalancerVault.sol\";\nimport \"../libraries/FixedPointMathLib.sol\";\n\n/// @title Stable Balancer LP Oracle\n/// @author BlueberryProtocol\n/// @notice Oracle contract which privides price feeds of Stable Balancer LP tokens\ncontract StableBPTOracle is UsingBaseOracle, IBaseOracle {\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    constructor(IBaseOracle _base) UsingBaseOracle(_base) {}\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Return the USD value of given Balancer Lp, with 18 decimals of precision.\n    /// @param token The ERC-20 token to check the value.\n    function getPrice(address token) external override returns (uint256) {\n        IBalancerPool pool = IBalancerPool(token);\n        IBalancerVault vault = IBalancerVault(pool.getVault());\n\n        // Reentrancy guard to prevent flashloan attack\n        checkReentrancy(vault);\n\n        (address[] memory tokens, , ) = vault\n            .getPoolTokens(pool.getPoolId());\n\n        uint256 length = tokens.length;\n        uint256 minPrice = base.getPrice(tokens[0]);\n        for(uint256 i = 1; i != length; ++i) {\n            uint256 price = base.getPrice(tokens[i]);\n            minPrice = (price < minPrice) ? price : minPrice;\n        }\n        return minPrice.mulWadDown(pool.getRate());\n    }\n\n    /// @dev Checks for reentrancy by calling a no-op function on the Balancer Vault.\n    ///      This is a preventative measure against potential reentrancy attacks.\n    /// @param vault The Balancer Vault contract instance.\n    function checkReentrancy(IBalancerVault vault) internal {\n        vault.manageUserBalance(new IBalancerVault.UserBalanceOp[](0));\n    }\n}"
    }
  ]
}