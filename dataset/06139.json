{
  "Title": "[L-07] `LensHub` contract cannot be unpaused if emergency admin and governance is the same address",
  "Content": "\nIn `GovernanceLib.sol`, the `setState()` function is used by both the emergency admin and governance to change the state of the contract:\n\n[GovernanceLib.sol#L50-L60](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/GovernanceLib.sol#L50-L60)\n\n```solidity\n    function setState(Types.ProtocolState newState) external {\n        // NOTE: This does not follow the CEI-pattern, but there is no interaction and this allows to abstract `_setState` logic.\n        Types.ProtocolState prevState = _setState(newState);\n        // If the sender is the emergency admin, prevent them from reducing restrictions.\n        if (msg.sender == StorageLib.getEmergencyAdmin()) {\n            if (newState <= prevState) {\n                revert Errors.EmergencyAdminCanOnlyPauseFurther();\n            }\n        } else if (msg.sender != StorageLib.getGovernance()) {\n            revert Errors.NotGovernanceOrEmergencyAdmin();\n        }\n```\n\nAs seen from above, the emergency admin can only pause further, whereas governance can set any state. \n\nHowever, if emergency admin and governance happens to be the same address, `msg.sender == StorageLib.getEmergencyAdmin()` will always be true, which only allows the system to be paused further. This could become a problem if Lens Protocol decides to set both to the same address.\n\n### Recommendation\n\nConsider making the following change to the if-statement:\n\n[GovernanceLib.sol#L50-L60](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/GovernanceLib.sol#L50-L60)\n\n```diff\n    function setState(Types.ProtocolState newState) external {\n        // NOTE: This does not follow the CEI-pattern, but there is no interaction and this allows to abstract `_setState` logic.\n        Types.ProtocolState prevState = _setState(newState);\n        // If the sender is the emergency admin, prevent them from reducing restrictions.\n-       if (msg.sender == StorageLib.getEmergencyAdmin()) {\n+       if (msg.sender != StorageLib.getGovernance() && msg.sender == StorageLib.getEmergencyAdmin()) {\n-           if (newState <= prevState) {\n-               revert Errors.EmergencyAdminCanOnlyPauseFurther();\n-           }\n-       } else if (msg.sender != StorageLib.getGovernance()) {\n-           revert Errors.NotGovernanceOrEmergencyAdmin();\n-       }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-07-lens",
  "Code": [
    {
      "filename": "contracts/libraries/GovernanceLib.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {Types} from 'contracts/libraries/constants/Types.sol';\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\nimport {StorageLib} from 'contracts/libraries/StorageLib.sol';\nimport {Events} from 'contracts/libraries/constants/Events.sol';\n\nlibrary GovernanceLib {\n    /**\n     * @notice Sets the governance address.\n     *\n     * @param newGovernance The new governance address to set.\n     */\n    function setGovernance(address newGovernance) external {\n        address prevGovernance = StorageLib.getGovernance();\n        StorageLib.setGovernance(newGovernance);\n        emit Events.GovernanceSet(msg.sender, prevGovernance, newGovernance, block.timestamp);\n    }\n\n    /**\n     * @notice Sets the emergency admin address.\n     *\n     * @param newEmergencyAdmin The new governance address to set.\n     */\n    function setEmergencyAdmin(address newEmergencyAdmin) external {\n        address prevEmergencyAdmin = StorageLib.getEmergencyAdmin();\n        StorageLib.setEmergencyAdmin(newEmergencyAdmin);\n        emit Events.EmergencyAdminSet(msg.sender, prevEmergencyAdmin, newEmergencyAdmin, block.timestamp);\n    }\n\n    /**\n     * @notice Sets the protocol state, only meant to be called at initialization since\n     * this does not validate the caller.\n     *\n     * @param newState The new protocol state to set.\n     */\n    function initState(Types.ProtocolState newState) external {\n        _setState(newState);\n    }\n\n    /**\n     * @notice Sets the protocol state and validates the caller. The emergency admin can only\n     * pause further (Unpaused => PublishingPaused => Paused). Whereas governance can set any\n     * state.\n     *\n     * @param newState The new protocol state to set.\n     */\n    function setState(Types.ProtocolState newState) external {\n        // NOTE: This does not follow the CEI-pattern, but there is no interaction and this allows to abstract `_setState` logic.\n        Types.ProtocolState prevState = _setState(newState);\n        // If the sender is the emergency admin, prevent them from reducing restrictions.\n        if (msg.sender == StorageLib.getEmergencyAdmin()) {\n            if (newState <= prevState) {\n                revert Errors.EmergencyAdminCanOnlyPauseFurther();\n            }\n        } else if (msg.sender != StorageLib.getGovernance()) {\n            revert Errors.NotGovernanceOrEmergencyAdmin();\n        }\n        emit Events.StateSet(msg.sender, prevState, newState, block.timestamp);\n    }\n\n    function _setState(Types.ProtocolState newState) private returns (Types.ProtocolState) {\n        Types.ProtocolState prevState = StorageLib.getState();\n        StorageLib.setState(newState);\n        emit Events.StateSet(msg.sender, prevState, newState, block.timestamp);\n        return prevState;\n    }\n\n    function whitelistProfileCreator(address profileCreator, bool whitelist) external {\n        StorageLib.profileCreatorWhitelisted()[profileCreator] = whitelist;\n        emit Events.ProfileCreatorWhitelisted(profileCreator, whitelist, block.timestamp);\n    }\n\n    function whitelistFollowModule(address followModule, bool whitelist) external {\n        StorageLib.followModuleWhitelisted()[followModule] = whitelist;\n        emit Events.FollowModuleWhitelisted(followModule, whitelist, block.timestamp);\n    }\n\n    function whitelistReferenceModule(address referenceModule, bool whitelist) external {\n        StorageLib.referenceModuleWhitelisted()[referenceModule] = whitelist;\n        emit Events.ReferenceModuleWhitelisted(referenceModule, whitelist, block.timestamp);\n    }\n\n    function whitelistActionModule(address actionModule, bool whitelist) external {\n        Types.ActionModuleWhitelistData memory actionModuleWhitelistData = StorageLib.actionModuleWhitelistData()[\n            actionModule\n        ];\n\n        uint256 id;\n        if (actionModuleWhitelistData.id == 0) {\n            // The action module with the given address wasn't whitelisted before, a new ID is assigned to it.\n            if (!whitelist) {\n                revert Errors.NotWhitelisted();\n            }\n            id = StorageLib.incrementMaxActionModuleIdUsed();\n\n            StorageLib.actionModuleWhitelistData()[actionModule] = Types.ActionModuleWhitelistData(\n                uint248(id),\n                whitelist\n            );\n            StorageLib.actionModuleById()[id] = actionModule;\n        } else {\n            // The action module with the given address was already whitelisted before, it has an ID already assigned.\n            StorageLib.actionModuleWhitelistData()[actionModule].isWhitelisted = whitelist;\n            id = actionModuleWhitelistData.id;\n        }\n        emit Events.ActionModuleWhitelisted(actionModule, id, whitelist, block.timestamp);\n    }\n}"
    },
    {
      "filename": "contracts/libraries/GovernanceLib.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {Types} from 'contracts/libraries/constants/Types.sol';\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\nimport {StorageLib} from 'contracts/libraries/StorageLib.sol';\nimport {Events} from 'contracts/libraries/constants/Events.sol';\n\nlibrary GovernanceLib {\n    /**\n     * @notice Sets the governance address.\n     *\n     * @param newGovernance The new governance address to set.\n     */\n    function setGovernance(address newGovernance) external {\n        address prevGovernance = StorageLib.getGovernance();\n        StorageLib.setGovernance(newGovernance);\n        emit Events.GovernanceSet(msg.sender, prevGovernance, newGovernance, block.timestamp);\n    }\n\n    /**\n     * @notice Sets the emergency admin address.\n     *\n     * @param newEmergencyAdmin The new governance address to set.\n     */\n    function setEmergencyAdmin(address newEmergencyAdmin) external {\n        address prevEmergencyAdmin = StorageLib.getEmergencyAdmin();\n        StorageLib.setEmergencyAdmin(newEmergencyAdmin);\n        emit Events.EmergencyAdminSet(msg.sender, prevEmergencyAdmin, newEmergencyAdmin, block.timestamp);\n    }\n\n    /**\n     * @notice Sets the protocol state, only meant to be called at initialization since\n     * this does not validate the caller.\n     *\n     * @param newState The new protocol state to set.\n     */\n    function initState(Types.ProtocolState newState) external {\n        _setState(newState);\n    }\n\n    /**\n     * @notice Sets the protocol state and validates the caller. The emergency admin can only\n     * pause further (Unpaused => PublishingPaused => Paused). Whereas governance can set any\n     * state.\n     *\n     * @param newState The new protocol state to set.\n     */\n    function setState(Types.ProtocolState newState) external {\n        // NOTE: This does not follow the CEI-pattern, but there is no interaction and this allows to abstract `_setState` logic.\n        Types.ProtocolState prevState = _setState(newState);\n        // If the sender is the emergency admin, prevent them from reducing restrictions.\n        if (msg.sender == StorageLib.getEmergencyAdmin()) {\n            if (newState <= prevState) {\n                revert Errors.EmergencyAdminCanOnlyPauseFurther();\n            }\n        } else if (msg.sender != StorageLib.getGovernance()) {\n            revert Errors.NotGovernanceOrEmergencyAdmin();\n        }\n        emit Events.StateSet(msg.sender, prevState, newState, block.timestamp);\n    }\n\n    function _setState(Types.ProtocolState newState) private returns (Types.ProtocolState) {\n        Types.ProtocolState prevState = StorageLib.getState();\n        StorageLib.setState(newState);\n        emit Events.StateSet(msg.sender, prevState, newState, block.timestamp);\n        return prevState;\n    }\n\n    function whitelistProfileCreator(address profileCreator, bool whitelist) external {\n        StorageLib.profileCreatorWhitelisted()[profileCreator] = whitelist;\n        emit Events.ProfileCreatorWhitelisted(profileCreator, whitelist, block.timestamp);\n    }\n\n    function whitelistFollowModule(address followModule, bool whitelist) external {\n        StorageLib.followModuleWhitelisted()[followModule] = whitelist;\n        emit Events.FollowModuleWhitelisted(followModule, whitelist, block.timestamp);\n    }\n\n    function whitelistReferenceModule(address referenceModule, bool whitelist) external {\n        StorageLib.referenceModuleWhitelisted()[referenceModule] = whitelist;\n        emit Events.ReferenceModuleWhitelisted(referenceModule, whitelist, block.timestamp);\n    }\n\n    function whitelistActionModule(address actionModule, bool whitelist) external {\n        Types.ActionModuleWhitelistData memory actionModuleWhitelistData = StorageLib.actionModuleWhitelistData()[\n            actionModule\n        ];\n\n        uint256 id;\n        if (actionModuleWhitelistData.id == 0) {\n            // The action module with the given address wasn't whitelisted before, a new ID is assigned to it.\n            if (!whitelist) {\n                revert Errors.NotWhitelisted();\n            }\n            id = StorageLib.incrementMaxActionModuleIdUsed();\n\n            StorageLib.actionModuleWhitelistData()[actionModule] = Types.ActionModuleWhitelistData(\n                uint248(id),\n                whitelist\n            );\n            StorageLib.actionModuleById()[id] = actionModule;\n        } else {\n            // The action module with the given address was already whitelisted before, it has an ID already assigned.\n            StorageLib.actionModuleWhitelistData()[actionModule].isWhitelisted = whitelist;\n            id = actionModuleWhitelistData.id;\n        }\n        emit Events.ActionModuleWhitelisted(actionModule, id, whitelist, block.timestamp);\n    }\n}"
    }
  ]
}