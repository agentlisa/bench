{
  "Title": "[M-03] Calls To `Swivel.initiate()` Do Not Verify `o.exit` or `o.vault` Allowing An Attacker To Manipulate Accounting In Their Favour",
  "Content": "_Submitted by kirk-baird_\n\nSwivel `lend()` does not validate the `o.exit` and `o.vault` for each order before making the external call to Swivel. These values determine which internal functions is [called in Swivel](https://github.com/Swivel-Finance/swivel/blob/2471ea5cda53568df5e5515153c6962f151bf358/contracts/v2/swivel/Swivel.sol#L64-L77).\n\nThe intended code path is `initiateZcTokenFillingVaultInitiate()` which takes the underlying tokens and mints zcTokens to the `Lender`. If one of the other functions is called the accounting in `lend()`. Swivel may transfer more tokens from `Lender` to `Swivel` than paid for by the caller of `lend()`.\n\nThe impact is that underlying tokens may be stolen from `Lender`.\n\n### Proof of Concept\n\nConsider the example where [initiateZcTokenFillingZcTokenExit()](https://github.com/Swivel-Finance/swivel/blob/2471ea5cda53568df5e5515153c6962f151bf358/contracts/v2/swivel/Swivel.sol#L162) is called. This will transfer `a - premiumFilled + fee` from `Lender` to `Swivel` rather than the expected `a + fee`.\n\n### Recommended Mitigation Steps\n\nIn `lend()` restrict the values of `o.exit` and `o.vault` so only one case can be triggered in `Swivel.initiate()`.\n\n**[sourabhmarathe (Illuminate) commented](https://github.com/code-423n4/2022-06-illuminate-findings/issues/93#issuecomment-1170106132):**\n > While it is true that a user could get better execution by submitting certain orders, we don't think this is a problem. Invalid orders would be rejected by Swivel, and users should be free to execute the best possible orders.\n\n**[JTraversa (Illuminate) confirmed, but disagreed wtih severity and commented](https://github.com/code-423n4/2022-06-illuminate-findings/issues/93#issuecomment-1172933061):**\n > So reviewing this, there is an issue though it may not be high-risk.\n> \n> The user *can* manipulate the method by sending it an order that is not the correct type to go down the intended order path.\n> \n> That said, the result on line [297](https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L297) is still that the calculated lent value is sent to the contract.\n> \n> So the result is that the user inputting this manipulation actually still pays for their iPTs, and their underlying just sits in lender.sol until maturity with no personal benefit. The attack would none-the-less leak value and with that in mind I'd probably just drop it down to medium?\n\n**[gzeoneth (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-illuminate-findings/issues/93#issuecomment-1186218223):**\n > Judging as Med Risk as no fund is lost (after maturity).\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-06-illuminate",
  "Code": [
    {
      "filename": "contracts/v2/swivel/Swivel.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.4;\n\nimport './Interfaces.sol';\nimport './Hash.sol';\nimport './Sig.sol';\nimport './Safe.sol';\n\ncontract Swivel {\n  /// @dev maps the key of an order to a boolean indicating if an order was cancelled\n  mapping (bytes32 => bool) public cancelled;\n  /// @dev maps the key of an order to an amount representing its taken volume\n  mapping (bytes32 => uint256) public filled;\n  /// @dev maps a token address to a point in time, a hold, after which a withdrawal can be made\n  mapping (address => uint256) public withdrawals;\n\n  string constant public NAME = 'Swivel Finance';\n  string constant public VERSION = '2.0.0';\n  uint256 constant public HOLD = 3 days;\n  bytes32 public immutable domain;\n  address public immutable marketPlace;\n  address public admin;\n  uint16 constant public MIN_FEENOMINATOR = 33;\n  /// @dev holds the fee demoninators for [zcTokenInitiate, zcTokenExit, vaultInitiate, vaultExit]\n  uint16[4] public feenominators;\n\n  /// @notice Emitted on order cancellation\n  event Cancel (bytes32 indexed key, bytes32 hash);\n  /// @notice Emitted on any initiate*\n  /// @dev filled is 'principalFilled' when (vault:false, exit:false) && (vault:true, exit:true)\n  /// @dev filled is 'premiumFilled' when (vault:true, exit:false) && (vault:false, exit:true)\n  event Initiate(bytes32 indexed key, bytes32 hash, address indexed maker, bool vault, bool exit, address indexed sender, uint256 amount, uint256 filled);\n  /// @notice Emitted on any exit*\n  /// @dev filled is 'principalFilled' when (vault:false, exit:false) && (vault:true, exit:true)\n  /// @dev filled is 'premiumFilled' when (vault:true, exit:false) && (vault:false, exit:true)\n  event Exit(bytes32 indexed key, bytes32 hash, address indexed maker, bool vault, bool exit, address indexed sender, uint256 amount, uint256 filled);\n  /// @notice Emitted on token withdrawal scheduling\n  event ScheduleWithdrawal(address indexed token, uint256 hold);\n  /// @notice Emitted on token withdrawal blocking\n  event BlockWithdrawal(address indexed token);\n  /// @notice Emitted on a change to the feenominators array\n  event SetFee(uint256 indexed index, uint256 indexed feenominator);\n\n  /// @param m deployed MarketPlace contract address\n  constructor(address m) {\n    admin = msg.sender;\n    domain = Hash.domain(NAME, VERSION, block.chainid, address(this));\n    marketPlace = m;\n    feenominators = [200, 600, 400, 200];\n  }\n\n  // ********* INITIATING *************\n\n  /// @notice Allows a user to initiate a position\n  /// @param o Array of offline Swivel.Orders\n  /// @param a Array of order volume (principal) amounts relative to passed orders\n  /// @param c Array of Components from valid ECDSA signatures\n  function initiate(Hash.Order[] calldata o, uint256[] calldata a, Sig.Components[] calldata c) external returns (bool) {\n    uint256 len = o.length;\n    // for each order filled, routes the order to the right interaction depending on its params\n    for (uint256 i; i < len; i++) {\n      Hash.Order memory order = o[i];\n      if (!order.exit) {\n        if (!order.vault) {\n          initiateVaultFillingZcTokenInitiate(o[i], a[i], c[i]);\n        } else {\n          initiateZcTokenFillingVaultInitiate(o[i], a[i], c[i]);\n        }\n      } else {\n        if (!order.vault) {\n          initiateZcTokenFillingZcTokenExit(o[i], a[i], c[i]);\n        } else {\n          initiateVaultFillingVaultExit(o[i], a[i], c[i]);\n        }\n      }\n    }\n\n    return true;\n  }\n\n  /// @notice Allows a user to initiate a Vault by filling an offline zcToken initiate order\n  /// @dev This method should pass (underlying, maturity, maker, sender, principalFilled) to MarketPlace.custodialInitiate\n  /// @param o Order being filled\n  /// @param a Amount of volume (premium) being filled by the taker's initiate\n  /// @param c Components of a valid ECDSA signature\n  function initiateVaultFillingZcTokenInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    // checks order signature, order cancellation and order expiry\n    bytes32 hash = validOrderHash(o, c);\n\n    // checks the side, and the amount compared to available\n    require((a + filled[hash]) <= o.premium, 'taker amount > available volume');\n    \n    filled[hash] += a;\n\n    // transfer underlying tokens\n    Erc20 uToken = Erc20(o.underlying);\n    Safe.transferFrom(uToken, msg.sender, o.maker, a);\n\n    uint256 principalFilled = (a * o.principal) / o.premium;\n    Safe.transferFrom(uToken, o.maker, address(this), principalFilled);\n\n    MarketPlace mPlace = MarketPlace(marketPlace);\n    // mint tokens\n    require(CErc20(mPlace.cTokenAddress(o.underlying, o.maturity)).mint(principalFilled) == 0, 'minting CToken failed');\n    // alert marketplace\n    require(mPlace.custodialInitiate(o.underlying, o.maturity, o.maker, msg.sender, principalFilled), 'custodial initiate failed');\n\n    // transfer fee in vault notional to swivel (from msg.sender)\n    uint256 fee = principalFilled / feenominators[2];\n    require(mPlace.transferVaultNotionalFee(o.underlying, o.maturity, msg.sender, fee), 'notional fee transfer failed');\n\n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);\n  }\n\n  /// @notice Allows a user to initiate a zcToken by filling an offline vault initiate order\n  /// @dev This method should pass (underlying, maturity, sender, maker, a) to MarketPlace.custodialInitiate\n  /// @param o Order being filled\n  /// @param a Amount of volume (principal) being filled by the taker's initiate\n  /// @param c Components of a valid ECDSA signature\n  function initiateZcTokenFillingVaultInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n\n    require((a + filled[hash]) <= o.principal, 'taker amount > available volume');\n\n    filled[hash] += a;\n\n    Erc20 uToken = Erc20(o.underlying);\n\n    uint256 premiumFilled = (a * o.premium) / o.principal;\n    Safe.transferFrom(uToken, o.maker, msg.sender, premiumFilled);\n\n    // transfer principal + fee in underlying to swivel (from sender)\n    uint256 fee = premiumFilled / feenominators[0];\n    Safe.transferFrom(uToken, msg.sender, address(this), (a + fee));\n\n    MarketPlace mPlace = MarketPlace(marketPlace);\n    // mint tokens\n    require(CErc20(mPlace.cTokenAddress(o.underlying, o.maturity)).mint(a) == 0, 'minting CToken Failed');\n    // alert marketplace \n    require(mPlace.custodialInitiate(o.underlying, o.maturity, msg.sender, o.maker, a), 'custodial initiate failed');\n\n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\n  }\n\n  /// @notice Allows a user to initiate zcToken? by filling an offline zcToken exit order\n  /// @dev This method should pass (underlying, maturity, maker, sender, a) to MarketPlace.p2pZcTokenExchange\n  /// @param o Order being filled\n  /// @param a Amount of volume (principal) being filled by the taker's initiate \n  /// @param c Components of a valid ECDSA signature\n  function initiateZcTokenFillingZcTokenExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n\n    require((a + filled[hash]) <= o.principal, 'taker amount > available volume');\n\n    filled[hash] += a;\n\n    uint256 premiumFilled = (a * o.premium) / o.principal;\n\n    Erc20 uToken = Erc20(o.underlying);\n    // transfer underlying tokens, then take fee\n    Safe.transferFrom(uToken, msg.sender, o.maker, a - premiumFilled);\n\n    uint256 fee = premiumFilled / feenominators[0];\n    Safe.transferFrom(uToken, msg.sender, address(this), fee);\n\n    // alert marketplace\n    require(MarketPlace(marketPlace).p2pZcTokenExchange(o.underlying, o.maturity, o.maker, msg.sender, a), 'zcToken exchange failed');\n            \n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\n  }\n\n  /// @notice Allows a user to initiate a Vault by filling an offline vault exit order\n  /// @dev This method should pass (underlying, maturity, maker, sender, principalFilled) to MarketPlace.p2pVaultExchange\n  /// @param o Order being filled\n  /// @param a Amount of volume (interest) being filled by the taker's exit\n  /// @param c Components of a valid ECDSA signature\n  function initiateVaultFillingVaultExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n\n    require((a + filled[hash]) <= o.premium, 'taker amount > available volume');\n\n    filled[hash] += a;\n\n    Safe.transferFrom(Erc20(o.underlying), msg.sender, o.maker, a);\n\n    MarketPlace mPlace = MarketPlace(marketPlace);\n    uint256 principalFilled = (a * o.principal) / o.premium;\n    // alert marketplace\n    require(mPlace.p2pVaultExchange(o.underlying, o.maturity, o.maker, msg.sender, principalFilled), 'vault exchange failed');\n\n    // transfer fee (in vault notional) to swivel\n    uint256 fee = principalFilled / feenominators[2];\n    require(mPlace.transferVaultNotionalFee(o.underlying, o.maturity, msg.sender, fee), \"notional fee transfer failed\");\n\n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);\n  }\n\n  // ********* EXITING ***************\n\n  /// @notice Allows a user to exit (sell) a currently held position to the marketplace.\n  /// @param o Array of offline Swivel.Orders\n  /// @param a Array of order volume (principal) amounts relative to passed orders\n  /// @param c Components of a valid ECDSA signature\n  function exit(Hash.Order[] calldata o, uint256[] calldata a, Sig.Components[] calldata c) external returns (bool) {\n    uint256 len = o.length;\n    // for each order filled, routes the order to the right interaction depending on its params\n    for (uint256 i; i < len; i++) {\n      Hash.Order memory order = o[i];\n      // if the order being filled is not an exit\n      if (!order.exit) {\n        // if the order being filled is a vault initiate or a zcToken initiate\n          if (!order.vault) {\n            // if filling a zcToken initiate with an exit, one is exiting zcTokens\n            exitZcTokenFillingZcTokenInitiate(o[i], a[i], c[i]);\n          } else {\n            // if filling a vault initiate with an exit, one is exiting vault notional\n            exitVaultFillingVaultInitiate(o[i], a[i], c[i]);\n          }\n      } else {\n        // if the order being filled is a vault exit or a zcToken exit\n        if (!order.vault) {\n          // if filling a zcToken exit with an exit, one is exiting vault\n          exitVaultFillingZcTokenExit(o[i], a[i], c[i]);\n        } else {\n          // if filling a vault exit with an exit, one is exiting zcTokens\n          exitZcTokenFillingVaultExit(o[i], a[i], c[i]);\n        }   \n      }   \n    }\n\n    return true;\n  }\n\n  /// @notice Allows a user to exit their zcTokens by filling an offline zcToken initiate order\n  /// @dev This method should pass (underlying, maturity, sender, maker, principalFilled) to MarketPlace.p2pZcTokenExchange\n  /// @param o Order being filled\n  /// @param a Amount of volume (interest) being filled by the taker's exit\n  /// @param c Components of a valid ECDSA signature\n  function exitZcTokenFillingZcTokenInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n\n    require((a + filled[hash]) <= o.premium, 'taker amount > available volume');\n\n    filled[hash] += a;       \n\n    Erc20 uToken = Erc20(o.underlying);\n\n    uint256 principalFilled = (a * o.principal) / o.premium;\n    // transfer underlying from initiating party to exiting party, minus the price the exit party pays for the exit (premium), and the fee.\n    Safe.transferFrom(uToken, o.maker, msg.sender, principalFilled - a);\n\n    // transfer fee in underlying to swivel\n    uint256 fee = principalFilled / feenominators[1];\n    Safe.transferFrom(uToken, o.maker, address(this), fee);\n\n    // alert marketplace\n    require(MarketPlace(marketPlace).p2pZcTokenExchange(o.underlying, o.maturity, msg.sender, o.maker, principalFilled), 'zcToken exchange failed');\n\n    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);\n  }\n  \n  /// @notice Allows a user to exit their Vault by filling an offline vault initiate order\n  /// @dev This method should pass (underlying, maturity, sender, maker, a) to MarketPlace.p2pVaultExchange\n  /// @param o Order being filled\n  /// @param a Amount of volume (principal) being filled by the taker's exit\n  /// @param c Components of a valid ECDSA signature\n  function exitVaultFillingVaultInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n\n    require((a + filled[hash]) <= o.principal, 'taker amount > available volume');\n    \n    filled[hash] += a;\n        \n    Erc20 uToken = Erc20(o.underlying);\n\n    // transfer premium from maker to sender\n    uint256 premiumFilled = (a * o.premium) / o.principal;\n    Safe.transferFrom(uToken, o.maker, msg.sender, premiumFilled);\n\n    uint256 fee = premiumFilled / feenominators[3];\n    // transfer fee in underlying to swivel from sender\n    Safe.transferFrom(uToken, msg.sender, address(this), fee);\n\n    // transfer <a> notional from sender to maker\n    require(MarketPlace(marketPlace).p2pVaultExchange(o.underlying, o.maturity, msg.sender, o.maker, a), 'vault exchange failed');\n\n    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\n  }\n\n  /// @notice Allows a user to exit their Vault filling an offline zcToken exit order\n  /// @dev This method should pass (underlying, maturity, maker, sender, a) to MarketPlace.exitFillingExit\n  /// @param o Order being filled\n  /// @param a Amount of volume (principal) being filled by the taker's exit\n  /// @param c Components of a valid ECDSA signature\n  function exitVaultFillingZcTokenExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n\n    require((a + filled[hash]) <= o.principal, 'taker amount > available volume');\n\n    filled[hash] += a;\n\n    // redeem underlying on Compound and burn cTokens\n    MarketPlace mPlace = MarketPlace(marketPlace);\n    address cTokenAddr = mPlace.cTokenAddress(o.underlying, o.maturity);\n    require((CErc20(cTokenAddr).redeemUnderlying(a) == 0), \"compound redemption error\");\n\n    Erc20 uToken = Erc20(o.underlying);\n    // transfer principal-premium  back to fixed exit party now that the interest coupon and zcb have been redeemed\n    uint256 premiumFilled = (a * o.premium) / o.principal;\n    Safe.transfer(uToken, o.maker, a - premiumFilled);\n\n    // transfer premium-fee to floating exit party\n    uint256 fee = premiumFilled / feenominators[3];\n    Safe.transfer(uToken, msg.sender, premiumFilled - fee);\n\n    // burn zcTokens + nTokens from o.maker and msg.sender respectively\n    require(mPlace.custodialExit(o.underlying, o.maturity, o.maker, msg.sender, a), 'custodial exit failed');\n\n    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\n  }\n\n  /// @notice Allows a user to exit their zcTokens by filling an offline vault exit order\n  /// @dev This method should pass (underlying, maturity, sender, maker, principalFilled) to MarketPlace.exitFillingExit\n  /// @param o Order being filled\n  /// @param a Amount of volume (interest) being filled by the taker's exit\n  /// @param c Components of a valid ECDSA signature\n  function exitZcTokenFillingVaultExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n\n    require((a + filled[hash]) <= o.premium, 'taker amount > available volume');\n    \n    filled[hash] += a;\n\n    // redeem underlying on Compound and burn cTokens\n    MarketPlace mPlace = MarketPlace(marketPlace);\n\n    address cTokenAddr = mPlace.cTokenAddress(o.underlying, o.maturity);\n    uint256 principalFilled = (a * o.principal) / o.premium;\n    require((CErc20(cTokenAddr).redeemUnderlying(principalFilled) == 0), \"compound redemption error\");\n\n    Erc20 uToken = Erc20(o.underlying);\n    // transfer principal-premium-fee back to fixed exit party now that the interest coupon and zcb have been redeemed\n    uint256 fee = principalFilled / feenominators[1];\n    Safe.transfer(uToken, msg.sender, principalFilled - a - fee);\n    Safe.transfer(uToken, o.maker, a);\n\n    // burn <principalFilled> zcTokens + nTokens from msg.sender and o.maker respectively\n    require(mPlace.custodialExit(o.underlying, o.maturity, msg.sender, o.maker, principalFilled), 'custodial exit failed');\n\n    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);\n  }\n\n  /// @notice Allows a user to cancel an order, preventing it from being filled in the future\n  /// @param o Order being cancelled\n  /// @param c Components of a valid ECDSA signature\n  function cancel(Hash.Order calldata o, Sig.Components calldata c) external returns (bool) {\n    bytes32 hash = validOrderHash(o, c);\n\n    require(msg.sender == o.maker, 'sender must be maker');\n\n    cancelled[hash] = true;\n\n    emit Cancel(o.key, hash);\n\n    return true;\n  }\n\n  // ********* ADMINISTRATIVE ***************\n\n  /// @param a Address of a new admin\n  function transferAdmin(address a) external authorized(admin) returns (bool) {\n    admin = a;\n\n    return true;\n  }\n\n  /// @notice Allows the admin to schedule the withdrawal of tokens\n  /// @param e Address of (erc20) token to withdraw\n  function scheduleWithdrawal(address e) external authorized(admin) returns (bool) {\n    uint256 when = block.timestamp + HOLD;\n    withdrawals[e] = when;\n\n    emit ScheduleWithdrawal(e, when);\n\n    return true;\n  }\n\n  /// @notice Emergency function to block unplanned withdrawals\n  /// @param e Address of token withdrawal to block\n  function blockWithdrawal(address e) external authorized(admin) returns (bool) {\n      withdrawals[e] = 0;\n\n      emit BlockWithdrawal(e);\n\n      return true;\n  }\n\n  /// @notice Allows the admin to withdraw the given token, provided the holding period has been observed\n  /// @param e Address of token to withdraw\n  function withdraw(address e) external authorized(admin) returns (bool) {\n    uint256 when = withdrawals[e];\n    require (when != 0, 'no withdrawal scheduled');\n\n    require (block.timestamp >= when, 'withdrawal still on hold');\n\n    withdrawals[e] = 0;\n\n    Erc20 token = Erc20(e);\n    Safe.transfer(token, admin, token.balanceOf(address(this)));\n\n    return true;\n  }\n\n  /// @notice Allows the admin to set a new fee denominator\n  /// @param i The index of the new fee denominator\n  /// @param d The new fee denominator\n  function setFee(uint16 i, uint16 d) external authorized(admin) returns (bool) {\n    require(d >= MIN_FEENOMINATOR, 'fee too high');\n\n    feenominators[i] = d;\n\n    emit SetFee(i, d);\n\n    return true;\n  }\n\n  /// @notice Allows the admin to bulk approve given compound addresses at the underlying token, saving marginal approvals\n  /// @param u array of underlying token addresses\n  /// @param c array of compound token addresses\n  function approveUnderlying(address[] calldata u, address[] calldata c) external authorized(admin) returns (bool) {\n    uint256 len = u.length;\n    require (len == c.length, 'array length mismatch');\n\n    uint256 max = 2**256 - 1;\n\n    for (uint256 i; i < len; i++) {\n      Erc20 uToken = Erc20(u[i]);\n      Safe.approve(uToken, c[i], max);\n    }\n\n    return true;\n  }\n\n  // ********* PROTOCOL UTILITY ***************\n\n  /// @notice Allows users to deposit underlying and in the process split it into/mint \n  /// zcTokens and vault notional. Calls mPlace.mintZcTokenAddingNotional\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param a Amount of underlying being deposited\n  function splitUnderlying(address u, uint256 m, uint256 a) external returns (bool) {\n    Erc20 uToken = Erc20(u);\n    Safe.transferFrom(uToken, msg.sender, address(this), a);\n    MarketPlace mPlace = MarketPlace(marketPlace);\n    require(CErc20(mPlace.cTokenAddress(u, m)).mint(a) == 0, 'minting CToken Failed');\n    require(mPlace.mintZcTokenAddingNotional(u, m, msg.sender, a), 'mint ZcToken adding Notional failed');\n\n    return true;\n  }\n\n  /// @notice Allows users deposit/burn 1-1 amounts of both zcTokens and vault notional,\n  /// in the process \"combining\" the two, and redeeming underlying. Calls mPlace.burnZcTokenRemovingNotional.\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param a Amount of zcTokens being redeemed\n  function combineTokens(address u, uint256 m, uint256 a) external returns (bool) {\n    MarketPlace mPlace = MarketPlace(marketPlace);\n    require(mPlace.burnZcTokenRemovingNotional(u, m, msg.sender, a), 'burn ZcToken removing Notional failed');\n    address cTokenAddr = mPlace.cTokenAddress(u, m);\n    require((CErc20(cTokenAddr).redeemUnderlying(a) == 0), \"compound redemption error\");\n    Safe.transfer(Erc20(u), msg.sender, a);\n\n    return true;\n  }\n\n  /// @notice Allows zcToken holders to redeem their tokens for underlying tokens after maturity has been reached (via MarketPlace).\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param a Amount of zcTokens being redeemed\n  function redeemZcToken(address u, uint256 m, uint256 a) external returns (bool) {\n    MarketPlace mPlace = MarketPlace(marketPlace);\n    // call marketplace to determine the amount redeemed\n    uint256 redeemed = mPlace.redeemZcToken(u, m, msg.sender, a);\n    // redeem underlying from compound\n    require(CErc20(mPlace.cTokenAddress(u, m)).redeemUnderlying(redeemed) == 0, 'compound redemption failed');\n    // transfer underlying back to msg.sender\n    Safe.transfer(Erc20(u), msg.sender, redeemed);\n\n    return true;\n  }\n\n  /// @notice Allows Vault owners to redeem any currently accrued interest (via MarketPlace)\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  function redeemVaultInterest(address u, uint256 m) external returns (bool) {\n    MarketPlace mPlace = MarketPlace(marketPlace);\n    // call marketplace to determine the amount redeemed\n    uint256 redeemed = mPlace.redeemVaultInterest(u, m, msg.sender);\n    // redeem underlying from compound\n    require(CErc20(mPlace.cTokenAddress(u, m)).redeemUnderlying(redeemed) == 0, 'compound redemption failed');\n    // transfer underlying back to msg.sender\n    Safe.transfer(Erc20(u), msg.sender, redeemed);\n\n    return true;\n  }\n\n  /// @notice Varifies the validity of an order and it's signature.\n  /// @param o An offline Swivel.Order\n  /// @param c Components of a valid ECDSA signature\n  /// @return the hashed order.\n  function validOrderHash(Hash.Order calldata o, Sig.Components calldata c) internal view returns (bytes32) {\n    bytes32 hash = Hash.order(o);\n\n    require(!cancelled[hash], 'order cancelled');\n    require(o.expiry >= block.timestamp, 'order expired');\n    require(o.maker == Sig.recover(Hash.message(domain, hash), c), 'invalid signature');\n\n    return hash;\n  }\n\n  modifier authorized(address a) {\n    require(msg.sender == a, 'sender must be authorized');\n    _;\n  }\n}"
    },
    {
      "filename": "contracts/v2/swivel/Swivel.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.4;\n\nimport './Interfaces.sol';\nimport './Hash.sol';\nimport './Sig.sol';\nimport './Safe.sol';\n\ncontract Swivel {\n  /// @dev maps the key of an order to a boolean indicating if an order was cancelled\n  mapping (bytes32 => bool) public cancelled;\n  /// @dev maps the key of an order to an amount representing its taken volume\n  mapping (bytes32 => uint256) public filled;\n  /// @dev maps a token address to a point in time, a hold, after which a withdrawal can be made\n  mapping (address => uint256) public withdrawals;\n\n  string constant public NAME = 'Swivel Finance';\n  string constant public VERSION = '2.0.0';\n  uint256 constant public HOLD = 3 days;\n  bytes32 public immutable domain;\n  address public immutable marketPlace;\n  address public admin;\n  uint16 constant public MIN_FEENOMINATOR = 33;\n  /// @dev holds the fee demoninators for [zcTokenInitiate, zcTokenExit, vaultInitiate, vaultExit]\n  uint16[4] public feenominators;\n\n  /// @notice Emitted on order cancellation\n  event Cancel (bytes32 indexed key, bytes32 hash);\n  /// @notice Emitted on any initiate*\n  /// @dev filled is 'principalFilled' when (vault:false, exit:false) && (vault:true, exit:true)\n  /// @dev filled is 'premiumFilled' when (vault:true, exit:false) && (vault:false, exit:true)\n  event Initiate(bytes32 indexed key, bytes32 hash, address indexed maker, bool vault, bool exit, address indexed sender, uint256 amount, uint256 filled);\n  /// @notice Emitted on any exit*\n  /// @dev filled is 'principalFilled' when (vault:false, exit:false) && (vault:true, exit:true)\n  /// @dev filled is 'premiumFilled' when (vault:true, exit:false) && (vault:false, exit:true)\n  event Exit(bytes32 indexed key, bytes32 hash, address indexed maker, bool vault, bool exit, address indexed sender, uint256 amount, uint256 filled);\n  /// @notice Emitted on token withdrawal scheduling\n  event ScheduleWithdrawal(address indexed token, uint256 hold);\n  /// @notice Emitted on token withdrawal blocking\n  event BlockWithdrawal(address indexed token);\n  /// @notice Emitted on a change to the feenominators array\n  event SetFee(uint256 indexed index, uint256 indexed feenominator);\n\n  /// @param m deployed MarketPlace contract address\n  constructor(address m) {\n    admin = msg.sender;\n    domain = Hash.domain(NAME, VERSION, block.chainid, address(this));\n    marketPlace = m;\n    feenominators = [200, 600, 400, 200];\n  }\n\n  // ********* INITIATING *************\n\n  /// @notice Allows a user to initiate a position\n  /// @param o Array of offline Swivel.Orders\n  /// @param a Array of order volume (principal) amounts relative to passed orders\n  /// @param c Array of Components from valid ECDSA signatures\n  function initiate(Hash.Order[] calldata o, uint256[] calldata a, Sig.Components[] calldata c) external returns (bool) {\n    uint256 len = o.length;\n    // for each order filled, routes the order to the right interaction depending on its params\n    for (uint256 i; i < len; i++) {\n      Hash.Order memory order = o[i];\n      if (!order.exit) {\n        if (!order.vault) {\n          initiateVaultFillingZcTokenInitiate(o[i], a[i], c[i]);\n        } else {\n          initiateZcTokenFillingVaultInitiate(o[i], a[i], c[i]);\n        }\n      } else {\n        if (!order.vault) {\n          initiateZcTokenFillingZcTokenExit(o[i], a[i], c[i]);\n        } else {\n          initiateVaultFillingVaultExit(o[i], a[i], c[i]);\n        }\n      }\n    }\n\n    return true;\n  }\n\n  /// @notice Allows a user to initiate a Vault by filling an offline zcToken initiate order\n  /// @dev This method should pass (underlying, maturity, maker, sender, principalFilled) to MarketPlace.custodialInitiate\n  /// @param o Order being filled\n  /// @param a Amount of volume (premium) being filled by the taker's initiate\n  /// @param c Components of a valid ECDSA signature\n  function initiateVaultFillingZcTokenInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    // checks order signature, order cancellation and order expiry\n    bytes32 hash = validOrderHash(o, c);\n\n    // checks the side, and the amount compared to available\n    require((a + filled[hash]) <= o.premium, 'taker amount > available volume');\n    \n    filled[hash] += a;\n\n    // transfer underlying tokens\n    Erc20 uToken = Erc20(o.underlying);\n    Safe.transferFrom(uToken, msg.sender, o.maker, a);\n\n    uint256 principalFilled = (a * o.principal) / o.premium;\n    Safe.transferFrom(uToken, o.maker, address(this), principalFilled);\n\n    MarketPlace mPlace = MarketPlace(marketPlace);\n    // mint tokens\n    require(CErc20(mPlace.cTokenAddress(o.underlying, o.maturity)).mint(principalFilled) == 0, 'minting CToken failed');\n    // alert marketplace\n    require(mPlace.custodialInitiate(o.underlying, o.maturity, o.maker, msg.sender, principalFilled), 'custodial initiate failed');\n\n    // transfer fee in vault notional to swivel (from msg.sender)\n    uint256 fee = principalFilled / feenominators[2];\n    require(mPlace.transferVaultNotionalFee(o.underlying, o.maturity, msg.sender, fee), 'notional fee transfer failed');\n\n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);\n  }\n\n  /// @notice Allows a user to initiate a zcToken by filling an offline vault initiate order\n  /// @dev This method should pass (underlying, maturity, sender, maker, a) to MarketPlace.custodialInitiate\n  /// @param o Order being filled\n  /// @param a Amount of volume (principal) being filled by the taker's initiate\n  /// @param c Components of a valid ECDSA signature\n  function initiateZcTokenFillingVaultInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n\n    require((a + filled[hash]) <= o.principal, 'taker amount > available volume');\n\n    filled[hash] += a;\n\n    Erc20 uToken = Erc20(o.underlying);\n\n    uint256 premiumFilled = (a * o.premium) / o.principal;\n    Safe.transferFrom(uToken, o.maker, msg.sender, premiumFilled);\n\n    // transfer principal + fee in underlying to swivel (from sender)\n    uint256 fee = premiumFilled / feenominators[0];\n    Safe.transferFrom(uToken, msg.sender, address(this), (a + fee));\n\n    MarketPlace mPlace = MarketPlace(marketPlace);\n    // mint tokens\n    require(CErc20(mPlace.cTokenAddress(o.underlying, o.maturity)).mint(a) == 0, 'minting CToken Failed');\n    // alert marketplace \n    require(mPlace.custodialInitiate(o.underlying, o.maturity, msg.sender, o.maker, a), 'custodial initiate failed');\n\n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\n  }\n\n  /// @notice Allows a user to initiate zcToken? by filling an offline zcToken exit order\n  /// @dev This method should pass (underlying, maturity, maker, sender, a) to MarketPlace.p2pZcTokenExchange\n  /// @param o Order being filled\n  /// @param a Amount of volume (principal) being filled by the taker's initiate \n  /// @param c Components of a valid ECDSA signature\n  function initiateZcTokenFillingZcTokenExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n\n    require((a + filled[hash]) <= o.principal, 'taker amount > available volume');\n\n    filled[hash] += a;\n\n    uint256 premiumFilled = (a * o.premium) / o.principal;\n\n    Erc20 uToken = Erc20(o.underlying);\n    // transfer underlying tokens, then take fee\n    Safe.transferFrom(uToken, msg.sender, o.maker, a - premiumFilled);\n\n    uint256 fee = premiumFilled / feenominators[0];\n    Safe.transferFrom(uToken, msg.sender, address(this), fee);\n\n    // alert marketplace\n    require(MarketPlace(marketPlace).p2pZcTokenExchange(o.underlying, o.maturity, o.maker, msg.sender, a), 'zcToken exchange failed');\n            \n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\n  }\n\n  /// @notice Allows a user to initiate a Vault by filling an offline vault exit order\n  /// @dev This method should pass (underlying, maturity, maker, sender, principalFilled) to MarketPlace.p2pVaultExchange\n  /// @param o Order being filled\n  /// @param a Amount of volume (interest) being filled by the taker's exit\n  /// @param c Components of a valid ECDSA signature\n  function initiateVaultFillingVaultExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n\n    require((a + filled[hash]) <= o.premium, 'taker amount > available volume');\n\n    filled[hash] += a;\n\n    Safe.transferFrom(Erc20(o.underlying), msg.sender, o.maker, a);\n\n    MarketPlace mPlace = MarketPlace(marketPlace);\n    uint256 principalFilled = (a * o.principal) / o.premium;\n    // alert marketplace\n    require(mPlace.p2pVaultExchange(o.underlying, o.maturity, o.maker, msg.sender, principalFilled), 'vault exchange failed');\n\n    // transfer fee (in vault notional) to swivel\n    uint256 fee = principalFilled / feenominators[2];\n    require(mPlace.transferVaultNotionalFee(o.underlying, o.maturity, msg.sender, fee), \"notional fee transfer failed\");\n\n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);\n  }\n\n  // ********* EXITING ***************\n\n  /// @notice Allows a user to exit (sell) a currently held position to the marketplace.\n  /// @param o Array of offline Swivel.Orders\n  /// @param a Array of order volume (principal) amounts relative to passed orders\n  /// @param"
    }
  ]
}