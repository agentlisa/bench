{
  "Title": "[H-02] 2 variables not indexed by `marketIndex`",
  "Content": "_Submitted by gpersoon_\n\nIn the token contract: `batched_stakerNextTokenShiftIndex` is indexed by `marketIndex`, so it can have separate (or the same) values for each different `marketIndex`.\n\n`stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping` and `stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping` are not indexed by `marketIndex`.\nSo the values of `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping` and `stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping`\ncan be overwritten by a different market, if `batched_stakerNextTokenShiftIndex[market1]`==`batched_stakerNextTokenShiftIndex[market2]`\n\nThis will lead to weird results in` _calculateAccumulatedFloat`, allocating too much or too little float.\n\n[`Staker.sol` L622](https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/Staker.sol#L622)\n```solidity\nfunction pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n    ...\n      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[ batched_stakerNextTokenShiftIndex[marketIndex]  ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;\n      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[  batched_stakerNextTokenShiftIndex[marketIndex]  ] = latestRewardIndex[marketIndex] + 1;\n      batched_stakerNextTokenShiftIndex[marketIndex] += 1;\n...\n)\n```\n\nRecommend adding an index with `marketIndex` to the variables:\n- `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping`\n- `stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping`\n\nAlso consider shortening the variable names, this way mistakes can be spotted easier.\n\nConfirmed by Jason of Float Capital: Yes, you are totally right, it should use the `marketIndex` since they are specific per market!\n\n**[JasoonS (Float) confirmed](https://github.com/code-423n4/2021-08-floatcapital-findings/issues/8#issuecomment-895999895):**\n > :see_no_evil: Embarrassed by this one!\n>\n> Thank you for the report.\n>\n> Fixed!!\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2021-08-floatcapital",
  "Code": [
    {
      "filename": "contracts/contracts/Staker.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol\";\n\nimport \"./interfaces/IFloatToken.sol\";\nimport \"./interfaces/ILongShort.sol\";\nimport \"./interfaces/IStaker.sol\";\nimport \"./interfaces/ISyntheticToken.sol\";\n\ncontract Staker is IStaker, Initializable {\n  /*╔═════════════════════════════╗\n    ║          VARIABLES          ║\n    ╚═════════════════════════════╝*/\n\n  /* ══════ Fixed-precision constants ══════ */\n  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;\n  // 2^52 ~= 4.5e15\n  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)\n  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error\n  uint256 public constant safeExponentBitShifting = 52;\n\n  /* ══════ Global state ══════ */\n  address public admin;\n  address public floatCapital;\n  address public floatTreasury;\n  uint256 public floatPercentage;\n\n  address public longShort;\n  address public floatToken;\n\n  /* ══════ Market specific ══════ */\n  mapping(uint32 => uint256) public marketLaunchIncentive_period; // seconds\n  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; // e18 scale\n  mapping(uint32 => uint256) public marketUnstakeFee_e18;\n  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;\n  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;\n\n  mapping(uint32 => mapping(bool => address)) public syntheticTokens;\n\n  mapping(address => uint32) public marketIndexOfToken;\n\n  /* ══════ Reward specific ══════ */\n  mapping(uint32 => uint256) public latestRewardIndex;\n  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))\n    public accumulativeFloatPerSyntheticTokenSnapshots;\n  struct AccumulativeIssuancePerStakedSynthSnapshot {\n    uint256 timestamp;\n    uint256 accumulativeFloatPerSyntheticToken_long;\n    uint256 accumulativeFloatPerSyntheticToken_short;\n  }\n\n  /* ══════ User specific ══════ */\n  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;\n  mapping(address => mapping(address => uint256)) public userAmountStaked;\n\n  /* ══════ Token shift management specific ══════ */\n  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;\n  /**\n  @notice Used to link a token shift to a staker state\n  @dev tokenShiftIndex => accumulativeFloatIssuanceSnapshotIndex\n    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.\n  */\n  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;\n  /// @notice Used to fetch the price from LongShort at that point in time\n  /// @dev tokenShiftIndex => longShortMarketPriceSnapshotIndex\n  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;\n  /// @dev marketIndex => usersAddress => stakerTokenShiftIndex\n  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;\n  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromLongOnNextUpdate\n  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;\n  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromShortOnNextUpdate\n  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;\n\n  /*╔════════════════════════════╗\n    ║           EVENTS           ║\n    ╚════════════════════════════╝*/\n\n  event StakerV1(\n    address admin,\n    address floatTreasury,\n    address floatCapital,\n    address floatToken,\n    uint256 floatPercentage\n  );\n\n  event MarketAddedToStaker(\n    uint32 marketIndex,\n    uint256 exitFee_e18,\n    uint256 period,\n    uint256 multiplier,\n    uint256 balanceIncentiveExponent,\n    int256 balanceIncentiveEquilibriumOffset\n  );\n\n  event AccumulativeIssuancePerStakedSynthSnapshotCreated(\n    uint32 marketIndex,\n    uint256 accumulativeFloatIssuanceSnapshotIndex,\n    uint256 accumulativeLong,\n    uint256 accumulativeShort\n  );\n\n  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);\n\n  event StakeWithdrawn(address user, address token, uint256 amount);\n\n  // Note: the `amountFloatMinted` isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.\n  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);\n\n  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);\n\n  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);\n\n  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);\n\n  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);\n\n  event FloatPercentageUpdated(uint256 floatPercentage);\n\n  event SyntheticTokensShifted();\n\n  event ChangeAdmin(address newAdmin);\n\n  /*╔═════════════════════════════╗\n    ║          MODIFIERS          ║\n    ╚═════════════════════════════╝*/\n\n  function onlyAdminModifierLogic() internal virtual {\n    require(msg.sender == admin, \"not admin\");\n  }\n\n  modifier onlyAdmin() {\n    onlyAdminModifierLogic();\n    _;\n  }\n\n  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {\n    require(marketIndexOfToken[_synth] != 0, \"not valid synth\");\n  }\n\n  modifier onlyValidSynthetic(address _synth) {\n    onlyValidSyntheticModifierLogic(_synth);\n    _;\n  }\n\n  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {\n    require(address(syntheticTokens[marketIndex][true]) != address(0), \"not valid market\");\n  }\n\n  modifier onlyValidMarket(uint32 marketIndex) {\n    onlyValidMarketModifierLogic(marketIndex);\n    _;\n  }\n\n  function onlyLongShortModifierLogic() internal virtual {\n    require(msg.sender == address(longShort), \"not long short\");\n  }\n\n  modifier onlyLongShort() {\n    onlyLongShortModifierLogic();\n    _;\n  }\n\n  /*╔═════════════════════════════╗\n    ║       CONTRACT SET-UP       ║\n    ╚═════════════════════════════╝*/\n\n  /**\n  @notice Initializes the contract.\n  @dev Calls OpenZeppelin's initializer modifier.\n  @param _admin Address of the admin role.\n  @param _longShort Address of the LongShort contract, a deployed LongShort.sol\n  @param _floatToken Address of the Float token earned by staking.\n  @param _floatTreasury Address of the treasury contract for managing fees.\n  @param _floatCapital Address of the contract which earns a fixed percentage of Float.\n  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.\n  */\n  function initialize(\n    address _admin,\n    address _longShort,\n    address _floatToken,\n    address _floatTreasury,\n    address _floatCapital,\n    uint256 _floatPercentage\n  ) external virtual initializer {\n    admin = _admin;\n    floatCapital = _floatCapital;\n    floatTreasury = _floatTreasury;\n    longShort = _longShort;\n    floatToken = _floatToken;\n\n    _changeFloatPercentage(_floatPercentage);\n\n    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);\n  }\n\n  /*╔═══════════════════╗\n    ║       ADMIN       ║\n    ╚═══════════════════╝*/\n\n  /** \n  @notice Changes admin for the contract\n  @param _admin The address of the new admin.\n  */\n  function changeAdmin(address _admin) external onlyAdmin {\n    admin = _admin;\n    emit ChangeAdmin(_admin);\n  }\n\n  /// @dev Logic for changeFloatPercentage\n  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {\n    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); // less than or equal to 100% and greater than 0%\n    floatPercentage = newFloatPercentage;\n  }\n\n  /**\n  @notice Changes percentage of float that is minted for float capital.\n  @param newFloatPercentage The new float percentage in base 1e18.\n  */\n  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {\n    _changeFloatPercentage(newFloatPercentage);\n    emit FloatPercentageUpdated(newFloatPercentage);\n  }\n\n  /// @dev Logic for changeUnstakeFee\n  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {\n    require(newMarketUnstakeFee_e18 <= 5e16); // Explicitely stating 5% fee as the max fee possible.\n    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;\n  }\n\n  /**\n  @notice Changes unstake fee for a market\n  @param marketIndex Identifies the market.\n  @param newMarketUnstakeFee_e18 The new unstake fee.\n  */\n  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {\n    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);\n    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);\n  }\n\n  /// @dev Logic for changeMarketLaunchIncentiveParameters\n  function _changeMarketLaunchIncentiveParameters(\n    uint32 marketIndex,\n    uint256 period,\n    uint256 initialMultiplier\n  ) internal virtual {\n    require(initialMultiplier >= 1e18, \"marketLaunchIncentiveMultiplier must be >= 1e18\");\n\n    marketLaunchIncentive_period[marketIndex] = period;\n    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;\n  }\n\n  /**\n  @notice Changes the market launch incentive parameters for a market\n  @param marketIndex Identifies the market.\n  @param period The new period for which float token generation should be boosted.\n  @param initialMultiplier The new multiplier on Float generation.\n  */\n  function changeMarketLaunchIncentiveParameters(\n    uint32 marketIndex,\n    uint256 period,\n    uint256 initialMultiplier\n  ) external onlyAdmin {\n    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);\n\n    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);\n  }\n\n  /// @dev Logic for changeBalanceIncentiveExponent\n  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)\n    internal\n    virtual\n  {\n    require(\n      // The exponent has to be less than 5 in these versions of the contracts.\n      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,\n      \"balanceIncentiveCurve_exponent out of bounds\"\n    );\n\n    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;\n  }\n\n  /** \n  @notice Changes the balance incentive exponent for a market\n  @param marketIndex Identifies the market.\n  @param _balanceIncentiveCurve_exponent The new exponent for the curve.\n  */\n  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)\n    external\n    onlyAdmin\n  {\n    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);\n\n    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);\n  }\n\n  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset\n  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)\n    internal\n    virtual\n  {\n    // Unreasonable that we would ever shift this more than 90% either way\n    require(\n      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,\n      \"balanceIncentiveCurve_equilibriumOffset out of bounds\"\n    );\n\n    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;\n  }\n\n  /**\n  @notice Changes the balance incentive curve equilibrium offset for a market\n  @param marketIndex Identifies the market.\n  @param _balanceIncentiveCurve_equilibriumOffset The new offset.\n  */\n  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)\n    external\n    onlyAdmin\n  {\n    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n\n    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n  }\n\n  /*╔═════════════════════════════╗\n    ║        STAKING SETUP        ║\n    ╚═════════════════════════════╝*/\n\n  /**\n  @notice Sets this contract to track staking for a market in LongShort.sol\n  @param marketIndex Identifies the market.\n  @param longToken Address of the long token for the market.\n  @param shortToken Address of the short token for the market.\n  @param kInitialMultiplier Initial boost on float generation for the market.\n  @param kPeriod Period which the boost should last.\n  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.\n  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)\n  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)\n  */\n  function addNewStakingFund(\n    uint32 marketIndex,\n    address longToken,\n    address shortToken,\n    uint256 kInitialMultiplier,\n    uint256 kPeriod,\n    uint256 unstakeFee_e18,\n    uint256 _balanceIncentiveCurve_exponent,\n    int256 _balanceIncentiveCurve_equilibriumOffset\n  ) external override onlyLongShort {\n    marketIndexOfToken[longToken] = marketIndex;\n    marketIndexOfToken[shortToken] = marketIndex;\n\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;\n\n    syntheticTokens[marketIndex][true] = longToken;\n    syntheticTokens[marketIndex][false] = shortToken;\n\n    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);\n    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);\n\n    _changeUnstakeFee(marketIndex, unstakeFee_e18);\n\n    // Set this value to one initially - 0 is a null value and thus potentially bug prone.\n    batched_stakerNextTokenShiftIndex[marketIndex] = 1;\n\n    emit MarketAddedToStaker(\n      marketIndex,\n      unstakeFee_e18,\n      kPeriod,\n      kInitialMultiplier,\n      _balanceIncentiveCurve_exponent,\n      _balanceIncentiveCurve_equilibriumOffset\n    );\n\n    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);\n  }\n\n  /*╔═════════════════════════════════════════════════════════════════════════╗\n    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║\n    ╚═════════════════════════════════════════════════════════════════════════╝*/\n\n  /**\n  @notice Returns the K factor parameters for the given market with sensible\n  defaults if they haven't been set yet.\n  @param marketIndex The market to change the parameters for.\n  @return period The period for which the k factor applies for in seconds.\n  @return multiplier The multiplier on Float generation in this period.\n  */\n  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)\n    internal\n    view\n    virtual\n    returns (uint256 period, uint256 multiplier)\n  {\n    period = marketLaunchIncentive_period[marketIndex];\n    multiplier = marketLaunchIncentive_multipliers[marketIndex];\n\n    if (multiplier < 1e18) {\n      multiplier = 1e18; // multiplier of 1 by default\n    }\n  }\n\n  /** \n  @notice Returns the extent to which a markets float generation should be adjusted\n  based on the market's launch incentive parameters. Should start at multiplier\n  then linearly change to 1e18 over time.\n  @param marketIndex Identifies the market.\n  @return k The calculated modifier for float generation.\n  */\n  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {\n    // Parameters controlling the float issuance multiplier.\n    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);\n\n    // Sanity check - under normal circumstances, the multipliers should\n    // *never* be set to a value < 1e18, as there are guards against this.\n    assert(kInitialMultiplier >= 1e18);\n\n    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;\n\n    if (block.timestamp - initialTimestamp <= kPeriod) {\n      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);\n    } else {\n      return 1e18;\n    }\n  }\n\n  /*\n  @notice Computes the number of float tokens a user earns per second for\n  every long/short synthetic token they've staked. The returned value has\n  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return\n  values are float per second per synthetic token (hence the requirement\n  to multiply by price)\n  @dev to see below math in latex form see TODO add link\n  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr\n  @param marketIndex The market referred to.\n  @param longPrice Price of the synthetic long token in units of payment token\n  @param shortPrice Price of the synthetic short token in units of payment token\n  @param longValue Amount of payment token in the long side of the market\n  @param shortValue Amount of payment token in the short side of the market\n  @return longFloatPerSecond Float token per second per long synthetic token\n  @return shortFloatPerSecond Float token per second per short synthetic token\n   */\n  function _calculateFloatPerSecond(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {\n    // A float issuance multiplier that starts high and decreases linearly\n    // over time to a value of 1. This incentivises users to stake early.\n    uint256 k = _getKValue(marketIndex);\n\n    uint256 totalLocked = (longValue + shortValue);\n\n    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size\n\n    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *\n      int256(totalLocked)) / 2e18;\n\n    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);\n\n    // Float is scaled by the percentage of the total market value held in\n    // the opposite position. This incentivises users to stake on the\n    // weaker position.\n    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {\n      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {\n        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token\n        //            extremeley unlikely to happen in practice\n        return (0, 1e18 * k * shortPrice);\n      }\n\n      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>\n        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];\n\n      // NOTE: `x * 5e17` == `(x * 10e18) / 2`\n      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;\n      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;\n\n      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);\n    } else {\n      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {\n        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token\n        //            extremeley unlikely to happen in practice\n        return (1e18 * k * longPrice, 0);\n      }\n\n      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>\n        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];\n\n      // NOTE: `x * 5e17` == `(x * 10e18) / 2`\n      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;\n      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;\n\n      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);\n    }\n  }\n\n  /**\n  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.\n  @param marketIndex The market referred to.\n  @return The time difference in seconds\n  */\n  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)\n    internal\n    view\n    virtual\n    returns (uint256)\n  {\n    return\n      block.timestamp -\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;\n  }\n\n  /**\n  @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use\n  cumulative 'r' value to avoid looping during issuance. Note that the\n  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  @param marketIndex An identifier for the market.\n  @return longCumulativeRates The long cumulative sum.\n  @return shortCumulativeRates The short cumulative sum.\n  */\n  function _calculateNewCumulativeIssuancePerStakedSynth(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {\n    // Compute the current 'r' value for float issuance per second.\n    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(\n      marketIndex,\n      longPrice,\n      shortPrice,\n      longValue,\n      shortValue\n    );\n\n    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.\n    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);\n\n    // Compute new cumulative 'r' value total.\n    return (\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]\n      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]\n      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)\n    );\n  }\n\n  /**\n  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  @param marketIndex An identifier for the market.\n  */\n  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal virtual {\n    (\n      uint256 newLongAccumulativeValue,\n      uint256 newShortAccumulativeValue\n    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);\n\n    uint256 newIndex = latestRewardIndex[marketIndex] + 1;\n\n    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]\n    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]\n    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;\n\n    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;\n\n    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.\n    latestRewardIndex[marketIndex] = newIndex;\n\n    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(\n      marketIndex,\n      newIndex,\n      newLongAccumulativeValue,\n      newShortAccumulativeValue\n    );\n  }\n\n  /**\n  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the\n  ILongShort contract whenever there is a state change for a market.\n  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  @param marketIndex An identifier for the market.\n  */\n  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured\n  ) external override onlyLongShort {\n    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.\n\n    // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch\n    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {\n      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[\n        batched_stakerNextTokenShiftIndex[marketIndex]\n      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;\n      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[\n        batched_stakerNextTokenShiftIndex[marketIndex]\n      ] = latestRewardIndex[marketIndex] + 1;\n      batched_stakerNextTokenShiftIndex[marketIndex] += 1;\n\n      emit SyntheticTokensShifted();\n    }\n\n    // Time delta is fetched twice in below code, can pass through? Which is less gas?\n    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {\n      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(\n        marketIndex,\n        longPrice,\n        shortPrice,\n        longValue,\n        shortValue\n      );\n    }\n  }\n\n  /*╔═══════════════════════════════════╗\n    ║    USER REWARD STATE FUNCTIONS    ║\n    ╚═══════════════════════════════════╝*/\n\n  /// @dev Calculates the accumulated float in a specific range of staker snapshots\n  function _calculateAccumulatedFloatInRange(\n    uint32 marketIndex,\n    uint256 amountStakedLong,\n    uint256 amountStakedShort,\n    uint256 rewardIndexFrom,\n    uint256 rewardIndexTo\n  ) internal view virtual returns (uint256 floatReward) {\n    if (amountStakedLong > 0) {\n      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]\n      .accumulativeFloatPerSyntheticToken_long -\n        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]\n        .accumulativeFloatPerSyntheticToken_long;\n      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;\n    }\n\n    if (amountStakedShort > 0) {\n      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]\n      .accumulativeFloatPerSyntheticToken_short -\n        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]\n        .accumulativeFloatPerSyntheticToken_short;\n      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;\n    }\n  }\n\n  /** \n  @notice Calculates float owed to the user since the user last minted float for a market.\n  @param marketIndex Identifier for the market which the user staked in.\n  @param user The address of the user.\n  @return floatReward The amount of float owed.\n   */\n  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {\n    address longToken = syntheticTokens[marketIndex][true];\n    address shortToken = syntheticTokens[marketIndex][false];\n\n    uint256 amountStakedLong = userAmountStaked[longToken][user];\n    uint256 amountStakedShort = userAmountStaked[shortToken][user];\n\n    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];\n\n    // Don't do the calculation and return zero immediately if there is no change\n    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {\n      return 0;\n    }\n\n    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];\n    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)\n    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {\n      floatReward = _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        usersLastRewardIndex,\n        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]\n      );\n\n      // Update the users balances\n      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {\n        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(\n          marketIndex,\n          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],\n          true,\n          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]\n        );\n\n        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];\n        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;\n      }\n\n      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {\n        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(\n          marketIndex,\n          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],\n          false,\n          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]\n        );\n\n        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];\n        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;\n      }\n\n      // Save the users updated staked amounts\n      userAmountStaked[longToken][user] = amountStakedLong;\n      userAmountStaked[shortToken][user] = amountStakedShort;\n\n      floatReward += _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],\n        latestRewardIndex[marketIndex]\n      );\n\n      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;\n    } else {\n      floatReward = _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        usersLastRewardIndex,\n        latestRewardIndex[marketIndex]\n      );\n    }\n  }\n\n  /**\n  @notice Mints float for a user.\n  @dev Mints a fixed percentage for Float capital.\n  @param user The address of the user.\n  @param floatToMint The amount of float to mint.\n   */\n  function _mintFloat(address user, uint256 floatToMint) internal virtual {\n    IFloatToken(floatToken).mint(user, floatToMint);\n    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);\n  }\n\n  /**\n  @notice Mints float owed to a user for a market since they last minted.\n  @param marketIndex An identifier for the market.\n  @param user The address of the user.\n   */\n  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {\n    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);\n\n    if (floatToMint > 0) {\n      // Set the user has claimed up until now, stops them setting this forward\n      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];\n\n      _mintFloat(user, floatToMint);\n      emit FloatMinted(user, marketIndex, floatToMint);\n    }\n  }\n\n  /**\n  @"
    }
  ]
}