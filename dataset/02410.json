{
  "Title": "H-3: LP tokens are not sent back to withdrawing user",
  "Content": "# Issue H-3: LP tokens are not sent back to withdrawing user \n\nSource: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/151 \n\n## Found by \nrvierdiiev, minhtrng, Dug, Jeiwan, obront, chaduke, koxuan, sinarette, Ch\\_301, cergyk, evan, berndartmueller, 0x52, Bauer\n\n## Summary\n\nWhen users withdraw their assets from `IchiVaultSpell.sol`, the function unwinds their position and sends them back their assets, but it never sends them back the amount they requested to withdraw, leaving the tokens stuck in the Spell contract.\n\n## Vulnerability Detail\n\nWhen a user withdraws from `IchiVaultSpell.sol`, they either call `closePosition()` or `closePositionFarm()`, both of which make an internal call to `withdrawInternal()`.\n\nThe following arguments are passed to the function:\n- strategyId: an index into the `strategies` array, which specifies the Ichi vault in question\n- collToken: the underlying token, which is withdrawn from Compound\n- amountShareWithdraw: the number of underlying tokens to withdraw from Compound\n- borrowToken: the token that was borrowed from Compound to create the position, one of the underlying tokens of the vault\n- amountRepay: the amount of the borrow token to repay to Compound\n- amountLpWithdraw: the amount of the LP token to withdraw, rather than trade back into borrow tokens\n\nIn order to accomplish these goals, the contract does the following...\n\n1) Removes the LP tokens from the ERC1155 holding them for collateral.\n```solidity\ndoTakeCollateral(strategies[strategyId].vault, lpTakeAmt);\n```\n2) Calculates the number of LP tokens to withdraw from the vault.\n```solidity\nuint256 amtLPToRemove = vault.balanceOf(address(this)) - amountLpWithdraw;\nvault.withdraw(amtLPToRemove, address(this));\n```\n\n3) Converts the non-borrowed token that was withdrawn in the borrowed token (not copying the code in, as it's not relevant to this issue).\n\n4) Withdraw the underlying token from Compound.\n```solidity\ndoWithdraw(collToken, amountShareWithdraw);\n```\n\n5) Pay back the borrowed token to Compound.\n```solidity\ndoRepay(borrowToken, amountRepay);\n```\n\n6) Validate that this situation does not put us above the maxLTV for our loans.\n```solidity\n_validateMaxLTV(strategyId);\n```\n\n7) Sends the remaining borrow token that weren't paid back and withdrawn underlying tokens to the user.\n```solidity\ndoRefund(borrowToken);\ndoRefund(collToken);\n```\n\nCrucially, the step of sending the remaining LP tokens to the user is skipped, even though the function specifically does the calculations to ensure that `amountLpWithdraw` is held back from being taken out of the vault.\n\n## Impact\n\nUsers who close their positions and choose to keep LP tokens (rather than unwinding the position for the constituent tokens) will have their LP tokens stuck permanently in the IchiVaultSpell contract.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/spell/IchiVaultSpell.sol#L276-L330\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd an additional line to the `withdrawInternal()` function to refund all LP tokens as well:\n\n```diff\n  doRefund(borrowToken);\n  doRefund(collToken);\n+ doRefund(address(vault));\n```\n\n## Discussion\n\n**Gornutz**\n\nduplicate of 34\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/41",
  "Code": [
    {
      "filename": "contracts/spell/IchiVaultSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\";\n\nimport \"./BasicSpell.sol\";\nimport \"../utils/BlueBerryConst.sol\";\nimport \"../libraries/UniV3/UniV3WrappedLibMockup.sol\";\nimport \"../interfaces/IOracle.sol\";\nimport \"../interfaces/IWIchiFarm.sol\";\nimport \"../interfaces/ichi/IICHIVault.sol\";\n\ncontract IchiVaultSpell is BasicSpell, IUniswapV3SwapCallback {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct Strategy {\n        address vault;\n        uint256 maxPositionSize;\n    }\n\n    /// @dev temperory state used to store uni v3 pool when swapping on uni v3\n    IUniswapV3Pool private swapPool;\n\n    /// @dev strategyId => ichi vault\n    Strategy[] public strategies;\n    /// @dev strategyId => collateral token => maxLTV\n    mapping(uint256 => mapping(address => uint256)) public maxLTV; // base 1e4\n    /// @dev address of ICHI farm wrapper\n    IWIchiFarm public wIchiFarm;\n    /// @dev address of ICHI token\n    address public ICHI;\n\n    event StrategyAdded(uint256 strategyId, address vault, uint256 maxPosSize);\n    event CollateralsSupportAdded(\n        uint256 strategyId,\n        address[] collaterals,\n        uint256[] maxLTVs\n    );\n\n    modifier existingStrategy(uint256 strategyId) {\n        if (strategyId >= strategies.length)\n            revert STRATEGY_NOT_EXIST(address(this), strategyId);\n\n        _;\n    }\n\n    modifier existingCollateral(uint256 strategyId, address col) {\n        if (maxLTV[strategyId][col] == 0)\n            revert COLLATERAL_NOT_EXIST(strategyId, col);\n\n        _;\n    }\n\n    function initialize(\n        IBank _bank,\n        address _werc20,\n        address _weth,\n        address _wichiFarm\n    ) external initializer {\n        __BasicSpell_init(_bank, _werc20, _weth);\n\n        wIchiFarm = IWIchiFarm(_wichiFarm);\n        ICHI = address(wIchiFarm.ICHI());\n        IWIchiFarm(_wichiFarm).setApprovalForAll(address(_bank), true);\n    }\n\n    /**\n     * @notice Owner privileged function to add vault\n     * @param vault Address of ICHI angel vault\n     * @param maxPosSize, USD price based maximum size of a position for given vault, based 1e18\n     */\n    function addStrategy(address vault, uint256 maxPosSize) external onlyOwner {\n        if (vault == address(0)) revert ZERO_ADDRESS();\n        if (maxPosSize == 0) revert ZERO_AMOUNT();\n        strategies.push(Strategy({vault: vault, maxPositionSize: maxPosSize}));\n        emit StrategyAdded(strategies.length - 1, vault, maxPosSize);\n    }\n\n    function addCollateralsSupport(\n        uint256 strategyId,\n        address[] memory collaterals,\n        uint256[] memory maxLTVs\n    ) external existingStrategy(strategyId) onlyOwner {\n        if (collaterals.length != maxLTVs.length || collaterals.length == 0)\n            revert INPUT_ARRAY_MISMATCH();\n\n        for (uint256 i = 0; i < collaterals.length; i++) {\n            if (collaterals[i] == address(0)) revert ZERO_ADDRESS();\n            if (maxLTVs[i] == 0) revert ZERO_AMOUNT();\n            maxLTV[strategyId][collaterals[i]] = maxLTVs[i];\n        }\n\n        emit CollateralsSupportAdded(strategyId, collaterals, maxLTVs);\n    }\n\n    function _validateMaxLTV(uint256 strategyId) internal view {\n        uint256 debtValue = bank.getDebtValue(bank.POSITION_ID());\n        (, address collToken, uint256 collAmount, , , , , ) = bank\n            .getCurrentPositionInfo();\n        uint256 collPrice = bank.oracle().getPrice(collToken);\n        uint256 collValue = (collPrice * collAmount) /\n            10**IERC20Metadata(collToken).decimals();\n\n        if (\n            debtValue >\n            (collValue * maxLTV[strategyId][collToken]) / DENOMINATOR\n        ) revert EXCEED_MAX_LTV();\n    }\n\n    /**\n     * @notice Internal function to deposit assets on ICHI Vault\n     * @param collToken Isolated collateral token address\n     * @param collAmount Amount of isolated collateral\n     * @param borrowToken Token address to borrow\n     * @param borrowAmount amount to borrow from Bank\n     */\n    function depositInternal(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 collAmount,\n        uint256 borrowAmount\n    ) internal {\n        Strategy memory strategy = strategies[strategyId];\n\n        // 1. Lend isolated collaterals on compound\n        doLend(collToken, collAmount);\n\n        // 2. Borrow specific amounts\n        doBorrow(borrowToken, borrowAmount);\n\n        // 3. Add liquidity - Deposit on ICHI Vault\n        IICHIVault vault = IICHIVault(strategy.vault);\n        bool isTokenA = vault.token0() == borrowToken;\n        uint256 balance = IERC20(borrowToken).balanceOf(address(this));\n        ensureApprove(borrowToken, address(vault));\n        if (isTokenA) {\n            vault.deposit(balance, 0, address(this));\n        } else {\n            vault.deposit(0, balance, address(this));\n        }\n\n        // 4. Validate MAX LTV\n        _validateMaxLTV(strategyId);\n\n        // 5. Validate Max Pos Size\n        uint256 lpPrice = bank.oracle().getPrice(strategy.vault);\n        uint256 curPosSize = (lpPrice * vault.balanceOf(address(this))) /\n            10**IICHIVault(strategy.vault).decimals();\n        if (curPosSize > strategy.maxPositionSize)\n            revert EXCEED_MAX_POS_SIZE(strategyId);\n    }\n\n    /**\n     * @notice External function to deposit assets on IchiVault\n     * @param collToken Collateral Token address to deposit (e.g USDC)\n     * @param collAmount Amount of user's collateral (e.g USDC)\n     * @param borrowToken Address of token to borrow\n     * @param borrowAmount Amount to borrow from Bank\n     */\n    function openPosition(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 collAmount,\n        uint256 borrowAmount\n    )\n        external\n        existingStrategy(strategyId)\n        existingCollateral(strategyId, collToken)\n    {\n        // 1-3 Deposit on ichi vault\n        depositInternal(\n            strategyId,\n            collToken,\n            borrowToken,\n            collAmount,\n            borrowAmount\n        );\n\n        // 4. Put collateral - ICHI Vault Lp Token\n        address vault = strategies[strategyId].vault;\n        doPutCollateral(vault, IERC20(vault).balanceOf(address(this)));\n    }\n\n    /**\n     * @notice External function to deposit assets on IchiVault and farm in Ichi Farm\n     * @param collToken Collateral Token address to deposit (e.g USDC)\n     * @param collAmount Amount of user's collateral (e.g USDC)\n     * @param borrowToken Address of token to borrow\n     * @param borrowAmount Amount to borrow from Bank\n     * @param farmingPid Pool Id of vault lp on ICHI Farm\n     */\n    function openPositionFarm(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 collAmount,\n        uint256 borrowAmount,\n        uint256 farmingPid\n    )\n        external\n        existingStrategy(strategyId)\n        existingCollateral(strategyId, collToken)\n    {\n        Strategy memory strategy = strategies[strategyId];\n        address lpToken = wIchiFarm.ichiFarm().lpToken(farmingPid);\n        if (strategy.vault != lpToken) revert INCORRECT_LP(lpToken);\n\n        // 1-3 Deposit on ichi vault\n        depositInternal(\n            strategyId,\n            collToken,\n            borrowToken,\n            collAmount,\n            borrowAmount\n        );\n\n        // 4. Take out collateral\n        (\n            ,\n            ,\n            ,\n            ,\n            address posCollToken,\n            uint256 collId,\n            uint256 collSize,\n\n        ) = bank.getCurrentPositionInfo();\n        if (collSize > 0) {\n            (uint256 decodedPid, ) = wIchiFarm.decodeId(collId);\n            if (farmingPid != decodedPid) revert INCORRECT_PID(farmingPid);\n            if (posCollToken != address(wIchiFarm))\n                revert INCORRECT_COLTOKEN(posCollToken);\n            bank.takeCollateral(collSize);\n            wIchiFarm.burn(collId, collSize);\n        }\n\n        // 5. Deposit on farming pool, put collateral\n        ensureApprove(strategy.vault, address(wIchiFarm));\n        uint256 lpAmount = IERC20(strategy.vault).balanceOf(address(this));\n        uint256 id = wIchiFarm.mint(farmingPid, lpAmount);\n        bank.putCollateral(address(wIchiFarm), id, lpAmount);\n    }\n\n    /**\n     * @dev Increase isolated collateral of position\n     * @param token Isolated collateral token address\n     * @param amount Amount of token to increase position\n     */\n    function increasePosition(address token, uint256 amount) external {\n        // 1. Get user input amounts\n        doLend(token, amount);\n    }\n\n    /**\n     * @dev Reduce isolated collateral of position\n     * @param collToken Isolated collateral token address\n     * @param collAmount Amount of Isolated collateral\n     */\n    function reducePosition(\n        uint256 strategyId,\n        address collToken,\n        uint256 collAmount\n    ) external {\n        doWithdraw(collToken, collAmount);\n        doRefund(collToken);\n        _validateMaxLTV(strategyId);\n    }\n\n    function withdrawInternal(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 amountRepay,\n        uint256 amountLpWithdraw,\n        uint256 amountShareWithdraw\n    ) internal {\n        Strategy memory strategy = strategies[strategyId];\n        IICHIVault vault = IICHIVault(strategy.vault);\n        uint256 positionId = bank.POSITION_ID();\n\n        // 1. Compute repay amount if MAX_INT is supplied (max debt)\n        if (amountRepay == type(uint256).max) {\n            amountRepay = bank.borrowBalanceCurrent(positionId, borrowToken);\n        }\n\n        // 2. Calculate actual amount to remove\n        uint256 amtLPToRemove = vault.balanceOf(address(this)) -\n            amountLpWithdraw;\n\n        // 3. Withdraw liquidity from ICHI vault\n        vault.withdraw(amtLPToRemove, address(this));\n\n        // 4. Swap withdrawn tokens to initial deposit token\n        bool isTokenA = vault.token0() == borrowToken;\n        uint256 amountToSwap = IERC20(\n            isTokenA ? vault.token1() : vault.token0()\n        ).balanceOf(address(this));\n        if (amountToSwap > 0) {\n            swapPool = IUniswapV3Pool(vault.pool());\n            swapPool.swap(\n                address(this),\n                // if withdraw token is Token0, then swap token1 -> token0 (false)\n                !isTokenA,\n                int256(amountToSwap),\n                isTokenA\n                    ? UniV3WrappedLibMockup.MAX_SQRT_RATIO - 1 // Token0 -> Token1\n                    : UniV3WrappedLibMockup.MIN_SQRT_RATIO + 1, // Token1 -> Token0\n                abi.encode(address(this))\n            );\n        }\n\n        // 5. Withdraw isolated collateral from Bank\n        doWithdraw(collToken, amountShareWithdraw);\n\n        // 6. Repay\n        doRepay(borrowToken, amountRepay);\n\n        _validateMaxLTV(strategyId);\n\n        // 7. Refund\n        doRefund(borrowToken);\n        doRefund(collToken);\n    }\n\n    /**\n     * @notice External function to withdraw assets from ICHI Vault\n     * @param collToken Token address to withdraw (e.g USDC)\n     * @param borrowToken Token address to withdraw (e.g USDC)\n     * @param lpTakeAmt Amount of ICHI Vault LP token to take out from Bank\n     * @param amountRepay Amount to repay the loan\n     * @param amountLpWithdraw Amount of ICHI Vault LP to withdraw from ICHI Vault\n     * @param amountShareWithdraw Amount of Isolated collateral to withdraw from Compound\n     */\n    function closePosition(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 lpTakeAmt,\n        uint256 amountRepay,\n        uint256 amountLpWithdraw,\n        uint256 amountShareWithdraw\n    )\n        external\n        existingStrategy(strategyId)\n        existingCollateral(strategyId, collToken)\n    {\n        // 1. Take out collateral\n        doTakeCollateral(strategies[strategyId].vault, lpTakeAmt);\n\n        withdrawInternal(\n            strategyId,\n            collToken,\n            borrowToken,\n            amountRepay,\n            amountLpWithdraw,\n            amountShareWithdraw\n        );\n    }\n\n    function closePositionFarm(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 lpTakeAmt,\n        uint256 amountRepay,\n        uint256 amountLpWithdraw,\n        uint256 amountShareWithdraw\n    )\n        external\n        existingStrategy(strategyId)\n        existingCollateral(strategyId, collToken)\n    {\n        address vault = strategies[strategyId].vault;\n        (, , , , address posCollToken, uint256 collId, , ) = bank\n            .getCurrentPositionInfo();\n        if (IWIchiFarm(posCollToken).getUnderlyingToken(collId) != vault)\n            revert INCORRECT_UNDERLYING(vault);\n        if (posCollToken != address(wIchiFarm))\n            revert INCORRECT_COLTOKEN(posCollToken);\n\n        // 1. Take out collateral\n        bank.takeCollateral(lpTakeAmt);\n        wIchiFarm.burn(collId, lpTakeAmt);\n        doCutRewardsFee(ICHI);\n\n        // 2-8. Remove liquidity\n        withdrawInternal(\n            strategyId,\n            collToken,\n            borrowToken,\n            amountRepay,\n            amountLpWithdraw,\n            amountShareWithdraw\n        );\n\n        // 9. Refund ichi token\n        doRefund(ICHI);\n    }\n\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external override {\n        if (msg.sender != address(swapPool)) revert NOT_FROM_UNIV3(msg.sender);\n        address payer = abi.decode(data, (address));\n\n        if (amount0Delta > 0) {\n            if (payer == address(this)) {\n                IERC20Upgradeable(swapPool.token0()).safeTransfer(\n                    msg.sender,\n                    uint256(amount0Delta)\n                );\n            } else {\n                IERC20Upgradeable(swapPool.token0()).safeTransferFrom(\n                    payer,\n                    msg.sender,\n                    uint256(amount0Delta)\n                );\n            }\n        } else if (amount1Delta > 0) {\n            if (payer == address(this)) {\n                IERC20Upgradeable(swapPool.token1()).safeTransfer(\n                    msg.sender,\n                    uint256(amount1Delta)\n                );\n            } else {\n                IERC20Upgradeable(swapPool.token1()).safeTransferFrom(\n                    payer,\n                    msg.sender,\n                    uint256(amount1Delta)\n                );\n            }\n        }\n    }\n}"
    }
  ]
}