{
  "Title": "[M-01] DoS on KeeperGauge due to division by zero",
  "Content": "_Submitted by fatherOfBlocks_\n\nIn the **\\_calcTotalClaimable()** function it should be validated that perPeriodTotalFees\\[i] != 0 since otherwise it would generate a DoS in **claimableRewards()** and **claimRewards()**.<br>\nThis would be possible since if **advanceEpoch()** or **kill()** is executed by the InflationManager address, the epoch will go up without perPeriodTotalFees\\[newIndexEpoch] is 0.<br>\nThe negative of this is that every time the **InflationManager** executes these two methods (**kill() and advanceEpoch()**) DoS is generated until you run **reportFees()**.<br>\nAnother possible case is that **kill()** or **advanceEpoch()** are executed 2 times in a row and there is no way of a perPeriodTotalFees\\[epoch-1] updating its value, therefore it would be an irreversible DoS.<br>\n\n### Recommended Mitigation Steps\n\nGenerate a behavior for the case that perPeriodTotalFees\\[i] == 0.\n\n**[samwerner (Backd) confirmed, but disagreed with severity](https://github.com/code-423n4/2022-05-backd-findings/issues/35)** \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-05-backd-findings/issues/35#issuecomment-1159318667):**\n > The finding at face value is valid and it's impact is a DOS.\n> \n> A division by zero in `keeperRecords[beneficiary].feesInPeriod[i].scaledDiv(perPeriodTotalFees[i])`, will cause an instantaneous revert making it impossible to claim fees.\n> \n> After more reading I believe that the finding is valid and can cause issues if there's one epoch without fees, if for any reason the protocol skips one epoch via `advanceEpoch`, while no [`perPeriodTotalFees`](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L88) are increased, then, because [`keeperRecords[beneficiary].nextEpochToClaim`](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L136`) will include the empty epoch, the `beneficiary` will not be able to receive fees.\n> \n> Given that setup is necessary for this to happen, I believe Medium Severity to be more appropriate.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-backd-tokenomics-contest",
  "Code": [
    {
      "filename": "protocol/contracts/tokenomics/KeeperGauge.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../interfaces/IController.sol\";\nimport \"../../interfaces/tokenomics/IKeeperGauge.sol\";\n\nimport \"../../libraries/ScaledMath.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/AddressProviderHelpers.sol\";\nimport \"../../libraries/UncheckedMath.sol\";\n\nimport \"../access/Authorization.sol\";\n\ncontract KeeperGauge is IKeeperGauge, Authorization {\n    using AddressProviderHelpers for IAddressProvider;\n    using ScaledMath for uint256;\n    using UncheckedMath for uint256;\n\n    struct KeeperRecord {\n        mapping(uint256 => uint256) feesInPeriod;\n        uint256 nextEpochToClaim;\n        bool firstEpochSet;\n    }\n\n    mapping(address => KeeperRecord) public keeperRecords;\n    mapping(uint256 => uint256) public perPeriodTotalFees;\n\n    IController public immutable controller;\n    address public immutable pool;\n    uint256 public epoch;\n\n    uint48 public lastUpdated;\n    mapping(uint256 => uint256) public perPeriodTotalInflation;\n\n    bool public override killed;\n\n    modifier onlyInflationManager() {\n        require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS);\n        _;\n    }\n\n    constructor(IController _controller, address _pool)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        pool = _pool;\n        lastUpdated = uint48(block.timestamp);\n    }\n\n    /**\n     * @notice Shut down the gauge.\n     * @dev Accrued inflation can still be claimed from the gauge after shutdown.\n     * @return `true` if successful.\n     */\n    function kill() external override onlyInflationManager returns (bool) {\n        poolCheckpoint();\n        epoch++;\n        killed = true;\n        return true;\n    }\n\n    /**\n     * @notice Report fees generated by a keeper (this is the basis for inflation accrual).\n     * @dev lpTokenAddress is included for forward compatibility with a single gauge solution.\n     * @param beneficiary Address of the keeper who earned the fees.\n     * @param amount Amount of fees (in lp tokens) earned.\n     * @param lpTokenAddress Address of the lpToken in which the fees are paid.\n     * @return `true` if successful.\n     */\n    function reportFees(\n        address beneficiary,\n        uint256 amount,\n        address lpTokenAddress\n    ) external override returns (bool) {\n        lpTokenAddress; // silencing compiler warning\n        require(\n            IController(controller).addressProvider().isWhiteListedFeeHandler(msg.sender),\n            Error.ADDRESS_NOT_WHITELISTED\n        );\n        require(!killed, Error.CONTRACT_PAUSED);\n        if (!keeperRecords[beneficiary].firstEpochSet) {\n            keeperRecords[beneficiary].firstEpochSet = true;\n            keeperRecords[beneficiary].nextEpochToClaim = epoch;\n        }\n        keeperRecords[beneficiary].feesInPeriod[epoch] += amount;\n        perPeriodTotalFees[epoch] += amount;\n        return true;\n    }\n\n    /**\n     * @notice Advance the inflation accrual epoch.\n     * @return `true` if successful.\n     */\n    function advanceEpoch() external virtual override onlyInflationManager returns (bool) {\n        poolCheckpoint();\n        epoch++;\n        return true;\n    }\n\n    function claimRewards(address beneficiary) external override returns (uint256) {\n        return claimRewards(beneficiary, epoch);\n    }\n\n    function claimableRewards(address beneficiary) external view override returns (uint256) {\n        return _calcTotalClaimable(beneficiary, keeperRecords[beneficiary].nextEpochToClaim, epoch);\n    }\n\n    function poolCheckpoint() public override returns (bool) {\n        if (killed) return false;\n        uint256 timeElapsed = block.timestamp - uint256(lastUpdated);\n        uint256 currentRate = IController(controller).inflationManager().getKeeperRateForPool(pool);\n        perPeriodTotalInflation[epoch] += currentRate * timeElapsed;\n        lastUpdated = uint48(block.timestamp);\n        return true;\n    }\n\n    /**\n     * @notice Claim rewards with an epoch up to which they should be claimed specified.\n     * @param beneficiary Address to claim rewards for.\n     * @param endEpoch Epoch up to which to claim rewards.\n     * @return The amount of rewards claimed.\n     */\n    function claimRewards(address beneficiary, uint256 endEpoch) public override returns (uint256) {\n        require(\n            msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender),\n            Error.UNAUTHORIZED_ACCESS\n        );\n        if (endEpoch > epoch) {\n            endEpoch = epoch;\n        }\n\n        uint256 totalClaimable = _calcTotalClaimable(\n            beneficiary,\n            keeperRecords[beneficiary].nextEpochToClaim,\n            endEpoch\n        );\n        keeperRecords[beneficiary].nextEpochToClaim = endEpoch;\n        require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED);\n        _mintRewards(beneficiary, totalClaimable);\n\n        return totalClaimable;\n    }\n\n    function _mintRewards(address beneficiary, uint256 amount) internal returns (bool) {\n        IController(controller).inflationManager().mintRewards(beneficiary, amount);\n        return true;\n    }\n\n    function _calcTotalClaimable(\n        address beneficiary,\n        uint256 startEpoch,\n        uint256 endEpoch\n    ) internal view returns (uint256) {\n        uint256 totalClaimable;\n        for (uint256 i = startEpoch; i < endEpoch; i = i.uncheckedInc()) {\n            totalClaimable += (\n                keeperRecords[beneficiary].feesInPeriod[i].scaledDiv(perPeriodTotalFees[i])\n            ).scaledMul(perPeriodTotalInflation[i]);\n        }\n        return totalClaimable;\n    }\n}"
    }
  ]
}