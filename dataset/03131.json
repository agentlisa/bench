{
  "Title": "Deviation from specifications",
  "Content": "The [`StakingEscrow` contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/vesting/escrow/StakingEscrow.sol#L18) implements the functionality to allow users who have vested tokens in L1 to be able to interact, participate, and stake those assets in the protocol. By doing so, the protocol could disburse rewards to users which would be collectable by calling the [`release` function](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/vesting/escrow/StakingEscrow.sol#L118), where the [documentation states](https://app.diagrams.net/#G1TTjUyMn7rPYkztKp2NhEQczIkT4K3FK4) that even if these assets are sent to a non-whitelisted address, the tokens will arrive but those will get stuck.\n\n\nHowever, due to the [`_beforeTokenTransfer` function hook](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/token/FortaCommon.sol#L35) being called during any regular transfer of ERC20 tokens, it [will not be possible](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/token/FortaCommon.sol#L37) to send those assets to a non-whitelisted address.\n\n\nConsider either updating the documentation to reflect the current behavior of the protocol or fixing the implementation to follow the specifications.\n\n\n***Update:** Fixed. Now the [documentation](https://drive.google.com/file/d/1TTjUyMn7rPYkztKp2NhEQczIkT4K3FK4/view) reflects what it is implemented in the code.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/vesting/escrow/StakingEscrow.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"../../token/FortaBridgedPolygon.sol\";\nimport \"../../components/staking/FortaStaking.sol\";\nimport \"../../components/utils/ForwardedContext.sol\";\n\n/**\n * Logic for the escrow that handles vesting tokens, on the child chain, for a vesting wallet\n * on the parent chain. Instances are created as Minimal Proxy Clones.\n *\n * This contract contains some immutable parameters, common to all instances, that are set at\n * construction and some \"normal\" storage-based parameters that are instance specific and set\n * during initialization.\n */\ncontract StakingEscrow is Initializable, ERC165, IRewardReceiver, ForwardedContext, ERC1155Receiver {\n    FortaBridgedPolygon public immutable l2token;\n    FortaStaking public immutable l2staking;\n    address      public           l1vesting;\n    address      public           l2manager;\n    uint256      public           pendingReward;\n\n    modifier onlyManager() {\n        require(_msgSender() == l2manager, \"restricted to manager\");\n        _;\n    }\n\n    modifier vestingBalance(uint256 amount) {\n        require(l2token.balanceOf(address(this)) >= amount + pendingReward, \"rewards should not be bridged or staked\");\n        _;\n    }\n\n    constructor(\n        address      __trustedForwarder,\n        FortaBridgedPolygon __token,\n        FortaStaking __staking\n    ) ForwardedContext(__trustedForwarder) initializer() {\n        l2token   = __token;\n        l2staking = __staking;\n    }\n\n    function initialize(\n        address __l1vesting,\n        address __l2manager\n    ) public initializer {\n        require(__l1vesting != address(0), \"StakingEscrow: __l1vesting cannot be address 0\");\n        require(__l2manager != address(0), \"StakingEscrow: __l1vesting cannot be address 0\");\n        l1vesting = __l1vesting;\n        l2manager = __l2manager;\n    }\n\n    /**\n     * Staking operation: Relay `deposit` calls to the staking contract (with corresponding approval).\n     *\n     * Tokens gained as staking rewards cannot be staked here. They should be released to another account and staked\n     * there.\n     */\n    function deposit(uint8 subjectType, uint256 subject, uint256 stakeValue) public onlyManager() vestingBalance(stakeValue) returns (uint256) {\n        SafeERC20.safeApprove(\n            IERC20(address(l2token)),\n            address(l2staking),\n            stakeValue\n        );\n        return l2staking.deposit(subjectType, subject, stakeValue);\n    }\n\n    /**\n     * Overload: deposit everything\n     */\n    function deposit(uint8 subjectType, uint256 subject) public returns (uint256) {\n        return deposit(subjectType, subject, l2token.balanceOf(address(this)) - pendingReward);\n    }\n\n    /**\n     * Staking operation: Relay `initiateWithdrawal` calls to the staking contract.\n     */\n    function initiateWithdrawal(uint8 subjectType, uint256 subject, uint256 sharesValue) public onlyManager() returns (uint64) {\n        return l2staking.initiateWithdrawal(subjectType, subject, sharesValue);\n    }\n\n    /**\n     * Overload: initiate withdrawal of the full stake amount\n     */\n    function initiateFullWithdrawal(uint8 subjectType, uint256 subject) public returns (uint64) {\n        return initiateWithdrawal(\n            subjectType,\n            subject,\n            l2staking.sharesOf(subjectType, subject, address(this))\n        );\n    }\n\n    /**\n     * Staking operation: Relay `withdrawal` calls to the staking contract.\n     */\n    function withdraw(uint8 subjectType, uint256 subject) public onlyManager() returns (uint256) {\n        return l2staking.withdraw(subjectType, subject);\n    }\n\n    /**\n     * Staking operation: Relay `withdrawal` calls to the staking contract.\n     *\n     * Note: anyone can call that directly on the staking contract. One should not assume rewards claims are done\n     * through this relay function.\n     */\n    function claimReward(uint8 subjectType, uint256 subject) public returns (uint256) {\n        return l2staking.releaseReward(subjectType, subject, address(this));\n    }\n\n    /**\n     * Release reward to any account chosen by the beneficiary. Rewards shouldn't be bridged back to prevent them\n     * from being subject to vesting.\n     *\n     * In addition to releasing rewards, this function can also be used to release any other tokens that would be\n     * sent to this escrow by mistake.\n     */\n    function release(address releaseToken, address receiver, uint256 amount) public onlyManager() {\n        if (address(l2token) == releaseToken) {\n            pendingReward -= amount; // reverts on overflow;\n        }\n\n        SafeERC20.safeTransfer(\n            IERC20(releaseToken),\n            receiver,\n            amount\n        );\n    }\n\n    function releaseAllReward(address receiver) public {\n        release(address(l2token), receiver, pendingReward);\n    }\n\n    /**\n     * Bridge operation: Send token back to the vesting instance on the parent chain.\n     *\n     * Any funds sent to the parent chain will be subject to the vesting schedule there. Consequently, rewards should\n     * not be bridged back, but rather released to another wallet (and potentially bridged back independently).\n     */\n    function bridge(uint256 amount) public onlyManager() vestingBalance(amount) {\n        require(amount > 0, \"StakingEscrow: amount must be > 0\");\n        l2token.withdrawTo(amount, l1vesting);\n    }\n\n    /**\n     * Overload: bridge everything\n     */\n    function bridge() public {\n        bridge(l2token.balanceOf(address(this)) - pendingReward);\n    }\n\n    /**\n     * ERC165 implementation, needed for onRewardReceived.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, ERC1155Receiver) returns (bool) {\n        return\n            interfaceId == type(IRewardReceiver).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * Hook for reward accounting\n     */\n    function onRewardReceived(uint8, uint256, uint256 amount) public {\n        require(msg.sender == address(l2staking), \"StakingEscrow: sender must be l2staking\");\n        pendingReward += amount;\n    }\n\n    /**\n     * This account is going to hold staking shares\n     */\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external view returns (bytes4) {\n        require(msg.sender == address(l2staking), \"StakingEscrow: sender must be l2staking\");\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata) external view returns (bytes4) {\n        require(msg.sender == address(l2staking), \"StakingEscrow: sender must be l2staking\");\n        return this.onERC1155BatchReceived.selector;\n    }\n}"
    },
    {
      "filename": "contracts/token/FortaCommon.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"../tools/ENSReverseRegistration.sol\";\n\nabstract contract FortaCommon is AccessControlUpgradeable, ERC20VotesUpgradeable, UUPSUpgradeable {\n    bytes32 public constant ADMIN_ROLE       = keccak256(\"ADMIN_ROLE\");\n    bytes32 public constant WHITELISTER_ROLE = keccak256(\"WHITELISTER_ROLE\");\n    bytes32 public constant WHITELIST_ROLE   = keccak256(\"WHITELIST_ROLE\");\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    function __FortaCommon_init(address admin) internal initializer {\n        require(admin != address(0), \"FortaCommon: admin cannot be address 0\");\n        __AccessControl_init();\n        __ERC20_init(\"Forta\", \"FORT\");\n        __ERC20Permit_init(\"Forta\");\n        __UUPSUpgradeable_init();\n        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n        _setRoleAdmin(WHITELISTER_ROLE, ADMIN_ROLE);\n        _setRoleAdmin(WHITELIST_ROLE, WHITELISTER_ROLE);\n        _grantRole(ADMIN_ROLE, admin);\n    }\n\n    // Allow whitelister to assign other whitelisters\n    function grantWhitelister(address to) public onlyRole(WHITELISTER_ROLE) {\n        _grantRole(WHITELISTER_ROLE, to);\n    }\n\n    // Only allow transfer to whitelisted accounts\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        require(from == address(0) || hasRole(WHITELIST_ROLE, from), \"Forta: sender is not whitelisted\");\n        require(to   == address(0) || hasRole(WHITELIST_ROLE, to), \"Forta: receiver is not whitelisted\");\n        super._beforeTokenTransfer(from, to, amount);\n    }\n\n    // Access control for the upgrade process\n    function _authorizeUpgrade(address newImplementation) internal virtual override onlyRole(ADMIN_ROLE) {\n    }\n\n    // Allow the upgrader to set ENS reverse registration\n    function setName(address ensRegistry, string calldata ensName) external onlyRole(ADMIN_ROLE) {\n        ENSReverseRegistration.setName(ensRegistry, ensName);\n    }\n}"
    }
  ]
}