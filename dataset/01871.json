{
  "Title": "An incorrect (misspelled) word in the comment",
  "Content": "##### Description\nAt line https://github.com/cryptoalgebra/Algebra/blob/7290fad656bfa89db3743c52af631154f6a8a2d5/src/tokenomics/contracts/libraries/VirtualTickManagement.sol#L134 a misspelled word is used. \n\n##### Recommendation\nWe recommend changing `if` to `of`.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/tokenomics/contracts/libraries/VirtualTickManagement.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.17;\n\nimport '@cryptoalgebra/core/contracts/interfaces/IAlgebraPoolErrors.sol';\n\nimport '@cryptoalgebra/core/contracts/libraries/TickMath.sol';\nimport '@cryptoalgebra/core/contracts/libraries/LiquidityMath.sol';\nimport '@cryptoalgebra/core/contracts/libraries/Constants.sol';\n\n/// @title VirtualTickManagement\n/// @notice Contains functions for managing tick processes and relevant calculations\nlibrary VirtualTickManagement {\n  // info stored for each initialized individual tick\n  struct Tick {\n    uint128 liquidityTotal; // the total position liquidity that references this tick\n    int128 liquidityDelta; // amount of net liquidity added (subtracted) when tick is crossed left-right (right-left),\n    // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n    // only has relative meaning, not absolute â€” the value depends on when the tick is initialized\n    uint256 outerFeeGrowth0Token;\n    uint256 outerFeeGrowth1Token;\n    int24 prevTick;\n    int24 nextTick;\n    uint160 outerSecondsPerLiquidity; // the seconds per unit of liquidity on the _other_ side of current tick, (relative meaning)\n  }\n\n  /// @notice Retrieves fee growth data\n  /// @param self The mapping containing all tick information for initialized ticks\n  /// @param bottomTick The lower tick boundary of the position\n  /// @param topTick The upper tick boundary of the position\n  /// @param currentTick The current tick\n  /// @param totalFeeGrowth0Token The all-time global fee growth, per unit of liquidity, in token0\n  /// @param totalFeeGrowth1Token The all-time global fee growth, per unit of liquidity, in token1\n  /// @return innerFeeGrowth0Token The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries\n  /// @return innerFeeGrowth1Token The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries\n  function getInnerFeeGrowth(\n    mapping(int24 => Tick) storage self,\n    int24 bottomTick,\n    int24 topTick,\n    int24 currentTick,\n    uint256 totalFeeGrowth0Token,\n    uint256 totalFeeGrowth1Token\n  ) internal view returns (uint256 innerFeeGrowth0Token, uint256 innerFeeGrowth1Token) {\n    Tick storage lower = self[bottomTick];\n    Tick storage upper = self[topTick];\n\n    unchecked {\n      if (currentTick < topTick) {\n        if (currentTick >= bottomTick) {\n          innerFeeGrowth0Token = totalFeeGrowth0Token - lower.outerFeeGrowth0Token;\n          innerFeeGrowth1Token = totalFeeGrowth1Token - lower.outerFeeGrowth1Token;\n        } else {\n          innerFeeGrowth0Token = lower.outerFeeGrowth0Token;\n          innerFeeGrowth1Token = lower.outerFeeGrowth1Token;\n        }\n        innerFeeGrowth0Token -= upper.outerFeeGrowth0Token;\n        innerFeeGrowth1Token -= upper.outerFeeGrowth1Token;\n      } else {\n        innerFeeGrowth0Token = upper.outerFeeGrowth0Token - lower.outerFeeGrowth0Token;\n        innerFeeGrowth1Token = upper.outerFeeGrowth1Token - lower.outerFeeGrowth1Token;\n      }\n    }\n  }\n\n  /// @notice Updates a tick and returns true if the tick was flipped from initialized to uninitialized, or vice versa\n  /// @param self The mapping containing all tick information for initialized ticks\n  /// @param tick The tick that will be updated\n  /// @param currentTick The current tick\n  /// @param liquidityDelta A new amount of liquidity to be added (subtracted) when tick is crossed from left to right (right to left)\n  /// @param totalFeeGrowth0Token The all-time global fee growth, per unit of liquidity, in token0\n  /// @param totalFeeGrowth1Token The all-time global fee growth, per unit of liquidity, in token1\n  /// @param secondsPerLiquidityCumulative The all-time seconds per max(1, liquidity) of the pool\n  /// @param upper true for updating a position's upper tick, or false for updating a position's lower tick\n  /// @return flipped Whether the tick was flipped from initialized to uninitialized, or vice versa\n  function update(\n    mapping(int24 => Tick) storage self,\n    int24 tick,\n    int24 currentTick,\n    int128 liquidityDelta,\n    uint256 totalFeeGrowth0Token,\n    uint256 totalFeeGrowth1Token,\n    uint160 secondsPerLiquidityCumulative,\n    bool upper\n  ) internal returns (bool flipped) {\n    Tick storage data = self[tick];\n\n    int128 liquidityDeltaBefore = data.liquidityDelta;\n    uint128 liquidityTotalBefore = data.liquidityTotal;\n\n    uint128 liquidityTotalAfter = LiquidityMath.addDelta(liquidityTotalBefore, liquidityDelta);\n    if (liquidityTotalAfter > Constants.MAX_LIQUIDITY_PER_TICK) revert IAlgebraPoolErrors.liquidityOverflow();\n\n    // when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)\n    data.liquidityDelta = upper ? int128(int256(liquidityDeltaBefore) - liquidityDelta) : int128(int256(liquidityDeltaBefore) + liquidityDelta);\n\n    data.liquidityTotal = liquidityTotalAfter;\n\n    flipped = (liquidityTotalAfter == 0);\n    if (liquidityTotalBefore == 0) {\n      flipped = !flipped;\n      // by convention, we assume that all growth before a tick was initialized happened _below_ the tick\n      if (tick <= currentTick) {\n        data.outerFeeGrowth0Token = totalFeeGrowth0Token;\n        data.outerFeeGrowth1Token = totalFeeGrowth1Token;\n        data.outerSecondsPerLiquidity = secondsPerLiquidityCumulative;\n      }\n    }\n  }\n\n  /// @notice Transitions to next tick as needed by price movement\n  /// @param self The mapping containing all tick information for initialized ticks\n  /// @param tick The destination tick of the transition\n  /// @param totalFeeGrowth0Token The all-time global fee growth, per unit of liquidity, in token0\n  /// @param totalFeeGrowth1Token The all-time global fee growth, per unit of liquidity, in token1\n  /// @param secondsPerLiquidityCumulative The current seconds per liquidity\n  /// @return liquidityDelta The amount of liquidity added (subtracted) when tick is crossed from left to right (right to left)\n  function cross(\n    mapping(int24 => Tick) storage self,\n    int24 tick,\n    uint256 totalFeeGrowth0Token,\n    uint256 totalFeeGrowth1Token,\n    uint160 secondsPerLiquidityCumulative\n  ) internal returns (int128 liquidityDelta) {\n    Tick storage data = self[tick];\n\n    unchecked {\n      data.outerSecondsPerLiquidity = secondsPerLiquidityCumulative - data.outerSecondsPerLiquidity;\n\n      data.outerFeeGrowth1Token = totalFeeGrowth1Token - data.outerFeeGrowth1Token;\n      data.outerFeeGrowth0Token = totalFeeGrowth0Token - data.outerFeeGrowth0Token;\n    }\n    return data.liquidityDelta;\n  }\n\n  /// @notice Used for initial setup if ticks list\n  /// @param self The mapping containing all tick information for initialized ticks\n  function initTickState(mapping(int24 => Tick) storage self) internal {\n    (self[TickMath.MIN_TICK].prevTick, self[TickMath.MIN_TICK].nextTick) = (TickMath.MIN_TICK, TickMath.MAX_TICK);\n    (self[TickMath.MAX_TICK].prevTick, self[TickMath.MAX_TICK].nextTick) = (TickMath.MIN_TICK, TickMath.MAX_TICK);\n  }\n\n  /// @notice Removes tick from linked list\n  /// @param self The mapping containing all tick information for initialized ticks\n  /// @param tick The tick that will be removed\n  /// @return prevTick\n  function removeTick(mapping(int24 => Tick) storage self, int24 tick) internal returns (int24) {\n    (int24 prevTick, int24 nextTick) = (self[tick].prevTick, self[tick].nextTick);\n    delete self[tick];\n\n    if (tick == TickMath.MIN_TICK || tick == TickMath.MAX_TICK) {\n      // MIN_TICK and MAX_TICK cannot be removed from tick list\n      (self[tick].prevTick, self[tick].nextTick) = (prevTick, nextTick);\n      return prevTick;\n    } else {\n      if (prevTick == nextTick) revert IAlgebraPoolErrors.tickIsNotInitialized();\n      self[prevTick].nextTick = nextTick;\n      self[nextTick].prevTick = prevTick;\n      return prevTick;\n    }\n  }\n\n  /// @notice Adds tick to linked list\n  /// @param self The mapping containing all tick information for initialized ticks\n  /// @param tick The tick that will be inserted\n  /// @param prevTick The previous active tick\n  /// @param nextTick The next active tick\n  function insertTick(mapping(int24 => Tick) storage self, int24 tick, int24 prevTick, int24 nextTick) internal {\n    if (tick == TickMath.MIN_TICK || tick == TickMath.MAX_TICK) return;\n    if (prevTick >= tick || nextTick <= tick) revert IAlgebraPoolErrors.tickInvalidLinks();\n    (self[tick].prevTick, self[tick].nextTick) = (prevTick, nextTick);\n\n    self[prevTick].nextTick = tick;\n    self[nextTick].prevTick = tick;\n  }\n}"
    }
  ]
}