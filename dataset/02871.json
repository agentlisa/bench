{
  "Title": "H-33: Claiming liquidationAccountant will reduce vault y-intercept by more than the correct amount",
  "Content": "# Issue H-33: Claiming liquidationAccountant will reduce vault y-intercept by more than the correct amount \n\nSource: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/48 \n\n## Found by \nobront\n\n## Summary\n\nWhen `claim()` is called on the Liquidation Accountant, it decreases the y-intercept based on the balance of the contract after funds have been distributed, rather than before. The result is that the y-intercept will be decreased more than it should be, siphoning funds from all users.\n\n## Vulnerability Detail\n\nWhen `LiquidationAccountant.sol:claim()` is called, it uses its `withdrawRatio` to send some portion of its earnings to the `WITHDRAW_PROXY` and the rest to the vault.\n\nAfter performing these transfers, it updates the vault's y-intercept, decreasing it by the gap between the expected return from the auction, and the reality of how much was sent back to the vault:\n\n```solidity\nPublicVault(VAULT()).decreaseYIntercept(\n  (expected - ERC20(underlying()).balanceOf(address(this))).mulDivDown(\n    1e18 - withdrawRatio,\n    1e18\n  )\n);\n```\nThis rebalancing uses the balance of the `liquidationAccountant` to perform its calculation, but it is done after the balance has already been distributed, so it will always be 0.\n\nLooking at an example:\n- `expected = 1 ether` (meaning the y-intercept is currently based on this value)\n- `withdrawRatio = 0` (meaning all funds will go back to the vault)\n- The auction sells for exactly 1 ether\n- 1 ether is therefore sent directly to the vault\n- In this case, the y-intercept should not be updated, as the outcome was equal to the expected outcome\n- However, because the calculation above happens after the funds are distributed, the decrease equals `(expected - 0) * 1e18 / 1e18`, which equals `expected`\n\nThat decrease should not happen, and causing problems for the protocol's accounting. For example, when `withdraw()` is called, it uses the y-intercept in its calculation of the `totalAssets()` held by the vault, creating artificially low asset values for a given number of shares.\n\n## Impact\n\nEvery time the liquidation accountant is used, the vault's math will be thrown off and user shares will be falsely diluted.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LiquidationAccountant.sol#L62-L97\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe amount of assets sent to the vault has already been calculated, as we've already sent it. Therefore, rather than the full existing formula, we can simply call:\n\n```solidity\nPublicVault(VAULT()).decreaseYIntercept(expected - balance)\n```\n\nAlternatively, we can move the current code above the block of code that transfers funds out (L73).\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/8",
  "Code": [
    {
      "filename": "src/LiquidationAccountant.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n/**\n *       __  ___       __\n *  /\\  /__'  |   /\\  |__) |  /\\\n * /~~\\ .__/  |  /~~\\ |  \\ | /~~\\\n *\n * Copyright (c) Astaria Labs, Inc\n */\n\npragma solidity ^0.8.17;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\nimport {Clone} from \"clones-with-immutable-args/Clone.sol\";\n\nimport {ILienToken} from \"./interfaces/ILienToken.sol\";\n\nimport {PublicVault} from \"./PublicVault.sol\";\nimport {WithdrawProxy} from \"./WithdrawProxy.sol\";\n\nabstract contract LiquidationBase is Clone {\n  function underlying() public pure returns (address) {\n    return _getArgAddress(0);\n  }\n\n  function ROUTER() public pure returns (address) {\n    return _getArgAddress(20);\n  }\n\n  function VAULT() public pure returns (address) {\n    return _getArgAddress(40);\n  }\n\n  function LIEN_TOKEN() public pure returns (address) {\n    return _getArgAddress(60);\n  }\n\n  function WITHDRAW_PROXY() public pure returns (address) {\n    return _getArgAddress(80);\n  }\n}\n\n/**\n * @title LiquidationAccountant\n * @author santiagogregory\n * @notice This contract collects funds from liquidations that overlap with an epoch boundary where liquidity providers are exiting.\n * When the final auction being tracked by a LiquidationAccountant for a given epoch is completed,\n * claim() proportionally pays out auction funds to withdrawing liquidity providers and the PublicVault.\n */\ncontract LiquidationAccountant is LiquidationBase {\n  using FixedPointMathLib for uint256;\n  using SafeTransferLib for ERC20;\n\n  uint256 withdrawRatio;\n\n  uint256 expected; // Expected value of auctioned NFTs. yIntercept (virtual assets) of a PublicVault are not modified on liquidation, only once an auction is completed.\n  uint256 finalAuctionEnd; // when this is deleted, we know the final auction is over\n\n  /**\n   * @notice Proportionally sends funds collected from auctions to withdrawing liquidity providers and the PublicVault for this LiquidationAccountant.\n   */\n  function claim() public {\n    require(\n      block.timestamp > finalAuctionEnd || finalAuctionEnd == uint256(0),\n      \"final auction has not ended\"\n    );\n\n    uint256 balance = ERC20(underlying()).balanceOf(address(this));\n    // would happen if there was no WithdrawProxy for current epoch\n    if (withdrawRatio == uint256(0)) {\n      ERC20(underlying()).safeTransfer(VAULT(), balance);\n    } else {\n      //should be wad multiplication\n      // declining\n      uint256 transferAmount = withdrawRatio.mulDivDown(balance, 1e18);\n\n      if (transferAmount > uint256(0)) {\n        ERC20(underlying()).safeTransfer(WITHDRAW_PROXY(), transferAmount);\n      }\n\n      unchecked {\n        balance -= transferAmount;\n      }\n\n      ERC20(underlying()).safeTransfer(VAULT(), balance);\n    }\n\n    PublicVault(VAULT()).decreaseYIntercept(\n      (expected - ERC20(underlying()).balanceOf(address(this))).mulDivDown(\n        1e18 - withdrawRatio,\n        1e18\n      )\n    );\n  }\n\n  /**\n   * @notice Called at epoch boundary, computes the ratio between the funds of withdrawing liquidity providers and the balance of the underlying PublicVault so that claim() proportionally pays out to all parties.\n   */\n  function setWithdrawRatio(uint256 liquidationWithdrawRatio) public {\n    require(msg.sender == VAULT());\n\n    withdrawRatio = liquidationWithdrawRatio;\n  }\n\n  /**\n   * @notice Adds an auction scheduled to end in a new epoch to this LiquidationAccountant.\n   * @param newLienExpectedValue The expected auction value for the lien being auctioned.\n   * @param finalAuctionTimestamp The timestamp by which the auction being added is guaranteed to end. As new auctions are added to the LiquidationAccountant, this value will strictly increase as all auctions have the same maximum duration.\n   */\n  function handleNewLiquidation(\n    uint256 newLienExpectedValue,\n    uint256 finalAuctionTimestamp\n  ) public {\n    require(msg.sender == ROUTER());\n    expected += newLienExpectedValue;\n    finalAuctionEnd = finalAuctionTimestamp;\n  }\n\n  function getFinalAuctionEnd() external view returns (uint256) {\n    return finalAuctionEnd;\n  }\n}"
    }
  ]
}