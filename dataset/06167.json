{
  "Title": "[L-10] Consider a two way transfer of `operator` and `distributor`",
  "Content": "\nhttps://github.com/code-423n4/2023-07-axelar/blob/main/contracts/its/utils/Distributable.sol#L51-L53\n\nhttps://github.com/code-423n4/2023-07-axelar/blob/main/contracts/its/utils/Operatable.sol#L51-L53\n\n```solidity\nFile: its/utils/Operatable.sol\n\n51:    function setOperator(address operator_) external onlyOperator {\n52:        _setOperator(operator_);\n53:    }\n```\n\nThe exact same code is in `Distributable` as well, as these are powerful roles in for tokens/token managers.\n\n### Recommendation\n\nConsider implementing a two way (propose/accept) change procedure for it to avoid accidentally handing it over to the wrong address.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-07-axelar",
  "Code": [
    {
      "filename": "contracts/its/utils/Distributable.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IDistributable } from '../interfaces/IDistributable.sol';\n\n/**\n * @title Distributable Contract\n * @dev A contract module which provides a basic access control mechanism, where\n * there is an account (a distributor) that can be granted exclusive access to\n * specific functions. This module is used through inheritance.\n */\ncontract Distributable is IDistributable {\n    // uint256(keccak256('distributor')) - 1\n    uint256 internal constant DISTRIBUTOR_SLOT = 0x71c5a35e45a25c49e8f747acd4bcb869814b3d104c492d2554f4c46e12371f56;\n\n    /**\n     * @dev Throws a NotDistributor custom eror if called by any account other than the distributor.\n     */\n    modifier onlyDistributor() {\n        if (distributor() != msg.sender) revert NotDistributor();\n        _;\n    }\n\n    /**\n     * @notice Get the address of the distributor\n     * @return distr of the distributor\n     */\n    function distributor() public view returns (address distr) {\n        assembly {\n            distr := sload(DISTRIBUTOR_SLOT)\n        }\n    }\n\n    /**\n     * @dev Internal function that stores the new distributor address in the correct storage slot\n     * @param distributor_ The address of the new distributor\n     */\n    function _setDistributor(address distributor_) internal {\n        assembly {\n            sstore(DISTRIBUTOR_SLOT, distributor_)\n        }\n        emit DistributorChanged(distributor_);\n    }\n\n    /**\n     * @notice Change the distributor of the contract\n     * @dev Can only be called by the current distributor\n     * @param distr The address of the new distributor\n     */\n    function setDistributor(address distr) external onlyDistributor {\n        _setDistributor(distr);\n    }\n}"
    },
    {
      "filename": "contracts/its/utils/Operatable.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IOperatable } from '../interfaces/IOperatable.sol';\n\n/**\n * @title Operatable Contract\n * @dev A contract module which provides a basic access control mechanism, where\n * there is an account (an operator) that can be granted exclusive access to\n * specific functions. This module is used through inheritance.\n */\ncontract Operatable is IOperatable {\n    // uint256(keccak256('operator')) - 1\n    uint256 internal constant OPERATOR_SLOT = 0xf23ec0bb4210edd5cba85afd05127efcd2fc6a781bfed49188da1081670b22d7;\n\n    /**\n     * @dev Throws a NotOperator custom error if called by any account other than the operator.\n     */\n    modifier onlyOperator() {\n        if (operator() != msg.sender) revert NotOperator();\n        _;\n    }\n\n    /**\n     * @notice Get the address of the operator\n     * @return operator_ of the operator\n     */\n    function operator() public view returns (address operator_) {\n        assembly {\n            operator_ := sload(OPERATOR_SLOT)\n        }\n    }\n\n    /**\n     * @dev Internal function that stores the new operator address in the operator storage slot\n     * @param operator_ The address of the new operator\n     */\n    function _setOperator(address operator_) internal {\n        assembly {\n            sstore(OPERATOR_SLOT, operator_)\n        }\n        emit OperatorChanged(operator_);\n    }\n\n    /**\n     * @notice Change the operator of the contract\n     * @dev Can only be called by the current operator\n     * @param operator_ The address of the new operator\n     */\n    function setOperator(address operator_) external onlyOperator {\n        _setOperator(operator_);\n    }\n}"
    }
  ]
}