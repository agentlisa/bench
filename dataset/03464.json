{
  "Title": "[M01] Callbacks to wrong address",
  "Content": "The `SkinnyOptimisticOracle` invokes callback functions on the price requester, if they exist, so the requester can respond to significant state changes. However, the callback is incorrectly invoked on the price proposer instead of the price requester in [the `proposePriceFor` function](https://github.com/UMAprotocol/protocol/blob/f24ad501c8e813cf685f72217e7f13c8f3c366df/packages/core/contracts/oracle/implementation/SkinnyOptimisticOracle.sol#L246). This means the price requester is unable to respond to price proposals.\n\n\nFortunately, this feature is not used in the current code base. Nevertheless, consider invoking the `priceProposed` callback on the requester.\n\n\n**Update:** *Fixed at commit [`7bd3faeb6f3706132f77b9ba2dce192d1a151e74`](https://github.com/UMAprotocol/protocol/pull/3531/commits/7bd3faeb6f3706132f77b9ba2dce192d1a151e74) in [PR3531](https://github.com/UMAprotocol/protocol/pull/3531).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "packages/core/contracts/oracle/implementation/SkinnyOptimisticOracle.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../interfaces/StoreInterface.sol\";\nimport \"../interfaces/OracleAncillaryInterface.sol\";\nimport \"../interfaces/OptimisticOracleInterface.sol\";\nimport \"../interfaces/SkinnyOptimisticOracleInterface.sol\";\nimport \"../interfaces/FinderInterface.sol\";\nimport \"../interfaces/IdentifierWhitelistInterface.sol\";\nimport \"./Constants.sol\";\n\nimport \"../../common/implementation/Testable.sol\";\nimport \"../../common/implementation/Lockable.sol\";\nimport \"../../common/implementation/FixedPoint.sol\";\nimport \"../../common/implementation/AncillaryData.sol\";\nimport \"../../common/implementation/AddressWhitelist.sol\";\n\n/**\n * @title Optimistic Requester.\n * @notice Optional interface that requesters can implement to receive callbacks.\n * @dev This contract does _not_ work with ERC777 collateral currencies or any others that call into the receiver on\n * transfer(). Using an ERC777 token would allow a user to maliciously grief other participants (while also losing\n * money themselves).\n */\ninterface OptimisticRequester {\n    /**\n     * @notice Callback for proposals.\n     * @param identifier price identifier being requested.\n     * @param timestamp timestamp of the price being requested.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param request request params after proposal.\n     */\n    function priceProposed(\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        SkinnyOptimisticOracleInterface.Request memory request\n    ) external;\n\n    /**\n     * @notice Callback for disputes.\n     * @param identifier price identifier being requested.\n     * @param timestamp timestamp of the price being requested.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param request request params after dispute.\n     */\n    function priceDisputed(\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        SkinnyOptimisticOracleInterface.Request memory request\n    ) external;\n\n    /**\n     * @notice Callback for settlement.\n     * @param identifier price identifier being requested.\n     * @param timestamp timestamp of the price being requested.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param request request params after settlement.\n     */\n    function priceSettled(\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        SkinnyOptimisticOracleInterface.Request memory request\n    ) external;\n}\n\n/**\n * @title Optimistic Oracle with a different interface and fewer features that emphasizes gas cost reductions.\n * @notice Pre-DVM escalation contract that allows faster settlement.\n */\ncontract SkinnyOptimisticOracle is SkinnyOptimisticOracleInterface, Testable, Lockable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    event RequestPrice(\n        address indexed requester,\n        bytes32 indexed identifier,\n        uint32 timestamp,\n        bytes ancillaryData,\n        Request request\n    );\n    event ProposePrice(\n        address indexed requester,\n        bytes32 indexed identifier,\n        uint32 timestamp,\n        bytes ancillaryData,\n        Request request\n    );\n    event DisputePrice(\n        address indexed requester,\n        bytes32 indexed identifier,\n        uint32 timestamp,\n        bytes ancillaryData,\n        Request request\n    );\n    event Settle(\n        address indexed requester,\n        bytes32 indexed identifier,\n        uint32 timestamp,\n        bytes ancillaryData,\n        Request request\n    );\n\n    // Maps hash of unique request params {identifier, timestamp, ancillary data} to customizable variables such as\n    // reward and bond amounts.\n    mapping(bytes32 => bytes32) public requests;\n\n    // Finder to provide addresses for DVM contracts.\n    FinderInterface public finder;\n\n    // Default liveness value for all price requests.\n    uint256 public defaultLiveness;\n\n    /**\n     * @notice Constructor.\n     * @param _liveness default liveness applied to each price request.\n     * @param _finderAddress finder to use to get addresses of DVM contracts.\n     * @param _timerAddress address of the timer contract. Should be 0x0 in prod.\n     */\n    constructor(\n        uint256 _liveness,\n        address _finderAddress,\n        address _timerAddress\n    ) Testable(_timerAddress) {\n        finder = FinderInterface(_finderAddress);\n        _validateLiveness(_liveness);\n        defaultLiveness = _liveness;\n    }\n\n    /**\n     * @notice Requests a new price.\n     * @param identifier price identifier being requested.\n     * @param timestamp timestamp of the price being requested.\n     * @param ancillaryData ancillary data representing additional args being passed with the price request.\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\n     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\n     *               which could make sense if the contract requests and proposes the value in the same call or\n     *               provides its own reward system.\n     * @param bond custom proposal bond to set for request. If set to 0, defaults to the final fee.\n     * @param customLiveness custom proposal liveness to set for request.\n     * @return totalBond default bond + final fee that the proposer and disputer will be required to pay.\n     */\n    function requestPrice(\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        IERC20 currency,\n        uint256 reward,\n        uint256 bond,\n        uint256 customLiveness\n    ) external override nonReentrant() returns (uint256 totalBond) {\n        bytes32 requestId = _getId(msg.sender, identifier, timestamp, ancillaryData);\n        require(requests[requestId] == bytes32(0), \"Request already initialized\");\n        require(_getIdentifierWhitelist().isIdentifierSupported(identifier), \"Unsupported identifier\");\n        require(_getCollateralWhitelist().isOnWhitelist(address(currency)), \"Unsupported currency\");\n        require(timestamp <= getCurrentTime(), \"Timestamp in future\");\n        require(\n            _stampAncillaryData(ancillaryData, msg.sender).length <= ancillaryBytesLimit,\n            \"Ancillary Data too long\"\n        );\n        uint256 finalFee = _getStore().computeFinalFee(address(currency)).rawValue;\n\n        // Associate new request with ID\n        Request memory request;\n        request.currency = currency;\n        request.reward = reward;\n        request.finalFee = finalFee;\n        request.bond = bond != 0 ? bond : finalFee;\n        request.customLiveness = customLiveness;\n        _storeRequestHash(requestId, request);\n\n        if (reward > 0) currency.safeTransferFrom(msg.sender, address(this), reward);\n\n        emit RequestPrice(msg.sender, identifier, timestamp, ancillaryData, request);\n\n        return request.bond.add(finalFee);\n    }\n\n    /**\n     * @notice Proposes a price value on another address' behalf. Note: this address will receive any rewards that come\n     * from this proposal. However, any bonds are pulled from the caller.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param request price request parameters whose hash must match the request that the caller wants to\n     * propose a price for.\n     * @param proposer address to set as the proposer.\n     * @param proposedPrice price being proposed.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the proposer once settled if the proposal is correct.\n     */\n    function proposePriceFor(\n        address requester,\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        Request memory request,\n        address proposer,\n        int256 proposedPrice\n    ) public override nonReentrant() returns (uint256 totalBond) {\n        require(proposer != address(0), \"Proposer address must be non 0\");\n        require(\n            _getState(requester, identifier, timestamp, ancillaryData, request) ==\n                OptimisticOracleInterface.State.Requested,\n            \"Must be requested\"\n        );\n        bytes32 requestId = _getId(requester, identifier, timestamp, ancillaryData);\n        _validateRequestHash(requestId, request);\n\n        // Associate newly proposed request params with ID\n        Request memory proposedRequest =\n            Request({\n                proposer: proposer, // Modified\n                disputer: request.disputer,\n                currency: request.currency,\n                settled: request.settled,\n                proposedPrice: proposedPrice, // Modified\n                resolvedPrice: request.resolvedPrice,\n                expirationTime: getCurrentTime().add(\n                    request.customLiveness != 0 ? request.customLiveness : defaultLiveness\n                ), // Modified\n                reward: request.reward,\n                finalFee: request.finalFee,\n                bond: request.bond,\n                customLiveness: request.customLiveness\n            });\n        _storeRequestHash(requestId, proposedRequest);\n\n        totalBond = request.bond.add(request.finalFee);\n        if (totalBond > 0) request.currency.safeTransferFrom(msg.sender, address(this), totalBond);\n\n        emit ProposePrice(requester, identifier, timestamp, ancillaryData, proposedRequest);\n\n        // Callback.\n        if (address(msg.sender).isContract())\n            try\n                OptimisticRequester(msg.sender).priceProposed(identifier, timestamp, ancillaryData, proposedRequest)\n            {} catch {}\n    }\n\n    /**\n     * @notice Proposes a price value where caller is the proposer.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param request price request parameters whose hash must match the request that the caller wants to\n     * propose a price for.\n     * @param proposedPrice price being proposed.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the proposer once settled if the proposal is correct.\n     */\n    function proposePrice(\n        address requester,\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        Request memory request,\n        int256 proposedPrice\n    ) external override returns (uint256 totalBond) {\n        // Note: re-entrancy guard is done in the inner call.\n        return proposePriceFor(requester, identifier, timestamp, ancillaryData, request, msg.sender, proposedPrice);\n    }\n\n    /**\n     * @notice Combines logic of requestPrice and proposePrice while taking advantage of gas savings from not having to\n     * overwrite Request params that a normal requestPrice() => proposePrice() flow would entail. Note: The proposer\n     * will receive any rewards that come from this proposal. However, any bonds are pulled from the caller.\n     * @dev The caller is the requester, but the proposer can be customized.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\n     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\n     *               which could make sense if the contract requests and proposes the value in the same call or\n     *               provides its own reward system.\n     * @param bond custom proposal bond to set for request. If set to 0, defaults to the final fee.\n     * @param customLiveness custom proposal liveness to set for request.\n     * @param proposer address to set as the proposer.\n     * @param proposedPrice price being proposed.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the proposer once settled if the proposal is correct.\n     */\n    function requestAndProposePriceFor(\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        IERC20 currency,\n        uint256 reward,\n        uint256 bond,\n        uint256 customLiveness,\n        address proposer,\n        int256 proposedPrice\n    ) external override returns (uint256 totalBond) {\n        bytes32 requestId = _getId(msg.sender, identifier, timestamp, ancillaryData);\n        require(requests[requestId] == bytes32(0), \"Request already initialized\");\n        require(proposer != address(0), \"proposer address must be non 0\");\n        require(_getIdentifierWhitelist().isIdentifierSupported(identifier), \"Unsupported identifier\");\n        require(_getCollateralWhitelist().isOnWhitelist(address(currency)), \"Unsupported currency\");\n        require(timestamp <= getCurrentTime(), \"Timestamp in future\");\n        require(\n            _stampAncillaryData(ancillaryData, msg.sender).length <= ancillaryBytesLimit,\n            \"Ancillary Data too long\"\n        );\n        uint256 finalFee = _getStore().computeFinalFee(address(currency)).rawValue;\n\n        // Associate new request with ID\n        Request memory request;\n        request.currency = currency;\n        request.reward = reward;\n        request.finalFee = finalFee;\n        request.bond = bond;\n        request.customLiveness = customLiveness;\n        request.proposer = proposer;\n        request.proposedPrice = proposedPrice;\n        request.expirationTime = getCurrentTime().add(customLiveness != 0 ? customLiveness : defaultLiveness);\n        _storeRequestHash(requestId, request);\n\n        // Pull reward from requester, who is the caller.\n        if (reward > 0) currency.safeTransferFrom(msg.sender, address(this), reward);\n        // Pull proposal bond from caller.\n        totalBond = request.bond.add(request.finalFee);\n        if (totalBond > 0) currency.safeTransferFrom(msg.sender, address(this), totalBond);\n\n        emit RequestPrice(msg.sender, identifier, timestamp, ancillaryData, request);\n        emit ProposePrice(msg.sender, identifier, timestamp, ancillaryData, request);\n\n        // Callback.\n        if (address(msg.sender).isContract())\n            try OptimisticRequester(msg.sender).priceProposed(identifier, timestamp, ancillaryData, request) {} catch {}\n    }\n\n    /**\n     * @notice Disputes a price request with an active proposal on another address' behalf. Note: this address will\n     * receive any rewards that come from this dispute. However, any bonds are pulled from the caller.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param request price request parameters whose hash must match the request that the caller wants to\n     *              dispute.\n     * @param disputer address to set as the disputer.\n     * @param requester sender of the initial price request.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\n     */\n    function disputePriceFor(\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        Request memory request,\n        address disputer,\n        address requester\n    ) public override nonReentrant() returns (uint256 totalBond) {\n        require(disputer != address(0), \"disputer address must be non 0\");\n        require(\n            _getState(requester, identifier, timestamp, ancillaryData, request) ==\n                OptimisticOracleInterface.State.Proposed,\n            \"Must be proposed\"\n        );\n        bytes32 requestId = _getId(requester, identifier, timestamp, ancillaryData);\n        _validateRequestHash(requestId, request);\n\n        // Associate newly disputed request params with ID\n        Request memory disputedRequest =\n            Request({\n                proposer: request.proposer,\n                disputer: disputer, // Modified\n                currency: request.currency,\n                settled: request.settled,\n                proposedPrice: request.proposedPrice,\n                resolvedPrice: request.resolvedPrice,\n                expirationTime: request.expirationTime,\n                reward: request.reward,\n                finalFee: request.finalFee,\n                bond: request.bond,\n                customLiveness: request.customLiveness\n            });\n        _storeRequestHash(requestId, disputedRequest);\n\n        totalBond = request.bond.add(request.finalFee);\n        if (totalBond > 0) request.currency.safeTransferFrom(msg.sender, address(this), totalBond);\n\n        StoreInterface store = _getStore();\n\n        // Avoids stack too deep compilation error.\n        {\n            // Along with the final fee, \"burn\" part of the loser's bond to ensure that a larger bond always makes it\n            // proportionally more expensive to delay the resolution even if the proposer and disputer are the same\n            // party.\n            uint256 burnedBond = _computeBurnedBond(disputedRequest);\n\n            // The total fee is the burned bond and the final fee added together.\n            uint256 totalFee = request.finalFee.add(burnedBond);\n\n            if (totalFee > 0) {\n                request.currency.safeIncreaseAllowance(address(store), totalFee);\n                _getStore().payOracleFeesErc20(address(request.currency), FixedPoint.Unsigned(totalFee));\n            }\n        }\n\n        _getOracle().requestPrice(identifier, timestamp, _stampAncillaryData(ancillaryData, requester));\n\n        emit DisputePrice(requester, identifier, timestamp, ancillaryData, disputedRequest);\n\n        // Callback.\n        if (address(requester).isContract())\n            try\n                OptimisticRequester(requester).priceDisputed(identifier, timestamp, ancillaryData, disputedRequest)\n            {} catch {}\n    }\n\n    /**\n     * @notice Disputes a price request with an active proposal where caller is the disputer.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param request price request parameters whose hash must match the request that the caller wants to\n     *             dispute.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\n     */\n    function disputePrice(\n        address requester,\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        Request memory request\n    ) external override returns (uint256 totalBond) {\n        // Note: re-entrancy guard is done in the inner call.\n        return disputePriceFor(identifier, timestamp, ancillaryData, request, msg.sender, requester);\n    }\n\n    /**\n     * @notice Attempts to settle an outstanding price request. Will revert if it isn't settleable.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param request price request parameters whose hash must match the request that the caller wants to\n     *              settle.\n     * @return payout the amount that the \"winner\" (proposer or disputer) receives on settlement. This amount includes\n     * the returned bonds as well as additional rewards.\n     * @return resolvedPrice the price that the request settled to.\n     */\n    function settle(\n        address requester,\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        Request memory request\n    ) external override nonReentrant() returns (uint256 payout, int256 resolvedPrice) {\n        return _settle(requester, identifier, timestamp, ancillaryData, request);\n    }\n\n    /**\n     * @notice Computes the current state of a price request. See the State enum for more details.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param request price request parameters.\n     * @return the State.\n     */\n    function getState(\n        address requester,\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        Request memory request\n    ) external override nonReentrant() returns (OptimisticOracleInterface.State) {\n        return _getState(requester, identifier, timestamp, ancillaryData, request);\n    }\n\n    /**\n     * @notice Checks if a given request has resolved, expired or been settled (i.e the optimistic oracle has a price).\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param request price request parameters. The hash of these parameters must match with the request hash that is\n     * associated with the price request unique ID {requester, identifier, timestamp, ancillaryData}, or this method\n     * will revert.\n     * @return boolean indicating true if price exists and false if not.\n     */\n    function hasPrice(\n        address requester,\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        Request memory request\n    ) public override nonReentrant() returns (bool) {\n        bytes32 requestId = _getId(requester, identifier, timestamp, ancillaryData);\n        _validateRequestHash(requestId, request);\n        OptimisticOracleInterface.State state = _getState(requester, identifier, timestamp, ancillaryData, request);\n        return\n            state == OptimisticOracleInterface.State.Settled ||\n            state == OptimisticOracleInterface.State.Resolved ||\n            state == OptimisticOracleInterface.State.Expired;\n    }\n\n    /**\n     * @notice Generates stamped ancillary data in the format that it would be used in the case of a price dispute.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param requester sender of the initial price request.\n     * @return the stamped ancillary bytes.\n     */\n    function stampAncillaryData(bytes memory ancillaryData, address requester)\n        public\n        pure\n        override\n        returns (bytes memory)\n    {\n        return _stampAncillaryData(ancillaryData, requester);\n    }\n\n    /****************************************\n     *    PRIVATE AND INTERNAL FUNCTIONS    *\n     ****************************************/\n    // Returns hash of unique request identifiers. This contract maps request ID hashes to hashes of the request's\n    // parameters.\n    function _getId(\n        address requester,\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData\n    ) private pure returns (bytes32) {\n        return keccak256(abi.encode(requester, identifier, timestamp, ancillaryData));\n    }\n\n    // Returns hash of request parameters. These are mapped to the unique request ID to track a request's lifecycle.\n    function _getRequestHash(Request memory request) private pure returns (bytes32) {\n        return keccak256(abi.encode(request));\n    }\n\n    // Resolves a price request that has expired or been disputed and a price is available from the DVM. This will\n    // revert if the unique request ID does not match the hashed request parameters. This also marks the request\n    // as settled, therefore this method can only be triggered once per eligible request.\n    function _settle(\n        address requester,\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        Request memory request\n    ) private returns (uint256 payout, int256 resolvedPrice) {\n        bytes32 requestId = _getId(requester, identifier, timestamp, ancillaryData);\n        _validateRequestHash(requestId, request);\n\n        // Associate settled request params with ID.\n        Request memory settledRequest =\n            Request({\n                proposer: request.proposer,\n                disputer: request.disputer,\n                currency: request.currency,\n                settled: true, // Modified\n                proposedPrice: request.proposedPrice,\n                resolvedPrice: request.resolvedPrice,\n                expirationTime: request.expirationTime,\n                reward: request.reward,\n                finalFee: request.finalFee,\n                bond: request.bond,\n                customLiveness: request.customLiveness\n            });\n\n        OptimisticOracleInterface.State state = _getState(requester, identifier, timestamp, ancillaryData, request);\n        if (state == OptimisticOracleInterface.State.Expired) {\n            // In the expiry case, just pay back the proposer's bond and final fee along with the reward.\n            resolvedPrice = request.proposedPrice;\n            settledRequest.resolvedPrice = resolvedPrice;\n            payout = request.bond.add(request.finalFee).add(request.reward);\n            request.currency.safeTransfer(request.proposer, payout);\n        } else if (state == OptimisticOracleInterface.State.Resolved) {\n            // In the Resolved case, pay either the disputer or the proposer the entire payout (+ bond and reward).\n            resolvedPrice = _getOracle().getPrice(identifier, timestamp, _stampAncillaryData(ancillaryData, requester));\n            settledRequest.resolvedPrice = resolvedPrice;\n            bool disputeSuccess = settledRequest.resolvedPrice != request.proposedPrice;\n\n            // Winner gets:\n            // - Their bond back.\n            // - The unburned portion of the loser's bond: proposal bond (not including final fee) - burned bond.\n            // - Their final fee back.\n            // - The request reward (if not already refunded -- if refunded, it will be set to 0).\n            payout = request.bond.add(request.bond.sub(_computeBurnedBond(settledRequest))).add(request.finalFee).add(\n                request.reward\n            );\n            request.currency.safeTransfer(disputeSuccess ? request.disputer : request.proposer, payout);\n        } else {\n            revert(\"Already settled or not settleable\");\n        }\n\n        _storeRequestHash(requestId, settledRequest);\n        emit Settle(requester, identifier, timestamp, ancillaryData, settledRequest);\n\n        // Callback.\n        if (address(requester).isContract())\n            try\n                OptimisticRequester(requester).priceSettled(identifier, timestamp, ancillaryData, settledRequest)\n            {} catch {}\n    }\n\n    function _computeBurnedBond(Request memory request) private pure returns (uint256) {\n        // burnedBond = floor(bond / 2)\n        return request.bond.div(2);\n    }\n\n    function _validateLiveness(uint256 liveness) private pure {\n        require(liveness < 5200 weeks, \"Liveness too large\");\n        require(liveness > 0, \"Liveness cannot be 0\");\n    }\n\n    function _validateRequestHash(bytes32 requestId, Request memory request) private view {\n        require(\n            requests[requestId] == _getRequestHash(request),\n            \"Hashed request params do not match existing request hash\"\n        );\n    }\n\n    function _storeRequestHash(bytes32 requestId, Request memory request) internal {\n        requests[requestId] = _getRequestHash(request);\n    }\n\n    function _getState(\n        address requester,\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        Request memory request\n    ) internal view returns (OptimisticOracleInterface.State) {\n        // Note: This function does not check whether all of the _request parameter values are correct. For example,\n        // the request.reward could be any value and it would not impact this function's return value. Therefore, it\n        // is the caller's responsibility to check that _request matches with the expected ID corresponding to\n        // {requester, identifier, timestamp, ancillaryData} via _validateRequestHash().\n        if (address(request.currency) == address(0)) return OptimisticOracleInterface.State.Invalid;\n\n        if (request.proposer == address(0)) return OptimisticOracleInterface.State.Requested;\n\n        if (request.settled) return OptimisticOracleInterface.State.Settled;\n\n        if (request.disputer == address(0))\n            return\n                request.expirationTime <= getCurrentTime()\n                    ? OptimisticOracleInterface.State.Expired\n                    : OptimisticOracleInterface.State.Proposed;\n\n        return\n            _getOracle().hasPrice(identifier, timestamp, _stampAncillaryData(ancillaryData, requester))\n                ? OptimisticOracleInterface.State.Resolved\n                : OptimisticOracleInterface.State.Disputed;\n    }\n\n    function _getOracle() internal view returns (OracleAncillaryInterface) {\n        return OracleAncillaryInterface(finder.getImplementationAddress(OracleInterfaces.Oracle));\n    }\n\n    function _getCollateralWhitelist() internal view returns (AddressWhitelist) {\n        return AddressWhitelist(finder.getImplementationAddress(OracleInterfaces.CollateralWhitelist));\n    }\n\n    function _getStore() internal view returns (StoreInterface) {\n        return StoreInterface(finder.getImplementationAddress(OracleInterfaces.Store));\n    }\n\n    function _getIdentifierWhitelist() internal view returns (IdentifierWhitelistInterface) {\n        return IdentifierWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist));\n    }\n\n    /**\n     * @dev We don't handle specifically the case where `ancillaryData` is not already readily translateable in utf8.\n     * For those cases, we assume that the client will be able to strip out the utf8-translateable part of the\n     * ancillary data that this contract stamps.\n     */\n    function _stampAncillaryData(bytes memory ancillaryData, address requester) internal pure returns (bytes memory) {\n        // Since this contract will be the one to formally submit DVM price requests, its useful for voters to know who\n        // the original requester was.\n        return AncillaryData.appendKeyValueAddress(ancillaryData, \"ooRequester\", requester);\n    }\n}\n\n/**\n * @notice This is the SkinnyOptimisticOracle contract that should be deployed on live networks. It is exactly the same\n * as the regular SkinnyOptimisticOracle contract, but it overrides getCurrentTime to make the call a simply return\n * block.timestamp with no branching or storage queries.\n */\ncontract SkinnyOptimisticOracleProd is SkinnyOptimisticOracle {\n    constructor(\n        uint256 _liveness,\n        address _finderAddress,\n        address _timerAddress\n    ) SkinnyOptimisticOracle(_liveness, _finderAddress, _timerAddress) {}\n\n    function getCurrentTime() public view virtual override returns (uint256) {\n        return block.timestamp;\n    }\n}"
    }
  ]
}