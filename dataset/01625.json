{
  "Title": "M-13: Suspended PartyBs can bypass the withdrawal restriction by exploiting `fillCloseRequest`",
  "Content": "# Issue M-13: Suspended PartyBs can bypass the withdrawal restriction by exploiting `fillCloseRequest` \n\nSource: https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/229 \n\n## Found by \n0xcrunch, 0xmuxyz, Juntao, PokemonAuditSimulator, Viktor\\_Cortess, ast3ros, bin2chen, circlelooper, josephdara, mrpathfindr, mstpr-brainbot, panprog, rvierdiiev, xiaoming90\n## Summary\n\nSuspended PartyBs can bypass the withdrawal restriction by exploiting `fillCloseRequest` function. Thus, an attacker can transfer the ill-gotten gains out of the protocol, leading to a loss of assets for the protocol and its users.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/Account/AccountFacet.sol#L26\n\n```solidity\nFile: AccountFacet.sol\n26:     function withdraw(uint256 amount) external whenNotAccountingPaused notSuspended(msg.sender) {\n27:         AccountFacetImpl.withdraw(msg.sender, amount);\n28:         emit Withdraw(msg.sender, msg.sender, amount);\n29:     }\n30: \n31:     function withdrawTo(\n32:         address user,\n33:         uint256 amount\n34:     ) external whenNotAccountingPaused notSuspended(msg.sender) {\n35:         AccountFacetImpl.withdraw(user, amount);\n36:         emit Withdraw(msg.sender, user, amount);\n37:     }\n```\n\nWhen a user is suspended, they are not allowed to call any of the withdraw functions (`withdraw` and `withdrawTo`) to withdraw funds from their account. These withdrawal functions are guarded by the `notSuspended` modifier that will revert if the user's address is suspended.\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/utils/Accessibility.sol#L73\n\n```solidity\nFile: Accessibility.sol\n73:     modifier notSuspended(address user) {\n74:         require(\n75:             !AccountStorage.layout().suspendedAddresses[user],\n76:             \"Accessibility: Sender is Suspended\"\n77:         );\n78:         _;\n79:     }\n```\n\nHowever, suspected PartyBs can bypass this restriction by exploiting the `fillCloseRequest` function to transfer the assets out of the protocol. Following describe the proof-of-concept:\n\n1) Anyone can be a PartyA within the protocol. Suspended PartyBs use one of their wallet addresses to operate as a PartyA. \n2) Use the PartyA to create a new position with an unfavorable price that will immediately result in a significant loss for any PartyB who takes on the position. The `partyBsWhiteList` of the new position is set to PartyB address only to prevent some other PartyB from taking on this position.\n3) Once PartyB takes on the position, PartyB will immediately incur a significant loss, while PartyA will enjoy a significant gain due to the zero-sum nature of this game.\n4) PartyA requested to close its position to lock the profits and PartyB will fill the close request.\n5) PartyA calls the deallocate and withdraw functions to move the assets/gains out of the protocol.\n\n## Impact\n\nIn the event of an attack, the protocol will suspend the malicious account and prevent it from transferring ill-gotten gains out of the protocol. However, since this restriction can be bypassed, the attacker can transfer the ill-gotten gains out of the protocol, leading to a loss of assets for the protocol and its users.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/Account/AccountFacet.sol#L98\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd the `notSuspended` modifier to the `openPosition` and `fillCloseRequest` functions to block the above-described attack path.\n\n```diff\nfunction fillCloseRequest(\n    uint256 quoteId,\n    uint256 filledAmount,\n    uint256 closedPrice,\n    PairUpnlAndPriceSig memory upnlSig\n- ) external whenNotPartyBActionsPaused onlyPartyBOfQuote(quoteId) notLiquidated(quoteId) {\n+ ) external whenNotPartyBActionsPaused onlyPartyBOfQuote(quoteId) notLiquidated(quoteId) notSuspended(msg.sender) {\n\t..SNIP..\n}\n```\n\n```diff\nfunction openPosition(\n    uint256 quoteId,\n    uint256 filledAmount,\n    uint256 openedPrice,\n    PairUpnlAndPriceSig memory upnlSig\n- ) external whenNotPartyBActionsPaused onlyPartyBOfQuote(quoteId) notLiquidated(quoteId) {\n+ ) external whenNotPartyBActionsPaused onlyPartyBOfQuote(quoteId) notLiquidated(quoteId) notSuspended(msg.sender) {\n    ..SNIP..\n}\n```\n\n\n\n## Discussion\n\n**MoonKnightDev**\n\nWe disagree with the severity of this issue because, in the current system, Party B is permissioned. Therefore, it is highly unlikely that Party B will be suspended.\n\n**Navid-Fkh**\n\nThe mentioned PartyA will also be suspended by our bots; thus, they won't be able to withdraw any funds. Therefore, we won't have any problems\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/85",
  "Code": [
    {
      "filename": "symmio-core/contracts/facets/Account/AccountFacet.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../utils/Accessibility.sol\";\nimport \"../../utils/Pausable.sol\";\nimport \"./IAccountEvents.sol\";\nimport \"./AccountFacetImpl.sol\";\nimport \"../../storages/GlobalAppStorage.sol\";\n\ncontract AccountFacet is Accessibility, Pausable, IAccountEvents {\n\n    //Party A\n    function deposit(uint256 amount) external whenNotAccountingPaused {\n        AccountFacetImpl.deposit(msg.sender, amount);\n        emit Deposit(msg.sender, msg.sender, amount);\n    }\n\n    function depositFor(address user, uint256 amount) external whenNotAccountingPaused {\n        AccountFacetImpl.deposit(user, amount);\n        emit Deposit(msg.sender, user, amount);\n    }\n\n    function withdraw(uint256 amount) external whenNotAccountingPaused notSuspended(msg.sender) {\n        AccountFacetImpl.withdraw(msg.sender, amount);\n        emit Withdraw(msg.sender, msg.sender, amount);\n    }\n\n    function withdrawTo(\n        address user,\n        uint256 amount\n    ) external whenNotAccountingPaused notSuspended(msg.sender) {\n        AccountFacetImpl.withdraw(user, amount);\n        emit Withdraw(msg.sender, user, amount);\n    }\n\n    function allocate(\n        uint256 amount\n    ) external whenNotAccountingPaused notLiquidatedPartyA(msg.sender) {\n        AccountFacetImpl.allocate(amount);\n        emit AllocatePartyA(msg.sender, amount);\n    }\n\n    function depositAndAllocate(\n        uint256 amount\n    ) external whenNotAccountingPaused notLiquidatedPartyA(msg.sender) {\n        AccountFacetImpl.deposit(msg.sender, amount);\n        uint256 amountWith18Decimals = (amount * 1e18) /\n        (10 ** IERC20Metadata(GlobalAppStorage.layout().collateral).decimals());\n        AccountFacetImpl.allocate(amountWith18Decimals);\n        emit Deposit(msg.sender, msg.sender, amount);\n        emit AllocatePartyA(msg.sender, amountWith18Decimals);\n    }\n\n    function deallocate(\n        uint256 amount,\n        SingleUpnlSig memory upnlSig\n    ) external whenNotAccountingPaused notLiquidatedPartyA(msg.sender) {\n        AccountFacetImpl.deallocate(amount, upnlSig);\n        emit DeallocatePartyA(msg.sender, amount);\n    }\n\n    // PartyB\n    function allocateForPartyB(\n        uint256 amount,\n        address partyA\n    ) public whenNotPartyBActionsPaused notLiquidatedPartyB(msg.sender, partyA) onlyPartyB {\n        AccountFacetImpl.allocateForPartyB(amount, partyA, true);\n        emit AllocateForPartyB(msg.sender, partyA, amount);\n    }\n\n    function depositAndAllocateForPartyB(\n        uint256 amount,\n        address partyA\n    ) external whenNotPartyBActionsPaused onlyPartyB {\n        AccountFacetImpl.depositForPartyB(amount);\n        AccountFacetImpl.allocateForPartyB(amount, partyA, true);\n        emit DepositForPartyB(msg.sender, amount);\n        emit AllocateForPartyB(msg.sender, partyA, amount);\n    }\n\n    function deallocateForPartyB(\n        uint256 amount,\n        address partyA,\n        SingleUpnlSig memory upnlSig\n    ) external whenNotPartyBActionsPaused notLiquidatedPartyB(msg.sender, partyA) onlyPartyB {\n        AccountFacetImpl.deallocateForPartyB(amount, partyA, upnlSig);\n        emit DeallocateForPartyB(msg.sender, partyA, amount);\n    }\n\n    function depositForPartyB(uint256 amount) external whenNotPartyBActionsPaused onlyPartyB {\n        AccountFacetImpl.depositForPartyB(amount);\n        emit DepositForPartyB(msg.sender, amount);\n    }\n\n    function transferAllocation(\n        uint256 amount,\n        address origin,\n        address recipient,\n        SingleUpnlSig memory upnlSig\n    ) external whenNotPartyBActionsPaused {\n        AccountFacetImpl.transferAllocation(amount, origin, recipient, upnlSig);\n        emit TransferAllocation(amount, origin, recipient);\n    }\n}"
    },
    {
      "filename": "symmio-core/contracts/utils/Accessibility.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../storages/MAStorage.sol\";\nimport \"../storages/AccountStorage.sol\";\nimport \"../storages/QuoteStorage.sol\";\nimport \"../libraries/LibAccessibility.sol\";\n\nabstract contract Accessibility {\n    modifier onlyPartyB() {\n        require(MAStorage.layout().partyBStatus[msg.sender], \"Accessibility: Should be partyB\");\n        _;\n    }\n\n    modifier notPartyB() {\n        require(!MAStorage.layout().partyBStatus[msg.sender], \"Accessibility: Shouldn't be partyB\");\n        _;\n    }\n\n    modifier onlyRole(bytes32 role) {\n        require(LibAccessibility.hasRole(msg.sender, role), \"Accessibility: Must has role\");\n        _;\n    }\n\n    modifier notLiquidatedPartyA(address partyA) {\n        require(\n            !MAStorage.layout().liquidationStatus[partyA],\n            \"Accessibility: PartyA isn't solvent\"\n        );\n        _;\n    }\n\n    modifier notLiquidatedPartyB(address partyB, address partyA) {\n        require(\n            !MAStorage.layout().partyBLiquidationStatus[partyB][partyA],\n            \"Accessibility: PartyB isn't solvent\"\n        );\n        _;\n    }\n\n    modifier notLiquidated(uint256 quoteId) {\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        require(\n            !MAStorage.layout().liquidationStatus[quote.partyA],\n            \"Accessibility: PartyA isn't solvent\"\n        );\n        require(\n            !MAStorage.layout().partyBLiquidationStatus[quote.partyB][quote.partyA],\n            \"Accessibility: PartyB isn't solvent\"\n        );\n        require(\n            quote.quoteStatus != QuoteStatus.LIQUIDATED && quote.quoteStatus != QuoteStatus.CLOSED,\n            \"Accessibility: Invalid state\"\n        );\n        _;\n    }\n\n    modifier onlyPartyAOfQuote(uint256 quoteId) {\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        require(quote.partyA == msg.sender, \"Accessibility: Should be partyA of quote\");\n        _;\n    }\n\n    modifier onlyPartyBOfQuote(uint256 quoteId) {\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        require(quote.partyB == msg.sender, \"Accessibility: Should be partyB of quote\");\n        _;\n    }\n\n    modifier notSuspended(address user) {\n        require(\n            !AccountStorage.layout().suspendedAddresses[user],\n            \"Accessibility: Sender is Suspended\"\n        );\n        _;\n    }\n}"
    },
    {
      "filename": "symmio-core/contracts/facets/Account/AccountFacet.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../utils/Accessibility.sol\";\nimport \"../../utils/Pausable.sol\";\nimport \"./IAccountEvents.sol\";\nimport \"./AccountFacetImpl.sol\";\nimport \"../../storages/GlobalAppStorage.sol\";\n\ncontract AccountFacet is Accessibility, Pausable, IAccountEvents {\n\n    //Party A\n    function deposit(uint256 amount) external whenNotAccountingPaused {\n        AccountFacetImpl.deposit(msg.sender, amount);\n        emit Deposit(msg.sender, msg.sender, amount);\n    }\n\n    function depositFor(address user, uint256 amount) external whenNotAccountingPaused {\n        AccountFacetImpl.deposit(user, amount);\n        emit Deposit(msg.sender, user, amount);\n    }\n\n    function withdraw(uint256 amount) external whenNotAccountingPaused notSuspended(msg.sender) {\n        AccountFacetImpl.withdraw(msg.sender, amount);\n        emit Withdraw(msg.sender, msg.sender, amount);\n    }\n\n    function withdrawTo(\n        address user,\n        uint256 amount\n    ) external whenNotAccountingPaused notSuspended(msg.sender) {\n        AccountFacetImpl.withdraw(user, amount);\n        emit Withdraw(msg.sender, user, amount);\n    }\n\n    function allocate(\n        uint256 amount\n    ) external whenNotAccountingPaused notLiquidatedPartyA(msg.sender) {\n        AccountFacetImpl.allocate(amount);\n        emit AllocatePartyA(msg.sender, amount);\n    }\n\n    function depositAndAllocate(\n        uint256 amount\n    ) external whenNotAccountingPaused notLiquidatedPartyA(msg.sender) {\n        AccountFacetImpl.deposit(msg.sender, amount);\n        uint256 amountWith18Decimals = (amount * 1e18) /\n        (10 ** IERC20Metadata(GlobalAppStorage.layout().collateral).decimals());\n        AccountFacetImpl.allocate(amountWith18Decimals);\n        emit Deposit(msg.sender, msg.sender, amount);\n        emit AllocatePartyA(msg.sender, amountWith18Decimals);\n    }\n\n    function deallocate(\n        uint256 amount,\n        SingleUpnlSig memory upnlSig\n    ) external whenNotAccountingPaused notLiquidatedPartyA(msg.sender) {\n        AccountFacetImpl.deallocate(amount, upnlSig);\n        emit DeallocatePartyA(msg.sender, amount);\n    }\n\n    // PartyB\n    function allocateForPartyB(\n        uint256 amount,\n        address partyA\n    ) public whenNotPartyBActionsPaused notLiquidatedPartyB(msg.sender, partyA) onlyPartyB {\n        AccountFacetImpl.allocateForPartyB(amount, partyA, true);\n        emit AllocateForPartyB(msg.sender, partyA, amount);\n    }\n\n    function depositAndAllocateForPartyB(\n        uint256 amount,\n        address partyA\n    ) external whenNotPartyBActionsPaused onlyPartyB {\n        AccountFacetImpl.depositForPartyB(amount);\n        AccountFacetImpl.allocateForPartyB(amount, partyA, true);\n        emit DepositForPartyB(msg.sender, amount);\n        emit AllocateForPartyB(msg.sender, partyA, amount);\n    }\n\n    function deallocateForPartyB(\n        uint256 amount,\n        address partyA,\n        SingleUpnlSig memory upnlSig\n    ) external whenNotPartyBActionsPaused notLiquidatedPartyB(msg.sender, partyA) onlyPartyB {\n        AccountFacetImpl.deallocateForPartyB(amount, partyA, upnlSig);\n        emit DeallocateForPartyB(msg.sender, partyA, amount);\n    }\n\n    function depositForPartyB(uint256 amount) external whenNotPartyBActionsPaused onlyPartyB {\n        AccountFacetImpl.depositForPartyB(amount);\n        emit DepositForPartyB(msg.sender, amount);\n    }\n\n    function transferAllocation(\n        uint256 amount,\n        address origin,\n        address recipient,\n        SingleUpnlSig memory upnlSig\n    ) external whenNotPartyBActionsPaused {\n        AccountFacetImpl.transferAllocation(amount, origin, recipient, upnlSig);\n        emit TransferAllocation(amount, origin, recipient);\n    }\n}"
    }
  ]
}