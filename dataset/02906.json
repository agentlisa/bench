{
  "Title": "H-5: Staker rewards can be gathered with maximal multiplier no matter how borrowers are overdue",
  "Content": "# Issue H-5: Staker rewards can be gathered with maximal multiplier no matter how borrowers are overdue \n\nSource: https://github.com/sherlock-audit/2022-10-union-finance-judging/issues/74 \n\n## Found by \nhyh, cccz\n\n## Summary\n\nFrozen coin age of an account is based on the `vouch.lastUpdated`, which is set to the current block not only on initial borrowing and debt full interest payment or notional repayment, but also on any repetitive borrowing from a vouch.\n\nUsing this a staker can collude with their borrowers, asking them to borrow a minimal amount, so staker's `memberTotalFrozen` end up being zero and maximal rewards can be obtained immediately with UserManager’s withdrawRewards().\n\n## Vulnerability Detail\n\nBob the staker whose borrowers are overdue can ask them to borrow min amount as soon as they can (1 DAI), then claim the rewards, which will be with maximal `2x` multiplier.\n\nBob can do it each time he wants to gather the rewards (say before he unstakes), effectively surpassing the reward multiplier logic altogether.\n\nAnother theoretical way to game the rewards logic is to lend to self, but this require paying interest, that isn't low. On the other side minimal borrow amount is kept low, now staying at `1.0 DAI`, to promote protocol adoption.\n\nThis way, Bob and his borrowers excess costs are negligible (gas and min borrowings), while benefit of obtaining max rewards are material.\n\nI.e. Bob, being a rational user, on each reward withdrawal can ask the vouchees to borrow minimal amount (Bob will update trust for that end, if needed) instead of repaying anything, this way removing the penalty. Bob will obtain the rewards with the maximal multiplier.\n\n## Impact\n\nBob gains bloated reward issuance and steals from all UNION token holders by having its supply diluted.\n\nAs this can be done without any major prerequisites, setting the severity to be **high**.\n\n## Code Snippet\n\nUNION tokens issuance is the main staker profit mechanics, while stake utilization is the core metric for reward issuance rate calculations:\n\nhttps://docs.union.finance/protocol-overview/plain-english-overview#stakers-earning-union-from-comptroller\n\n```markdown\nStake utilization is meant to give control of the protocol to those who vouch for people who borrow and dont default. And the 0.75 is to allow non-members a non financial means but still sybil resistant way to acquire the UNION. The curve is upgradeable without requiring a fork or a withdrawal of the dai staked. All of this is handled by the {Comptroller.sol Contract}\n```\n\nUserManager’s updateLocked() sets `vouchers[borrower][i].lastUpdated` to the current block both on borrowing and repaying:\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/user/UserManager.sol#L800-L841\n\n```solidity\n    function updateLocked(\n        address borrower,\n        uint96 amount,\n        bool lock\n    ) external onlyMarket {\n        uint96 remaining = amount;\n\n        for (uint256 i = 0; i < vouchers[borrower].length; i++) {\n            Vouch storage vouch = vouchers[borrower][i];\n            uint96 innerAmount;\n\n            if (lock) {\n                // Look up the staker and determine how much unlock stake they\n                // have available for the borrower to borrow. If there is 0\n                // then continue to the next voucher in the array\n                uint96 stakerLocked = stakers[vouch.staker].locked;\n                uint96 stakerStakedAmount = stakers[vouch.staker].stakedAmount;\n                uint96 availableStake = stakerStakedAmount - stakerLocked;\n                uint96 lockAmount = _min(availableStake, vouch.trust - vouch.locked);\n                if (lockAmount == 0) continue;\n\n                // Calculate the amount to add to the lock then\n                // add the extra amount to lock to the stakers locked amount\n                // and also update the vouches locked amount and lastUpdated block\n                innerAmount = _min(remaining, lockAmount);\n                stakers[vouch.staker].locked = stakerLocked + innerAmount;\n                vouch.locked += innerAmount;\n                vouch.lastUpdated = uint64(block.number);\n            } else {\n                // Look up how much this vouch has locked. If it is 0 then\n                // continue to the next voucher. Then calculate the amount to\n                // unlock which is the min of the vouches lock and what is\n                // remaining to unlock\n                uint96 locked = vouch.locked;\n                if (locked == 0) continue;\n                innerAmount = _min(locked, remaining);\n\n                // Update the stored locked values and last updated block\n                stakers[vouch.staker].locked -= innerAmount;\n                vouch.locked -= innerAmount;\n                vouch.lastUpdated = uint64(block.number);\n            }\n```\n\ngetFrozenInfo() uses `vouchers[vouchee.borrower][vouchee.voucherIndex].lastUpdated` for calculating what share of the total staker’s lending business with the system is overdue:\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/user/UserManager.sol#L438-L454\n\n```solidity\n    function getFrozenInfo(address staker, uint256 pastBlocks)\n        public\n        view\n        returns (uint256 memberTotalFrozen, uint256 memberFrozenCoinAge)\n    {\n        uint256 overdueBlocks = uToken.overdueBlocks();\n        uint256 voucheesLength = vouchees[staker].length;\n        // Loop through all of the stakers vouchees sum their total\n        // locked balance and sum their total memberFrozenCoinAge\n        for (uint256 i = 0; i < voucheesLength; i++) {\n            // Get the vouchee record and look up the borrowers voucher record\n            // to get the locked amount and lastUpdate block number\n            Vouchee memory vouchee = vouchees[staker][i];\n            Vouch memory vouch = vouchers[vouchee.borrower][vouchee.voucherIndex];\n\n            uint256 lastUpdated = vouch.lastUpdated;\n            uint256 diff = block.number - lastUpdated;\n```\n\nI.e. as a result getFrozenInfo() will treat constantly borrowing account as not frozen.\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider either basing total frozen on borrower's `lastRepay` instead of voucher's `lastUpdate` (as it described in another issue) or removing the `lastUpdate` renewal on a repetitive borrow.\n\nI.e. update of the indicator that is used in the total frozen calculation on a repetitive borrow is the issue here as it neither loan start nor full interest / partial notional prepayment and shouldn't reset the frozen counter.\n\nIn other words frozen age is overdue analogue with regard to lender's account health. Repetitive borrow do not reduce this overdue, but is counted towards it.\n\nAs `lastUpdate` is used in account frozen statistics calculation only, the simplest solution is to change `lastUpdate` on the notional repay and initial borrowing from the vouch only:\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/user/UserManager.sol#L811-L828\n\n```solidity\n            if (lock) {\n                // Look up the staker and determine how much unlock stake they\n                // have available for the borrower to borrow. If there is 0\n                // then continue to the next voucher in the array\n                uint96 stakerLocked = stakers[vouch.staker].locked;\n                uint96 stakerStakedAmount = stakers[vouch.staker].stakedAmount;\n                uint96 availableStake = stakerStakedAmount - stakerLocked;\n+               uint96 vouchLocked = vouch.locked;\n-               uint96 lockAmount = _min(availableStake, vouch.trust - vouch.locked);\n+               uint96 lockAmount = _min(availableStake, vouch.trust - vouchLocked);\n                if (lockAmount == 0) continue;\n\n                // Calculate the amount to add to the lock then\n                // add the extra amount to lock to the stakers locked amount\n                // and also update the vouches locked amount and lastUpdated block\n                innerAmount = _min(remaining, lockAmount);\n                stakers[vouch.staker].locked = stakerLocked + innerAmount;\n+               vouch.locked = vouchLocked + innerAmount;\n+               if (vouchLocked == 0) vouch.lastUpdated = uint64(block.number);\n-               vouch.locked += innerAmount;\n-               vouch.lastUpdated = uint64(block.number);\n            }\n```\nNotice, that this example solution will suffice if the issue is treated in isolation, but given other issues using `lastRepay` is preferred.\n\n## Discussion\n\n**kingjacob**\n\nDupe of #99 \n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/11",
  "Code": [
    {
      "filename": "union-v2-contracts/contracts/user/UserManager.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport {Controller} from \"../Controller.sol\";\nimport {IAssetManager} from \"../interfaces/IAssetManager.sol\";\nimport {IUserManager} from \"../interfaces/IUserManager.sol\";\nimport {IComptroller} from \"../interfaces/IComptroller.sol\";\nimport {IUnionToken} from \"../interfaces/IUnionToken.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\n\n/**\n * @title UserManager Contract\n * @dev Manages the Union members stake and vouches.\n */\ncontract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /* -------------------------------------------------------------------\n      Types \n    ------------------------------------------------------------------- */\n\n    struct Vouch {\n        // staker recieveing the vouch\n        address staker;\n        // trust amount\n        uint96 trust;\n        // amount of stake locked by this vouch\n        uint96 locked;\n        // block number of last update\n        uint64 lastUpdated;\n    }\n\n    struct Staker {\n        bool isMember;\n        uint96 stakedAmount;\n        uint96 locked;\n    }\n\n    struct Index {\n        bool isSet;\n        uint128 idx;\n    }\n\n    struct Vouchee {\n        address borrower;\n        uint96 voucherIndex;\n    }\n\n    /* -------------------------------------------------------------------\n      Storage \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Max amount that can be staked of the staking token\n     */\n    uint96 public maxStakeAmount;\n\n    /**\n     *  @dev The staking token that is staked in the comptroller\n     */\n    address public stakingToken;\n\n    /**\n     *  @dev Address of the UNION token contract\n     */\n    address public unionToken;\n\n    /**\n     *  @dev Address of the asset manager contract\n     */\n    address public assetManager;\n\n    /**\n     *  @dev uToken contract\n     */\n    IUToken public uToken;\n\n    /**\n     *  @dev Comptroller contract\n     */\n    IComptroller public comptroller;\n\n    /**\n     * @dev Number of vouches needed to become a member\n     */\n    uint256 public effectiveCount;\n\n    /**\n     *  @dev New member fee\n     */\n    uint256 public newMemberFee;\n\n    /**\n     *  @dev Total amount of staked staked token\n     */\n    uint256 public totalStaked;\n\n    /**\n     *  @dev Total amount of stake frozen\n     */\n    uint256 public totalFrozen;\n\n    /**\n     *  @dev Max blocks can be overdue for\n     */\n    uint256 public maxOverdueBlocks;\n\n    /**\n     * @dev Max voucher limit\n     */\n    uint256 public maxVouchers;\n\n    /**\n     *  @dev Union Stakers\n     */\n    mapping(address => Staker) public stakers;\n\n    /**\n     *  @dev Staker (borrower) mapped to recieved vouches (staker)\n     */\n    mapping(address => Vouch[]) public vouchers;\n\n    /**\n     * @dev Borrower mapped to Staker mapped to index in vouchers array\n     */\n    mapping(address => mapping(address => Index)) public voucherIndexes;\n\n    /**\n     *  @dev Staker (staker) mapped to vouches given (borrower)\n     */\n    mapping(address => Vouchee[]) public vouchees;\n\n    /**\n     * @dev Borrower mapped to Staker mapped to index in vochee array\n     */\n    mapping(address => mapping(address => Index)) public voucheeIndexes;\n\n    /**\n     * @dev Stakers frozen amounts\n     */\n    mapping(address => uint256) public memberFrozen;\n\n    /* -------------------------------------------------------------------\n      Errors \n    ------------------------------------------------------------------- */\n\n    error AuthFailed();\n    error ErrorSelfVouching();\n    error TrustAmountLtLocked();\n    error NoExistingMember();\n    error NotEnoughStakers();\n    error StakeLimitReached();\n    error AssetManagerDepositFailed();\n    error AssetManagerWithdrawFailed();\n    error InsufficientBalance();\n    error LockedStakeNonZero();\n    error NotOverdue();\n    error ExceedsLocked();\n    error AmountZero();\n    error LockedRemaining();\n    error VoucherNotFound();\n    error VouchWhenOverdue();\n    error MaxVouchees();\n    error InvalidParams();\n\n    /* -------------------------------------------------------------------\n      Events \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Add new member event\n     *  @param member New member address\n     */\n    event LogAddMember(address member);\n\n    /**\n     *  @dev Update vouch for existing member event\n     *  @param staker Trustee address\n     *  @param borrower The address gets vouched for\n     *  @param trustAmount Vouch amount\n     */\n    event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);\n\n    /**\n     *  @dev New member application event\n     *  @param account New member's voucher address\n     *  @param borrower New member address\n     */\n    event LogRegisterMember(address indexed account, address indexed borrower);\n\n    /**\n     *  @dev Cancel vouching for other member event\n     *  @param account New member's voucher address\n     *  @param borrower The address gets vouched for\n     */\n    event LogCancelVouch(address indexed account, address indexed borrower);\n\n    /**\n     *  @dev Stake event\n     *  @param account The staker's address\n     *  @param amount The amount of tokens to stake\n     */\n    event LogStake(address indexed account, uint256 amount);\n\n    /**\n     *  @dev Unstake event\n     *  @param account The staker's address\n     *  @param amount The amount of tokens to unstake\n     */\n    event LogUnstake(address indexed account, uint256 amount);\n\n    /**\n     *  @dev DebtWriteOff event\n     *  @param staker The staker's address\n     *  @param borrower The borrower's address\n     *  @param amount The amount of write off\n     */\n    event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);\n\n    /**\n     *  @dev set utoken address\n     *  @param uToken new uToken address\n     */\n    event LogSetUToken(address uToken);\n\n    /**\n     *  @dev set new member fee\n     *  @param oldMemberFee old member fee\n     *  @param newMemberFee new member fee\n     */\n    event LogSetNewMemberFee(uint256 oldMemberFee, uint256 newMemberFee);\n\n    /**\n     *  @dev set max stake amount\n     *  @param oldMaxStakeAmount Old amount\n     *  @param newMaxStakeAmount New amount\n     */\n    event LogSetMaxStakeAmount(uint256 oldMaxStakeAmount, uint256 newMaxStakeAmount);\n\n    /**\n     *  @dev set max overdue blocks\n     *  @param oldMaxOverdueBlocks Old value\n     *  @param newMaxOverdueBlocks New value\n     */\n    event LogSetMaxOverdueBlocks(uint256 oldMaxOverdueBlocks, uint256 newMaxOverdueBlocks);\n\n    /**\n     *  @dev set effective count\n     *  @param oldEffectiveCount Old value\n     *  @param newEffectiveCount New value\n     */\n    event LogSetEffectiveCount(uint256 oldEffectiveCount, uint256 newEffectiveCount);\n\n    /**\n     * @dev Set max voucher\n     * @param maxVouchers new max voucher limit\n     */\n    event LogSetMaxVouchers(uint256 maxVouchers);\n\n    /* -------------------------------------------------------------------\n      Constructor/Initializer \n    ------------------------------------------------------------------- */\n\n    function __UserManager_init(\n        address assetManager_,\n        address unionToken_,\n        address stakingToken_,\n        address comptroller_,\n        address admin_,\n        uint256 maxOverdueBlocks_,\n        uint256 effectiveCount_,\n        uint256 maxVouchers_\n    ) public initializer {\n        Controller.__Controller_init(admin_);\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        comptroller = IComptroller(comptroller_);\n        assetManager = assetManager_;\n        unionToken = unionToken_;\n        stakingToken = stakingToken_;\n        newMemberFee = 1 ether;\n        maxStakeAmount = 10_000e18;\n        maxOverdueBlocks = maxOverdueBlocks_;\n        effectiveCount = effectiveCount_;\n        maxVouchers = maxVouchers_;\n    }\n\n    /* -------------------------------------------------------------------\n      Modifiers \n    ------------------------------------------------------------------- */\n\n    modifier onlyMember(address account) {\n        if (!checkIsMember(account)) revert AuthFailed();\n        _;\n    }\n\n    modifier onlyMarket() {\n        if (address(uToken) != msg.sender) revert AuthFailed();\n        _;\n    }\n\n    modifier onlyComptroller() {\n        if (address(comptroller) != msg.sender) revert AuthFailed();\n        _;\n    }\n\n    /* -------------------------------------------------------------------\n      Setters \n    ------------------------------------------------------------------- */\n\n    /**\n     * @dev Set the max amount that a user can stake\n     * Emits {LogSetMaxStakeAmount} event\n     * @param maxStakeAmount_ The max stake amount\n     */\n    function setMaxStakeAmount(uint96 maxStakeAmount_) external onlyAdmin {\n        uint96 oldMaxStakeAmount = maxStakeAmount;\n        maxStakeAmount = maxStakeAmount_;\n        emit LogSetMaxStakeAmount(uint256(oldMaxStakeAmount), uint256(maxStakeAmount));\n    }\n\n    /**\n     * @dev set the UToken contract address\n     * Emits {LogSetUToken} event\n     * @param uToken_ UToken contract address\n     */\n    function setUToken(address uToken_) external onlyAdmin {\n        uToken = IUToken(uToken_);\n        emit LogSetUToken(uToken_);\n    }\n\n    /**\n     * @dev set New Member fee\n     * @dev The amount of UNION an account must burn to become a member\n     * Emits {LogSetNewMemberFee} event\n     * @param amount New member fee amount\n     */\n    function setNewMemberFee(uint256 amount) external onlyAdmin {\n        uint256 oldMemberFee = newMemberFee;\n        newMemberFee = amount;\n        emit LogSetNewMemberFee(oldMemberFee, amount);\n    }\n\n    /**\n     * @dev set New max overdue blocks\n     * Emits {LogSetMaxOverdueBlocks} event\n     * @param _maxOverdueBlocks New maxOverdueBlocks value\n     */\n    function setMaxOverdueBlocks(uint256 _maxOverdueBlocks) external onlyAdmin {\n        uint256 oldMaxOverdueBlocks = maxOverdueBlocks;\n        maxOverdueBlocks = _maxOverdueBlocks;\n        emit LogSetMaxOverdueBlocks(oldMaxOverdueBlocks, _maxOverdueBlocks);\n    }\n\n    /**\n     * @dev set New effective count\n     * @dev this is the number of vouches an account needs in order\n     *      to register as a member\n     * Emits {LogSetEffectiveCount} event\n     * @param _effectiveCount New effectiveCount value\n     */\n    function setEffectiveCount(uint256 _effectiveCount) external onlyAdmin {\n        uint256 oldEffectiveCount = effectiveCount;\n        effectiveCount = _effectiveCount;\n        emit LogSetEffectiveCount(oldEffectiveCount, _effectiveCount);\n    }\n\n    function setMaxVouchers(uint256 _maxVouchers) external onlyAdmin {\n        maxVouchers = _maxVouchers;\n        emit LogSetMaxVouchers(_maxVouchers);\n    }\n\n    /* -------------------------------------------------------------------\n      View Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Check if the account is a valid member\n     *  @param account Member address\n     *  @return Address whether is member\n     */\n    function checkIsMember(address account) public view returns (bool) {\n        return stakers[account].isMember;\n    }\n\n    /**\n     *  @dev  Get the member's available credit limit\n     *  @dev  IMPORTANT: This function can take up a tonne of gas as the vouchers[address] array\n     *        grows in size. the maxVoucher limit will ensure this function can always run within a\n     *        single block but it is intended only to be used as a view function called from a UI\n     *  @param borrower Member address\n     *  @return total Credit line amount\n     */\n    function getCreditLimit(address borrower) external view returns (uint256 total) {\n        for (uint256 i = 0; i < vouchers[borrower].length; i++) {\n            Vouch memory vouch = vouchers[borrower][i];\n            Staker memory staker = stakers[vouch.staker];\n            total += _min(staker.stakedAmount - staker.locked, vouch.trust - vouch.locked);\n        }\n    }\n\n    /**\n     *  @dev  Get the count of vouchers\n     *        Vouchers are addresses that this borrower is recieving a vouch from.\n     *  @param borrower Address of borrower\n     */\n    function getVoucherCount(address borrower) external view returns (uint256) {\n        return vouchers[borrower].length;\n    }\n\n    /**\n     *  @dev  Get the count of vouchees\n     *        Voucheers are addresses that this staker is vouching for\n     *  @param staker Address of staker\n     */\n    function getVoucheeCount(address staker) external view returns (uint256) {\n        return vouchees[staker].length;\n    }\n\n    /**\n     *  @dev Get the user's deposited stake amount\n     *  @param account Member address\n     *  @return Deposited stake amount\n     */\n    function getStakerBalance(address account) external view returns (uint256) {\n        return stakers[account].stakedAmount;\n    }\n\n    /**\n     *  @dev Get frozen coin age\n     *  @param  staker Address of staker\n     *  @param  pastBlocks Number of blocks past to calculate coin age from\n     *          coin age = min(block.number - lastUpdated, pastBlocks) * amount\n     */\n    function getFrozenInfo(address staker, uint256 pastBlocks)\n        public\n        view\n        returns (uint256 memberTotalFrozen, uint256 memberFrozenCoinAge)\n    {\n        uint256 overdueBlocks = uToken.overdueBlocks();\n        uint256 voucheesLength = vouchees[staker].length;\n        // Loop through all of the stakers vouchees sum their total\n        // locked balance and sum their total memberFrozenCoinAge\n        for (uint256 i = 0; i < voucheesLength; i++) {\n            // Get the vouchee record and look up the borrowers voucher record\n            // to get the locked amount and lastUpdate block number\n            Vouchee memory vouchee = vouchees[staker][i];\n            Vouch memory vouch = vouchers[vouchee.borrower][vouchee.voucherIndex];\n\n            uint256 lastUpdated = vouch.lastUpdated;\n            uint256 diff = block.number - lastUpdated;\n\n            if (overdueBlocks < diff) {\n                uint96 locked = vouch.locked;\n                memberTotalFrozen += locked;\n                if (pastBlocks >= diff) {\n                    memberFrozenCoinAge += (locked * diff);\n                } else {\n                    memberFrozenCoinAge += (locked * pastBlocks);\n                }\n            }\n        }\n    }\n\n    /**\n     *  @dev Get Total locked stake\n     *  @param staker Staker address\n     */\n    function getTotalLockedStake(address staker) external view returns (uint256) {\n        return stakers[staker].locked;\n    }\n\n    /**\n     *  @dev Get staker locked stake for a borrower\n     *  @param staker Staker address\n     *  @param borrower Borrower address\n     *  @return LockedStake\n     */\n    function getLockedStake(address staker, address borrower) external view returns (uint256) {\n        Index memory index = voucherIndexes[borrower][staker];\n        if (!index.isSet) return 0;\n        return vouchers[borrower][index.idx].locked;\n    }\n\n    /**\n     *  @dev Get vouching amount\n     *  @param _staker Staker address\n     *  @param borrower Borrower address\n     */\n    function getVouchingAmount(address _staker, address borrower) external view returns (uint256) {\n        Index memory index = voucherIndexes[borrower][_staker];\n        Staker memory staker = stakers[_staker];\n        if (!index.isSet) return 0;\n        uint96 trustAmount = vouchers[borrower][index.idx].trust;\n        return trustAmount < staker.stakedAmount ? trustAmount : staker.stakedAmount;\n    }\n\n    /* -------------------------------------------------------------------\n      Core Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Manually add union members and bypass all the requirements of `registerMember`\n     *  Only accepts calls from the admin\n     *  Emit {LogAddMember} event\n     *  @param account Member address\n     */\n    function addMember(address account) external onlyAdmin {\n        stakers[account].isMember = true;\n        emit LogAddMember(account);\n    }\n\n    /**\n     *  @dev  Update the trust amount for exisitng members.\n     *  @dev  Trust is the amount of the underlying token you would in theory be\n     *        happy to lend to another member. Vouch is derived from trust and stake.\n     *        Vouch is the minimum of trust and staked amount.\n     *  Emits {LogUpdateTrust} event\n     *  @param borrower Account address\n     *  @param trustAmount Trust amount\n     */\n    function updateTrust(address borrower, uint96 trustAmount) external onlyMember(msg.sender) whenNotPaused {\n        address staker = msg.sender;\n        if (borrower == staker) revert ErrorSelfVouching();\n        if (!checkIsMember(staker)) revert AuthFailed();\n\n        // Check if this staker is already vouching for this borrower\n        // If they are already vouching then update the existing vouch record\n        // If this is a new vouch then insert a new Vouch record\n        Index memory index = voucherIndexes[borrower][staker];\n        if (index.isSet) {\n            // Update existing record checking that the new trust amount is\n            // not less than the amount of stake currently locked by the borrower\n            Vouch storage vouch = vouchers[borrower][index.idx];\n            if (trustAmount < vouch.locked) revert TrustAmountLtLocked();\n            vouch.trust = trustAmount;\n        } else {\n            // If the member is overdue they cannot create new vouches they can\n            // only update existing vouches\n            if (uToken.checkIsOverdue(staker)) revert VouchWhenOverdue();\n\n            // This is a new vouch so we need to check that the\n            // member has not reached the max voucher limit\n            uint256 voucheesLength = vouchees[staker].length;\n            if (voucheesLength >= maxVouchers) revert MaxVouchees();\n\n            // Get the new index that this vouch is going to be inserted at\n            // Then update the voucher indexes for this borrower as well as\n            // Adding the Vouch the the vouchers array for this staker\n            uint256 voucherIndex = vouchers[borrower].length;\n            voucherIndexes[borrower][staker] = Index(true, uint128(voucherIndex));\n            vouchers[borrower].push(Vouch(staker, trustAmount, 0, 0));\n\n            // Add the voucherIndex of this new vouch to the vouchees array for this\n            // staker then update the voucheeIndexes with the voucheeIndex\n            uint256 voucheeIndex = voucheesLength;\n            vouchees[staker].push(Vouchee(borrower, uint96(voucherIndex)));\n            voucheeIndexes[borrower][staker] = Index(true, uint128(voucheeIndex));\n        }\n\n        emit LogUpdateTrust(staker, borrower, trustAmount);\n    }\n\n    /**\n     *  @dev Remove voucher for memeber\n     *  Can be called by either the borrower or the staker. It will remove the voucher from\n     *  the voucher array by replacing it with the last item of the array and reseting the array\n     *  size to -1 by poping off the last item\n     *  Only callable by a member when the contract is not paused\n     *  Emit {LogCancelVouch} event\n     *  @param staker Staker address\n     *  @param borrower borrower address\n     */\n    function cancelVouch(address staker, address borrower) public onlyMember(msg.sender) whenNotPaused {\n        if (staker != msg.sender && borrower != msg.sender) revert AuthFailed();\n\n        Index memory voucherIndex = voucherIndexes[borrower][staker];\n        if (!voucherIndex.isSet) revert VoucherNotFound();\n\n        // Check that the locked amount for this vouch is 0\n        Vouch memory vouch = vouchers[borrower][voucherIndex.idx];\n        if (vouch.locked > 0) revert LockedStakeNonZero();\n\n        // Remove borrower from vouchers array by moving the last item into the position\n        // of the index being removed and then poping the last item off the array\n        vouchers[borrower][voucherIndex.idx] = vouchers[borrower][vouchers[borrower].length - 1];\n        vouchers[borrower].pop();\n        delete voucherIndexes[borrower][staker];\n\n        // Remove borrower from vouchee array by moving the last item into the position\n        // of the index being removed and then poping the last item off the array\n        Index memory voucheeIndex = voucheeIndexes[borrower][staker];\n        vouchees[staker][voucheeIndex.idx] = vouchees[staker][vouchees[staker].length - 1];\n        vouchees[staker].pop();\n        delete voucheeIndexes[borrower][staker];\n\n        emit LogCancelVouch(staker, borrower);\n    }\n\n    /**\n     *  @notice Register a a member using a signed permit\n     *  @dev See registerMember\n     *  @param newMember New member address\n     *  @param value Amount approved by permit\n     *  @param deadline Timestamp for when the permit expires\n     *  @param v secp256k1 signature part\n     *  @param r secp256k1 signature part\n     *  @param s secp256k1 signature part\n     */\n    function registerMemberWithPermit(\n        address newMember,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external whenNotPaused {\n        IUnionToken unionTokenContract = IUnionToken(unionToken);\n        unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);\n        registerMember(newMember);\n    }\n\n    /**\n     *  @notice Register a a member, and burn an application fees\n     *  @dev    In order to register as a member an address must be recieving x amount\n     *          of vouches greater than 0 from stakers. x is defined by `effectiveCount`\n     *          Emits {LogRegisterMember} event\n     *  @param newMember New member address\n     */\n    function registerMember(address newMember) public virtual whenNotPaused {\n        if (stakers[newMember].isMember) revert NoExistingMember();\n\n        uint256 count = 0;\n        uint256 vouchersLength = vouchers[newMember].length;\n\n        // Loop through all the vouchers to count how many active vouches there\n        // are that are greater than 0. Vouch is the min of stake and trust\n        for (uint256 i = 0; i < vouchersLength; i++) {\n            Vouch memory vouch = vouchers[newMember][i];\n            Staker memory staker = stakers[vouch.staker];\n            if (staker.stakedAmount > 0) count++;\n            if (count >= effectiveCount) break;\n        }\n\n        if (count < effectiveCount) revert NotEnoughStakers();\n\n        stakers[newMember].isMember = true;\n        IUnionToken(unionToken).burnFrom(msg.sender, newMemberFee);\n\n        emit LogRegisterMember(msg.sender, newMember);\n    }\n\n    /**\n     *  @notice Stake staking tokens\n     *  @dev    Stake is used to underwrite loans and becomes locked if a\n     *          member a staker has vouched for borrows against it.\n     *          Stake also earns rewards from the comptroller\n     *  Emits a {LogStake} event.\n     *  @param amount Amount to stake\n     */\n    function stake(uint96 amount) public whenNotPaused nonReentrant {\n        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);\n\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        Staker storage staker = stakers[msg.sender];\n\n        if (staker.stakedAmount + amount > maxStakeAmount) revert StakeLimitReached();\n\n        staker.stakedAmount += amount;\n        totalStaked += amount;\n\n        erc20Token.safeTransferFrom(msg.sender, address(this), amount);\n        erc20Token.safeApprove(assetManager, 0);\n        erc20Token.safeApprove(assetManager, amount);\n\n        if (!IAssetManager(assetManager).deposit(stakingToken, amount)) revert AssetManagerDepositFailed();\n        emit LogStake(msg.sender, amount);\n    }\n\n    /**\n     *  @notice Unstake staking token\n     *  @dev    Tokens can only be unstaked if they are not locked. ie a\n     *          vouchee is not borrowing against them.\n     *  Emits {LogUnstake} event\n     *  @param amount Amount to unstake\n     */\n    function unstake(uint96 amount) external whenNotPaused nonReentrant {\n        Staker storage staker = stakers[msg.sender];\n\n        // Stakers can only unstaked stake balance that is unlocked. Stake balance\n        // becomes locked when it is used to underwrite a borrow.\n        if (staker.stakedAmount - staker.locked < amount) revert InsufficientBalance();\n\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        staker.stakedAmount -= amount;\n        totalStaked -= amount;\n\n        if (!IAssetManager(assetManager).withdraw(stakingToken, msg.sender, amount)) {\n            revert AssetManagerWithdrawFailed();\n        }\n\n        emit LogUnstake(msg.sender, amount);\n    }\n\n    /**\n     *  @dev collect staker rewards from the comptroller\n     */\n    function withdrawRewards() external whenNotPaused nonReentrant {\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n    }\n\n    /**\n     *  @notice Write off a borrowers debt\n     *  @dev    Used the stakers locked stake to write off the loan, transfering the\n     *          Stake to the AssetManager and adjusting balances in the AssetManager\n     *          and the UToken to repay the principal\n     *  @dev    Emits {LogDebtWriteOff} event\n     *  @param borrower address of borrower\n     *  @param amount amount to writeoff\n     */\n    function debtWriteOff(\n        address staker,\n        address borrower,\n        uint96 amount\n    ) external {\n        if (amount == 0) revert AmountZero();\n        uint256 overdueBlocks = uToken.overdueBlocks();\n        uint256 lastRepay = uToken.getLastRepay(borrower);\n\n        // This function is only callable by the public if the loan is overdue by\n        // overdue blocks + maxOverdueBlocks. This stops the system being left with\n        // debt that is overdue indefinitely and no ability to do anything about it.\n        if (block.number <= lastRepay + overdueBlocks + maxOverdueBlocks) {\n            if (staker != msg.sender) revert AuthFailed();\n        }\n\n        Index memory index = voucherIndexes[borrower][staker];\n        if (!index.isSet) revert VoucherNotFound();\n        Vouch storage vouch = vouchers[borrower][index.idx];\n\n        if (amount > vouch.locked) revert ExceedsLocked();\n\n        // update staker staked amount\n        stakers[staker].stakedAmount -= amount;\n        stakers[staker].locked -= amount;\n        totalStaked -= amount;\n\n        // update vouch trust amount\n        vouch.trust -= amount;\n        vouch.locked -= amount;\n\n        // Update total frozen and member frozen. We don't want to move th\n        // burden of calling updateFrozenInfo into this function as it is quite\n        // gas intensive. Instead we just want to remove the amount that was\n        // frozen which is now being written off. However, it is possible that\n        // member frozen has not been updated prior to calling debtWriteOff and\n        // the amount being written off could be greater than the amount frozen.\n        // To avoid an underflow here we need to check this condition\n        uint256 stakerFrozen = memberFrozen[staker];\n        if (amount > stakerFrozen) {\n            // The amount being written off is more than the amount that has\n            // been previously frozen for this staker. Reset their frozen stake\n            // to zero and adjust totalFrozen\n            memberFrozen[staker] = 0;\n            totalFrozen -= stakerFrozen;\n        } else {\n            totalFrozen -= amount;\n            memberFrozen[staker] -= amount;\n        }\n\n        if (vouch.trust == 0) {\n            cancelVouch(staker, borrower);\n        }\n\n        // Notify the AssetManager and the UToken market of the debt write off\n        // so they can adjust their balances accordingly\n        IAssetManager(assetManager).debtWriteOff(stakingToken, uint256(amount));\n        uToken.debtWriteOff(borrower, uint256(amount));\n\n        comptroller.updateTotalStaked(stakingToken, totalStaked - totalFrozen);\n\n        emit LogDebtWriteOff(msg.sender, borrower, uint256(amount));\n    }\n\n    /**\n     *  @notice Borrowing from the market\n     *  @dev    Locks/Unlocks the borrowers stakers staked amounts in a first in\n     *          First out order. Meaning the members that vouched for this borrower\n     *          first will be the first members to get their stake locked or unlocked\n     *          following a borrow or repayment.\n     *  @param borrower The address of the borrower\n     *  @param amount Lock/Unlock amount\n     *  @param lock If the amount is being locked or unlocked\n     */\n    function updateLocked(\n        address borrower,\n        uint96 amount,\n        bool lock\n    ) external onlyMarket {\n        uint96 remaining = amount;\n\n        for (uint256 i = 0; i < vouchers[borrower].length; i++) {\n            Vouch storage vouch = vouchers[borrower][i];\n            uint96 innerAmount;\n\n            if (lock) {\n                // Look up the staker and determine how much unlock stake they\n                // have available for the borrower to borrow. If there is 0\n                // then continue to the next voucher in the array\n                uint96 stakerLocked = stakers[vouch.staker].locked;\n                uint96 stakerStakedAmount = stakers[vouch.staker].stakedAmount;\n                uint96 availableStake = stakerStakedAmount - stakerLocked;\n                uint96 lockAmount = _min(availableStake, vouch.trust - vouch.locked);\n                if (lockAmount == 0) continue;\n\n                // Calculate the amount to add to the lock then\n                // add the extra amount to lock to the stakers locked amount\n                // and also update the vouches locked amount and lastUpdated block\n                innerAmount = _min(remaining, lockAmount);\n                stakers[vouch.staker].locked = stakerLocked + innerAmount;\n                vouch.locked += innerAmount;\n                vouch.lastUpdated = uint64(block.number);\n            } else {\n                // Look up how much this vouch has locked. If it is 0 then\n                // continue to the next voucher. Then calculate the amount to\n                // unlock which is the min of the vouches lock and what is\n                // remaining to unlock\n                uint96 locked = vouch.locked;\n                if (locked == 0) continue;\n                innerAmount = _min(locked, remaining);\n\n                // Update the stored locked values and last updated block\n                stakers[vouch.staker].locked -= innerAmount;\n                vouch.locked -= innerAmount;\n                vouch.lastUpdated = uint64(block.number);\n            }\n\n            remaining -= innerAmount;\n            // If there is no remaining amount to lock/unlock\n            // we can stop looping through vouchers\n            if (remaining <= 0) break;\n        }\n\n        // If we have looped through all the available vouchers for this\n        // borrower and we still have a remaining amount then we have to\n        // revert as there is not enough vouchers to lock/unlock\n        if (remaining > 0) revert LockedRemaining();\n    }\n\n    /**\n     * @dev Update the frozen info for a single staker\n     * @param staker Staker address\n     * @param pastBlocks The past blocks\n     * @return  memberTotalFrozen Total frozen amount for this staker\n     *          memberFrozenCoinAge Total frozen coin age for this staker\n     */\n    function _updateFrozen(address staker, uint256 pastBlocks) internal returns (uint256, uint256) {\n        (uint256 memberTotalFrozen, uint256 memberFrozenCoinAge) = getFrozenInfo(staker, pastBlocks);\n\n        uint256 memberFrozenBefore = memberFrozen[staker];\n        if (memberFrozenBefore != memberTotalFrozen) {\n            memberFrozen[staker] = memberTotalFrozen;\n            totalFrozen = totalFrozen - memberFrozenBefore + memberTotalFrozen;\n        }\n\n        return (memberTotalFrozen, memberFrozenCoinAge);\n    }\n\n    /**\n     * @dev Update the frozen info by the comptroller\n     * @param staker Staker address\n     * @param pastBlocks The past blocks\n     * @return  memberTotalFrozen Total frozen amount for this staker\n     *          memberFrozenCoinAge Total frozen coin age for this staker\n     */\n    function updateFrozenInfo(address staker, uint256 pastBlocks) external onlyComp"
    }
  ]
}