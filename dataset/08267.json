{
  "Title": "[M-04] Persisted msg.value in a loop of delegate calls can be used to drain ETH from your proxy",
  "Content": "_Submitted by peritoflores, also found by 8olidity and vlad&#95;bochok_\n\n`msg.value` in a loop can be used to drain proxy funds.\n\n### Proof of Concept\n\nWhile `BoringBatchable` is out of the scope, this bug affects seriously `MIMOProxy` as it inherits.\n\nSome time ago I read a report about an auditor called *samczsun*  (<https://samczsun.com/two-rights-might-make-a-wrong/>).     I believe that you are having the same problem here.\n\nI will try to  explain it as brief as possible but I can add a PoC in QA stage if required.\n\n#### First step: Draining ETH\n\nThis vulnerability comes from the fact that `msg.value` and `msg.sender` are persisted in `delegatecall`.\n\nIt is possible to call  `execute()` (which is payable ) from  `batch()` (which is also payable )   because both are public functions.   (For now ignore the fact that `execute()` has access control).\n\nThe attacker would call `batch()` sending, for example, 1 ETH with an array of 100 equal items that call `execute()`\n\nThis `execute()` will call and external contract 100 times and in every time it will send 1ETH from proxy funds (not from the attacker).\n\nIf the receiving contract stores these value then the proxy wallet will be drained.\n\n#### Second step: Access control bypass scenario\n\nWhile this is already a high risk and there should be many attacking scenarios I would like to show you a pretty simple one.\n\nSuppose the owner would like to grant access to a target with a normal function    (maybe no even `payable`).\n\nFor example   suppose that the owner grant access to the function\n\n      function goodFunction() public \n\nThis function has the selector  `0x0d092393` .   However, for some reason. the owner mistyped the selector  and grant access  to non existing function `0x0d09392`.\n\nThen if the target contract has the  so common function.\n\n    fallback() external payable {  }\n\nThen the attacker can drain wallet funds using this selector as I explained above.\n\n### Recommended Mitigation Steps\n\nThe solution is pretty straightforward.\n\nRemove `payable`  from `batch()` in `BoringBatchable`.\n\n**[horsefacts (warden) commented](https://github.com/code-423n4/2022-08-mimo-findings/issues/153#issuecomment-1208687301):**\n > Agree this is possible. I would note that there is a [big warning](https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/libraries/BoringBatchable.sol#L8) at the top of `BoringBatchable` that links this very blog post.\n\n**[RayXpub (Mimo) commented](https://github.com/code-423n4/2022-08-mimo-findings/issues/153#issuecomment-1210483318):**\n > We are not modifying any state in the `MimoProxy` based on msg.value, so this doesn't apply here. Please refer to our test case [here](https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/test/02_integration/MIMOVaultActions.test.ts#L226).\n\n**[peritoflores (warden) commented](https://github.com/code-423n4/2022-08-mimo-findings/issues/153#issuecomment-1212105445):**\n > Hi @RayXpub .   I found that there is an error in the test case that you mentioned.\n> The test is passing because the contract has no ETH and you call batch with false parameter.\n> \n> The second delegatecall is reverting.    However, by design delegatecall  will not revert the main transaction and instead will return false that is ignored in this case.\n> \n> To show you this I have created a PoC with a few modification to your original test.\n> I just send ETH before and then compared that the amount deposited was double.\n> \n> \n>     it(\"PoC: should be able to reuse msg.value for multiple deposits\", async () => {\n>     const { mimoProxy, vaultActions, vaultsDataProvider, wmatic } = await setup();\n>     \n>     //Send ETH to the proxy RECEIVE EXTERNAL PAYABLE\n>     const [owner] = await ethers.getSigners();\n>     owner.sendTransaction({ to: mimoProxy.address, value: DEPOSIT_AMOUNT });\n>     await mimoProxy.execute(vaultActions.address, vaultActions.interface.encodeFunctionData(\"depositETH\"), {\n>       value: DEPOSIT_AMOUNT,\n>     });\n>     const vaultIdBefore = await vaultsDataProvider.vaultId(wmatic.address, mimoProxy.address);\n>     const vaultBalanceBefore = await vaultsDataProvider.vaultCollateralBalance(vaultIdBefore);\n>     const data = vaultActions.interface.encodeFunctionData(\"depositETH\");\n>     mimoProxy.batch(\n>       [\n>         mimoProxy.interface.encodeFunctionData(\"execute\", [vaultActions.address, data]),\n>         mimoProxy.interface.encodeFunctionData(\"execute\", [vaultActions.address, data]),\n>       ],\n>       true,\n>       { value: DEPOSIT_AMOUNT },\n>     );\n>     const vaultId = await vaultsDataProvider.vaultId(wmatic.address, mimoProxy.address);\n>     const vaultBalanceAfter = await vaultsDataProvider.vaultCollateralBalance(vaultId);\n>     expect(vaultBalanceAfter).to.be.equal(vaultBalanceBefore.add(DEPOSIT_AMOUNT).add(DEPOSIT_AMOUNT));}\n>     );\n> \n> \n> \n\n**[RayXpub (Mimo) disagreed with severity and commented](https://github.com/code-423n4/2022-08-mimo-findings/issues/153#issuecomment-1213124377):**\n > Hi @peritoflores ,\n> \n> Thanks for providing a PoC. It seems we misunderstood the issue as we were looking at it in the context of the miso platform vulnerability described in the paradigm article where it is our understanding that the issue was a `msg.value` reliant state update. Here ETH are actually transferred in each call. However, for an attacker to be able to call `execute()` he would need to have been granted permission, so that would rely an approval made by the `MIMOProxy` owner. \n> \n> In the case of the fallback function this would require the owner making a mistake while granting permission by entering an erroneous selector and the target contract would need to have a fallback. \n> \n> As we do not see any scenario where this issue would work without a user mistake we consider that this should be labeled as medium risk. But we are considering making all the `MIMOProxy` functions non payable, this is still being discussed. \n> \n> Btw the PoC provided is missing an `await` on the `owner.sendTransaction` line which ends up not really showcasing the issue but we did manage to reproduce the scenario.\n\n**[gzeoneth (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-08-mimo-findings/issues/153#issuecomment-1221559832):**\n > Agree this is not High Risk due to the requirement of owner privilege.\n\n**horsefacts (warden) reviewed mitigation:**\n> **Status:** ðŸ‘ Acknowledged\n\n> **Finding:** Wardens identified that calling `payable` functions via `BoringBatchable#batch` could lead to double spends or reuse of `msg.value`.\n\n> **What changed:** The Mimo team have acknowledged the risk of `payable` calls to `BoringBatchable#batch`. \n\n> **Acknowledgment:**\n> > In no normal usage of the `MIMOProxy` should there ever be ETH stuck in the contract.<br>\n> > In the future, we might need `batch` to be `payable`. For example, our main protocol supports calls such as `depositETH` and `depositETHAndBorrow`, which we do want to work with the `MIMOProxy`.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-08-mimo-august-2022-contest",
  "Code": [
    {
      "filename": "contracts/libraries/BoringBatchable.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\n// solhint-disable avoid-low-level-calls\n// solhint-disable no-inline-assembly\n\n// WARNING!!!\n// Combining BoringBatchable with msg.value can cause double spending issues\n// https://www.paradigm.xyz/2021/08/two-rights-might-make-a-wrong/\n\ncontract BoringBatchable {\n  error BatchError(bytes innerError);\n\n  /// @dev Helper function to extract a useful revert message from a failed call.\n  /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.\n  function _getRevertMsg(bytes memory _returnData) internal pure {\n    // If the _res length is less than 68, then\n    // the transaction failed with custom error or silently (without a revert message)\n    if (_returnData.length < 68) revert BatchError(_returnData);\n\n    assembly {\n      // Slice the sighash.\n      _returnData := add(_returnData, 0x04)\n    }\n    revert(abi.decode(_returnData, (string))); // All that remains is the revert string\n  }\n\n  /// @notice Allows batched call to self (this contract).\n  /// @param calls An array of inputs for each call.\n  /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.\n  // F1: External is ok here because this is the batch function, adding it to a batch makes no sense\n  // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value\n  // C3: The length of the loop is fully under user control, so can't be exploited\n  // C7: Delegatecall is only used on the same contract, so it's safe\n  function batch(bytes[] calldata calls, bool revertOnFail) external payable {\n    for (uint256 i = 0; i < calls.length; i++) {\n      (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\n      if (!success && revertOnFail) {\n        _getRevertMsg(result);\n      }\n    }\n  }\n}"
    },
    {
      "filename": "test/02_integration/MIMOVaultActions.test.ts",
      "content": "import chai, { expect } from \"chai\";\nimport { solidity } from \"ethereum-waffle\";\nimport { deployments, ethers, network } from \"hardhat\";\nimport { ADDRESSES } from \"../../config/addresses\";\nimport { POLYGON_ENDPOINT } from \"../../hardhat.config\";\nimport {\n  IAccessController,\n  IAddressProvider,\n  IConfigProvider,\n  ISTABLEX,\n  IVaultsCore,\n  IVaultsDataProvider,\n  IWETH,\n  MIMOProxy,\n  MIMOProxyRegistry,\n  MIMOVaultActions,\n} from \"../../typechain\";\n\nchai.use(solidity);\n\nconst DEPOSIT_AMOUNT = ethers.utils.parseEther(\"50\");\nconst BORROW_AMOUNT = ethers.utils.parseEther(\"5\");\nconst WAD = ethers.constants.WeiPerEther;\n\nconst setup = deployments.createFixture(async () => {\n  const [owner] = await ethers.getSigners();\n  const chainAddresses = ADDRESSES[\"137\"];\n  process.env.FORK_ID = \"137\";\n\n  // Fork polygon mainnet\n  await network.provider.request({\n    method: \"hardhat_reset\",\n    params: [\n      {\n        forking: {\n          jsonRpcUrl: POLYGON_ENDPOINT,\n        },\n      },\n    ],\n  });\n\n  // Impersonate multisig\n  await network.provider.request({\n    method: \"hardhat_impersonateAccount\",\n    params: [chainAddresses.MULTISIG],\n  });\n  const multisig = await ethers.getSigner(chainAddresses.MULTISIG);\n\n  // Deploy Proxy contracts\n  await deployments.fixture([\"Proxy\", \"MIMOVaultActions\"]);\n\n  // Fetch contracts\n  const addressProvider: IAddressProvider = await ethers.getContractAt(\n    \"IAddressProvider\",\n    chainAddresses.ADDRESS_PROVIDER,\n  );\n  const [vaultsCoreAddress, vaultsDataProviderAddress, accessControllerAddress, stablexAddress, configProviderAddress] =\n    await Promise.all([\n      addressProvider.core(),\n      addressProvider.vaultsData(),\n      addressProvider.controller(),\n      addressProvider.stablex(),\n      addressProvider.config(),\n    ]);\n\n  const [\n    vaultsCore,\n    vaultsDataProvider,\n    accessController,\n    stablex,\n    wmatic,\n    mimoProxyRegistry,\n    configProvider,\n    vaultActions,\n  ] = (await Promise.all([\n    ethers.getContractAt(\"IVaultsCore\", vaultsCoreAddress),\n    ethers.getContractAt(\"IVaultsDataProvider\", vaultsDataProviderAddress),\n    ethers.getContractAt(\"IAccessController\", accessControllerAddress),\n    ethers.getContractAt(\"ISTABLEX\", stablexAddress),\n    ethers.getContractAt(\"IWETH\", chainAddresses.WMATIC),\n    ethers.getContract(\"MIMOProxyRegistry\"),\n    ethers.getContractAt(\"IConfigProvider\", configProviderAddress),\n    ethers.getContract(\"MIMOVaultActions\"),\n  ])) as [\n    IVaultsCore,\n    IVaultsDataProvider,\n    IAccessController,\n    ISTABLEX,\n    IWETH,\n    MIMOProxyRegistry,\n    IConfigProvider,\n    MIMOVaultActions,\n  ];\n\n  await mimoProxyRegistry.deploy();\n  const deployedMIMOProxy = await mimoProxyRegistry.getCurrentProxy(owner.address);\n  const mimoProxy: MIMOProxy = await ethers.getContractAt(\"MIMOProxy\", deployedMIMOProxy);\n\n  // Get WMATIC and approve them for MIMOProxy\n  await wmatic.deposit({ value: DEPOSIT_AMOUNT });\n  await wmatic.approve(mimoProxy.address, DEPOSIT_AMOUNT);\n\n  // Give minter role to owner\n  owner.sendTransaction({ to: multisig.address, value: ethers.utils.parseEther(\"20\") });\n  const MINITER_ROLE = await accessController.MINTER_ROLE();\n  await accessController.connect(multisig).grantRole(MINITER_ROLE, owner.address);\n  await stablex.approve(mimoProxy.address, ethers.constants.MaxUint256);\n\n  return {\n    owner,\n    addressProvider,\n    vaultsCore,\n    vaultsDataProvider,\n    configProvider,\n    vaultActions,\n    mimoProxy,\n    wmatic,\n    stablex,\n  };\n});\n\ndescribe(\"--- MIMOVaultActions Integration Tests ---\", () => {\n  it(\"should be able to deposit\", async () => {\n    const { mimoProxy, wmatic, vaultActions, vaultsDataProvider } = await setup();\n    await mimoProxy.execute(\n      vaultActions.address,\n      vaultActions.interface.encodeFunctionData(\"deposit\", [wmatic.address, DEPOSIT_AMOUNT]),\n    );\n    const vaultId = await vaultsDataProvider.vaultId(wmatic.address, mimoProxy.address);\n    const vaultBalance = await vaultsDataProvider.vaultCollateralBalance(vaultId);\n    expect(vaultBalance).to.be.equal(DEPOSIT_AMOUNT);\n  });\n  it(\"should be able to deposit ETH\", async () => {\n    const { mimoProxy, wmatic, vaultActions, vaultsDataProvider } = await setup();\n    await mimoProxy.execute(vaultActions.address, vaultActions.interface.encodeFunctionData(\"depositETH\"), {\n      value: DEPOSIT_AMOUNT,\n    });\n    const vaultId = await vaultsDataProvider.vaultId(wmatic.address, mimoProxy.address);\n    const vaultBalance = await vaultsDataProvider.vaultCollateralBalance(vaultId);\n    expect(vaultBalance).to.be.equal(DEPOSIT_AMOUNT);\n  });\n  it(\"should be able to deposit and borrow\", async () => {\n    const { mimoProxy, wmatic, vaultActions, vaultsDataProvider, configProvider } = await setup();\n    await mimoProxy.execute(\n      vaultActions.address,\n      vaultActions.interface.encodeFunctionData(\"depositAndBorrow\", [wmatic.address, DEPOSIT_AMOUNT, BORROW_AMOUNT]),\n    );\n    const vaultId = await vaultsDataProvider.vaultId(wmatic.address, mimoProxy.address);\n    const vaultBalance = await vaultsDataProvider.vaultCollateralBalance(vaultId);\n    const vaultDebt = await vaultsDataProvider.vaultDebt(vaultId);\n    const originationFee = await configProvider.collateralOriginationFee(wmatic.address);\n    expect(vaultBalance).to.be.equal(DEPOSIT_AMOUNT);\n    expect(Number(vaultDebt.sub(BORROW_AMOUNT.add(BORROW_AMOUNT.mul(originationFee).div(WAD))))).to.be.closeTo(0, 1);\n  });\n  it(\"should be able to deposit ETH and borrow\", async () => {\n    const { mimoProxy, wmatic, vaultActions, vaultsDataProvider, configProvider } = await setup();\n    await mimoProxy.execute(\n      vaultActions.address,\n      vaultActions.interface.encodeFunctionData(\"depositETHAndBorrow\", [BORROW_AMOUNT]),\n      { value: DEPOSIT_AMOUNT },\n    );\n    const vaultId = await vaultsDataProvider.vaultId(wmatic.address, mimoProxy.address);\n    const vaultBalance = await vaultsDataProvider.vaultCollateralBalance(vaultId);\n    const vaultDebt = await vaultsDataProvider.vaultDebt(vaultId);\n    const originationFee = await configProvider.collateralOriginationFee(wmatic.address);\n    expect(vaultBalance).to.be.equal(DEPOSIT_AMOUNT);\n    expect(Number(vaultDebt.sub(BORROW_AMOUNT.add(BORROW_AMOUNT.mul(originationFee).div(WAD))))).to.be.closeTo(0, 1);\n  });\n  it(\"should be able to withraw\", async () => {\n    const { mimoProxy, wmatic, vaultActions, vaultsDataProvider } = await setup();\n    await mimoProxy.execute(\n      vaultActions.address,\n      vaultActions.interface.encodeFunctionData(\"deposit\", [wmatic.address, DEPOSIT_AMOUNT]),\n    );\n    const vaultId = await vaultsDataProvider.vaultId(wmatic.address, mimoProxy.address);\n    const vaultBalanceBeforeWithdraw = await vaultsDataProvider.vaultCollateralBalance(vaultId);\n    const mimoProxyBalanceBeforeWithdraw = await wmatic.balanceOf(mimoProxy.address);\n    await mimoProxy.execute(\n      vaultActions.address,\n      vaultActions.interface.encodeFunctionData(\"withdraw\", [vaultId, DEPOSIT_AMOUNT]),\n    );\n    const vaultBalanceAfterWithdraw = await vaultsDataProvider.vaultCollateralBalance(vaultId);\n    const mimoProxyBalanceAfterWithdraw = await wmatic.balanceOf(mimoProxy.address);\n    expect(vaultBalanceBeforeWithdraw).to.be.equal(DEPOSIT_AMOUNT);\n    expect(vaultBalanceAfterWithdraw).to.be.equal(ethers.constants.Zero);\n    expect(mimoProxyBalanceBeforeWithdraw).to.be.equal(ethers.constants.Zero);\n    expect(mimoProxyBalanceAfterWithdraw).to.be.equal(DEPOSIT_AMOUNT);\n  });\n  it(\"should be able to withraw ETH\", async () => {\n    const { mimoProxy, wmatic, vaultActions, vaultsDataProvider } = await setup();\n    await mimoProxy.execute(\n      vaultActions.address,\n      vaultActions.interface.encodeFunctionData(\"deposit\", [wmatic.address, DEPOSIT_AMOUNT]),\n    );\n    const vaultId = await vaultsDataProvider.vaultId(wmatic.address, mimoProxy.address);\n    const vaultBalanceBeforeWithdraw = await vaultsDataProvider.vaultCollateralBalance(vaultId);\n    const mimoProxyBalanceBeforeWithdraw = await ethers.provider.getBalance(mimoProxy.address);\n    await mimoProxy.execute(\n      vaultActions.address,\n      vaultActions.interface.encodeFunctionData(\"withdrawETH\", [vaultId, DEPOSIT_AMOUNT]),\n    );\n    const vaultBalanceAfterWithdraw = await vaultsDataProvider.vaultCollateralBalance(vaultId);\n    const mimoProxyBalanceAfterWithdraw = await ethers.provider.getBalance(mimoProxy.address);\n    expect(vaultBalanceBeforeWithdraw).to.be.equal(DEPOSIT_AMOUNT);\n    expect(vaultBalanceAfterWithdraw).to.be.equal(ethers.constants.Zero);\n    expect(mimoProxyBalanceBeforeWithdraw).to.be.equal(ethers.constants.Zero);\n    expect(mimoProxyBalanceAfterWithdraw).to.be.equal(DEPOSIT_AMOUNT);\n  });\n  it(\"should be able to borrow\", async () => {\n    const { mimoProxy, wmatic, vaultActions, vaultsDataProvider, configProvider } = await setup();\n    await mimoProxy.execute(\n      vaultActions.address,\n      vaultActions.interface.encodeFunctionData(\"deposit\", [wmatic.address, DEPOSIT_AMOUNT]),\n    );\n    const vaultId = await vaultsDataProvider.vaultId(wmatic.address, mimoProxy.address);\n    const vaultDebtBeforeBorrow = await vaultsDataProvider.vaultDebt(vaultId);\n    await mimoProxy.execute(\n      vaultActions.address,\n      vaultActions.interface.encodeFunctionData(\"borrow\", [vaultId, BORROW_AMOUNT]),\n    );\n    const originationFee = await configProvider.collateralOriginationFee(wmatic.address);\n    const vaultDebtBeforeAfter = await vaultsDataProvider.vaultDebt(vaultId);\n    expect(vaultDebtBeforeBorrow).to.be.equal(ethers.constants.Zero);\n    expect(vaultDebtBeforeAfter).to.be.equal(BORROW_AMOUNT.add(BORROW_AMOUNT.mul(originationFee).div(WAD)));\n  });\n  it(\"should not be able to reuse msg.value for multiple deposits\", async () => {\n    const { mimoProxy, vaultActions, vaultsDataProvider, wmatic } = await setup();\n    await mimoProxy.execute(vaultActions.address, vaultActions.interface.encodeFunctionData(\"depositETH\"), {\n      value: DEPOSIT_AMOUNT,\n    });\n    const vaultIdBefore = await vaultsDataProvider.vaultId(wmatic.address, mimoProxy.address);\n    const vaultBalanceBefore = await vaultsDataProvider.vaultCollateralBalance(vaultIdBefore);\n    const data = vaultActions.interface.encodeFunctionData(\"depositETH\");\n    mimoProxy.batch(\n      [\n        mimoProxy.interface.encodeFunctionData(\"execute\", [vaultActions.address, data]),\n        mimoProxy.interface.encodeFunctionData(\"execute\", [vaultActions.address, data]),\n      ],\n      false,\n      { value: DEPOSIT_AMOUNT },\n    );\n    const vaultId = await vaultsDataProvider.vaultId(wmatic.address, mimoProxy.address);\n    const vaultBalanceAfter = await vaultsDataProvider.vaultCollateralBalance(vaultId);\n    expect(vaultBalanceAfter).to.be.equal(vaultBalanceBefore.add(DEPOSIT_AMOUNT));\n  });\n});"
    }
  ]
}