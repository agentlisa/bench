{
  "Title": "[M-05] EIP-155 is not enforced, allowing attackers/malicious operators to profit from replaying transactions",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/contracts/libraries/TransactionHelper.sol#L183-L187><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/contracts/DefaultAccount.sol#L78-L107>\n\n### Vulnerability details\n\nThe L2 `DefaultAccount.validateTransaction` function and transaction encoding process in the bootloader do not enforce EIP-155. If the `reserved[0]`  of the legacy tx is zero, the EIP-155 will be disabled. The chainId will not be included in the transaction signature.\n\n```solidity\n        bytes memory encodedChainId;\n        if (_transaction.reserved[0] != 0) {\n            encodedChainId = bytes.concat(RLPEncoder.encodeUint256(block.chainid), hex\"80_80\");\n        }\n```\n\n### Impact\n\nThere are two potential exploitation scenarios:\n1. A malicious attacker can replay transactions from the mainnet or other networks not protected by EIP-155. While there are very few EVM networks currently supporting transactions without EIP-155, attackers still have an opportunity to profit by replaying early transactions from other networks. For example, if an early ETH user A sent a legacy tx to user B before EIP-155 enabled, and now user A deposited some ETH into the zkSync era network, then user B could replay the early transaction from user A to steal his funds on the zkSync network.\n2. Operators can replay early user transactions from eth/other EVM networks to collect gas fees or even profit directly.\n\n### Proof of Concept\n\nEIP-155 will be disabled when the following two conditions are met:\n1. Transaction type is legacy tx, which `tx_type=0`.\n2. `tx.reserved[0] == 0`.\n\nThe value of the reserved field cannot be set arbitrarily, but if the user inputs a transaction with `tx_type=0` and the `v` in the signature is 27 or 28, then `reserved[0]` will be set to `0`.\n\nCode [here](https://github.com/matter-labs/zksync-era/blob/6cb8c2c350385ed96c0824869a885a7285735a91/core/lib/vm/src/types/internals/transaction_data.rs#L52-L60).\n\n```rust\n                let should_check_chain_id = if matches!(\n                    common_data.transaction_type,\n                    TransactionType::LegacyTransaction\n                ) && common_data.extract_chain_id().is_some()\n                {\n                    U256([1, 0, 0, 0])\n                } else {\n                    U256::zero()\n                };\n```\n\n```rust\n    pub fn extract_chain_id(&self) -> Option<u64> {\n        let bytes = self.input_data()?;\n        let chain_id = match bytes.first() {\n            Some(x) if *x >= 0x80 => {\n                let rlp = Rlp::new(bytes);\n                let v = rlp.val_at(6).ok()?;\n                PackedEthSignature::unpack_v(v).ok()?.1?\n            }\n```\n\n### Recommended Mitigation Steps\n\nEnforce EIP-155 signature verification in the contract `DefaultAccount.validateTransaction`.\n\n**[miladpiri (zkSync) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/882#issuecomment-1794660244):**\n > This is a design decision. So, QA.\n\n**[Alex the Entreprenerd (judge) decreased severity to QA and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/882#issuecomment-1824841175):**\n > This is an option, not the default.\n\n**[Alex the Entreprenerd (judge) increased severity to Medium and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/882#issuecomment-1887439561):**\n > I have spent time investigating this issues impact and why this is considered \"acceptable\". I believe that a clear divide between Developers and Security Researchers can be seen in how the severity is interpreted for this issue.\n>\n> Any \"EVM Developer\" will look at this finding as trivial, and obvious, \"it's the user fault\" for having a wallet that is pre EIP-155 and the usage of this signature scheme are keyless deployments. Any security researcher will look at this as a means to DOS users, and potentially steal their funds.\n> \n> I have spoken with a lot of different actors in the security space and have heard every possible severity for this type of findings, from known to high severity.\n> \n> After talking with 4 different judges, am going to set the finding as Medium severity. As zkSync is not uniquely subjected to this finding, I believe the finding to be a danger to end users which should be publicly disclosed to them.\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2023-10-zksync-findings/issues/882).*\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-zksync",
  "Code": [
    {
      "filename": "code/system-contracts/contracts/libraries/TransactionHelper.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../openzeppelin/token/ERC20/IERC20.sol\";\nimport \"../openzeppelin/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/IPaymasterFlow.sol\";\nimport \"../interfaces/IContractDeployer.sol\";\nimport {ETH_TOKEN_SYSTEM_CONTRACT, BOOTLOADER_FORMAL_ADDRESS} from \"../Constants.sol\";\nimport \"./RLPEncoder.sol\";\nimport \"./EfficientCall.sol\";\n\n/// @dev The type id of zkSync's EIP-712-signed transaction.\nuint8 constant EIP_712_TX_TYPE = 0x71;\n\n/// @dev The type id of legacy transactions.\nuint8 constant LEGACY_TX_TYPE = 0x0;\n/// @dev The type id of legacy transactions.\nuint8 constant EIP_2930_TX_TYPE = 0x01;\n/// @dev The type id of EIP1559 transactions.\nuint8 constant EIP_1559_TX_TYPE = 0x02;\n\n/// @notice Structure used to represent zkSync transaction.\nstruct Transaction {\n    // The type of the transaction.\n    uint256 txType;\n    // The caller.\n    uint256 from;\n    // The callee.\n    uint256 to;\n    // The gasLimit to pass with the transaction.\n    // It has the same meaning as Ethereum's gasLimit.\n    uint256 gasLimit;\n    // The maximum amount of gas the user is willing to pay for a byte of pubdata.\n    uint256 gasPerPubdataByteLimit;\n    // The maximum fee per gas that the user is willing to pay.\n    // It is akin to EIP1559's maxFeePerGas.\n    uint256 maxFeePerGas;\n    // The maximum priority fee per gas that the user is willing to pay.\n    // It is akin to EIP1559's maxPriorityFeePerGas.\n    uint256 maxPriorityFeePerGas;\n    // The transaction's paymaster. If there is no paymaster, it is equal to 0.\n    uint256 paymaster;\n    // The nonce of the transaction.\n    uint256 nonce;\n    // The value to pass with the transaction.\n    uint256 value;\n    // In the future, we might want to add some\n    // new fields to the struct. The `txData` struct\n    // is to be passed to account and any changes to its structure\n    // would mean a breaking change to these accounts. In order to prevent this,\n    // we should keep some fields as \"reserved\".\n    // It is also recommended that their length is fixed, since\n    // it would allow easier proof integration (in case we will need\n    // some special circuit for preprocessing transactions).\n    uint256[4] reserved;\n    // The transaction's calldata.\n    bytes data;\n    // The signature of the transaction.\n    bytes signature;\n    // The properly formatted hashes of bytecodes that must be published on L1\n    // with the inclusion of this transaction. Note, that a bytecode has been published\n    // before, the user won't pay fees for its republishing.\n    bytes32[] factoryDeps;\n    // The input to the paymaster.\n    bytes paymasterInput;\n    // Reserved dynamic type for the future use-case. Using it should be avoided,\n    // But it is still here, just in case we want to enable some additional functionality.\n    bytes reservedDynamic;\n}\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice Library is used to help custom accounts to work with common methods for the Transaction type.\n */\nlibrary TransactionHelper {\n    using SafeERC20 for IERC20;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 constant EIP712_DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId)\");\n\n    bytes32 constant EIP712_TRANSACTION_TYPE_HASH =\n        keccak256(\n            \"Transaction(uint256 txType,uint256 from,uint256 to,uint256 gasLimit,uint256 gasPerPubdataByteLimit,uint256 maxFeePerGas,uint256 maxPriorityFeePerGas,uint256 paymaster,uint256 nonce,uint256 value,bytes data,bytes32[] factoryDeps,bytes paymasterInput)\"\n        );\n\n    /// @notice Whether the token is Ethereum.\n    /// @param _addr The address of the token\n    /// @return `true` or `false` based on whether the token is Ether.\n    /// @dev This method assumes that address is Ether either if the address is 0 (for convenience)\n    /// or if the address is the address of the L2EthToken system contract.\n    function isEthToken(uint256 _addr) internal pure returns (bool) {\n        return _addr == uint256(uint160(address(ETH_TOKEN_SYSTEM_CONTRACT))) || _addr == 0;\n    }\n\n    /// @notice Calculate the suggested signed hash of the transaction,\n    /// i.e. the hash that is signed by EOAs and is recommended to be signed by other accounts.\n    function encodeHash(Transaction calldata _transaction) internal view returns (bytes32 resultHash) {\n        if (_transaction.txType == LEGACY_TX_TYPE) {\n            resultHash = _encodeHashLegacyTransaction(_transaction);\n        } else if (_transaction.txType == EIP_712_TX_TYPE) {\n            resultHash = _encodeHashEIP712Transaction(_transaction);\n        } else if (_transaction.txType == EIP_1559_TX_TYPE) {\n            resultHash = _encodeHashEIP1559Transaction(_transaction);\n        } else if (_transaction.txType == EIP_2930_TX_TYPE) {\n            resultHash = _encodeHashEIP2930Transaction(_transaction);\n        } else {\n            // Currently no other transaction types are supported.\n            // Any new transaction types will be processed in a similar manner.\n            revert(\"Encoding unsupported tx\");\n        }\n    }\n\n    /// @notice Encode hash of the zkSync native transaction type.\n    /// @return keccak256 hash of the EIP-712 encoded representation of transaction\n    function _encodeHashEIP712Transaction(Transaction calldata _transaction) private view returns (bytes32) {\n        bytes32 structHash = keccak256(\n            abi.encode(\n                EIP712_TRANSACTION_TYPE_HASH,\n                _transaction.txType,\n                _transaction.from,\n                _transaction.to,\n                _transaction.gasLimit,\n                _transaction.gasPerPubdataByteLimit,\n                _transaction.maxFeePerGas,\n                _transaction.maxPriorityFeePerGas,\n                _transaction.paymaster,\n                _transaction.nonce,\n                _transaction.value,\n                EfficientCall.keccak(_transaction.data),\n                keccak256(abi.encodePacked(_transaction.factoryDeps)),\n                EfficientCall.keccak(_transaction.paymasterInput)\n            )\n        );\n\n        bytes32 domainSeparator = keccak256(\n            abi.encode(EIP712_DOMAIN_TYPEHASH, keccak256(\"zkSync\"), keccak256(\"2\"), block.chainid)\n        );\n\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n\n    /// @notice Encode hash of the legacy transaction type.\n    /// @return keccak256 of the serialized RLP encoded representation of transaction\n    function _encodeHashLegacyTransaction(Transaction calldata _transaction) private view returns (bytes32) {\n        // Hash of legacy transactions are encoded as one of the:\n        // - RLP(nonce, gasPrice, gasLimit, to, value, data, chainId, 0, 0)\n        // - RLP(nonce, gasPrice, gasLimit, to, value, data)\n        //\n        // In this RLP encoding, only the first one above list appears, so we encode each element\n        // inside list and then concatenate the length of all elements with them.\n\n        bytes memory encodedNonce = RLPEncoder.encodeUint256(_transaction.nonce);\n        // Encode `gasPrice` and `gasLimit` together to prevent \"stack too deep error\".\n        bytes memory encodedGasParam;\n        {\n            bytes memory encodedGasPrice = RLPEncoder.encodeUint256(_transaction.maxFeePerGas);\n            bytes memory encodedGasLimit = RLPEncoder.encodeUint256(_transaction.gasLimit);\n            encodedGasParam = bytes.concat(encodedGasPrice, encodedGasLimit);\n        }\n\n        bytes memory encodedTo = RLPEncoder.encodeAddress(address(uint160(_transaction.to)));\n        bytes memory encodedValue = RLPEncoder.encodeUint256(_transaction.value);\n        // Encode only the length of the transaction data, and not the data itself,\n        // so as not to copy to memory a potentially huge transaction data twice.\n        bytes memory encodedDataLength;\n        {\n            // Safe cast, because the length of the transaction data can't be so large.\n            uint64 txDataLen = uint64(_transaction.data.length);\n            if (txDataLen != 1) {\n                // If the length is not equal to one, then only using the length can it be encoded definitely.\n                encodedDataLength = RLPEncoder.encodeNonSingleBytesLen(txDataLen);\n            } else if (_transaction.data[0] >= 0x80) {\n                // If input is a byte in [0x80, 0xff] range, RLP encoding will concatenates 0x81 with the byte.\n                encodedDataLength = hex\"81\";\n            }\n            // Otherwise the length is not encoded at all.\n        }\n\n        // Encode `chainId` according to EIP-155, but only if the `chainId` is specified in the transaction.\n        bytes memory encodedChainId;\n        if (_transaction.reserved[0] != 0) {\n            encodedChainId = bytes.concat(RLPEncoder.encodeUint256(block.chainid), hex\"80_80\");\n        }\n\n        bytes memory encodedListLength;\n        unchecked {\n            uint256 listLength = encodedNonce.length +\n                encodedGasParam.length +\n                encodedTo.length +\n                encodedValue.length +\n                encodedDataLength.length +\n                _transaction.data.length +\n                encodedChainId.length;\n\n            // Safe cast, because the length of the list can't be so large.\n            encodedListLength = RLPEncoder.encodeListLen(uint64(listLength));\n        }\n\n        return\n            keccak256(\n                bytes.concat(\n                    encodedListLength,\n                    encodedNonce,\n                    encodedGasParam,\n                    encodedTo,\n                    encodedValue,\n                    encodedDataLength,\n                    _transaction.data,\n                    encodedChainId\n                )\n            );\n    }\n\n    /// @notice Encode hash of the EIP2930 transaction type.\n    /// @return keccak256 of the serialized RLP encoded representation of transaction\n    function _encodeHashEIP2930Transaction(Transaction calldata _transaction) private view returns (bytes32) {\n        // Hash of EIP2930 transactions is encoded the following way:\n        // H(0x01 || RLP(chain_id, nonce, gas_price, gas_limit, destination, amount, data, access_list))\n        //\n        // Note, that on zkSync access lists are not supported and should always be empty.\n\n        // Encode all fixed-length params to avoid \"stack too deep error\"\n        bytes memory encodedFixedLengthParams;\n        {\n            bytes memory encodedChainId = RLPEncoder.encodeUint256(block.chainid);\n            bytes memory encodedNonce = RLPEncoder.encodeUint256(_transaction.nonce);\n            bytes memory encodedGasPrice = RLPEncoder.encodeUint256(_transaction.maxFeePerGas);\n            bytes memory encodedGasLimit = RLPEncoder.encodeUint256(_transaction.gasLimit);\n            bytes memory encodedTo = RLPEncoder.encodeAddress(address(uint160(_transaction.to)));\n            bytes memory encodedValue = RLPEncoder.encodeUint256(_transaction.value);\n            encodedFixedLengthParams = bytes.concat(\n                encodedChainId,\n                encodedNonce,\n                encodedGasPrice,\n                encodedGasLimit,\n                encodedTo,\n                encodedValue\n            );\n        }\n\n        // Encode only the length of the transaction data, and not the data itself,\n        // so as not to copy to memory a potentially huge transaction data twice.\n        bytes memory encodedDataLength;\n        {\n            // Safe cast, because the length of the transaction data can't be so large.\n            uint64 txDataLen = uint64(_transaction.data.length);\n            if (txDataLen != 1) {\n                // If the length is not equal to one, then only using the length can it be encoded definitely.\n                encodedDataLength = RLPEncoder.encodeNonSingleBytesLen(txDataLen);\n            } else if (_transaction.data[0] >= 0x80) {\n                // If input is a byte in [0x80, 0xff] range, RLP encoding will concatenates 0x81 with the byte.\n                encodedDataLength = hex\"81\";\n            }\n            // Otherwise the length is not encoded at all.\n        }\n\n        // On zkSync, access lists are always zero length (at least for now).\n        bytes memory encodedAccessListLength = RLPEncoder.encodeListLen(0);\n\n        bytes memory encodedListLength;\n        unchecked {\n            uint256 listLength = encodedFixedLengthParams.length +\n                encodedDataLength.length +\n                _transaction.data.length +\n                encodedAccessListLength.length;\n\n            // Safe cast, because the length of the list can't be so large.\n            encodedListLength = RLPEncoder.encodeListLen(uint64(listLength));\n        }\n\n        return\n            keccak256(\n                bytes.concat(\n                    \"\\x01\",\n                    encodedListLength,\n                    encodedFixedLengthParams,\n                    encodedDataLength,\n                    _transaction.data,\n                    encodedAccessListLength\n                )\n            );\n    }\n\n    /// @notice Encode hash of the EIP1559 transaction type.\n    /// @return keccak256 of the serialized RLP encoded representation of transaction\n    function _encodeHashEIP1559Transaction(Transaction calldata _transaction) private view returns (bytes32) {\n        // Hash of EIP1559 transactions is encoded the following way:\n        // H(0x02 || RLP(chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, destination, amount, data, access_list))\n        //\n        // Note, that on zkSync access lists are not supported and should always be empty.\n\n        // Encode all fixed-length params to avoid \"stack too deep error\"\n        bytes memory encodedFixedLengthParams;\n        {\n            bytes memory encodedChainId = RLPEncoder.encodeUint256(block.chainid);\n            bytes memory encodedNonce = RLPEncoder.encodeUint256(_transaction.nonce);\n            bytes memory encodedMaxPriorityFeePerGas = RLPEncoder.encodeUint256(_transaction.maxPriorityFeePerGas);\n            bytes memory encodedMaxFeePerGas = RLPEncoder.encodeUint256(_transaction.maxFeePerGas);\n            bytes memory encodedGasLimit = RLPEncoder.encodeUint256(_transaction.gasLimit);\n            bytes memory encodedTo = RLPEncoder.encodeAddress(address(uint160(_transaction.to)));\n            bytes memory encodedValue = RLPEncoder.encodeUint256(_transaction.value);\n            encodedFixedLengthParams = bytes.concat(\n                encodedChainId,\n                encodedNonce,\n                encodedMaxPriorityFeePerGas,\n                encodedMaxFeePerGas,\n                encodedGasLimit,\n                encodedTo,\n                encodedValue\n            );\n        }\n\n        // Encode only the length of the transaction data, and not the data itself,\n        // so as not to copy to memory a potentially huge transaction data twice.\n        bytes memory encodedDataLength;\n        {\n            // Safe cast, because the length of the transaction data can't be so large.\n            uint64 txDataLen = uint64(_transaction.data.length);\n            if (txDataLen != 1) {\n                // If the length is not equal to one, then only using the length can it be encoded definitely.\n                encodedDataLength = RLPEncoder.encodeNonSingleBytesLen(txDataLen);\n            } else if (_transaction.data[0] >= 0x80) {\n                // If input is a byte in [0x80, 0xff] range, RLP encoding will concatenates 0x81 with the byte.\n                encodedDataLength = hex\"81\";\n            }\n            // Otherwise the length is not encoded at all.\n        }\n\n        // On zkSync, access lists are always zero length (at least for now).\n        bytes memory encodedAccessListLength = RLPEncoder.encodeListLen(0);\n\n        bytes memory encodedListLength;\n        unchecked {\n            uint256 listLength = encodedFixedLengthParams.length +\n                encodedDataLength.length +\n                _transaction.data.length +\n                encodedAccessListLength.length;\n\n            // Safe cast, because the length of the list can't be so large.\n            encodedListLength = RLPEncoder.encodeListLen(uint64(listLength));\n        }\n\n        return\n            keccak256(\n                bytes.concat(\n                    \"\\x02\",\n                    encodedListLength,\n                    encodedFixedLengthParams,\n                    encodedDataLength,\n                    _transaction.data,\n                    encodedAccessListLength\n                )\n            );\n    }\n\n    /// @notice Processes the common paymaster flows, e.g. setting proper allowance\n    /// for tokens, etc. For more information on the expected behavior, check out\n    /// the \"Paymaster flows\" section in the documentation.\n    function processPaymasterInput(Transaction calldata _transaction) internal {\n        require(_transaction.paymasterInput.length >= 4, \"The standard paymaster input must be at least 4 bytes long\");\n\n        bytes4 paymasterInputSelector = bytes4(_transaction.paymasterInput[0:4]);\n        if (paymasterInputSelector == IPaymasterFlow.approvalBased.selector) {\n            require(\n                _transaction.paymasterInput.length >= 68,\n                \"The approvalBased paymaster input must be at least 68 bytes long\"\n            );\n\n            // While the actual data consists of address, uint256 and bytes data,\n            // the data is needed only for the paymaster, so we ignore it here for the sake of optimization\n            (address token, uint256 minAllowance) = abi.decode(_transaction.paymasterInput[4:68], (address, uint256));\n            address paymaster = address(uint160(_transaction.paymaster));\n\n            uint256 currentAllowance = IERC20(token).allowance(address(this), paymaster);\n            if (currentAllowance < minAllowance) {\n                // Some tokens, e.g. USDT require that the allowance is firsty set to zero\n                // and only then updated to the new value.\n\n                IERC20(token).safeApprove(paymaster, 0);\n                IERC20(token).safeApprove(paymaster, minAllowance);\n            }\n        } else if (paymasterInputSelector == IPaymasterFlow.general.selector) {\n            // Do nothing. general(bytes) paymaster flow means that the paymaster must interpret these bytes on his own.\n        } else {\n            revert(\"Unsupported paymaster flow\");\n        }\n    }\n\n    /// @notice Pays the required fee for the transaction to the bootloader.\n    /// @dev Currently it pays the maximum amount \"_transaction.maxFeePerGas * _transaction.gasLimit\",\n    /// it will change in the future.\n    function payToTheBootloader(Transaction calldata _transaction) internal returns (bool success) {\n        address bootloaderAddr = BOOTLOADER_FORMAL_ADDRESS;\n        uint256 amount = _transaction.maxFeePerGas * _transaction.gasLimit;\n\n        assembly {\n            success := call(gas(), bootloaderAddr, amount, 0, 0, 0, 0)\n        }\n    }\n\n    // Returns the balance required to process the transaction.\n    function totalRequiredBalance(Transaction calldata _transaction) internal pure returns (uint256 requiredBalance) {\n        if (address(uint160(_transaction.paymaster)) != address(0)) {\n            // Paymaster pays for the fee\n            requiredBalance = _transaction.value;\n        } else {\n            // The user should have enough balance for both the fee and the value of the transaction\n            requiredBalance = _transaction.maxFeePerGas * _transaction.gasLimit + _transaction.value;\n        }\n    }\n}"
    },
    {
      "filename": "code/system-contracts/contracts/DefaultAccount.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IAccount.sol\";\nimport \"./libraries/TransactionHelper.sol\";\nimport \"./libraries/SystemContractHelper.sol\";\nimport \"./libraries/EfficientCall.sol\";\nimport {BOOTLOADER_FORMAL_ADDRESS, NONCE_HOLDER_SYSTEM_CONTRACT, DEPLOYER_SYSTEM_CONTRACT, INonceHolder} from \"./Constants.sol\";\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice The default implementation of account.\n * @dev The bytecode of the contract is set by default for all addresses for which no other bytecodes are deployed.\n * @notice If the caller is not a bootloader always returns empty data on call, just like EOA does.\n * @notice If it is delegate called always returns empty data, just like EOA does.\n */\ncontract DefaultAccount is IAccount {\n    using TransactionHelper for *;\n\n    /**\n     * @dev Simulate the behavior of the EOA if the caller is not the bootloader.\n     * Essentially, for all non-bootloader callers halt the execution with empty return data.\n     * If all functions will use this modifier AND the contract will implement an empty payable fallback()\n     * then the contract will be indistinguishable from the EOA when called.\n     */\n    modifier ignoreNonBootloader() {\n        if (msg.sender != BOOTLOADER_FORMAL_ADDRESS) {\n            // If function was called outside of the bootloader, behave like an EOA.\n            assembly {\n                return(0, 0)\n            }\n        }\n        // Continue execution if called from the bootloader.\n        _;\n    }\n\n    /**\n     * @dev Simulate the behavior of the EOA if it is called via `delegatecall`.\n     * Thus, the default account on a delegate call behaves the same as EOA on Ethereum.\n     * If all functions will use this modifier AND the contract will implement an empty payable fallback()\n     * then the contract will be indistinguishable from the EOA when called.\n     */\n    modifier ignoreInDelegateCall() {\n        address codeAddress = SystemContractHelper.getCodeAddress();\n        if (codeAddress != address(this)) {\n            // If the function was delegate called, behave like an EOA.\n            assembly {\n                return(0, 0)\n            }\n        }\n\n        // Continue execution if not delegate called.\n        _;\n    }\n\n    /// @notice Validates the transaction & increments nonce.\n    /// @dev The transaction is considered accepted by the account if\n    /// the call to this function by the bootloader does not revert\n    /// and the nonce has been set as used.\n    /// @param _suggestedSignedHash The suggested hash of the transaction to be signed by the user.\n    /// This is the hash that is signed by the EOA by default.\n    /// @param _transaction The transaction structure itself.\n    /// @dev Besides the params above, it also accepts unused first paramter \"_txHash\", which\n    /// is the unique (canonical) hash of the transaction.\n    function validateTransaction(\n        bytes32, // _txHash\n        bytes32 _suggestedSignedHash,\n        Transaction calldata _transaction\n    ) external payable override ignoreNonBootloader ignoreInDelegateCall returns (bytes4 magic) {\n        magic = _validateTransaction(_suggestedSignedHash, _transaction);\n    }\n\n    /// @notice Inner method for validating transaction and increasing the nonce\n    /// @param _suggestedSignedHash The hash of the transaction signed by the EOA\n    /// @param _transaction The transaction.\n    function _validateTransaction(\n        bytes32 _suggestedSignedHash,\n        Transaction calldata _transaction\n    ) internal returns (bytes4 magic) {\n        // Note, that nonce holder can only be called with \"isSystem\" flag.\n        SystemContractsCaller.systemCallWithPropagatedRevert(\n            uint32(gasleft()),\n            address(NONCE_HOLDER_SYSTEM_CONTRACT),\n            0,\n            abi.encodeCall(INonceHolder.incrementMinNonceIfEquals, (_transaction.nonce))\n        );\n\n        // Even though for the transaction types present in the system right now,\n        // we always provide the suggested signed hash, this should not be\n        // always expected. In case the bootloader has no clue what the default hash\n        // is, the bytes32(0) will be supplied.\n        bytes32 txHash = _suggestedSignedHash != bytes32(0) ? _suggestedSignedHash : _transaction.encodeHash();\n\n        // The fact there is are enough balance for the account\n        // should be checked explicitly to prevent user paying for fee for a\n        // transaction that wouldn't be included on Ethereum.\n        uint256 totalRequiredBalance = _transaction.totalRequiredBalance();\n        require(totalRequiredBalance <= address(this).balance, \"Not enough balance for fee + value\");\n\n        if (_isValidSignature(txHash, _transaction.signature)) {\n            magic = ACCOUNT_VALIDATION_SUCCESS_MAGIC;\n        } else {\n            magic = bytes4(0);\n        }\n    }\n\n    /// @notice Method called by the bootloader to execute the transaction.\n    /// @param _transaction The transaction to execute.\n    /// @dev It also accepts unused _txHash and _suggestedSignedHash parameters:\n    /// the unique (canonical) hash of the transaction and the suggested signed\n    /// hash of the transaction.\n    function executeTransaction(\n        bytes32, // _txHash\n        bytes32, // _suggestedSignedHash\n        Transaction calldata _transaction\n    ) external payable override ignoreNonBootloader ignoreInDelegateCall {\n        _execute(_transaction);\n    }\n\n    /// @notice Method that should be used to initiate a transaction from this account by an external call.\n    /// @dev The custom account is supposed to implement this method to initiate a transaction on behalf\n    /// of the account via L1 -> L2 communication. However, the default account can initiate a transaction\n    /// from L1, so we formally implement the interface method, but it doesn't execute any logic.\n    /// @param _transaction The transaction to execute.\n    function executeTransactionFromOutside(Transaction calldata _transaction) external payable override {\n        // Behave the same as for fallback/receive, just execute nothing, returns nothing\n    }\n\n    /// @notice Inner method for executing a transaction.\n    /// @param _transaction The transaction to execute.\n    function _execute(Transaction calldata _transaction) internal {\n        address to = address(uint160(_transaction.to));\n        uint128 value = Utils.safeCastToU128(_transaction.value);\n        bytes calldata data = _transaction.data;\n        uint32 gas = Utils.safeCastToU32(gasleft());\n\n        // Note, that the deployment method from the deployer contract can only be called with a \"systemCall\" flag.\n        bool isSystemCall;\n        if (to == address(DEPLOYER_SYSTEM_CONTRACT) && data.length >= 4) {\n            bytes4 selector = bytes4(data[:4]);\n            // Check that called function is the deployment method,\n            // the others deployer method is not supposed to be called from the default account.\n            isSystemCall =\n                selector == DEPLOYER_SYSTEM_CONTRACT.create.selector ||\n                selector == DEPLOYER_SYSTEM_CONTRACT.create2.selector ||\n                selector == DEPLOYER_SYSTEM_CONTRACT.createAccount.selector ||\n                selector == DEPLOYER_SYSTEM_CONTRACT.create2Account.selector;\n        }\n        bool success = EfficientCall.rawCall(gas, to, value, data, isSystemCall);\n        if (!success) {\n            EfficientCall.propagateRevert();\n        }\n    }\n\n    /// @notice Validation that the ECDSA signature of the transaction is correct.\n    /// @param _hash The hash of the transaction to be signed.\n    /// @param _signature The signature of the transaction.\n    /// @return EIP1271_SUCCESS_RETURN_VALUE if the signaure is correct. It reverts otherwise.\n    function _isValidSignature(bytes32 _hash, bytes memory _signature) internal view returns (bool) {\n        require(_signature.length == 65, \"Signature length is incorrect\");\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        // Signature loading code\n        // we jump 32 (0x20) as the first slot of bytes contains the length\n        // we jump 65 (0x41) per signature\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\n        assembly {\n            r := mload(add(_signature, 0x20))\n            s := mload(add(_signature, 0x40))\n            v := and(mload(add(_signature, 0x41)), 0xff)\n        }\n        require(v == 27 || v == 28, \"v is neither 27 nor 28\");\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"Invalid s\");\n\n        address recoveredAddress = ecrecover(_hash, v, r, s);\n\n        return recoveredAddress == address(this) && recoveredAddress != address(0);\n    }\n\n    /// @notice Method for paying the bootloader for the transaction.\n    /// @param _transaction The transaction for which the fee is paid.\n    /// @dev It also accepts unused _txHash and _suggestedSignedHash parameters:\n    /// the unique (canonical) hash of the transaction and the suggested signed\n    /// hash of the transaction.\n    function payForTransaction(\n        bytes32, // _txHash\n        bytes32, // _suggestedSignedHash\n        Transaction calldata _transaction\n    ) external payable ignoreNonBootloader ignoreInDelegateCall {\n        bool success = _transaction.payToTheBootloader();\n        require(success, \"Failed to pay the fee to the operator\");\n    }\n\n    /// @notice Method, where the user should prepare for the transaction to be\n    /// paid for by a paymaster.\n    /// @dev Here, the account should set the allowance for the smart contracts\n    /// @param _transaction The transaction.\n    /// @dev It also accepts unused _txHash and _suggestedSignedHash parameters:\n    /// the unique (canonical) hash of the transaction and the suggested signed\n    /// hash of the transaction.\n    function prepareForPaymaster(\n        bytes32, // _txHash\n        bytes32, // _suggestedSignedHash\n        Transaction calldata _transaction\n    ) external payable ignoreNonBootloader ignoreInDelegateCall {\n        _transaction.processPaymasterInput();\n    }\n\n    fallback() external payable {\n        // fallback of default account shouldn't be called by bootloader under no circumstances\n        assert(msg.sender != BOOTLOADER_FORMAL_ADDRESS);\n\n        // If the contract is called directly, behave like an EOA\n    }\n\n    receive() external payable {\n        // If the contract is called directly, behave like an EOA\n    }\n}"
    }
  ]
}