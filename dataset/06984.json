{
  "Title": "[H-03] Rewards will be locked in LQTYStaking Contract",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Core/contracts/LQTY/LQTYStaking.sol#L181-L183\nhttps://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Core/contracts/RedemptionHelper.sol#L191-L197\nhttps://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Core/contracts/ActivePool.sol#L296-L300\n\n\n# Vulnerability details\n\n# Vulnerability details\nThe state variable `F_Collateral` in the LQTYStaking contract is used to keep track of rewards for each of the collateral types used in the protocol. Every time the LQTYStaking contract is sent collateral assets for rewards by the ActivePool or the RedemptionHelper, `LQTYStaking.increaseF_Collateral` is called to record the rewards that are to be distributed to stakers. \n\nHowever, if the state variable `totalLQTYStaked` is large enough in the LQTYStaking contract, zero rewards will be distributed to stakers even though LQTYStaking received assets. This issue is exarcebated when using WBTC as collateral due to its low number of decimals. \n\nFor example, given the following:\n1. `totalLQTYStaked` = 1e25; LQTY/OATH token has 18 decimals; this means that a total of 10million LQTY has been staked\n2. A redemption rate of 0.5% was applied on a redemption of 10e8 WBTC. This leads to a redemption fee of 5e6 WBTC that is sent to the LQTYStaking contract. This happens in [this code](https://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Core/contracts/RedemptionHelper.sol#L190-L197). \n3. Given the above, RedemptionHelper calls `LQTYStaking.increaseF_Collateral(WBTCaddress, 5e6)`\n\nThe issue is in this line in `increaseF_Collateral`:\n```solidity\nif (totalLQTYStaked > 0) {collFeePerLQTYStaked = _collFee.mul(DECIMAL_PRECISION).div(totalLQTYStaked);}\n```\n\n`_collFee` = 5e6; `DECIMAL_PRECISION` = 1e18; `totalLQTYStaked` = 1e25\n\nIf we substitute the variables with the actual values and represent the code in math, it looks like:\n```\n(5e6 * 1e18) / 1e25 = 5e24 / 1e25 = 0.5\n```\n\nSince the result of that math is a value less than 1 and in Solidity/EVM we only deal with integers and division rounds down, we get 0 as a result. That means the below code will only add `0` to `F_Collateral`:\n```solidity\nF_Collateral[_collateral] = F_Collateral[_collateral].add(collFeePerLQTYStaked);\n```\n\nSo even though LQTYStaking received 5e6 WBTC in redemption fee, that fee will never be distributed to stakers and will remain forever locked in the LQTYStaking contract. The minimum amount of redemption fee that is needed for the reward to be recognized and distributed to stakers is 1e7 WBTC. That means at least 0.1 BTC in collateral fee is needed for the rewards to be distributed when there is 1Million total LQTY staked.\n\n\n## Impact\n\nThis leads to loss of significant rewards for stakers. These collateral assets that are not distributed as rewards will remain forever locked in LQTYStaking.\n\nIf 1e25 LQTY is staked in LQTYStaking (10M LQTY), at least 1e7 (0.1) WBTC in redemption fee must be sent by the RedemptionHelper for that WBTC to be sent as rewards to the stakers. That means only redemptions of 20e8 (20) WBTC and more will lead to redemption fees high enough to be distributed as rewards to stakers. Redemption of 20e8 WBTC will rarely happen, so it's likely that majority of rewards will be forever locked since most redemptions will be less than that.\n\nGiven the above, if only 3% of redemptions have amounts of 20e8 WBTC or greater, then 97% of redemptions will have their fees forever locked in the contract. The greater the amount of LQTY Staked, the higher the amount needed for the fees to be recorded. \n\n## Proof of Concept\n\nFirst, comment out [this line](https://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Core/contracts/LQTY/LQTYStaking.sol#L178) in `increaseF_Collateral` to disable the access control. This allows us to write a more concise POC. It is fine since the issue has nothing to do with access control.\n\nAdd the following test case to the `Ethos-Core/test/LQTYStakingFeeRewardsTest.js` file after the `beforeEach` clause:\n```js\n  it('does not increase F collateral even with large amount of collateral fee', async () => {\n    await stakingToken.mint(A, dec(10_000_000, 18))\n    await stakingToken.approve(lqtyStaking.address, dec(10_000_000, 18), {from: A})\n    await lqtyStaking.stake(dec(10_000_000, 18), {from: A})\n\n    const wbtc = collaterals[1].address\n    const oldWBTC_FCollateral = await lqtyStaking.F_Collateral(wbtc)\n\n    // .09 WBTC in redemption/collateral fee will not be distributed as reward to stakers\n    await lqtyStaking.increaseF_Collateral(wbtc, dec(9, 6))\n    assert.isTrue(oldWBTC_FCollateral.eq(await lqtyStaking.F_Collateral(wbtc)))\n    \n    // at least 0.1 WBTC in redemption/collateral fee is needed for it to be distributed as reward to stakers\n    await lqtyStaking.increaseF_Collateral(wbtc, dec(1, 7))\n    assert.isTrue(oldWBTC_FCollateral.lt(await lqtyStaking.F_Collateral(wbtc)))\n  })\n```\n\nThe test can then be run with the following command:\n```\n$ npx hardhat test --grep \"does not increase F collateral even with large amount of collateral fee\"\n```\n\n## Tools Used\nManual review\n\n## Mitigation\nOne way to address this issue is to use the same error-recording logic found in the `_computeLQTYPerUnitStaked` logic that looks like:\n\n```solidity\n        uint LQTYNumerator = _LQTYIssuance.mul(DECIMAL_PRECISION).add(lastLQTYError);\n\n        uint LQTYPerUnitStaked = LQTYNumerator.div(_totalLUSDDeposits);\n        lastLQTYError = LQTYNumerator.sub(LQTYPerUnitStaked.mul(_totalLUSDDeposits));\n```\n\nThe `lastLQTYError` state variable stores the LQTY issuance that was not distributed since they were just rounded off. The same approach can be used in `increaseF_Collateral`.",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2023-02-ethos-reserve-contest",
  "Code": [
    {
      "filename": "Ethos-Core/contracts/LQTY/LQTYStaking.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.6.11;\n\nimport \"../Dependencies/BaseMath.sol\";\nimport \"../Dependencies/SafeMath.sol\";\nimport \"../Dependencies/Ownable.sol\";\nimport \"../Dependencies/CheckContract.sol\";\nimport \"../Dependencies/console.sol\";\nimport \"../Dependencies/IERC20.sol\";\nimport \"../Interfaces/ICollateralConfig.sol\";\nimport \"../Interfaces/ILQTYStaking.sol\";\nimport \"../Interfaces/ITroveManager.sol\";\nimport \"../Dependencies/LiquityMath.sol\";\nimport \"../Interfaces/ILUSDToken.sol\";\nimport \"../Dependencies/SafeERC20.sol\";\n\ncontract LQTYStaking is ILQTYStaking, Ownable, CheckContract, BaseMath {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n    // --- Data ---\n    string constant public NAME = \"LQTYStaking\";\n\n    mapping( address => uint) public stakes;\n    uint public totalLQTYStaked;\n\n    mapping (address => uint) public F_Collateral;  // Running sum of collateral fees per-LQTY-staked\n    uint public F_LUSD; // Running sum of LUSD fees per-LQTY-staked\n\n    // User snapshots of F_Collateral and F_LUSD, taken at the point at which their latest deposit was made\n    mapping (address => Snapshot) public snapshots; \n\n    struct Snapshot {\n        mapping (address => uint) F_Collateral_Snapshot;\n        uint F_LUSD_Snapshot;\n    }\n    \n    IERC20 public lqtyToken;\n    ILUSDToken public lusdToken;\n    ICollateralConfig public collateralConfig;\n\n    address public troveManagerAddress;\n    address public borrowerOperationsAddress;\n    address public activePoolAddress;\n\n    // --- Events ---\n\n    event LQTYTokenAddressSet(address _lqtyTokenAddress);\n    event LUSDTokenAddressSet(address _lusdTokenAddress);\n    event TroveManagerAddressSet(address _troveManager);\n    event BorrowerOperationsAddressSet(address _borrowerOperationsAddress);\n    event ActivePoolAddressSet(address _activePoolAddress);\n    event CollateralConfigAddressSet(address _collateralConfigAddress);\n\n    event StakeChanged(address indexed staker, uint newStake);\n    event StakingGainsWithdrawn(address indexed staker, uint LUSDGain, address[] _assets, uint[] _amounts);\n    event F_CollateralUpdated(address _collateral, uint _F_Collateral);\n    event F_LUSDUpdated(uint _F_LUSD);\n    event TotalLQTYStakedUpdated(uint _totalLQTYStaked);\n    event CollateralSent(address _account, address _collateral, uint _amount);\n    event StakerSnapshotsUpdated(address _staker, address[] _assets, uint[] _amounts, uint _F_LUSD);\n\n    // --- Functions ---\n\n    function setAddresses\n    (\n        address _lqtyTokenAddress,\n        address _lusdTokenAddress,\n        address _troveManagerAddress, \n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _collateralConfigAddress\n    ) \n        external \n        onlyOwner \n        override \n    {\n        checkContract(_lqtyTokenAddress);\n        checkContract(_lusdTokenAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_collateralConfigAddress);\n\n        lqtyToken = IERC20(_lqtyTokenAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        troveManagerAddress = _troveManagerAddress;\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePoolAddress = _activePoolAddress;\n        collateralConfig = ICollateralConfig(_collateralConfigAddress);\n\n        emit LQTYTokenAddressSet(_lqtyTokenAddress);\n        emit LQTYTokenAddressSet(_lusdTokenAddress);\n        emit TroveManagerAddressSet(_troveManagerAddress);\n        emit BorrowerOperationsAddressSet(_borrowerOperationsAddress);\n        emit ActivePoolAddressSet(_activePoolAddress);\n        emit CollateralConfigAddressSet(_collateralConfigAddress);\n\n        _renounceOwnership();\n    }\n\n    // If caller has a pre-existing stake, send any accumulated collateral and LUSD gains to them. \n    function stake(uint _LQTYamount) external override {\n        _requireNonZeroAmount(_LQTYamount);\n\n        uint currentStake = stakes[msg.sender];\n\n        address[] memory collGainAssets;\n        uint[] memory collGainAmounts;\n        uint LUSDGain;\n        // Grab any accumulated collateral and LUSD gains from the current stake\n        if (currentStake != 0) {\n            (collGainAssets, collGainAmounts) = _getPendingCollateralGain(msg.sender);\n            LUSDGain = _getPendingLUSDGain(msg.sender);\n        }\n    \n       _updateUserSnapshots(msg.sender);\n\n        uint newStake = currentStake.add(_LQTYamount);\n\n        // Increase user’s stake and total LQTY staked\n        stakes[msg.sender] = newStake;\n        totalLQTYStaked = totalLQTYStaked.add(_LQTYamount);\n        emit TotalLQTYStakedUpdated(totalLQTYStaked);\n\n        // Transfer LQTY from caller to this contract\n        lqtyToken.safeTransferFrom(msg.sender, address(this), _LQTYamount);\n\n        emit StakeChanged(msg.sender, newStake);\n        emit StakingGainsWithdrawn(msg.sender, LUSDGain, collGainAssets, collGainAmounts);\n\n         // Send accumulated LUSD and collateral gains to the caller\n        if (currentStake != 0) {\n            lusdToken.transfer(msg.sender, LUSDGain);\n            _sendCollGainToUser(collGainAssets, collGainAmounts);\n        }\n    }\n\n    // Unstake the LQTY and send the it back to the caller, along with their accumulated LUSD & collateral gains.\n    // If requested amount > stake, send their entire stake.\n    function unstake(uint _LQTYamount) external override {\n        uint currentStake = stakes[msg.sender];\n        _requireUserHasStake(currentStake);\n\n        // Grab any accumulated ETH and LUSD gains from the current stake\n        (address[] memory collGainAssets, uint[] memory collGainAmounts) = _getPendingCollateralGain(msg.sender);\n        uint LUSDGain = _getPendingLUSDGain(msg.sender);\n        \n        _updateUserSnapshots(msg.sender);\n\n        if (_LQTYamount > 0) {\n            uint LQTYToWithdraw = LiquityMath._min(_LQTYamount, currentStake);\n\n            uint newStake = currentStake.sub(LQTYToWithdraw);\n\n            // Decrease user's stake and total LQTY staked\n            stakes[msg.sender] = newStake;\n            totalLQTYStaked = totalLQTYStaked.sub(LQTYToWithdraw);\n            emit TotalLQTYStakedUpdated(totalLQTYStaked);\n\n            // Transfer unstaked LQTY to user\n            lqtyToken.safeTransfer(msg.sender, LQTYToWithdraw);\n\n            emit StakeChanged(msg.sender, newStake);\n        }\n\n        emit StakingGainsWithdrawn(msg.sender, LUSDGain, collGainAssets, collGainAmounts);\n\n        // Send accumulated LUSD and ETH gains to the caller\n        lusdToken.transfer(msg.sender, LUSDGain);\n        _sendCollGainToUser(collGainAssets, collGainAmounts);\n    }\n\n    // --- Reward-per-unit-staked increase functions. Called by Liquity core contracts ---\n\n    function increaseF_Collateral(address _collateral, uint _collFee) external override {\n        _requireCallerIsTroveManagerOrActivePool();\n        uint collFeePerLQTYStaked;\n     \n        if (totalLQTYStaked > 0) {collFeePerLQTYStaked = _collFee.mul(DECIMAL_PRECISION).div(totalLQTYStaked);}\n\n        F_Collateral[_collateral] = F_Collateral[_collateral].add(collFeePerLQTYStaked);\n        emit F_CollateralUpdated(_collateral, F_Collateral[_collateral]);\n    }\n\n    function increaseF_LUSD(uint _LUSDFee) external override {\n        _requireCallerIsBorrowerOperations();\n        uint LUSDFeePerLQTYStaked;\n        \n        if (totalLQTYStaked > 0) {LUSDFeePerLQTYStaked = _LUSDFee.mul(DECIMAL_PRECISION).div(totalLQTYStaked);}\n        \n        F_LUSD = F_LUSD.add(LUSDFeePerLQTYStaked);\n        emit F_LUSDUpdated(F_LUSD);\n    }\n\n    // --- Pending reward functions ---\n\n    function getPendingCollateralGain(address _user) external view override returns (address[] memory, uint[] memory) {\n        return _getPendingCollateralGain(_user);\n    }\n\n    function _getPendingCollateralGain(address _user) internal view returns (address[] memory assets, uint[] memory amounts) {\n        assets = collateralConfig.getAllowedCollaterals();\n        amounts = new uint[](assets.length);\n        for (uint i = 0; i < assets.length; i++) {\n            address collateral = assets[i];\n            uint F_Collateral_Snapshot = snapshots[_user].F_Collateral_Snapshot[collateral];\n            amounts[i] = stakes[_user].mul(F_Collateral[collateral].sub(F_Collateral_Snapshot)).div(DECIMAL_PRECISION);\n        }\n    }\n\n    function getPendingLUSDGain(address _user) external view override returns (uint) {\n        return _getPendingLUSDGain(_user);\n    }\n\n    function _getPendingLUSDGain(address _user) internal view returns (uint) {\n        uint F_LUSD_Snapshot = snapshots[_user].F_LUSD_Snapshot;\n        uint LUSDGain = stakes[_user].mul(F_LUSD.sub(F_LUSD_Snapshot)).div(DECIMAL_PRECISION);\n        return LUSDGain;\n    }\n\n    // --- Internal helper functions ---\n\n    function _updateUserSnapshots(address _user) internal {\n        address[] memory collaterals = collateralConfig.getAllowedCollaterals();\n        uint[] memory amounts = new uint[](collaterals.length);\n        for (uint i = 0; i < collaterals.length; i++) {\n            address collateral = collaterals[i];\n            snapshots[_user].F_Collateral_Snapshot[collateral] = F_Collateral[collateral];\n            amounts[i] = F_Collateral[collateral];\n        }\n        uint fLUSD = F_LUSD;\n        snapshots[_user].F_LUSD_Snapshot = fLUSD;\n        emit StakerSnapshotsUpdated(_user, collaterals, amounts, fLUSD);\n    }\n\n    function _sendCollGainToUser(address[] memory assets, uint[] memory amounts) internal {\n        uint numCollaterals = assets.length;\n        for (uint i = 0; i < numCollaterals; i++) {\n            if (amounts[i] != 0) {\n                address collateral = assets[i];\n                emit CollateralSent(msg.sender, collateral, amounts[i]);\n                IERC20(collateral).safeTransfer(msg.sender, amounts[i]);\n            }\n        }\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsTroveManagerOrActivePool() internal view {\n        address redemptionHelper = address(ITroveManager(troveManagerAddress).redemptionHelper());\n        require(\n            msg.sender == troveManagerAddress ||\n            msg.sender == redemptionHelper ||\n            msg.sender == activePoolAddress,\n            \"LQTYStaking: caller is not TroveM or ActivePool\"\n        );\n    }\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(msg.sender == borrowerOperationsAddress, \"LQTYStaking: caller is not BorrowerOps\");\n    }\n\n    function _requireUserHasStake(uint currentStake) internal pure {  \n        require(currentStake > 0, 'LQTYStaking: User must have a non-zero stake');  \n    }\n\n    function _requireNonZeroAmount(uint _amount) internal pure {\n        require(_amount > 0, 'LQTYStaking: Amount must be non-zero');\n    }\n}"
    },
    {
      "filename": "Ethos-Core/contracts/RedemptionHelper.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.6.11;\n\nimport \"./Interfaces/ICollateralConfig.sol\";\nimport \"./Interfaces/ILQTYStaking.sol\";\nimport \"./Interfaces/ILUSDToken.sol\";\nimport \"./Interfaces/IPriceFeed.sol\";\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/IRedemptionHelper.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/IERC20.sol\";\n\ncontract RedemptionHelper is LiquityBase, Ownable, IRedemptionHelper {\n    uint constant public BOOTSTRAP_PERIOD = 14 days;\n\n    ITroveManager public troveManager;\n    ICollateralConfig public collateralConfig;\n    IERC20 public lqtyToken;\n    ILUSDToken public lusdToken;\n    ISortedTroves public sortedTroves;\n    ILQTYStaking public lqtyStaking;\n\n    struct RedemptionTotals {\n        uint remainingLUSD;\n        uint totalLUSDToRedeem;\n        uint totalCollateralDrawn;\n        uint collateralFee;\n        uint collateralToSendToRedeemer;\n        uint decayedBaseRate;\n        uint price;\n        uint totalLUSDSupplyAtStart;\n        uint256 collDecimals;\n        uint256 collMCR;\n        address currentBorrower;\n    }\n\n    struct SingleRedemptionValues {\n        uint LUSDLot;\n        uint collLot;\n        bool cancelledPartial;\n    }\n\n    // Due to \"stack too deep\" error\n    struct LocalVariables_redeemCollateralFromTrove {\n        uint newDebt;\n        uint newColl;\n        uint newNICR;\n        uint256 collDecimals;\n    }\n\n    function setAddresses(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        ITroveManager _troveManager,\n        ICollateralConfig _collateralConfig,\n        IERC20 _lqtyToken,\n        IPriceFeed _priceFeed,\n        ILUSDToken _lusdToken,\n        ISortedTroves _sortedTroves,\n        ILQTYStaking _lqtyStaking\n    ) external onlyOwner {\n        activePool = _activePool;\n        defaultPool = _defaultPool;\n        troveManager = _troveManager;\n        collateralConfig = _collateralConfig;\n        lqtyToken = _lqtyToken;\n        priceFeed = _priceFeed;\n        lusdToken = _lusdToken;\n        sortedTroves = _sortedTroves;\n        lqtyStaking = _lqtyStaking;\n\n        _renounceOwnership();\n    }\n\n    /* Send _LUSDamount LUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n    * request.  Applies pending rewards to a Trove before reducing its debt and coll.\n    *\n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by\n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\n    *\n    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to\n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”\n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode\n    * costs can vary.\n    *\n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.\n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position\n    * in the sortedTroves list along with the ICR value that the hint was found for.\n    *\n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining LUSD amount, which they can attempt\n    * to redeem later.\n    */\n    function redeemCollateral(\n        address _collateral,\n        address _redeemer,\n        uint _LUSDamount,\n        address _firstRedemptionHint,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint _partialRedemptionHintNICR,\n        uint _maxIterations,\n        uint _maxFeePercentage\n    )\n        external override\n    {\n        _requireCallerIsTroveManager();\n        _requireValidCollateralAddress(_collateral);\n        RedemptionTotals memory totals;\n\n        _requireValidMaxFeePercentage(_maxFeePercentage);\n        _requireAfterBootstrapPeriod();\n        totals.price = priceFeed.fetchPrice(_collateral);\n        ICollateralConfig collateralConfigCached = collateralConfig;\n        totals.collDecimals = collateralConfigCached.getCollateralDecimals(_collateral);\n        totals.collMCR = collateralConfigCached.getCollateralMCR(_collateral);\n        _requireTCRoverMCR(_collateral, totals.price, totals.collDecimals, totals.collMCR);\n        _requireAmountGreaterThanZero(_LUSDamount);\n        _requireLUSDBalanceCoversRedemption(lusdToken, _redeemer, _LUSDamount);\n\n        totals.totalLUSDSupplyAtStart = getEntireSystemDebt(_collateral);\n        // Confirm redeemer's balance is less than total LUSD supply\n        assert(lusdToken.balanceOf(_redeemer) <= totals.totalLUSDSupplyAtStart);\n\n        totals.remainingLUSD = _LUSDamount;\n\n        ISortedTroves sortedTrovesCached = sortedTroves;\n        if (_isValidFirstRedemptionHint(\n            sortedTrovesCached,\n            _collateral,\n            _firstRedemptionHint,\n            totals.price,\n            totals.collMCR)\n        ) {\n            totals.currentBorrower = _firstRedemptionHint;\n        } else {\n            totals.currentBorrower = sortedTrovesCached.getLast(_collateral);\n            // Find the first trove with ICR >= MCR\n            while (totals.currentBorrower != address(0) &&\n                troveManager.getCurrentICR(totals.currentBorrower, _collateral, totals.price) < totals.collMCR) \n            {\n                totals.currentBorrower = sortedTrovesCached.getPrev(_collateral, totals.currentBorrower);\n            }\n        }\n\n        // Loop through the Troves starting from the one with lowest collateral ratio until _amount of LUSD is exchanged for collateral\n        if (_maxIterations == 0) { _maxIterations = uint(-1); }\n        while (totals.currentBorrower != address(0) && totals.remainingLUSD > 0 && _maxIterations > 0) {\n            _maxIterations--;\n            // Save the address of the Trove preceding the current one, before potentially modifying the list\n            address nextUserToCheck = sortedTrovesCached.getPrev(_collateral, totals.currentBorrower);\n\n            troveManager.applyPendingRewards(totals.currentBorrower, _collateral);\n\n            SingleRedemptionValues memory singleRedemption = _redeemCollateralFromTrove(\n                totals.currentBorrower,\n                _collateral,\n                totals.remainingLUSD,\n                totals.price,\n                _upperPartialRedemptionHint,\n                _lowerPartialRedemptionHint,\n                _partialRedemptionHintNICR,\n                collateralConfigCached\n            );\n\n            if (singleRedemption.cancelledPartial) break; // Partial redemption was cancelled (out-of-date hint, or new net debt < minimum), therefore we could not redeem from the last Trove\n\n            totals.totalLUSDToRedeem  = totals.totalLUSDToRedeem.add(singleRedemption.LUSDLot);\n            totals.totalCollateralDrawn = totals.totalCollateralDrawn.add(singleRedemption.collLot);\n\n            totals.remainingLUSD = totals.remainingLUSD.sub(singleRedemption.LUSDLot);\n            totals.currentBorrower = nextUserToCheck;\n        }\n        require(totals.totalCollateralDrawn > 0);\n\n        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption.\n        // Use the saved total LUSD supply value, from before it was reduced by the redemption.\n        troveManager.updateBaseRateFromRedemption(\n            totals.totalCollateralDrawn,\n            totals.price,\n            totals.collDecimals,\n            totals.totalLUSDSupplyAtStart\n        );\n\n        // Calculate the ETH fee\n        totals.collateralFee = troveManager.getRedemptionFee(totals.totalCollateralDrawn);\n\n        _requireUserAcceptsFee(totals.collateralFee, totals.totalCollateralDrawn, _maxFeePercentage);\n\n        // Send the collateral fee to the LQTY staking contract\n        activePool.sendCollateral(_collateral, address(lqtyStaking), totals.collateralFee);\n        lqtyStaking.increaseF_Collateral(_collateral, totals.collateralFee);\n\n        totals.collateralToSendToRedeemer = totals.totalCollateralDrawn.sub(totals.collateralFee);\n\n        // Burn the total LUSD that is cancelled with debt, and send the redeemed collateral to _redeemer\n        troveManager.burnLUSDAndEmitRedemptionEvent(\n            _redeemer,\n            _collateral,\n            _LUSDamount,\n            totals.totalLUSDToRedeem,\n            totals.totalCollateralDrawn,\n            totals.collateralFee\n        );\n\n        // Update Active Pool LUSD, and send ETH to account\n        activePool.decreaseLUSDDebt(_collateral, totals.totalLUSDToRedeem);\n        activePool.sendCollateral(_collateral, _redeemer, totals.collateralToSendToRedeemer);\n    }\n\n    function _isValidFirstRedemptionHint(\n        ISortedTroves _sortedTroves,\n        address _collateral,\n        address _firstRedemptionHint,\n        uint _price,\n        uint256 _MCR\n    ) internal view returns (bool) {\n        if (_firstRedemptionHint == address(0) ||\n            !_sortedTroves.contains(_collateral, _firstRedemptionHint) ||\n            troveManager.getCurrentICR(_firstRedemptionHint, _collateral, _price) < _MCR\n        ) {\n            return false;\n        }\n\n        address nextTrove = _sortedTroves.getNext(_collateral, _firstRedemptionHint);\n        return nextTrove == address(0) || troveManager.getCurrentICR(nextTrove, _collateral, _price) < _MCR;\n    }\n\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for LUSD up to _maxLUSDamount\n    function _redeemCollateralFromTrove(\n        address _borrower,\n        address _collateral,\n        uint _maxLUSDamount,\n        uint _price,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint _partialRedemptionHintNICR,\n        ICollateralConfig _collateralConfig\n    )\n        internal returns (SingleRedemptionValues memory singleRedemption)\n    {\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the liquidation reserve\n        singleRedemption.LUSDLot = LiquityMath._min(\n            _maxLUSDamount,\n            troveManager.getTroveDebt(_borrower, _collateral).sub(LUSD_GAS_COMPENSATION)\n        );\n\n        LocalVariables_redeemCollateralFromTrove memory vars;\n        vars.collDecimals = _collateralConfig.getCollateralDecimals(_collateral);\n\n        // Get the collLot of equivalent value in USD\n        singleRedemption.collLot = singleRedemption.LUSDLot.mul(10**vars.collDecimals).div(_price);\n\n        // Decrease the debt and collateral of the current Trove according to the LUSD lot and corresponding collateral to send\n        vars.newDebt = troveManager.getTroveDebt(_borrower, _collateral).sub(singleRedemption.LUSDLot);\n        vars.newColl = troveManager.getTroveColl(_borrower, _collateral).sub(singleRedemption.collLot);\n\n        if (vars.newDebt == LUSD_GAS_COMPENSATION) {\n            // No debt left in the Trove (except for the liquidation reserve), therefore the trove gets closed\n            troveManager.removeStake(_borrower, _collateral);\n            troveManager.closeTrove(_borrower, _collateral, 4); // 4 = closedByRedemption\n            troveManager.redeemCloseTrove(_borrower, _collateral, LUSD_GAS_COMPENSATION, vars.newColl);\n        } else {\n            vars.newNICR = LiquityMath._computeNominalCR(vars.newColl, vars.newDebt, vars.collDecimals);\n\n            /*\n            * If the provided hint is out of date, we bail since trying to reinsert without a good hint will almost\n            * certainly result in running out of gas. \n            *\n            * If the resultant net debt of the partial is less than the minimum, net debt we bail.\n            */\n            if (vars.newNICR != _partialRedemptionHintNICR || _getNetDebt(vars.newDebt) < MIN_NET_DEBT) {\n                singleRedemption.cancelledPartial = true;\n                return singleRedemption;\n            }\n\n            troveManager.reInsert(\n                _borrower,\n                _collateral,\n                vars.newNICR,\n                _upperPartialRedemptionHint,\n                _lowerPartialRedemptionHint\n            );\n            troveManager.updateDebtAndCollAndStakesPostRedemption(_borrower, _collateral, vars.newDebt, vars.newColl);\n        }\n\n        return singleRedemption;\n    }\n\n    function _requireCallerIsTroveManager() internal view {\n        require(msg.sender == address(troveManager), \"RedemptionHelper: Caller is not TroveManager\");\n    }\n\n    function _requireValidCollateralAddress(address _collateral) internal view {\n        require(collateralConfig.isCollateralAllowed(_collateral), \"Invalid collateral address\");\n    }\n\n    function _requireValidMaxFeePercentage(uint _maxFeePercentage) internal view {\n        require(_maxFeePercentage >= troveManager.REDEMPTION_FEE_FLOOR() && _maxFeePercentage <= DECIMAL_PRECISION);\n    }\n\n    function _requireAfterBootstrapPeriod() internal view {\n        uint systemDeploymentTime = lusdToken.getDeploymentStartTime();\n        require(block.timestamp >= systemDeploymentTime.add(BOOTSTRAP_PERIOD));\n    }\n\n    function _requireTCRoverMCR(address _collateral, uint _price, uint256 _collDecimals, uint256 _MCR) internal view {\n        require(_getTCR(_collateral, _price, _collDecimals) >= _MCR);\n    }\n\n    function _requireAmountGreaterThanZero(uint _amount) internal pure {\n        require(_amount > 0);\n    }\n\n    function _requireLUSDBalanceCoversRedemption(ILUSDToken _lusdToken, address _redeemer, uint _amount) internal view {\n        require(_lusdToken.balanceOf(_redeemer) >= _amount);\n    }\n}"
    },
    {
      "filename": "Ethos-Core/contracts/ActivePool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.6.11;\n\nimport './Interfaces/IActivePool.sol';\nimport \"./Interfaces/ICollateralConfig.sol\";\nimport './Interfaces/IDefaultPool.sol';\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/ILQTYStaking.sol\";\nimport \"./Interfaces/IStabilityPool.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/CheckContract.sol\";\nimport \"./Dependencies/console.sol\";\nimport \"./Dependencies/SafeERC20.sol\";\nimport \"./Dependencies/IERC4626.sol\";\n\n/*\n * The Active Pool holds the collateral and LUSD debt for each collateral (but not LUSD tokens) for all active troves.\n *\n * When a trove is liquidated, it's collateral and LUSD debt are transferred from the Active Pool, to either the\n * Stability Pool, the Default Pool, or both, depending on the liquidation conditions.\n *\n */\ncontract ActivePool is Ownable, CheckContract, IActivePool {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    string constant public NAME = \"ActivePool\";\n\n    bool public addressesSet = false;\n    address public collateralConfigAddress;\n    address public borrowerOperationsAddress;\n    address public troveManagerAddress;\n    address public stabilityPoolAddress;\n    address public defaultPoolAddress;\n    address public collSurplusPoolAddress;\n    address public treasuryAddress;\n    address public lqtyStakingAddress;\n    mapping (address => uint256) internal collAmount;  // collateral => amount tracker\n    mapping (address => uint256) internal LUSDDebt;  // collateral => corresponding debt tracker\n\n    mapping (address => uint256) public yieldingPercentage; // collateral => % to use for yield farming (in BPS, <= 10k)\n    mapping (address => uint256) public yieldingAmount; // collateral => actual wei amount being used for yield farming\n    mapping (address => address) public yieldGenerator; // collateral => corresponding ERC4626 vault\n    mapping (address => uint256) public yieldClaimThreshold; // collateral => minimum wei amount of yield to claim and redistribute\n    \n    uint256 public yieldingPercentageDrift = 100; // rebalance iff % is off by more than 100 BPS\n\n    // Yield distribution params, must add up to 10k\n    uint256 public yieldSplitTreasury = 20_00; // amount of yield to direct to treasury in BPS\n    uint256 public yieldSplitSP = 40_00; // amount of yield to direct to stability pool in BPS\n    uint256 public yieldSplitStaking = 40_00; // amount of yield to direct to OATH Stakers in BPS\n\n    // --- Events ---\n\n    event CollateralConfigAddressChanged(address _newCollateralConfigAddress);\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event ActivePoolLUSDDebtUpdated(address _collateral, uint _LUSDDebt);\n    event ActivePoolCollateralBalanceUpdated(address _collateral, uint _amount);\n    event YieldingPercentageUpdated(address _collateral, uint256 _bps);\n    event YieldingPercentageDriftUpdated(uint256 _driftBps);\n    event YieldClaimThresholdUpdated(address _collateral, uint256 _threshold);\n    event YieldDistributionParamsUpdated(uint256 _treasurySplit, uint256 _SPSplit, uint256 _stakingSplit);\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _collateralConfigAddress,\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _stabilityPoolAddress,\n        address _defaultPoolAddress,\n        address _collSurplusPoolAddress,\n        address _treasuryAddress,\n        address _lqtyStakingAddress,\n        address[] calldata _erc4626vaults\n    )\n        external\n        onlyOwner\n    {\n        require(!addressesSet, \"Can call setAddresses only once\");\n\n        checkContract(_collateralConfigAddress);\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        require(_treasuryAddress != address(0), \"Treasury cannot be 0 address\");\n        checkContract(_lqtyStakingAddress);\n\n        collateralConfigAddress = _collateralConfigAddress;\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        troveManagerAddress = _troveManagerAddress;\n        stabilityPoolAddress = _stabilityPoolAddress;\n        defaultPoolAddress = _defaultPoolAddress;\n        collSurplusPoolAddress = _collSurplusPoolAddress;\n        treasuryAddress = _treasuryAddress;\n        lqtyStakingAddress = _lqtyStakingAddress;\n\n        address[] memory collaterals = ICollateralConfig(collateralConfigAddress).getAllowedCollaterals();\n        uint256 numCollaterals = collaterals.length;\n        require(numCollaterals == _erc4626vaults.length, \"Vaults array length must match number of collaterals\");\n        for(uint256 i = 0; i < numCollaterals; i++) {\n            address collateral = collaterals[i];\n            address vault = _erc4626vaults[i];\n            require(IERC4626(vault).asset() == collateral, \"Vault asset must be collateral\");\n            yieldGenerator[collateral] = vault;\n        }\n\n        emit CollateralConfigAddressChanged(_collateralConfigAddress);\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n\n        addressesSet = true;\n    }\n\n    function setYieldingPercentage(address _collateral, uint256 _bps) external onlyOwner {\n        _requireValidCollateralAddress(_collateral);\n        require(_bps <= 10_000, \"Invalid BPS value\");\n        yieldingPercentage[_collateral] = _bps;\n        emit YieldingPercentageUpdated(_collateral, _bps);\n    }\n\n    function setYieldingPercentageDrift(uint256 _driftBps) external onlyOwner {\n        require(_driftBps <= 500, \"Exceeds max allowed value of 500 BPS\");\n        yieldingPercentageDrift = _driftBps;\n        emit YieldingPercentageDriftUpdated(_driftBps);\n    }\n\n    function setYieldClaimThreshold(address _collateral, uint256 _threshold) external onlyOwner {\n        _requireValidCollateralAddress(_collateral);\n        yieldClaimThreshold[_collateral] = _threshold;\n        emit YieldClaimThresholdUpdated(_collateral, _threshold);\n    }\n\n    function setYieldDistributionParams(uint256 _treasurySplit, uint256 _SPSplit, uint256 _stakingSplit) external onlyOwner {\n        require(_treasurySplit + _SPSplit + _stakingSplit == 10_000, \"Splits must add up to 10000 BPS\");\n        yieldSplitTreasury = _treasurySplit;\n        yieldSplitSP = _SPSplit;\n        yieldSplitStaking = _stakingSplit;\n        emit YieldDistributionParamsUpdated(_treasurySplit, _SPSplit, _stakingSplit);\n    }\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    /*\n    * Returns the collAmount state variable.\n    *\n    *Not necessarily equal to the the contract's raw collateral balance - collateral can"
    }
  ]
}