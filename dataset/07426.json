{
  "Title": "[M-15] Wrong reward distribution between early and late depositors because of the late syncRewards() call in the cycle, syncReward() logic should be executed in each withdraw or deposits (without reverting)",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/tokens/TokenggAVAX.sol#L88-L109\nhttps://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/tokens/TokenggAVAX.sol#L166-L178\nhttps://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/tokens/TokenggAVAX.sol#L180-L189\n\n\n# Vulnerability details\n\n## Impact\nFunction `syncRewards()` distributes rewards to TokenggAVAX holders, it linearly distribute cycle's rewards from `block.timestamp` to the cycle end time which is next multiple of the `rewardsCycleLength` (the end time of the cycle is defined and the real duration of the cycle changes). when a cycle ends `syncRewards()` should be called so the next cycle starts but if `syncRewards()` doesn't get called fast, then users depositing or withdrawing funds before call to `syncRewards()` would lose their rewards and those rewards would go to users who deposited funds after `syncRewards()` call. contract should try to start the next cycle whenever deposit or withdraw happens to make sure rewards are distributed fairly between users.\n\n## Proof of Concept\nThis is `syncRewards()` code:\n```\n\tfunction syncRewards() public {\n\t\tuint32 timestamp = block.timestamp.safeCastTo32();\n\n\t\tif (timestamp < rewardsCycleEnd) {\n\t\t\trevert SyncError();\n\t\t}\n\n\t\tuint192 lastRewardsAmt_ = lastRewardsAmt;\n\t\tuint256 totalReleasedAssets_ = totalReleasedAssets;\n\t\tuint256 stakingTotalAssets_ = stakingTotalAssets;\n\n\t\tuint256 nextRewardsAmt = (asset.balanceOf(address(this)) + stakingTotalAssets_) - totalReleasedAssets_ - lastRewardsAmt_;\n\n\t\t// Ensure nextRewardsCycleEnd will be evenly divisible by `rewardsCycleLength`.\n\t\tuint32 nextRewardsCycleEnd = ((timestamp + rewardsCycleLength) / rewardsCycleLength) * rewardsCycleLength;\n\n\t\tlastRewardsAmt = nextRewardsAmt.safeCastTo192();\n\t\tlastSync = timestamp;\n\t\trewardsCycleEnd = nextRewardsCycleEnd;\n\t\ttotalReleasedAssets = totalReleasedAssets_ + lastRewardsAmt_;\n\t\temit NewRewardsCycle(nextRewardsCycleEnd, nextRewardsAmt);\n\t}\n```\nAs you can see whenever this function is called it starts the new cycle and sets the end of the cycle to the next multiple of the `rewardsCycleLength` and it release the rewards linearly between current timestamp and cycle end time. so if `syncRewards()` get called near to multiple of the `rewardsCycleLength` then rewards would be distributed with higher speed in less time. the problem is that users depositing funds before call `syncRewards()` won't receive new cycles rewards and early depositing won't get considered in reward distribution if deposits happen before `syncRewards()` call and if a user withdraws his funds before the `syncRewards()` call then he receive no rewards.\nimagine this scenario:\n1. `rewardsCycleLength` is 10 days and the rewards for the next cycle is `100` AVAX.\n2. the last cycle has been ended and user1 has `10000` AVAX deposited and has 50% of the pool shares.\n3. `syncRewards()` don't get called for 8 days.\n3. users1 withdraws his funds receive `10000` AVAX even so he deposits for 8 days in the current cycle.\n4. users2 deposit `1000` AVAX and get 10% of pool shares and the user2 would call `syncRewards()` and contract would start distributing `100` avax as reward.\n5. after 2 days cycle would finish and user2 would receive `100 * 10% = 10` AVAX as rewards for his `1000` AVAX deposit for 2 days but user1 had `10000` AVAX for 8 days and would receive 0 rewards.\n\nso rewards won't distribute fairly between depositors across the time and any user interacting with contract before the `syncRewards()` call can lose his rewards. contract won't consider deposit amounts and duration before `syncRewards()` call and it won't make sure that `syncRewards()` logic would be executed as early as possible with deposit or withdraw calls when a cycle ends.\n\n## Tools Used\nVIM\n\n## Recommended Mitigation Steps\none way to solve this is to call `syncRewards()` logic in each deposit or withdraw and make sure that cycles start as early as possible (the revert \"SyncError()\" in the `syncRewards()` should be removed for this).",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-12-gogopool-contest",
  "Code": [
    {
      "filename": "contracts/contract/tokens/TokenggAVAX.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n// Copied from https://github.com/fei-protocol/ERC4626/blob/main/src/xERC4626.sol\n// Rewards logic inspired by xERC20 (https://github.com/ZeframLou/playpen/blob/main/src/xERC20.sol)\npragma solidity 0.8.17;\n\nimport \"../BaseUpgradeable.sol\";\nimport {ERC20Upgradeable} from \"./upgradeable/ERC20Upgradeable.sol\";\nimport {ERC4626Upgradeable} from \"./upgradeable/ERC4626Upgradeable.sol\";\nimport {ProtocolDAO} from \"../ProtocolDAO.sol\";\nimport {Storage} from \"../Storage.sol\";\n\nimport {IWithdrawer} from \"../../interface/IWithdrawer.sol\";\nimport {IWAVAX} from \"../../interface/IWAVAX.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\nimport {ERC20} from \"@rari-capital/solmate/src/mixins/ERC4626.sol\";\nimport {FixedPointMathLib} from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\nimport {SafeCastLib} from \"@rari-capital/solmate/src/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\n\n/// @dev Local variables and parent contracts must remain in order between contract upgrades\ncontract TokenggAVAX is Initializable, ERC4626Upgradeable, UUPSUpgradeable, BaseUpgradeable {\n\tusing SafeTransferLib for ERC20;\n\tusing SafeTransferLib for address;\n\tusing SafeCastLib for *;\n\tusing FixedPointMathLib for uint256;\n\n\terror SyncError();\n\terror ZeroShares();\n\terror ZeroAssets();\n\terror InvalidStakingDeposit();\n\terror WithdrawAmountTooLarge();\n\n\tevent NewRewardsCycle(uint256 indexed cycleEnd, uint256 rewardsAmt);\n\tevent WithdrawnForStaking(address indexed caller, uint256 assets);\n\tevent DepositedFromStaking(address indexed caller, uint256 baseAmt, uint256 rewardsAmt);\n\n\t/// @notice the effective start of the current cycle\n\tuint32 public lastSync;\n\n\t/// @notice the maximum length of a rewards cycle\n\tuint32 public rewardsCycleLength;\n\n\t/// @notice the end of the current cycle. Will always be evenly divisible by `rewardsCycleLength`.\n\tuint32 public rewardsCycleEnd;\n\n\t/// @notice the amount of rewards distributed in a the most recent cycle.\n\tuint192 public lastRewardsAmt;\n\n\t/// @notice the total amount of avax (including avax sent out for staking and all incoming rewards)\n\tuint256 public totalReleasedAssets;\n\n\t/// @notice total amount of avax currently out for staking (not including any rewards)\n\tuint256 public stakingTotalAssets;\n\n\tmodifier whenTokenNotPaused(uint256 amt) {\n\t\tif (amt > 0 && getBool(keccak256(abi.encodePacked(\"contract.paused\", \"TokenggAVAX\")))) {\n\t\t\trevert ContractPaused();\n\t\t}\n\t\t_;\n\t}\n\n\t/// @custom:oz-upgrades-unsafe-allow constructor\n\tconstructor() {\n\t\t// The constructor is exectued only when creating implementation contract\n\t\t// so prevent it's reinitialization\n\t\t_disableInitializers();\n\t}\n\n\tfunction initialize(Storage storageAddress, ERC20 asset) public initializer {\n\t\t__ERC4626Upgradeable_init(asset, \"GoGoPool Liquid Staking Token\", \"ggAVAX\");\n\t\t__BaseUpgradeable_init(storageAddress);\n\n\t\trewardsCycleLength = 14 days;\n\t\t// Ensure it will be evenly divisible by `rewardsCycleLength`.\n\t\trewardsCycleEnd = (block.timestamp.safeCastTo32() / rewardsCycleLength) * rewardsCycleLength;\n\t}\n\n\t/// @notice only accept AVAX via fallback from the WAVAX contract\n\treceive() external payable {\n\t\tassert(msg.sender == address(asset));\n\t}\n\n\t/// @notice Distributes rewards to TokenggAVAX holders. Public, anyone can call.\n\t/// \t\t\t\tAll surplus `asset` balance of the contract over the internal balance becomes queued for the next cycle.\n\tfunction syncRewards() public {\n\t\tuint32 timestamp = block.timestamp.safeCastTo32();\n\n\t\tif (timestamp < rewardsCycleEnd) {\n\t\t\trevert SyncError();\n\t\t}\n\n\t\tuint192 lastRewardsAmt_ = lastRewardsAmt;\n\t\tuint256 totalReleasedAssets_ = totalReleasedAssets;\n\t\tuint256 stakingTotalAssets_ = stakingTotalAssets;\n\n\t\tuint256 nextRewardsAmt = (asset.balanceOf(address(this)) + stakingTotalAssets_) - totalReleasedAssets_ - lastRewardsAmt_;\n\n\t\t// Ensure nextRewardsCycleEnd will be evenly divisible by `rewardsCycleLength`.\n\t\tuint32 nextRewardsCycleEnd = ((timestamp + rewardsCycleLength) / rewardsCycleLength) * rewardsCycleLength;\n\n\t\tlastRewardsAmt = nextRewardsAmt.safeCastTo192();\n\t\tlastSync = timestamp;\n\t\trewardsCycleEnd = nextRewardsCycleEnd;\n\t\ttotalReleasedAssets = totalReleasedAssets_ + lastRewardsAmt_;\n\t\temit NewRewardsCycle(nextRewardsCycleEnd, nextRewardsAmt);\n\t}\n\n\t/// @notice Compute the amount of tokens available to share holders.\n\t///         Increases linearly during a reward distribution period from the sync call, not the cycle start.\n\tfunction totalAssets() public view override returns (uint256) {\n\t\t// cache global vars\n\t\tuint256 totalReleasedAssets_ = totalReleasedAssets;\n\t\tuint192 lastRewardsAmt_ = lastRewardsAmt;\n\t\tuint32 rewardsCycleEnd_ = rewardsCycleEnd;\n\t\tuint32 lastSync_ = lastSync;\n\n\t\tif (block.timestamp >= rewardsCycleEnd_) {\n\t\t\t// no rewards or rewards are fully unlocked\n\t\t\t// entire reward amount is available\n\t\t\treturn totalReleasedAssets_ + lastRewardsAmt_;\n\t\t}\n\n\t\t// rewards are not fully unlocked\n\t\t// return unlocked rewards and stored total\n\t\tuint256 unlockedRewards = (lastRewardsAmt_ * (block.timestamp - lastSync_)) / (rewardsCycleEnd_ - lastSync_);\n\t\treturn totalReleasedAssets_ + unlockedRewards;\n\t}\n\n\tfunction amountAvailableForStaking() public view returns (uint256) {\n\t\tProtocolDAO protocolDAO = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tuint256 targetCollateralRate = protocolDAO.getTargetGGAVAXReserveRate();\n\n\t\tuint256 totalAssets_ = totalAssets();\n\n\t\tuint256 reservedAssets = totalAssets_.mulDivDown(targetCollateralRate, 1 ether);\n\t\treturn totalAssets_ - reservedAssets - stakingTotalAssets;\n\t}\n\n\tfunction depositFromStaking(uint256 baseAmt, uint256 rewardAmt) public payable onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tuint256 totalAmt = msg.value;\n\t\tif (totalAmt != (baseAmt + rewardAmt) || baseAmt > stakingTotalAssets) {\n\t\t\trevert InvalidStakingDeposit();\n\t\t}\n\n\t\temit DepositedFromStaking(msg.sender, baseAmt, rewardAmt);\n\t\tstakingTotalAssets -= baseAmt;\n\t\tIWAVAX(address(asset)).deposit{value: totalAmt}();\n\t}\n\n\tfunction withdrawForStaking(uint256 assets) public onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tif (assets > amountAvailableForStaking()) {\n\t\t\trevert WithdrawAmountTooLarge();\n\t\t}\n\n\t\temit WithdrawnForStaking(msg.sender, assets);\n\n\t\tstakingTotalAssets += assets;\n\t\tIWAVAX(address(asset)).withdraw(assets);\n\t\tIWithdrawer withdrawer = IWithdrawer(msg.sender);\n\t\twithdrawer.receiveWithdrawalAVAX{value: assets}();\n\t}\n\n\tfunction depositAVAX() public payable returns (uint256 shares) {\n\t\tuint256 assets = msg.value;\n\t\t// Check for rounding error since we round down in previewDeposit.\n\t\tif ((shares = previewDeposit(assets)) == 0) {\n\t\t\trevert ZeroShares();\n\t\t}\n\n\t\temit Deposit(msg.sender, msg.sender, assets, shares);\n\n\t\tIWAVAX(address(asset)).deposit{value: assets}();\n\t\t_mint(msg.sender, shares);\n\t\tafterDeposit(assets, shares);\n\t}\n\n\tfunction withdrawAVAX(uint256 assets) public returns (uint256 shares) {\n\t\tshares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\t\tbeforeWithdraw(assets, shares);\n\t\t_burn(msg.sender, shares);\n\n\t\temit Withdraw(msg.sender, msg.sender, msg.sender, assets, shares);\n\n\t\tIWAVAX(address(asset)).withdraw(assets);\n\t\tmsg.sender.safeTransferETH(assets);\n\t}\n\n\tfunction redeemAVAX(uint256 shares) public returns (uint256 assets) {\n\t\t// Check for rounding error since we round down in previewRedeem.\n\t\tif ((assets = previewRedeem(shares)) == 0) {\n\t\t\trevert ZeroAssets();\n\t\t}\n\t\tbeforeWithdraw(assets, shares);\n\t\t_burn(msg.sender, shares);\n\n\t\temit Withdraw(msg.sender, msg.sender, msg.sender, assets, shares);\n\n\t\tIWAVAX(address(asset)).withdraw(assets);\n\t\tmsg.sender.safeTransferETH(assets);\n\t}\n\n\t/// @notice Max amount of assets owner would be able to withdraw taking into account liquidity in this contract\n\tfunction maxWithdraw(address _owner) public view override returns (uint256) {\n\t\tif (getBool(keccak256(abi.encodePacked(\"contract.paused\", \"TokenggAVAX\")))) {\n\t\t\treturn 0;\n\t\t}\n\t\tuint256 assets = convertToAssets(balanceOf[_owner]);\n\t\tuint256 avail = totalAssets() - stakingTotalAssets;\n\t\treturn assets > avail ? avail : assets;\n\t}\n\n\t/// @notice Max amount of shares owner would be able to withdraw taking into account liquidity in this contract\n\tfunction maxRedeem(address _owner) public view override returns (uint256) {\n\t\tif (getBool(keccak256(abi.encodePacked(\"contract.paused\", \"TokenggAVAX\")))) {\n\t\t\treturn 0;\n\t\t}\n\t\tuint256 shares = balanceOf[_owner];\n\t\tuint256 avail = convertToShares(totalAssets() - stakingTotalAssets);\n\t\treturn shares > avail ? avail : shares;\n\t}\n\n\tfunction previewDeposit(uint256 assets) public view override whenTokenNotPaused(assets) returns (uint256) {\n\t\treturn super.previewDeposit(assets);\n\t}\n\n\tfunction previewMint(uint256 shares) public view override whenTokenNotPaused(shares) returns (uint256) {\n\t\treturn super.previewMint(shares);\n\t}\n\n\tfunction previewWithdraw(uint256 assets) public view override whenTokenNotPaused(assets) returns (uint256) {\n\t\treturn super.previewWithdraw(assets);\n\t}\n\n\tfunction previewRedeem(uint256 shares) public view override whenTokenNotPaused(shares) returns (uint256) {\n\t\treturn super.previewRedeem(shares);\n\t}\n\n\tfunction beforeWithdraw(\n\t\tuint256 amount,\n\t\tuint256 /* shares */\n\t) internal override {\n\t\ttotalReleasedAssets -= amount;\n\t}\n\n\tfunction afterDeposit(\n\t\tuint256 amount,\n\t\tuint256 /* shares */\n\t) internal override {\n\t\ttotalReleasedAssets += amount;\n\t}\n\n\tfunction _authorizeUpgrade(address newImplementation) internal override onlyGuardian {}\n}"
    },
    {
      "filename": "contracts/contract/tokens/TokenggAVAX.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n// Copied from https://github.com/fei-protocol/ERC4626/blob/main/src/xERC4626.sol\n// Rewards logic inspired by xERC20 (https://github.com/ZeframLou/playpen/blob/main/src/xERC20.sol)\npragma solidity 0.8.17;\n\nimport \"../BaseUpgradeable.sol\";\nimport {ERC20Upgradeable} from \"./upgradeable/ERC20Upgradeable.sol\";\nimport {ERC4626Upgradeable} from \"./upgradeable/ERC4626Upgradeable.sol\";\nimport {ProtocolDAO} from \"../ProtocolDAO.sol\";\nimport {Storage} from \"../Storage.sol\";\n\nimport {IWithdrawer} from \"../../interface/IWithdrawer.sol\";\nimport {IWAVAX} from \"../../interface/IWAVAX.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\nimport {ERC20} from \"@rari-capital/solmate/src/mixins/ERC4626.sol\";\nimport {FixedPointMathLib} from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\nimport {SafeCastLib} from \"@rari-capital/solmate/src/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\n\n/// @dev Local variables and parent contracts must remain in order between contract upgrades\ncontract TokenggAVAX is Initializable, ERC4626Upgradeable, UUPSUpgradeable, BaseUpgradeable {\n\tusing SafeTransferLib for ERC20;\n\tusing SafeTransferLib for address;\n\tusing SafeCastLib for *;\n\tusing FixedPointMathLib for uint256;\n\n\terror SyncError();\n\terror ZeroShares();\n\terror ZeroAssets();\n\terror InvalidStakingDeposit();\n\terror WithdrawAmountTooLarge();\n\n\tevent NewRewardsCycle(uint256 indexed cycleEnd, uint256 rewardsAmt);\n\tevent WithdrawnForStaking(address indexed caller, uint256 assets);\n\tevent DepositedFromStaking(address indexed caller, uint256 baseAmt, uint256 rewardsAmt);\n\n\t/// @notice the effective start of the current cycle\n\tuint32 public lastSync;\n\n\t/// @notice the maximum length of a rewards cycle\n\tuint32 public rewardsCycleLength;\n\n\t/// @notice the end of the current cycle. Will always be evenly divisible by `rewardsCycleLength`.\n\tuint32 public rewardsCycleEnd;\n\n\t/// @notice the amount of rewards distributed in a the most recent cycle.\n\tuint192 public lastRewardsAmt;\n\n\t/// @notice the total amount of avax (including avax sent out for staking and all incoming rewards)\n\tuint256 public totalReleasedAssets;\n\n\t/// @notice total amount of avax currently out for staking (not including any rewards)\n\tuint256 public stakingTotalAssets;\n\n\tmodifier whenTokenNotPaused(uint256 amt) {\n\t\tif (amt > 0 && getBool(keccak256(abi.encodePacked(\"contract.paused\", \"TokenggAVAX\")))) {\n\t\t\trevert ContractPaused();\n\t\t}\n\t\t_;\n\t}\n\n\t/// @custom:oz-upgrades-unsafe-allow constructor\n\tconstructor() {\n\t\t// The constructor is exectued only when creating implementation contract\n\t\t// so prevent it's reinitialization\n\t\t_disableInitializers();\n\t}\n\n\tfunction initialize(Storage storageAddress, ERC20 asset) public initializer {\n\t\t__ERC4626Upgradeable_init(asset, \"GoGoPool Liquid Staking Token\", \"ggAVAX\");\n\t\t__BaseUpgradeable_init(storageAddress);\n\n\t\trewardsCycleLength = 14 days;\n\t\t// Ensure it will be evenly divisible by `rewardsCycleLength`.\n\t\trewardsCycleEnd = (block.timestamp.safeCastTo32() / rewardsCycleLength) * rewardsCycleLength;\n\t}\n\n\t/// @notice only accept AVAX via fallback from the WAVAX contract\n\treceive() external payable {\n\t\tassert(msg.sender == address(asset));\n\t}\n\n\t/// @notice Distributes rewards to TokenggAVAX holders. Public, anyone can call.\n\t/// \t\t\t\tAll surplus `asset` balance of the contract over the internal balance becomes queued for the next cycle.\n\tfunction syncRewards() public {\n\t\tuint32 timestamp = block.timestamp.safeCastTo32();\n\n\t\tif (timestamp < rewardsCycleEnd) {\n\t\t\trevert SyncError();\n\t\t}\n\n\t\tuint192 lastRewardsAmt_ = lastRewardsAmt;\n\t\tuint256 totalReleasedAssets_ = totalReleasedAssets;\n\t\tuint256 stakingTotalAssets_ = stakingTotalAssets;\n\n\t\tuint256 nextRewardsAmt = (asset.balanceOf(address(this)) + stakingTotalAssets_) - totalReleasedAssets_ - lastRewardsAmt_;\n\n\t\t// Ensure nextRewardsCycleEnd will be evenly divisible by `rewardsCycleLength`.\n\t\tuint32 nextRewardsCycleEnd = ((timestamp + rewardsCycleLength) / rewardsCycleLength) * rewardsCycleLength;\n\n\t\tlastRewardsAmt = nextRewardsAmt.safeCastTo192();\n\t\tlastSync = timestamp;\n\t\trewardsCycleEnd = nextRewardsCycleEnd;\n\t\ttotalReleasedAssets = totalReleasedAssets_ + lastRewardsAmt_;\n\t\temit NewRewardsCycle(nextRewardsCycleEnd, nextRewardsAmt);\n\t}\n\n\t/// @notice Compute the amount of tokens available to share holders.\n\t///         Increases linearly during a reward distribution period from the sync call, not the cycle start.\n\tfunction totalAssets() public view override returns (uint256) {\n\t\t// cache global vars\n\t\tuint256 totalReleasedAssets_ = totalReleasedAssets;\n\t\tuint192 lastRewardsAmt_ = lastRewardsAmt;\n\t\tuint32 rewardsCycleEnd_ = rewardsCycleEnd;\n\t\tuint32 lastSync_ = lastSync;\n\n\t\tif (block.timestamp >= rewardsCycleEnd_) {\n\t\t\t// no rewards or rewards are fully unlocked\n\t\t\t// entire reward amount is available\n\t\t\treturn totalReleasedAssets_ + lastRewardsAmt_;\n\t\t}\n\n\t\t// rewards are not fully unlocked\n\t\t// return unlocked rewards and stored total\n\t\tuint256 unlockedRewards = (lastRewardsAmt_ * (block.timestamp - lastSync_)) / (rewardsCycleEnd_ - lastSync_);\n\t\treturn totalReleasedAssets_ + unlockedRewards;\n\t}\n\n\tfunction amountAvailableForStaking() public view returns (uint256) {\n\t\tProtocolDAO protocolDAO = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tuint256 targetCollateralRate = protocolDAO.getTargetGGAVAXReserveRate();\n\n\t\tuint256 totalAssets_ = totalAssets();\n\n\t\tuint256 reservedAssets = totalAssets_.mulDivDown(targetCollateralRate, 1 ether);\n\t\treturn totalAssets_ - reservedAssets - stakingTotalAssets;\n\t}\n\n\tfunction depositFromStaking(uint256 baseAmt, uint256 rewardAmt) public payable onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tuint256 totalAmt = msg.value;\n\t\tif (totalAmt != (baseAmt + rewardAmt) || baseAmt > stakingTotalAssets) {\n\t\t\trevert InvalidStakingDeposit();\n\t\t}\n\n\t\temit DepositedFromStaking(msg.sender, baseAmt, rewardAmt);\n\t\tstakingTotalAssets -= baseAmt;\n\t\tIWAVAX(address(asset)).deposit{value: totalAmt}();\n\t}\n\n\tfunction withdrawForStaking(uint256 assets) public onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tif (assets > amountAvailableForStaking()) {\n\t\t\trevert WithdrawAmountTooLarge();\n\t\t}\n\n\t\temit WithdrawnForStaking(msg.sender, assets);\n\n\t\tstakingTotalAssets += assets;\n\t\tIWAVAX(address(asset)).withdraw(assets);\n\t\tIWithdrawer withdrawer = IWithdrawer(msg.sender);\n\t\twithdrawer.receiveWithdrawalAVAX{value: assets}();\n\t}\n\n\tfunction depositAVAX() public payable returns (uint256 shares) {\n\t\tuint256 assets = msg.value;\n\t\t// Check for rounding error since we round down in previewDeposit.\n\t\tif ((shares = previewDeposit(assets)) == 0) {\n\t\t\trevert ZeroShares();\n\t\t}\n\n\t\temit Deposit(msg.sender, msg.sender, assets, shares);\n\n\t\tIWAVAX(address(asset)).deposit{value: assets}();\n\t\t_mint(msg.sender, shares);\n\t\tafterDeposit(assets, shares);\n\t}\n\n\tfunction withdrawAVAX(uint256 assets) public returns (uint256 shares) {\n\t\tshares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\t\tbeforeWithdraw(assets, shares);\n\t\t_burn(msg.sender, shares);\n\n\t\temit Withdraw(msg.sender, msg.sender, msg.sender, assets, shares);\n\n\t\tIWAVAX(address(asset)).withdraw(assets);\n\t\tmsg.sender.safeTransferETH(assets);\n\t}\n\n\tfunction redeemAVAX(uint256 shares) public returns (uint256 assets) {\n\t\t// Check for rounding error since we round down in previewRedeem.\n\t\tif ((assets = previewRedeem(shares)) == 0) {\n\t\t\trevert ZeroAssets();\n\t\t}\n\t\tbeforeWithdraw(assets, shares);\n\t\t_burn(msg.sender, shares);\n\n\t\temit Withdraw(msg.sender, msg.sender, msg.sender, assets, shares);\n\n\t\tIWAVAX(address(asset)).withdraw(assets);\n\t\tmsg.sender.safeTransferETH(assets);\n\t}\n\n\t/// @notice Max amount of assets owner would be able to withdraw taking into account liquidity in this contract\n\tfunction maxWithdraw(address _owner) public view override returns (uint256) {\n\t\tif (getBool(keccak256(abi.encodePacked(\"contract.paused\", \"TokenggAVAX\")))) {\n\t\t\treturn 0;\n\t\t}\n\t\tuint256 assets = convertToAssets(balanceOf[_owner]);\n\t\tuint256 avail = totalAssets() - stakingTotalAssets;\n\t\treturn assets > avail ? avail : assets;\n\t}\n\n\t/// @notice Max amount of shares owner would be able to withdraw taking into account liquidity in this contract\n\tfunction maxRedeem(address _owner) public view override returns (uint256) {\n\t\tif (getBool(keccak256(abi.encodePacked(\"contract.paused\", \"TokenggAVAX\")))) {\n\t\t\treturn 0;\n\t\t}\n\t\tuint256 shares = balanceOf[_owner];\n\t\tuint256 avail = convertToShares(totalAssets() - stakingTotalAssets);\n\t\treturn shares > avail ? avail : shares;\n\t}\n\n\tfunction previewDeposit(uint256 assets) public view override whenTokenNotPaused(assets) returns (uint256) {\n\t\treturn super.previewDeposit(assets);\n\t}\n\n\tfunction previewMint(uint256 shares) public view override whenTokenNotPaused(shares) returns (uint256) {\n\t\treturn super.previewMint(shares);\n\t}\n\n\tfunction previewWithdraw(uint256 assets) public view override whenTokenNotPaused(assets) returns (uint256) {\n\t\treturn super.previewWithdraw(assets);\n\t}\n\n\tfunction previewRedeem(uint256 shares) public view override whenTokenNotPaused(shares) returns (uint256) {\n\t\treturn super.previewRedeem(shares);\n\t}\n\n\tfunction beforeWithdraw(\n\t\tuint256 amount,\n\t\tuint256 /* shares */\n\t) internal override {\n\t\ttotalReleasedAssets -= amount;\n\t}\n\n\tfunction afterDeposit(\n\t\tuint256 amount,\n\t\tuint256 /* shares */\n\t) internal override {\n\t\ttotalReleasedAssets += amount;\n\t}\n\n\tfunction _authorizeUpgrade(address newImplementation) internal override onlyGuardian {}\n}"
    },
    {
      "filename": "contracts/contract/tokens/TokenggAVAX.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n// Copied from https://github.com/fei-protocol/ERC4626/blob/main/src/xERC4626.sol\n// Rewards logic inspired by xERC20 (https://github.com/ZeframLou/playpen/blob/main/src/xERC20.sol)\npragma solidity 0.8.17;\n\nimport \"../BaseUpgradeable.sol\";\nimport {ERC20Upgradeable} from \"./upgradeable/ERC20Upgradeable.sol\";\nimport {ERC4626Upgradeable} from \"./upgradeable/ERC4626Upgradeable.sol\";\nimport {ProtocolDAO} from \"../ProtocolDAO.sol\";\nimport {Storage} from \"../Storage.sol\";\n\nimport {IWithdrawer} from \"../../interface/IWithdrawer.sol\";\nimport {IWAVAX} from \"../../interface/IWAVAX.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\nimport {ERC20} from \"@rari-capital/solmate/src/mixins/ERC4626.sol\";\nimport {FixedPointMathLib} from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\nimport {SafeCastLib} from \"@rari-capital/solmate/src/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\n\n/// @dev Local variables and parent contracts must remain in order between contract upgrades\ncontract TokenggAVAX is Initializable, ERC4626Upgradeable, UUPSUpgradeable, BaseUpgradeable {\n\tusing SafeTransferLib for ERC20;\n\tusing SafeTransferLib for address;\n\tusing SafeCastLib for *;\n\tusing FixedPointMathLib for uint256;\n\n\terror SyncError();\n\terror ZeroShares();\n\terror ZeroAssets();\n\terror InvalidStakingDeposit();\n\terror WithdrawAmountTooLarge();\n\n\tevent NewRewardsCycle(uint256 indexed cycleEnd, uint256 rewardsAmt);\n\tevent WithdrawnForStaking(address indexed caller, uint256 assets);\n\tevent DepositedFromStaking(address indexed caller, uint256 baseAmt, uint256 rewardsAmt);\n\n\t/// @notice the effective start of the current cycle\n\tuint32 public lastSync;\n\n\t/// @notice the maximum length of a rewards cycle\n\tuint32 public rewardsCycleLength;\n\n\t/// @notice the end of the current cycle. Will always be evenly divisible by `rewardsCycleLength`.\n\tuint32 public rewardsCycleEnd;\n\n\t/// @notice the amount of rewards distributed in a the most recent cycle.\n\tuint192 public lastRewardsAmt;\n\n\t/// @notice the total amount of avax (including avax sent out for staking and all incoming rewards)\n\tuint256 public totalReleasedAssets;\n\n\t/// @notice total amount of avax currently out for staking (not including any rewards)\n\tuint256 public stakingTotalAssets;\n\n\tmodifier whenTokenNotPaused(uint256 amt) {\n\t\tif (amt > 0 && getBool(keccak256(abi.encodePacked(\"contract.paused\", \"TokenggAVAX\")))) {\n\t\t\trevert ContractPaused();\n\t\t}\n\t\t_;\n\t}\n\n\t/// @custom:oz-upgrades-unsafe-allow constructor\n\tconstructor() {\n\t\t// The constructor is exectued only when creating implementation contract\n\t\t// so prevent it's reinitialization\n\t\t_disableInitializers();\n\t}\n\n\tfunction initialize(Storage storageAddress, ERC20 asset) public initializer {\n\t\t__ERC4626Upgradeable_init(asset, \"GoGoPool Liquid Staking Token\", \"ggAVAX\");\n\t\t__BaseUpgradeable_init(storageAddress);\n\n\t\trewardsCycleLength = 14 days;\n\t\t// Ensure it will be evenly divisible by `rewardsCycleLength`.\n\t\trewardsCycleEnd = (block.timestamp.safeCastTo32() / rewardsCycleLength) * rewardsCycleLength;\n\t}\n\n\t/// @notice only accept AVAX via fallback from the WAVAX contract\n\treceive() external payable {\n\t\tassert(msg.sender == address(asset));\n\t}\n\n\t/// @notice Distributes rewards to TokenggAVAX holders. Public, anyone can call.\n\t/// \t\t\t\tAll surplus `asset` balance of the contract over the internal balance becomes queued for the next cycle.\n\tfunction syncRewards() public {\n\t\tuint32 timestamp = block.timestamp.safeCastTo32();\n\n\t\tif (timestamp < rewardsCycleEnd) {\n\t\t\trevert SyncError();\n\t\t}\n\n\t\tuint192 lastRewardsAmt_ = lastRewardsAmt;\n\t\tuint256 totalReleasedAssets_ = totalReleasedAssets;\n\t\tuint256 stakingTotalAssets_ = stakingTotalAssets;\n\n\t\tuint256 nextRewardsAmt = (asset.balanceOf(address(this)) + stakingTotalAssets_) - totalReleasedAssets_ - lastRewardsAmt_;\n\n\t\t// Ensure nextRewardsCycleEnd will be evenly divisible by `rewardsCycleLength`.\n\t\tuint32 nextRewardsCycleEnd = ((timestamp + rewardsCycleLength) / rewardsCycleLength) * rewardsCycleLength;\n\n\t\tlastRewardsAmt = nextRewardsAmt.safeCastTo192();\n\t\tlastSync = timestamp;\n\t\trewardsCycleEnd = nextRewardsCycleEnd;\n\t\ttotalReleasedAssets = totalReleasedAssets_ + lastRewardsAmt_;\n\t\temit NewRewardsCycle(nextRewardsCycleEnd, nextRewardsAmt);\n\t}\n\n\t/// @notice Compute the amount of tokens available to share holders.\n\t///         Increases linearly during a reward distribution period from the sync call, not the cycle start.\n\tfunction totalAssets() public view override returns (uint256) {\n\t\t// cache global vars\n\t\tuint256 totalReleasedAssets_ = totalReleasedAssets;\n\t\tuint192 lastRewardsAmt_ = lastRewardsAmt;\n\t\tuint32 rewardsCycleEnd_ = rewardsCycleEnd;\n\t\tuint32 lastSync_ = lastSync;\n\n\t\tif (block.timestamp >= rewardsCycleEnd_) {\n\t\t\t// no rewards or rewards are fully unlocked\n\t\t\t// entire reward amount is available\n\t\t\treturn totalReleasedAssets_ + lastRewardsAmt_;\n\t\t}\n\n\t\t// rewards are not fully unlocked\n\t\t// return unlocked rewards and stored total\n\t\tuint256 unlockedRewards = (lastRewardsAmt_ * (block.timestamp - lastSync_)) / (rewardsCycleEnd_ - lastSync_);\n\t\treturn totalReleasedAssets_ + unlockedRewards;\n\t}\n\n\tfunction amountAvailableForStaking() public view returns (uint256) {\n\t\tProtocolDAO protocolDAO = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tuint256 targetCollateralRate = protocolDAO.getTargetGGAVAXReserveRate();\n\n\t\tuint256 totalAssets_ = totalAssets();\n\n\t\tuint256 reservedAssets = totalAssets_.mulDivDown(targetCollateralRate, 1 ether);\n\t\treturn totalAssets_ - reservedAssets - stakingTotalAssets;\n\t}\n\n\tfunction depositFromStaking(uint256 baseAmt, uint256 rewardAmt) public payable onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tuint256 totalAmt = msg.value;\n\t\tif (totalAmt != (baseAmt + rewardAmt) || baseAmt > stakingTotalAssets) {\n\t\t\trevert InvalidStakingDeposit();\n\t\t}\n\n\t\temit DepositedFromStaking(msg.sender, baseAmt, rewardAmt);\n\t\tstakingTotalAssets -= baseAmt;\n\t\tIWAVAX(address(asset)).deposit{value: totalAmt}();\n\t}\n\n\tfunction withdrawForStaking(uint256 assets) public onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tif (assets > amountAvailableForStaking()) {\n\t\t\trevert WithdrawAmountTooLarge();\n\t\t}\n\n\t\temit WithdrawnForStaking(msg.sender, assets);\n\n\t\tstakingTotalAssets += assets;\n\t\tIWAVAX(address(asset)).withdraw(assets);\n\t\tIWithdrawer withdrawer = IWithdrawer(msg.sender);\n\t\twithdrawer.receiveWithdrawalAVAX{value: assets}();\n\t}\n\n\tfunction depositAVAX() public payable returns (uint256 shares) {\n\t\tuint256 assets = msg.value;\n\t\t// Check for rounding error since we round down in previewDeposit.\n\t\tif ((shares = previewDeposit(assets)) == 0) {\n\t\t\trevert ZeroShares();\n\t\t}\n\n\t\temit Deposit(msg.sender, msg.sender, assets, shares);\n\n\t\tIWAVAX(address(asset)).deposit{value: assets}();\n\t\t_mint(msg.sender, shares);\n\t\tafterDeposit(assets, shares);\n\t}\n\n\tfunction withdrawAVAX(uint256 assets) public returns (uint256 shares) {\n\t\tshares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\t\tbeforeWithdraw(assets, shares);\n\t\t_burn(msg.sender, shares);\n\n\t\temit Withdraw(msg.sender, msg.sender, msg.sender, assets, shares);\n\n\t\tIWAVAX(address(asset)).withdraw(assets);\n\t\tmsg.sender.safeTransferETH(assets);\n\t}\n\n\tfunction redeemAVAX(uint256 shares) public returns (uint256 assets) {\n\t\t// Check for rounding error since we round down in previewRedeem.\n\t\tif ((assets = previewRedeem(shares)) == 0) {\n\t\t\trevert ZeroAssets();\n\t\t}\n\t\tbeforeWithdraw(assets, shares);\n\t\t_burn(msg.sender, shares);\n\n\t\temit Withdraw(msg.sender, msg.sender, msg.sender, assets, shares);\n\n\t\tIWAVAX(address(asset)).withdraw(assets);\n\t\tmsg.sender.safeTransferETH(assets);\n\t}\n\n\t/// @notice Max amount of assets owner would be able to withdraw taking into account liquidity in this contract\n\tfunction maxWithdraw(address _owner) public view override returns (uint256) {\n\t\tif (getBool(keccak256(abi.encodePacked(\"contract.paused\", \"TokenggAVAX\")))) {\n\t\t\treturn 0;\n\t\t}\n\t\tuint256 assets = convertToAssets(balanceOf[_owner]);\n\t\tuint256 avail = totalAssets() - stakingTotalAssets;\n\t\treturn assets > avail ? avail : assets;\n\t}\n\n\t/// @notice Max amount of shares owner would be able to withdraw taking into account liquidity in this contract\n\tfunction maxRedeem(address _owner) public view override returns (uint256) {\n\t\tif (getBool(keccak256(abi.encodePacked(\"contract.paused\", \"TokenggAVAX\")))) {\n\t\t\treturn 0;\n\t\t}\n\t\tuint256 shares = balanceOf[_owner];\n\t\tuint256 avail = convertToShares(totalAssets() - stakingTotalAssets);\n\t\treturn shares > avail ? avail : shares;\n\t}\n\n\tfunction previewDeposit(uint256 assets) public view override whenTokenNotPaused(assets) returns (uint256) {\n\t\treturn super.previewDeposit(assets);\n\t}\n\n\tfunction previewMint(uint256 shares) public view override whenTokenNotPaused(shares) returns (uint256) {\n\t\treturn super.previewMint(shares);\n\t}\n\n\tfunction previewWithdraw(uint256 assets) public view override whenTokenNotPaused(assets) returns (uint256) {\n\t\treturn super.previewWithdraw(assets);\n\t}\n\n\tfunction previewRedeem(uint256 shares) public view override whenTokenNotPaused(shares) returns (uint256) {\n\t\treturn super.previewRedeem(shares);\n\t}\n\n\tfunction beforeWithdraw(\n\t\tuint256 amount,\n\t\tuint256 /* shares */\n\t) internal override {\n\t\ttotalReleasedAssets -= amount;\n\t}\n\n\tfunction afterDeposit(\n\t\tuint256 amount,\n\t\tuint256 /* shares */\n\t) internal override {\n\t\ttotalReleasedAssets += amount;\n\t}\n\n\tfunction _authorizeUpgrade(address newImplementation) internal override onlyGuardian {}\n}"
    }
  ]
}