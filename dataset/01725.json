{
  "Title": "M-2: Missing Sequencer Uptime Feed check can cause unfair liquidations on Arbitrum",
  "Content": "# Issue M-2: Missing Sequencer Uptime Feed check can cause unfair liquidations on Arbitrum \n\nSource: https://github.com/sherlock-audit/2023-05-perennial-judging/issues/37 \n\n## Found by \nroguereddwarf\n## Summary\nWhen the Arbitrum sequencer is down and then comes back up, all Chainlink price updates will become available on Arbitrum within a very short time.\n\nThis leaves users no time to react to the price changes which can lead to unfair liquidations.\n\n## Vulnerability Detail\nChainlink explains their Sequencer Uptime Feeds [here](https://docs.chain.link/data-feeds/l2-sequencer-feeds).\n\nQuoting from the documentation:\n> To help your applications identify when the sequencer is unavailable, you can use a data feed that tracks the last known status of the sequencer at a given point in time. This helps you prevent mass liquidations by providing a grace period to allow customers to react to such an event.\n\nUsers are still able in principle to avoid liquidations by interacting with the Arbitrum delayed inbox via L1, but this is out of reach for most users.\n\n## Impact\nUsers can get unfairly liquidated because they cannot react to price movements when the sequencer is down and when the sequencer comes back up, all price updates will immediately become available.\n\n## Code Snippet\nThis issue can be observed in both the `ChainlinkOracle` and `ChainlinkFeedOracle`, which do not make use of the sequencer uptime feed to check the status of the sequencer:\n\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial-oracle/contracts/ChainlinkOracle.sol#L59-L64\n\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial-oracle/contracts/ChainlinkFeedOracle.sol#L94-L97\n\n## Tool used\nManual Review\n\n## Recommendation\nThe Chainlink documentation contains an example for how to check the sequencer status: https://docs.chain.link/data-feeds/l2-sequencer-feeds\n\nThere can be a grace period when the sequencer comes back up for users to act on their collateral (increase collateral to avoid liquidation). \n\n\n\n## Discussion\n\n**roguereddwarf**\n\nEscalate for 10 USDC\n\nThis issue is marked as a duplicate of #13.\n\nThis is wrong and I argue that my report is a legitimate Medium (speaking only of my report here, other dupes must be checked as well).\n\n#13 argues that outdated prices would be used when the sequencer is down.\nThe sponsor correctly explained that:\n> From our understanding, when the sequencer is down the prices can't be updated by the data feed so therefore settlement can't occur. This means that effectively each product is paused as no state changes can occur\n\nMy point on the other hand is that when the sequencer comes back up, all the old prices will be processed at once and users have no time to react to price changes, which can lead to unfair liquidations.\n\nTherefore I had the suggestion for a grace period.\n\nYou can see a detailed explanation for my argument in the Aave V3 technical paper: https://github.com/aave/aave-v3-core/blob/master/techpaper/Aave_V3_Technical_Paper.pdf (section 4.6)\n![2023-06-30_09-38](https://github.com/sherlock-audit/2023-05-perennial-judging/assets/118631472/9e94b0cd-1be0-4449-8d8f-4588b6939813)\n\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> This issue is marked as a duplicate of #13.\n> \n> This is wrong and I argue that my report is a legitimate Medium (speaking only of my report here, other dupes must be checked as well).\n> \n> #13 argues that outdated prices would be used when the sequencer is down.\n> The sponsor correctly explained that:\n> > From our understanding, when the sequencer is down the prices can't be updated by the data feed so therefore settlement can't occur. This means that effectively each product is paused as no state changes can occur\n> \n> My point on the other hand is that when the sequencer comes back up, all the old prices will be processed at once and users have no time to react to price changes, which can lead to unfair liquidations.\n> \n> Therefore I had the suggestion for a grace period.\n> \n> You can see a detailed explanation for my argument in the Aave V3 technical paper: https://github.com/aave/aave-v3-core/blob/master/techpaper/Aave_V3_Technical_Paper.pdf (section 4.6)\n> ![2023-06-30_09-38](https://github.com/sherlock-audit/2023-05-perennial-judging/assets/118631472/9e94b0cd-1be0-4449-8d8f-4588b6939813)\n> \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**KenzoAgada**\n\n- Watson is correct in saying that his issue is different than the rest of the \"Arbitrum sequencer downtime\" issues with regards to the impact described.\n- While all other issues speak about stale prices, this issue says that the problem is unfair liquidations as users will not have time to react when oracle data feeds are updated again.\n- Therefore watson suggests a grace period.\n- So this is similar issue to #190, which mentions the lack of grace period when unpausing.\n- There is an ongoing escalation there. The protocol team disputed the issue, but the escalator wrote that the _validity_ of the issue should be accepted. Please see that issue for all the context and comments.\n\nI think that this issue should have a similar fate to #190. If that escalation is accepted, this one should be accepted as well.\n\n**jacksanford1**\n\nBelieve #190 is trending towards being accepted. This issue has a different root case (Arbitrum sequencer down vs. protocol team pausing contracts) but the effect is the same (depositors can't salvage their position before they get liquidated). \n\nI think it should be a valid Medium, even though the root case is a temporary freezing. \n\n**jacksanford1**\n\nResult:\nMedium\nUnique\nReasoning can be found in previous message. \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [roguereddwarf](https://github.com/sherlock-audit/2023-05-perennial-judging/issues/37/#issuecomment-1614260151): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/79",
  "Code": [
    {
      "filename": "perennial-mono/packages/perennial-oracle/contracts/ChainlinkOracle.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.15;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/FeedRegistryInterface.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"./interfaces/IOracleProvider.sol\";\nimport \"./types/ChainlinkRegistry.sol\";\n\n/**\n * @title ChainlinkOracle\n * @notice Chainlink registry implementation of the IOracle interface.\n * @dev One instance per Chainlink price feed should be deployed. Multiple products may use the same\n *      ChainlinkOracle instance if their payoff functions are based on the same underlying oracle.\n */\ncontract ChainlinkOracle is IOracleProvider {\n    /// @dev Chainlink registry feed address\n    ChainlinkRegistry public immutable registry;\n\n    /// @dev Base token address for the Chainlink oracle\n    address public immutable base;\n\n    /// @dev Quote token address for the Chainlink oracle\n    address public immutable quote;\n\n    /// @dev Decimal offset used to normalize chainlink price to 18 decimals\n    int256 private immutable _decimalOffset;\n\n    /// @dev Mapping of the starting data for each underlying phase\n    Phase[] private _phases;\n\n    struct Phase {\n        uint128 startingVersion;\n        uint128 startingRoundId;\n    }\n\n    /**\n     * @notice Initializes the contract state\n     * @param registry_ Chainlink price feed registry\n     * @param base_ base currency for feed\n     * @param quote_ quote currency for feed\n     */\n    constructor(ChainlinkRegistry registry_, address base_, address quote_) {\n        registry = registry_;\n        base = base_;\n        quote = quote_;\n\n        // phaseId is 1-indexed, skip index 0\n        _phases.push(Phase(uint128(0), uint128(0)));\n        // phaseId is 1-indexed, first phase starts as version 0\n        _phases.push(Phase(uint128(0), uint128(registry_.getStartingRoundId(base_, quote_, 1))));\n\n        _decimalOffset = SafeCast.toInt256(10 ** registry_.decimals(base, quote));\n    }\n\n    /**\n     * @notice Checks for a new price and updates the internal phase annotation state accordingly\n     * @return The current oracle version after sync\n     */\n    function sync() external returns (OracleVersion memory) {\n        // Fetch latest round\n        ChainlinkRound memory round = registry.getLatestRound(base, quote);\n\n        // Revert if the round id or timestamp is 0\n        if (uint64(round.roundId) == 0 || round.timestamp == 0) revert InvalidOracleRound();\n\n        // Update phase annotation when new phase detected\n        while (round.phaseId() > _latestPhaseId()) {\n            _phases.push(\n                Phase(\n                    uint128(registry.getRoundCount(base, quote, _latestPhaseId())) +\n                        _phases[_phases.length - 1].startingVersion,\n                    uint128(registry.getStartingRoundId(base, quote, _latestPhaseId() +  1))\n                )\n            );\n        }\n\n        // Return packaged oracle version\n        return _buildOracleVersion(round);\n    }\n\n    /**\n     * @notice Returns the current oracle version\n     * @return oracleVersion Current oracle version\n     */\n    function currentVersion() public view returns (OracleVersion memory oracleVersion) {\n        return _buildOracleVersion(registry.getLatestRound(base, quote));\n    }\n\n    /**\n     * @notice Returns the current oracle version\n     * @param version The version of which to lookup\n     * @return oracleVersion Oracle version at version `version`\n     */\n    function atVersion(uint256 version) public view returns (OracleVersion memory oracleVersion) {\n        return _buildOracleVersion(registry.getRound(base, quote, _versionToRoundId(version)), version);\n    }\n\n    /**\n     * @notice Builds an oracle version object from a Chainlink round object\n     * @dev Computes the version for the round\n     * @param round Chainlink round to build from\n     * @return Built oracle version\n     */\n    function _buildOracleVersion(ChainlinkRound memory round) private view returns (OracleVersion memory) {\n        Phase memory phase = _phases[round.phaseId()];\n        uint256 version = uint256(phase.startingVersion) + round.roundId - uint256(phase.startingRoundId);\n        return _buildOracleVersion(round, version);\n    }\n\n    /**\n     * @notice Builds an oracle version object from a Chainlink round object\n     * @param round Chainlink round to build from\n     * @param version Determined version for the round\n     * @return Built oracle version\n     */\n    function _buildOracleVersion(ChainlinkRound memory round, uint256 version)\n    private view returns (OracleVersion memory) {\n        Fixed18 price = Fixed18Lib.ratio(round.answer, _decimalOffset);\n        return OracleVersion({ version: version, timestamp: round.timestamp, price: price });\n    }\n\n    /**\n     * @notice Computes the chainlink round ID from a version\n     * @param version Version to compute from\n     * @return Chainlink round ID\n     */\n    function _versionToRoundId(uint256 version) private view returns (uint256) {\n        Phase memory phase = _versionToPhase(version);\n        return uint256(phase.startingRoundId) + version - uint256(phase.startingVersion);\n    }\n\n    /**\n     * @notice Computes the chainlink phase ID from a version\n     * @param version Version to compute from\n     * @return phase Chainlink phase\n     */\n    function _versionToPhase(uint256 version) private view returns (Phase memory phase) {\n        uint256 phaseId = _latestPhaseId();\n        phase = _phases[phaseId];\n        while (uint256(phase.startingVersion) > version) {\n            phaseId--;\n            phase = _phases[phaseId];\n        }\n    }\n\n    /**\n     * @notice Returns the latest phase ID that this contract has seen via `sync()`\n     * @return Latest seen phase ID\n     */\n    function _latestPhaseId() private view returns (uint16) {\n        return uint16(_phases.length - 1);\n    }\n}"
    },
    {
      "filename": "perennial-mono/packages/perennial-oracle/contracts/ChainlinkFeedOracle.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.15;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"./interfaces/IOracleProvider.sol\";\nimport \"./types/ChainlinkAggregator.sol\";\n\n/**\n * @title ChainlinkFeedOracle\n * @notice Chainlink feed implementation of the IOracle interface.\n * @dev One instance per Chainlink price feed should be deployed. Multiple products may use the same\n *      ChainlinkOracle instance if their payoff functions are based on the same underlying oracle.\n */\ncontract ChainlinkFeedOracle is IOracleProvider {\n    error InvalidPhaseInitialization();\n\n    struct Phase {\n        uint128 startingVersion;\n        uint128 startingRoundId;\n    }\n\n    /// @dev Chainlink feed aggregator address\n    ChainlinkAggregator public immutable aggregator;\n\n    /// @dev Decimal offset used to normalize chainlink price to 18 decimals\n    int256 private immutable _decimalOffset;\n\n    /// @dev Last roundID seen when `sync` was called\n    uint256 private _lastSyncedRoundId;\n\n    /// @dev Mapping of the starting data for each underlying phase\n    Phase[] private _phases;\n\n    /**\n     * @notice Initializes the contract state\n     * @param aggregator_ Chainlink price feed aggregator\n     * @param phases_ Array of phases to initialize the oracle with\n     * @dev If `phases_` is empty, the oracle will be initialized with the latest round from the aggregator as the\n     *      starting round\n     */\n    constructor(ChainlinkAggregator aggregator_, Phase[] memory phases_) {\n        aggregator = aggregator_;\n\n        _decimalOffset = SafeCast.toInt256(10 ** aggregator.decimals());\n\n        if (phases_.length > 0) {\n            // Phases should be initialized with at least 2 values\n            if (phases_.length < 2) revert InvalidPhaseInitialization();\n\n            // Phases[0] should always be empty, since phases are 1-indexed\n            if (phases_[0].startingVersion != 0 || phases_[0].startingRoundId != 0) revert InvalidPhaseInitialization();\n\n            // Phases[1] should start at version 0\n            if (phases_[1].startingVersion != 0) revert InvalidPhaseInitialization();\n\n            // Set the lastSyncedRoundId to the starting round of the latest phase\n            ChainlinkRound memory latestRound = aggregator.getLatestRound();\n\n            // The phases array should be initialized up to the latest phase\n            if (phases_.length - 1 != latestRound.phaseId()) revert InvalidPhaseInitialization();\n\n            // Load phases array with the provided phases\n            for (uint i = 0; i < phases_.length; i++) {\n                _phases.push(phases_[i]);\n            }\n\n            _lastSyncedRoundId = latestRound.roundId;\n        } else {\n            ChainlinkRound memory firstSeenRound = aggregator.getLatestRound();\n\n            // Load the phases array with empty phase values. these phases will be invalid if requested\n            while (firstSeenRound.phaseId() > _phases.length) {\n                _phases.push(Phase(0, 0));\n            }\n\n            // first seen round starts as version 0 at current phase\n            _phases.push(Phase(0, uint128(firstSeenRound.roundId)));\n            _lastSyncedRoundId = firstSeenRound.roundId;\n        }\n    }\n\n    /**\n     * @notice Checks for a new price and updates the internal phase annotation state accordingly\n     * @dev `sync` is expected to be called soon after a phase update occurs in the underlying proxy.\n     *      Phase updates should be detected using off-chain mechanism and should trigger a `sync` call\n     *      This is feasible in the short term due to how infrequent phase updates are, but phase update\n     *      and roundCount detection should eventually be implemented at the contract level.\n     *      Reverts if there is more than 1 phase to update in a single sync because we currently cannot\n     *      determine the startingRoundId for the intermediary phase.\n     * @return The current oracle version after sync\n     */\n    function sync() external returns (OracleVersion memory) {\n        // Fetch latest round\n        ChainlinkRound memory round = aggregator.getLatestRound();\n\n        // Revert if the aggregator round id or timestamp is 0 which is an invalid round.\n        if (round.aggregatorRoundId() == 0 || round.timestamp == 0) revert InvalidOracleRound();\n\n        // Update phase annotation when new phase detected\n        // `_lastSyncedRoundId` is the last round we have seen\n        // `round.roundId` is the current round\n        //\n        // When encountering a new phase, we need to find _lastSyncedRoundId + 1 (N + 1)\n        // `getPhaseSwitchoverData` will find the roundCount for the current phase, as well as the phaseId and roundId\n        // for the next non-empty phase.\n        // There are three cases:\n        //  1. N + 1 is in the same phase as `_lastSyncedRoundId`\n        //    - `nextPhase` == round.phaseId(), and `nextStartingRoundId` == round.roundId\n        //  2. N + 1 is in some phase between _lastSyncedRoundId and the current phase\n        //    - `nextPhase` < round.phaseId(), and starts at `nextStartingRoundId`\n        //  3. N + 1 is in the current phase\n        //   - the `nextPhase` == round.phaseId(), and `nextStartingRoundId` < round.roundId\n        //\n        // Depending on the returned phase, we need to push empty phases into the phase array\n        // Empty phases are pushed between _lastSyncedRoundId.phase and (N + 1).phase\n        // and between (N + 1).phase and round.phase\n        if (round.phaseId() > _latestPhaseId()) {\n            // Get the round count for the lastSyncedRound phase, and the next phase information\n            (uint256 phaseRoundCount, uint16 nextPhase, uint256 nextStartingRoundId) =\n                aggregator.getPhaseSwitchoverData(_phases[_latestPhaseId()].startingRoundId, _lastSyncedRoundId, round);\n\n            // If the next phase is not immediately after the latestPhase, push empty phases\n            // These phases will be invalid if queried\n            while (nextPhase > _latestPhaseId() + 1) {\n                _phases.push(Phase(_phases[_latestPhaseId()].startingVersion, 0));\n            }\n\n            // The starting version for the next phase is the phaseRoundCount plus startingVersion\n            _phases.push(\n                Phase(\n                    uint128(phaseRoundCount) + _phases[_latestPhaseId()].startingVersion,\n                    uint128(nextStartingRoundId)\n                )\n            );\n\n            // If the intermediary phase is not `round`'s phase, fill in the intermediary phases\n            if (nextPhase < round.phaseId()) {\n                // After the intermediary phase is found, the phases up until round.phaseId can be skipped\n                while (round.phaseId() > _latestPhaseId() + 1) {\n                    _phases.push(Phase(_phases[_latestPhaseId()].startingVersion, 0));\n                }\n\n                // And finally push the current phase\n                // We add 1 to the startingVersion for the previous phase because the intermediary phase is only\n                // 1 round long\n                _phases.push(\n                    Phase(\n                        1 + _phases[_latestPhaseId()].startingVersion,\n                        uint128(round.roundId)\n                    )\n                );\n            }\n        }\n\n        _lastSyncedRoundId = round.roundId;\n\n        // Return packaged oracle version\n        return _buildOracleVersion(round);\n    }\n\n    /**\n     * @notice Returns the current oracle version\n     * @return oracleVersion Current oracle version\n     */\n    function currentVersion() public view returns (OracleVersion memory oracleVersion) {\n        return _buildOracleVersion(aggregator.getLatestRound());\n    }\n\n    /**\n     * @notice Returns the current oracle version\n     * @param version The version of which to lookup\n     * @return oracleVersion Oracle version at version `version`\n     */\n    function atVersion(uint256 version) public view returns (OracleVersion memory oracleVersion) {\n        return _buildOracleVersion(aggregator.getRound(_versionToRoundId(version)), version);\n    }\n\n    /**\n     * @notice Builds an oracle version object from a Chainlink round object\n     * @dev Computes the version for the round\n     * @param round Chainlink round to build from\n     * @return Built oracle version\n     */\n    function _buildOracleVersion(ChainlinkRound memory round) private view returns (OracleVersion memory) {\n        Phase memory phase = _phases[round.phaseId()];\n        uint256 version = uint256(phase.startingVersion) + round.roundId - uint256(phase.startingRoundId);\n        return _buildOracleVersion(round, version);\n    }\n\n    /**\n     * @notice Builds an oracle version object from a Chainlink round object\n     * @param round Chainlink round to build from\n     * @param version Determined version for the round\n     * @return Built oracle version\n     */\n    function _buildOracleVersion(ChainlinkRound memory round, uint256 version)\n    private view returns (OracleVersion memory) {\n        Fixed18 price = Fixed18Lib.ratio(round.answer, _decimalOffset);\n        return OracleVersion({ version: version, timestamp: round.timestamp, price: price });\n    }\n\n    /**\n     * @notice Computes the chainlink round ID from a version\n     * @param version Version to compute from\n     * @return Chainlink round ID\n     */\n    function _versionToRoundId(uint256 version) private view returns (uint256) {\n        Phase memory phase = _versionToPhase(version);\n        return uint256(phase.startingRoundId) + version - uint256(phase.startingVersion);\n    }\n\n    /**\n     * @notice Computes the chainlink phase ID from a version\n     * @param version Version to compute from\n     * @return phase Chainlink phase\n     */\n    function _versionToPhase(uint256 version) private view returns (Phase memory phase) {\n        uint256 phaseId = _latestPhaseId();\n        phase = _phases[phaseId];\n\n        // Exit if the phase is non-empty (startingRoundId != 0) and starts at a version less than or equal to `version`\n        while (phase.startingRoundId == 0 || uint256(phase.startingVersion) > version) {\n            phaseId--;\n            phase = _phases[phaseId];\n        }\n    }\n\n    /**\n     * @notice Returns the latest phase ID that this contract has seen via `sync()`\n     * @return Latest seen phase ID\n     */\n    function _latestPhaseId() private view returns (uint16) {\n        return uint16(_phases.length - 1);\n    }\n}"
    }
  ]
}