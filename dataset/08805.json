{
  "Title": "[M-11] Tokens with `decimals` larger than `18` are not supported",
  "Content": "_Submitted by WatchPug, also found by 0x1f8b_\n\nFor tokens with decimals larger than 18, many functions across the codebase will revert due to underflow.\n\n[ConnextPriceOracle.sol#L99-L115](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/helpers/ConnextPriceOracle.sol#L99-L115)<br>\n\n```solidity\nfunction getPriceFromDex(address _tokenAddress) public view returns (uint256) {\n    PriceInfo storage priceInfo = priceRecords[_tokenAddress];\n    if (priceInfo.active) {\n      uint256 rawTokenAmount = IERC20Extended(priceInfo.token).balanceOf(priceInfo.lpToken);\n      uint256 tokenDecimalDelta = 18 - uint256(IERC20Extended(priceInfo.token).decimals());\n      uint256 tokenAmount = rawTokenAmount.mul(10**tokenDecimalDelta);\n      uint256 rawBaseTokenAmount = IERC20Extended(priceInfo.baseToken).balanceOf(priceInfo.lpToken);\n      uint256 baseTokenDecimalDelta = 18 - uint256(IERC20Extended(priceInfo.baseToken).decimals());\n      uint256 baseTokenAmount = rawBaseTokenAmount.mul(10**baseTokenDecimalDelta);\n      uint256 baseTokenPrice = getTokenPrice(priceInfo.baseToken);\n      uint256 tokenPrice = baseTokenPrice.mul(baseTokenAmount).div(tokenAmount);\n\n      return tokenPrice;\n    } else {\n      return 0;\n    }\n  }\n```\n\n[StableSwapFacet.sol#L426](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/StableSwapFacet.sol#L426)<br>\n\n```solidity\nprecisionMultipliers[i] = 10**uint256(SwapUtils.POOL_PRECISION_DECIMALS - decimals[i]);\n```\n\nChainlink feeds' with decimals > 18 are not supported neither:\n\n[ConnextPriceOracle.sol#L122-L140](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/helpers/ConnextPriceOracle.sol#L122-L140)<br>\n\n```solidity\nfunction getPriceFromChainlink(address _tokenAddress) public view returns (uint256) {\n    AggregatorV3Interface aggregator = aggregators[_tokenAddress];\n    if (address(aggregator) != address(0)) {\n      (, int256 answer, , , ) = aggregator.latestRoundData();\n\n      // It's fine for price to be 0. We have two price feeds.\n      if (answer == 0) {\n        return 0;\n      }\n\n      // Extend the decimals to 1e18.\n      uint256 retVal = uint256(answer);\n      uint256 price = retVal.mul(10**(18 - uint256(aggregator.decimals())));\n\n      return price;\n    }\n\n    return 0;\n  }\n```\n\n### Recommended Mitigation Steps\n\nConsider checking if decimals > 18 and normalize the value by div the decimals difference.\n\n**[ecmendenhall (Connext) commented](https://github.com/code-423n4/2022-06-connext-findings/issues/204#issuecomment-1160572904):**\n > I gave this a :heart: along with issue #[61](https://github.com/code-423n4/2022-06-connext-findings/issues/61) because these findings both identified an additional location in the `StableSwap` contract where the 18 decimal assumption is hardcoded.\n\n**[jakekidd (Connext) confirmed and commented](https://github.com/code-423n4/2022-06-connext-findings/issues/204#issuecomment-1165955099):**\n > > I gave this a ❤️ along with #61 because these findings both identified an additional location in the `StableSwap` contract where the 18 decimal assumption is hardcoded.\n> \n> Marking as confirmed (and leaving issue open) for this reason. Would be great to merge both findings into 1 issue in the finalized audit.\n\n**[jakekidd (Connext) commented](https://github.com/code-423n4/2022-06-connext-findings/issues/204#issuecomment-1166801705):**\n > Assortment of findings across these three issues:<br>\n> https://github.com/code-423n4/2022-06-connext-findings/issues/39<br>\n> https://github.com/code-423n4/2022-06-connext-findings/issues/61<br>\n> https://github.com/code-423n4/2022-06-connext-findings/issues/204<br>\n\n**[jakekidd (Connext) resolved](https://github.com/code-423n4/2022-06-connext-findings/issues/204#issuecomment-1170453579):**\n > Fixed by [connext/nxtp@f2e5b66](https://github.com/connext/nxtp/commit/f2e5b66da49877f6b63ac0ec5a5db93c9088526a)\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-06-connext-findings/issues/204#issuecomment-1214246438):**\n > Marking this as the primary issue because it highlights an active part of the codebase while other issues do not. `initializeSwap` will not be compatible with any token with `decimals` greater than `18`.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-06-connext",
  "Code": [
    {
      "filename": "contracts/contracts/core/connext/helpers/ConnextPriceOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20Extended} from \"../interfaces/IERC20Extended.sol\";\n\nimport {PriceOracle} from \"./PriceOracle.sol\";\nimport {IPriceOracle} from \"../interfaces/IPriceOracle.sol\";\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n\ncontract ConnextPriceOracle is PriceOracle {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20Extended;\n\n  address public admin;\n  address public wrapped;\n  address public v1PriceOracle;\n\n  /// @notice Chainlink Aggregators\n  mapping(address => AggregatorV3Interface) public aggregators;\n\n  struct PriceInfo {\n    address token; // Address of token contract, TOKEN\n    address baseToken; // Address of base token contract, BASETOKEN\n    address lpToken; // Address of TOKEN-BASETOKEN pair contract\n    bool active; // Active status of price record 0\n  }\n\n  mapping(address => PriceInfo) public priceRecords;\n  mapping(address => uint256) public assetPrices;\n\n  event NewAdmin(address oldAdmin, address newAdmin);\n  event PriceRecordUpdated(address token, address baseToken, address lpToken, bool _active);\n  event DirectPriceUpdated(address token, uint256 oldPrice, uint256 newPrice);\n  event AggregatorUpdated(address tokenAddress, address source);\n  event V1PriceOracleUpdated(address oldAddress, address newAddress);\n\n  modifier onlyAdmin() {\n    require(msg.sender == admin, \"caller is not the admin\");\n    _;\n  }\n\n  constructor(address _wrapped) {\n    wrapped = _wrapped;\n    admin = msg.sender;\n  }\n\n  function getTokenPrice(address _tokenAddress) public view override returns (uint256) {\n    address tokenAddress = _tokenAddress;\n    if (_tokenAddress == address(0)) {\n      tokenAddress = wrapped;\n    }\n    uint256 tokenPrice = assetPrices[tokenAddress];\n    if (tokenPrice == 0) {\n      tokenPrice = getPriceFromOracle(tokenAddress);\n    }\n    if (tokenPrice == 0) {\n      tokenPrice = getPriceFromDex(tokenAddress);\n    }\n    if (tokenPrice == 0 && v1PriceOracle != address(0)) {\n      tokenPrice = IPriceOracle(v1PriceOracle).getTokenPrice(tokenAddress);\n    }\n    return tokenPrice;\n  }\n\n  function getPriceFromDex(address _tokenAddress) public view returns (uint256) {\n    PriceInfo storage priceInfo = priceRecords[_tokenAddress];\n    if (priceInfo.active) {\n      uint256 rawTokenAmount = IERC20Extended(priceInfo.token).balanceOf(priceInfo.lpToken);\n      uint256 tokenDecimalDelta = 18 - uint256(IERC20Extended(priceInfo.token).decimals());\n      uint256 tokenAmount = rawTokenAmount.mul(10**tokenDecimalDelta);\n      uint256 rawBaseTokenAmount = IERC20Extended(priceInfo.baseToken).balanceOf(priceInfo.lpToken);\n      uint256 baseTokenDecimalDelta = 18 - uint256(IERC20Extended(priceInfo.baseToken).decimals());\n      uint256 baseTokenAmount = rawBaseTokenAmount.mul(10**baseTokenDecimalDelta);\n      uint256 baseTokenPrice = getTokenPrice(priceInfo.baseToken);\n      uint256 tokenPrice = baseTokenPrice.mul(baseTokenAmount).div(tokenAmount);\n\n      return tokenPrice;\n    } else {\n      return 0;\n    }\n  }\n\n  function getPriceFromOracle(address _tokenAddress) public view returns (uint256) {\n    uint256 chainLinkPrice = getPriceFromChainlink(_tokenAddress);\n    return chainLinkPrice;\n  }\n\n  function getPriceFromChainlink(address _tokenAddress) public view returns (uint256) {\n    AggregatorV3Interface aggregator = aggregators[_tokenAddress];\n    if (address(aggregator) != address(0)) {\n      (, int256 answer, , , ) = aggregator.latestRoundData();\n\n      // It's fine for price to be 0. We have two price feeds.\n      if (answer == 0) {\n        return 0;\n      }\n\n      // Extend the decimals to 1e18.\n      uint256 retVal = uint256(answer);\n      uint256 price = retVal.mul(10**(18 - uint256(aggregator.decimals())));\n\n      return price;\n    }\n\n    return 0;\n  }\n\n  function setDexPriceInfo(\n    address _token,\n    address _baseToken,\n    address _lpToken,\n    bool _active\n  ) external onlyAdmin {\n    PriceInfo storage priceInfo = priceRecords[_token];\n    uint256 baseTokenPrice = getTokenPrice(_baseToken);\n    require(baseTokenPrice > 0, \"invalid base token\");\n    priceInfo.token = _token;\n    priceInfo.baseToken = _baseToken;\n    priceInfo.lpToken = _lpToken;\n    priceInfo.active = _active;\n    emit PriceRecordUpdated(_token, _baseToken, _lpToken, _active);\n  }\n\n  function setDirectPrice(address _token, uint256 _price) external onlyAdmin {\n    emit DirectPriceUpdated(_token, assetPrices[_token], _price);\n    assetPrices[_token] = _price;\n  }\n\n  function setV1PriceOracle(address _v1PriceOracle) external onlyAdmin {\n    emit V1PriceOracleUpdated(v1PriceOracle, _v1PriceOracle);\n    v1PriceOracle = _v1PriceOracle;\n  }\n\n  function setAdmin(address newAdmin) external onlyAdmin {\n    address oldAdmin = admin;\n    admin = newAdmin;\n\n    emit NewAdmin(oldAdmin, newAdmin);\n  }\n\n  function setAggregators(address[] calldata tokenAddresses, address[] calldata sources) external onlyAdmin {\n    for (uint256 i = 0; i < tokenAddresses.length; i++) {\n      aggregators[tokenAddresses[i]] = AggregatorV3Interface(sources[i]);\n      emit AggregatorUpdated(tokenAddresses[i], sources[i]);\n    }\n  }\n}"
    },
    {
      "filename": "contracts/contracts/core/connext/facets/StableSwapFacet.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\nimport {AmplificationUtils, SwapUtils} from \"../libraries/AmplificationUtils.sol\";\nimport {LPToken} from \"../helpers/LPToken.sol\";\n\n/**\n * @title Swap - A StableSwap implementation in solidity.\n * @notice This contract is responsible for custody of closely pegged assets (eg. group of stablecoins)\n * and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens\n * in desired ratios for an exchange of the pool token that represents their share of the pool.\n * Users can burn pool tokens and withdraw their share of token(s).\n *\n * Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets\n * distributed to the LPs.\n *\n * In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which\n * stops the ratio of the tokens in the pool from changing.\n * Users can always withdraw their tokens via multi-asset withdraws.\n *\n * @dev Most of the logic is stored as a library `SwapUtils` for the sake of reducing contract's\n * deployment size.\n */\n\ncontract StableSwapFacet is BaseConnextFacet {\n  using SwapUtils for SwapUtils.Swap;\n  using AmplificationUtils for SwapUtils.Swap;\n\n  // ========== Custom Errors ===========\n  error StableSwapFacet__deadlineCheck_deadlineNotMet();\n  error StableSwapFacet__initializeSwap_alreadyInitialized();\n  error StableSwapFacet__initializeSwap_invalidPooledTokens();\n  error StableSwapFacet__initializeSwap_decimalsMismatch();\n  error StableSwapFacet__initializeSwap_duplicateTokens();\n  error StableSwapFacet__initializeSwap_zeroTokenAddress();\n  error StableSwapFacet__initializeSwap_tokenDecimalsExceedMax();\n  error StableSwapFacet__initializeSwap_aExceedMax();\n  error StableSwapFacet__initializeSwap_feeExceedMax();\n  error StableSwapFacet__initializeSwap_adminFeeExceedMax();\n  error StableSwapFacet__initializeSwap_failedInitLpTokenClone();\n  error StableSwapFacet__getSwapToken_outOfRange();\n  error StableSwapFacet__getSwapTokenIndex_notExist();\n  error StableSwapFacet__getSwapTokenBalance_indexOutOfRange();\n\n  // ============ Properties ============\n\n  // ============ Modifiers ============\n\n  /**\n   * @notice Modifier to check deadline against current timestamp\n   * @param deadline latest timestamp to accept this transaction\n   */\n  modifier deadlineCheck(uint256 deadline) {\n    if (block.timestamp > deadline) revert StableSwapFacet__deadlineCheck_deadlineNotMet();\n    _;\n  }\n\n  // ============ View Functions ============\n  /**\n   * @notice Return Stable swap storage\n   * @param canonicalId the canonical token id\n   * @return SwapUtils.Swap\n   */\n  function getSwapStorage(bytes32 canonicalId) external view returns (SwapUtils.Swap memory) {\n    return s.swapStorages[canonicalId];\n  }\n\n  /**\n   * @notice Return LP token for canonical Id\n   * @param canonicalId the canonical token id\n   * @return LPToken\n   */\n  function getSwapLPToken(bytes32 canonicalId) external view returns (address) {\n    return address(s.swapStorages[canonicalId].lpToken);\n  }\n\n  /**\n   * @notice Return A, the amplification coefficient * n * (n - 1)\n   * @dev See the StableSwap paper for details\n   * @param canonicalId the canonical token id\n   * @return A parameter\n   */\n  function getSwapA(bytes32 canonicalId) external view returns (uint256) {\n    return s.swapStorages[canonicalId].getA();\n  }\n\n  /**\n   * @notice Return A in its raw precision form\n   * @dev See the StableSwap paper for details\n   * @param canonicalId the canonical token id\n   * @return A parameter in its raw precision form\n   */\n  function getSwapAPrecise(bytes32 canonicalId) external view returns (uint256) {\n    return s.swapStorages[canonicalId].getAPrecise();\n  }\n\n  /**\n   * @notice Return address of the pooled token at given index. Reverts if tokenIndex is out of range.\n   * @param canonicalId the canonical token id\n   * @param index the index of the token\n   * @return address of the token at given index\n   */\n  function getSwapToken(bytes32 canonicalId, uint8 index) public view returns (IERC20) {\n    if (index >= s.swapStorages[canonicalId].pooledTokens.length) revert StableSwapFacet__getSwapToken_outOfRange();\n    return s.swapStorages[canonicalId].pooledTokens[index];\n  }\n\n  /**\n   * @notice Return the index of the given token address. Reverts if no matching\n   * token is found.\n   * @param canonicalId the canonical token id\n   * @param tokenAddress address of the token\n   * @return the index of the given token address\n   */\n  function getSwapTokenIndex(bytes32 canonicalId, address tokenAddress) public view returns (uint8) {\n    uint8 index = s.tokenIndexes[canonicalId][tokenAddress];\n    if (address(getSwapToken(canonicalId, index)) != tokenAddress) revert StableSwapFacet__getSwapTokenIndex_notExist();\n    return index;\n  }\n\n  /**\n   * @notice Return current balance of the pooled token at given index\n   * @param canonicalId the canonical token id\n   * @param index the index of the token\n   * @return current balance of the pooled token at given index with token's native precision\n   */\n  function getSwapTokenBalance(bytes32 canonicalId, uint8 index) external view returns (uint256) {\n    if (index >= s.swapStorages[canonicalId].balances.length)\n      revert StableSwapFacet__getSwapTokenBalance_indexOutOfRange();\n    return s.swapStorages[canonicalId].balances[index];\n  }\n\n  /**\n   * @notice Get the virtual price, to help calculate profit\n   * @param canonicalId the canonical token id\n   * @return the virtual price, scaled to the POOL_PRECISION_DECIMALS\n   */\n  function getSwapVirtualPrice(bytes32 canonicalId) external view returns (uint256) {\n    return s.swapStorages[canonicalId].getVirtualPrice();\n  }\n\n  /**\n   * @notice Calculate amount of tokens you receive on swap\n   * @param canonicalId the canonical token id\n   * @param tokenIndexFrom the token the user wants to sell\n   * @param tokenIndexTo the token the user wants to buy\n   * @param dx the amount of tokens the user wants to sell. If the token charges\n   * a fee on transfers, use the amount that gets transferred after the fee.\n   * @return amount of tokens the user will receive\n   */\n  function calculateSwap(\n    bytes32 canonicalId,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx\n  ) external view returns (uint256) {\n    return s.swapStorages[canonicalId].calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n  }\n\n  /**\n   * @notice A simple method to calculate prices from deposits or\n   * withdrawals, excluding fees but including slippage. This is\n   * helpful as an input into the various \"min\" parameters on calls\n   * to fight front-running\n   *\n   * @dev This shouldn't be used outside frontends for user estimates.\n   *\n   * @param canonicalId the canonical token id\n   * @param amounts an array of token amounts to deposit or withdrawal,\n   * corresponding to pooledTokens. The amount should be in each\n   * pooled token's native precision. If a token charges a fee on transfers,\n   * use the amount that gets transferred after the fee.\n   * @param deposit whether this is a deposit or a withdrawal\n   * @return token amount the user will receive\n   */\n  function calculateSwapTokenAmount(\n    bytes32 canonicalId,\n    uint256[] calldata amounts,\n    bool deposit\n  ) external view returns (uint256) {\n    return s.swapStorages[canonicalId].calculateTokenAmount(amounts, deposit);\n  }\n\n  /**\n   * @notice A simple method to calculate amount of each underlying\n   * tokens that is returned upon burning given amount of LP tokens\n   * @param canonicalId the canonical token id\n   * @param amount the amount of LP tokens that would be burned on withdrawal\n   * @return array of token balances that the user will receive\n   */\n  function calculateRemoveSwapLiquidity(bytes32 canonicalId, uint256 amount) external view returns (uint256[] memory) {\n    return s.swapStorages[canonicalId].calculateRemoveLiquidity(amount);\n  }\n\n  /**\n   * @notice Calculate the amount of underlying token available to withdraw\n   * when withdrawing via only single token\n   * @param canonicalId the canonical token id\n   * @param tokenAmount the amount of LP token to burn\n   * @param tokenIndex index of which token will be withdrawn\n   * @return availableTokenAmount calculated amount of underlying token\n   * available to withdraw\n   */\n  function calculateRemoveSwapLiquidityOneToken(\n    bytes32 canonicalId,\n    uint256 tokenAmount,\n    uint8 tokenIndex\n  ) external view returns (uint256 availableTokenAmount) {\n    return s.swapStorages[canonicalId].calculateWithdrawOneToken(tokenAmount, tokenIndex);\n  }\n\n  /**\n   * @notice This function reads the accumulated amount of admin fees of the token with given index\n   * @param canonicalId the canonical token id\n   * @param index Index of the pooled token\n   * @return admin's token balance in the token's precision\n   */\n  function getSwapAdminBalance(bytes32 canonicalId, uint256 index) external view returns (uint256) {\n    return s.swapStorages[canonicalId].getAdminBalance(index);\n  }\n\n  /*** STATE MODIFYING FUNCTIONS ***/\n\n  /**\n   * @notice Swap two tokens using this pool\n   * @param canonicalId the canonical token id\n   * @param tokenIndexFrom the token the user wants to swap from\n   * @param tokenIndexTo the token the user wants to swap to\n   * @param dx the amount of tokens the user wants to swap from\n   * @param minDy the min amount the user would like to receive, or revert.\n   * @param deadline latest timestamp to accept this transaction\n   */\n  function swap(\n    bytes32 canonicalId,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx,\n    uint256 minDy,\n    uint256 deadline\n  ) external nonReentrant deadlineCheck(deadline) whenNotPaused returns (uint256) {\n    return s.swapStorages[canonicalId].swap(tokenIndexFrom, tokenIndexTo, dx, minDy);\n  }\n\n  /**\n   * @notice Swap two tokens using this pool\n   * @param canonicalId the canonical token id\n   * @param assetIn the token the user wants to swap from\n   * @param assetOut the token the user wants to swap to\n   * @param amountIn the amount of tokens the user wants to swap from\n   */\n  function swapExact(\n    bytes32 canonicalId,\n    uint256 amountIn,\n    address assetIn,\n    address assetOut,\n    uint256 minAmountOut,\n    uint256 deadline\n  ) external payable nonReentrant deadlineCheck(deadline) whenNotPaused returns (uint256) {\n    return\n      s.swapStorages[canonicalId].swap(\n        getSwapTokenIndex(canonicalId, assetIn),\n        getSwapTokenIndex(canonicalId, assetOut),\n        amountIn,\n        minAmountOut\n      );\n  }\n\n  /**\n   * @notice Swap two tokens using this pool\n   * @param canonicalId the canonical token id\n   * @param assetIn the token the user wants to swap from\n   * @param assetOut the token the user wants to swap to\n   * @param amountOut the amount of tokens the user wants to swap to\n   */\n  function swapExactOut(\n    bytes32 canonicalId,\n    uint256 amountOut,\n    address assetIn,\n    address assetOut,\n    uint256 maxAmountIn,\n    uint256 deadline\n  ) external payable nonReentrant deadlineCheck(deadline) returns (uint256) {\n    return\n      s.swapStorages[canonicalId].swapOut(\n        getSwapTokenIndex(canonicalId, assetIn),\n        getSwapTokenIndex(canonicalId, assetOut),\n        amountOut,\n        maxAmountIn\n      );\n  }\n\n  /**\n   * @notice Add liquidity to the pool with the given amounts of tokens\n   * @param canonicalId the canonical token id\n   * @param amounts the amounts of each token to add, in their native precision\n   * @param minToMint the minimum LP tokens adding this amount of liquidity\n   * should mint, otherwise revert. Handy for front-running mitigation\n   * @param deadline latest timestamp to accept this transaction\n   * @return amount of LP token user minted and received\n   */\n  function addSwapLiquidity(\n    bytes32 canonicalId,\n    uint256[] calldata amounts,\n    uint256 minToMint,\n    uint256 deadline\n  ) external nonReentrant deadlineCheck(deadline) returns (uint256) {\n    return s.swapStorages[canonicalId].addLiquidity(amounts, minToMint);\n  }\n\n  /**\n   * @notice Burn LP tokens to remove liquidity from the pool. Withdraw fee that decays linearly\n   * over period of 4 weeks since last deposit will apply.\n   * @dev Liquidity can always be removed, even when the pool is paused.\n   * @param canonicalId the canonical token id\n   * @param amount the amount of LP tokens to burn\n   * @param minAmounts the minimum amounts of each token in the pool\n   *        acceptable for this burn. Useful as a front-running mitigation\n   * @param deadline latest timestamp to accept this transaction\n   * @return amounts of tokens user received\n   */\n  function removeSwapLiquidity(\n    bytes32 canonicalId,\n    uint256 amount,\n    uint256[] calldata minAmounts,\n    uint256 deadline\n  ) external nonReentrant deadlineCheck(deadline) whenNotPaused returns (uint256[] memory) {\n    return s.swapStorages[canonicalId].removeLiquidity(amount, minAmounts);\n  }\n\n  /**\n   * @notice Remove liquidity from the pool all in one token. Withdraw fee that decays linearly\n   * over period of 4 weeks since last deposit will apply.\n   * @param canonicalId the canonical token id\n   * @param tokenAmount the amount of the token you want to receive\n   * @param tokenIndex the index of the token you want to receive\n   * @param minAmount the minimum amount to withdraw, otherwise revert\n   * @param deadline latest timestamp to accept this transaction\n   * @return amount of chosen token user received\n   */\n  function removeSwapLiquidityOneToken(\n    bytes32 canonicalId,\n    uint256 tokenAmount,\n    uint8 tokenIndex,\n    uint256 minAmount,\n    uint256 deadline\n  ) external nonReentrant deadlineCheck(deadline) whenNotPaused returns (uint256) {\n    return s.swapStorages[canonicalId].removeLiquidityOneToken(tokenAmount, tokenIndex, minAmount);\n  }\n\n  /**\n   * @notice Remove liquidity from the pool, weighted differently than the\n   * pool's current balances. Withdraw fee that decays linearly\n   * over period of 4 weeks since last deposit will apply.\n   * @param canonicalId the canonical token id\n   * @param amounts how much of each token to withdraw\n   * @param maxBurnAmount the max LP token provider is willing to pay to\n   * remove liquidity. Useful as a front-running mitigation.\n   * @param deadline latest timestamp to accept this transaction\n   * @return amount of LP tokens burned\n   */\n  function removeSwapLiquidityImbalance(\n    bytes32 canonicalId,\n    uint256[] calldata amounts,\n    uint256 maxBurnAmount,\n    uint256 deadline\n  ) external nonReentrant deadlineCheck(deadline) whenNotPaused returns (uint256) {\n    return s.swapStorages[canonicalId].removeLiquidityImbalance(amounts, maxBurnAmount);\n  }\n\n  /*** ADMIN FUNCTIONS ***/\n  /**\n   * @notice Initializes this Swap contract with the given parameters.\n   * This will also clone a LPToken contract that represents users'\n   * LP positions. The owner of LPToken will be this contract - which means\n   * only this contract is allowed to mint/burn tokens.\n   *\n   * @param _canonicalId the canonical token id\n   * @param _pooledTokens an array of ERC20s this pool will accept\n   * @param decimals the decimals to use for each pooled token,\n   * eg 8 for WBTC. Cannot be larger than POOL_PRECISION_DECIMALS\n   * @param lpTokenName the long-form name of the token to be deployed\n   * @param lpTokenSymbol the short symbol for the token to be deployed\n   * @param _a the amplification coefficient * n * (n - 1). See the\n   * StableSwap paper for details\n   * @param _fee default swap fee to be initialized with\n   * @param _adminFee default adminFee to be initialized with\n   * @param lpTokenTargetAddress the address of an existing LPToken contract to use as a target\n   */\n  function initializeSwap(\n    bytes32 _canonicalId,\n    IERC20[] memory _pooledTokens,\n    uint8[] memory decimals,\n    string memory lpTokenName,\n    string memory lpTokenSymbol,\n    uint256 _a,\n    uint256 _fee,\n    uint256 _adminFee,\n    address lpTokenTargetAddress\n  ) external onlyOwner {\n    if (s.swapStorages[_canonicalId].pooledTokens.length != 0)\n      revert StableSwapFacet__initializeSwap_alreadyInitialized();\n\n    // Check _pooledTokens and precisions parameter\n    if (_pooledTokens.length <= 1 || _pooledTokens.length > 32)\n      revert StableSwapFacet__initializeSwap_invalidPooledTokens();\n\n    if (_pooledTokens.length != decimals.length) revert StableSwapFacet__initializeSwap_decimalsMismatch();\n\n    uint256[] memory precisionMultipliers = new uint256[](decimals.length);\n\n    for (uint8 i = 0; i < _pooledTokens.length; i++) {\n      if (i > 0) {\n        // Check if index is already used. Check if 0th element is a duplicate.\n        if (s.tokenIndexes[_canonicalId][address(_pooledTokens[i])] != 0 || _pooledTokens[0] == _pooledTokens[i])\n          revert StableSwapFacet__initializeSwap_duplicateTokens();\n      }\n      if (address(_pooledTokens[i]) == address(0)) revert StableSwapFacet__initializeSwap_zeroTokenAddress();\n\n      if (decimals[i] > SwapUtils.POOL_PRECISION_DECIMALS)\n        revert StableSwapFacet__initializeSwap_tokenDecimalsExceedMax();\n\n      precisionMultipliers[i] = 10**uint256(SwapUtils.POOL_PRECISION_DECIMALS - decimals[i]);\n      s.tokenIndexes[_canonicalId][address(_pooledTokens[i])] = i;\n    }\n\n    // Check _a, _fee, _adminFee, _withdrawFee parameters\n    if (_a >= AmplificationUtils.MAX_A) revert StableSwapFacet__initializeSwap_aExceedMax();\n    if (_fee >= SwapUtils.MAX_SWAP_FEE) revert StableSwapFacet__initializeSwap_feeExceedMax();\n    if (_adminFee >= SwapUtils.MAX_ADMIN_FEE) revert StableSwapFacet__initializeSwap_adminFeeExceedMax();\n\n    // Initialize a LPToken contract\n    LPToken lpToken = LPToken(Clones.clone(lpTokenTargetAddress));\n    if (!lpToken.initialize(lpTokenName, lpTokenSymbol))\n      revert StableSwapFacet__initializeSwap_failedInitLpTokenClone();\n\n    // Initialize swapStorage struct\n    s.swapStorages[_canonicalId] = SwapUtils.Swap({\n      initialA: _a * AmplificationUtils.A_PRECISION,\n      futureA: _a * AmplificationUtils.A_PRECISION,\n      swapFee: _fee,\n      adminFee: _adminFee,\n      lpToken: lpToken,\n      pooledTokens: _pooledTokens,\n      tokenPrecisionMultipliers: precisionMultipliers,\n      balances: new uint256[](_pooledTokens.length),\n      adminFees: new uint256[](_pooledTokens.length),\n      initialATime: 0,\n      futureATime: 0\n    });\n  }\n\n  /**\n   * @notice Withdraw all admin fees to the contract owner\n   * @param canonicalId the canonical token id\n   */\n  function withdrawSwapAdminFees(bytes32 canonicalId) external onlyOwner {\n    s.swapStorages[canonicalId].withdrawAdminFees(msg.sender);\n  }\n\n  /**\n   * @notice Update the admin fee. Admin fee takes portion of the swap fee.\n   * @param canonicalId the canonical token id\n   * @param newAdminFee new admin fee to be applied on future transactions\n   */\n  function setSwapAdminFee(bytes32 canonicalId, uint256 newAdminFee) external onlyOwner {\n    s.swapStorages[canonicalId].setAdminFee(newAdminFee);\n  }\n\n  /**\n   * @notice Update the swap fee to be applied on swaps\n   * @param canonicalId the canonical token id\n   * @param newSwapFee new swap fee to be applied on future transactions\n   */\n  function setSwapFee(bytes32 canonicalId, uint256 newSwapFee) external onlyOwner {\n    s.swapStorages[canonicalId].setSwapFee(newSwapFee);\n  }\n\n  /**\n   * @notice Start ramping up or down A parameter towards given futureA and futureTime\n   * Checks if the change is too rapid, and commits the new A value only when it falls under\n   * the limit range.\n   * @param canonicalId the canonical token id\n   * @param futureA the new A to ramp towards\n   * @param futureTime timestamp when the new A should be reached\n   */\n  function rampA(\n    bytes32 canonicalId,\n    uint256 futureA,\n    uint256 futureTime\n  ) external onlyOwner {\n    s.swapStorages[canonicalId].rampA(futureA, futureTime);\n  }\n\n  /**\n   * @notice Stop ramping A immediately. Reverts if ramp A is already stopped.\n   * @param canonicalId the canonical token id\n   */\n  function stopRampA(bytes32 canonicalId) external onlyOwner {\n    s.swapStorages[canonicalId].stopRampA();\n  }\n}"
    },
    {
      "filename": "contracts/contracts/core/connext/helpers/ConnextPriceOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20Extended} from \"../interfaces/IERC20Extended.sol\";\n\nimport {PriceOracle} from \"./PriceOracle.sol\";\nimport {IPriceOracle} from \"../interfaces/IPriceOracle.sol\";\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n\ncontract ConnextPriceOracle is PriceOracle {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20Extended;\n\n  address public admin;\n  address public wrapped;\n  address public v1PriceOracle;\n\n  /// @notice Chainlink Aggregators\n  mapping(address => AggregatorV3Interface) public aggregators;\n\n  struct PriceInfo {\n    address token; // Address of token contract, TOKEN\n    address baseToken; // Address of base token contract, BASETOKEN\n    address lpToken; // Address of TOKEN-BASETOKEN pair contract\n    bool active; // Active status of price record 0\n  }\n\n  mapping(address => PriceInfo) public priceRecords;\n  mapping(address => uint256) public assetPrices;\n\n  event NewAdmin(address oldAdmin, address newAdmin);\n  event PriceRecordUpdated(address token, address baseToken, address lpToken, bool _active);\n  event DirectPriceUpdated(address token, uint256 oldPrice, uint256 newPrice);\n  event AggregatorUpdated(address tokenAddress, address source);\n  event V1PriceOracleUpdated(address oldAddress, address newAddress);\n\n  modifier onlyAdmin() {\n    require(msg.sender == admin, \"caller is not the admin\");\n    _;\n  }\n\n  constructor(address _wrapped) {\n    wrapped = _wrapped;\n    admin = msg.sender;\n  }\n\n  function getTokenPrice(address _tokenAddress) public view override returns (uint256) {\n    address tokenAddress = _tokenAddress;\n    if (_tokenAddress == address(0)) {\n      tokenAddress = wrapped;\n    }\n    uint256 tokenPrice = assetPrices[tokenAddress];\n    if (tokenPrice == 0) {\n      tokenPrice = getPriceFromOracle(tokenAddress);\n    }\n    if (tokenPrice == 0) {\n      tokenPrice = getPriceFromDex(tokenAddress);\n    }\n    if (tokenPrice == 0 && v1PriceOracle != address(0)) {\n      tokenPrice = IPriceOracle(v1PriceOracle).getTokenPrice(tokenAddress);\n    }\n    return tokenPrice;\n  }\n\n  function getPriceFromDex(address _tokenAddress) public view returns (uint256) {\n    PriceInfo storage priceInfo = priceRecords[_tokenAddress];\n    if (priceInfo.active) {\n      uint256 rawTokenAmount = IERC20Extended(priceInfo.token).balanceOf(priceInfo.lpToken);\n      uint256 tokenDecimalDelta = 18 - uint256(IERC20Extended(priceInfo.token).decimals());\n      uint256 tokenAmount = rawTokenAmount.mul(10**tokenDecimalDelta);\n      uint256 rawBaseTokenAmount = IERC20Extended(priceInfo.baseToken).balanceOf(priceInfo.lpToken);\n      uint256 baseTokenDecimalDelta = 18 - uint256(IERC20Extended(priceInfo.baseToken).decimals());\n      uint256 baseTokenAmount = rawBaseTokenAmount.mul(10**baseTokenDecimalDelta);\n      uint256 baseTokenPrice = getTokenPrice(priceInfo.baseToken);\n      uint256 tokenPrice = baseTokenPrice.mul(baseTokenAmount).div(tokenAmount);\n\n      return tokenPrice;\n    } else {\n      return 0;\n    }\n  }\n\n  function getPriceFromOracle(address _tokenAddress) public view returns (uint256) {\n    uint256 chainLinkPrice = getPriceFromChainlink(_tokenAddress);\n    return chainLinkPrice;\n  }\n\n  function getPriceFromChainlink(address _tokenAddress) public view returns (uint256) {\n    AggregatorV3Interface aggregator = aggregators[_tokenAddress];\n    if (address(aggregator) != address(0)) {\n      (, int256 answer, , , ) = aggregator.latestRoundData();\n\n      // It's fine for price to be 0. We have two price feeds.\n      if (answer == 0) {\n        return 0;\n      }\n\n      // Extend the decimals to 1e18.\n      uint256 retVal = uint256(answer);\n      uint256 price = retVal.mul(10**(18 - uint256(aggregator.decimals())));\n\n      return price;\n    }\n\n    return 0;\n  }\n\n  function setDexPriceInfo(\n    address _token,\n    address _baseToken,\n    address _lpToken,\n    bool _active\n  ) external onlyAdmin {\n    PriceInfo storage priceInfo = priceRecords[_token];\n    uint256 baseTokenPrice = getTokenPrice(_baseToken);\n    require(baseTokenPrice > 0, \"invalid base token\");\n    priceInfo.token = _token;\n    priceInfo.baseToken = _baseToken;\n    priceInfo.lpToken = _lpToken;\n    priceInfo.active = _active;\n    emit PriceRecordUpdated(_token, _baseToken, _lpToken, _active);\n  }\n\n  function setDirectPrice(address _token, uint256 _price) external onlyAdmin {\n    emit DirectPriceUpdated(_token, assetPrices[_token], _price);\n    assetPrices[_token] = _price;\n  }\n\n  function setV1PriceOracle(address _v1PriceOracle) external onlyAdmin {\n    emit V1PriceOracleUpdated(v1PriceOracle, _v1PriceOracle);\n    v1PriceOracle = _v1PriceOracle;\n  }\n\n  function setAdmin(address newAdmin) external onlyAdmin {\n    address oldAdmin = admin;\n    admin = newAdmin;\n\n    emit NewAdmin(oldAdmin, newAdmin);\n  }\n\n  function setAggregators(address[] calldata tokenAddresses, address[] calldata sources) external onlyAdmin {\n    for (uint256 i = 0; i < tokenAddresses.length; i++) {\n      aggregators[tokenAddresses[i]] = AggregatorV3Interface(sources[i]);\n      emit AggregatorUpdated(tokenAddresses[i], sources[i]);\n    }\n  }\n}"
    }
  ]
}