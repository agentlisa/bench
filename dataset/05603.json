{
  "Title": "[H-04] When `withdrawalBatchDuration` is set to zero lenders can withdraw more then allocated to a batch",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-10-wildcat/blob/c5df665f0bc2ca5df6f06938d66494b11e7bdada/src/market/WildcatMarketWithdrawals.sol#L137><br>\n<https://github.com/code-423n4/2023-10-wildcat/blob/c5df665f0bc2ca5df6f06938d66494b11e7bdada/src/market/WildcatMarketWithdrawals.sol#L77>\n\n### Vulnerability details\n\nThe Wildcat protocol utilizes a withdrawal cycle where lenders call   `queueWithdrawals` which then goes through a set amount of time (withdrawal duration period) before a withdrawal can be executed (if the protocol has enough funds to cover the withdrawal). Withdrawal requests that could not be fully honored at the end of their withdrawal cycle are batched together, marked as expired withdrawals, and added to the withdrawal queue. These batches are tracked using the time of expiry, and when assets are returned to a market with a non-zero withdrawal queue, assets are immediately routed to the unclaimed withdrawals pool and can subsequently be claimed by lenders with the oldest expired withdrawals first.\n\nThe `withdrawalBatchDuration` can be set to zero so lenders do not have to wait before being able to withdraw funds from the market; however, this can cause issues where lenders in a batch can withdraw more than their pro-rata share of the batch's paid assets.\n\nA lender calls `queueWithdrawal` first to initiate the withdrawal; this will place it in a batch respective to its expiry:\n\n```solidity\nfunction queueWithdrawal(uint256 amount) external nonReentrant {\n        MarketState memory state = _getUpdatedState();\n\n        ...\n\n        // If there is no pending withdrawal batch, create a new one.\n        if (state.pendingWithdrawalExpiry == 0) {\n            state.pendingWithdrawalExpiry = uint32(block.timestamp + withdrawalBatchDuration);\n            emit WithdrawalBatchCreated(state.pendingWithdrawalExpiry);\n        }\n        // Cache batch expiry on the stack for gas savings.\n        uint32 expiry = state.pendingWithdrawalExpiry;\n\n        WithdrawalBatch memory batch = _withdrawalData.batches[expiry];\n\n        // Add scaled withdrawal amount to account withdrawal status, withdrawal batch and market state.\n        _withdrawalData.accountStatuses[expiry][msg.sender].scaledAmount += scaledAmount;\n        batch.scaledTotalAmount += scaledAmount;\n        state.scaledPendingWithdrawals += scaledAmount;\n\n        emit WithdrawalQueued(expiry, msg.sender, scaledAmount);\n\n        // Burn as much of the withdrawal batch as possible with available liquidity.\n        uint256 availableLiquidity = batch.availableLiquidityForPendingBatch(state, totalAssets());\n        if (availableLiquidity > 0) {\n            _applyWithdrawalBatchPayment(batch, state, expiry, availableLiquidity);\n        }\n\n        // Update stored batch data\n        _withdrawalData.batches[expiry] = batch;\n\n        // Update stored state\n        _writeState(state);\n    }\n```\n\nNow once the `withdrawalBatchDuration` has passed, a lender can call `executeWithdrawal` to finalize the withdrawal. This will grab the batch and let the lender withdraw a percentage of the batch if the batch is not fully paid or all funds if it is fully paid.\n\n```solidity\nfunction executeWithdrawal(address accountAddress, uint32 expiry) external nonReentrant returns (uint256) {\n        if (expiry > block.timestamp) {\n            revert WithdrawalBatchNotExpired();\n        }\n        MarketState memory state = _getUpdatedState();\n\n        WithdrawalBatch memory batch = _withdrawalData.batches[expiry];\n        AccountWithdrawalStatus storage status = _withdrawalData.accountStatuses[expiry][accountAddress];\n\n        uint128 newTotalWithdrawn =\n            uint128(MathUtils.mulDiv(batch.normalizedAmountPaid, status.scaledAmount, batch.scaledTotalAmount));\n        uint128 normalizedAmountWithdrawn = newTotalWithdrawn - status.normalizedAmountWithdrawn;\n        status.normalizedAmountWithdrawn = newTotalWithdrawn;\n        state.normalizedUnclaimedWithdrawals -= normalizedAmountWithdrawn;\n\n        ...\n\n        // Update stored state\n        _writeState(state);\n\n        return normalizedAmountWithdrawn;\n    }\n```\n\nLet's look at how this percentage is determined: the `newTotalWithdrawn` function determines a lender's available withdrawal amount by multiplying the `normalizedAmountPaid` with the `scaledAmount` and dividing the result by the batch's `scaledTotalAmount`. This ensures that each lender in the batch can withdraw an even amount of the available funds in the batch depending on their `scaledAmount`.\n\n```solidity\n uint128 newTotalWithdrawn =\n            uint128(MathUtils.mulDiv(batch.normalizedAmountPaid, status.scaledAmount, batch.scaledTotalAmount));\n```\n\nThis works fine when `withdrawalBatchDuration` is set over zero, as the batch values (except `normalizedAmountPaid`) are finalized. However, when set to zero, we can end up with lenders in a batch being able to withdraw more than `normalizedAmountPaid` in that batch, potentially violating protocol invariants.\n\nConsider the following scenario:\n\nThere is only 5 tokens available to burn.\n\nLender A calls `queueWithdrawal` with 5 and `executeWithdrawal` instantly.\n\n    newTotalWithdrawn = (normalizedAmountPaid) * (scaledAmount) / scaledTotalAmount\n\n    newTotalWithdrawn = 5 * 5 = 25 / 5 = 5\n\nLender A was able to fully withdraw.\n\nLender B comes along and calls `queueWithdrawal` with 5 and `executeWithdrawal` instantly in the same block. This will add to the same batch as lender A as it is the same expiry.\n\nNow let's look at `newTotalWithdrawn` for Lender B:\n\n    newTotalWithdrawn = (normalizedAmountPaid) * (scaledAmount) / scaledTotalAmount\n\n    newTotalWithdrawn = 5 * 5 = 25 / 10 = 2.5\n\nLets see what the batch looks like now:\n\n- Lender A was able to withdraw 5 tokens in the batch.\n- Lender B was able to withdraw 2.5 tokens in the batch.\n- The `batch.normalizedAmountPaid` is 5, meaning the Lenders' withdrawal amount surpassed the batch's current limit.\n\n### Impact\n\nThis will break the following invariant in the protocol:\n\n> \"Withdrawal execution can only transfer assets that have been counted as paid assets in the corresponding batch, i.e. lenders with withdrawal requests can not withdraw more than their pro-rata share of the batch's paid assets.\"\n\nIt will also mean that funds reserved for other batches may not be able to be fulfilled even if the batch's `normalizedAmountPaid` number shows that it should be able to.\n\n### Proof Of Concept\n\nFor the following test, make sure you use the following parameters in `ExpectedStateTracker`:\n\n```solidity\nMarketParameters internal parameters = MarketParameters({\n        asset: address(0),\n        namePrefix: \"Wildcat \",\n        symbolPrefix: \"WC\",\n        borrower: borrower,\n        controller: address(0),\n        feeRecipient: address(0),\n        sentinel: address(sanctionsSentinel),\n        maxTotalSupply: uint128(DefaultMaximumSupply),\n        protocolFeeBips: 0,\n        annualInterestBips: 0,\n        delinquencyFeeBips: DefaultDelinquencyFee,\n        withdrawalBatchDuration: 0,\n        reserveRatioBips: DefaultReserveRatio,\n        delinquencyGracePeriod: DefaultGracePeriod\n    });\n```\n\n```solidity\nfunction test_ZeroWithdrawalDuration() external asAccount(address(controller)) {\n        assertEq(market.withdrawalBatchDuration(), 0);\n        // alice deposit\n        _deposit(alice, 2e18);\n        // bob deposit\n        _deposit(bob, 1e18);\n        // borrow 33% of deposits\n        _borrow(1e18);\n        // alice withdraw request\n        startPrank(alice);\n        market.queueWithdrawal(1e18);\n        stopPrank();\n        // fast forward 1 days\n        fastForward(1 days);\n        // alice withdraw request\n        startPrank(alice);\n        market.queueWithdrawal(1e18);\n        stopPrank();\n        // lets look at the withdrawal batch\n        assertEq(market.getWithdrawalBatch(uint32(block.timestamp)).normalizedAmountPaid, 1e18);\n        assertEq(market.getWithdrawalBatch(uint32(block.timestamp)).scaledTotalAmount, 1e18);\n        assertEq(market.getWithdrawalBatch(uint32(block.timestamp)).scaledAmountBurned, 1e18);\n        // check amount alice has withdrawn so far (should be zero)\n        assertEq(\n            market.getAccountWithdrawalStatus(address(alice), uint32(block.timestamp)).normalizedAmountWithdrawn, 0\n        );\n        // alice withdraw\n        startPrank(alice);\n        market.executeWithdrawal(address(alice), uint32(block.timestamp));\n        stopPrank();\n        // check amount alice has withdrawn so far (should be 1e18)\n        assertEq(\n            market.getAccountWithdrawalStatus(address(alice), uint32(block.timestamp)).normalizedAmountWithdrawn, 1e18\n        );\n        // bob withdraw request in same batch\n        startPrank(bob);\n        market.queueWithdrawal(1e18);\n        stopPrank();\n        // lets look at the withdrawal batch now\n        assertEq(market.getWithdrawalBatch(uint32(block.timestamp)).normalizedAmountPaid, 1e18);\n        assertEq(market.getWithdrawalBatch(uint32(block.timestamp)).scaledTotalAmount, 2e18);\n        assertEq(market.getWithdrawalBatch(uint32(block.timestamp)).scaledAmountBurned, 1e18);\n        // check amount bob has withdrawn so far (should be zero)\n        assertEq(market.getAccountWithdrawalStatus(address(bob), uint32(block.timestamp)).normalizedAmountWithdrawn, 0);\n        // bob withdraw\n        startPrank(bob);\n        market.executeWithdrawal(address(bob), uint32(block.timestamp));\n        stopPrank();\n        // check amount bob has withdrawn so far (should be 5e17)\n        assertEq(\n            market.getAccountWithdrawalStatus(address(bob), uint32(block.timestamp)).normalizedAmountWithdrawn, 5e17\n        );\n        // lets look at the withdrawal batch now\n        assertEq(market.getWithdrawalBatch(uint32(block.timestamp)).normalizedAmountPaid, 1e18);\n        assertEq(market.getWithdrawalBatch(uint32(block.timestamp)).scaledTotalAmount, 2e18);\n        assertEq(market.getWithdrawalBatch(uint32(block.timestamp)).scaledAmountBurned, 1e18);\n        // what happened is alice and bob have withdrawn 1e18 and 5e17 respectively\n        // but the batch is 1e18\n        uint128 normalizedAmountPaid = market.getWithdrawalBatch(uint32(block.timestamp)).normalizedAmountPaid;\n        uint128 aliceWithdrawn =\n            market.getAccountWithdrawalStatus(address(alice), uint32(block.timestamp)).normalizedAmountWithdrawn;\n        uint128 bobWithdrawn =\n            market.getAccountWithdrawalStatus(address(bob), uint32(block.timestamp)).normalizedAmountWithdrawn;\n        assertGt(aliceWithdrawn + bobWithdrawn, normalizedAmountPaid);\n    }\n```\n\n### Tools Used\n\nFoundry\n\n### Recommendation\n\nReview the protocol's withdrawal mechanism and consider adjusting the behaviour of withdrawals when `withdrawalBatchDuration` is set to zero to ensure that lenders cannot withdraw more than their pro-rata share of the batch's paid assets.\n\n**[d1ll0n (Wildcat) confirmed and commented](https://github.com/code-423n4/2023-10-wildcat-findings/issues/410#issuecomment-1789235997):**\n > Thank you! Good catch - going to fix this by changing the assertion in `executeWithdrawal` from:\n> ```solidity\n> if (expiry > block.timestamp) {\n>     revert WithdrawalBatchNotExpired();\n> }\n> ```\n>     \n> to:\n>     \n> ```solidity\n> if (expiry >= block.timestamp) {\n>       revert WithdrawalBatchNotExpired();\n> }\n> ```\n>     \n> so that it's guaranteed the withdrawal batch can not be added to when it's in a state that allows execution.\n\n**[laurenceday (Wildcat) commented](https://github.com/code-423n4/2023-10-wildcat-findings/issues/410#issuecomment-1803369074):**\n > Mitigated [here](https://github.com/wildcat-finance/wildcat-protocol/pull/57/commits/f9ecf3df04a6c9608faeae76f2c40d61716e9061).\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-10-wildcat",
  "Code": [
    {
      "filename": "src/market/WildcatMarketWithdrawals.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport './WildcatMarketBase.sol';\nimport '../libraries/MarketState.sol';\nimport '../libraries/FeeMath.sol';\nimport '../libraries/FIFOQueue.sol';\nimport '../interfaces/IWildcatSanctionsSentinel.sol';\nimport 'solady/utils/SafeTransferLib.sol';\n\ncontract WildcatMarketWithdrawals is WildcatMarketBase {\n  using SafeTransferLib for address;\n  using MathUtils for uint256;\n  using SafeCastLib for uint256;\n  using BoolUtils for bool;\n\n  /* -------------------------------------------------------------------------- */\n  /*                             Withdrawal Queries                             */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @dev Returns the expiry timestamp of every unpaid withdrawal batch.\n   */\n  function getUnpaidBatchExpiries() external view nonReentrantView returns (uint32[] memory) {\n    return _withdrawalData.unpaidBatches.values();\n  }\n\n  function getWithdrawalBatch(\n    uint32 expiry\n  ) external view nonReentrantView returns (WithdrawalBatch memory) {\n    (, uint32 expiredBatchExpiry, WithdrawalBatch memory expiredBatch) = _calculateCurrentState();\n    if ((expiry == expiredBatchExpiry).and(expiry > 0)) {\n      return expiredBatch;\n    }\n    return _withdrawalData.batches[expiry];\n  }\n\n  function getAccountWithdrawalStatus(\n    address accountAddress,\n    uint32 expiry\n  ) external view nonReentrantView returns (AccountWithdrawalStatus memory) {\n    return _withdrawalData.accountStatuses[expiry][accountAddress];\n  }\n\n  function getAvailableWithdrawalAmount(\n    address accountAddress,\n    uint32 expiry\n  ) external view nonReentrantView returns (uint256) {\n    if (expiry > block.timestamp) {\n      revert WithdrawalBatchNotExpired();\n    }\n    (, uint32 expiredBatchExpiry, WithdrawalBatch memory expiredBatch) = _calculateCurrentState();\n    WithdrawalBatch memory batch;\n    if (expiry == expiredBatchExpiry) {\n      batch = expiredBatch;\n    } else {\n      batch = _withdrawalData.batches[expiry];\n    }\n    AccountWithdrawalStatus memory status = _withdrawalData.accountStatuses[expiry][accountAddress];\n    // Rounding errors will lead to some dust accumulating in the batch, but the cost of\n    // executing a withdrawal will be lower for users.\n    uint256 previousTotalWithdrawn = status.normalizedAmountWithdrawn;\n    uint256 newTotalWithdrawn = uint256(batch.normalizedAmountPaid).mulDiv(\n      status.scaledAmount,\n      batch.scaledTotalAmount\n    );\n    return newTotalWithdrawn - previousTotalWithdrawn;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                             Withdrawal Actions                             */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @dev Create a withdrawal request for a lender.\n   */\n  function queueWithdrawal(uint256 amount) external nonReentrant {\n    MarketState memory state = _getUpdatedState();\n\n    // Cache account data and revert if not authorized to withdraw.\n    Account memory account = _getAccountWithRole(msg.sender, AuthRole.WithdrawOnly);\n\n    uint104 scaledAmount = state.scaleAmount(amount).toUint104();\n    if (scaledAmount == 0) {\n      revert NullBurnAmount();\n    }\n\n    // Reduce caller's balance and emit transfer event.\n    account.scaledBalance -= scaledAmount;\n    _accounts[msg.sender] = account;\n    emit Transfer(msg.sender, address(this), amount);\n\n    // If there is no pending withdrawal batch, create a new one.\n    if (state.pendingWithdrawalExpiry == 0) {\n      state.pendingWithdrawalExpiry = uint32(block.timestamp + withdrawalBatchDuration);\n      emit WithdrawalBatchCreated(state.pendingWithdrawalExpiry);\n    }\n    // Cache batch expiry on the stack for gas savings.\n    uint32 expiry = state.pendingWithdrawalExpiry;\n\n    WithdrawalBatch memory batch = _withdrawalData.batches[expiry];\n\n    // Add scaled withdrawal amount to account withdrawal status, withdrawal batch and market state.\n    _withdrawalData.accountStatuses[expiry][msg.sender].scaledAmount += scaledAmount;\n    batch.scaledTotalAmount += scaledAmount;\n    state.scaledPendingWithdrawals += scaledAmount;\n\n    emit WithdrawalQueued(expiry, msg.sender, scaledAmount);\n\n    // Burn as much of the withdrawal batch as possible with available liquidity.\n    uint256 availableLiquidity = batch.availableLiquidityForPendingBatch(state, totalAssets());\n    if (availableLiquidity > 0) {\n      _applyWithdrawalBatchPayment(batch, state, expiry, availableLiquidity);\n    }\n\n    // Update stored batch data\n    _withdrawalData.batches[expiry] = batch;\n\n    // Update stored state\n    _writeState(state);\n  }\n\n  /**\n   * @dev Execute a pending withdrawal request for a batch that has expired.\n   *\n   *      Withdraws the proportional amount of the paid batch owed to\n   *      `accountAddress` which has not already been withdrawn.\n   *\n   *      If `accountAddress` is sanctioned, transfers the owed amount to\n   *      an escrow contract specific to the account and blocks the account.\n   *\n   *      Reverts if:\n   *      - `expiry > block.timestamp`\n   *      -  `expiry` does not correspond to an existing withdrawal batch\n   *      - `accountAddress` has already withdrawn the full amount owed\n   */\n  function executeWithdrawal(\n    address accountAddress,\n    uint32 expiry\n  ) external nonReentrant returns (uint256) {\n    if (expiry > block.timestamp) {\n      revert WithdrawalBatchNotExpired();\n    }\n    MarketState memory state = _getUpdatedState();\n\n    WithdrawalBatch memory batch = _withdrawalData.batches[expiry];\n    AccountWithdrawalStatus storage status = _withdrawalData.accountStatuses[expiry][\n      accountAddress\n    ];\n\n    uint128 newTotalWithdrawn = uint128(\n      MathUtils.mulDiv(batch.normalizedAmountPaid, status.scaledAmount, batch.scaledTotalAmount)\n    );\n\n    uint128 normalizedAmountWithdrawn = newTotalWithdrawn - status.normalizedAmountWithdrawn;\n\n    status.normalizedAmountWithdrawn = newTotalWithdrawn;\n    state.normalizedUnclaimedWithdrawals -= normalizedAmountWithdrawn;\n\n    if (normalizedAmountWithdrawn == 0) {\n      revert NullWithdrawalAmount();\n    }\n\n    if (IWildcatSanctionsSentinel(sentinel).isSanctioned(borrower, accountAddress)) {\n      _blockAccount(state, accountAddress);\n      address escrow = IWildcatSanctionsSentinel(sentinel).createEscrow(\n        accountAddress,\n        borrower,\n        address(asset)\n      );\n      asset.safeTransfer(escrow, normalizedAmountWithdrawn);\n      emit SanctionedAccountWithdrawalSentToEscrow(\n        accountAddress,\n        escrow,\n        expiry,\n        normalizedAmountWithdrawn\n      );\n    } else {\n      asset.safeTransfer(accountAddress, normalizedAmountWithdrawn);\n    }\n\n    emit WithdrawalExecuted(expiry, accountAddress, normalizedAmountWithdrawn);\n\n    // Update stored state\n    _writeState(state);\n\n    return normalizedAmountWithdrawn;\n  }\n\n  function processUnpaidWithdrawalBatch() external nonReentrant {\n    MarketState memory state = _getUpdatedState();\n\n    // Get the next unpaid batch timestamp from storage (reverts if none)\n    uint32 expiry = _withdrawalData.unpaidBatches.first();\n\n    // Cache batch data in memory\n    WithdrawalBatch memory batch = _withdrawalData.batches[expiry];\n\n    // Calculate assets available to process the batch\n    uint256 availableLiquidity = totalAssets() -\n      (state.normalizedUnclaimedWithdrawals + state.accruedProtocolFees);\n\n    _applyWithdrawalBatchPayment(batch, state, expiry, availableLiquidity);\n\n    // Remove batch from unpaid set if fully paid\n    if (batch.scaledTotalAmount == batch.scaledAmountBurned) {\n      _withdrawalData.unpaidBatches.shift();\n      emit WithdrawalBatchClosed(expiry);\n    }\n\n    // Update stored batch\n    _withdrawalData.batches[expiry] = batch;\n    _writeState(state);\n  }\n}"
    },
    {
      "filename": "src/market/WildcatMarketWithdrawals.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport './WildcatMarketBase.sol';\nimport '../libraries/MarketState.sol';\nimport '../libraries/FeeMath.sol';\nimport '../libraries/FIFOQueue.sol';\nimport '../interfaces/IWildcatSanctionsSentinel.sol';\nimport 'solady/utils/SafeTransferLib.sol';\n\ncontract WildcatMarketWithdrawals is WildcatMarketBase {\n  using SafeTransferLib for address;\n  using MathUtils for uint256;\n  using SafeCastLib for uint256;\n  using BoolUtils for bool;\n\n  /* -------------------------------------------------------------------------- */\n  /*                             Withdrawal Queries                             */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @dev Returns the expiry timestamp of every unpaid withdrawal batch.\n   */\n  function getUnpaidBatchExpiries() external view nonReentrantView returns (uint32[] memory) {\n    return _withdrawalData.unpaidBatches.values();\n  }\n\n  function getWithdrawalBatch(\n    uint32 expiry\n  ) external view nonReentrantView returns (WithdrawalBatch memory) {\n    (, uint32 expiredBatchExpiry, WithdrawalBatch memory expiredBatch) = _calculateCurrentState();\n    if ((expiry == expiredBatchExpiry).and(expiry > 0)) {\n      return expiredBatch;\n    }\n    return _withdrawalData.batches[expiry];\n  }\n\n  function getAccountWithdrawalStatus(\n    address accountAddress,\n    uint32 expiry\n  ) external view nonReentrantView returns (AccountWithdrawalStatus memory) {\n    return _withdrawalData.accountStatuses[expiry][accountAddress];\n  }\n\n  function getAvailableWithdrawalAmount(\n    address accountAddress,\n    uint32 expiry\n  ) external view nonReentrantView returns (uint256) {\n    if (expiry > block.timestamp) {\n      revert WithdrawalBatchNotExpired();\n    }\n    (, uint32 expiredBatchExpiry, WithdrawalBatch memory expiredBatch) = _calculateCurrentState();\n    WithdrawalBatch memory batch;\n    if (expiry == expiredBatchExpiry) {\n      batch = expiredBatch;\n    } else {\n      batch = _withdrawalData.batches[expiry];\n    }\n    AccountWithdrawalStatus memory status = _withdrawalData.accountStatuses[expiry][accountAddress];\n    // Rounding errors will lead to some dust accumulating in the batch, but the cost of\n    // executing a withdrawal will be lower for users.\n    uint256 previousTotalWithdrawn = status.normalizedAmountWithdrawn;\n    uint256 newTotalWithdrawn = uint256(batch.normalizedAmountPaid).mulDiv(\n      status.scaledAmount,\n      batch.scaledTotalAmount\n    );\n    return newTotalWithdrawn - previousTotalWithdrawn;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                             Withdrawal Actions                             */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @dev Create a withdrawal request for a lender.\n   */\n  function queueWithdrawal(uint256 amount) external nonReentrant {\n    MarketState memory state = _getUpdatedState();\n\n    // Cache account data and revert if not authorized to withdraw.\n    Account memory account = _getAccountWithRole(msg.sender, AuthRole.WithdrawOnly);\n\n    uint104 scaledAmount = state.scaleAmount(amount).toUint104();\n    if (scaledAmount == 0) {\n      revert NullBurnAmount();\n    }\n\n    // Reduce caller's balance and emit transfer event.\n    account.scaledBalance -= scaledAmount;\n    _accounts[msg.sender] = account;\n    emit Transfer(msg.sender, address(this), amount);\n\n    // If there is no pending withdrawal batch, create a new one.\n    if (state.pendingWithdrawalExpiry == 0) {\n      state.pendingWithdrawalExpiry = uint32(block.timestamp + withdrawalBatchDuration);\n      emit WithdrawalBatchCreated(state.pendingWithdrawalExpiry);\n    }\n    // Cache batch expiry on the stack for gas savings.\n    uint32 expiry = state.pendingWithdrawalExpiry;\n\n    WithdrawalBatch memory batch = _withdrawalData.batches[expiry];\n\n    // Add scaled withdrawal amount to account withdrawal status, withdrawal batch and market state.\n    _withdrawalData.accountStatuses[expiry][msg.sender].scaledAmount += scaledAmount;\n    batch.scaledTotalAmount += scaledAmount;\n    state.scaledPendingWithdrawals += scaledAmount;\n\n    emit WithdrawalQueued(expiry, msg.sender, scaledAmount);\n\n    // Burn as much of the withdrawal batch as possible with available liquidity.\n    uint256 availableLiquidity = batch.availableLiquidityForPendingBatch(state, totalAssets());\n    if (availableLiquidity > 0) {\n      _applyWithdrawalBatchPayment(batch, state, expiry, availableLiquidity);\n    }\n\n    // Update stored batch data\n    _withdrawalData.batches[expiry] = batch;\n\n    // Update stored state\n    _writeState(state);\n  }\n\n  /**\n   * @dev Execute a pending withdrawal request for a batch that has expired.\n   *\n   *      Withdraws the proportional amount of the paid batch owed to\n   *      `accountAddress` which has not already been withdrawn.\n   *\n   *      If `accountAddress` is sanctioned, transfers the owed amount to\n   *      an escrow contract specific to the account and blocks the account.\n   *\n   *      Reverts if:\n   *      - `expiry > block.timestamp`\n   *      -  `expiry` does not correspond to an existing withdrawal batch\n   *      - `accountAddress` has already withdrawn the full amount owed\n   */\n  function executeWithdrawal(\n    address accountAddress,\n    uint32 expiry\n  ) external nonReentrant returns (uint256) {\n    if (expiry > block.timestamp) {\n      revert WithdrawalBatchNotExpired();\n    }\n    MarketState memory state = _getUpdatedState();\n\n    WithdrawalBatch memory batch = _withdrawalData.batches[expiry];\n    AccountWithdrawalStatus storage status = _withdrawalData.accountStatuses[expiry][\n      accountAddress\n    ];\n\n    uint128 newTotalWithdrawn = uint128(\n      MathUtils.mulDiv(batch.normalizedAmountPaid, status.scaledAmount, batch.scaledTotalAmount)\n    );\n\n    uint128 normalizedAmountWithdrawn = newTotalWithdrawn - status.normalizedAmountWithdrawn;\n\n    status.normalizedAmountWithdrawn = newTotalWithdrawn;\n    state.normalizedUnclaimedWithdrawals -= normalizedAmountWithdrawn;\n\n    if (normalizedAmountWithdrawn == 0) {\n      revert NullWithdrawalAmount();\n    }\n\n    if (IWildcatSanctionsSentinel(sentinel).isSanctioned(borrower, accountAddress)) {\n      _blockAccount(state, accountAddress);\n      address escrow = IWildcatSanctionsSentinel(sentinel).createEscrow(\n        accountAddress,\n        borrower,\n        address(asset)\n      );\n      asset.safeTransfer(escrow, normalizedAmountWithdrawn);\n      emit SanctionedAccountWithdrawalSentToEscrow(\n        accountAddress,\n        escrow,\n        expiry,\n        normalizedAmountWithdrawn\n      );\n    } else {\n      asset.safeTransfer(accountAddress, normalizedAmountWithdrawn);\n    }\n\n    emit WithdrawalExecuted(expiry, accountAddress, normalizedAmountWithdrawn);\n\n    // Update stored state\n    _writeState(state);\n\n    return normalizedAmountWithdrawn;\n  }\n\n  function processUnpaidWithdrawalBatch() external nonReentrant {\n    MarketState memory state = _getUpdatedState();\n\n    // Get the next unpaid batch timestamp from storage (reverts if none)\n    uint32 expiry = _withdrawalData.unpaidBatches.first();\n\n    // Cache batch data in memory\n    WithdrawalBatch memory batch = _withdrawalData.batches[expiry];\n\n    // Calculate assets available to process the batch\n    uint256 availableLiquidity = totalAssets() -\n      (state.normalizedUnclaimedWithdrawals + state.accruedProtocolFees);\n\n    _applyWithdrawalBatchPayment(batch, state, expiry, availableLiquidity);\n\n    // Remove batch from unpaid set if fully paid\n    if (batch.scaledTotalAmount == batch.scaledAmountBurned) {\n      _withdrawalData.unpaidBatches.shift();\n      emit WithdrawalBatchClosed(expiry);\n    }\n\n    // Update stored batch\n    _withdrawalData.batches[expiry] = batch;\n    _writeState(state);\n  }\n}"
    }
  ]
}