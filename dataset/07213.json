{
  "Title": "[G-16] Reorder the require statements to have the less gas consuming before the expensive one",
  "Content": "https://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/cash/kyc/KYCRegistry.sol#L79-L112<br>\n**Save 225 gas on average**\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 752    | 23892   | 34436 | 41128 |\n| After  | 690    | 23667   | 34436 | 41128 |\n\n```solidity\nFile: /contracts/cash/kyc/KYCRegistry.sol\n79: function addKYCAddressViaSignature(\n80:    uint256 kycRequirementGroup,\n81:    address user,\n82:    uint256 deadline,\n83:    uint8 v,\n84:    bytes32 r,\n85:    bytes32 s\n86:  ) external {\n87:    require(v == 27 || v == 28, \"KYCRegistry: invalid v value in signature\");\n88:    require(\n89:      !kycState[kycRequirementGroup][user],\n90:      \"KYCRegistry: user already verified\"\n91:    );\n92:    require(block.timestamp <= deadline, \"KYCRegistry: signature expired\");\n```\n\nIts cheaper to check for `block.timestamp <= deadline` as compared to `!kycState\\[kycRequirementGroup]\\[user]` as this involves reading the storage variable. Therefore if the `require(block.timestamp <= deadline, \"KYCRegistry: signature expired\");` fails it would be cheaper to fail before evaluating the `!kycState\\[kycRequirementGroup]\\[user]`\n\n\n```diff\ndiff --git a/contracts/cash/kyc/KYCRegistry.sol b/contracts/cash/kyc/KYCRegistry.sol\nindex 896c727..d5401df 100644\n--- a/contracts/cash/kyc/KYCRegistry.sol\n+++ b/contracts/cash/kyc/KYCRegistry.sol\n@@ -85,11 +85,12 @@ contract KYCRegistry is AccessControlEnumerable, IKYCRegistry, EIP712 {\n     bytes32 s\n   ) external {\n     require(v == 27 || v == 28, \"KYCRegistry: invalid v value in signature\");\n+    require(block.timestamp <= deadline, \"KYCRegistry: signature expired\");\n+\n     require(\n       !kycState[kycRequirementGroup][user],\n       \"KYCRegistry: user already verified\"\n     );\n-    require(block.timestamp <= deadline, \"KYCRegistry: signature expired\");\n     bytes32 structHash = keccak256(\n       abi.encode(_APPROVAL_TYPEHASH, kycRequirementGroup, user, deadline)\n     );\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2023-01-ondo-finance-contest",
  "Code": [
    {
      "filename": "contracts/cash/kyc/KYCRegistry.sol",
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/cash/interfaces/IKYCRegistry.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"contracts/cash/external/chainalysis/ISanctionsList.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/utils/cryptography/EIP712.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n/**\n * @title KYCRegistry\n * @author Ondo Finance\n * @notice This contract manages KYC status for addresses that interact with\n *         Ondo products.\n */\ncontract KYCRegistry is AccessControlEnumerable, IKYCRegistry, EIP712 {\n  bytes32 public constant _APPROVAL_TYPEHASH =\n    keccak256(\n      \"KYCApproval(uint256 kycRequirementGroup,address user,uint256 deadline)\"\n    );\n  // Admin role that has permission to add/remove KYC related roles\n  bytes32 public constant REGISTRY_ADMIN = keccak256(\"REGISTRY_ADMIN\");\n\n  // {<KYCLevel> => {<user account address> => is user KYC approved}\n  mapping(uint256 => mapping(address => bool)) public kycState;\n\n  // Represents which roles msg.sender must have in order to change\n  // KYC state at that group.\n  /// @dev Default admin role of 0x00... will be able to set all group roles\n  ///      that are unset.\n  mapping(uint256 => bytes32) public kycGroupRoles;\n\n  // Chainalysis sanctions list\n  ISanctionsList public immutable sanctionsList;\n\n  /// @notice constructor\n  constructor(\n    address admin,\n    address _sanctionsList\n  ) EIP712(\"OndoKYCRegistry\", \"1\") {\n    _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    _grantRole(REGISTRY_ADMIN, admin);\n    sanctionsList = ISanctionsList(_sanctionsList);\n  }\n\n  /**\n   * @notice Add a provided user to the registry at a specified\n   *         `kycRequirementGroup`. In order to sucessfully call this function,\n   *         An external caller must provide a signature signed by an address\n   *         with the role `kycGroupRoles[kycRequirementGroup]`.\n   *\n   * @param kycRequirementGroup KYC requirement group to modify `user`'s\n   *                            KYC status for\n   * @param user                User address to change KYC status for\n   * @param deadline            Deadline for which the signature-auth based\n   *                            operations with the signature become invalid\n   * @param v                   Recovery ID (See EIP 155)\n   * @param r                   Part of ECDSA signature representation\n   * @param s                   Part of ECDSA signature representation\n   *\n   * @dev Please note that ecrecover (which the Registry uses) requires V be\n   *      27 or 28, so a conversion must be applied before interacting with\n   *      `addKYCAddressViaSignature`\n   */\n  function addKYCAddressViaSignature(\n    uint256 kycRequirementGroup,\n    address user,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    require(v == 27 || v == 28, \"KYCRegistry: invalid v value in signature\");\n    require(\n      !kycState[kycRequirementGroup][user],\n      \"KYCRegistry: user already verified\"\n    );\n    require(block.timestamp <= deadline, \"KYCRegistry: signature expired\");\n    bytes32 structHash = keccak256(\n      abi.encode(_APPROVAL_TYPEHASH, kycRequirementGroup, user, deadline)\n    );\n    // https://eips.ethereum.org/EIPS/eip-712 compliant\n    bytes32 expectedMessage = _hashTypedDataV4(structHash);\n\n    // `ECDSA.recover` reverts if signer is address(0)\n    address signer = ECDSA.recover(expectedMessage, v, r, s);\n    _checkRole(kycGroupRoles[kycRequirementGroup], signer);\n\n    kycState[kycRequirementGroup][user] = true;\n\n    emit KYCAddressAddViaSignature(\n      msg.sender,\n      user,\n      signer,\n      kycRequirementGroup,\n      deadline\n    );\n  }\n\n  /// @notice Getter for EIP 712 Domain separator.\n  function DOMAIN_SEPARATOR() external view returns (bytes32) {\n    return _domainSeparatorV4();\n  }\n\n  /**\n   * @notice Get KYC status of `account` for the provided\n   *         `kycRequirementGroup`. In order to return true, `account`'s state\n   *         in this contract must be true and additionally pass a\n   *         `sanctionsList` check.\n   *\n   * @param kycRequirementGroup KYC group to check KYC status for\n   * @param account             Addresses to check KYC status for\n   */\n  function getKYCStatus(\n    uint256 kycRequirementGroup,\n    address account\n  ) external view override returns (bool) {\n    return\n      kycState[kycRequirementGroup][account] &&\n      !sanctionsList.isSanctioned(account);\n  }\n\n  /**\n   * @notice Assigns a role to specified `kycRequirementGroup` to gate changes\n   *         to that group's KYC state\n   *\n   * @param kycRequirementGroup KYC group to set role for\n   * @param role                The role being assigned to a group\n   */\n  function assignRoletoKYCGroup(\n    uint256 kycRequirementGroup,\n    bytes32 role\n  ) external onlyRole(REGISTRY_ADMIN) {\n    kycGroupRoles[kycRequirementGroup] = role;\n    emit RoleAssignedToKYCGroup(kycRequirementGroup, role);\n  }\n\n  /**\n   * @notice Add addresses to KYC list for specified `kycRequirementGroup`\n   *\n   * @param kycRequirementGroup KYC group associated with `addresses`\n   * @param addresses           List of addresses to grant KYC'd status\n   */\n  function addKYCAddresses(\n    uint256 kycRequirementGroup,\n    address[] calldata addresses\n  ) external onlyRole(kycGroupRoles[kycRequirementGroup]) {\n    uint256 length = addresses.length;\n    for (uint256 i = 0; i < length; i++) {\n      kycState[kycRequirementGroup][addresses[i]] = true;\n    }\n    emit KYCAddressesAdded(msg.sender, kycRequirementGroup, addresses);\n  }\n\n  /**\n   * @notice Remove addresses from KYC list\n   *\n   * @param kycRequirementGroup KYC group associated with `addresses`\n   * @param addresses           List of addresses to revoke KYC'd status\n   */\n  function removeKYCAddresses(\n    uint256 kycRequirementGroup,\n    address[] calldata addresses\n  ) external onlyRole(kycGroupRoles[kycRequirementGroup]) {\n    uint256 length = addresses.length;\n    for (uint256 i = 0; i < length; i++) {\n      kycState[kycRequirementGroup][addresses[i]] = false;\n    }\n    emit KYCAddressesRemoved(msg.sender, kycRequirementGroup, addresses);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                        Events\n  //////////////////////////////////////////////////////////////*/\n  /**\n   * @dev Event emitted when a role is assigned to a KYC group\n   *\n   * @param kycRequirementGroup The KYC group\n   * @param role                The role being assigned\n   */\n  event RoleAssignedToKYCGroup(\n    uint256 indexed kycRequirementGroup,\n    bytes32 indexed role\n  );\n\n  /**\n   * @dev Event emitted when addresses are added to KYC requirement group\n   *\n   * @param sender              Sender of the transaction\n   * @param kycRequirementGroup KYC requirement group being updated\n   * @param addresses           Array of addresses being added as elligible\n   */\n  event KYCAddressesAdded(\n    address indexed sender,\n    uint256 indexed kycRequirementGroup,\n    address[] addresses\n  );\n\n  /**\n   * @dev Event emitted when a user is added to the KYCRegistry\n   *      by an external caller through signature-auth\n   *\n   * @param sender              Sender of the transaction\n   * @param user                User being added to registry\n   * @param signer              Digest signer\n   * @param kycRequirementGroup KYC requirement group being updated\n   * @param deadline            Expiration constraint on signature\n   */\n  event KYCAddressAddViaSignature(\n    address indexed sender,\n    address indexed user,\n    address indexed signer,\n    uint256 kycRequirementGroup,\n    uint256 deadline\n  );\n\n  /**\n   * @dev Event emitted when addresses are removed from KYC requirement group\n   *\n   * @param sender              Sender of the transaction\n   * @param kycRequirementGroup KYC requirement group being updated\n   * @param addresses           Array of addresses being added as elligible\n   */\n  event KYCAddressesRemoved(\n    address indexed sender,\n    uint256 indexed kycRequirementGroup,\n    address[] addresses\n  );\n}"
    }
  ]
}