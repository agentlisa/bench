{
  "Title": "[M-23] StakingRewards pools are not given their promised share of rewards due to incorrect calculation",
  "Content": "\n[RewardsEmitter::performUpkeep()](https://github.com/code-423n4/2024-01-salty/blob/main/src/rewards/RewardsEmitter.sol#L82) distributes the added rewards to the eligible staking pools at the rate of `X%` per day (default value set to 1% by the protocol). To ensure that once disbursed, it is not sent again, the code reduces the `pendingRewards[poolID]` variable on [L126](https://github.com/code-423n4/2024-01-salty/blob/main/src/rewards/RewardsEmitter.sol#L126):\n\n```js\n120\t\t\t// Each pool will send a percentage of the pending rewards based on the time elapsed since the last send\n121\t\t\tuint256 amountToAddForPool = ( pendingRewards[poolID] * numeratorMult ) / denominatorMult;\n122\n123\t\t\t// Reduce the pending rewards so they are not sent again\n124\t\t\tif ( amountToAddForPool != 0 )\n125\t\t\t\t{\n126\t\t\t\tpendingRewards[poolID] -= amountToAddForPool;\n127\n128\t\t\t\tsum += amountToAddForPool;\n129\t\t\t\t}\n```\n\nThe impact of this is: ***higher the number of times performUpkeep() is called, lesser the rewards per day is distributed to the pools.*** That is, calling it 100 times a day is worse than calling it once at the end of the day. This is at odds with how the protocol wants to achieve a higher frequency of upkeep-ing. <br>\n\nReasoning:<br>\nThis above code logic is incorrect maths as doing this will result in the following scenario:\n\n*   Suppose that on Day0, the `addedRewards = 10 ether` and `rewardsEmitterDailyPercentTimes1000 = 2500` i.e. 2.5% per day. One would expect all rewards to be distributed to the pool after 40 days (since 2.5% \\* 40 = 100%).\n*   On Day1, `performUpkeep()` gets called. `amountToAddForPool` and `pendingRewards[poolID]` are calculated on L121 & L126 respectively as:\n    *   `amountToAddForPool = 0.025 * 10 ether = 0.25 ether`\n    *   `pendingRewards[poolID] = 10 ether - 0.25 ether = 9.75 ether`\n*   On Day2, `performUpkeep()` gets called again. `amountToAddForPool` and `pendingRewards[poolID]` are calculated now as:\n    *   `amountToAddForPool = 0.025 * 9.75 ether = 0.24375 ether`\n    *   `pendingRewards[poolID] = 9.75 ether - 0.24375 ether = 9.50625 ether`\n\nSo on and so forth for each new day. The actual formula being followed is `totalRewardsStillRemainingAfterXdays = 10 ether * (1 - 2.5%)**X` which would be `3632324398878806621` or `3.63232 ether` after 40 days. In fact, even after another 40 days, it's still not all paid out. Please refer the ***\"Proof of Concept - 1\"*** provided below. In fact, since this is a classic negative compounding formula ( $Amount = Principle \\* (1 - rate)^{time}$ ), no matter how many days pass, all the rewards would never be distributed and dust would always remain in the contract.\n\n### Further Evidence & Impact\n\nTo remove any doubts regarding the interpretation of the `1% per day rate` and if indeed the current implementation is as intended or not, one can look at the following calculation provided in the comments:<br>\n[StakingRewards.sol#L178-L181](https://github.com/code-423n4/2024-01-salty/blob/main/src/staking/StakingRewards.sol#L178-L181)\n\n```js\n\t// 3. Rewards are first placed into a RewardsEmitter which deposits rewards via addSALTRewards at the default rate of 1% per day.\n\t// 4. Rewards are deposited fairly often, with outstanding rewards being transferred with a frequency proportional to the activity of the exchange.\n\t// Example: if $100k rewards were being deposited in a bulk transaction, it would only equate to $1000 (1%) the first day,\n\t// or $10 in claimable rewards during a 15 minute upkeep period.\n```\n\nLet's crunch the above numbers:\n\n*   The comment says, `\"$100K rewards would equate to $1000 (1%) the first day\"` **OR** \"`$10 claimable rewards`\" when upkeep() is called every 15 minutes.\n*   This conclusion could have been arrived at by the protocol only when the reward of `$1000` (over 24 hours) is divided equally for each 15 minutes i.e. `$1000 / (24 * 60 / 15)` equalling `$10` (rounded-down).\n\nThis is certainly not the case currently as can be seen in the ***\"Proof of Concept - 2\"***. <br><br>\n\n**Note** that this means that per day much lesser rewards than 1% are distributed if `performUpkeep()` is called every 15 minutes instead of once after 24 hours. A malicious actor can use this to grief the protocol and delay/diminish emissions. The power of negative compunding causes this and can be seen in the second PoC.\n\n### Proof of Concept - 1\n\nAdd the following test inside `src/rewards/tests/RewardsEmitter.t.sol` and run via `COVERAGE=\"yes\" NETWORK=\"sep\" forge test -vv --rpc-url https://rpc.ankr.com/eth_sepolia --mt test_allPendingRewardsNeverPaidOut` to see the two assertions fail. The value of `rewardsEmitterDailyPercentTimes1000` in the test is 2.5% per day.<br>\n\n<Details>\n\n```js\n    function test_allPendingRewardsNeverPaidOut() public {\n\n        // Add some pending rewards to the pools\n        AddedReward[] memory addedRewards = new AddedReward[](1);\n        addedRewards[0] = AddedReward({poolID: poolIDs[0], amountToAdd: 10 ether});\n        liquidityRewardsEmitter.addSALTRewards(addedRewards);\n\n        // Verify that the rewards were added\n        assertEq(pendingLiquidityRewardsForPool(poolIDs[0]), 10 ether);\n\n        // Call performUpkeep\n        vm.startPrank(address(upkeep));\n        for (uint256 i; i < 40; ++i)\n            liquidityRewardsEmitter.performUpkeep(1 days);\n        vm.stopPrank();\n\n        // Verify that the correct amount of rewards were deducted from each pool's pending rewards\n        // 2.5% of the rewards should be deducted per day, so all rewards should be paid out after the 40 days' iteration above\n        assertEq(pendingLiquidityRewardsForPool(poolIDs[0]), 0 ether, \"not all reward distributed\");\n\n\n        // Let's try 40 times more, just to confirm the behaviour and see if ever all the rewards are paid out\n        vm.startPrank(address(upkeep));\n        for (uint256 i; i < 40; ++i)\n            liquidityRewardsEmitter.performUpkeep(1 days);\n        vm.stopPrank();\n        assertEq(pendingLiquidityRewardsForPool(poolIDs[0]), 0 ether, \"nope, not even now\");\n    }\n```\n\nOutput:\n\n```text\n[FAIL. Reason: assertion failed] test_allPendingRewardsNeverPaidOut() (gas: 5441491)\nLogs:\n  Error: not all reward distributed\n  Error: a == b not satisfied [uint]\n        Left: 3632324398878806621\n       Right: 0\n  Error: nope, not even now\n  Error: a == b not satisfied [uint]\n        Left: 1319378053869028394\n       Right: 0\n```\n\n</details>\n\n### Proof of Concept - 2\n\nAdd the following test inside `src/rewards/tests/RewardsEmitter.t.sol` and run via `COVERAGE=\"yes\" NETWORK=\"sep\" forge test -vv --rpc-url https://rpc.ankr.com/eth_sepolia --mt test_perDayDefaultRateNotAdheredTo` to see last assertion fail. The value of `rewardsEmitterDailyPercentTimes1000` in the test is 1% per day and `upkeep()` is called every 15 minutes.<br>\n**We observe that by the end of the day, `4931 ethers` less is disbursed than expected.**\n\n<details>\n\n```js\n    function test_perDayDefaultRateNotAdheredTo() public {\n        // set daily rate to 1%\n        vm.startPrank(address(dao));\n\t\tfor ( uint256 i = 0; i < 6; i++ )\n\t\t\trewardsConfig.changeRewardsEmitterDailyPercent(false);\n\t\tvm.stopPrank();\n        assertEq(rewardsConfig.rewardsEmitterDailyPercentTimes1000(), 1000);\n\n        // Add some pending rewards to the pools\n        deal(address(salt), address(this), 100_000_000 ether);\n        AddedReward[] memory addedRewards = new AddedReward[](1);\n        addedRewards[0] = AddedReward({poolID: poolIDs[0], amountToAdd: 100_000_000 ether});\n        liquidityRewardsEmitter.addSALTRewards(addedRewards);\n        // Verify that the rewards were added\n        assertEq(pendingLiquidityRewardsForPool(poolIDs[0]), 100_000_000 ether);\n\n        // Call performUpkeep every 15 minutes for a full day\n        uint256 totalDisbursed = 0;\n        uint256 disbursedInLast15Mins = pendingLiquidityRewardsForPool(poolIDs[0]);\n        console.log(\"Time Lapsed ( in mins)        |       Reward emiited in last 15 mins      |       Total reward emitted\");\n        vm.startPrank(address(upkeep));\n        for (uint256 i; i < 24 * 4; ++i) {\n            liquidityRewardsEmitter.performUpkeep(15 minutes);\n            uint256 diff = disbursedInLast15Mins - pendingLiquidityRewardsForPool(poolIDs[0]);\n            totalDisbursed += diff;\n            console.log(\"%s                        |          %s         |          %s\", (i+1)*15, diff, totalDisbursed); \n            disbursedInLast15Mins = pendingLiquidityRewardsForPool(poolIDs[0]);\n        }\n        vm.stopPrank();\n\n        // Verify that the correct amount of rewards were deducted from each pool's pending rewards\n        // 1% of the rewards should be deducted per day\n        assertEq(pendingLiquidityRewardsForPool(poolIDs[0]), 99_000_000 ether, \"1% per day not adhered to\");\n    }\n```\n\nOutput:\n\n```text\n[FAIL. Reason: assertion failed] test_perDayDefaultRateNotAdheredTo() (gas: 7243619)\nLogs:\n  Time Lapsed ( in mins)        |       Reward emiited in last 15 mins      |       Total reward emitted\n  15                        |          10416666666666666666666         |          10416666666666666666666\n  30                        |          10415581597222222222222         |          20832248263888888888888\n  45                        |          10414496640805844907407         |          31246744904694733796295\n  60                        |          10413411797405760965229         |          41660156702100494761524\n  75                        |          10412327067010197865129         |          52072483769110692626653\n  90                        |          10411242449607384302851         |          62483726218718076929504\n  105                        |          10410157945185550200319         |          72893884163903627129823\n  120                        |          10409073553732926705507         |          83302957717636553835330\n  135                        |          10407989275237746192308         |          93710946992874300027638\n  150                        |          10406905109688242260413         |          104117852102562542288051\n  165                        |          10405821057072649735178         |          114523673159635192023229\n  180                        |          10404737117379204667497         |          124928410277014396690726\n  195                        |          10403653290596144333678         |          135332063567610541024404\n  210                        |          10402569576711707235309         |          145734633144322248259713\n  225                        |          10401485975714133099139         |          156136119120036381358852\n  240                        |          10400402487591662876941         |          166536521607628044235793\n  255                        |          10399319112332538745392         |          176935840719960582981185\n  270                        |          10398235849925004105939         |          187334076569885587087124\n  285                        |          10397152700357303584678         |          197731229270242890671802\n  300                        |          10396069663617683032221         |          208127298933860573704023\n  315                        |          10394986739694389523572         |          218522285673554963227595\n  330                        |          10393903928575671357997         |          228916189602130634585592\n  345                        |          10392821230249778058897         |          239309010832380412644489\n  360                        |          10391738644704960373682         |          249700749477085373018171\n  375                        |          10390656171929470273643         |          260091405649014843291814\n  390                        |          10389573811911560953823         |          270480979460926404245637\n  405                        |          10388491564639486832891         |          280869471025565891078528\n  420                        |          10387409430101503553012         |          291256880455667394631540\n  435                        |          10386327408285867979725         |          301643207863953262611265\n  450                        |          10385245499180838201811         |          312028453363134100813076\n  465                        |          10384163702774673531165         |          322412617065908774344241\n  480                        |          10383082019055634502672         |          332795699084964408846913\n  495                        |          10382000448011982874078         |          343177699532976391720991\n  510                        |          10380918989631981625862         |          353558618522608373346853\n  525                        |          10379837643903894961109         |          363938456166512268307962\n  540                        |          10378756410815988305384         |          374317212577328256613346\n  555                        |          10377675290356528306602         |          384694887867684784919948\n  570                        |          10376594282513782834904         |          395071482150198567754852\n  585                        |          10375513387276020982525         |          405446995537474588737377\n  600                        |          10374432604631513063673         |          415821428142106101801050\n  615                        |          10373351934568530614395         |          426194780076674632415445\n  630                        |          10372271377075346392456         |          436567051453749978807901\n  645                        |          10371190932140234377207         |          446938242385890213185108\n  660                        |          10370110599751469769459         |          457308352985641682954567\n  675                        |          10369030379897328991358         |          467677383365539011945925\n  690                        |          10367950272566089686255         |          478045333638105101632180\n  705                        |          10366870277746030718579         |          488412203915851132350759\n  720                        |          10365790395425432173713         |          498777994311276564524472\n  735                        |          10364710625592575357862         |          509142704936869139882334\n  750                        |          10363630968235742797928         |          519506335905104882680262\n  765                        |          10362551423343218241387         |          529868887328448100921649\n  780                        |          10361471990903286656153         |          540230359319351387577802\n  795                        |          10360392670904234230460         |          550590751990255621808262\n  810                        |          10359313463334348372728         |          560950065453589970180990\n  825                        |          10358234368181917711439         |          571308299821771887892429\n  840                        |          10357155385435232095011         |          581665455207207119987440\n  855                        |          10356076515082582591667         |          592021531722289702579107\n  870                        |          10354997757112261489314         |          602376529479401964068421\n  885                        |          10353919111512562295409         |          612730448590914526363830\n  900                        |          10352840578271779736837         |          623083289169186306100667\n  915                        |          10351762157378209759781         |          633435051326564515860448\n  930                        |          10350683848820149529597         |          643785735175384665390045\n  945                        |          10349605652585897430688         |          654135340827970562820733\n  960                        |          10348527568663753066372         |          664483868396634315887105\n  975                        |          10347449597042017258761         |          674831317993676333145866\n  990                        |          10346371737708992048630         |          685177689731385325194496\n  1005                        |          10345293990652980695292         |          695522983722038305889788\n  1020                        |          10344216355862287676469         |          705867200077900593566257\n  1035                        |          10343138833325218688170         |          716210338911225812254427\n  1050                        |          10342061423030080644556         |          726552400334255892898983\n  1065                        |          10340984124965181677823         |          736893384459221074576806\n  1080                        |          10339906939118831138064         |          747233291398339905714870\n  1095                        |          10338829865479339593154         |          757572121263819245308024\n  1110                        |          10337752904035018828613         |          767909874167854264136637\n  1125                        |          10336676054774181847485         |          778246550222628445984122\n  1140                        |          10335599317685142870209         |          788582149540313588854331\n  1155                        |          10334522692756217334494         |          798916672233069806188825\n  1170                        |          10333446179975721895188         |          809250118413045528084013\n  1185                        |          10332369779331974424157         |          819582488192377502508170\n  1200                        |          10331293490813294010155         |          829913781683190796518325\n  1215                        |          10330217314408000958696         |          840243998997598797477021\n  1230                        |          10329141250104416791929         |          850573140247703214268950\n  1245                        |          10328065297890864248513         |          860901205545594078517463\n  1260                        |          10326989457755667283487         |          871228195003349745800950\n  1275                        |          10325913729687151068145         |          881554108733036896869095\n  1290                        |          10324838113673641989909         |          891878946846710538859004\n  1305                        |          10323762609703467652202         |          902202709456414006511206\n  1320                        |          10322687217764956874321         |          912525396674178963385527\n  1335                        |          10321611937846439691314         |          922847008612025403076841\n  1350                        |          10320536769936247353846         |          933167545381961650430687\n  1365                        |          10319461714022712328080         |          943487007095984362758767\n  1380                        |          10318386770094168295545         |          953805393866078531054312\n  1395                        |          10317311938138950153015         |          964122705804217481207327\n  1410                        |          10316237218145394012374         |          974438943022362875219701\n  1425                        |          10315162610101837200497         |          984754105632464712420198\n  1440                        |          10314088113996618259122         |          995068193746461330679320\n  Error: 1% per day not adhered to\n  Error: a == b not satisfied [uint]\n        Left: 99004931806253538669320680\n       Right: 99000000000000000000000000\n```\n\n</details>\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nStore the eligible pool reward & the already paid out reward in separate variables and compare them to make sure extra rewards are not being paid out to a pool.\nIrrespective of the `performUpkeep()` calling frequency, at the end of the day, 1% should be disbursed.\n\n\n**[Picodes (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-01-salty-findings/issues/243#issuecomment-1956839550):**\n > Medium severity seems more appropriate considering this only concerns rewards and is subject to external conditions.\n\n**[othernet-global (Salty.IO) acknowledged](https://github.com/code-423n4/2024-01-salty-findings/issues/243#issuecomment-1960670620)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-salty",
  "Code": [
    {
      "filename": "src/rewards/RewardsEmitter.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"../rewards/interfaces/IRewardsConfig.sol\";\nimport \"../pools/interfaces/IPoolsConfig.sol\";\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"./interfaces/IRewardsEmitter.sol\";\nimport \"../interfaces/ISalt.sol\";\nimport \"../pools/PoolUtils.sol\";\n\n\n// Stores SALT rewards for later distribution at a default rate of 1% per day to those holding shares in the specified StakingRewards contract.\n// The gradual emissions rate is to help offset natural rewards fluctuation and create a more stable yield.\n// This also creates an easy mechanism to see what the current yield is for any pool as the emitter acts like an exponential average of the incoming SALT rewards.\n// There will be two deplyed RewardsEmitters:\n// Staking.sol - allows users to stake SALT to acquire xSALT and distributes rewards to Staking.sol\n// Liquidity.sol - allows liquidity providers to deposit and stake collateralAndLiquidity and distributes rewards to CollateralAndLiquidity.sol.\ncontract RewardsEmitter is IRewardsEmitter, ReentrancyGuard\n    {\n\tusing SafeERC20 for ISalt;\n\n\tIStakingRewards immutable public stakingRewards;\n\tIExchangeConfig immutable public exchangeConfig;\n\tIPoolsConfig immutable public poolsConfig;\n\tIRewardsConfig immutable public rewardsConfig;\n\tISalt immutable public salt;\n   \tbool immutable isForCollateralAndLiquidity;\n\n\tuint256 constant public MAX_TIME_SINCE_LAST_UPKEEP = 1 days;\n\n    // The stored SALT rewards by poolID that need to be distributed to the specified StakingRewards.sol contract.\n    // Only a percentage of these will be distributed per day (interpolated to a default of 1% per day).\n   \tmapping(bytes32=>uint256) public pendingRewards;\n\n\n\n    constructor( IStakingRewards _stakingRewards, IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig, IRewardsConfig _rewardsConfig, bool _isForCollateralAndLiquidity )\n\t\t{\n\t\tstakingRewards = _stakingRewards;\n\t\texchangeConfig = _exchangeConfig;\n\t\tpoolsConfig = _poolsConfig;\n\t\trewardsConfig = _rewardsConfig;\n\t\tisForCollateralAndLiquidity = _isForCollateralAndLiquidity;\n\n\t\tsalt = _exchangeConfig.salt();\n\n\t\t// Save gas for later reward distribution by approving in advance\n\t\tsalt.approve(address(stakingRewards), type(uint256).max);\n\t\t}\n\n\n\t// Add SALT rewards for later distribution to the specified whitelisted pools.\n\t// Specified SALT rewards are transfered from the sender.\n\t// Requires that rewarded pools are whitelisted.\n\tfunction addSALTRewards( AddedReward[] calldata addedRewards ) external nonReentrant\n\t\t{\n\t\tuint256 sum = 0;\n\t\tfor( uint256 i = 0; i < addedRewards.length; i++ )\n\t\t\t{\n\t\t\tAddedReward memory addedReward = addedRewards[i];\n\t\t\trequire( poolsConfig.isWhitelisted( addedReward.poolID ), \"Invalid pool\" );\n\n\t\t\tuint256 amountToAdd = addedReward.amountToAdd;\n\t\t\tif ( amountToAdd != 0 )\n\t\t\t\t{\n\t\t\t\t// Update pendingRewards so the SALT can be distributed later\n\t\t\t\tpendingRewards[ addedReward.poolID ] += amountToAdd;\n\t\t\t\tsum += amountToAdd;\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Transfer the SALT from the sender for all of the specified rewards\n\t\tif ( sum > 0 )\n\t\t\tsalt.safeTransferFrom( msg.sender, address(this), sum );\n\t\t}\n\n\n\t// Transfer a percent (default 1% per day) of the currently held rewards to the specified StakingRewards pools.\n\t// The percentage to transfer is interpolated from how long it's been since the last performUpkeep().\n\tfunction performUpkeep( uint256 timeSinceLastUpkeep ) external\n\t\t{\n\t\trequire( msg.sender == address(exchangeConfig.upkeep()), \"RewardsEmitter.performUpkeep is only callable from the Upkeep contract\" );\n\n\t\tif ( timeSinceLastUpkeep == 0 )\n\t\t\treturn;\n\n\t\tbytes32[] memory poolIDs;\n\n\t\t if ( isForCollateralAndLiquidity )\n\t\t \t{\n\t\t \t// For the liquidityRewardsEmitter, all pools can receive rewards\n\t\t\tpoolIDs = poolsConfig.whitelistedPools();\n\t\t\t}\n\t\t else\n\t\t \t{\n\t\t \t// The stakingRewardsEmitter only distributes rewards to those that have staked SALT\n\t\t \tpoolIDs = new bytes32[](1);\n\t\t \tpoolIDs[0] = PoolUtils.STAKED_SALT;\n\t\t \t}\n\n\t\t// Cap the timeSinceLastUpkeep at one day (if for some reason it has been longer).\n\t\t// This will cap the emitted rewards at a default of 1% in this transaction.\n\t\tif ( timeSinceLastUpkeep >= MAX_TIME_SINCE_LAST_UPKEEP )\n        \ttimeSinceLastUpkeep = MAX_TIME_SINCE_LAST_UPKEEP;\n\n\t\t// These are the AddedRewards that will be sent to the specified StakingRewards contract\n\t\tAddedReward[] memory addedRewards = new AddedReward[]( poolIDs.length );\n\n\t\t// Rewards to emit = pendingRewards * timeSinceLastUpkeep * rewardsEmitterDailyPercent / oneDay\n\t\tuint256 numeratorMult = timeSinceLastUpkeep * rewardsConfig.rewardsEmitterDailyPercentTimes1000();\n\t\tuint256 denominatorMult = 1 days * 100000; // simplification of numberSecondsInOneDay * (100 percent) * 1000\n\n\t\tuint256 sum = 0;\n\t\tfor( uint256 i = 0; i < poolIDs.length; i++ )\n\t\t\t{\n\t\t\tbytes32 poolID = poolIDs[i];\n\n\t\t\t// Each pool will send a percentage of the pending rewards based on the time elapsed since the last send\n\t\t\tuint256 amountToAddForPool = ( pendingRewards[poolID] * numeratorMult ) / denominatorMult;\n\n\t\t\t// Reduce the pending rewards so they are not sent again\n\t\t\tif ( amountToAddForPool != 0 )\n\t\t\t\t{\n\t\t\t\tpendingRewards[poolID] -= amountToAddForPool;\n\n\t\t\t\tsum += amountToAddForPool;\n\t\t\t\t}\n\n\t\t\t// Specify the rewards that will be added for the specific pool\n\t\t\taddedRewards[i] = AddedReward( poolID, amountToAddForPool );\n\t\t\t}\n\n\t\t// Add the rewards so that they can later be claimed by the users proportional to their share of the StakingRewards derived contract.\n\t\tstakingRewards.addSALTRewards( addedRewards );\n\t\t}\n\n\n\t// === VIEWS ===\n\n\tfunction pendingRewardsForPools( bytes32[] calldata pools ) external view returns (uint256[] memory)\n\t\t{\n\t\tuint256[] memory rewards = new uint256[]( pools.length );\n\n\t\tfor( uint256 i = 0; i < rewards.length; i++ )\n\t\t\trewards[i] = pendingRewards[ pools[i] ];\n\n\t\treturn rewards;\n\t\t}\n\t}"
    },
    {
      "filename": "src/staking/StakingRewards.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport \"../pools/interfaces/IPoolsConfig.sol\";\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"./interfaces/IStakingRewards.sol\";\nimport \"./interfaces/IStakingConfig.sol\";\nimport \"../interfaces/ISalt.sol\";\n\n// This contract allows users to receive rewards (as SALT tokens) for staking SALT or liquidity shares.\n// A user's reward is proportional to their share of the stake and is based on their share at the time that rewards are added.\n//\n// What staked shares represent is specific to the contracts that derive from StakingRewards.\n//\n// 1. Staking.sol: shares represent the amount of SALT staked (staked to the STAKED_SALT pool)\n// 2. Liquidity.sol: shares represent the amount of liquidity deposited and staked to specific pools\n\nabstract contract StakingRewards is IStakingRewards, ReentrancyGuard\n    {\n\tevent UserShareIncreased(address indexed wallet, bytes32 indexed poolID, uint256 amountIncreased);\n\tevent UserShareDecreased(address indexed wallet, bytes32 indexed poolID, uint256 amountDecreased, uint256 claimedRewards);\n\tevent RewardsClaimed(address indexed wallet, uint256 claimedRewards);\n\tevent SaltRewardsAdded(bytes32 indexed poolID, uint256 amountAdded);\n\n\tusing SafeERC20 for ISalt;\n\n\tISalt immutable public salt;\n\tIExchangeConfig immutable public exchangeConfig;\n    IStakingConfig immutable public stakingConfig;\n    IPoolsConfig immutable public poolsConfig;\n\n\t// A nested mapping that stores the UserShareInfo data for each user and each poolID.\n\tmapping(address=>mapping(bytes32=>UserShareInfo)) private _userShareInfo;\n\n    // A mapping that stores the total pending SALT rewards for each poolID.\n    mapping(bytes32=>uint256) public totalRewards;\n\n    // A mapping that stores the total shares for each poolID.\n    mapping(bytes32=>uint256) public totalShares;\n\n\n\t// Constructs a new StakingRewards contract with providing configs\n \tconstructor( IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig, IStakingConfig _stakingConfig )\n\t\t{\n\t\texchangeConfig = _exchangeConfig;\n    \tpoolsConfig = _poolsConfig;\n\t\tstakingConfig = _stakingConfig;\n\n\t\tsalt = _exchangeConfig.salt(); // cached for efficiency\n        }\n\n\n\t// Increase a user's share for the given whitelisted pool.\n\tfunction _increaseUserShare( address wallet, bytes32 poolID, uint256 increaseShareAmount, bool useCooldown ) internal\n\t\t{\n\t\trequire( poolsConfig.isWhitelisted( poolID ), \"Invalid pool\" );\n\t\trequire( increaseShareAmount != 0, \"Cannot increase zero share\" );\n\n\t\tUserShareInfo storage user = _userShareInfo[wallet][poolID];\n\n\t\tif ( useCooldown )\n\t\tif ( msg.sender != address(exchangeConfig.dao()) ) // DAO doesn't use the cooldown\n\t\t\t{\n\t\t\trequire( block.timestamp >= user.cooldownExpiration, \"Must wait for the cooldown to expire\" );\n\n\t\t\t// Update the cooldown expiration for future transactions\n\t\t\tuser.cooldownExpiration = block.timestamp + stakingConfig.modificationCooldown();\n\t\t\t}\n\n\t\tuint256 existingTotalShares = totalShares[poolID];\n\n\t\t// Determine the amount of virtualRewards to add based on the current ratio of rewards/shares.\n\t\t// The ratio of virtualRewards/increaseShareAmount is the same as totalRewards/totalShares for the pool.\n\t\t// The virtual rewards will be deducted later when calculating the user's owed rewards.\n        if ( existingTotalShares != 0 ) // prevent / 0\n        \t{\n\t\t\t// Round up in favor of the protocol.\n\t\t\tuint256 virtualRewardsToAdd = Math.ceilDiv( totalRewards[poolID] * increaseShareAmount, existingTotalShares );\n\n\t\t\tuser.virtualRewards += uint128(virtualRewardsToAdd);\n\t        totalRewards[poolID] += uint128(virtualRewardsToAdd);\n\t        }\n\n\t\t// Update the deposit balances\n\t\tuser.userShare += uint128(increaseShareAmount);\n\t\ttotalShares[poolID] = existingTotalShares + increaseShareAmount;\n\n\t\temit UserShareIncreased(wallet, poolID, increaseShareAmount);\n\t\t}\n\n\n\t// Decrease a user's share for the pool and have any pending rewards sent to them.\n\t// Does not require the pool to be valid (in case the pool was recently unwhitelisted).\n\tfunction _decreaseUserShare( address wallet, bytes32 poolID, uint256 decreaseShareAmount, bool useCooldown ) internal\n\t\t{\n\t\trequire( decreaseShareAmount != 0, \"Cannot decrease zero share\" );\n\n\t\tUserShareInfo storage user = _userShareInfo[wallet][poolID];\n\t\trequire( decreaseShareAmount <= user.userShare, \"Cannot decrease more than existing user share\" );\n\n\t\tif ( useCooldown )\n\t\tif ( msg.sender != address(exchangeConfig.dao()) ) // DAO doesn't use the cooldown\n\t\t\t{\n\t\t\trequire( block.timestamp >= user.cooldownExpiration, \"Must wait for the cooldown to expire\" );\n\n\t\t\t// Update the cooldown expiration for future transactions\n\t\t\tuser.cooldownExpiration = block.timestamp + stakingConfig.modificationCooldown();\n\t\t\t}\n\n\t\t// Determine the share of the rewards for the amountToDecrease (will include previously added virtual rewards)\n\t\tuint256 rewardsForAmount = ( totalRewards[poolID] * decreaseShareAmount ) / totalShares[poolID];\n\n\t\t// For the amountToDecrease determine the proportion of virtualRewards (proportional to all virtualRewards for the user)\n\t\t// Round virtualRewards down in favor of the protocol\n\t\tuint256 virtualRewardsToRemove = (user.virtualRewards * decreaseShareAmount) / user.userShare;\n\n\t\t// Update totals\n\t\ttotalRewards[poolID] -= rewardsForAmount;\n\t\ttotalShares[poolID] -= decreaseShareAmount;\n\n\t\t// Update the user's share and virtual rewards\n\t\tuser.userShare -= uint128(decreaseShareAmount);\n\t\tuser.virtualRewards -= uint128(virtualRewardsToRemove);\n\n\t\tuint256 claimableRewards = 0;\n\n\t\t// Some of the rewardsForAmount are actually virtualRewards and can't be claimed.\n\t\t// In the event that virtualRewards are greater than actual rewards - claimableRewards will stay zero.\n\t\tif ( virtualRewardsToRemove < rewardsForAmount )\n\t\t\tclaimableRewards = rewardsForAmount - virtualRewardsToRemove;\n\n\t\t// Send the claimable rewards\n\t\tif ( claimableRewards != 0 )\n\t\t\tsalt.safeTransfer( wallet, claimableRewards );\n\n\t\temit UserShareDecreased(wallet, poolID, decreaseShareAmount, claimableRewards);\n\t\t}\n\n\n\t// ===== PUBLIC FUNCTIONS =====\n\n\t// Claim all available SALT rewards from multiple pools for the user.\n\t// The claimed rewards are added to the user's virtual rewards balance - so that they can't be claimed again later.\n     function claimAllRewards( bytes32[] calldata poolIDs ) external nonReentrant returns (uint256 claimableRewards)\n    \t{\n\t\tmapping(bytes32=>UserShareInfo) storage userInfo = _userShareInfo[msg.sender];\n\n\t\tclaimableRewards = 0;\n\t\tfor( uint256 i = 0; i < poolIDs.length; i++ )\n\t\t\t{\n\t\t\tbytes32 poolID = poolIDs[i];\n\n\t\t\tuint256 pendingRewards = userRewardForPool( msg.sender, poolID );\n\n\t\t\t// Increase the virtualRewards balance for the user to account for them receiving the rewards without withdrawing\n\t\t\tuserInfo[poolID].virtualRewards += uint128(pendingRewards);\n\n\t\t\tclaimableRewards += pendingRewards;\n\t\t\t}\n\n\t\tif ( claimableRewards > 0 )\n\t\t\t{\n\t\t\t// Send the actual rewards\n\t\t\tsalt.safeTransfer( msg.sender, claimableRewards );\n\n\t\t\temit RewardsClaimed(msg.sender, claimableRewards);\n\t\t\t}\n    \t}\n\n\n\t// Adds SALT rewards for specific whitelisted pools.\n\t// There is some risk of addSALTRewards being frontrun to hunt rewards, but there are multiple mechanisms in place to prevent this from being effective.\n\t// 1. There is a cooldown period of default one hour before shares can be withdrawn once deposited.\n\t// 2. Staked SALT has a default unstake period of 52 weeks.\n\t// 3. Rewards are first placed into a RewardsEmitter which deposits rewards via addSALTRewards at the default rate of 1% per day.\n\t// 4. Rewards are deposited fairly often, with outstanding rewards being transferred with a frequency proportional to the activity of the exchange.\n\t// Example: if $100k rewards were being deposited in a bulk transaction, it would only equate to $1000 (1%) the first day,\n\t// or $10 in claimable rewards during a 15 minute upkeep period.\n \tfunction addSALTRewards( AddedReward[] calldata addedRewards ) external nonReentrant\n\t\t{\n\t\tuint256 sum = 0;\n\t\tfor( uint256 i = 0; i < addedRewards.length; i++ )\n\t\t\t{\n\t\t\tAddedReward memory addedReward = addedRewards[i];\n\n\t\t\tbytes32 poolID = addedReward.poolID;\n\t\t\trequire( poolsConfig.isWhitelisted( poolID ), \"Invalid pool\" );\n\n\t\t\tuint256 amountToAdd = addedReward.amountToAdd;\n\n\t\t\ttotalRewards[ poolID ] += amountToAdd;\n\t\t\tsum = sum + amountToAdd;\n\n\t\t\temit SaltRewardsAdded(poolID, amountToAdd);\n\t\t\t}\n\n\t\t// Transfer in the SALT for all the specified rewards\n\t\tif ( sum > 0 )\n\t\t\t{\n\t\t\t// Transfer the SALT rewards from the sender\n\t\t\tsalt.safeTransferFrom( msg.sender, address(this), sum );\n\t\t\t}\n\t\t}\n\n\n\t// === VIEWS ===\n\n\t// Returns the total shares for specified pools.\n\tfunction totalSharesForPools( bytes32[] calldata poolIDs ) external view returns (uint256[] memory shares)\n\t\t{\n\t\tshares = new uint256[]( poolIDs.length );\n\n\t\tfor( uint256 i = 0; i < shares.length; i++ )\n\t\t\tshares[i] = totalShares[ poolIDs[i] ];\n\t\t}\n\n\n\t// Returns the total rewards for specified pools.\n\tfunction totalRewardsForPools( bytes32[] calldata poolIDs ) external view returns (uint256[] memory rewards)\n\t\t{\n\t\trewards = new uint256[]( poolIDs.length );\n\n\t\tfor( uint256 i = 0; i < rewards.length; i++ )\n\t\t\trewards[i] = totalRewards[ poolIDs[i] ];\n\t\t}\n\n\n\t// Returns the user's pending rewards for a specified pool.\n\tfunction userRewardForPool( address wallet, bytes32 poolID ) public view returns (uint256)\n\t\t{\n\t\t// If there are no shares for the pool, the user can't have any shares either and there can't be any rewards\n\t\tif ( totalShares[poolID] == 0 )\n\t\t\treturn 0;\n\n\t\tUserShareInfo memory user = _userShareInfo[wallet][poolID];\n\t\tif ( user.userShare == 0 )\n\t\t\treturn 0;\n\n\t\t// Determine the share of the rewards for the user based on their deposited share\n\t\tuint256 rewardsShare = ( totalRewards[poolID] * user.userShare ) / totalShares[poolID];\n\n\t\t// Reduce by the virtualRewards - as they were only added to keep the share / rewards ratio the same when the used added their share\n\n\t\t// In the event that virtualRewards exceeds rewardsShare due to precision loss - just return zero\n\t\tif ( user.virtualRewards > rewardsShare )\n\t\t\treturn 0;\n\n\t\treturn rewardsShare - user.virtualRewards;\n\t\t}\n\n\n\t// Returns the user's pending rewards for specified pools.\n\tfunction userRewardsForPools( address wallet, bytes32[] calldata poolIDs ) external view returns (uint256[] memory rewards)\n\t\t{\n\t\trewards = new uint256[]( poolIDs.length );\n\n\t\tfor( uint256 i = 0; i < rewards.length; i++ )\n\t\t\trewards[i] = userRewardForPool( wallet, poolIDs[i] );\n\t\t}\n\n\n\t// Get the user's shares for a specified pool.\n\tfunction userShareForPool( address wallet, bytes32 poolID ) public view returns (uint256)\n\t\t{\n\t\treturn _userShareInfo[wallet][poolID].userShare;\n\t\t}\n\n\n\t// Get the user's shares for specified pools.\n\tfunction userShareForPools( address wallet, bytes32[] calldata poolIDs ) external view returns (uint256[] memory shares)\n\t\t{\n\t\tshares = new uint256[]( poolIDs.length );\n\n\t\tfor( uint256 i = 0; i < shares.length; i++ )\n\t\t\tshares[i] = _userShareInfo[wallet][ poolIDs[i] ].userShare;\n\t\t}\n\n\n\t// Get the user's virtual rewards for a specified pool.\n\tfunction userVirtualRewardsForPool( address wallet, bytes32 poolID ) public view returns (uint256)\n\t\t{\n\t\treturn _userShareInfo[wallet][poolID].virtualRewards;\n\t\t}\n\n\n\t// Get the cooldown time remaining for the user for specified pools.\n\tfunction userCooldowns( address wallet, bytes32[] calldata poolIDs ) external view returns (uint256[] memory cooldowns)\n\t\t{\n\t\tcooldowns = new uint256[]( poolIDs.length );\n\n\t\tmapping(bytes32=>UserShareInfo) storage userInfo = _userShareInfo[wallet];\n\n\t\tfor( uint256 i = 0; i < cooldowns.length; i++ )\n\t\t\t{\n\t\t\tuint256 cooldownExpiration = userInfo[ poolIDs[i] ].cooldownExpiration;\n\n\t\t\tif ( block.timestamp >= cooldownExpiration )\n\t\t\t\tcooldowns[i] = 0;\n\t\t\telse\n\t\t\t\tcooldowns[i] = cooldownExpiration - block.timestamp;\n\t\t\t}\n\t\t}\n\t}"
    }
  ]
}