{
  "Title": "[H-02] User can lose up to whole stake on vault withdrawal when there are funds locked in the strategy",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Vault/contracts/ReaperVaultV2.sol#L399-L407\n\n\n# Vulnerability details\n\nReaperVaultV2's `withdrawMaxLoss` isn't honoured when there are any locked funds in the strategy. Locked funds mean that there is a gap between requested and returned amount other than the loss reported. This is valid behavior of a strategy, but in this case realized loss is miscalculated in _withdraw() and a withdrawing user will receive less funds, while having all the shares burned.\n\n## Impact\n\nUsers can lose up to the whole asset amount due as all their requested shares can be burned, while only available amount be transferred to them. This amount can be arbitrary low.\n\nThe behaviour is not controlled by `withdrawMaxLoss` limit and is conditional only on a strategy having some funds locked (i.e. strategy experiencing liquidity squeeze).\n\n## Proof of Concept\n\n_withdraw() resets `value` to be `token.balanceOf(address(this))` when the balance isn't enough for withdrawal:\n\nhttps://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Vault/contracts/ReaperVaultV2.sol#L357-L412\n\n```solidity\n    // Internal helper function to burn {_shares} of vault shares belonging to {_owner}\n    // and return corresponding assets to {_receiver}. Returns the number of assets that were returned.\n    function _withdraw(\n        uint256 _shares,\n        address _receiver,\n        address _owner\n    ) internal nonReentrant returns (uint256 value) {\n        ...\n\n            vaultBalance = token.balanceOf(address(this));\n            if (value > vaultBalance) {\n                value = vaultBalance;\n            }\n\n            require(\n                totalLoss <= ((value + totalLoss) * withdrawMaxLoss) / PERCENT_DIVISOR,\n                \"Withdraw loss exceeds slippage\"\n            );\n        }\n\n        token.safeTransfer(_receiver, value);\n        emit Withdraw(msg.sender, _receiver, _owner, value, _shares);\n    }\n```\n\nEach strategy can return less than `requested - loss` as some funds can be temporary frozen:\n\nhttps://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Vault/contracts/abstract/ReaperBaseStrategyv4.sol#L90-L103\n\n```solidity\n    /**\n     * @dev Withdraws funds and sends them back to the vault. Can only\n     *      be called by the vault. _amount must be valid and security fee\n     *      is deducted up-front.\n     */\n    function withdraw(uint256 _amount) external override returns (uint256 loss) {\n        require(msg.sender == vault, \"Only vault can withdraw\");\n        require(_amount != 0, \"Amount cannot be zero\");\n        require(_amount <= balanceOf(), \"Ammount must be less than balance\");\n\n        uint256 amountFreed = 0;\n        (amountFreed, loss) = _liquidatePosition(_amount);\n        IERC20Upgradeable(want).safeTransfer(vault, amountFreed);\n    }\n```\n\nThe invariant there is `liquidatedAmount + loss <= _amountNeeded`, so `liquidatedAmount + loss < _amountNeeded` is a valid state (due to the funds locked):\n\nhttps://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Vault/contracts/abstract/ReaperBaseStrategyv4.sol#L230-L243\n\n```solidity\n    /**\n     * Liquidate up to `_amountNeeded` of `want` of this strategy's positions,\n     * irregardless of slippage. Any excess will be re-invested with `_adjustPosition()`.\n     * This function should return the amount of `want` tokens made available by the\n     * liquidation. If there is a difference between them, `loss` indicates whether the\n     * difference is due to a realized loss, or if there is some other sitution at play\n     * (e.g. locked funds) where the amount made available is less than what is needed.\n     *\n     * NOTE: The invariant `liquidatedAmount + loss <= _amountNeeded` should always be maintained\n     */\n    function _liquidatePosition(uint256 _amountNeeded)\n        internal\n        virtual\n        returns (uint256 liquidatedAmount, uint256 loss);\n```\n\n_liquidatePosition() is called in strategy withdraw():\n\nhttps://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Vault/contracts/abstract/ReaperBaseStrategyv4.sol#L90-L103\n\n```solidity\n    /**\n     * @dev Withdraws funds and sends them back to the vault. Can only\n     *      be called by the vault. _amount must be valid and security fee\n     *      is deducted up-front.\n     */\n    function withdraw(uint256 _amount) external override returns (uint256 loss) {\n        require(msg.sender == vault, \"Only vault can withdraw\");\n        require(_amount != 0, \"Amount cannot be zero\");\n        require(_amount <= balanceOf(), \"Ammount must be less than balance\");\n\n        uint256 amountFreed = 0;\n        (amountFreed, loss) = _liquidatePosition(_amount);\n        IERC20Upgradeable(want).safeTransfer(vault, amountFreed);\n    }\n```\n\nThis way there can be `lockedAmount = _amountNeeded - (liquidatedAmount + loss) >= 0`, which is neither a loss, nor withdraw-able at the moment.\n\nAs ReaperVaultV2's _withdraw() updates `value` per `if (value > vaultBalance) {value = vaultBalance;}`, the following `totalLoss <= ((value + totalLoss) * withdrawMaxLoss) / PERCENT_DIVISOR` check do not control for the real loss and allows user to lose up to the whole amount due as _withdraw() first burns the full amount of the `_shares` requested and this total loss check for the *rebased* `value` is the only guard in place:\n\nhttps://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Vault/contracts/ReaperVaultV2.sol#L359-L412\n\n```solidity\n    function _withdraw(\n        uint256 _shares,\n        address _receiver,\n        address _owner\n    ) internal nonReentrant returns (uint256 value) {\n        require(_shares != 0, \"Invalid amount\");\n        value = (_freeFunds() * _shares) / totalSupply();\n        _burn(_owner, _shares);\n\n        if (value > token.balanceOf(address(this))) {\n            ...\n\n            vaultBalance = token.balanceOf(address(this));\n            if (value > vaultBalance) {\n                value = vaultBalance;\n            }\n\n            require(\n                totalLoss <= ((value + totalLoss) * withdrawMaxLoss) / PERCENT_DIVISOR,\n                \"Withdraw loss exceeds slippage\"\n            );\n        }\n\n        token.safeTransfer(_receiver, value);\n        emit Withdraw(msg.sender, _receiver, _owner, value, _shares);\n    }\n```\n\nSuppose there is only one strategy and `90` of the `100` tokens requested is locked at the moment, and there is no loss, just a temporal liquidity squeeze. Say there is no tokens on the vault balance before strategy withdrawal.\n\nReaperBaseStrategyv4's withdraw() will transfer `10`, report `0` loss, `0 = totalLoss <= ((value + totalLoss) * withdrawMaxLoss) / PERCENT_DIVISOR = (10 + 0) * withdrawMaxLoss / PERCENT_DIVISOR` check will be satisfied for any viable `withdrawMaxLoss` setting.\n\nBob the withdrawing user will receive `10` tokens and have `100` tokens worth of the shares burned.\n\n## Recommended Mitigation Steps\n\nConsider rewriting the controlling logic so the check be based on initial value:\n\nNow:\n\nhttps://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Vault/contracts/ReaperVaultV2.sol#L399-L407\n\n```solidity\n            vaultBalance = token.balanceOf(address(this));\n            if (value > vaultBalance) {\n                value = vaultBalance;\n            }\n\n            require(\n                totalLoss <= ((value + totalLoss) * withdrawMaxLoss) / PERCENT_DIVISOR,\n                \"Withdraw loss exceeds slippage\"\n            );\n```\n\nTo be, as an example, if treat the loss attributed to the current user only as they have requested the withdrawal:\n\n```solidity\n            require(\n                totalLoss <= (value * withdrawMaxLoss) / PERCENT_DIVISOR,\n                \"Withdraw loss exceeds slippage\"\n            );\n\n            value -= totalLoss;\n\n            vaultBalance = token.balanceOf(address(this));\n            require(\n                value <= vaultBalance,\n                \"Not enough funds\"\n            );\n```\n\nAlso, `shares` can be updated according to the real value obtained as it is done in yearn:\n\nhttps://github.com/yearn/yearn-vaults/blob/master/contracts/Vault.vy#L1147-L1151\n\n```solidity\n        if value > vault_balance:\n            value = vault_balance\n            # NOTE: Burn # of shares that corresponds to what Vault has on-hand,\n            #       including the losses that were incurred above during withdrawals\n            shares = self._sharesForAmount(value + totalLoss)\n```",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2023-02-ethos-reserve-contest",
  "Code": [
    {
      "filename": "Ethos-Vault/contracts/ReaperVaultV2.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IERC4626Events.sol\";\nimport \"./interfaces/IStrategy.sol\";\nimport \"./libraries/ReaperMathUtils.sol\";\nimport \"./mixins/ReaperAccessControl.sol\";\nimport \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/**\n * @notice Implementation of a vault to deposit funds for yield optimizing.\n * This is the contract that receives funds and that users interface with.\n * The yield optimizing strategy itself is implemented in a separate 'Strategy.sol' contract.\n */\ncontract ReaperVaultV2 is ReaperAccessControl, ERC20, IERC4626Events, AccessControlEnumerable, ReentrancyGuard {\n    using ReaperMathUtils for uint256;\n    using SafeERC20 for IERC20Metadata;\n\n    struct StrategyParams {\n        uint256 activation; // Activation block.timestamp\n        uint256 feeBPS; // Performance fee taken from profit, in BPS\n        uint256 allocBPS; // Allocation in BPS of vault's total assets\n        uint256 allocated; // Amount of capital allocated to this strategy\n        uint256 gains; // Total returns that Strategy has realized for Vault\n        uint256 losses; // Total losses that Strategy has realized for Vault\n        uint256 lastReport; // block.timestamp of the last time a report occured\n    }\n\n    mapping(address => StrategyParams) public strategies;\n\n    // Ordering that `withdraw` uses to determine which strategies to pull funds from\n    address[] public withdrawalQueue;\n\n    uint256 public constant DEGRADATION_COEFFICIENT = 10**18; // The unit for calculating profit degradation.\n    uint256 public constant PERCENT_DIVISOR = 10000;\n    uint256 public tvlCap;\n\n    uint256 public totalAllocBPS; // Sum of allocBPS across all strategies (in BPS, <= 10k)\n    uint256 public totalAllocated; // Amount of tokens that have been allocated to all strategies\n    uint256 public lastReport; // block.timestamp of last report from any strategy\n\n    uint256 public immutable constructionTime;\n    bool public emergencyShutdown;\n\n    // The token the vault accepts and looks to maximize.\n    IERC20Metadata public immutable token;\n\n    // Max slippage(loss) allowed when withdrawing, in BPS (0.01%)\n    uint256 public withdrawMaxLoss = 1;\n    uint256 public lockedProfitDegradation; // rate per block of degradation. DEGRADATION_COEFFICIENT is 100% per block\n    uint256 public lockedProfit; // how much profit is locked and cant be withdrawn\n\n    /**\n     * Reaper Roles in increasing order of privilege.\n     * {DEPOSITOR} - Role conferred to EOAs/contracts that are allowed to deposit in the vault.\n     * {STRATEGIST} - Role conferred to authors of the strategy, allows for tweaking non-critical params.\n     * {GUARDIAN} - Multisig requiring 2 signatures for invoking emergency measures.\n     * {ADMIN}- Multisig requiring 3 signatures for deactivating emergency measures and changing TVL cap.\n     *\n     * The DEFAULT_ADMIN_ROLE (in-built access control role) will be granted to a multisig requiring 4\n     * signatures. This role would have the ability to add strategies, as well as the ability to grant any other\n     * roles.\n     *\n     * Also note that roles are cascading. So any higher privileged role should be able to perform all the functions\n     * of any lower privileged role.\n     */\n    bytes32 public constant DEPOSITOR = keccak256(\"DEPOSITOR\");\n    bytes32 public constant STRATEGIST = keccak256(\"STRATEGIST\");\n    bytes32 public constant GUARDIAN = keccak256(\"GUARDIAN\");\n    bytes32 public constant ADMIN = keccak256(\"ADMIN\");\n\n    address public treasury; // address to whom performance fee is remitted in the form of vault shares\n\n    event StrategyAdded(address indexed strategy, uint256 feeBPS, uint256 allocBPS);\n    event StrategyFeeBPSUpdated(address indexed strategy, uint256 feeBPS);\n    event StrategyAllocBPSUpdated(address indexed strategy, uint256 allocBPS);\n    event StrategyRevoked(address indexed strategy);\n    event UpdateWithdrawalQueue(address[] withdrawalQueue);\n    event WithdrawMaxLossUpdated(uint256 withdrawMaxLoss);\n    event EmergencyShutdown(bool active);\n    event InCaseTokensGetStuckCalled(address token, uint256 amount);\n    event TvlCapUpdated(uint256 newTvlCap);\n    event LockedProfitDegradationUpdated(uint256 degradation);\n    event StrategyReported(\n        address indexed strategy,\n        uint256 gain,\n        uint256 loss,\n        uint256 debtPaid,\n        uint256 gains,\n        uint256 losses,\n        uint256 allocated,\n        uint256 allocationAdded,\n        uint256 allocBPS\n    );\n\n    /**\n     * @notice Initializes the vault's own 'RF' token.\n     * This token is minted when someone does a deposit. It is burned in order\n     * to withdraw the corresponding portion of the underlying assets.\n     * @param _token the token to maximize.\n     * @param _name the name of the vault token.\n     * @param _symbol the symbol of the vault token.\n     * @param _tvlCap initial deposit cap for scaling TVL safely\n     */\n    constructor(\n        address _token,\n        string memory _name,\n        string memory _symbol,\n        uint256 _tvlCap,\n        address _treasury,\n        address[] memory _strategists,\n        address[] memory _multisigRoles\n    ) ERC20(string(_name), string(_symbol)) {\n        token = IERC20Metadata(_token);\n        constructionTime = block.timestamp;\n        lastReport = block.timestamp;\n        tvlCap = _tvlCap;\n        treasury = _treasury;\n        lockedProfitDegradation = (DEGRADATION_COEFFICIENT * 46) / 10**6; // 6 hours in blocks\n\n        uint256 numStrategists = _strategists.length;\n        for (uint256 i = 0; i < numStrategists; i = i.uncheckedInc()) {\n            _grantRole(STRATEGIST, _strategists[i]);\n        }\n\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(DEFAULT_ADMIN_ROLE, _multisigRoles[0]);\n        _grantRole(ADMIN, _multisigRoles[1]);\n        _grantRole(GUARDIAN, _multisigRoles[2]);\n    }\n\n    /**\n     * @notice Adds a new strategy to the vault with a given allocation amount in basis points.\n     * @param _strategy The strategy to add.\n     * @param _feeBPS The performance fee (taken from profit) in basis points\n     * @param _allocBPS The strategy allocation in basis points\n     */\n    function addStrategy(\n        address _strategy,\n        uint256 _feeBPS,\n        uint256 _allocBPS\n    ) external {\n        _atLeastRole(DEFAULT_ADMIN_ROLE);\n        require(!emergencyShutdown, \"Cannot add strategy during emergency shutdown\");\n        require(_strategy != address(0), \"Invalid strategy address\");\n        require(strategies[_strategy].activation == 0, \"Strategy already added\");\n        require(address(this) == IStrategy(_strategy).vault(), \"Strategy's vault does not match\");\n        require(address(token) == IStrategy(_strategy).want(), \"Strategy's want does not match\");\n        require(_feeBPS <= PERCENT_DIVISOR / 5, \"Fee cannot be higher than 20 BPS\");\n        require(_allocBPS + totalAllocBPS <= PERCENT_DIVISOR, \"Invalid allocBPS value\");\n\n        strategies[_strategy] = StrategyParams({\n            activation: block.timestamp,\n            feeBPS: _feeBPS,\n            allocBPS: _allocBPS,\n            allocated: 0,\n            gains: 0,\n            losses: 0,\n            lastReport: block.timestamp\n        });\n\n        totalAllocBPS += _allocBPS;\n        withdrawalQueue.push(_strategy);\n        emit StrategyAdded(_strategy, _feeBPS, _allocBPS);\n    }\n\n    /**\n     * @notice Updates the strategy's performance fee.\n     * @param _strategy The strategy to update.\n     * @param _feeBPS The new performance fee in basis points.\n     */\n    function updateStrategyFeeBPS(address _strategy, uint256 _feeBPS) external {\n        _atLeastRole(ADMIN);\n        require(strategies[_strategy].activation != 0, \"Invalid strategy address\");\n        require(_feeBPS <= PERCENT_DIVISOR / 5, \"Fee cannot be higher than 20 BPS\");\n        strategies[_strategy].feeBPS = _feeBPS;\n        emit StrategyFeeBPSUpdated(_strategy, _feeBPS);\n    }\n\n    /**\n     * @notice Updates the allocation points for a given strategy.\n     * @param _strategy The strategy to update.\n     * @param _allocBPS The strategy allocation in basis points\n     */\n    function updateStrategyAllocBPS(address _strategy, uint256 _allocBPS) external {\n        _atLeastRole(STRATEGIST);\n        require(strategies[_strategy].activation != 0, \"Invalid strategy address\");\n        totalAllocBPS -= strategies[_strategy].allocBPS;\n        strategies[_strategy].allocBPS = _allocBPS;\n        totalAllocBPS += _allocBPS;\n        require(totalAllocBPS <= PERCENT_DIVISOR, \"Invalid BPS value\");\n        emit StrategyAllocBPSUpdated(_strategy, _allocBPS);\n    }\n\n    /**\n     * @notice Removes any allocation to a given strategy.\n     * @param _strategy The strategy to revoke.\n     */\n    function revokeStrategy(address _strategy) external {\n        if (msg.sender != _strategy) {\n            _atLeastRole(GUARDIAN);\n        }\n\n        if (strategies[_strategy].allocBPS == 0) {\n            return;\n        }\n\n        totalAllocBPS -= strategies[_strategy].allocBPS;\n        strategies[_strategy].allocBPS = 0;\n        emit StrategyRevoked(_strategy);\n    }\n\n    /**\n     * @notice Called by a strategy to determine the amount of capital that the vault is\n     * able to provide it. A positive amount means that vault has excess capital to provide\n     * the strategy, while a negative amount means that the strategy has a balance owing to\n     * the vault.\n     */\n    function availableCapital() public view returns (int256) {\n        address stratAddr = msg.sender;\n        if (totalAllocBPS == 0 || emergencyShutdown) {\n            return -int256(strategies[stratAddr].allocated);\n        }\n\n        uint256 stratMaxAllocation = (strategies[stratAddr].allocBPS * balance()) / PERCENT_DIVISOR;\n        uint256 stratCurrentAllocation = strategies[stratAddr].allocated;\n\n        if (stratCurrentAllocation > stratMaxAllocation) {\n            return -int256(stratCurrentAllocation - stratMaxAllocation);\n        } else if (stratCurrentAllocation < stratMaxAllocation) {\n            uint256 vaultMaxAllocation = (totalAllocBPS * balance()) / PERCENT_DIVISOR;\n            uint256 vaultCurrentAllocation = totalAllocated;\n\n            if (vaultCurrentAllocation >= vaultMaxAllocation) {\n                return 0;\n            }\n\n            uint256 available = stratMaxAllocation - stratCurrentAllocation;\n            available = Math.min(available, vaultMaxAllocation - vaultCurrentAllocation);\n            available = Math.min(available, token.balanceOf(address(this)));\n\n            return int256(available);\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Updates the withdrawalQueue to match the addresses and order specified.\n     * @param _withdrawalQueue The new withdrawalQueue to update to.\n     */\n    function setWithdrawalQueue(address[] calldata _withdrawalQueue) external {\n        _atLeastRole(ADMIN);\n        uint256 queueLength = _withdrawalQueue.length;\n        require(queueLength != 0, \"Queue must not be empty\");\n\n        delete withdrawalQueue;\n        for (uint256 i = 0; i < queueLength; i = i.uncheckedInc()) {\n            address strategy = _withdrawalQueue[i];\n            StrategyParams storage params = strategies[strategy];\n            require(params.activation != 0, \"Invalid strategy address\");\n            withdrawalQueue.push(strategy);\n        }\n        emit UpdateWithdrawalQueue(_withdrawalQueue);\n    }\n\n    /**\n     * @dev It calculates the total underlying value of {token} held by the system.\n     * It takes into account the vault contract balance, and the balance deployed across\n     * all the strategies.\n     */\n    function balance() public view returns (uint256) {\n        return token.balanceOf(address(this)) + totalAllocated;\n    }\n\n    /**\n     * @notice It calculates the amount of free funds available after profit locking.\n     * For calculating share price, issuing shares during deposit, or burning shares during withdrawal.\n     * @return freeFunds - the total amount of free funds available.\n     */\n    function _freeFunds() internal view returns (uint256) {\n        return balance() - _calculateLockedProfit();\n    }\n\n    /**\n     * @dev Function for various UIs to display the current value of one of our yield tokens.\n     * Returns an uint256 with 18 decimals of how much underlying asset one vault share represents.\n     */\n    function getPricePerFullShare() public view returns (uint256) {\n        return totalSupply() == 0 ? 10**decimals() : (_freeFunds() * 10**decimals()) / totalSupply();\n    }\n\n    /**\n     * @dev A helper function to call deposit() with all the sender's funds.\n     */\n    function depositAll() external {\n        _deposit(token.balanceOf(msg.sender), msg.sender);\n    }\n\n    /**\n     * @notice The entrypoint of funds into the system. People deposit with this function\n     * into the vault.\n     * @notice the _before and _after variables are used to account properly for\n     * 'burn-on-transaction' tokens.\n     * @param _amount The amount of assets to deposit\n     */\n    function deposit(uint256 _amount) external {\n        _deposit(_amount, msg.sender);\n    }\n\n    // Internal helper function to deposit {_amount} of assets and mint corresponding\n    // shares to {_receiver}. Returns the number of shares that were minted.\n    function _deposit(uint256 _amount, address _receiver) internal nonReentrant returns (uint256 shares) {\n        _atLeastRole(DEPOSITOR);\n        require(!emergencyShutdown, \"Cannot deposit during emergency shutdown\");\n        require(_amount != 0, \"Invalid amount\");\n        uint256 pool = balance();\n        require(pool + _amount <= tvlCap, \"Vault is full\");\n\n        uint256 freeFunds = _freeFunds();\n        uint256 balBefore = token.balanceOf(address(this));\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        uint256 balAfter = token.balanceOf(address(this));\n        _amount = balAfter - balBefore;\n        if (totalSupply() == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount * totalSupply()) / freeFunds; // use \"freeFunds\" instead of \"pool\"\n        }\n        _mint(_receiver, shares);\n        emit Deposit(msg.sender, _receiver, _amount, shares);\n    }\n\n    /**\n     * @dev A helper function to call withdraw() with all the sender's funds.\n     */\n    function withdrawAll() external {\n        _withdraw(balanceOf(msg.sender), msg.sender, msg.sender);\n    }\n\n    /**\n     * @notice Function to exit the system. The vault will withdraw the required tokens\n     * from the strategies and pay up the token holder. A proportional number of IOU\n     * tokens are burned in the process.\n     * @param _shares the number of shares to burn\n     */\n    function withdraw(uint256 _shares) external {\n        _withdraw(_shares, msg.sender, msg.sender);\n    }\n\n    // Internal helper function to burn {_shares} of vault shares belonging to {_owner}\n    // and return corresponding assets to {_receiver}. Returns the number of assets that were returned.\n    function _withdraw(\n        uint256 _shares,\n        address _receiver,\n        address _owner\n    ) internal nonReentrant returns (uint256 value) {\n        require(_shares != 0, \"Invalid amount\");\n        value = (_freeFunds() * _shares) / totalSupply();\n        _burn(_owner, _shares);\n\n        if (value > token.balanceOf(address(this))) {\n            uint256 totalLoss = 0;\n            uint256 queueLength = withdrawalQueue.length;\n            uint256 vaultBalance = 0;\n            for (uint256 i = 0; i < queueLength; i = i.uncheckedInc()) {\n                vaultBalance = token.balanceOf(address(this));\n                if (value <= vaultBalance) {\n                    break;\n                }\n\n                address stratAddr = withdrawalQueue[i];\n                uint256 strategyBal = strategies[stratAddr].allocated;\n                if (strategyBal == 0) {\n                    continue;\n                }\n\n                uint256 remaining = value - vaultBalance;\n                uint256 loss = IStrategy(stratAddr).withdraw(Math.min(remaining, strategyBal));\n                uint256 actualWithdrawn = token.balanceOf(address(this)) - vaultBalance;\n\n                // Withdrawer incurs any losses from withdrawing as reported by strat\n                if (loss != 0) {\n                    value -= loss;\n                    totalLoss += loss;\n                    _reportLoss(stratAddr, loss);\n                }\n\n                strategies[stratAddr].allocated -= actualWithdrawn;\n                totalAllocated -= actualWithdrawn;\n            }\n\n            vaultBalance = token.balanceOf(address(this));\n            if (value > vaultBalance) {\n                value = vaultBalance;\n            }\n\n            require(\n                totalLoss <= ((value + totalLoss) * withdrawMaxLoss) / PERCENT_DIVISOR,\n                \"Withdraw loss exceeds slippage\"\n            );\n        }\n\n        token.safeTransfer(_receiver, value);\n        emit Withdraw(msg.sender, _receiver, _owner, value, _shares);\n    }\n\n    /**\n     * @notice It calculates the amount of locked profit from recent harvests.\n     * @return the amount of locked profit.\n     */\n    function _calculateLockedProfit() internal view returns (uint256) {\n        uint256 lockedFundsRatio = (block.timestamp - lastReport) * lockedProfitDegradation;\n        if (lockedFundsRatio < DEGRADATION_COEFFICIENT) {\n            return lockedProfit - ((lockedFundsRatio * lockedProfit) / DEGRADATION_COEFFICIENT);\n        }\n\n        return 0;\n    }\n\n    /**\n     * @notice Helper function to report a loss by a given strategy.\n     * @param strategy The strategy to report the loss for.\n     * @param loss The amount lost.\n     */\n    function _reportLoss(address strategy, uint256 loss) internal {\n        StrategyParams storage stratParams = strategies[strategy];\n        // Loss can only be up the amount of capital allocated to the strategy\n        uint256 allocation = stratParams.allocated;\n        require(loss <= allocation, \"Strategy loss cannot be greater than allocation\");\n\n        if (totalAllocBPS != 0) {\n            // reduce strat's allocBPS proportional to loss\n            uint256 bpsChange = Math.min((loss * totalAllocBPS) / totalAllocated, stratParams.allocBPS);\n\n            // If the loss is too small, bpsChange will be 0\n            if (bpsChange != 0) {\n                stratParams.allocBPS -= bpsChange;\n                totalAllocBPS -= bpsChange;\n            }\n        }\n\n        // Finally, adjust our strategy's parameters by the loss\n        stratParams.losses += loss;\n        stratParams.allocated -= loss;\n        totalAllocated -= loss;\n    }\n\n    /**\n     * @notice Helper function to charge fees from the gain reported by a strategy.\n     * Fees is charged by issuing the corresponding amount of vault shares to the treasury.\n     * @param strategy The strategy that reported gain.\n     * @param gain The amount of profit reported.\n     * @return The fee amount in assets.\n     */\n    function _chargeFees(address strategy, uint256 gain) internal returns (uint256) {\n        uint256 performanceFee = (gain * strategies[strategy].feeBPS) / PERCENT_DIVISOR;\n        if (performanceFee != 0) {\n            uint256 supply = totalSupply();\n            uint256 shares = supply == 0 ? performanceFee : (performanceFee * supply) / _freeFunds();\n            _mint(treasury, shares);\n        }\n        return performanceFee;\n    }\n\n    // To avoid \"stack too deep\" errors\n    struct LocalVariables_report {\n        address stratAddr;\n        uint256 loss;\n        uint256 gain;\n        uint256 fees;\n        int256 available;\n        uint256 debt;\n        uint256 credit;\n        uint256 debtPayment;\n        uint256 freeWantInStrat;\n        uint256 lockedProfitBeforeLoss;\n    }\n\n    /**\n     * @notice Main contact point where each strategy interacts with the vault during its harvest\n     * to report profit/loss as well as any repayment of debt.\n     * @param _roi The return on investment (positive or negative) given as the total amount\n     * gained or lost from the harvest.\n     * @param _repayment The repayment of debt by the strategy.\n     */\n    function report(int256 _roi, uint256 _repayment) external returns (uint256) {\n        LocalVariables_report memory vars;\n        vars.stratAddr = msg.sender;\n        StrategyParams storage strategy = strategies[vars.stratAddr];\n        require(strategy.activation != 0, \"Unauthorized strategy\");\n\n        if (_roi < 0) {\n            vars.loss = uint256(-_roi);\n            _reportLoss(vars.stratAddr, vars.loss);\n        } else if (_roi > 0) {\n            vars.gain = uint256(_roi);\n            vars.fees = _chargeFees(vars.stratAddr, vars.gain);\n            strategy.gains += vars.gain;\n        }\n\n        vars.available = availableCapital();\n        if (vars.available < 0) {\n            vars.debt = uint256(-vars.available);\n            vars.debtPayment = Math.min(vars.debt, _repayment);\n\n            if (vars.debtPayment != 0) {\n                strategy.allocated -= vars.debtPayment;\n                totalAllocated -= vars.debtPayment;\n                vars.debt -= vars.debtPayment; // tracked for return value\n            }\n        } else if (vars.available > 0) {\n            vars.credit = uint256(vars.available);\n            strategy.allocated += vars.credit;\n            totalAllocated += vars.credit;\n        }\n\n        vars.freeWantInStrat = vars.gain + _repayment;\n        if (vars.credit > vars.freeWantInStrat) {\n            token.safeTransfer(vars.stratAddr, vars.credit - vars.freeWantInStrat);\n        } else if (vars.credit < vars.freeWantInStrat) {\n            token.safeTransferFrom(vars.stratAddr, address(this), vars.freeWantInStrat - vars.credit);\n        }\n\n        // Profit is locked and gradually released per block\n        // NOTE: compute current locked profit and replace with sum of current and new\n        vars.lockedProfitBeforeLoss = _calculateLockedProfit() + vars.gain - vars.fees;\n        if (vars.lockedProfitBeforeLoss > vars.loss) {\n            lockedProfit = vars.lockedProfitBeforeLoss - vars.loss;\n        } else {\n            lockedProfit = 0;\n        }\n\n        strategy.lastReport = block.timestamp;\n        lastReport = block.timestamp;\n\n        emit StrategyReported(\n            vars.stratAddr,\n            vars.gain,\n            vars.loss,\n            vars.debtPayment,\n            strategy.gains,\n            strategy.losses,\n            strategy.allocated,\n            vars.credit,\n            strategy.allocBPS\n        );\n\n        if (strategy.allocBPS == 0 || emergencyShutdown) {\n            return IStrategy(vars.stratAddr).balanceOf();\n        }\n\n        return vars.debt;\n    }\n\n    /**\n     * @notice Updates the withdrawMaxLoss which is the maximum allowed slippage.\n     * @param _withdrawMaxLoss The new value, in basis points.\n     */\n    function updateWithdrawMaxLoss(uint256 _withdrawMaxLoss) external {\n        _atLeastRole(STRATEGIST);\n        require(_withdrawMaxLoss <= PERCENT_DIVISOR, \"Invalid BPS value\");\n        withdrawMaxLoss = _withdrawMaxLoss;\n        emit WithdrawMaxLossUpdated(_withdrawMaxLoss);\n    }\n\n    /**\n     * @notice Updates the vault tvl cap (the max amount of assets held by the vault).\n     * @dev pass in max value of uint to effectively remove TVL cap.\n     * @param _newTvlCap The new tvl cap.\n     */\n    function updateTvlCap(uint256 _newTvlCap) public {\n        _atLeastRole(ADMIN);\n        tvlCap = _newTvlCap;\n        emit TvlCapUpdated(tvlCap);\n    }\n\n    /**\n     * @dev helper function to remove TVL cap\n     */\n    function removeTvlCap() external {\n        updateTvlCap(type(uint256).max);\n    }\n\n    /**\n     * Activates or deactivates Vault mode where all Strategies go into full\n     * withdrawal.\n     * During Emergency Shutdown:\n     * 1. No Users may deposit into the Vault (but may withdraw as usual.)\n     * 2. New Strategies may not be added.\n     * 3. Each Strategy must pay back their debt as quickly as reasonable to\n     * minimally affect their position.\n     *\n     * If true, the Vault goes into Emergency Shutdown. If false, the Vault\n     * goes back into Normal Operation.\n     */\n    function setEmergencyShutdown(bool _active) external {\n        if (_active) {\n            _atLeastRole(GUARDIAN);\n        } else {\n            _atLeastRole(ADMIN);\n        }\n        emergencyShutdown = _active;\n        emit EmergencyShutdown(_active);\n    }\n\n    /**\n     * @notice Changes the locked profit degradation.\n     * @param degradation - The rate of degradation in percent per second scaled to 1e18.\n     */\n    function setLockedProfitDegradation(uint256 degradation) external {\n        _atLeastRole(ADMIN);\n        require(degradation <= DEGRADATION_COEFFICIENT, \"Degradation cannot be more than 100%\");\n        lockedProfitDegradation = degradation;\n        emit LockedProfitDegradationUpdated(degradation);\n    }\n\n    /**\n     * @notice Only DEFAULT_ADMIN_ROLE can update treasury address.\n     */\n    function updateTreasury(address newTreasury) external {\n        _atLeastRole(DEFAULT_ADMIN_ROLE);\n        require(newTreasury != address(0), \"Invalid address\");\n        treasury = newTreasury;\n    }\n\n    /**\n     * @dev Rescues random funds stuck that the strat can't handle.\n     * @param _token address of the token to rescue.\n     */\n    function inCaseTokensGetStuck(address _token) external {\n        _atLeastRole(ADMIN);\n        require(_token != address(token), \"!token\");\n\n        uint256 amount = IERC20Metadata(_token).balanceOf(address(this));\n        IERC20Metadata(_token).safeTransfer(msg.sender, amount);\n        emit InCaseTokensGetStuckCalled(_token, amount);\n    }\n\n    /**\n     * @dev Overrides the default 18 decimals for the vault ERC20 to\n     * match the same decimals as the underlying token used\n     */\n    function decimals() public view override returns (uint8) {\n        return token.decimals();\n    }\n\n    /**\n     * @dev Returns an array of all the relevant roles arranged in descending order of privilege.\n     *      Subclasses should override this to specify their unique roles arranged in the correct\n     *      order, for example, [SUPER-ADMIN, ADMIN, GUARDIAN, STRATEGIST].\n     */\n    function _cascadingAccessRoles() internal view override returns (bytes32[] memory) {\n        bytes32[] memory cascadingAccessRoles = new bytes32[](5);\n        cascadingAccessRoles[0] = DEFAULT_ADMIN_ROLE;\n        cascadingAccessRoles[1] = ADMIN;\n        cascadingAccessRoles[2] = GUARDIAN;\n        cascadingAccessRoles[3] = STRATEGIST;\n        cascadingAccessRoles[4] = DEPOSITOR;\n        return cascadingAccessRoles;\n    }\n\n    /**\n     * @dev Returns {true} if {_account} has been granted {_role}. Subclasses should override\n     *      this to specify their unique role-checking criteria.\n     */\n    function _hasRole(bytes32 _role, address _account) internal view override returns (bool) {\n        return hasRole(_role, _account);\n    }\n}"
    }
  ]
}