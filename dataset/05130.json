{
  "Title": "[L-06] Unnecessary implementations for ETH rewards - Pools canâ€™t receive ETH in balance and will never be eligible for ETH rewards",
  "Content": "\n### Instances(2)\n\nThree contracts have implementations for ETH Blast rewards but these contracts don't implement `receive()` or `payable` functions to ever receive eth after deployment. Contracts that do not hold ETH will not be eligible for ETH blast rewards. So no need for these ETH blast reward implementations in these contracts.\n\n```solidity\n//thruster-protocol/thruster-clmm/contracts/ThrusterPool.sol\nconstructor() {\n        int24 _tickSpacing;\n        BLAST.configureClaimableGas();\n        //@audit Pool will not in normal circumstance be able to receive ETH in balance and will not be eligible for ETH rewards.\n|>      BLAST.configureClaimableYield();\n        USDB.configure(YieldMode.CLAIMABLE);\n        WETHB.configure(YieldMode.CLAIMABLE);\n...\n```\n(https://github.com/code-423n4/2024-02-thruster/blob/3896779349f90a44b46f2646094cb34fffd7f66e/thruster-protocol/thruster-clmm/contracts/ThrusterPool.sol#L130)\n\n```solidity\n//thruster-protocol/thruster-cfmm/contracts/ThrusterYield.sol\n    constructor(address _manager) public {\n        BLAST.configureClaimableGas();\n|>      BLAST.configureClaimableYield();\n        USDB.configure(IERC20Rebasing.YieldMode.CLAIMABLE);\n        WETHB.configure(IERC20Rebasing.YieldMode.CLAIMABLE);\n        manager = _manager;\n    }\n...\n```\n(https://github.com/code-423n4/2024-02-thruster/blob/3896779349f90a44b46f2646094cb34fffd7f66e/thruster-protocol/thruster-cfmm/contracts/ThrusterYield.sol#L26)\n\n### Recommendations\n\nRemove both the ETH rewards configuration and the claiming code for ETH rewards for contracts not able to receive ETH.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-02-thruster",
  "Code": [
    {
      "filename": "thruster-protocol/thruster-clmm/contracts/ThrusterPool.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.7.6;\n\nimport \"interfaces/IERC20Minimal.sol\";\nimport \"interfaces/IThrusterPoolFactory.sol\";\nimport \"interfaces/IThrusterGauge.sol\";\nimport \"interfaces/IThrusterPool.sol\";\nimport \"interfaces/IThrusterPoolDeployer.sol\";\nimport \"interfaces/callback/IThrusterMintCallback.sol\";\nimport \"interfaces/callback/IThrusterSwapCallback.sol\";\nimport \"interfaces/callback/IThrusterFlashCallback.sol\";\n\nimport \"interfaces/IBlast.sol\";\nimport \"interfaces/IERC20Rebasing.sol\";\n\nimport \"contracts/NoDelegateCall.sol\";\nimport \"contracts/libraries/FixedPoint128.sol\";\nimport \"contracts/libraries/FullMath.sol\";\nimport \"contracts/libraries/LiquidityMath.sol\";\nimport \"contracts/libraries/LowGasSafeMath.sol\";\nimport \"contracts/libraries/Oracle.sol\";\nimport \"contracts/libraries/Position.sol\";\nimport \"contracts/libraries/SafeCast.sol\";\nimport \"contracts/libraries/SqrtPriceMath.sol\";\nimport \"contracts/libraries/SwapMath.sol\";\nimport \"contracts/libraries/Tick.sol\";\nimport \"contracts/libraries/TickMath.sol\";\nimport \"contracts/libraries/TickBitmap.sol\";\nimport \"contracts/libraries/TransferHelper.sol\";\n\ncontract ThrusterPool is IThrusterPool, NoDelegateCall {\n    using LowGasSafeMath for uint256;\n    using LowGasSafeMath for int256;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using Tick for mapping(int24 => Tick.Info);\n    using TickBitmap for mapping(int16 => uint256);\n    using Position for mapping(bytes32 => Position.Info);\n    using Position for Position.Info;\n    using Oracle for Oracle.Observation[65535];\n\n    IBlast public constant BLAST = IBlast(0x4300000000000000000000000000000000000002);\n    IERC20Rebasing public constant USDB = IERC20Rebasing(0x4200000000000000000000000000000000000022);\n    IERC20Rebasing public constant WETHB = IERC20Rebasing(0x4200000000000000000000000000000000000023);\n\n    /// @inheritdoc IThrusterPoolImmutables\n    address public immutable override factory;\n    /// @inheritdoc IThrusterPoolImmutables\n    address public immutable override token0;\n    /// @inheritdoc IThrusterPoolImmutables\n    address public immutable override token1;\n    /// @inheritdoc IThrusterPoolImmutables\n    uint24 public immutable override fee;\n\n    /// @inheritdoc IThrusterPoolImmutables\n    int24 public immutable override tickSpacing;\n\n    /// @inheritdoc IThrusterPoolImmutables\n    uint128 public immutable override maxLiquidityPerTick;\n\n    struct Slot0 {\n        // the current price\n        uint160 sqrtPriceX96;\n        // the current tick\n        int24 tick;\n        // the most-recently updated index of the observations array\n        uint16 observationIndex;\n        // the current maximum number of observations that are being stored\n        uint16 observationCardinality;\n        // the next maximum number of observations to store, triggered in observations.write\n        uint16 observationCardinalityNext;\n        // the current protocol fee as a percentage of the swap fee taken on withdrawal\n        // represented as an integer denominator (1/x)%\n        uint8 feeProtocol;\n        // whether the pool is locked\n        bool unlocked;\n    }\n    /// @inheritdoc IThrusterPoolState\n\n    Slot0 public override slot0;\n\n    /// @inheritdoc IThrusterPoolState\n    uint256 public override feeGrowthGlobal0X128;\n    /// @inheritdoc IThrusterPoolState\n    uint256 public override feeGrowthGlobal1X128;\n\n    // accumulated protocol fees in token0/token1 units\n    struct ProtocolFees {\n        uint128 token0;\n        uint128 token1;\n    }\n    /// @inheritdoc IThrusterPoolState\n\n    ProtocolFees public override protocolFees;\n\n    /// @inheritdoc IThrusterPoolState\n    uint128 public override liquidity;\n\n    /// @inheritdoc IThrusterPoolState\n    mapping(int24 => Tick.Info) public override ticks;\n    /// @inheritdoc IThrusterPoolState\n    mapping(int16 => uint256) public override tickBitmap;\n    /// @inheritdoc IThrusterPoolState\n    mapping(bytes32 => Position.Info) public override positions;\n    /// @inheritdoc IThrusterPoolState\n    Oracle.Observation[65535] public override observations;\n\n    // Gauges\n    address public gauge;\n\n    /// @dev Mutually exclusive reentrancy protection into the pool to/from a method. This method also prevents entrance\n    /// to a function before the pool is initialized. The reentrancy guard is required throughout the contract because\n    /// we use balance checks to determine the payment status of interactions such as mint, swap and flash.\n    modifier lock() {\n        require(slot0.unlocked, \"LOK\");\n        slot0.unlocked = false;\n        _;\n        slot0.unlocked = true;\n    }\n\n    /// @dev Prevents calling a function from anyone except the address returned by IThrusterPoolFactory#owner()\n    modifier onlyFactoryOwner() {\n        require(msg.sender == IThrusterPoolFactory(factory).owner());\n        _;\n    }\n\n    constructor() {\n        int24 _tickSpacing;\n        BLAST.configureClaimableGas();\n        BLAST.configureClaimableYield();\n        USDB.configure(YieldMode.CLAIMABLE);\n        WETHB.configure(YieldMode.CLAIMABLE);\n        (factory, token0, token1, fee, _tickSpacing) = IThrusterPoolDeployer(msg.sender).parameters();\n        tickSpacing = _tickSpacing;\n\n        maxLiquidityPerTick = Tick.tickSpacingToMaxLiquidityPerTick(_tickSpacing);\n    }\n\n    /// @dev Common checks for valid tick inputs.\n    function checkTicks(int24 tickLower, int24 tickUpper) private pure {\n        require(tickLower < tickUpper, \"TLU\");\n        require(tickLower >= TickMath.MIN_TICK, \"TLM\");\n        require(tickUpper <= TickMath.MAX_TICK, \"TUM\");\n    }\n\n    /// @dev Get the pool's balance of token0\n    /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize\n    /// check\n    function balance0() private view returns (uint256) {\n        (bool success, bytes memory data) =\n            token0.staticcall(abi.encodeWithSelector(IERC20Minimal.balanceOf.selector, address(this)));\n        require(success && data.length >= 32);\n        return abi.decode(data, (uint256));\n    }\n\n    /// @dev Get the pool's balance of token1\n    /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize\n    /// check\n    function balance1() private view returns (uint256) {\n        (bool success, bytes memory data) =\n            token1.staticcall(abi.encodeWithSelector(IERC20Minimal.balanceOf.selector, address(this)));\n        require(success && data.length >= 32);\n        return abi.decode(data, (uint256));\n    }\n\n    /// @inheritdoc IThrusterPoolDerivedState\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        override\n        noDelegateCall\n        returns (int56 tickCumulativeInside, uint160 secondsPerLiquidityInsideX128, uint32 secondsInside)\n    {\n        checkTicks(tickLower, tickUpper);\n\n        int56 tickCumulativeLower;\n        int56 tickCumulativeUpper;\n        uint160 secondsPerLiquidityOutsideLowerX128;\n        uint160 secondsPerLiquidityOutsideUpperX128;\n        uint32 secondsOutsideLower;\n        uint32 secondsOutsideUpper;\n\n        {\n            Tick.Info storage lower = ticks[tickLower];\n            Tick.Info storage upper = ticks[tickUpper];\n            bool initializedLower;\n            (tickCumulativeLower, secondsPerLiquidityOutsideLowerX128, secondsOutsideLower, initializedLower) = (\n                lower.tickCumulativeOutside,\n                lower.secondsPerLiquidityOutsideX128,\n                lower.secondsOutside,\n                lower.initialized\n            );\n            require(initializedLower);\n\n            bool initializedUpper;\n            (tickCumulativeUpper, secondsPerLiquidityOutsideUpperX128, secondsOutsideUpper, initializedUpper) = (\n                upper.tickCumulativeOutside,\n                upper.secondsPerLiquidityOutsideX128,\n                upper.secondsOutside,\n                upper.initialized\n            );\n            require(initializedUpper);\n        }\n\n        Slot0 memory _slot0 = slot0;\n\n        if (_slot0.tick < tickLower) {\n            return (\n                tickCumulativeLower - tickCumulativeUpper,\n                secondsPerLiquidityOutsideLowerX128 - secondsPerLiquidityOutsideUpperX128,\n                secondsOutsideLower - secondsOutsideUpper\n            );\n        } else if (_slot0.tick < tickUpper) {\n            uint32 time = uint32(block.timestamp);\n            (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) = observations.observeSingle(\n                time, 0, _slot0.tick, _slot0.observationIndex, liquidity, _slot0.observationCardinality\n            );\n            return (\n                tickCumulative - tickCumulativeLower - tickCumulativeUpper,\n                secondsPerLiquidityCumulativeX128 - secondsPerLiquidityOutsideLowerX128\n                    - secondsPerLiquidityOutsideUpperX128,\n                time - secondsOutsideLower - secondsOutsideUpper\n            );\n        } else {\n            return (\n                tickCumulativeUpper - tickCumulativeLower,\n                secondsPerLiquidityOutsideUpperX128 - secondsPerLiquidityOutsideLowerX128,\n                secondsOutsideUpper - secondsOutsideLower\n            );\n        }\n    }\n\n    /// @inheritdoc IThrusterPoolDerivedState\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        override\n        noDelegateCall\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s)\n    {\n        return observations.observe(\n            uint32(block.timestamp),\n            secondsAgos,\n            slot0.tick,\n            slot0.observationIndex,\n            liquidity,\n            slot0.observationCardinality\n        );\n    }\n\n    /// @inheritdoc IThrusterPoolActions\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext)\n        external\n        override\n        lock\n        noDelegateCall\n    {\n        uint16 observationCardinalityNextOld = slot0.observationCardinalityNext; // for the event\n        uint16 observationCardinalityNextNew =\n            observations.grow(observationCardinalityNextOld, observationCardinalityNext);\n        slot0.observationCardinalityNext = observationCardinalityNextNew;\n        if (observationCardinalityNextOld != observationCardinalityNextNew) {\n            emit IncreaseObservationCardinalityNext(observationCardinalityNextOld, observationCardinalityNextNew);\n        }\n    }\n\n    /// @inheritdoc IThrusterPoolActions\n    /// @dev not locked because it initializes unlocked\n    function initialize(uint160 sqrtPriceX96) external override {\n        require(slot0.sqrtPriceX96 == 0, \"AI\");\n\n        int24 tick = TickMath.getTickAtSqrtRatio(sqrtPriceX96);\n\n        (uint16 cardinality, uint16 cardinalityNext) = observations.initialize(uint32(block.timestamp));\n\n        slot0 = Slot0({\n            sqrtPriceX96: sqrtPriceX96,\n            tick: tick,\n            observationIndex: 0,\n            observationCardinality: cardinality,\n            observationCardinalityNext: cardinalityNext,\n            feeProtocol: 0,\n            unlocked: true\n        });\n\n        emit Initialize(sqrtPriceX96, tick);\n    }\n\n    struct ModifyPositionParams {\n        // the address that owns the position\n        address owner;\n        // the lower and upper tick of the position\n        int24 tickLower;\n        int24 tickUpper;\n        // any change in liquidity\n        int128 liquidityDelta;\n    }\n\n    /// @dev Effect some changes to a position\n    /// @param params the position details and the change to the position's liquidity to effect\n    /// @return position a storage pointer referencing the position with the given owner and tick range\n    /// @return amount0 the amount of token0 owed to the pool, negative if the pool should pay the recipient\n    /// @return amount1 the amount of token1 owed to the pool, negative if the pool should pay the recipient\n    function _modifyPosition(ModifyPositionParams memory params)\n        private\n        noDelegateCall\n        returns (Position.Info storage position, int256 amount0, int256 amount1)\n    {\n        checkTicks(params.tickLower, params.tickUpper);\n\n        Slot0 memory _slot0 = slot0; // SLOAD for gas optimization\n\n        position = _updatePosition(params.owner, params.tickLower, params.tickUpper, params.liquidityDelta, _slot0.tick);\n\n        if (params.liquidityDelta != 0) {\n            if (_slot0.tick < params.tickLower) {\n                // current tick is below the passed range; liquidity can only become in range by crossing from left to\n                // right, when we'll need _more_ token0 (it's becoming more valuable) so user must provide it\n                amount0 = SqrtPriceMath.getAmount0Delta(\n                    TickMath.getSqrtRatioAtTick(params.tickLower),\n                    TickMath.getSqrtRatioAtTick(params.tickUpper),\n                    params.liquidityDelta\n                );\n            } else if (_slot0.tick < params.tickUpper) {\n                // current tick is inside the passed range\n                uint128 liquidityBefore = liquidity; // SLOAD for gas optimization\n\n                // write an oracle entry\n                (slot0.observationIndex, slot0.observationCardinality) = observations.write(\n                    _slot0.observationIndex,\n                    uint32(block.timestamp),\n                    _slot0.tick,\n                    liquidityBefore,\n                    _slot0.observationCardinality,\n                    _slot0.observationCardinalityNext\n                );\n\n                amount0 = SqrtPriceMath.getAmount0Delta(\n                    _slot0.sqrtPriceX96, TickMath.getSqrtRatioAtTick(params.tickUpper), params.liquidityDelta\n                );\n                amount1 = SqrtPriceMath.getAmount1Delta(\n                    TickMath.getSqrtRatioAtTick(params.tickLower), _slot0.sqrtPriceX96, params.liquidityDelta\n                );\n\n                liquidity = LiquidityMath.addDelta(liquidityBefore, params.liquidityDelta);\n            } else {\n                // current tick is above the passed range; liquidity can only become in range by crossing from right to\n                // left, when we'll need _more_ token1 (it's becoming more valuable) so user must provide it\n                amount1 = SqrtPriceMath.getAmount1Delta(\n                    TickMath.getSqrtRatioAtTick(params.tickLower),\n                    TickMath.getSqrtRatioAtTick(params.tickUpper),\n                    params.liquidityDelta\n                );\n            }\n        }\n    }\n\n    /// @dev Gets and updates a position with the given liquidity delta\n    /// @param owner the owner of the position\n    /// @param tickLower the lower tick of the position's tick range\n    /// @param tickUpper the upper tick of the position's tick range\n    /// @param tick the current tick, passed to avoid sloads\n    function _updatePosition(address owner, int24 tickLower, int24 tickUpper, int128 liquidityDelta, int24 tick)\n        private\n        returns (Position.Info storage position)\n    {\n        position = positions.get(owner, tickLower, tickUpper);\n\n        uint256 _feeGrowthGlobal0X128 = feeGrowthGlobal0X128; // SLOAD for gas optimization\n        uint256 _feeGrowthGlobal1X128 = feeGrowthGlobal1X128; // SLOAD for gas optimization\n\n        // if we need to update the ticks, do it\n        bool flippedLower;\n        bool flippedUpper;\n        if (liquidityDelta != 0) {\n            uint32 time = uint32(block.timestamp);\n            (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) = observations.observeSingle(\n                time, 0, slot0.tick, slot0.observationIndex, liquidity, slot0.observationCardinality\n            );\n\n            flippedLower = ticks.update(\n                tickLower,\n                tick,\n                liquidityDelta,\n                _feeGrowthGlobal0X128,\n                _feeGrowthGlobal1X128,\n                secondsPerLiquidityCumulativeX128,\n                tickCumulative,\n                time,\n                false,\n                maxLiquidityPerTick\n            );\n            flippedUpper = ticks.update(\n                tickUpper,\n                tick,\n                liquidityDelta,\n                _feeGrowthGlobal0X128,\n                _feeGrowthGlobal1X128,\n                secondsPerLiquidityCumulativeX128,\n                tickCumulative,\n                time,\n                true,\n                maxLiquidityPerTick\n            );\n\n            if (flippedLower) {\n                tickBitmap.flipTick(tickLower, tickSpacing);\n            }\n            if (flippedUpper) {\n                tickBitmap.flipTick(tickUpper, tickSpacing);\n            }\n        }\n\n        (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) =\n            ticks.getFeeGrowthInside(tickLower, tickUpper, tick, _feeGrowthGlobal0X128, _feeGrowthGlobal1X128);\n\n        position.update(liquidityDelta, feeGrowthInside0X128, feeGrowthInside1X128);\n\n        // clear any tick data that is no longer needed\n        if (liquidityDelta < 0) {\n            if (flippedLower) {\n                ticks.clear(tickLower);\n            }\n            if (flippedUpper) {\n                ticks.clear(tickUpper);\n            }\n        }\n    }\n\n    /// @inheritdoc IThrusterPoolActions\n    /// @dev noDelegateCall is applied indirectly via _modifyPosition\n    function mint(address recipient, int24 tickLower, int24 tickUpper, uint128 amount, bytes calldata data)\n        external\n        override\n        lock\n        returns (uint256 amount0, uint256 amount1)\n    {\n        require(amount > 0);\n        (, int256 amount0Int, int256 amount1Int) = _modifyPosition(\n            ModifyPositionParams({\n                owner: recipient,\n                tickLower: tickLower,\n                tickUpper: tickUpper,\n                liquidityDelta: int256(amount).toInt128()\n            })\n        );\n\n        amount0 = uint256(amount0Int);\n        amount1 = uint256(amount1Int);\n\n        uint256 balance0Before;\n        uint256 balance1Before;\n        if (amount0 > 0) balance0Before = balance0();\n        if (amount1 > 0) balance1Before = balance1();\n        IThrusterMintCallback(msg.sender).thrusterMintCallback(amount0, amount1, data);\n        if (amount0 > 0) require(balance0Before.add(amount0) <= balance0(), \"M0\");\n        if (amount1 > 0) require(balance1Before.add(amount1) <= balance1(), \"M1\");\n\n        emit Mint(msg.sender, recipient, tickLower, tickUpper, amount, amount0, amount1);\n    }\n\n    /// @inheritdoc IThrusterPoolActions\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external override lock returns (uint128 amount0, uint128 amount1) {\n        // we don't need to checkTicks here, because invalid positions will never have non-zero tokensOwed{0,1}\n        Position.Info storage position = positions.get(msg.sender, tickLower, tickUpper);\n\n        amount0 = amount0Requested > position.tokensOwed0 ? position.tokensOwed0 : amount0Requested;\n        amount1 = amount1Requested > position.tokensOwed1 ? position.tokensOwed1 : amount1Requested;\n\n        if (amount0 > 0) {\n            position.tokensOwed0 -= amount0;\n            TransferHelper.safeTransfer(token0, recipient, amount0);\n        }\n        if (amount1 > 0) {\n            position.tokensOwed1 -= amount1;\n            TransferHelper.safeTransfer(token1, recipient, amount1);\n        }\n\n        emit Collect(msg.sender, recipient, tickLower, tickUpper, amount0, amount1);\n    }\n\n    /// @inheritdoc IThrusterPoolActions\n    /// @dev noDelegateCall is applied indirectly via _modifyPosition\n    function burn(int24 tickLower, int24 tickUpper, uint128 amount)\n        external\n        override\n        lock\n        returns (uint256 amount0, uint256 amount1)\n    {\n        (Position.Info storage position, int256 amount0Int, int256 amount1Int) = _modifyPosition(\n            ModifyPositionParams({\n                owner: msg.sender,\n                tickLower: tickLower,\n                tickUpper: tickUpper,\n                liquidityDelta: -int256(amount).toInt128()\n            })\n        );\n\n        amount0 = uint256(-amount0Int);\n        amount1 = uint256(-amount1Int);\n\n        if (amount0 > 0 || amount1 > 0) {\n            (position.tokensOwed0, position.tokensOwed1) =\n                (position.tokensOwed0 + uint128(amount0), position.tokensOwed1 + uint128(amount1));\n        }\n\n        emit Burn(msg.sender, tickLower, tickUpper, amount, amount0, amount1);\n    }\n\n    struct SwapCache {\n        // the protocol fee for the input token\n        uint8 feeProtocol;\n        // liquidity at the beginning of the swap\n        uint128 liquidityStart;\n        // the timestamp of the current block\n        uint32 blockTimestamp;\n        // the current value of the tick accumulator, computed only if we cross an initialized tick\n        int56 tickCumulative;\n        // the current value of seconds per liquidity accumulator, computed only if we cross an initialized tick\n        uint160 secondsPerLiquidityCumulativeX128;\n        // whether we've computed and cached the above two accumulators\n        bool computedLatestObservation;\n    }\n\n    // the top level state of the swap, the results of which are recorded in storage at the end\n    struct SwapState {\n        // the amount remaining to be swapped in/out of the input/output asset\n        int256 amountSpecifiedRemaining;\n        // the amount already swapped out/in of the output/input asset\n        int256 amountCalculated;\n        // current sqrt(price)\n        uint160 sqrtPriceX96;\n        // the tick associated with the current price\n        int24 tick;\n        // the global fee growth of the input token\n        uint256 feeGrowthGlobalX128;\n        // amount of input token paid as protocol fee\n        uint128 protocolFee;\n        // the current liquidity in range\n        uint128 liquidity;\n    }\n\n    struct StepComputations {\n        // the price at the beginning of the step\n        uint160 sqrtPriceStartX96;\n        // the next tick to swap to from the current tick in the swap direction\n        int24 tickNext;\n        // whether tickNext is initialized or not\n        bool initialized;\n        // sqrt(price) for the next tick (1/0)\n        uint160 sqrtPriceNextX96;\n        // how much is being swapped in in this step\n        uint256 amountIn;\n        // how much is being swapped out\n        uint256 amountOut;\n        // how much fee is being paid in\n        uint256 feeAmount;\n    }\n\n    /// @inheritdoc IThrusterPoolActions\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external override noDelegateCall returns (int256 amount0, int256 amount1) {\n        require(amountSpecified != 0, \"AS\");\n\n        Slot0 memory slot0Start = slot0;\n\n        require(slot0Start.unlocked, \"LOK\");\n        require(\n            zeroForOne\n                ? sqrtPriceLimitX96 < slot0Start.sqrtPriceX96 && sqrtPriceLimitX96 > TickMath.MIN_SQRT_RATIO\n                : sqrtPriceLimitX96 > slot0Start.sqrtPriceX96 && sqrtPriceLimitX96 < TickMath.MAX_SQRT_RATIO,\n            \"SPL\"\n        );\n\n        slot0.unlocked = false;\n\n        SwapCache memory cache = SwapCache({\n            liquidityStart: liquidity,\n            blockTimestamp: uint32(block.timestamp),\n            feeProtocol: zeroForOne ? (slot0Start.feeProtocol % 16) : (slot0Start.feeProtocol >> 4),\n            secondsPerLiquidityCumulativeX128: 0,\n            tickCumulative: 0,\n            computedLatestObservation: false\n        });\n\n        if (address(gauge) != address(0)) {\n            IThrusterGauge(gauge).checkpoint(cache.blockTimestamp);\n        }\n\n        bool exactInput = amountSpecified > 0;\n\n        SwapState memory state = SwapState({\n            amountSpecifiedRemaining: amountSpecified,\n            amountCalculated: 0,\n            sqrtPriceX96: slot0Start.sqrtPriceX96,\n            tick: slot0Start.tick,\n            feeGrowthGlobalX128: zeroForOne ? feeGrowthGlobal0X128 : feeGrowthGlobal1X128,\n            protocolFee: 0,\n            liquidity: cache.liquidityStart\n        });\n\n        // continue swapping as long as we haven't used the entire input/output and haven't reached the price limit\n        while (state.amountSpecifiedRemaining != 0 && state.sqrtPriceX96 != sqrtPriceLimitX96) {\n            StepComputations memory step;\n\n            step.sqrtPriceStartX96 = state.sqrtPriceX96;\n\n            (step.tickNext, step.initialized) =\n                tickBitmap.nextInitializedTickWithinOneWord(state.tick, tickSpacing, zeroForOne);\n\n            // ensure that we do not overshoot the min/max tick, as the tick bitmap is not aware of these bounds\n            if (step.tickNext < TickMath.MIN_TICK) {\n                step.tickNext = TickMath.MIN_TICK;\n            } else if (step.tickNext > TickMath.MAX_TICK) {\n                step.tickNext = TickMath.MAX_TICK;\n            }\n\n            // get the price for the next tick\n            step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);\n\n            // compute values to swap to the target tick, price limit, or point where input/output amount is exhausted\n            (state.sqrtPriceX96, step.amountIn, step.amountOut, step.feeAmount) = SwapMath.computeSwapStep(\n                state.sqrtPriceX96,\n                (zeroForOne ? step.sqrtPriceNextX96 < sqrtPriceLimitX96 : step.sqrtPriceNextX96 > sqrtPriceLimitX96)\n                    ? sqrtPriceLimitX96\n                    : step.sqrtPriceNextX96,\n                state.liquidity,\n                state.amountSpecifiedRemaining,\n                fee\n            );\n\n            if (exactInput) {\n                state.amountSpecifiedRemaining -= (step.amountIn + step.feeAmount).toInt256();\n                state.amountCalculated = state.amountCalculated.sub(step.amountOut.toInt256());\n            } else {\n                state.amountSpecifiedRemaining += step.amountOut.toInt256();\n                state.amountCalculated = state.amountCalculated.add((step.amountIn + step.feeAmount).toInt256());\n            }\n\n            // if the protocol fee is on, calculate how much is owed, decrement feeAmount, and increment protocolFee\n            if (cache.feeProtocol > 0) {\n                uint256 delta = step.feeAmount / cache.feeProtocol;\n                step.feeAmount -= delta;\n                state.protocolFee += uint128(delta);\n            }\n\n            // update global fee tracker\n            if (state.liquidity > 0) {\n                state.feeGrowthGlobalX128 += FullMath.mulDiv(step.feeAmount, FixedPoint128.Q128, state.liquidity);\n            }\n\n            // shift tick if we reached the next price\n            if (state.sqrtPriceX96 == step.sqrtPriceNextX96) {\n                // if the tick is initialized, run the tick transition\n                if (step.initialized) {\n                    // check for the placeholder value, which we replace with the actual value the first time the swap\n                    // crosses an initialized tick\n                    if (!cache.computedLatestObservation) {\n                        (cache.tickCumulative, cache.secondsPerLiquidityCumulativeX128) = observations.observeSingle(\n                            cache.blockTimestamp,\n                            0,\n                            slot0Start.tick,\n                            slot0Start.observationIndex,\n                            cache.liquidityStart,\n                            slot0Start.observationCardinality\n                        );\n                        cache.computedLatestObservation = true;\n                    }\n\n                    if (gauge != address(0)) {\n                        IThrusterGauge(gauge).cross(step.tickNext, zeroForOne);\n                    }\n\n                    int128 liquidityNet = ticks.cross(\n                        step.tickNext,\n                        (zeroForOne ? state.feeGrowthGlobalX128 : feeGrowthGlobal0X128),\n                        (zeroForOne ? feeGrowthGlobal1X128 : state.feeGrowthGlobalX128),\n                        cache.secondsPerLiquidityCumulativeX128,\n                        cache.tickCumulative,\n                        cache.blockTimestamp\n                    );\n                    // if we're moving leftward, we interpret liquidityNet as the opposite sign\n                    // safe because liquidityNet cannot be type(int128).min\n                    if (zeroForOne) liquidityNet = -liquidityNet;\n\n                    state.liquidity = LiquidityMath.addDelta(state.liquidity, liquidityNet);\n                }\n\n                state.tick = zeroForOne ? step.tickNext - 1 : step.tickNext;\n            } else if (state.sqrtPriceX96 != step.sqrtPriceStartX96) {\n                // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved\n                state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);\n            }\n        }\n\n        // update tick and write an oracle entry if the tick change\n        if (state.tick != slot0Start.tick) {\n            (uint16 observationIndex, uint16 observationCardinality) = observations.write(\n                slot0Start.observationIndex,\n                cache.blockTimestamp,\n                slot0Start.tick,\n                cache.liquidityStart,\n                slot0Start.observationCardinality,\n                slot0Start.observationCardinalityNext\n            );\n            (slot0.sqrtPriceX96, slot0.tick, slot0.observationIndex, slot0.observationCardinality) =\n                (state.sqrtPriceX96, state.tick, observationIndex, observationCardinality);\n        } else {\n            // otherwise just update the price\n            slot0.sqrtPriceX96 = state.sqrtPriceX96;\n        }\n\n        // update liquidity if it changed\n        if (cache.liquidityStart != state.liquidity) liquidity = state.liquidity;\n\n        // update fee growth global and, if necessary, protocol fees\n        // overflow is acceptable, protocol has to withdraw before it hits type(uint128).max fees\n        if (zeroForOne) {\n            feeGrowthGlobal0X128 = state.feeGrowthGlobalX128;\n            if (state.protocolFee > 0) protocolFees.token0 += state.protocolFee;\n        } else {\n            feeGrowthGlobal1X128 = state.feeGrowthGlobalX128;\n            if (state.protocolFee > 0) protocolFees.token1 += state.protocolFee;\n        }\n\n        (amount0, amount1) = zeroForOne == exactInput\n            ? (amountSpecified - state.amountSpecifiedRemaining, state.amountCalculated)\n            : (state.amountCalculated, amountSpecified - state.amountSpecifiedRemaining);\n\n        // do the transfers and collect payment\n        if (zeroForOne) {\n            if (amount1 < 0) TransferHelper.safeTransfer(token1, recipient, uint256(-amount1));\n\n            uint256 balance0Before = balance0();\n            IThrusterSwapCallback(msg.sender).thrusterSwapCallback(amount0, amount1, data);\n            require(balance0Before.add(uint256(amount0)) <= balance0(), \"IIA\");\n        } else {\n            if (amount0 < 0) TransferHelper.safeTransfer(token0, recipient, uint256(-amount0));\n\n            uint256 balance1Before = balance1();\n            IThrusterSwapCallback(msg.sender).thrusterSwapCallback(amount0, amount1, data);\n            require(balance1Before.add(uint256(amount1)) <= balance1(), \"IIA\");\n        }\n\n        emit Swap(msg.sender, recipient, amount0, amount1, state.sqrtPriceX96, state.liquidity, state.tick);\n        IThrusterPoolFactory(factory).emitSwap(\n            msg.sender, recipient, amount0, amount1, state.sqrtPriceX96, state.liquidity, state.tick\n        );\n        slot0.unlocked = true;\n    }\n\n    /// @inheritdoc IThrusterPoolOwnerActions\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external override lock onlyFactoryOwner {\n        require(\n            (feeProtocol0 == 0 || (feeProtocol0 >= 4 && feeProtocol0 <= 10))\n                && (feeProtocol1 == 0 || (feeProtocol1 >= 4 && feeProtocol1 <= 10))\n        );\n        slot0.feeProtocol = feeProtocol0 + (feeProtocol1 << 4);\n    }\n\n    /// @inheritdoc IThrusterPoolOwnerActions\n    function collectProtocol(address recipient, uint128 amount0Requested, uint128 amount1Requested)\n        external\n        override\n        lock\n        onlyFactoryOwner\n        returns (uint128 amount0, uint128 amount1)\n    {\n        amount0 = amount0Requested > protocolFees.token0 ? protocolFees.token0 : amount0Requested;\n        amount1 = amount1Requested > protocolFees.to"
    }
  ]
}