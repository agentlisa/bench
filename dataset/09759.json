{
  "Title": "[N-02] Multiple `address` mappings can be combined into a single `mapping` of an `address` to a `struct`, where appropriate",
  "Content": "\nFile: erc20-1.0.0-beta.2/contracts/ERC20.sol (lines [32-34](https://github.com/maple-labs/erc20/blob/10ccf4aa0b2d6914e3c2d32e454e4d106a99a4fd/contracts/ERC20.sol#L32-L34))<br>\n\n```solidity\nmapping(address => uint256) public override balanceOf;\n\nmapping(address => mapping(address => uint256)) public override allowance;\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-03-maple",
  "Code": [
    {
      "filename": "contracts/ERC20.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.7;\n\nimport { IERC20 } from \"./interfaces/IERC20.sol\";\n\n/*\n    ███████╗██████╗  ██████╗    ██████╗  ██████╗\n    ██╔════╝██╔══██╗██╔════╝    ╚════██╗██╔═████╗\n    █████╗  ██████╔╝██║          █████╔╝██║██╔██║\n    ██╔══╝  ██╔══██╗██║         ██╔═══╝ ████╔╝██║\n    ███████╗██║  ██║╚██████╗    ███████╗╚██████╔╝\n    ╚══════╝╚═╝  ╚═╝ ╚═════╝    ╚══════╝ ╚═════╝\n*/\n\n/**\n *  @title Modern ERC-20 implementation.\n *  @dev   Acknowledgements to Solmate, OpenZeppelin, and DSS for inspiring this code.\n */\ncontract ERC20 is IERC20 {\n\n    /**************/\n    /*** ERC-20 ***/\n    /**************/\n\n    string public override name;\n    string public override symbol;\n\n    uint8 public immutable override decimals;\n\n    uint256 public override totalSupply;\n\n    mapping(address => uint256) public override balanceOf;\n\n    mapping(address => mapping(address => uint256)) public override allowance;\n\n    /****************/\n    /*** ERC-2612 ***/\n    /****************/\n\n    // PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 amount,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant override PERMIT_TYPEHASH = bytes32(0xfc77c2b9d30fe91687fd39abb7d16fcdfe1472d065740051ab8b13e4bf4a617f);\n\n    mapping(address => uint256) public override nonces;\n\n    /**\n     *  @param name_     The name of the token.\n     *  @param symbol_   The symbol of the token.\n     *  @param decimals_ The decimal precision used by the token.\n     */\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) {\n        name     = name_;\n        symbol   = symbol_;\n        decimals = decimals_;\n    }\n\n    /**************************/\n    /*** External Functions ***/\n    /**************************/\n\n    function approve(address spender_, uint256 amount_) external override returns (bool success_) {\n        _approve(msg.sender, spender_, amount_);\n        return true;\n    }\n\n    function decreaseAllowance(address spender_, uint256 subtractedAmount_) external override returns (bool success_) {\n        _approve(msg.sender, spender_, allowance[msg.sender][spender_] - subtractedAmount_);\n        return true;\n    }\n\n    function increaseAllowance(address spender_, uint256 addedAmount_) external override returns (bool success_) {\n        _approve(msg.sender, spender_, allowance[msg.sender][spender_] + addedAmount_);\n        return true;\n    }\n\n    function permit(address owner_, address spender_, uint256 amount_, uint256 deadline_, uint8 v_, bytes32 r_, bytes32 s_) external override {\n        require(deadline_ >= block.timestamp, \"ERC20:P:EXPIRED\");\n\n        // Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}.\n        require(\n            uint256(s_) <= uint256(0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) &&\n            (v_ == 27 || v_ == 28),\n            \"ERC20:P:MALLEABLE\"\n        );\n\n        // Nonce realistically cannot overflow.\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner_, spender_, amount_, nonces[owner_]++, deadline_))\n                )\n            );\n\n            address recoveredAddress = ecrecover(digest, v_, r_, s_);\n\n            require(recoveredAddress == owner_ && owner_ != address(0), \"ERC20:P:INVALID_SIGNATURE\");\n        }\n\n        _approve(owner_, spender_, amount_);\n    }\n\n    function transfer(address recipient_, uint256 amount_) external override returns (bool success_) {\n        _transfer(msg.sender, recipient_, amount_);\n        return true;\n    }\n\n    function transferFrom(address owner_, address recipient_, uint256 amount_) external override returns (bool success_) {\n        _approve(owner_, msg.sender, allowance[owner_][msg.sender] - amount_);\n        _transfer(owner_, recipient_, amount_);\n        return true;\n    }\n\n    /**********************/\n    /*** View Functions ***/\n    /**********************/\n\n    function DOMAIN_SEPARATOR() public view override returns (bytes32 domainSeparator_) {\n        return keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n\n    /**************************/\n    /*** Internal Functions ***/\n    /**************************/\n\n    function _approve(address owner_, address spender_, uint256 amount_) internal {\n        emit Approval(owner_, spender_, allowance[owner_][spender_] = amount_);\n    }\n\n    function _burn(address owner_, uint256 amount_) internal {\n        balanceOf[owner_] -= amount_;\n\n        // Cannot underflow because a user's balance will never be larger than the total supply.\n        unchecked { totalSupply -= amount_; }\n\n        emit Transfer(owner_, address(0), amount_);\n    }\n\n    function _mint(address recipient_, uint256 amount_) internal {\n        totalSupply += amount_;\n\n        // Cannot overflow because totalSupply would first overflow in the statement above.\n        unchecked { balanceOf[recipient_] += amount_; }\n\n        emit Transfer(address(0), recipient_, amount_);\n    }\n\n    function _transfer(address owner_, address recipient_, uint256 amount_) internal {\n        balanceOf[owner_] -= amount_;\n\n        // Cannot overflow because minting prevents overflow of totalSupply, and sum of user balances == totalSupply.\n        unchecked { balanceOf[recipient_] += amount_; }\n\n        emit Transfer(owner_, recipient_, amount_);\n    }\n\n}"
    }
  ]
}