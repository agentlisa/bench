{
  "Title": "M-8: If the vault's side token balance is 0 or a tiny amount, then most if not all IG Bear trades will revert due to incorrect check of computation error during delta hedge amount calculation",
  "Content": "# Issue M-8: If the vault's side token balance is 0 or a tiny amount, then most if not all IG Bear trades will revert due to incorrect check of computation error during delta hedge amount calculation \n\nSource: https://github.com/sherlock-audit/2024-02-smilee-finance-judging/issues/100 \n\n## Found by \npanprog\n## Summary\n\nWhen delta hedge amount is calculated in `FinanceIGDelta.deltaHedgeAmount`, the last step is to verify that delta hedge amount to sell is slightly more than vault's side token due to computation error. The check is the following:\n```solidity\n    if (SignedMath.abs(tokensToSwap) > params.sideTokensAmount) {\n        if (SignedMath.abs(tokensToSwap) - params.sideTokensAmount < params.sideTokensAmount / 10000) {\n            tokensToSwap = SignedMath.revabs(params.sideTokensAmount, true);\n        }\n    }\n```\n\nThe check works correctly most of the time, but if the vault's side token (`param.sideTokensAmount`) is 0 or close to it, then the check will always fail, because `0 / 10000 = 0` and unsigned amount can not be less than 0. This means that even tiny amount to sell (like 1 wei) will revert the transaction if the vault has 0 side tokens.\n\n## Vulnerability Detail\n\nVault's side token is 0 when:\n- the current price trades above high boundary (Kb)\n- **and** IG Bull used liquidity equals 0\n\nIn such situation, any IG bear trade doesn't impact hedge amount, but due to computation error will almost always result in tiny but non-0 side token amount to sell value, which will revert due to incorrect comparision described above.\n\n## Impact\n\nAlmost all IG Bear trades will revert in certain situations, leading to core protocol function being unavailable and potentially loss of funds to the users who expected to do these trades.\n\n## Proof Of Concept\n\nCopy to `attack.t.sol`:\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.15;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {console} from \"forge-std/console.sol\";\nimport {UD60x18, ud, convert} from \"@prb/math/UD60x18.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IPositionManager} from \"@project/interfaces/IPositionManager.sol\";\nimport {Epoch} from \"@project/lib/EpochController.sol\";\nimport {AmountsMath} from \"@project/lib/AmountsMath.sol\";\nimport {EpochFrequency} from \"@project/lib/EpochFrequency.sol\";\nimport {OptionStrategy} from \"@project/lib/OptionStrategy.sol\";\nimport {AddressProvider} from \"@project/AddressProvider.sol\";\nimport {MarketOracle} from \"@project/MarketOracle.sol\";\nimport {FeeManager} from \"@project/FeeManager.sol\";\nimport {Vault} from \"@project/Vault.sol\";\nimport {TestnetToken} from \"@project/testnet/TestnetToken.sol\";\nimport {TestnetPriceOracle} from \"@project/testnet/TestnetPriceOracle.sol\";\nimport {DVPUtils} from \"./utils/DVPUtils.sol\";\nimport {TokenUtils} from \"./utils/TokenUtils.sol\";\nimport {Utils} from \"./utils/Utils.sol\";\nimport {VaultUtils} from \"./utils/VaultUtils.sol\";\nimport {MockedIG} from \"./mock/MockedIG.sol\";\nimport {MockedRegistry} from \"./mock/MockedRegistry.sol\";\nimport {MockedVault} from \"./mock/MockedVault.sol\";\nimport {TestnetSwapAdapter} from \"@project/testnet/TestnetSwapAdapter.sol\";\nimport {PositionManager} from \"@project/periphery/PositionManager.sol\";\n\n\ncontract IGTradeTest is Test {\n    using AmountsMath for uint256;\n\n    address admin = address(0x1);\n\n    // User of Vault\n    address alice = address(0x2);\n    address bob = address(0x3);\n\n    //User of DVP\n    address charlie = address(0x4);\n    address david = address(0x5);\n\n    AddressProvider ap;\n    TestnetToken baseToken;\n    TestnetToken sideToken;\n    FeeManager feeManager;\n\n    MockedRegistry registry;\n\n    MockedVault vault;\n    MockedIG ig;\n    TestnetPriceOracle priceOracle;\n    TestnetSwapAdapter exchange;\n    uint _strike;\n\n    function setUp() public {\n        vm.warp(EpochFrequency.REF_TS);\n        //ToDo: Replace with Factory\n        vm.startPrank(admin);\n        ap = new AddressProvider(0);\n        registry = new MockedRegistry();\n        ap.grantRole(ap.ROLE_ADMIN(), admin);\n        registry.grantRole(registry.ROLE_ADMIN(), admin);\n        ap.setRegistry(address(registry));\n\n        vm.stopPrank();\n\n        vault = MockedVault(VaultUtils.createVault(EpochFrequency.WEEKLY, ap, admin, vm));\n        priceOracle = TestnetPriceOracle(ap.priceOracle());\n\n        baseToken = TestnetToken(vault.baseToken());\n        sideToken = TestnetToken(vault.sideToken());\n\n        vm.startPrank(admin);\n       \n        ig = new MockedIG(address(vault), address(ap));\n        ig.grantRole(ig.ROLE_ADMIN(), admin);\n        ig.grantRole(ig.ROLE_EPOCH_ROLLER(), admin);\n        vault.grantRole(vault.ROLE_ADMIN(), admin);\n        vm.stopPrank();\n        ig.setOptionPrice(1e3);\n        ig.setPayoffPerc(0.1e18); // 10 % -> position paying 1.1\n        ig.useRealDeltaHedge();\n        ig.useRealPercentage();\n        ig.useRealPremium();\n\n        DVPUtils.disableOracleDelayForIG(ap, ig, admin, vm);\n\n        vm.prank(admin);\n        registry.registerDVP(address(ig));\n        vm.prank(admin);\n        MockedVault(vault).setAllowedDVP(address(ig));\n        feeManager = FeeManager(ap.feeManager());\n\n        exchange = TestnetSwapAdapter(ap.exchangeAdapter());\n    }\n\n    // try to buy/sell ig bull below strike for user's profit\n    // this will not be hedged, and thus the vault should lose funds\n    function test() public {\n        _strike = 1e18;\n        VaultUtils.addVaultDeposit(alice, 1e18, admin, address(vault), vm);\n        VaultUtils.addVaultDeposit(bob, 1e18, admin, address(vault), vm);\n\n        Utils.skipWeek(true, vm);\n\n        vm.prank(admin);\n        ig.rollEpoch();\n\n        VaultUtils.logState(vault);\n        DVPUtils.debugState(ig);\n\n        testBuyOption(1.24e18, 1, 0); // re-balance to have 0 side tokens\n        testBuyOption(1.24e18, 0, 0.1e18); // reverts due to computation error and incorrect check to fix it\n    }\n\n    function testBuyOption(uint price, uint128 optionAmountUp, uint128 optionAmountDown) internal {\n\n        vm.prank(admin);\n        priceOracle.setTokenPrice(address(sideToken), price);\n\n        (uint256 premium, uint256 fee) = _assurePremium(charlie, _strike, optionAmountUp, optionAmountDown);\n\n        vm.startPrank(charlie);\n        premium = ig.mint(charlie, _strike, optionAmountUp, optionAmountDown, premium, 10e18, 0);\n        vm.stopPrank();\n\n        console.log(\"premium\", premium);\n    }\n\n    function testSellOption(uint price, uint128 optionAmountUp, uint128 optionAmountDown) internal returns (uint) {\n        vm.prank(admin);\n        priceOracle.setTokenPrice(address(sideToken), price);\n\n        uint256 charliePayoff;\n        uint256 charliePayoffFee;\n        {\n            vm.startPrank(charlie);\n            (charliePayoff, charliePayoffFee) = ig.payoff(\n                ig.currentEpoch(),\n                _strike,\n                optionAmountUp,\n                optionAmountDown\n            );\n\n            charliePayoff = ig.burn(\n                ig.currentEpoch(),\n                charlie,\n                _strike,\n                optionAmountUp,\n                optionAmountDown,\n                charliePayoff,\n                0.1e18\n            );\n            vm.stopPrank();\n\n            console.log(\"payoff received\", charliePayoff);\n        }\n    }\n\n    function _assurePremium(\n        address user,\n        uint256 strike,\n        uint256 amountUp,\n        uint256 amountDown\n    ) private returns (uint256 premium_, uint256 fee) {\n        (premium_, fee) = ig.premium(strike, amountUp, amountDown);\n        TokenUtils.provideApprovedTokens(admin, address(baseToken), user, address(ig), premium_*5, vm);\n    }\n}\n```\n\nNotice: execution will revert when trying to buy IG Bear options.\n\n## Code Snippet\n\n`FinanceIGDelta.deltaHedgeAmount` will always revert for 0 or tiny side token amounts:\nhttps://github.com/sherlock-audit/2024-02-smilee-finance/blob/main/smilee-v2-contracts/src/lib/FinanceIGDelta.sol#L111-L113\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nPossibly check both relative (sideToken / 10000) and absolute (e.g. 1000 or `side token UNIT / 10000`) value. Alternatively, always limit side token to sell amount to max of side token balance when hedging (but needs additional research if that might create issues).\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid; medium(8)\n\n\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/dverso/smilee-v2-contracts/commit/a83d79fbd1f7be48f69d36e0cd5812c333a44ce8.\n\n**panprog**\n\nFix review: Fixed\n\n**sherlock-admin4**\n\nThe Lead Senior Watson signed off on the fix.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/180",
  "Code": [
    {
      "filename": "smilee-v2-contracts/src/lib/FinanceIGDelta.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.19;\n\nimport {SD59x18, sd, convert as convertint} from \"@prb/math/SD59x18.sol\";\nimport {UD60x18, ud, convert} from \"@prb/math/UD60x18.sol\";\nimport {AmountsMath} from \"./AmountsMath.sol\";\nimport {SignedMath} from \"./SignedMath.sol\";\n\n/// @title Implementation of core financial computations for Smilee protocol\nlibrary FinanceIGDelta {\n    /// @notice A wrapper for the input parameters of delta perc functions\n    struct Parameters {\n        // strike\n        uint256 k;\n        // lower bound liquidity range\n        uint256 kA;\n        // upper bound liquidity range\n        uint256 kB;\n        // reference price\n        uint256 s;\n        // theta factor\n        uint256 theta;\n    }\n\n    struct DeltaHedgeParameters {\n        int256 igDBull;\n        int256 igDBear;\n        uint8 baseTokenDecimals;\n        uint8 sideTokenDecimals;\n        uint256 initialLiquidityBull;\n        uint256 initialLiquidityBear;\n        uint256 availableLiquidityBull;\n        uint256 availableLiquidityBear;\n        uint256 sideTokensAmount;\n        int256 notionalUp;\n        int256 notionalDown;\n        uint256 strike;\n        uint256 theta;\n        uint256 kb;\n    }\n\n    int256 internal constant _MAX_EXP = 133_084258667509499441;\n\n    /**\n        @notice Computes unitary delta hedge quantity for bull/bear options\n        @param params The set of Parameters to compute deltas\n        @return igDBull The unitary integer quantity of side token to hedge a bull position\n        @return igDBear The unitary integer quantity of side token to hedge a bear position\n        @dev the formulas are the ones for different ranges of liquidity\n    */\n    function deltaHedgePercentages(Parameters calldata params) external pure returns (int256 igDBull, int256 igDBear) {\n        igDBull = bullDelta(params.k, params.kB, params.s, params.theta);\n        igDBear = bearDelta(params.k, params.kA, params.s, params.theta);\n    }\n\n    /**\n        @notice Gives the amount of side tokens to swap in order to hedge protocol delta exposure\n        @param params The DeltaHedgeParameters info\n        @return tokensToSwap An integer amount, positive when there are side tokens in excess (need to sell) and negative vice versa\n        @dev This is what's called `h` in the papers\n     */\n    function deltaHedgeAmount(DeltaHedgeParameters memory params) public pure returns (int256 tokensToSwap) {\n        params.initialLiquidityBull = AmountsMath.wrapDecimals(params.initialLiquidityBull, params.baseTokenDecimals);\n        params.initialLiquidityBear = AmountsMath.wrapDecimals(params.initialLiquidityBear, params.baseTokenDecimals);\n        params.availableLiquidityBull = AmountsMath.wrapDecimals(\n            params.availableLiquidityBull,\n            params.baseTokenDecimals\n        );\n        params.availableLiquidityBear = AmountsMath.wrapDecimals(\n            params.availableLiquidityBear,\n            params.baseTokenDecimals\n        );\n\n        uint256 notionalBull = AmountsMath.wrapDecimals(SignedMath.abs(params.notionalUp), params.baseTokenDecimals);\n        uint256 notionalBear = AmountsMath.wrapDecimals(SignedMath.abs(params.notionalDown), params.baseTokenDecimals);\n        params.sideTokensAmount = AmountsMath.wrapDecimals(params.sideTokensAmount, params.sideTokenDecimals);\n\n        uint256 protoNotionalBull = params.notionalUp >= 0\n            ? ud(params.availableLiquidityBull).sub(ud(notionalBull)).unwrap()\n            : ud(params.availableLiquidityBull).add(ud(notionalBull)).unwrap();\n\n        uint256 protoNotionalBear = params.notionalDown >= 0\n            ? ud(params.availableLiquidityBear).sub(ud(notionalBear)).unwrap()\n            : ud(params.availableLiquidityBear).add(ud(notionalBear)).unwrap();\n\n        uint256 protoDBull = 2 * ud(SignedMath.abs(params.igDBull))\n            .mul(ud(protoNotionalBull))\n            .unwrap();\n        uint256 protoDBear = 2 * ud(SignedMath.abs(params.igDBear))\n            .mul(ud(protoNotionalBear))\n            .unwrap();\n\n        uint256 deltaLimit;\n        {\n            UD60x18 v0 = ud(params.initialLiquidityBull + params.initialLiquidityBear);\n            UD60x18 strike = ud(params.strike);\n            UD60x18 theta = ud(params.theta);\n            UD60x18 kb = ud(params.kb);\n            // DeltaLimit := v0 / (θ * k) - v0 / (θ * √(K * Kb))\n            deltaLimit = v0.div(theta.mul(strike)).sub(v0.div(theta.mul(strike.mul(kb).sqrt()))).unwrap();\n        }\n\n        tokensToSwap =\n            SignedMath.revabs(protoDBull, params.igDBull >= 0) +\n            SignedMath.revabs(protoDBear, params.igDBear >= 0) +\n            SignedMath.castInt(params.sideTokensAmount) -\n            SignedMath.castInt(deltaLimit);\n\n        // due to sqrt computation error, sideTokens to sell may be very few more than available\n        if (SignedMath.abs(tokensToSwap) > params.sideTokensAmount) {\n            if (SignedMath.abs(tokensToSwap) - params.sideTokensAmount < params.sideTokensAmount / 10000) {\n                tokensToSwap = SignedMath.revabs(params.sideTokensAmount, true);\n            }\n        }\n        params.sideTokensAmount = SignedMath.abs(tokensToSwap);\n        params.sideTokensAmount = AmountsMath.unwrapDecimals(params.sideTokensAmount, params.sideTokenDecimals);\n        tokensToSwap = SignedMath.revabs(params.sideTokensAmount, tokensToSwap >= 0);\n    }\n\n    ////// HELPERS //////\n\n    /**\n        Δ_bull = (1 / θ) * F\n        F = {\n            * 0                     if (S < K)\n            * (1 - √(K / Kb)) / K   if (S > Kb)\n            * 1 / K - 1 / √(S * K)  if (K < S < Kb)\n        }\n    */\n    function bullDelta(uint256 k, uint256 kB, uint256 s, uint256 theta) internal pure returns (int256) {\n        SD59x18 delta;\n        if (s <= k) {\n            return 0;\n        }\n        if (s > kB) {\n            delta = (convertint(1).sub((sd(int256(k)).div(sd(int256(kB)))).sqrt())).div(sd(int256(k)));\n        } else {\n            // if (k < s < kB)\n            delta = _inRangeDelta(k, s);\n        }\n        return delta.div(sd(int256(theta))).unwrap();\n    }\n\n    /**\n        Δ_bear = (1 / θ) * F\n        F = {\n            * (1 - √(K / Ka)) / K   if (S < Ka)\n            * 0                     if (S > K)\n            * 1 / K - 1 / √(S * K)  if (Ka < S < K)\n        }\n    */\n    function bearDelta(uint256 k, uint256 kA, uint256 s, uint256 theta) internal pure returns (int256) {\n        SD59x18 delta;\n        if (s >= k) {\n            return 0;\n        }\n        if (s < kA) {\n            delta = (convertint(1).sub((sd(int256(k)).div(sd(int256(kA)))).sqrt())).div(sd(int256(k)));\n        } else {\n            // if (kA < s < k)\n            delta = _inRangeDelta(k, s);\n        }\n        return delta.div(sd(int256(theta))).unwrap();\n    }\n\n    /// @dev (1 / K) - 1 / √(S * K)\n    function _inRangeDelta(uint256 k, uint256 s) internal pure returns (SD59x18) {\n        return (convertint(1).div(sd(int256(k)))).sub(convertint(1).div((sd(int256(s)).mul(sd(int256(k))).sqrt())));\n    }\n}"
    }
  ]
}