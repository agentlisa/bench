{
  "Title": "H-1: `liquidatePartyA` requires signature which doesn't have nonce, making possible unfair liquidation and loss of funds for all parties",
  "Content": "# Issue H-1: `liquidatePartyA` requires signature which doesn't have nonce, making possible unfair liquidation and loss of funds for all parties \n\nSource: https://github.com/sherlock-audit/2023-08-symmetrical-judging/issues/5 \n\n## Found by \npanprog, xiaoming90\n\n`liquidationSig` provided by liquidator to `liquidatePartyA` doesn't have nonces of neither partyA nor partyB. This means that this signature is valid even if partyA and/or partyB do some actions before the liquidation with this signature happens. There are numerous scenarios possible, both happening by itself and caused by malicious parties, where this can lead to loss of funds for some or all parties involved.\n\n## Vulnerability Detail\n\nExample Scenario:\n\n1. PartyA: allocated=109, upnl=-99, cva+lf=10. To avoid liquidation, partyA tries to close 50% of its position, submitting requestToClosePosition\n2. PartyA: allocated=109, upnl=-100, cva+lf=10. PartyA becomes liquidatable\n3. Liquidator submits liquidating transaction (with upnl=-100), but partyB at the same time fulfills partyA request\n3. partyB transaction executes first, partyA has: allocated = 59, upnl=-50, cva+lf=5 (not liquidatable anymore)\n4. Liquidator transaction executes (with upnl=-100):\n4.1. Available Balance = 59-5 - 100 = -46\n4.2. Liquidation type = OVERDUE (46 > 5), deficit = 41\n4.3. Corresponding partyB receives 50 - 50*46/100 = 27\n4.4. PartyA allocated balance is set to 0\n4.5. Liquidators receives 0 (because it's OVERDUE liquidation)\n\nThe result: \n1. PartyA was solvent just before the liquidation, but was still liquidated, losing all funds\n2. PartyB has received 27 instead of full 50 profit (even though partyA had enough funds)\n3. Liquidator didn't receive any fee, although it should have received it as partyA had enough funds.\n\nAll 3 parties have lost funds. Protocol basically stole those funds.\n\n## Impact\n\nUnfair liquidation for partyA, loss of funds for liquidator and partyB in many possible situations during partyA liquidation - happening by itself or caused by malicious actors.\n\n## Proof of Concept\n\nAdd this to any test, for example to `ClosePosition.behavior.ts`.\n\n```ts\nit(\"PartyA wrong upnl liquidation\", async function () {\n  const context: RunContext = this.context;\n\n  this.user_allocated = decimal(119);\n  this.hedger_allocated = decimal(1000);\n  \n  this.user = new User(this.context, this.context.signers.user);\n  await this.user.setup();\n  await this.user.setBalances(this.user_allocated, this.user_allocated, this.user_allocated);\n\n  this.hedger = new Hedger(this.context, this.context.signers.hedger);\n  await this.hedger.setup();\n  await this.hedger.setBalances(this.hedger_allocated, this.hedger_allocated);\n\n  this.liquidator = new User(this.context, this.context.signers.liquidator);\n  await this.liquidator.setup();\n\n  // open position (100 @ 10)\n  await this.user.sendQuote(limitQuoteRequestBuilder()\n    .positionType(PositionType.LONG)\n    .quantity(decimal(100))\n    .price(decimal(10))\n    .cva(decimal(6)).lf(decimal(4)).mm(decimal(10))\n    .build()\n  );\n  await this.hedger.lockQuote(1, 0, decimal(1));\n  await this.hedger.openPosition(1, limitOpenRequestBuilder().filledAmount(decimal(100)).openPrice(decimal(10)).price(decimal(10)).build());\n\n  var info = await this.user.getBalanceInfo();\n  console.log(\"partyA allocated: \" + info.allocatedBalances / 1e18 + \" locked: \" + info.totalLocked/1e18 + \" pendingLocked: \" + info.totalPendingLocked / 1e18);\n  var info = await this.hedger.getBalanceInfo(this.user.getAddress());\n  console.log(\"partyB allocated: \" + info.allocatedBalances / 1e18 + \" locked: \" + info.totalLocked/1e18 + \" pendingLocked: \" + info.totalPendingLocked / 1e18);\n\n  // price goes to 9, so user is in a loss of -100 (less fee), locked balance = 10, so liquidatable\n  // user tries to close half of its position to save liquidation\n  //await this.user.setBalances(this.user_allocated, this.user_allocated, this.user_allocated);\n  await this.user.requestToClosePosition(\n    1,\n    limitCloseRequestBuilder().quantityToClose(decimal(50)).closePrice(decimal(9)).build(),\n  );\n\n  // liquidators obtains signature to liquidate\n  var sig = await getDummyLiquidationSig(\"0x10\", decimal(-100), [1], [decimal(9)], decimal(-100));\n  // fix timestamp\n  sig.timestamp = BigNumber.from(await sig.timestamp).add(5);\n\n  // but before liquidation, partyB fullfills partyA close request\n  await this.hedger.fillCloseRequest(\n    1,\n    limitFillCloseRequestBuilder()\n      .filledAmount(decimal(50))\n      .closedPrice(decimal(9))\n      .build(),\n  );\n\n  var info = await this.user.getBalanceInfo();\n  console.log(\"after closing: partyA allocated: \" + info.allocatedBalances / 1e18 + \" locked: \" + info.totalLocked/1e18 + \" pendingLocked: \" + info.totalPendingLocked / 1e18);\n  var info = await this.hedger.getBalanceInfo(this.user.getAddress());\n  console.log(\"after closing: partyB allocated: \" + info.allocatedBalances / 1e18 + \" locked: \" + info.totalLocked/1e18 + \" pendingLocked: \" + info.totalPendingLocked / 1e18);\n\n  // liquidator starts liquidating partyA\n  await context.liquidationFacet.connect(this.liquidator.signer).liquidatePartyA(\n    this.user.signer.address,\n    sig\n  );\n  await context.liquidationFacet.connect(this.liquidator.signer).setSymbolsPrice(\n    this.user.signer.address,\n    sig\n  );\n  await context.liquidationFacet.connect(this.liquidator.signer).liquidatePositionsPartyA(\n    this.user.signer.address,\n    [1]\n  );\n\n  var info = await this.user.getBalanceInfo();\n  console.log(\"after liquidation: partyA allocated: \" + info.allocatedBalances / 1e18 + \" locked: \" + info.totalLocked/1e18 + \" pendingLocked: \" + info.totalPendingLocked / 1e18);\n  var info = await this.hedger.getBalanceInfo(this.user.getAddress());\n  console.log(\"after liquidation: partyB allocated: \" + info.allocatedBalances / 1e18 + \" locked: \" + info.totalLocked/1e18 + \" pendingLocked: \" + info.totalPendingLocked / 1e18);\n\n});\n```\n\nConsole execution result:\n```js\npartyA allocated: 109 locked: 20 pendingLocked: 0\npartyB allocated: 1000 locked: 20 pendingLocked: 0\nafter closing: partyA allocated: 59 locked: 10 pendingLocked: 0\nafter closing: partyB allocated: 1050 locked: 10 pendingLocked: 0\nafter liquidation: partyA allocated: 0 locked: 0 pendingLocked: 0\nafter liquidation: partyB allocated: 1079.5 locked: 0 pendingLocked: 0\nliquidator balance: 0\n```\nAs can be noticed, partyA + partyB have 1109 total after closing, but only 1079.5 after liquidation.\n\nIf the `fillCloseRequest` is commented out, then liquidation produces correct result:\n```js\npartyA allocated: 109 locked: 20 pendingLocked: 0\npartyB allocated: 1000 locked: 20 pendingLocked: 0\nafter liquidation: partyA allocated: 0 locked: 0 pendingLocked: 0\nafter liquidation: partyB allocated: 1106 locked: 0 pendingLocked: 0\nliquidator balance: 3\n```\n\n## Code Snippet\n\nNotice that there are no nonces of either party in the liquidation signature:\nhttps://github.com/sherlock-audit/2023-08-symmetrical/blob/main/symmio-core/contracts/libraries/LibMuon.sol#L54-L67\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nInclude partyA and partyB nonces in the liquidation signature.\n\n\n\n## Discussion\n\n**MoonKnightDev**\n\nFixed Code PR: https://github.com/SYMM-IO/symmio-core/pull/34\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/108",
  "Code": [
    {
      "filename": "symmio-core/contracts/libraries/LibMuon.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"../libraries/LibMuonV04ClientBase.sol\";\nimport \"../storages/MuonStorage.sol\";\nimport \"../storages/AccountStorage.sol\";\n\nlibrary LibMuon {\n    using ECDSA for bytes32;\n\n    function getChainId() internal view returns (uint256 id) {\n        assembly {\n            id := chainid()\n        }\n    }\n\n    // CONTEXT for commented out lines\n    // We're utilizing muon signatures for asset pricing and user uPNLs calculations. \n    // Even though these signatures are necessary for full testing of the system, particularly when invoking various methods.\n    // The process of creating automated functional signature for tests has proven to be either impractical or excessively time-consuming. therefore, we've established commenting out the necessary code as a workaround specifically for testing.\n    // Essentially, during testing, we temporarily disable the code sections responsible for validating these signatures. The sections I'm referring to are located within the LibMuon file. Specifically, the body of the 'verifyTSSAndGateway' method is a prime candidate for temporary disablement. In addition, several 'require' statements within other functions of this file, which examine the signatures' expiration status, also need to be temporarily disabled.\n    // However, it is crucial to note that these lines should not be disabled in the production deployed version. \n    // We emphasize this because they are only disabled for testing purposes.\n\n    function verifyTSSAndGateway(\n        bytes32 hash,\n        SchnorrSign memory sign,\n        bytes memory gatewaySignature\n    ) internal view {\n//       bool verified = LibMuonV04ClientBase.muonVerify(\n//           uint256(hash),\n//           sign,\n//           MuonStorage.layout().muonPublicKey\n//       );\n//       require(verified, \"LibMuon: TSS not verified\");\n//\n//       hash = hash.toEthSignedMessageHash();\n//       address gatewaySignatureSigner = hash.recover(gatewaySignature);\n//\n//       require(\n//           gatewaySignatureSigner == MuonStorage.layout().validGateway,\n//           \"LibMuon: Gateway is not valid\"\n//       );\n    }\n\n    function verifyLiquidationSig(LiquidationSig memory liquidationSig, address partyA) internal view {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n        require(liquidationSig.prices.length == liquidationSig.symbolIds.length, \"LibMuon: Invalid length\");\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                muonLayout.muonAppId,\n                liquidationSig.reqId,\n                liquidationSig.liquidationId,\n                address(this),\n                \"verifyPrices\",\n                partyA,\n                liquidationSig.upnl,\n                liquidationSig.totalUnrealizedLoss,\n                liquidationSig.symbolIds,\n                liquidationSig.prices,\n                liquidationSig.timestamp,\n                getChainId()\n            )\n        );\n        verifyTSSAndGateway(hash, liquidationSig.sigs, liquidationSig.gatewaySignature);\n    }\n\n    function verifyQuotePrices(QuotePriceSig memory priceSig) internal view {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n        require(priceSig.prices.length == priceSig.quoteIds.length, \"LibMuon: Invalid length\");\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                muonLayout.muonAppId,\n                priceSig.reqId,\n                address(this),\n                priceSig.quoteIds,\n                priceSig.prices,\n                priceSig.timestamp,\n                getChainId()\n            )\n        );\n        verifyTSSAndGateway(hash, priceSig.sigs, priceSig.gatewaySignature);\n    }\n\n    function verifyPartyAUpnl(SingleUpnlSig memory upnlSig, address partyA) internal view {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n//        require(\n//            block.timestamp <= upnlSig.timestamp + muonLayout.upnlValidTime,\n//            \"LibMuon: Expired signature\"\n//        );\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                muonLayout.muonAppId,\n                upnlSig.reqId,\n                address(this),\n                partyA,\n                AccountStorage.layout().partyANonces[partyA],\n                upnlSig.upnl,\n                upnlSig.timestamp,\n                getChainId()\n            )\n        );\n        verifyTSSAndGateway(hash, upnlSig.sigs, upnlSig.gatewaySignature);\n    }\n\n    function verifyPartyAUpnlAndPrice(\n        SingleUpnlAndPriceSig memory upnlSig,\n        address partyA,\n        uint256 symbolId\n    ) internal view {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n//        require(\n//            block.timestamp <= upnlSig.timestamp + muonLayout.upnlValidTime,\n//            \"LibMuon: Expired signature\"\n//        );\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                muonLayout.muonAppId,\n                upnlSig.reqId,\n                address(this),\n                partyA,\n                AccountStorage.layout().partyANonces[partyA],\n                upnlSig.upnl,\n                symbolId,\n                upnlSig.price,\n                upnlSig.timestamp,\n                getChainId()\n            )\n        );\n        verifyTSSAndGateway(hash, upnlSig.sigs, upnlSig.gatewaySignature);\n    }\n\n    function verifyPartyBUpnl(\n        SingleUpnlSig memory upnlSig,\n        address partyB,\n        address partyA\n    ) internal view {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n//        require(\n//            block.timestamp <= upnlSig.timestamp + muonLayout.upnlValidTime,\n//            \"LibMuon: Expired signature\"\n//        );\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                muonLayout.muonAppId,\n                upnlSig.reqId,\n                address(this),\n                partyB,\n                partyA,\n                AccountStorage.layout().partyBNonces[partyB][partyA],\n                upnlSig.upnl,\n                upnlSig.timestamp,\n                getChainId()\n            )\n        );\n        verifyTSSAndGateway(hash, upnlSig.sigs, upnlSig.gatewaySignature);\n    }\n\n    function verifyPairUpnlAndPrice(\n        PairUpnlAndPriceSig memory upnlSig,\n        address partyB,\n        address partyA,\n        uint256 symbolId\n    ) internal view {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n//        require(\n//            block.timestamp <= upnlSig.timestamp + muonLayout.upnlValidTime,\n//            \"LibMuon: Expired signature\"\n//        );\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                muonLayout.muonAppId,\n                upnlSig.reqId,\n                address(this),\n                partyB,\n                partyA,\n                AccountStorage.layout().partyBNonces[partyB][partyA],\n                AccountStorage.layout().partyANonces[partyA],\n                upnlSig.upnlPartyB,\n                upnlSig.upnlPartyA,\n                symbolId,\n                upnlSig.price,\n                upnlSig.timestamp,\n                getChainId()\n            )\n        );\n        verifyTSSAndGateway(hash, upnlSig.sigs, upnlSig.gatewaySignature);\n    }\n\n    function verifyPairUpnl(\n        PairUpnlSig memory upnlSig,\n        address partyB,\n        address partyA\n    ) internal view {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n//        require(\n//            block.timestamp <= upnlSig.timestamp + muonLayout.upnlValidTime,\n//            \"LibMuon: Expired signature\"\n//        );\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                muonLayout.muonAppId,\n                upnlSig.reqId,\n                address(this),\n                partyB,\n                partyA,\n                AccountStorage.layout().partyBNonces[partyB][partyA],\n                AccountStorage.layout().partyANonces[partyA],\n                upnlSig.upnlPartyB,\n                upnlSig.upnlPartyA,\n                upnlSig.timestamp,\n                getChainId()\n            )\n        );\n        verifyTSSAndGateway(hash, upnlSig.sigs, upnlSig.gatewaySignature);\n    }\n}"
    }
  ]
}