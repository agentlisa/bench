{
  "Title": "[M-01] Some arbitrary proposal calls will fail because `executeProposal()` in `ProposalExecutionEngine` is not payable",
  "Content": "\nThe `executeProposal()` function in `ProposalExecutionEngine.sol` is used to execute different types of proposal call. One of this type is `ArbitraryCallsProposal` and this type should be able to send ether from the Party's balance or the forwarded ETH attached to the call `msg.value`. However, the problem is that the `executeProposal()` function is not marked as payable and all calls that are sending ether and using `msg.value` will fail because of that.\n\nNote: Even though this function is delegate-called from `PartyGovernance.sol::execute()`, which is payable the `msg.value`, it is still preserved when `delegatecall` is used and the function called needs to be payable.\n\n### Impact\n\nAll proposal calls that are using attached ether will fail and Party wont be able to execute these types of proposals, which can be important.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-10-party/blob/b23c65d62a20921c709582b0b76b387f2bb9ebb5/contracts/proposals/ProposalExecutionEngine.sol#L146-L148>\n\n```solidity\n146:   function executeProposal(\n147:     ExecuteProposalParams memory params\n148:   ) external onlyDelegateCall returns (bytes memory nextProgressData) { \n```\n\nAs you can see, the `executeProposal()` function is not payable; however, later it then calls `_executeArbitraryCalls()`:\n\n<https://github.com/code-423n4/2023-10-party/blob/b23c65d62a20921c709582b0b76b387f2bb9ebb5/contracts/proposals/ArbitraryCallsProposal.sol#L72-L74>\n\n```solidity\n72:  // If we're not allowing arbitrary calls to spend the Party's ETH, only\n73:  // allow forwarded ETH attached to the call to be spent.\n74:  uint256 ethAvailable = allowArbCallsToSpendPartyEth ? address(this).balance : msg.value;\n```\n\nAs you can see and as the comment suggests, the call should be able to use the forwarded ether attached to the call and `ethAvailable` is then used in `_executeSingleArbitraryCall()`. However, because the function is not payable, the call will revert.\n\n### Recommended Mitigation Steps\n\nMake the `executeProposal()` function payable.\n\n### Assessed type\n\nPayable\n\n**[KingNFT (lookout) commented](https://github.com/code-423n4/2023-10-party-findings/issues/475#issuecomment-1806831773):**\n > Seems right, EVM source code:\n> ```golang\n> File: core\\vm\\contract.go\n> 134: func (c *Contract) AsDelegate() *Contract {\n> 135: \t// NOTE: caller must, at all times be a contract. It should never happen\n> 136: \t// that caller is something other than a Contract.\n> 137: \tparent := c.caller.(*Contract)\n> 138: \tc.CallerAddress = parent.CallerAddress\n> 139: \tc.value = parent.value\n> 140: \n> 141: \treturn c\n> 142: }\n> ```\n\n**[arr00 (Party) confirmed](https://github.com/code-423n4/2023-10-party-findings/issues/475#issuecomment-1811162360)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-party",
  "Code": [
    {
      "filename": "contracts/proposals/ProposalExecutionEngine.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport \"../utils/Implementation.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../globals/IGlobals.sol\";\nimport { IERC1271 } from \"openzeppelin/contracts/interfaces/IERC1271.sol\";\n\nimport \"./IProposalExecutionEngine.sol\";\nimport \"./ListOnOpenseaProposal.sol\";\nimport \"./ListOnOpenseaAdvancedProposal.sol\";\nimport \"./ListOnZoraProposal.sol\";\nimport \"./FractionalizeProposal.sol\";\nimport \"./ArbitraryCallsProposal.sol\";\nimport \"./ProposalStorage.sol\";\nimport \"./DistributeProposal.sol\";\nimport \"./AddAuthorityProposal.sol\";\nimport \"./OperatorProposal.sol\";\nimport { SetSignatureValidatorProposal } from \"./SetSignatureValidatorProposal.sol\";\nimport { SetGovernanceParameterProposal } from \"./SetGovernanceParameterProposal.sol\";\n\n/// @notice Upgradable implementation of proposal execution logic for parties that use it.\n/// @dev This contract will be delegatecall'ed into by `Party` proxy instances.\ncontract ProposalExecutionEngine is\n    IProposalExecutionEngine,\n    Implementation,\n    ProposalStorage,\n    ListOnOpenseaProposal,\n    ListOnOpenseaAdvancedProposal,\n    ListOnZoraProposal,\n    FractionalizeProposal,\n    ArbitraryCallsProposal,\n    DistributeProposal,\n    AddAuthorityProposal,\n    OperatorProposal,\n    SetSignatureValidatorProposal,\n    SetGovernanceParameterProposal,\n    IERC1271\n{\n    using LibRawResult for bytes;\n\n    error UnsupportedProposalTypeError(uint32 proposalType);\n\n    // The types of proposals supported.\n    // The first 4 bytes of a proposal's `proposalData` determine the proposal\n    // type.\n    // WARNING: This should be append-only.\n    enum ProposalType {\n        Invalid,\n        ListOnOpensea,\n        ListOnZora,\n        Fractionalize,\n        ArbitraryCalls,\n        UpgradeProposalEngineImpl,\n        ListOnOpenseaAdvanced,\n        Distribute,\n        AddAuthority,\n        Operator,\n        SetSignatureValidatorProposal,\n        SetGovernanceParameterProposal\n    }\n\n    // Explicit storage bucket for \"private\" state owned by the `ProposalExecutionEngine`.\n    // See `_getStorage()` for how this is addressed.\n    //\n    // Read this for more context on the pattern motivating this:\n    // https://github.com/dragonfly-xyz/useful-solidity-patterns/tree/main/patterns/explicit-storage-buckets\n    struct Storage {\n        // The hash of the next `progressData` for the current `InProgress`\n        // proposal. This is updated to the hash of the next `progressData` every\n        // time a proposal is executed. This enforces that the next call to\n        // `executeProposal()` receives the correct `progressData`.\n        // If there is no current `InProgress` proposal, this will be 0x0.\n        bytes32 nextProgressDataHash;\n        // The proposal ID of the current, in progress proposal being executed.\n        // `InProgress` proposals need to have `executeProposal()` called on them\n        // multiple times until they complete. Only one proposal may be\n        // in progress at a time, meaning no other proposals can be executed\n        // if this value is nonzero.\n        uint256 currentInProgressProposalId;\n    }\n\n    event ProposalEngineImplementationUpgraded(address oldImpl, address newImpl);\n\n    error ProposalDisabled(ProposalType proposalType);\n    error ZeroProposalIdError();\n    error MalformedProposalDataError();\n    error ProposalExecutionBlockedError(uint256 proposalId, uint256 currentInProgressProposalId);\n    error ProposalProgressDataInvalidError(\n        bytes32 actualProgressDataHash,\n        bytes32 expectedProgressDataHash\n    );\n    error ProposalNotInProgressError(uint256 proposalId);\n    error UnexpectedProposalEngineImplementationError(\n        IProposalExecutionEngine actualImpl,\n        IProposalExecutionEngine expectedImpl\n    );\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and itâ€™s address will never change.\n    IGlobals private immutable _GLOBALS;\n    // Storage slot for `Storage`.\n    // Use a constant, non-overlapping slot offset for the storage bucket.\n    uint256 private constant _STORAGE_SLOT = uint256(keccak256(\"ProposalExecutionEngine.Storage\"));\n\n    // Set immutables.\n    constructor(\n        IGlobals globals,\n        IReserveAuctionCoreEth zora,\n        IFractionalV1VaultFactory fractionalVaultFactory\n    )\n        ListOnOpenseaAdvancedProposal(globals)\n        ListOnZoraProposal(globals, zora)\n        FractionalizeProposal(fractionalVaultFactory)\n        ArbitraryCallsProposal(zora)\n    {\n        _GLOBALS = globals;\n    }\n\n    /// @notice Used by `Party` to setup the execution engine.\n    /// @param oldImpl The previous implementation address.\n    /// @param initializeData The data to use to initialize the execution engine.\n    function initialize(\n        address oldImpl,\n        bytes calldata initializeData\n    ) external override onlyDelegateCall {\n        // Prevent old parties from configuring new options to maintain security guarantees.\n        if (oldImpl != address(0)) return;\n\n        // If there is no initialize data, there is nothing to do.\n        if (initializeData.length == 0) return;\n\n        ProposalEngineOpts memory opts = abi.decode(initializeData, (ProposalEngineOpts));\n\n        // Set proposal engine opts\n        _getSharedProposalStorage().opts = opts;\n    }\n\n    /// @notice Get the current `InProgress` proposal ID.\n    /// @dev With this version, only one proposal may be in progress at a time.\n    function getCurrentInProgressProposalId() external view returns (uint256 id) {\n        return _getStorage().currentInProgressProposalId;\n    }\n\n    /// @inheritdoc IProposalExecutionEngine\n    function executeProposal(\n        ExecuteProposalParams memory params\n    ) external onlyDelegateCall returns (bytes memory nextProgressData) {\n        // Must have a valid proposal ID.\n        if (params.proposalId == 0) {\n            revert ZeroProposalIdError();\n        }\n        Storage storage stor = _getStorage();\n        uint256 currentInProgressProposalId = stor.currentInProgressProposalId;\n        if (currentInProgressProposalId == 0) {\n            // No proposal is currently in progress.\n            // Mark this proposal as the one in progress.\n            stor.currentInProgressProposalId = params.proposalId;\n        } else if (currentInProgressProposalId != params.proposalId) {\n            // Only one proposal can be in progress at a time.\n            revert ProposalExecutionBlockedError(params.proposalId, currentInProgressProposalId);\n        }\n        {\n            bytes32 nextProgressDataHash = stor.nextProgressDataHash;\n            if (nextProgressDataHash == 0) {\n                // Expecting no progress data.\n                // This is the state if there is no current `InProgress` proposal.\n                assert(currentInProgressProposalId == 0);\n                if (params.progressData.length != 0) {\n                    revert ProposalProgressDataInvalidError(\n                        keccak256(params.progressData),\n                        nextProgressDataHash\n                    );\n                }\n            } else {\n                // Expecting progress data.\n                bytes32 progressDataHash = keccak256(params.progressData);\n                // Progress data must match the one stored.\n                if (nextProgressDataHash != progressDataHash) {\n                    revert ProposalProgressDataInvalidError(progressDataHash, nextProgressDataHash);\n                }\n            }\n            // Temporarily set the expected next progress data hash to an\n            // unachievable constant to act as a reentrancy guard.\n            stor.nextProgressDataHash = bytes32(type(uint256).max);\n        }\n\n        // Note that we do not enforce that the proposal has not been executed\n        // (and completed) before in this contract. That is enforced by PartyGovernance.\n\n        // Execute the proposal.\n        ProposalType pt;\n        (pt, params.proposalData) = _extractProposalType(params.proposalData);\n        nextProgressData = _execute(pt, params);\n\n        // If progress data is empty, the proposal is complete.\n        if (nextProgressData.length == 0) {\n            stor.currentInProgressProposalId = 0;\n            stor.nextProgressDataHash = 0;\n        } else {\n            // Remember the next progress data.\n            stor.nextProgressDataHash = keccak256(nextProgressData);\n        }\n    }\n\n    /// @inheritdoc IProposalExecutionEngine\n    function cancelProposal(uint256 proposalId) external onlyDelegateCall {\n        // Must be a valid proposal ID.\n        if (proposalId == 0) {\n            revert ZeroProposalIdError();\n        }\n        Storage storage stor = _getStorage();\n        {\n            // Must be the current InProgress proposal.\n            uint256 currentInProgressProposalId = stor.currentInProgressProposalId;\n            if (currentInProgressProposalId != proposalId) {\n                revert ProposalNotInProgressError(proposalId);\n            }\n        }\n        // Clear the current InProgress proposal ID and next progress data.\n        stor.currentInProgressProposalId = 0;\n        stor.nextProgressDataHash = 0;\n    }\n\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4) {\n        IERC1271 validator = getSignatureValidatorForHash(hash);\n        if (address(validator) == address(1)) {\n            // Signature set by party to be always valid\n            return IERC1271.isValidSignature.selector;\n        }\n        if (address(validator) != address(0)) {\n            return validator.isValidSignature(hash, signature);\n        }\n        if (tx.origin == address(0)) {\n            validator = getSignatureValidatorForHash(0);\n            if (address(validator) == address(0)) {\n                // Use global off-chain signature validator\n                validator = IERC1271(\n                    _GLOBALS.getAddress(LibGlobals.GLOBAL_OFF_CHAIN_SIGNATURE_VALIDATOR)\n                );\n            }\n            return validator.isValidSignature(hash, signature);\n        }\n        return 0;\n    }\n\n    // Switch statement used to execute the right proposal.\n    function _execute(\n        ProposalType pt,\n        ExecuteProposalParams memory params\n    ) internal virtual returns (bytes memory nextProgressData) {\n        if (pt == ProposalType.ListOnOpensea) {\n            nextProgressData = _executeListOnOpensea(params);\n        } else if (pt == ProposalType.ListOnOpenseaAdvanced) {\n            nextProgressData = _executeListOnOpenseaAdvanced(params);\n        } else if (pt == ProposalType.ListOnZora) {\n            nextProgressData = _executeListOnZora(params);\n        } else if (pt == ProposalType.Fractionalize) {\n            nextProgressData = _executeFractionalize(params);\n        } else if (pt == ProposalType.ArbitraryCalls) {\n            nextProgressData = _executeArbitraryCalls(\n                params,\n                _getSharedProposalStorage().opts.allowArbCallsToSpendPartyEth\n            );\n        } else if (pt == ProposalType.Distribute) {\n            if (!_getSharedProposalStorage().opts.distributionsRequireVote) {\n                revert ProposalDisabled(pt);\n            }\n\n            nextProgressData = _executeDistribute(params);\n        } else if (pt == ProposalType.AddAuthority) {\n            if (!_getSharedProposalStorage().opts.enableAddAuthorityProposal) {\n                revert ProposalDisabled(pt);\n            }\n\n            nextProgressData = _executeAddAuthority(params);\n        } else if (pt == ProposalType.Operator) {\n            if (!_getSharedProposalStorage().opts.allowOperators) {\n                revert ProposalDisabled(pt);\n            }\n\n            nextProgressData = _executeOperation(params);\n        } else if (pt == ProposalType.SetSignatureValidatorProposal) {\n            nextProgressData = _executeSetSignatureValidator(params);\n        } else if (pt == ProposalType.SetGovernanceParameterProposal) {\n            nextProgressData = _executeSetGovernanceParameter(params);\n        } else if (pt == ProposalType.UpgradeProposalEngineImpl) {\n            _executeUpgradeProposalsImplementation(params.proposalData);\n        } else {\n            revert UnsupportedProposalTypeError(uint32(pt));\n        }\n    }\n\n    // Destructively pops off the first 4 bytes of `proposalData` to determine\n    // the type. This modifies `proposalData` and returns the updated\n    // pointer to it.\n    function _extractProposalType(\n        bytes memory proposalData\n    ) private pure returns (ProposalType proposalType, bytes memory offsetProposalData) {\n        // First 4 bytes is proposal type. While the proposal type could be\n        // stored in just 1 byte, this makes it easier to encode with\n        // `abi.encodeWithSelector`.\n        if (proposalData.length < 4) {\n            revert MalformedProposalDataError();\n        }\n        assembly {\n            // By reading 4 bytes into the length prefix, the leading 4 bytes\n            // of the data will be in the lower bits of the read word.\n            proposalType := and(mload(add(proposalData, 4)), 0xffffffff)\n            mstore(add(proposalData, 4), sub(mload(proposalData), 4))\n            offsetProposalData := add(proposalData, 4)\n        }\n        require(proposalType != ProposalType.Invalid);\n        require(uint8(proposalType) <= uint8(type(ProposalType).max));\n    }\n\n    // Upgrade implementation to the latest version.\n    function _executeUpgradeProposalsImplementation(bytes memory proposalData) private {\n        (address expectedImpl, bytes memory initData) = abi.decode(proposalData, (address, bytes));\n        // Always upgrade to latest implementation stored in `_GLOBALS`.\n        IProposalExecutionEngine newImpl = IProposalExecutionEngine(\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_PROPOSAL_ENGINE_IMPL)\n        );\n        if (expectedImpl != address(newImpl)) {\n            revert UnexpectedProposalEngineImplementationError(\n                newImpl,\n                IProposalExecutionEngine(expectedImpl)\n            );\n        }\n        _initProposalImpl(newImpl, initData);\n        emit ProposalEngineImplementationUpgraded(address(implementation), expectedImpl);\n    }\n\n    // Retrieve the explicit storage bucket for the ProposalExecutionEngine logic.\n    function _getStorage() internal pure returns (Storage storage stor) {\n        uint256 slot = _STORAGE_SLOT;\n        assembly {\n            stor.slot := slot\n        }\n    }\n}"
    },
    {
      "filename": "contracts/proposals/ArbitraryCallsProposal.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport \"../tokens/IERC721.sol\";\nimport \"../tokens/IERC721Receiver.sol\";\nimport \"../tokens/ERC1155Receiver.sol\";\nimport \"../utils/LibSafeERC721.sol\";\nimport \"../utils/LibAddress.sol\";\nimport \"../vendor/markets/IReserveAuctionCoreEth.sol\";\nimport \"./vendor/IOpenseaExchange.sol\";\n\nimport \"./LibProposal.sol\";\nimport \"./IProposalExecutionEngine.sol\";\n\n// Implements arbitrary call proposals. Inherited by the `ProposalExecutionEngine`.\n// This contract will be delegatecall'ed into by `Party` proxy instances.\ncontract ArbitraryCallsProposal {\n    using LibSafeERC721 for IERC721;\n    using LibAddress for address payable;\n\n    struct ArbitraryCall {\n        // The call target.\n        address payable target;\n        // Amount of ETH to attach to the call.\n        uint256 value;\n        // Calldata.\n        bytes data;\n        // Hash of the successful return data of the call.\n        // If 0x0, no return data checking will occur for this call.\n        bytes32 expectedResultHash;\n    }\n\n    error PreciousLostError(IERC721 token, uint256 tokenId);\n    error CallProhibitedError(address target, bytes data);\n    error ArbitraryCallFailedError(bytes revertData);\n    error UnexpectedCallResultHashError(\n        uint256 idx,\n        bytes32 resultHash,\n        bytes32 expectedResultHash\n    );\n    error NotEnoughEthAttachedError(uint256 callValue, uint256 ethAvailable);\n    error InvalidApprovalCallLength(uint256 callDataLength);\n\n    event ArbitraryCallExecuted(uint256 proposalId, uint256 idx, uint256 count);\n\n    IReserveAuctionCoreEth private immutable _ZORA;\n\n    constructor(IReserveAuctionCoreEth zora) {\n        _ZORA = zora;\n    }\n\n    function _executeArbitraryCalls(\n        IProposalExecutionEngine.ExecuteProposalParams memory params,\n        bool allowArbCallsToSpendPartyEth\n    ) internal returns (bytes memory nextProgressData) {\n        // Get the calls to execute.\n        ArbitraryCall[] memory calls = abi.decode(params.proposalData, (ArbitraryCall[]));\n        // Check whether the proposal was unanimously passed.\n        bool isUnanimous = params.flags & LibProposal.PROPOSAL_FLAG_UNANIMOUS ==\n            LibProposal.PROPOSAL_FLAG_UNANIMOUS;\n        // If not unanimous, keep track of which preciouses we had before the calls\n        // so we can check that we still have them later.\n        bool[] memory hadPreciouses = new bool[](params.preciousTokenIds.length);\n        if (!isUnanimous) {\n            for (uint256 i; i < hadPreciouses.length; ++i) {\n                hadPreciouses[i] = _getHasPrecious(\n                    params.preciousTokens[i],\n                    params.preciousTokenIds[i]\n                );\n            }\n        }\n        // If we're not allowing arbitrary calls to spend the Party's ETH, only\n        // allow forwarded ETH attached to the call to be spent.\n        uint256 ethAvailable = allowArbCallsToSpendPartyEth ? address(this).balance : msg.value;\n        for (uint256 i; i < calls.length; ++i) {\n            // Execute an arbitrary call.\n            _executeSingleArbitraryCall(\n                i,\n                calls,\n                params.preciousTokens,\n                params.preciousTokenIds,\n                isUnanimous,\n                ethAvailable\n            );\n            // Update the amount of ETH available for the subsequent calls.\n            ethAvailable = allowArbCallsToSpendPartyEth\n                ? address(this).balance\n                : ethAvailable - calls[i].value;\n            emit ArbitraryCallExecuted(params.proposalId, i, calls.length);\n        }\n        // If not a unanimous vote and we had a precious beforehand,\n        // ensure that we still have it now.\n        if (!isUnanimous) {\n            for (uint256 i; i < hadPreciouses.length; ++i) {\n                if (hadPreciouses[i]) {\n                    if (!_getHasPrecious(params.preciousTokens[i], params.preciousTokenIds[i])) {\n                        revert PreciousLostError(\n                            params.preciousTokens[i],\n                            params.preciousTokenIds[i]\n                        );\n                    }\n                }\n            }\n        }\n        // Refund leftover ETH attached to the call if none was spent from the\n        // Party's balance.\n        if (!allowArbCallsToSpendPartyEth && ethAvailable > 0) {\n            payable(msg.sender).transferEth(ethAvailable);\n        }\n        // No next step, so no progressData.\n        return \"\";\n    }\n\n    function _executeSingleArbitraryCall(\n        uint256 idx,\n        ArbitraryCall[] memory calls,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds,\n        bool isUnanimous,\n        uint256 ethAvailable\n    ) private {\n        ArbitraryCall memory call = calls[idx];\n        // Check that the call is not prohibited.\n        if (\n            !_isCallAllowed(call, isUnanimous, idx, calls.length, preciousTokens, preciousTokenIds)\n        ) {\n            revert CallProhibitedError(call.target, call.data);\n        }\n        // Check that we have enough ETH to execute the call.\n        if (ethAvailable < call.value) {\n            revert NotEnoughEthAttachedError(call.value, ethAvailable);\n        }\n        // Execute the call.\n        (bool s, bytes memory r) = call.target.call{ value: call.value }(call.data);\n        if (!s) {\n            // Call failed. If not optional, revert.\n            revert ArbitraryCallFailedError(r);\n        } else {\n            // Call succeeded.\n            // If we have a nonzero expectedResultHash, check that the result data\n            // from the call has a matching hash.\n            if (call.expectedResultHash != bytes32(0)) {\n                bytes32 resultHash = keccak256(r);\n                if (resultHash != call.expectedResultHash) {\n                    revert UnexpectedCallResultHashError(idx, resultHash, call.expectedResultHash);\n                }\n            }\n        }\n    }\n\n    // Do we possess the precious?\n    function _getHasPrecious(\n        IERC721 preciousToken,\n        uint256 preciousTokenId\n    ) private view returns (bool hasPrecious) {\n        hasPrecious = preciousToken.safeOwnerOf(preciousTokenId) == address(this);\n    }\n\n    function _isCallAllowed(\n        ArbitraryCall memory call,\n        bool isUnanimous,\n        uint256 callIndex,\n        uint256 callsCount,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds\n    ) private view returns (bool isAllowed) {\n        // Cannot call ourselves.\n        if (call.target == address(this)) {\n            return false;\n        }\n        if (call.data.length >= 4) {\n            // Get the function selector of the call (first 4 bytes of calldata).\n            bytes4 selector;\n            {\n                bytes memory callData = call.data;\n                assembly {\n                    selector := and(\n                        mload(add(callData, 32)),\n                        0xffffffff00000000000000000000000000000000000000000000000000000000\n                    )\n                }\n            }\n            // Non-unanimous proposals restrict what ways some functions can be\n            // called on a precious token.\n            if (!isUnanimous) {\n                // Cannot call `approve()` or `setApprovalForAll()` on the precious\n                // unless it's to revoke approvals.\n                if (selector == IERC721.approve.selector) {\n                    // Can only call `approve()` on the precious if the operator is null.\n                    (address op, uint256 tokenId) = _decodeApproveCallDataArgs(call.data);\n                    if (op != address(0)) {\n                        return\n                            !LibProposal.isTokenIdPrecious(\n                                IERC721(call.target),\n                                tokenId,\n                                preciousTokens,\n                                preciousTokenIds\n                            );\n                    }\n                    // Can only call `setApprovalForAll()` on the precious if\n                    // toggling off.\n                } else if (selector == IERC721.setApprovalForAll.selector) {\n                    (, bool isApproved) = _decodeSetApprovalForAllCallDataArgs(call.data);\n                    if (isApproved) {\n                        return !LibProposal.isTokenPrecious(IERC721(call.target), preciousTokens);\n                    }\n                    // Can only call cancelAuction on the zora AH if it's the last call\n                    // in the sequence.\n                } else if (selector == IReserveAuctionCoreEth.cancelAuction.selector) {\n                    if (call.target == address(_ZORA)) {\n                        return callIndex + 1 == callsCount;\n                    }\n                }\n            }\n            // Can never call receive hooks on any target.\n            if (\n                selector == IERC721Receiver.onERC721Received.selector ||\n                selector == ERC1155TokenReceiverBase.onERC1155Received.selector ||\n                selector == ERC1155TokenReceiverBase.onERC1155BatchReceived.selector\n            ) {\n                return false;\n            }\n            // Disallow calling `validate()` on Seaport if there are preciouses.\n            if (selector == IOpenseaExchange.validate.selector && preciousTokens.length != 0) {\n                return false;\n            }\n        }\n        // All other calls are allowed.\n        return true;\n    }\n\n    // Get the `operator` and `tokenId` from the `approve()` call data.\n    function _decodeApproveCallDataArgs(\n        bytes memory callData\n    ) private pure returns (address operator, uint256 tokenId) {\n        if (callData.length < 68) {\n            revert InvalidApprovalCallLength(callData.length);\n        }\n        assembly {\n            operator := and(mload(add(callData, 36)), 0xffffffffffffffffffffffffffffffffffffffff)\n            tokenId := mload(add(callData, 68))\n        }\n    }\n\n    // Get the `operator` and `tokenId` from the `setApprovalForAll()` call data.\n    function _decodeSetApprovalForAllCallDataArgs(\n        bytes memory callData\n    ) private pure returns (address operator, bool isApproved) {\n        if (callData.length < 68) {\n            revert InvalidApprovalCallLength(callData.length);\n        }\n        assembly {\n            operator := and(mload(add(callData, 36)), 0xffffffffffffffffffffffffffffffffffffffff)\n            isApproved := xor(iszero(mload(add(callData, 68))), 1)\n        }\n    }\n}"
    }
  ]
}