{
  "Title": "M-3: The `_fee()` function is wrongly implemented in the code",
  "Content": "# Issue M-3: The `_fee()` function is wrongly implemented in the code \n\nSource: https://github.com/sherlock-audit/2022-11-buffer-judging/issues/95 \n\n## Found by \nCh\\_301\n\n## Summary\n _fee() function is wrongly implemented in the code so the protocol will get fewer fees and the trader will earn more\n\n## Vulnerability Detail\n```solidity\n        (uint256 unitFee, , ) = _fees(10**decimals(), settlementFeePercentage);\n        amount = (newFee * 10**decimals()) / unitFee;\n```\nlet's say we have:\n`newFee` 100 USDC\nUSDC Decimals is 6\n`settlementFeePercentage` is 20% ==> 200\n\nThe `unitFee` will be 520_000\n\n`amount` = (100 * 1_000_000) / 520_000 \n`amount` = 192 USDC\nWhich is supposed to be  `amount` = 160 USDC\n\n## Impact\nThe protocol will earn fees less than expected\n\n## Code Snippet\n```solidity\n       function checkParams(OptionParams calldata optionParams)\n        external\n        view\n        override\n        returns (\n            uint256 amount,\n            uint256 revisedFee,\n            bool isReferralValid\n        )\n    {\n        require(\n            assetCategory != AssetCategory.Forex ||\n                isInCreationWindow(optionParams.period),\n            \"O30\"\n        );\n\n        uint256 maxAmount = getMaxUtilization();\n\n        // Calculate the max fee due to the max txn limit\n        uint256 maxPerTxnFee = ((pool.availableBalance() *\n            config.optionFeePerTxnLimitPercent()) / 100e2);\n        uint256 newFee = min(optionParams.totalFee, maxPerTxnFee);\n\n        // Calculate the amount here from the new fees\n        uint256 settlementFeePercentage;\n        (\n            settlementFeePercentage,\n            isReferralValid\n        ) = _getSettlementFeePercentage(\n            referral.codeOwner(optionParams.referralCode),\n            optionParams.user,\n            _getbaseSettlementFeePercentage(optionParams.isAbove),\n            optionParams.traderNFTId\n        );\n        (uint256 unitFee, , ) = _fees(10**decimals(), settlementFeePercentage);\n        amount = (newFee * 10**decimals()) / unitFee;\n\n```\nhttps://github.com/bufferfinance/Buffer-Protocol-v2/blob/83d85d9b18f1a4d09c728adaa0dde4c37406dfed/contracts/core/BufferBinaryOptions.sol#L318-L353\n\n```solidity\n    function _fees(uint256 amount, uint256 settlementFeePercentage)\n        internal\n        pure\n        returns (\n            uint256 total,\n            uint256 settlementFee,\n            uint256 premium\n        )\n    {\n        // Probability for ATM options will always be 0.5 due to which we can skip using BSM\n        premium = amount / 2;\n        settlementFee = (amount * settlementFeePercentage) / 1e4;\n        total = settlementFee + premium;\n    }\n\n```\nhttps://github.com/bufferfinance/Buffer-Protocol-v2/blob/83d85d9b18f1a4d09c728adaa0dde4c37406dfed/contracts/core/BufferBinaryOptions.sol#L424-L437\n\n## Tool used\n\nManual Review\n\n## Recommendation\nThe `_fee()` function needs to calculate the fees in this way\n```solidity\ntotal_fee = (5000 * amount)/ (10000 - sf)\n```\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/24",
  "Code": [
    {
      "filename": "contracts/core/BufferBinaryOptions.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"../interfaces/Interfaces.sol\";\n\n/**\n * @author Heisenberg\n * @title Buffer Options\n * @notice Creates ERC721 Options\n */\n\ncontract BufferBinaryOptions is\n    IBufferBinaryOptions,\n    ReentrancyGuard,\n    ERC721,\n    AccessControl\n{\n    uint256 public nextTokenId = 0;\n    uint256 public totalLockedAmount;\n    bool public isPaused;\n    uint16 public baseSettlementFeePercentageForAbove; // Factor of 1e2\n    uint16 public baseSettlementFeePercentageForBelow; // Factor of 1e2\n    uint16 public stepSize = 250; // Factor of 1e2\n    string public assetPair;\n\n    ILiquidityPool public override pool;\n    IOptionsConfig public override config;\n    IReferralStorage public referral;\n    AssetCategory public assetCategory;\n    ERC20 public override tokenX;\n\n    mapping(uint256 => Option) public override options;\n    mapping(address => uint256[]) public userOptionIds;\n    mapping(uint8 => uint8) public nftTierStep;\n\n    bytes32 public constant ROUTER_ROLE = keccak256(\"ROUTER_ROLE\");\n\n    /************************************************\n     *  INITIALIZATION FUNCTIONS\n     ***********************************************/\n\n    constructor(\n        ERC20 _tokenX,\n        ILiquidityPool _pool,\n        IOptionsConfig _config,\n        IReferralStorage _referral,\n        AssetCategory _category,\n        string memory _assetPair\n    ) ERC721(\"Buffer\", \"BFR\") {\n        tokenX = _tokenX;\n        pool = _pool;\n        config = _config;\n        referral = _referral;\n        assetPair = _assetPair;\n        assetCategory = _category;\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /**\n     * @notice Used to configure the contracts\n     */\n    function configure(\n        uint16 _baseSettlementFeePercentageForAbove,\n        uint16 _baseSettlementFeePercentageForBelow,\n        uint8[4] calldata _nftTierStep\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(10e2 <= _baseSettlementFeePercentageForAbove, \"O27\");\n        require(_baseSettlementFeePercentageForAbove <= 50e2, \"O28\");\n        baseSettlementFeePercentageForAbove = _baseSettlementFeePercentageForAbove; // Percent with a factor of 1e2\n\n        require(10e2 <= _baseSettlementFeePercentageForBelow, \"O27\");\n        require(_baseSettlementFeePercentageForBelow <= 50e2, \"O28\");\n        baseSettlementFeePercentageForBelow = _baseSettlementFeePercentageForBelow;\n\n        for (uint8 i; i < 4; i++) {\n            nftTierStep[i] = _nftTierStep[i];\n        }\n    }\n\n    /**\n     * @notice Grants complete approval from the pool\n     */\n    function approvePoolToTransferTokenX() public {\n        tokenX.approve(address(pool), ~uint256(0));\n    }\n\n    /**\n     * @notice Pauses/Unpauses the option creation\n     */\n    function toggleCreation() public onlyRole(DEFAULT_ADMIN_ROLE) {\n        isPaused = !isPaused;\n        emit Pause(isPaused);\n    }\n\n    /************************************************\n     *  ROUTER ONLY FUNCTIONS\n     ***********************************************/\n\n    /**\n     * @notice Creates an option with the specified parameters\n     * @dev Can only be called by router\n     */\n    function createFromRouter(\n        OptionParams calldata optionParams,\n        bool isReferralValid\n    ) external override onlyRole(ROUTER_ROLE) returns (uint256 optionID) {\n        Option memory option = Option(\n            State.Active,\n            optionParams.strike,\n            optionParams.amount,\n            optionParams.amount,\n            optionParams.amount / 2,\n            block.timestamp + optionParams.period,\n            optionParams.isAbove,\n            optionParams.totalFee,\n            block.timestamp\n        );\n        totalLockedAmount += optionParams.amount;\n        optionID = _generateTokenId();\n        userOptionIds[optionParams.user].push(optionID);\n        options[optionID] = option;\n        _mint(optionParams.user, optionID);\n\n        uint256 referrerFee = _processReferralRebate(\n            optionParams.user,\n            optionParams.totalFee,\n            optionParams.amount,\n            optionParams.referralCode,\n            optionParams.isAbove,\n            isReferralValid\n        );\n\n        uint256 settlementFee = optionParams.totalFee -\n            option.premium -\n            referrerFee;\n\n        tokenX.transfer(config.settlementFeeDisbursalContract(), settlementFee);\n        pool.lock(optionID, option.lockedAmount, option.premium);\n        emit Create(\n            optionParams.user,\n            optionID,\n            settlementFee,\n            optionParams.totalFee\n        );\n    }\n\n    /**\n     * @notice Unlocks/Exercises the active options\n     * @dev Can only be called router\n     */\n    function unlock(uint256 optionID, uint256 priceAtExpiration)\n        external\n        override\n        onlyRole(ROUTER_ROLE)\n    {\n        require(_exists(optionID), \"O10\");\n        Option storage option = options[optionID];\n        require(option.expiration <= block.timestamp, \"O4\");\n        require(option.state == State.Active, \"O5\");\n\n        if (\n            (option.isAbove && priceAtExpiration > option.strike) ||\n            (!option.isAbove && priceAtExpiration < option.strike)\n        ) {\n            _exercise(optionID, priceAtExpiration);\n        } else {\n            option.state = State.Expired;\n            pool.unlock(optionID);\n            _burn(optionID);\n            emit Expire(optionID, option.premium, priceAtExpiration);\n        }\n        totalLockedAmount -= option.lockedAmount;\n    }\n\n    /************************************************\n     *  READ ONLY FUNCTIONS\n     ***********************************************/\n\n    /**\n     * @notice Returns decimals of the pool token\n     */\n    function decimals() public view returns (uint256) {\n        return tokenX.decimals();\n    }\n\n    /**\n     * @notice Calculates the fees for buying an option\n     */\n    function fees(\n        uint256 amount,\n        address user,\n        bool isAbove,\n        string calldata referralCode,\n        uint256 traderNFTId\n    )\n        public\n        view\n        returns (\n            uint256 total,\n            uint256 settlementFee,\n            uint256 premium\n        )\n    {\n        (uint256 settlementFeePercentage, ) = _getSettlementFeePercentage(\n            referral.codeOwner(referralCode),\n            user,\n            _getbaseSettlementFeePercentage(isAbove),\n            traderNFTId\n        );\n        (total, settlementFee, premium) = _fees(\n            amount,\n            settlementFeePercentage\n        );\n    }\n\n    /**\n     * @notice Checks if the strike price at which the trade is opened lies within the slippage bounds\n     */\n    function isStrikeValid(\n        uint256 slippage,\n        uint256 strike,\n        uint256 expectedStrike\n    ) external pure override returns (bool) {\n        if (\n            (strike <= (expectedStrike * (1e4 + slippage)) / 1e4) &&\n            (strike >= (expectedStrike * (1e4 - slippage)) / 1e4)\n        ) {\n            return true;\n        } else return false;\n    }\n\n    /**\n     * @notice Checks if the market is open at the time of option creation and execution.\n     * Used only for forex options\n     */\n    function isInCreationWindow(uint256 period) public view returns (bool) {\n        uint256 currentTime = block.timestamp;\n        uint256 currentDay = ((currentTime / 86400) + 4) % 7;\n        uint256 expirationDay = (((currentTime + period) / 86400) + 4) % 7;\n\n        if (currentDay == expirationDay) {\n            uint256 currentHour = (currentTime / 3600) % 24;\n            uint256 currentMinute = (currentTime % 3600) / 60;\n            uint256 expirationHour = ((currentTime + period) / 3600) % 24;\n            uint256 expirationMinute = ((currentTime + period) % 3600) / 60;\n            (\n                uint256 startHour,\n                uint256 startMinute,\n                uint256 endHour,\n                uint256 endMinute\n            ) = config.marketTimes(uint8(currentDay));\n\n            if (\n                (currentHour > startHour ||\n                    (currentHour == startHour &&\n                        currentMinute >= startMinute)) &&\n                (currentHour < endHour ||\n                    (currentHour == endHour && currentMinute < endMinute)) &&\n                (expirationHour < endHour ||\n                    (expirationHour == endHour && expirationMinute < endMinute))\n            ) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @notice Runs the basic checks for option creation\n     */\n    function runInitialChecks(\n        uint256 slippage,\n        uint256 period,\n        uint256 totalFee\n    ) external view override {\n        require(!isPaused, \"O33\");\n        require(slippage <= 5e2, \"O34\"); // 5% is the max slippage a user can use\n        require(period >= config.minPeriod(), \"O21\");\n        require(period <= config.maxPeriod(), \"O25\");\n        require(totalFee >= config.minFee(), \"O35\");\n    }\n\n    /**\n     * @notice Calculates max option amount based on the pool's capacity\n     */\n    function getMaxUtilization() public view returns (uint256 maxAmount) {\n        // Calculate the max option size due to asset wise pool utilization limit\n        uint256 totalPoolBalance = pool.totalTokenXBalance();\n        uint256 availableBalance = totalPoolBalance - totalLockedAmount;\n        uint256 utilizationLimit = config.assetUtilizationLimit();\n        uint256 maxAssetWiseUtilizationAmount = _getMaxUtilization(\n            totalPoolBalance,\n            availableBalance,\n            utilizationLimit\n        );\n\n        // Calculate the max option size due to overall pool utilization limit\n        utilizationLimit = config.overallPoolUtilizationLimit();\n        availableBalance = pool.availableBalance();\n        uint256 maxUtilizationAmount = _getMaxUtilization(\n            totalPoolBalance,\n            availableBalance,\n            utilizationLimit\n        );\n\n        // Take the min of the above 2 values\n        maxAmount = min(maxUtilizationAmount, maxAssetWiseUtilizationAmount);\n    }\n\n    /**\n     * @notice Runs all the checks on the option parameters and\n     * returns the revised amount and fee\n     */\n    function checkParams(OptionParams calldata optionParams)\n        external\n        view\n        override\n        returns (\n            uint256 amount,\n            uint256 revisedFee,\n            bool isReferralValid\n        )\n    {\n        require(\n            assetCategory != AssetCategory.Forex ||\n                isInCreationWindow(optionParams.period),\n            \"O30\"\n        );\n\n        uint256 maxAmount = getMaxUtilization();\n\n        // Calculate the max fee due to the max txn limit\n        uint256 maxPerTxnFee = ((pool.availableBalance() *\n            config.optionFeePerTxnLimitPercent()) / 100e2);\n        uint256 newFee = min(optionParams.totalFee, maxPerTxnFee);\n\n        // Calculate the amount here from the new fees\n        uint256 settlementFeePercentage;\n        (\n            settlementFeePercentage,\n            isReferralValid\n        ) = _getSettlementFeePercentage(\n            referral.codeOwner(optionParams.referralCode),\n            optionParams.user,\n            _getbaseSettlementFeePercentage(optionParams.isAbove),\n            optionParams.traderNFTId\n        );\n        (uint256 unitFee, , ) = _fees(10**decimals(), settlementFeePercentage);\n        amount = (newFee * 10**decimals()) / unitFee;\n\n        // Recalculate the amount and the fees if values are greater than the max and partial fill is allowed\n        if (amount > maxAmount || newFee < optionParams.totalFee) {\n            require(optionParams.allowPartialFill, \"O29\");\n            amount = min(amount, maxAmount);\n            (revisedFee, , ) = _fees(amount, settlementFeePercentage);\n        } else {\n            revisedFee = optionParams.totalFee;\n        }\n    }\n\n    /************************************************\n     * ERC721 FUNCTIONS\n     ***********************************************/\n\n    function _generateTokenId() internal returns (uint256) {\n        return nextTokenId++;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721, AccessControl)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    /************************************************\n     *  INTERNAL OPTION UTILITY FUNCTIONS\n     ***********************************************/\n\n    /**\n     * @notice Returns the base settlement fee based on option type\n     */\n    function _getbaseSettlementFeePercentage(bool isAbove)\n        internal\n        view\n        returns (uint16 baseSettlementFeePercentage)\n    {\n        baseSettlementFeePercentage = isAbove\n            ? baseSettlementFeePercentageForAbove\n            : baseSettlementFeePercentageForBelow;\n    }\n\n    /**\n     * @notice Calculates the max utilization\n     */\n    function _getMaxUtilization(\n        uint256 totalPoolBalance,\n        uint256 availableBalance,\n        uint256 utilizationLimit\n    ) internal pure returns (uint256) {\n        require(\n            availableBalance >\n                (((1e4 - utilizationLimit) * totalPoolBalance) / 1e4),\n            \"O31\"\n        );\n        return\n            availableBalance -\n            (((1e4 - utilizationLimit) * totalPoolBalance) / 1e4);\n    }\n\n    /**\n     * @notice Calculates the fees for buying an option\n     */\n    function _fees(uint256 amount, uint256 settlementFeePercentage)\n        internal\n        pure\n        returns (\n            uint256 total,\n            uint256 settlementFee,\n            uint256 premium\n        )\n    {\n        // Probability for ATM options will always be 0.5 due to which we can skip using BSM\n        premium = amount / 2;\n        settlementFee = (amount * settlementFeePercentage) / 1e4;\n        total = settlementFee + premium;\n    }\n\n    /**\n     * @notice Exercises the ITM options\n     */\n    function _exercise(uint256 optionID, uint256 priceAtExpiration)\n        internal\n        returns (uint256 profit)\n    {\n        Option storage option = options[optionID];\n        address user = ownerOf(optionID);\n        profit = option.lockedAmount;\n        pool.send(optionID, user, profit);\n\n        // Burn the option\n        _burn(optionID);\n        option.state = State.Exercised;\n        emit Exercise(user, optionID, profit, priceAtExpiration);\n    }\n\n    /**\n     * @notice Sends the referral rebate to the referrer and\n     * updates the stats in the referral storage contract\n     */\n    function _processReferralRebate(\n        address user,\n        uint256 totalFee,\n        uint256 amount,\n        string calldata referralCode,\n        bool isAbove,\n        bool isReferralValid\n    ) internal returns (uint256 referrerFee) {\n        address referrer = referral.codeOwner(referralCode);\n\n        if (referrer != user && referrer != address(0)) {\n            referrerFee = ((totalFee *\n                referral.referrerTierDiscount(\n                    referral.referrerTier(referrer)\n                )) / (1e4 * 1e3));\n            if (referrerFee > 0) {\n                tokenX.transfer(referrer, referrerFee);\n\n                (uint256 formerUnitFee, , ) = _fees(\n                    10**decimals(),\n                    _getbaseSettlementFeePercentage(isAbove)\n                );\n                emit UpdateReferral(\n                    referrer,\n                    isReferralValid,\n                    totalFee,\n                    referrerFee,\n                    ((formerUnitFee * amount) - totalFee),\n                    referralCode\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Calculates the discount to be applied on settlement fee based on\n     * NFT and referrer tiers\n     */\n    function _getSettlementFeeDiscount(\n        address referrer,\n        address user,\n        uint256 traderNFTId\n    ) public view returns (bool isReferralValid, uint8 maxStep) {\n        if (config.traderNFTContract() != address(0)) {\n            ITraderNFT nftContract = ITraderNFT(config.traderNFTContract());\n            if (nftContract.tokenOwner(traderNFTId) == user)\n                maxStep = nftTierStep[\n                    nftContract.tokenTierMappings(traderNFTId)\n                ];\n        }\n        if (referrer != user && referrer != address(0)) {\n            uint8 step = referral.referrerTierStep(\n                referral.referrerTier(referrer)\n            );\n            if (step > maxStep) {\n                maxStep = step;\n                isReferralValid = true;\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the discounted settlement fee\n     */\n    function _getSettlementFeePercentage(\n        address referrer,\n        address user,\n        uint16 baseSettlementFeePercentage,\n        uint256 traderNFTId\n    )\n        internal\n        view\n        returns (uint256 settlementFeePercentage, bool isReferralValid)\n    {\n        settlementFeePercentage = baseSettlementFeePercentage;\n        uint256 maxStep;\n        (isReferralValid, maxStep) = _getSettlementFeeDiscount(\n            referrer,\n            user,\n            traderNFTId\n        );\n        settlementFeePercentage =\n            settlementFeePercentage -\n            (stepSize * maxStep);\n    }\n}"
    },
    {
      "filename": "contracts/core/BufferBinaryOptions.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"../interfaces/Interfaces.sol\";\n\n/**\n * @author Heisenberg\n * @title Buffer Options\n * @notice Creates ERC721 Options\n */\n\ncontract BufferBinaryOptions is\n    IBufferBinaryOptions,\n    ReentrancyGuard,\n    ERC721,\n    AccessControl\n{\n    uint256 public nextTokenId = 0;\n    uint256 public totalLockedAmount;\n    bool public isPaused;\n    uint16 public baseSettlementFeePercentageForAbove; // Factor of 1e2\n    uint16 public baseSettlementFeePercentageForBelow; // Factor of 1e2\n    uint16 public stepSize = 250; // Factor of 1e2\n    string public assetPair;\n\n    ILiquidityPool public override pool;\n    IOptionsConfig public override config;\n    IReferralStorage public referral;\n    AssetCategory public assetCategory;\n    ERC20 public override tokenX;\n\n    mapping(uint256 => Option) public override options;\n    mapping(address => uint256[]) public userOptionIds;\n    mapping(uint8 => uint8) public nftTierStep;\n\n    bytes32 public constant ROUTER_ROLE = keccak256(\"ROUTER_ROLE\");\n\n    /************************************************\n     *  INITIALIZATION FUNCTIONS\n     ***********************************************/\n\n    constructor(\n        ERC20 _tokenX,\n        ILiquidityPool _pool,\n        IOptionsConfig _config,\n        IReferralStorage _referral,\n        AssetCategory _category,\n        string memory _assetPair\n    ) ERC721(\"Buffer\", \"BFR\") {\n        tokenX = _tokenX;\n        pool = _pool;\n        config = _config;\n        referral = _referral;\n        assetPair = _assetPair;\n        assetCategory = _category;\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /**\n     * @notice Used to configure the contracts\n     */\n    function configure(\n        uint16 _baseSettlementFeePercentageForAbove,\n        uint16 _baseSettlementFeePercentageForBelow,\n        uint8[4] calldata _nftTierStep\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(10e2 <= _baseSettlementFeePercentageForAbove, \"O27\");\n        require(_baseSettlementFeePercentageForAbove <= 50e2, \"O28\");\n        baseSettlementFeePercentageForAbove = _baseSettlementFeePercentageForAbove; // Percent with a factor of 1e2\n\n        require(10e2 <= _baseSettlementFeePercentageForBelow, \"O27\");\n        require(_baseSettlementFeePercentageForBelow <= 50e2, \"O28\");\n        baseSettlementFeePercentageForBelow = _baseSettlementFeePercentageForBelow;\n\n        for (uint8 i; i < 4; i++) {\n            nftTierStep[i] = _nftTierStep[i];\n        }\n    }\n\n    /**\n     * @notice Grants complete approval from the pool\n     */\n    function approvePoolToTransferTokenX() public {\n        tokenX.approve(address(pool), ~uint256(0));\n    }\n\n    /**\n     * @notice Pauses/Unpauses the option creation\n     */\n    function toggleCreation() public onlyRole(DEFAULT_ADMIN_ROLE) {\n        isPaused = !isPaused;\n        emit Pause(isPaused);\n    }\n\n    /************************************************\n     *  ROUTER ONLY FUNCTIONS\n     ***********************************************/\n\n    /**\n     * @notice Creates an option with the specified parameters\n     * @dev Can only be called by router\n     */\n    function createFromRouter(\n        OptionParams calldata optionParams,\n        bool isReferralValid\n    ) external override onlyRole(ROUTER_ROLE) returns (uint256 optionID) {\n        Option memory option = Option(\n            State.Active,\n            optionParams.strike,\n            optionParams.amount,\n            optionParams.amount,\n            optionParams.amount / 2,\n            block.timestamp + optionParams.period,\n            optionParams.isAbove,\n            optionParams.totalFee,\n            block.timestamp\n        );\n        totalLockedAmount += optionParams.amount;\n        optionID = _generateTokenId();\n        userOptionIds[optionParams.user].push(optionID);\n        options[optionID] = option;\n        _mint(optionParams.user, optionID);\n\n        uint256 referrerFee = _processReferralRebate(\n            optionParams.user,\n            optionParams.totalFee,\n            optionParams.amount,\n            optionParams.referralCode,\n            optionParams.isAbove,\n            isReferralValid\n        );\n\n        uint256 settlementFee = optionParams.totalFee -\n            option.premium -\n            referrerFee;\n\n        tokenX.transfer(config.settlementFeeDisbursalContract(), settlementFee);\n        pool.lock(optionID, option.lockedAmount, option.premium);\n        emit Create(\n            optionParams.user,\n            optionID,\n            settlementFee,\n            optionParams.totalFee\n        );\n    }\n\n    /**\n     * @notice Unlocks/Exercises the active options\n     * @dev Can only be called router\n     */\n    function unlock(uint256 optionID, uint256 priceAtExpiration)\n        external\n        override\n        onlyRole(ROUTER_ROLE)\n    {\n        require(_exists(optionID), \"O10\");\n        Option storage option = options[optionID];\n        require(option.expiration <= block.timestamp, \"O4\");\n        require(option.state == State.Active, \"O5\");\n\n        if (\n            (option.isAbove && priceAtExpiration > option.strike) ||\n            (!option.isAbove && priceAtExpiration < option.strike)\n        ) {\n            _exercise(optionID, priceAtExpiration);\n        } else {\n            option.state = State.Expired;\n            pool.unlock(optionID);\n            _burn(optionID);\n            emit Expire(optionID, option.premium, priceAtExpiration);\n        }\n        totalLockedAmount -= option.lockedAmount;\n    }\n\n    /************************************************\n     *  READ ONLY FUNCTIONS\n     ***********************************************/\n\n    /**\n     * @notice Returns decimals of the pool token\n     */\n    function decimals() public view returns (uint256) {\n        return tokenX.decimals();\n    }\n\n    /**\n     * @notice Calculates the fees for buying an option\n     */\n    function fees(\n        uint256 amount,\n        address user,\n        bool isAbove,\n        string calldata referralCode,\n        uint256 traderNFTId\n    )\n        public\n        view\n        returns (\n            uint256 total,\n            uint256 settlementFee,\n            uint256 premium\n        )\n    {\n        (uint256 settlementFeePercentage, ) = _getSettlementFeePercentage(\n            referral.codeOwner(referralCode),\n            user,\n            _getbaseSettlementFeePercentage(isAbove),\n            traderNFTId\n        );\n        (total, settlementFee, premium) = _fees(\n            amount,\n            settlementFeePercentage\n        );\n    }\n\n    /**\n     * @notice Checks if the strike price at which the trade is opened lies within the slippage bounds\n     */\n    function isStrikeValid(\n        uint256 slippage,\n        uint256 strike,\n        uint256 expectedStrike\n    ) external pure override returns (bool) {\n        if (\n            (strike <= (expectedStrike * (1e4 + slippage)) / 1e4) &&\n            (strike >= (expectedStrike * (1e4 - slippage)) / 1e4)\n        ) {\n            return true;\n        } else return false;\n    }\n\n    /**\n     * @notice Checks if the market is open at the time of option creation and execution.\n     * Used only for forex options\n     */\n    function isInCreationWindow(uint256 period) public view returns (bool) {\n        uint256 currentTime = block.timestamp;\n        uint256 currentDay = ((currentTime / 86400) + 4) % 7;\n        uint256 expirationDay = (((currentTime + period) / 86400) + 4) % 7;\n\n        if (currentDay == expirationDay) {\n            uint256 currentHour = (currentTime / 3600) % 24;\n            uint256 currentMinute = (currentTime % 3600) / 60;\n            uint256 expirationHour = ((currentTime + period) / 3600) % 24;\n            uint256 expirationMinute = ((currentTime + period) % 3600) / 60;\n            (\n                uint256 startHour,\n                uint256 startMinute,\n                uint256 endHour,\n                uint256 endMinute\n            ) = config.marketTimes(uint8(currentDay));\n\n            if (\n                (currentHour > startHour ||\n                    (currentHour == startHour &&\n                        currentMinute >= startMinute)) &&\n                (currentHour < endHour ||\n                    (currentHour == endHour && currentMinute < endMinute)) &&\n                (expirationHour < endHour ||\n                    (expirationHour == endHour && expirationMinute < endMinute))\n            ) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @notice Runs the basic checks for option creation\n     */\n    function runInitialChecks(\n        uint256 slippage,\n        uint256 period,\n        uint256 totalFee\n    ) external view override {\n        require(!isPaused, \"O33\");\n        require(slippage <= 5e2, \"O34\"); // 5% is the max slippage a user can use\n        require(period >= config.minPeriod(), \"O21\");\n        require(period <= config.maxPeriod(), \"O25\");\n        require(totalFee >= config.minFee(), \"O35\");\n    }\n\n    /**\n     * @notice Calculates max option amount based on the pool's capacity\n     */\n    function getMaxUtilization() public view returns (uint256 maxAmount) {\n        // Calculate the max option size due to asset wise pool utilization limit\n        uint256 totalPoolBalance = pool.totalTokenXBalance();\n        uint256 availableBalance = totalPoolBalance - totalLockedAmount;\n        uint256 utilizationLimit = config.assetUtilizationLimit();\n        uint256 maxAssetWiseUtilizationAmount = _getMaxUtilization(\n            totalPoolBalance,\n            availableBalance,\n            utilizationLimit\n        );\n\n        // Calculate the max option size due to overall pool utilization limit\n        utilizationLimit = config.overallPoolUtilizationLimit();\n        availableBalance = pool.availableBalance();\n        uint256 maxUtilizationAmount = _getMaxUtilization(\n            totalPoolBalance,\n            availableBalance,\n            utilizationLimit\n        );\n\n        // Take the min of the above 2 values\n        maxAmount = min(maxUtilizationAmount, maxAssetWiseUtilizationAmount);\n    }\n\n    /**\n     * @notice Runs all the checks on the option parameters and\n     * returns the revised amount and fee\n     */\n    function checkParams(OptionParams calldata optionParams)\n        external\n        view\n        override\n        returns (\n            uint256 amount,\n            uint256 revisedFee,\n            bool isReferralValid\n        )\n    {\n        require(\n            assetCategory != AssetCategory.Forex ||\n                isInCreationWindow(optionParams.period),\n            \"O30\"\n        );\n\n        uint256 maxAmount = getMaxUtilization();\n\n        // Calculate the max fee due to the max txn limit\n        uint256 maxPerTxnFee = ((pool.availableBalance() *\n            config.optionFeePerTxnLimitPercent()) / 100e2);\n        uint256 newFee = min(optionParams.totalFee, maxPerTxnFee);\n\n        // Calculate the amount here from the new fees\n        uint256 settlementFeePercentage;\n        (\n            settlementFeePercentage,\n            isReferralValid\n        ) = _getSettlementFeePercentage(\n            referral.codeOwner(optionParams.referralCode),\n            optionParams.user,\n            _getbaseSettlementFeePercentage(optionParams.isAbove),\n            optionParams.traderNFTId\n        );\n        (uint256 unitFee, , ) = _fees(10**decimals(), settlementFeePercentage);\n        amount = (newFee * 10**decimals()) / unitFee;\n\n        // Recalculate the amount and the fees if values are greater than the max and partial fill is allowed\n        if (amount > maxAmount || newFee < optionParams.totalFee) {\n            require(optionParams.allowPartialFill, \"O29\");\n            amount = min(amount, maxAmount);\n            (revisedFee, , ) = _fees(amount, settlementFeePercentage);\n        } else {\n            revisedFee = optionParams.totalFee;\n        }\n    }\n\n    /************************************************\n     * ERC721 FUNCTIONS\n     ***********************************************/\n\n    function _generateTokenId() internal returns (uint256) {\n        return nextTokenId++;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721, AccessControl)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    /************************************************\n     *  INTERNAL OPTION UTILITY FUNCTIONS\n     ***********************************************/\n\n    /**\n     * @notice Returns the base settlement fee based on option type\n     */\n    function _getbaseSettlementFeePercentage(bool isAbove)\n        internal\n        view\n        returns (uint16 baseSettlementFeePercentage)\n    {\n        baseSettlementFeePercentage = isAbove\n            ? baseSettlementFeePercentageForAbove\n            : baseSettlementFeePercentageForBelow;\n    }\n\n    /**\n     * @notice Calculates the max utilization\n     */\n    function _getMaxUtilization(\n        uint256 totalPoolBalance,\n        uint256 availableBalance,\n        uint256 utilizationLimit\n    ) internal pure returns (uint256) {\n        require(\n            availableBalance >\n                (((1e4 - utilizationLimit) * totalPoolBalance) / 1e4),\n            \"O31\"\n        );\n        return\n            availableBalance -\n            (((1e4 - utilizationLimit) * totalPoolBalance) / 1e4);\n    }\n\n    /**\n     * @notice Calculates the fees for buying an option\n     */\n    function _fees(uint256 amount, uint256 settlementFeePercentage)\n        internal\n        pure\n        returns (\n            uint256 total,\n            uint256 settlementFee,\n            uint256 premium\n        )\n    {\n        // Probability for ATM options will always be 0.5 due to which we can skip using BSM\n        premium = amount / 2;\n        settlementFee = (amount * settlementFeePercentage) / 1e4;\n        total = settlementFee + premium;\n    }\n\n    /**\n     * @notice Exercises the ITM options\n     */\n    function _exercise(uint256 optionID, uint256 priceAtExpiration)\n        internal\n        returns (uint256 profit)\n    {\n        Option storage option = options[optionID];\n        address user = ownerOf(optionID);\n        profit = option.lockedAmount;\n        pool.send(optionID, user, profit);\n\n        // Burn the option\n        _burn(optionID);\n        option.state = State.Exercised;\n        emit Exercise(user, optionID, profit, priceAtExpiration);\n    }\n\n    /**\n     * @notice Sends the referral rebate to the referrer and\n     * updates the stats in the referral storage contract\n     */\n    function _processReferralRebate(\n        address user,\n        uint256 totalFee,\n        uint256 amount,\n        string calldata referralCode,\n        bool isAbove,\n        bool isReferralValid\n    ) internal returns (uint25"
    }
  ]
}