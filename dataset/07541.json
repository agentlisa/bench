{
  "Title": "[M-11] LooksRare orders using WETH as currency cannot be paid with WETH",
  "Content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/marketplaces/LooksRareAdapter.sol#L51-L54><br>\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/logic/MarketplaceLogic.sol#L564-L565>\n\nUsers won't be able to buy NFTs from LooksRare via the Paraspace Marketplace and pay with WETH when `MakerOrder` currency is set to WETH.\n\n### Proof of Concept\n\nThe Paraspace Marketplace allows users to buy NFTs from third-party marketplaces (LooksRare, Seaport, X2Y2) using funds borrowed from Paraspace. The mechanism of buying tokens requires a `MakerOrder`: a data structure that's created by the seller and posted on a third-party exchange and that contains all the information about the order. Besides other fields, `MakerOrder` contains the `currency` field, which sets the currency the buyer is willing to receive payment in ([OrderTypes.sol#L20](https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/dependencies/looksrare/contracts/libraries/OrderTypes.sol#L20)):\n\n```solidity\nstruct MakerOrder {\n    ...\n    address currency; // currency (e.g., WETH)\n    ...\n}\n```\n\nWhile WETH is supported by LooksRare as a currency of orders, the LooksRare adapter of Paraspace converts it to the native (e.g. ETH) currency: if order's currency is WETH, the currency of consideration is set to the native currency ([LooksRareAdapter.sol#L49-L62](https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/marketplaces/LooksRareAdapter.sol#L49-L62)):\n\n```solidity\nItemType itemType = ItemType.ERC20;\naddress token = makerAsk.currency;\nif (token == weth) {\n    itemType = ItemType.NATIVE;\n    token = address(0);\n}\nconsideration[0] = ConsiderationItem(\n    itemType,\n    token,\n    0,\n    makerAsk.price, // TODO: take minPercentageToAsk into account\n    makerAsk.price,\n    payable(takerBid.taker)\n);\n```\n\nWhen users call the `buyWithCredit` function, they provide credit parameters: token address and amount (besides others) ([PoolMarketplace.sol#L71-L76](https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/pool/PoolMarketplace.sol#L71-L76), [DataTypes.sol#L296-L303](https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/types/DataTypes.sol#L296-L303)):\n\n```solidity\nfunction buyWithCredit(\n    bytes32 marketplaceId,\n    bytes calldata payload,\n    DataTypes.Credit calldata credit,\n    uint16 referralCode\n) external payable virtual override nonReentrant {\n```\n\n```solidity\nstruct Credit {\n    address token;\n    uint256 amount;\n    bytes orderId;\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n}\n```\n\nDeep inside the `buyWithCredit` function, `isETH` flag is set when the credit token specified by user is `address(0)` ([MarketplaceLogic.sol#L564-L566](https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/logic/MarketplaceLogic.sol#L564-L566)):\n\n```solidity\nvars.isETH = params.credit.token == address(0);\nvars.creditToken = vars.isETH ? params.weth : params.credit.token;\nvars.creditAmount = params.credit.amount;\n```\n\nFinally, before giving a credit, consideration type and credit token are checked ([MarketplaceLogic.sol#L388-L392](https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/logic/MarketplaceLogic.sol#L388-L392)):\n\n```solidity\nrequire(\n    item.itemType == ItemType.ERC20 ||\n        (vars.isETH && item.itemType == ItemType.NATIVE),\n    Errors.INVALID_ASSET_TYPE\n);\n```\n\nThis is what happens when a user tries to buy an NFT from LooksRare and pays with WETH as the maker order requires:\n\n1.  User calls `buyWithCredit` and sets credit token to WETH.\n2.  The currency of the consideration is changed to the native currency, and the consideration token is set to `address(0)`.\n3.  `var.isETH` is not set since the credit token is WETH, not `address(0)`.\n4.  The consideration type and credit token check fails because the type of the consideration is `NATIVE` but `var.isETH` is not set.\n5.  As a result, the call to `buyWithCredit` reverts and the user cannot buy a token while correctly using the API.\n\n```js\nit(\"fails when trying to buy a token on LooksRare with WETH [AUDIT]\", async () => {\n  const {\n    doodles,\n    pool,\n    weth,\n    users: [maker, taker, middleman],\n  } = await loadFixture(testEnvFixture);\n  const payNowNumber = \"8\";\n  const creditNumber = \"2\";\n  const payNowAmount = await convertToCurrencyDecimals(\n    weth.address,\n    payNowNumber\n  );\n  const creditAmount = await convertToCurrencyDecimals(\n    weth.address,\n    creditNumber\n  );\n  const startAmount = payNowAmount.add(creditAmount);\n  const nftId = 0;\n  // mint WETH to offer\n  await mintAndValidate(weth, payNowNumber, taker);\n  // middleman supplies DAI to pool to be borrowed by offer later\n  await supplyAndValidate(weth, creditNumber, middleman, true);\n  // maker mint mayc\n  await mintAndValidate(doodles, \"1\", maker);\n  // approve\n  await waitForTx(\n    await weth.connect(taker.signer).approve(pool.address, payNowAmount)\n  );\n\n  await expect(\n    executeLooksrareBuyWithCredit(\n      doodles,\n      weth as MintableERC20,\n      startAmount,\n      creditAmount,\n      nftId,\n      maker,\n      taker\n    )\n  ).to.be.revertedWith('93'); // invalid asset type for action.\n});\n```\n\n### Recommended Mitigation Steps\n\nConsider removing the WETH to NATIVE conversion in the LooksRare adapter. Alternatively, consider converting WETH to ETH seamlessly, without forcing users to send ETH instead of WETH when maker order requires WETH.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-paraspace-contest",
  "Code": [
    {
      "filename": "paraspace-core/contracts/misc/marketplaces/LooksRareAdapter.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {DataTypes} from \"../../protocol/libraries/types/DataTypes.sol\";\nimport {Errors} from \"../../protocol/libraries/helpers/Errors.sol\";\nimport {OrderTypes} from \"../../dependencies/looksrare/contracts/libraries/OrderTypes.sol\";\nimport {SeaportInterface} from \"../../dependencies/seaport/contracts/interfaces/SeaportInterface.sol\";\nimport {ILooksRareExchange} from \"../../dependencies/looksrare/contracts/interfaces/ILooksRareExchange.sol\";\nimport {SignatureChecker} from \"../../dependencies/looksrare/contracts/libraries/SignatureChecker.sol\";\nimport {ConsiderationItem} from \"../../dependencies/seaport/contracts/lib/ConsiderationStructs.sol\";\nimport {AdvancedOrder, CriteriaResolver, Fulfillment, OfferItem, ItemType} from \"../../dependencies/seaport/contracts/lib/ConsiderationStructs.sol\";\nimport {Address} from \"../../dependencies/openzeppelin/contracts/Address.sol\";\nimport {IERC1271} from \"../../dependencies/openzeppelin/contracts/IERC1271.sol\";\nimport {IMarketplace} from \"../../interfaces/IMarketplace.sol\";\nimport {PoolStorage} from \"../../protocol/pool/PoolStorage.sol\";\n\n/**\n * @title LooksRare Adapter\n *\n * @notice Implements the NFT <=> ERC20 exchange logic via LooksRare marketplace\n */\ncontract LooksRareAdapter is IMarketplace {\n    constructor() {}\n\n    function getAskOrderInfo(bytes memory params, address weth)\n        external\n        pure\n        override\n        returns (DataTypes.OrderInfo memory orderInfo)\n    {\n        (\n            OrderTypes.TakerOrder memory takerBid,\n            OrderTypes.MakerOrder memory makerAsk\n        ) = abi.decode(params, (OrderTypes.TakerOrder, OrderTypes.MakerOrder));\n        orderInfo.maker = makerAsk.signer;\n\n        OfferItem[] memory offer = new OfferItem[](1);\n        offer[0] = OfferItem(\n            ItemType.ERC721,\n            makerAsk.collection,\n            makerAsk.tokenId,\n            1,\n            1\n        );\n        orderInfo.offer = offer;\n\n        ConsiderationItem[] memory consideration = new ConsiderationItem[](1);\n\n        ItemType itemType = ItemType.ERC20;\n        address token = makerAsk.currency;\n        if (token == weth) {\n            itemType = ItemType.NATIVE;\n            token = address(0);\n        }\n        consideration[0] = ConsiderationItem(\n            itemType,\n            token,\n            0,\n            makerAsk.price, // TODO: take minPercentageToAsk into account\n            makerAsk.price,\n            payable(takerBid.taker)\n        );\n        orderInfo.id = abi.encodePacked(makerAsk.r, makerAsk.s, makerAsk.v);\n        orderInfo.consideration = consideration;\n    }\n\n    function getBidOrderInfo(\n        bytes memory /*params*/\n    ) external pure override returns (DataTypes.OrderInfo memory) {\n        revert(Errors.CALL_MARKETPLACE_FAILED);\n    }\n\n    function matchAskWithTakerBid(\n        address marketplace,\n        bytes calldata params,\n        uint256 value\n    ) external payable override returns (bytes memory) {\n        bytes4 selector;\n        if (value == 0) {\n            selector = ILooksRareExchange.matchAskWithTakerBid.selector;\n        } else {\n            selector = ILooksRareExchange\n                .matchAskWithTakerBidUsingETHAndWETH\n                .selector;\n        }\n        bytes memory data = abi.encodePacked(selector, params);\n        return\n            Address.functionCallWithValue(\n                marketplace,\n                data,\n                value,\n                Errors.CALL_MARKETPLACE_FAILED\n            );\n    }\n\n    function matchBidWithTakerAsk(address, bytes calldata)\n        external\n        pure\n        override\n        returns (bytes memory)\n    {\n        revert(Errors.CALL_MARKETPLACE_FAILED);\n    }\n}"
    },
    {
      "filename": "paraspace-core/contracts/protocol/libraries/logic/MarketplaceLogic.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {IERC721} from \"../../../dependencies/openzeppelin/contracts/IERC721.sol\";\nimport {INToken} from \"../../../interfaces/INToken.sol\";\nimport {IPoolAddressesProvider} from \"../../../interfaces/IPoolAddressesProvider.sol\";\nimport {XTokenType} from \"../../../interfaces/IXTokenType.sol\";\nimport {ICollateralizableERC721} from \"../../../interfaces/ICollateralizableERC721.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\nimport {IPToken} from \"../../../interfaces/IPToken.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {ValidationLogic} from \"./ValidationLogic.sol\";\nimport {SupplyLogic} from \"./SupplyLogic.sol\";\nimport {BorrowLogic} from \"./BorrowLogic.sol\";\nimport {SeaportInterface} from \"../../../dependencies/seaport/contracts/interfaces/SeaportInterface.sol\";\nimport {SafeERC20} from \"../../../dependencies/openzeppelin/contracts/SafeERC20.sol\";\nimport {IERC20} from \"../../../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport {IERC721} from \"../../../dependencies/openzeppelin/contracts/IERC721.sol\";\nimport {ConsiderationItem, OfferItem} from \"../../../dependencies/seaport/contracts/lib/ConsiderationStructs.sol\";\nimport {ItemType} from \"../../../dependencies/seaport/contracts/lib/ConsiderationEnums.sol\";\nimport {AdvancedOrder, CriteriaResolver, Fulfillment} from \"../../../dependencies/seaport/contracts/lib/ConsiderationStructs.sol\";\nimport {IWETH} from \"../../../misc/interfaces/IWETH.sol\";\nimport {UserConfiguration} from \"../configuration/UserConfiguration.sol\";\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {IMarketplace} from \"../../../interfaces/IMarketplace.sol\";\nimport {Address} from \"../../../dependencies/openzeppelin/contracts/Address.sol\";\n\n/**\n * @title Marketplace library\n *\n * @notice Implements the base logic for all the actions related to NFT buy/accept bid\n */\nlibrary MarketplaceLogic {\n    using UserConfiguration for DataTypes.UserConfigurationMap;\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n    using SafeERC20 for IERC20;\n\n    event BuyWithCredit(\n        bytes32 indexed marketplaceId,\n        DataTypes.OrderInfo orderInfo,\n        DataTypes.Credit credit\n    );\n\n    event AcceptBidWithCredit(\n        bytes32 indexed marketplaceId,\n        DataTypes.OrderInfo orderInfo,\n        DataTypes.Credit credit\n    );\n\n    struct MarketplaceLocalVars {\n        bool isETH;\n        address xTokenAddress;\n        address creditToken;\n        uint256 creditAmount;\n        address weth;\n        uint256 ethLeft;\n        bytes32 marketplaceId;\n        bytes payload;\n        DataTypes.Marketplace marketplace;\n        DataTypes.OrderInfo orderInfo;\n    }\n\n    function executeBuyWithCredit(\n        bytes32 marketplaceId,\n        bytes calldata payload,\n        DataTypes.Credit calldata credit,\n        DataTypes.PoolStorage storage ps,\n        IPoolAddressesProvider poolAddressProvider,\n        uint16 referralCode\n    ) external {\n        MarketplaceLocalVars memory vars;\n\n        vars.weth = poolAddressProvider.getWETH();\n        DataTypes.Marketplace memory marketplace = poolAddressProvider\n            .getMarketplace(marketplaceId);\n        DataTypes.OrderInfo memory orderInfo = IMarketplace(marketplace.adapter)\n            .getAskOrderInfo(payload, vars.weth);\n        orderInfo.taker = msg.sender;\n        vars.ethLeft = msg.value;\n\n        _depositETH(vars, orderInfo);\n\n        vars.ethLeft -= _buyWithCredit(\n            ps._reserves,\n            ps._reservesList,\n            ps._usersConfig[orderInfo.taker],\n            DataTypes.ExecuteMarketplaceParams({\n                marketplaceId: marketplaceId,\n                payload: payload,\n                credit: credit,\n                ethLeft: vars.ethLeft,\n                marketplace: marketplace,\n                orderInfo: orderInfo,\n                weth: vars.weth,\n                referralCode: referralCode,\n                reservesCount: ps._reservesCount,\n                oracle: poolAddressProvider.getPriceOracle(),\n                priceOracleSentinel: poolAddressProvider.getPriceOracleSentinel()\n            })\n        );\n\n        _refundETH(vars.ethLeft);\n    }\n\n    /**\n     * @notice Implements the buyWithCredit feature. BuyWithCredit allows users to buy NFT from various NFT marketplaces\n     * including OpenSea, LooksRare, X2Y2 etc. Users can use NFT's credit and will need to pay at most (1 - LTV) * $NFT\n     * @dev  Emits the `BuyWithCredit()` event\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets\n     * @param params The additional parameters needed to execute the buyWithCredit function\n     */\n    function _buyWithCredit(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.ExecuteMarketplaceParams memory params\n    ) internal returns (uint256) {\n        ValidationLogic.validateBuyWithCredit(params);\n\n        MarketplaceLocalVars memory vars = _cache(params);\n\n        _borrowTo(reservesData, params, vars, address(this));\n\n        (uint256 priceEth, uint256 downpaymentEth) = _delegateToPool(\n            params,\n            vars\n        );\n\n        // delegateCall to avoid extra token transfer\n        Address.functionDelegateCall(\n            params.marketplace.adapter,\n            abi.encodeWithSelector(\n                IMarketplace.matchAskWithTakerBid.selector,\n                params.marketplace.marketplace,\n                params.payload,\n                priceEth\n            )\n        );\n\n        _repay(\n            reservesData,\n            reservesList,\n            userConfig,\n            params,\n            vars,\n            params.orderInfo.taker\n        );\n\n        emit BuyWithCredit(\n            params.marketplaceId,\n            params.orderInfo,\n            params.credit\n        );\n\n        return downpaymentEth;\n    }\n\n    function executeBatchBuyWithCredit(\n        bytes32[] calldata marketplaceIds,\n        bytes[] calldata payloads,\n        DataTypes.Credit[] calldata credits,\n        DataTypes.PoolStorage storage ps,\n        IPoolAddressesProvider poolAddressProvider,\n        uint16 referralCode\n    ) external {\n        MarketplaceLocalVars memory vars;\n\n        vars.weth = poolAddressProvider.getWETH();\n        require(\n            marketplaceIds.length == payloads.length &&\n                payloads.length == credits.length,\n            Errors.INCONSISTENT_PARAMS_LENGTH\n        );\n        vars.ethLeft = msg.value;\n        for (uint256 i = 0; i < marketplaceIds.length; i++) {\n            vars.marketplaceId = marketplaceIds[i];\n            vars.payload = payloads[i];\n            DataTypes.Credit memory credit = credits[i];\n\n            DataTypes.Marketplace memory marketplace = poolAddressProvider\n                .getMarketplace(vars.marketplaceId);\n            DataTypes.OrderInfo memory orderInfo = IMarketplace(\n                marketplace.adapter\n            ).getAskOrderInfo(vars.payload, vars.weth);\n            orderInfo.taker = msg.sender;\n\n            // Once we encounter a listing using WETH, then we convert all our ethLeft to WETH\n            // this also means that the parameters order is very important\n            //\n            // frontend/sdk needs to guarantee that WETH orders will always be put after ALL\n            // ETH orders, all ETH orders after WETH orders will fail\n            //\n            // eg. The following example image that the `taker` owns only ETH and wants to\n            // batch buy bunch of NFTs which are listed using WETH and ETH\n            //\n            // batchBuyWithCredit([ETH, WETH, ETH]) => ko\n            //                            | -> convert all ethLeft to WETH, 3rd purchase will fail\n            // batchBuyWithCredit([ETH, ETH, ETH]) => ok\n            // batchBuyWithCredit([ETH, ETH, WETH]) => ok\n            //\n            _depositETH(vars, orderInfo);\n\n            vars.ethLeft -= _buyWithCredit(\n                ps._reserves,\n                ps._reservesList,\n                ps._usersConfig[orderInfo.taker],\n                DataTypes.ExecuteMarketplaceParams({\n                    marketplaceId: vars.marketplaceId,\n                    payload: vars.payload,\n                    credit: credit,\n                    ethLeft: vars.ethLeft,\n                    marketplace: marketplace,\n                    orderInfo: orderInfo,\n                    weth: vars.weth,\n                    referralCode: referralCode,\n                    reservesCount: ps._reservesCount,\n                    oracle: poolAddressProvider.getPriceOracle(),\n                    priceOracleSentinel: poolAddressProvider\n                        .getPriceOracleSentinel()\n                })\n            );\n        }\n\n        _refundETH(vars.ethLeft);\n    }\n\n    function executeAcceptBidWithCredit(\n        bytes32 marketplaceId,\n        bytes calldata payload,\n        DataTypes.Credit calldata credit,\n        address onBehalfOf,\n        DataTypes.PoolStorage storage ps,\n        IPoolAddressesProvider poolAddressProvider,\n        uint16 referralCode\n    ) external {\n        MarketplaceLocalVars memory vars;\n\n        vars.weth = poolAddressProvider.getWETH();\n        vars.marketplace = poolAddressProvider.getMarketplace(marketplaceId);\n        vars.orderInfo = IMarketplace(vars.marketplace.adapter).getBidOrderInfo(\n            payload\n        );\n        require(vars.orderInfo.taker == onBehalfOf, Errors.INVALID_ORDER_TAKER);\n\n        _acceptBidWithCredit(\n            ps._reserves,\n            ps._reservesList,\n            ps._usersConfig[vars.orderInfo.maker],\n            DataTypes.ExecuteMarketplaceParams({\n                marketplaceId: marketplaceId,\n                payload: payload,\n                credit: credit,\n                ethLeft: 0,\n                marketplace: vars.marketplace,\n                orderInfo: vars.orderInfo,\n                weth: vars.weth,\n                referralCode: referralCode,\n                reservesCount: ps._reservesCount,\n                oracle: poolAddressProvider.getPriceOracle(),\n                priceOracleSentinel: poolAddressProvider.getPriceOracleSentinel()\n            })\n        );\n    }\n\n    function executeBatchAcceptBidWithCredit(\n        bytes32[] calldata marketplaceIds,\n        bytes[] calldata payloads,\n        DataTypes.Credit[] calldata credits,\n        address onBehalfOf,\n        DataTypes.PoolStorage storage ps,\n        IPoolAddressesProvider poolAddressProvider,\n        uint16 referralCode\n    ) external {\n        MarketplaceLocalVars memory vars;\n\n        vars.weth = poolAddressProvider.getWETH();\n        require(\n            marketplaceIds.length == payloads.length &&\n                payloads.length == credits.length,\n            Errors.INCONSISTENT_PARAMS_LENGTH\n        );\n        for (uint256 i = 0; i < marketplaceIds.length; i++) {\n            vars.marketplaceId = marketplaceIds[i];\n            vars.payload = payloads[i];\n            DataTypes.Credit memory credit = credits[i];\n\n            vars.marketplace = poolAddressProvider.getMarketplace(\n                vars.marketplaceId\n            );\n            vars.orderInfo = IMarketplace(vars.marketplace.adapter)\n                .getBidOrderInfo(vars.payload);\n            require(\n                vars.orderInfo.taker == onBehalfOf,\n                Errors.INVALID_ORDER_TAKER\n            );\n\n            _acceptBidWithCredit(\n                ps._reserves,\n                ps._reservesList,\n                ps._usersConfig[vars.orderInfo.maker],\n                DataTypes.ExecuteMarketplaceParams({\n                    marketplaceId: vars.marketplaceId,\n                    payload: vars.payload,\n                    credit: credit,\n                    ethLeft: 0,\n                    marketplace: vars.marketplace,\n                    orderInfo: vars.orderInfo,\n                    weth: vars.weth,\n                    referralCode: referralCode,\n                    reservesCount: ps._reservesCount,\n                    oracle: poolAddressProvider.getPriceOracle(),\n                    priceOracleSentinel: poolAddressProvider\n                        .getPriceOracleSentinel()\n                })\n            );\n        }\n    }\n\n    /**\n     * @notice Implements the acceptBidWithCredit feature. AcceptBidWithCredit allows users to\n     * accept a leveraged bid on ParaSpace NFT marketplace. Users can submit leveraged bid and pay\n     * at most (1 - LTV) * $NFT\n     * @dev  Emits the `AcceptBidWithCredit()` event\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets\n     * @param params The additional parameters needed to execute the acceptBidWithCredit function\n     */\n    function _acceptBidWithCredit(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.ExecuteMarketplaceParams memory params\n    ) internal {\n        ValidationLogic.validateAcceptBidWithCredit(params);\n\n        MarketplaceLocalVars memory vars = _cache(params);\n\n        _borrowTo(reservesData, params, vars, params.orderInfo.maker);\n\n        // delegateCall to avoid extra token transfer\n        Address.functionDelegateCall(\n            params.marketplace.adapter,\n            abi.encodeWithSelector(\n                IMarketplace.matchBidWithTakerAsk.selector,\n                params.marketplace.marketplace,\n                params.payload\n            )\n        );\n\n        _repay(\n            reservesData,\n            reservesList,\n            userConfig,\n            params,\n            vars,\n            params.orderInfo.maker\n        );\n\n        emit AcceptBidWithCredit(\n            params.marketplaceId,\n            params.orderInfo,\n            params.credit\n        );\n    }\n\n    /**\n     * @notice Transfer payNow portion from taker to this contract. This is only useful\n     * in buyWithCredit.\n     * @dev\n     * @param params The additional parameters needed to execute the buyWithCredit/acceptBidWithCredit function\n     * @param vars The marketplace local vars for caching storage values for future reads\n     */\n    function _delegateToPool(\n        DataTypes.ExecuteMarketplaceParams memory params,\n        MarketplaceLocalVars memory vars\n    ) internal returns (uint256, uint256) {\n        uint256 price = 0;\n\n        for (uint256 i = 0; i < params.orderInfo.consideration.length; i++) {\n            ConsiderationItem memory item = params.orderInfo.consideration[i];\n            require(\n                item.startAmount == item.endAmount,\n                Errors.INVALID_MARKETPLACE_ORDER\n            );\n            require(\n                item.itemType == ItemType.ERC20 ||\n                    (vars.isETH && item.itemType == ItemType.NATIVE),\n                Errors.INVALID_ASSET_TYPE\n            );\n            require(\n                item.token == params.credit.token,\n                Errors.CREDIT_DOES_NOT_MATCH_ORDER\n            );\n            price += item.startAmount;\n        }\n\n        uint256 downpayment = price - vars.creditAmount;\n        if (!vars.isETH) {\n            IERC20(vars.creditToken).safeTransferFrom(\n                params.orderInfo.taker,\n                address(this),\n                downpayment\n            );\n            _checkAllowance(vars.creditToken, params.marketplace.operator);\n            // convert to (priceEth, downpaymentEth)\n            price = 0;\n            downpayment = 0;\n        } else {\n            require(params.ethLeft >= downpayment, Errors.PAYNOW_NOT_ENOUGH);\n        }\n\n        return (price, downpayment);\n    }\n\n    /**\n     * @notice Borrow credit.amount from `credit.token` reserve without collateral. The corresponding\n     * debt will be minted in the same block to the borrower.\n     * @dev\n     * @param reservesData The state of all the reserves\n     * @param params The additional parameters needed to execute the buyWithCredit/acceptBidWithCredit function\n     * @param vars The marketplace local vars for caching storage values for future reads\n     * @param to The receiver of borrowed tokens\n     */\n    function _borrowTo(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        DataTypes.ExecuteMarketplaceParams memory params,\n        MarketplaceLocalVars memory vars,\n        address to\n    ) internal {\n        if (vars.creditAmount == 0) {\n            return;\n        }\n\n        DataTypes.ReserveData storage reserve = reservesData[vars.creditToken];\n        vars.xTokenAddress = reserve.xTokenAddress;\n\n        require(vars.xTokenAddress != address(0), Errors.ASSET_NOT_LISTED);\n        ValidationLogic.validateFlashloanSimple(reserve);\n        // TODO: support PToken\n        IPToken(vars.xTokenAddress).transferUnderlyingTo(to, vars.creditAmount);\n\n        if (vars.isETH) {\n            // No re-entrancy because it sent to our contract address\n            IWETH(params.weth).withdraw(vars.creditAmount);\n        }\n    }\n\n    /**\n     * @notice Repay credit.amount by minting debt to the borrower. Borrower's received NFT\n     * will also need to be supplied to the pool to provide bigger borrow limit.\n     * @dev\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets\n     * @param params The additional parameters needed to execute the buyWithCredit/acceptBidWithCredit function\n     * @param vars The marketplace local vars for caching storage values for future reads\n     * @param onBehalfOf The receiver of minted debt and NToken\n     */\n    function _repay(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.ExecuteMarketplaceParams memory params,\n        MarketplaceLocalVars memory vars,\n        address onBehalfOf\n    ) internal {\n        for (uint256 i = 0; i < params.orderInfo.offer.length; i++) {\n            OfferItem memory item = params.orderInfo.offer[i];\n            require(\n                item.itemType == ItemType.ERC721,\n                Errors.INVALID_ASSET_TYPE\n            );\n\n            // underlyingAsset\n            address token = item.token;\n            uint256 tokenId = item.identifierOrCriteria;\n            // NToken\n            vars.xTokenAddress = reservesData[token].xTokenAddress;\n\n            // item.token == NToken\n            if (vars.xTokenAddress == address(0)) {\n                address underlyingAsset = INToken(token)\n                    .UNDERLYING_ASSET_ADDRESS();\n                bool isNToken = reservesData[underlyingAsset].xTokenAddress ==\n                    token;\n                require(isNToken, Errors.ASSET_NOT_LISTED);\n                vars.xTokenAddress = token;\n                token = underlyingAsset;\n            }\n\n            require(\n                INToken(vars.xTokenAddress).getXTokenType() !=\n                    XTokenType.NTokenUniswapV3,\n                Errors.UNIV3_NOT_ALLOWED\n            );\n\n            // item.token == underlyingAsset but supplied after listing/offering\n            // so NToken is transferred instead\n            if (INToken(vars.xTokenAddress).ownerOf(tokenId) == address(this)) {\n                _transferAndCollateralize(\n                    reservesData,\n                    userConfig,\n                    vars,\n                    token,\n                    tokenId,\n                    onBehalfOf\n                );\n                // item.token == underlyingAsset and underlyingAsset stays in wallet\n            } else {\n                DataTypes.ERC721SupplyParams[]\n                    memory tokenData = new DataTypes.ERC721SupplyParams[](1);\n                tokenData[0] = DataTypes.ERC721SupplyParams(tokenId, true);\n                SupplyLogic.executeSupplyERC721(\n                    reservesData,\n                    userConfig,\n                    DataTypes.ExecuteSupplyERC721Params({\n                        asset: token,\n                        tokenData: tokenData,\n                        onBehalfOf: onBehalfOf,\n                        payer: address(this),\n                        referralCode: params.referralCode\n                    })\n                );\n            }\n        }\n\n        if (vars.creditAmount == 0) {\n            return;\n        }\n\n        BorrowLogic.executeBorrow(\n            reservesData,\n            reservesList,\n            userConfig,\n            DataTypes.ExecuteBorrowParams({\n                asset: vars.creditToken,\n                user: onBehalfOf,\n                onBehalfOf: onBehalfOf,\n                amount: vars.creditAmount,\n                referralCode: params.referralCode,\n                releaseUnderlying: false,\n                reservesCount: params.reservesCount,\n                oracle: params.oracle,\n                priceOracleSentinel: params.priceOracleSentinel\n            })\n        );\n    }\n\n    function _checkAllowance(address token, address operator) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), operator);\n        if (allowance == 0) {\n            IERC20(token).safeApprove(operator, type(uint256).max);\n        }\n    }\n\n    function _cache(DataTypes.ExecuteMarketplaceParams memory params)\n        internal\n        pure\n        returns (MarketplaceLocalVars memory vars)\n    {\n        vars.isETH = params.credit.token == address(0);\n        vars.creditToken = vars.isETH ? params.weth : params.credit.token;\n        vars.creditAmount = params.credit.amount;\n    }\n\n    function _refundETH(uint256 ethLeft) internal {\n        if (ethLeft > 0) {\n            Address.sendValue(payable(msg.sender), ethLeft);\n        }\n    }\n\n    function _depositETH(\n        MarketplaceLocalVars memory vars,\n        DataTypes.OrderInfo memory orderInfo\n    ) internal {\n        if (\n            vars.ethLeft > 0 &&\n            orderInfo.consideration[0].itemType != ItemType.NATIVE\n        ) {\n            IWETH(vars.weth).deposit{value: vars.ethLeft}();\n            IERC20(vars.weth).safeTransferFrom(\n                address(this),\n                msg.sender,\n                vars.ethLeft\n            );\n            vars.ethLeft = 0;\n        }\n    }\n\n    function _transferAndCollateralize(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        DataTypes.UserConfigurationMap storage userConfig,\n        MarketplaceLocalVars memory vars,\n        address token,\n        uint256 tokenId,\n        address onBehalfOf\n    ) internal {\n        uint256[] memory tokenIds = new uint256[](1);\n        tokenIds[0] = tokenId;\n\n        IERC721(vars.xTokenAddress).safeTransferFrom(\n            address(this),\n            onBehalfOf,\n            tokenId\n        );\n        SupplyLogic.executeCollateralizeERC721(\n            reservesData,\n            userConfig,\n            token,\n            tokenIds,\n            onBehalfOf\n        );\n    }\n}"
    },
    {
      "filename": "paraspace-core/contracts/dependencies/looksrare/contracts/libraries/OrderTypes.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title OrderTypes\n * @notice This library contains order types for the LooksRare exchange.\n */\nlibrary OrderTypes {\n    // keccak256(\"MakerOrder(bool isOrderAsk,address signer,address collection,uint256 price,uint256 tokenId,uint256 amount,address strategy,address currency,uint256 nonce,uint256 startTime,uint256 endTime,uint256 minPercentageToAsk,bytes params)\")\n    bytes32 internal constant MAKER_ORDER_HASH = 0x40261ade532fa1d2c7293df30aaadb9b3c616fae525a0b56d3d411c841a85028;\n\n    struct MakerOrder {\n        bool isOrderAsk; // true --> ask / false --> bid\n        address signer; // signer of the maker order\n        address collection; // collection address\n        uint256 price; // price (used as )\n        uint256 tokenId; // id of the token\n        uint256 amount; // amount of tokens to sell/purchase (must be 1 for ERC721, 1+ for ERC1155)\n        address strategy; // strategy for trade execution (e.g., DutchAuction, StandardSaleForFixedPrice)\n        address currency; // currency (e.g., WETH)\n        uint256 nonce; // order nonce (must be unique unless new maker order is meant to override existing one e.g., lower ask price)\n        uint256 startTime; // startTime in timestamp\n        uint256 endTime; // endTime in timestamp\n        uint256 minPercentageToAsk; // slippage protection (9000 --> 90% of the final price must return to ask)\n        bytes params; // additional parameters\n        uint8 v; // v: parameter (27 or 28)\n        bytes32 r; // r: parameter\n        bytes32 s; // s: parameter\n    }\n\n    struct TakerOrder {\n        bool isOrderAsk; // true --> ask / false --> bid\n        address taker; // msg.sender\n        uint256 price; // final price for the purchase\n        uint256 tokenId;\n        uint256 minPercentageToAsk; // // slippage protection (9000 --> 90% of the final price must return to ask)\n        bytes params; // other params (e.g., tokenId)\n    }\n\n    function hash(MakerOrder memory makerOrder) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    MAKER_ORDER_HASH,\n                    makerOrder.isOrderAsk,\n                    makerOrder.signer,\n                    makerOrder.collection,\n                    makerOrder.price,\n                    makerOrder.tokenId,\n                    makerOrder.amount,\n                    makerOrder.strategy,\n                    makerOrder.currency,\n                    makerOrder.nonce,\n                    makerOrder.startTime,\n                    makerOrder.endTime,\n                    makerOrder.minPercentageToAsk,\n                    keccak256(makerOrder.params)\n                )\n            );\n    }\n}"
    },
    {
      "filename": "paraspace-core/contracts/misc/marketplaces/LooksRareAdapter.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {DataTypes} from \"../../protocol/libraries/types/DataTypes.sol\";\nimport {Errors} from \"../../protocol/libraries/helpers/Errors.sol\";\nimport {OrderTypes} from \"../../dependencies/looksrare/contracts/libraries/OrderTypes.sol\";\nimport {SeaportInterface} from \"../../dependencies/seaport/contracts/interfaces/SeaportInterface.sol\";\nimport {ILooksRareExchange} from \"../../dependencies/looksrare/contracts/interfaces/ILooksRareExchange.sol\";\nimport {SignatureChecker} from \"../../dependencies/looksrare/contracts/libraries/SignatureChecker.sol\";\nimport {ConsiderationItem} from \"../../dependencies/seaport/contracts/lib/ConsiderationStructs.sol\";\nimport {AdvancedOrder, CriteriaResolver, Fulfillment, OfferItem, ItemType} from \"../../dependencies/seaport/contracts/lib/ConsiderationStructs.sol\";\nimport {Address} from \"../../dependencies/openzeppelin/contracts/Address.sol\";\nimport {IERC1271} from \"../../dependencies/openzeppelin/contracts/IERC1271.sol\";\nimport {IMarketplace} from \"../../interfaces/IMarketplace.sol\";\nimport {PoolStorage} from \"../../protocol/pool/PoolStorage.sol\";\n\n/**\n * @title LooksRare Adapter\n *\n * @notice Implements the NFT <=> ERC20 exchange logic via LooksRare marketplace\n */\ncontract LooksRareAdapter is IMarketplace {\n    constructor() {}\n\n    function getAskOrderInfo(bytes memory params, address weth)\n        external\n        pure\n        override\n        returns (DataTypes.OrderInfo memory orderInfo)\n    {\n        (\n            OrderTypes.TakerOrder memory takerBid,\n            OrderTypes.MakerOrder memory makerAsk\n        ) = abi.decode(params, (OrderTypes.TakerOrder, OrderTypes.MakerOrder));\n        orderInfo.maker = makerAsk.signer;\n\n        OfferItem[] memory offer = new OfferItem[](1);\n        offer[0] = OfferItem(\n            ItemType.ERC721,\n            makerAsk.collection,\n            makerAsk.tokenId,\n            1,\n            1\n        );\n        orderInfo.offer = offer;\n\n        ConsiderationItem[] memory consideration = new ConsiderationItem[](1);\n\n        ItemType itemType = ItemType.ERC20;\n        address token = makerAsk.currency;\n        if (token == weth) {\n            itemType = ItemType.NATIVE;\n            token = address(0);\n        }\n        consideration[0] = ConsiderationItem(\n            itemType,\n            token,\n            0,\n            makerAsk.price, // TODO: take minPercentageToAsk into account\n            makerAsk.price,"
    }
  ]
}