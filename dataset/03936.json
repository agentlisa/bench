{
  "Title": "[L01] Approved addresses can forfeit user rewards",
  "Content": "Holders of [`FPOOL`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pool/FeiPool.sol#L17) tokens are entitled to rewards from the `FeiPool` contract. When the rewards have been collected using the [`claim`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pool/Pool.sol#L40) function, the user’s `FPOOL` tokens are burned. The situation is analogous with [`FGEN`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/genesis/GenesisGroup.sol#L59) tokens in `GenesisGroup`, with rewards collected using [`redeem`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/genesis/GenesisGroup.sol#L89), which burns the `FGEN` tokens.\n\n\nAs with all ERC20 tokens, holders of `FPOOL` and `FGEN` can `approve` other addresses to transfer their tokens on their behalf. However, with `FPOOL` and `FGEN`, these approved addresses are given an extra power: they can [burn the user’s tokens](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pool/Pool.sol#L93), forfeiting reward collection. This forfeiture of user rewards also increases the amount of rewards other token holders are entitled to, as [rewards are split proportionally](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pool/Pool.sol#L101) between holders.\n\n\nWhile it is assumed that users trust the addresses that they are approving, these external `burnFrom` functions seem to serve no purpose in the system, and so the increased risk could be removed.\n\n\nConsider changing the `FPOOL` and `FGEN` tokens to be [`ERC20`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/token/ERC20/ERC20.sol) instead of [`ERC20Burnable`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/token/ERC20/ERC20Burnable.sol). Functions that need to perform token burns can use the internal [`_burn` function](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/fa64a1ced0b70ab89073d5d0b6e01b0778f7e7d6/contracts/token/ERC20/ERC20.sol#L249) to do so, and additional `allowance` checks can be added if a third party is calling the function.\n\n\n**Update:** *Fixed in [PR#32](https://github.com/fei-protocol/fei-protocol-core/pull/32). The `FeiPool` contract no longer inherits from the `ERC20Burnable` contract. Additionally, the `burnFrom` public function was removed, and a new `_burnFrom` function was added to be used in the `_withdraw` function.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/pool/FeiPool.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./Pool.sol\";\nimport \"../refs/CoreRef.sol\";\n\n/// @title A Pool for earning TRIBE with staked FEI/TRIBE LP tokens\n/// @author Fei Protocol\n/// @notice deposited LP tokens will earn TRIBE over time at a linearly decreasing rate\ncontract FeiPool is Pool, CoreRef {\n\t\n\t/// @notice Fei Pool constructor\n\t/// @param _core Fei Core to reference\n\t/// @param _pair Uniswap pair to stake\n\t/// @param _duration duration of staking rewards\n\tconstructor(address _core, address _pair, uint32 _duration) public \n\t\tCoreRef(_core) Pool(_duration, \"Fei USD Pool\", \"FPOOL\") \n\t{\n\t\t_setTokens(\n\t\t\taddress(tribe()),\n\t\t\t_pair\n\t\t);\n\t}\n\n\t/// @notice sends tokens back to governance treasury. Only callable by governance\n\t/// @param amount the amount of tokens to send back to treasury\n\tfunction governorWithdraw(uint amount) external onlyGovernor {\n\t\ttribe().transfer(address(core()), amount);\n\t}\n\n\tfunction init() public override postGenesis {\n\t\tsuper.init();\t\n\t}\n\n\t// Represents the integral of 2R/d - 2R/d^2 x dx from t to d\n\t// Integral equals 2Rx/d - Rx^2/d^2\n\t// Evaluated at t = 2R*t/d (start) - R*t^2/d^2 (end)\n\t// Evaluated at d = 2R - R = R\n\t// Solution = R - (start - end) or equivalently end + R - start (latter more convenient to code)\n\tfunction _unreleasedReward(\n\t\tuint _totalReward, \n\t\tuint _duration, \n\t\tuint _time\n\t) internal view override returns (uint) {\n\t\t// 2R*t/d \n\t\tDecimal.D256 memory start = Decimal.ratio(_totalReward, _duration).mul(2).mul(_time);\n\n\t\t// R*t^2/d^2\n\t\tDecimal.D256 memory end = Decimal.ratio(_totalReward, _duration).div(_duration).mul(_time * _time);\n\n\t\treturn end.add(_totalReward).sub(start).asUint256();\n\t}\n}"
    },
    {
      "filename": "contracts/pool/Pool.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./IPool.sol\";\nimport \"../utils/Timed.sol\";\nimport \"../utils/SafeMath128.sol\";\nimport \"../external/SafeMathCopy.sol\";\nimport \"../external/Decimal.sol\";\n\n/// @title abstract implementation of IPool interface\n/// @author Fei Protocol\nabstract contract Pool is IPool, ERC20, ERC20Burnable, Timed {\n\tusing Decimal for Decimal.D256;\n\tusing SafeMath128 for uint128;\n\tusing SafeCast for uint;\n\n\tbool internal initialized;\n\n\tIERC20 public override rewardToken;\n\tIERC20 public override stakedToken;\n\n\tuint128 public override claimedRewards;\n\tuint128 public override totalStaked;\n\n    mapping (address => uint) public override stakedBalance;\n\n\t/// @notice Pool constructor\n\t/// @param _duration duration of the pool reward distribution\n\t/// @param _name the name of the pool token\n\t/// @param _ticker the token ticker for the pool token\n\tconstructor(\n\t\tuint32 _duration,\n\t\tstring memory _name,\n\t\tstring memory _ticker\n\t) public ERC20(_name, _ticker) Timed(_duration) {}\n\n\tfunction claim(address from, address to) external override returns(uint amountReward) {\n\t\tamountReward = _claim(from, to);\n\t\temit Claim(from, to, amountReward);\n\t\treturn amountReward;\n\t}\n\n\tfunction deposit(address to, uint amount) external override {\n\t\taddress from = msg.sender;\n\t\t_deposit(from, to, amount);\n\t\temit Deposit(from, to, amount);\n\t}\n\n\tfunction withdraw(address to) external override returns(uint amountStaked, uint amountReward) {\n\t\taddress from = msg.sender;\n\t\tamountReward = _claim(from, to);\n\t\tamountStaked = _withdraw(from, to);\n\t\temit Withdraw(from, to, amountStaked, amountReward);\n\t\treturn (amountStaked, amountReward);\n\t}\n\n\tfunction init() public override virtual {\n\t\trequire(!initialized, \"Pool: Already initialized\");\n\t\t_initTimed();\n\t\tinitialized = true;\n\t}\n\n    function redeemableReward(address account) public view override returns(uint amountReward, uint amountPool) {\n\t\tamountPool = _redeemablePoolTokens(account);\n\t\treturn (releasedReward() * amountPool / _totalRedeemablePoolTokens(), amountPool);\n    }\n\n\tfunction releasedReward() public view override returns (uint) {\n\t\tuint total = rewardBalance();\n\t\tuint unreleased = unreleasedReward();\n\t\trequire(total >= unreleased, \"Pool: Released Reward underflow\");\n\t\treturn total - unreleased;\n\t}\n\n\tfunction unreleasedReward() public view override returns (uint) {\n\t\tif (isTimeEnded()) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn _unreleasedReward(totalReward(), uint(duration), uint(timestamp()));\n\t}\n\n\tfunction totalReward() public view override returns (uint) {\n\t\treturn rewardBalance() + uint(claimedRewards);\n\t}\n\n\tfunction rewardBalance() public view override returns (uint) {\n\t\treturn rewardToken.balanceOf(address(this));\n\t}\n\n\tfunction burnFrom(address account, uint amount) public override {\n\t\tif (msg.sender == account) {\n\t\t\tincreaseAllowance(account, amount);\n\t\t}\n\t\tsuper.burnFrom(account, amount);\n\t}\n\n\tfunction _totalRedeemablePoolTokens() internal view returns(uint) {\n\t\tuint total = totalSupply();\n\t\tuint balance = _twfb(uint(totalStaked));\n\t\trequire(total >= balance, \"Pool: Total redeemable underflow\");\n\t\treturn total - balance;\n\t}\n\n\tfunction _redeemablePoolTokens(address account) internal view returns(uint) {\n\t\tuint total = balanceOf(account);\n\t\tuint balance = _twfb(stakedBalance[account]);\n\t\trequire(total >= balance, \"Pool: Redeemable underflow\");\n\t\treturn total - balance;\n\t}\n\n\tfunction _unreleasedReward(uint _totalReward, uint _duration, uint _time) internal view virtual returns (uint);\n\n\tfunction _deposit(address from, address to, uint amount) internal {\n\t\trequire(initialized, \"Pool: Uninitialized\");\n\t\trequire(amount <= stakedToken.balanceOf(from), \"Pool: Balance too low to stake\");\n\n\t\tstakedToken.transferFrom(from, address(this), amount);\n\n\t\tstakedBalance[to] += amount;\n\t\t_incrementStaked(amount);\n\t\t\n\t\tuint poolTokens = _twfb(amount);\n\t\trequire(poolTokens != 0, \"Pool: Window has ended\");\n\n\t\t_mint(to, poolTokens);\n\t}\n\n\tfunction _withdraw(address from, address to) internal returns(uint amountStaked) {\n\t\tamountStaked = stakedBalance[from];\n\t\tstakedBalance[from] = 0;\n\t\tstakedToken.transfer(to, amountStaked);\n\n\t\tuint amountPool = balanceOf(from);\n\t\tif (amountPool != 0) {\n\t\t\t_burn(from, amountPool);\n\t\t}\n\t\treturn amountStaked;\t\n\t}\n\n\tfunction _claim(address from, address to) internal returns(uint) {\n\t\t(uint amountReward, uint amountPool) = redeemableReward(from);\n\t\trequire(amountPool != 0, \"Pool: User has no redeemable pool tokens\");\n\n\t\tburnFrom(from, amountPool);\n\t\t_incrementClaimed(amountReward);\n\n\t\trewardToken.transfer(to, amountReward);\n\t\treturn amountReward;\n\t}\n\n\tfunction _incrementClaimed(uint amount) internal {\n\t\tclaimedRewards = claimedRewards.add(amount.toUint128());\n\t}\n\n\tfunction _incrementStaked(uint amount) internal {\n\t\ttotalStaked = totalStaked.add(amount.toUint128());\n\t}\n\n\tfunction _twfb(uint amount) internal view returns(uint) {\n\t\treturn amount * uint(remainingTime());\n\t}\n\n\t// Updates stored staked balance pro-rata for transfer and transferFrom\n\tfunction _beforeTokenTransfer(address from, address to, uint amount) internal override {\n        if (from != address(0) && to != address(0)) {\n \t\t\tDecimal.D256 memory ratio = Decimal.ratio(amount, balanceOf(from));\n \t\t\tuint amountStaked = ratio.mul(stakedBalance[from]).asUint256();\n\t\t\t\n \t\t\tstakedBalance[from] -= amountStaked;\n \t\t\tstakedBalance[to] += amountStaked;\n        }\n    }\n\n\tfunction _setTokens(address _rewardToken, address _stakedToken) internal {\n\t\trewardToken = IERC20(_rewardToken);\n\t\tstakedToken = IERC20(_stakedToken);\t\n\t}\n}"
    }
  ]
}