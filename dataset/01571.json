{
  "Title": "M-2: Escrow record not cleared on cancellation and order fill",
  "Content": "# Issue M-2: Escrow record not cleared on cancellation and order fill \n\nSource: https://github.com/sherlock-audit/2023-06-dinari-judging/issues/56 \n\n## Found by \nDelvir0, bin2chen, bitsurfer, chainNue, ctf\\_sec, dirk\\_y, hals, volodya\n## Summary\nIn `DirectBuyIssuer.sol`, a market buy requires the operator to take the payment token as escrow prior to filling the order. Checks are in place so that the math works out in terms of how much escrow has been taken vs the order's remaining fill amount. However, if the user cancels the order or fill the order, the escrow record is not cleared. \n\nThe escrow record will exists as a positive amount which can lead to accounting issues.\n\n## Vulnerability Detail\nTake the following example:\n\n- Operator broadcasts a `takeEscrow()` transaction around the same time that the user calls `requestCancel()` for the order\n- Operator also broadcasts a `cancelOrder()` transaction\n- If the `cancelOrder()` transaction is mined before the `takeEscrow()` transaction, then the contract will transfer out token when it should not be able to.\n\n`takeEscrow()` simply checks that the `getOrderEscrow[orderId]` is less than or equal to the requested amount:\n```solidity\n        bytes32 orderId = getOrderIdFromOrderRequest(orderRequest, salt);\n        uint256 escrow = getOrderEscrow[orderId];\n        if (amount > escrow) revert AmountTooLarge();\n\n\n        // Update escrow tracking\n        getOrderEscrow[orderId] = escrow - amount;\n        // Notify escrow taken\n        emit EscrowTaken(orderId, orderRequest.recipient, amount);\n\n\n        // Take escrowed payment\n        IERC20(orderRequest.paymentToken).safeTransfer(msg.sender, amount);\n```\n\nCancelling the order does not clear the `getOrderEscrow` record:\n```solidity\n    function _cancelOrderAccounting(OrderRequest calldata order, bytes32 orderId, OrderState memory orderState)\n        internal\n        virtual\n        override\n    {\n        // Prohibit cancel if escrowed payment has been taken and not returned or filled\n        uint256 escrow = getOrderEscrow[orderId];\n        if (orderState.remainingOrder != escrow) revert UnreturnedEscrow();\n\n\n        // Standard buy order accounting\n        super._cancelOrderAccounting(order, orderId, orderState);\n    }\n}\n```\n\nThis can lead to an good-faith and trusted operator accidentally taking funds from the contract that should not be able to leave.\n\ncoming up with the fact that the transaction does not have deadline or expiration date:\n\nconsider the case below:\n\n1. a good-faith operator send a transaction, takeEscrow\n2. the transaction is pending in the mempool for a long long long time\n3. then user fire a cancel order request\n4. the operator help user cancel the order\n5. the operator send a transcation cancel order\n6. cancel order transaction land first\n7. the takeEscrow transaction lands\n\nbecause escrow state is not clear up, the fund (other user's fund) is taken \n\nIt's also worth noting that the operator would not be able to call `returnEscrow()` because the order state has already been cleared by the cancellation. `getRemainingOrder()` would return **0**.\n\n```solidity\n    function returnEscrow(OrderRequest calldata orderRequest, bytes32 salt, uint256 amount)\n        external\n        onlyRole(OPERATOR_ROLE)\n    {\n        // No nonsense\n        if (amount == 0) revert ZeroValue();\n        // Can only return unused amount\n        bytes32 orderId = getOrderIdFromOrderRequest(orderRequest, salt);\n        uint256 remainingOrder = getRemainingOrder(orderId);\n        uint256 escrow = getOrderEscrow[orderId];\n        // Unused amount = remaining order - remaining escrow\n        if (escrow + amount > remainingOrder) revert AmountTooLarge();\n```\n\n## Impact\n- Insolvency due to pulling escrow that should not be allowed to be taken\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-06-dinari/blob/4851cb7ebc86a7bc26b8d0d399a7dd7f9520f393/sbt-contracts/src/issuer/DirectBuyIssuer.sol#L130-L142\n\n## Tool used\nManual Review\n\n## Recommendation\nClear the escrow record upon canceling the order.\n\n\n\n## Discussion\n\n**jaketimothy**\n\nFixed in \n- https://github.com/dinaricrypto/sbt-contracts/pull/122\n\n**ctf-sec**\n\nThe fix reset the escrow balance after cancelling\n\nthe protocol may want to consider handling the escrow accounting properly when the order is filled as well (such as reset the escrow balance to 0)\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/98",
  "Code": [
    {
      "filename": "sbt-contracts/src/issuer/DirectBuyIssuer.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.19;\n\nimport {SafeERC20, IERC20} from \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {BuyOrderIssuer, OrderProcessor} from \"./BuyOrderIssuer.sol\";\nimport {IMintBurn} from \"../IMintBurn.sol\";\n\n/// @notice Contract managing market purchase orders for bridged assets with direct payment\n/// @author Dinari (https://github.com/dinaricrypto/sbt-contracts/blob/main/src/issuer/DirectBuyIssuer.sol)\n/// This order processor emits market orders to buy the underlying asset that are good until cancelled\n/// Fees are calculated upfront and held back from the order amount\n/// The payment is taken by the operator before the order is filled\n/// The operator can return unused payment to the user\n/// The operator cannot cancel the order until payment is returned or the order is filled\n/// Implicitly assumes that asset tokens are BridgedERC20 and can be minted\n/// Order lifecycle (fulfillment):\n///   1. User requests an order (requestOrder)\n///   2. Operator takes escrowed payment (takeEscrow)\n///   3. [Optional] Operator partially fills the order (fillOrder)\n///   4. Operator completely fulfills the order (fillOrder)\n/// Order lifecycle (cancellation):\n///   1. User requests an order (requestOrder)\n///   2. Operator takes escrowed payment (takeEscrow)\n///   3. [Optional] Operator partially fills the order (fillOrder)\n///   4. [Optional] User requests cancellation (requestCancel)\n///   5. Operator returns unused payment to contract (returnEscrow)\n///   6. Operator cancels the order (cancelOrder)\ncontract DirectBuyIssuer is BuyOrderIssuer {\n    using SafeERC20 for IERC20;\n\n    /// ------------------ Types ------------------ ///\n\n    /// @dev Escrowed payment has been taken\n    error UnreturnedEscrow();\n\n    /// @dev Emitted when `amount` of escrowed payment is taken for `orderId`\n    event EscrowTaken(bytes32 indexed orderId, address indexed recipient, uint256 amount);\n    /// @dev Emitted when `amount` of escrowed payment is returned for `orderId`\n    event EscrowReturned(bytes32 indexed orderId, address indexed recipient, uint256 amount);\n\n    /// ------------------ State ------------------ ///\n\n    /// @dev orderId => escrow\n    mapping(bytes32 => uint256) public getOrderEscrow;\n\n    /// ------------------ Order Lifecycle ------------------ ///\n\n    /// @notice Take escrowed payment for an order\n    /// @param orderRequest Order request\n    /// @param salt Salt used to generate unique order ID\n    /// @param amount Amount of escrowed payment token to take\n    /// @dev Only callable by operator\n    function takeEscrow(OrderRequest calldata orderRequest, bytes32 salt, uint256 amount)\n        external\n        onlyRole(OPERATOR_ROLE)\n    {\n        // No nonsense\n        if (amount == 0) revert ZeroValue();\n        // Can't take more than escrowed\n        bytes32 orderId = getOrderIdFromOrderRequest(orderRequest, salt);\n        uint256 escrow = getOrderEscrow[orderId];\n        if (amount > escrow) revert AmountTooLarge();\n\n        // Update escrow tracking\n        getOrderEscrow[orderId] = escrow - amount;\n        // Notify escrow taken\n        emit EscrowTaken(orderId, orderRequest.recipient, amount);\n\n        // Take escrowed payment\n        IERC20(orderRequest.paymentToken).safeTransfer(msg.sender, amount);\n    }\n\n    /// @notice Return unused escrowed payment for an order\n    /// @param orderRequest Order request\n    /// @param salt Salt used to generate unique order ID\n    /// @param amount Amount of payment token to return to escrow\n    /// @dev Only callable by operator\n    function returnEscrow(OrderRequest calldata orderRequest, bytes32 salt, uint256 amount)\n        external\n        onlyRole(OPERATOR_ROLE)\n    {\n        // No nonsense\n        if (amount == 0) revert ZeroValue();\n        // Can only return unused amount\n        bytes32 orderId = getOrderIdFromOrderRequest(orderRequest, salt);\n        uint256 remainingOrder = getRemainingOrder(orderId);\n        uint256 escrow = getOrderEscrow[orderId];\n        // Unused amount = remaining order - remaining escrow\n        if (escrow + amount > remainingOrder) revert AmountTooLarge();\n\n        // Update escrow tracking\n        getOrderEscrow[orderId] = escrow + amount;\n        // Notify escrow returned\n        emit EscrowReturned(orderId, orderRequest.recipient, amount);\n\n        // Return payment to escrow\n        IERC20(orderRequest.paymentToken).safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    /// @inheritdoc OrderProcessor\n    function _requestOrderAccounting(OrderRequest calldata orderRequest, bytes32 orderId)\n        internal\n        virtual\n        override\n        returns (Order memory order)\n    {\n        // Compile standard buy order\n        order = super._requestOrderAccounting(orderRequest, orderId);\n        // Initialize escrow tracking for order\n        getOrderEscrow[orderId] = order.paymentTokenQuantity;\n    }\n\n    /// @inheritdoc OrderProcessor\n    function _fillOrderAccounting(\n        OrderRequest calldata orderRequest,\n        bytes32 orderId,\n        OrderState memory orderState,\n        uint256 fillAmount,\n        uint256 receivedAmount\n    ) internal virtual override {\n        // Can't fill more than payment previously taken from escrow\n        uint256 escrow = getOrderEscrow[orderId];\n        if (fillAmount > orderState.remainingOrder - escrow) revert AmountTooLarge();\n\n        // Buy order accounting\n        _fillBuyOrder(orderRequest, orderId, orderState, fillAmount, receivedAmount);\n    }\n\n    /// @inheritdoc OrderProcessor\n    function _cancelOrderAccounting(OrderRequest calldata order, bytes32 orderId, OrderState memory orderState)\n        internal\n        virtual\n        override\n    {\n        // Prohibit cancel if escrowed payment has been taken and not returned or filled\n        uint256 escrow = getOrderEscrow[orderId];\n        if (orderState.remainingOrder != escrow) revert UnreturnedEscrow();\n\n        // Standard buy order accounting\n        super._cancelOrderAccounting(order, orderId, orderState);\n    }\n}"
    }
  ]
}