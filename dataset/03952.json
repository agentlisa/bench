{
  "Title": "[M03] Users can avoid some slashing penalties by front-running",
  "Content": "The `slash` function of the `LockedGold` contract is called whenever any type of slashing occurs. It will [decrement the account’s non-voting locked gold balance](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/LockedGold.sol#L319), as well as [the accounts’ active and pending votes](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/LockedGold.sol#L313) if needed. However, an attacker can take advantage of the protocol in specific circumstances, when slashed accounts have more than the [locked gold requirement](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Validators.sol#L797) and the slashing [`penalty`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/LockedGold.sol#L296) is greater than the locked gold requirement.\n\n\nIn order to avoid some slashing penalties, a user can simply front-run the call to `slash` with calls to the functions [`revokePending`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L281) and [`revokeActive`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L317) of the `Election` contract, and the [`unlock` function](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/LockedGold.sol#L134) of the `LockedGold` contract. These first two functions will turn pending or active votes into nonvoting account balance, while the `unlock` function will turn the nonvoting account balance into `PendingWithdrawal` objects. \n\n\n[Aside from locked gold requirements for validators](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/LockedGold.sol#L141-L145), a user can `unlock` all of their other votes and account balances, turning them into `PendingWithdrawal`s. The `slash` function does not attempt to decrement from these, so a user can avoid some slashing penalties by doing so. If a user sees that they are being slashed before the slasher’s transaction is mined, the user can construct a transaction that moves their locked gold to a `PendingWithdrawal` and send it with a higher gas cost, front-running the slashing transaction. \n\n\nIt should be noted that there is little incentive for a validator or validator group to have any amount of locked gold above the required amount, so if they plan to be malicious, they will likely rid their accounts of anything other than the minimum amount of locked gold ahead of time, rather than taking a chance on trying to front-run. \n\n\nConsider adding functionality to `slash` that will also decrement from `pendingWithdrawals`.\n\n\n****Update:*** Not fixed. cLabs’ statement for this issue:*\n\n\n\n> \n> The current implementation limits the slashing penalty to be the `min(penalty, accountTotalLockedGold(validator))` so an account will never be slashed more than an account’s locked gold balance.  \n> \n> The intent is for penalties to never exceed the `lockedGoldRequirement` for any account.  \n> \n> For non-validators or validators/groups slashed via governance, they may still front-run their slashing by withdrawing. This is being tracked in [celo-org/celo-monorepo#2887](https://github.com/celo-org/celo-monorepo/issues/2887).\n> \n> \n> \n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/governance/LockedGold.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/Math.sol\";\nimport \"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./interfaces/ILockedGold.sol\";\n\nimport \"../common/Initializable.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/UsingRegistry.sol\";\n\ncontract LockedGold is ILockedGold, ReentrancyGuard, Initializable, UsingRegistry {\n  using SafeMath for uint256;\n\n  struct PendingWithdrawal {\n    // The value of the pending withdrawal.\n    uint256 value;\n    // The timestamp at which the pending withdrawal becomes available.\n    uint256 timestamp;\n  }\n\n  // NOTE: This contract does not store an account's locked gold that is being used in electing\n  // validators.\n  struct Balances {\n    // The amount of locked gold that this account has that is not currently participating in\n    // validator elections.\n    uint256 nonvoting;\n    // Gold that has been unlocked and will become available for withdrawal.\n    PendingWithdrawal[] pendingWithdrawals;\n  }\n\n  mapping(address => Balances) private balances;\n  mapping(address => bool) public isSlasher;\n\n  modifier onlySlasher() {\n    require(isSlasher[msg.sender], \"Caller must be registered slasher\");\n    _;\n  }\n\n  uint256 public totalNonvoting;\n  uint256 public unlockingPeriod;\n\n  event UnlockingPeriodSet(uint256 period);\n  event GoldLocked(address indexed account, uint256 value);\n  event GoldUnlocked(address indexed account, uint256 value, uint256 available);\n  event GoldWithdrawn(address indexed account, uint256 value);\n  event SlasherWhitelistAdded(address indexed slasher);\n  event SlasherWhitelistRemoved(address indexed slasher);\n  event AccountSlashed(\n    address indexed slashed,\n    uint256 penalty,\n    address indexed reporter,\n    uint256 reward\n  );\n\n  function initialize(address registryAddress, uint256 _unlockingPeriod) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    unlockingPeriod = _unlockingPeriod;\n  }\n\n  /**\n   * @notice Sets the duration in seconds users must wait before withdrawing gold after unlocking.\n   * @param value The unlocking period in seconds.\n   */\n  function setUnlockingPeriod(uint256 value) external onlyOwner {\n    require(value != unlockingPeriod, \"Unlocking period not changed\");\n    unlockingPeriod = value;\n    emit UnlockingPeriodSet(value);\n  }\n\n  /**\n   * @notice Locks gold to be used for voting.\n   */\n  function lock() external payable nonReentrant {\n    require(getAccounts().isAccount(msg.sender), \"not account\");\n    require(msg.value > 0, \"no value\");\n    _incrementNonvotingAccountBalance(msg.sender, msg.value);\n    emit GoldLocked(msg.sender, msg.value);\n  }\n\n  /**\n   * @notice Increments the non-voting balance for an account.\n   * @param account The account whose non-voting balance should be incremented.\n   * @param value The amount by which to increment.\n   * @dev Can only be called by the registered Election smart contract.\n   */\n  function incrementNonvotingAccountBalance(address account, uint256 value)\n    external\n    onlyRegisteredContract(ELECTION_REGISTRY_ID)\n  {\n    _incrementNonvotingAccountBalance(account, value);\n  }\n\n  /**\n   * @notice Decrements the non-voting balance for an account.\n   * @param account The account whose non-voting balance should be decremented.\n   * @param value The amount by which to decrement.\n   * @dev Can only be called by the registered \"Election\" smart contract.\n   */\n  function decrementNonvotingAccountBalance(address account, uint256 value)\n    external\n    onlyRegisteredContract(ELECTION_REGISTRY_ID)\n  {\n    _decrementNonvotingAccountBalance(account, value);\n  }\n\n  /**\n   * @notice Increments the non-voting balance for an account.\n   * @param account The account whose non-voting balance should be incremented.\n   * @param value The amount by which to increment.\n   */\n  function _incrementNonvotingAccountBalance(address account, uint256 value) private {\n    balances[account].nonvoting = balances[account].nonvoting.add(value);\n    totalNonvoting = totalNonvoting.add(value);\n  }\n\n  /**\n   * @notice Decrements the non-voting balance for an account.\n   * @param account The account whose non-voting balance should be decremented.\n   * @param value The amount by which to decrement.\n   */\n  function _decrementNonvotingAccountBalance(address account, uint256 value) private {\n    balances[account].nonvoting = balances[account].nonvoting.sub(value);\n    totalNonvoting = totalNonvoting.sub(value);\n  }\n\n  /**\n   * @notice Unlocks gold that becomes withdrawable after the unlocking period.\n   * @param value The amount of gold to unlock.\n   */\n  function unlock(uint256 value) external nonReentrant {\n    require(getAccounts().isAccount(msg.sender), \"Unknown account\");\n    Balances storage account = balances[msg.sender];\n    // Prevent unlocking gold when voting on governance proposals so that the gold cannot be\n    // used to vote more than once.\n    require(!getGovernance().isVoting(msg.sender), \"Account locked\");\n    uint256 balanceRequirement = getValidators().getAccountLockedGoldRequirement(msg.sender);\n    require(\n      balanceRequirement == 0 ||\n        balanceRequirement <= getAccountTotalLockedGold(msg.sender).sub(value),\n      \"Trying to unlock too much gold\"\n    );\n    _decrementNonvotingAccountBalance(msg.sender, value);\n    uint256 available = now.add(unlockingPeriod);\n    account.pendingWithdrawals.push(PendingWithdrawal(value, available));\n    emit GoldUnlocked(msg.sender, value, available);\n  }\n\n  /**\n   * @notice Relocks gold that has been unlocked but not withdrawn.\n   * @param index The index of the pending withdrawal to relock from.\n   * @param value The value to relock from the specified pending withdrawal.\n   */\n  function relock(uint256 index, uint256 value) external nonReentrant {\n    require(getAccounts().isAccount(msg.sender), \"Unknown account\");\n    Balances storage account = balances[msg.sender];\n    require(index < account.pendingWithdrawals.length, \"Bad pending withdrawal index\");\n    PendingWithdrawal storage pendingWithdrawal = account.pendingWithdrawals[index];\n    require(value <= pendingWithdrawal.value, \"Requested value larger than pending value\");\n    if (value == pendingWithdrawal.value) {\n      deletePendingWithdrawal(account.pendingWithdrawals, index);\n    } else {\n      pendingWithdrawal.value = pendingWithdrawal.value.sub(value);\n    }\n    _incrementNonvotingAccountBalance(msg.sender, value);\n    emit GoldLocked(msg.sender, value);\n  }\n\n  /**\n   * @notice Withdraws gold that has been unlocked after the unlocking period has passed.\n   * @param index The index of the pending withdrawal to withdraw.\n   */\n  function withdraw(uint256 index) external nonReentrant {\n    require(getAccounts().isAccount(msg.sender), \"Unknown account\");\n    Balances storage account = balances[msg.sender];\n    require(index < account.pendingWithdrawals.length, \"Bad pending withdrawal index\");\n    PendingWithdrawal storage pendingWithdrawal = account.pendingWithdrawals[index];\n    require(now >= pendingWithdrawal.timestamp, \"Pending withdrawal not available\");\n    uint256 value = pendingWithdrawal.value;\n    deletePendingWithdrawal(account.pendingWithdrawals, index);\n    require(getGoldToken().transfer(msg.sender, value), \"Transfer failed\");\n    emit GoldWithdrawn(msg.sender, value);\n  }\n\n  /**\n   * @notice Returns the total amount of locked gold in the system. Note that this does not include\n   *   gold that has been unlocked but not yet withdrawn.\n   * @return The total amount of locked gold in the system.\n   */\n  function getTotalLockedGold() external view returns (uint256) {\n    return totalNonvoting.add(getElection().getTotalVotes());\n  }\n\n  /**\n   * @notice Returns the total amount of locked gold not being used to vote in elections.\n   * @return The total amount of locked gold not being used to vote in elections.\n   */\n  function getNonvotingLockedGold() external view returns (uint256) {\n    return totalNonvoting;\n  }\n\n  /**\n   * @notice Returns the total amount of locked gold for an account.\n   * @param account The account.\n   * @return The total amount of locked gold for an account.\n   */\n  function getAccountTotalLockedGold(address account) public view returns (uint256) {\n    uint256 total = balances[account].nonvoting;\n    return total.add(getElection().getTotalVotesByAccount(account));\n  }\n\n  /**\n   * @notice Returns the total amount of non-voting locked gold for an account.\n   * @param account The account.\n   * @return The total amount of non-voting locked gold for an account.\n   */\n  function getAccountNonvotingLockedGold(address account) external view returns (uint256) {\n    return balances[account].nonvoting;\n  }\n\n  /**\n   * @notice Returns the pending withdrawals from unlocked gold for an account.\n   * @param account The address of the account.\n   * @return The value and timestamp for each pending withdrawal.\n   */\n  function getPendingWithdrawals(address account)\n    external\n    view\n    returns (uint256[] memory, uint256[] memory)\n  {\n    require(getAccounts().isAccount(account), \"Unknown account\");\n    uint256 length = balances[account].pendingWithdrawals.length;\n    uint256[] memory values = new uint256[](length);\n    uint256[] memory timestamps = new uint256[](length);\n    for (uint256 i = 0; i < length; i++) {\n      PendingWithdrawal memory pendingWithdrawal = (balances[account].pendingWithdrawals[i]);\n      values[i] = pendingWithdrawal.value;\n      timestamps[i] = pendingWithdrawal.timestamp;\n    }\n    return (values, timestamps);\n  }\n\n  /**\n   * @notice Deletes a pending withdrawal.\n   * @param list The list of pending withdrawals from which to delete.\n   * @param index The index of the pending withdrawal to delete.\n   */\n  function deletePendingWithdrawal(PendingWithdrawal[] storage list, uint256 index) private {\n    uint256 lastIndex = list.length.sub(1);\n    list[index] = list[lastIndex];\n    list.length = lastIndex;\n  }\n\n  /**\n   * @notice Adds `slasher` to whitelist of approved slashing addresses.\n   * @param slasher Address to whitelist.\n   */\n  function addSlasher(address slasher) external onlyOwner {\n    require(slasher != address(0) && !isSlasher[slasher], \"Invalid address to `addSlasher`.\");\n    isSlasher[slasher] = true;\n    emit SlasherWhitelistAdded(slasher);\n  }\n\n  /**\n   * @notice Removes `slasher` from whitelist of approved slashing addresses.\n   * @param slasher Address to remove from whitelist.\n   */\n  function removeSlasher(address slasher) external onlyOwner {\n    require(isSlasher[slasher], \"Address must be valid slasher.\");\n    isSlasher[slasher] = false;\n    emit SlasherWhitelistRemoved(slasher);\n  }\n\n  /**\n   * @notice Slashes `account` by reducing its nonvoting locked gold by `penalty`.\n   *         If there is not enough nonvoting locked gold to slash, calls into\n   *         `Election.slashVotes` to slash the remaining gold. If `account` does not have\n   *         `penalty` worth of locked gold, slashes `account`'s total locked gold.\n   *         Also sends `reward` gold to the reporter, and penalty-reward to the Community Fund.\n   * @param account Address of account being slashed.\n   * @param penalty Amount to slash account.\n   * @param reporter Address of account reporting the slasher.\n   * @param reward Reward to give reporter.\n   * @param lessers The groups receiving fewer votes than i'th group, or 0 if the i'th group has\n   *                the fewest votes of any validator group.\n   * @param greaters The groups receiving more votes than the i'th group, or 0 if the i'th group\n   *                 has the most votes of any validator group.\n   * @param indices The indices of the i'th group in `account`'s voting list.\n   * @dev Fails if `reward` is greater than `account`'s total locked gold.\n   */\n  function slash(\n    address account,\n    uint256 penalty,\n    address reporter,\n    uint256 reward,\n    address[] calldata lessers,\n    address[] calldata greaters,\n    uint256[] calldata indices\n  ) external onlySlasher {\n    uint256 maxSlash = Math.min(penalty, getAccountTotalLockedGold(account));\n    require(maxSlash >= reward, \"reward cannot exceed penalty.\");\n    // Local scoping is required to avoid Solc \"stack too deep\" error from too many locals.\n    {\n      uint256 nonvotingBalance = balances[account].nonvoting;\n      uint256 difference = 0;\n      // If not enough nonvoting, revoke the difference\n      if (nonvotingBalance < maxSlash) {\n        difference = maxSlash.sub(nonvotingBalance);\n        require(\n          getElection().forceDecrementVotes(account, difference, lessers, greaters, indices) ==\n            difference,\n          \"Cannot revoke enough voting gold.\"\n        );\n      }\n      // forceDecrementVotes does not increment nonvoting account balance, so we can't double count\n      _decrementNonvotingAccountBalance(account, maxSlash.sub(difference));\n      _incrementNonvotingAccountBalance(reporter, reward);\n    }\n    address communityFund = registry.getAddressForOrDie(GOVERNANCE_REGISTRY_ID);\n    address payable communityFundPayable = address(uint160(communityFund));\n    communityFundPayable.transfer(maxSlash.sub(reward));\n    emit AccountSlashed(account, maxSlash, reporter, reward);\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/governance/Election.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/Math.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"./interfaces/IElection.sol\";\nimport \"./interfaces/IValidators.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/FixidityLib.sol\";\nimport \"../common/linkedlists/AddressSortedLinkedList.sol\";\nimport \"../common/UsingPrecompiles.sol\";\nimport \"../common/UsingRegistry.sol\";\n\ncontract Election is\n  IElection,\n  Ownable,\n  ReentrancyGuard,\n  Initializable,\n  UsingRegistry,\n  UsingPrecompiles\n{\n  using AddressSortedLinkedList for SortedLinkedList.List;\n  using FixidityLib for FixidityLib.Fraction;\n  using SafeMath for uint256;\n\n  struct PendingVote {\n    // The value of the vote, in gold.\n    uint256 value;\n    // The epoch at which the vote was cast.\n    uint256 epoch;\n  }\n\n  struct GroupPendingVotes {\n    // The total number of pending votes that have been cast for this group.\n    uint256 total;\n    // Pending votes cast per voter.\n    mapping(address => PendingVote) byAccount;\n  }\n\n  // Pending votes are those for which no following elections have been held.\n  // These votes have yet to contribute to the election of validators and thus do not accrue\n  // rewards.\n  struct PendingVotes {\n    // The total number of pending votes cast across all groups.\n    uint256 total;\n    mapping(address => GroupPendingVotes) forGroup;\n  }\n\n  struct GroupActiveVotes {\n    // The total number of active votes that have been cast for this group.\n    uint256 total;\n    // The total number of active votes by a voter is equal to the number of active vote units for\n    // that voter times the total number of active votes divided by the total number of active\n    // vote units.\n    uint256 totalUnits;\n    mapping(address => uint256) unitsByAccount;\n  }\n\n  // Active votes are those for which at least one following election has been held.\n  // These votes have contributed to the election of validators and thus accrue rewards.\n  struct ActiveVotes {\n    // The total number of active votes cast across all groups.\n    uint256 total;\n    mapping(address => GroupActiveVotes) forGroup;\n  }\n\n  struct TotalVotes {\n    // A list of eligible ValidatorGroups sorted by total (pending+active) votes.\n    // Note that this list will omit ineligible ValidatorGroups, including those that may have > 0\n    // total votes.\n    SortedLinkedList.List eligible;\n  }\n\n  struct Votes {\n    PendingVotes pending;\n    ActiveVotes active;\n    TotalVotes total;\n    // Maps an account to the list of groups it's voting for.\n    mapping(address => address[]) groupsVotedFor;\n  }\n\n  struct ElectableValidators {\n    uint256 min;\n    uint256 max;\n  }\n\n  Votes private votes;\n  // Governs the minimum and maximum number of validators that can be elected.\n  ElectableValidators public electableValidators;\n  // Governs how many validator groups a single account can vote for.\n  uint256 public maxNumGroupsVotedFor;\n  // Groups must receive at least this fraction of the total votes in order to be considered in\n  // elections.\n  FixidityLib.Fraction public electabilityThreshold;\n\n  event ElectableValidatorsSet(uint256 min, uint256 max);\n\n  event MaxNumGroupsVotedForSet(uint256 maxNumGroupsVotedFor);\n\n  event ElectabilityThresholdSet(uint256 electabilityThreshold);\n\n  event ValidatorGroupMarkedEligible(address group);\n\n  event ValidatorGroupMarkedIneligible(address group);\n\n  event ValidatorGroupVoteCast(address indexed account, address indexed group, uint256 value);\n\n  event ValidatorGroupVoteActivated(address indexed account, address indexed group, uint256 value);\n\n  event ValidatorGroupVoteRevoked(address indexed account, address indexed group, uint256 value);\n\n  event EpochRewardsDistributedToVoters(address indexed group, uint256 value);\n\n  /**\n   * @notice Initializes critical variables.\n   * @param registryAddress The address of the registry contract.\n   * @param minElectableValidators The minimum number of validators that can be elected.\n   * @param _maxNumGroupsVotedFor The maximum number of groups that an acconut can vote for at once.\n   * @param _electabilityThreshold The minimum ratio of votes a group needs before its members can\n   *   be elected.\n   * @dev Should be called only once.\n   */\n  function initialize(\n    address registryAddress,\n    uint256 minElectableValidators,\n    uint256 maxElectableValidators,\n    uint256 _maxNumGroupsVotedFor,\n    uint256 _electabilityThreshold\n  ) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setElectableValidators(minElectableValidators, maxElectableValidators);\n    setMaxNumGroupsVotedFor(_maxNumGroupsVotedFor);\n    setElectabilityThreshold(_electabilityThreshold);\n  }\n\n  /**\n   * @notice Updates the minimum and maximum number of validators that can be elected.\n   * @param min The minimum number of validators that can be elected.\n   * @param max The maximum number of validators that can be elected.\n   * @return True upon success.\n   */\n  function setElectableValidators(uint256 min, uint256 max) public onlyOwner returns (bool) {\n    require(0 < min, \"Minimum electable validators cannot be zero\");\n    require(min <= max, \"Maximum electable validators cannot be smaller than minimum\");\n    require(\n      min != electableValidators.min || max != electableValidators.max,\n      \"Electable validators not changed\"\n    );\n    electableValidators = ElectableValidators(min, max);\n    emit ElectableValidatorsSet(min, max);\n    return true;\n  }\n\n  /**\n   * @notice Returns the minimum and maximum number of validators that can be elected.\n   * @return The minimum and maximum number of validators that can be elected.\n   */\n  function getElectableValidators() external view returns (uint256, uint256) {\n    return (electableValidators.min, electableValidators.max);\n  }\n\n  /**\n   * @notice Updates the maximum number of groups an account can be voting for at once.\n   * @param _maxNumGroupsVotedFor The maximum number of groups an account can vote for.\n   * @return True upon success.\n   */\n  function setMaxNumGroupsVotedFor(uint256 _maxNumGroupsVotedFor) public onlyOwner returns (bool) {\n    require(_maxNumGroupsVotedFor != maxNumGroupsVotedFor, \"Max groups voted for not changed\");\n    maxNumGroupsVotedFor = _maxNumGroupsVotedFor;\n    emit MaxNumGroupsVotedForSet(_maxNumGroupsVotedFor);\n    return true;\n  }\n\n  /**\n   * @notice Sets the electability threshold.\n   * @param threshold Electability threshold as unwrapped Fraction.\n   * @return True upon success.\n   */\n  function setElectabilityThreshold(uint256 threshold) public onlyOwner returns (bool) {\n    electabilityThreshold = FixidityLib.wrap(threshold);\n    require(\n      electabilityThreshold.lt(FixidityLib.fixed1()),\n      \"Electability threshold must be lower than 100%\"\n    );\n    emit ElectabilityThresholdSet(threshold);\n    return true;\n  }\n\n  /**\n   * @notice Gets the election threshold.\n   * @return Threshold value as unwrapped fraction.\n   */\n  function getElectabilityThreshold() external view returns (uint256) {\n    return electabilityThreshold.unwrap();\n  }\n\n  /**\n   * @notice Increments the number of total and pending votes for `group`.\n   * @param group The validator group to vote for.\n   * @param value The amount of gold to use to vote.\n   * @param lesser The group receiving fewer votes than `group`, or 0 if `group` has the\n   *   fewest votes of any validator group.\n   * @param greater The group receiving more votes than `group`, or 0 if `group` has the\n   *   most votes of any validator group.\n   * @return True upon success.\n   * @dev Fails if `group` is empty or not a validator group.\n   */\n  function vote(address group, uint256 value, address lesser, address greater)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    require(votes.total.eligible.contains(group), \"Group not eligible\");\n    require(0 < value, \"Vote value cannot be zero\");\n    require(canReceiveVotes(group, value), \"Group cannot receive votes\");\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n\n    // Add group to the groups voted for by the account.\n    bool alreadyVotedForGroup = false;\n    address[] storage groups = votes.groupsVotedFor[account];\n    for (uint256 i = 0; i < groups.length; i = i.add(1)) {\n      alreadyVotedForGroup = alreadyVotedForGroup || groups[i] == group;\n    }\n    if (!alreadyVotedForGroup) {\n      require(groups.length < maxNumGroupsVotedFor, \"Voted for too many groups\");\n      groups.push(group);\n    }\n\n    incrementPendingVotes(group, account, value);\n    incrementTotalVotes(group, value, lesser, greater);\n    getLockedGold().decrementNonvotingAccountBalance(account, value);\n    emit ValidatorGroupVoteCast(account, group, value);\n    return true;\n  }\n\n  /**\n   * @notice Converts `account`'s pending votes for `group` to active votes.\n   * @param group The validator group to vote for.\n   * @return True upon success.\n   * @dev Pending votes cannot be activated until an election has been held.\n   */\n  function activate(address group) external nonReentrant returns (bool) {\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    PendingVote storage pendingVote = votes.pending.forGroup[group].byAccount[account];\n    require(pendingVote.epoch < getEpochNumber(), \"Pending vote epoch not passed\");\n    uint256 value = pendingVote.value;\n    require(value > 0, \"Vote value cannot be zero\");\n    decrementPendingVotes(group, account, value);\n    incrementActiveVotes(group, account, value);\n    emit ValidatorGroupVoteActivated(account, group, value);\n    return true;\n  }\n\n  /**\n   * @notice Returns whether or not an account's votes for the specified group can be activated.\n   * @param account The account with pending votes.\n   * @param group The validator group that `account` has pending votes for.\n   * @return Whether or not `account` has activatable votes for `group`.\n   * @dev Pending votes cannot be activated until an election has been held.\n   */\n  function hasActivatablePendingVotes(address account, address group) external view returns (bool) {\n    PendingVote storage pendingVote = votes.pending.forGroup[group].byAccount[account];\n    return pendingVote.epoch < getEpochNumber() && pendingVote.value > 0;\n  }\n\n  /**\n   * @notice Revokes `value` pending votes for `group`\n   * @param group The validator group to revoke votes from.\n   * @param value The number of votes to revoke.\n   * @param lesser The group receiving fewer votes than the group for which the vote was revoked,\n   *   or 0 if that group has the fewest votes of any validator group.\n   * @param greater The group receiving more votes than the group for which the vote was revoked,\n   *   or 0 if that group has the most votes of any validator group.\n   * @param index The index of the group in the account's voting list.\n   * @return True upon success.\n   * @dev Fails if the account has not voted on a validator group.\n   */\n  function revokePending(\n    address group,\n    uint256 value,\n    address lesser,\n    address greater,\n    uint256 index\n  ) external nonReentrant returns (bool) {\n    require(group != address(0), \"Group address zero\");\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    require(0 < value, \"Vote value cannot be zero\");\n    require(\n      value <= getPendingVotesForGroupByAccount(group, account),\n      \"Vote value larger than pending votes\"\n    );\n    decrementPendingVotes(group, account, value);\n    decrementTotalVotes(group, value, lesser, greater);\n    getLockedGold().incrementNonvotingAccountBalance(account, value);\n    if (getTotalVotesForGroupByAccount(group, account) == 0) {\n      deleteElement(votes.groupsVotedFor[account], group, index);\n    }\n    emit ValidatorGroupVoteRevoked(account, group, value);\n    return true;\n  }\n\n  /**\n   * @notice Revokes `value` active votes for `group`\n   * @param group The validator group to revoke votes from.\n   * @param value The number of votes to revoke.\n   * @param lesser The group receiving fewer votes than the group for which the vote was revoked,\n   *   or 0 if that group has the fewest votes of any validator group.\n   * @param greater The group receiving more votes than the group for which the vote was revoked,\n   *   or 0 if that group has the most votes of any validator group.\n   * @param index The index of the group in the account's voting list.\n   * @return True upon success.\n   * @dev Fails if the account has not voted on a validator group.\n   */\n  function revokeActive(\n    address group,\n    uint256 value,\n    address lesser,\n    address greater,\n    uint256 index\n  ) external nonReentrant returns (bool) {\n    // TODO(asa): Dedup with revokePending.\n    require(group != address(0), \"Group address zero\");\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    require(0 < value, \"Vote value cannot be zero\");\n    require(\n      value <= getActiveVotesForGroupByAccount(group, account),\n      \"Vote value larger than active votes\"\n    );\n    decrementActiveVotes(group, account, value);\n    decrementTotalVotes(group, value, lesser, greater);\n    getLockedGold().incrementNonvotingAccountBalance(account, value);\n    if (getTotalVotesForGroupByAccount(group, account) == 0) {\n      deleteElement(votes.groupsVotedFor[account], group, index);\n    }\n    emit ValidatorGroupVoteRevoked(account, group, value);\n    return true;\n  }\n\n  /**\n   * @notice Decrements `value` pending or active votes for `group` from `account`.\n   *         First revokes all pending votes and then, if `value` votes haven't\n   *         been revoked yet, revokes additional active votes.\n   *         Fundamentally calls `revokePending` and `revokeActive` but only resorts groups once.\n   * @param account The account whose votes to `group` should be decremented.\n   * @param group The validator group to decrement votes from.\n   * @param maxValue The maxinum number of votes to decrement and revoke.\n   * @param lesser The group receiving fewer votes than the group for which the vote was revoked,\n   *               or 0 if that group has the fewest votes of any validator group.\n   * @param greater The group receiving more votes than the group for which the vote was revoked,\n   *                or 0 if that group has the most votes of any validator group.\n   * @param index The index of the group in the account's voting list.\n   * @return uint256 Number of votes successfully decremented and revoked, with a max of `value`.\n   */\n  function _decrementVotes(\n    address account,\n    address group,\n    uint256 maxValue,\n    address lesser,\n    address greater,\n    uint256 index\n  ) internal returns (uint256) {\n    uint256 remainingValue = maxValue;\n    uint256 pendingVotes = getPendingVotesForGroupByAccount(group, account);\n    if (pendingVotes > 0) {\n      uint256 decrementValue = Math.min(remainingValue, pendingVotes);\n      decrementPendingVotes(group, account, decrementValue);\n      remainingValue = remainingValue.sub(decrementValue);\n    }\n    uint256 activeVotes = getActiveVotesForGroupByAccount(group, account);\n    if (activeVotes > 0 && remainingValue > 0) {\n      uint256 decrementValue = Math.min(remainingValue, activeVotes);\n      decrementActiveVotes(group, account, decrementValue);\n      remainingValue = remainingValue.sub(decrementValue);\n    }\n    uint256 decrementedValue = maxValue.sub(remainingValue);\n    if (decrementedValue > 0) {\n      decrementTotalVotes(group, decrementedValue, lesser, greater);\n      emit ValidatorGroupVoteRevoked(account, group, decrementedValue);\n      if (getTotalVotesForGroupByAccount(group, account) == 0) {\n        deleteElement(votes.groupsVotedFor[account], group, index);\n      }\n    }\n    return decrementedValue;\n  }\n\n  /**\n   * @notice Returns the total number of votes cast by an account.\n   * @param account The address of the account.\n   * @return The total number of votes cast by an account.\n   */\n  function getTotalVotesByAccount(address account) external view returns (uint256) {\n    uint256 total = 0;\n    address[] memory groups = votes.groupsVotedFor[account];\n    for (uint256 i = 0; i < groups.length; i = i.add(1)) {\n      total = total.add(getTotalVotesForGroupByAccount(groups[i], account));\n    }\n    return total;\n  }\n\n  /**\n   * @notice Returns the pending votes for `group` made by `account`.\n   * @param group The address of the validator group.\n   * @param account The address of the voting account.\n   * @return The pending votes for `group` made by `account`.\n   */\n  function getPendingVotesForGroupByAccount(address group, address account)\n    public\n    view\n    returns (uint256)\n  {\n    return votes.pending.forGroup[group].byAccount[account].value;\n  }\n\n  /**\n   * @notice Returns the active votes for `group` made by `account`.\n   * @param group The address of the validator group.\n   * @param account The address of the voting account.\n   * @return The active votes for `group` made by `account`.\n   */\n  function getActiveVotesForGroupByAccount(address group, address account)\n    public\n    view\n    returns (uint256)\n  {\n    GroupActiveVotes storage groupActiveVotes = votes.active.forGroup[group];\n    uint256 numerator = groupActiveVotes.unitsByAccount[account].mul(groupActiveVotes.total);\n    if (numerator == 0) {\n      return 0;\n    }\n    uint256 denominator = groupActiveVotes.totalUnits;\n    return numerator.div(denominator);\n  }\n\n  /**\n   * @notice Returns the total votes for `group` made by `account`.\n   * @param group The address of the validator group.\n   * @param account The address of the voting account.\n   * @return The total votes for `group` made by `account`.\n   */\n  function getTotalVotesForGroupByAccount(address group, address account)\n    public\n    view\n    returns (uint256)\n  {\n    uint256 pending = getPendingVotesForGroupByAccount(group, account);\n    uint256 active = getActiveVotesForGroupByAccount(group, account);\n    return pending.add(active);\n  }\n\n  /**\n   * @notice Returns the total votes made for `group`.\n   * @param group The address of the validator group.\n   * @return The total votes made for `group`.\n   */\n  function getTotalVotesForGroup(address group) public view returns (uint256) {\n    return votes.pending.forGroup[group].total.add(votes.active.forGroup[group].total);\n  }\n\n  /**\n   * @notice Returns the active votes made for `group`.\n   * @param group The address of the validator group.\n   * @return The active votes made for `group`.\n   */\n  function getActiveVotesForGroup(address group) public view returns (uint256) {\n    return votes.active.forGroup[group].total;\n  }\n\n  /**\n   * @notice Returns whether or not a group is eligible to receive votes.\n   * @return Whether or not a group is eligible to receive votes.\n   * @dev Eligible groups that have received their maximum number of votes cannot receive more.\n   */\n  function getGroupEligibility(address group) external view returns (bool) {\n    return votes.total.eligible.contains(group);\n  }\n\n  /**\n   * @notice Returns the amount of rewards that voters for `group` are due at the end of an epoch.\n   * @param group The group to calculate epoch rewards for.\n   * @param totalEpochRewards The total"
    }
  ]
}