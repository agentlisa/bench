{
  "Title": "[H-13] TOFT `triggerSendFrom` can be used to steal all the balance",
  "Content": "\n[`triggerSendFrom`](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/BaseTOFT.sol#L99) -> [`sendFromDestination`](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/BaseTOFT.sol#L551) message pathway can be used to steal all the balance of the [`TapiocaOFT`](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/TapiocaOFT.sol) and [`mTapiocaOFT`](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/mTapiocaOFT.sol)\\` tokens in case when their underlying tokens is native gas token.\nTOFTs that hold native tokens are deployed with [erc20 address](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/TapiocaOFT.sol#L35) set to address zero, so while [minting you need to transfer value](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/TapiocaOFT.sol#L74).\n\n### Proof of Concept\n\nThe attack flow is the following:\n\n1.  Attacker calls `triggerSendFrom` with [`airdropAdapterParams`](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L41) of type [airdropAdapterParamsV1](https://layerzero.gitbook.io/docs/evm-guides/advanced/relayer-adapter-parameters) which don't airdrop any value on the remote chain but just deliver the message.\n2.  On the other hand [lzCallParams](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L44) are of type `adapterParamsV2` which are used to airdrop the balance from the destination chain to another chain to the attacker.\n\n```solidity\nstruct LzCallParams {\n    address payable refundAddress; // => address of the attacker\n    address zroPaymentAddress; // => doesn't matter\n    bytes adapterParams; //=> airdropAdapterParamsV2\n}\n```\n\n3.  Whereby the `sendFromData.adapterParams` would be encoded in the following way:\n\n```solidity\nfunction encodeAdapterParamsV2() public {\n    // https://layerzero.gitbook.io/docs/evm-guides/advanced/relayer-adapter-parameters#airdrop\n    uint256 gasLimit = 250_000; // something enough to deliver the message\n    uint256 airdroppedAmount = max airdrop cap defined at https://layerzero.gitbook.io/docs/evm-guides/advanced/relayer-adapter-parameters#airdrop. => 0.24 for ethereum, 1.32 for bsc, 681 for polygon etc.\n    address attacker = makeAddr(\"attacker\"); // => address of the attacker\n    bytes memory adapterParams = abi.encodePacked(uint16(2), gasLimit, airdroppedAmount, attacker);\n}\n```\n\n4.  When this is received on the remote inside the [`sendFromDestination`](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L118) [`ISendFrom(address(this)).sendFrom{value: address(this).balance}`](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L142)\n    is instructed by the malicious `ISendFrom.LzCallParams memory callParams`to actually airdrop the max amount allowed by LayerZero to the attacker on the [`lzDstChainId`](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L144).\n5.  Since there is a cap on the maximum airdrop amount this type of attack would need to be executed multiple times to drain the balance of the TOFT.\n\nThe core issue at play here is that `BaseTOFT` delegatecalls into the `BaseTOFTOptionsModule` and thus the BaseTOFT is the `msg.sender` for `sendFrom` function.\n\nThere is also another simpler attack flow possible:\n\n1.  Since [`sendFromDestination`](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L142) passes as value whole balance of the TapiocaOFT it is enough to specify the refundAddress in [callParams](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L123) as the address of the attacker.\n2.  This way the whole balance will be transferred to the [\\_lzSend](https://github.com/Tapioca-DAO/tapioca-sdk-audit/blob/90d1e8a16ebe278e86720bc9b69596f74320e749/src/contracts/lzApp/LzApp.sol#L53) and any excess will be refunded to the `_refundAddress`.\n3.  [This is how layer zero works](https://github.com/LayerZero-Labs/LayerZero/blob/main/contracts/UltraLightNodeV2.sol#L151-L156).\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nOne of the ways of tackling this issue is during the [`triggerSendFrom`](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L39) to:\n\n*   Not allowing [`airdropAdapterParams`](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L41) and [`sendFromData.adapterParams`](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L44) params to be passed as bytes but rather as `gasLimit` and `airdroppedAmount`, from which you would encode either `adapterParamsV1` or `adapterParamsV2`.\n*   And then on the receiving side check and send with value only the amount the user has airdropped.\n\n```solidity\n// Only allow the airdropped amount to be used for another message\nISendFrom(address(this)).sendFrom{value: aidroppedAmount}(\n   from,\n   lzDstChainId,\n   LzLib.addressToBytes32(from),\n   amount,\n   callParams\n);\n```\n\n**[0xRektora (Tapioca) confirmed](https://github.com/code-423n4/2023-07-tapioca-findings/issues/1290#issuecomment-1702995456)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-tapioca",
  "Code": [
    {
      "filename": "contracts/tOFT/BaseTOFT.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"./BaseTOFTStorage.sol\";\n\n//TOFT MODULES\nimport \"./modules/BaseTOFTLeverageModule.sol\";\nimport \"./modules/BaseTOFTStrategyModule.sol\";\nimport \"./modules/BaseTOFTMarketModule.sol\";\nimport \"./modules/BaseTOFTOptionsModule.sol\";\n\n/// @title BaseTOFT contract \n/// @notice Common tOFT capabilitites\n/// @dev all LayerZero methods are defined here\ncontract BaseTOFT is BaseTOFTStorage, ERC20Permit {\n    using SafeERC20 for IERC20;\n    using BytesLib for bytes;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    enum Module {\n        Leverage,\n        Strategy,\n        Market,\n        Options\n    }\n\n    /// @notice returns the leverage module\n    BaseTOFTLeverageModule public leverageModule;\n\n    /// @notice returns the Strategy module\n    BaseTOFTStrategyModule public strategyModule;\n\n    /// @notice returns the Market module\n    BaseTOFTMarketModule public marketModule;\n\n    /// @notice returns the Options module\n    BaseTOFTOptionsModule public optionsModule;\n\n    // ******************//\n    // *** MODIFIERS *** //\n    // ***************** //\n    /// @notice Require that the caller is on the host chain of the ERC20.\n    modifier onlyHostChain() {\n        require(block.chainid == hostChainID, \"TOFT_host\");\n        _;\n    }\n\n    constructor(\n        address _lzEndpoint,\n        address _erc20,\n        IYieldBoxBase _yieldBox,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal,\n        uint256 _hostChainID,\n        address payable _leverageModule,\n        address payable _strategyModule,\n        address payable _marketModule,\n        address payable _optionsModule\n    )\n        BaseTOFTStorage(\n            _lzEndpoint,\n            _erc20,\n            _yieldBox,\n            _name,\n            _symbol,\n            _decimal,\n            _hostChainID\n        )\n        ERC20Permit(string(abi.encodePacked(\"TapiocaOFT-\", _name)))\n    {\n        leverageModule = BaseTOFTLeverageModule(_leverageModule);\n        strategyModule = BaseTOFTStrategyModule(_strategyModule);\n        marketModule = BaseTOFTMarketModule(_marketModule);\n        optionsModule = BaseTOFTOptionsModule(_optionsModule);\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice decimal number of the ERC20\n    function decimals() public view override returns (uint8) {\n        if (_decimalCache == 0) return 18; //temporary fix for LZ _sharedDecimals check\n        return _decimalCache;\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice triggers a sendFrom to another layer from destination\n    /// @param lzDstChainId LZ destination id\n    /// @param airdropAdapterParams airdrop params\n    /// @param zroPaymentAddress ZRO payment address\n    /// @param amount amount to send back\n    /// @param sendFromData data needed to trigger sendFrom on destination\n    /// @param approvals approvals array\n    function triggerSendFrom(\n        uint16 lzDstChainId,\n        bytes calldata airdropAdapterParams,\n        address zroPaymentAddress,\n        uint256 amount,\n        ISendFrom.LzCallParams calldata sendFromData,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        _executeModule(\n            Module.Options,\n            abi.encodeWithSelector(\n                BaseTOFTOptionsModule.triggerSendFrom.selector,\n                lzDstChainId,\n                airdropAdapterParams,\n                zroPaymentAddress,\n                amount,\n                sendFromData,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice Exercise an oTAP position\n    /// @param optionsData oTap exerciseOptions data\n    /// @param lzData data needed for the cross chain transer\n    /// @param tapSendData needed for withdrawing Tap token\n    /// @param approvals array\n    function exerciseOption(\n        ITapiocaOptionsBrokerCrossChain.IExerciseOptionsData\n            calldata optionsData,\n        ITapiocaOptionsBrokerCrossChain.IExerciseLZData calldata lzData,\n        ITapiocaOptionsBrokerCrossChain.IExerciseLZSendTapData\n            calldata tapSendData,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        _executeModule(\n            Module.Options,\n            abi.encodeWithSelector(\n                BaseTOFTOptionsModule.exerciseOption.selector,\n                optionsData,\n                lzData,\n                tapSendData,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice inits a multiHopSellCollateral call\n    /// @param from The user who sells\n    /// @param share Collateral YieldBox-shares to sell\n    /// @param swapData Swap data used on destination chain for swapping USDO to the underlying TOFT token\n    /// @param lzData LayerZero specific data\n    /// @param externalData External contracts used for the cross chain operation\n    /// @param airdropAdapterParams default or airdrop adapter params\n    /// @param approvals array\n    function initMultiSell(\n        address from,\n        uint256 share,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData,\n        bytes calldata airdropAdapterParams,\n        ICommonData.IApproval[] memory approvals\n    ) external payable {\n        _executeModule(\n            Module.Leverage,\n            abi.encodeWithSelector(\n                BaseTOFTLeverageModule.initMultiSell.selector,\n                from,\n                share,\n                swapData,\n                lzData,\n                externalData,\n                airdropAdapterParams,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice calls removeCollateral on another layer\n    /// @param from sending address\n    /// @param to receiver address\n    /// @param lzDstChainId LayerZero destination chain id\n    /// @param zroPaymentAddress LayerZero ZRO payment address\n    /// @param withdrawParams withdrawTo specific params\n    /// @param removeParams removeAsset specific params\n    /// @param approvals approvals specific params\n    /// @param adapterParams LZ adapter params\n    function removeCollateral(\n        address from,\n        address to,\n        uint16 lzDstChainId,\n        address zroPaymentAddress,\n        ICommonData.IWithdrawParams calldata withdrawParams,\n        ITapiocaOFT.IRemoveParams calldata removeParams,\n        ICommonData.IApproval[] calldata approvals,\n        bytes calldata adapterParams\n    ) external payable {\n        _executeModule(\n            Module.Market,\n            abi.encodeWithSelector(\n                BaseTOFTMarketModule.removeCollateral.selector,\n                from,\n                to,\n                lzDstChainId,\n                zroPaymentAddress,\n                withdrawParams,\n                removeParams,\n                approvals,\n                adapterParams\n            ),\n            false\n        );\n    }\n\n    /// @notice sends TOFT to a specific strategy available on another layer\n    /// @param from the sender address\n    /// @param to the receiver address\n    /// @param amount the transferred amount\n    /// @param assetId the destination YieldBox asset id\n    /// @param lzDstChainId the destination LayerZero id\n    /// @param options the operation data\n    function sendToStrategy(\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share,\n        uint256 assetId,\n        uint16 lzDstChainId,\n        ICommonData.ISendOptions calldata options\n    ) external payable {\n        _executeModule(\n            Module.Strategy,\n            abi.encodeWithSelector(\n                BaseTOFTStrategyModule.sendToStrategy.selector,\n                from,\n                to,\n                amount,\n                share,\n                assetId,\n                lzDstChainId,\n                options\n            ),\n            false\n        );\n    }\n\n    /// @notice extracts TOFT from a specific strategy available on another layer\n    /// @param from the sender address\n    /// @param amount the transferred amount\n    /// @param assetId the destination YieldBox asset id\n    /// @param lzDstChainId the destination LayerZero id\n    /// @param zroPaymentAddress LayerZero ZRO payment address\n    /// @param airdropAdapterParam the LayerZero aidrop adapter params\n    function retrieveFromStrategy(\n        address from,\n        uint256 amount,\n        uint256 share,\n        uint256 assetId,\n        uint16 lzDstChainId,\n        address zroPaymentAddress,\n        bytes memory airdropAdapterParam\n    ) external payable {\n        _executeModule(\n            Module.Strategy,\n            abi.encodeWithSelector(\n                BaseTOFTStrategyModule.retrieveFromStrategy.selector,\n                from,\n                amount,\n                share,\n                assetId,\n                lzDstChainId,\n                zroPaymentAddress,\n                airdropAdapterParam\n            ),\n            false\n        );\n    }\n\n    /// @notice sends TOFT to a specific chain and performs a borrow operation\n    /// @param from the sender address\n    /// @param to the receiver address\n    /// @param lzDstChainId the destination LayerZero id\n    /// @param airdropAdapterParams the LayerZero aidrop adapter params\n    /// @param borrowParams the borrow operation data\n    /// @param withdrawParams the withdraw operation data\n    /// @param options the cross chain send operation data\n    /// @param approvals the cross chain approval operation data\n    function sendToYBAndBorrow(\n        address from,\n        address to,\n        uint16 lzDstChainId,\n        bytes calldata airdropAdapterParams,\n        ITapiocaOFT.IBorrowParams calldata borrowParams,\n        ICommonData.IWithdrawParams calldata withdrawParams,\n        ICommonData.ISendOptions calldata options,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        _executeModule(\n            Module.Market,\n            abi.encodeWithSelector(\n                BaseTOFTMarketModule.sendToYBAndBorrow.selector,\n                from,\n                to,\n                lzDstChainId,\n                airdropAdapterParams,\n                borrowParams,\n                withdrawParams,\n                options,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice sends TOFT to a specific chain and performs a leverage down operation\n    /// @param amount the amount to use\n    /// @param leverageFor the receiver address\n    /// @param lzData LZ specific data\n    /// @param swapData ISwapper specific data\n    /// @param externalData external contracts used for the flow\n    function sendForLeverage(\n        uint256 amount,\n        address leverageFor,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData\n    ) external payable {\n        _executeModule(\n            Module.Leverage,\n            abi.encodeWithSelector(\n                BaseTOFTLeverageModule.sendForLeverage.selector,\n                amount,\n                leverageFor,\n                lzData,\n                swapData,\n                externalData\n            ),\n            false\n        );\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n\n    //---internal-\n    function _wrap(\n        address _fromAddress,\n        address _toAddress,\n        uint256 _amount\n    ) internal virtual {\n        if (_fromAddress != msg.sender) {\n            require(\n                allowance(_fromAddress, msg.sender) >= _amount,\n                \"TOFT_allowed\"\n            );\n        }\n        IERC20(erc20).safeTransferFrom(_fromAddress, address(this), _amount);\n        _mint(_toAddress, _amount);\n    }\n\n    function _wrapNative(address _toAddress) internal virtual {\n        require(msg.value > 0, \"TOFT_0\");\n        _mint(_toAddress, msg.value);\n    }\n\n    function _unwrap(address _toAddress, uint256 _amount) internal virtual {\n        _burn(msg.sender, _amount);\n\n        if (erc20 == address(0)) {\n            _safeTransferETH(_toAddress, _amount);\n        } else {\n            IERC20(erc20).safeTransfer(_toAddress, _amount);\n        }\n    }\n\n    //---private---\n    function _safeTransferETH(address to, uint256 amount) internal {\n        (bool sent, ) = to.call{value: amount}(\"\");\n        require(sent, \"TOFT_failed\");\n    }\n\n    function _extractModule(Module _module) private view returns (address) {\n        address module;\n        if (_module == Module.Leverage) {\n            module = address(leverageModule);\n        } else if (_module == Module.Strategy) {\n            module = address(strategyModule);\n        } else if (_module == Module.Market) {\n            module = address(marketModule);\n        } else if (_module == Module.Options) {\n            module = address(optionsModule);\n        }\n\n        if (module == address(0)) {\n            revert(\"TOFT_module\");\n        }\n\n        return module;\n    }\n\n    function _executeModule(\n        Module _module,\n        bytes memory _data,\n        bool _forwardRevert\n    ) private returns (bool success, bytes memory returnData) {\n        success = true;\n        address module = _extractModule(_module);\n\n        (success, returnData) = module.delegatecall(_data);\n        if (!success && !_forwardRevert) {\n            revert(_getRevertMsg(returnData));\n        }\n    }\n\n    function _executeOnDestination(\n        Module _module,\n        bytes memory _data,\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) private {\n        (bool success, bytes memory returnData) = _executeModule(\n            _module,\n            _data,\n            true\n        );\n        if (!success) {\n            _storeFailedMessage(\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload,\n                returnData\n            );\n        }\n    }\n\n    //---LZ---\n    function _nonblockingLzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal virtual override {\n        uint256 packetType = _payload.toUint256(0);\n\n        if (packetType == PT_YB_SEND_STRAT) {\n            _executeOnDestination(\n                Module.Strategy,\n                abi.encodeWithSelector(\n                    BaseTOFTStrategyModule.strategyDeposit.selector,\n                    strategyModule,\n                    _srcChainId,\n                    _srcAddress,\n                    _nonce,\n                    _payload,\n                    IERC20(address(this))\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_YB_RETRIEVE_STRAT) {\n            _executeOnDestination(\n                Module.Strategy,\n                abi.encodeWithSelector(\n                    BaseTOFTStrategyModule.strategyWithdraw.selector,\n                    _srcChainId,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_LEVERAGE_MARKET_DOWN) {\n            _executeOnDestination(\n                Module.Leverage,\n                abi.encodeWithSelector(\n                    BaseTOFTLeverageModule.leverageDown.selector,\n                    leverageModule,\n                    _srcChainId,\n                    _srcAddress,\n                    _nonce,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_YB_SEND_SGL_BORROW) {\n            _executeOnDestination(\n                Module.Market,\n                abi.encodeWithSelector(\n                    BaseTOFTMarketModule.borrow.selector,\n                    marketModule,\n                    _srcChainId,\n                    _srcAddress,\n                    _nonce,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_MARKET_REMOVE_COLLATERAL) {\n            _executeOnDestination(\n                Module.Market,\n                abi.encodeWithSelector(\n                    BaseTOFTMarketModule.remove.selector,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_MARKET_MULTIHOP_SELL) {\n            _executeOnDestination(\n                Module.Leverage,\n                abi.encodeWithSelector(\n                    BaseTOFTLeverageModule.multiHop.selector,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_TAP_EXERCISE) {\n            _executeOnDestination(\n                Module.Options,\n                abi.encodeWithSelector(\n                    BaseTOFTOptionsModule.exercise.selector,\n                    _srcChainId,\n                    _srcAddress,\n                    _nonce,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_SEND_FROM) {\n            _executeOnDestination(\n                Module.Options,\n                abi.encodeWithSelector(\n                    BaseTOFTOptionsModule.sendFromDestination.selector,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else {\n            packetType = _payload.toUint8(0);\n            if (packetType == PT_SEND) {\n                _sendAck(_srcChainId, _srcAddress, _nonce, _payload);\n            } else if (packetType == PT_SEND_AND_CALL) {\n                _sendAndCallAck(_srcChainId, _srcAddress, _nonce, _payload);\n            } else {\n                revert(\"TOFT_packet\");\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/tOFT/TapiocaOFT.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\nimport \"./BaseTOFT.sol\";\n\n/*\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\n*/\n\n/// @title tOFT contract\n/// @notice tOFT wrapper contract\n/// @dev transforms a normal ERC20 or the native gas token into an OFTV2 type contract\n///      - wrapping & unwrapping of the ERC20/the gas token can only happen on the host chain\ncontract TapiocaOFT is BaseTOFT {\n    using SafeERC20 for IERC20;\n    using BytesLib for bytes;\n\n    /// @notice creates a new TapiocaOFT\n    /// @param _lzEndpoint LayerZero endpoint address\n    /// @param _erc20 true the underlying ERC20 address\n    /// @param _yieldBox the YieldBox address\n    /// @param _name the TOFT name\n    /// @param _symbol the TOFT symbol\n    /// @param _decimal the TOFT decimal\n    /// @param _hostChainID the TOFT host chain LayerZero id\n    constructor(\n        address _lzEndpoint,\n        address _erc20,\n        IYieldBoxBase _yieldBox,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal,\n        uint256 _hostChainID,\n        address payable _leverageModule,\n        address payable _strategyModule,\n        address payable _marketModule,\n        address payable _optionsModule\n    )\n        BaseTOFT(\n            _lzEndpoint,\n            _erc20,\n            _yieldBox,\n            _name,\n            _symbol,\n            _decimal,\n            _hostChainID,\n            _leverageModule,\n            _strategyModule,\n            _marketModule,\n            _optionsModule\n        )\n    {}\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice Wrap an ERC20 with a 1:1 ratio with a fee if existing.\n    /// @dev Since it can be executed only on the main chain, if an address exists on the OP chain it will not allowed to wrap.\n    /// @param _fromAddress The address to wrap from.\n    /// @param _toAddress The address to wrap the ERC20 to.\n    /// @param _amount The amount of ERC20 to wrap.\n    function wrap(\n        address _fromAddress,\n        address _toAddress,\n        uint256 _amount\n    ) external payable onlyHostChain {\n        if (erc20 == address(0)) {\n            _wrapNative(_toAddress);\n        } else {\n            _wrap(_fromAddress, _toAddress, _amount);\n        }\n    }\n\n    /// @notice Unwrap an ERC20/Native with a 1:1 ratio. Called only on host chain.\n    /// @param _toAddress The address to unwrap the tokens to.\n    /// @param _amount The amount of tokens to unwrap.\n\n    function unwrap(\n        address _toAddress,\n        uint256 _amount\n    ) external onlyHostChain {\n        _unwrap(_toAddress, _amount);\n    }\n}"
    },
    {
      "filename": "contracts/tOFT/modules/BaseTOFTOptionsModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\n//LZ\nimport \"tapioca-sdk/dist/contracts/libraries/LzLib.sol\";\n\n//TAPIOCA\nimport \"tapioca-periph/contracts/interfaces/IPermitBorrow.sol\";\nimport \"tapioca-periph/contracts/interfaces/IPermitAll.sol\";\nimport \"tapioca-periph/contracts/interfaces/ITapiocaOptionsBroker.sol\";\n// import {ITapiocaOptionsBrokerCrossChain} from \"tapioca-periph/contracts/interfaces/ITapiocaOptionsBroker.sol\";\nimport \"../BaseTOFTStorage.sol\";\n\n/// @title tOFT options module\n/// @notice tOFT module for oTAP type actions\ncontract BaseTOFTOptionsModule is BaseTOFTStorage {\n    using SafeERC20 for IERC20;\n\n    constructor(\n        address _lzEndpoint,\n        address _erc20,\n        IYieldBoxBase _yieldBox,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal,\n        uint256 _hostChainID\n    )\n        BaseTOFTStorage(\n            _lzEndpoint,\n            _erc20,\n            _yieldBox,\n            _name,\n            _symbol,\n            _decimal,\n            _hostChainID\n        )\n    {}\n\n    function triggerSendFrom(\n        uint16 lzDstChainId,\n        bytes calldata airdropAdapterParams,\n        address zroPaymentAddress,\n        uint256 amount,\n        ISendFrom.LzCallParams calldata sendFromData,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        bytes memory lzPayload = abi.encode(\n            PT_SEND_FROM,\n            msg.sender,\n            amount,\n            sendFromData,\n            lzEndpoint.getChainId(),\n            approvals\n        );\n\n        _lzSend(\n            lzDstChainId,\n            lzPayload,\n            payable(msg.sender),\n            zroPaymentAddress,\n            airdropAdapterParams,\n            msg.value\n        );\n\n        emit SendToChain(\n            lzDstChainId,\n            msg.sender,\n            LzLib.addressToBytes32(msg.sender),\n            0\n        );\n    }\n\n    function exerciseOption(\n        ITapiocaOptionsBrokerCrossChain.IExerciseOptionsData\n            calldata optionsData,\n        ITapiocaOptionsBrokerCrossChain.IExerciseLZData calldata lzData,\n        ITapiocaOptionsBrokerCrossChain.IExerciseLZSendTapData\n            calldata tapSendData,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        bytes32 toAddress = LzLib.addressToBytes32(optionsData.from);\n\n        _debitFrom(\n            optionsData.from,\n            lzEndpoint.getChainId(),\n            toAddress,\n            optionsData.paymentTokenAmount\n        );\n\n        bytes memory lzPayload = abi.encode(\n            PT_TAP_EXERCISE,\n            optionsData,\n            tapSendData,\n            approvals\n        );\n\n        bytes memory adapterParams = LzLib.buildDefaultAdapterParams(\n            lzData.extraGas\n        );\n\n        _lzSend(\n            lzData.lzDstChainId,\n            lzPayload,\n            payable(optionsData.from),\n            lzData.zroPaymentAddress,\n            adapterParams,\n            msg.value\n        );\n\n        emit SendToChain(\n            lzData.lzDstChainId,\n            optionsData.from,\n            toAddress,\n            optionsData.paymentTokenAmount\n        );\n    }\n\n    function sendFromDestination(bytes memory _payload) public {\n        (\n            ,\n            address from,\n            uint256 amount,\n            ISendFrom.LzCallParams memory callParams,\n            uint16 lzDstChainId,\n            ICommonData.IApproval[] memory approvals\n        ) = abi.decode(\n                _payload,\n                (\n                    uint16,\n                    address,\n                    uint256,\n                    ISendFrom.LzCallParams,\n                    uint16,\n                    ICommonData.IApproval[]\n                )\n            );\n\n        if (approvals.length > 0) {\n            _callApproval(approvals);\n        }\n\n        ISendFrom(address(this)).sendFrom{value: address(this).balance}(\n            from,\n            lzDstChainId,\n            LzLib.addressToBytes32(from),\n            amount,\n            callParams\n        );\n\n        emit ReceiveFromChain(lzDstChainId, from, 0);\n    }\n\n    function exercise(\n        address module,\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) public {\n        (\n            ,\n            ITapiocaOptionsBrokerCrossChain.IExerciseOptionsData\n                memory optionsData,\n            ITapiocaOptionsBrokerCrossChain.IExerciseLZSendTapData\n                memory tapSendData,\n            ICommonData.IApproval[] memory approvals\n        ) = abi.decode(\n                _payload,\n                (\n                    uint16,\n                    ITapiocaOptionsBrokerCrossChain.IExerciseOptionsData,\n                    ITapiocaOptionsBrokerCrossChain.IExerciseLZSendTapData,\n                    ICommonData.IApproval[]\n                )\n            );\n\n        uint256 balanceBefore = balanceOf(address(this));\n        bool credited = creditedPackets[_srcChainId][_srcAddress][_nonce];\n        if (!credited) {\n            _creditTo(\n                _srcChainId,\n                address(this),\n                optionsData.paymentTokenAmount\n            );\n            creditedPackets[_srcChainId][_srcAddress][_nonce] = true;\n        }\n        uint256 balanceAfter = balanceOf(address(this));\n\n        (bool success, bytes memory reason) = module.delegatecall(\n            abi.encodeWithSelector(\n                this.exerciseInternal.selector,\n                optionsData.from,\n                optionsData.oTAPTokenID,\n                optionsData.paymentToken,\n                optionsData.tapAmount,\n                optionsData.target,\n                tapSendData,\n                approvals\n            )\n        );\n\n        if (!success) {\n            if (\n                balanceAfter - balanceBefore >= optionsData.paymentTokenAmount\n            ) {\n                IERC20(address(this)).safeTransfer(\n                    optionsData.from,\n                    optionsData.paymentTokenAmount\n                );\n            }\n            revert(_getRevertMsg(reason)); //forward revert because it's handled by the main executor\n        }\n\n        emit ReceiveFromChain(\n            _srcChainId,\n            optionsData.from,\n            optionsData.paymentTokenAmount\n        );\n    }\n\n    function exerciseInternal(\n        address from,\n        uint256 oTAPTokenID,\n        address paymentToken,\n        uint256 tapAmount,\n        address target,\n        ITapiocaOptionsBrokerCrossChain.IExerciseLZSendTapData\n            memory tapSendData,\n        ICommonData.IApproval[] memory approvals\n    ) public {\n        if (approvals.length > 0) {\n            _callApproval(approvals);\n        }\n\n        ITapiocaOptionsBroker(target).exerciseOption(\n            oTAPTokenID,\n            paymentToken,\n            tapAmount\n        );\n        if (tapSendData.withdrawOnAnotherChain) {\n            ISendFrom(tapSendData.tapOftAddress).sendFrom(\n                address(this),\n                tapSendData.lzDstChainId,\n                LzLib.addressToBytes32(from),\n                tapAmount,\n                ISendFrom.LzCallParams({\n                    refundAddress: payable(from),\n                    zroPaymentAddress: tapSendData.zroPaymentAddress,\n                    adapterParams: LzLib.buildDefaultAdapterParams(\n                        tapSendData.extraGas\n                    )\n                })\n            );\n        } else {\n            IERC20(tapSendData.tapOftAddress).safeTransfer(from, tapAmount);\n        }\n    }\n\n    function _callApproval(ICommonData.IApproval[] memory approvals) private {\n        for (uint256 i = 0; i < approvals.length; ) {\n            if (approvals[i].permitBorrow) {\n                try\n                    IPermitBorrow(approvals[i].target).permitBorrow(\n                        approvals[i].owner,\n                        approvals[i].spender,\n                        approvals[i].value,\n                        approvals[i].deadline,\n                        approvals[i].v,\n                        approvals[i].r,\n                        approvals[i].s\n                    )\n                {} catch Error(string memory reason) {\n                    if (!approvals[i].allowFailure) {\n                        revert(reason);\n                    }\n                }\n            } else if (approvals[i].permitAll) {\n                try\n                    IPermitAll(approvals[i].target).permitAll(\n                        approvals[i].owner,\n                        approvals[i].spender,\n                        approvals[i].deadline,\n                        approvals[i].v,\n                        approvals[i].r,\n                        approvals[i].s\n                    )\n                {} catch Error(string memory reason) {\n                    if (!approvals[i].allowFailure) {\n                        revert(reason);\n                    }\n                }\n            } else {\n                try\n                    IERC20Permit(approvals[i].target).permit(\n                        approvals[i].owner,\n                        approvals[i].spender,\n                        approvals[i].value,\n                        approvals[i].deadline,\n                        approvals[i].v,\n                        approvals[i].r,\n                        approvals[i].s\n                    )\n                {} catch Error(string memory reason) {\n                    if (!approvals[i].allowFailure) {\n                        revert(reason);\n                    }\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/tOFT/modules/BaseTOFTOptionsModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\n//LZ\nimport \"tapioca-sdk/dist/contracts/libraries/LzLib.sol\";\n\n//TAPIOCA\nimport \"tapioca-periph/contracts/interfaces/IPermitBorrow.sol\";\nimport \"tapioca-periph/contracts/interfaces/IPermitAll.sol\";\nimport \"tapioca-periph/contracts/interfaces/ITapiocaOptionsBroker.sol\";\n// import {ITapiocaOptionsBrokerCrossChain} from \"tapioca-periph/contracts/interfaces/ITapiocaOptionsBroker.sol\";\nimport \"../BaseTOFTS"
    }
  ]
}