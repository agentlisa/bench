{
  "Title": "[05] Overpaid asset is locked in lending pool when flashloan",
  "Content": "\n*Note: At the judgeâ€™s request [here](https://github.com/code-423n4/2024-01-init-capital-invitational-findings/issues/7#issuecomment-1934027323), this downgraded issue from the same warden has been included in this report for completeness.*\n\nhttps://github.com/code-423n4/2024-01-init-capital-invitational/blob/a01c4de620be98f9e57a60cf6a82d4feaec54f58/contracts/core/InitCore.sol#L392\n\nhttps://github.com/code-423n4/2024-01-init-capital-invitational/blob/a01c4de620be98f9e57a60cf6a82d4feaec54f58/contracts/core/InitCore.sol#L380\n\nOverpaid asset in locked when flashloan\n\n### Proof of Concept\n\nWhen flashloan, in this end to code check if the lending pool balance is greater than the consumed balance before flashloan:\n\nhttps://github.com/code-423n4/2024-01-init-capital-invitational/blob/a01c4de620be98f9e57a60cf6a82d4feaec54f58/contracts/core/InitCore.sol#L392\n\n```solidity\n// execute callback\nIFlashReceiver(msg.sender).flashCallback(_pools, _amts, _data);\n// check pool balance after callback\nfor (uint i; i < _pools.length; i = i.uinc()) {\n\t_require(IERC20(tokens[i]).balanceOf(_pools[i]) >= balanceBefores[i], Errors.INVALID_AMOUNT_TO_REPAY);\n}\n```\n\nThe problem is that in case when user over-pay flashloan. \n\nSuppose user flash loan 10000 USDC and then repay 10100 USDC, the 100 USDC is lost and locked in the lending pool because the internal accounting of lending pool use cashAmount to track available balance.\n\nHowever, the code above does not update [cash amount](https://github.com/code-423n4/2024-01-init-capital-invitational/blob/a01c4de620be98f9e57a60cf6a82d4feaec54f58/contracts/lending_pool/LendingPool.sol#L108) after flashloan is finished.\n\n### Recommended Mitigation Steps\n\nwhile I understand this is an mitigation for finding\n\nhttps://github.com/code-423n4/2023-12-initcapital-findings/issues/3\n\nthe issue above can be resolved (issue 3)\n\nhttps://github.com/code-423n4/2024-01-init-capital-invitational/blob/a01c4de620be98f9e57a60cf6a82d4feaec54f58/contracts/core/InitCore.sol#L380\n\n```solidity\n// check that flash is enabled\n_require(poolConfig.canFlash, Errors.FLASH_PAUSED);\n```\n\nWhen setModeStatus.canCollateralize and can.Borrow to false\n\nhttps://github.com/code-423n4/2024-01-init-capital-invitational/blob/a01c4de620be98f9e57a60cf6a82d4feaec54f58/contracts/core/Config.sol#L136\n\n```solidity\n /// @inheritdoc IConfig\n    function setModeStatus(uint16 _mode, ModeStatus calldata _status) external onlyGuardian {\n        _require(_mode != 0, Errors.INVALID_MODE);\n        __modeConfigs[_mode].status = _status;\n        emit SetModeStatus(_mode, _status);\n    }\n```\n\nDisable all flashloan for all the pool that belongs to a mode and sync the lending pool balance even user overpays flashloan\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-01-init-capital-invitational",
  "Code": [
    {
      "filename": "contracts/core/InitCore.sol",
      "content": "// SPDX-License-Identifier: None\npragma solidity ^0.8.19;\n\nimport {Multicall} from '../common/Multicall.sol';\nimport '../common/library/InitErrors.sol';\nimport '../common/library/ArrayLib.sol';\nimport {UnderACM} from '../common/UnderACM.sol';\n\nimport {IInitCore} from '../interfaces/core/IInitCore.sol';\nimport {IPosManager} from '../interfaces/core/IPosManager.sol';\nimport {PoolConfig, TokenFactors, ModeStatus, IConfig} from '../interfaces/core/IConfig.sol';\nimport {ILendingPool} from '../interfaces/lending_pool/ILendingPool.sol';\nimport {IBaseWrapLp} from '../interfaces/wrapper/IBaseWrapLp.sol';\nimport {IInitOracle} from '../interfaces/oracle/IInitOracle.sol';\nimport {ILiqIncentiveCalculator} from '../interfaces/core/ILiqIncentiveCalculator.sol';\nimport {ICallbackReceiver} from '../interfaces/receiver/ICallbackReceiver.sol';\nimport {IFlashReceiver} from '../interfaces/receiver/IFlashReceiver.sol';\nimport {IRiskManager} from '../interfaces/risk_manager/IRiskManager.sol';\n\nimport {ReentrancyGuardUpgradeable} from '@openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol';\nimport {SafeCast} from '@openzeppelin-contracts/utils/math/SafeCast.sol';\nimport {SafeERC20} from '@openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol';\nimport {MathUpgradeable} from '@openzeppelin-contracts-upgradeable/utils/math/MathUpgradeable.sol';\nimport {IERC20} from '@openzeppelin-contracts/token/ERC20/IERC20.sol';\nimport {EnumerableSet} from '@openzeppelin-contracts/utils/structs/EnumerableSet.sol';\n\ncontract InitCore is IInitCore, Multicall, ReentrancyGuardUpgradeable, UnderACM {\n    using SafeCast for uint;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using MathUpgradeable for uint;\n    using UncheckedIncrement for uint;\n\n    // constants\n    uint private constant ONE_E18 = 1e18;\n    bytes32 private constant GUARDIAN = keccak256('guardian');\n    bytes32 private constant GOVERNOR = keccak256('governor');\n\n    // immutables\n    address public immutable POS_MANAGER;\n\n    // storages\n    address public config; // @inheritdoc IInitCore\n    address public oracle; // @inheritdoc IInitCore\n    address public liqIncentiveCalculator; // @inheritdoc IInitCore\n    address public riskManager; // @inheritdoc IInitCore\n    bool internal isMulticallTx;\n    EnumerableSet.UintSet internal uncheckedPosIds; // posIds that need to be checked after multicall\n\n    // modifiers\n    modifier onlyGuardian() {\n        ACM.checkRole(GUARDIAN, msg.sender);\n        _;\n    }\n\n    modifier onlyGovernor() {\n        ACM.checkRole(GOVERNOR, msg.sender);\n        _;\n    }\n\n    modifier onlyAuthorized(uint _posId) {\n        _require(IPosManager(POS_MANAGER).isAuthorized(msg.sender, _posId), Errors.NOT_AUTHORIZED);\n        _;\n    }\n\n    /// @dev keep track of the position and ensure that the position is healthy at the very end\n    /// @param _posId pos id to ensure health\n    modifier ensurePositionHealth(uint _posId) {\n        if (isMulticallTx) uncheckedPosIds.add(_posId);\n        _;\n        if (!isMulticallTx) _require(_isPosHealthy(_posId), Errors.POSITION_NOT_HEALTHY);\n    }\n\n    // constructor\n    constructor(address _posManager, address _acm) UnderACM(_acm) {\n        POS_MANAGER = _posManager;\n        _disableInitializers();\n    }\n\n    // initalize\n    /// @dev initialize contract and setup config, oracle, incentive calculator and risk manager addresses\n    /// @param _config config address\n    /// @param _oracle oracle address\n    /// @param _liqIncentiveCalculator liquidation incentive calculator address\n    /// @param _riskManager risk manager address\n    function initialize(address _config, address _oracle, address _liqIncentiveCalculator, address _riskManager)\n        external\n        initializer\n    {\n        __ReentrancyGuard_init();\n        _setConfig(_config);\n        _setOracle(_oracle);\n        _setLiqIncentiveCalculator(_liqIncentiveCalculator);\n        _setRiskManager(_riskManager);\n    }\n\n    // functions\n    /// @inheritdoc IInitCore\n    function mintTo(address _pool, address _to) public virtual nonReentrant returns (uint shares) {\n        // check pool status\n        PoolConfig memory poolConfig = IConfig(config).getPoolConfig(_pool);\n        _require(poolConfig.canMint, Errors.MINT_PAUSED);\n        // call mint at pool using _to\n        shares = ILendingPool(_pool).mint(_to);\n        // check supply cap after mint\n        _require(ILendingPool(_pool).totalAssets() <= poolConfig.supplyCap, Errors.SUPPLY_CAP_REACHED);\n    }\n\n    /// @inheritdoc IInitCore\n    function burnTo(address _pool, address _to) public virtual nonReentrant returns (uint amt) {\n        // check pool status\n        PoolConfig memory poolConfig = IConfig(config).getPoolConfig(_pool);\n        _require(poolConfig.canBurn, Errors.REDEEM_PAUSED);\n        // call burn at pool using _to\n        amt = ILendingPool(_pool).burn(_to);\n    }\n\n    /// @inheritdoc IInitCore\n    function borrow(address _pool, uint _amt, uint _posId, address _to)\n        public\n        virtual\n        onlyAuthorized(_posId)\n        ensurePositionHealth(_posId)\n        nonReentrant\n        returns (uint shares)\n    {\n        IConfig _config = IConfig(config);\n        // check pool and mode status\n        PoolConfig memory poolConfig = _config.getPoolConfig(_pool);\n        uint16 mode = _getPosMode(_posId);\n        // check if the mode is allow to borrow\n        _require(poolConfig.canBorrow && _config.getModeStatus(mode).canBorrow, Errors.BORROW_PAUSED);\n        // check if the position mode supports _pool\n        _require(_config.isAllowedForBorrow(mode, _pool), Errors.INVALID_MODE);\n        // get borrow shares (accrue interest)\n        shares = ILendingPool(_pool).debtAmtToShareCurrent(_amt);\n        // check shares != 0\n        _require(shares != 0, Errors.ZERO_VALUE);\n        // check borrow cap after borrow\n        _require(ILendingPool(_pool).totalDebt() + _amt <= poolConfig.borrowCap, Errors.BORROW_CAP_REACHED);\n        // update debt on the position\n        IPosManager(POS_MANAGER).updatePosDebtShares(_posId, _pool, shares.toInt256());\n        // call borrow from the pool with target _to\n        ILendingPool(_pool).borrow(_to, _amt);\n        // update debt on mode\n        IRiskManager(riskManager).updateModeDebtShares(mode, _pool, shares.toInt256());\n        emit Borrow(_pool, _posId, _to, _amt, shares);\n    }\n\n    /// @inheritdoc IInitCore\n    function repay(address _pool, uint _shares, uint _posId)\n        public\n        virtual\n        onlyAuthorized(_posId)\n        nonReentrant\n        returns (uint amt)\n    {\n        (, amt) = _repay(IConfig(config), _getPosMode(_posId), _posId, _pool, _shares);\n    }\n\n    /// @inheritdoc IInitCore\n    function createPos(uint16 _mode, address _viewer) public virtual nonReentrant returns (uint posId) {\n        _require(_mode != 0, Errors.INVALID_MODE);\n        posId = IPosManager(POS_MANAGER).createPos(msg.sender, _mode, _viewer);\n        emit CreatePosition(msg.sender, posId, _mode, _viewer);\n    }\n\n    /// @inheritdoc IInitCore\n    function setPosMode(uint _posId, uint16 _mode)\n        public\n        virtual\n        onlyAuthorized(_posId)\n        ensurePositionHealth(_posId)\n        nonReentrant\n    {\n        IConfig _config = IConfig(config);\n        // get current collaterals in the position\n        (address[] memory pools,, address[] memory wLps, uint[][] memory ids,) =\n            IPosManager(POS_MANAGER).getPosCollInfo(_posId);\n\n        uint16 currentMode = _getPosMode(_posId);\n        ModeStatus memory currentModeStatus = _config.getModeStatus(currentMode);\n        ModeStatus memory newModeStatus = _config.getModeStatus(_mode);\n        if (pools.length != 0 || wLps.length != 0) {\n            _require(newModeStatus.canCollateralize, Errors.COLLATERALIZE_PAUSED);\n            _require(currentModeStatus.canDecollateralize, Errors.DECOLLATERALIZE_PAUSED);\n        }\n        // check that each position collateral belongs to the _mode\n        for (uint i; i < pools.length; i = i.uinc()) {\n            _require(_config.isAllowedForCollateral(_mode, pools[i]), Errors.INVALID_MODE);\n        }\n        for (uint i; i < wLps.length; i = i.uinc()) {\n            // check if the wLp is whitelisted\n            _require(_config.whitelistedWLps(wLps[i]), Errors.TOKEN_NOT_WHITELISTED);\n            for (uint j; j < ids[i].length; j = j.uinc()) {\n                _require(_config.isAllowedForCollateral(_mode, IBaseWrapLp(wLps[i]).lp(ids[i][j])), Errors.INVALID_MODE);\n            }\n        }\n        // validate max wLp count\n        _validateModeMaxWLpCount(_config, _mode, _posId);\n        // get current debts in the position\n        uint[] memory shares;\n        (pools, shares) = IPosManager(POS_MANAGER).getPosBorrInfo(_posId);\n        IRiskManager _riskManager = IRiskManager(riskManager);\n        _require(newModeStatus.canBorrow, Errors.BORROW_PAUSED);\n        _require(currentModeStatus.canRepay && newModeStatus.canRepay, Errors.REPAY_PAUSED);\n        // check that each position debt belongs to the _mode\n        for (uint i; i < pools.length; i = i.uinc()) {\n            _require(_config.isAllowedForBorrow(_mode, pools[i]), Errors.INVALID_MODE);\n            // update debt on current mode\n            _riskManager.updateModeDebtShares(currentMode, pools[i], -shares[i].toInt256());\n            // update debt on new mode\n            _riskManager.updateModeDebtShares(_mode, pools[i], shares[i].toInt256());\n        }\n        // update position mode\n        IPosManager(POS_MANAGER).updatePosMode(_posId, _mode);\n        emit SetPositionMode(_posId, _mode);\n    }\n\n    /// @inheritdoc IInitCore\n    function collateralize(uint _posId, address _pool) public virtual onlyAuthorized(_posId) nonReentrant {\n        IConfig _config = IConfig(config);\n        // check mode status\n        uint16 mode = _getPosMode(_posId);\n        _require(_config.getModeStatus(mode).canCollateralize, Errors.COLLATERALIZE_PAUSED);\n        // check if the position mode supports _pool\n        _require(_config.isAllowedForCollateral(mode, _pool), Errors.INVALID_MODE);\n        // update collateral on the position\n        uint amtColl = IPosManager(POS_MANAGER).addCollateral(_posId, _pool);\n        emit Collateralize(_posId, _pool, amtColl);\n    }\n\n    /// @inheritdoc IInitCore\n    function decollateralize(uint _posId, address _pool, uint _shares, address _to)\n        public\n        virtual\n        onlyAuthorized(_posId)\n        ensurePositionHealth(_posId)\n        nonReentrant\n    {\n        // check mode status\n        _require(IConfig(config).getModeStatus(_getPosMode(_posId)).canDecollateralize, Errors.DECOLLATERALIZE_PAUSED);\n        // take _pool from position to _to\n        uint amtDecoll = IPosManager(POS_MANAGER).removeCollateralTo(_posId, _pool, _shares, _to);\n        emit Decollateralize(_posId, _pool, _to, amtDecoll);\n    }\n\n    /// @inheritdoc IInitCore\n    function collateralizeWLp(uint _posId, address _wLp, uint _tokenId)\n        public\n        virtual\n        onlyAuthorized(_posId)\n        nonReentrant\n    {\n        IConfig _config = IConfig(config);\n        uint16 mode = _getPosMode(_posId);\n        // check mode status\n        _require(_config.getModeStatus(mode).canCollateralize, Errors.COLLATERALIZE_PAUSED);\n        // check if the wLp is whitelisted\n        _require(_config.whitelistedWLps(_wLp), Errors.TOKEN_NOT_WHITELISTED);\n        // check if the position mode supports _wLp\n        _require(_config.isAllowedForCollateral(mode, IBaseWrapLp(_wLp).lp(_tokenId)), Errors.INVALID_MODE);\n        // update collateral on the position\n        uint amtColl = IPosManager(POS_MANAGER).addCollateralWLp(_posId, _wLp, _tokenId);\n        // validate max wLp count\n        _validateModeMaxWLpCount(_config, mode, _posId);\n        emit CollateralizeWLp(_posId, _wLp, _tokenId, amtColl);\n    }\n\n    /// @inheritdoc IInitCore\n    function decollateralizeWLp(uint _posId, address _wLp, uint _tokenId, uint _amt, address _to)\n        public\n        virtual\n        onlyAuthorized(_posId)\n        ensurePositionHealth(_posId)\n        nonReentrant\n    {\n        IConfig _config = IConfig(config);\n        // check mode status\n        _require(_config.getModeStatus(_getPosMode(_posId)).canDecollateralize, Errors.DECOLLATERALIZE_PAUSED);\n        // check wLp is whitelisted\n        _require(_config.whitelistedWLps(_wLp), Errors.TOKEN_NOT_WHITELISTED);\n        // update and take _wLp from position to _to\n        uint amtDecoll = IPosManager(POS_MANAGER).removeCollateralWLpTo(_posId, _wLp, _tokenId, _amt, _to);\n        emit DecollateralizeWLp(_posId, _wLp, _tokenId, _to, amtDecoll);\n    }\n\n    /// @inheritdoc IInitCore\n    function liquidate(uint _posId, address _poolToRepay, uint _repayShares, address _poolOut, uint _minShares)\n        public\n        virtual\n        nonReentrant\n        returns (uint shares)\n    {\n        LiquidateLocalVars memory vars = _liquidateInternal(_posId, _poolToRepay, _repayShares);\n\n        _require(vars.config.isAllowedForCollateral(vars.mode, _poolOut), Errors.TOKEN_NOT_WHITELISTED); // config and mode are already stored\n\n        vars.collToken = ILendingPool(_poolOut).underlyingToken();\n        vars.liqIncentive_e18 = ILiqIncentiveCalculator(liqIncentiveCalculator).getLiqIncentiveMultiplier_e18(\n            vars.mode, vars.health_e18, vars.repayToken, vars.collToken\n        );\n        vars.repayAmtWithLiqIncentive = (vars.repayAmt * vars.liqIncentive_e18) / ONE_E18;\n        {\n            uint[] memory prices_e36; // prices = [repayTokenPrice, collToken]\n            address[] memory tokens = new address[](2);\n            (tokens[0], tokens[1]) = (vars.repayToken, vars.collToken);\n            prices_e36 = IInitOracle(oracle).getPrices_e36(tokens);\n            // calculate _tokenOut amt to return to liquidator\n            shares = ILendingPool(_poolOut).toShares((vars.repayAmtWithLiqIncentive * prices_e36[0]) / prices_e36[1]);\n            // take min of what's available (for bad debt repayment)\n            shares = shares.min(IPosManager(POS_MANAGER).getCollAmt(_posId, _poolOut)); // take min of what's available\n            _require(shares >= _minShares, Errors.SLIPPAGE_CONTROL);\n        }\n        // take _tokenOut from position to msg.sender\n        if (shares > 0) IPosManager(POS_MANAGER).removeCollateralTo(_posId, _poolOut, shares, msg.sender);\n        // check that position's health <= maxHealth\n        // NOTE: bypass this for underwater position\n        if (vars.health_e18 != 0) _ensurePosHealthAfterLiq(vars.config, _posId, vars.mode);\n        emit Liquidate(_posId, msg.sender, _poolOut, shares);\n    }\n\n    /// @inheritdoc IInitCore\n    function liquidateWLp(\n        uint _posId,\n        address _poolToRepay,\n        uint _repayShares,\n        address _wLp,\n        uint _tokenId,\n        uint _minlpOut\n    ) external virtual nonReentrant returns (uint lpAmtOut) {\n        LiquidateLocalVars memory vars = _liquidateInternal(_posId, _poolToRepay, _repayShares);\n\n        _require(vars.config.whitelistedWLps(_wLp), Errors.TOKEN_NOT_WHITELISTED); // config is already stored\n\n        vars.collToken = IBaseWrapLp(_wLp).lp(_tokenId);\n\n        vars.liqIncentive_e18 = ILiqIncentiveCalculator(liqIncentiveCalculator).getLiqIncentiveMultiplier_e18(\n            vars.mode, vars.health_e18, vars.repayToken, vars.collToken\n        );\n        vars.repayAmtWithLiqIncentive = (vars.repayAmt * vars.liqIncentive_e18) / ONE_E18;\n\n        uint wLpAmtToBurn;\n        {\n            address _oracle = oracle;\n            uint wLpAmt = IPosManager(POS_MANAGER).getCollWLpAmt(_posId, _wLp, _tokenId);\n            wLpAmtToBurn = IInitOracle(_oracle).getPrice_e36(vars.repayToken).mulDiv(\n                vars.repayAmtWithLiqIncentive, IBaseWrapLp(_wLp).calculatePrice_e36(_tokenId, _oracle)\n            );\n            // take min of what's available (for bad debt repayment)\n            wLpAmtToBurn = wLpAmtToBurn.min(wLpAmt);\n        }\n        // reduce and burn wLp to underlying for liquidator\n        if (wLpAmtToBurn > 0) {\n            lpAmtOut = IPosManager(POS_MANAGER).removeCollateralWLpTo(_posId, _wLp, _tokenId, wLpAmtToBurn, msg.sender);\n        }\n        _require(lpAmtOut >= _minlpOut, Errors.SLIPPAGE_CONTROL);\n        // check that position's health <= maxHealth\n        // NOTE: bypass this for underwater position\n        if (vars.health_e18 != 0) _ensurePosHealthAfterLiq(vars.config, _posId, vars.mode);\n        emit LiquidateWLp(_posId, msg.sender, _wLp, _tokenId, wLpAmtToBurn);\n    }\n\n    /// @inheritdoc IInitCore\n    function flash(address[] calldata _pools, uint[] calldata _amts, bytes calldata _data)\n        public\n        virtual\n        nonReentrant\n    {\n        // validate _pools and _amts length & validate _pools contain distinct addresses to avoid paying less flash fees\n        _require(_validateFlash(_pools, _amts), Errors.INVALID_FLASHLOAN);\n        // check that is not multicall tx\n        _require(!isMulticallTx, Errors.LOCKED_MULTICALL);\n        uint[] memory balanceBefores = new uint[](_pools.length);\n        address[] memory tokens = new address[](_pools.length);\n        IConfig _config = IConfig(config);\n        for (uint i; i < _pools.length; i = i.uinc()) {\n            PoolConfig memory poolConfig = _config.getPoolConfig(_pools[i]);\n            // check that flash is enabled\n            _require(poolConfig.canFlash, Errors.FLASH_PAUSED);\n            address token = ILendingPool(_pools[i]).underlyingToken();\n            tokens[i] = token;\n            // calculate return amt\n            balanceBefores[i] = IERC20(token).balanceOf(_pools[i]);\n            // take _amts[i] of _pools[i] to msg.sender\n            IERC20(token).safeTransferFrom(_pools[i], msg.sender, _amts[i]);\n        }\n        // execute callback\n        IFlashReceiver(msg.sender).flashCallback(_pools, _amts, _data);\n        // check pool balance after callback\n        for (uint i; i < _pools.length; i = i.uinc()) {\n            _require(IERC20(tokens[i]).balanceOf(_pools[i]) >= balanceBefores[i], Errors.INVALID_AMOUNT_TO_REPAY);\n        }\n    }\n\n    /// @dev multicall function with health check after all call\n    function multicall(bytes[] calldata data) public payable virtual override returns (bytes[] memory results) {\n        _require(!isMulticallTx, Errors.LOCKED_MULTICALL);\n        isMulticallTx = true;\n        // multicall\n        results = super.multicall(data);\n        // === loop uncheckedPosIds ===\n        uint[] memory posIds = uncheckedPosIds.values();\n        for (uint i; i < posIds.length; i = i.uinc()) {\n            // check position health\n            _require(_isPosHealthy(posIds[i]), Errors.POSITION_NOT_HEALTHY);\n            uncheckedPosIds.remove(posIds[i]);\n        }\n        // clear uncheckedPosIds\n        isMulticallTx = false;\n    }\n\n    /// @inheritdoc IInitCore\n    function setConfig(address _config) external onlyGovernor {\n        _setConfig(_config);\n    }\n\n    /// @inheritdoc IInitCore\n    function setOracle(address _oracle) external onlyGovernor {\n        _setOracle(_oracle);\n    }\n\n    /// @inheritdoc IInitCore\n    function setLiqIncentiveCalculator(address _liqIncentiveCalculator) external onlyGuardian {\n        _setLiqIncentiveCalculator(_liqIncentiveCalculator);\n    }\n\n    /// @inheritdoc IInitCore\n    function setRiskManager(address _riskManager) external onlyGuardian {\n        _setRiskManager(_riskManager);\n    }\n\n    /// @dev set config\n    function _setConfig(address _config) internal {\n        config = _config;\n        emit SetConfig(_config);\n    }\n\n    /// @dev set oracle\n    function _setOracle(address _oracle) internal {\n        oracle = _oracle;\n        emit SetOracle(_oracle);\n    }\n\n    /// @dev set liquidation incentive calculator\n    function _setLiqIncentiveCalculator(address _liqIncentiveCalculator) internal {\n        liqIncentiveCalculator = _liqIncentiveCalculator;\n        emit SetIncentiveCalculator(_liqIncentiveCalculator);\n    }\n\n    /// @dev set risk manager\n    function _setRiskManager(address _riskManager) internal {\n        riskManager = _riskManager;\n        emit SetRiskManager(_riskManager);\n    }\n\n    /// @inheritdoc IInitCore\n    function getCollateralCreditCurrent_e36(uint _posId) public virtual returns (uint collCredit_e36) {\n        address _oracle = oracle;\n        IConfig _config = IConfig(config);\n        uint16 mode = _getPosMode(_posId);\n        // get position collateral\n        (address[] memory pools, uint[] memory shares, address[] memory wLps, uint[][] memory ids, uint[][] memory amts)\n        = IPosManager(POS_MANAGER).getPosCollInfo(_posId);\n        // calculate collateralCredit\n        uint collCredit_e54;\n        for (uint i; i < pools.length; i = i.uinc()) {\n            address token = ILendingPool(pools[i]).underlyingToken();\n            uint tokenPrice_e36 = IInitOracle(_oracle).getPrice_e36(token);\n            uint tokenValue_e36 = ILendingPool(pools[i]).toAmtCurrent(shares[i]) * tokenPrice_e36;\n            TokenFactors memory factors = _config.getTokenFactors(mode, pools[i]);\n            collCredit_e54 += tokenValue_e36 * factors.collFactor_e18;\n        }\n        for (uint i; i < wLps.length; i = i.uinc()) {\n            for (uint j; j < ids[i].length; j = j.uinc()) {\n                uint wLpPrice_e36 = IBaseWrapLp(wLps[i]).calculatePrice_e36(ids[i][j], _oracle);\n                uint wLpValue_e36 = amts[i][j] * wLpPrice_e36;\n                TokenFactors memory factors = _config.getTokenFactors(mode, IBaseWrapLp(wLps[i]).lp(ids[i][j]));\n                collCredit_e54 += wLpValue_e36 * factors.collFactor_e18;\n            }\n        }\n        collCredit_e36 = collCredit_e54 / ONE_E18;\n    }\n\n    /// @inheritdoc IInitCore\n    function getBorrowCreditCurrent_e36(uint _posId) public virtual returns (uint borrowCredit_e36) {\n        IConfig _config = IConfig(config);\n        uint16 mode = _getPosMode(_posId);\n        // get position debtShares\n        (address[] memory pools, uint[] memory debtShares) = IPosManager(POS_MANAGER).getPosBorrInfo(_posId);\n        uint borrowCredit_e54;\n        address _oracle = oracle;\n        for (uint i; i < pools.length; i = i.uinc()) {\n            address token = ILendingPool(pools[i]).underlyingToken();\n            uint tokenPrice_e36 = IInitOracle(_oracle).getPrice_e36(token);\n            // calculate position debt\n            uint tokenValue_e36 = tokenPrice_e36 * ILendingPool(pools[i]).debtShareToAmtCurrent(debtShares[i]);\n            TokenFactors memory factors = _config.getTokenFactors(mode, pools[i]);\n            borrowCredit_e54 += (tokenValue_e36 * factors.borrFactor_e18);\n        }\n        borrowCredit_e36 = borrowCredit_e54.ceilDiv(ONE_E18);\n    }\n\n    /// @inheritdoc IInitCore\n    function getPosHealthCurrent_e18(uint _posId) public virtual returns (uint health_e18) {\n        uint borrowCredit_e36 = getBorrowCreditCurrent_e36(_posId);\n        health_e18 = borrowCredit_e36 > 0\n            ? (getCollateralCreditCurrent_e36(_posId) * ONE_E18) / borrowCredit_e36\n            : type(uint).max;\n    }\n\n    /// @inheritdoc IInitCore\n    function callback(address _to, uint _value, bytes memory _data)\n        public\n        payable\n        virtual\n        returns (bytes memory result)\n    {\n        _require(_to != address(this), Errors.INVALID_CALLBACK_ADDRESS);\n        // call _to with _data\n        return ICallbackReceiver(_to).coreCallback{value: _value}(msg.sender, _data);\n    }\n\n    /// @inheritdoc IInitCore\n    function transferToken(address _token, address _to, uint _amt) public virtual nonReentrant {\n        // transfer _amt of token to _to from msg.sender\n        IERC20(_token).safeTransferFrom(msg.sender, _to, _amt);\n    }\n\n    /// @dev repay borrowed tokens\n    /// @param _config config\n    /// @param _mode position mode\n    /// @param _posId position id\n    /// @param _pool pool address to repay\n    /// @param _shares amount of shares to repay\n    /// @return tokenToRepay token address to repay\n    ///         amt          amt of token to repay\n    function _repay(IConfig _config, uint16 _mode, uint _posId, address _pool, uint _shares)\n        internal\n        returns (address tokenToRepay, uint amt)\n    {\n        // check status\n        _require(_config.getPoolConfig(_pool).canRepay && _config.getModeStatus(_mode).canRepay, Errors.REPAY_PAUSED);\n        // get position debt share\n        uint positionDebtShares = IPosManager(POS_MANAGER).getPosDebtShares(_posId, _pool);\n        uint sharesToRepay = _shares < positionDebtShares ? _shares : positionDebtShares;\n        // get amtToRepay (accrue interest)\n        uint amtToRepay = ILendingPool(_pool).debtShareToAmtCurrent(sharesToRepay);\n        // take token from msg.sender to pool\n        tokenToRepay = ILendingPool(_pool).underlyingToken();\n        IERC20(tokenToRepay).safeTransferFrom(msg.sender, _pool, amtToRepay);\n        // update debt on the position\n        IPosManager(POS_MANAGER).updatePosDebtShares(_posId, _pool, -sharesToRepay.toInt256());\n        // call repay on the pool\n        amt = ILendingPool(_pool).repay(sharesToRepay);\n        // update debt on mode\n        IRiskManager(riskManager).updateModeDebtShares(_mode, _pool, -sharesToRepay.toInt256());\n        emit Repay(_pool, _posId, msg.sender, sharesToRepay, amt);\n    }\n\n    /// @dev get position mode\n    function _getPosMode(uint _posId) internal view returns (uint16 mode) {\n        mode = IPosManager(POS_MANAGER).getPosMode(_posId);\n    }\n\n    /// @dev get whether the position is healthy\n    function _isPosHealthy(uint _posId) internal returns (bool isHealthy) {\n        isHealthy = getPosHealthCurrent_e18(_posId) >= ONE_E18;\n    }\n\n    /// @dev validate flash data\n    function _validateFlash(address[] calldata _pools, uint[] calldata _amts) internal pure returns (bool) {\n        if (_pools.length != _amts.length) return false;\n        return AddressArrayLib.isSortedAndNotDuplicate(_pools);\n    }\n\n    /// @dev check that the position health after liquidation does not exceed the threshold\n    function _ensurePosHealthAfterLiq(IConfig _config, uint _posId, uint16 _mode) internal {\n        uint healthAfterLiquidation_e18 = _config.getMaxHealthAfterLiq_e18(_mode);\n        // if healthAfterLiquidation_e18 == uint64.max, then no need to check\n        if (healthAfterLiquidation_e18 != type(uint64).max) {\n            _require(\n                getPosHealthCurrent_e18(_posId) <= healthAfterLiquidation_e18, Errors.INVALID_HEALTH_AFTER_LIQUIDATION\n            );\n        }\n    }\n\n    /// @dev liquidation internal logic\n    function _liquidateInternal(uint _posId, address _poolToRepay, uint _repayShares)\n        internal\n        returns (LiquidateLocalVars memory vars)\n    {\n        vars.config = IConfig(config);\n        vars.mode = _getPosMode(_posId);\n\n        // check position must be unhealthy\n        vars.health_e18 = getPosHealthCurrent_e18(_posId);\n        _require(vars.health_e18 < ONE_E18, Errors.POSITION_HEALTHY);\n\n        (vars.repayToken, vars.repayAmt) = _repay(vars.config, vars.mode, _posId, _poolToRepay, _repayShares);\n    }\n\n    /// @dev validate mode max wlp count internal logic\n    function _validateModeMaxWLpCount(IConfig _config, uint16 _mode, uint _posId) internal view {\n        _require(\n            IPosManager(POS_MANAGER).getPosCollWLpCount(_posId) <= _config.getModeMaxCollWLpCount(_mode),\n            Errors.MAX_COLLATERAL_COUNT_REACHED\n        );\n    }\n}"
    },
    {
      "filename": "contracts/core/InitCore.sol",
      "content": "// SPDX-License-Identifier: None\npragma solidity ^0.8.19;\n\nimport {Multicall} from '../common/Multicall.sol';\nimport '../common/library/InitErrors.sol';\nimport '../common/library/ArrayLib.sol';\nimport {UnderACM} from '../common/UnderACM.sol';\n\nimport {IInitCore} from '../interfaces/core/IInitCore.sol';\nimport {IPosManager} from '../interfaces/core/IPosManager.sol';\nimport {PoolConfig, TokenFactors, ModeStatus, IConfig} from '../interfaces/core/IConfig.sol';\nimport {ILendingPool} from '../interfaces/lending_pool/ILendingPool.sol';\nimport {IBaseWrapLp} from '../interfaces/wrapper/IBaseWrapLp.sol';\nimport {IInitOracle} from '../interfaces/oracle/IInitOracle.sol';\nimport {ILiqIncentiveCalculator} from '../interfaces/core/ILiqIncentiveCalculator.sol';\nimport {ICallbackReceiver} from '../interfaces/receiver/ICallbackReceiver.sol';\nimport {IFlashReceiver} from '../interfaces/receiver/IFlashReceiver.sol';\nimport {IRiskManager} from '../interfaces/risk_manager/IRiskManager.sol';\n\nimport {ReentrancyGuardUpgradeable} from '@openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol';\nimport {SafeCast} from '@openzeppelin-contracts/utils/math/SafeCast.sol';\nimport {SafeERC20} from '@openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol';\nimport {MathUpgradeable} from '@openzeppelin-contracts-upgradeable/utils/math/MathUpgradeable.sol';\nimport {IERC20} from '@openzeppelin-contracts/token/ERC20/IERC20.sol';\nimport {EnumerableSet} from '@openzeppelin-contracts/utils/structs/EnumerableSet.sol';\n\ncontract InitCore is IInitCore, Multicall, ReentrancyGuardUpgradeable, UnderACM {\n    using SafeCast for uint;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using MathUpgradeable for uint;\n    using UncheckedIncrement for uint;\n\n    // constants\n    uint private constant ONE_E18 = 1e18;\n    bytes32 private constant GUARDIAN = keccak256('guardian');\n    bytes32 private constant GOVERNOR = keccak256('governor');\n\n    // immutables\n    address public immutable POS_MANAGER;\n\n    // storages\n    address public config; // @inheritdoc IInitCore\n    address public oracle; // @inheritdoc IInitCore\n    address public liqIncentiveCalculator; // @inheritdoc IInitCore\n    address public riskManager; // @inheritdoc IInitCore\n    bool internal isMulticallTx;\n    EnumerableSet.UintSet internal uncheckedPosIds; // posIds that need to be checked after multicall\n\n    // modifiers\n    modifier onlyGuardian() {\n        ACM.checkRole(GUARDIAN, msg.sender);\n        _;\n    }\n\n    modifier onlyGovernor() {\n        ACM.checkRole(GOVERNOR, msg.sender);\n        _;\n    }\n\n    modifier onlyAuthorized(uint _posId) {\n        _require(IPosManager(POS_MANAGER).isAuthorized(msg.sender, _posId), Errors.NOT_AUTHORIZED);\n        _;\n    }\n\n    /// @dev keep track of the position and ensure that the position is healthy at the very end\n    /// @param _posId pos id to ensure health\n    modifier ensurePositionHealth(uint _posId) {\n        if (isMulticallTx) uncheckedPosIds.add(_posId);\n        _;\n        if (!isMulticallTx) _require(_isPosHealthy(_posId), Errors.POSITION_NOT_HEALTHY);\n    }\n\n    // constructor\n    constructor(address _posManager, address _acm) UnderACM(_acm) {\n        POS_MANAGER = _posManager;\n        _disableInitializers();\n    }\n\n    // initalize\n    /// @dev initialize contract and setup config, oracle, incentive calculator and risk manager addresses\n    /// @param _config config address\n    /// @param _oracle oracle address\n    /// @param _liqIncentiveCalculator liquidation incentive calculator address\n    /// @param _riskManager risk manager address\n    function initialize(address _config, address _oracle, address _liqIncentiveCalculator, address _riskManager)\n        external\n        initializer\n    {\n        __ReentrancyGuard_init();\n        _setConfig(_config);\n        _setOracle(_oracle);\n        _setLiqIncentiveCalculator(_liqIncentiveCalculator);\n        _setRiskManager(_riskManager);\n    }\n\n    // functions\n    /// @inheritdoc IInitCore\n    function mintTo(address _pool, address _to) public virtual nonReentrant returns (uint shares) {\n        // check pool status\n        PoolConfig memory poolConfig = IConfig(config).getPoolConfig(_pool);\n        _require(poolConfig.canMint, Errors.MINT_PAUSED);\n        // call mint at pool using _to\n        shares = ILendingPool(_pool).mint(_to);\n        // check supply cap after mint\n        _require(ILendingPool(_pool).totalAssets() <= poolConfig.supplyCap, Errors.SUPPLY_CAP_REACHED);\n    }\n\n    /// @inheritdoc IInitCore\n    function burnTo(address _pool, address _to) public virtual nonReentrant returns (uint amt) {\n        // check pool status\n        PoolConfig memory poolConfig = IConfig(config).getPoolConfig(_pool);\n        _require(poolConfig.canBurn, Errors.REDEEM_PAUSED);\n        // call burn at pool using _to\n        amt = ILendingPool(_pool).burn(_to);\n    }\n\n    /// @inheritdoc IInitCore\n    function borrow(address _pool, uint _amt, uint _posId, address _to)\n        public\n        virtual\n        onlyAuthorized(_posId)\n        ensurePositionHealth(_posId)\n        nonReentrant\n        returns (uint shares)\n    {\n        IConfig _config = IConfig(config);\n        // check pool and"
    }
  ]
}