{
  "Title": "M-10: Virtual swap impacts can be bypassed by swapping through markets where only one of the collateral tokens has virtual inventory",
  "Content": "# Issue M-10: Virtual swap impacts can be bypassed by swapping through markets where only one of the collateral tokens has virtual inventory \n\nSource: https://github.com/sherlock-audit/2023-04-gmx-judging/issues/257 \n\n## Found by \nIllIllI\n## Summary\n\nVirtual swap impacts can be bypassed by swapping through markets where only one of the collateral tokens has virtual inventory\n\n\n## Vulnerability Detail\n\nThe code that calculates price impacts related to swapping, skips the application of virtual impacts if one of the tokens doesn't have a virtual token set\n\n\n## Impact\n\nIf the virtual swap amount for a particular token is very large, and a large swap through that market would cause the balance to drop a lot, causing the trade to have a large negative impact, a user can split their large order into multiple smaller orders, and route them through other markets where there is no virtual token for one of the pools, and avoid the fees (assuming those pools have non-virtual imbalances that favor such a trade).\n\n\n## Code Snippet\n\nVirtual impacts are completely skipped if one of the tokens doesn't have a virtual version:\n```solidity\n// File: gmx-synthetics/contracts/pricing/SwapPricingUtils.sol : SwapPricingUtils.getPriceImpactUsd()   #1\n\n113            (bool hasVirtualInventoryTokenB, uint256 virtualPoolAmountForTokenB) = MarketUtils.getVirtualInventoryForSwaps(\n114                params.dataStore,\n115                params.market.marketToken,\n116                params.tokenB\n117            );\n118    \n119            if (!hasVirtualInventoryTokenA || !hasVirtualInventoryTokenB) {\n120 @>             return priceImpactUsd;\n121:           }\n```\nhttps://github.com/sherlock-audit/2023-04-gmx/blob/main/gmx-synthetics/contracts/pricing/SwapPricingUtils.sol#L113-L121\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nUse the non-virtual token's inventory as the standin for the missing virtual inventory token\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/74",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/pricing/SwapPricingUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\n\nimport \"../market/MarketUtils.sol\";\n\nimport \"../utils/Precision.sol\";\nimport \"../utils/Calc.sol\";\n\nimport \"./PricingUtils.sol\";\n\n// @title SwapPricingUtils\n// @dev Library for pricing functions\nlibrary SwapPricingUtils {\n    using SignedMath for int256;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    using EventUtils for EventUtils.AddressItems;\n    using EventUtils for EventUtils.UintItems;\n    using EventUtils for EventUtils.IntItems;\n    using EventUtils for EventUtils.BoolItems;\n    using EventUtils for EventUtils.Bytes32Items;\n    using EventUtils for EventUtils.BytesItems;\n    using EventUtils for EventUtils.StringItems;\n\n    // @dev GetPriceImpactUsdParams struct used in getPriceImpactUsd to\n    // avoid stack too deep errors\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param tokenA the token to check balance for\n    // @param tokenB the token to check balance for\n    // @param priceForTokenA the price for tokenA\n    // @param priceForTokenB the price for tokenB\n    // @param usdDeltaForTokenA the USD change in amount of tokenA\n    // @param usdDeltaForTokenB the USD change in amount of tokenB\n    struct GetPriceImpactUsdParams {\n        DataStore dataStore;\n        Market.Props market;\n        address tokenA;\n        address tokenB;\n        uint256 priceForTokenA;\n        uint256 priceForTokenB;\n        int256 usdDeltaForTokenA;\n        int256 usdDeltaForTokenB;\n    }\n\n    // @dev PoolParams struct to contain pool values\n    // @param poolUsdForTokenA the USD value of tokenA in the pool\n    // @param poolUsdForTokenB the USD value of tokenB in the pool\n    // @param nextPoolUsdForTokenA the next USD value of tokenA in the pool\n    // @param nextPoolUsdForTokenB the next USD value of tokenB in the pool\n    struct PoolParams {\n        uint256 poolUsdForTokenA;\n        uint256 poolUsdForTokenB;\n        uint256 nextPoolUsdForTokenA;\n        uint256 nextPoolUsdForTokenB;\n    }\n\n    // @dev SwapFees struct to contain swap fee values\n    // @param feeReceiverAmount the fee amount for the fee receiver\n    // @param feeAmountForPool the fee amount for the pool\n    // @param amountAfterFees the output amount after fees\n    struct SwapFees {\n        uint256 feeReceiverAmount;\n        uint256 feeAmountForPool;\n        uint256 amountAfterFees;\n\n        address uiFeeReceiver;\n        uint256 uiFeeReceiverFactor;\n        uint256 uiFeeAmount;\n    }\n\n    // @dev get the price impact in USD\n    //\n    // note that there will be some difference between the pool amounts used for\n    // calculating the price impact and fees vs the actual pool amounts after the\n    // swap is done, since the pool amounts will be increased / decreased by an amount\n    // after factoring in the calculated price impact and fees\n    //\n    // since the calculations are based on the real-time prices values of the tokens\n    // if a token price increases, the pool will incentivise swapping out more of that token\n    // this is useful if prices are ranging, if prices are strongly directional, the pool may\n    // be selling tokens as the token price increases\n    //\n    // @param params GetPriceImpactUsdParams\n    //\n    // @return the price impact in USD\n    function getPriceImpactUsd(GetPriceImpactUsdParams memory params) internal view returns (int256) {\n        PoolParams memory poolParams = getNextPoolAmountsUsd(params);\n\n        int256 priceImpactUsd = _getPriceImpactUsd(params.dataStore, params.market, poolParams);\n\n        // the virtual price impact calculation is skipped if the price impact\n        // is positive since the action is helping to balance the pool\n        //\n        // in case two virtual pools are unbalanced in a different direction\n        // e.g. pool0 has more WNT than USDC while pool1 has less WNT\n        // than USDT\n        // not skipping the virtual price impact calculation would lead to\n        // a negative price impact for any trade on either pools and would\n        // disincentivise the balancing of pools\n        if (priceImpactUsd >= 0) { return priceImpactUsd; }\n\n        (bool hasVirtualInventoryTokenA, uint256 virtualPoolAmountForTokenA) = MarketUtils.getVirtualInventoryForSwaps(\n            params.dataStore,\n            params.market.marketToken,\n            params.tokenA\n        );\n\n        (bool hasVirtualInventoryTokenB, uint256 virtualPoolAmountForTokenB) = MarketUtils.getVirtualInventoryForSwaps(\n            params.dataStore,\n            params.market.marketToken,\n            params.tokenB\n        );\n\n        if (!hasVirtualInventoryTokenA || !hasVirtualInventoryTokenB) {\n            return priceImpactUsd;\n        }\n\n        PoolParams memory poolParamsForVirtualInventory = getNextPoolAmountsParams(\n            params,\n            virtualPoolAmountForTokenA,\n            virtualPoolAmountForTokenB\n        );\n\n        int256 priceImpactUsdForVirtualInventory = _getPriceImpactUsd(params.dataStore, params.market, poolParamsForVirtualInventory);\n\n        return priceImpactUsdForVirtualInventory < priceImpactUsd ? priceImpactUsdForVirtualInventory : priceImpactUsd;\n    }\n\n    // @dev get the price impact in USD\n    // @param dataStore DataStore\n    // @param market the trading market\n    // @param poolParams PoolParams\n    // @return the price impact in USD\n    function _getPriceImpactUsd(DataStore dataStore, Market.Props memory market, PoolParams memory poolParams) internal view returns (int256) {\n        uint256 initialDiffUsd = Calc.diff(poolParams.poolUsdForTokenA, poolParams.poolUsdForTokenB);\n        uint256 nextDiffUsd = Calc.diff(poolParams.nextPoolUsdForTokenA, poolParams.nextPoolUsdForTokenB);\n\n        // check whether an improvement in balance comes from causing the balance to switch sides\n        // for example, if there is $2000 of ETH and $1000 of USDC in the pool\n        // adding $1999 USDC into the pool will reduce absolute balance from $1000 to $999 but it does not\n        // help rebalance the pool much, the isSameSideRebalance value helps avoid gaming using this case\n        bool isSameSideRebalance = (poolParams.poolUsdForTokenA <= poolParams.poolUsdForTokenB) == (poolParams.nextPoolUsdForTokenA <= poolParams.nextPoolUsdForTokenB);\n        uint256 impactExponentFactor = dataStore.getUint(Keys.swapImpactExponentFactorKey(market.marketToken));\n\n        if (isSameSideRebalance) {\n            bool hasPositiveImpact = nextDiffUsd < initialDiffUsd;\n            uint256 impactFactor = MarketUtils.getAdjustedSwapImpactFactor(dataStore, market.marketToken, hasPositiveImpact);\n\n            return PricingUtils.getPriceImpactUsdForSameSideRebalance(\n                initialDiffUsd,\n                nextDiffUsd,\n                impactFactor,\n                impactExponentFactor\n            );\n        } else {\n            (uint256 positiveImpactFactor, uint256 negativeImpactFactor) = MarketUtils.getAdjustedSwapImpactFactors(dataStore, market.marketToken);\n\n            return PricingUtils.getPriceImpactUsdForCrossoverRebalance(\n                initialDiffUsd,\n                nextDiffUsd,\n                positiveImpactFactor,\n                negativeImpactFactor,\n                impactExponentFactor\n            );\n        }\n    }\n\n    // @dev get the next pool amounts in USD\n    // @param params GetPriceImpactUsdParams\n    // @return PoolParams\n    function getNextPoolAmountsUsd(\n        GetPriceImpactUsdParams memory params\n    ) internal view returns (PoolParams memory) {\n        uint256 poolAmountForTokenA = MarketUtils.getPoolAmount(params.dataStore, params.market, params.tokenA);\n        uint256 poolAmountForTokenB = MarketUtils.getPoolAmount(params.dataStore, params.market, params.tokenB);\n\n        return getNextPoolAmountsParams(\n            params,\n            poolAmountForTokenA,\n            poolAmountForTokenB\n        );\n    }\n\n    function getNextPoolAmountsParams(\n        GetPriceImpactUsdParams memory params,\n        uint256 poolAmountForTokenA,\n        uint256 poolAmountForTokenB\n    ) internal view returns (PoolParams memory) {\n        uint256 poolUsdForTokenA = poolAmountForTokenA * params.priceForTokenA;\n        uint256 poolUsdForTokenB = poolAmountForTokenB * params.priceForTokenB;\n\n        if (params.usdDeltaForTokenA < 0 && (-params.usdDeltaForTokenA).toUint256() > poolUsdForTokenA) {\n            revert Errors.UsdDeltaExceedsPoolValue(params.usdDeltaForTokenA, poolUsdForTokenA);\n        }\n\n        if (params.usdDeltaForTokenB < 0 && (-params.usdDeltaForTokenB).toUint256() > poolUsdForTokenB) {\n            revert Errors.UsdDeltaExceedsPoolValue(params.usdDeltaForTokenB, poolUsdForTokenB);\n        }\n\n        uint256 nextPoolUsdForTokenA = Calc.sumReturnUint256(poolUsdForTokenA, params.usdDeltaForTokenA);\n        uint256 nextPoolUsdForTokenB = Calc.sumReturnUint256(poolUsdForTokenB, params.usdDeltaForTokenB);\n\n        int256 poolUsdAdjustmentForTokenA = params.dataStore.getInt(Keys.poolAmountAdjustmentKey(params.market.marketToken, params.tokenA)) * params.priceForTokenA.toInt256();\n        int256 poolUsdAdjustmentForTokenB = params.dataStore.getInt(Keys.poolAmountAdjustmentKey(params.market.marketToken, params.tokenB)) * params.priceForTokenB.toInt256();\n\n        if (poolUsdAdjustmentForTokenA < 0 && poolUsdAdjustmentForTokenA.abs() > nextPoolUsdForTokenA) {\n            revert Errors.InvalidPoolAdjustment(params.tokenA, nextPoolUsdForTokenA, poolUsdAdjustmentForTokenA);\n        }\n\n        if (poolUsdAdjustmentForTokenB < 0 && poolUsdAdjustmentForTokenB.abs() > nextPoolUsdForTokenB) {\n            revert Errors.InvalidPoolAdjustment(params.tokenB, nextPoolUsdForTokenB, poolUsdAdjustmentForTokenB);\n        }\n\n        nextPoolUsdForTokenA = Calc.sumReturnUint256(nextPoolUsdForTokenA, poolUsdAdjustmentForTokenA);\n        nextPoolUsdForTokenB = Calc.sumReturnUint256(nextPoolUsdForTokenB, poolUsdAdjustmentForTokenB);\n\n        PoolParams memory poolParams = PoolParams(\n            poolUsdForTokenA,\n            poolUsdForTokenB,\n            nextPoolUsdForTokenA,\n            nextPoolUsdForTokenB\n        );\n\n        return poolParams;\n    }\n\n    // @dev get the swap fees\n    // @param dataStore DataStore\n    // @param marketToken the address of the market token\n    // @param amount the total swap fee amount\n    function getSwapFees(\n        DataStore dataStore,\n        address marketToken,\n        uint256 amount,\n        address uiFeeReceiver\n    ) internal view returns (SwapFees memory) {\n        SwapFees memory fees;\n\n        uint256 feeFactor = dataStore.getUint(Keys.swapFeeFactorKey(marketToken));\n        uint256 swapFeeReceiverFactor = dataStore.getUint(Keys.SWAP_FEE_RECEIVER_FACTOR);\n\n        uint256 feeAmount = Precision.applyFactor(amount, feeFactor);\n\n        fees.feeReceiverAmount = Precision.applyFactor(feeAmount, swapFeeReceiverFactor);\n        fees.feeAmountForPool = feeAmount - fees.feeReceiverAmount;\n\n        fees.uiFeeReceiver = uiFeeReceiver;\n        fees.uiFeeReceiverFactor = MarketUtils.getUiFeeFactor(dataStore, uiFeeReceiver);\n        fees.uiFeeAmount = Precision.applyFactor(amount, fees.uiFeeReceiverFactor);\n\n        fees.amountAfterFees = amount - feeAmount - fees.uiFeeAmount;\n\n        return fees;\n    }\n\n    function emitSwapInfo(\n        EventEmitter eventEmitter,\n        bytes32 orderKey,\n        address market,\n        address receiver,\n        address tokenIn,\n        address tokenOut,\n        uint256 tokenInPrice,\n        uint256 tokenOutPrice,\n        uint256 amountIn,\n        uint256 amountInAfterFees,\n        uint256 amountOut,\n        int256 priceImpactUsd\n    ) internal {\n        EventUtils.EventLogData memory eventData;\n\n        eventData.bytes32Items.initItems(1);\n        eventData.bytes32Items.setItem(0, \"orderKey\", orderKey);\n\n        eventData.addressItems.initItems(4);\n        eventData.addressItems.setItem(0, \"market\", market);\n        eventData.addressItems.setItem(1, \"receiver\", receiver);\n        eventData.addressItems.setItem(2, \"tokenIn\", tokenIn);\n        eventData.addressItems.setItem(3, \"tokenOut\", tokenOut);\n\n        eventData.uintItems.initItems(5);\n        eventData.uintItems.setItem(0, \"tokenInPrice\", tokenInPrice);\n        eventData.uintItems.setItem(1, \"tokenOutPrice\", tokenOutPrice);\n        eventData.uintItems.setItem(2, \"amountIn\", amountIn);\n        // note that amountInAfterFees includes negative price impact\n        eventData.uintItems.setItem(3, \"amountInAfterFees\", amountInAfterFees);\n        eventData.uintItems.setItem(4, \"amountOut\", amountOut);\n\n        eventData.intItems.initItems(1);\n        eventData.intItems.setItem(0, \"priceImpactUsd\", priceImpactUsd);\n\n        eventEmitter.emitEventLog1(\n            \"SwapInfo\",\n            Cast.toBytes32(market),\n            eventData\n        );\n    }\n\n    function emitSwapFeesCollected(\n        EventEmitter eventEmitter,\n        address market,\n        address token,\n        uint256 tokenPrice,\n        string memory action,\n        SwapFees memory fees\n    ) internal {\n        EventUtils.EventLogData memory eventData;\n\n        eventData.addressItems.initItems(3);\n        eventData.addressItems.setItem(0, \"uiFeeReceiver\", fees.uiFeeReceiver);\n        eventData.addressItems.setItem(1, \"market\", market);\n        eventData.addressItems.setItem(2, \"token\", token);\n\n        eventData.stringItems.initItems(1);\n        eventData.stringItems.setItem(0, \"action\", action);\n\n        eventData.uintItems.initItems(6);\n        eventData.uintItems.setItem(0, \"tokenPrice\", tokenPrice);\n        eventData.uintItems.setItem(1, \"feeReceiverAmount\", fees.feeReceiverAmount);\n        eventData.uintItems.setItem(2, \"feeAmountForPool\", fees.feeAmountForPool);\n        eventData.uintItems.setItem(3, \"amountAfterFees\", fees.amountAfterFees);\n        eventData.uintItems.setItem(4, \"uiFeeReceiverFactor\", fees.uiFeeReceiverFactor);\n        eventData.uintItems.setItem(5, \"uiFeeAmount\", fees.uiFeeAmount);\n\n        eventEmitter.emitEventLog1(\n            \"SwapFeesCollected\",\n            Cast.toBytes32(market),\n            eventData\n        );\n    }\n}"
    }
  ]
}