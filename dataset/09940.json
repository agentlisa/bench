{
  "Title": "[M-02] Inappropriate handling of referralFee makes collecting Mirror fails without error when referrerProfileId is burned",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-02-aave-lens/blob/c1d2de2b0609b7d2734ada2ce45c91a73cc54dd9/contracts/core/modules/collect/FeeCollectModule.sol#L163-L172\n\n\n# Vulnerability details\n\nIn the current implementation, even when the profile's owner burnt the `ProfileNFT`, as the profile's legacy, the publications can still be collected.\n\nHowever, if the publication is a `Mirror` and there is a `referralFee` set by the original publication, the user won't be able to collect from a `Mirror` that was published by a burned profile.\n\nhttps://github.com/code-423n4/2022-02-aave-lens/blob/c1d2de2b0609b7d2734ada2ce45c91a73cc54dd9/contracts/core/modules/collect/FeeCollectModule.sol#L163-L172\n\n```solidity\nif (referralFee != 0) {\n    // The reason we levy the referral fee on the adjusted amount is so that referral fees\n    // don't bypass the treasury fee, in essence referrals pay their fair share to the treasury.\n    uint256 referralAmount = (adjustedAmount * referralFee) / BPS_MAX;\n    adjustedAmount = adjustedAmount - referralAmount;\n\n    address referralRecipient = IERC721(HUB).ownerOf(referrerProfileId);\n\n    IERC20(currency).safeTransferFrom(collector, referralRecipient, referralAmount);\n}\n```\n\n> When a mirror is collected, what happens behind the scenes is the original, mirrored publication is collected, and the mirror publisher's profile ID is passed as a \"referrer.\"\n\nIn `_processCollectWithReferral()`, if there is a `referralFee`, contract will read `referralRecipient` from `IERC721(HUB).ownerOf(referrerProfileId)`, if `referrerProfileId` is burned, the `IERC721(HUB).ownerOf(referrerProfileId)` will revert with `ERC721: owner query for nonexistent token`.\n\nHowever, since we wish to allow the content to be collected, we should just treat referrals as non-existent in this situation.\n\n### Recommendation\n\nChange to:\n\n```solidity\ntry IERC721(HUB).ownerOf(referrerProfileId) returns (address referralRecipient) {\n    uint256 referralAmount = (adjustedAmount * referralFee) / BPS_MAX;\n    adjustedAmount = adjustedAmount - referralAmount;\n\n    address referralRecipient = IERC721(HUB).ownerOf(referrerProfileId);\n\n    IERC20(currency).safeTransferFrom(collector, referralRecipient, referralAmount);\n} catch {\n    emit LogNonExistingReferrer(referrerProfileId);\n}\n```\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-aave-lens-contest",
  "Code": [
    {
      "filename": "contracts/core/modules/collect/FeeCollectModule.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {ICollectModule} from '../../../interfaces/ICollectModule.sol';\nimport {Errors} from '../../../libraries/Errors.sol';\nimport {FeeModuleBase} from '../FeeModuleBase.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {FollowValidationModuleBase} from '../FollowValidationModuleBase.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @notice A struct containing the necessary data to execute collect actions on a publication.\n *\n * @param amount The collecting cost associated with this publication.\n * @param recipient The recipient address associated with this publication.\n * @param currency The currency associated with this publication.\n * @param referralFee The referral fee associated with this publication.\n */\nstruct ProfilePublicationData {\n    uint256 amount;\n    address recipient;\n    address currency;\n    uint16 referralFee;\n}\n\n/**\n * @title FeeCollectModule\n * @author Lens Protocol\n *\n * @notice This is a simple Lens CollectModule implementation, inheriting from the ICollectModule interface and\n * the FeeCollectModuleBase abstract contract.\n *\n * This module works by allowing unlimited collects for a publication at a given price.\n */\ncontract FeeCollectModule is ICollectModule, FeeModuleBase, FollowValidationModuleBase {\n    using SafeERC20 for IERC20;\n\n    mapping(uint256 => mapping(uint256 => ProfilePublicationData))\n        internal _dataByPublicationByProfile;\n\n    constructor(address hub, address moduleGlobals) FeeModuleBase(moduleGlobals) ModuleBase(hub) {}\n\n    /**\n     * @notice This collect module levies a fee on collects and supports referrals. Thus, we need to decode data.\n     *\n     * @param profileId The token ID of the profile of the publisher, passed by the hub.\n     * @param pubId The publication ID of the newly created publication, passed by the hub.\n     * @param data The arbitrary data parameter, decoded into:\n     *      uint256 amount: The currency total amount to levy.\n     *      address currency: The currency address, must be internally whitelisted.\n     *      address recipient: The custom recipient address to direct earnings to.\n     *      uint16 referralFee: The referral fee to set.\n     *\n     * @return An abi encoded bytes parameter, which is the same as the passed data parameter.\n     */\n    function initializePublicationCollectModule(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external override onlyHub returns (bytes memory) {\n        (uint256 amount, address currency, address recipient, uint16 referralFee) = abi.decode(\n            data,\n            (uint256, address, address, uint16)\n        );\n        if (\n            !_currencyWhitelisted(currency) ||\n            recipient == address(0) ||\n            referralFee > BPS_MAX ||\n            amount < BPS_MAX\n        ) revert Errors.InitParamsInvalid();\n\n        _dataByPublicationByProfile[profileId][pubId].referralFee = referralFee;\n        _dataByPublicationByProfile[profileId][pubId].recipient = recipient;\n        _dataByPublicationByProfile[profileId][pubId].currency = currency;\n        _dataByPublicationByProfile[profileId][pubId].amount = amount;\n\n        return data;\n    }\n\n    /**\n     * @dev Processes a collect by:\n     *  1. Ensuring the collector is a follower\n     *  2. Charging a fee\n     */\n    function processCollect(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external virtual override onlyHub {\n        _checkFollowValidity(profileId, collector);\n        if (referrerProfileId == profileId) {\n            _processCollect(collector, profileId, pubId, data);\n        } else {\n            _processCollectWithReferral(referrerProfileId, collector, profileId, pubId, data);\n        }\n    }\n\n    /**\n     * @notice Returns the publication data for a given publication, or an empty struct if that publication was not\n     * initialized with this module.\n     *\n     * @param profileId The token ID of the profile mapped to the publication to query.\n     * @param pubId The publication ID of the publication to query.\n     *\n     * @return The ProfilePublicationData struct mapped to that publication.\n     */\n    function getPublicationData(uint256 profileId, uint256 pubId)\n        external\n        view\n        returns (ProfilePublicationData memory)\n    {\n        return _dataByPublicationByProfile[profileId][pubId];\n    }\n\n    function _processCollect(\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) internal {\n        uint256 amount = _dataByPublicationByProfile[profileId][pubId].amount;\n        address currency = _dataByPublicationByProfile[profileId][pubId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        (address treasury, uint16 treasuryFee) = _treasuryData();\n        address recipient = _dataByPublicationByProfile[profileId][pubId].recipient;\n        uint256 treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        IERC20(currency).safeTransferFrom(collector, recipient, adjustedAmount);\n        IERC20(currency).safeTransferFrom(collector, treasury, treasuryAmount);\n    }\n\n    function _processCollectWithReferral(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) internal {\n        uint256 amount = _dataByPublicationByProfile[profileId][pubId].amount;\n        address currency = _dataByPublicationByProfile[profileId][pubId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        uint256 referralFee = _dataByPublicationByProfile[profileId][pubId].referralFee;\n        address treasury;\n        uint256 treasuryAmount;\n\n        // Avoids stack too deep\n        {\n            uint16 treasuryFee;\n            (treasury, treasuryFee) = _treasuryData();\n            treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        }\n\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        if (referralFee != 0) {\n            // The reason we levy the referral fee on the adjusted amount is so that referral fees\n            // don't bypass the treasury fee, in essence referrals pay their fair share to the treasury.\n            uint256 referralAmount = (adjustedAmount * referralFee) / BPS_MAX;\n            adjustedAmount = adjustedAmount - referralAmount;\n\n            address referralRecipient = IERC721(HUB).ownerOf(referrerProfileId);\n\n            IERC20(currency).safeTransferFrom(collector, referralRecipient, referralAmount);\n        }\n        address recipient = _dataByPublicationByProfile[profileId][pubId].recipient;\n\n        IERC20(currency).safeTransferFrom(collector, recipient, adjustedAmount);\n        IERC20(currency).safeTransferFrom(collector, treasury, treasuryAmount);\n    }\n}"
    }
  ]
}