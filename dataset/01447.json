{
  "Title": "H-4: isCoolerCallback can be bypassed",
  "Content": "# Issue H-4: isCoolerCallback can be bypassed \n\nSource: https://github.com/sherlock-audit/2023-08-cooler-judging/issues/187 \n\n## Found by \n0xbepresent, BugHunter101, Delvir0, Hama, Ignite, Kow, Mlome, Vagner, banditx0x, castle\\_chain, deadrxsezzz, detectiveking, evilakela, harisnabeel, jah, klaus, libratus, mert\\_eren, ni8mare, nmirchev8, ubermensch\n\nThe lender can bypass `CoolerCallback.isCoolerCallback()` validation without implements the `CoolerCallback` abstract.\n\nIn the provided example, this may force the loan to default.\n\n## Vulnerability Detail\n\nThe `CoolerCallback.isCoolerCallback()` is intended to ensure that the lender implements the `CoolerCallback` abstract at line 241 when the parameter `isCallback_` is `true`.\n\n```solidity=!\nfunction clearRequest(\n    uint256 reqID_,\n    bool repayDirect_,\n    bool isCallback_\n) external returns (uint256 loanID) {\n    Request memory req = requests[reqID_];\n\n    // If necessary, ensure lender implements the CoolerCallback abstract.\n    if (isCallback_ && !CoolerCallback(msg.sender).isCoolerCallback()) revert NotCoolerCallback();\n\n    // Ensure loan request is active. \n    if (!req.active) revert Deactivated();\n\n    // Clear the loan request in memory.\n    req.active = false;\n\n    // Calculate and store loan terms.\n    uint256 interest = interestFor(req.amount, req.interest, req.duration);\n    uint256 collat = collateralFor(req.amount, req.loanToCollateral);\n    uint256 expiration = block.timestamp + req.duration;\n    loanID = loans.length;\n    loans.push(\n        Loan({\n            request: req,\n            amount: req.amount + interest,\n            unclaimed: 0,\n            collateral: collat,\n            expiry: expiration,\n            lender: msg.sender,\n            repayDirect: repayDirect_,\n            callback: isCallback_\n        })\n    );\n\n    // Clear the loan request storage.\n    requests[reqID_].active = false;\n\n    // Transfer debt tokens to the owner of the request.\n    debt().safeTransferFrom(msg.sender, owner(), req.amount);\n\n    // Log the event.\n    factory().newEvent(reqID_, CoolerFactory.Events.ClearRequest, 0);\n}\n```\nhttps://github.com/sherlock-audit/2023-08-cooler/blob/main/Cooler/src/Cooler.sol#L233-L275\n\nHowever, this function doesn't provide any protection. The lender can bypass this check without implementing the `CoolerCallback` abstract by calling the `Cooler.clearRequest()` function using a contract that implements the `isCoolerCallback()` function and returns a `true` value.\n\nFor example:\n\n```solidity=!\ncontract maliciousLender {\n    function isCoolerCallback() pure returns(bool) {\n        return true;\n    }\n    \n    function operation(\n        address _to,\n        uint256 reqID_\n    ) public {\n        Cooler(_to).clearRequest(reqID_, true, true);\n    }\n    \n    function onDefault(uint256 loanID_, uint256 debt, uint256 collateral) public {}\n}\n```\n\nBy being the `loan.lender` with implement only `onDefault()` function, this will cause the `repayLoan()` and `rollLoan()` methods to fail due to revert at `onRepay()` and `onRoll()` function. The borrower cannot repay and the loan will be defaulted.\n\nAfter the loan default, the attacker can execute `claimDefault()` to claim the collateral.\n\nFurthermore, there is another method that allows lenders to bypass the `CoolerCallback.isCoolerCallback()` function which is loan ownership transfer.\n\n```solidity=!\n/// @notice Approve transfer of loan ownership rights to a new address.\n/// @param  to_ address to be approved.\n/// @param  loanID_ index of loan in loans[].\nfunction approveTransfer(address to_, uint256 loanID_) external {\n    if (msg.sender != loans[loanID_].lender) revert OnlyApproved();\n\n    // Update transfer approvals.\n    approvals[loanID_] = to_;\n}\n\n/// @notice Execute loan ownership transfer. Must be previously approved by the lender.\n/// @param  loanID_ index of loan in loans[].\nfunction transferOwnership(uint256 loanID_) external {\n    if (msg.sender != approvals[loanID_]) revert OnlyApproved();\n\n    // Update the load lender.\n    loans[loanID_].lender = msg.sender;\n    // Clear transfer approvals.\n    approvals[loanID_] = address(0);\n}\n```\n\nNormally, the lender who implements the `CoolerCallback` abstract may call the `Cooler.clearRequest()` with the `_isCoolerCallback` parameter set to `true` to execute logic when a loan is repaid, rolled, or defaulted.\n\nBut the lender needs to change the owner of the loan, so they call the `approveTransfer()` and `transferOwnership()` functions to the contract that doesn't implement the `CoolerCallback` abstract (or implement only `onDefault()` function to force the loan default), but the `loan.callback` flag is still set to `true`.\n\nThus, this breaks the business logic since the three callback functions don't need to be implemented when the `isCoolerCallback()` is set to `true` according to the dev note in the `CoolerCallback` abstract below:\n\n> /// @notice Allows for debt issuers to execute logic when a loan is repaid, rolled, or defaulted.\n/// @dev    The three callback functions must be implemented if `isCoolerCallback()` is set to true.\n\n## Impact\n\n1. The lender forced the Loan become default to get the collateral token, owner lost the collateral token.\n\n2. Bypass the `isCoolerCallback` validation.\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-08-cooler/blob/main/Cooler/src/Cooler.sol#L241\n\nhttps://github.com/sherlock-audit/2023-08-cooler/blob/main/Cooler/src/Cooler.sol#L338-L343\n\nhttps://github.com/sherlock-audit/2023-08-cooler/blob/main/Cooler/src/Cooler.sol#L347-L354\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nOnly allowing callbacks from the protocol-trusted address (eg., `Clearinghouse` contract).\n\nDisable the transfer owner of the loan when the `loan.callback` is set to `true`.\n\n\n\n## Discussion\n\n**Oot2k**\n\nDuplicate of 30\n\n**Oot2k**\n\nReorder issues\n\n**0xRusowsky**\n\n- https://github.com/ohmzeus/Cooler/pull/51\n- https://github.com/ohmzeus/Cooler/pull/57\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/107",
  "Code": [
    {
      "filename": "Cooler/src/Cooler.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {Clone} from \"clones/Clone.sol\";\n\nimport {IDelegate} from \"interfaces/IDelegate.sol\";\nimport {CoolerFactory} from \"src/CoolerFactory.sol\";\nimport {CoolerCallback} from \"src/CoolerCallback.sol\";\n\n/// @title  Cooler Loans.\n/// @notice A Cooler is a smart contract escrow that facilitates fixed-duration, peer-to-peer\n///         loans for a user-defined debt-collateral pair.\n/// @dev    This contract uses Clones (https://github.com/wighawag/clones-with-immutable-args)\n///         to save gas on deployment.\ncontract Cooler is Clone {\n    using SafeTransferLib for ERC20;\n\n    // --- ERRORS ----------------------------------------------------\n\n    error OnlyApproved();\n    error Deactivated();\n    error Default();\n    error NoDefault();\n    error NotRollable();\n    error ZeroCollateralReturned();\n    error NotCoolerCallback();\n\n    // --- DATA STRUCTURES -------------------------------------------\n\n    /// @notice A loan begins with a borrow request.\n    struct Request {\n        uint256 amount;             // Amount to be borrowed.\n        uint256 interest;           // Annualized percentage to be paid as interest.\n        uint256 loanToCollateral;   // Requested loan-to-collateral ratio.\n        uint256 duration;           // Time to repay the loan before it defaults.\n        bool active;                // Any lender can clear an active loan request.\n    }\n\n    /// @notice A request is converted to a loan when a lender clears it.\n    struct Loan {\n        Request request;        // Loan terms specified in the request.\n        uint256 amount;         // Amount of debt owed to the lender.\n        uint256 unclaimed;      // Amount of debt tokens repaid but unclaimed.\n        uint256 collateral;     // Amount of collateral pledged.\n        uint256 expiry;         // Time when the loan defaults.\n        address lender;         // Lender's address.\n        bool repayDirect;       // If this is false, repaid tokens must be claimed by lender.\n        bool callback;          // If this is true, the lender must inherit CoolerCallback.\n    }\n\n    // --- IMMUTABLES ------------------------------------------------\n\n    // This makes the code look prettier.\n    uint256 private constant DECIMALS_INTEREST = 1e18;\n\n    /// @notice This address owns the collateral in escrow.\n    function owner() public pure returns (address _owner) {\n        return _getArgAddress(0x0);\n    }\n\n    /// @notice This token is borrowed against.\n    function collateral() public pure returns (ERC20 _collateral) {\n        return ERC20(_getArgAddress(0x14));\n    }\n\n    /// @notice This token is lent.\n    function debt() public pure returns (ERC20 _debt) {\n        return ERC20(_getArgAddress(0x28));\n    }\n    \n    /// @notice This contract created the Cooler\n    function factory() public pure returns (CoolerFactory _factory) {\n        return CoolerFactory(_getArgAddress(0x3c));\n    }\n\n    // --- STATE VARIABLES -------------------------------------------\n\n    /// @notice Arrays stores all the loan requests.\n    Request[] public requests;\n\n    /// @notice Arrays stores all the granted loans.\n    Loan[] public loans;\n\n    /// @notice Facilitates transfer of lender ownership to new addresses\n    mapping(uint256 => address) public approvals;\n\n    // --- BORROWER --------------------------------------------------\n\n    /// @notice Request a loan with given parameters.\n    ///         Collateral is taken at time of request.\n    /// @param  amount_ of debt tokens to borrow.\n    /// @param  interest_ to pay (annualized % of 'amount_'). Expressed in DECIMALS_INTEREST.\n    /// @param  loanToCollateral_ debt tokens per collateral token pledged. Expressed in 10**debt().decimals().\n    /// @param  duration_ of loan tenure in seconds.\n    /// @return reqID of the created request. Equivalent to the index of request in requests[].\n    function requestLoan(\n        uint256 amount_,\n        uint256 interest_,\n        uint256 loanToCollateral_,\n        uint256 duration_\n    ) external returns (uint256 reqID) {\n        reqID = requests.length;\n        requests.push(\n            Request({\n                amount: amount_,\n                interest: interest_,\n                loanToCollateral: loanToCollateral_,\n                duration: duration_,\n                active: true\n            })\n        );\n\n        // The collateral is taken upfront. Will be escrowed\n        // until the loan is repaid or defaulted.\n        collateral().safeTransferFrom(\n            msg.sender,\n            address(this),\n            collateralFor(amount_, loanToCollateral_)\n        );\n\n        // Log the event.\n        factory().newEvent(reqID, CoolerFactory.Events.RequestLoan, 0);\n    }\n\n    /// @notice Cancel a loan request and get the collateral back.\n    /// @param  reqID_ index of request in requests[].\n    function rescindRequest(uint256 reqID_) external {\n        if (msg.sender != owner()) revert OnlyApproved();\n\n        Request storage req = requests[reqID_];\n\n        if (!req.active) revert Deactivated();\n\n        // Update storage and send collateral back to the owner.\n        req.active = false;\n        collateral().safeTransfer(owner(), collateralFor(req.amount, req.loanToCollateral));\n\n        // Log the event.\n        factory().newEvent(reqID_, CoolerFactory.Events.RescindRequest, 0);\n    }\n\n    /// @notice Repay a loan to get the collateral back.\n    /// @dev    Despite a malicious lender could reenter with the callback, the\n    ///         usage of `msg.sender` prevents any economical benefit to the\n    ///         attacker, since they would be repaying the loan themselves.\n    /// @param  loanID_ index of loan in loans[]\n    /// @param  repaid_ debt tokens to be repaid.\n    /// @return collateral given back to the borrower.\n    function repayLoan(uint256 loanID_, uint256 repaid_) external returns (uint256) {\n        Loan memory loan = loans[loanID_];\n\n        if (block.timestamp > loan.expiry) revert Default();\n\n        if (repaid_ > loan.amount) repaid_ = loan.amount;\n\n        uint256 decollateralized = (loan.collateral * repaid_) / loan.amount;\n        if (decollateralized == 0) revert ZeroCollateralReturned();\n\n        // Update loan memory.\n        loan.amount -= repaid_;\n        loan.collateral -= decollateralized;\n\n        address repayTo;\n        // Check whether repayment needs to be manually claimed or not.\n        if (loan.repayDirect) {\n            repayTo = loan.lender;\n        } else {\n            repayTo = address(this);\n            loan.unclaimed += repaid_;\n        }\n\n        // Save updated loan info in storage.\n        loans[loanID_] = loan;\n\n        // Transfer repaid debt back to the lender and (de)collateral back to the owner.\n        debt().safeTransferFrom(msg.sender, repayTo, repaid_);\n        collateral().safeTransfer(owner(), decollateralized);\n\n        // Log the event.\n        factory().newEvent(loanID_, CoolerFactory.Events.RepayLoan, repaid_);\n\n        // If necessary, trigger lender callback.\n        if (loan.callback) CoolerCallback(loan.lender).onRepay(loanID_, repaid_);\n        return decollateralized;\n    }\n\n    /// @notice Roll a loan over with new terms.\n    ///         provideNewTermsForRoll must have been called beforehand by the lender.\n    /// @param  loanID_ index of loan in loans[].\n    function rollLoan(uint256 loanID_) external {\n        Loan memory loan = loans[loanID_];\n\n        if (block.timestamp > loan.expiry) revert Default();\n        if (!loan.request.active) revert NotRollable();\n\n        // Check whether rolling the loan requires pledging more collateral or not (if there was a previous repayment).\n        uint256 newCollateral = newCollateralFor(loanID_);\n        uint256 newDebt = interestFor(loan.amount, loan.request.interest, loan.request.duration);\n\n        // Update memory accordingly.\n        loan.amount += newDebt;\n        loan.collateral += newCollateral;\n        loan.expiry += loan.request.duration;\n        loan.request.active = false;\n\n        // Save updated loan info in storage.\n        loans[loanID_] = loan;\n\n        if (newCollateral > 0) {\n            collateral().safeTransferFrom(msg.sender, address(this), newCollateral);\n        }\n\n        // If necessary, trigger lender callback.\n        if (loan.callback) CoolerCallback(loan.lender).onRoll(loanID_, newDebt, newCollateral);\n    }\n\n    /// @notice Delegate voting power on collateral.\n    /// @param  to_ address to delegate.\n    function delegateVoting(address to_) external {\n        if (msg.sender != owner()) revert OnlyApproved();\n        IDelegate(address(collateral())).delegate(to_);\n    }\n\n    // --- LENDER ----------------------------------------------------\n\n    /// @notice Fill a requested loan as a lender.\n    /// @param  reqID_ index of request in requests[].\n    /// @param  repayDirect_ lender should input false if concerned about debt token blacklisting.\n    /// @param  isCallback_ true if the lender implements the CoolerCallback abstract. False otherwise.\n    /// @return loanID of the granted loan. Equivalent to the index of loan in loans[].\n    function clearRequest(\n        uint256 reqID_,\n        bool repayDirect_,\n        bool isCallback_\n    ) external returns (uint256 loanID) {\n        Request memory req = requests[reqID_];\n\n        // If necessary, ensure lender implements the CoolerCallback abstract.\n        if (isCallback_ && !CoolerCallback(msg.sender).isCoolerCallback()) revert NotCoolerCallback();\n\n        // Ensure loan request is active. \n        if (!req.active) revert Deactivated();\n\n        // Clear the loan request in memory.\n        req.active = false;\n\n        // Calculate and store loan terms.\n        uint256 interest = interestFor(req.amount, req.interest, req.duration);\n        uint256 collat = collateralFor(req.amount, req.loanToCollateral);\n        uint256 expiration = block.timestamp + req.duration;\n        loanID = loans.length;\n        loans.push(\n            Loan({\n                request: req,\n                amount: req.amount + interest,\n                unclaimed: 0,\n                collateral: collat,\n                expiry: expiration,\n                lender: msg.sender,\n                repayDirect: repayDirect_,\n                callback: isCallback_\n            })\n        );\n\n        // Clear the loan request storage.\n        requests[reqID_].active = false;\n\n        // Transfer debt tokens to the owner of the request.\n        debt().safeTransferFrom(msg.sender, owner(), req.amount);\n\n        // Log the event.\n        factory().newEvent(reqID_, CoolerFactory.Events.ClearRequest, 0);\n    }\n\n    /// @notice Provide new terms for loan to be rolled over.\n    /// @param  loanID_ index of loan in loans[].\n    /// @param  interest_ to pay (annualized % of 'amount_'). Expressed in DECIMALS_INTEREST.\n    /// @param  loanToCollateral_ debt tokens per collateral token pledged. Expressed in 10**debt().decimals().\n    /// @param  duration_ of loan tenure in seconds.\n    function provideNewTermsForRoll(\n        uint256 loanID_,\n        uint256 interest_,\n        uint256 loanToCollateral_,\n        uint256 duration_\n    ) external {\n        Loan storage loan = loans[loanID_];\n\n        if (msg.sender != loan.lender) revert OnlyApproved();\n\n        loan.request =\n            Request(\n                loan.amount,\n                interest_,\n                loanToCollateral_,\n                duration_,\n                true\n            );\n    }\n\n    /// @notice Claim debt tokens if repayDirect was false.\n    /// @param  loanID_ index of loan in loans[].\n    function claimRepaid(uint256 loanID_) external {\n        Loan memory loan = loans[loanID_];\n\n        // Update storage.\n        uint256 claim = loan.unclaimed;\n        delete loans[loanID_].unclaimed;\n\n        // Transfer repaid debt back to the lender.\n        debt().safeTransfer(loan.lender, claim);\n    }\n\n    /// @notice Claim collateral upon loan default.\n    /// @param loanID_ index of loan in loans[]\n    /// @return defaulted debt by the borrower, collateral kept by the lender, elapsed time since expiry.\n    function claimDefaulted(uint256 loanID_) external returns (uint256, uint256, uint256) {\n        Loan memory loan = loans[loanID_];\n        delete loans[loanID_];\n\n        if (block.timestamp <= loan.expiry) revert NoDefault();\n\n        // Transfer defaulted collateral to the lender.\n        collateral().safeTransfer(loan.lender, loan.collateral);\n\n        // Log the event.\n        factory().newEvent(loanID_, CoolerFactory.Events.DefaultLoan, 0);\n\n        // If necessary, trigger lender callback.\n        if (loan.callback) CoolerCallback(loan.lender).onDefault(loanID_, loan.amount, loan.collateral);\n        return (loan.amount, loan.collateral, block.timestamp - loan.expiry);\n    }\n\n    /// @notice Approve transfer of loan ownership rights to a new address.\n    /// @param  to_ address to be approved.\n    /// @param  loanID_ index of loan in loans[].\n    function approveTransfer(address to_, uint256 loanID_) external {\n        if (msg.sender != loans[loanID_].lender) revert OnlyApproved();\n\n        // Update transfer approvals.\n        approvals[loanID_] = to_;\n    }\n\n    /// @notice Execute loan ownership transfer. Must be previously approved by the lender.\n    /// @param  loanID_ index of loan in loans[].\n    function transferOwnership(uint256 loanID_) external {\n        if (msg.sender != approvals[loanID_]) revert OnlyApproved();\n\n        // Update the load lender.\n        loans[loanID_].lender = msg.sender;\n        // Clear transfer approvals.\n        approvals[loanID_] = address(0);\n    }\n\n    /// @notice Set direct repayment of a given loan.\n    /// @param  loanID_ of lender's loan.\n    /// @param  direct_ true if a direct repayment is desired. False otherwise.\n    function setDirectRepay(uint256 loanID_, bool direct_) external {\n        if (msg.sender != loans[loanID_].lender) revert OnlyApproved();\n\n        // Update the repayment method.\n        loans[loanID_].repayDirect = direct_;\n    }\n\n    // --- AUX FUNCTIONS ---------------------------------------------\n\n    /// @notice Compute collateral needed for loan amount at given loan to collateral ratio.\n    /// @param  amount_ of collateral tokens.\n    /// @param  loanToCollateral_ ratio for loan.\n    function collateralFor(uint256 amount_, uint256 loanToCollateral_) public view returns (uint256) {\n        return (amount_ * (10 ** collateral().decimals())) / loanToCollateral_;\n    }\n\n    /// @notice compute collateral needed to roll loan.\n    /// @param  loanID_ of loan to roll.\n    function newCollateralFor(uint256 loanID_) public view returns (uint256) {\n        Loan memory loan = loans[loanID_];\n        // Accounts for all outstanding debt (borrowed amount + interest).\n        uint256 neededCollateral = collateralFor(\n            loan.amount,\n            loan.request.loanToCollateral\n        );\n\n        return\n            neededCollateral > loan.collateral ?\n            neededCollateral - loan.collateral :\n            0;\n    }\n\n    /// @notice Compute interest cost on amount for duration at given annualized rate.\n    /// @param  amount_ of debt tokens.\n    /// @param  rate_ of interest (annualized).\n    /// @param  duration_ of loan in seconds.\n    /// @return Interest in debt token terms.\n    function interestFor(uint256 amount_, uint256 rate_, uint256 duration_) public pure returns (uint256) {\n        uint256 interest = (rate_ * duration_) / 365 days;\n        return (amount_ * interest) / DECIMALS_INTEREST;\n    }\n\n    /// @notice Check if given loan is in default.\n    /// @param  loanID_ index of loan in loans[].\n    /// @return Defaulted status.\n    function isDefaulted(uint256 loanID_) external view returns (bool) {\n        return block.timestamp > loans[loanID_].expiry;\n    }\n\n    /// @notice Check if a given request is active.\n    /// @param  reqID_ index of request in requests[].\n    /// @return Active status.\n    function isActive(uint256 reqID_) external view returns (bool) {\n        return requests[reqID_].active;\n    }\n\n    /// @notice Getter for Request data as a struct.\n    /// @param  reqID_ index of request in requests[].\n    /// @return Request struct.\n    function getRequest(uint256 reqID_) external view returns (Request memory) {\n        return requests[reqID_];\n    }\n\n    /// @notice Getter for Loan data as a struct.\n    /// @param loanID_ index of loan in loans[].\n    /// @return Loan struct.\n    function getLoan(uint256 loanID_) external view returns (Loan memory) {\n        return loans[loanID_];\n    }\n}"
    },
    {
      "filename": "Cooler/src/Cooler.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {Clone} from \"clones/Clone.sol\";\n\nimport {IDelegate} from \"interfaces/IDelegate.sol\";\nimport {CoolerFactory} from \"src/CoolerFactory.sol\";\nimport {CoolerCallback} from \"src/CoolerCallback.sol\";\n\n/// @title  Cooler Loans.\n/// @notice A Cooler is a smart contract escrow that facilitates fixed-duration, peer-to-peer\n///         loans for a user-defined debt-collateral pair.\n/// @dev    This contract uses Clones (https://github.com/wighawag/clones-with-immutable-args)\n///         to save gas on deployment.\ncontract Cooler is Clone {\n    using SafeTransferLib for ERC20;\n\n    // --- ERRORS ----------------------------------------------------\n\n    error OnlyApproved();\n    error Deactivated();\n    error Default();\n    error NoDefault();\n    error NotRollable();\n    error ZeroCollateralReturned();\n    error NotCoolerCallback();\n\n    // --- DATA STRUCTURES -------------------------------------------\n\n    /// @notice A loan begins with a borrow request.\n    struct Request {\n        uint256 amount;             // Amount to be borrowed.\n        uint256 interest;           // Annualized percentage to be paid as interest.\n        uint256 loanToCollateral;   // Requested loan-to-collateral ratio.\n        uint256 duration;           // Time to repay the loan before it defaults.\n        bool active;                // Any lender can clear an active loan request.\n    }\n\n    /// @notice A request is converted to a loan when a lender clears it.\n    struct Loan {\n        Request request;        // Loan terms specified in the request.\n        uint256 amount;         // Amount of debt owed to the lender.\n        uint256 unclaimed;      // Amount of debt tokens repaid but unclaimed.\n        uint256 collateral;     // Amount of collateral pledged.\n        uint256 expiry;         // Time when the loan defaults.\n        address lender;         // Lender's address.\n        bool repayDirect;       // If this is false, repaid tokens must be claimed by lender.\n        bool callback;          // If this is true, the lender must inherit CoolerCallback.\n    }\n\n    // --- IMMUTABLES ------------------------------------------------\n\n    // This makes the code look prettier.\n    uint256 private constant DECIMALS_INTEREST = 1e18;\n\n    /// @notice This address owns the collateral in escrow.\n    function owner() public pure returns (address _owner) {\n        return _getArgAddress(0x0);\n    }\n\n    /// @notice This token is borrowed against.\n    function collateral() public pure returns (ERC20 _collateral) {\n        return ERC20(_getArgAddress(0x14));\n    }\n\n    /// @notice This token is lent.\n    function debt() public pure returns (ERC20 _debt) {\n        return ERC20(_getArgAddress(0x28));\n    }\n    \n    /// @notice This contract created the Cooler\n    function factory() public pure returns (CoolerFactory _factory) {\n        return CoolerFactory(_getArgAddress(0x3c));\n    }\n\n    // --- STATE VARIABLES -------------------------------------------\n\n    /// @notice Arrays stores all the loan requests.\n    Request[] public requests;\n\n    /// @notice Arrays stores all the granted loans.\n    Loan[] public loans;\n\n    /// @notice Facilitates transfer of lender ownership to new addresses\n    mapping(uint256 => address) public approvals;\n\n    // --- BORROWER --------------------------------------------------\n\n    /// @notice Request a loan with given parameters.\n    ///         Collateral is taken at time of request.\n    /// @param  amount_ of debt tokens to borrow.\n    /// @param  interest_ to pay (annualized % of 'amount_'). Expressed in DECIMALS_INTEREST.\n    /// @param  loanToCollateral_ debt tokens per collateral token pledged. Expressed in 10**debt().decimals().\n    /// @param  duration_ of loan tenure in seconds.\n    /// @return reqID of the created request. Equivalent to the index of request in requests[].\n    function requestLoan(\n        uint256 amount_,\n        uint256 interest_,\n        uint256 loanToCollateral_,\n        uint256 duration_\n    ) external returns (uint256 reqID) {\n        reqID = requests.length;\n        requests.push(\n            Request({\n                amount: amount_,\n                interest: interest_,\n                loanToCollateral: loanToCollateral_,\n                duration: duration_,\n                active: true\n            })\n        );\n\n        // The collateral is taken upfront. Will be escrowed\n        // until the loan is repaid or defaulted.\n        collateral().safeTransferFrom(\n            msg.sender,\n            address(this),\n            collateralFor(amount_, loanToCollateral_)\n        );\n\n        // Log the event.\n        factory().newEvent(reqID, CoolerFactory.Events.RequestLoan, 0);\n    }\n\n    /// @notice Cancel a loan request and get the collateral back.\n    /// @param  reqID_ index of request in requests[].\n    function rescindRequest(uint256 reqID_) external {\n        if (msg.sender != owner()) revert OnlyApproved();\n\n        Request storage req = requests[reqID_];\n\n        if (!req.active) revert Deactivated();\n\n        // Update storage and send collateral back to the owner.\n        req.active = false;\n        collateral().safeTransfer(owner(), collateralFor(req.amount, req.loanToCollateral));\n\n        // Log the event.\n        factory().newEvent(reqID_, CoolerFactory.Events.RescindRequest, 0);\n    }\n\n    /// @notice Repay a loan to get the collateral back.\n    /// @dev    Despite a malicious lender could reenter with the callback, the\n    ///         usage of `msg.sender` prevents any economical benefit to the\n    ///         attacker, since they would be repaying the loan themselves.\n    /// @param  loanID_ index of loan in loans[]\n    /// @param  repaid_ debt tokens to be repaid.\n    /// @return collateral given back to the borrower.\n    function repayLoan(uint256 loanID_, uint256 repaid_) external returns (uint256) {\n        Loan memory loan = loans[loanID_];\n\n        if (block.timestamp > loan.expiry) revert Default();\n\n        if (repaid_ > loan.amount) repaid_ = loan.amount;\n\n        uint256 decollateralized = (loan.collateral * repaid_) / loan.amount;\n        if (decollateralized == 0) revert ZeroCollateralReturned();\n\n        // Update loan memory.\n        loan.amount -= repaid_;\n        loan.collateral -= decollateralized;\n\n        address repayTo;\n        // Check whether repayment needs to be manually claimed or not.\n        if (loan.repayDirect) {\n            repayTo = loan.lender;\n        } else {\n            repayTo = address(this);\n            loan.unclaimed += repaid_;\n        }\n\n        // Save updated loan info in storage.\n        loans[loanID_] = loan;\n\n        // Transfer repaid debt back to the lender and (de)collateral back to the owner.\n        debt().safeTransferFrom(msg.sender, repayTo, repaid_);\n        collateral().safeTransfer(owner(), decollateralized);\n\n        // Log the event.\n        factory().newEvent(loanID_, CoolerFactory.Events.RepayLoan, repaid_);\n\n        // If necessary, trigger lender callback.\n        if (loan.callback) CoolerCallback(loan.lender).onRepay(loanID_, repaid_);\n        return decollateralized;\n    }\n\n    /// @notice Roll a loan over with new terms.\n    ///         provideNewTermsForRoll must have been called beforehand by the lender.\n    /// @param  loanID_ index of loan in loans[].\n    function rollLoan(uint256 loanID_) external {\n        Loan memory loan = loans[loanID_];\n\n        if (block.timestamp > loan.expiry) revert Default();\n        if (!loan.request.active) revert NotRollable();\n\n        // Check whether rolling the loan requires pledging more collateral or not (if there was a previous repayment).\n        uint256 newCollateral = newCollateralFor(loanID_);\n        uint256 newDebt = interestFor(loan.amount, loan.request.interest, loan.request.duration);\n\n        // Update memory accordingly.\n        loan.amount += newDebt;\n        loan.collateral += newCollateral;\n        loan.expiry += loan.request.duration;\n        loan.request.active = false;\n\n        // Save updated loan info in storage.\n        loans[loanID_] = loan;\n\n        if (newCollateral > 0) {\n            collateral().safeTransferFrom(msg.sender, address(this), newCollateral);\n        }\n\n        // If necessary, trigger lender callback.\n        if (loan.callback) CoolerCallback(loan.lender).onRoll(loanID_, newDebt, newCollateral);\n    }\n\n    /// @notice Delegate voting power on collateral.\n    /// @param  to_ address to delegate.\n    function delegateVoting(address to_) external {\n        if (msg.sender != owner()) revert OnlyApproved();\n        IDelegate(address(collateral())).delegate(to_);\n    }\n\n    // --- LENDER ----------------------------------------------------\n\n    /// @notice Fill a requested loan as a lender.\n    /// @param  reqID_ index of request in requests[].\n    /// @param  repayDirect_ lender should input false if concerned about debt token blacklisting.\n    /// @param  isCallback_ true if the lender implements the CoolerCallback abstract. False otherwise.\n    /// @return loanID of the granted loan. Equivalent to the index of loan in loans[].\n    function clearRequest(\n        uint256 reqID_,\n        bool repayDirect_,\n        bool isCallback_\n    ) external returns (uint256 loanID) {\n        Request memory req = requests[reqID_];\n\n        // If necessary, ensure lender implements the CoolerCallback abstract.\n        if (isCallback_ && !CoolerCallback(msg.sender).isCoolerCallback()) revert NotCoolerCallback();\n\n        // Ensure loan request is active. \n        if (!req.active) revert Deactivated();\n\n        // Clear the loan request in memory.\n        req.active = false;\n\n        // Calculate and store loan terms.\n        uint256 interest = interestFor(req.amount, req.interest, req.duration);\n        uint256 collat = collateralFor(req.amount, req.loanToCollateral);\n        uint256 expiration = block.timestamp + req.duration;\n        loanID = loans.length;\n        loans.push(\n            Loan({\n                request: req,\n                amount: req.amount + interest,\n                unclaimed: 0,\n                collateral: collat,\n                expiry: expiration,\n                lender: msg.sender,\n                repayDirect: repayDirect_,\n                callback: isCallback_\n            })\n        );\n\n        // Clear the loan request storage.\n        requests[reqID_].active = false;\n\n        // Transfer debt tokens to the owner of the request.\n        debt().safeTransferFrom(msg.sender, owner(), req.amount);\n\n        // Log the event.\n        factory().newEvent(reqID_, CoolerFactory.Events.ClearRequest, 0);\n    }\n\n    /// @notice Provide new terms for loan to be rolled over.\n    /// @param  loanID_ index of loan in loans[].\n    /// @param  interest_ to pay (annualized % of 'amount_'). Expressed in DECIMALS_INTEREST.\n    /// @param  loanToCollateral_ debt tokens per collateral token pledged. Expressed in 10**debt().decimals().\n    /// @param  duration_ of loan tenure in seconds.\n    function provideNewTermsForRoll(\n        uint256 loanID_,\n        uint256 interest_,\n        uint256 loanToCollateral_,\n        uint256 duration_\n    ) external {\n        Loan storage loan = loans[loanID_];\n\n        if (msg.sender != loan.lender) revert OnlyApproved();\n\n        loan.request =\n            Request(\n                loan.amount,\n                interest_,\n                loanToCollateral_,\n                duration_,\n                true\n            );\n    }\n\n    /// @notice Claim debt tokens if repayDirect was false.\n    /// @param  loanID_ index of loan in loans[].\n    function claimRepaid(uint256 loanID_) external {\n        Loan memory loan = loans[loanID_];\n\n        // Update storage.\n        uint256 claim = loan.unclaimed;\n        delete loans[loanID_].unclaimed;\n\n        // Transfer repaid debt back to the lender.\n        debt().safeTransfer(loan.lender, claim);\n    }\n\n    /// @notice Claim collateral upon loan default.\n    /// @param loanID_ index of loan in loans[]\n    /// @return defaulted debt by the borrower, collateral kept by the lender, elapsed time since expiry.\n    function claimDefaulted(uint256 loanID_) external returns (uint256, uint256, uint256) {\n        Loan memory loan = loans[loanID_];\n        delete loans[loanID_];\n\n        if (block.timestamp <= loan.expiry) revert NoDefault();\n\n        // Transfer defaulted collateral to the lender.\n        collateral().safeTransfer(loan.lender, loan.collateral);\n\n        // Log the event.\n        factory().newEvent(loanID_, CoolerFactory.Events.DefaultLoan, 0);\n\n        // If necessary, trigger lender callback.\n        if (loan.callback) CoolerCallback(loan.lender).onDefault(loanID_, loan.amount, loan.collateral);\n        return (loan.amount, loan.collateral, block.timestamp - loan.expiry);\n    }\n\n    /// @notice Approve transfer of loan ownership rights to a new address.\n    /// @param  to_ address to be approved.\n    /// @param  loanID_ index of loan in loans[].\n    function approveTransfer(address to_, uint256 loanID_) external {\n        if (msg.sender != loans[loanID_].lender) revert OnlyApproved();\n\n        // Update transfer approvals.\n        approvals[loanID_] = to_;\n    }\n\n    /// @notice Execute loan ownership transfer. Must be previously approved by the lender.\n    /// @param  loanID_ index of loan in loans[].\n    function transferOwnership(uint256 loanID_) external {\n        if (msg.sender != approvals[loanID_]) revert OnlyApproved();\n\n        // Update the load lender.\n        loans[loanID_].lender = msg.sender;\n        // Clear transfer approvals.\n        approvals[loanID_] = address(0);\n    }\n\n    /// @notice Set direct repayment of a given loan.\n    /// @param  loanID_ of lender's loan.\n    /// @param  direct_ true if a direct repayment is desired. False otherwise.\n    function setDirectRepay(uint256 loanID_, bool direct_) external {\n        if (msg.sender != loans[loanID_].lender) revert OnlyApproved();\n\n        // Update the repayment method.\n        loans[loanID_].repayDirect = direct_;\n    }\n\n    // --- AUX FUNCTIONS ---------------------------------------------\n\n    /// @notice Compute collateral needed for loan amount at given loan to collateral ratio.\n    /// @param  amount_ of collateral tokens.\n    /// @param  loanToCollateral_ ratio for loan.\n    function collateralFor(uint256 amount_, uint256 loanToCollateral_) public view returns (uint256) {\n        return (amount_ * (10 ** collateral().decimals())) / loanToCollateral_;\n    }\n\n    /// @notice compute collateral needed to roll loan.\n    /// @param  loanID_ of loan to roll.\n    function newCollateralFor(uint256 loanID_) public view returns (uint256) {\n        Loan memory loan = loans[loanID_];\n        // Accounts for all outstanding debt (borrowed amount + interest).\n        uint256 neededCollateral = collateralFor(\n            loan.amount,\n            loan.request.loanToCollateral\n        );\n\n        return\n            neededCollateral > loan.collateral ?\n            neededCollateral - loan.collateral :\n            0;\n    }\n\n    /// @notice Compute interest cost on amount for duration at given annualized rate.\n    /// @param  amount_ of debt tokens.\n    /// @param  rate_ of interest (annualized).\n    /// @param  duration_ of loan in seconds.\n    /// @return Interest in debt token terms.\n    function interestFor(uint256 amount_, uint256 rate_, uint256 duration_) public pure returns (uint256) {\n        uint256 interest = (rate_ * duration_) / 365 days;\n        return (amount_ * interest) / DECIMALS_INTEREST;\n    }\n\n    /// @notice Check if given loan is in default.\n    /// @param  loanID_ index of loan in loans[].\n    /// @return Defaulted status.\n    function isDefaulted(uint256 loanID_) external view returns (bool) {\n        return block.timestamp > loans[loanID_].expiry;\n    }\n\n    /// @notice Check if a given request is a"
    }
  ]
}