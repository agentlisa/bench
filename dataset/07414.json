{
  "Title": "[M-01] RewardsPool.sol : It is safe to have the startRewardsCycle with WhenNotPaused modifier",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/RewardsPool.sol#L155-L197\n\n\n# Vulnerability details\n\n## Impact\nwhen the contract is paused , allowing startRewardsCycle would inflate the token value which might not be safe.\n\nRewards should not be claimed by anyone when all other operations are paused.\n\nI saw that the `witdrawGGP` has this `WhenNotPaused` modifier.\n\nInflate should not consider the paused duration.\n\nlets say, when the contract is paused for theduration of 2 months, then the dao, protocol, and node validator would enjoy the rewards. This is not good for a health protocol\n\n## Proof of Concept\n\nstartRewardsCycle does not have the WhenNotPaused modifier.\n\n\tfunction startRewardsCycle() external {\n\t\tif (!canStartRewardsCycle()) {\n\t\t\trevert UnableToStartRewardsCycle();\n\t\t}\n\n\n\t\temit NewRewardsCycleStarted(getRewardsCycleTotalAmt());\n\n\n\t\t// Set start of new rewards cycle\n\t\tsetUint(keccak256(\"RewardsPool.RewardsCycleStartTime\"), block.timestamp);\n\t\tincreaseRewardsCycleCount();\n\t\t// Mint any new tokens from GGP inflation\n\t\t// This will always 'mint' (release) new tokens if the rewards cycle length requirement is met\n\t\t// \t\tsince inflation is on a 1 day interval and it needs at least one cycle since last calculation\n\t\tinflate();\n\n\n\t\tuint256 multisigClaimContractAllotment = getClaimingContractDistribution(\"ClaimMultisig\");\n\t\tuint256 nopClaimContractAllotment = getClaimingContractDistribution(\"ClaimNodeOp\");\n\t\tuint256 daoClaimContractAllotment = getClaimingContractDistribution(\"ClaimProtocolDAO\");\n\t\tif (daoClaimContractAllotment + nopClaimContractAllotment + multisigClaimContractAllotment > getRewardsCycleTotalAmt()) {\n\t\t\trevert IncorrectRewardsDistribution();\n\t\t}\n\n\n\t\tTokenGGP ggp = TokenGGP(getContractAddress(\"TokenGGP\"));\n\t\tVault vault = Vault(getContractAddress(\"Vault\"));\n\n\n\t\tif (daoClaimContractAllotment > 0) {\n\t\t\temit ProtocolDAORewardsTransfered(daoClaimContractAllotment);\n\t\t\tvault.transferToken(\"ClaimProtocolDAO\", ggp, daoClaimContractAllotment);\n\t\t}\n\n\n\t\tif (multisigClaimContractAllotment > 0) {\n\t\t\temit MultisigRewardsTransfered(multisigClaimContractAllotment);\n\t\t\tdistributeMultisigAllotment(multisigClaimContractAllotment, vault, ggp);\n\t\t}\n\n\n\t\tif (nopClaimContractAllotment > 0) {\n\t\t\temit ClaimNodeOpRewardsTransfered(nopClaimContractAllotment);\n\t\t\tClaimNodeOp nopClaim = ClaimNodeOp(getContractAddress(\"ClaimNodeOp\"));\n\t\t\tnopClaim.setRewardsCycleTotal(nopClaimContractAllotment);\n\t\t\tvault.transferToken(\"ClaimNodeOp\", ggp, nopClaimContractAllotment);\n\t\t}\n\t}\n\n## Tools Used\n\nManual review\n\n## Recommended Mitigation Steps\n\nWe suggest to use `WhenNotPaused` modifier.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-12-gogopool-contest",
  "Code": [
    {
      "filename": "contracts/contract/RewardsPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport \"./Base.sol\";\nimport {ClaimNodeOp} from \"./ClaimNodeOp.sol\";\nimport {MultisigManager} from \"./MultisigManager.sol\";\nimport {ProtocolDAO} from \"./ProtocolDAO.sol\";\nimport {Storage} from \"./Storage.sol\";\nimport {TokenGGP} from \"./tokens/TokenGGP.sol\";\nimport {Vault} from \"./Vault.sol\";\n\nimport {FixedPointMathLib} from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\n\n/// @title Vault for GGP Rewards\ncontract RewardsPool is Base {\n\tusing FixedPointMathLib for uint256;\n\n\t/// @notice Distribution cannot exceed total rewards\n\terror IncorrectRewardsDistribution();\n\terror UnableToStartRewardsCycle();\n\terror ContractHasNotBeenInitialized();\n\terror MaximumTokensReached();\n\n\tevent GGPInflated(uint256 newTokens);\n\tevent NewRewardsCycleStarted(uint256 totalRewardsAmt);\n\tevent ClaimNodeOpRewardsTransfered(uint256 value);\n\tevent ProtocolDAORewardsTransfered(uint256 value);\n\tevent MultisigRewardsTransfered(uint256 value);\n\n\tconstructor(Storage storageAddress) Base(storageAddress) {\n\t\tversion = 1;\n\t}\n\n\tfunction initialize() external onlyGuardian {\n\t\tif (getBool(keccak256(\"RewardsPool.initialized\"))) {\n\t\t\treturn;\n\t\t}\n\t\tsetBool(keccak256(\"RewardsPool.initialized\"), true);\n\n\t\tsetUint(keccak256(\"RewardsPool.RewardsCycleStartTime\"), block.timestamp);\n\t\tsetUint(keccak256(\"RewardsPool.InflationIntervalStartTime\"), block.timestamp);\n\t}\n\n\t/* INFLATION */\n\n\t/// @notice Get the last time that inflation was calculated at\n\t/// @return timestamp when inflation was last calculated\n\tfunction getInflationIntervalStartTime() public view returns (uint256) {\n\t\treturn getUint(keccak256(\"RewardsPool.InflationIntervalStartTime\"));\n\t}\n\n\t/// @notice Inflation intervals that have elapsed since inflation was last calculated\n\t/// @return Number of intervals since last inflation cycle (0, 1, 2, etc)\n\tfunction getInflationIntervalsElapsed() public view returns (uint256) {\n\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tuint256 startTime = getInflationIntervalStartTime();\n\t\tif (startTime == 0) {\n\t\t\trevert ContractHasNotBeenInitialized();\n\t\t}\n\t\treturn (block.timestamp - startTime) / dao.getInflationIntervalSeconds();\n\t}\n\n\t/// @notice Function to compute how many tokens should be minted\n\t/// @return currentTotalSupply current total supply\n\t/// @return newTotalSupply supply after mint\n\tfunction getInflationAmt() public view returns (uint256 currentTotalSupply, uint256 newTotalSupply) {\n\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tuint256 inflationRate = dao.getInflationIntervalRate();\n\t\tuint256 inflationIntervalsElapsed = getInflationIntervalsElapsed();\n\t\tcurrentTotalSupply = dao.getTotalGGPCirculatingSupply();\n\t\tnewTotalSupply = currentTotalSupply;\n\n\t\t// Compute inflation for total inflation intervals elapsed\n\t\tfor (uint256 i = 0; i < inflationIntervalsElapsed; i++) {\n\t\t\tnewTotalSupply = newTotalSupply.mulWadDown(inflationRate);\n\t\t}\n\t\treturn (currentTotalSupply, newTotalSupply);\n\t}\n\n\t/// @notice Releases more GGP if appropriate\n\t/// @dev Mint new tokens if enough time has elapsed since last mint\n\tfunction inflate() internal {\n\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tuint256 inflationIntervalElapsedSeconds = (block.timestamp - getInflationIntervalStartTime());\n\t\t(uint256 currentTotalSupply, uint256 newTotalSupply) = getInflationAmt();\n\n\t\tTokenGGP ggp = TokenGGP(getContractAddress(\"TokenGGP\"));\n\t\tif (newTotalSupply > ggp.totalSupply()) {\n\t\t\trevert MaximumTokensReached();\n\t\t}\n\n\t\tuint256 newTokens = newTotalSupply - currentTotalSupply;\n\n\t\temit GGPInflated(newTokens);\n\n\t\tdao.setTotalGGPCirculatingSupply(newTotalSupply);\n\n\t\taddUint(keccak256(\"RewardsPool.InflationIntervalStartTime\"), inflationIntervalElapsedSeconds);\n\t\tsetUint(keccak256(\"RewardsPool.RewardsCycleTotalAmt\"), newTokens);\n\t}\n\n\t/* REWARDS */\n\n\t/// @notice The current cycle number for GGP rewards\n\tfunction getRewardsCycleCount() public view returns (uint256) {\n\t\treturn getUint(keccak256(\"RewardsPool.RewardsCycleCount\"));\n\t}\n\n\t/// @notice Increase the cycle number for GGP rewards\n\tfunction increaseRewardsCycleCount() internal {\n\t\taddUint(keccak256(\"RewardsPool.RewardsCycleCount\"), 1);\n\t}\n\n\t/// @notice The current rewards cycle start time\n\tfunction getRewardsCycleStartTime() public view returns (uint256) {\n\t\treturn getUint(keccak256(\"RewardsPool.RewardsCycleStartTime\"));\n\t}\n\n\t/// @notice The current rewards cycle total amount of GGP\n\tfunction getRewardsCycleTotalAmt() public view returns (uint256) {\n\t\treturn getUint(keccak256(\"RewardsPool.RewardsCycleTotalAmt\"));\n\t}\n\n\t/// @notice The number of reward cycles that have elapsed\n\tfunction getRewardsCyclesElapsed() public view returns (uint256) {\n\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tuint256 startTime = getRewardsCycleStartTime();\n\t\treturn (block.timestamp - startTime) / dao.getRewardsCycleSeconds();\n\t}\n\n\t/// @notice Get the approx amount of GGP rewards owed for this cycle per claiming contract\n\t/// @param claimingContract Name of the contract being claimed for\n\t/// @return GGP Rewards amount for current cycle per claiming contract\n\tfunction getClaimingContractDistribution(string memory claimingContract) public view returns (uint256) {\n\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tuint256 claimContractPct = dao.getClaimingContractPct(claimingContract);\n\t\t// How much rewards are available for this claim interval?\n\t\tuint256 currentCycleRewardsTotal = getRewardsCycleTotalAmt();\n\n\t\t// How much this claiming contract is entitled to in perc\n\t\tuint256 contractRewardsTotal = 0;\n\t\tif (claimContractPct > 0 && currentCycleRewardsTotal > 0) {\n\t\t\t// Calculate how much rewards this claimer will receive based on their claiming perc\n\t\t\tcontractRewardsTotal = claimContractPct.mulWadDown(currentCycleRewardsTotal);\n\t\t}\n\t\treturn contractRewardsTotal;\n\t}\n\n\t/// @notice Checking if enough time has passed since the last rewards cycle\n\t/// @dev Rialto calls this to see if at least one cycle has passed\n\tfunction canStartRewardsCycle() public view returns (bool) {\n\t\treturn getRewardsCyclesElapsed() > 0 && getInflationIntervalsElapsed() > 0;\n\t}\n\n\t/// @notice Public function that will run a GGP rewards cycle if possible\n\tfunction startRewardsCycle() external {\n\t\tif (!canStartRewardsCycle()) {\n\t\t\trevert UnableToStartRewardsCycle();\n\t\t}\n\n\t\temit NewRewardsCycleStarted(getRewardsCycleTotalAmt());\n\n\t\t// Set start of new rewards cycle\n\t\tsetUint(keccak256(\"RewardsPool.RewardsCycleStartTime\"), block.timestamp);\n\t\tincreaseRewardsCycleCount();\n\t\t// Mint any new tokens from GGP inflation\n\t\t// This will always 'mint' (release) new tokens if the rewards cycle length requirement is met\n\t\t// \t\tsince inflation is on a 1 day interval and it needs at least one cycle since last calculation\n\t\tinflate();\n\n\t\tuint256 multisigClaimContractAllotment = getClaimingContractDistribution(\"ClaimMultisig\");\n\t\tuint256 nopClaimContractAllotment = getClaimingContractDistribution(\"ClaimNodeOp\");\n\t\tuint256 daoClaimContractAllotment = getClaimingContractDistribution(\"ClaimProtocolDAO\");\n\t\tif (daoClaimContractAllotment + nopClaimContractAllotment + multisigClaimContractAllotment > getRewardsCycleTotalAmt()) {\n\t\t\trevert IncorrectRewardsDistribution();\n\t\t}\n\n\t\tTokenGGP ggp = TokenGGP(getContractAddress(\"TokenGGP\"));\n\t\tVault vault = Vault(getContractAddress(\"Vault\"));\n\n\t\tif (daoClaimContractAllotment > 0) {\n\t\t\temit ProtocolDAORewardsTransfered(daoClaimContractAllotment);\n\t\t\tvault.transferToken(\"ClaimProtocolDAO\", ggp, daoClaimContractAllotment);\n\t\t}\n\n\t\tif (multisigClaimContractAllotment > 0) {\n\t\t\temit MultisigRewardsTransfered(multisigClaimContractAllotment);\n\t\t\tdistributeMultisigAllotment(multisigClaimContractAllotment, vault, ggp);\n\t\t}\n\n\t\tif (nopClaimContractAllotment > 0) {\n\t\t\temit ClaimNodeOpRewardsTransfered(nopClaimContractAllotment);\n\t\t\tClaimNodeOp nopClaim = ClaimNodeOp(getContractAddress(\"ClaimNodeOp\"));\n\t\t\tnopClaim.setRewardsCycleTotal(nopClaimContractAllotment);\n\t\t\tvault.transferToken(\"ClaimNodeOp\", ggp, nopClaimContractAllotment);\n\t\t}\n\t}\n\n\t/// @notice Distributes GGP to enabled Multisigs\n\t/// @param allotment Total GGP for Multisigs\n\t/// @param vault Vault contract\n\t/// @param ggp TokenGGP contract\n\tfunction distributeMultisigAllotment(\n\t\tuint256 allotment,\n\t\tVault vault,\n\t\tTokenGGP ggp\n\t) internal {\n\t\tMultisigManager mm = MultisigManager(getContractAddress(\"MultisigManager\"));\n\n\t\tuint256 enabledCount;\n\t\tuint256 count = mm.getCount();\n\t\taddress[] memory enabledMultisigs = new address[](count);\n\n\t\t// there should never be more than a few multisigs, so a loop should be fine here\n\t\tfor (uint256 i = 0; i < count; i++) {\n\t\t\t(address addr, bool enabled) = mm.getMultisig(i);\n\t\t\tif (enabled) {\n\t\t\t\tenabledMultisigs[enabledCount] = addr;\n\t\t\t\tenabledCount++;\n\t\t\t}\n\t\t}\n\n\t\t// Dirty hack to cut unused elements off end of return value (from RP)\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly {\n\t\t\tmstore(enabledMultisigs, enabledCount)\n\t\t}\n\n\t\tuint256 tokensPerMultisig = allotment / enabledCount;\n\t\tfor (uint256 i = 0; i < enabledMultisigs.length; i++) {\n\t\t\tvault.withdrawToken(enabledMultisigs[i], ggp, tokensPerMultisig);\n\t\t}\n\t}\n}"
    }
  ]
}