{
  "Title": "H-7: There are no Illuminate PT transfers from the owner in ERC5095's withdraw and redeem before maturity",
  "Content": "# Issue H-7: There are no Illuminate PT transfers from the owner in ERC5095's withdraw and redeem before maturity \n\nSource: https://github.com/sherlock-audit/2022-10-illuminate-judging/issues/195 \n\n## Found by \ncryptphi, minhtrng, bin2chen, hansfriese, hyh, kenzo, Holmgren\n\n## Summary\n\nIlluminate PT's withdraw() and redeem() sell the PTs via pool and return the obtained underlying to the receiver `r`, but do not transfer these shares from the owner, i.e. selling PTs from the contract balance, if there is any. There is no accounting for the owner side that something was sold on his behalf, i.e. any owner can sell all Pts from the contract balance without spending anything.\n\nNormal operation, on the other hand, is inaccessible, if there are not enough PTs on the Illuminate PT contract balance, withdraw and redeem will be reverting, i.e. an owner is not able to provide anything.\n\n## Vulnerability Detail\n\n`IMarketPlace(marketplace).sellPrincipalToken` transfers the PT to be sold from Illuminate PT contract via Marketplace's `Safe.transferFrom( IERC20(address(pool.fyToken())), msg.sender, address(pool),a)`, but these aren't owner's PTs as nothing was transferred from the owner before and the owner's ERC5095 record aren't updated anyhow.\n\nI.e. `o == msg.sender` check does virtually nothing as `o` record neither checked nor changed as a result of withdraw() and redeem(). Say `o` might not own anything at all at this Illuminate PT contract, the calls succeed anyway as long as the contract has PTs on the balance.\n\n## Impact\n\nAnyone can empty the total holdings of Illuminate PTs of the ERC5095 contract by calling withdraw() or redeem(). This is fund stealing impact for the PTs on the balance.\n\nValid withdraw() or redeem() from real owners will be reverted as long as there will not be enough Illuminate PTs on the balance, i.e. withdrawal before maturity functionality will not be available at all. Although it can be done directly via Marketplace, there also are downstream systems integrated specifically with Illuminate PT contract and execution delays overall do have monetary costs.\n\nSetting the severity to be high as this is the violation of core business logic with total impact from temporal fund freezing to fund loss.\n\n## Code Snippet\n\nwithdraw() sells the PTs held by Illuminate PT contract, if any, reverting if there are not enough funds on the balance, not transferring PTs from the owner:\n\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/tokens/ERC5095.sol#L204-L249\n\n```solidity\n    /// @notice At or after maturity, Burns `shares` from `owner` and sends exactly `assets` of underlying tokens to `receiver`. Before maturity, sends `assets` by selling shares of PT on a YieldSpace AMM.\n    /// @param a The amount of underlying tokens withdrawn\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param o The owner of the underlying tokens\n    /// @return uint256 The amount of principal tokens burnt by the withdrawal\n    function withdraw(\n        uint256 a,\n        address r,\n        address o\n    ) external override returns (uint256) {\n        // Pre maturity\n        if (block.timestamp < maturity) {\n            uint128 shares = Cast.u128(previewWithdraw(a));\n            // If owner is the sender, sell PT without allowance check\n            if (o == msg.sender) {\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    shares,\n                    Cast.u128(a - (a / 100))\n                );\n                Safe.transfer(IERC20(underlying), r, returned);\n                return returned;\n                // Else, sell PT with allowance check\n            } else {\n                uint256 allowance = _allowance[o][msg.sender];\n                if (allowance < shares) {\n                    revert Exception(\n                        20,\n                        allowance,\n                        shares,\n                        address(0),\n                        address(0)\n                    );\n                }\n                _allowance[o][msg.sender] = allowance - shares;\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    Cast.u128(shares),\n                    Cast.u128(a - (a / 100))\n                );\n                Safe.transfer(IERC20(underlying), r, returned);\n                return returned;\n            }\n        }\n```\n\nredeem() sells the PTs held by Illuminate PT contract, if any:\n\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/tokens/ERC5095.sol#L279-L319\n\n```solidity\n    /// @notice At or after maturity, burns exactly `shares` of Principal Tokens from `owner` and sends `assets` of underlying tokens to `receiver`. Before maturity, sends `assets` by selling `shares` of PT on a YieldSpace AMM.\n    /// @param s The number of shares to be burned in exchange for the underlying asset\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param o Address of the owner of the shares being burned\n    /// @return uint256 The amount of underlying tokens distributed by the redemption\n    function redeem(\n        uint256 s,\n        address r,\n        address o\n    ) external override returns (uint256) {\n        // Pre-maturity\n        if (block.timestamp < maturity) {\n            uint128 assets = Cast.u128(previewRedeem(s));\n            // If owner is the sender, sell PT without allowance check\n            if (o == msg.sender) {\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    Cast.u128(s),\n                    assets - (assets / 100)\n                );\n                Safe.transfer(IERC20(underlying), r, returned);\n                return returned;\n                // Else, sell PT with allowance check\n            } else {\n                uint256 allowance = _allowance[o][msg.sender];\n                if (allowance < s) {\n                    revert Exception(20, allowance, s, address(0), address(0));\n                }\n                _allowance[o][msg.sender] = allowance - s;\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    Cast.u128(s),\n                    assets - (assets / 100)\n                );\n                Safe.transfer(IERC20(underlying), r, returned);\n                return returned;\n            }\n            // Post-maturity\n        } else {\n```\n\nsellPrincipalToken() both functions above invoke transfers `IERC20(address(pool.fyToken()))` from `msg.sender`, which is the calling Illuminate PT contract:\n\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Marketplace.sol#L279-L314\n\n```solidity\n    /// @notice sells the PT for the underlying via the pool\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of PTs to sell\n    /// @param s slippage cap, minimum amount of underlying that must be received\n    /// @return uint128 amount of underlying bought\n    function sellPrincipalToken(\n        address u,\n        uint256 m,\n        uint128 a,\n        uint128 s\n    ) external returns (uint128) {\n        // Get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // Preview amount of underlying received by selling `a` PTs\n        uint256 expected = pool.sellFYTokenPreview(a);\n\n        if (expected < s) {\n            revert Exception(16, expected, s, address(0), address(0));\n        }\n\n        // Transfer the principal tokens to the pool\n        Safe.transferFrom(\n            IERC20(address(pool.fyToken())),\n            msg.sender,\n            address(pool),\n            a\n        );\n\n        // Execute the swap\n        uint128 received = pool.sellFYToken(msg.sender, uint128(expected));\n        emit Swap(u, m, address(pool.fyToken()), u, received, a, msg.sender);\n\n        return received;\n    }\n```\n\nNotice that after maturity there is no need to transfer, and the burning is correctly performed by authRedeem():\n\nFor example redeem() calls authRedeem():\n\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/tokens/ERC5095.sol#L318-L344\n\n```solidity\n            // Post-maturity\n        } else {\n            if (o == msg.sender) {\n                return\n                    IRedeemer(redeemer).authRedeem(\n                        underlying,\n                        maturity,\n                        msg.sender,\n                        r,\n                        s\n                    );\n            } else {\n                uint256 allowance = _allowance[o][msg.sender];\n                if (allowance < s) {\n                    revert Exception(20, allowance, s, address(0), address(0));\n                }\n                _allowance[o][msg.sender] = allowance - s;\n                return\n                    IRedeemer(redeemer).authRedeem(\n                        underlying,\n                        maturity,\n                        o,\n                        r,\n                        s\n                    );\n            }\n        }\n```\n\nauthRedeem() burns the shares from the owner `f`:\n\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Redeemer.sol#L443-L470\n\n```solidity\n    function authRedeem(\n        address u,\n        uint256 m,\n        address f,\n        address t,\n        uint256 a\n    )\n        external\n        authorized(IMarketPlace(marketPlace).token(u, m, 0))\n        returns (uint256)\n    {\n        // Get the principal token for the given market\n        IERC5095 pt = IERC5095(IMarketPlace(marketPlace).token(u, m, 0));\n\n        // Make sure the market has matured\n        uint256 maturity = pt.maturity();\n        if (block.timestamp < maturity) {\n            revert Exception(7, maturity, 0, address(0), address(0));\n        }\n\n        // Calculate the amount redeemed\n        uint256 redeemed = (a * holdings[u][m]) / pt.totalSupply();\n\n        // Update holdings of underlying\n        holdings[u][m] = holdings[u][m] - redeemed;\n\n        // Burn the user's principal tokens\n        pt.authBurn(f, a);\n```\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider performing PT transfer before selling them via Marketplace, for example:\n\nwithdraw():\n\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/tokens/ERC5095.sol#L204-L249\n\n```solidity\n    /// @notice At or after maturity, Burns `shares` from `owner` and sends exactly `assets` of underlying tokens to `receiver`. Before maturity, sends `assets` by selling shares of PT on a YieldSpace AMM.\n    /// @param a The amount of underlying tokens withdrawn\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param o The owner of the underlying tokens\n    /// @return uint256 The amount of principal tokens burnt by the withdrawal\n    function withdraw(\n        uint256 a,\n        address r,\n        address o\n    ) external override returns (uint256) {\n        // Pre maturity\n        if (block.timestamp < maturity) {\n            uint128 shares = Cast.u128(previewWithdraw(a));\n+\t    _transfer(o, address(this), shares);\n            // If owner is the sender, sell PT without allowance check\n            if (o == msg.sender) {\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    shares,\n                    Cast.u128(a - (a / 100))\n                );\n                Safe.transfer(IERC20(underlying), r, returned);\n                return returned;\n                // Else, sell PT with allowance check\n            } else {\n                uint256 allowance = _allowance[o][msg.sender];\n                if (allowance < shares) {\n                    revert Exception(\n                        20,\n                        allowance,\n                        shares,\n                        address(0),\n                        address(0)\n                    );\n                }\n                _allowance[o][msg.sender] = allowance - shares;\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    Cast.u128(shares),\n                    Cast.u128(a - (a / 100))\n                );\n                Safe.transfer(IERC20(underlying), r, returned);\n                return returned;\n            }\n        }\n```\n\nredeem():\n\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/tokens/ERC5095.sol#L279-L319\n\n```solidity\n    /// @notice At or after maturity, burns exactly `shares` of Principal Tokens from `owner` and sends `assets` of underlying tokens to `receiver`. Before maturity, sends `assets` by selling `shares` of PT on a YieldSpace AMM.\n    /// @param s The number of shares to be burned in exchange for the underlying asset\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param o Address of the owner of the shares being burned\n    /// @return uint256 The amount of underlying tokens distributed by the redemption\n    function redeem(\n        uint256 s,\n        address r,\n        address o\n    ) external override returns (uint256) {\n        // Pre-maturity\n        if (block.timestamp < maturity) {\n+\t    _transfer(o, address(this), s);\n            uint128 assets = Cast.u128(previewRedeem(s));\n            // If owner is the sender, sell PT without allowance check\n            if (o == msg.sender) {\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    Cast.u128(s),\n                    assets - (assets / 100)\n                );\n                Safe.transfer(IERC20(underlying), r, returned);\n                return returned;\n                // Else, sell PT with allowance check\n            } else {\n                uint256 allowance = _allowance[o][msg.sender];\n                if (allowance < s) {\n                    revert Exception(20, allowance, s, address(0), address(0));\n                }\n                _allowance[o][msg.sender] = allowance - s;\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    Cast.u128(s),\n                    assets - (assets / 100)\n                );\n                Safe.transfer(IERC20(underlying), r, returned);\n                return returned;\n            }\n            // Post-maturity\n        } else {\n```\n\n## Discussion\n\n**Evert0x**\n\n@sourabhmarathe I would like to know why you disagree with severity, seems like a valid high to me. \n\n**IllIllI000**\n\nI believe the ERC5095 doesn't normally hold any balance. The tests in https://github.com/sherlock-audit/2022-10-illuminate-judging/issues/71 use `deal()` to give it a balance, which wouldn't happen in reality. The bug here looks to be that `withdraw()` will fail before maturity since `MarketPlace.sellPrincipalToken()` won't have any balance to pull out of the ERC5095. As the submitter mentions, `MarketPlace` can be called by the holder directly in order to sell before maturity, so the function is broken, but there's a workaround. @sourabhmarathe please correct me if I'm mistaken\n\n**sourabhmarathe**\n\nOriginally, I felt that this did not put user funds at risk but certainly agreed with the report (I believe we have a fix for it). However, it seems like this is a serious enough problem where we can keep the severity level High. I removed the dispute label.\n\n**0x00052**\n\nEscalate for 10 USDC\n\nDon't agree with high severity. ERC5095 normally doesn't hold any balance so any balance in the contract to be \"stolen\" was accidentally sent there. Agreed that withdraw/redeem won't work pre-maturity but given that it is basically just a wrapper on Marketplace#sellPrincipleToken, users can just use that instead. Medium seems more appropriate given that users have alternatives to sell pre-maturity and no funds are at risk\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> Don't agree with high severity. ERC5095 normally doesn't hold any balance so any balance in the contract to be \"stolen\" was accidentally sent there. Agreed that withdraw/redeem won't work pre-maturity but given that it is basically just a wrapper on Marketplace#sellPrincipleToken, users can just use that instead. Medium seems more appropriate given that users have alternatives to sell pre-maturity and no funds are at risk\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/12",
  "Code": [
    {
      "filename": "src/tokens/ERC5095.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport 'src/tokens/ERC20Permit.sol';\nimport 'src/interfaces/IERC5095.sol';\nimport 'src/interfaces/IRedeemer.sol';\nimport 'src/interfaces/IMarketPlace.sol';\nimport 'src/interfaces/IYield.sol';\nimport 'src/errors/Exception.sol';\nimport 'src/lib/Cast.sol';\nimport 'src/lib/Safe.sol';\n\ncontract ERC5095 is ERC20Permit, IERC5095 {\n    /// @dev unix timestamp when the ERC5095 token can be redeemed\n    uint256 public immutable override maturity;\n    /// @dev address of the ERC20 token that is returned on ERC5095 redemption\n    address public immutable override underlying;\n    /// @dev address of the minting authority\n    address public immutable lender;\n    /// @dev address of the \"marketplace\" YieldSpace AMM router\n    address public immutable marketplace;\n    ///@dev Interface to interact with the pool\n    address public immutable pool;\n\n    /// @dev address and interface for an external custody contract (necessary for some project's backwards compatability)\n    address public immutable redeemer;\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Exception(0, 0, 0, msg.sender, a);\n        }\n        _;\n    }\n\n    constructor(\n        address _underlying,\n        uint256 _maturity,\n        address _redeemer,\n        address _lender,\n        address _marketplace,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) ERC20Permit(name_, symbol_, decimals_) {\n        underlying = _underlying;\n        maturity = _maturity;\n        redeemer = _redeemer;\n        lender = _lender;\n        marketplace = _marketplace;\n        pool = IMarketPlace(marketplace).pools(underlying, maturity);\n    }\n\n    /// @notice Post or at maturity converts an amount of principal tokens to an amount of underlying that would be returned.\n    /// @param s The amount of principal tokens to convert\n    /// @return uint256 The amount of underlying tokens returned by the conversion\n    function convertToUnderlying(uint256 s)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (block.timestamp < maturity) {\n            return previewRedeem(s);\n        }\n        return s;\n    }\n\n    /// @notice Post or at maturity converts a desired amount of underlying tokens returned to principal tokens needed.\n    /// @param a The amount of underlying tokens to convert\n    /// @return uint256 The amount of principal tokens returned by the conversion\n    function convertToShares(uint256 a)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (block.timestamp < maturity) {\n            return previewWithdraw(a);\n        }\n        return a;\n    }\n\n    /// @notice Post or at maturity returns user's PT balance. Pre maturity, returns a previewRedeem for owner's PT balance.\n    /// @param o The address of the owner for which redemption is calculated\n    /// @return uint256 The maximum amount of principal tokens that `owner` can redeem.\n    function maxRedeem(address o) external view override returns (uint256) {\n        if (block.timestamp < maturity) {\n            return previewRedeem(_balanceOf[o]);\n        }\n        return _balanceOf[o];\n    }\n\n    /// @notice Post or at maturity returns user's PT balance. Pre maturity, returns a previewWithdraw for owner's PT balance.\n    /// @param  o The address of the owner for which withdrawal is calculated\n    /// @return uint256 maximum amount of underlying tokens that `owner` can withdraw.\n    function maxWithdraw(address o) external view override returns (uint256) {\n        if (block.timestamp < maturity) {\n            return previewWithdraw(_balanceOf[address(this)]);\n        }\n        return _balanceOf[o];\n    }\n\n    /// @notice Post or at maturity returns 0. Pre maturity returns the amount of `shares` when spending `assets` in underlying on a YieldSpace AMM.\n    /// @param a The amount of underlying spent\n    /// @return uint256 The amount of PT purchased by spending `assets` of underlying\n    function previewDeposit(uint256 a) public view returns (uint256) {\n        if (block.timestamp < maturity) {\n            return IYield(pool).sellBasePreview(Cast.u128(a));\n        }\n        return 0;\n    }\n\n    /// @notice Post or at maturity returns 0. Pre maturity returns the amount of `assets` in underlying spent on a purchase of `shares` in PT on a YieldSpace AMM.\n    /// @param s the amount of principal tokens bought in the simulation\n    /// @return uint256 The amount of underlying spent to purchase `shares` of PT\n    function previewMint(uint256 s) public view returns (uint256) {\n        if (block.timestamp < maturity) {\n            return IYield(pool).buyFYTokenPreview(Cast.u128(s));\n        }\n        return 0;\n    }\n\n    /// @notice Post or at maturity simulates the effects of redeemption at the current block. Pre maturity returns the amount of `assets from a sale of `shares` in PT from a sale of PT on a YieldSpace AMM.\n    /// @param s the amount of principal tokens redeemed in the simulation\n    /// @return uint256 The amount of underlying returned by `shares` of PT redemption\n    function previewRedeem(uint256 s) public view override returns (uint256) {\n        if (block.timestamp > maturity) {\n            return s;\n        }\n        return IYield(pool).sellFYTokenPreview(Cast.u128(s));\n    }\n\n    /// @notice Post or at maturity simulates the effects of withdrawal at the current block. Pre maturity simulates the amount of `shares` in PT necessary to receive `assets` in underlying from a sale of PT on a YieldSpace AMM.\n    /// @param a the amount of underlying tokens withdrawn in the simulation\n    /// @return uint256 The amount of principal tokens required for the withdrawal of `assets`\n    function previewWithdraw(uint256 a) public view override returns (uint256) {\n        if (block.timestamp > maturity) {\n            return a;\n        }\n        return IYield(pool).buyBasePreview(Cast.u128(a));\n    }\n\n    /// @notice Before maturity spends `assets` of underlying, and sends `shares` of PTs to `receiver`. Post or at maturity, reverts.\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param a The amount of underlying tokens withdrawn\n    /// @return uint256 The amount of principal tokens burnt by the withdrawal\n    function deposit(address r, uint256 a) external override returns (uint256) {\n        if (block.timestamp > maturity) {\n            revert Exception(\n                21,\n                block.timestamp,\n                maturity,\n                address(0),\n                address(0)\n            );\n        }\n        uint128 shares = Cast.u128(previewDeposit(a));\n        Safe.transferFrom(IERC20(underlying), msg.sender, address(this), a);\n        // consider the hardcoded slippage limit, 4626 compliance requires no minimum param.\n        uint128 returned = IMarketPlace(marketplace).sellUnderlying(\n            underlying,\n            maturity,\n            Cast.u128(a),\n            shares - (shares / 100)\n        );\n        _transfer(address(this), r, returned);\n        return returned;\n    }\n\n    /// @notice Before maturity mints `shares` of PTs to `receiver` and spending `assets` of underlying. Post or at maturity, reverts.\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param s The amount of underlying tokens withdrawn\n    /// @return uint256 The amount of principal tokens burnt by the withdrawal\n    function mint(address r, uint256 s) external override returns (uint256) {\n        if (block.timestamp > maturity) {\n            revert Exception(\n                21,\n                block.timestamp,\n                maturity,\n                address(0),\n                address(0)\n            );\n        }\n        uint128 assets = Cast.u128(previewMint(s));\n        Safe.transferFrom(\n            IERC20(underlying),\n            msg.sender,\n            address(this),\n            assets\n        );\n        // consider the hardcoded slippage limit, 4626 compliance requires no minimum param.\n        uint128 returned = IMarketPlace(marketplace).sellUnderlying(\n            underlying,\n            maturity,\n            assets,\n            assets - (assets / 100)\n        );\n        _transfer(address(this), r, returned);\n        return returned;\n    }\n\n    /// @notice At or after maturity, Burns `shares` from `owner` and sends exactly `assets` of underlying tokens to `receiver`. Before maturity, sends `assets` by selling shares of PT on a YieldSpace AMM.\n    /// @param a The amount of underlying tokens withdrawn\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param o The owner of the underlying tokens\n    /// @return uint256 The amount of principal tokens burnt by the withdrawal\n    function withdraw(\n        uint256 a,\n        address r,\n        address o\n    ) external override returns (uint256) {\n        // Pre maturity\n        if (block.timestamp < maturity) {\n            uint128 shares = Cast.u128(previewWithdraw(a));\n            // If owner is the sender, sell PT without allowance check\n            if (o == msg.sender) {\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    shares,\n                    Cast.u128(a - (a / 100))\n                );\n                Safe.transfer(IERC20(underlying), r, returned);\n                return returned;\n                // Else, sell PT with allowance check\n            } else {\n                uint256 allowance = _allowance[o][msg.sender];\n                if (allowance < shares) {\n                    revert Exception(\n                        20,\n                        allowance,\n                        shares,\n                        address(0),\n                        address(0)\n                    );\n                }\n                _allowance[o][msg.sender] = allowance - shares;\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    Cast.u128(shares),\n                    Cast.u128(a - (a / 100))\n                );\n                Safe.transfer(IERC20(underlying), r, returned);\n                return returned;\n            }\n        }\n        // Post maturity\n        else {\n            if (o == msg.sender) {\n                return\n                    IRedeemer(redeemer).authRedeem(\n                        underlying,\n                        maturity,\n                        msg.sender,\n                        r,\n                        a\n                    );\n            } else {\n                uint256 allowance = _allowance[o][msg.sender];\n                if (allowance < a) {\n                    revert Exception(20, allowance, a, address(0), address(0));\n                }\n                _allowance[o][msg.sender] = allowance - a;\n                return\n                    IRedeemer(redeemer).authRedeem(\n                        underlying,\n                        maturity,\n                        o,\n                        r,\n                        a\n                    );\n            }\n        }\n    }\n\n    /// @notice At or after maturity, burns exactly `shares` of Principal Tokens from `owner` and sends `assets` of underlying tokens to `receiver`. Before maturity, sends `assets` by selling `shares` of PT on a YieldSpace AMM.\n    /// @param s The number of shares to be burned in exchange for the underlying asset\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param o Address of the owner of the shares being burned\n    /// @return uint256 The amount of underlying tokens distributed by the redemption\n    function redeem(\n        uint256 s,\n        address r,\n        address o\n    ) external override returns (uint256) {\n        // Pre-maturity\n        if (block.timestamp < maturity) {\n            uint128 assets = Cast.u128(previewRedeem(s));\n            // If owner is the sender, sell PT without allowance check\n            if (o == msg.sender) {\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    Cast.u128(s),\n                    assets - (assets / 100)\n                );\n                Safe.transfer(IERC20(underlying), r, returned);\n                return returned;\n                // Else, sell PT with allowance check\n            } else {\n                uint256 allowance = _allowance[o][msg.sender];\n                if (allowance < s) {\n                    revert Exception(20, allowance, s, address(0), address(0));\n                }\n                _allowance[o][msg.sender] = allowance - s;\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    Cast.u128(s),\n                    assets - (assets / 100)\n                );\n                Safe.transfer(IERC20(underlying), r, returned);\n                return returned;\n            }\n            // Post-maturity\n        } else {\n            if (o == msg.sender) {\n                return\n                    IRedeemer(redeemer).authRedeem(\n                        underlying,\n                        maturity,\n                        msg.sender,\n                        r,\n                        s\n                    );\n            } else {\n                uint256 allowance = _allowance[o][msg.sender];\n                if (allowance < s) {\n                    revert Exception(20, allowance, s, address(0), address(0));\n                }\n                _allowance[o][msg.sender] = allowance - s;\n                return\n                    IRedeemer(redeemer).authRedeem(\n                        underlying,\n                        maturity,\n                        o,\n                        r,\n                        s\n                    );\n            }\n        }\n    }\n\n    /// @param f Address to burn from\n    /// @param a Amount to burn\n    /// @return bool true if successful\n    function authBurn(address f, uint256 a)\n        external\n        authorized(redeemer)\n        returns (bool)\n    {\n        _burn(f, a);\n        return true;\n    }\n\n    /// @param t Address recieving the minted amount\n    /// @param a The amount to mint\n    /// @return bool true if successful\n    function authMint(address t, uint256 a)\n        external\n        authorized(lender)\n        returns (bool)\n    {\n        _mint(t, a);\n        return true;\n    }\n}"
    },
    {
      "filename": "src/tokens/ERC5095.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport 'src/tokens/ERC20Permit.sol';\nimport 'src/interfaces/IERC5095.sol';\nimport 'src/interfaces/IRedeemer.sol';\nimport 'src/interfaces/IMarketPlace.sol';\nimport 'src/interfaces/IYield.sol';\nimport 'src/errors/Exception.sol';\nimport 'src/lib/Cast.sol';\nimport 'src/lib/Safe.sol';\n\ncontract ERC5095 is ERC20Permit, IERC5095 {\n    /// @dev unix timestamp when the ERC5095 token can be redeemed\n    uint256 public immutable override maturity;\n    /// @dev address of the ERC20 token that is returned on ERC5095 redemption\n    address public immutable override underlying;\n    /// @dev address of the minting authority\n    address public immutable lender;\n    /// @dev address of the \"marketplace\" YieldSpace AMM router\n    address public immutable marketplace;\n    ///@dev Interface to interact with the pool\n    address public immutable pool;\n\n    /// @dev address and interface for an external custody contract (necessary for some project's backwards compatability)\n    address public immutable redeemer;\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Exception(0, 0, 0, msg.sender, a);\n        }\n        _;\n    }\n\n    constructor(\n        address _underlying,\n        uint256 _maturity,\n        address _redeemer,\n        address _lender,\n        address _marketplace,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) ERC20Permit(name_, symbol_, decimals_) {\n        underlying = _underlying;\n        maturity = _maturity;\n        redeemer = _redeemer;\n        lender = _lender;\n        marketplace = _marketplace;\n        pool = IMarketPlace(marketplace).pools(underlying, maturity);\n    }\n\n    /// @notice Post or at maturity converts an amount of principal tokens to an amount of underlying that would be returned.\n    /// @param s The amount of principal tokens to convert\n    /// @return uint256 The amount of underlying tokens returned by the conversion\n    function convertToUnderlying(uint256 s)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (block.timestamp < maturity) {\n            return previewRedeem(s);\n        }\n        return s;\n    }\n\n    /// @notice Post or at maturity converts a desired amount of underlying tokens returned to principal tokens needed.\n    /// @param a The amount of underlying tokens to convert\n    /// @return uint256 The amount of principal tokens returned by the conversion\n    function convertToShares(uint256 a)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (block.timestamp < maturity) {\n            return previewWithdraw(a);\n        }\n        return a;\n    }\n\n    /// @notice Post or at maturity returns user's PT balance. Pre maturity, returns a previewRedeem for owner's PT balance.\n    /// @param o The address of the owner for which redemption is calculated\n    /// @return uint256 The maximum amount of principal tokens that `owner` can redeem.\n    function maxRedeem(address o) external view override returns (uint256) {\n        if (block.timestamp < maturity) {\n            return previewRedeem(_balanceOf[o]);\n        }\n        return _balanceOf[o];\n    }\n\n    /// @notice Post or at maturity returns user's PT balance. Pre maturity, returns a previewWithdraw for owner's PT balance.\n    /// @param  o The address of the owner for which withdrawal is calculated\n    /// @return uint256 maximum amount of underlying tokens that `owner` can withdraw.\n    function maxWithdraw(address o) external view override returns (uint256) {\n        if (block.timestamp < maturity) {\n            return previewWithdraw(_balanceOf[address(this)]);\n        }\n        return _balanceOf[o];\n    }\n\n    /// @notice Post or at maturity returns 0. Pre maturity returns the amount of `shares` when spending `assets` in underlying on a YieldSpace AMM.\n    /// @param a The amount of underlying spent\n    /// @return uint256 The amount of PT purchased by spending `assets` of underlying\n    function previewDeposit(uint256 a) public view returns (uint256) {\n        if (block.timestamp < maturity) {\n            return IYield(pool).sellBasePreview(Cast.u128(a));\n        }\n        return 0;\n    }\n\n    /// @notice Post or at maturity returns 0. Pre maturity returns the amount of `assets` in underlying spent on a purchase of `shares` in PT on a YieldSpace AMM.\n    /// @param s the amount of principal tokens bought in the simulation\n    /// @return uint256 The amount of underlying spent to purchase `shares` of PT\n    function previewMint(uint256 s) public view returns (uint256) {\n        if (block.timestamp < maturity) {\n            return IYield(pool).buyFYTokenPreview(Cast.u128(s));\n        }\n        return 0;\n    }\n\n    /// @notice Post or at maturity simulates the effects of redeemption at the current block. Pre maturity returns the amount of `assets from a sale of `shares` in PT from a sale of PT on a YieldSpace AMM.\n    /// @param s the amount of principal tokens redeemed in the simulation\n    /// @return uint256 The amount of underlying returned by `shares` of PT redemption\n    function previewRedeem(uint256 s) public view override returns (uint256) {\n        if (block.timestamp > maturity) {\n            return s;\n        }\n        return IYield(pool).sellFYTokenPreview(Cast.u128(s));\n    }\n\n    /// @notice Post or at maturity simulates the effects of withdrawal at the current block. Pre maturity simulates the amount of `shares` in PT necessary to receive `assets` in underlying from a sale of PT on a YieldSpace AMM.\n    /// @param a the amount of underlying tokens withdrawn in the simulation\n    /// @return uint256 The amount of principal tokens required for the withdrawal of `assets`\n    function previewWithdraw(uint256 a) public view override returns (uint256) {\n        if (block.timestamp > maturity) {\n            return a;\n        }\n        return IYield(pool).buyBasePreview(Cast.u128(a));\n    }\n\n    /// @notice Before maturity spends `assets` of underlying, and sends `shares` of PTs to `receiver`. Post or at maturity, reverts.\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param a The amount of underlying tokens withdrawn\n    /// @return uint256 The amount of principal tokens burnt by the withdrawal\n    function deposit(address r, uint256 a) external override returns (uint256) {\n        if (block.timestamp > maturity) {\n            revert Exception(\n                21,\n                block.timestamp,\n                maturity,\n                address(0),\n                address(0)\n            );\n        }\n        uint128 shares = Cast.u128(previewDeposit(a));\n        Safe.transferFrom(IERC20(underlying), msg.sender, address(this), a);\n        // consider the hardcoded slippage limit, 4626 compliance requires no minimum param.\n        uint128 returned = IMarketPlace(marketplace).sellUnderlying(\n            underlying,\n            maturity,\n            Cast.u128(a),\n            shares - (shares / 100)\n        );\n        _transfer(address(this), r, returned);\n        return returned;\n    }\n\n    /// @notice Before maturity mints `shares` of PTs to `receiver` and spending `assets` of underlying. Post or at maturity, reverts.\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param s The amount of underlying tokens withdrawn\n    /// @return uint256 The amount of principal tokens burnt by the withdrawal\n    function mint(address r, uint256 s) external override returns (uint256) {\n        if (block.timestamp > maturity) {\n            revert Exception(\n                21,\n                block.timestamp,\n                maturity,\n                address(0),\n                address(0)\n            );\n        }\n        uint128 assets = Cast.u128(previewMint(s));\n        Safe.transferFrom(\n            IERC20(underlying),\n            msg.sender,\n            address(this),\n            assets\n        );\n        // consider the hardcoded slippage limit, 4626 compliance requires no minimum param.\n        uint128 returned = IMarketPlace(marketplace).sellUnderlying(\n            underlying,\n            maturity,\n            assets,\n            assets - (assets / 100)\n        );\n        _transfer(address(this), r, returned);\n        return returned;\n    }\n\n    /// @notice At or after maturity, Burns `shares` from `owner` and sends exactly `assets` of underlying tokens to `receiver`. Before maturity, sends `assets` by selling shares of PT on a YieldSpace AMM.\n    /// @param a The amount of underlying tokens withdrawn\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param o The owner of the underlying tokens\n    /// @return uint256 The amount of principal tokens burnt by the withdrawal\n    function withdraw(\n        uint256 a,\n        address r,\n        address o\n    ) external override returns (uint256) {\n        // Pre maturity\n        if (block.timestamp < maturity) {\n            uint128 shares = Cast.u128(previewWithdraw(a));\n            // If owner is the sender, sell PT without allowance check\n            if (o == msg.sender) {\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    shares,\n                    Cast.u128(a - (a / 100))\n                );\n                Safe.transfer(IERC20(underlying), r, returned);\n                return returned;\n                // Else, sell PT with allowance check\n            } else {\n                uint256 allowance = _allowance[o][msg.sender];\n                if (allowance < shares) {\n                    revert Exception(\n                        20,\n                        allowance,\n                        shares,\n                        address(0),\n                        address(0)\n                    );\n                }\n                _allowance[o][msg.sender] = allowance - shares;\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    Cast.u128(shares),\n                    Cast.u128(a - (a / 100))\n                );\n                Safe.transfer(IERC20(underlying), r, returned);\n                return returned;\n            }\n        }\n        // Post maturity\n        else {\n            if (o == msg.sender) {\n                return\n                    IRedeemer(redeemer).authRedeem(\n                        underlying,\n                        maturity,\n                        msg.sender,\n                        r,\n                        a\n                    );\n            } else {\n                uint256 allowance = _allowance[o][msg.sender];\n                if (allowance < a) {\n                    revert Exception(20, allowance, a, address(0), address(0));\n                }\n                _allowance[o][msg.sender] = allowance - a;\n                return\n                    IRedeemer(redeemer).authRedeem(\n                        underlying,\n                        maturity,\n                        o,\n                        r,\n                        a\n                    );\n            }\n        }\n    }\n\n    /// @notice At or after maturity, burns exactly `shares` of Principal Tokens from `owner` and sends `assets` of underlying tokens to `receiver`. Before maturity, sends `assets` by selling `shares` of PT on a YieldSpace AMM.\n    /// @param s The number of shares to be burned in exchange for the underlying asset\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param o Address of the owner of the shares being burned\n    /// @return uint256 The amount of underlying tokens distributed by the redemption\n    function redeem(\n        uint256 s,\n        address r,\n        address o\n    ) external override returns (uint256) {\n        // Pre-maturity\n        if (block.timestamp < maturity) {\n            uint128 assets = Cast.u128(previewRedeem(s));\n            // If owner is the sender, sell PT without allowance check\n            if (o == msg.sender) {\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    Cast.u128(s),\n                    assets - (assets / 100)\n                );\n                Safe.transfer(IERC20(underlying), r, returned);\n                return returned;\n                // Else, sell PT with allowance check\n            } else {\n                uint256 allowance = _allowance[o][msg.sender];\n                if (allowance < s) {\n                    revert Exception(20, allowance, s, address(0), address(0));\n                }\n                _allowance[o][msg.sender] = allowance - s;\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    Cast.u128(s),\n                    assets - (assets / 100)\n                );\n                Safe.transfer(IERC20(underlying), r, returned);\n                return returned;\n            }\n            // Post-maturity\n        } else {\n            if (o == msg.sender) {\n                return\n                    IRedeemer(redeemer).authRedeem(\n                        underlying,\n                        maturity,\n                        msg.sender,\n                        r,\n                        s\n                    );\n            } else {\n                uint256 allowance = _allowance[o][msg.sender];\n                if (allowance < s) {\n                    revert Exception(20, allowance, s, address(0), address(0));\n                }\n                _allowance[o][msg.sender] = allowance - s;\n                return\n                    IRedeemer(redeemer).authRedeem(\n                        underlying,\n                        maturity,\n                        o,\n                        r,\n                        s\n                    );\n            }\n        }\n    }\n\n    /// @param f Address to burn from\n    /// @param a Amount to burn\n    /// @return bool true if successful\n    function authBurn(address f, uint256 a)\n        external\n        authorized(redeemer)\n        returns (bool)\n    {\n        _burn(f, a);\n        return true;\n    }\n\n    /// @param t Address recieving the minted amount\n    /// @param a The amount to mint\n    /// @return bool true if successful\n    function authMint(address t, uint256 a)\n        external\n        authorized(lender)\n        returns (bool)\n    {\n        _mint(t, a);\n        return true;\n    }\n}"
    },
    {
      "filename": "src/Marketplace.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\nimport 'src/tokens/ERC5095.sol';\nimport 'src/lib/Safe.sol';\nimport 'src/lib/RevertMsgExtractor.sol';\n\nimport 'src/interfaces/ILender.sol';\nimport 'src/interfaces/IPool.sol';\nimport 'src/interfaces/IPendleToken.sol';\nimport 'src/interfaces/IAPWineToken.sol';\nimport 'src/interfaces/IAPWineFutureVault.sol';\n\nimport 'src/errors/Exception.sol';\n\n/// @title MarketPlace\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice This contract is in charge of managing the available principals for each loan market.\n/// @notice In addition, this contract routes swap orders between Illuminate PTs and their respective underlying to YieldSpace pools.\ncontract MarketPlace {\n    /// @notice the available principals\n    /// @dev the order of this enum is used to select principals from the markets\n    /// mapping (e.g. Illuminate => 0, Swivel => 1, and so on)\n    enum Principals {\n        Illuminate, // 0\n        Swivel, // 1\n        Yield, // 2\n        Element, // 3\n        Pendle, // 4\n        Tempus, // 5\n        Sense, // 6\n        Apwine, // 7\n        Notional // 8\n    }\n\n    /// @notice markets are defined by a tuple that points to a fixed length array of principal token addresses.\n    mapping(address => mapping(uint256 => address[9])) public markets;\n\n    /// @notice pools map markets to their respective YieldSpace pools for the MetaPrincipal token\n    mapping(address => mapping(uint256 => address)) public pools;\n\n    /// @notice address that is allowed to create markets, set pools, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the deployed redeemer contract\n    address public immutable redeemer;\n    /// @notice address of the deployed lender contract\n    address public immutable lender;\n\n    /// @notice emitted upon the creation of a new market\n    event CreateMarket(\n        address indexed underlying,\n        uint256 indexed maturity,\n        address[9] tokens,\n        address element,\n        address apwine\n    );\n    /// @notice emitted upon setting a principal token\n    event SetPrincipal(\n        address indexed underlying,\n        uint256 indexed maturity,\n        address indexed principal,\n        uint8 protocol\n    );\n    /// @notice emitted upon swapping with the pool\n    event Swap(\n        address indexed underlying,\n        uint256 indexed maturity,\n        address sold,\n        address bought,\n        uint256 received,\n        uint256 spent,\n        address spender\n    );\n    /// @notice emitted upon minting tokens with the pool\n    event Mint(\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 underlyingIn,\n        uint256 principalTokensIn,\n        uint256 minted,\n        address minter\n    );\n    /// @notice emitted upon burning tokens with the pool\n    event Burn(\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 tokensBurned,\n        uint256 underlyingReceived,\n        uint256 principalTokensReceived,\n        address burner\n    );\n    /// @notice emitted upon changing the admin\n    event"
    }
  ]
}