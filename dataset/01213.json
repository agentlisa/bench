{
  "Title": "Incomplete Test Coverage",
  "Content": "\nWhile the overall coverage is close to 100%, there are several lines of code lacking test  \ncoverage:\n\n\n* In the [`ExclusiveDutchOrderReactor` contract](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/reactors/ExclusiveDutchOrderReactor.sol#L79:L87), the validation logic is not tested for orders with input decay. Consider adding at least one succeeding and one reverting test case with input decay to the [`ExclusiveDutchOrderReactor` test file](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/test/reactors/ExclusiveDutchOrderReactor.t.sol).\n* In the [`ProtocolFees` contract](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/base/ProtocolFees.sol#L84:L86), the `_injectFees` function is not tested for input fees.\n\n\nTo further enhance the quality of the tests, here are some suggested improvements:\n\n\n\n\n\n* Add tests of `[executeBatch](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/reactors/BaseReactor.sol#L59)` for `ExclusiveDutchOrders` (already present for `DutchOrder` and `LimitOrder`).\n* Add integration tests for limit orders and exclusive Dutch orders since currently only the Dutch order reactor is being integration-tested.\n\n\n\n\n\n***Update:** Resolved in [pull request #197](https://github.com/Uniswap/UniswapX/pull/197) at commit [e327540](https://github.com/Uniswap/UniswapX/commit/e327540e0490b33c019d42dca5c988989e2b031a) by adding tests for input fees and exclusive Dutch auctions with decaying input. The Uniswap team explained that additional integration tests are expected to be added in the future.*\n\n\n\n### Redundant Code\n\n\n\n\n\n\nRedundant code reduces the protocol's gas efficiency, especially when considering on-chain trading, as it impacts the filler's profit and the swapper's execution price. The following opportunities have been identified for potential enhancements: \n\n\n* Checking the [order expiration](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/lib/ResolvedOrderLib.sol#L21-L23) is redundant since the [same check](https://github.com/Uniswap/permit2/blob/576f549a7351814f112edcc42f3f8472d1712673/src/SignatureTransfer.sol#L60) is performed when calling `permitTransferFrom` on the `Permit2` contract afterwards. These deadlines are the same value, as set through the [`Permit2Lib`](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/lib/Permit2Lib.sol#L22). Removing this check makes successful trades more gas-optimized while reverting trades will use a bit more gas.\n* The exclusive Dutch order reactor does not have to [validate](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/reactors/ExclusiveDutchOrderReactor.sol#L75-L77) that `endDecayTime` is larger than or equal to `startDecayTime`, since it will be validated again when applying the `[decay](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/lib/DutchDecayLib.sol#L31-L32)`.\n* The `CurrencyLibrary` implements a [`balanceOf` function](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/lib/CurrencyLibrary.sol#L24-L30) that is not used throughout the protocol. Consider removing unused code to improve the readability.\n\n\nConsider applying the suggested changes in order to make the code more efficient. Note that for the removed checks, it is important to document where the actual check is performed.\n\n\n\n\n\n***Update:** Resolved in [pull request #195](https://github.com/Uniswap/UniswapX/pull/195) at commit [36a0a28](https://github.com/Uniswap/UniswapX/commit/36a0a28917aa093290d9e57951a21fb32195dcd2). The `balanceOf` function of the `CurrencyLibrary` was not removed since it might be used by the fill contracts.*\n\n\n\n### Magic Numbers\n\n\n\n\nIn the `OrderQuoter` contract, there are occurrences of literal values with unexplained  \nmeanings:\n\n\n* [`ORDER_INFO_OFFSET = 64`](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/lens/OrderQuoter.sol#L15), which is used to skip a bytes length and struct offset slot to point to the offset slot of the inner `OrderInfo` struct. In addition, it lacks an explicitly declared visibility.\n* `[reason.length < 192](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/lens/OrderQuoter.sol#L43)`, which checks whether `reason` is less than 6 slots to distinguish a revert reason from an encoded order. Note that the `OrderInfo` struct has a minimal encoded length of 8 slots to account for the struct and dynamic bytes offsets.\n\n\nConsider documenting these numbers to improve the readability of the codebase.\n\n\n***Update:** Resolved in [pull request #196](https://github.com/Uniswap/UniswapX/pull/196) at commit [2b881d4](https://github.com/Uniswap/UniswapX/commit/2b881d4cf7d026150190cc81467a395844ac0d70).*\n\n\n\n\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/reactors/ExclusiveDutchOrderReactor.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {BaseReactor} from \"./BaseReactor.sol\";\nimport {IPermit2} from \"permit2/src/interfaces/IPermit2.sol\";\nimport {ExclusivityOverrideLib} from \"../lib/ExclusivityOverrideLib.sol\";\nimport {Permit2Lib} from \"../lib/Permit2Lib.sol\";\nimport {DutchDecayLib} from \"../lib/DutchDecayLib.sol\";\nimport {ExclusiveDutchOrderLib, ExclusiveDutchOrder, DutchOutput, DutchInput} from \"../lib/ExclusiveDutchOrderLib.sol\";\nimport {SignedOrder, ResolvedOrder, OrderInfo} from \"../base/ReactorStructs.sol\";\n\n/// @notice Reactor for exclusive dutch orders\ncontract ExclusiveDutchOrderReactor is BaseReactor {\n    using Permit2Lib for ResolvedOrder;\n    using ExclusiveDutchOrderLib for ExclusiveDutchOrder;\n    using DutchDecayLib for DutchOutput[];\n    using DutchDecayLib for DutchInput;\n    using ExclusivityOverrideLib for ResolvedOrder;\n\n    /// @notice thrown when an order's deadline is before its end time\n    error DeadlineBeforeEndTime();\n\n    /// @notice thrown when an order's end time is before its start time\n    error OrderEndTimeBeforeStartTime();\n\n    /// @notice thrown when an order's inputs and outputs both decay\n    error InputAndOutputDecay();\n\n    constructor(IPermit2 _permit2, address _protocolFeeOwner) BaseReactor(_permit2, _protocolFeeOwner) {}\n\n    /// @inheritdoc BaseReactor\n    function resolve(SignedOrder calldata signedOrder)\n        internal\n        view\n        virtual\n        override\n        returns (ResolvedOrder memory resolvedOrder)\n    {\n        ExclusiveDutchOrder memory order = abi.decode(signedOrder.order, (ExclusiveDutchOrder));\n        _validateOrder(order);\n\n        resolvedOrder = ResolvedOrder({\n            info: order.info,\n            input: order.input.decay(order.decayStartTime, order.decayEndTime),\n            outputs: order.outputs.decay(order.decayStartTime, order.decayEndTime),\n            sig: signedOrder.sig,\n            hash: order.hash()\n        });\n        resolvedOrder.handleOverride(order.exclusiveFiller, order.decayStartTime, order.exclusivityOverrideBps);\n    }\n\n    /// @inheritdoc BaseReactor\n    function transferInputTokens(ResolvedOrder memory order, address to) internal override {\n        permit2.permitWitnessTransferFrom(\n            order.toPermit(),\n            order.transferDetails(to),\n            order.info.swapper,\n            order.hash,\n            ExclusiveDutchOrderLib.PERMIT2_ORDER_TYPE,\n            order.sig\n        );\n    }\n\n    /// @notice validate the dutch order fields\n    /// - deadline must be greater than or equal than decayEndTime\n    /// - decayEndTime must be greater than or equal to decayStartTime\n    /// - if there's input decay, outputs must not decay\n    /// - for input decay, startAmount must < endAmount\n    /// @dev Throws if the order is invalid\n    function _validateOrder(ExclusiveDutchOrder memory order) internal pure {\n        if (order.info.deadline < order.decayEndTime) {\n            revert DeadlineBeforeEndTime();\n        }\n\n        if (order.decayEndTime < order.decayStartTime) {\n            revert OrderEndTimeBeforeStartTime();\n        }\n\n        if (order.input.startAmount != order.input.endAmount) {\n            unchecked {\n                for (uint256 i = 0; i < order.outputs.length; i++) {\n                    if (order.outputs[i].startAmount != order.outputs[i].endAmount) {\n                        revert InputAndOutputDecay();\n                    }\n                }\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/base/ProtocolFees.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {Owned} from \"solmate/src/auth/Owned.sol\";\nimport {SafeTransferLib} from \"solmate/src/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport {ERC20} from \"solmate/src/tokens/ERC20.sol\";\nimport {IProtocolFeeController} from \"../interfaces/IProtocolFeeController.sol\";\nimport {CurrencyLibrary} from \"../lib/CurrencyLibrary.sol\";\nimport {ResolvedOrder, OutputToken} from \"../base/ReactorStructs.sol\";\n\n/// @notice Handling for protocol fees\nabstract contract ProtocolFees is Owned {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n    using CurrencyLibrary for address;\n\n    /// @notice thrown if two fee outputs have the same token\n    error DuplicateFeeOutput(address duplicateToken);\n    /// @notice thrown if a given fee output is greater than MAX_FEE_BPS of the order outputs\n    error FeeTooLarge(address token, uint256 amount, address recipient);\n    /// @notice thrown if a fee output token does not have a corresponding non-fee output\n    error InvalidFeeToken(address feeToken);\n\n    event ProtocolFeeControllerSet(address oldFeeController, address newFeeController);\n\n    uint256 private constant BPS = 10_000;\n    uint256 private constant MAX_FEE_BPS = 5;\n\n    /// @dev The address of the fee controller\n    IProtocolFeeController public feeController;\n\n    // @notice Required to customize owner from constructor of BaseReactor.sol\n    constructor(address _owner) Owned(_owner) {}\n\n    /// @notice Injects fees into an order\n    /// @dev modifies the orders to include protocol fee outputs\n    /// @param order The encoded order to inject fees into\n    function _injectFees(ResolvedOrder memory order) internal view {\n        if (address(feeController) == address(0)) {\n            return;\n        }\n\n        OutputToken[] memory feeOutputs = feeController.getFeeOutputs(order);\n        uint256 outputsLength = order.outputs.length;\n        uint256 feeOutputsLength = feeOutputs.length;\n\n        // apply fee outputs\n        // fill new outputs with old outputs\n        OutputToken[] memory newOutputs = new OutputToken[](\n            outputsLength + feeOutputsLength\n        );\n\n        unchecked {\n            for (uint256 i = 0; i < outputsLength; i++) {\n                newOutputs[i] = order.outputs[i];\n            }\n        }\n\n        for (uint256 i = 0; i < feeOutputsLength;) {\n            OutputToken memory feeOutput = feeOutputs[i];\n            // assert no duplicates\n            unchecked {\n                for (uint256 j = 0; j < i; j++) {\n                    if (feeOutput.token == feeOutputs[j].token) {\n                        revert DuplicateFeeOutput(feeOutput.token);\n                    }\n                }\n            }\n\n            // assert not greater than MAX_FEE_BPS\n            uint256 tokenValue;\n            for (uint256 j = 0; j < outputsLength;) {\n                OutputToken memory output = order.outputs[j];\n                if (output.token == feeOutput.token) {\n                    tokenValue += output.amount;\n                }\n                unchecked {\n                    j++;\n                }\n            }\n\n            // allow fee on input token as well\n            if (address(order.input.token) == feeOutput.token) {\n                tokenValue += order.input.amount;\n            }\n\n            if (tokenValue == 0) revert InvalidFeeToken(feeOutput.token);\n\n            if (feeOutput.amount > tokenValue.mulDivDown(MAX_FEE_BPS, BPS)) {\n                revert FeeTooLarge(feeOutput.token, feeOutput.amount, feeOutput.recipient);\n            }\n            newOutputs[outputsLength + i] = feeOutput;\n\n            unchecked {\n                i++;\n            }\n        }\n\n        order.outputs = newOutputs;\n    }\n\n    /// @notice sets the protocol fee controller\n    /// @dev only callable by the owner\n    /// @param _newFeeController the new fee controller\n    function setProtocolFeeController(address _newFeeController) external onlyOwner {\n        address oldFeeController = address(feeController);\n        feeController = IProtocolFeeController(_newFeeController);\n        emit ProtocolFeeControllerSet(oldFeeController, _newFeeController);\n    }\n}"
    },
    {
      "filename": "src/reactors/BaseReactor.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {SafeTransferLib} from \"solmate/src/utils/SafeTransferLib.sol\";\nimport {ReentrancyGuard} from \"openzeppelin-contracts/security/ReentrancyGuard.sol\";\nimport {IPermit2} from \"permit2/src/interfaces/IPermit2.sol\";\nimport {ERC20} from \"solmate/src/tokens/ERC20.sol\";\nimport {ReactorEvents} from \"../base/ReactorEvents.sol\";\nimport {ResolvedOrderLib} from \"../lib/ResolvedOrderLib.sol\";\nimport {CurrencyLibrary, NATIVE} from \"../lib/CurrencyLibrary.sol\";\nimport {IReactorCallback} from \"../interfaces/IReactorCallback.sol\";\nimport {IReactor} from \"../interfaces/IReactor.sol\";\nimport {ProtocolFees} from \"../base/ProtocolFees.sol\";\nimport {SignedOrder, ResolvedOrder, OutputToken} from \"../base/ReactorStructs.sol\";\n\n/// @notice Generic reactor logic for settling off-chain signed orders\n///     using arbitrary fill methods specified by a filler\nabstract contract BaseReactor is IReactor, ReactorEvents, ProtocolFees, ReentrancyGuard {\n    using SafeTransferLib for ERC20;\n    using ResolvedOrderLib for ResolvedOrder;\n    using CurrencyLibrary for address;\n\n    // Occurs when an output = ETH and the reactor does contain enough ETH but\n    // the direct filler did not include enough ETH in their call to execute/executeBatch\n    error InsufficientEth();\n\n    /// @notice permit2 address used for token transfers and signature verification\n    IPermit2 public immutable permit2;\n\n    constructor(IPermit2 _permit2, address _protocolFeeOwner) ProtocolFees(_protocolFeeOwner) {\n        permit2 = _permit2;\n    }\n\n    /// @inheritdoc IReactor\n    function execute(SignedOrder calldata order) external payable override nonReentrant {\n        ResolvedOrder[] memory resolvedOrders = new ResolvedOrder[](1);\n        resolvedOrders[0] = resolve(order);\n\n        _prepare(resolvedOrders);\n        _fill(resolvedOrders);\n    }\n\n    /// @inheritdoc IReactor\n    function executeWithCallback(SignedOrder calldata order, bytes calldata callbackData)\n        external\n        payable\n        override\n        nonReentrant\n    {\n        ResolvedOrder[] memory resolvedOrders = new ResolvedOrder[](1);\n        resolvedOrders[0] = resolve(order);\n\n        _prepare(resolvedOrders);\n        IReactorCallback(msg.sender).reactorCallback(resolvedOrders, callbackData);\n        _fill(resolvedOrders);\n    }\n\n    /// @inheritdoc IReactor\n    function executeBatch(SignedOrder[] calldata orders) external payable override nonReentrant {\n        uint256 ordersLength = orders.length;\n        ResolvedOrder[] memory resolvedOrders = new ResolvedOrder[](ordersLength);\n\n        unchecked {\n            for (uint256 i = 0; i < ordersLength; i++) {\n                resolvedOrders[i] = resolve(orders[i]);\n            }\n        }\n\n        _prepare(resolvedOrders);\n        _fill(resolvedOrders);\n    }\n\n    /// @inheritdoc IReactor\n    function executeBatchWithCallback(SignedOrder[] calldata orders, bytes calldata callbackData)\n        external\n        payable\n        override\n        nonReentrant\n    {\n        uint256 ordersLength = orders.length;\n        ResolvedOrder[] memory resolvedOrders = new ResolvedOrder[](ordersLength);\n\n        unchecked {\n            for (uint256 i = 0; i < ordersLength; i++) {\n                resolvedOrders[i] = resolve(orders[i]);\n            }\n        }\n\n        _prepare(resolvedOrders);\n        IReactorCallback(msg.sender).reactorCallback(resolvedOrders, callbackData);\n        _fill(resolvedOrders);\n    }\n\n    /// @notice validates, injects fees, and transfers input tokens in preparation for order fill\n    /// @param orders The orders to prepare\n    function _prepare(ResolvedOrder[] memory orders) internal {\n        uint256 ordersLength = orders.length;\n        unchecked {\n            for (uint256 i = 0; i < ordersLength; i++) {\n                ResolvedOrder memory order = orders[i];\n                _injectFees(order);\n                order.validate(msg.sender);\n                transferInputTokens(order, msg.sender);\n            }\n        }\n    }\n\n    /// @notice fills a list of orders, ensuring all outputs are satisfied\n    /// @param orders The orders to fill\n    function _fill(ResolvedOrder[] memory orders) internal {\n        uint256 ordersLength = orders.length;\n        // attempt to transfer all currencies to all recipients\n        unchecked {\n            // transfer output tokens to their respective recipients\n            for (uint256 i = 0; i < ordersLength; i++) {\n                ResolvedOrder memory resolvedOrder = orders[i];\n                uint256 outputsLength = resolvedOrder.outputs.length;\n                for (uint256 j = 0; j < outputsLength; j++) {\n                    OutputToken memory output = resolvedOrder.outputs[j];\n                    output.token.transferFill(output.recipient, output.amount);\n                }\n\n                emit Fill(orders[i].hash, msg.sender, resolvedOrder.info.swapper, resolvedOrder.info.nonce);\n            }\n        }\n\n        // refund any remaining ETH to the filler. Only occurs when filler sends more ETH than required to\n        // `execute()` or `executeBatch()`, or when there is excess contract balance remaining from others\n        // incorrectly calling execute/executeBatch without direct filler method but with a msg.value\n        if (address(this).balance > 0) {\n            CurrencyLibrary.transferNative(msg.sender, address(this).balance);\n        }\n    }\n\n    receive() external payable {\n        // receive native asset to support native output\n    }\n\n    /// @notice Resolve order-type specific requirements into a generic order with the final inputs and outputs.\n    /// @param order The encoded order to resolve\n    /// @return resolvedOrder generic resolved order of inputs and outputs\n    /// @dev should revert on any order-type-specific validation errors\n    function resolve(SignedOrder calldata order) internal view virtual returns (ResolvedOrder memory resolvedOrder);\n\n    /// @notice Transfers tokens to the fillContract\n    /// @param order The encoded order to transfer tokens for\n    /// @param to The address to transfer tokens to\n    function transferInputTokens(ResolvedOrder memory order, address to) internal virtual;\n}"
    },
    {
      "filename": "src/lib/ResolvedOrderLib.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {ResolvedOrder} from \"../base/ReactorStructs.sol\";\nimport {IValidationCallback} from \"../interfaces/IValidationCallback.sol\";\n\nlibrary ResolvedOrderLib {\n    /// @notice thrown when the order targets a different reactor\n    error InvalidReactor();\n\n    /// @notice thrown if the order has expired\n    error DeadlinePassed();\n\n    /// @notice Validates a resolved order, reverting if invalid\n    /// @param filler The filler of the order\n    function validate(ResolvedOrder memory resolvedOrder, address filler) internal view {\n        if (address(this) != address(resolvedOrder.info.reactor)) {\n            revert InvalidReactor();\n        }\n\n        if (block.timestamp > resolvedOrder.info.deadline) {\n            revert DeadlinePassed();\n        }\n\n        if (address(resolvedOrder.info.additionalValidationContract) != address(0)) {\n            resolvedOrder.info.additionalValidationContract.validate(filler, resolvedOrder);\n        }\n    }\n}"
    },
    {
      "filename": "src/reactors/ExclusiveDutchOrderReactor.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {BaseReactor} from \"./BaseReactor.sol\";\nimport {IPermit2} from \"permit2/src/interfaces/IPermit2.sol\";\nimport {ExclusivityOverrideLib} from \"../lib/ExclusivityOverrideLib.sol\";\nimport {Permit2Lib} from \"../lib/Permit2Lib.sol\";\nimport {DutchDecayLib} from \"../lib/DutchDecayLib.sol\";\nimport {ExclusiveDutchOrderLib, ExclusiveDutchOrder, DutchOutput, DutchInput} from \"../lib/ExclusiveDutchOrderLib.sol\";\nimport {SignedOrder, ResolvedOrder, OrderInfo} from \"../base/ReactorStructs.sol\";\n\n/// @notice Reactor for exclusive dutch orders\ncontract ExclusiveDutchOrderReactor is BaseReactor {\n    using Permit2Lib for ResolvedOrder;\n    using ExclusiveDutchOrderLib for ExclusiveDutchOrder;\n    using DutchDecayLib for DutchOutput[];\n    using DutchDecayLib for DutchInput;\n    using ExclusivityOverrideLib for ResolvedOrder;\n\n    /// @notice thrown when an order's deadline is before its end time\n    error DeadlineBeforeEndTime();\n\n    /// @notice thrown when an order's end time is before its start time\n    error OrderEndTimeBeforeStartTime();\n\n    /// @notice thrown when an order's inputs and outputs both decay\n    error InputAndOutputDecay();\n\n    constructor(IPermit2 _permit2, address _protocolFeeOwner) BaseReactor(_permit2, _protocolFeeOwner) {}\n\n    /// @inheritdoc BaseReactor\n    function resolve(SignedOrder calldata signedOrder)\n        internal\n        view\n        virtual\n        override\n        returns (ResolvedOrder memory resolvedOrder)\n    {\n        ExclusiveDutchOrder memory order = abi.decode(signedOrder.order, (ExclusiveDutchOrder));\n        _validateOrder(order);\n\n        resolvedOrder = ResolvedOrder({\n            info: order.info,\n            input: order.input.decay(order.decayStartTime, order.decayEndTime),\n            outputs: order.outputs.decay(order.decayStartTime, order.decayEndTime),\n            sig: signedOrder.sig,\n            hash: order.hash()\n        });\n        resolvedOrder.handleOverride(order.exclusiveFiller, order.decayStartTime, order.exclusivityOverrideBps);\n    }\n\n    /// @inheritdoc BaseReactor\n    function transferInputTokens(ResolvedOrder memory order, address to) internal override {\n        permit2.permitWitnessTransferFrom(\n            order.toPermit(),\n            order.transferDetails(to),\n            order.info.swapper,\n            order.hash,\n            ExclusiveDutchOrderLib.PERMIT2_ORDER_TYPE,\n            order.sig\n        );\n    }\n\n    /// @notice validate the dutch order fields\n    /// - deadline must be greater than or equal than decayEndTime\n    /// - decayEndTime must be greater than or equal to decayStartTime\n    /// - if there's input decay, outputs must not decay\n    /// - for input decay, startAmount must < endAmount\n    /// @dev Throws if the order is invalid\n    function _validateOrder(ExclusiveDutchOrder memory order) internal pure {\n        if (order.info.deadline < order.decayEndTime) {\n            revert DeadlineBeforeEndTime();\n        }\n\n        if (order.decayEndTime < order.decayStartTime) {\n            revert OrderEndTimeBeforeStartTime();\n        }\n\n        if (order.input.startAmount != order.input.endAmount) {\n            unchecked {\n                for (uint256 i = 0; i < order.outputs.length; i++) {\n                    if (order.outputs[i].startAmount != order.outputs[i].endAmount) {\n                        revert InputAndOutputDecay();\n                    }\n                }\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/lib/CurrencyLibrary.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {ERC20} from \"solmate/src/tokens/ERC20.sol\";\nimport {IPermit2} from \"permit2/src/interfaces/IPermit2.sol\";\nimport {SafeCast} from \"openzeppelin-contracts/utils/math/SafeCast.sol\";\nimport {SafeTransferLib} from \"solmate/src/utils/SafeTransferLib.sol\";\n\naddress constant NATIVE = 0x0000000000000000000000000000000000000000;\nuint256 constant TRANSFER_NATIVE_GAS_LIMIT = 6900;\n\n/// @title CurrencyLibrary\n/// @dev This library allows for transferring native ETH and ERC20s via direct filler OR fill contract.\nlibrary CurrencyLibrary {\n    using SafeTransferLib for ERC20;\n\n    /// @notice Thrown when a native transfer fails\n    error NativeTransferFailed();\n\n    /// @notice Get the balance of a currency for addr\n    /// @param currency The currency to get the balance of\n    /// @param addr The address to get the balance of\n    /// @return balance The balance of the currency for addr\n    function balanceOf(address currency, address addr) internal view returns (uint256 balance) {\n        if (isNative(currency)) {\n            balance = addr.balance;\n        } else {\n            balance = ERC20(currency).balanceOf(addr);\n        }\n    }\n\n    /// @notice Transfer currency from the caller to recipient\n    /// @dev for native outputs we will already have the currency in local balance\n    /// @param currency The currency to transfer\n    /// @param recipient The recipient of the currency\n    /// @param amount The amount of currency to transfer\n    function transferFill(address currency, address recipient, uint256 amount) internal {\n        if (isNative(currency)) {\n            // we will have received native assets directly so can directly transfer\n            transferNative(recipient, amount);\n        } else {\n            // else the caller must have approved the token for the fill\n            ERC20(currency).safeTransferFrom(msg.sender, recipient, amount);\n        }\n    }\n\n    /// @notice Transfer native currency to recipient\n    /// @param recipient The recipient of the currency\n    /// @param amount The amount of currency to transfer\n    function transferNative(address recipient, uint256 amount) internal {\n        (bool success,) = recipient.call{value: amount, gas: TRANSFER_NATIVE_GAS_LIMIT}(\"\");\n        if (!success) revert NativeTransferFailed();\n    }\n\n    /// @notice returns true if currency is native\n    /// @param currency The currency to check\n    /// @return true if currency is native\n    function isNative(address currency) internal pure returns (bool) {\n        return currency == NATIVE;\n    }\n}"
    },
    {
      "filename": "src/lens/OrderQuoter.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {IReactorCallback} from \"../interfaces/IReactorCallback.sol\";\nimport {IReactor} from \"../interfaces/IReactor.sol\";\nimport {BaseReactor} from \"../reactors/BaseReactor.sol\";\nimport {OrderInfo, ResolvedOrder, SignedOrder} from \"../base/ReactorStructs.sol\";\n\n/// @notice Quoter contract for orders\n/// @dev note this is meant to be used as an off-chain lens contract to pre-validate generic orders\ncontract OrderQuoter is IReactorCallback {\n    /// @notice thrown if reactorCallback receives more than one order\n    error OrdersLengthIncorrect();\n\n    uint256 constant ORDER_INFO_OFFSET = 64;\n\n    /// @notice Quote the given order, returning the ResolvedOrder object which defines\n    /// the current input and output token amounts required to satisfy it\n    /// Also bubbles up any reverts that would occur during the processing of the order\n    /// @param order abi-encoded order, including `reactor` as the first encoded struct member\n    /// @param sig The order signature\n    /// @return result The ResolvedOrder\n    function quote(bytes memory order, bytes memory sig) external returns (ResolvedOrder memory result) {\n        try IReactor(getReactor(order)).executeWithCallback(SignedOrder(order, sig), bytes(\"\")) {}\n        catch (bytes memory reason) {\n            result = parseRevertReason(reason);\n        }\n    }\n\n    /// @notice Return the reactor of a given order (abi.encoded bytes).\n    /// @param order abi-encoded order, including `reactor` as the first encoded struct member\n    /// @return reactor\n    function getReactor(bytes memory order) public pure returns (IReactor reactor) {\n        assembly {\n            let orderInfoOffsetPointer := add(order, ORDER_INFO_OFFSET)\n            reactor := mload(add(orderInfoOffsetPointer, mload(orderInfoOffsetPointer)))\n        }\n    }\n\n    /// @notice Return the order info of a given order (abi-encoded bytes).\n    /// @param order abi-encoded order, including `reactor` as the first encoded struct member\n    function parseRevertReason(bytes memory reason) private pure returns (ResolvedOrder memory order) {\n        if (reason.length < 192) {\n            assembly {\n                revert(add(32, reason), mload(reason))\n            }\n        } else {\n            return abi.decode(reason, (ResolvedOrder));\n        }\n    }\n\n    /// @notice Reactor callback function\n    /// @dev reverts with the resolved order as reason\n    /// @param resolvedOrders The resolved orders\n    function reactorCallback(ResolvedOrder[] memory resolvedOrders, bytes memory) external pure {\n        if (resolvedOrders.length != 1) {\n            revert OrdersLengthIncorrect();\n        }\n        bytes memory order = abi.encode(resolvedOrders[0]);\n        assembly {\n            revert(add(32, order), mload(order))\n        }\n    }\n}"
    },
    {
      "filename": "src/lens/OrderQuoter.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {IReactorCallback} from \"../interfaces/IReactorCallback.sol\";\nimport {IReactor} from \"../interfaces/IReactor.sol\";\nimport {BaseReactor} from \"../reactors/BaseReactor.sol\";\nimport {OrderInfo, ResolvedOrder, SignedOrder} from \"../base/ReactorStructs.sol\";\n\n/// @notice Quoter contract for orders\n/// @dev note this is meant to be used as an off-chain lens contract to pre-validate generic orders\ncontract OrderQuoter is IReactorCallback {\n    /// @notice thrown if reactorCallback receives more than one order\n    error OrdersLengthIncorrect();\n\n    uint256 constant ORDER_INFO_OFFSET = 64;\n\n    /// @notice Quote the given order, returning the ResolvedOrder object which defines\n    /// the current input and output token amounts required to satisfy it\n    /// Also bubbles up any reverts that would occur during the processing of the order\n    /// @param order abi-encoded order, including `reactor` as the first encoded struct member\n    /// @param sig The order signature\n    /// @return result The ResolvedOrder\n    function quote(bytes memory order, bytes memory sig) external returns (ResolvedOrder memory result) {\n        try IReactor(getReactor(order)).executeWithCallback(SignedOrder(order, sig), bytes(\"\")) {}\n        catch (bytes memory reason) {\n            result = parseRevertReason(reason);\n        }\n    }\n\n    /// @notice Return the reactor of a given order (abi.encoded bytes).\n    /// @param order abi-encoded order, including `reactor` as the first encoded struct member\n    /// @return reactor\n    function getReactor(bytes memory order) public pure returns (IReactor reactor) {\n        assembly {\n            let orderInfoOffsetPointer := add(order, ORDER_INFO_OFFSET)\n            reactor := mload(add(orderInfoOffsetPointer, mload(orderInfoOffsetPointer)))\n        }\n    }\n\n    /// @notice Return the order info of a given order (abi-encoded bytes).\n    /// @param order abi-encoded order, including `reactor` as the first encoded struct member\n    function parseRevertReason(bytes memory reason) private pure returns (ResolvedOrder memory order) {\n        if (reason.length < 192) {\n            assembly {\n                revert(add(32, reason), mload(reason))\n            }\n        } else {\n            return abi.decode(reason, (ResolvedOrder));\n        }\n    }\n\n    /// @notice Reactor callback function\n    /// @dev reverts with the resolved order as reason\n    /// @param resolvedOrders The resolved orders\n    function reactorCallback(ResolvedOrder[] memory resolvedOrders, bytes memory) external pure {\n        if (resolvedOrders.length != 1) {\n            revert OrdersLengthIncorrect();\n        }\n        bytes memory order = abi.encode(resolvedOrders[0]);\n        assembly {\n            revert(add(32, order), mload(order))\n        }\n    }\n}"
    }
  ]
}