{
  "Title": "[M-29] TRSRY susceptible to loan / withdraw confusion",
  "Content": "_Submitted by Trust, also found by 0xSky, datapunk, and tonisives_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L64-L102><br>\n\nTreasury allocates approvals in the withdrawApproval mapping which is set via setApprovalFor(). In both withdrawReserves() and in getLoan(), \\_checkApproval() is used to verify user has enough approval and subtracts the withdraw / loan amount. Therefore, there is no differentiation in validation between loan approval and withdraw approval. Policies which will use getLoan() (currently none) can simply withdraw the tokens without bookkeeping it as a loan.\n\n### Proof of Concept\n\n1.  Policy P has getLoan permission\n2.  setApprovalFor(policy, token, amount) was called to grant P permission to loan amount\n3.  P calls withdrawReserves(address, token, amount) and directly withdraws the funds without registering as loan\n\n### Recommended Mitigation Steps\n\nA separate mapping called loanApproval should be implemented, and setLoanApprovalFor() will set it, getLoan() will reduce loanApproval balance.\n\n**[ind-igo (Olympus) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/75#issuecomment-1239657706):**\n > Confirmed. Good suggestion. Would put as low risk though.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/75#issuecomment-1250396074):**\n > Currently thinking Medium is appropriate for this issue, but will circle back on it. \n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/75#issuecomment-1251404052):**\n > See [#293](https://github.com/code-423n4/2022-08-olympus-findings/issues/293) for a possible vector in which this could lead to loss of funds.  Going to leave as Medium.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-08-olympus-dao-contest",
  "Code": [
    {
      "filename": "src/modules/TRSRY.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\n\nimport \"src/Kernel.sol\";\n\n// ERRORS\nerror TRSRY_NotApproved();\nerror TRSRY_NoDebtOutstanding();\n\n/// @notice Treasury holds reserves, LP tokens and all other assets under the control\n///         of the protocol.\ncontract OlympusTreasury is Module, ReentrancyGuard {\n    using TransferHelper for ERC20;\n\n    event ApprovedForWithdrawal(address indexed policy_, ERC20 indexed token_, uint256 amount_);\n    event Withdrawal(\n        address indexed policy_,\n        address indexed withdrawer_,\n        ERC20 indexed token_,\n        uint256 amount_\n    );\n    event DebtIncurred(ERC20 indexed token_, address indexed policy_, uint256 amount_);\n    event DebtRepaid(ERC20 indexed token_, address indexed policy_, uint256 amount_);\n    event DebtSet(ERC20 indexed token_, address indexed policy_, uint256 amount_);\n\n    /// @notice Mapping of who is approved for withdrawal.\n    /// @dev    withdrawer -> token -> amount. Infinite approval is max(uint256).\n    mapping(address => mapping(ERC20 => uint256)) public withdrawApproval;\n\n    /// @notice Total debt for token across all withdrawals.\n    mapping(ERC20 => uint256) public totalDebt;\n\n    /// @notice Debt for particular token and debtor address\n    mapping(ERC20 => mapping(address => uint256)) public reserveDebt;\n\n    /*//////////////////////////////////////////////////////////////\n                            MODULE INTERFACE\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(Kernel kernel_) Module(kernel_) {}\n\n    function KEYCODE() public pure override returns (Keycode) {\n        return toKeycode(\"TRSRY\");\n    }\n\n    function VERSION() external pure override returns (uint8 major, uint8 minor) {\n        return (1, 0);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CORE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function getReserveBalance(ERC20 token_) external view returns (uint256) {\n        return token_.balanceOf(address(this)) + totalDebt[token_];\n    }\n\n    /// @notice Sets approval for specific withdrawer addresses\n    function setApprovalFor(\n        address withdrawer_,\n        ERC20 token_,\n        uint256 amount_\n    ) external permissioned {\n        withdrawApproval[withdrawer_][token_] = amount_;\n\n        emit ApprovedForWithdrawal(withdrawer_, token_, amount_);\n    }\n\n    /// @notice Allow withdrawal of reserve funds from pre-approved addresses.\n    function withdrawReserves(\n        address to_,\n        ERC20 token_,\n        uint256 amount_\n    ) public {\n        _checkApproval(msg.sender, token_, amount_);\n\n        token_.safeTransfer(to_, amount_);\n\n        emit Withdrawal(msg.sender, to_, token_, amount_);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             DEBT FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Pre-approved policies can get a loan to perform operations on treasury assets.\n    function getLoan(ERC20 token_, uint256 amount_) external permissioned {\n        _checkApproval(msg.sender, token_, amount_);\n\n        // Add debt to caller\n        reserveDebt[token_][msg.sender] += amount_;\n        totalDebt[token_] += amount_;\n\n        token_.safeTransfer(msg.sender, amount_);\n\n        emit DebtIncurred(token_, msg.sender, amount_);\n    }\n\n    /// @notice Lets an address with debt repay their loan.\n    function repayLoan(ERC20 token_, uint256 amount_) external nonReentrant {\n        if (reserveDebt[token_][msg.sender] == 0) revert TRSRY_NoDebtOutstanding();\n\n        // Deposit from caller first (to handle nonstandard token transfers)\n        uint256 prevBalance = token_.balanceOf(address(this));\n        token_.safeTransferFrom(msg.sender, address(this), amount_);\n\n        uint256 received = token_.balanceOf(address(this)) - prevBalance;\n\n        // Subtract debt from caller\n        reserveDebt[token_][msg.sender] -= received;\n        totalDebt[token_] -= received;\n\n        emit DebtRepaid(token_, msg.sender, received);\n    }\n\n    /// @notice An escape hatch for setting debt in special cases, like swapping reserves to another token.\n    function setDebt(\n        ERC20 token_,\n        address debtor_,\n        uint256 amount_\n    ) external permissioned {\n        uint256 oldDebt = reserveDebt[token_][debtor_];\n\n        reserveDebt[token_][debtor_] = amount_;\n\n        if (oldDebt < amount_) totalDebt[token_] += amount_ - oldDebt;\n        else totalDebt[token_] -= oldDebt - amount_;\n\n        emit DebtSet(token_, debtor_, amount_);\n    }\n\n    function _checkApproval(\n        address withdrawer_,\n        ERC20 token_,\n        uint256 amount_\n    ) internal {\n        // Must be approved\n        uint256 approval = withdrawApproval[withdrawer_][token_];\n        if (approval < amount_) revert TRSRY_NotApproved();\n\n        // Check for infinite approval\n        if (approval != type(uint256).max) {\n            unchecked {\n                withdrawApproval[withdrawer_][token_] = approval - amount_;\n            }\n        }\n    }\n}"
    }
  ]
}