{
  "Title": "[G-05] Cache state variables outside of loop to avoid reading storage on every iteration",
  "Content": "Reading from storage should always try to be avoided within loops. In the following instances, we are able to cache state variables outside of the loop to save a `Gwarmaccess (100 gas)` per loop iteration.\n\nhttps://github.com/code-423n4/2023-05-venus/blob/main/contracts/Rewards/RewardsDistributor.sol#L282-L284\n\nGas Savings for `RewardsDistributor.claimRewardToken`, obtained via protocol's tests: Avg 77 gas.\n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  262655  |  291169  |  276621 |    3   |\n| After  |  262578  |  291092  |  276544 |    3   |\n\n```solidity\nFile: contracts/Rewards/RewardsDistributor.sol\n282:        for (uint256 i; i < vTokensCount; ++i) {\n283:            VToken vToken = vTokens[i];\n284:            require(comptroller.isMarketListed(vToken), \"market must be listed\");\n```\n```diff\ndiff --git a/contracts/Rewards/RewardsDistributor.sol b/contracts/Rewards/RewardsDistributor.sol\nindex 434732d..1b92e43 100644\n--- a/contracts/Rewards/RewardsDistributor.sol\n+++ b/contracts/Rewards/RewardsDistributor.sol\n@@ -278,10 +278,11 @@ contract RewardsDistributor is ExponentialNoError, Ownable2StepUpgradeable, Acce\n         uint256 vTokensCount = vTokens.length;\n\n         _ensureMaxLoops(vTokensCount);\n-\n+\n+        Comptroller _comptroller = comptroller;\n         for (uint256 i; i < vTokensCount; ++i) {\n             VToken vToken = vTokens[i];\n-            require(comptroller.isMarketListed(vToken), \"market must be listed\");\n+            require(_comptroller.isMarketListed(vToken), \"market must be listed\");\n             Exp memory borrowIndex = Exp({ mantissa: vToken.borrowIndex() });\n             _updateRewardTokenBorrowIndex(address(vToken), borrowIndex);\n             _distributeBorrowerRewardToken(address(vToken), holder, borrowIndex);\n```\n\nhttps://github.com/code-423n4/2023-05-venus/blob/main/contracts/Comptroller.sol#L584-L586\n\nGas Savings for `Comptroller.healAccount`, obtained via protocol's tests: Avg 181 gas.\n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  84584   |  331091  |  223131 |    10   |\n| After  |  84324   |  330963  |  222950 |    10   |\n\n### Cache `oracle` outside loop to save 1 SLOAD per iteration. \n\n**Note:** We must remove cached `msg.sender` variable to fix `stack too deep` error.\n```solidity\nFile: contracts/Comptroller.sol\n584:        for (uint256 i; i < userAssetsCount; ++i) {\n585:            userAssets[i].accrueInterest();\n586:            oracle.updatePrice(address(userAssets[i])); // @audit: sload on every iteration\n```\n```diff\ndiff --git a/contracts/Comptroller.sol b/contracts/Comptroller.sol\nindex 41dc518..8ae7709 100644\n--- a/contracts/Comptroller.sol\n+++ b/contracts/Comptroller.sol\n@@ -579,12 +579,13 @@ contract Comptroller is\n         VToken[] memory userAssets = accountAssets[user];\n         uint256 userAssetsCount = userAssets.length;\n\n-        address liquidator = msg.sender;\n         // We need all user's markets to be fresh for the computations to be correct\n+        PriceOracle _oracle = oracle;\n         for (uint256 i; i < userAssetsCount; ++i) {\n             userAssets[i].accrueInterest();\n-            oracle.updatePrice(address(userAssets[i]));\n+            _oracle.updatePrice(address(userAssets[i]));\n         }\n+\n\n         AccountLiquiditySnapshot memory snapshot = _getCurrentLiquiditySnapshot(user, _getLiquidationThreshold);\n\n@@ -616,11 +617,11 @@ contract Comptroller is\n\n             // Seize the entire collateral\n             if (tokens != 0) {\n-                market.seize(liquidator, user, tokens);\n+                market.seize(msg.sender, user, tokens);\n             }\n             // Repay a certain percentage of the borrow, forgive the rest\n             if (borrowBalance != 0) {\n-                market.healBorrow(liquidator, user, repaymentAmount);\n+                market.healBorrow(msg.sender, user, repaymentAmount);\n             }\n         }\n     }\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-05-venus",
  "Code": [
    {
      "filename": "contracts/Rewards/RewardsDistributor.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"../ExponentialNoError.sol\";\nimport \"../VToken.sol\";\nimport \"../Comptroller.sol\";\nimport \"../MaxLoopsLimitHelper.sol\";\nimport \"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\";\n\ncontract RewardsDistributor is ExponentialNoError, Ownable2StepUpgradeable, AccessControlledV8, MaxLoopsLimitHelper {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct RewardToken {\n        // The market's last updated rewardTokenBorrowIndex or rewardTokenSupplyIndex\n        uint224 index;\n        // The block number the index was last updated at\n        uint32 block;\n    }\n\n    /// @notice The REWARD TOKEN market supply state for each market\n    mapping(address => RewardToken) public rewardTokenSupplyState;\n\n    /// @notice The REWARD TOKEN borrow index for each market for each supplier as of the last time they accrued REWARD TOKEN\n    mapping(address => mapping(address => uint256)) public rewardTokenSupplierIndex;\n\n    /// @notice The initial REWARD TOKEN index for a market\n    uint224 public constant rewardTokenInitialIndex = 1e36;\n\n    /// @notice The REWARD TOKEN accrued but not yet transferred to each user\n    mapping(address => uint256) public rewardTokenAccrued;\n\n    /// @notice The rate at which rewardToken is distributed to the corresponding borrow market (per block)\n    mapping(address => uint256) public rewardTokenBorrowSpeeds;\n\n    /// @notice The rate at which rewardToken is distributed to the corresponding supply market (per block)\n    mapping(address => uint256) public rewardTokenSupplySpeeds;\n\n    /// @notice The REWARD TOKEN market borrow state for each market\n    mapping(address => RewardToken) public rewardTokenBorrowState;\n\n    /// @notice The portion of REWARD TOKEN that each contributor receives per block\n    mapping(address => uint256) public rewardTokenContributorSpeeds;\n\n    /// @notice Last block at which a contributor's REWARD TOKEN rewards have been allocated\n    mapping(address => uint256) public lastContributorBlock;\n\n    /// @notice The REWARD TOKEN borrow index for each market for each borrower as of the last time they accrued REWARD TOKEN\n    mapping(address => mapping(address => uint256)) public rewardTokenBorrowerIndex;\n\n    Comptroller private comptroller;\n\n    IERC20Upgradeable public rewardToken;\n\n    /// @notice Emitted when REWARD TOKEN is distributed to a supplier\n    event DistributedSupplierRewardToken(\n        VToken indexed vToken,\n        address indexed supplier,\n        uint256 rewardTokenDelta,\n        uint256 rewardTokenTotal,\n        uint256 rewardTokenSupplyIndex\n    );\n\n    /// @notice Emitted when REWARD TOKEN is distributed to a borrower\n    event DistributedBorrowerRewardToken(\n        VToken indexed vToken,\n        address indexed borrower,\n        uint256 rewardTokenDelta,\n        uint256 rewardTokenTotal,\n        uint256 rewardTokenBorrowIndex\n    );\n\n    /// @notice Emitted when a new supply-side REWARD TOKEN speed is calculated for a market\n    event RewardTokenSupplySpeedUpdated(VToken indexed vToken, uint256 newSpeed);\n\n    /// @notice Emitted when a new borrow-side REWARD TOKEN speed is calculated for a market\n    event RewardTokenBorrowSpeedUpdated(VToken indexed vToken, uint256 newSpeed);\n\n    /// @notice Emitted when REWARD TOKEN is granted by admin\n    event RewardTokenGranted(address recipient, uint256 amount);\n\n    /// @notice Emitted when a new REWARD TOKEN speed is set for a contributor\n    event ContributorRewardTokenSpeedUpdated(address indexed contributor, uint256 newSpeed);\n\n    /// @notice Emitted when a market is initialized\n    event MarketInitialized(address vToken);\n\n    /// @notice Emitted when a reward token supply index is updated\n    event RewardTokenSupplyIndexUpdated(address vToken);\n\n    /// @notice Emitted when a reward token borrow index is updated\n    event RewardTokenBorrowIndexUpdated(address vToken, Exp marketBorrowIndex);\n\n    /// @notice Emitted when a reward for contributor is updated\n    event ContributorRewardsUpdated(address contributor, uint256 rewardAccrued);\n\n    modifier onlyComptroller() {\n        require(address(comptroller) == msg.sender, \"Only comptroller can call this function\");\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Initializes the deployer to owner.\n     */\n    function initialize(\n        Comptroller comptroller_,\n        IERC20Upgradeable rewardToken_,\n        uint256 loopsLimit_,\n        address accessControlManager_\n    ) external initializer {\n        comptroller = comptroller_;\n        rewardToken = rewardToken_;\n        __Ownable2Step_init();\n        __AccessControlled_init_unchained(accessControlManager_);\n\n        _setMaxLoopsLimit(loopsLimit_);\n    }\n\n    function initializeMarket(address vToken) external onlyComptroller {\n        uint32 blockNumber = safe32(getBlockNumber(), \"block number exceeds 32 bits\");\n\n        RewardToken storage supplyState = rewardTokenSupplyState[vToken];\n        RewardToken storage borrowState = rewardTokenBorrowState[vToken];\n\n        /*\n         * Update market state indices\n         */\n        if (supplyState.index == 0) {\n            // Initialize supply state index with default value\n            supplyState.index = rewardTokenInitialIndex;\n        }\n\n        if (borrowState.index == 0) {\n            // Initialize borrow state index with default value\n            borrowState.index = rewardTokenInitialIndex;\n        }\n\n        /*\n         * Update market state block numbers\n         */\n        supplyState.block = borrowState.block = blockNumber;\n\n        emit MarketInitialized(vToken);\n    }\n\n    /*** Reward Token Distribution ***/\n\n    /**\n     * @notice Calculate reward token accrued by a borrower and possibly transfer it to them\n     *         Borrowers will begin to accrue after the first interaction with the protocol.\n     * @dev This function should only be called when the user has a borrow position in the market\n     *      (e.g. Comptroller.preBorrowHook, and Comptroller.preRepayHook)\n     *      We avoid an external call to check if they are in the market to save gas because this function is called in many places.\n     * @param vToken The market in which the borrower is interacting\n     * @param borrower The address of the borrower to distribute REWARD TOKEN to\n     */\n    function distributeBorrowerRewardToken(\n        address vToken,\n        address borrower,\n        Exp memory marketBorrowIndex\n    ) external onlyComptroller {\n        _distributeBorrowerRewardToken(vToken, borrower, marketBorrowIndex);\n    }\n\n    function updateRewardTokenSupplyIndex(address vToken) external onlyComptroller {\n        _updateRewardTokenSupplyIndex(vToken);\n    }\n\n    /**\n     * @notice Transfer REWARD TOKEN to the recipient.\n     * @dev Note: If there is not enough REWARD TOKEN, we do not perform the transfer all.\n     * @param recipient The address of the recipient to transfer REWARD TOKEN to\n     * @param amount The amount of REWARD TOKEN to (possibly) transfer\n     */\n    function grantRewardToken(address recipient, uint256 amount) external onlyOwner {\n        uint256 amountLeft = _grantRewardToken(recipient, amount);\n        require(amountLeft == 0, \"insufficient rewardToken for grant\");\n        emit RewardTokenGranted(recipient, amount);\n    }\n\n    function updateRewardTokenBorrowIndex(address vToken, Exp memory marketBorrowIndex) external onlyComptroller {\n        _updateRewardTokenBorrowIndex(vToken, marketBorrowIndex);\n    }\n\n    /**\n     * @notice Set REWARD TOKEN borrow and supply speeds for the specified markets.\n     * @param vTokens The markets whose REWARD TOKEN speed to update.\n     * @param supplySpeeds New supply-side REWARD TOKEN speed for the corresponding market.\n     * @param borrowSpeeds New borrow-side REWARD TOKEN speed for the corresponding market.\n     */\n    function setRewardTokenSpeeds(\n        VToken[] memory vTokens,\n        uint256[] memory supplySpeeds,\n        uint256[] memory borrowSpeeds\n    ) external {\n        _checkAccessAllowed(\"setRewardTokenSpeeds(address[],uint256[],uint256[])\");\n        uint256 numTokens = vTokens.length;\n        require(\n            numTokens == supplySpeeds.length && numTokens == borrowSpeeds.length,\n            \"RewardsDistributor::setRewardTokenSpeeds invalid input\"\n        );\n\n        for (uint256 i; i < numTokens; ++i) {\n            _setRewardTokenSpeed(vTokens[i], supplySpeeds[i], borrowSpeeds[i]);\n        }\n    }\n\n    /**\n     * @notice Set REWARD TOKEN speed for a single contributor.\n     * @param contributor The contributor whose REWARD TOKEN speed to update\n     * @param rewardTokenSpeed New REWARD TOKEN speed for contributor\n     */\n    function setContributorRewardTokenSpeed(address contributor, uint256 rewardTokenSpeed) external onlyOwner {\n        // note that REWARD TOKEN speed could be set to 0 to halt liquidity rewards for a contributor\n        updateContributorRewards(contributor);\n        if (rewardTokenSpeed == 0) {\n            // release storage\n            delete lastContributorBlock[contributor];\n        } else {\n            lastContributorBlock[contributor] = getBlockNumber();\n        }\n        rewardTokenContributorSpeeds[contributor] = rewardTokenSpeed;\n\n        emit ContributorRewardTokenSpeedUpdated(contributor, rewardTokenSpeed);\n    }\n\n    function distributeSupplierRewardToken(address vToken, address supplier) external onlyComptroller {\n        _distributeSupplierRewardToken(vToken, supplier);\n    }\n\n    /**\n     * @notice Claim all the rewardToken accrued by holder in all markets.\n     * @param holder The address to claim REWARD TOKEN for\n     */\n    function claimRewardToken(address holder) external {\n        return claimRewardToken(holder, comptroller.getAllMarkets());\n    }\n\n    /**\n     * @notice Set the limit for the loops can iterate to avoid the DOS\n     * @param limit Limit for the max loops can execute at a time\n     */\n    function setMaxLoopsLimit(uint256 limit) external onlyOwner {\n        _setMaxLoopsLimit(limit);\n    }\n\n    /**\n     * @notice Calculate additional accrued REWARD TOKEN for a contributor since last accrual.\n     * @param contributor The address to calculate contributor rewards for\n     */\n    function updateContributorRewards(address contributor) public {\n        uint256 rewardTokenSpeed = rewardTokenContributorSpeeds[contributor];\n        uint256 blockNumber = getBlockNumber();\n        uint256 deltaBlocks = sub_(blockNumber, lastContributorBlock[contributor]);\n        if (deltaBlocks > 0 && rewardTokenSpeed > 0) {\n            uint256 newAccrued = mul_(deltaBlocks, rewardTokenSpeed);\n            uint256 contributorAccrued = add_(rewardTokenAccrued[contributor], newAccrued);\n\n            rewardTokenAccrued[contributor] = contributorAccrued;\n            lastContributorBlock[contributor] = blockNumber;\n\n            emit ContributorRewardsUpdated(contributor, rewardTokenAccrued[contributor]);\n        }\n    }\n\n    /**\n     * @notice Claim all the rewardToken accrued by holder in the specified markets.\n     * @param holder The address to claim REWARD TOKEN for\n     * @param vTokens The list of markets to claim REWARD TOKEN in\n     */\n    function claimRewardToken(address holder, VToken[] memory vTokens) public {\n        uint256 vTokensCount = vTokens.length;\n\n        _ensureMaxLoops(vTokensCount);\n\n        for (uint256 i; i < vTokensCount; ++i) {\n            VToken vToken = vTokens[i];\n            require(comptroller.isMarketListed(vToken), \"market must be listed\");\n            Exp memory borrowIndex = Exp({ mantissa: vToken.borrowIndex() });\n            _updateRewardTokenBorrowIndex(address(vToken), borrowIndex);\n            _distributeBorrowerRewardToken(address(vToken), holder, borrowIndex);\n            _updateRewardTokenSupplyIndex(address(vToken));\n            _distributeSupplierRewardToken(address(vToken), holder);\n        }\n        rewardTokenAccrued[holder] = _grantRewardToken(holder, rewardTokenAccrued[holder]);\n    }\n\n    function getBlockNumber() public view virtual returns (uint256) {\n        return block.number;\n    }\n\n    /**\n     * @notice Set REWARD TOKEN speed for a single market.\n     * @param vToken market's whose reward token rate to be updated\n     * @param supplySpeed New supply-side REWARD TOKEN speed for market\n     * @param borrowSpeed New borrow-side REWARD TOKEN speed for market\n     */\n    function _setRewardTokenSpeed(\n        VToken vToken,\n        uint256 supplySpeed,\n        uint256 borrowSpeed\n    ) internal {\n        require(comptroller.isMarketListed(vToken), \"rewardToken market is not listed\");\n\n        if (rewardTokenSupplySpeeds[address(vToken)] != supplySpeed) {\n            // Supply speed updated so let's update supply state to ensure that\n            //  1. REWARD TOKEN accrued properly for the old speed, and\n            //  2. REWARD TOKEN accrued at the new speed starts after this block.\n            _updateRewardTokenSupplyIndex(address(vToken));\n\n            // Update speed and emit event\n            rewardTokenSupplySpeeds[address(vToken)] = supplySpeed;\n            emit RewardTokenSupplySpeedUpdated(vToken, supplySpeed);\n        }\n\n        if (rewardTokenBorrowSpeeds[address(vToken)] != borrowSpeed) {\n            // Borrow speed updated so let's update borrow state to ensure that\n            //  1. REWARD TOKEN accrued properly for the old speed, and\n            //  2. REWARD TOKEN accrued at the new speed starts after this block.\n            Exp memory borrowIndex = Exp({ mantissa: vToken.borrowIndex() });\n            _updateRewardTokenBorrowIndex(address(vToken), borrowIndex);\n\n            // Update speed and emit event\n            rewardTokenBorrowSpeeds[address(vToken)] = borrowSpeed;\n            emit RewardTokenBorrowSpeedUpdated(vToken, borrowSpeed);\n        }\n    }\n\n    /**\n     * @notice Calculate REWARD TOKEN accrued by a supplier and possibly transfer it to them.\n     * @param vToken The market in which the supplier is interacting\n     * @param supplier The address of the supplier to distribute REWARD TOKEN to\n     */\n    function _distributeSupplierRewardToken(address vToken, address supplier) internal {\n        RewardToken storage supplyState = rewardTokenSupplyState[vToken];\n        uint256 supplyIndex = supplyState.index;\n        uint256 supplierIndex = rewardTokenSupplierIndex[vToken][supplier];\n\n        // Update supplier's index to the current index since we are distributing accrued REWARD TOKEN\n        rewardTokenSupplierIndex[vToken][supplier] = supplyIndex;\n\n        if (supplierIndex == 0 && supplyIndex >= rewardTokenInitialIndex) {\n            // Covers the case where users supplied tokens before the market's supply state index was set.\n            // Rewards the user with REWARD TOKEN accrued from the start of when supplier rewards were first\n            // set for the market.\n            supplierIndex = rewardTokenInitialIndex;\n        }\n\n        // Calculate change in the cumulative sum of the REWARD TOKEN per vToken accrued\n        Double memory deltaIndex = Double({ mantissa: sub_(supplyIndex, supplierIndex) });\n\n        uint256 supplierTokens = VToken(vToken).balanceOf(supplier);\n\n        // Calculate REWARD TOKEN accrued: vTokenAmount * accruedPerVToken\n        uint256 supplierDelta = mul_(supplierTokens, deltaIndex);\n\n        uint256 supplierAccrued = add_(rewardTokenAccrued[supplier], supplierDelta);\n        rewardTokenAccrued[supplier] = supplierAccrued;\n\n        emit DistributedSupplierRewardToken(VToken(vToken), supplier, supplierDelta, supplierAccrued, supplyIndex);\n    }\n\n    /**\n     * @notice Calculate reward token accrued by a borrower and possibly transfer it to them.\n     * @param vToken The market in which the borrower is interacting\n     * @param borrower The address of the borrower to distribute REWARD TOKEN to\n     */\n    function _distributeBorrowerRewardToken(\n        address vToken,\n        address borrower,\n        Exp memory marketBorrowIndex\n    ) internal {\n        RewardToken storage borrowState = rewardTokenBorrowState[vToken];\n        uint256 borrowIndex = borrowState.index;\n        uint256 borrowerIndex = rewardTokenBorrowerIndex[vToken][borrower];\n\n        // Update borrowers's index to the current index since we are distributing accrued REWARD TOKEN\n        rewardTokenBorrowerIndex[vToken][borrower] = borrowIndex;\n\n        if (borrowerIndex == 0 && borrowIndex >= rewardTokenInitialIndex) {\n            // Covers the case where users borrowed tokens before the market's borrow state index was set.\n            // Rewards the user with REWARD TOKEN accrued from the start of when borrower rewards were first\n            // set for the market.\n            borrowerIndex = rewardTokenInitialIndex;\n        }\n\n        // Calculate change in the cumulative sum of the REWARD TOKEN per borrowed unit accrued\n        Double memory deltaIndex = Double({ mantissa: sub_(borrowIndex, borrowerIndex) });\n\n        uint256 borrowerAmount = div_(VToken(vToken).borrowBalanceStored(borrower), marketBorrowIndex);\n\n        // Calculate REWARD TOKEN accrued: vTokenAmount * accruedPerBorrowedUnit\n        if (borrowerAmount != 0) {\n            uint256 borrowerDelta = mul_(borrowerAmount, deltaIndex);\n\n            uint256 borrowerAccrued = add_(rewardTokenAccrued[borrower], borrowerDelta);\n            rewardTokenAccrued[borrower] = borrowerAccrued;\n\n            emit DistributedBorrowerRewardToken(VToken(vToken), borrower, borrowerDelta, borrowerAccrued, borrowIndex);\n        }\n    }\n\n    /**\n     * @notice Transfer REWARD TOKEN to the user.\n     * @dev Note: If there is not enough REWARD TOKEN, we do not perform the transfer all.\n     * @param user The address of the user to transfer REWARD TOKEN to\n     * @param amount The amount of REWARD TOKEN to (possibly) transfer\n     * @return The amount of REWARD TOKEN which was NOT transferred to the user\n     */\n    function _grantRewardToken(address user, uint256 amount) internal returns (uint256) {\n        uint256 rewardTokenRemaining = rewardToken.balanceOf(address(this));\n        if (amount > 0 && amount <= rewardTokenRemaining) {\n            rewardToken.safeTransfer(user, amount);\n            return 0;\n        }\n        return amount;\n    }\n\n    /**\n     * @notice Accrue REWARD TOKEN to the market by updating the supply index.\n     * @param vToken The market whose supply index to update\n     * @dev Index is a cumulative sum of the REWARD TOKEN per vToken accrued.\n     */\n    function _updateRewardTokenSupplyIndex(address vToken) internal {\n        RewardToken storage supplyState = rewardTokenSupplyState[vToken];\n        uint256 supplySpeed = rewardTokenSupplySpeeds[vToken];\n        uint32 blockNumber = safe32(getBlockNumber(), \"block number exceeds 32 bits\");\n        uint256 deltaBlocks = sub_(uint256(blockNumber), uint256(supplyState.block));\n        if (deltaBlocks > 0 && supplySpeed > 0) {\n            uint256 supplyTokens = VToken(vToken).totalSupply();\n            uint256 accruedSinceUpdate = mul_(deltaBlocks, supplySpeed);\n            Double memory ratio = supplyTokens > 0\n                ? fraction(accruedSinceUpdate, supplyTokens)\n                : Double({ mantissa: 0 });\n            supplyState.index = safe224(\n                add_(Double({ mantissa: supplyState.index }), ratio).mantissa,\n                \"new index exceeds 224 bits\"\n            );\n            supplyState.block = blockNumber;\n        } else if (deltaBlocks > 0) {\n            supplyState.block = blockNumber;\n        }\n\n        emit RewardTokenSupplyIndexUpdated(vToken);\n    }\n\n    /**\n     * @notice Accrue REWARD TOKEN to the market by updating the borrow index.\n     * @param vToken The market whose borrow index to update\n     * @dev Index is a cumulative sum of the REWARD TOKEN per vToken accrued.\n     */\n    function _updateRewardTokenBorrowIndex(address vToken, Exp memory marketBorrowIndex) internal {\n        RewardToken storage borrowState = rewardTokenBorrowState[vToken];\n        uint256 borrowSpeed = rewardTokenBorrowSpeeds[vToken];\n        uint32 blockNumber = safe32(getBlockNumber(), \"block number exceeds 32 bits\");\n        uint256 deltaBlocks = sub_(uint256(blockNumber), uint256(borrowState.block));\n        if (deltaBlocks > 0 && borrowSpeed > 0) {\n            uint256 borrowAmount = div_(VToken(vToken).totalBorrows(), marketBorrowIndex);\n            uint256 accruedSinceUpdate = mul_(deltaBlocks, borrowSpeed);\n            Double memory ratio = borrowAmount > 0\n                ? fraction(accruedSinceUpdate, borrowAmount)\n                : Double({ mantissa: 0 });\n            borrowState.index = safe224(\n                add_(Double({ mantissa: borrowState.index }), ratio).mantissa,\n                \"new index exceeds 224 bits\"\n            );\n            borrowState.block = blockNumber;\n        } else if (deltaBlocks > 0) {\n            borrowState.block = blockNumber;\n        }\n\n        emit RewardTokenBorrowIndexUpdated(vToken, marketBorrowIndex);\n    }\n}"
    },
    {
      "filename": "contracts/Comptroller.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n\nimport \"./VToken.sol\";\nimport \"@venusprotocol/oracle/contracts/PriceOracle.sol\";\nimport \"./ComptrollerInterface.sol\";\nimport \"./ComptrollerStorage.sol\";\nimport \"./Rewards/RewardsDistributor.sol\";\nimport \"@venusprotocol/governance-contracts/contracts/Governance/AccessControlManager.sol\";\nimport \"./MaxLoopsLimitHelper.sol\";\n\n/**\n * @title Comptroller Contract\n */\ncontract Comptroller is\n    Ownable2StepUpgradeable,\n    AccessControlledV8,\n    ComptrollerStorage,\n    ComptrollerInterface,\n    ExponentialNoError,\n    MaxLoopsLimitHelper\n{\n    // PoolRegistry, immutable to save on gas\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable poolRegistry;\n\n    /// @notice Emitted when an account enters a market\n    event MarketEntered(VToken vToken, address account);\n\n    /// @notice Emitted when an account exits a market\n    event MarketExited(VToken vToken, address account);\n\n    /// @notice Emitted when close factor is changed by admin\n    event NewCloseFactor(uint256 oldCloseFactorMantissa, uint256 newCloseFactorMantissa);\n\n    /// @notice Emitted when a collateral factor is changed by admin\n    event NewCollateralFactor(VToken vToken, uint256 oldCollateralFactorMantissa, uint256 newCollateralFactorMantissa);\n\n    /// @notice Emitted when liquidation threshold is changed by admin\n    event NewLiquidationThreshold(\n        VToken vToken,\n        uint256 oldLiquidationThresholdMantissa,\n        uint256 newLiquidationThresholdMantissa\n    );\n\n    /// @notice Emitted when liquidation incentive is changed by admin\n    event NewLiquidationIncentive(uint256 oldLiquidationIncentiveMantissa, uint256 newLiquidationIncentiveMantissa);\n\n    /// @notice Emitted when price oracle is changed\n    event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\n\n    /// @notice Emitted when an action is paused on a market\n    event ActionPausedMarket(VToken vToken, Action action, bool pauseState);\n\n    /// @notice Emitted when borrow cap for a vToken is changed\n    event NewBorrowCap(VToken indexed vToken, uint256 newBorrowCap);\n\n    /// @notice Emitted when the collateral threshold (in USD) for non-batch liquidations is changed\n    event NewMinLiquidatableCollateral(uint256 oldMinLiquidatableCollateral, uint256 newMinLiquidatableCollateral);\n\n    /// @notice Emitted when supply cap for a vToken is changed\n    event NewSupplyCap(VToken indexed vToken, uint256 newSupplyCap);\n\n    /// @notice Emitted when a rewards distributor is added\n    event NewRewardsDistributor(address indexed rewardsDistributor);\n\n    /// @notice Emitted when a market is supported\n    event MarketSupported(VToken vToken);\n\n    /// @notice Thrown when collateral factor exceeds the upper bound\n    error InvalidCollateralFactor();\n\n    /// @notice Thrown when liquidation threshold exceeds the collateral factor\n    error InvalidLiquidationThreshold();\n\n    /// @notice Thrown when the action is only available to specific sender, but the real sender was different\n    error UnexpectedSender(address expectedSender, address actualSender);\n\n    /// @notice Thrown when the oracle returns an invalid price for some asset\n    error PriceError(address vToken);\n\n    /// @notice Thrown if VToken unexpectedly returned a nonzero error code while trying to get account snapshot\n    error SnapshotError(address vToken, address user);\n\n    /// @notice Thrown when the market is not listed\n    error MarketNotListed(address market);\n\n    /// @notice Thrown when a market has an unexpected comptroller\n    error ComptrollerMismatch();\n\n    /**\n     * @notice Throwed during the liquidation if user's total collateral amount is lower than\n     *   a predefined threshold. In this case only batch liquidations (either liquidateAccount\n     *   or healAccount) are available.\n     */\n    error MinimalCollateralViolated(uint256 expectedGreaterThan, uint256 actual);\n    error CollateralExceedsThreshold(uint256 expectedLessThanOrEqualTo, uint256 actual);\n    error InsufficientCollateral(uint256 collateralToSeize, uint256 availableCollateral);\n\n    /// @notice Thrown when the account doesn't have enough liquidity to redeem or borrow\n    error InsufficientLiquidity();\n\n    /// @notice Thrown when trying to liquidate a healthy account\n    error InsufficientShortfall();\n\n    /// @notice Thrown when trying to repay more than allowed by close factor\n    error TooMuchRepay();\n\n    /// @notice Thrown if the user is trying to exit a market in which they have an outstanding debt\n    error NonzeroBorrowBalance();\n\n    /// @notice Thrown when trying to perform an action that is paused\n    error ActionPaused(address market, Action action);\n\n    /// @notice Thrown when trying to add a market that is already listed\n    error MarketAlreadyListed(address market);\n\n    /// @notice Thrown if the supply cap is exceeded\n    error SupplyCapExceeded(address market, uint256 cap);\n\n    /// @notice Thrown if the borrow cap is exceeded\n    error BorrowCapExceeded(address market, uint256 cap);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address poolRegistry_) {\n        require(poolRegistry_ != address(0), \"invalid pool registry address\");\n\n        poolRegistry = poolRegistry_;\n        _disableInitializers();\n    }\n\n    /**\n     * @param loopLimit Limit for the loops can iterate to avoid the DOS\n     * @param accessControlManager Access control manager contract address\n     */\n    function initialize(uint256 loopLimit, address accessControlManager) external initializer {\n        __Ownable2Step_init();\n        __AccessControlled_init_unchained(accessControlManager);\n\n        _setMaxLoopsLimit(loopLimit);\n    }\n\n    /**\n     * @notice Add assets to be included in account liquidity calculation; enabling them to be used as collateral\n     * @param vTokens The list of addresses of the vToken markets to be enabled\n     * @return errors An array of NO_ERROR for compatibility with Venus core tooling\n     * @custom:event MarketEntered is emitted for each market on success\n     * @custom:error ActionPaused error is thrown if entering any of the markets is paused\n     * @custom:error MarketNotListed error is thrown if any of the markets is not listed\n     * @custom:access Not restricted\n     */\n    function enterMarkets(address[] memory vTokens) external override returns (uint256[] memory) {\n        uint256 len = vTokens.length;\n\n        uint256 accountAssetsLen = accountAssets[msg.sender].length;\n\n        _ensureMaxLoops(accountAssetsLen + len);\n\n        uint256[] memory results = new uint256[](len);\n        for (uint256 i; i < len; ++i) {\n            VToken vToken = VToken(vTokens[i]);\n\n            _addToMarket(vToken, msg.sender);\n            results[i] = NO_ERROR;\n        }\n\n        return results;\n    }\n\n    /**\n     * @notice Removes asset from sender's account liquidity calculation; disabling them as collateral\n     * @dev Sender must not have an outstanding borrow balance in the asset,\n     *  or be providing necessary collateral for an outstanding borrow.\n     * @param vTokenAddress The address of the asset to be removed\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\n     * @custom:event MarketExited is emitted on success\n     * @custom:error ActionPaused error is thrown if exiting the market is paused\n     * @custom:error NonzeroBorrowBalance error is thrown if the user has an outstanding borrow in this market\n     * @custom:error MarketNotListed error is thrown when the market is not listed\n     * @custom:error InsufficientLiquidity error is thrown if exiting the market would lead to user's insolvency\n     * @custom:error SnapshotError is thrown if some vToken fails to return the account's supply and borrows\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\n     * @custom:access Not restricted\n     */\n    function exitMarket(address vTokenAddress) external override returns (uint256) {\n        _checkActionPauseState(vTokenAddress, Action.EXIT_MARKET);\n        VToken vToken = VToken(vTokenAddress);\n        /* Get sender tokensHeld and amountOwed underlying from the vToken */\n        (uint256 tokensHeld, uint256 amountOwed, ) = _safeGetAccountSnapshot(vToken, msg.sender);\n\n        /* Fail if the sender has a borrow balance */\n        if (amountOwed != 0) {\n            revert NonzeroBorrowBalance();\n        }\n\n        /* Fail if the sender is not permitted to redeem all of their tokens */\n        _checkRedeemAllowed(vTokenAddress, msg.sender, tokensHeld);\n\n        Market storage marketToExit = markets[address(vToken)];\n\n        /* Return true if the sender is not already ‘in’ the market */\n        if (!marketToExit.accountMembership[msg.sender]) {\n            return NO_ERROR;\n        }\n\n        /* Set vToken account membership to false */\n        delete marketToExit.accountMembership[msg.sender];\n\n        /* Delete vToken from the account’s list of assets */\n        // load into memory for faster iteration\n        VToken[] memory userAssetList = accountAssets[msg.sender];\n        uint256 len = userAssetList.length;\n\n        uint256 assetIndex = len;\n        for (uint256 i; i < len; ++i) {\n            if (userAssetList[i] == vToken) {\n                assetIndex = i;\n                break;\n            }\n        }\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n        assert(assetIndex < len);\n\n        // copy last item in list to location of item to be removed, reduce length by 1\n        VToken[] storage storedList = accountAssets[msg.sender];\n        storedList[assetIndex] = storedList[storedList.length - 1];\n        storedList.pop();\n\n        emit MarketExited(vToken, msg.sender);\n\n        return NO_ERROR;\n    }\n\n    /*** Policy Hooks ***/\n\n    /**\n     * @notice Checks if the account should be allowed to mint tokens in the given market\n     * @param vToken The market to verify the mint against\n     * @param minter The account which would get the minted tokens\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\n     * @custom:error ActionPaused error is thrown if supplying to this market is paused\n     * @custom:error MarketNotListed error is thrown when the market is not listed\n     * @custom:error SupplyCapExceeded error is thrown if the total supply exceeds the cap after minting\n     * @custom:access Not restricted\n     */\n    function preMintHook(\n        address vToken,\n        address minter,\n        uint256 mintAmount\n    ) external override {\n        _checkActionPauseState(vToken, Action.MINT);\n\n        if (!markets[vToken].isListed) {\n            revert MarketNotListed(address(vToken));\n        }\n\n        uint256 supplyCap = supplyCaps[vToken];\n        // Skipping the cap check for uncapped coins to save some gas\n        if (supplyCap != type(uint256).max) {\n            uint256 vTokenSupply = VToken(vToken).totalSupply();\n            Exp memory exchangeRate = Exp({ mantissa: VToken(vToken).exchangeRateStored() });\n            uint256 nextTotalSupply = mul_ScalarTruncateAddUInt(exchangeRate, vTokenSupply, mintAmount);\n            if (nextTotalSupply > supplyCap) {\n                revert Sup"
    }
  ]
}