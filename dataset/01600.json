{
  "Title": "M-8: Malicious users can donate/leave dust amounts of collateral in contract during auctions to buy other collateral at very low prices",
  "Content": "# Issue M-8: Malicious users can donate/leave dust amounts of collateral in contract during auctions to buy other collateral at very low prices \n\nSource: https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/168 \n\n## Found by \n0x3e84fa45, 0x52, rogue-lion-0619, ver0759\n## Summary\n\nAuctions are only ended early if the amount of the token being auctioned drops to 0. This can be exploited via donation or leaving dust in the contract to malicious extend the auction and buy further liquidate collateral at heavily discounted prices.\n\n## Vulnerability Detail\n\n[InsuranceFund.sol#L184-L199](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/InsuranceFund.sol#L184-L199)\n\n    function buyCollateralFromAuction(address token, uint amount) override external {\n        Auction memory auction = auctions[token];\n        // validate auction\n        require(_isAuctionOngoing(auction.startedAt, auction.expiryTime), \"IF.no_ongoing_auction\");\n\n        // transfer funds\n        uint vusdToTransfer = _calcVusdAmountForAuction(auction, token, amount);\n        address buyer = _msgSender();\n        vusd.safeTransferFrom(buyer, address(this), vusdToTransfer);\n        IERC20(token).safeTransfer(buyer, amount); // will revert if there wasn't enough amount as requested\n\n        // close auction if no collateral left\n        if (IERC20(token).balanceOf(address(this)) == 0) { <- @audit-issue only cancels auction if balance = 0\n            auctions[token].startedAt = 0;\n        }\n    }\n\nWhen buying collateral from an auction, the auction is only closed if the balance of the token is 0. This can be exploited in a few ways to maliciously extend auctions and keep the timer (and price) decreasing. The first would be buy all but 1 wei of a token leaving it in the contract so the auction won't close. Since 1 wei isn't worth the gas costs to buy, there would be a negative incentive to buy the collateral, likely resulting in no on buying the final amount. A second approach would be to frontrun an buys with a single wei transfer with the same results.\n\nNow that the auction has been extended any additional collateral added during the duration of the auction will start immediately well below the assets actual value. This allows malicious users to buy the asset for much cheaper, causing loss to the insurance fund.\n\n## Impact\n\nUsers can maliciously extend auctions and potentially get collateral for very cheap\n\n## Code Snippet\n\n[InsuranceFund.sol#L184-L199](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/InsuranceFund.sol#L184-L199)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nClose the auction if there is less than a certain threshold of a token remaining after it has been bought:\n\n        IERC20(token).safeTransfer(buyer, amount); // will revert if there wasn't enough amount as requested\n\n    +   uint256 minRemainingBalance = 1 * 10 ** (IERC20(token).decimal() - 3);\n\n        // close auction if no collateral left\n    +   if (IERC20(token).balanceOf(address(this)) <= minRemainingBalance) {\n            auctions[token].startedAt = 0;\n        }\n\n\n\n## Discussion\n\n**asquare08**\n\nThis issue can come when multi-collateral is enabled. Therefore, we will fix this with post-mainnet releases as we are launching mainnet with single collateral. \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/72",
  "Code": [
    {
      "filename": "hubble-protocol/contracts/InsuranceFund.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport { VanillaGovernable } from \"./legos/Governable.sol\";\nimport { IRegistry, IOracle, IMarginAccount, ERC20Detailed, IInsuranceFund } from \"./Interfaces.sol\";\n\n/**\n * @title The Insurance Fund acts as a backstop for the protocol. Since you can take leverage on Hubble, there is a chance that the protocol will be undercollateralized in the event of a rapid market movement. The insurance fund is used to cover any shortfalls.\n*/\ncontract InsuranceFund is VanillaGovernable, ERC20Upgradeable, IInsuranceFund {\n    using SafeERC20 for IERC20;\n\n    uint8 constant DECIMALS = 6;\n    uint constant PRECISION = 10 ** DECIMALS;\n\n    IERC20 public vusd;\n    address public marginAccount;\n    address public marginAccountHelper;\n    IOracle public oracle;\n    uint public pendingObligation;\n    uint public startPriceMultiplier;\n    uint public auctionDuration;\n\n    struct UnbondInfo {\n        uint shares;\n        uint unbondTime;\n    }\n\n    struct Auction {\n        uint startPrice;\n        uint startedAt;\n        uint expiryTime;\n    }\n\n    /// @notice token to auction mapping\n    mapping(address => Auction) public auctions;\n\n    mapping(address => UnbondInfo) public unbond;\n    uint256 public withdrawPeriod;\n    uint256 public unbondPeriod;\n    uint256 public unbondRoundOff;\n\n    uint256[50] private __gap;\n\n    event FundsAdded(address indexed insurer, uint amount, uint timestamp);\n    event Unbonded(address indexed trader, uint256 unbondAmount, uint256 unbondTime, uint timestamp);\n    event FundsWithdrawn(address indexed insurer, uint amount, uint timestamp);\n    event BadDebtAccumulated(uint amount, uint timestamp);\n\n    modifier onlyMarginAccount() {\n        require(_msgSender() == address(marginAccount), \"IF.only_margin_account\");\n        _;\n    }\n\n    modifier onlyMarginAccountHelper() {\n        require(_msgSender() == marginAccountHelper, \"IF.only_margin_account_helper\");\n        _;\n    }\n\n    function initialize(address _governance) external initializer {\n        __ERC20_init(\"Hubble-Insurance-Fund\", \"HIF\");\n        _setGovernace(_governance);\n\n        unbondPeriod = 2 days;\n        withdrawPeriod = 1 days;\n        unbondRoundOff = 1 days;\n        startPriceMultiplier = 1050000; // 1.05\n        auctionDuration = 2 hours;\n    }\n\n    /**\n     * @notice deposit vusd to the insurance fund\n     * @param amount amount to deposit\n    */\n    function deposit(uint amount) external {\n        depositFor(_msgSender(), amount);\n    }\n\n    /**\n     * @notice Deposit to the insurance fund on behalf of another address\n     * @param to address to deposit for\n    */\n    function depositFor(address to, uint amount) override public {\n        settlePendingObligation();\n        // we want to protect new LPs, when the insurance fund is in deficit\n        require(pendingObligation == 0, \"IF.deposit.pending_obligations\");\n\n        uint _pool = _totalPoolValue();\n        uint _totalSupply = totalSupply();\n        uint vusdBalance = balance();\n        if (_totalSupply == 0 && vusdBalance > 0) { // trading fee accumulated while there were no IF LPs\n            vusd.safeTransfer(governance(), vusdBalance);\n            _pool = 0;\n        }\n\n        vusd.safeTransferFrom(_msgSender(), address(this), amount);\n        uint shares = 0;\n        if (_pool == 0) {\n            shares = amount;\n        } else {\n            shares = amount * _totalSupply / _pool;\n        }\n        _mint(to, shares);\n        emit FundsAdded(to, amount, _blockTimestamp());\n    }\n\n    /**\n     * @notice Begin the withdrawal process\n    */\n    function unbondShares(uint shares) external {\n        address usr = _msgSender();\n        require(shares <= balanceOf(usr), \"unbonding_too_much\");\n        uint _now = _blockTimestamp();\n        uint unbondTime = ((_now + unbondPeriod) / unbondRoundOff) * unbondRoundOff;\n        unbond[usr] = UnbondInfo(shares, unbondTime);\n        emit Unbonded(usr, shares, unbondTime, _now);\n    }\n\n    /**\n     * @notice Withdraw funds after unbonding period is over\n    */\n    function withdraw(uint shares) external {\n        address user = _msgSender();\n        _withdrawFor(user, shares, user);\n    }\n\n    /**\n     * @notice Priviliged withdraw function used by the MarginAccountHelper to unwrap the tokens before sending it to the user\n    */\n    function withdrawFor(address user, uint shares) override external onlyMarginAccountHelper returns (uint) {\n        return _withdrawFor(user, shares, marginAccountHelper);\n    }\n\n    /**\n     * @notice Margin Account contract calls this function to seize bad debt\n    */\n    function seizeBadDebt(uint amount) override external onlyMarginAccount {\n        pendingObligation += amount;\n        emit BadDebtAccumulated(amount, block.timestamp);\n        settlePendingObligation();\n    }\n\n    /**\n     * @notice Sometimes the insurance fund may be in deficit and there might not be enough vusd to settle the obligation.\n     * Using this function obligation can be settled with future fees.\n    */\n    function settlePendingObligation() public {\n        if (pendingObligation > 0) {\n            uint toTransfer = Math.min(vusd.balanceOf(address(this)), pendingObligation);\n            if (toTransfer > 0) {\n                pendingObligation -= toTransfer;\n                vusd.safeTransfer(marginAccount, toTransfer);\n            }\n        }\n    }\n\n    /**\n     * @notice Insurance fund starts an auction for assets seized from a bad debt settlement\n     * @param token token to auction\n    */\n    function startAuction(address token) override external onlyMarginAccount {\n        if(!_isAuctionOngoing(auctions[token].startedAt, auctions[token].expiryTime)) {\n            uint currentPrice = uint(oracle.getUnderlyingPrice(token));\n            uint currentTimestamp = _blockTimestamp();\n            auctions[token] = Auction(\n                currentPrice * startPriceMultiplier / PRECISION,\n                currentTimestamp,\n                currentTimestamp + auctionDuration\n            );\n        }\n    }\n\n    /**\n    * @notice buy collateral from ongoing auction at current auction price\n    * @param token token to buy\n    * @param amount amount to buy\n    */\n    function buyCollateralFromAuction(address token, uint amount) override external {\n        Auction memory auction = auctions[token];\n        // validate auction\n        require(_isAuctionOngoing(auction.startedAt, auction.expiryTime), \"IF.no_ongoing_auction\");\n\n        // transfer funds\n        uint vusdToTransfer = _calcVusdAmountForAuction(auction, token, amount);\n        address buyer = _msgSender();\n        vusd.safeTransferFrom(buyer, address(this), vusdToTransfer);\n        IERC20(token).safeTransfer(buyer, amount); // will revert if there wasn't enough amount as requested\n\n        // close auction if no collateral left\n        if (IERC20(token).balanceOf(address(this)) == 0) {\n            auctions[token].startedAt = 0;\n        }\n    }\n\n    /* ****************** */\n    /*      Internal      */\n    /* ****************** */\n\n    function _withdrawFor(address user, uint shares, address to) internal returns (uint amount) {\n        // Checks\n        require(unbond[user].shares >= shares, \"withdrawing_more_than_unbond\");\n        uint _now = _blockTimestamp();\n        require(_now >= unbond[user].unbondTime, \"still_unbonding\");\n        require(!_hasWithdrawPeriodElapsed(_now, unbond[user].unbondTime), \"withdraw_period_over\");\n\n        // Effects\n        settlePendingObligation();\n        require(pendingObligation == 0, \"IF.withdraw.pending_obligations\");\n        amount = balance() * shares / totalSupply();\n        unchecked { unbond[user].shares -= shares; }\n        _burn(user, shares);\n\n        // Interactions\n        vusd.safeTransfer(to, amount);\n        emit FundsWithdrawn(user, amount, _now);\n    }\n\n    /* ****************** */\n    /*        View        */\n    /* ****************** */\n\n    /**\n    * @notice Just a vanity function\n    * @return The hUSD amount backing each Insurance Fund share\n    */\n    function pricePerShare() external view returns (uint) {\n        uint _totalSupply = totalSupply();\n        uint _balance = balance();\n        _balance -= Math.min(_balance, pendingObligation);\n        if (_totalSupply == 0 || _balance == 0) {\n            return PRECISION;\n        }\n        return _balance * PRECISION / _totalSupply;\n    }\n\n    function getAuctionPrice(address token) external view returns (uint) {\n        Auction memory auction = auctions[token];\n        if (_isAuctionOngoing(auction.startedAt, auction.expiryTime)) {\n            return _getAuctionPrice(auction);\n        }\n        return 0;\n    }\n\n    function calcVusdAmountForAuction(address token, uint amount) override external view returns(uint) {\n        Auction memory auction = auctions[token];\n        return _calcVusdAmountForAuction(auction, token, amount);\n    }\n\n    function isAuctionOngoing(address token) external view returns (bool) {\n        return _isAuctionOngoing(auctions[token].startedAt, auctions[token].expiryTime);\n    }\n\n    function balance() public view returns (uint) {\n        return vusd.balanceOf(address(this));\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return DECIMALS;\n    }\n\n    function _blockTimestamp() internal view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    /* ****************** */\n    /*   Internal View    */\n    /* ****************** */\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) override internal view {\n        if (from == address(0) || to == address(0)) return; // gas optimisation for _mint and _burn\n        if (!_hasWithdrawPeriodElapsed(_blockTimestamp(), unbond[from].unbondTime)) {\n            require(amount <= balanceOf(from) - unbond[from].shares, \"shares_are_unbonding\");\n        }\n    }\n\n    function _hasWithdrawPeriodElapsed(uint _now, uint _unbondTime) internal view returns (bool) {\n        return _now > (_unbondTime + withdrawPeriod);\n    }\n\n    function _getAuctionPrice(Auction memory auction) internal view returns (uint) {\n        uint diff = auction.startPrice * (_blockTimestamp() - auction.startedAt) / auctionDuration;\n        return auction.startPrice - diff;\n    }\n\n    function _isAuctionOngoing(uint startedAt, uint expiryTime) internal view returns (bool) {\n        if (startedAt == 0) return false;\n        uint currentTimestamp = _blockTimestamp();\n        return startedAt <= currentTimestamp && currentTimestamp <= expiryTime;\n    }\n\n    function _calcVusdAmountForAuction(Auction memory auction, address token, uint amount) internal view returns(uint) {\n        uint price = _getAuctionPrice(auction);\n        uint _decimals = ERC20Detailed(token).decimals();  // will fail if .decimals() is not defined on the contract\n        return amount * price / 10 ** _decimals;\n    }\n\n    function _totalPoolValue() internal view returns (uint totalBalance) {\n        IMarginAccount.Collateral[] memory assets = IMarginAccount(marginAccount).supportedAssets();\n\n        for (uint i; i < assets.length; i++) {\n            uint _balance = IERC20(address(assets[i].token)).balanceOf(address(this));\n            if (_balance == 0) continue;\n\n            uint numerator = _balance * uint(oracle.getUnderlyingPrice(address(assets[i].token)));\n            uint denomDecimals = assets[i].decimals;\n\n            totalBalance += (numerator / 10 ** denomDecimals);\n        }\n    }\n\n    /* ****************** */\n    /*   onlyGovernance   */\n    /* ****************** */\n\n    function syncDeps(address _registry) public onlyGovernance {\n        IRegistry registry = IRegistry(_registry);\n        vusd = IERC20(registry.vusd());\n        marginAccount = registry.marginAccount();\n        oracle = IOracle(registry.oracle());\n        marginAccountHelper = registry.marginAccountHelper();\n    }\n}"
    },
    {
      "filename": "hubble-protocol/contracts/InsuranceFund.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport { VanillaGovernable } from \"./legos/Governable.sol\";\nimport { IRegistry, IOracle, IMarginAccount, ERC20Detailed, IInsuranceFund } from \"./Interfaces.sol\";\n\n/**\n * @title The Insurance Fund acts as a backstop for the protocol. Since you can take leverage on Hubble, there is a chance that the protocol will be undercollateralized in the event of a rapid market movement. The insurance fund is used to cover any shortfalls.\n*/\ncontract InsuranceFund is VanillaGovernable, ERC20Upgradeable, IInsuranceFund {\n    using SafeERC20 for IERC20;\n\n    uint8 constant DECIMALS = 6;\n    uint constant PRECISION = 10 ** DECIMALS;\n\n    IERC20 public vusd;\n    address public marginAccount;\n    address public marginAccountHelper;\n    IOracle public oracle;\n    uint public pendingObligation;\n    uint public startPriceMultiplier;\n    uint public auctionDuration;\n\n    struct UnbondInfo {\n        uint shares;\n        uint unbondTime;\n    }\n\n    struct Auction {\n        uint startPrice;\n        uint startedAt;\n        uint expiryTime;\n    }\n\n    /// @notice token to auction mapping\n    mapping(address => Auction) public auctions;\n\n    mapping(address => UnbondInfo) public unbond;\n    uint256 public withdrawPeriod;\n    uint256 public unbondPeriod;\n    uint256 public unbondRoundOff;\n\n    uint256[50] private __gap;\n\n    event FundsAdded(address indexed insurer, uint amount, uint timestamp);\n    event Unbonded(address indexed trader, uint256 unbondAmount, uint256 unbondTime, uint timestamp);\n    event FundsWithdrawn(address indexed insurer, uint amount, uint timestamp);\n    event BadDebtAccumulated(uint amount, uint timestamp);\n\n    modifier onlyMarginAccount() {\n        require(_msgSender() == address(marginAccount), \"IF.only_margin_account\");\n        _;\n    }\n\n    modifier onlyMarginAccountHelper() {\n        require(_msgSender() == marginAccountHelper, \"IF.only_margin_account_helper\");\n        _;\n    }\n\n    function initialize(address _governance) external initializer {\n        __ERC20_init(\"Hubble-Insurance-Fund\", \"HIF\");\n        _setGovernace(_governance);\n\n        unbondPeriod = 2 days;\n        withdrawPeriod = 1 days;\n        unbondRoundOff = 1 days;\n        startPriceMultiplier = 1050000; // 1.05\n        auctionDuration = 2 hours;\n    }\n\n    /**\n     * @notice deposit vusd to the insurance fund\n     * @param amount amount to deposit\n    */\n    function deposit(uint amount) external {\n        depositFor(_msgSender(), amount);\n    }\n\n    /**\n     * @notice Deposit to the insurance fund on behalf of another address\n     * @param to address to deposit for\n    */\n    function depositFor(address to, uint amount) override public {\n        settlePendingObligation();\n        // we want to protect new LPs, when the insurance fund is in deficit\n        require(pendingObligation == 0, \"IF.deposit.pending_obligations\");\n\n        uint _pool = _totalPoolValue();\n        uint _totalSupply = totalSupply();\n        uint vusdBalance = balance();\n        if (_totalSupply == 0 && vusdBalance > 0) { // trading fee accumulated while there were no IF LPs\n            vusd.safeTransfer(governance(), vusdBalance);\n            _pool = 0;\n        }\n\n        vusd.safeTransferFrom(_msgSender(), address(this), amount);\n        uint shares = 0;\n        if (_pool == 0) {\n            shares = amount;\n        } else {\n            shares = amount * _totalSupply / _pool;\n        }\n        _mint(to, shares);\n        emit FundsAdded(to, amount, _blockTimestamp());\n    }\n\n    /**\n     * @notice Begin the withdrawal process\n    */\n    function unbondShares(uint shares) external {\n        address usr = _msgSender();\n        require(shares <= balanceOf(usr), \"unbonding_too_much\");\n        uint _now = _blockTimestamp();\n        uint unbondTime = ((_now + unbondPeriod) / unbondRoundOff) * unbondRoundOff;\n        unbond[usr] = UnbondInfo(shares, unbondTime);\n        emit Unbonded(usr, shares, unbondTime, _now);\n    }\n\n    /**\n     * @notice Withdraw funds after unbonding period is over\n    */\n    function withdraw(uint shares) external {\n        address user = _msgSender();\n        _withdrawFor(user, shares, user);\n    }\n\n    /**\n     * @notice Priviliged withdraw function used by the MarginAccountHelper to unwrap the tokens before sending it to the user\n    */\n    function withdrawFor(address user, uint shares) override external onlyMarginAccountHelper returns (uint) {\n        return _withdrawFor(user, shares, marginAccountHelper);\n    }\n\n    /**\n     * @notice Margin Account contract calls this function to seize bad debt\n    */\n    function seizeBadDebt(uint amount) override external onlyMarginAccount {\n        pendingObligation += amount;\n        emit BadDebtAccumulated(amount, block.timestamp);\n        settlePendingObligation();\n    }\n\n    /**\n     * @notice Sometimes the insurance fund may be in deficit and there might not be enough vusd to settle the obligation.\n     * Using this function obligation can be settled with future fees.\n    */\n    function settlePendingObligation() public {\n        if (pendingObligation > 0) {\n            uint toTransfer = Math.min(vusd.balanceOf(address(this)), pendingObligation);\n            if (toTransfer > 0) {\n                pendingObligation -= toTransfer;\n                vusd.safeTransfer(marginAccount, toTransfer);\n            }\n        }\n    }\n\n    /**\n     * @notice Insurance fund starts an auction for assets seized from a bad debt settlement\n     * @param token token to auction\n    */\n    function startAuction(address token) override external onlyMarginAccount {\n        if(!_isAuctionOngoing(auctions[token].startedAt, auctions[token].expiryTime)) {\n            uint currentPrice = uint(oracle.getUnderlyingPrice(token));\n            uint currentTimestamp = _blockTimestamp();\n            auctions[token] = Auction(\n                currentPrice * startPriceMultiplier / PRECISION,\n                currentTimestamp,\n                currentTimestamp + auctionDuration\n            );\n        }\n    }\n\n    /**\n    * @notice buy collateral from ongoing auction at current auction price\n    * @param token token to buy\n    * @param amount amount to buy\n    */\n    function buyCollateralFromAuction(address token, uint amount) override external {\n        Auction memory auction = auctions[token];\n        // validate auction\n        require(_isAuctionOngoing(auction.startedAt, auction.expiryTime), \"IF.no_ongoing_auction\");\n\n        // transfer funds\n        uint vusdToTransfer = _calcVusdAmountForAuction(auction, token, amount);\n        address buyer = _msgSender();\n        vusd.safeTransferFrom(buyer, address(this), vusdToTransfer);\n        IERC20(token).safeTransfer(buyer, amount); // will revert if there wasn't enough amount as requested\n\n        // close auction if no collateral left\n        if (IERC20(token).balanceOf(address(this)) == 0) {\n            auctions[token].startedAt = 0;\n        }\n    }\n\n    /* ****************** */\n    /*      Internal      */\n    /* ****************** */\n\n    function _withdrawFor(address user, uint shares, address to) internal returns (uint amount) {\n        // Checks\n        require(unbond[user].shares >= shares, \"withdrawing_more_than_unbond\");\n        uint _now = _blockTimestamp();\n        require(_now >= unbond[user].unbondTime, \"still_unbonding\");\n        require(!_hasWithdrawPeriodElapsed(_now, unbond[user].unbondTime), \"withdraw_period_over\");\n\n        // Effects\n        settlePendingObligation();\n        require(pendingObligation == 0, \"IF.withdraw.pending_obligations\");\n        amount = balance() * shares / totalSupply();\n        unchecked { unbond[user].shares -= shares; }\n        _burn(user, shares);\n\n        // Interactions\n        vusd.safeTransfer(to, amount);\n        emit FundsWithdrawn(user, amount, _now);\n    }\n\n    /* ****************** */\n    /*        View        */\n    /* ****************** */\n\n    /**\n    * @notice Just a vanity function\n    * @return The hUSD amount backing each Insurance Fund share\n    */\n    function pricePerShare() external view returns (uint) {\n        uint _totalSupply = totalSupply();\n        uint _balance = balance();\n        _balance -= Math.min(_balance, pendingObligation);\n        if (_totalSupply == 0 || _balance == 0) {\n            return PRECISION;\n        }\n        return _balance * PRECISION / _totalSupply;\n    }\n\n    function getAuctionPrice(address token) external view returns (uint) {\n        Auction memory auction = auctions[token];\n        if (_isAuctionOngoing(auction.startedAt, auction.expiryTime)) {\n            return _getAuctionPrice(auction);\n        }\n        return 0;\n    }\n\n    function calcVusdAmountForAuction(address token, uint amount) override external view returns(uint) {\n        Auction memory auction = auctions[token];\n        return _calcVusdAmountForAuction(auction, token, amount);\n    }\n\n    function isAuctionOngoing(address token) external view returns (bool) {\n        return _isAuctionOngoing(auctions[token].startedAt, auctions[token].expiryTime);\n    }\n\n    function balance() public view returns (uint) {\n        return vusd.balanceOf(address(this));\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return DECIMALS;\n    }\n\n    function _blockTimestamp() internal view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    /* ****************** */\n    /*   Internal View    */\n    /* ****************** */\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) override internal view {\n        if (from == address(0) || to == address(0)) return; // gas optimisation for _mint and _burn\n        if (!_hasWithdrawPeriodElapsed(_blockTimestamp(), unbond[from].unbondTime)) {\n            require(amount <= balanceOf(from) - unbond[from].shares, \"shares_are_unbonding\");\n        }\n    }\n\n    function _hasWithdrawPeriodElapsed(uint _now, uint _unbondTime) internal view returns (bool) {\n        return _now > (_unbondTime + withdrawPeriod);\n    }\n\n    function _getAuctionPrice(Auction memory auction) internal view returns (uint) {\n        uint diff = auction.startPrice * (_blockTimestamp() - auction.startedAt) / auctionDuration;\n        return auction.startPrice - diff;\n    }\n\n    function _isAuctionOngoing(uint startedAt, uint expiryTime) internal view returns (bool) {\n        if (startedAt == 0) return false;\n        uint currentTimestamp = _blockTimestamp();\n        return startedAt <= currentTimestamp && currentTimestamp <= expiryTime;\n    }\n\n    function _calcVusdAmountForAuction(Auction memory auction, address token, uint amount) internal view returns(uint) {\n        uint price = _getAuctionPrice(auction);\n        uint _decimals = ERC20Detailed(token).decimals();  // will fail if .decimals() is not defined on the contract\n        return amount * price / 10 ** _decimals;\n    }\n\n    function _totalPoolValue() internal view returns (uint totalBalance) {\n        IMarginAccount.Collateral[] memory assets = IMarginAccount(marginAccount).supportedAssets();\n\n        for (uint i; i < assets.length; i++) {\n            uint _balance = IERC20(address(assets[i].token)).balanceOf(address(this));\n            if (_balance == 0) continue;\n\n            uint numerator = _balance * uint(oracle.getUnderlyingPrice(address(assets[i].token)));\n            uint denomDecimals = assets[i].decimals;\n\n            totalBalance += (numerator / 10 ** denomDecimals);\n        }\n    }\n\n    /* ****************** */\n    /*   onlyGovernance   */\n    /* ****************** */\n\n    function syncDeps(address _registry) public onlyGovernance {\n        IRegistry registry = IRegistry(_registry);\n        vusd = IERC20(registry.vusd());\n        marginAccount = registry.marginAccount();\n        oracle = IOracle(registry.oracle());\n        marginAccountHelper = registry.marginAccountHelper();\n    }\n}"
    }
  ]
}