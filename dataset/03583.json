{
  "Title": "[H01] Corruptible storage upgradeability pattern",
  "Content": "Both [`RibbonThetaVault`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/RibbonThetaVault.sol) and [`RibbonDeltaVault`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/RibbonDeltaVault.sol) inherit from [`RibbonVault`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/storage/OptionsVaultStorage.sol) and either [`OptionsThetaVaultStorage`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/storage/OptionsVaultStorage.sol#L83) or [`OptionsDeltaVaultStorage`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/storage/OptionsVaultStorage.sol#L85), respectively. `RibbonVault` itself inherits from [`OptionsVaultStorage`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/storage/OptionsVaultStorage.sol#L79), so that the latter is also inherited by both the `RibbonThetaVault` and `RibbonDeltaVault`.\n\n\nAll of these storage contracts reside in [`OptionsVaultStorage`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/storage/OptionsVaultStorage.sol) as “top-level” storage contracts. Each of these top-level contracts inherit from additional “storage contracts” that are suffixed with a version number, e.g.: `OptionsVaultStorage` inherits from `OptionsVaultStorageV1`. The intent is to allow for upgradeability of the storage layout of the top-level storage contracts by just having them inherit from additional storage contracts as necessary.\n\n\nThe [inline comments](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/storage/OptionsVaultStorage.sol#L75-L78) explain the intention well:\n\n\n\n> \n>  When we need to add new storage variables, we create a new version of OptionsVaultStorage e.g. OptionsVaultStorageV, so finally it would look like contract OptionsVaultStorage is OptionsVaultStorageV1, OptionsVaultStorageV2\n> \n> \n> \n\n\nThe issue is that multiple top-level storage contracts are being inherited by the `RibbonThetaVault` and `RibbonDeltaVault` contracts. This storage upgradeability pattern is not composable in this manner without modifications. In both cases, upgrading `OptionsVaultStorage` to include additional storage slots would shift storage slots from any subsequently inherited top-level storage contracts, thus corrupting the storage layout.\n\n\nSince the newly upgraded smart contracts would be reading from some storage slots that held data which would no longer correspond to the new storage layout, the system would break in an unpredictable manner that would be dependent on the number of storage slots added as part of the upgrade.\n\n\nConsider reserving storage slots in `OptionsVaultStorage` so that any future upgrades to that contract will not shift the storage slots of other top-level storage contracts. A common pattern is to use a [`__gap` array for this purpose](https://docs.openzeppelin.com/contracts/3.x/upgradeable#storage_gaps) and to decrement the number of slots used by the `__gap` as necessary during upgrades. Alternatively, consider making `OptionsVaultStorage` non-upgradeable and only allowing `OptionsThetaVaultStorage` and `OptionsDeltaVaultStorage` to be upgradeable. Also consider adding additional inline comments explaining the limitations of this upgradeability pattern in practice to avoid future iterations reintroducing corruptible upgradeable storage layouts.\n\n\n**Update**: *Fixed in commit [`b362625ae3c6917f41e801ddf7a5bd5d4d8fb295` of PR#85](https://github.com/ribbon-finance/ribbon-v2/pull/85/commits/b362625ae3c6917f41e801ddf7a5bd5d4d8fb295).*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/storage/OptionsVaultStorage.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.2;\n\nimport {\n    ReentrancyGuardUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {\n    ERC20Upgradeable\n} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {Vault} from \"../libraries/Vault.sol\";\nimport {IRibbonThetaVault} from \"../interfaces/IRibbonThetaVault.sol\";\n\nabstract contract OptionsVaultStorageV1 is\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable,\n    ERC20Upgradeable\n{\n    /// @notice Stores the user's pending deposit for the round\n    mapping(address => Vault.DepositReceipt) public depositReceipts;\n\n    /// @notice On every round's close, the pricePerShare value of an rTHETA token is stored\n    /// This is used to determine the number of shares to be returned\n    /// to a user with their DepositReceipt.depositAmount\n    mapping(uint16 => uint256) public roundPricePerShare;\n\n    /// @notice Stores pending user withdrawals\n    mapping(address => Vault.Withdrawal) public withdrawals;\n\n    Vault.VaultParams public vaultParams;\n\n    Vault.VaultState public vaultState;\n\n    Vault.OptionState public optionState;\n\n    address public feeRecipient;\n\n    uint256 public performanceFee;\n\n    uint256 public managementFee;\n}\n\nabstract contract OptionsThetaVaultStorageV1 {\n    // Logic contract used to price options\n    address public optionsPremiumPricer;\n    // Logic contract used to select strike prices\n    address public strikeSelection;\n    // Premium discount on options we are selling (thousandths place: 000 - 999)\n    uint32 public premiumDiscount;\n    // Current oToken premium\n    uint104 public currentOtokenPremium;\n    // Last round id at which the strike was manually overridden\n    uint16 public lastStrikeOverride;\n    // Price last overridden strike set to\n    uint128 public overriddenStrikePrice;\n    // Auction duration\n    uint256 public auctionDuration;\n    // Auction id of current option\n    uint256 public optionAuctionID;\n}\n\nabstract contract OptionsDeltaVaultStorageV1 {\n    // Ribbon counterparty theta vault\n    IRibbonThetaVault public counterpartyThetaVault;\n    // % of funds to be used for weekly option purchase\n    uint256 public optionAllocationPct;\n    // Delta vault equivalent of lockedAmount\n    uint104 public balanceBeforePremium;\n    // User Id of delta vault in latest gnosis auction\n    Vault.AuctionSellOrder public auctionSellOrder;\n}\n\n// We are following Compound's method of upgrading new contract implementations\n// When we need to add new storage variables, we create a new version of OptionsVaultStorage\n// e.g. OptionsVaultStorageV<versionNumber>, so finally it would look like\n// contract OptionsVaultStorage is OptionsVaultStorageV1, OptionsVaultStorageV2\nabstract contract OptionsVaultStorage is OptionsVaultStorageV1 {\n\n}\n\nabstract contract OptionsThetaVaultStorage is OptionsThetaVaultStorageV1 {}\n\nabstract contract OptionsDeltaVaultStorage is OptionsDeltaVaultStorageV1 {}"
    }
  ]
}