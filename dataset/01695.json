{
  "Title": "H-5: The `_estimateWithdrawalLp` function might return a very large value, result in users losing significant incentives or being unable to withdraw from the Dispatcher contract",
  "Content": "# Issue H-5: The `_estimateWithdrawalLp` function might return a very large value, result in users losing significant incentives or being unable to withdraw from the Dispatcher contract \n\nSource: https://github.com/sherlock-audit/2023-06-real-wagmi-judging/issues/142 \n\n## Found by \ncrimson-rat-reach, duc, qpzm\n## Summary\nThe `_estimateWithdrawalLp` function might return a very large value, result in users losing significant incentives or being unable to withdraw from the Dispatcher contract\n## Vulnerability Detail\nIn Dispatcher contract, `_estimateWithdrawalLp` function returns the value of shares amount based on the average of ratios `amount0 / reserve0` and `amount1 / reserve1`.\n```solidity=\nfunction _estimateWithdrawalLp(\n    uint256 reserve0,\n    uint256 reserve1,\n    uint256 _totalSupply,\n    uint256 amount0,\n    uint256 amount1\n) private pure returns (uint256 shareAmount) {\n    shareAmount =\n        ((amount0 * _totalSupply) / reserve0 + (amount1 * _totalSupply) / reserve1) /\n        2;\n}\n```\nFrom `Dispatcher.withdraw` and `Dispatcher.deposit` function, amount0 and amount1 will be the accumulated fees of users\n```solidity=\nuint256 lpAmount;\n{\n    (uint256 fee0, uint256 fee1) = _calcFees(feesGrow, user);\n    lpAmount = _estimateWithdrawalLp(reserve0, reserve1, _totalSupply, fee0, fee1);\n}\nuser.shares -= lpAmount;\n_withdrawFee(pool, lpAmount, reserve0, reserve1, _totalSupply, deviationBP);\n```\nHowever, it is important to note that the values of reserve0 and reserve1 can fluctuate significantly. This is because the positions of the Multipool in UniSwapV3 pools (concentrated) are unstable on-chain, and they can change substantially as the state of the pools changes. As a result, the `_estimateWithdrawalLp` function might return a large value even for a small fee amount. This could potentially lead to reverting due to underflow in the deposit function (in cases where `lpAmount > user.shares`), or it could result in withdrawing a larger amount of Multipool LP than initially expected.\n\nScenario:\n1. Total supply of Multipool is 1e18, and Alice has 1e16  (1%) LP amounts which deposited into Dispatcher contract.\n2. Alice accrued fees = 200 USDC and 100 USDT\n3. The reserves of Multipool are 100,000 USDC and 100,000 USDT, `_estimateWithdrawalLp` of Alice fees will be `(0.2% + 0.1%) / 2 * totalSupply` = `0.15% * totalSupply` = 1.5e15 LP amounts\n4. However, in some cases, UniSwapV3 pools may experience fluctuations, reserves of Multipool are 10,000 USDC and 190,000 USDT, `_estimateWithdrawalLp` of Alice fees will be `(2% + 0.052%) / 2 * totalSupply` = `1.026% * totalSupply` = 1.026e16 LP amounts\nThis result is greater than LP amounts of Alice (1e16), leading to reverting by underflow in deposit/withdraw function of Dispatcher contract.\n## Impact\nUsers may face 2 potential issues when interacting with the Dispatcher contract. \n1. They might be unable to deposit/withdraw\n2. Secondly, users could potentially lose significant incentives when depositing or withdrawing due to unexpected withdrawals of LP amounts for their fees.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-06-real-wagmi/blob/main/concentrator/contracts/Dispatcher.sol#L140-L150\n## Tool used\nManual review\n\n## Recommendation\nShouldn't use the average ratio for calculation in`_estimateWithdrawalLp` function\n\n\n\n## Discussion\n\n**ctf-sec**\n\nThink can change the severity to medium\n\n**huuducsc**\n\nEscalate\n\nI believe the severity of this issue is high. There is no reason for downgrading this issue to medium, since it has high impact and high likelihood.\nThe state of the UniswapV3 pool always changes, which causes the reserves of the Multipool contract (Multipool.getReserve()) to fluctuate significantly. The reserves of the Multipool contract are accumulated from all token amounts of each position. ([code snippet](https://github.com/sherlock-audit/2023-06-real-wagmi/blob/main/concentrator/contracts/Multipool.sol#L748-L753)). \nIt is a fact that if the tick range of a position is short, the token amounts of this position can change significantly by 1 swap, for example, from (1e21, 0) to (0, 1e21)! This is because the amounts of each position depend on the situation of the current `sqrtP` (square root of the price) of this pool within the tick range of this position. \nTherefore, using the average calculation for `_estimateWithdrawalLp` function always puts users at risk of significant loss.\n\n**sherlock-admin**\n\n > Escalate\n> \n> I believe the severity of this issue is high. There is no reason for downgrading this issue to medium, since it has high impact and high likelihood.\n> The state of the UniswapV3 pool always changes, which causes the reserves of the Multipool contract (Multipool.getReserve()) to fluctuate significantly. The reserves of the Multipool contract are accumulated from all token amounts of each position. ([code snippet](https://github.com/sherlock-audit/2023-06-real-wagmi/blob/main/concentrator/contracts/Multipool.sol#L748-L753)). \n> It is a fact that if the tick range of a position is short, the token amounts of this position can change significantly by 1 swap, for example, from (1e21, 0) to (0, 1e21)! This is because the amounts of each position depend on the situation of the current `sqrtP` (square root of the price) of this pool within the tick range of this position. \n> Therefore, using the average calculation for `_estimateWithdrawalLp` function always puts users at risk of significant loss.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**fann95**\n\nfixed https://github.com/RealWagmi/concentrator/blob/fbccf1caf28edbb23db8c7e0409d0c40c3a56461/contracts/Dispatcher.sol#L268\nand https://github.com/RealWagmi/concentrator/blob/fbccf1caf28edbb23db8c7e0409d0c40c3a56461/contracts/Dispatcher.sol#L409C17-L409C17\n\n**JeffCX**\n\nBased on the impact\n\n> Users may face 2 potential issues when interacting with the Dispatcher contract.\n\nThey might be unable to deposit/withdraw\nSecondly, users could potentially lose significant incentives when depositing or withdrawing due to unexpected withdrawals of LP amounts for their fees.\n\nAll impact is medium except  when user are not able to withdraw and withdraw revert in underflow,\n\nI think a high severity is ok\n\n**hrishibhat**\n\n@huuducsc This revert happens only when there is a massive fluctuation in the pool right? These seem to be temporary or extreme cases. I think this should be a medium.\n\n**huuducsc**\n\n> @huuducsc This revert happens only when there is a massive fluctuation in the pool right? These seem to be temporary or extreme cases. I think this should be a medium.\n\nFluctuations in positions usually occur in an UniswapV3 pool, which utilizes a concentrated price mechanism. For example, if the price of ARB is currently 1.25 USDC, and the Multipool contract holds a position in the ARB-USDC pool with a price range of [1.245, 1.255], then the ratio of tokens (token0/token1) in this position is 1:1. However, if the price of ARB increases to 1.253, the ratio of tokens in this position changes to 2:8.\n\n**hrishibhat**\n\nResult:\nHigh\nHas duplicates\nAgree with the above comments and the impact mentioned in its duplicates considering this a valid high as the price change can get user funds to be stuck forever. \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [huuducsc](https://github.com/sherlock-audit/2023-06-real-wagmi-judging/issues/142/#issuecomment-1632894153): accepted\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/88",
  "Code": [
    {
      "filename": "concentrator/contracts/Dispatcher.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@uniswap/v3-core/contracts/libraries/FixedPoint128.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { FullMath, LiquidityAmounts } from \"./vendor0.8/uniswap/LiquidityAmounts.sol\";\nimport \"./interfaces/IMultipool.sol\";\n\n// import \"hardhat/console.sol\";\n\ncontract Dispatcher is Ownable {\n    using SafeERC20 for IERC20;\n    struct UserInfo {\n        uint256 shares;\n        uint256 feeDebt0;\n        uint256 feeDebt1;\n    }\n\n    struct PoolInfo {\n        address owner;\n        address multipool;\n        address strategy;\n        address token0;\n        address token1;\n    }\n\n    uint256 public constant MAX_DEVIATION = 1000;\n\n    PoolInfo[] public poolInfo;\n    ///         pid =>(userAddress=>UserInfo)\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n\n    event AddNewPool(address _multipool);\n    event Deposit(address user, uint256 pid, uint256 amount);\n    event Withdraw(address user, uint256 pid, uint256 amount);\n\n    modifier checkPid(uint256 pid) {\n        require(pid < poolInfo.length, \"invalid pid\");\n        _;\n    }\n\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    /**\n     * @dev Add a new multipool to the list of supported pools.\n     * @param _owner Address of the pool owner\n     * @param _multipool Address of the multipool\n     * @param _strategy Address of the strategy contract that manages the pool\n     * @param _token0 Address of the first token in the pool\n     * @param _token1 Address of the second token in the pool\n     */\n    function add(\n        address _owner,\n        address _multipool,\n        address _strategy,\n        address _token0,\n        address _token1\n    ) external onlyOwner {\n        PoolInfo memory pInfo = PoolInfo({\n            owner: _owner,\n            multipool: _multipool,\n            strategy: _strategy,\n            token0: _token0,\n            token1: _token1\n        });\n\n        poolInfo.push(pInfo);\n        emit AddNewPool(_multipool);\n    }\n\n    function _pay(address token, address payer, address recipient, uint256 value) private {\n        if (value > 0) {\n            if (payer == address(this)) {\n                IERC20(token).safeTransfer(recipient, value);\n            } else {\n                IERC20(token).safeTransferFrom(payer, recipient, value);\n            }\n        }\n    }\n\n    function _calcFees(\n        IMultipool.FeeGrowth memory growth,\n        UserInfo memory user\n    ) private pure returns (uint256 amount0, uint256 amount1) {\n        amount0 = FullMath.mulDiv(\n            user.shares,\n            growth.accPerShare0 - user.feeDebt0,\n            FixedPoint128.Q128\n        );\n        amount1 = FullMath.mulDiv(\n            user.shares,\n            growth.accPerShare1 - user.feeDebt1,\n            FixedPoint128.Q128\n        );\n    }\n\n    /**\n     * @dev Estimates the amount of tokens that can be claimed by a user, and the corresponding LP tokens\n     *      that would need to be removed from the pool.\n     *      The claimable amount is based on the user's shares in the pool and the accumulated fees.\n     * @param pid The ID of the pool to query\n     * @param userAddress The address of the user\n     * @return lpAmountRemoved The estimated number of LP tokens that would need to be removed to withdraw the user's entire share\n     * @return amount0 The estimated amount of token0 that can be claimed by the user\n     * @return amount1 The estimated amount of token1 that can be claimed by the user\n     */\n    function estimateClaim(\n        uint256 pid,\n        address userAddress\n    )\n        external\n        view\n        checkPid(pid)\n        returns (uint256 lpAmountRemoved, uint256 amount0, uint256 amount1)\n    {\n        PoolInfo memory pool = poolInfo[pid];\n        UserInfo memory user = userInfo[pid][userAddress];\n        if (user.shares > 0) {\n            IMultipool.FeeGrowth memory feesGrow = IMultipool(pool.multipool)\n                .feesGrowthInsideLastX128();\n            (uint256 fee0, uint256 fee1) = _calcFees(feesGrow, user);\n            (\n                uint256 reserve0,\n                uint256 reserve1,\n                uint256 pendingFee0,\n                uint256 pendingFee1\n            ) = IMultipool(pool.multipool).getReserves();\n            uint256 _totalSupply = IERC20(pool.multipool).totalSupply();\n            fee0 += (pendingFee0 * user.shares) / _totalSupply;\n            fee1 += (pendingFee1 * user.shares) / _totalSupply;\n            lpAmountRemoved = _estimateWithdrawalLp(reserve0, reserve1, _totalSupply, fee0, fee1);\n            amount0 = (reserve0 * lpAmountRemoved) / _totalSupply;\n            amount1 = (reserve1 * lpAmountRemoved) / _totalSupply;\n        }\n    }\n\n    function _estimateWithdrawalLp(\n        uint256 reserve0,\n        uint256 reserve1,\n        uint256 _totalSupply,\n        uint256 amount0,\n        uint256 amount1\n    ) private pure returns (uint256 shareAmount) {\n        shareAmount =\n            ((amount0 * _totalSupply) / reserve0 + (amount1 * _totalSupply) / reserve1) /\n            2;\n    }\n\n    function _withdrawFee(\n        PoolInfo memory pool,\n        uint256 lpAmount,\n        uint256 reserve0,\n        uint256 reserve1,\n        uint256 _totalSupply,\n        uint256 deviationBP\n    ) private {\n        uint256 amount0OutMin = (reserve0 * lpAmount * deviationBP) /\n            (_totalSupply * MAX_DEVIATION);\n        uint256 amount1OutMin = (reserve1 * lpAmount * deviationBP) /\n            (_totalSupply * MAX_DEVIATION);\n        (uint256 withdrawnAmount0, uint256 withdrawnAmount1) = IMultipool(pool.multipool).withdraw(\n            lpAmount,\n            amount0OutMin,\n            amount1OutMin\n        );\n        _pay(pool.token0, address(this), msg.sender, withdrawnAmount0);\n        _pay(pool.token1, address(this), msg.sender, withdrawnAmount1);\n    }\n\n    /**\n     * @dev Deposit multipools LP tokens to track fees and updates user's balance and fee debts.\n     * calculation of the received fees goes on without taking into account losses during rebalancing.\n     * @param pid Identifier of the pool\n     * @param amount Amount of LP tokens to be deposited.If the amount is null, then will be just claimed  the fees\n     * @param deviationBP The deviation basis points used for calculating withdrawal fees\n     */\n    function deposit(uint256 pid, uint256 amount, uint256 deviationBP) external checkPid(pid) {\n        PoolInfo memory pool = poolInfo[pid];\n        UserInfo storage user = userInfo[pid][msg.sender];\n        (\n            uint256 reserve0,\n            uint256 reserve1,\n            IMultipool.FeeGrowth memory feesGrow,\n            uint256 _totalSupply\n        ) = IMultipool(pool.multipool).snapshot();\n        if (user.shares > 0) {\n            uint256 lpAmount;\n            {\n                (uint256 fee0, uint256 fee1) = _calcFees(feesGrow, user);\n                lpAmount = _estimateWithdrawalLp(reserve0, reserve1, _totalSupply, fee0, fee1);\n            }\n            user.shares -= lpAmount;\n            _withdrawFee(pool, lpAmount, reserve0, reserve1, _totalSupply, deviationBP);\n        }\n\n        if (amount > 0) {\n            _pay(pool.multipool, msg.sender, address(this), amount);\n            user.shares += amount;\n        }\n        user.feeDebt0 = feesGrow.accPerShare0;\n        user.feeDebt1 = feesGrow.accPerShare1;\n\n        emit Deposit(msg.sender, pid, amount);\n    }\n\n    /**\n     * @dev Allows a user to withdraw their Lp-share from a specific pool and receive their proportionate share of fees.\n     * @param pid The ID of the Uniswap pool in which the user has invested\n     * @param amount The amount of LP tokens to withdraw from the pool\n     * @param deviationBP The deviation basis points used for calculating withdrawal fees\n     */\n    function withdraw(uint256 pid, uint256 amount, uint256 deviationBP) external checkPid(pid) {\n        PoolInfo memory pool = poolInfo[pid];\n        UserInfo storage user = userInfo[pid][msg.sender];\n        (\n            uint256 reserve0,\n            uint256 reserve1,\n            IMultipool.FeeGrowth memory feesGrow,\n            uint256 _totalSupply\n        ) = IMultipool(pool.multipool).snapshot();\n\n        require(user.shares > 0, \"user.shares is 0\");\n        require(_totalSupply > 0, \"sharesTotal is 0\");\n        if (amount > user.shares) {\n            // withdraw witout claiming\n            amount = user.shares;\n        } else if (amount < user.shares) {\n            uint256 lpAmount;\n            {\n                (uint256 fee0, uint256 fee1) = _calcFees(feesGrow, user);\n                lpAmount = _estimateWithdrawalLp(reserve0, reserve1, _totalSupply, fee0, fee1);\n            }\n            user.shares -= lpAmount;\n            _withdrawFee(pool, lpAmount, reserve0, reserve1, _totalSupply, deviationBP);\n        }\n\n        uint256 sharesRemoved = amount > user.shares ? user.shares : amount;\n        user.shares -= sharesRemoved;\n\n        user.feeDebt0 = feesGrow.accPerShare0;\n        user.feeDebt1 = feesGrow.accPerShare1;\n        _pay(pool.multipool, address(this), msg.sender, sharesRemoved);\n\n        emit Withdraw(msg.sender, pid, amount);\n    }\n}"
    },
    {
      "filename": "concentrator/contracts/Multipool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@uniswap/v3-core/contracts/libraries/FixedPoint128.sol\";\nimport { IUniswapV3Pool } from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport { Babylonian } from \"./vendor0.8/uniswap/Babylonian.sol\";\nimport { FullMath, LiquidityAmounts } from \"./vendor0.8/uniswap/LiquidityAmounts.sol\";\nimport { TickMath } from \"./vendor0.8/uniswap/TickMath.sol\";\nimport { PositionKey } from \"@uniswap/v3-periphery/contracts/libraries/PositionKey.sol\";\nimport { ErrLib } from \"./libraries/ErrLib.sol\";\nimport { IMultiStrategy } from \"./interfaces/IMultiStrategy.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\n\n// import \"hardhat/console.sol\";\n\ncontract Multipool is Ownable, ERC20 {\n    error InvalidManaging();\n    error InvalidFee(uint24 fee);\n\n    enum MANAGING {\n        MAXTOTALSUPPLY,\n        PROTOCOLFEEWEIGHT,\n        OPERATOR,\n        TWAPDURATION,\n        MAXTWAPDEVIATION\n    }\n\n    struct Slot0Data {\n        int24 tick;\n        uint160 currentSqrtRatioX96;\n    }\n\n    struct PositionInfo {\n        int24 lowerTick;\n        int24 upperTick;\n        uint24 poolFeeAmt;\n        uint256 weight;\n        address poolAddress;\n        bytes32 positionKey;\n    }\n\n    struct RebalanceParams {\n        // The direction of the swap, true for token0 to token1, false for token1 to token0\n        bool zeroForOne;\n        // Aggregator's router address\n        address swapTarget;\n        // The amount of the swap\n        uint amountIn;\n        // Aggregator's data that stores pathes and amounts swap through\n        bytes swapData;\n    }\n\n    struct UnderlyingPool {\n        int24 tickSpacing;\n        address poolAddress;\n    }\n\n    struct FeeGrowth {\n        uint256 accPerShare0;\n        uint256 accPerShare1;\n        uint256 gmiAccPerShare0;\n        uint256 gmiAccPerShare1;\n    }\n\n    IUniswapV3Factory public immutable underlyingV3Factory;\n    uint24[] public fees;\n    bool private entered;\n    address private constant burnAddress = 0x000000000000000000000000000000000000dEaD;\n    IMultiStrategy public immutable strategy;\n    uint256 public constant MAX_WEIGHT_UINT256 = 10000;\n    uint256 public constant MINIMUM_LIQUIDITY = 1000;\n    uint256 public constant MINIMUM_AMOUNT = 1000_000;\n    address public immutable multiFactory;\n    address public immutable token0;\n    address public immutable token1;\n\n    address operator;\n\n    uint256 public protocolFeeWeightMax = 2000; //20 %\n    uint256 public protocolFeeWeight = 2000;\n\n    uint256 public maxTotalSupply = 1e20;\n\n    uint256 public maxTwapDeviation = 100; // 1%\n\n    uint32 public twapDuration = 150;\n    /**\n     * @dev The accumulated fee per share of liquidity multiplied by FixedPoint128.Q128.\n     * Tthe amount of pending fees per share should be added to the userRewardDebt variable.\n     */\n    FeeGrowth public feesGrowthInsideLastX128;\n\n    //      fee =>poolAddress\n    mapping(uint24 => UnderlyingPool) public underlyingTrustedPools;\n\n    mapping(address => bool) public approvedTargets;\n\n    PositionInfo[] public multiPosition;\n\n    event Deposit(address user, uint256 amount0, uint256 amount1, uint256 liquidity);\n    event Withdraw(address user, uint256 amount0, uint256 amount1, uint256 liquidity);\n    event Rebalance(\n        uint256 reserve0Before,\n        uint256 reserve1Before,\n        uint256 reserve0,\n        uint256 reserve1,\n        uint256 swappedOut\n    );\n    event SwapTargetApproved(address indexed target, bool approved);\n    event ParamChanged(MANAGING managing, uint param);\n    event TrustedPoolAdded(uint24 fee, address poolAddress);\n\n    constructor(\n        address _token0,\n        address _token1,\n        address manager,\n        address _underlyingV3Factory,\n        IMultiStrategy _strategy,\n        string memory _name,\n        string memory _symbol,\n        uint24[] memory _fees\n    ) ERC20(_name, _symbol) {\n        IUniswapV3Factory factory = IUniswapV3Factory(_underlyingV3Factory);\n\n        for (uint256 i = 0; i < _fees.length; ) {\n            _addUnderlyingPool(_fees[i], _token0, _token1, factory);\n            unchecked {\n                ++i;\n            }\n        }\n        underlyingV3Factory = factory;\n\n        multiFactory = msg.sender;\n\n        strategy = _strategy;\n        token0 = _token0;\n        token1 = _token1;\n\n        _transferOwnership(manager);\n        operator = manager;\n    }\n\n    modifier nonReentrant() {\n        require(!entered, \"RC\");\n        entered = true;\n        _;\n        entered = false;\n    }\n\n    function addUnderlyingPool(uint24 fee) external onlyOwner {\n        _addUnderlyingPool(fee, token0, token1, underlyingV3Factory);\n    }\n\n    function _addUnderlyingPool(\n        uint24 _fee,\n        address _token0,\n        address _token1,\n        IUniswapV3Factory _factory\n    ) private {\n        address poolAddress = _factory.getPool(_token0, _token1, _fee);\n\n        if (poolAddress == address(0)) {\n            revert InvalidFee(_fee);\n        }\n        underlyingTrustedPools[_fee] = UnderlyingPool({\n            tickSpacing: IUniswapV3Pool(poolAddress).tickSpacing(),\n            poolAddress: poolAddress\n        });\n        fees.push(_fee);\n        emit TrustedPoolAdded(_fee, poolAddress);\n    }\n\n    function _safeTransfer(address token, address to, uint256 value) private {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20.transfer.selector, to, value)\n        );\n        ErrLib.requirement(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            ErrLib.ErrorCode.ERC20_TRANSFER_DID_NOT_SUCCEED\n        );\n    }\n\n    function _safeTransferFrom(address token, address from, address to, uint256 value) private {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value)\n        );\n        ErrLib.requirement(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            ErrLib.ErrorCode.ERC20_TRANSFER_FROM_DID_NOT_SUCCEED\n        );\n    }\n\n    function _safeApprove(address token, address spender, uint256 amount) private {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20.approve.selector, spender, amount)\n        );\n        ErrLib.requirement(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            ErrLib.ErrorCode.ERC20_APPROVE_DID_NOT_SUCCEED\n        );\n    }\n\n    /**\n     * @dev Takes a snapshot of current state and returns various information related to multi pool.\n     * @return reserve0 Amount of token0 in the reserve\n     * @return reserve1 Amount of token1 in the reserve\n     * @return feesGrow A structure containing fee growth information\n     * @return _totalSupply Total number of LP tokens minted\n     */\n    function snapshot()\n        external\n        returns (\n            uint256 reserve0,\n            uint256 reserve1,\n            FeeGrowth memory feesGrow,\n            uint256 _totalSupply\n        )\n    {\n        _totalSupply = totalSupply();\n        _earn(_totalSupply);\n        Slot0Data[] memory slots = getSlots();\n        (reserve0, reserve1, , ) = _getReserves(slots);\n        feesGrow = feesGrowthInsideLastX128;\n    }\n\n    /**\n     * @notice This function collects fees from the liquidity pool and updates the fee growth inside both Vaults per share\n     *         based on the amount of fees collected. It then returns the updated fee growth values.\n     * @dev When called, this function updates the fee growth inside each Vault according to the realised fees in the current block,\n     *      adding them to the `feesGrowthInsideLastX128` struct member variable of the contract.\n     */\n    function earn() external {\n        uint256 _totalSupply = totalSupply();\n        _earn(_totalSupply);\n    }\n\n    function _earn(uint256 _totalSupply) private {\n        if (_totalSupply > 0) {\n            _withdraw(0, _totalSupply);\n        }\n    }\n\n    function _checkTicks(int24 tickLower, int24 tickUpper, int24 _tickSpacing) private pure {\n        ErrLib.requirement(tickLower < tickUpper, ErrLib.ErrorCode.LOWER_SHOULD_BE_LESS_UPPER);\n        ErrLib.requirement(tickLower >= TickMath.MIN_TICK, ErrLib.ErrorCode.LOWER_TOO_SMALL);\n        ErrLib.requirement(tickUpper <= TickMath.MAX_TICK, ErrLib.ErrorCode.UPPER_TOO_BIG);\n        ErrLib.requirement(tickLower % _tickSpacing == 0, ErrLib.ErrorCode.TICKLOWER_IS_NOT_SPACED);\n        ErrLib.requirement(tickUpper % _tickSpacing == 0, ErrLib.ErrorCode.TICKUPPER_IS_NOT_SPACED);\n    }\n\n    function _getTicksForPosition(\n        int24 tick,\n        int24 positionRange,\n        int24 tickSpacingOffset,\n        int24 tickSpacing\n    ) private pure returns (int24 lowerTick, int24 upperTick) {\n        int24 floorTick = (tick / tickSpacing) * tickSpacing;\n        if (tickSpacingOffset == 0) {\n            lowerTick = floorTick - (positionRange - tickSpacing) / 2;\n            upperTick = floorTick + (positionRange + tickSpacing) / 2;\n        } else if (tickSpacingOffset > 0) {\n            lowerTick = floorTick + tickSpacing * tickSpacingOffset;\n            upperTick = lowerTick + positionRange;\n        } else {\n            upperTick = floorTick + tickSpacing * tickSpacingOffset;\n            lowerTick = upperTick - positionRange;\n        }\n    }\n\n    function _initializeStrategy() private returns (Slot0Data[] memory) {\n        uint256 positionsNum = strategy.strategySize();\n        ErrLib.requirement(positionsNum > 0, ErrLib.ErrorCode.STRATEGY_DOES_NOT_EXIST);\n        delete multiPosition;\n        PositionInfo memory position;\n        int24 upperTick;\n        int24 lowerTick;\n        Slot0Data[] memory slots = new Slot0Data[](positionsNum);\n\n        for (uint256 i = 0; i < positionsNum; ) {\n            IMultiStrategy.Strategy memory sPosition = strategy.getStrategyAt(i);\n            UnderlyingPool memory uPool = underlyingTrustedPools[sPosition.poolFeeAmt];\n            position.poolFeeAmt = sPosition.poolFeeAmt;\n            position.weight = sPosition.weight;\n            position.poolAddress = uPool.poolAddress;\n            (slots[i].currentSqrtRatioX96, slots[i].tick, , , , , ) = IUniswapV3Pool(\n                uPool.poolAddress\n            ).slot0();\n            (lowerTick, upperTick) = _getTicksForPosition(\n                slots[i].tick,\n                sPosition.positionRange,\n                sPosition.tickSpacingOffset,\n                uPool.tickSpacing\n            );\n            _checkTicks(lowerTick, upperTick, uPool.tickSpacing);\n            position.upperTick = upperTick;\n            position.lowerTick = lowerTick;\n            position.positionKey = PositionKey.compute(\n                address(this),\n                position.lowerTick,\n                position.upperTick\n            );\n\n            multiPosition.push(position);\n            unchecked {\n                ++i;\n            }\n        }\n        return slots;\n    }\n\n    function _calcLiquidityAmountToDeposit(\n        uint160 currentSqrtRatioX96,\n        PositionInfo memory position,\n        uint256 amount0Desired,\n        uint256 amount1Desired\n    ) private pure returns (uint128 liquidity) {\n        liquidity = LiquidityAmounts.getLiquidityForAmounts(\n            currentSqrtRatioX96,\n            TickMath.getSqrtRatioAtTick(position.lowerTick),\n            TickMath.getSqrtRatioAtTick(position.upperTick),\n            (amount0Desired * position.weight) / MAX_WEIGHT_UINT256,\n            (amount1Desired * position.weight) / MAX_WEIGHT_UINT256\n        );\n    }\n\n    function _upFeesGrowth(uint256 fee0, uint256 fee1, uint256 _totalSupply) private {\n        feesGrowthInsideLastX128.gmiAccPerShare0 += FullMath.mulDiv(\n            fee0,\n            FixedPoint128.Q128,\n            _totalSupply\n        );\n\n        feesGrowthInsideLastX128.gmiAccPerShare1 += FullMath.mulDiv(\n            fee1,\n            FixedPoint128.Q128,\n            _totalSupply\n        );\n        uint256 feeGrowthWeight = MAX_WEIGHT_UINT256 - protocolFeeWeight;\n        uint256 fee0WPF = (fee0 * feeGrowthWeight) / MAX_WEIGHT_UINT256;\n        uint256 fee1WPF = (fee1 * feeGrowthWeight) / MAX_WEIGHT_UINT256;\n\n        feesGrowthInsideLastX128.accPerShare0 += FullMath.mulDiv(\n            fee0WPF,\n            FixedPoint128.Q128,\n            _totalSupply\n        );\n\n        feesGrowthInsideLastX128.accPerShare1 += FullMath.mulDiv(\n            fee1WPF,\n            FixedPoint128.Q128,\n            _totalSupply\n        );\n\n        _pay(token0, address(this), owner(), fee0 - fee0WPF);\n        _pay(token1, address(this), owner(), fee1 - fee1WPF);\n    }\n\n    function _deposit(\n        uint256 amount0Desired,\n        uint256 amount1Desired,\n        uint256 _totalSupply,\n        Slot0Data[] memory slots\n    ) private {\n        uint128 liquidity;\n        uint256 fee0;\n        uint256 fee1;\n        uint256 posNum = multiPosition.length;\n        PositionInfo memory position;\n        for (uint256 i = 0; i < posNum; ) {\n            position = multiPosition[i];\n\n            liquidity = _calcLiquidityAmountToDeposit(\n                slots[i].currentSqrtRatioX96,\n                position,\n                amount0Desired,\n                amount1Desired\n            );\n            if (liquidity > 0) {\n                (, , , uint128 tokensOwed0Before, uint128 tokensOwed1Before) = IUniswapV3Pool(\n                    position.poolAddress\n                ).positions(position.positionKey);\n\n                IUniswapV3Pool(position.poolAddress).mint(\n                    address(this), //recipient\n                    position.lowerTick,\n                    position.upperTick,\n                    liquidity,\n                    abi.encode(position.poolFeeAmt)\n                );\n\n                (, , , uint128 tokensOwed0After, uint128 tokensOwed1After) = IUniswapV3Pool(\n                    position.poolAddress\n                ).positions(position.positionKey);\n\n                fee0 += tokensOwed0After - tokensOwed0Before;\n                fee1 += tokensOwed1After - tokensOwed1Before;\n\n                IUniswapV3Pool(position.poolAddress).collect(\n                    address(this),\n                    position.lowerTick,\n                    position.upperTick,\n                    type(uint128).max,\n                    type(uint128).max\n                );\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (_totalSupply > 0) {\n            _upFeesGrowth(fee0, fee1, _totalSupply);\n        }\n    }\n\n    /**\n     * @notice Deposit function for adding liquidity to the pool\n     * @dev This function allows a user to deposit `amount0Desired` and `amount1Desired` amounts of token0 and token1\n     *      respectively into the liquidity pool and receive `lpAmount` amount of corresponding liquidity pool tokens in return.\n     *      It first checks if the pool has been initialized, meaning there's already liquidity added in it. If not,\n     *      then it requires that the first deposit be made by the owner address. If initialized, the optimal amount of token\n     *      to be deposited is calculated based on existing reserves and minimums specified. Then, the amount of LP tokens\n     *      to be minted is calculated, and the tokens are transferred accordingly from the caller to the contract. Finally,\n     *      the deposit function is called internally, which uses Uniswap V3's mint function to add the liquidity to the pool.\n     * @param amount0Desired The amount of token0 desired to deposit.\n     * @param amount1Desired The amount of token1 desired to deposit.\n     * @param amount0Min The minimum amount of token0 required to be deposited.\n     * @param amount1Min The minimum amount of token1 required to be deposited.\n     * @return lpAmount Returns the amount of liquidity tokens created.\n     */\n    function deposit(\n        // TODO:  PAUSED + Max CAPS\n        uint256 amount0Desired,\n        uint256 amount1Desired,\n        uint256 amount0Min,\n        uint256 amount1Min\n    ) external returns (uint256 lpAmount) {\n        ErrLib.requirement(\n            amount0Desired > MINIMUM_AMOUNT && amount1Desired > MINIMUM_AMOUNT,\n            ErrLib.ErrorCode.AMOUNT_TOO_SMALL\n        );\n        uint256 _totalSupply = totalSupply();\n        Slot0Data[] memory slots;\n\n        if (_totalSupply == 0) {\n            ErrLib.requirement(\n                msg.sender == owner(),\n                ErrLib.ErrorCode.FIRST_DEPOSIT_SHOULD_BE_MAKE_BY_OWNER\n            );\n            // fetched from Uniswap codebase\n            lpAmount = Babylonian.sqrt(amount0Desired * amount1Desired) - MINIMUM_LIQUIDITY;\n            _mint(burnAddress, MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n            slots = _initializeStrategy();\n        } else {\n            slots = getSlots();\n            (uint256 reserve0, uint256 reserve1, , ) = _getReserves(slots);\n            (amount0Desired, amount1Desired) = _optimizeAmounts(\n                amount0Desired,\n                amount1Desired,\n                amount0Min,\n                amount1Min,\n                reserve0,\n                reserve1\n            );\n            // MINIMUM\n            uint256 l0 = (amount0Desired * _totalSupply) / reserve0;\n            uint256 l1 = (amount1Desired * _totalSupply) / reserve1;\n            lpAmount = l0 < l1 ? l0 : l1;\n        }\n\n        ErrLib.requirement(lpAmount > 0, ErrLib.ErrorCode.INSUFFICIENT_LIQUIDITY_MINTED);\n        ErrLib.requirement(\n            maxTotalSupply >= _totalSupply + lpAmount,\n            ErrLib.ErrorCode.MAX_TOTAL_SUPPLY_REACHED\n        );\n        _pay(token0, msg.sender, address(this), amount0Desired);\n        _pay(token1, msg.sender, address(this), amount1Desired);\n\n        _deposit(amount0Desired, amount1Desired, _totalSupply, slots);\n\n        _mint(msg.sender, lpAmount);\n\n        emit Deposit(msg.sender, amount0Desired, amount1Desired, lpAmount);\n    }\n\n    function _withdraw(\n        uint256 lpAmount,\n        uint256 _totalSupply\n    ) private returns (uint256 withdrawnAmount0, uint256 withdrawnAmount1) {\n        assert(_totalSupply > 0);\n        PositionInfo memory position;\n        uint256 posNum = multiPosition.length;\n        uint256 fee0;\n        uint256 fee1;\n        for (uint256 i = 0; i < posNum; ) {\n            position = multiPosition[i];\n\n            {\n                (uint128 liquidity, , , , ) = IUniswapV3Pool(position.poolAddress).positions(\n                    position.positionKey\n                );\n\n                uint128 liquidityToWithdraw = uint128(\n                    (uint256(liquidity) * lpAmount) / _totalSupply\n                );\n\n                (, , , uint128 tokensOwed0Before, uint128 tokensOwed1Before) = IUniswapV3Pool(\n                    position.poolAddress\n                ).positions(position.positionKey);\n\n                (uint256 amount0, uint256 amount1) = IUniswapV3Pool(position.poolAddress).burn(\n                    position.lowerTick,\n                    position.upperTick,\n                    liquidityToWithdraw\n                );\n\n                withdrawnAmount0 += amount0;\n                withdrawnAmount1 += amount1;\n\n                (, , , uint128 tokensOwed0After, uint128 tokensOwed1After) = IUniswapV3Pool(\n                    position.poolAddress\n                ).positions(position.positionKey);\n\n                fee0 += (tokensOwed0After - amount0) - tokensOwed0Before;\n                fee1 += (tokensOwed1After - amount1) - tokensOwed1Before;\n            }\n\n            IUniswapV3Pool(position.poolAddress).collect(\n                address(this),\n                position.lowerTick,\n                position.upperTick,\n                type(uint128).max,\n                type(uint128).max\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        _upFeesGrowth(fee0, fee1, _totalSupply);\n    }\n\n    /**\n     * @notice Allows the caller to withdraw their liquidity from the pool and receive the underlying tokens.\n     * @param lpAmount The amount of liquidity pool tokens to withdraw.\n     * @param amount0OutMin The minimum amount of token0 that the caller must receive on withdrawal.\n     * @param amount1OutMin The minimum amount of token1 that the caller must receive on withdrawal.\n     * @dev This function transfers the withdrawn liquidity proportional to the caller's share of the total liquidity pool. It then collects\n     *      the accumulated fees for the position before burning and withdrawing liquidity. Finally, it transfers the withdrawn tokens\n     *      to the caller and emits the Withdraw event.\n     * @return withdrawnAmount0 The amount of token0 received by the caller after the withdrawal.\n     * @return withdrawnAmount1 The amount of token1 received by the caller after the withdrawal.\n     */\n    function withdraw(\n        uint256 lpAmount,\n        uint256 amount0OutMin,\n        uint256 amount1OutMin\n    ) external returns (uint256 withdrawnAmount0, uint256 withdrawnAmount1) {\n        uint256 _totalSupply = totalSupply();\n\n        (withdrawnAmount0, withdrawnAmount1) = _withdraw(lpAmount, _totalSupply);\n\n        if (lpAmount > 0) {\n            withdrawnAmount0 +=\n                ((IERC20(token0).balanceOf(address(this)) - withdrawnAmount0) * lpAmount) /\n                _totalSupply;\n            withdrawnAmount1 +=\n                ((IERC20(token1).balanceOf(address(this)) - withdrawnAmount1) * lpAmount) /\n                _totalSupply;\n\n            ErrLib.requirement(\n                withdrawnAmount0 >= amount0OutMin && withdrawnAmount1 >= amount1OutMin,\n                ErrLib.ErrorCode.PRICE_SLIPPAGE_CHECK\n            );\n\n            _burn(msg.sender, lpAmount);\n            _pay(token0, address(this), msg.sender, withdrawnAmount0);\n            _pay(token1, address(this), msg.sender, withdrawnAmount1);\n            emit Withdraw(msg.sender, withdrawnAmount0, withdrawnAmount1, lpAmount);\n        }\n    }\n\n    /**\n     * @dev This function returns the current sqrt price and tick from every opened position\n     */\n    function getSlots() public view returns (Slot0Data[] memory) {\n        uint256 posNum = multiPosition.length;\n        Slot0Data[] memory slots = new Slot0Data[](posNum);\n        for (uint256 i = 0; i < posNum; ) {\n            PositionInfo memory position = multiPosition[i];\n            (slots[i].currentSqrtRatioX96, slots[i].tick, , , , , ) = IUniswapV3Pool(\n                position.poolAddress\n            ).slot0();\n            unchecked {\n                ++i;\n            }\n        }\n        return slots;\n    }\n\n    /**\n     * @dev This function is called after a underlying pool is minted.\n     * It pays the underlying pool their owed amounts of token0 and token1 taking into account slippage, if any.\n     * In order to verify that the correct pool has minted, it decodes the `data` parameter to get the pool\n     * fee and uses it to check against a trusted underlying pool.\n     * @param amount0Owed The amount of token0 owed to the underlying pool\n     * @param amount1Owed The amount of token1 owed to the underlying pool\n     * @param data Additional data provided during the minting process.\n     * The function decodes a `poolFee` variable from the `data` parameter, which is used to validate\n     * if the call"
    }
  ]
}