{
  "Title": "Outdated Solidity Versions",
  "Content": "Throughout the [codebase](https://github.com/spherex-collab/spherex-protect/tree/main/src/), there are `pragma` statements that use an outdated version of Solidity. For instance:\n\n\n* The `pragma` statement on [line 4](https://github.com/spherex-collab/spherex-protect/blob/main/src/ISphereXEngine.sol#L4) of [`ISphereXEngine.sol`](https://github.com/spherex-collab/spherex-protect/blob/main/src/ISphereXEngine.sol)\n* The `pragma` statement on [line 4](https://github.com/spherex-collab/spherex-protect/blob/main/src/SphereXEngine.sol#L4) of [`SphereXEngine.sol`](https://github.com/spherex-collab/spherex-protect/blob/main/src/SphereXEngine.sol)\n* The `pragma` statement on [line 4](https://github.com/spherex-collab/spherex-protect/blob/main/src/SphereXProtected.sol#L4) of [`SphereXProtected.sol`](https://github.com/spherex-collab/spherex-protect/blob/main/src/SphereXProtected.sol)\n\n\nConsider taking advantage of the [latest Solidity version](https://github.com/ethereum/solidity/releases) to improve the overall readability and security of the codebase by avoiding known bugs and taking advantage of newer language features.\n\n\nFurthermore, it is highly unlikely that newly deployed customer contracts will use versions of Solidity that are older than 0.8. To accommodate specific clients who may require an older version, code can be back-ported and audited separately for that specific integration as part of the integration audit (which is needed for other reasons as well).\n\n\n***Update**: Resolved in [pull request #16](https://github.com/spherex-collab/spherex-protect/pull/16) at commit [9b6c897](https://github.com/spherex-collab/spherex-protect/pull/16/commits/9b6c897f4e8278f7848a607781f088d481eea1d4).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/ISphereXEngine.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// (c) SphereX 2023 Terms&Conditions\n\npragma solidity ^0.8.0;\n\n/**\n * @title Interface for SphereXEngine - definitions of core functionality\n * @author SphereX Technologies ltd\n * @notice This interface is imported by SphereXProtected, so that SphereXProtected can call functions from SphereXEngine\n * @dev Full docs of these functions can be found in SphereXEngine\n */\n\ninterface ISphereXEngine {\n    function sphereXValidatePre(int256 num, address sender, bytes calldata data) external returns (bytes32[] memory);\n    function sphereXValidatePost(\n        int256 num,\n        uint256 gas,\n        bytes32[] calldata valuesBefore,\n        bytes32[] calldata valuesAfter\n    ) external;\n    function sphereXValidateInternalPre(int256 num) external returns (bytes32[] memory);\n    function sphereXValidateInternalPost(\n        int256 num,\n        uint256 gas,\n        bytes32[] calldata valuesBefore,\n        bytes32[] calldata valuesAfter\n    ) external;\n\n    function addAllowedSenderOnChain(address sender) external;\n\n    /**\n     * This function is taken as is from OZ IERC165, we don't inherit from OZ\n     * to avoid collisions with the customer OZ version.\n     *\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev this struct is used to reduce the stack usage of the modifiers.\n */\nstruct ModifierLocals {\n    bytes32[] storageSlots;\n    bytes32[] valuesBefore;\n    uint256 gas;\n    address engine;\n}"
    },
    {
      "filename": "src/SphereXEngine.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// (c) SphereX 2023 Terms&Conditions\n\npragma solidity ^0.8.17;\n\nimport {AccessControlDefaultAdminRules} from \"openzeppelin/access/AccessControlDefaultAdminRules.sol\";\nimport {ISphereXEngine} from \"./ISphereXEngine.sol\";\n\n/**\n * @title SphereX Engine\n * @notice Gathers information about an ongoing transaction and reverts if it seems malicious\n */\ncontract SphereXEngine is ISphereXEngine, AccessControlDefaultAdminRules {\n    // the following are packed together for slot optimization and gas saving\n    struct FlowConfiguration {\n        uint16 depth;\n        uint16 reserved;\n        bool enforce;\n        uint216 pattern;\n    }\n\n    // the following are packed together for slot optimization and gas saving\n    struct EngineConfig {\n        bytes8 rules;\n        // The next variable is not a config but we place it here to save gas\n        // Represent bytes16(keccak256(abi.encode(block.number, tx.origin, block.difficulty, block.timestamp)))\n        bytes16 txBoundaryHash;\n        bytes8 reserved;\n    }\n\n    EngineConfig internal _engineConfig = EngineConfig(0, bytes16(uint128(1)), 0);\n    mapping(address => bool) internal _allowedSenders;\n    mapping(uint216 => bool) internal _allowedPatterns;\n\n    FlowConfiguration internal _flowConfig = FlowConfiguration(DEPTH_START, 0, false, PATTERN_START);\n\n    mapping(uint256 => bool) internal _enforceFunction;\n\n    uint216 internal constant PATTERN_START = 1;\n    uint16 internal constant DEPTH_START = 1;\n    bytes8 internal constant DEACTIVATED = bytes8(0);\n    bytes8 internal constant CF = bytes8(uint64(1));\n    bytes8 internal constant TXF = bytes8(uint64(2));\n    bytes8 internal constant SELECTIVE_TXF = bytes8(uint64(4));\n    bytes8 internal constant CF_AND_TXF_TOGETHER = CF | TXF;\n    bytes8 internal constant CF_AND_SELECTIVE_TXF_TOGETHER = CF | SELECTIVE_TXF;\n    bytes8 internal constant TXF_AND_SELECTIVE_TXF_TOGETHER = TXF | SELECTIVE_TXF;\n\n    // the index of the addAllowedSenderOnChain in the call flow\n    int256 internal constant ADD_ALLOWED_SENDER_ONCHAIN_INDEX = int256(uint256(keccak256(\"factory.allowed.sender\")));\n\n    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR_ROLE\");\n    bytes32 public constant SENDER_ADDER_ROLE = keccak256(\"SENDER_ADDER_ROLE\");\n\n    constructor() AccessControlDefaultAdminRules(1 days, msg.sender) {\n        grantRole(OPERATOR_ROLE, msg.sender);\n    }\n\n    modifier onlyOperator() {\n        require(hasRole(OPERATOR_ROLE, msg.sender), \"SphereX error: operator required\");\n        _;\n    }\n\n    modifier onlySenderAdderRole() {\n        require(hasRole(SENDER_ADDER_ROLE, msg.sender), \"SphereX error: sender adder required\");\n        _;\n    }\n\n    event TxStartedAtIrregularDepth();\n    event ConfigureRules(bytes8 oldRules, bytes8 newRules);\n    event AddedAllowedSenders(address[] senders);\n    event AddedAllowedSenderOnchain(address sender);\n    event RemovedAllowedSenders(address[] senders);\n    event AddedAllowedPatterns(uint216[] patterns);\n    event RemovedAllowedPatterns(uint216[] patterns);\n    event AddedEnforcedFunctions(uint256[] functions);\n    event RemovedEnforcedFunctions(uint256[] functions);\n\n    modifier returnsIfNotActivated() {\n        if (_engineConfig.rules == DEACTIVATED) {\n            return;\n        }\n\n        _;\n    }\n\n    modifier onlyApprovedSenders() {\n        require(_allowedSenders[msg.sender], \"SphereX error: disallowed sender\");\n        _;\n    }\n\n    // ============ Management ============\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AccessControlDefaultAdminRules, ISphereXEngine)\n        returns (bool)\n    {\n        return interfaceId == type(ISphereXEngine).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * Activate the guardian rules\n     * @param rules bytes8 representing the new rules to activate.\n     */\n    function configureRules(bytes8 rules) external onlyOperator {\n        require(CF_AND_TXF_TOGETHER & rules != CF_AND_TXF_TOGETHER, \"SphereX error: illegal rules combination\");\n        require(\n            CF_AND_SELECTIVE_TXF_TOGETHER & rules != CF_AND_SELECTIVE_TXF_TOGETHER,\n            \"SphereX error: illegal rules combination\"\n        );\n        require(\n            TXF_AND_SELECTIVE_TXF_TOGETHER & rules != TXF_AND_SELECTIVE_TXF_TOGETHER,\n            \"SphereX error: illegal rules combination\"\n        );\n        require(uint64(rules) <= uint64(SELECTIVE_TXF), \"SphereX error: illegal rules combination\");\n        bytes8 oldRules = _engineConfig.rules;\n        _engineConfig.rules = rules;\n        emit ConfigureRules(oldRules, rules);\n    }\n\n    /**\n     * Deactivates the engine, the calls will return without being checked\n     */\n    function deactivateAllRules() external onlyOperator {\n        bytes8 oldRules = _engineConfig.rules;\n        _engineConfig.rules = DEACTIVATED;\n        emit ConfigureRules(oldRules, 0);\n    }\n\n    /**\n     * Adds addresses that will be served by this engine. An address that was never added will get a revert if it tries to call the engine.\n     * @param senders list of address to add to the set of allowed addresses\n     */\n    function addAllowedSender(address[] calldata senders) external onlyOperator {\n        for (uint256 i = 0; i < senders.length; ++i) {\n            _allowedSenders[senders[i]] = true;\n        }\n        emit AddedAllowedSenders(senders);\n    }\n\n    /**\n     * Adds address that will be served by this engine. An address that was never added will get a revert if it tries to call the engine.\n     * @param sender address to add to the set of allowed addresses\n     * @notice This function adds elements to the current pattern in order to guard itself from unwanted calls.\n     * Lets say the client has a contract with SENDER_ADDER role and we approve only function indexed 1 to call addAllowedSenderOnChain.\n     * We will allow the pattern [1, addAllowedSenderOnChain, -addAllowedSenderOnChain ,-1] and by doing so we guarantee no other function\n     * will call addAllowedSenderOnChain.\n     */\n    function addAllowedSenderOnChain(address sender) external onlySenderAdderRole {\n        _allowedSenders[sender] = true;\n        emit AddedAllowedSenderOnchain(sender);\n    }\n\n    /**\n     * Removes address so that they will not get served when calling the engine. Transaction from these addresses will get reverted.\n     * @param senders list of address to stop service.\n     */\n    function removeAllowedSender(address[] calldata senders) external onlyOperator {\n        for (uint256 i = 0; i < senders.length; ++i) {\n            _allowedSenders[senders[i]] = false;\n        }\n        emit RemovedAllowedSenders(senders);\n    }\n\n    /**\n     * Add allowed patterns - these are representation of allowed flows of transactions, and prefixes of these flows\n     * @param patterns list of flows to allow as valid and non-malicious flows\n     */\n    function addAllowedPatterns(uint216[] calldata patterns) external onlyOperator {\n        for (uint256 i = 0; i < patterns.length; ++i) {\n            _allowedPatterns[patterns[i]] = true;\n        }\n        emit AddedAllowedPatterns(patterns);\n    }\n\n    /**\n     * Remove allowed patterns - these are representation flows of transactions, and prefixes of these flows,\n     * that are no longer considered valid and benign\n     * @param patterns list of flows that no longer considered valid and non-malicious\n     */\n    function removeAllowedPatterns(uint216[] calldata patterns) external onlyOperator {\n        for (uint256 i = 0; i < patterns.length; ++i) {\n            _allowedPatterns[patterns[i]] = false;\n        }\n        emit RemovedAllowedPatterns(patterns);\n    }\n\n    /**\n     * Add functions for enforcment (apply to selective txf)\n     * @param functions function indexes to enforce flows\n     */\n    function includeEnforcedFunctions(uint256[] calldata functions) external onlyOperator {\n        for (uint256 i = 0; i < functions.length; ++i) {\n            _enforceFunction[functions[i]] = true;\n        }\n        emit AddedEnforcedFunctions(functions);\n    }\n\n    /**\n     * Remove functions for enforcment (apply to selective txf)\n     * @param functions function indexes to stop enforcing flows\n     */\n    function excludeEnforcedFunctions(uint256[] calldata functions) external onlyOperator {\n        for (uint256 i = 0; i < functions.length; ++i) {\n            _enforceFunction[functions[i]] = false;\n        }\n        emit RemovedEnforcedFunctions(functions);\n    }\n\n    function grantSenderAdderRole(address newSenderAdder) external onlyOperator {\n        _grantRole(SENDER_ADDER_ROLE, newSenderAdder);\n    }\n\n    // ============ Guardians logic ============\n\n    /**\n     * Checks if CF is activated.\n     */\n    function _isCFActivated(bytes8 rules) internal pure returns (bool) {\n        return (rules & bytes8(CF)) > 0;\n    }\n\n    /**\n     * Checks if selective txf is activated.\n     */\n    function _isSelectiveTxfActivated(bytes8 rules) internal pure returns (bool) {\n        return (rules & bytes8(SELECTIVE_TXF)) > 0;\n    }\n\n    /**\n     * update the current CF pattern with a new positive number (signifying function entry),\n     * @param num element to add to the flow.\n     */\n    function _addCfElementFunctionEntry(int256 num) internal {\n        require(num > 0, \"SphereX error: expected positive num\");\n        FlowConfiguration memory flowConfig = _flowConfig;\n        EngineConfig memory engineConfig = _engineConfig;\n\n        // Upon entry to a new function we should check if we are at the same transaction\n        // or a new one. \n        bytes16 currentTxBoundaryHash =\n            bytes16(keccak256(abi.encode(block.number, tx.origin, block.timestamp, block.difficulty)));\n        if (currentTxBoundaryHash != engineConfig.txBoundaryHash) {\n            // in case of a new one we need to reinit the currentPattern, and save\n            // the new transaction \"boundry\" (block.number+tx.origin+block.timestamp+block.difficulty)\n            flowConfig.pattern = PATTERN_START;\n            engineConfig.txBoundaryHash = currentTxBoundaryHash;\n            flowConfig.enforce = false;\n            if (flowConfig.depth != DEPTH_START) {\n                // This is an edge case we (and the client) should be able to monitor easily.\n                emit TxStartedAtIrregularDepth();\n                flowConfig.depth = DEPTH_START;\n            }\n\n            _engineConfig.txBoundaryHash = engineConfig.txBoundaryHash;\n        }\n\n        if (_isSelectiveTxfActivated(engineConfig.rules)) {\n            // if we are not in enforment mode then check if the current function turn it on\n            if (!flowConfig.enforce && _enforceFunction[uint256(num)]) {\n                flowConfig.enforce = true;\n            }\n        }\n\n        flowConfig.pattern = uint216(bytes27(keccak256(abi.encode(num, flowConfig.pattern))));\n        ++flowConfig.depth;\n\n        _flowConfig = flowConfig;\n    }\n\n    /**\n     * update the current CF pattern with a new negative number (signfying function exit),\n     * under some conditions, this will also check the validity of the pattern.\n     * @param num element to add to the flow. should be negative.\n     * @param forceCheck force the check of the current pattern, even if normal test conditions don't exist.\n     */\n    function _addCfElementFunctionExit(int256 num, bool forceCheck) internal {\n        require(num < 0, \"SphereX error: expected negative num\");\n        FlowConfiguration memory flowConfig = _flowConfig;\n        bytes8 rules = _engineConfig.rules;\n\n        flowConfig.pattern = uint216(bytes27(keccak256(abi.encode(num, flowConfig.pattern))));\n        --flowConfig.depth;\n\n        if ((forceCheck) || (flowConfig.depth == DEPTH_START)) {\n            if (_isSelectiveTxfActivated(rules)) {\n                if (flowConfig.enforce) {\n                    _checkCallFlow(flowConfig.pattern);\n                }\n            } else {\n                _checkCallFlow(flowConfig.pattern);\n            }\n        }\n\n        // If we are configured to CF then if we reach depth == DEPTH_START we should reinit the\n        // currentPattern\n        if (flowConfig.depth == DEPTH_START && _isCFActivated(rules)) {\n            flowConfig.pattern = PATTERN_START;\n        }\n\n        _flowConfig = flowConfig;\n    }\n\n    /**\n     * Check if the current call flow pattern (that is, the result of the rolling hash) is an allowed pattern.\n     */\n    function _checkCallFlow(uint216 pattern) internal view {\n        require(_allowedPatterns[pattern], \"SphereX error: disallowed tx pattern\");\n    }\n\n    /**\n     * This is the function that is actually called by the modifier of the protected contract before the body of the function.\n     * This is used only for external call functions.\n     * @param num id of function to add. Should be positive\n     * @param sender For future use\n     * @param data For future use\n     * @return result in the future will return instruction on what storage slots to gather, but not used for now\n     */\n    function sphereXValidatePre(int256 num, address sender, bytes calldata data)\n        external\n        override\n        returnsIfNotActivated // may return empty bytes32[]\n        onlyApprovedSenders\n        returns (bytes32[] memory result)\n    {\n        _addCfElementFunctionEntry(num);\n        return result;\n    }\n\n    /**\n     * This is the function that is actually called by the modifier of the protected contract after the body of the function.\n     * This is used only for external call functions (that is, external, and public when called outside the contract).\n     * @param num id of function to add. Should be negative\n     * @param valuesBefore For future use\n     * @param valuesAfter For future use\n     */\n    function sphereXValidatePost(\n        int256 num,\n        uint256 gas,\n        bytes32[] calldata valuesBefore,\n        bytes32[] calldata valuesAfter\n    ) external override returnsIfNotActivated onlyApprovedSenders {\n        _addCfElementFunctionExit(num, true);\n    }\n\n    /**\n     * This is the function that is actually called by the modifier of the protected contract before and after the body of the function.\n     * This is used only for internal function calls (internal and private functions).\n     * @param num id of function to add.\n     */\n    function sphereXValidateInternalPre(int256 num)\n        external\n        override\n        returnsIfNotActivated\n        onlyApprovedSenders\n        returns (bytes32[] memory result)\n    {\n        _addCfElementFunctionEntry(num);\n    }\n\n    /**\n     * This is the function that is actually called by the modifier of the protected contract before and after the body of the function.\n     * This is used only for internal function calls (internal and private functions).\n     * @param num id of function to add.\n     */\n    function sphereXValidateInternalPost(\n        int256 num,\n        uint256 gas,\n        bytes32[] calldata valuesBefore,\n        bytes32[] calldata valuesAfter\n    ) external override returnsIfNotActivated onlyApprovedSenders {\n        _addCfElementFunctionExit(num, false);\n    }\n}"
    },
    {
      "filename": "src/SphereXProtected.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// (c) SphereX 2023 Terms&Conditions\n\npragma solidity ^0.8.0;\n\nimport {SphereXProtectedBase} from \"./SphereXProtectedBase.sol\";\n\n/**\n * @title SphereX base Customer contract template\n * @dev notice this is an abstract\n */\nabstract contract SphereXProtected is SphereXProtectedBase(msg.sender, address(0), address(0)) {}"
    }
  ]
}