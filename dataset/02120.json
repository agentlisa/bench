{
  "Title": "M-36: _validateRange in Config does not check the input value as described",
  "Content": "# Issue M-36: _validateRange in Config does not check the input value as described \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/49 \n\n## Found by \n0xGoodess\n\n## Summary\n`_validateRange` in Config does not check the input value as described\n\n## Vulnerability Detail\nin the dev note of this function `_validateRange` : it said  `// @dev validate that the value is within the allowed range`. However in the function itself the value is only used in sending revert message, but not used in any check against a pre-set boundary.\n\n\n## Impact\nfunction does not verify the input value is within an expected range\n\n## Code Snippet\n\nhttps://github.com/gmx-io/gmx-synthetics/blob/8028cb8022b85174be861b311f1082b5b76239df/contracts/config/Config.sol#L271\n\n## Tool used\n\nManual Review\n\n## Recommendation\nRetrieve the min/max of a baseKey and does checking.\n\n\n\n## Discussion\n\n**IllIllI000**\n\n@xvi10 can you confirm that this is invalid?\n\n**xvi10**\n\nit is a valid issue\n\n**IllIllI000**\n\n@hrishibhat agree with sponsor â€“ valid Medium\n\n**chrisckwong821**\n\nEscalate for 10 USDC\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**IllIllI000**\n\nI messed up the tagging - Valid solo Medium\n\n**hrishibhat**\n\nEscalation accepted\n\nConsidering this issue a valid medium\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Considering this issue a valid medium\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n**xvi10**\n\nFix in https://github.com/gmx-io/gmx-synthetics/pull/81\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "contracts/config/Config.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../data/DataStore.sol\";\nimport \"../data/Keys.sol\";\nimport \"../role/RoleModule.sol\";\nimport \"../event/EventEmitter.sol\";\nimport \"../utils/BasicMulticall.sol\";\n\n// @title Config\ncontract Config is ReentrancyGuard, RoleModule, BasicMulticall {\n    using EventUtils for EventUtils.AddressItems;\n    using EventUtils for EventUtils.UintItems;\n    using EventUtils for EventUtils.IntItems;\n    using EventUtils for EventUtils.BoolItems;\n    using EventUtils for EventUtils.Bytes32Items;\n    using EventUtils for EventUtils.BytesItems;\n    using EventUtils for EventUtils.StringItems;\n\n    uint256 public constant MAX_FEE_FACTOR = 5 * Precision.FLOAT_PRECISION / 100; // 5%\n\n    DataStore public immutable dataStore;\n    EventEmitter public immutable eventEmitter;\n\n    // @dev the base keys that can be set\n    mapping (bytes32 => bool) public allowedBaseKeys;\n\n    error InvalidBaseKey(bytes32 baseKey);\n    error InvalidFeeFactor(bytes32 baseKey, uint256 value);\n    error InvalidFactor(bytes32 baseKey, uint256 value);\n\n    constructor(\n        RoleStore _roleStore,\n        DataStore _dataStore,\n        EventEmitter _eventEmitter\n    ) RoleModule(_roleStore) {\n        dataStore = _dataStore;\n        eventEmitter = _eventEmitter;\n\n        _initAllowedBaseKeys();\n    }\n\n    // @dev set a bool value\n    // @param baseKey the base key of the value to set\n    // @param data the additional data to be combined with the base key\n    // @param value the bool value\n    function setBool(bytes32 baseKey, bytes memory data, bool value) external onlyConfigKeeper nonReentrant {\n        _validateKey(baseKey);\n\n        bytes32 fullKey = keccak256(bytes.concat(baseKey, data));\n\n        dataStore.setBool(fullKey, value);\n\n        EventUtils.EventLogData memory eventData;\n\n        eventData.bytes32Items.initItems(1);\n        eventData.bytes32Items.setItem(0, \"baseKey\", baseKey);\n\n        eventData.bytesItems.initItems(1);\n        eventData.bytesItems.setItem(0, \"data\", data);\n\n        eventData.boolItems.initItems(1);\n        eventData.boolItems.setItem(0, \"value\", value);\n\n        eventEmitter.emitEventLog1(\n            \"SetBool\",\n            baseKey,\n            eventData\n        );\n    }\n\n    // @dev set an address value\n    // @param baseKey the base key of the value to set\n    // @param data the additional data to be combined with the base key\n    // @param value the address value\n    function setAddress(bytes32 baseKey, bytes memory data, address value) external onlyConfigKeeper nonReentrant {\n        _validateKey(baseKey);\n\n        bytes32 fullKey = keccak256(bytes.concat(baseKey, data));\n\n        dataStore.setAddress(fullKey, value);\n\n        EventUtils.EventLogData memory eventData;\n\n        eventData.bytes32Items.initItems(1);\n        eventData.bytes32Items.setItem(0, \"baseKey\", baseKey);\n\n        eventData.bytesItems.initItems(1);\n        eventData.bytesItems.setItem(0, \"data\", data);\n\n        eventData.addressItems.initItems(1);\n        eventData.addressItems.setItem(0, \"value\", value);\n\n        eventEmitter.emitEventLog1(\n            \"SetAddress\",\n            baseKey,\n            eventData\n        );\n    }\n\n    // @dev set a bytes32 value\n    // @param baseKey the base key of the value to set\n    // @param data the additional data to be combined with the base key\n    // @param value the bytes32 value\n    function setBytes32(bytes32 baseKey, bytes memory data, bytes32 value) external onlyConfigKeeper nonReentrant {\n        _validateKey(baseKey);\n\n        bytes32 fullKey = keccak256(bytes.concat(baseKey, data));\n\n        dataStore.setBytes32(fullKey, value);\n\n        EventUtils.EventLogData memory eventData;\n\n        eventData.bytes32Items.initItems(2);\n        eventData.bytes32Items.setItem(0, \"baseKey\", baseKey);\n        eventData.bytes32Items.setItem(1, \"value\", value);\n\n        eventData.bytesItems.initItems(1);\n        eventData.bytesItems.setItem(0, \"data\", data);\n\n        eventEmitter.emitEventLog1(\n            \"SetBytes32\",\n            baseKey,\n            eventData\n        );\n    }\n\n    // @dev set a uint256 value\n    // @param basekey the base key of the value to set\n    // @param data the additional data to be combined with the base key\n    // @param value the uint256 value\n    function setUint(bytes32 baseKey, bytes memory data, uint256 value) external onlyConfigKeeper nonReentrant {\n        _validateKey(baseKey);\n\n        bytes32 fullKey = keccak256(bytes.concat(baseKey, data));\n\n        _validateRange(baseKey, value);\n\n        dataStore.setUint(fullKey, value);\n\n        EventUtils.EventLogData memory eventData;\n\n        eventData.bytes32Items.initItems(1);\n        eventData.bytes32Items.setItem(0, \"baseKey\", baseKey);\n\n        eventData.bytesItems.initItems(1);\n        eventData.bytesItems.setItem(0, \"data\", data);\n\n        eventData.uintItems.initItems(1);\n        eventData.uintItems.setItem(0, \"value\", value);\n\n        eventEmitter.emitEventLog1(\n            \"SetUint\",\n            baseKey,\n            eventData\n        );\n    }\n\n    // @dev set an int256 value\n    // @param basekey the base key of the value to set\n    // @param data the additional data to be combined with the base key\n    // @param value the int256 value\n    function setInt(bytes32 baseKey, bytes memory data, int256 value) external onlyConfigKeeper nonReentrant {\n        _validateKey(baseKey);\n\n        bytes32 fullKey = keccak256(bytes.concat(baseKey, data));\n\n        dataStore.setInt(fullKey, value);\n\n        EventUtils.EventLogData memory eventData;\n\n        eventData.bytes32Items.initItems(1);\n        eventData.bytes32Items.setItem(0, \"baseKey\", baseKey);\n\n        eventData.bytesItems.initItems(1);\n        eventData.bytesItems.setItem(0, \"data\", data);\n\n        eventData.intItems.initItems(1);\n        eventData.intItems.setItem(0, \"value\", value);\n\n        eventEmitter.emitEventLog1(\n            \"SetInt\",\n            baseKey,\n            eventData\n        );\n    }\n\n    // @dev initialize the allowed base keys\n    function _initAllowedBaseKeys() internal {\n        allowedBaseKeys[Keys.IS_MARKET_DISABLED] = true;\n\n        allowedBaseKeys[Keys.CREATE_DEPOSIT_FEATURE_DISABLED] = true;\n        allowedBaseKeys[Keys.CANCEL_DEPOSIT_FEATURE_DISABLED] = true;\n        allowedBaseKeys[Keys.EXECUTE_DEPOSIT_FEATURE_DISABLED] = true;\n\n        allowedBaseKeys[Keys.CREATE_WITHDRAWAL_FEATURE_DISABLED] = true;\n        allowedBaseKeys[Keys.CANCEL_WITHDRAWAL_FEATURE_DISABLED] = true;\n        allowedBaseKeys[Keys.EXECUTE_WITHDRAWAL_FEATURE_DISABLED] = true;\n\n        allowedBaseKeys[Keys.CREATE_ORDER_FEATURE_DISABLED] = true;\n        allowedBaseKeys[Keys.EXECUTE_ORDER_FEATURE_DISABLED] = true;\n        allowedBaseKeys[Keys.EXECUTE_ADL_FEATURE_DISABLED] = true;\n        allowedBaseKeys[Keys.UPDATE_ORDER_FEATURE_DISABLED] = true;\n        allowedBaseKeys[Keys.CANCEL_ORDER_FEATURE_DISABLED] = true;\n\n        allowedBaseKeys[Keys.MIN_ORACLE_BLOCK_CONFIRMATIONS] = true;\n        allowedBaseKeys[Keys.MAX_ORACLE_PRICE_AGE] = true;\n        allowedBaseKeys[Keys.POSITION_FEE_RECEIVER_FACTOR] = true;\n        allowedBaseKeys[Keys.SWAP_FEE_RECEIVER_FACTOR] = true;\n        allowedBaseKeys[Keys.BORROWING_FEE_RECEIVER_FACTOR] = true;\n\n        allowedBaseKeys[Keys.ESTIMATED_GAS_FEE_BASE_AMOUNT] = true;\n        allowedBaseKeys[Keys.ESTIMATED_GAS_FEE_MULTIPLIER_FACTOR] = true;\n\n        allowedBaseKeys[Keys.EXECUTION_GAS_FEE_BASE_AMOUNT] = true;\n        allowedBaseKeys[Keys.EXECUTION_GAS_FEE_MULTIPLIER_FACTOR] = true;\n\n        allowedBaseKeys[Keys.DEPOSIT_GAS_LIMIT] = true;\n        allowedBaseKeys[Keys.WITHDRAWAL_GAS_LIMIT] = true;\n        allowedBaseKeys[Keys.SINGLE_SWAP_GAS_LIMIT] = true;\n        allowedBaseKeys[Keys.INCREASE_ORDER_GAS_LIMIT] = true;\n        allowedBaseKeys[Keys.DECREASE_ORDER_GAS_LIMIT] = true;\n        allowedBaseKeys[Keys.SWAP_ORDER_GAS_LIMIT] = true;\n        allowedBaseKeys[Keys.TOKEN_TRANSFER_GAS_LIMIT] = true;\n        allowedBaseKeys[Keys.NATIVE_TOKEN_TRANSFER_GAS_LIMIT] = true;\n\n        allowedBaseKeys[Keys.REQUEST_EXPIRATION_BLOCK_AGE] = true;\n        allowedBaseKeys[Keys.MIN_COLLATERAL_FACTOR] = true;\n        allowedBaseKeys[Keys.MIN_COLLATERAL_FACTOR_FOR_OPEN_INTEREST_MULTIPLIER] = true;\n        allowedBaseKeys[Keys.MIN_COLLATERAL_USD] = true;\n\n        allowedBaseKeys[Keys.VIRTUAL_TOKEN_ID] = true;\n        allowedBaseKeys[Keys.VIRTUAL_MARKET_ID] = true;\n        allowedBaseKeys[Keys.VIRTUAL_INVENTORY_FOR_SWAPS] = true;\n        allowedBaseKeys[Keys.VIRTUAL_INVENTORY_FOR_POSITIONS] = true;\n        allowedBaseKeys[Keys.THRESHOLD_POSITION_IMPACT_FACTOR_FOR_VIRTUAL_INVENTORY] = true;\n        allowedBaseKeys[Keys.THRESHOLD_SWAP_IMPACT_FACTOR_FOR_VIRTUAL_INVENTORY] = true;\n\n        allowedBaseKeys[Keys.POSITION_IMPACT_FACTOR] = true;\n        allowedBaseKeys[Keys.POSITION_IMPACT_EXPONENT_FACTOR] = true;\n        allowedBaseKeys[Keys.MAX_POSITION_IMPACT_FACTOR] = true;\n        allowedBaseKeys[Keys.POSITION_FEE_FACTOR] = true;\n\n        allowedBaseKeys[Keys.SWAP_IMPACT_FACTOR] = true;\n        allowedBaseKeys[Keys.SWAP_IMPACT_EXPONENT_FACTOR] = true;\n        allowedBaseKeys[Keys.SWAP_FEE_FACTOR] = true;\n\n        allowedBaseKeys[Keys.ORACLE_TYPE] = true;\n\n        allowedBaseKeys[Keys.RESERVE_FACTOR] = true;\n        allowedBaseKeys[Keys.MAX_PNL_FACTOR] = true;\n        allowedBaseKeys[Keys.MAX_PNL_FACTOR_FOR_WITHDRAWALS] = true;\n        allowedBaseKeys[Keys.FUNDING_FACTOR] = true;\n        allowedBaseKeys[Keys.BORROWING_FACTOR] = true;\n    }\n\n    // @dev validate that the baseKey is allowed to be used\n    // @param baseKey the base key to validate\n    function _validateKey(bytes32 baseKey) internal view {\n        if (!allowedBaseKeys[baseKey]) {\n            revert InvalidBaseKey(baseKey);\n        }\n    }\n\n    // @dev validate that the value is within the allowed range\n    // @param baseKey the base key for the value\n    // @param value the value to be set\n    function _validateRange(bytes32 baseKey, uint256 value) internal pure {\n        if (\n            baseKey == Keys.SWAP_FEE_FACTOR ||\n            baseKey == Keys.POSITION_FEE_FACTOR\n        ) {\n            revert InvalidFeeFactor(baseKey, value);\n        }\n\n        if (\n            baseKey == Keys.POSITION_FEE_RECEIVER_FACTOR ||\n            baseKey == Keys.SWAP_FEE_RECEIVER_FACTOR ||\n            baseKey == Keys.BORROWING_FEE_RECEIVER_FACTOR ||\n            baseKey == Keys.MIN_COLLATERAL_FACTOR ||\n            baseKey == Keys.RESERVE_FACTOR ||\n            baseKey == Keys.MAX_PNL_FACTOR ||\n            baseKey == Keys.MAX_PNL_FACTOR_FOR_WITHDRAWALS ||\n            baseKey == Keys.FUNDING_FACTOR ||\n            baseKey == Keys.BORROWING_FACTOR\n        ) {\n            revert InvalidFactor(baseKey, value);\n        }\n    }\n}"
    }
  ]
}