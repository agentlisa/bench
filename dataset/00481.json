{
  "Title": "M-8: All operators can have ETH deposits regardless of the cap setted for them leading to miscalculated TVL",
  "Content": "# Issue M-8: All operators can have ETH deposits regardless of the cap setted for them leading to miscalculated TVL \n\nSource: https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/235 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nhash, klaus, mstpr-brainbot, neumo, zzykxx\n## Summary\nSome operators might not be eligible for using some strategies in the LRT's underlying tokens. However, in default every operator can have ETH deposits which would impact the TVL/Exchange rate of the LRT regardless of they have a cap or not. \n## Vulnerability Detail\nFirst, let's examine how an operator can have ETH deposit\n\nAn operator can have ETH deposits by simply staking in beacon chain, to do so they are not mandatory to call EigenPods \"stake\" function. They can do it separately without calling the EigenPods [stake](https://github.com/Layr-Labs/eigenlayer-contracts/blob/6de01c6c16d6df44af15f0b06809dc160eac0ebf/src/contracts/pods/EigenPod.sol#L403-L412) function. \n\nAlso, every operator delegator contract can call [`verifyWithdrawalCredentials`](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTOperatorDelegator.sol#L135-L145) to increase EigenPod shares and decrease the queued ETH regardless of they are active operator or they have a cap determined for BEACON_CHAIN_STRATEGY. \n\nNow, let's look at how the TVL of ETH (BEACON_CHAIN_STRATEGY) is calculated in the AssetRegistry:\n```solidity\nfunction getTVLForAsset(address asset) public view returns (uint256) {\n        uint256 balance = getTotalBalanceForAsset(asset);\n        if (asset == ETH_ADDRESS) {\n            return balance;\n        }\n        return convertToUnitOfAccountFromAsset(asset, balance);\n    }\n\n    function getTotalBalanceForAsset(address asset) public view returns (uint256) {\n        if (!isSupportedAsset(asset)) revert ASSET_NOT_SUPPORTED(asset);\n\n        address depositPool_ = address(depositPool());\n        if (asset == ETH_ADDRESS) {\n            return depositPool_.balance + getETHBalanceInEigenLayer();\n        }\n\n        uint256 sharesHeld = getAssetSharesHeld(asset);\n        uint256 tokensInRio = IERC20(asset).balanceOf(depositPool_);\n        uint256 tokensInEigenLayer = convertFromSharesToAsset(getAssetStrategy(asset), sharesHeld);\n\n        return tokensInRio + tokensInEigenLayer;\n    }\n\n    function getETHBalanceInEigenLayer() public view returns (uint256 balance) {\n        balance = ethBalanceInUnverifiedValidators;\n\n        IRioLRTOperatorRegistry operatorRegistry_ = operatorRegistry();\n        -> uint8 endAtID = operatorRegistry_.operatorCount() + 1; // Operator IDs start at 1.\n        -> for (uint8 id = 1; id < endAtID; ++id) {\n            -> balance += operatorDelegator(operatorRegistry_, id).getETHUnderManagement();\n        }\n    }\n```\n\nAs we can see above, regardless of the operators cap the entire active validator counts are looped. \n\n```solidity\nfunction getEigenPodShares() public view returns (int256) {\n        return eigenPodManager.podOwnerShares(address(this));\n    }\n\n    function getETHQueuedForWithdrawal() public view returns (uint256) {\n        uint256 ethQueuedSlotData;\n        assembly {\n            ethQueuedSlotData := sload(ethQueuedForUserSettlementGwei.slot)\n        }\n\n        uint64 userSettlementGwei = uint64(ethQueuedSlotData);\n        uint64 operatorExitAndScrapeGwei = uint64(ethQueuedSlotData >> 64);\n\n        return (userSettlementGwei + operatorExitAndScrapeGwei).toWei();\n    }\n\n    function getETHUnderManagement() external view returns (uint256) {\n        int256 aum = getEigenPodShares() + int256(getETHQueuedForWithdrawal());\n        if (aum < 0) return 0;\n\n        return uint256(aum);\n    }\n```\n\nSince the operator has eigen pod shares, the TVL will account it aswell. However, since the operator is not actively participating on ether deposits (not in the heap order) the withdrawals or deposits to this specific operator is impossible. Hence, the TVL is accounting an operators eigen pod share which the contract assumes that it is not in the heap. \n\n**Textual PoC:**\nAssume there are 5 operators whereas only 4 of these operators are actively participating in BEACON_CHAIN_STRATEGY which means that 1 operator has no validator caps set hence, it is not in the heap order.\nHowever, this operator can still have ether deposits and can verify them. Since the TVL accounting **loops over all the operators but not the operators that are actively participating in beacon chain strategy**, the TVL calculated will be wrong. \n## Impact\nMiscalculation of total ether holdings of an LRT. Withdrawals can fail because the calculated ether is not existed in the heap but the TVL says there are ether to withdraw from the LRT.\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTAssetRegistry.sol#L79-L114\n\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTOperatorDelegator.sol#L101-L126\n## Tool used\n\nManual Review\n\n## Recommendation\nput a check on `verifyWithdrawalCredentials` that is not possible to call the function if the operator is not actively participating in the BEACON_CHAIN_STRATEGY. \n\n\n\n## Discussion\n\n**solimander**\n\nThis is a necessary feature, and should be a short-lived quirk. If an operator is deactivated prior to all validator withdrawal credentials being proven, they will need to prove the credentials and withdraw after deactivation, which would then be scraped back into the deposit pool.\n\n**nevillehuang**\n\nI believe this should have been a known consideration stated in the contest details, so leaving as medium severity.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/176",
  "Code": [
    {
      "filename": "src/contracts/pods/EigenPod.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.12;\n\nimport \"@openzeppelin-upgrades/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin-upgrades/contracts/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin-upgrades/contracts/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin-upgrades/contracts/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin-upgrades/contracts/utils/math/MathUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libraries/BeaconChainProofs.sol\";\nimport \"../libraries/BytesLib.sol\";\nimport \"../libraries/Endian.sol\";\n\nimport \"../interfaces/IETHPOSDeposit.sol\";\nimport \"../interfaces/IEigenPodManager.sol\";\nimport \"../interfaces/IEigenPod.sol\";\nimport \"../interfaces/IDelayedWithdrawalRouter.sol\";\nimport \"../interfaces/IPausable.sol\";\n\nimport \"./EigenPodPausingConstants.sol\";\n\n/**\n * @title The implementation contract used for restaking beacon chain ETH on EigenLayer\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n * @notice The main functionalities are:\n * - creating new ETH validators with their withdrawal credentials pointed to this contract\n * - proving from beacon chain state roots that withdrawal credentials are pointed to this contract\n * - proving from beacon chain state roots the balances of ETH validators with their withdrawal credentials\n *   pointed to this contract\n * - updating aggregate balances in the EigenPodManager\n * - withdrawing eth when withdrawals are initiated\n * @notice This EigenPod Beacon Proxy implementation adheres to the current Capella consensus specs\n * @dev Note that all beacon chain balances are stored as gwei within the beacon chain datastructures. We choose\n *   to account balances in terms of gwei in the EigenPod contract and convert to wei when making calls to other contracts\n */\ncontract EigenPod is IEigenPod, Initializable, ReentrancyGuardUpgradeable, EigenPodPausingConstants {\n    using BytesLib for bytes;\n    using SafeERC20 for IERC20;\n    using BeaconChainProofs for *;\n\n    // CONSTANTS + IMMUTABLES\n    // @notice Internal constant used in calculations, since the beacon chain stores balances in Gwei rather than wei\n    uint256 internal constant GWEI_TO_WEI = 1e9;\n\n    /**\n     * @notice Maximum \"staleness\" of a Beacon Chain state root against which `verifyBalanceUpdate` or `verifyWithdrawalCredentials` may be proven.\n     * We can't allow \"stale\" roots to be used for restaking as the validator may have been slashed in a more updated beacon state root. \n     */\n    uint256 internal constant VERIFY_BALANCE_UPDATE_WINDOW_SECONDS = 4.5 hours;\n\n    /// @notice This is the beacon chain deposit contract\n    IETHPOSDeposit public immutable ethPOS;\n\n    /// @notice Contract used for withdrawal routing, to provide an extra \"safety net\" mechanism\n    IDelayedWithdrawalRouter public immutable delayedWithdrawalRouter;\n\n    /// @notice The single EigenPodManager for EigenLayer\n    IEigenPodManager public immutable eigenPodManager;\n\n    ///@notice The maximum amount of ETH, in gwei, a validator can have restaked in the eigenlayer\n    uint64 public immutable MAX_RESTAKED_BALANCE_GWEI_PER_VALIDATOR;\n\n    /// @notice This is the genesis time of the beacon state, to help us calculate conversions between slot and timestamp\n    uint64 public immutable GENESIS_TIME;\n\n    // STORAGE VARIABLES\n    /// @notice The owner of this EigenPod\n    address public podOwner;\n\n    /**\n     * @notice The latest timestamp at which the pod owner withdrew the balance of the pod, via calling `withdrawBeforeRestaking`.\n     * @dev This variable is only updated when the `withdrawBeforeRestaking` function is called, which can only occur before `hasRestaked` is set to true for this pod.\n     * Proofs for this pod are only valid against Beacon Chain state roots corresponding to timestamps after the stored `mostRecentWithdrawalTimestamp`.\n     */\n    uint64 public mostRecentWithdrawalTimestamp;\n\n    /// @notice the amount of execution layer ETH in this contract that is staked in EigenLayer (i.e. withdrawn from the Beacon Chain but not from EigenLayer),\n    uint64 public withdrawableRestakedExecutionLayerGwei;\n\n    /// @notice an indicator of whether or not the podOwner has ever \"fully restaked\" by successfully calling `verifyCorrectWithdrawalCredentials`.\n    bool public hasRestaked;\n\n    /// @notice This is a mapping of validatorPubkeyHash to timestamp to whether or not they have proven a withdrawal for that timestamp\n    mapping(bytes32 => mapping(uint64 => bool)) public provenWithdrawal;\n\n    /// @notice This is a mapping that tracks a validator's information by their pubkey hash\n    mapping(bytes32 => ValidatorInfo) internal _validatorPubkeyHashToInfo;\n\n    /// @notice This variable tracks any ETH deposited into this contract via the `receive` fallback function\n    uint256 public nonBeaconChainETHBalanceWei;\n\n     /// @notice This variable tracks the total amount of partial withdrawals claimed via merkle proofs prior to a switch to ZK proofs for claiming partial withdrawals\n    uint64 public sumOfPartialWithdrawalsClaimedGwei;\n\n    modifier onlyEigenPodManager() {\n        require(msg.sender == address(eigenPodManager), \"EigenPod.onlyEigenPodManager: not eigenPodManager\");\n        _;\n    }\n\n    modifier onlyEigenPodOwner() {\n        require(msg.sender == podOwner, \"EigenPod.onlyEigenPodOwner: not podOwner\");\n        _;\n    }\n\n    modifier hasNeverRestaked() {\n        require(!hasRestaked, \"EigenPod.hasNeverRestaked: restaking is enabled\");\n        _;\n    }\n\n    /// @notice checks that hasRestaked is set to true by calling activateRestaking()\n    modifier hasEnabledRestaking() {\n        require(hasRestaked, \"EigenPod.hasEnabledRestaking: restaking is not enabled\");\n        _;\n    }\n\n    /// @notice Checks that `timestamp` is strictly greater than the value stored in `mostRecentWithdrawalTimestamp`\n    modifier proofIsForValidTimestamp(uint64 timestamp) {\n        require(\n            timestamp > mostRecentWithdrawalTimestamp,\n            \"EigenPod.proofIsForValidTimestamp: beacon chain proof must be for timestamp after mostRecentWithdrawalTimestamp\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Based on 'Pausable' code, but uses the storage of the EigenPodManager instead of this contract. This construction\n     * is necessary for enabling pausing all EigenPods at the same time (due to EigenPods being Beacon Proxies).\n     * Modifier throws if the `indexed`th bit of `_paused` in the EigenPodManager is 1, i.e. if the `index`th pause switch is flipped.\n     */\n    modifier onlyWhenNotPaused(uint8 index) {\n        require(\n            !IPausable(address(eigenPodManager)).paused(index),\n            \"EigenPod.onlyWhenNotPaused: index is paused in EigenPodManager\"\n        );\n        _;\n    }\n\n    constructor(\n        IETHPOSDeposit _ethPOS,\n        IDelayedWithdrawalRouter _delayedWithdrawalRouter,\n        IEigenPodManager _eigenPodManager,\n        uint64 _MAX_RESTAKED_BALANCE_GWEI_PER_VALIDATOR,\n        uint64 _GENESIS_TIME\n    ) {\n        ethPOS = _ethPOS;\n        delayedWithdrawalRouter = _delayedWithdrawalRouter;\n        eigenPodManager = _eigenPodManager;\n        MAX_RESTAKED_BALANCE_GWEI_PER_VALIDATOR = _MAX_RESTAKED_BALANCE_GWEI_PER_VALIDATOR;\n        GENESIS_TIME = _GENESIS_TIME;\n        _disableInitializers();\n    }\n\n    /// @notice Used to initialize the pointers to addresses crucial to the pod's functionality. Called on construction by the EigenPodManager.\n    function initialize(address _podOwner) external initializer {\n        require(_podOwner != address(0), \"EigenPod.initialize: podOwner cannot be zero address\");\n        podOwner = _podOwner;\n        /**\n         * From the M2 deployment onwards, we are requiring that pods deployed are by default enabled with restaking\n         * In prior deployments without proofs, EigenPods could be deployed with restaking disabled so as to allow\n         * simple (proof-free) withdrawals.  However, this is no longer the case.  Thus going forward, all pods are\n         * initialized with hasRestaked set to true.\n         */\n        hasRestaked = true;\n        emit RestakingActivated(podOwner);\n    }\n\n    /// @notice payable fallback function that receives ether deposited to the eigenpods contract\n    receive() external payable {\n        nonBeaconChainETHBalanceWei += msg.value;\n        emit NonBeaconChainETHReceived(msg.value);\n    }\n\n    /**\n     * @notice This function records an update (either increase or decrease) in a validator's balance.\n     * @param oracleTimestamp The oracleTimestamp whose state root the proof will be proven against.\n     *        Must be within `VERIFY_BALANCE_UPDATE_WINDOW_SECONDS` of the current block.\n     * @param validatorIndices is the list of indices of the validators being proven, refer to consensus specs \n     * @param stateRootProof proves a `beaconStateRoot` against a block root fetched from the oracle\n     * @param validatorFieldsProofs proofs against the `beaconStateRoot` for each validator in `validatorFields`\n     * @param validatorFields are the fields of the \"Validator Container\", refer to consensus specs\n     * @dev For more details on the Beacon Chain spec, see: https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#validator\n     */\n    function verifyBalanceUpdates(\n        uint64 oracleTimestamp,\n        uint40[] calldata validatorIndices,\n        BeaconChainProofs.StateRootProof calldata stateRootProof,\n        bytes[] calldata validatorFieldsProofs,\n        bytes32[][] calldata validatorFields\n    ) external onlyWhenNotPaused(PAUSED_EIGENPODS_VERIFY_BALANCE_UPDATE) {\n        require(\n            (validatorIndices.length == validatorFieldsProofs.length) && (validatorFieldsProofs.length == validatorFields.length),\n            \"EigenPod.verifyBalanceUpdates: validatorIndices and proofs must be same length\"\n        );\n\n        // Balance updates should not be \"stale\" (older than VERIFY_BALANCE_UPDATE_WINDOW_SECONDS)\n        require(\n            oracleTimestamp + VERIFY_BALANCE_UPDATE_WINDOW_SECONDS >= block.timestamp,\n            \"EigenPod.verifyBalanceUpdates: specified timestamp is too far in past\"\n        );\n\n        // Verify passed-in beaconStateRoot against oracle-provided block root:\n        BeaconChainProofs.verifyStateRootAgainstLatestBlockRoot({\n            latestBlockRoot: eigenPodManager.getBlockRootAtTimestamp(oracleTimestamp),\n            beaconStateRoot: stateRootProof.beaconStateRoot,\n            stateRootProof: stateRootProof.proof\n        });\n\n        int256 sharesDeltaGwei;\n        for (uint256 i = 0; i < validatorIndices.length; i++) {\n            sharesDeltaGwei += _verifyBalanceUpdate(\n                oracleTimestamp,\n                validatorIndices[i],\n                stateRootProof.beaconStateRoot,\n                validatorFieldsProofs[i], // Use validator fields proof because contains the effective balance\n                validatorFields[i]\n            );\n        }\n        eigenPodManager.recordBeaconChainETHBalanceUpdate(podOwner, sharesDeltaGwei * int256(GWEI_TO_WEI));\n    }\n\n    /**\n     * @notice This function records full and partial withdrawals on behalf of one or more of this EigenPod's validators\n     * @param oracleTimestamp is the timestamp of the oracle slot that the withdrawal is being proven against\n     * @param stateRootProof proves a `beaconStateRoot` against a block root fetched from the oracle\n     * @param withdrawalProofs proves several withdrawal-related values against the `beaconStateRoot`\n     * @param validatorFieldsProofs proves `validatorFields` against the `beaconStateRoot`\n     * @param withdrawalFields are the fields of the withdrawals being proven\n     * @param validatorFields are the fields of the validators being proven\n     */\n    function verifyAndProcessWithdrawals(\n        uint64 oracleTimestamp,\n        BeaconChainProofs.StateRootProof calldata stateRootProof,\n        BeaconChainProofs.WithdrawalProof[] calldata withdrawalProofs,\n        bytes[] calldata validatorFieldsProofs,\n        bytes32[][] calldata validatorFields,\n        bytes32[][] calldata withdrawalFields\n    ) external onlyWhenNotPaused(PAUSED_EIGENPODS_VERIFY_WITHDRAWAL) {\n        require(\n            (validatorFields.length == validatorFieldsProofs.length) &&\n                (validatorFieldsProofs.length == withdrawalProofs.length) &&\n                (withdrawalProofs.length == withdrawalFields.length),\n            \"EigenPod.verifyAndProcessWithdrawals: inputs must be same length\"\n        );\n\n        // Verify passed-in beaconStateRoot against oracle-provided block root:\n        BeaconChainProofs.verifyStateRootAgainstLatestBlockRoot({\n            latestBlockRoot: eigenPodManager.getBlockRootAtTimestamp(oracleTimestamp),\n            beaconStateRoot: stateRootProof.beaconStateRoot,\n            stateRootProof: stateRootProof.proof\n        });\n\n        VerifiedWithdrawal memory withdrawalSummary;\n        for (uint256 i = 0; i < withdrawalFields.length; i++) {\n            VerifiedWithdrawal memory verifiedWithdrawal = _verifyAndProcessWithdrawal(\n                stateRootProof.beaconStateRoot,\n                withdrawalProofs[i],\n                validatorFieldsProofs[i],\n                validatorFields[i],\n                withdrawalFields[i]\n            );\n\n            withdrawalSummary.amountToSendGwei += verifiedWithdrawal.amountToSendGwei;\n            withdrawalSummary.sharesDeltaGwei += verifiedWithdrawal.sharesDeltaGwei;\n        }\n\n        // If any withdrawals are eligible for immediate redemption, send to the pod owner via\n        // DelayedWithdrawalRouter\n        if (withdrawalSummary.amountToSendGwei != 0) {\n            _sendETH_AsDelayedWithdrawal(podOwner, withdrawalSummary.amountToSendGwei * GWEI_TO_WEI);\n        }\n        // If any withdrawals resulted in a change in the pod's shares, update the EigenPodManager\n        if (withdrawalSummary.sharesDeltaGwei != 0) {\n            eigenPodManager.recordBeaconChainETHBalanceUpdate(podOwner, withdrawalSummary.sharesDeltaGwei * int256(GWEI_TO_WEI));\n        }\n    }\n\n    /*******************************************************************************\n                    EXTERNAL FUNCTIONS CALLABLE BY EIGENPOD OWNER\n    *******************************************************************************/\n\n    /**\n     * @notice This function verifies that the withdrawal credentials of validator(s) owned by the podOwner are pointed to\n     * this contract. It also verifies the effective balance  of the validator.  It verifies the provided proof of the ETH validator against the beacon chain state\n     * root, marks the validator as 'active' in EigenLayer, and credits the restaked ETH in Eigenlayer.\n     * @param oracleTimestamp is the Beacon Chain timestamp whose state root the `proof` will be proven against.\n     * @param stateRootProof proves a `beaconStateRoot` against a block root fetched from the oracle\n     * @param validatorIndices is the list of indices of the validators being proven, refer to consensus specs\n     * @param validatorFieldsProofs proofs against the `beaconStateRoot` for each validator in `validatorFields`\n     * @param validatorFields are the fields of the \"Validator Container\", refer to consensus specs\n     * for details: https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#validator\n     */\n    function verifyWithdrawalCredentials(\n        uint64 oracleTimestamp,\n        BeaconChainProofs.StateRootProof calldata stateRootProof,\n        uint40[] calldata validatorIndices,\n        bytes[] calldata validatorFieldsProofs,\n        bytes32[][] calldata validatorFields\n    )\n        external\n        onlyEigenPodOwner\n        onlyWhenNotPaused(PAUSED_EIGENPODS_VERIFY_CREDENTIALS)\n        // check that the provided `oracleTimestamp` is after the `mostRecentWithdrawalTimestamp`\n        proofIsForValidTimestamp(oracleTimestamp)\n        // ensure that caller has previously enabled restaking by calling `activateRestaking()`\n        hasEnabledRestaking\n    {\n        require(\n            (validatorIndices.length == validatorFieldsProofs.length) &&\n                (validatorFieldsProofs.length == validatorFields.length),\n            \"EigenPod.verifyWithdrawalCredentials: validatorIndices and proofs must be same length\"\n        );\n\n        /**\n         * Withdrawal credential proof should not be \"stale\" (older than VERIFY_BALANCE_UPDATE_WINDOW_SECONDS) as we are doing a balance check here\n         * The validator container persists as the state evolves and even after the validator exits. So we can use a more \"fresh\" credential proof within\n         * the VERIFY_BALANCE_UPDATE_WINDOW_SECONDS window, not just the first proof where the validator container is registered in the state.\n         */\n        require(\n            oracleTimestamp + VERIFY_BALANCE_UPDATE_WINDOW_SECONDS >= block.timestamp,\n            \"EigenPod.verifyWithdrawalCredentials: specified timestamp is too far in past\"\n        );\n\n        // Verify passed-in beaconStateRoot against oracle-provided block root:\n        BeaconChainProofs.verifyStateRootAgainstLatestBlockRoot({\n            latestBlockRoot: eigenPodManager.getBlockRootAtTimestamp(oracleTimestamp),\n            beaconStateRoot: stateRootProof.beaconStateRoot,\n            stateRootProof: stateRootProof.proof\n        });\n\n        uint256 totalAmountToBeRestakedWei;\n        for (uint256 i = 0; i < validatorIndices.length; i++) {\n            totalAmountToBeRestakedWei += _verifyWithdrawalCredentials(\n                oracleTimestamp,\n                stateRootProof.beaconStateRoot,\n                validatorIndices[i],\n                validatorFieldsProofs[i],\n                validatorFields[i]\n            );\n        }\n\n        // Update the EigenPodManager on this pod's new balance\n        eigenPodManager.recordBeaconChainETHBalanceUpdate(podOwner, int256(totalAmountToBeRestakedWei));\n    }\n\n    /// @notice Called by the pod owner to withdraw the nonBeaconChainETHBalanceWei\n    function withdrawNonBeaconChainETHBalanceWei(\n        address recipient,\n        uint256 amountToWithdraw\n    ) external onlyEigenPodOwner onlyWhenNotPaused(PAUSED_NON_PROOF_WITHDRAWALS) {\n        require(\n            amountToWithdraw <= nonBeaconChainETHBalanceWei,\n            \"EigenPod.withdrawnonBeaconChainETHBalanceWei: amountToWithdraw is greater than nonBeaconChainETHBalanceWei\"\n        );\n        nonBeaconChainETHBalanceWei -= amountToWithdraw;\n        emit NonBeaconChainETHWithdrawn(recipient, amountToWithdraw);\n        _sendETH_AsDelayedWithdrawal(recipient, amountToWithdraw);\n    }\n\n    /// @notice called by owner of a pod to remove any ERC20s deposited in the pod\n    function recoverTokens(\n        IERC20[] memory tokenList,\n        uint256[] memory amountsToWithdraw,\n        address recipient\n    ) external onlyEigenPodOwner onlyWhenNotPaused(PAUSED_NON_PROOF_WITHDRAWALS) {\n        require(\n            tokenList.length == amountsToWithdraw.length,\n            \"EigenPod.recoverTokens: tokenList and amountsToWithdraw must be same length\"\n        );\n        for (uint256 i = 0; i < tokenList.length; i++) {\n            tokenList[i].safeTransfer(recipient, amountsToWithdraw[i]);\n        }\n    }\n\n    /**\n     * @notice Called by the pod owner to activate restaking by withdrawing\n     * all existing ETH from the pod and preventing further withdrawals via\n     * \"withdrawBeforeRestaking()\"\n     */\n    function activateRestaking()\n        external\n        onlyWhenNotPaused(PAUSED_EIGENPODS_VERIFY_CREDENTIALS)\n        onlyEigenPodOwner\n        hasNeverRestaked\n    {\n        hasRestaked = true;\n        _processWithdrawalBeforeRestaking(podOwner);\n\n        emit RestakingActivated(podOwner);\n    }\n\n    /// @notice Called by the pod owner to withdraw the balance of the pod when `hasRestaked` is set to false\n    function withdrawBeforeRestaking() external onlyEigenPodOwner hasNeverRestaked {\n        _processWithdrawalBeforeRestaking(podOwner);\n    }\n\n    /*******************************************************************************\n                    EXTERNAL FUNCTIONS CALLABLE BY EIGENPODMANAGER\n    *******************************************************************************/\n\n    /// @notice Called by EigenPodManager when the owner wants to create another ETH validator.\n    function stake(\n        bytes calldata pubkey,\n        bytes calldata signature,\n        bytes32 depositDataRoot\n    ) external payable onlyEigenPodManager {\n        // stake on ethpos\n        require(msg.value == 32 ether, \"EigenPod.stake: must initially stake for any validator with 32 ether\");\n        ethPOS.deposit{value: 32 ether}(pubkey, _podWithdrawalCredentials(), signature, depositDataRoot);\n        emit EigenPodStaked(pubkey);\n    }\n\n    /**\n     * @notice Transfers `amountWei` in ether from this contract to the specified `recipient` address\n     * @notice Called by EigenPodManager to withdrawBeaconChainETH that has been added to the EigenPod's balance due to a withdrawal from the beacon chain.\n     * @dev The podOwner must have already proved sufficient withdrawals, so that this pod's `withdrawableRestakedExecutionLayerGwei` exceeds the\n     * `amountWei` input (when converted to GWEI).\n     * @dev Reverts if `amountWei` is not a whole Gwei amount\n     */\n    function withdrawRestakedBeaconChainETH(address recipient, uint256 amountWei) external onlyEigenPodManager {\n        require(amountWei % GWEI_TO_WEI == 0, \"EigenPod.withdrawRestakedBeaconChainETH: amountWei must be a whole Gwei amount\");\n        uint64 amountGwei = uint64(amountWei / GWEI_TO_WEI);\n        require(amountGwei <= withdrawableRestakedExecutionLayerGwei, \"EigenPod.withdrawRestakedBeaconChainETH: amountGwei exceeds withdrawableRestakedExecutionLayerGwei\");\n        withdrawableRestakedExecutionLayerGwei -= amountGwei;\n        emit RestakedBeaconChainETHWithdrawn(recipient, amountWei);\n        // transfer ETH from pod to `recipient` directly\n        _sendETH(recipient, amountWei);\n    }\n\n    /*******************************************************************************\n                                INTERNAL FUNCTIONS\n    *******************************************************************************/\n    /**\n     * @notice internal function that proves an individual validator's withdrawal credentials\n     * @param oracleTimestamp is the timestamp whose state root the `proof` will be proven against.\n     * @param validatorIndex is the index of the validator being proven\n     * @param validatorFieldsProof is the bytes that prove the ETH validator's  withdrawal credentials against a beacon chain state root\n     * @param validatorFields are the fields of the \"Validator Container\", refer to consensus specs\n     */\n    function _verifyWithdrawalCredentials(\n        uint64 oracleTimestamp,\n        bytes32 beaconStateRoot,\n        uint40 validatorIndex,\n        bytes calldata validatorFieldsProof,\n        bytes32[] calldata validatorFields\n    ) internal returns (uint256) {\n        bytes32 validatorPubkeyHash = validatorFields.getPubkeyHash();\n        ValidatorInfo memory validatorInfo = _validatorPubkeyHashToInfo[validatorPubkeyHash];\n\n        // Withdrawal credential proofs should only be processed for \"INACTIVE\" validators\n        require(\n            validatorInfo.status == VALIDATOR_STATUS.INACTIVE,\n            \"EigenPod.verifyCorrectWithdrawalCredentials: Validator must be inactive to prove withdrawal credentials\"\n        );\n\n        // Ensure the `validatorFields` we're proving have the correct withdrawal credentials\n        require(\n            validatorFields.getWithdrawalCredentials() == bytes32(_podWithdrawalCredentials()),\n            \"EigenPod.verifyCorrectWithdrawalCredentials: Proof is not for this EigenPod\"\n        );\n\n        /**\n         * Deserialize the balance field from the Validator struct.  Note that this is the \"effective\" balance of the validator\n         * rather than the current balance.  Effective balance is generated via a hystersis function such that an effective\n         * balance, always a multiple of 1 ETH, will only lower to the next multiple of 1 ETH if the current balance is less\n         * than 0.25 ETH below their current effective balance.  For example, if the effective balance is 31ETH, it only falls to\n         * 30ETH when the true balance falls below 30.75ETH.  Thus in the worst case, the effective balance is overestimating the\n         * actual validator balance by 0.25 ETH. \n         */\n        uint64 validatorEffectiveBalanceGwei = validatorFields.getEffectiveBalanceGwei();\n\n        // Verify passed-in validatorFields against verified beaconStateRoot:\n        BeaconChainProofs.verifyValidatorFields({\n            beaconStateRoot: beaconStateRoot,\n            validatorFields: validatorFields,\n            validatorFieldsProof: validatorFieldsProof,\n            validatorIndex: validatorIndex\n        });\n\n        // Proofs complete - update this validator's status, record its proven balance, and save in state:\n        validatorInfo.status = VALIDATOR_STATUS.ACTIVE;\n        validatorInfo.validatorIndex = validatorIndex;\n        validatorInfo.mostRecentBalanceUpdateTimestamp = oracleTimestamp;\n\n        if (validatorEffectiveBalanceGwei > MAX_RESTAKED_BALANCE_GWEI_PER_VALIDATOR) {\n            validatorInfo.restakedBalanceGwei = MAX_RESTAKED_BALANCE_GWEI_PER_VALIDATOR;\n        } else {\n            validatorInfo.restakedBalanceGwei = validatorEffectiveBalanceGwei;\n        }\n        _validatorPubkeyHashToInfo[validatorPubkeyHash] = validatorInfo;\n\n        emit ValidatorRestaked(validatorIndex);\n        emit ValidatorBalanceUpdated(validatorIndex, oracleTimestamp, validatorInfo.restakedBalanceGwei);\n\n        return validatorInfo.restakedBalanceGwei * GWEI_TO_WEI;\n    }\n\n    function _verifyBalanceUpdate(\n        uint64 oracleTimestamp,\n        uint40 validatorIndex,\n        bytes32 beaconStateRoot,\n        bytes calldata validatorFieldsProof,\n        bytes32[] calldata validatorFields\n    ) internal returns(int256 sharesDeltaGwei){\n        uint64 validatorEffectiveBalanceGwei = validatorFields.getEffectiveBalanceGwei();\n        bytes32 validatorPubkeyHash = validatorFields.getPubkeyHash();\n        ValidatorInfo memory validatorInfo = _validatorPubkeyHashToInfo[validatorPubkeyHash];\n\n        // 1. Balance updates should be more recent than the most recent update\n        require(\n            validatorInfo.mostRecentBalanceUpdateTimestamp < oracleTimestamp,\n            \"EigenPod.verifyBalanceUpdate: Validators balance has already been updated for this timestamp\"\n        );\n\n        // 2. Balance updates should only be performed on \"ACTIVE\" validators\n        require(\n            validatorInfo.status == VALIDATOR_STATUS.ACTIVE, \n            \"EigenPod.verifyBalanceUpdate: Validator not active\"\n        );\n\n        // 3. Balance updates should only be made before a validator is fully withdrawn. \n        // -- A withdrawable validator may not have withdrawn yet, so we require their balance is nonzero\n        // -- A fully withdrawn validator should withdraw via verifyAndProcessWithdrawals\n        if (validatorFields.getWithdrawableEpoch() <= _timestampToEpoch(oracleTimestamp)) {\n            require(\n                validatorEffectiveBalanceGwei > 0,\n                \"EigenPod.verifyBalanceUpdate: validator is withdrawable but has not withdrawn\"\n            );\n        }\n\n        // Verify passed-in validatorFields against verified beaconStateRoot:\n        BeaconChainProofs.verifyValidatorFields({\n            beaconStateRoot: beaconStateRoot,\n            validatorFields: validatorFields,\n            validatorFieldsProof: validatorFieldsProof,\n            validatorIndex: validatorIndex\n        });\n\n        // Done with proofs! Now update the validator's balance and send to the EigenPodManager if needed\n\n        uint64 currentRestakedBalanceGwei = validatorInfo.restakedBalanceGwei;\n        uint64 newRestakedBalanceGwei;\n        if (validatorEffectiveBalanceGwei > MAX_RESTAKED_BALANCE_GWEI_PER_VALIDATOR) {\n            newRestakedBalanceGwei = MAX_RESTAKED_BALANCE_GWEI_PER_VALIDATOR;\n        } else {\n            newRestakedBalanceGwei = validatorEffectiveBalanceGwei;\n        }\n        \n        // Update validator balance and timestamp, and save to state:\n        validatorInfo.restakedBalanceGwei = newRestakedBalanceGwei;\n        validatorInfo.mostRecentBalanceUpdateTimestamp = oracleTimestamp;\n        _validatorPubkeyHashToInfo[validatorPubkeyHash] = validatorInfo;\n\n        // If our new and old balances differ, calculate the delta and send to the EigenPodManager\n        if (newRestakedBalanceGwei != currentRestakedBalanceGwei) {\n            emit ValidatorBalanceUpdated(validatorIndex, oracleTimestamp, newRestakedBalanceGwei);\n\n            sharesDeltaGwei = _calculateSharesDelta({\n                newAmountGwei: newRestakedBalanceGwei,\n                previousAmountGwei: currentRestakedBalanceGwei\n            });\n        }\n    }\n\n    function _verifyAndProcessWithdrawal(\n        bytes32 beaconStateRoot,\n        BeaconChainProofs.WithdrawalProof calldata withdrawalProof,\n        bytes calldata validatorFieldsProof,\n        bytes32[] calldata validatorFields,\n        bytes32[] calldata withdrawalFields\n    )\n        internal\n        /**\n         * Check that the provided timestamp being proven against is after the `mostRecentWithdrawalTimestamp`.\n         * Without this check, there is an edge case where a user proves a past withdrawal for a validator whose funds they already withdrew,\n         * as a way to \"withdraw the same funds twice\" without providing adequate proof.\n         * Note that this check is not made using the oracleTimestamp as in the `verifyWithdrawalCredentials` proof; instead this proof\n         * proof is made for the timestamp of the withdrawal, which may be within SLOTS_PER_HISTORICAL_ROOT slots of the oracleTimestamp.\n         * This difference in modifier usage is OK, since it is still not possible to `verifyAndProcessWithdrawal` against a slot that occurred\n         * *prior* to the proof provided in the `verifyWithdrawalCredentials` function.\n         */\n        proofIsForValidTimestamp(withdrawalProof.getWithdrawalTimestamp())\n        returns (VerifiedWithdrawal memory)\n    {\n        uint64 withdrawalTimestamp = withdrawalProof.getWithdrawalTimestamp();\n        bytes32 validatorPubkeyHash = validatorFields.getPubkeyHash();\n\n        /**\n         * Withdrawal processing should only be performed for \"ACTIVE\" or \"WITHDRAWN\" validators.\n         * (WITHDRAWN is allowed because technically you can deposit to a validator even after it exits)\n         */\n        require(\n            _validatorPubkeyHashToInfo[validatorPubkeyHash].status != VALIDATOR_STATUS.INACTIVE,\n            \"EigenPod._verifyAndProcessWithdrawal: Validator never proven to have withdrawal credentials pointed to this contract\"\n        );\n\n        // Ensure we don't process the same withdrawal twice\n        require(\n            !provenWithdrawal[validatorPubkeyHash][withdrawalTimestamp],\n            \"EigenPod._verifyAndProcessWithdrawal: withdrawal has already been proven for this timestamp\"\n        );\n\n        provenWithdrawal[validatorPubkeyHash][withdrawalTimestamp] = true;\n\n        // Verifying the withdrawal against verified beaconStateRoot:\n        BeaconChainProofs.verifyWithdrawal({\n            beaconStateRoot: beaconStateRoot, \n            withdrawalFields: withdrawalFields, \n            withdrawalProof: withdrawalProof,\n            denebForkTimestamp: eigenPodManager.denebForkTimestamp()\n        });\n\n        uint40 validatorIndex = withdrawalFields.getValidatorIndex();\n\n        // Verify passed-in validatorFields against verified beaconStateRoot:\n        BeaconChainProofs.verifyValidatorFields({\n            beaconStateRoot: beaconStateRoot,\n            validatorFields: validatorFields,\n            validatorFieldsProof: validatorFieldsProof,\n            validatorIndex: validatorIndex\n        });\n\n        uint64 withdrawalAmountGwei = withdrawalFields.getWithdrawalAmountGwei();\n        \n        /**\n         * If the withdrawal's epoch comes after the validator's \"withdrawable epoch,\" we know the validator\n         * has fully withdrawn, and we process this as a full withdrawal.\n         */\n        if (withdrawalProof.getWithdrawalEpoch() >= validatorFields.getWithdrawableEpoch()) {\n            return\n                _processFullWithdrawal(\n                    validatorIndex,\n                    validatorPubkeyHash,\n                    withdrawalTimestamp,"
    }
  ]
}