{
  "Title": "[H02] EIP 820 implementation must be updated to EIP 1820",
  "Content": "[EIP 1820](https://github.com/ethereum/EIPs/pull/1820) has superseded [EIP 820](https://github.com/ethereum/EIPs/issues/820), the former being the latter’s adaptation for Solidity 0.5, due to [a bug](https://github.com/ethereum/EIPs/issues/820#issuecomment-452465748) that was found in [ERC820](https://eips.ethereum.org/EIPS/eip-820) which would prevent certain calls made in the [`staticcall`](https://github.com/jbaylina/ERC820/blob/master/contracts/ERC820Registry.sol#L201) to never return a `true`.\n\n\nTherefore, consider updating the specification to [ERC1820](https://eips.ethereum.org/EIPS/eip-1820). This will update the [`insize`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/ERC820Registry.sol#L149) [parameter of the](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/ERC820Registry.sol#L149) [`staticcall`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/ERC820Registry.sol#L149) from `0x08` to `0x24`. Contracts in [`ERC820Implementer.sol`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/ERC820Implementer.sol), [`IERC820Registry.sol`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/IERC820Registry.sol)[`ERC820Registry.sol`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/ERC820Registry.sol), [`ReputationToken.sol`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L28), [`DisputeWindow.sol`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/DisputeCrowdsourcer.sol#L20), and a number of other contracts using the ERC820 registry must all be updated to reflect the changes.\n\n\n***Update****: the ERC820 contract has been replaced with the ERC1820 contract in* [*`484e3ac`*](https://github.com/AugurProject/augur/commit/484e3ac8c3ae077797941d763ac2fc80dabf4161).\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "packages/augur-core/source/contracts/ERC820Registry.sol",
      "content": "pragma solidity 0.5.4;\n\nimport 'ROOT/libraries/ContractExists.sol';\nimport 'ROOT/libraries/IERC820Registry.sol';\n\n\ninterface ERC820ImplementerInterface {\n    /// @notice Contracts that implement an interferce in behalf of another contract must return true\n    /// @param addr Address that the contract woll implement the interface in behalf of\n    /// @param interfaceHash keccak256 of the name of the interface\n    /// @return ERC820_ACCEPT_MAGIC if the contract can implement the interface represented by\n    ///  `ìnterfaceHash` in behalf of `addr`\n    function canImplementInterfaceForAddress(address addr, bytes32 interfaceHash) external view returns(bytes32);\n}\n\n\ncontract ERC820Registry is IERC820Registry {\n    using ContractExists for address;\n\n    bytes4 constant InvalidID = 0xffffffff;\n    bytes4 constant ERC165ID = 0x01ffc9a7;\n    bytes32 constant ERC820_ACCEPT_MAGIC = keccak256(\"ERC820_ACCEPT_MAGIC\");\n\n    address private constant FOUNDATION_820_REGISTRY_ADDRESS = address(0x991a1bcb077599290d7305493c9A630c20f8b798);\n\n    constructor() public {\n        // This is to confirm we are not on foundation network\n        require(!FOUNDATION_820_REGISTRY_ADDRESS.exists());\n    }\n\n    mapping (address => mapping(bytes32 => address)) interfaces;\n    mapping (address => address) managers;\n    mapping (address => mapping(bytes4 => bool)) erc165Cache;\n\n    modifier canManage(address addr) {\n        require(getManager(addr) == msg.sender);\n        _;\n    }\n\n    event InterfaceImplementerSet(address indexed addr, bytes32 indexed interfaceHash, address indexed implementer);\n    event ManagerChanged(address indexed addr, address indexed newManager);\n\n    /// @notice Query the hash of an interface given a name\n    /// @param interfaceName Name of the interfce\n    function interfaceHash(string memory interfaceName) public pure returns(bytes32) {\n        return keccak256(abi.encodePacked(interfaceName));\n    }\n\n    /// @notice GetManager\n    function getManager(address addr) public view returns(address) {\n        // By default the manager of an address is the same address\n        if (managers[addr] == address(0)) {\n            return addr;\n        } else {\n            return managers[addr];\n        }\n    }\n\n    /// @notice Sets an external `manager` that will be able to call `setInterfaceImplementer()`\n    ///  on behalf of the address.\n    /// @param addr Address that you are defining the manager for.\n    /// @param newManager The address of the manager for the `addr` that will replace\n    ///  the old one.  Set to 0x0 if you want to remove the manager.\n    function setManager(address addr, address newManager) public canManage(addr) {\n        managers[addr] = newManager == addr ? address(0) : newManager;\n        emit ManagerChanged(addr, newManager);\n    }\n\n    /// @notice Query if an address implements an interface and thru which contract\n    /// @param addr Address that is being queried for the implementation of an interface\n    /// @param iHash SHA3 of the name of the interface as a string\n    ///  Example `web3.utils.sha3('ERC777Token`')`\n    /// @return The address of the contract that implements a specific interface\n    ///  or 0x0 if `addr` does not implement this interface\n    function getInterfaceImplementer(address addr, bytes32 iHash) public returns (address) {\n        if (isERC165Interface(iHash)) {\n            bytes4 i165Hash = bytes4(iHash);\n            return erc165InterfaceSupported(addr, i165Hash) ? addr : address(0);\n        }\n        return interfaces[addr][iHash];\n    }\n\n    /// @notice Sets the contract that will handle a specific interface; only\n    ///  the address itself or a `manager` defined for that address can set it\n    /// @param addr Address that you want to define the interface for\n    /// @param iHash SHA3 of the name of the interface as a string\n    ///  For example `web3.utils.sha3('Ierc777')` for the Ierc777\n    function setInterfaceImplementer(address addr, bytes32 iHash, address implementer) public canManage(addr) {\n        require(!isERC165Interface(iHash));\n        if ((implementer != address(0)) && (implementer!=msg.sender)) {\n            require(ERC820ImplementerInterface(implementer).canImplementInterfaceForAddress(addr, iHash) == ERC820_ACCEPT_MAGIC);\n        }\n        interfaces[addr][iHash] = implementer;\n        emit InterfaceImplementerSet(addr, iHash, implementer);\n    }\n\n    /// ERC165 Specific\n\n    function isERC165Interface(bytes32 iHash) internal pure returns (bool) {\n        return iHash & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0;\n    }\n\n    function erc165InterfaceSupported(address _contract, bytes4 _interfaceId) public returns (bool) {\n        if (!erc165Cache[_contract][_interfaceId]) {\n            erc165UpdateCache(_contract, _interfaceId);\n        }\n        return interfaces[_contract][_interfaceId] != address(0);\n    }\n\n    function erc165UpdateCache(address _contract, bytes4 _interfaceId) public {\n        interfaces[_contract][_interfaceId] =\n            erc165InterfaceSupported_NoCache(_contract, _interfaceId) ? _contract : address(0);\n        erc165Cache[_contract][_interfaceId] = true;\n    }\n\n    function erc165InterfaceSupported_NoCache(address _contract, bytes4 _interfaceId) public view returns (bool) {\n        uint256 success;\n        uint256 result;\n\n        (success, result) = noThrowCall(_contract, ERC165ID);\n        if ((success==0)||(result==0)) {\n            return false;\n        }\n\n        (success, result) = noThrowCall(_contract, InvalidID);\n        if ((success==0)||(result!=0)) {\n            return false;\n        }\n\n        (success, result) = noThrowCall(_contract, _interfaceId);\n        if ((success==1)&&(result==1)) {\n            return true;\n        }\n        return false;\n    }\n\n    function noThrowCall(address _contract, bytes4 _interfaceId) internal view returns (uint256 success, uint256 result) {\n        bytes4 erc165ID = ERC165ID;\n\n        assembly {\n                let x := mload(0x40)               // Find empty storage location using \"free memory pointer\"\n                mstore(x, erc165ID)                // Place signature at begining of empty storage\n                mstore(add(x, 0x04), _interfaceId) // Place first argument directly next to signature\n\n                success := staticcall(\n                                    30000,         // 30k gas\n                                    _contract,     // To addr\n                                    x,             // Inputs are stored at location x\n                                    0x08,          // Inputs are 8 bytes long\n                                    x,             // Store output over input (saves space)\n                                    0x20)          // Outputs are 32 bytes long\n\n                result := mload(x)                 // Load the result\n        }\n    }\n}"
    }
  ]
}