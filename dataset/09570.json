{
  "Title": "[L-01] Use safeTransfer/safeTransferFrom consistently instead of transfer/transferFrom",
  "Content": "<h2 id=\"l-01-use-safetransfersafetransferfrom-consistently-instead-of-transfertransferfrom\" style=\"position:relative;\"><a href=\"#l-01-use-safetransfersafetransferfrom-consistently-instead-of-transfertransferfrom\" aria-label=\"l 01 use safetransfersafetransferfrom consistently instead of transfertransferfrom permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-01] Use safeTransfer/safeTransferFrom consistently instead of transfer/transferFrom</h2>\n<p>It is good to add a require() statement that checks the return value of token transfers or to use something like OpenZeppelinâ€™s safeTransfer/safeTransferFrom unless one is sure the given token reverts in case of a failure. Failure to do so will cause silent failures of transfers and affect token accounting in contract.</p>\n<p>Reference: This <a href=\"https://consensys.net/diligence/audits/2021/01/fei-protocol/#unchecked-return-value-for-iweth-transfer-call\">similar medium-severity finding</a> from Consensys Diligence Audit of Fei Protocol.</p>\n<h3 id=\"proof-of-concept-4\" style=\"position:relative;\"><a href=\"#proof-of-concept-4\" aria-label=\"proof of concept 4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h3>\n<ol>\n<li>Navigate to the following contracts.</li>\n<li>transfer/transferFrom functions are used instead of safe transfer/transferFrom on the following contracts.</li>\n</ol>\n<p><a href=\"https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/FlashLoan.sol#L57\">FlashLoan.sol#L57</a><br>\n<a href=\"https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/UniV3LpVault.sol#L366\">UniV3LpVault.sol#L366</a><br></p>\n<h3 id=\"recommended-mitigation-steps-5\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-5\" aria-label=\"recommended mitigation steps 5 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<p>Consider using safeTransfer/safeTransferFrom or require() consistently.</p>\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-04-duality-focus-contest",
  "Code": [
    {
      "filename": "contracts/vault_and_oracles/FlashLoan.sol",
      "content": "pragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport { IFlashLoanReceiver, ILendingPool, ILendingPoolAddressesProvider } from \"../external/aave/AaveInterfaces.sol\";\nimport { IERC20 } from \"../external/openzeppelin/token/ERC20/IERC20.sol\";\nimport { SafeMath } from \"../external/openzeppelin/math/SafeMath.sol\";\n\nimport { CErc20Interface } from \"../interfaces/CompoundInterfaces.sol\";\nimport \"../interfaces/IUniV3LpVault.sol\";\n\n/** \n    !!!\n    Never keep funds permanently on your FlashLoanReceiverBase contract as they could be \n    exposed to a 'griefing' attack, where the stored funds are used by an attacker.\n    !!!\n */\ncontract FlashLoan is IFlashLoanReceiver {\n    using SafeMath for uint256;\n\n    ILendingPoolAddressesProvider public immutable override ADDRESSES_PROVIDER;\n    ILendingPool public immutable override LENDING_POOL;\n    IUniV3LpVault public immutable LP_VAULT;\n\n    constructor(address _addressesProvider, address _lpVault) {\n        ADDRESSES_PROVIDER = ILendingPoolAddressesProvider(_addressesProvider);\n        LENDING_POOL = ILendingPool(ILendingPoolAddressesProvider(_addressesProvider).getLendingPool());\n        LP_VAULT = IUniV3LpVault(_lpVault);\n    }\n\n    /**\n        This function is called after your contract has received the flash loaned amount\n     */\n    function executeOperation(\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata premiums,\n        address initiator,\n        bytes calldata params\n    ) external override returns (bool) {\n        require(msg.sender == address(LENDING_POOL), \"Flashloan from untrusted lending pool\");\n        require(initiator == address(LP_VAULT), \"Flashloan must be initiated from LP Vault\");\n        //\n        // This contract now has the funds requested.\n        // Your logic goes here.\n        //\n\n        IUniV3LpVault.FlashFocusParams memory focusParams = abi.decode(params, (IUniV3LpVault.FlashFocusParams));\n        IERC20(assets[0]).approve(address(LP_VAULT), amounts[0]);\n        focusParams.asset = assets[0];\n        focusParams.amount = amounts[0];\n        focusParams.premium = premiums[0];\n\n        LP_VAULT.flashFocusCall(focusParams);\n\n        // Approve the LendingPool contract allowance to *pull* the owed amount\n        uint256 amountOwing = amounts[0].add(premiums[0]);\n        IERC20(assets[0]).transferFrom(address(LP_VAULT), address(this), amountOwing);\n        IERC20(assets[0]).approve(address(LENDING_POOL), amountOwing);\n\n        return true;\n    }\n}"
    },
    {
      "filename": "contracts/vault_and_oracles/UniV3LpVault.sol",
      "content": "pragma solidity ^0.7.6;\npragma abicoder v2;\n\n// interfaces\nimport { ComptrollerInterface, TickOracleInterface, CErc20Interface } from \"../interfaces/CompoundInterfaces.sol\";\nimport \"../interfaces/IUniV3LpVault.sol\";\nimport \"../interfaces/IERC20Detailed.sol\";\nimport { IFlashLoanReceiver } from \"../external/aave/AaveInterfaces.sol\";\nimport \"../external/openzeppelin/token/ERC721/IERC721.sol\";\nimport \"../external/uniswap/v3-periphery/interfaces/INonfungiblePositionManager.sol\";\nimport \"../external/uniswap/v3-periphery/interfaces/ISwapRouter.sol\";\n\n// libs\nimport \"../external/uniswap/v3-core/libraries/TransferHelper.sol\";\nimport \"../external/uniswap/v3-periphery/libraries/BytesLib.sol\";\nimport { Uint256Casting } from \"../external/opyn/Uint256Casting.sol\";\nimport { SafeMath } from \"../external/openzeppelin/math/SafeMath.sol\";\nimport \"../libs/LiquidityLibrary.sol\";\n\n/**\n * @title UniV3LpVault\n * @author Duality (h/t to Uniswap's UniswapV3Staker as a starting point)\n */\ncontract UniV3LpVault is IUniV3LpVault {\n    using SafeMath for uint256;\n    using Uint256Casting for uint256;\n    using BytesLib for bytes;\n\n    address public override factory;\n\n    INonfungiblePositionManager public override nonfungiblePositionManager;\n\n    ISwapRouter public override swapRouter;\n\n    ComptrollerInterface public override comptroller;\n\n    IFlashLoanReceiver public override flashLoan;\n\n    mapping(address => bool) public override flashLoanAuthorized;\n\n    /// @dev ownerOf[tokenId] => address owner\n    mapping(uint256 => address) public override ownerOf;\n\n    /// @dev userTokens[userAddress] => tokenIds[]\n    mapping(address => uint256[]) public userTokens;\n\n    /// @notice max number of userTokens for a single userAddress\n    uint256 public override userTokensMax = 4;\n\n    /// @notice whether or not periphery functionality has been paused\n    bool public peripheryGuardianPaused;\n\n    /// @notice whether or not deposits have been paused\n    bool public depositGuardianPaused;\n\n    /// @dev Guard variable for re-entrancy checks\n    bool internal _notEntered;\n\n    constructor(\n        address _factory,\n        INonfungiblePositionManager _nonfungiblePositionManager,\n        ISwapRouter _swapRouter,\n        ComptrollerInterface _comptroller\n    ) {\n        factory = _factory;\n        nonfungiblePositionManager = _nonfungiblePositionManager;\n        swapRouter = _swapRouter;\n        comptroller = _comptroller;\n        _notEntered = true;\n    }\n\n    /*** External Mutator Functions ***/\n\n    /// @dev Upon receiving a Uniswap V3 ERC721, creates the token deposit setting owner to `from`\n    /// @inheritdoc IERC721Receiver\n    function onERC721Received(\n        address,\n        address from,\n        uint256 tokenId,\n        bytes calldata\n    ) external override nonReentrant(false) returns (bytes4) {\n        require(!depositGuardianPaused, \"deposit is paused\");\n        require(msg.sender == address(nonfungiblePositionManager), \"IUniV3LpVault::onERC721Received: not a Uni V3 nft\");\n\n        _processNewToken(tokenId, from);\n        emit TokenDeposited(from, tokenId);\n        return this.onERC721Received.selector;\n    }\n\n    /**\n     * @notice Withdraw a tokenId from the vault, so long as the caller's debt is still sufficiently collateralized\n     * @param tokenId The tokenId of the NFT to be withdrawn\n     * @param to The address to send tokenId to\n     * @param data any data to provide for the safeTransferFrom call\n     */\n    function withdrawToken(\n        uint256 tokenId,\n        address to,\n        bytes memory data\n    ) external override nonReentrant(false) avoidsShortfall {\n        require(to != address(this), \"IUniV3LpVault::withdrawToken: cannot withdraw to vault\");\n        require(ownerOf[tokenId] == msg.sender, \"IUniV3LpVault::withdrawToken: only owner can withdraw token\");\n\n        _deleteOldToken(msg.sender, tokenId);\n\n        nonfungiblePositionManager.safeTransferFrom(address(this), to, tokenId, data);\n        emit TokenWithdrawn(msg.sender, to, tokenId);\n    }\n\n    /**\n     * @notice Seize fees and/or liquidity from a borrower's LP NFT, assuming the seizure is allowed.\n     *          To be called exclusively from the CToken of the debt asset (Best mirroring original compound liquidation path)\n     * @param liquidator The address of the EOA/Contract claiming the liquidation + incentive\n     * @param borrower The address of the account currently in shortfall. Owner of tokenId.\n     * @param tokenId The tokenId to be partially or fully liquidated. Owned by Borrower.\n     * @param seizeFeesToken0 The amount of token0 to seize from tokenId's fees\n     * @param seizeFeesToken1 The amount of token1 to seize from tokenId's fees\n     * @param seizeLiquidity The amount of liquidity to convert to token0/token1 and seize\n     */\n    function seizeAssets(\n        address liquidator,\n        address borrower,\n        uint256 tokenId,\n        uint256 seizeFeesToken0,\n        uint256 seizeFeesToken1,\n        uint256 seizeLiquidity\n    ) external override nonReentrant(true) {\n        require(ownerOf[tokenId] == borrower, \"borrower must own tokenId\");\n\n        // make call to comptroller to ensure seize is allowed\n        uint256 allowed = ComptrollerInterface(comptroller).seizeAllowedUniV3(\n            address(this),\n            msg.sender,\n            liquidator,\n            borrower,\n            tokenId,\n            seizeFeesToken0,\n            seizeFeesToken1,\n            seizeLiquidity\n        );\n\n        // TODO: do we want some Comptroller like error handling/messaging here?\n        require(allowed == 0, \"seize not allowed according to Comptroller\");\n\n        if (seizeLiquidity > 0) {\n            // liquidate seizeLiquidity from tokenId position\n            _decreaseLiquidity(tokenId, uint128(seizeLiquidity));\n\n            // claim all fees + tokens from liquidity removal\n            nonfungiblePositionManager.collect(\n                INonfungiblePositionManager.CollectParams(tokenId, liquidator, type(uint128).max, type(uint128).max)\n            );\n        } else {\n            // claim feesAmountToken0 and feesAmountToken1 and send to liquidator\n            nonfungiblePositionManager.collect(\n                INonfungiblePositionManager.CollectParams(\n                    tokenId,\n                    liquidator,\n                    uint128(seizeFeesToken0),\n                    uint128(seizeFeesToken1)\n                )\n            );\n        }\n    }\n\n    // TODO: do we want a \"decreaseLiquidityAndCollect\" function?\n\n    /**\n     * @notice Passthrough function to NonfungiblePositionManager for an owner of an NFT to decrease its liquidity.\n     *          Checks that the user's position is still sufficiently collateralized after taking this action\n     * @param params INonfungiblePositionManager's decreaseLiquidityParams for the passthrough call\n     */\n    function decreaseLiquidity(INonfungiblePositionManager.DecreaseLiquidityParams calldata params)\n        external\n        override\n        nonReentrant(false)\n        isAuthorizedForToken(params.tokenId)\n        avoidsShortfall\n    {\n        require(!peripheryGuardianPaused, \"periphery functionality is paused\");\n\n        nonfungiblePositionManager.decreaseLiquidity(params);\n        emit LiquidityDecreased(msg.sender, params.tokenId, params.liquidity);\n    }\n\n    /**\n     * @notice Passthrough function to NonfungiblePositionManager for an owner of an NFT to collect its fees.\n     *          Checks that the user's position is still sufficiently collateralized after taking this action\n     * @param params INonfungiblePositionManager's CollectParams for the passthrough call\n     */\n    function collectFees(INonfungiblePositionManager.CollectParams calldata params)\n        external\n        override\n        nonReentrant(false)\n        isAuthorizedForToken(params.tokenId)\n        avoidsShortfall\n    {\n        require(!peripheryGuardianPaused, \"periphery functionality is paused\");\n\n        (uint256 amount0, uint256 amount1) = nonfungiblePositionManager.collect(params);\n        emit FeesCollected(msg.sender, params.tokenId, amount0, amount1);\n    }\n\n    /**\n     * @notice function for an owner of an NFT to automatically compound fees into liquidity of a range.\n     *          Checks that the user's position is still sufficiently collateralized after taking this action\n     *\n     *          Target balance of fees for swap are pre-computed off-chain along with slippage tolerance.\n     *\n     *          Swap is made by swapping the extra of token0 (according to expectedAmount0) to token1, depositing\n     *          the max liquidity possible (along with min checks), and any remnants left are sent back to the user\n     *\n     * @param params our CompoundFeesParams, described at definition in the interface\n     */\n    function compoundFees(CompoundFeesParams calldata params)\n        external\n        override\n        nonReentrant(false)\n        isAuthorizedForToken(params.tokenId)\n        avoidsShortfall\n    {\n        require(!peripheryGuardianPaused, \"periphery functionality is paused\");\n\n        // collect all fees\n        (uint256 amount0, uint256 amount1) = _collectMax(params.tokenId);\n\n        address token0;\n        address token1;\n\n        {\n            // avoid stack too deep\n            uint24 fee;\n            (, , token0, token1, fee, , , , , , , ) = nonfungiblePositionManager.positions(params.tokenId);\n\n            // trade assets to expectedAmounts (assuming correct off-chain computation)\n            (amount0, amount1) = _prepareForDeposit(\n                token0,\n                token1,\n                fee,\n                params.expectedAmount0,\n                params.expectedAmount1,\n                amount0,\n                amount1\n            );\n        }\n\n        // attempt to deposit amount0 and amount1 into our range\n        (uint256 amountTaken0, uint256 amountTaken1) = _increaseLiquidity(\n            params.tokenId,\n            token0,\n            token1,\n            amount0,\n            amount1,\n            params.amount0Min,\n            params.amount1Min\n        );\n\n        uint256 amountReturned0 = amount0 > amountTaken0 ? amount0.sub(amountTaken0) : 0;\n        uint256 amountReturned1 = amount1 > amountTaken1 ? amount1.sub(amountTaken1) : 0;\n\n        // send back remnants to user\n        if (amountReturned0 > 0) TransferHelper.safeTransfer(token0, msg.sender, amountReturned0);\n        if (amountReturned1 > 0) TransferHelper.safeTransfer(token1, msg.sender, amountReturned1);\n        emit FeesCompounded(msg.sender, params.tokenId, amountTaken0, amountTaken1, amountReturned0, amountReturned1);\n    }\n\n    /**\n     * @notice function for an owner of an NFT to move liquidity of one range into a new range.\n     *          Checks that the user's position is still sufficiently collateralized after taking this action\n     *\n     *          Target balance of fees for swap are pre-computed off-chain along with slippage tolerance.\n     *\n     *          Swap is made by swapping the extra of token0 (according to expectedAmount0) to token1, depositing\n     *          the max liquidity possible (along with min checks), and any remnants left are sent back to the user\n     *\n     * @param params our MoveRangeParams, described at definition in the interface\n     * @return newTokenId The tokenId of our new Uni V3 LP position\n     */\n    function moveRange(MoveRangeParams calldata params)\n        external\n        override\n        nonReentrant(false)\n        isAuthorizedForToken(params.tokenId)\n        avoidsShortfall\n        returns (uint256 newTokenId)\n    {\n        require(!peripheryGuardianPaused, \"periphery functionality is paused\");\n\n        // remove params.liquidity from token (moves to token's fees)\n        if (params.liquidity > 0) _decreaseLiquidity(params.tokenId, params.liquidity);\n\n        // collect all fees (includes decreased liquidity)\n        (uint256 amount0, uint256 amount1) = _collectMax(params.tokenId);\n\n        (, , address token0, address token1, uint24 fee, , , , , , , ) = nonfungiblePositionManager.positions(\n            params.tokenId\n        );\n\n        // trade assets to expectedAmounts (assuming correct off-chain computation)\n        (amount0, amount1) = _prepareForDeposit(\n            token0,\n            token1,\n            fee,\n            params.expectedAmount0,\n            params.expectedAmount1,\n            amount0,\n            amount1\n        );\n\n        // prepare mintParams\n        INonfungiblePositionManager.MintParams memory mintParams = INonfungiblePositionManager.MintParams(\n            token0,\n            token1,\n            fee,\n            params.newTickLower,\n            params.newTickUpper,\n            amount0,\n            amount1,\n            params.amount0Min,\n            params.amount1Min,\n            msg.sender, // _mint utilizes this appropriately\n            block.timestamp + 200\n        );\n\n        // burn old token if emptied\n        (, , , , , , , uint128 newLiquidity, , , , ) = nonfungiblePositionManager.positions(params.tokenId);\n        if (newLiquidity == 0) _burn(msg.sender, params.tokenId);\n\n        {\n            uint256 amountTaken0;\n            uint256 amountTaken1;\n\n            // mint new range\n            (newTokenId, amountTaken0, amountTaken1) = _mint(mintParams);\n\n            // send back remnants to user\n            if (amount0 > amountTaken0) TransferHelper.safeTransfer(token0, msg.sender, amount0.sub(amountTaken0));\n            if (amount1 > amountTaken1) TransferHelper.safeTransfer(token1, msg.sender, amount1.sub(amountTaken1));\n        }\n\n        emit RangeMoved(msg.sender, params.tokenId, newTokenId, params.liquidity, newLiquidity == 0);\n    }\n\n    /**\n     * @notice function only to be called by flashloan contract initiated from the NFT owner\n     * @param params our MoveRangeParams, described at definition in the interface\n     */\n    function flashFocusCall(FlashFocusParams calldata params) external override {\n        address owner = ownerOf[params.tokenId];\n        (, , address token0, address token1, , , , , , , , ) = nonfungiblePositionManager.positions(params.tokenId);\n\n        bool tokenOfPool = params.asset == token0 || params.asset == token1;\n\n        require(!peripheryGuardianPaused, \"periphery functionality is paused\");\n        require(msg.sender == address(flashLoan), \"Can only be called from our flashLoan contract\");\n        require(flashLoanAuthorized[owner], \"flashLoan action must have been authorized by tokenId owner\");\n        require(\n            tokenOfPool || params.swapPath.length > 0,\n            \"flashLoaned asset must be a pool asset or swapping to token0\"\n        );\n        require(_checkSwapPath(params.swapPath, params.asset, token0), \"swapPath did not pass integrity check\");\n\n        flashLoanAuthorized[owner] = false;\n\n        // transfer flashLoaned assets to vault\n        IERC20Detailed(params.asset).transferFrom(msg.sender, address(this), params.amount);\n\n        uint256 amount0;\n        uint256 amount1;\n\n        {\n            // creating local scope, avoiding stack too deep\n\n            // calculate our starting amounts of each asset\n            uint256 amountIn0 = params.asset == token0 ? params.amount : 0;\n            uint256 amountIn1 = params.asset == token1 ? params.amount : 0;\n\n            // swap everything to token0 if swap path is provided and params.asset is neither of the tokens\n            if (!tokenOfPool && params.swapPath.length > 0) amountIn0 = _swap(params.swapPath, params.amount);\n\n            (, , , , uint24 fee, , , , , , , ) = nonfungiblePositionManager.positions(params.tokenId);\n\n            // trade assets to expectedAmounts (assuming correct off-chain computation)\n            (amount0, amount1) = _prepareForDeposit(\n                token0,\n                token1,\n                fee,\n                params.expectedAmount0,\n                params.expectedAmount1,\n                amountIn0,\n                amountIn1\n            );\n        }\n\n        // attempt to deposit amount0 and amount1 into our range\n        (uint256 amountTaken0, uint256 amountTaken1) = _increaseLiquidity(\n            params.tokenId,\n            token0,\n            token1,\n            amount0,\n            amount1,\n            params.amount0Min,\n            params.amount1Min\n        );\n\n        {\n            // another local scope :)\n            uint256 owedBack = params.amount.add(params.premium);\n\n            // borrow the flashloaned asset in preparation for closing loan\n            uint256 success = CErc20Interface(comptroller.cTokensByUnderlying(params.asset)).borrowBehalf(\n                owner,\n                owedBack\n            );\n            require(success == 0, \"borrow failed\");\n\n            // approve borrowed assets for flashLoan to pull\n            IERC20Detailed(params.asset).approve(msg.sender, owedBack);\n        }\n\n        uint256 amountReturned0 = amount0 > amountTaken0 ? amount0.sub(amountTaken0) : 0;\n        uint256 amountReturned1 = amount1 > amountTaken1 ? amount1.sub(amountTaken1) : 0;\n\n        // send back remnants to user\n        if (amountReturned0 > 0) TransferHelper.safeTransfer(token0, msg.sender, amountReturned0);\n        if (amountReturned1 > 0) TransferHelper.safeTransfer(token1, msg.sender, amountReturned1);\n        emit FlashFocus(\n            msg.sender,\n            params.tokenId,\n            params.asset,\n            params.amount,\n            amountTaken0,\n            amountTaken1,\n            amountReturned0,\n            amountReturned1\n        );\n    }\n\n    /**\n     * @notice function for an owner of an NFT to be able enter into a focused position in one click.\n     *          Allows a user, via flashloan, to open debt and re-deposit as liquidity into their NFT range\n     *          up to max leverage in one tx.\n     *          Reentrancy guard must be local, or split up around call to CToken\n     * @param params our FlashFocusParams, described at definition in the interface\n     */\n    function flashFocus(FlashFocusParams calldata params)\n        external\n        override\n        nonReentrant(true)\n        isAuthorizedForToken(params.tokenId)\n        avoidsShortfall\n    {\n        require(!peripheryGuardianPaused, \"periphery functionality is paused\");\n        address receiverAddress = address(flashLoan);\n\n        address[] memory assets = new address[](1);\n        uint256[] memory amounts = new uint256[](1);\n        uint256[] memory modes = new uint256[](1);\n\n        assets[0] = params.asset;\n        amounts[0] = params.amount;\n        modes[0] = 0;\n\n        address onBehalfOf = address(this);\n        bytes memory newParams = abi.encode(params);\n        uint16 referralCode = 0;\n\n        flashLoanAuthorized[msg.sender] = true;\n        flashLoan.LENDING_POOL().flashLoan(\n            receiverAddress,\n            assets,\n            amounts,\n            modes,\n            onBehalfOf,\n            newParams,\n            referralCode\n        );\n    }\n\n    /**\n     * @notice function for an owner of an NFT to be able to repay a debt using an NFT in one click.\n     *          Allows a user to repay debt by removing liquidity / fees from an NFT and swapping to\n     *          the debt token in one tx.\n     * @param params our RepayDebtParams, described at definition in the interface\n     * @return amountReturned The amount of the debtToken returned to the function caller\n     */\n    function repayDebt(RepayDebtParams calldata params)\n        external\n        override\n        nonReentrant(true)\n        isAuthorizedForToken(params.tokenId)\n        avoidsShortfall\n        returns (uint256 amountReturned)\n    {\n        require(!peripheryGuardianPaused, \"periphery functionality is paused\");\n        require(comptroller.markets(params.debtCToken).isListed, \"Debt CToken must be listed by comptroller\");\n        require(\n            params.underlying == CErc20Interface(params.debtCToken).underlying(),\n            \"Underlying must match CToken underlying\"\n        );\n\n        (, , address token0, address token1, , , , , , , , ) = nonfungiblePositionManager.positions(params.tokenId);\n        require(_checkSwapPath(params.swapPath0, token0, params.underlying), \"swapPath0 did not pass integrity check\");\n        require(_checkSwapPath(params.swapPath1, token1, params.underlying), \"swapPath1 did not pass integrity check\");\n\n        // remove params.liquidity from token (moves to token's fees)\n        if (params.liquidity > 0) _decreaseLiquidity(params.tokenId, params.liquidity);\n\n        uint256 amountOutTotal;\n\n        {\n            // collect all fees (includes decreased liquidity)\n            (uint256 amount0, uint256 amount1) = _collectMax(params.tokenId);\n\n            // calculate the totalAmount of debt asset we have.\n            // check if token0 or token1 are the debt asset. otherwise, swap token0 and token1 to debt asset using swapPaths\n            uint256 amountOutFrom0 = token0 == params.underlying ? amount0 : 0;\n            uint256 amountOutFrom1 = token1 == params.underlying ? amount1 : 0;\n\n            if (amountOutFrom0 == 0 && params.swapPath0.length > 0) amountOutFrom0 = _swap(params.swapPath0, amount0);\n            if (amountOutFrom1 == 0 && params.swapPath1.length > 0) amountOutFrom1 = _swap(params.swapPath1, amount1);\n\n            // total amount of debtAsset we've collected to use towards repay\n            amountOutTotal = amountOutFrom0.add(amountOutFrom1);\n        }\n\n        require(\n            amountOutTotal > params.repayAmount,\n            \"not enough liquidity burned: Repay debt must repay repayAmount of debt\"\n        );\n\n        // repay the debt for user with new funds\n        IERC20Detailed(params.underlying).approve(address(params.debtCToken), params.repayAmount);\n        uint256 succeeded = CErc20Interface(params.debtCToken).repayBorrowBehalf(msg.sender, params.repayAmount);\n        require(succeeded == 0, \"repay debt did not succeed\");\n        IERC20Detailed(params.underlying).approve(address(params.debtCToken), 0);\n\n        // return remnants to user\n        amountReturned = amountOutTotal > params.repayAmount ? amountOutTotal.sub(params.repayAmount) : 0;\n\n        if (amountReturned > 0) TransferHelper.safeTransfer(params.underlying, msg.sender, amountReturned);\n\n        emit RepayDebt(\n            msg.sender,\n            params.tokenId,\n            params.liquidity,\n            params.debtCToken,\n            params.underlying,\n            params.repayAmount,\n            amountReturned\n        );\n    }\n\n    /*** External View Functions ***/\n\n    /**\n     * @notice gets the length of UserTokens for an account. Allows comptroller to query NFTs for value\n     * @param account The address of the account we want the user tokens length for\n     * @return length The length of the user's userTokens array\n     */\n    function getUserTokensLength(address account) external view override returns (uint256 length) {\n        length = userTokens[account].length;\n    }\n\n    /**\n     * @notice gets the poolAddress for a deposited tokenId\n     * @param tokenId The tokenId to get the poolAddress of\n     * @return poolAddress The address of the pool the token is a deposit of\n     */\n    function getPoolAddress(uint256 tokenId) external view override returns (address poolAddress) {\n        poolAddress = _getPoolAddress(tokenId);\n    }\n\n    /*** Internal Mutator Functions ***/\n\n    /**\n     * @notice Internal function to prepare for a deposit liquidity into a Uni V3 range.\n     *          uses a pool to swap amount0 and amount1 to expectedAmount0 and expectedAmount1.\n     *          uses naive logic, assumes adequate off-chain computation for expectedAmounts\n     *\n     * @param token0 Address of token0\n     * @param token1 Address of token1\n     * @param fee Fee of the pool to swap with\n     * @param expectedAmount0 The amount of token0 that we expect to deposit into a range\n     * @param expectedAmount1 The amount of token1 that we expect to deposit into a range\n     * @param amount0 The amount of token0 that we currently hold and are preparing for deposit (some may be swapped for token1)\n     * @param amount1 The amount of token1 that we currently hold and are preparing for deposit (some may be swapped for token1)\n     * @return newAmount0 Amount of token0 after preparation\n     *         newAmount1 Amount of token1 after preparation\n     */\n    function _prepareForDeposit(\n        address token0,\n        address token1,\n        uint24 fee,\n        uint256 expectedAmount0,\n        uint256 expectedAmount1,\n        uint256 amount0,\n        uint256 amount1\n    ) internal returns (uint256 newAmount0, uint256 newAmount1) {\n        if (expectedAmount0 < amount0) {\n            // have extra token0, trade all of the extra to token1\n            uint256 amountOut = _swap(abi.encodePacked(token0, fee, token1), amount0.sub(expectedAmount0));\n            newAmount0 = expectedAmount0;\n            newAmount1 = amount1.add(amountOut);\n        } else if (expectedAmount1 < amount1) {\n            // have extra of token1, trade all of the extra to token0\n            uint256 amountOut = _swap(abi.encodePacked(token1, fee, token0), amount1.sub(expectedAmount1));\n            newAmount0 = amount0.add(amountOut);\n            newAmount1 = expectedAmount1;\n        } else {\n            newAmount0 = amount0;\n            newAmount1 = amount1;\n        }\n    }\n\n    /**\n     * @notice Executes a swap. Performs necessary approval beforehand, and zeros out afterwards for safety\n     * @param swapPath The path to swap along\n     * @param amount The amount of the first token to swap\n     */\n    function _swap(bytes memory swapPath, uint256 amount) internal returns (uint256 amountOut) {\n        IERC20Detailed(swapPath.toAddress(0)).approve(address(swapRouter), amount);\n        amountOut = swapRouter.exactInput(\n            ISwapRouter.ExactInputParams(swapPath, address(this), block.timestamp + 200, amount, 0)\n        );\n        IERC20Detailed(swapPath.toAddress(0)).approve(address(swapRouter), 0);\n    }\n\n    /**\n     * @notice Increases liquidity of a Uni V3 NFT\n     * @param tokenId The tokenId of the NFT we are depositing liquidity into\n     * @param token0 The address of the first token of the pool\n     * @param token1 The address of the second token of the pool\n     * @param amount0 The amount of token0 that we expect to deposit\n     * @param amount1 The amount of token1 that we expect to deposit\n     * @param amount0Min The min amount of token0 that we are willing to deposit (slippage check)\n     * @param amount1Min The min amount of token1 that we are willing to deposit (slippage check)\n     * @return amountOut0 Amount of token0 deposited into tokenId\n     *         amountOut1 Amount of token1 deposited into tokenId\n     */\n    function _increaseLiquidity(\n        uint256 tokenId,\n        address token0,\n        address token1,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 amount0Min,\n        uint256 amount1Min\n    ) internal returns (uint256 amountOut0, uint256 amountOut1) {\n        IERC20Detailed(token0).approve(address(nonfungiblePositionManager), amount0);\n        IERC20Detailed(token1).approve(address(nonfungiblePositionManager), amount1);\n\n        // deposit liquidity into tokenId\n        (, amountOut0, amountOut1) = nonfungiblePositionManager.increaseLiquidity(\n            INonfungiblePositionManager.IncreaseLiquidityParams(\n                tokenId,\n                amount0,\n                amount1,\n                amount0Min,\n                amount1Min,\n                block.timestamp + 200\n            )\n        );\n\n        IERC20Detailed(token0).approve(address(nonfungiblePositionManager), 0);\n        IERC20Detailed(token1).approve(address(nonfungiblePositionManager), 0);\n    }\n\n    /**\n     * @notice Decreases liquidity of a Uni V3 NFT\n     * @param tokenId The tokenId of the NFT we are decreasing liquidity of\n     * @param liquidity The amount of liquidity that we will be decreasing of tokenId\n     */\n    function _decreaseLiquidity(uint256 tokenId, uint128 liquidity) internal {\n        nonfungiblePositionManager.decreaseLiquidity(\n            INonfungiblePositionManager.DecreaseLiquidityParams(tokenId, liquidity, 0, 0, block.timestamp + 200)\n        );\n    }\n\n    /**\n     * @notice Collects the maximum amount of fees available from the NFT to this contract\n     * @param tokenId The tokenId of the NFT we are collecting fees from\n     */\n    function _collectMax(uint256 tokenId) internal returns (uint256 amount0, uint256 amount1) {\n        (amount0, amount1) = nonfungiblePositionManager.collect(\n            INonfungiblePositionManager.CollectParams(tokenId, address(this), type(uint128).max, type(uint128).max)\n        );\n    }\n\n    /**\n     * @notice mints a fresh Uni V3 NFT on behalf of a user of this contract.\n     *          Ownership of the mint is replaced with this contract, and the new token is then processed as a new token\n     *          in this contract under the user's ownership\n     * @param params NonfungiblePositionManager's MintParams. Acts as a passthrough except for ownership management\n     */\n    function _mint(INonfungiblePositionManager.MintParams memory params)\n        internal\n        returns (\n            uint256 tokenId,\n            uint256 amount0,\n            uint256 amount1\n        )\n    {\n        IERC20Detailed(params.token0).approve(address(nonfungiblePositionManager), params.amount0Desired);\n        IERC20Detailed(params.token1).approve(address(nonfungiblePositionManager), params.amount1Desired);\n\n        (tokenId, , amount0, amount1) = nonfungiblePositionManager.mint(\n            INonfungiblePositionManager.MintParams(\n                params.token0,\n                params.token1,\n                params.fee,\n                params.tickLower,\n                params.tickUpper,\n                params.amount0Desired,\n                params.amount1Desired,\n                params.amount0Min,\n                params.amount1Min,\n                address(this), // replace recipient, and denote owner on deposit entry\n                params.deadline\n            )\n        );\n\n        IERC20Detailed(params.token0).approve(addre"
    }
  ]
}