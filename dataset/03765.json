{
  "Title": "The approval value obtained in the constructor may not be enough for the long term of the smart contract",
  "Content": "##### Description\nSmart contracts call `safeApprove()` functions for different tokens. But in the process of work, the obtained value will only decrease. If this value decreases to zero, then the tokens will remain locked in the contract forever.\nIt is at the following lines:\n- https://github.com/andy8052/yveCRV-vault/blob/6706b9ad45e71ee9014454419f229adfa6409f1d/contracts/Strategy.sol#L96-L97\n  \n##### Recommendation\nIt is recommended to add a function to increase the value of approvals.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Strategy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\n// Feel free to change the license, but this is what we use\n\n// Feel free to change this version of Solidity. We support >=0.6.0 <0.7.0;\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\n// These are the core Yearn libraries\nimport {\n    BaseStrategy\n} from \"@yearnvaults/contracts/BaseStrategy.sol\";\nimport {\n    SafeERC20,\n    SafeMath,\n    IERC20,\n    Address\n} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\ninterface Swap {\n    function swapExactTokensForTokens(\n        uint256,\n        uint256,\n        address[] calldata,\n        address,\n        uint256\n    ) external;\n    function getAmountsOut(uint amountIn, address[] memory path) external view returns (uint[] memory amounts);\n}\n\ninterface Pair {\n    function getReserves() external view returns (\n        uint112,\n        uint112,\n        uint32\n    );\n}\n\n\n\ninterface ICurveFi {\n    function calc_withdraw_one_coin(uint256, int128) external view returns(uint256);\n    function remove_liquidity_one_coin(uint256, int128, uint256) external;\n}\n\ninterface IVoterProxy {\n    function lock() external;\n}\n\ninterface IyveCRV {\n    function claimable(address) external view returns(uint256);\n    function supplyIndex(address) external view returns(uint256);\n    function balanceOf(address) external view returns(uint256);\n    function index() external view returns(uint256);\n    function claim() external;\n    function depositAll() external;\n}\n\nlibrary UniswapV2Library {\n    using SafeMath for uint;\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n}\n\ncontract Strategy is BaseStrategy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public constant proxy          = address(0x9a165622a744C20E3B2CB443AeD98110a33a231b);\n    address public constant crv            = address(0xD533a949740bb3306d119CC777fa900bA034cd52);\n    address public constant yveCrv         = address(0xc5bDdf9843308380375a611c18B50Fb9341f502A);\n    address public constant usdc           = address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    address public constant crv3           = address(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);\n    address public constant crv3Pool       = address(0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7);\n    address public constant weth           = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    address public constant sushiswap      = address(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);\n    address public constant ethCrvPair     = address(0x58Dc5a51fE44589BEb22E8CE67720B5BC5378009); // Sushi\n    address public constant ethYveCrvPair  = address(0x10B47177E92Ef9D5C6059055d92DdF6290848991); // Sushi\n    address public constant ethUsdcPair    = address(0x397FF1542f962076d0BFE58eA045FfA2d347ACa0);\n\n    uint256 public constant DENOMINATOR = 1000;\n    // Configurable preference for locking CRV in vault vs market-buying yveCRV. Buy only when yveCRV price becomes > 3% price of CRV\n    uint256 public vaultBuffer          = 30;\n\n    constructor(address _vault) public BaseStrategy(_vault) {\n        // You can set these parameters on deployment to whatever you want\n        // maxReportDelay = 6300;\n        // profitFactor = 100;\n        // debtThreshold = 0;\n        IERC20(crv).safeApprove(address(want), type(uint256).max);\n        IERC20(usdc).safeApprove(sushiswap, type(uint256).max);\n    }\n\n    function name() external view override returns (string memory) {\n        return \"StrategyYearnVECRV\";\n    }\n\n    function estimatedTotalAssets() public view override returns (uint256) {\n        uint256 _totalAssets = want.balanceOf(address(this));\n        uint256 claimable = getClaimable3Crv();\n        if(claimable > 0){\n            uint256 stable = quoteWithdrawFromCrv(claimable); // Calculate withdrawal amount\n            if(stable > 0){ // Quote will revert if amount is < 1\n                uint256 estveCrv = quote(usdc, address(want), stable);\n                _totalAssets = _totalAssets.add(estveCrv);\n            }\n        }\n        return _totalAssets;\n    }\n\n    function prepareReturn(uint256 _debtOutstanding)\n        internal\n        override\n        returns (\n            uint256 _profit,\n            uint256 _loss,\n            uint256 _debtPayment\n        )\n    {\n        if (_debtOutstanding > 0) {\n            (_debtPayment, _loss) = liquidatePosition(_debtOutstanding);\n        }\n\n        // Figure out how much want we have\n        uint256 claimable = getClaimable3Crv();\n        claimable = claimable > 0 ? claimable : IERC20(crv3).balanceOf(address(this)); // We do this to make testing harvest easier\n        if (claimable > 0) {\n            IyveCRV(address(want)).claim();\n            withdrawFromCrv(); // Convert 3crv to USDC\n            uint256 usdcBalance = IERC20(usdc).balanceOf(address(this));\n            if(usdcBalance > 0){\n                // Aquire yveCRV either via mint or market-buy\n                if(shouldMint(usdcBalance)){\n                    swap(usdc, crv, usdcBalance);\n                    deposityveCRV();\n                }\n                else{\n                    swap(usdc, yveCrv, usdcBalance);\n                }\n            }\n        }\n    }\n\n    // Here we lock curve in the voter contract\n    function adjustPosition(uint256 _debtOutstanding) internal override {\n        IVoterProxy(proxy).lock();\n    }\n\n    function liquidatePosition(uint256 _amountNeeded)\n        internal\n        override\n        returns (uint256 _liquidatedAmount, uint256 _loss)\n    {\n        uint256 totalAssets = want.balanceOf(address(this));\n        if (_amountNeeded > totalAssets) {\n            _liquidatedAmount = totalAssets;\n            _loss = _amountNeeded.sub(totalAssets);\n        } else {\n            _liquidatedAmount = _amountNeeded;\n        }\n    }\n\n    // NOTE: Can override `tendTrigger` and `harvestTrigger` if necessary\n\n    function prepareMigration(address _newStrategy) internal override {\n        uint256 balance3crv = IERC20(crv3).balanceOf(address(this));\n        uint256 balanceYveCrv = IERC20(yveCrv).balanceOf(address(this));\n        if(balance3crv > 0){\n            IERC20(crv3).safeTransfer(_newStrategy, balance3crv);\n        }\n        if(balanceYveCrv > 0){\n            IERC20(yveCrv).safeTransfer(_newStrategy, balanceYveCrv);\n        }\n        return;\n    }\n\n    // Here we determine if better to market-buy yveCRV or mint it with the vault\n    function shouldMint(uint256 _amountIn) internal view returns (bool) {\n        // Using reserve ratios of swap pairs will allow us to compare CRV vs yveCRV price\n        // Get reserves for all 3 pairs to be used. This should be a cheaper operation than multiple getAmountsOut calls\n        Pair pair = Pair(ethUsdcPair);\n        (uint256 reserveUsdc, uint256 wethU, ) = pair.getReserves();\n        pair = Pair(ethCrvPair);\n        (uint256 wethC, uint256 reserveCrv, ) = pair.getReserves();\n        pair = Pair(ethYveCrvPair);\n        (uint256 wethY, uint256 reserveYveCrv, ) = pair.getReserves();\n\n        uint256 projectedWeth = UniswapV2Library.getAmountOut(_amountIn, reserveUsdc, wethU);\n        uint256 projectedCrv = UniswapV2Library.getAmountOut(projectedWeth, wethC, reserveCrv);\n        uint256 projectedYveCrv = UniswapV2Library.getAmountOut(projectedWeth, wethY, reserveYveCrv);\n\n        // Return true if CRV output plus buffer is better than yveCRV\n        return projectedCrv.mul(DENOMINATOR.add(vaultBuffer)).div(DENOMINATOR) > projectedYveCrv;\n    }\n\n    function withdrawFromCrv() internal {\n        uint256 amount = IERC20(crv3).balanceOf(address(this));\n        ICurveFi(crv3Pool).remove_liquidity_one_coin(amount, 1, 0);\n    }\n\n    function quoteWithdrawFromCrv(uint256 _amount) internal view returns(uint256) {\n        return ICurveFi(crv3Pool).calc_withdraw_one_coin(_amount, 1);\n    }\n\n    function quote(address token_in, address token_out, uint256 amount_in) internal view returns (uint256) {\n        bool is_weth = token_in == weth || token_out == weth;\n        address[] memory path = new address[](is_weth ? 2 : 3);\n        path[0] = token_in;\n        if (is_weth) {\n            path[1] = token_out;\n        } else {\n            path[1] = weth;\n            path[2] = token_out;\n        }\n        uint256[] memory amounts = Swap(sushiswap).getAmountsOut(amount_in, path);\n        return amounts[amounts.length - 1];\n    }\n\n    function getClaimable3Crv() public view returns (uint256) {\n        IyveCRV YveCrv = IyveCRV(address(want));\n        uint256 claimable = YveCrv.claimable(address(this));\n        // REVIEW: Can YveCrv.supplyIndex(address(this))) be larger than YveCrv.index()\n        // Shouldn't we use safeMath?\n        uint256 claimableToAdd = (YveCrv.index().sub(YveCrv.supplyIndex(address(this))))\n            .mul(YveCrv.balanceOf(address(this)))\n            .div(1e18);\n        return claimable.mul(1e18).add(claimableToAdd);\n    }\n\n    function swap(address token_in, address token_out, uint amount_in) internal {\n        bool is_weth = token_in == weth || token_out == weth;\n        address[] memory path = new address[](is_weth ? 2 : 3);\n        path[0] = token_in;\n        if (is_weth) {\n            path[1] = token_out;\n        } else {\n            path[1] = weth;\n            path[2] = token_out;\n        }\n        Swap(sushiswap).swapExactTokensForTokens(\n            amount_in,\n            0,\n            path,\n            address(this),\n            now\n        );\n    }\n\n    function deposityveCRV() internal {\n        IyveCRV(address(want)).depositAll();\n    }\n\n    function setBuffer(uint256 _newBuffer) external {\n        require(msg.sender == governance(), \"!Governance\");\n        require(_newBuffer < DENOMINATOR, \"!TooHigh\");\n        vaultBuffer = _newBuffer;\n    }\n\n    // internal helpers\n    function protectedTokens()\n        internal\n        view\n        override\n        returns (address[] memory)\n    {\n        address[] memory protected = new address[](3);\n        protected[0] = address(want);\n        protected[1] = crv3;\n        protected[2] = usdc;\n        return protected;\n    }\n}"
    }
  ]
}