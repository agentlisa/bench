{
  "Title": "[H-01] Possible reentrancy during redemption/swap",
  "Content": "\nRedeemers might charge more collaterals during redemption/swap by the reentrancy attack.\n\n### Proof of Concept\n\nRedeemers can redeem the agToken for collaterals in `Redeemer` contract and `_redeem()` burns the agToken and transfers the collaterals.\n\n```solidity\n    function _redeem(\n        uint256 amount,\n        address to,\n        uint256 deadline,\n        uint256[] memory minAmountOuts,\n        address[] memory forfeitTokens\n    ) internal returns (address[] memory tokens, uint256[] memory amounts) {\n        TransmuterStorage storage ts = s.transmuterStorage();\n        if (ts.isRedemptionLive == 0) revert Paused();\n        if (block.timestamp > deadline) revert TooLate();\n        uint256[] memory subCollateralsTracker;\n        (tokens, amounts, subCollateralsTracker) = _quoteRedemptionCurve(amount);\n        // Updating the normalizer enables to simultaneously and proportionally reduce the amount\n        // of stablecoins issued from each collateral without having to loop through each of them\n        _updateNormalizer(amount, false);\n\n        IAgToken(ts.agToken).burnSelf(amount, msg.sender); //@audit-info burn agToken\n\n        address[] memory collateralListMem = ts.collateralList;\n        uint256 indexCollateral;\n        for (uint256 i; i < amounts.length; ++i) {\n            if (amounts[i] < minAmountOuts[i]) revert TooSmallAmountOut();\n            // If a token is in the `forfeitTokens` list, then it is not sent as part of the redemption process\n            if (amounts[i] > 0 && LibHelpers.checkList(tokens[i], forfeitTokens) < 0) {\n                Collateral storage collatInfo = ts.collaterals[collateralListMem[indexCollateral]];\n                if (collatInfo.onlyWhitelisted > 0 && !LibWhitelist.checkWhitelist(collatInfo.whitelistData, to))\n                    revert NotWhitelisted();\n                if (collatInfo.isManaged > 0)\n                    LibManager.release(tokens[i], to, amounts[i], collatInfo.managerData.config);\n                else IERC20(tokens[i]).safeTransfer(to, amounts[i]); //@audit reentrancy\n            }\n            if (subCollateralsTracker[indexCollateral] - 1 <= i) ++indexCollateral;\n        }\n        emit Redeemed(amount, tokens, amounts, forfeitTokens, msg.sender, to);\n    }\n```\n\nDuring the collateral transfers(direct transfer or in `LibManager.release()`), there might be a hook for the recipient in the case of ERC777 tokens.\n\nThen the recipient might charge more collaterals by reentrancy like this.\n\n1.  Let's suppose there are 2 collaterals `colA` and `colB`. The transmuter contract contains 1000 amounts of `colA` and `colB`. Alice has 20 amounts of agToken.\n2.  At the first time, Alice calls `redeem()` with 10 amounts of agToken and she should receive 10 amounts of `colA` and `colB`.\n3.  As `colA` is an ERC777 token, she calls `redeem(10)` again inside the hook after the [colA transfer](https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/transmuter/facets/Redeemer.sol#L131).\n4.  During the second redemption, total collaterals will be `colA = 990, colB = 1000` because `colB` isn't transferred in the first redemption yet.\n5.  After all, Alice will receive more collaterals in the second redemption from [this calculation](https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/transmuter/facets/Redeemer.sol#L167).\n\nI think a similar reentrancy attack might be possible during the swap as well.\n\n### Recommended Mitigation Steps\n\nI think we should add the `nonReentrant` modifier to the major functions like `redeem()/swap()`.\n\n**[Picodes (Angle) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-06-angle-findings/issues/24#issuecomment-1628650145):**\n > Valid. We had this in mind but thought it was ok as we don't plan to accept collaterals with callbacks. However better than sorry and we may add the modifier.\n\n**[hansfriese (Judge) commented](https://github.com/code-423n4/2023-06-angle-findings/issues/24#issuecomment-1628722575):**\n > @Picodes - `LibManager.release()` is called during the redemption and it might have a callback although the governance doesn't accept collaterals with hooks.\n> \n> Because the assumption is practical enough and the users can steal collaterals directly, will keep as High.\n\n**[Angle mitigated](https://github.com/code-423n4/2023-07-angle-mitigation/blob/main/README.md#mitigations-to-be-reviewed):**\n> PR: https://github.com/AngleProtocol/angle-transmuter/commit/864c1c47cb550f8e337244f0f70409a171a4e671<br>\n> Adds a reentrancy guard to several functions.\n\n**Status:** Mitigation confirmed. Full details in reports from [auditor0517](https://github.com/code-423n4/2023-07-angle-mitigation-findings/issues/22), [Lambda](https://github.com/code-423n4/2023-07-angle-mitigation-findings/issues/6), and [Jeiwan](https://github.com/code-423n4/2023-07-angle-mitigation-findings/issues/13).\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2022-01-dev-test-repo",
  "Code": [
    {
      "filename": "contracts/transmuter/facets/Redeemer.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.19;\n\nimport { IERC20 } from \"oz/token/ERC20/IERC20.sol\";\nimport { SafeCast } from \"oz/utils/math/SafeCast.sol\";\nimport { SafeERC20 } from \"oz/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"oz/utils/math/Math.sol\";\n\nimport { IAgToken } from \"interfaces/IAgToken.sol\";\nimport { IRedeemer } from \"interfaces/IRedeemer.sol\";\n\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\nimport { LibHelpers } from \"../libraries/LibHelpers.sol\";\nimport { LibGetters } from \"../libraries/LibGetters.sol\";\nimport { LibManager } from \"../libraries/LibManager.sol\";\nimport { LibStorage as s } from \"../libraries/LibStorage.sol\";\nimport { LibWhitelist } from \"../libraries/LibWhitelist.sol\";\n\nimport \"../../utils/Constants.sol\";\nimport \"../../utils/Errors.sol\";\nimport \"../Storage.sol\";\n\n/// @title Redeemer\n/// @author Angle Labs, Inc.\ncontract Redeemer is IRedeemer {\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n    using SafeCast for uint256;\n\n    event Redeemed(\n        uint256 amount,\n        address[] tokens,\n        uint256[] amounts,\n        address[] forfeitTokens,\n        address indexed from,\n        address indexed to\n    );\n    event NormalizerUpdated(uint256 newNormalizerValue);\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                   EXTERNAL ACTIONS                                                 \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRedeemer\n    /// @dev The `minAmountOuts` list must reflect or be longer than the amount of `tokens` returned\n    /// @dev In normal conditions, the amount of tokens outputted by this function should be the amount\n    /// of collateral assets supported by the system, following their order in the `collateralList`.\n    /// @dev If one collateral has its liquidity managed through strategies, then it's possible that this asset\n    /// has sub-collaterals with it. In this situation, these sub-collaterals may be sent during the redemption\n    /// process and the `minAmountOuts` will be bigger than the `collateralList` length. If there are 3 collateral\n    /// assets and the 2nd collateral asset in the list (at index 1) consists of 3 sub-collaterals, then the ordering\n    /// of the token list will be as follows:\n    /// `[collat 1, sub-collat 1 of collat 2, sub-collat 2 of collat 2, sub-collat 3 of collat 2, collat 3]`\n    /// @dev The list of tokens outputted (and hence the minimum length of the `minAmountOuts` list) can be obtained\n    /// by calling the `quoteRedemptionCurve` function\n    /// @dev Tokens requiring a whitelist must be forfeited if the redemption is to an address that is not in the\n    /// whitelist, otherwise this function reverts\n    /// @dev No approval is needed before calling this function\n    function redeem(\n        uint256 amount,\n        address receiver,\n        uint256 deadline,\n        uint256[] memory minAmountOuts\n    ) external returns (address[] memory tokens, uint256[] memory amounts) {\n        return _redeem(amount, receiver, deadline, minAmountOuts, new address[](0));\n    }\n\n    /// @inheritdoc IRedeemer\n    /// @dev Beware that if a token is given in the `forfeitTokens` list, the redemption will not try to send token\n    /// even if it has enough immediately available to send the amount\n    function redeemWithForfeit(\n        uint256 amount,\n        address receiver,\n        uint256 deadline,\n        uint256[] memory minAmountOuts,\n        address[] memory forfeitTokens\n    ) external returns (address[] memory tokens, uint256[] memory amounts) {\n        return _redeem(amount, receiver, deadline, minAmountOuts, forfeitTokens);\n    }\n\n    /// @inheritdoc IRedeemer\n    /// @dev This function may be called by trusted addresses: these could be for instance savings contract\n    /// minting stablecoins when they notice a profit\n    function updateNormalizer(uint256 amount, bool increase) external returns (uint256) {\n        if (!LibDiamond.isGovernor(msg.sender) && s.transmuterStorage().isTrusted[msg.sender] == 0) revert NotTrusted();\n        return _updateNormalizer(amount, increase);\n    }\n\n    /// @inheritdoc IRedeemer\n    function quoteRedemptionCurve(\n        uint256 amount\n    ) external view returns (address[] memory tokens, uint256[] memory amounts) {\n        (tokens, amounts, ) = _quoteRedemptionCurve(amount);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                   INTERNAL HELPERS                                                 \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Internal function of the `redeem` function in the `Redeemer` contract\n    function _redeem(\n        uint256 amount,\n        address to,\n        uint256 deadline,\n        uint256[] memory minAmountOuts,\n        address[] memory forfeitTokens\n    ) internal returns (address[] memory tokens, uint256[] memory amounts) {\n        TransmuterStorage storage ts = s.transmuterStorage();\n        if (ts.isRedemptionLive == 0) revert Paused();\n        if (block.timestamp > deadline) revert TooLate();\n        uint256[] memory subCollateralsTracker;\n        (tokens, amounts, subCollateralsTracker) = _quoteRedemptionCurve(amount);\n        // Updating the normalizer enables to simultaneously and proportionally reduce the amount\n        // of stablecoins issued from each collateral without having to loop through each of them\n        _updateNormalizer(amount, false);\n\n        IAgToken(ts.agToken).burnSelf(amount, msg.sender);\n\n        address[] memory collateralListMem = ts.collateralList;\n        uint256 indexCollateral;\n        for (uint256 i; i < amounts.length; ++i) {\n            if (amounts[i] < minAmountOuts[i]) revert TooSmallAmountOut();\n            // If a token is in the `forfeitTokens` list, then it is not sent as part of the redemption process\n            if (amounts[i] > 0 && LibHelpers.checkList(tokens[i], forfeitTokens) < 0) {\n                Collateral storage collatInfo = ts.collaterals[collateralListMem[indexCollateral]];\n                if (collatInfo.onlyWhitelisted > 0 && !LibWhitelist.checkWhitelist(collatInfo.whitelistData, to))\n                    revert NotWhitelisted();\n                if (collatInfo.isManaged > 0)\n                    LibManager.release(tokens[i], to, amounts[i], collatInfo.managerData.config);\n                else IERC20(tokens[i]).safeTransfer(to, amounts[i]);\n            }\n            if (subCollateralsTracker[indexCollateral] - 1 <= i) ++indexCollateral;\n        }\n        emit Redeemed(amount, tokens, amounts, forfeitTokens, msg.sender, to);\n    }\n\n    /// @dev This function reverts if `stablecoinsIssued==0`, which is expected behavior as there is nothing to redeem\n    /// anyway in this case, or if the `amountBurnt` is greater than `stablecoinsIssued`\n    function _quoteRedemptionCurve(\n        uint256 amountBurnt\n    )\n        internal\n        view\n        returns (address[] memory tokens, uint256[] memory balances, uint256[] memory subCollateralsTracker)\n    {\n        TransmuterStorage storage ts = s.transmuterStorage();\n        uint64 collatRatio;\n        uint256 stablecoinsIssued;\n        (collatRatio, stablecoinsIssued, tokens, balances, subCollateralsTracker) = LibGetters.getCollateralRatio();\n        if (amountBurnt > stablecoinsIssued) revert TooBigAmountIn();\n        int64[] memory yRedemptionCurveMem = ts.yRedemptionCurve;\n        uint64 penaltyFactor;\n        // If the protocol is under-collateralized, a penalty factor is applied to the returned amount of each asset\n        if (collatRatio < BASE_9) {\n            uint64[] memory xRedemptionCurveMem = ts.xRedemptionCurve;\n            penaltyFactor = uint64(LibHelpers.piecewiseLinear(collatRatio, xRedemptionCurveMem, yRedemptionCurveMem));\n        }\n\n        uint256 balancesLength = balances.length;\n        for (uint256 i; i < balancesLength; ++i) {\n            // The amount given for each token in reserves does not depend on the price of the tokens in reserve:\n            // it is a proportion of the balance for each token computed as the ratio between the stablecoins\n            // burnt relative to the amount of stablecoins issued.\n            // If the protocol is over-collateralized, the amount of each token given is inversely proportional\n            // to the collateral ratio.\n            balances[i] = collatRatio >= BASE_9\n                ? (amountBurnt * balances[i] * (uint64(yRedemptionCurveMem[yRedemptionCurveMem.length - 1]))) /\n                    (stablecoinsIssued * collatRatio)\n                : (amountBurnt * balances[i] * penaltyFactor) / (stablecoinsIssued * BASE_9);\n        }\n    }\n\n    /// @notice Updates the `normalizer` variable used to track stablecoins issued from each asset and globally\n    function _updateNormalizer(uint256 amount, bool increase) internal returns (uint256 newNormalizerValue) {\n        TransmuterStorage storage ts = s.transmuterStorage();\n        uint256 _normalizer = ts.normalizer;\n        uint256 _normalizedStables = ts.normalizedStables;\n        // In case of an increase, the update formula used is the simplified version of the formula below:\n        /*\n            _normalizer * (BASE_27 + BASE_27 * amount / stablecoinsIssued) / BASE_27\n             = _normalizer + (_normalizer * BASE_27 * amount * (BASE_27 / (_normalizedStables * normalizer))) / BASE_27\n             = _normalizer + BASE_27 * amount / _normalizedStables\n        */\n        if (increase) {\n            newNormalizerValue = _normalizer + (amount * BASE_27) / _normalizedStables;\n        } else {\n            newNormalizerValue = _normalizer - (amount * BASE_27) / _normalizedStables;\n        }\n        // If the `normalizer` gets too small or too big, it must be renormalized to later avoid the propagation of\n        // rounding errors, as well as overflows. In this case, the function has to iterate through all the\n        // supported collateral assets\n        if (newNormalizerValue <= BASE_18 || newNormalizerValue >= BASE_36) {\n            address[] memory collateralListMem = ts.collateralList;\n            uint256 collateralListLength = collateralListMem.length;\n            // For each asset, we store the actual amount of stablecoins issued based on the `newNormalizerValue`\n            // (and not a normalized value)\n            // We ensure to preserve the invariant `sum(collateralNewNormalizedStables) = normalizedStables`\n            uint128 newNormalizedStables = 0;\n            for (uint256 i; i < collateralListLength; ++i) {\n                uint128 newCollateralNormalizedStable = ((uint256(\n                    ts.collaterals[collateralListMem[i]].normalizedStables\n                ) * newNormalizerValue) / BASE_27).toUint128();\n                newNormalizedStables += newCollateralNormalizedStable;\n                ts.collaterals[collateralListMem[i]].normalizedStables = uint216(newCollateralNormalizedStable);\n            }\n            ts.normalizedStables = newNormalizedStables;\n            newNormalizerValue = BASE_27;\n        }\n        ts.normalizer = newNormalizerValue.toUint128();\n        emit NormalizerUpdated(newNormalizerValue);\n    }\n}"
    },
    {
      "filename": "contracts/transmuter/facets/Redeemer.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.19;\n\nimport { IERC20 } from \"oz/token/ERC20/IERC20.sol\";\nimport { SafeCast } from \"oz/utils/math/SafeCast.sol\";\nimport { SafeERC20 } from \"oz/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"oz/utils/math/Math.sol\";\n\nimport { IAgToken } from \"interfaces/IAgToken.sol\";\nimport { IRedeemer } from \"interfaces/IRedeemer.sol\";\n\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\nimport { LibHelpers } from \"../libraries/LibHelpers.sol\";\nimport { LibGetters } from \"../libraries/LibGetters.sol\";\nimport { LibManager } from \"../libraries/LibManager.sol\";\nimport { LibStorage as s } from \"../libraries/LibStorage.sol\";\nimport { LibWhitelist } from \"../libraries/LibWhitelist.sol\";\n\nimport \"../../utils/Constants.sol\";\nimport \"../../utils/Errors.sol\";\nimport \"../Storage.sol\";\n\n/// @title Redeemer\n/// @author Angle Labs, Inc.\ncontract Redeemer is IRedeemer {\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n    using SafeCast for uint256;\n\n    event Redeemed(\n        uint256 amount,\n        address[] tokens,\n        uint256[] amounts,\n        address[] forfeitTokens,\n        address indexed from,\n        address indexed to\n    );\n    event NormalizerUpdated(uint256 newNormalizerValue);\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                   EXTERNAL ACTIONS                                                 \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRedeemer\n    /// @dev The `minAmountOuts` list must reflect or be longer than the amount of `tokens` returned\n    /// @dev In normal conditions, the amount of tokens outputted by this function should be the amount\n    /// of collateral assets supported by the system, following their order in the `collateralList`.\n    /// @dev If one collateral has its liquidity managed through strategies, then it's possible that this asset\n    /// has sub-collaterals with it. In this situation, these sub-collaterals may be sent during the redemption\n    /// process and the `minAmountOuts` will be bigger than the `collateralList` length. If there are 3 collateral\n    /// assets and the 2nd collateral asset in the list (at index 1) consists of 3 sub-collaterals, then the ordering\n    /// of the token list will be as follows:\n    /// `[collat 1, sub-collat 1 of collat 2, sub-collat 2 of collat 2, sub-collat 3 of collat 2, collat 3]`\n    /// @dev The list of tokens outputted (and hence the minimum length of the `minAmountOuts` list) can be obtained\n    /// by calling the `quoteRedemptionCurve` function\n    /// @dev Tokens requiring a whitelist must be forfeited if the redemption is to an address that is not in the\n    /// whitelist, otherwise this function reverts\n    /// @dev No approval is needed before calling this function\n    function redeem(\n        uint256 amount,\n        address receiver,\n        uint256 deadline,\n        uint256[] memory minAmountOuts\n    ) external returns (address[] memory tokens, uint256[] memory amounts) {\n        return _redeem(amount, receiver, deadline, minAmountOuts, new address[](0));\n    }\n\n    /// @inheritdoc IRedeemer\n    /// @dev Beware that if a token is given in the `forfeitTokens` list, the redemption will not try to send token\n    /// even if it has enough immediately available to send the amount\n    function redeemWithForfeit(\n        uint256 amount,\n        address receiver,\n        uint256 deadline,\n        uint256[] memory minAmountOuts,\n        address[] memory forfeitTokens\n    ) external returns (address[] memory tokens, uint256[] memory amounts) {\n        return _redeem(amount, receiver, deadline, minAmountOuts, forfeitTokens);\n    }\n\n    /// @inheritdoc IRedeemer\n    /// @dev This function may be called by trusted addresses: these could be for instance savings contract\n    /// minting stablecoins when they notice a profit\n    function updateNormalizer(uint256 amount, bool increase) external returns (uint256) {\n        if (!LibDiamond.isGovernor(msg.sender) && s.transmuterStorage().isTrusted[msg.sender] == 0) revert NotTrusted();\n        return _updateNormalizer(amount, increase);\n    }\n\n    /// @inheritdoc IRedeemer\n    function quoteRedemptionCurve(\n        uint256 amount\n    ) external view returns (address[] memory tokens, uint256[] memory amounts) {\n        (tokens, amounts, ) = _quoteRedemptionCurve(amount);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                   INTERNAL HELPERS                                                 \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Internal function of the `redeem` function in the `Redeemer` contract\n    function _redeem(\n        uint256 amount,\n        address to,\n        uint256 deadline,\n        uint256[] memory minAmountOuts,\n        address[] memory forfeitTokens\n    ) internal returns (address[] memory tokens, uint256[] memory amounts) {\n        TransmuterStorage storage ts = s.transmuterStorage();\n        if (ts.isRedemptionLive == 0) revert Paused();\n        if (block.timestamp > deadline) revert TooLate();\n        uint256[] memory subCollateralsTracker;\n        (tokens, amounts, subCollateralsTracker) = _quoteRedemptionCurve(amount);\n        // Updating the normalizer enables to simultaneously and proportionally reduce the amount\n        // of stablecoins issued from each collateral without having to loop through each of them\n        _updateNormalizer(amount, false);\n\n        IAgToken(ts.agToken).burnSelf(amount, msg.sender);\n\n        address[] memory collateralListMem = ts.collateralList;\n        uint256 indexCollateral;\n        for (uint256 i; i < amounts.length; ++i) {\n            if (amounts[i] < minAmountOuts[i]) revert TooSmallAmountOut();\n            // If a token is in the `forfeitTokens` list, then it is not sent as part of the redemption process\n            if (amounts[i] > 0 && LibHelpers.checkList(tokens[i], forfeitTokens) < 0) {\n                Collateral storage collatInfo = ts.collaterals[collateralListMem[indexCollateral]];\n                if (collatInfo.onlyWhitelisted > 0 && !LibWhitelist.checkWhitelist(collatInfo.whitelistData, to))\n                    revert NotWhitelisted();\n                if (collatInfo.isManaged > 0)\n                    LibManager.release(tokens[i], to, amounts[i], collatInfo.managerData.config);\n                else IERC20(tokens[i]).safeTransfer(to, amounts[i]);\n            }\n            if (subCollateralsTracker[indexCollateral] - 1 <= i) ++indexCollateral;\n        }\n        emit Redeemed(amount, tokens, amounts, forfeitTokens, msg.sender, to);\n    }\n\n    /// @dev This function reverts if `stablecoinsIssued==0`, which is expected behavior as there is nothing to redeem\n    /// anyway in this case, or if the `amountBurnt` is greater than `stablecoinsIssued`\n    function _quoteRedemptionCurve(\n        uint256 amountBurnt\n    )\n        internal\n        view\n        returns (address[] memory tokens, uint256[] memory balances, uint256[] memory subCollateralsTracker)\n    {\n        TransmuterStorage storage ts = s.transmuterStorage();\n        uint64 collatRatio;\n        uint256 stablecoinsIssued;\n        (collatRatio, stablecoinsIssued, tokens, balances, subCollateralsTracker) = LibGetters.getCollateralRatio();\n        if (amountBurnt > stablecoinsIssued) revert TooBigAmountIn();\n        int64[] memory yRedemptionCurveMem = ts.yRedemptionCurve;\n        uint64 penaltyFactor;\n        // If the protocol is under-collateralized, a penalty factor is applied to the returned amount of each asset\n        if (collatRatio < BASE_9) {\n            uint64[] memory xRedemptionCurveMem = ts.xRedemptionCurve;\n            penaltyFactor = uint64(LibHelpers.piecewiseLinear(collatRatio, xRedemptionCurveMem, yRedemptionCurveMem));\n        }\n\n        uint256 balancesLength = balances.length;\n        for (uint256 i; i < balancesLength; ++i) {\n            // The amount given for each token in reserves does not depend on the price of the tokens in reserve:\n            // it is a proportion of the balance for each token computed as the ratio between the stablecoins\n            // burnt relative to the amount of stablecoins issued.\n            // If the protocol is over-collateralized, the amount of each token given is inversely proportional\n            // to the collateral ratio.\n            balances[i] = collatRatio >= BASE_9\n                ? (amountBurnt * balances[i] * (uint64(yRedemptionCurveMem[yRedemptionCurveMem.length - 1]))) /\n                    (stablecoinsIssued * collatRatio)\n                : (amountBurnt * balances[i] * penaltyFactor) / (stablecoinsIssued * BASE_9);\n        }\n    }\n\n    /// @notice Updates the `normalizer` variable used to track stablecoins issued from each asset and globally\n    function _updateNormalizer(uint256 amount, bool increase) internal returns (uint256 newNormalizerValue) {\n        TransmuterStorage storage ts = s.transmuterStorage();\n        uint256 _normalizer = ts.normalizer;\n        uint256 _normalizedStables = ts.normalizedStables;\n        // In case of an increase, the update formula used is the simplified version of the formula below:\n        /*\n            _normalizer * (BASE_27 + BASE_27 * amount / stablecoinsIssued) / BASE_27\n             = _normalizer + (_normalizer * BASE_27 * amount * (BASE_27 / (_normalizedStables * normalizer))) / BASE_27\n             = _normalizer + BASE_27 * amount / _normalizedStables\n        */\n        if (increase) {\n            newNormalizerValue = _normalizer + (amount * BASE_27) / _normalizedStables;\n        } else {\n            newNormalizerValue = _normalizer - (amount * BASE_27) / _normalizedStables;\n        }\n        // If the `normalizer` gets too small or too big, it must be renormalized to later avoid the propagation of\n        // rounding errors, as well as overflows. In this case, the function has to iterate through all the\n        // supported collateral assets\n        if (newNormalizerValue <= BASE_18 || newNormalizerValue >= BASE_36) {\n            address[] memory collateralListMem = ts.collateralList;\n            uint256 collateralListLength = collateralListMem.length;\n            // For each asset, we store the actual amount of stablecoins issued based on the `newNormalizerValue`\n            // (and not a normalized value)\n            // We ensure to preserve the invariant `sum(collateralNewNormalizedStables) = normalizedStables`\n            uint128 newNormalizedStables = 0;\n            for (uint256 i; i < collateralListLength; ++i) {\n                uint128 newCollateralNormalizedStable = ((uint256(\n                    ts.collaterals[collateralListMem[i]].normalizedStables\n                ) * newNormalizerValue) / BASE_27).toUint128();\n                newNormalizedStables += newCollateralNormalizedStable;\n                ts.collaterals[collateralListMem[i]].normalizedStables = uint216(newCollateralNormalizedStable);\n            }\n            ts.normalizedStables = newNormalizedStables;\n            newNormalizerValue = BASE_27;\n        }\n        ts.normalizer = newNormalizerValue.toUint128();\n        emit NormalizerUpdated(newNormalizerValue);\n    }\n}"
    },
    {
      "filename": "README.md",
      "content": "# Angle Protocol - Mitigation Review details\n\n- Total Prize Pool: $14,000 USDC\n- [Warden guidelines for C4 mitigation reviews](https://code4rena.notion.site/Guidelines-for-C4-mitigation-reviews-ed10fc5cfbf640bd8dcec66f38b343c4)\n- Submit findings [using the C4 form](https://code4rena.com/contests/2023-07-angle-protocol-mitigation-review/submit)\n- Starts July 17, 2023 20:00 UTC\n- Ends July 21, 2023 20:00 UTC \n\n## Important note\n\nEach warden must submit a mitigation review for:\n\n- Every High and Medium finding listed as in-scope below, and\n- one report each for the Gas and QA fixes.\n\nFor the Gas and QA mitigation reports:\n- Submit any new High or Medium issues introduced by the QA and GAS fixes as a newly-introduced High and Medium risk issue.\n\n**Incomplete mitigation reviews will not be eligible for awards.**\n\n## Findings being mitigated\n\nMitigations of all High and Medium issues will be considered in-scope and listed here.\n\n- [H-01: Possible reentrancy during redemption/swap](https://github.com/code-423n4/2023-06-angle-findings/issues/24)\n- [H-02: The first disputer might lose funds although his dispute is valid.](https://github.com/code-423n4/2023-06-angle-findings/issues/23)\n- [H-03: Poor detection of disputed trees allows claiming tokens from a disputed tre](https://github.com/code-423n4/2023-06-angle-findings/issues/10)\n- [M-01: LibHelpers.piecewiseLinear will revert when the value is less than the first element of the array](https://github.com/code-423n4/2023-06-angle-findings/issues/40)\n- [M-02: Unsafe cast in getCollateralRatio()](https://github.com/code-423n4/2023-06-angle-findings/issues/31)\n- [M-03: Read-only reentrancy is possible](https://github.com/code-423n4/2023-06-angle-findings/issues/30)\n- [M-04: estimatedAPR() might return the wrong APR.](https://github.com/code-423n4/2023-06-angle-findings/issues/28)\n- [M-06: Interest is not accrued before parameters are updated in SavingsVest](https://github.com/code-423n4/2023-06-angle-findings/issues/13)\n- [M-07: User may get less tokens than expected when collateral list order changes](https://github.com/code-423n4/2023-06-angle-findings/issues/8)\n\n## Overview of changes\n\nChanges related to High and Medium issues on Merkl can be found [here](https://github.com/AngleProtocol/merkl-contracts/compare/code-423n4-2023-06-angle...code-423n4-2023-06-angle-mitigation).\nChanges that we intend to make on Merkl prior to final deployment, so including QA and GAS can be found [here](https://github.com/AngleProtocol/merkl-contracts/compare/code-423n4-2023-06-angle...code-423n4-2023-06-angle-full-mitigation). Updated tests and scripts are on the `main` branch.\n\nChanges related to High and Medium issues on Transmuter can be found [here](https://github.com/AngleProtocol/angle-transmuter/compare/code-423n4-2023-06-angle...code-423n4-2023-06-angle-mitigation).\nChanges that we intend to make on Transmuter prior to final deployment, so including QA and GAS can be found can be found [here](https://github.com/AngleProtocol/angle-transmuter/compare/code-423n4-2023-06-angle...code-423n4-2023-06-angle-full-mitigation). Updated tests and scripts are on the `main` branch.\n\n## Mitigations to be reviewed\n\n### Individual PRs\n\n| URL                                                                                               | Mitigation of | Purpose                                             |\n| ------------------------------------------------------------------------------------------------- | ------------- | --------------------------------------------------- |\n| https://github.com/AngleProtocol/angle-transmuter/commit/864c1c47cb550f8e337244f0f70409a171a4e671 | H-01          | Adds a reentrancy guard to several functions        |\n| https://github.com/AngleProtocol/merkl-contracts/commit/7402ee6b84789391479c5876b27be23fd579f7b2  | H-02          | Applies the suggested fix                           |\n| https://github.com/AngleProtocol/merkl-contracts/commit/82d8c0ff37b4a9ad8277cac4aef85f3ca0ad5c7c  | H-03          | Applies the suggested fix                           |\n| https://github.com/AngleProtocol/angle-transmuter/commit/5f7635cdab52b75416309d45f8cd253609c705ff | M-01          | Add an handler for this edge case                   |\n| https://github.com/AngleProtocol/angle-transmuter/commit/6f2ffcb1e89e3bba05c9aa2133ef94347aa42c28 | M-02          | Adds safeCast                                       |\n| https://github.com/AngleProtocol/angle-transmuter/commit/864c1c47cb550f8e337244f0f70409a171a4e671 | M-03          | Adds a reentrancy guard to several functions        |\n| https://github.com/AngleProtocol/angle-transmuter/commit/337c65d005bbd8ed6dfa76929d2cae475066756a | M-04          | Applies the suggested fix                           |\n| https://github.com/AngleProtocol/angle-transmuter/commit/94c4e51ae3400a63532e85f04f4081152adc97db | M-06          | Calls `accrues` before updating sensible parameters |\n| https://github.com/AngleProtocol/angle-transmuter/commit/f8d0bf7c4009586f7022d5929359041db3990175 | M-07          | Applies the suggested fix                           |\n| https://github.com/AngleProtocol/merkl-contracts/commit/3c2fe3a956cdd29b632e8d7a20e1fc2ce5e8ac37  | QA & GAS      |                                                     |\n| https://github.com/AngleProtocol/angle-transmuter/commit/66bba3f5dba4ab6307c997e350dfadb13d2a2119 | QA & GAS      |                                                     |\n\n## Out of Scope\n\n- [M-05: uint128 changeAmount might overflow](https://github.com/code-423n4/2023-06-angle-findings/issues/16): we consider that there is no risk here as swaps will be reverting, and that the chances that this happen are infinitesimals"
    }
  ]
}