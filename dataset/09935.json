{
  "Title": "[M-02] `NestedFactory` does not track operators properly",
  "Content": "_Submitted by IllIllI, also found by 0x1f8b, hyh, and pauliax_\n\n[NestedFactory.sol#L99-L108](https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L99-L108)<br>\n[MixinOperatorResolver.sol#L30-L47](https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/abstracts/MixinOperatorResolver.sol#L30-L47)<br>\n[NestedFactory.sol#L110-L122](https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L110-L122)<br>\n[MixinOperatorResolver.sol#L49-L55](https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/abstracts/MixinOperatorResolver.sol#L49-L55)\n\n`NestedFactory` extends the `MixinOperatorResolver` contract which comes from the [`synthetix/MixinResolver.sol`](https://github.com/Synthetixio/synthetix/blob/a1786e5d64b5b51212785ade6d8b42435f69c387/contracts/MixinResolver.sol) code base where the expectation is that `isResolverCached()` returns false until [`rebuildCache()` is called and the cache is fully up to date](https://github.com/Synthetixio/synthetix/blob/a1786e5d64b5b51212785ade6d8b42435f69c387/test/contracts/MixinResolver.js#L82-L105). Due to [a medium issue](https://github.com/code-423n4/2021-11-nested-findings/issues/217) identified in a prior contest, the `OperatorResolver.importOperators()` step was made to be atomically combined with the `NestedFactory.rebuildCache()` step. However, the atomicity was not applied everywhere and the ability to add/remove operators from the `NestedFactory` also had other cache-inconsistency issues. There are *four separate instances* of operator tracking problems in this submission.\n\n### Impact\n\nAs with the prior issue, many core operations (such as `NestedFactory.create()` and `NestedFactory.swapTokenForTokens()`) are dependant on the assumption that the `operatorCache` cache is synced prior to these functions being executed, but this may not necessarily be the case. Unlike the prior issue which was about updates to the resolver not getting reflected in the cache, this issue is about changes to the factory not updating the cache.\n\n### Proof of Concept\n\n#### 1. `removeOperator()` does not call `rebuildCache()`\n\n1.  `NestedFactory.removeOperator()` is called to remove an operator\n2.  A user calls `NestedFactory(MixinOperatorResolver).create()` using that operator and succeedes\n3.  `NestedFactory.rebuildCache()` is called to rebuild cache\n\nThis flow is not aware that the cache is not in sync\n\n```solidity\n/// @inheritdoc INestedFactory\nfunction addOperator(bytes32 operator) external override onlyOwner {\n  require(operator != bytes32(\"\"), \"NF: INVALID_OPERATOR_NAME\");\n  bytes32[] memory operatorsCache = operators;\n  for (uint256 i = 0; i < operatorsCache.length; i++) {\n      require(operatorsCache[i] != operator, \"NF: EXISTENT_OPERATOR\");\n  }\n  operators.push(operator);\n  emit OperatorAdded(operator);\n}\n```\n\n[NestedFactory.sol#L99-L108](https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L99-L108)\n\n#### 2. Using both `removeOperator()` and `rebuildCache()` does not prevent `create()` from using the operator\n\nEven if `removeOperator()` calls `rebuildCache()` the function will still not work because `resolverOperatorsRequired()` only keeps track of remaining operators, and `rebuildCache()` currently has no way of knowing that an entry was removed from that array and that a corresponding entry from `operatorCache` needs to be removed too.\n\n```solidity\n/// @notice Rebuild the operatorCache\nfunction rebuildCache() external {\n    bytes32[] memory requiredOperators = resolverOperatorsRequired();\n    bytes32 name;\n    IOperatorResolver.Operator memory destination;\n    // The resolver must call this function whenever it updates its state\n    for (uint256 i = 0; i < requiredOperators.length; i++) {\n        name = requiredOperators[i];\n        // Note: can only be invoked once the resolver has all the targets needed added\n        destination = resolver.getOperator(name);\n        if (destination.implementation != address(0)) {\n            operatorCache[name] = destination;\n        } else {\n            delete operatorCache[name];\n        }\n        emit CacheUpdated(name, destination);\n    }\n}\n```\n\n[MixinOperatorResolver.sol#L30-L47](https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/abstracts/MixinOperatorResolver.sol#L30-L47)\n\n#### 3. `addOperator()` does not call `rebuildCache()`\n\n1.  `NestedFactory.addOperator()` is called to add an operator\n2.  A user calls `NestedFactory(MixinOperatorResolver).create()` using that operator and fails because the operator wasn't in the `resolverOperatorsRequired()` during the last call to `rebuildCaches()`, so the operator isn't in `operatorCache`\n3.  `NestedFactory.rebuildCache()` is called to rebuild cache\n\nThis flow is not aware that the cache is not in sync\n\n```solidity\n/// @inheritdoc INestedFactory\nfunction removeOperator(bytes32 operator) external override onlyOwner {\n  uint256 operatorsLength = operators.length;\n  for (uint256 i = 0; i < operatorsLength; i++) {\n      if (operators[i] == operator) {\n          operators[i] = operators[operatorsLength - 1];\n          operators.pop();\n          emit OperatorRemoved(operator);\n          return;\n      }\n  }\n  revert(\"NF: NON_EXISTENT_OPERATOR\");\n}\n```\n\n[NestedFactory.sol#L110-L122](https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L110-L122)\n\n#### 4. `isResolverCached()` does not reflect the actual updated-or-not state\n\nThis function, like `removeOperator()` is not able to tell that there is an operator that needs to be removed from `resolverCache`, causing the owner not to know a call to `rebuildCache()` is required to 'remove' the operator\n\n```solidity\n/// @notice Check the state of operatorCache\nfunction isResolverCached() external view returns (bool) {\n  bytes32[] memory requiredOperators = resolverOperatorsRequired();\n  bytes32 name;\n  IOperatorResolver.Operator memory cacheTmp;\n  IOperatorResolver.Operator memory actualValue;\n  for (uint256 i = 0; i < requiredOperators.length; i++) {\n```\n\n[MixinOperatorResolver.sol#L49-L55](https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/abstracts/MixinOperatorResolver.sol#L49-L55)\n\n### Recommended Mitigation Steps\n\nAdd calls to `rebuildCache()` in `addOperator()` and `removeOperator()`, have `INestedFactory` also track operators that have been removed with a new array, and have `isResolverCached()` also check whether this new array is empty or not.\n\n**[maximebrugel (Nested Finance) confirmed and commented](https://github.com/code-423n4/2022-02-nested-findings/issues/38#issuecomment-1041944815):**\n > With this fix => [#18](https://github.com/code-423n4/2022-02-nested-findings/issues/18)<br>\n> No need to add an array of removed operators, because we are now removing the operators from the cache at the same time. Only need to call rebuildCache when adding and removing operators.\n> \n> PR: [Med/High Risk Fixes](https://github.com/NestedFi/nested-core-lego/pull/100)\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-nested-finance-contest",
  "Code": [
    {
      "filename": "contracts/NestedFactory.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.11;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./abstracts/OwnableProxyDelegation.sol\";\nimport \"./abstracts/MixinOperatorResolver.sol\";\nimport \"./libraries/ExchangeHelpers.sol\";\nimport \"./interfaces/external/IWETH.sol\";\nimport \"./interfaces/INestedFactory.sol\";\nimport \"./FeeSplitter.sol\";\nimport \"./NestedReserve.sol\";\nimport \"./NestedAsset.sol\";\nimport \"./NestedRecords.sol\";\n\n/// @title Creates, updates and destroys NestedAssets (portfolios).\n/// @notice Responsible for the business logic of the protocol and interaction with operators\ncontract NestedFactory is INestedFactory, ReentrancyGuard, OwnableProxyDelegation, MixinOperatorResolver {\n    using SafeERC20 for IERC20;\n\n    /* ----------------------------- VARIABLES ----------------------------- */\n\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Supported operators by the factory contract\n    bytes32[] private operators;\n\n    /// @dev Current feeSplitter contract/address\n    FeeSplitter public feeSplitter;\n\n    /// @dev Current reserve contract/address\n    NestedReserve public immutable reserve;\n\n    /// @dev Current nested asset (ERC721) contract/address\n    NestedAsset public immutable nestedAsset;\n\n    /// @dev Wrapped Ether contract/address\n    /// Note: Will be WMATIC, WAVAX, WBNB,... Depending on the chain.\n    IWETH public immutable weth;\n\n    /// @dev Current records contract/address\n    NestedRecords public immutable nestedRecords;\n\n    /* ---------------------------- CONSTRUCTOR ---------------------------- */\n\n    constructor(\n        NestedAsset _nestedAsset,\n        NestedRecords _nestedRecords,\n        NestedReserve _reserve,\n        FeeSplitter _feeSplitter,\n        IWETH _weth,\n        address _operatorResolver\n    ) MixinOperatorResolver(_operatorResolver) {\n        require(\n            address(_nestedAsset) != address(0) &&\n                address(_nestedRecords) != address(0) &&\n                address(_reserve) != address(0) &&\n                address(_feeSplitter) != address(0) &&\n                address(_weth) != address(0) &&\n                _operatorResolver != address(0),\n            \"NF: INVALID_ADDRESS\"\n        );\n        nestedAsset = _nestedAsset;\n        nestedRecords = _nestedRecords;\n        reserve = _reserve;\n        feeSplitter = _feeSplitter;\n        weth = _weth;\n    }\n\n    /// @dev Receive function\n    receive() external payable {}\n\n    /* ------------------------------ MODIFIERS ---------------------------- */\n\n    /// @dev Reverts the transaction if the caller is not the token owner\n    /// @param _nftId The NFT Id\n    modifier onlyTokenOwner(uint256 _nftId) {\n        require(nestedAsset.ownerOf(_nftId) == _msgSender(), \"NF: CALLER_NOT_OWNER\");\n        _;\n    }\n\n    /// @dev Reverts the transaction if the nft is locked (hold by design).\n    /// The block.timestamp must be greater than NFT record lock timestamp\n    /// @param _nftId The NFT Id\n    modifier isUnlocked(uint256 _nftId) {\n        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), \"NF: LOCKED_NFT\");\n        _;\n    }\n\n    /* ------------------------------- VIEWS ------------------------------- */\n\n    /// @notice Get the required operators\n    function resolverOperatorsRequired() public view override returns (bytes32[] memory) {\n        return operators;\n    }\n\n    /* -------------------------- OWNER FUNCTIONS -------------------------- */\n\n    /// @inheritdoc INestedFactory\n    function addOperator(bytes32 operator) external override onlyOwner {\n        require(operator != bytes32(\"\"), \"NF: INVALID_OPERATOR_NAME\");\n        bytes32[] memory operatorsCache = operators;\n        for (uint256 i = 0; i < operatorsCache.length; i++) {\n            require(operatorsCache[i] != operator, \"NF: EXISTENT_OPERATOR\");\n        }\n        operators.push(operator);\n        emit OperatorAdded(operator);\n    }\n\n    /// @inheritdoc INestedFactory\n    function removeOperator(bytes32 operator) external override onlyOwner {\n        uint256 operatorsLength = operators.length;\n        for (uint256 i = 0; i < operatorsLength; i++) {\n            if (operators[i] == operator) {\n                operators[i] = operators[operatorsLength - 1];\n                operators.pop();\n                emit OperatorRemoved(operator);\n                return;\n            }\n        }\n        revert(\"NF: NON_EXISTENT_OPERATOR\");\n    }\n\n    /// @inheritdoc INestedFactory\n    function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {\n        require(address(_feeSplitter) != address(0), \"NF: INVALID_FEE_SPLITTER_ADDRESS\");\n        feeSplitter = _feeSplitter;\n        emit FeeSplitterUpdated(address(_feeSplitter));\n    }\n\n    /// @inheritdoc INestedFactory\n    function unlockTokens(IERC20 _token) external override onlyOwner {\n        uint256 amount = _token.balanceOf(address(this));\n        _token.safeTransfer(owner(), amount);\n        emit TokensUnlocked(address(_token), amount);\n    }\n\n    /* -------------------------- USERS FUNCTIONS -------------------------- */\n\n    /// @inheritdoc INestedFactory\n    function create(uint256 _originalTokenId, BatchedInputOrders[] calldata _batchedOrders)\n        external\n        payable\n        override\n        nonReentrant\n    {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n\n        _checkMsgValue(_batchedOrders);\n        uint256 nftId = nestedAsset.mint(_msgSender(), _originalTokenId);\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 fees, IERC20 tokenSold) = _submitInOrders(nftId, _batchedOrders[i], false);\n            _transferFeeWithRoyalty(fees, tokenSold, nftId);\n        }\n\n        emit NftCreated(nftId, _originalTokenId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders)\n        external\n        payable\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        _checkMsgValue(_batchedOrders);\n        _processInputOrders(_nftId, _batchedOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        _processOutputOrders(_nftId, _batchedOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processInputAndOutputOrders(\n        uint256 _nftId,\n        BatchedInputOrders[] calldata _batchedInputOrders,\n        BatchedOutputOrders[] calldata _batchedOutputOrders\n    ) external payable override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        _checkMsgValue(_batchedInputOrders);\n        _processInputOrders(_nftId, _batchedInputOrders);\n        _processOutputOrders(_nftId, _batchedOutputOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function destroy(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        address[] memory tokens = nestedRecords.getAssetTokens(_nftId);\n        uint256 tokensLength = tokens.length;\n        require(_orders.length != 0, \"NF: INVALID_ORDERS\");\n        require(tokensLength == _orders.length, \"NF: INPUTS_LENGTH_MUST_MATCH\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        uint256 buyTokenInitialBalance = _buyToken.balanceOf(address(this));\n\n        for (uint256 i = 0; i < tokensLength; i++) {\n            uint256 amount = nestedRecords.getAssetHolding(_nftId, tokens[i]);\n            reserve.withdraw(IERC20(tokens[i]), amount);\n\n            _safeSubmitOrder(tokens[i], address(_buyToken), amount, _nftId, _orders[i]);\n            nestedRecords.freeHolding(_nftId, tokens[i]);\n        }\n\n        // Amount calculation to send fees and tokens\n        uint256 amountBought = _buyToken.balanceOf(address(this)) - buyTokenInitialBalance;\n        uint256 amountFees = amountBought / 100; // 1% Fee\n        amountBought -= amountFees;\n\n        _transferFeeWithRoyalty(amountFees, _buyToken, _nftId);\n        _safeTransferAndUnwrap(_buyToken, amountBought, _msgSender());\n\n        // Burn NFT\n        nestedRecords.removeNFT(_nftId);\n        nestedAsset.burn(_msgSender(), _nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function withdraw(uint256 _nftId, uint256 _tokenIndex)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        uint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);\n        require(assetTokensLength > _tokenIndex, \"NF: INVALID_TOKEN_INDEX\");\n        // Use destroy instead if NFT has a single holding\n        require(assetTokensLength > 1, \"NF: UNALLOWED_EMPTY_PORTFOLIO\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        address token = nestedRecords.getAssetTokens(_nftId)[_tokenIndex];\n\n        uint256 amount = nestedRecords.getAssetHolding(_nftId, token);\n        reserve.withdraw(IERC20(token), amount);\n        _safeTransferWithFees(IERC20(token), amount, _msgSender(), _nftId);\n\n        nestedRecords.deleteAsset(_nftId, _tokenIndex);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function updateLockTimestamp(uint256 _nftId, uint256 _timestamp) external override onlyTokenOwner(_nftId) {\n        nestedRecords.updateLockTimestamp(_nftId, _timestamp);\n    }\n\n    /* ------------------------- PRIVATE FUNCTIONS ------------------------- */\n\n    /// @dev Internal logic extraction of processInputOrders()\n    /// @param _nftId The id of the NFT to update\n    /// @param _batchedOrders The order to execute\n    function _processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders) private {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 fees, IERC20 tokenSold) = _submitInOrders(\n                _nftId,\n                _batchedOrders[i],\n                _batchedOrders[i].fromReserve\n            );\n            _transferFeeWithRoyalty(fees, tokenSold, _nftId);\n        }\n    }\n\n    /// @dev Internal logic extraction of processOutputOrders()\n    /// @param _nftId The id of the NFT to update\n    /// @param _batchedOrders The order to execute\n    function _processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders) private {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 feesAmount, uint256 amountBought) = _submitOutOrders(\n                _nftId,\n                _batchedOrders[i],\n                _batchedOrders[i].toReserve\n            );\n            _transferFeeWithRoyalty(feesAmount, _batchedOrders[i].outputToken, _nftId);\n            if (!_batchedOrders[i].toReserve) {\n                _safeTransferAndUnwrap(_batchedOrders[i].outputToken, amountBought - feesAmount, _msgSender());\n            }\n        }\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit orders (where the input is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _batchedOrders The order to process\n    /// @param _fromReserve True if the input tokens are from the reserve (portfolio)\n    /// @return feesAmount The total amount of fees on the input\n    /// @return tokenSold The ERC20 token sold (in case of ETH to WETH)\n    function _submitInOrders(\n        uint256 _nftId,\n        BatchedInputOrders calldata _batchedOrders,\n        bool _fromReserve\n    ) private returns (uint256 feesAmount, IERC20 tokenSold) {\n        uint256 batchLength = _batchedOrders.orders.length;\n        require(batchLength != 0, \"NF: INVALID_ORDERS\");\n        uint256 _inputTokenAmount;\n        (tokenSold, _inputTokenAmount) = _transferInputTokens(\n            _nftId,\n            _batchedOrders.inputToken,\n            _batchedOrders.amount,\n            _fromReserve\n        );\n\n        uint256 amountSpent;\n        for (uint256 i = 0; i < batchLength; i++) {\n            amountSpent += _submitOrder(\n                address(tokenSold),\n                _batchedOrders.orders[i].token,\n                _nftId,\n                _batchedOrders.orders[i],\n                true // always to the reserve\n            );\n        }\n        feesAmount = amountSpent / 100; // 1% Fee\n        require(amountSpent <= _inputTokenAmount - feesAmount, \"NF: OVERSPENT\");\n\n        uint256 underSpentAmount = _inputTokenAmount - feesAmount - amountSpent;\n        if (underSpentAmount != 0) {\n            tokenSold.safeTransfer(_fromReserve ? address(reserve) : _msgSender(), underSpentAmount);\n        }\n\n        // If input is from the reserve, update the records\n        if (_fromReserve) {\n            _decreaseHoldingAmount(_nftId, address(tokenSold), _inputTokenAmount - underSpentAmount);\n        }\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit sell orders (where the output is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _batchedOrders The order to process\n    /// @param _toReserve True if the output is store in the reserve/records (portfolio), false if not.\n    /// @return feesAmount The total amount of fees on the output\n    /// @return amountBought The total amount bought\n    function _submitOutOrders(\n        uint256 _nftId,\n        BatchedOutputOrders calldata _batchedOrders,\n        bool _toReserve\n    ) private returns (uint256 feesAmount, uint256 amountBought) {\n        uint256 batchLength = _batchedOrders.orders.length;\n        require(batchLength != 0, \"NF: INVALID_ORDERS\");\n        require(_batchedOrders.amounts.length == batchLength, \"NF: INPUTS_LENGTH_MUST_MATCH\");\n        amountBought = _batchedOrders.outputToken.balanceOf(address(this));\n\n        IERC20 _inputToken;\n        uint256 _inputTokenAmount;\n        for (uint256 i = 0; i < _batchedOrders.orders.length; i++) {\n            (_inputToken, _inputTokenAmount) = _transferInputTokens(\n                _nftId,\n                IERC20(_batchedOrders.orders[i].token),\n                _batchedOrders.amounts[i],\n                true\n            );\n\n            // Submit order and update holding of spent token\n            uint256 amountSpent = _submitOrder(\n                address(_inputToken),\n                address(_batchedOrders.outputToken),\n                _nftId,\n                _batchedOrders.orders[i],\n                false\n            );\n            require(amountSpent <= _inputTokenAmount, \"NF: OVERSPENT\");\n\n            uint256 underSpentAmount = _inputTokenAmount - amountSpent;\n            if (underSpentAmount != 0) {\n                _inputToken.safeTransfer(address(reserve), underSpentAmount);\n            }\n\n            _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmount - underSpentAmount);\n        }\n\n        amountBought = _batchedOrders.outputToken.balanceOf(address(this)) - amountBought;\n        feesAmount = amountBought / 100; // 1% Fee\n\n        if (_toReserve) {\n            _transferToReserveAndStore(_batchedOrders.outputToken, amountBought - feesAmount, _nftId);\n        }\n    }\n\n    /// @dev Call the operator to submit the order and add the output\n    /// assets to the reserve (if needed).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    /// @param _toReserve True if the output is store in the reserve/records, false if not.\n    function _submitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _nftId,\n        Order calldata _order,\n        bool _toReserve\n    ) private returns (uint256 amountSpent) {\n        (bool success, uint256[] memory amounts) = callOperator(_order, _inputToken, _outputToken);\n        require(success, \"NF: OPERATOR_CALL_FAILED\");\n\n        if (_toReserve) {\n            _transferToReserveAndStore(IERC20(_outputToken), amounts[0], _nftId);\n        }\n        amountSpent = amounts[1];\n    }\n\n    /// @dev Call the operator to submit the order but dont stop if the call to the operator fail.\n    ///      It will send the input token back to the msg.sender.\n    /// Note : The _toReserve Boolean has been removed (compare to _submitOrder) since it was\n    ///        useless for the only use case (destroy).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _amountToSpend The input amount available (to spend)\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    function _safeSubmitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _amountToSpend,\n        uint256 _nftId,\n        Order calldata _order\n    ) private {\n        (bool success, uint256[] memory amounts) = callOperator(_order, _inputToken, _outputToken);\n        if (success) {\n            require(amounts[1] <= _amountToSpend, \"NestedFactory::_safeSubmitOrder: Overspent\");\n            if (_amountToSpend > amounts[1]) {\n                IERC20(_inputToken).safeTransfer(_msgSender(), _amountToSpend - amounts[1]);\n            }\n        } else {\n            _safeTransferWithFees(IERC20(_inputToken), _amountToSpend, _msgSender(), _nftId);\n        }\n    }\n\n    /// @dev Transfer tokens to the reserve, and compute the amount received to store\n    /// in the records. We need to know the amount received in case of deflationary tokens.\n    /// @param _token The token to transfer (IERC20)\n    /// @param _amount The amount to send to the reserve\n    /// @param _nftId The Token ID to store the assets\n    function _transferToReserveAndStore(\n        IERC20 _token,\n        uint256 _amount,\n        uint256 _nftId\n    ) private {\n        address reserveAddr = address(reserve);\n        uint256 balanceReserveBefore = _token.balanceOf(reserveAddr);\n\n        // Send output to reserve\n        _token.safeTransfer(reserveAddr, _amount);\n\n        uint256 balanceReserveAfter = _token.balanceOf(reserveAddr);\n\n        nestedRecords.store(_nftId, address(_token), balanceReserveAfter - balanceReserveBefore, reserveAddr);\n    }\n\n    /// @dev Choose between ERC20 (safeTransfer) and ETH (deposit), to transfer from the Reserve\n    ///      or the user wallet, to the factory.\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token to receive\n    /// @param _inputTokenAmount Amount to transfer\n    /// @param _fromReserve True to transfer from the reserve\n    /// @return Token transfered (in case of ETH)\n    ///         The real amount received after the transfer to the factory\n    function _transferInputTokens(\n        uint256 _nftId,\n        IERC20 _inputToken,\n        uint256 _inputTokenAmount,\n        bool _fromReserve\n    ) private returns (IERC20, uint256) {\n        if (address(_inputToken) == ETH) {\n            require(address(this).balance >= _inputTokenAmount, \"NF: INVALID_AMOUNT_IN\");\n            weth.deposit{ value: _inputTokenAmount }();\n            return (IERC20(address(weth)), _inputTokenAmount);\n        }\n\n        uint256 balanceBefore = _inputToken.balanceOf(address(this));\n        if (_fromReserve) {\n            require(\n                nestedRecords.getAssetHolding(_nftId, address(_inputToken)) >= _inputTokenAmount,\n                \"NF: INSUFFICIENT_AMOUNT_IN\"\n            );\n            // Get input from reserve\n            reserve.withdraw(IERC20(_inputToken), _inputTokenAmount);\n        } else {\n            _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount);\n        }\n        return (_inputToken, _inputToken.balanceOf(address(this)) - balanceBefore);\n    }\n\n    /// @dev Send a fee to the FeeSplitter, royalties will be paid to the owner of the original asset\n    /// @param _amount Amount to send\n    /// @param _token Token to send\n    /// @param _nftId User portfolio ID used to find a potential royalties recipient\n    function _transferFeeWithRoyalty(\n        uint256 _amount,\n        IERC20 _token,\n        uint256 _nftId\n    ) private {\n        address originalOwner = nestedAsset.originalOwner(_nftId);\n        ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));\n        if (originalOwner != address(0)) {\n            feeSplitter.sendFeesWithRoyalties(originalOwner, _token, _amount);\n        } else {\n            feeSplitter.sendFees(_token, _amount);\n        }\n    }\n\n    /// @dev Decrease the amount of a NFT holding\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token holding\n    /// @param _amount The amount to subtract from the actual holding amount\n    function _decreaseHoldingAmount(\n        uint256 _nftId,\n        address _inputToken,\n        uint256 _amount\n    ) private {\n        nestedRecords.updateHoldingAmount(\n            _nftId,\n            _inputToken,\n            nestedRecords.getAssetHolding(_nftId, _inputToken) - _amount\n        );\n    }\n\n    /// @dev Transfer a token amount from the factory to the recipient.\n    ///      The token is unwrapped if WETH.\n    /// @param _token The token to transfer\n    /// @param _amount The amount to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferAndUnwrap(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest\n    ) private {\n        // if buy token is WETH, unwrap it instead of transferring it to the sender\n        if (address(_token) == address(weth)) {\n            IWETH(weth).withdraw(_amount);\n            (bool success, ) = _dest.call{ value: _amount }(\"\");\n            require(success, \"NF: ETH_TRANSFER_ERROR\");\n        } else {\n            _token.safeTransfer(_dest, _amount);\n        }\n    }\n\n    /// @dev Transfer from factory and collect fees\n    /// @param _token The token to transfer\n    /// @param _amount The amount (with fees) to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferWithFees(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest,\n        uint256 _nftId\n    ) private {\n        uint256 feeAmount = _amount / 100; // 1% Fee\n        _transferFeeWithRoyalty(feeAmount, _token, _nftId);\n        _token.safeTransfer(_dest, _amount - feeAmount);\n    }\n\n    /// @dev Verify that msg.value is equal to the amount needed (in the orders)\n    /// @param _batchedOrders The batched input orders\n    function _checkMsgValue(BatchedInputOrders[] calldata _batchedOrders) private {\n        uint256 ethNeeded;\n        for (uint256 i = 0; i < _batchedOrders.length; i++) {\n            if (address(_batchedOrders[i].inputToken) == ETH) {\n                ethNeeded += _batchedOrders[i].amount;\n            }\n        }\n        require(msg.value == ethNeeded, \"NF: WRONG_MSG_VALUE\");\n    }\n}"
    },
    {
      "filename": "contracts/abstracts/MixinOperatorResolver.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.11;\n\nimport \"../OperatorResolver.sol\";\nimport \"../interfaces/IOperatorResolver.sol\";\nimport \"../interfaces/INestedFactory.sol\";\n\n/// @title Mixin operator resolver\n/// @notice Store in cache operators name and address/selector\nabstract contract MixinOperatorResolver {\n    /// @notice Emitted when cache is updated\n    /// @param name The operator name\n    /// @param destination The operator address\n    event CacheUpdated(bytes32 name, IOperatorResolver.Operator destination);\n\n    /// @dev The OperatorResolver used to build the cache\n    OperatorResolver public immutable resolver;\n\n    /// @dev Cache operators map of the name and Operator struct (address/selector)\n    mapping(bytes32 => IOperatorResolver.Operator) private operatorCache;\n\n    constructor(address _resolver) {\n        resolver = OperatorResolver(_resolver);\n    }\n\n    /// @dev This function is public not external in order for it to be overridden and\n    ///      invoked via super in subclasses\n    function resolverOperatorsRequired() public view virtual returns (bytes32[] memory) {}\n\n    /// @notice Rebuild the operatorCache\n    function rebuildCache() external {\n        bytes32[] memory requiredOperators = resolverOperatorsRequired();\n        bytes32 name;\n        IOperatorResolver.Operator memory destination;\n        // The resolver must call this function whenever it updates its state\n        for (uint256 i = 0; i < requiredOperators.length; i++) {\n            name = requiredOperators[i];\n            // Note: can only be invoked once the resolver has all the targets needed added\n            destination = resolver.getOperator(name);\n            if (destination.implementation != address(0)) {\n                operatorCache[name] = destination;\n            } else {\n                delete operatorCache[name];\n            }\n            emit CacheUpdated(name, destination);\n        }\n    }\n\n    /// @notice Check the state of operatorCache\n    function isResolverCached() external view returns (bool) {\n        bytes32[] memory requiredOperators = resolverOperatorsRequired();\n        bytes32 name;\n        IOperatorResolver.Operator memory cacheTmp;\n        IOperatorResolver.Operator memory actualValue;\n        for (uint256 i = 0; i < requiredOperators.length; i++) {\n            name = requiredOperators[i];\n            cacheTmp = operatorCache[name];\n            actualValue = resolver.getOperator(name);\n            // false if our cache is invalid or if the resolver doesn't have the required address\n            if (\n                actualValue.implementation != cacheTmp.implementation ||\n                actualValue.selector != cacheTmp.selector ||\n                cacheTmp.implementation == address(0)\n            ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @dev Get operator address in cache and require (if exists)\n    /// @param name The operator name\n    /// @return The operator address\n    function requireAndGetAddress(bytes32 name) internal view returns (IOperatorResolver.Operator memory) {\n        IOperatorResolver.Operator memory _foundAddress = operatorCache[name];\n        require(_foundAddress.implementation != address(0), string(abi.encodePacked(\"MOR: MISSING_OPERATOR: \", name)));\n        return _foundAddress;\n    }\n\n    /// @dev Build the calldata (with safe datas) and call the Operator\n    /// @param _order The order to execute\n    /// @return success If the operator call is successful\n    /// @return amounts The amounts from the execution (used and received)\n    ///         - amounts[0] : The amount of output token\n    ///         - amounts[1] : The amount of input token USED by the operator (can be different than expected)\n    function callOperator(\n        INestedFactory.Order calldata _order,\n        address _inputToken,\n        address _outputToken\n    ) internal returns (bool success, uint256[] memory amounts) {\n        IOperatorResolver.Operator memory _operator = requireAndGetAddress(_order.operator);\n        // Parameters are concatenated and padded to 32 bytes.\n        // We are concatenating the selector + given params\n        bytes memory data;\n        (success, data) = _operator.implementation.delegatecall(bytes.concat(_operator.selector, _order.callData));\n\n        if (success) {\n            address[] memory tokens;\n            (amounts, tokens) = abi.decode(data, (uint256[], address[]));\n            require(tokens[0] == _outputToken, \"OH: INVALID_OUTPUT_TOKEN\");\n            require(tokens[1] == _inputToken, \"OH: INVALID_OUTPUT_TOKEN\");\n        }\n    }\n}"
    },
    {
      "filename": "contracts/NestedFactory.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.11;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./abstracts/OwnableProxyDelegation.sol\";\nimport \"./abstracts/MixinOperatorResolver.sol\";\nimport \"./libraries/ExchangeHelpers.sol\";\nimport \"./interfaces/external/IWETH.sol\";\nimport \"./interfaces/INestedFactory.sol\";\nimport \"./FeeSplitter.sol\";\nimport \"./NestedReserve.sol\";\nimport \"./NestedAsset.sol\";\nimport \"./NestedRecords.sol\";\n\n/// @title Creates, updates and destroys NestedAssets (portfolios).\n/// @notice Responsible for the business logic of the protocol and interaction with operators\ncontract NestedFactory is INestedFactory, ReentrancyGuard, OwnableProxyDelegation, MixinOperatorResolver {\n    using SafeERC20 for IERC20;\n\n    /* ----------------------------- VARIABLES ----------------------------- */\n\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Supported operators by the factory contract\n    bytes32[] private operators;\n\n    /// @dev Current feeSplitter contract/address\n    FeeSplitter public feeSplitter;\n\n    /// @dev Current reserve contract/address\n    NestedReserve public immutable reserve;\n\n    /// @dev Current nested asset (ERC721) contract/address\n    NestedAsset public immutable nestedAsset;\n\n    /// @dev Wrapped Ether contract/address\n    /// Note: Will be WMATIC, WAVAX, WBNB,... Depending on the chain.\n    IWETH public immutable weth;\n\n    /// @dev Current records contract/address\n    NestedRecords public immutable nestedRecords;\n\n    /* ---------------------------- CONSTRUCTOR ---------------------------- */\n\n    constructor(\n        NestedAsset _nestedAsset,\n        NestedRecords _nestedRecords,\n        NestedReserve _reserve,\n        FeeSplitter _feeSplitter,\n        IWETH _weth,\n        address _operatorResolver\n    ) MixinOperatorResolver(_operatorResolver) {\n        require(\n            address(_nestedAsset) != address(0) &&\n                address(_nestedRecords) != address(0) &&\n                address(_reserve) != address(0) &&\n                address(_feeSplitter) != address(0) &&\n                address(_weth) != address(0) &&\n                _operatorResolver != address(0),\n            \"NF: INVALID_ADDRESS\"\n        );\n        nestedAsset = _nestedAsset;\n        nestedRecords = _nestedRecords;\n        reserve = _reserve;\n        feeSplitter = _feeSplitter;\n        weth = _weth;\n    }\n\n    /// @dev Receive function\n    receive() external payable {}\n\n    /* ------------------------------ MODIFIERS ---------------------------- */\n\n    /// @dev Reverts the transaction if the caller is not the token owner\n    /// @param _nftId The NFT Id\n    modifier onlyTokenOwner(uint256 _nftId) {\n        require(nestedAsset.ownerOf(_nftId) == _msgSender(), \"NF: CALLER_NOT_OWNER\");\n        _;\n    }\n\n    /// @dev Reverts the transaction if the nft is locked (hold by design).\n    /// The block.timestamp must be greater than NFT record lock timestamp\n    /// @param _nftId The NFT Id\n    modifier isUnlocked(uint256 _nftId) {\n        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), \"NF: LOCKED_NFT\");\n        _;\n    }\n\n    /* ------------------------------- VIEWS ------------------------------- */\n\n    /// @notice Get the required operators\n    function resolverOperatorsRequired() public view override returns (bytes32[] memory) {\n        return operators;\n    }\n\n    /* -------------------------- OWNER FUNCTIONS -------------------------- */\n\n    /// @inheritdoc INestedFactory\n    function addOperator(bytes32 operator) external override onlyOwner {\n        require(operator != bytes32(\"\"), \"NF: INVALID_OPERATOR_NAME\");\n        bytes32[] memory operatorsCache = operators;\n        for (uint256 i = 0; i < operatorsCache.length; i++) {\n            require(operatorsCache[i] != operator, \"NF: EXISTENT_OPERATOR\");\n        }\n        operators.push(operator);\n        emit OperatorAdded(operator);\n    }\n\n    /// @inheritdoc INestedFactory\n    function removeOperator(bytes32 operator) external override onlyOwner {\n        uint256 operatorsLength = operators.length;\n        for (uint256 i = 0; i < operatorsLength; i++) {\n            if (operators[i] == operator) {\n                operators[i] = operators[operatorsLength - 1];"
    }
  ]
}