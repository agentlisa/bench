{
  "Title": "M-1: Napier pool owner can unfairly increase protocol fees on swaps to earn more revenue",
  "Content": "# Issue M-1: Napier pool owner can unfairly increase protocol fees on swaps to earn more revenue \n\nSource: https://github.com/sherlock-audit/2024-01-napier-judging/issues/51 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nSolidity\\_ATL\\_Team\\_2, xiaoming90\n## Summary\nCurrently there is no limit to how often a `poolOwner` can update fees which can be abused to earn more fees by charging users higher swap fees than they expect.\n\n## Vulnerability Detail\nThe `NapierPool::setFeeParameter` function allows the `poolOwner` to set the `protocolFeePercent` at any point to a maximum value of 100%. The `poolOwner` is a trusted party but should not be able to abuse protocol settings to earn more revenue. There are no limits to how often this can be updated.\n\n## Impact\nA malicious `poolOwner` could change the protocol swap fees unfairly for users by front-running swaps and increasing fees to higher values on unsuspecting users. An example scenario is:\n\n- The `poolOwner` sets swap fees to 1% to attract users\n- The `poolOwner` front runs all swaps and changes the swap fees to the maximum value of 100%\n- After the swap the `poolOwner` resets `protocolFeePercent` to a low value to attract more users\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/v1-pool/src/NapierPool.sol#L544-L556\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/v1-pool/src/libs/PoolMath.sol#L313\n\n## Tool used\nManual Review and Foundry\n\n## Proof of concept\n```solidity\n function test_protocol_owner_frontRuns_swaps_with_higher_fees() public whenMaturityNotPassed {\n        // pre-condition\n        vm.warp(maturity - 30 days);\n        deal(address(pts[0]), alice, type(uint96).max, false); // ensure alice has enough pt\n        uint256 preBaseLptSupply = tricrypto.totalSupply();\n        uint256 ptInDesired = 100 * ONE_UNDERLYING;\n        uint256 expectedBaseLptIssued = tricrypto.calc_token_amount([ptInDesired, 0, 0], true);\n\n        // Pool owner sees swap about to occur and front runs updating fees to max value\n        vm.startPrank(owner);\n        pool.setFeeParameter(\"protocolFeePercent\", 100);\n        vm.stopPrank();\n\n        // execute\n        vm.prank(alice);\n        uint256 underlyingOut = pool.swapPtForUnderlying(\n            0, ptInDesired, recipient, abi.encode(CallbackInputType.SwapPtForUnderlying, SwapInput(underlying, pts[0]))\n        );\n        // sanity check\n        uint256 protocolFee = SwapEventsLib.getProtocolFeeFromLastSwapEvent(pool);\n        assertGt(protocolFee, 0, \"fee should be charged\");\n    }\n```\n\n## Recommendation\nIntroduce a delay in fee updates to ensure users receive the fees they expect.\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  invalid\n\n\n\n**massun-onibakuchi**\n\nwe have acknowledge the issue\n\n**cvetanovv**\n\nAs the sponsor wrote in the other report, slippage protection can prevent a malicious increase in fees.\n\n**Darkartt**\n\nEscalate\n\n**sherlock-admin2**\n\n> Escalate\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Robert-H-Leonard**\n\nThere is slippage protection in the swap but it does not fully protect against a malicious increase.\n\nThe PoC in this issue can be added to the test suite in `v1-pool/test/unit/pool/Swap.t.sol` to show this increase is possible. The default protocol fee is set to 80% and this test is setting it to 100% and performing the swap.\n\n To test an extreme case that still passes you can decrease the default protocol fee to 5% ([which is configured here ](https://github.com/sherlock-audit/2024-01-napier/blob/main/v1-pool/test/Base.t.sol#L112) and still have the fee increase.\n\n**Czar102**\n\n@cvetanovv can you elaborate on your stance, also given the new context?\n\n**cvetanovv**\n\nI agree with the escalation. This report and #98 should be Medium.\n\n**Czar102**\n\nPlanning to apply the suggestion. Any idea why is the escalation empty? I'm not sure if I should accept it or choose [this one](https://github.com/sherlock-audit/2024-01-napier-judging/issues/98#issuecomment-1984792549) to be accepted for this single modification of the validity.\n\n**Robert-H-Leonard**\n\n@Czar102 the escalation is empty because we are working on a team of 5  and he was the only team member that could raise it. My comment below his escalation is the context of the escalation\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [Darkartt](https://github.com/sherlock-audit/2024-01-napier-judging/issues/51/#issuecomment-1984575069): accepted\n\n**Czar102**\n\nResult:\nMedium\nHas duplicates\n\n**Czar102**\n\n@Robert-H-Leonard next time please just share the escalation contents with each other to put the recommendation in the escalation. This won't be accepted in the future.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/171",
  "Code": [
    {
      "filename": "v1-pool/src/NapierPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\n// interfaces\nimport {IERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/IERC20.sol\";\nimport {CurveTricryptoOptimizedWETH} from \"./interfaces/external/CurveTricryptoOptimizedWETH.sol\";\nimport {ITranche} from \"@napier/napier-v1/src/interfaces/ITranche.sol\";\n\nimport {INapierPool} from \"./interfaces/INapierPool.sol\";\nimport {INapierSwapCallback} from \"./interfaces/INapierSwapCallback.sol\";\nimport {INapierMintCallback} from \"./interfaces/INapierMintCallback.sol\";\nimport {IPoolFactory} from \"./interfaces/IPoolFactory.sol\";\n// libs\nimport {PoolMath, PoolState} from \"./libs/PoolMath.sol\";\nimport {Math} from \"@openzeppelin/contracts@4.9.3/utils/math/Math.sol\";\nimport {SignedMath} from \"./libs/SignedMath.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts@4.9.3/utils/math/SafeCast.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/utils/SafeERC20.sol\";\nimport {DecimalConversion} from \"./libs/DecimalConversion.sol\";\nimport {MAX_LN_FEE_RATE_ROOT, MAX_PROTOCOL_FEE_PERCENT} from \"./libs/Constants.sol\";\nimport {Errors} from \"./libs/Errors.sol\";\n// inherits\nimport {ERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/ERC20.sol\";\nimport {ERC20Permit} from \"@openzeppelin/contracts@4.9.3/token/ERC20/extensions/ERC20Permit.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts@4.9.3/security/ReentrancyGuard.sol\";\n\n/// @dev NapierPool is a pool that allows users to trade between a BasePool LP token and an underlying asset.\n/// BasePool LP token is a token that represents a share of basket of 3 Principal Tokens Curve V2 pool.\n///\n/// Note: This pool and its math assumes the following regarding BasePool:\n/// 1. The BasePool assets are 3 Napier Principal Tokens (PT) of the same maturity and same underlying asset.\n///    We can consider BasePool LP token as something like ETF of 3 PTs.\n/// 2. BasePool LP token is approximately three times more valuable than 1 PT because the initial deposit on Curve pool issues 1:1:1:1=pt1:pt2:pt3:share.\n/// e.g. When the initial price of PT1, PT2 and PT3 is 1,`1` BasePool LP token is convertible to `1` PT1 + `1` PT2 + `1` PT3 instead of `1/3` for each PT.\n/// We need to adjust the balance of BasePool LP token by multiplying 3 to make it comparable to underlying asset.\n/// Economically at maturity 1/3 BaseLP token is expected to be convertible to approximately 1 underlying asset.\n/// 3. BasePool LP token has 18 decimals.\n/// 4. PTs have the same decimals as underlying asset.\ncontract NapierPool is INapierPool, ReentrancyGuard, ERC20Permit {\n    using PoolMath for PoolState;\n    using SafeERC20 for IERC20;\n    using SafeERC20 for CurveTricryptoOptimizedWETH;\n    using SignedMath for uint256;\n    using SafeCast for uint256;\n    using DecimalConversion for uint256;\n\n    /// @dev Number of coins in the BasePool\n    uint256 internal constant N_COINS = 3;\n\n    /// @notice The factory that deployed this pool.\n    IPoolFactory public immutable factory;\n\n    /// @notice BasePool LP token i.e. Curve v2 3assets pool\n    CurveTricryptoOptimizedWETH public immutable tricrypto;\n\n    /// @notice Underlying asset (e.g. DAI, WETH)\n    IERC20 public immutable underlying;\n    uint8 internal immutable uDecimals;\n\n    /// @notice Napier Principal Tokens\n    /// @dev We don't use static size array here because Solidity doesn't support immutable static size array.\n    /// @dev This would significantly reduce gas cost by avoiding SLOAD. About 2000 gas per reading principal token. (cold)\n    /// @dev pt_i is the i-th asset of the BasePool coins. i.e pt[i] = CurveV2Pool.coins(i)\n    IERC20 internal immutable pt1;\n    IERC20 internal immutable pt2;\n    IERC20 internal immutable pt3;\n\n    /// @notice Maturity of the pool in unix timestamp\n    /// @notice At or after maturity, the pool will no longer accept any liquidity provision or swap. Removing liquidity is still allowed.\n    /// @dev Users can still swap, add or remove liquidity even after maturity on Curve pool.\n    /// @dev expiry of the pool. This is the maturity of all principal tokens in the pool.\n    uint256 public immutable maturity;\n\n    /// @notice AMM parameter: Scalar root of the pool\n    /// @dev adjust the capital efficiency of the market.\n    uint256 public immutable scalarRoot;\n\n    /// @notice AMM parameter: Initial anchor of the pool\n    /// @dev initial rate anchor to anchor the marketâ€™s formula to be more capital efficient around a certain interest rate.\n    int256 public immutable initialAnchor;\n\n    /// @notice Recipient of the protocol fee\n    address public immutable feeRecipient;\n\n    /// @notice AMM parameter: Logarithmic fee rate root of the pool\n    /// @dev Fees rate in terms of interest rate\n    uint80 internal lnFeeRateRoot;\n\n    /// @notice AMM parameter: Fee Napier charges for swaps in percentage (100=100%)\n    uint8 internal protocolFeePercent;\n\n    /// @notice AMM parameter: Last logarithmic implied rate of the pool\n    uint256 public lastLnImpliedRate;\n\n    /// @notice Total amount of BaseLpt in the pool (Reserve)\n    uint128 public totalBaseLpt;\n\n    /// @notice Total amount of underlying in the pool (Reserve)\n    uint128 public totalUnderlying;\n\n    /// @dev Revert if maturity is reached\n    modifier notExpired() {\n        if (maturity <= block.timestamp) revert Errors.PoolExpired();\n        _;\n    }\n\n    constructor() payable ERC20(\"Napier Pool LP Token\", \"NapierPool LPT\") ERC20Permit(\"Napier Pool LP Token\") {\n        factory = IPoolFactory(msg.sender);\n        IPoolFactory.InitArgs memory args = factory.args();\n        // Set mutable variables\n        protocolFeePercent = args.configs.protocolFeePercent;\n        // Set immutable variables\n        scalarRoot = args.configs.scalarRoot;\n        initialAnchor = args.configs.initialAnchor;\n        lnFeeRateRoot = args.configs.lnFeeRateRoot;\n        feeRecipient = args.configs.feeRecipient;\n\n        address basePool = args.assets.basePool;\n        tricrypto = CurveTricryptoOptimizedWETH(basePool);\n\n        ERC20 _underlying = ERC20(args.assets.underlying);\n        underlying = _underlying;\n        uDecimals = _underlying.decimals();\n\n        // hack: we don't use static size array here to save gas cost\n        ITranche _pt1 = ITranche(args.assets.principalTokens[0]);\n        ITranche _pt2 = ITranche(args.assets.principalTokens[1]);\n        ITranche _pt3 = ITranche(args.assets.principalTokens[2]);\n\n        pt1 = _pt1;\n        pt2 = _pt2;\n        pt3 = _pt3;\n        // Assume that the maturity of all principal tokens are the same\n        maturity = _pt1.maturity();\n\n        // Approve Curve pool to transfer PTs\n        _pt1.approve(basePool, type(uint256).max); // dev: Principal token will revert if failed to approve\n        _pt2.approve(basePool, type(uint256).max);\n        _pt3.approve(basePool, type(uint256).max);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Mutative functions\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @inheritdoc INapierPool\n    /// @notice Provide BasePoolLpToken (BaseLpt) and underlying in exchange for Lp token, which will grant LP holders more exchange fee over time\n    /// @dev Mint as much LP token as possible.\n    /// @dev BaseLpt and Underlying should be transferred to this contract prior to calling\n    /// @dev Revert if maturity is reached\n    /// @dev Revert if deposited assets are too small to mint more than minimum liquidity\n    /// @dev Revert if deposited assets are too small to compute ln implied rate\n    /// @dev Revert if computed initial exchange rate in base LP token is below one. (deposited base LP token is much less than deposited underlying)\n    /// @dev Revert if proportion of deposited base LP token is higher than the maximum proportion. (deposited base LP token is too large compared to deposited underlying)\n    /// @dev Revert if minted LP token is zero\n    /// @param recipient recipient of the minted LP token\n    /// @return liquidity amount of LP token minted\n    function addLiquidity(uint256 underlyingInDesired, uint256 baseLptInDesired, address recipient, bytes memory data)\n        external\n        override\n        nonReentrant\n        notExpired\n        returns (uint256)\n    {\n        // Cache state variables\n        (uint256 _totalUnderlying, uint256 _totalBaseLpt) = (totalUnderlying, totalBaseLpt);\n\n        uint256 bBalance = _balance(tricrypto); // Base Pool LP token reserve\n        uint256 uBalance = _balance(underlying); // NOTE: Sum of underlying asset reserve and stuck protocol fees.\n\n        (uint256 liquidity, uint256 underlyingUsed, uint256 baseLptUsed) =\n            _mintLiquidity(_totalUnderlying, _totalBaseLpt, recipient, underlyingInDesired, baseLptInDesired);\n\n        /// WRITE ///\n        // Last ln implied rate doesn't change because liquidity is added proportionally\n        totalUnderlying = (_totalUnderlying + underlyingUsed).toUint128();\n        totalBaseLpt = (_totalBaseLpt + baseLptUsed).toUint128();\n\n        /// INTERACTION ///\n        if (!factory.isCallbackReceiverAuthorized(msg.sender)) revert Errors.PoolUnauthorizedCallback();\n        INapierMintCallback(msg.sender).mintCallback(underlyingUsed, baseLptUsed, data);\n\n        /// CHECK ///\n        if (_balance(tricrypto) < bBalance + baseLptUsed) revert Errors.PoolInsufficientBaseLptReceived();\n        if (_balance(underlying) < uBalance + underlyingUsed) {\n            revert Errors.PoolInsufficientUnderlyingReceived();\n        }\n\n        return liquidity;\n    }\n\n    /// @notice Mint LP token for the given amount of underlying and base LP token\n    /// @dev This function doesn't update state variables except Lp token and last implied rate.\n    /// @dev *variableName*18 represents the value *in 18 decimals*.\n    /// @dev Mint as much LP token as possible.\n    /// @dev If the pool is not initialized, a portion of issued LP token will be permanently locked.\n    /// @dev Revert if minted LP token is zero\n    /// @param totalUnderlyingCache total underlying balance of the pool in underlying unit.\n    /// @param totalBaseLptCache total base LP token balance of the pool **(All BaseLpt has 18 decimals)**\n    /// @param recipient recipient of the minted LP token\n    /// @param underlyingIn deposited underlying **in underlying unit**\n    /// @param baseLptIn deposited base LP token **(All BaseLpt has 18 decimals)**\n    /// @return liquidity - amount of LP token minted\n    /// @return underlyingUsed - amount of underlying used\n    /// @return baseLptUsed - amount of base LP token used\n    function _mintLiquidity(\n        uint256 totalUnderlyingCache,\n        uint256 totalBaseLptCache,\n        address recipient,\n        uint256 underlyingIn,\n        uint256 baseLptIn\n    ) internal returns (uint256 liquidity, uint256 underlyingUsed, uint256 baseLptUsed) {\n        uint256 totalLp = totalSupply();\n\n        if (totalLp == 0) {\n            // Note: This path is executed only once.\n            // Amounts of underlying is converted to 18 decimals to normalize how much LP token is issued.\n            liquidity = Math.sqrt(underlyingIn.to18Decimals(uDecimals) * baseLptIn) - PoolMath.MINIMUM_LIQUIDITY;\n            underlyingUsed = underlyingIn;\n            baseLptUsed = baseLptIn;\n            /// WRITE\n            // Note: Only at initial issuance, a portion of the issued LP tokens will be permanently locked.\n            _mint(address(1), PoolMath.MINIMUM_LIQUIDITY);\n            lastLnImpliedRate = PoolMath.computeInitialLnImpliedRate(\n                PoolState({\n                    totalBaseLptTimesN: baseLptUsed * N_COINS,\n                    totalUnderlying18: underlyingUsed.to18Decimals(uDecimals),\n                    scalarRoot: scalarRoot,\n                    maturity: maturity,\n                    lnFeeRateRoot: lnFeeRateRoot,\n                    protocolFeePercent: protocolFeePercent,\n                    lastLnImpliedRate: 0\n                }),\n                initialAnchor\n            );\n            emit UpdateLnImpliedRate(lastLnImpliedRate);\n        } else {\n            // Note: Multiplying N_COINS is not needed because it is canceled out thanks to ratio calculation.\n            uint256 netLpByBaseLpt = (baseLptIn * totalLp) / totalBaseLptCache;\n            uint256 netLpByUnderlying = (underlyingIn * totalLp) / totalUnderlyingCache;\n            if (netLpByBaseLpt < netLpByUnderlying) {\n                liquidity = netLpByBaseLpt;\n                baseLptUsed = baseLptIn;\n                underlyingUsed = (totalUnderlyingCache * liquidity) / totalLp;\n            } else {\n                liquidity = netLpByUnderlying;\n                underlyingUsed = underlyingIn;\n                baseLptUsed = (totalBaseLptCache * liquidity) / totalLp;\n            }\n        }\n        /// WRITE\n        // Mint LP token to recipient\n        if (liquidity == 0) revert Errors.PoolZeroAmountsOutput();\n        _mint(recipient, liquidity);\n\n        emit Mint(recipient, liquidity, underlyingUsed, baseLptUsed);\n    }\n\n    /// @inheritdoc INapierPool\n    /// @notice Burn Lp token in exchange for underlying and base LP token.\n    /// @dev liquidity token (Lp token) should be transferred to this contract prior to calling this function\n    /// @dev Revert if underlying and base LP token are zero\n    /// @dev Revert if liquidity to burn is zero\n    /// @param recipient recipient of the withdrawn underlying and base LP token\n    /// @return underlyingOut amount of underlying withdrawn\n    /// @return baseLptOut amount of base LP token withdrawn\n    function removeLiquidity(address recipient)\n        external\n        override\n        nonReentrant\n        returns (uint256 underlyingOut, uint256 baseLptOut)\n    {\n        uint256 liquidity = balanceOf(address(this));\n        (uint256 _totalUnderlying, uint256 _totalBaseLpt) = (totalUnderlying, totalBaseLpt);\n\n        (underlyingOut, baseLptOut) = _burnLiquidity(totalUnderlying, totalBaseLpt, liquidity);\n        if (underlyingOut == 0 && baseLptOut == 0) revert Errors.PoolZeroAmountsOutput();\n\n        /// WRITE ///\n        totalUnderlying = (_totalUnderlying - underlyingOut).toUint128();\n        totalBaseLpt = (_totalBaseLpt - baseLptOut).toUint128();\n\n        /// INTERACTION ///\n        underlying.safeTransfer(recipient, underlyingOut);\n        tricrypto.safeTransfer(recipient, baseLptOut);\n\n        emit Burn(recipient, liquidity, underlyingOut, baseLptOut);\n    }\n\n    /// @notice Burn Lp token in exchange for underlying and Base LP token.\n    /// @dev This function doesn't update state variables except Lp token.\n    /// @dev *variableName*18 represents the value *in 18 decimals*.\n    /// @dev Not revert even if `underlyingOut18` and `baseLptOut` are zero\n    /// @param totalUnderlyingCache total underlying balance of the pool **in 18 decimals**.\n    /// @param totalBaseLptCache total Base LP token balance of the pool **(All BaseLpt has 18 decimals)**\n    /// @param liquidity amount of LP token to burn\n    /// @return underlyingOut - amount of underlying withdrawn **in 18 decimals**\n    /// @return baseLptOut - amount of Base LP token withdrawn\n    function _burnLiquidity(uint256 totalUnderlyingCache, uint256 totalBaseLptCache, uint256 liquidity)\n        internal\n        returns (uint256 underlyingOut, uint256 baseLptOut)\n    {\n        if (liquidity == 0) revert Errors.PoolZeroAmountsInput();\n\n        uint256 totalLp = totalSupply();\n        underlyingOut = (liquidity * totalUnderlyingCache) / totalLp;\n        baseLptOut = (liquidity * totalBaseLptCache) / totalLp;\n\n        _burn(address(this), liquidity);\n    }\n\n    /// @inheritdoc INapierPool\n    /// @notice Swap exact amount of PT for underlying token\n    /// @dev Revert if maturity is reached\n    /// @dev Revert if index is invalid\n    /// @dev Revert if callback recipient is not authorized\n    /// @dev Revert if ptIn is too large and runs out of underlying reserve\n    /// @dev Revert if minted base Lp token is less than expected. (pt is not enough to mint expected base Lp token amount)\n    /// @param index index of the PT token\n    /// @param ptIn amount of PT token to swap\n    /// @param recipient recipient of the underlying token and receiver of callback function\n    /// @param data data to pass to the recipient on callback. If empty, no callback.\n    /// @return underlyingOut amount of underlying token out\n    function swapPtForUnderlying(uint256 index, uint256 ptIn, address recipient, bytes calldata data)\n        external\n        override\n        nonReentrant\n        notExpired\n        returns (uint256 underlyingOut)\n    {\n        uint256[3] memory amountsIn;\n        uint256 exactBaseLptIn;\n        uint256 swapFee;\n        uint256 protocolFee;\n        // stack too deep\n        {\n            PoolState memory state = _loadState();\n\n            // Pre-compute the swap result given principal token\n            amountsIn[index] = ptIn;\n            exactBaseLptIn = tricrypto.calc_token_amount(amountsIn, true);\n            // Pre-compute the swap result given BaseLpt and underlying\n            (uint256 underlyingOut18, uint256 swapFee18, uint256 protocolFee18) =\n                state.swapExactBaseLpTokenForUnderlying(exactBaseLptIn);\n            underlyingOut = underlyingOut18.from18Decimals(uDecimals);\n            swapFee = swapFee18.from18Decimals(uDecimals);\n            protocolFee = protocolFee18.from18Decimals(uDecimals);\n\n            // dev: If `underlyingOut18` is less than 10**(18 - underlyingDecimals), `underlyingOut` will be zero.\n            // Revert to prevent users from swapping non-zero amount of BaseLpt for 0 underlying.\n            if (underlyingOut == 0) revert Errors.PoolZeroAmountsOutput();\n\n            /// WRITE ///\n            _writeState(state);\n        }\n        {\n            uint256 bBalance = _balance(tricrypto); // Base Pool LP token reserve\n            uint256 uBalance = _balance(underlying); // NOTE: Sum of underlying asset reserve and stuck protocol fees.\n\n            /// INTERACTION ///\n            // dev: Optimistically transfer underlying to recipient\n            underlying.safeTransfer(recipient, underlyingOut);\n\n            // incoming to user => positive, outgoing from user => negative\n            if (!factory.isCallbackReceiverAuthorized(msg.sender)) revert Errors.PoolUnauthorizedCallback();\n            INapierSwapCallback(msg.sender).swapCallback(underlyingOut.toInt256(), ptIn.neg(), data);\n\n            // Curve pool will revert if we don't receive enough principal token at this point\n            // Deposit the principal token which `msg.sender` should send in the callback to BasePool\n            tricrypto.add_liquidity(amountsIn, 0); // unlimited slippage\n\n            /// CHECK ///\n            // Revert if we don't receive enough baseLpt\n            if (_balance(tricrypto) < bBalance + exactBaseLptIn) revert Errors.PoolInsufficientBaseLptReceived();\n            if (_balance(underlying) < uBalance - underlyingOut) {\n                revert Errors.PoolInvariantViolated();\n            }\n        }\n        emit Swap(msg.sender, recipient, underlyingOut.toInt256(), index, ptIn.neg(), swapFee, protocolFee);\n    }\n\n    /// @inheritdoc INapierPool\n    /// @notice Swap underlying token for approximately exact amount of PT\n    /// @notice This function can NOT swap underlying for *exact* amount of PT due to approximation error on Curve pool.\n    /// Revert if maturity is reached\n    /// Revert if index is invalid\n    /// Revert if callback recipient is not authorized\n    /// Revert if ptOutDesired is too large and runs out of pt reserve in Base pool\n    /// Revert if underlying received is less than expected.\n    /// @param index index of the PT\n    /// @param ptOutDesired amount of PT to be swapped out\n    /// @param recipient recipient of the PT and receiver of callback function\n    /// @param data data to pass to the recipient on callback\n    /// callback can be invoked by only authorized contract\n    function swapUnderlyingForPt(uint256 index, uint256 ptOutDesired, address recipient, bytes calldata data)\n        external\n        override\n        nonReentrant\n        notExpired\n        returns (uint256 underlyingIn)\n    {\n        uint256 exactBaseLptOut;\n        uint256 swapFee;\n        uint256 protocolFee;\n        // Pre-compute the swap result\n        // stack too deep\n        {\n            PoolState memory state = _loadState();\n\n            uint256[3] memory ptsOut;\n            ptsOut[index] = ptOutDesired;\n            exactBaseLptOut = tricrypto.calc_token_amount(ptsOut, false);\n            // Pre-compute the swap result given BaseLpt\n            (uint256 underlyingIn18, uint256 swapFee18, uint256 protocolFee18) =\n                state.swapUnderlyingForExactBaseLpToken(exactBaseLptOut);\n            underlyingIn = underlyingIn18.from18Decimals(uDecimals);\n            swapFee = swapFee18.from18Decimals(uDecimals);\n            protocolFee = protocolFee18.from18Decimals(uDecimals);\n\n            // dev: If `underlyingIn18` is less than 10**(18 - underlyingDecimals), `underlyingIn` will be zero.\n            // Revert to prevent users from swapping for free.\n            if (underlyingIn == 0) revert Errors.PoolZeroAmountsInput();\n\n            /// WRITE ///\n            _writeState(state);\n        }\n\n        uint256 bBalance = _balance(tricrypto); // Base Pool LP token reserve\n        uint256 uBalance = _balance(underlying); // NOTE: Sum of underlying asset reserve and stuck protocol fees.\n\n        /// INTERACTION ///\n        // Remove the principal token from BasePool with minimum = 0\n        uint256 ptOutActual = tricrypto.remove_liquidity_one_coin(exactBaseLptOut, index, 0, false, recipient);\n\n        // incoming to user => positive, outgoing from user => negative\n        if (!factory.isCallbackReceiverAuthorized(msg.sender)) revert Errors.PoolUnauthorizedCallback();\n        INapierSwapCallback(msg.sender).swapCallback(underlyingIn.neg(), ptOutActual.toInt256(), data);\n\n        /// CHECK ///\n        // Revert if we don't receive enough underlying\n        if (_balance(underlying) < uBalance + underlyingIn) {\n            revert Errors.PoolInsufficientUnderlyingReceived();\n        }\n        if (_balance(tricrypto) < bBalance - exactBaseLptOut) {\n            revert Errors.PoolInvariantViolated();\n        }\n\n        emit Swap(msg.sender, recipient, underlyingIn.neg(), index, ptOutActual.toInt256(), swapFee, protocolFee);\n    }\n\n    /// @inheritdoc INapierPool\n    /// @notice Swap underlying token for exact amount of Base Lp token\n    /// @notice Approve this contract to use underlying prior to calling this function.\n    /// @dev Revert if maturity is reached\n    function swapUnderlyingForExactBaseLpToken(uint256 baseLptOut, address recipient)\n        external\n        override\n        nonReentrant\n        notExpired\n        returns (uint256)\n    {\n        PoolState memory state = _loadState();\n\n        (uint256 underlyingIn18, uint256 swapFee18, uint256 protocolFee18) =\n            state.swapUnderlyingForExactBaseLpToken(baseLptOut);\n        uint256 underlyingIn = underlyingIn18.from18Decimals(uDecimals);\n        uint256 swapFee = swapFee18.from18Decimals(uDecimals);\n        uint256 protocolFee = protocolFee18.from18Decimals(uDecimals);\n\n        // dev: If `underlyingIn18` is less than 10**(18 - underlyingDecimals), `underlyingIn` will be zero.\n        // Revert to prevent users from swapping for free.\n        if (underlyingIn == 0) revert Errors.PoolZeroAmountsInput();\n\n        /// WRITE ///\n        _writeState(state);\n\n        /// INTERACTION ///\n        underlying.safeTransferFrom(msg.sender, address(this), underlyingIn);\n        tricrypto.safeTransfer(recipient, baseLptOut);\n\n        emit SwapBaseLpt(msg.sender, recipient, -(underlyingIn.toInt256()), baseLptOut.toInt256(), swapFee, protocolFee);\n        return underlyingIn;\n    }\n\n    /// @inheritdoc INapierPool\n    /// @notice Swap exact amount of Base Lp token for underlying token\n    /// @notice Approve this contract to use BaseLP token prior to calling this function.\n    /// @dev Revert if maturity is reached\n    function swapExactBaseLpTokenForUnderlying(uint256 baseLptIn, address recipient)\n        external\n        override\n        nonReentrant\n        notExpired\n        returns (uint256)\n    {\n        PoolState memory state = _loadState();\n\n        (uint256 underlyingOut18, uint256 swapFee18, uint256 protocolFee18) =\n            state.swapExactBaseLpTokenForUnderlying(baseLptIn);\n        uint256 underlyingOut = underlyingOut18.from18Decimals(uDecimals);\n        uint256 swapFee = swapFee18.from18Decimals(uDecimals);\n        uint256 protocolFee = protocolFee18.from18Decimals(uDecimals);\n\n        // dev: If `underlyingOut18` is less than 10**(18 - underlyingDecimals), `underlyingOut` will be zero.\n        // Revert to prevent users from swapping non-zero amount of BaseLpt for 0 underlying.\n        if (underlyingOut == 0) revert Errors.PoolZeroAmountsOutput();\n\n        /// WRITE ///\n        _writeState(state);\n\n        /// INTERACTION ///\n        tricrypto.safeTransferFrom(msg.sender, address(this), baseLptIn);\n        underlying.safeTransfer(recipient, underlyingOut);\n\n        emit SwapBaseLpt(msg.sender, recipient, underlyingOut.toInt256(), baseLptIn.neg(), swapFee, protocolFee);\n        return underlyingOut;\n    }\n\n    /// @notice Forcibly sweep excess tokens to the fee recipient\n    /// @notice This function can be called by anyone\n    /// @notice Protocol fee is sent to the fee recipient\n    /// @dev Excess tokens (excluding fees) can be swept by anyone, using `addLiquidity` etc.\n    /// @dev Can be used when the pool is in an inconsistent state:\n    /// A large amount of base LP token or underlying is donated to the pool, which makes the pool revert when swapping base LP token for underlying\n    /// because the pool doesn't have enough underlying to swap.\n    function skim() external nonReentrant {\n        (uint256 _totalUnderlying, uint256 _totalBaseLpt) = (totalUnderlying, totalBaseLpt);\n\n        uint256 baseLptExcess = _balance(tricrypto) - _totalBaseLpt;\n        uint256 feesAndExcess = _balance(underlying) - _totalUnderlying;\n\n        if (baseLptExcess != 0) tricrypto.safeTransfer(feeRecipient, baseLptExcess);\n        if (feesAndExcess != 0) underlying.safeTransfer(feeRecipient, feesAndExcess);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Protected functions\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Set fee parameters\n    /// @notice Only the factory owner can call this function.\n    /// @param paramName name of the parameter to set (lnFeeRateRoot, protocolFeePercent)\n    /// @param value value of the parameter\n    function setFeeParameter(bytes32 paramName, uint256 value) external {\n        if (factory.owner() != msg.sender) revert Errors.PoolOnlyOwner();\n\n        if (paramName == \"lnFeeRateRoot\") {\n            if (value > MAX_LN_FEE_RATE_ROOT) revert Errors.LnFeeRateRootTooHigh();\n            lnFeeRateRoot = uint80(value); // unsafe cast here is Okay because we checked the value is less than MAX_LN_FEE_RATE_ROOT\n        } else if (paramName == \"protocolFeePercent\") {\n            if (value > MAX_PROTOCOL_FEE_PERCENT) revert Errors.ProtocolFeePercentTooHigh();\n            protocolFeePercent = uint8(value); // unsafe cast here is Okay\n        } else {\n            revert Errors.PoolInvalidParamName();\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // View functions\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice get Principal Tokens within the pool\n    function principalTokens() public view returns (IERC20[3] memory) {\n        return [pt1, pt2, pt3];\n    }\n\n    /// @notice read the state of the pool\n    function readState() external view returns (PoolState memory) {\n        return _loadState();\n    }\n    /// @notice get underlying and tricrypto addresses of the pool\n\n    function getAssets() public view returns (address, address) {\n        return (address(underlying), address(tricrypto));\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Util\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice read the state of the pool from storage into memory\n    function _loadState() internal view returns (PoolState memory state) {\n        state = PoolState({\n            totalBaseLptTimesN: totalBaseLpt * N_COINS,\n            totalUnderlying18: uint256(totalUnderlying).to18Decimals(uDecimals),\n            lnFeeRateRoot: lnFeeRateRoot,\n            protocolFeePercent: protocolFeePercent,\n            scalarRoot: scalarRoot,\n            maturity: maturity,\n            lastLnImpliedRate: lastLnImpliedRate\n        });\n    }\n\n    /// @notice write back the state of the pool from memory to storage\n    function _writeState(PoolState memory state) internal {\n        lastLnImpliedRate = state.lastLnImpliedRate;\n        totalBaseLpt = (state.totalBaseLptTimesN / N_COINS).toUint128();\n        totalUnderlying = state.totalUnderlying18.from18Decimals(uDecimals).toUint128();\n\n        emit UpdateLnImpliedRate(state.lastLnImpliedRate);\n    }\n\n    /// @notice credit: UniswapV3Pool\n    /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize\n    /// check\n    function _balance(IERC20 token) internal view returns (uint256) {\n        (bool success, bytes memory data) =\n            address(token).staticcall(abi.encodeWithSelector(IERC20.balanceOf.selector, address(this)));\n        require(success && data.length >= 32);\n        return abi.decode(data, (uint256));\n    }\n}"
    },
    {
      "filename": "v1-pool/src/libs/PoolMath.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\n/// @notice This library contains the math used in NapierPool.\n/// @dev Taken and modified from Pendle V2: https://github.com/pendle-finance/pendle-core-v2-public/blob/163783b09014e515b645b83936fec32c5731d092/contracts/core/Market/MarketMathCore.sol\n/// @dev Taken and modified from Notional : https://github.com/notional-finance/contracts-v2/blob/1845605ab0d9eec9b5dd374cf7c246957b534f85/contracts/internal/markets/Market.sol\n/// @dev Naming convention:\n/// - `pt` => baseLpt: BasePool LP token\n/// - `asset` => `underlying`: underlying asset\n/// - `totalPt` => `totalBaseLptTimesN`: total BasePool LP token reserve in the pool multiplied by the number of BasePool assets (N)\n/// See NapierPool.sol for more details.\n/// - `totalAsset` => `totalUnderlying`: total underlying asset reserve in the pool\n/// - `executeTradeCore` function =>  `executeSwap` function\n/// - `calculateTrade` function => `calculateSwap` function\n/// - `getMarketPreCompute` function => `computeAmmParameters` function\n/// - `setNewMarketStateTrade` function => `_setPostPoolState` function\n/// @dev All functions in this library are view functions.\n/// @dev Changes:\n///  1) Math library dependency from LogExpMath to PRBMath etc.\n///  2) Swap functions multiply the parameter `exactPtToAccount` by N(=3) to make it equivalent to the amount of PT being swapped.\n///  3) Swap functions divide the computed underlying swap result by N.\n///  3) Remove some redundant checks (e.g. check for maturity)\n///  4) Remove some redundant variables (e.g. `totalAsset` in `MarketPreCompute`)\n///  5) Remove some redundant functions (`addLiquidity` and `removeLiquidity`)\n\n// libraries\nimport {Math} from \"@openzeppelin/contracts@4.9.3/utils/math/Math.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts@4.9.3/utils/math/SafeCast.sol\";\nimport {FixedPointMathLib} from \"./FixedPointMathLib.sol\";\nimport {SignedMath} from \"./SignedMath.sol\";\nimport {sd, ln, intoInt256} from \"@prb/math/SD59x18.sol\"; // used for logarithm operation\nimport {ud, exp, intoUint256} from \"@prb/math/UD60x18.sol\"; // used for exp operation\nimport {Errors} from \"./Errors.sol\";\n\n/// @param totalBaseLptTimesN - Reserve Curve v2 Tricrypto 3PrincipalToken Pool LP token x times N(=# of Curve v2 Pool assets) in 18 decimals\n/// @param totalUnderlying18 - Reserve underlying asset in 18 decimals\n/// @param scalarRoot - Scalar root for NapierPool (See whitepaper)\n/// @param maturity - Expiry of NapierPool (Unix timestamp)\n/// @param lnFeeRateRoot - Logarithmic fee rate root\n/// @param protocolFeePercent - Protocol fee percent (base 100)\n/// @param lastLnImpliedRate - Last ln implied rate\nstruct PoolState {\n    uint256 totalBaseLptTimesN;\n    uint256 totalUnderlying18;\n    /// immutable variables ///\n    u"
    }
  ]
}