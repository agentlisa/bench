{
  "Title": "[G-15] Create one, specific event, instead of emitting two events in a row",
  "Content": "\n**Files:** `StateTransitionManager.sol`, `Bridgehub.sol`, `Admin.sol`\n\nInstead of spending gas on emitting two events at once, it's better to create one, single event and emit it once.\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Admin.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Admin.sol#L40)\n```solidity\n40:         emit NewPendingAdmin(pendingAdmin, address(0));\n41:         emit NewAdmin(previousAdmin, pendingAdmin);\n```\n\n[File: code/contracts/ethereum/contracts/state-transition/StateTransitionManager.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/StateTransitionManager.sol#L127)\n```solidity\n127:         emit NewPendingAdmin(currentPendingAdmin, address(0));\n128:         emit NewAdmin(previousAdmin, pendingAdmin);\n```\n\n[File: code/contracts/ethereum/contracts/bridgehub/Bridgehub.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/bridgehub/Bridgehub.sol#L68)\n```solidity\n68:         emit NewPendingAdmin(currentPendingAdmin, address(0));\n69:         emit NewAdmin(previousAdmin, pendingAdmin);\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Admin.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {IAdmin} from \"../../chain-interfaces/IAdmin.sol\";\nimport {Diamond} from \"../../libraries/Diamond.sol\";\nimport {MAX_GAS_PER_TRANSACTION} from \"../../../common/Config.sol\";\nimport {FeeParams, PubdataPricingMode} from \"../ZkSyncStateTransitionStorage.sol\";\nimport {ZkSyncStateTransitionBase} from \"./ZkSyncStateTransitionBase.sol\";\nimport {IStateTransitionManager} from \"../../IStateTransitionManager.sol\";\n\n// While formally the following import is not used, it is needed to inherit documentation from it\nimport {IZkSyncStateTransitionBase} from \"../../chain-interfaces/IZkSyncStateTransitionBase.sol\";\n\n/// @title Admin Contract controls access rights for contract management.\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract AdminFacet is ZkSyncStateTransitionBase, IAdmin {\n    /// @inheritdoc IZkSyncStateTransitionBase\n    string public constant override getName = \"AdminFacet\";\n\n    /// @inheritdoc IAdmin\n    function setPendingAdmin(address _newPendingAdmin) external onlyAdmin {\n        // Save previous value into the stack to put it into the event later\n        address oldPendingAdmin = s.pendingAdmin;\n        // Change pending admin\n        s.pendingAdmin = _newPendingAdmin;\n        emit NewPendingAdmin(oldPendingAdmin, _newPendingAdmin);\n    }\n\n    /// @inheritdoc IAdmin\n    function acceptAdmin() external {\n        address pendingAdmin = s.pendingAdmin;\n        require(msg.sender == pendingAdmin, \"n4\"); // Only proposed by current admin address can claim the admin rights\n\n        address previousAdmin = s.admin;\n        s.admin = pendingAdmin;\n        delete s.pendingAdmin;\n\n        emit NewPendingAdmin(pendingAdmin, address(0));\n        emit NewAdmin(previousAdmin, pendingAdmin);\n    }\n\n    /// @inheritdoc IAdmin\n    function setValidator(address _validator, bool _active) external onlyStateTransitionManager {\n        s.validators[_validator] = _active;\n        emit ValidatorStatusUpdate(_validator, _active);\n    }\n\n    /// @inheritdoc IAdmin\n    function setPorterAvailability(bool _zkPorterIsAvailable) external onlyStateTransitionManager {\n        // Change the porter availability\n        s.zkPorterIsAvailable = _zkPorterIsAvailable;\n        emit IsPorterAvailableStatusUpdate(_zkPorterIsAvailable);\n    }\n\n    /// @inheritdoc IAdmin\n    function setPriorityTxMaxGasLimit(uint256 _newPriorityTxMaxGasLimit) external onlyStateTransitionManager {\n        require(_newPriorityTxMaxGasLimit <= MAX_GAS_PER_TRANSACTION, \"n5\");\n\n        uint256 oldPriorityTxMaxGasLimit = s.priorityTxMaxGasLimit;\n        s.priorityTxMaxGasLimit = _newPriorityTxMaxGasLimit;\n        emit NewPriorityTxMaxGasLimit(oldPriorityTxMaxGasLimit, _newPriorityTxMaxGasLimit);\n    }\n\n    /// @inheritdoc IAdmin\n    function changeFeeParams(FeeParams calldata _newFeeParams) external onlyAdminOrStateTransitionManager {\n        // Double checking that the new fee params are valid, i.e.\n        // the maximal pubdata per batch is not less than the maximal pubdata per priority transaction.\n        require(_newFeeParams.maxPubdataPerBatch >= _newFeeParams.priorityTxMaxPubdata, \"n6\");\n\n        FeeParams memory oldFeeParams = s.feeParams;\n        s.feeParams = _newFeeParams;\n\n        emit NewFeeParams(oldFeeParams, _newFeeParams);\n    }\n\n    /// @inheritdoc IAdmin\n    function setTokenMultiplier(uint128 _nominator, uint128 _denominator) external onlyAdminOrStateTransitionManager {\n        uint128 oldNominator = s.baseTokenGasPriceMultiplierNominator;\n        uint128 oldDenominator = s.baseTokenGasPriceMultiplierDenominator;\n\n        s.baseTokenGasPriceMultiplierNominator = _nominator;\n        s.baseTokenGasPriceMultiplierDenominator = _denominator;\n\n        emit NewBaseTokenMultiplier(oldNominator, oldDenominator, _nominator, _denominator);\n    }\n\n    function setValidiumMode(PubdataPricingMode _validiumMode) external onlyAdmin {\n        require(s.totalBatchesCommitted == 0, \"AdminFacet: set validium only after genesis\"); // Validium mode can be set only before the first batch is committed\n        s.feeParams.pubdataPricingMode = _validiumMode;\n        emit ValidiumModeStatusUpdate(_validiumMode);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            UPGRADE EXECUTION\n    //////////////////////////////////////////////////////////////*/\n\n    /// upgrade a specific chain\n    function upgradeChainFromVersion(\n        uint256 _oldProtocolVersion,\n        Diamond.DiamondCutData calldata _diamondCut\n    ) external onlyAdminOrStateTransitionManager {\n        bytes32 cutHashInput = keccak256(abi.encode(_diamondCut));\n        require(\n            cutHashInput == IStateTransitionManager(s.stateTransitionManager).upgradeCutHash(_oldProtocolVersion),\n            \"StateTransition: cutHash mismatch\"\n        );\n\n        require(\n            s.protocolVersion == _oldProtocolVersion,\n            \"StateTransition: protocolVersion mismatch in STC when upgrading\"\n        );\n        Diamond.diamondCut(_diamondCut);\n        emit ExecuteUpgrade(_diamondCut);\n        require(\n            s.protocolVersion > _oldProtocolVersion,\n            \"StateTransition: protocolVersion mismatch in STC after upgrading\"\n        );\n    }\n\n    /// @inheritdoc IAdmin\n    function executeUpgrade(Diamond.DiamondCutData calldata _diamondCut) external onlyStateTransitionManager {\n        Diamond.diamondCut(_diamondCut);\n        emit ExecuteUpgrade(_diamondCut);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            CONTRACT FREEZING\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IAdmin\n    function freezeDiamond() external onlyAdminOrStateTransitionManager {\n        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();\n\n        require(!diamondStorage.isFrozen, \"a9\"); // diamond proxy is frozen already\n        diamondStorage.isFrozen = true;\n\n        emit Freeze();\n    }\n\n    /// @inheritdoc IAdmin\n    function unfreezeDiamond() external onlyAdminOrStateTransitionManager {\n        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();\n\n        require(diamondStorage.isFrozen, \"a7\"); // diamond proxy is not frozen\n        diamondStorage.isFrozen = false;\n\n        emit Unfreeze();\n    }\n}"
    },
    {
      "filename": "code/contracts/ethereum/contracts/state-transition/StateTransitionManager.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {Diamond} from \"./libraries/Diamond.sol\";\nimport {DiamondProxy} from \"./chain-deps/DiamondProxy.sol\";\nimport {IAdmin} from \"./chain-interfaces/IAdmin.sol\";\nimport {IDefaultUpgrade} from \"../upgrades/IDefaultUpgrade.sol\";\nimport {IDiamondInit} from \"./chain-interfaces/IDiamondInit.sol\";\nimport {IExecutor} from \"./chain-interfaces/IExecutor.sol\";\nimport {IStateTransitionManager, StateTransitionManagerInitializeData} from \"./IStateTransitionManager.sol\";\nimport {ISystemContext} from \"./l2-deps/ISystemContext.sol\";\nimport {IZkSyncStateTransition} from \"./chain-interfaces/IZkSyncStateTransition.sol\";\nimport {L2_SYSTEM_CONTEXT_SYSTEM_CONTRACT_ADDR, L2_FORCE_DEPLOYER_ADDR} from \"../common/L2ContractAddresses.sol\";\nimport {L2CanonicalTransaction} from \"../common/Messaging.sol\";\nimport {Ownable2Step} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport {ProposedUpgrade} from \"../upgrades/BaseZkSyncUpgrade.sol\";\nimport {ReentrancyGuard} from \"../common/ReentrancyGuard.sol\";\nimport {REQUIRED_L2_GAS_PRICE_PER_PUBDATA, L2_TO_L1_LOG_SERIALIZE_SIZE, DEFAULT_L2_LOGS_TREE_ROOT_HASH, EMPTY_STRING_KECCAK, SYSTEM_UPGRADE_L2_TX_TYPE, ERA_DIAMOND_PROXY, ERA_CHAIN_ID} from \"../common/Config.sol\";\nimport {VerifierParams} from \"./chain-interfaces/IVerifier.sol\";\n\n/// @title StateTransition contract\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract StateTransitionManager is IStateTransitionManager, ReentrancyGuard, Ownable2Step {\n    /// @notice Address of the bridgehub\n    address public immutable bridgehub;\n\n    /// @notice chainId => chainContract\n    mapping(uint256 => address) public stateTransition;\n\n    /// @dev Batch hash zero, calculated at initialization\n    bytes32 public storedBatchZero;\n\n    /// @dev Stored cutData for diamond cut\n    bytes32 public initialCutHash;\n\n    /// @dev genesisUpgrade contract address, used to setChainId\n    address public genesisUpgrade;\n\n    /// @dev current protocolVersion\n    uint256 public protocolVersion;\n\n    /// @dev validatorTimelock contract address, used to setChainId\n    address public validatorTimelock;\n\n    /// @dev Stored cutData for upgrade diamond cut. protocolVersion => cutHash\n    mapping(uint256 => bytes32) public upgradeCutHash;\n\n    /// @dev used to manage non critical updates\n    address public admin;\n\n    /// @dev used to accept the admin role\n    address private pendingAdmin;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(address _bridgehub) reentrancyGuardInitializer {\n        bridgehub = _bridgehub;\n    }\n\n    /// @notice only the bridgehub can call\n    modifier onlyBridgehub() {\n        require(msg.sender == bridgehub, \"StateTransition: only bridgehub\");\n        _;\n    }\n\n    /// @notice the admin can call, for non-critical updates\n    modifier onlyOwnerOrAdmin() {\n        require(msg.sender == admin || msg.sender == owner(), \"Bridgehub: not owner or admin\");\n        _;\n    }\n\n    function getChainAdmin(uint256 _chainId) external view override returns (address) {\n        return IZkSyncStateTransition(stateTransition[_chainId]).getAdmin();\n    }\n\n    /// @dev initialize\n    function initialize(\n        StateTransitionManagerInitializeData calldata _initializeData\n    ) external reentrancyGuardInitializer {\n        require(_initializeData.governor != address(0), \"StateTransition: governor zero\");\n        _transferOwnership(_initializeData.governor);\n\n        genesisUpgrade = _initializeData.genesisUpgrade;\n        protocolVersion = _initializeData.protocolVersion;\n        validatorTimelock = _initializeData.validatorTimelock;\n\n        // We need to initialize the state hash because it is used in the commitment of the next batch\n        IExecutor.StoredBatchInfo memory batchZero = IExecutor.StoredBatchInfo(\n            0,\n            _initializeData.genesisBatchHash,\n            _initializeData.genesisIndexRepeatedStorageChanges,\n            0,\n            EMPTY_STRING_KECCAK,\n            DEFAULT_L2_LOGS_TREE_ROOT_HASH,\n            0,\n            _initializeData.genesisBatchCommitment\n        );\n        storedBatchZero = keccak256(abi.encode(batchZero));\n\n        initialCutHash = keccak256(abi.encode(_initializeData.diamondCut));\n\n        // While this does not provide a protection in the production, it is needed for local testing\n        // Length of the L2Log encoding should not be equal to the length of other L2Logs' tree nodes preimages\n        assert(L2_TO_L1_LOG_SERIALIZE_SIZE != 2 * 32);\n    }\n\n    /// @inheritdoc IStateTransitionManager\n    function setPendingAdmin(address _newPendingAdmin) external onlyOwnerOrAdmin {\n        // Save previous value into the stack to put it into the event later\n        address oldPendingAdmin = pendingAdmin;\n        // Change pending admin\n        pendingAdmin = _newPendingAdmin;\n        emit NewPendingAdmin(oldPendingAdmin, _newPendingAdmin);\n    }\n\n    /// @inheritdoc IStateTransitionManager\n    function acceptAdmin() external {\n        address currentPendingAdmin = pendingAdmin;\n        require(msg.sender == currentPendingAdmin, \"n42\"); // Only proposed by current admin address can claim the admin rights\n\n        address previousAdmin = admin;\n        admin = currentPendingAdmin;\n        delete pendingAdmin;\n\n        emit NewPendingAdmin(currentPendingAdmin, address(0));\n        emit NewAdmin(previousAdmin, pendingAdmin);\n    }\n\n    /// @dev set validatorTimelock. Cannot do it an initialization, as validatorTimelock is deployed after STM\n    function setValidatorTimelock(address _validatorTimelock) external onlyOwnerOrAdmin {\n        validatorTimelock = _validatorTimelock;\n    }\n\n    /// @dev set initial cutHash\n    function setInitialCutHash(Diamond.DiamondCutData calldata _diamondCut) external onlyOwner {\n        initialCutHash = keccak256(abi.encode(_diamondCut));\n    }\n\n    /// @dev set New Version with upgrade from old version\n    function setNewVersionUpgrade(\n        Diamond.DiamondCutData calldata _cutData,\n        uint256 _oldProtocolVersion,\n        uint256 _newProtocolVersion\n    ) external onlyOwner {\n        upgradeCutHash[_oldProtocolVersion] = keccak256(abi.encode(_cutData));\n        protocolVersion = _newProtocolVersion;\n    }\n\n    /// @dev set upgrade for some protocolVersion\n    function setUpgradeDiamondCut(\n        Diamond.DiamondCutData calldata _cutData,\n        uint256 _oldProtocolVersion\n    ) external onlyOwner {\n        upgradeCutHash[_oldProtocolVersion] = keccak256(abi.encode(_cutData));\n    }\n\n    /// @dev freezes the specified chain\n    function freezeChain(uint256 _chainId) external onlyOwner {\n        IZkSyncStateTransition(stateTransition[_chainId]).freezeDiamond();\n    }\n\n    /// @dev freezes the specified chain\n    function unfreezeChain(uint256 _chainId) external onlyOwner {\n        IZkSyncStateTransition(stateTransition[_chainId]).freezeDiamond();\n    }\n\n    /// @dev reverts batches on the specified chain\n    function revertBatches(uint256 _chainId, uint256 _newLastBatch) external onlyOwnerOrAdmin {\n        IZkSyncStateTransition(stateTransition[_chainId]).revertBatches(_newLastBatch);\n    }\n\n    /// registration\n\n    /// @dev we have to set the chainId at genesis, as blockhashzero is the same for all chains with the same chainId\n    function _setChainIdUpgrade(uint256 _chainId, address _chainContract) internal {\n        bytes memory systemContextCalldata = abi.encodeCall(ISystemContext.setChainId, (_chainId));\n        uint256[] memory uintEmptyArray;\n        bytes[] memory bytesEmptyArray;\n\n        L2CanonicalTransaction memory l2ProtocolUpgradeTx = L2CanonicalTransaction({\n            txType: SYSTEM_UPGRADE_L2_TX_TYPE,\n            from: uint256(uint160(L2_FORCE_DEPLOYER_ADDR)),\n            to: uint256(uint160(L2_SYSTEM_CONTEXT_SYSTEM_CONTRACT_ADDR)),\n            gasLimit: $(PRIORITY_TX_MAX_GAS_LIMIT),\n            gasPerPubdataByteLimit: REQUIRED_L2_GAS_PRICE_PER_PUBDATA,\n            maxFeePerGas: uint256(0),\n            maxPriorityFeePerGas: uint256(0),\n            paymaster: uint256(0),\n            // Note, that the priority operation id is used as \"nonce\" for L1->L2 transactions\n            nonce: protocolVersion,\n            value: 0,\n            reserved: [uint256(0), 0, 0, 0],\n            data: systemContextCalldata,\n            signature: new bytes(0),\n            factoryDeps: uintEmptyArray,\n            paymasterInput: new bytes(0),\n            reservedDynamic: new bytes(0)\n        });\n\n        ProposedUpgrade memory proposedUpgrade = ProposedUpgrade({\n            l2ProtocolUpgradeTx: l2ProtocolUpgradeTx,\n            factoryDeps: bytesEmptyArray,\n            bootloaderHash: bytes32(0),\n            defaultAccountHash: bytes32(0),\n            verifier: address(0),\n            verifierParams: VerifierParams({\n                recursionNodeLevelVkHash: bytes32(0),\n                recursionLeafLevelVkHash: bytes32(0),\n                recursionCircuitsSetVksHash: bytes32(0)\n            }),\n            l1ContractsUpgradeCalldata: new bytes(0),\n            postUpgradeCalldata: new bytes(0),\n            upgradeTimestamp: 0,\n            newProtocolVersion: protocolVersion\n        });\n\n        Diamond.FacetCut[] memory emptyArray;\n        Diamond.DiamondCutData memory cutData = Diamond.DiamondCutData({\n            facetCuts: emptyArray,\n            initAddress: genesisUpgrade,\n            initCalldata: abi.encodeCall(IDefaultUpgrade.upgrade, (proposedUpgrade))\n        });\n\n        IAdmin(_chainContract).executeUpgrade(cutData);\n        emit SetChainIdUpgrade(_chainContract, l2ProtocolUpgradeTx, protocolVersion);\n    }\n\n    function registerAlreadyDeployedStateTransition(\n        uint256 _chainId,\n        address _stateTransitionContract\n    ) external onlyOwner {\n        stateTransition[_chainId] = _stateTransitionContract;\n        emit StateTransitionNewChain(_chainId, _stateTransitionContract);\n    }\n\n    /// @notice called by Bridgehub when a chain registers\n    function createNewChain(\n        uint256 _chainId,\n        address _baseToken,\n        address _sharedBridge,\n        address _admin,\n        bytes calldata _diamondCut\n    ) external onlyBridgehub {\n        if (stateTransition[_chainId] != address(0)) {\n            // StateTransition chain already registered\n            return;\n        }\n\n        // check not registered\n        Diamond.DiamondCutData memory diamondCut = abi.decode(_diamondCut, (Diamond.DiamondCutData));\n\n        // check input\n        bytes32 cutHashInput = keccak256(_diamondCut);\n        require(cutHashInput == initialCutHash, \"StateTransition: initial cutHash mismatch\");\n\n        // construct init data\n        bytes memory initData;\n        /// all together 4+9*32=292 bytes\n        initData = bytes.concat(\n            IDiamondInit.initialize.selector,\n            bytes32(_chainId),\n            bytes32(uint256(uint160(bridgehub))),\n            bytes32(uint256(uint160(address(this)))),\n            bytes32(uint256(protocolVersion)),\n            bytes32(uint256(uint160(_admin))),\n            bytes32(uint256(uint160(validatorTimelock))),\n            bytes32(uint256(uint160(_baseToken))),\n            bytes32(uint256(uint160(_sharedBridge))),\n            bytes32(storedBatchZero),\n            diamondCut.initCalldata\n        );\n\n        diamondCut.initCalldata = initData;\n        // deploy stateTransitionContract\n        DiamondProxy stateTransitionContract = new DiamondProxy{salt: bytes32(0)}(block.chainid, diamondCut);\n\n        // save data\n        address stateTransitionAddress = address(stateTransitionContract);\n\n        stateTransition[_chainId] = stateTransitionAddress;\n\n        // set chainId in VM\n        _setChainIdUpgrade(_chainId, stateTransitionAddress);\n\n        emit StateTransitionNewChain(_chainId, stateTransitionAddress);\n    }\n}"
    },
    {
      "filename": "code/contracts/ethereum/contracts/bridgehub/Bridgehub.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {Ownable2Step} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\n\nimport \"./IBridgehub.sol\";\nimport \"../bridge/interfaces/IL1SharedBridge.sol\";\nimport \"../state-transition/IStateTransitionManager.sol\";\nimport \"../common/ReentrancyGuard.sol\";\nimport \"../state-transition/chain-interfaces/IZkSyncStateTransition.sol\";\nimport {ETH_TOKEN_ADDRESS, TWO_BRIDGES_MAGIC_VALUE, BRIDGEHUB_MIN_SECOND_BRIDGE_ADDRESS} from \"../common/Config.sol\";\nimport {BridgehubL2TransactionRequest} from \"../common/Messaging.sol\";\nimport \"../vendor/AddressAliasHelper.sol\";\n\ncontract Bridgehub is IBridgehub, ReentrancyGuard, Ownable2Step {\n    /// @notice all the ether is held by the weth bridge\n    IL1SharedBridge public sharedBridge;\n\n    /// @notice we store registered stateTransitionManagers\n    mapping(address _stateTransitionManager => bool) public stateTransitionManagerIsRegistered;\n    /// @notice we store registered tokens (for arbitrary base token)\n    mapping(address _token => bool) public tokenIsRegistered;\n\n    /// @notice chainID => StateTransitionManager contract address, storing StateTransitionManager\n    mapping(uint256 _chainId => address) public stateTransitionManager;\n\n    /// @notice chainID => baseToken contract address, storing baseToken\n    mapping(uint256 _chainId => address) public baseToken;\n\n    /// @dev used to manage non critical updates\n    address public admin;\n\n    /// @dev used to accept the admin role\n    address private pendingAdmin;\n\n    /// @notice to avoid parity hack\n    constructor() reentrancyGuardInitializer {}\n\n    /// @notice used to initialize the contract\n    function initialize(address _owner) external reentrancyGuardInitializer {\n        _transferOwnership(_owner);\n    }\n\n    modifier onlyOwnerOrAdmin() {\n        require(msg.sender == admin || msg.sender == owner(), \"Bridgehub: not owner or admin\");\n        _;\n    }\n\n    /// @inheritdoc IBridgehub\n    function setPendingAdmin(address _newPendingAdmin) external onlyOwnerOrAdmin {\n        // Save previous value into the stack to put it into the event later\n        address oldPendingAdmin = pendingAdmin;\n        // Change pending admin\n        pendingAdmin = _newPendingAdmin;\n        emit NewPendingAdmin(oldPendingAdmin, _newPendingAdmin);\n    }\n\n    /// @inheritdoc IBridgehub\n    function acceptAdmin() external {\n        address currentPendingAdmin = pendingAdmin;\n        require(msg.sender == currentPendingAdmin, \"n42\"); // Only proposed by current admin address can claim the admin rights\n\n        address previousAdmin = admin;\n        admin = currentPendingAdmin;\n        delete pendingAdmin;\n\n        emit NewPendingAdmin(currentPendingAdmin, address(0));\n        emit NewAdmin(previousAdmin, pendingAdmin);\n    }\n\n    ///// Getters\n\n    /// @notice return the state transition chain contract for a chainId\n    function getStateTransition(uint256 _chainId) public view returns (address) {\n        return IStateTransitionManager(stateTransitionManager[_chainId]).stateTransition(_chainId);\n    }\n\n    //// Registry\n\n    /// @notice State Transition can be any contract with the appropriate interface/functionality\n    function addStateTransitionManager(address _stateTransitionManager) external onlyOwner {\n        require(\n            !stateTransitionManagerIsRegistered[_stateTransitionManager],\n            \"Bridgehub: state transition already registered\"\n        );\n        stateTransitionManagerIsRegistered[_stateTransitionManager] = true;\n    }\n\n    /// @notice State Transition can be any contract with the appropriate interface/functionality\n    /// @notice this stops new Chains from using the STF, old chains are not affected\n    function removeStateTransitionManager(address _stateTransitionManager) external onlyOwner {\n        require(\n            stateTransitionManagerIsRegistered[_stateTransitionManager],\n            \"Bridgehub: state transition not registered yet\"\n        );\n        stateTransitionManagerIsRegistered[_stateTransitionManager] = false;\n    }\n\n    /// @notice token can be any contract with the appropriate interface/functionality\n    function addToken(address _token) external onlyOwner {\n        require(!tokenIsRegistered[_token], \"Bridgehub: token already registered\");\n        tokenIsRegistered[_token] = true;\n    }\n\n    /// @notice To set shared bridge, only Owner. Not done in initialize, as\n    /// the order of deployment is Bridgehub, Shared bridge, and then we call this\n    function setSharedBridge(address _sharedBridge) external onlyOwner {\n        sharedBridge = IL1SharedBridge(_sharedBridge);\n    }\n\n    /// @notice register new chain\n    /// @notice for Eth the baseToken address is 1\n    function createNewChain(\n        uint256 _chainId,\n        address _stateTransitionManager,\n        address _baseToken,\n        uint256, //_salt\n        address _admin,\n        bytes calldata _initData\n    ) external onlyOwnerOrAdmin nonReentrant returns (uint256 chainId) {\n        require(_chainId != 0, \"Bridgehub: chainId cannot be 0\");\n        require(_chainId <= type(uint48).max, \"Bridgehub: chainId too large\");\n\n        require(\n            stateTransitionManagerIsRegistered[_stateTransitionManager],\n            \"Bridgehub: state transition not registered\"\n        );\n        require(tokenIsRegistered[_baseToken], \"Bridgehub: token not registered\");\n        require(address(sharedBridge) != address(0), \"Bridgehub: weth bridge not set\");\n\n        require(stateTransitionManager[_chainId] == address(0), \"Bridgehub: chainId already registered\");\n\n        stateTransitionManager[_chainId] = _stateTransitionManager;\n        baseToken[_chainId] = _baseToken;\n\n        IStateTransitionManager(_stateTransitionManager).createNewChain(\n            _chainId,\n            _baseToken,\n            address(sharedBridge),\n            _admin,\n            _initData\n        );\n\n        emit NewChain(_chainId, _stateTransitionManager, _admin);\n        return _chainId;\n    }\n\n    //// Mailbox forwarder\n\n    /// @notice forwards function call to Mailbox based on ChainId\n    function proveL2MessageInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view override returns (bool) {\n        address stateTransition = getStateTransition(_chainId);\n        return IZkSyncStateTransition(stateTransition).proveL2MessageInclusion(_batchNumber, _index, _message, _proof);\n    }\n\n    /// @notice forwards function call to Mailbox based on ChainId\n    function proveL2LogInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view override returns (bool) {\n        address stateTransition = getStateTransition(_chainId);\n        return IZkSyncStateTransition(stateTransition).proveL2LogInclusion(_batchNumber, _index, _log, _proof);\n    }\n\n    /// @notice forwards function call to Mailbox based on ChainId\n    function proveL1ToL2TransactionStatus(\n        uint256 _chainId,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view override returns (bool) {\n        address stateTransition = getStateTransition(_chainId);\n        return\n            IZkSyncStateTransition(stateTransition).proveL1ToL2TransactionStatus(\n                _l2TxHash,\n                _l2BatchNumber,\n                _l2MessageIndex,\n                _l2TxNumberInBatch,\n                _merkleProof,\n                _status\n            );\n    }\n\n    /// @notice forwards function call to Mailbox based on ChainId\n    function l2TransactionBaseCost(\n        uint256 _chainId,\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256) {\n        address stateTransition = getStateTransition(_chainId);\n        return\n            IZkSyncStateTransition(stateTransition).l2TransactionBaseCost(\n                _gasPrice,\n                _l2GasLimit,\n                _l2GasPerPubdataByteLimit\n            );\n    }\n\n    /// @notice the mailbox is called directly after the sharedBridge received the deposit\n    /// this assumes that either ether is the base token or\n    /// the msg.sender has approved mintValue allowance for the sharedBridge.\n    /// This means this is not ideal for contract calls, as the contract would have to handle token allowance of the base Token\n    function requestL2TransactionDirect(\n        L2TransactionRequestDirect calldata _request\n    ) external payable override nonReentrant returns (bytes32 canonicalTxHash) {\n        {\n            address token = baseToken[_request.chainId];\n            if (token == ETH_TOKEN_ADDRESS) {\n                require(msg.value == _request.mintValue, \"Bridgehub: msg.value mismatch 1\");\n            } else {\n                require(msg.value == 0, \"Bridgehub: non-eth bridge with msg.value\");\n            }\n\n            sharedBridge.bridgehubDepositBaseToken{value: msg.value}(\n                _request.chainId,\n                msg.sender,\n                token,\n                _request.mintValue\n            );\n        }\n\n        address stateTransition = getStateTransition(_request.chainId);\n        address refundRecipient = _actualRefundRecipient(_request.refundRecipient);\n        canonicalTxHash = IZkSyncStateTransition(stateTransition).bridgehubRequestL2Transaction(\n            BridgehubL2TransactionRequest({\n                sender: msg.sender,\n                contractL2: _request.l2Contract,\n                mintValue: _request.mintValue,\n                l2Value: _request.l2Value,\n                l2Calldata: _request.l2Calldata,\n                l2GasLimit: _request.l2GasLimit,\n                l2GasPerPubdataByteLimit: _request.l2GasPerPubdataByteLimit,\n                factoryDeps: _request.factoryDeps,\n                refundRecipient: refundRecipient\n            })\n        );\n    }\n\n    /// @notice After depositing funds to the sharedBridge, the secondBridge is called\n    ///  to return the actual L2 message which is sent to the Mailbox.\n    ///  This assumes that either ether is the base token or\n    ///  the msg.sender has approved the sharedBridge with the mintValue,\n    ///  and also the necessary approvals are given for the second bridge.\n    /// @notice The logic of this bridge is to allow easy depositing for bridges.\n    /// Each contract that handles the users ERC20 tokens needs approvals from the user, this contract allows\n    /// the user to approve for each token only its respective bridge\n    /// @notice This function is great for contract calls to L2, the secondBridge can be any contract.\n    function requestL2TransactionTwoBridges(\n        L2TransactionRequestTwoBridgesOuter calldata _request\n    ) external payable override nonReentrant returns (bytes32 canonicalTxHash) {\n        {\n            address token = baseToken[_request.chainId];\n            uint256 baseTokenMsgValue;\n            if (token == ETH_TOKEN_ADDRESS) {\n                require(\n                    msg.value == _request.mintValue + _request.secondBridgeValue,\n                    \"Bridgehub: msg.value mismatch 2\"\n                );\n                baseTokenMsgValue = _request.mintValue;\n            } else {\n                require(msg.value == _request.secondBridgeValue, \"Bridgehub: msg.value mismatch 3\");\n                baseTokenMsgValue = 0;\n            }\n            sharedBridge.bridgehubDepositBaseToken{value: baseTokenMsgValue}(\n                _request.chainId,\n                msg.sender,\n                token,\n                _request.mintValue\n            );\n        }\n\n        address stateTransition = getStateTransition(_request.chainId);\n\n        L2TransactionRequestTwoBridgesInner memory outputRequest = IL1SharedBridge(_request.secondBridgeAddress)\n            .bridgehubDeposit{value: _request.secondBridgeValue}(\n            _request.chainId,\n            msg.sender,\n            _request.l2Value,\n            _request.secondBridgeCalldata\n        );\n\n        require(outputRequest.magicValue == TWO_BRIDGES_MAGIC_VALUE, \"Bridgehub: magic value mismatch\");\n\n        address refundRecipient = _actualRefundRecipient(_request.refundRecipient);\n\n        require(\n            _request.secondBridgeAddress > BRIDGEHUB_MIN_SECOND_BRIDGE_ADDRESS,\n            \"Bridgehub: second bridge address too low\"\n        ); // to avoid calls to precompiles\n        canonicalTxHash = IZkSyncStateTransition(stateTransition).bridgehubRequestL2Transaction(\n            BridgehubL2TransactionRequest({\n                sender: _request.secondBridgeAddress,\n                contractL2: outputRequest.l2Contract,\n                mintValue: _request.mintValue,\n                l2Value: _request.l2Value,\n                l2Calldata: outputRequest.l2Calldata,\n                l2GasLimit: _request.l2GasLimit,\n                l2GasPerPubdataByteLimit: _request.l2GasPerPubdataByteLimit,\n                factoryDeps: outputRequest.factoryDeps,\n                refundRecipient: refundRecipient\n            })\n        );\n\n        IL1SharedBridge(_request.secondBridgeAddress).bridgehubConfirmL2Transaction(\n            _request.chainId,\n            outputRequest.txDataHash,\n            canonicalTxHash\n        );\n    }\n\n    function _actualRefundRecipient(address _refundRecipient) internal view returns (address _recipient) {\n        if (_refundRecipient == address(0)) {\n            // If the `_refundRecipient` is not provided, we use the `msg.sender` as the recipient.\n            _recipient = msg.sender == tx.origin ? msg.sender : AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n        } else if (_refundRecipient.code.length > 0) {\n            // If the `_refundRecipient` is a smart contract, we apply the L1 to L2 alias to prevent foot guns.\n            _recipient = AddressAliasHelper.applyL1ToL2Alias(_refundRecipient);\n        } else {\n            _recipient = _refundRecipient;\n        }\n    }\n}"
    }
  ]
}