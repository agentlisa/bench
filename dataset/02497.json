{
  "Title": "M-22: Memorializing an NFT position on the same bucket of a previously memorialized NFT locks redemption",
  "Content": "# Issue M-22: Memorializing an NFT position on the same bucket of a previously memorialized NFT locks redemption \n\nSource: https://github.com/sherlock-audit/2023-01-ajna-judging/issues/13 \n\n## Found by \nMalfurionWhitehat\n\n## Summary\n\nMemorializing a position as an NFT on the same bucket of an existing memorialized position will not allow any of the owners to directly redeem it back later.\n\n## Vulnerability Detail\n\nThis issue happens because, after a position is memorialized on the `PositionManager`, this contract will centralize LP positions from different users, but these will be mapped to the same address from the point of view of Ajna pools (different users will be mapped as the same `lender` from the point of view of a `Pool`). \n\nIf more than one user has memorialized a position to the same bucket index, when attempting to `PositionManager.redeemPositions`, the call to [`pool.transferLPs`](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/PositionManager.sol#L311) will revert with [`NoAllowance`](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/LenderActions.sol#L538), as `LenderActions` does not allow a transfer with value lower than the total `lenderLpBalance`.\n\nBecause of that, any of the users' that share a bucket `redeemPositions` calls will fail.\n\n## Impact\n\nAlthough users that share a bucket with memorialized positions are not able to direct redeem their positions, they can eventually get their LPs back with a specific set of actions.\n\nBy first calling `PositionManager.moveLiquidity` to a bucket _without any other LPs_ managed by `PositionsManager` (since `LenderActions.moveQuoteToken` accepts moving less liquidity than the total a LP balance for a specific bucket), and then calling `PositionManager.redeemPositions`, LP-ers will be able to redeem their positions back. Because of this possibility, this is a Medium-severity issue.\n\n## Code Snippet\n\n```diff\ndiff --git a/contracts/tests/forge/PositionManager.t.sol b/contracts/tests/forge/PositionManager.t.sol\nindex 5e691fc..5d5e822 100644\n--- a/contracts/tests/forge/PositionManager.t.sol\n+++ b/contracts/tests/forge/PositionManager.t.sol\n@@ -186,6 +186,91 @@ contract PositionManagerERC20PoolTest is PositionManagerERC20PoolHelperContract\n         assertTrue(_positionManager.isIndexInPosition(tokenId, 2552));\n     }\n \n+    function testMemorializePositionsTwoAccountsSameBucket() external {\n+        address alice = makeAddr(\"alice\");\n+        address bob = makeAddr(\"bob\");\n+        uint256 mintAmount  = 10_000 * 1e18;\n+\n+        uint256 lpBalance;\n+        uint256 depositTime;\n+\n+        _mintQuoteAndApproveManagerTokens(alice, mintAmount);\n+        _mintQuoteAndApproveManagerTokens(bob, mintAmount);\n+\n+        // call pool contract directly to add quote tokens\n+        uint256[] memory indexes = new uint256[](1);\n+        indexes[0] = 2550;\n+\n+        // alice adds liquidity now\n+        _addInitialLiquidity(\n+            {\n+                from:   alice,\n+                amount: 3_000 * 1e18,\n+                index:  indexes[0]\n+            }\n+        );\n+        (lpBalance, depositTime) = _pool.lenderInfo(indexes[0], alice);\n+        uint256 aliceDepositTime = block.timestamp;\n+        assertEq(lpBalance, 3_000 * 1e27);\n+        assertEq(depositTime, aliceDepositTime);\n+\n+        // bob adds liquidity later\n+        skip(1 hours);\n+        _addInitialLiquidity(\n+            {\n+                from:   bob,\n+                amount: 3_000 * 1e18,\n+                index:  indexes[0]\n+            }\n+        );\n+        (lpBalance, depositTime) = _pool.lenderInfo(indexes[0], bob);\n+        assertEq(lpBalance, 3_000 * 1e27);\n+        assertEq(depositTime, aliceDepositTime + 1 hours);\n+\n+\n+        // bob memorializes first, alice memorializes second\n+        address[] memory addresses = new address[](2);\n+        addresses[0] = bob;\n+        addresses[1] = alice;\n+        uint256[] memory tokenIds = new uint256[](2);\n+\n+        // bob and alice mint an NFT to later memorialize existing positions into\n+        tokenIds[0] = _mintNFT(bob, bob, address(_pool));\n+        assertFalse(_positionManager.isIndexInPosition(tokenIds[0], 2550));\n+        tokenIds[1] = _mintNFT(alice, alice, address(_pool));\n+        assertFalse(_positionManager.isIndexInPosition(tokenIds[1], 2550));\n+\n+        for(uint256 i = 0; i < addresses.length; ++i) {\n+            // construct memorialize params struct\n+            IPositionManagerOwnerActions.MemorializePositionsParams memory memorializeParams = IPositionManagerOwnerActions.MemorializePositionsParams(\n+                tokenIds[i], indexes\n+            );\n+\n+            // allow position manager to take ownership of the position\n+            changePrank(addresses[i]);\n+            _pool.approveLpOwnership(address(_positionManager), indexes[0], 3_000 * 1e27);\n+\n+            // memorialize quote tokens into minted NFT\n+            vm.expectEmit(true, true, true, true);\n+            emit MemorializePosition(addresses[i], tokenIds[i]);\n+            vm.expectEmit(true, true, true, true);\n+            emit TransferLPTokens(addresses[i], address(_positionManager), indexes, 3_000 * 1e27);\n+\n+            _positionManager.memorializePositions(memorializeParams);\n+        }\n+\n+        // now both redeem\n+        // will revert\n+        for(uint256 i = 0; i < addresses.length; ++i) {\n+            // construct memorialize params struct\n+            IPositionManagerOwnerActions.RedeemPositionsParams memory params = IPositionManagerOwnerActions.RedeemPositionsParams(\n+                tokenIds[i], address(_pool), indexes\n+            );\n+            changePrank(addresses[i]);\n+            _positionManager.reedemPositions(params);\n+        }\n+    }\n+\n     function testRememorializePositions() external {\n         address testAddress = makeAddr(\"testAddress\");\n         uint256 mintAmount  = 50_000 * 1e18;\n\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThere are some possible alternatives to solving this issue.\n\n1. Allow `LenderActions.transferLPs` to transfer an amount different than the total LP balance. Appropriate care must be taken with [`approve/transfer` attack vectors](https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit#), that do not exist now as approvals are always exact and cleared after every transfer, but they may become important if the this flow is refactored.\n2. Reconsider the `PositionsManager` architecture and the way the LP balances are stored on the Ajna protocol. Since positions are not tokenized by default, but instead are stored on state variables on each pool, it is arguably more complex to reason about transferring positions between two users. Conversely, the ERC-20 and ERC-721 standards already provide straightforward methods for minting/burning/sending tokens for accounts. A suggestion is, for example, to remove the optionality of NFT minting through another independent contract (the `PositionManager.sol`), and instead to refactor the Ajna pools so that every position is an ERC-721 NFT minted directly by the `Pool.sol`.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/32",
  "Code": [
    {
      "filename": "contracts/src/PositionManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport { ERC20 }           from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport { IERC20 }          from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { ERC721 }          from '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport { EnumerableSet }   from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport { Multicall }       from '@openzeppelin/contracts/utils/Multicall.sol';\nimport { ReentrancyGuard } from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport { SafeERC20 }       from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport { IPool }                        from './interfaces/pool/IPool.sol';\nimport { IPositionManager }             from './interfaces/position/IPositionManager.sol';\nimport { IPositionManagerOwnerActions } from './interfaces/position/IPositionManagerOwnerActions.sol';\nimport { IPositionManagerDerivedState } from './interfaces/position/IPositionManagerDerivedState.sol';\n\nimport { ERC20PoolFactory }  from './ERC20PoolFactory.sol';\nimport { ERC721PoolFactory } from './ERC721PoolFactory.sol';\n\nimport { PermitERC721 } from './base/PermitERC721.sol';\n\nimport {\n    _lpsToQuoteToken,\n    _priceAt\n}                      from './libraries/helpers/PoolHelper.sol';\nimport { tokenSymbol } from './libraries/helpers/SafeTokenNamer.sol';\n\nimport { PositionNFTSVG } from './libraries/external/PositionNFTSVG.sol';\n\n/**\n *  @title  Position Manager Contract\n *  @notice Used by Pool lenders to optionally mint NFT that represents their positions.\n *          Lenders can:\n *          - mint positions NFT token for a specific pool\n *          - memorialize positions for given buckets\n *          - move liquidity in pool\n *          - redeem positions for given buckets\n *          - burn positions NFT\n */\ncontract PositionManager is ERC721, PermitERC721, IPositionManager, Multicall, ReentrancyGuard {\n\n    using EnumerableSet for EnumerableSet.UintSet;\n    using SafeERC20     for ERC20;\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    mapping(uint256 => address)                     public override poolKey;     // token id => ajna pool address for which token was minted\n    mapping(uint256 => mapping(uint256 => uint256)) public override positionLPs; // token id => bucket index => LPs\n\n    mapping(uint256 => uint96)                internal nonces;          // token id => nonce value used for permit\n    mapping(uint256 => EnumerableSet.UintSet) internal positionIndexes; // token id => bucket indexes associated with position\n\n    uint176 private _nextId = 1; // id of the next token that will be minted. Skips 0\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    ERC20PoolFactory  private immutable erc20PoolFactory;  // The ERC20 pools factory contract, used to check if address is an Ajna pool\n    ERC721PoolFactory private immutable erc721PoolFactory; // The ERC721 pools factory contract, used to check if address is an Ajna pool\n\n    /*****************/\n    /*** Modifiers ***/\n    /*****************/\n\n    modifier mayInteract(address pool_, uint256 tokenId_) {\n\n        // revert if token id is not a valid / minted id\n        _requireMinted(tokenId_);\n\n        // revert if sender is not owner of or entitled to operate on token id\n        if (!_isApprovedOrOwner(msg.sender, tokenId_)) revert NoAuth();\n\n        // revert if the token id is not minted for given pool address\n        if (pool_ != poolKey[tokenId_]) revert WrongPool();\n\n        _;\n    }\n\n    /*******************/\n    /*** Constructor ***/\n    /*******************/\n\n    constructor(\n        ERC20PoolFactory erc20Factory_,\n        ERC721PoolFactory erc721Factory_\n    ) PermitERC721(\"Ajna Positions NFT-V1\", \"AJNA-V1-POS\", \"1\") {\n        erc20PoolFactory  = erc20Factory_;\n        erc721PoolFactory = erc721Factory_;\n    }\n\n    /********************************/\n    /*** Owner External Functions ***/\n    /********************************/\n\n    /**\n     *  @inheritdoc IPositionManagerOwnerActions\n     *  @dev write state:\n     *          - nonces: remove tokenId nonce\n     *          - poolKey: remove tokenId => pool mapping\n     *  @dev revert on:\n     *          - mayInteract:\n     *              - token id is not a valid / minted id\n     *              - sender is not owner NoAuth()\n     *              - token id not minted for given pool WrongPool()\n     *          - positions token to burn has liquidity LiquidityNotRemoved()\n     *  @dev emit events:\n     *          - Burn\n     */\n    function burn(\n        BurnParams calldata params_\n    ) external override mayInteract(params_.pool, params_.tokenId) {\n        // revert if trying to burn an positions token that still has liquidity\n        if (positionIndexes[params_.tokenId].length() != 0) revert LiquidityNotRemoved();\n\n        // remove permit nonces and pool mapping for burned token\n        delete nonces[params_.tokenId];\n        delete poolKey[params_.tokenId];\n\n        emit Burn(msg.sender, params_.tokenId);\n\n        _burn(params_.tokenId);\n    }\n\n    /**\n     *  @inheritdoc IPositionManagerOwnerActions\n     *  @dev External calls to Pool contract:\n     *          - lenderInfo(): get lender position in bucket\n     *          - transferLPs(): transfer LPs ownership to PositionManager contracts\n     *  @dev write state:\n     *          - positionIndexes: add bucket index\n     *          - positionLPs: update tokenId => bucket id mapping\n     *  @dev revert on:\n     *          - positions token to burn has liquidity LiquidityNotRemoved()\n     *  @dev emit events:\n     *          - MemorializePosition\n     */\n    function memorializePositions(\n        MemorializePositionsParams calldata params_\n    ) external override {\n        EnumerableSet.UintSet storage positionIndex = positionIndexes[params_.tokenId];\n\n        IPool pool = IPool(poolKey[params_.tokenId]);\n\n        address owner = ownerOf(params_.tokenId);\n\n        uint256 indexesLength = params_.indexes.length;\n\n        for (uint256 i = 0; i < indexesLength; ) {\n\n            // record bucket index at which a position has added liquidity\n            // slither-disable-next-line unused-return\n            positionIndex.add(params_.indexes[i]);\n\n            (uint256 lpBalance,) = pool.lenderInfo(params_.indexes[i], owner);\n\n            // update token position LPs\n            positionLPs[params_.tokenId][params_.indexes[i]] += lpBalance;\n\n            unchecked { ++i; }\n        }\n\n        emit MemorializePosition(owner, params_.tokenId);\n\n        // update pool lp token accounting and transfer ownership of lp tokens to PositionManager contract\n        pool.transferLPs(owner, address(this), params_.indexes);\n    }\n\n    /**\n     *  @inheritdoc IPositionManagerOwnerActions\n     *  @dev write state:\n     *          - poolKey: update tokenId => pool mapping\n     *  @dev revert on:\n     *          - provided pool not valid NotAjnaPool()\n     *  @dev emit events:\n     *          - Mint\n     */\n    function mint(\n        MintParams calldata params_\n    ) external override returns (uint256 tokenId_) {\n        tokenId_ = _nextId++;\n\n        // revert if the address is not a valid Ajna pool\n        if (!_isAjnaPool(params_.pool, params_.poolSubsetHash)) revert NotAjnaPool();\n\n        // record which pool the tokenId was minted in\n        poolKey[tokenId_] = params_.pool;\n\n        emit Mint(params_.recipient, params_.pool, tokenId_);\n\n        _safeMint(params_.recipient, tokenId_);\n    }\n\n    /**\n     *  @inheritdoc IPositionManagerOwnerActions\n     *  @dev External calls to Pool contract:\n     *          - bucketInfo(): get from bucket info\n     *          - moveQuoteToken(): move liquidity between buckets\n     *  @dev write state:\n     *          - positionIndexes: remove from bucket index\n     *          - positionIndexes: add to bucket index\n     *          - positionLPs: decrement from bucket LPs\n     *          - positionLPs: increment to bucket LPs\n     *  @dev revert on:\n     *          - mayInteract:\n     *              - token id is not a valid / minted id\n     *              - sender is not owner NoAuth()\n     *              - token id not minted for given pool WrongPool()\n     *          - positions token to burn has liquidity LiquidityNotRemoved()\n     *  @dev emit events:\n     *          - MoveLiquidity\n     */\n    function moveLiquidity(\n        MoveLiquidityParams calldata params_\n    ) external override mayInteract(params_.pool, params_.tokenId) nonReentrant {\n        // retrieve info of bucket from which liquidity is moved  \n        (\n            uint256 bucketLPs,\n            uint256 bucketCollateral,\n            ,\n            uint256 bucketDeposit,\n        ) = IPool(params_.pool).bucketInfo(params_.fromIndex);\n\n        // calculate the max amount of quote tokens that can be moved, given the tracked LPs\n        uint256 maxQuote = _lpsToQuoteToken(\n            bucketLPs,\n            bucketCollateral,\n            bucketDeposit,\n            positionLPs[params_.tokenId][params_.fromIndex],\n            bucketDeposit,\n            _priceAt(params_.fromIndex)\n        );\n\n        EnumerableSet.UintSet storage positionIndex = positionIndexes[params_.tokenId];\n\n        // remove bucket index from which liquidity is moved from tracked positions\n        if (!positionIndex.remove(params_.fromIndex)) revert RemoveLiquidityFailed();\n\n        // update bucket set at which a position has liquidity\n        // slither-disable-next-line unused-return\n        positionIndex.add(params_.toIndex);\n\n        emit MoveLiquidity(ownerOf(params_.tokenId), params_.tokenId);\n\n        // move quote tokens in pool\n        (\n            uint256 lpbAmountFrom,\n            uint256 lpbAmountTo\n        ) = IPool(params_.pool).moveQuoteToken(\n            maxQuote,\n            params_.fromIndex,\n            params_.toIndex\n        );\n\n        // update position LPs state\n        positionLPs[params_.tokenId][params_.fromIndex] -= lpbAmountFrom;\n        positionLPs[params_.tokenId][params_.toIndex]   += lpbAmountTo;\n    }\n\n    /**\n     *  @inheritdoc IPositionManagerOwnerActions\n     *  @dev External calls to Pool contract:\n     *          - approveLpOwnership(): approve ownership for transfer\n     *          - transferLPs(): transfer LPs ownership from PositionManager contract\n     *  @dev write state:\n     *          - positionIndexes: remove from bucket index\n     *          - positionLPs: delete bucket LPs\n     *  @dev revert on:\n     *          - mayInteract:\n     *              - token id is not a valid / minted id\n     *              - sender is not owner NoAuth()\n     *              - token id not minted for given pool WrongPool()\n     *          - position not tracked RemoveLiquidityFailed()\n     *  @dev emit events:\n     *          - RedeemPosition\n     */\n    function reedemPositions(\n        RedeemPositionsParams calldata params_\n    ) external override mayInteract(params_.pool, params_.tokenId) {\n\n        EnumerableSet.UintSet storage positionIndex = positionIndexes[params_.tokenId];\n\n        IPool pool = IPool(poolKey[params_.tokenId]);\n\n        uint256 indexesLength = params_.indexes.length;\n\n        address owner = ownerOf(params_.tokenId);\n\n        for (uint256 i = 0; i < indexesLength; ) {\n\n            // remove bucket index at which a position has added liquidity\n            if (!positionIndex.remove(params_.indexes[i])) revert RemoveLiquidityFailed();\n\n            uint256 lpAmount = positionLPs[params_.tokenId][params_.indexes[i]];\n\n            // remove LPs tracked by position manager at bucket index\n            delete positionLPs[params_.tokenId][params_.indexes[i]];\n\n            // approve owner to take over the LPs ownership (required for transferLPs pool call)\n            pool.approveLpOwnership(owner, params_.indexes[i], lpAmount);\n\n            unchecked { ++i; }\n        }\n\n        emit RedeemPosition(owner, params_.tokenId);\n\n        // update pool lp token accounting and transfer ownership of lp tokens from PositionManager contract\n        pool.transferLPs(address(this), owner, params_.indexes);\n    }\n\n    /**************************/\n    /*** Internal Functions ***/\n    /**************************/\n\n    /**\n     *  @dev    Retrieves token's next nonce for permit.\n     *  @param  tokenId_ Address of the Ajna pool to retrieve accumulators of.\n     *  @return Incremented token permit nonce.\n     */\n    function _getAndIncrementNonce(\n        uint256 tokenId_\n    ) internal override returns (uint256) {\n        return uint256(nonces[tokenId_]++);\n    }\n\n    /**\n     *  @dev    Checks that a provided pool address was deployed by an Ajna factory.\n     *  @param  pool_       Address of the Ajna pool.\n     *  @param  subsetHash_ Factory's subset hash pool.\n     *  @return True if a valid Ajna pool false otherwise.\n     */\n    function _isAjnaPool(\n        address pool_,\n        bytes32 subsetHash_\n    ) internal view returns (bool) {\n        address collateralAddress = IPool(pool_).collateralAddress();\n        address quoteAddress      = IPool(pool_).quoteTokenAddress();\n\n        address erc20DeployedPoolAddress  = erc20PoolFactory.deployedPools(subsetHash_, collateralAddress, quoteAddress);\n        address erc721DeployedPoolAddress = erc721PoolFactory.deployedPools(subsetHash_, collateralAddress, quoteAddress);\n\n        return (pool_ == erc20DeployedPoolAddress || pool_ == erc721DeployedPoolAddress);\n    }\n\n    /**********************/\n    /*** View Functions ***/\n    /**********************/\n\n    /// @inheritdoc IPositionManagerDerivedState\n    function getLPTokens(\n        uint256 tokenId_,\n        uint256 index_\n    ) external override view returns (uint256) {\n        return positionLPs[tokenId_][index_];\n    }\n\n    /// @inheritdoc IPositionManagerDerivedState\n    function getPositionIndexes(\n        uint256 tokenId_\n    ) external view override returns (uint256[] memory) {\n        return positionIndexes[tokenId_].values();\n    }\n\n    /// @inheritdoc IPositionManagerDerivedState\n    function isIndexInPosition(\n        uint256 tokenId_,\n        uint256 index_\n    ) external override view returns (bool) {\n        return positionIndexes[tokenId_].contains(index_);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(\n        uint256 tokenId_\n    ) public view override(ERC721) returns (string memory) {\n        require(_exists(tokenId_));\n\n        address collateralTokenAddress = IPool(poolKey[tokenId_]).collateralAddress();\n        address quoteTokenAddress      = IPool(poolKey[tokenId_]).quoteTokenAddress();\n\n        PositionNFTSVG.ConstructTokenURIParams memory params = PositionNFTSVG.ConstructTokenURIParams({\n            collateralTokenSymbol: tokenSymbol(collateralTokenAddress),\n            quoteTokenSymbol:      tokenSymbol(quoteTokenAddress),\n            tokenId:               tokenId_,\n            pool:                  poolKey[tokenId_],\n            owner:                 ownerOf(tokenId_),\n            indexes:               positionIndexes[tokenId_].values()\n        });\n\n        return PositionNFTSVG.constructTokenURI(params);\n    }\n\n}"
    }
  ]
}