{
  "Title": "M-12: OCC_Modular::applyCombine will round APR down",
  "Content": "# Issue M-12: OCC_Modular::applyCombine will round APR down \n\nSource: https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/304 \n\n## Found by \ncergyk, denzi\\_, jasonxiale\n## Summary\n\n`OCC_Modular::applyCombine` calculation of `APR` `APR = APR / notional` rounds in defavor of the protocol, and a user can game this feature to shave of a point of APR from one of his loans.\n\n## Vulnerability Detail\n\n`OCC_Modular::applyCombine` is used to combine multiple loans into a single loan.\n\nWe can see that the APR for the new loan is computed as a weighted average of combined APRs. However since the division rounds down, the APR can be underestimated by 1 point. Since the APR is expressed as BIPS, a point represents a significant amount of interest.\n\n[OCC_Modular.sol#L781](https://github.com/sherlock-audit/2024-03-zivoe/blob/d4111645b19a1ad3ccc899bea073b6f19be04ccd/zivoe-core-foundry/src/lockers/OCC/OCC_Modular.sol#L781)\n```solidity\n        APR = APR / notional;\n```\n\n> Please note that even in the case where an underwriter has verified off-chain that the APR would not be rounded down before approving a combination, a user can make sure it rounds down by making some payments on his loans \n\n## Impact\n\nLoss of funds for the borrowers of the protocol, since a user can reduce APR on his loans by 1 point\n\n## Code Snippet\n\n- https://github.com/sherlock-audit/2024-03-zivoe/blob/d4111645b19a1ad3ccc899bea073b6f19be04ccd/zivoe-core-foundry/src/lockers/OCC/OCC_Modular.sol#L781\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nEnsure that there is no rounding error in the `APR` calculation's result by adding a check such as:\n\n```diff\n+ require(APR % notional == 0, \"rounding\");\nAPR = APR / notional;\n```\n\n\n\n## Discussion\n\n**pseudonaut**\n\nNot relevant, also not of concern\n\n**sherlock-admin3**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> invalid, the impact is insignificant and impossible to avoid rounding anyway, so it has to happen anyway\n\n\n\n**CergyK**\n\nEscalate\n\nIssue should have the same severity as #416, since it has exactly the same impact (rounding down on a BIPS precision number).\n\nThis has the impact of causing a loss of approx 100$ on a 1M$ loan, which is not negligible. A reasonable fix recommendation is provided to avoid rounding down. \n\n**sherlock-admin3**\n\n> Escalate\n> \n> Issue should have the same severity as #416, since it has exactly the same impact (rounding down on a BIPS precision number).\n> \n> This has the impact of causing a loss of approx 100$ on a 1M$ loan, which is not negligible. A reasonable fix recommendation is provided to avoid rounding down. \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**panprog**\n\nThis issue is different from #416, because here it's impossible to avoid rounding due to low precision of APR - so it's either rounded up (user loses funds at the expense of protocol) or rounded down as now (protocol loses funds at the expense of the user). Since it's impossible to avoid funds loss due to APR precision (which is apparently protocol choice), the rounding direction is also a protocol choice. There are no security concerns with either rounding direction here (as opposed to, say, ERC4626, where incorrect rounding direction might cause critical issues in extreme situations).\n\nIn #416 the issue is in the order of multiplication and division, which makes it round to the same 0.01% as here, but with the correct order of operations it's possible to avoid this rounding and increase precision. So this is different as it can be fixed and thus can not be considered protocol decision.\n\n**omar-ahsan**\n\n@panprog with all due respect, every line of code written by devs is a protocol decision on how they want the protocol to act. Watsons have identified a line of code which makes the protocol lose funds. The decision that they have made makes the protocol lose funds, this is a major concern in my opinion.\n\nIf it was known to the protocol that rounding down here makes the protocol lose funds and it is acceptable for the protocol to bear this loss then it should have been mentioned in known issues. \n![image](https://github.com/sherlock-audit/2024-03-zivoe-judging/assets/106596821/084a8d2d-515d-4c12-8909-d66b89ae6cc0)\n\nFurthermore rounding up in the favor of the protocol is the right decision, the protocol's task is to offer combinations. It's the borrower's decision to accept it or let it expire, Users who do not want to overpay (in case it is rounded up) can simply keep on paying the interests per each payment as before.\n\nThe loss of funds is always going to occur here for any magnitude of loans. I believe this should be judged according to the best interest of the protocol as its simply the case of protocol losing funds which they should not after an action. \n\n**WangSecurity**\n\nNeed clarification on [this](https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/304#issuecomment-2106146142) and [this](https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/304#issuecomment-2106005205) comments. LSW says it's a loss of $100 on a $1M loan, which is only 0.0001%, when the lead judge says it's 0.01% as well as on #416. So what is the correct percentage here?\n\n**panprog**\n\n@WangSecurity \n\n100/1000000=0.0001 = 0.01%\nAPR is in BIPS, 1 BIPS = 1/10000 (0.01%)\n\n**WangSecurity**\n\nI agree that loss is quite low (0.01%), but I believe it exceeds small and finite amounts, therefore sufficient for medium severity. Planning to accept the escalation and validate the report with medium severity.\n\nAre there other issues which identified this issue?\n\n**marchev**\n\n@WangSecurity Unfortunately, I don't think I can escalate one of my reports #671. It is not the same issue however it is an issue that identifies an attack path that results in a loss of 0.17% APR for some loans. Given that a loss of 0.01% warrants a valid issue can I please ask you to take a look at #671? ðŸ™\n\n**panprog**\n\n@WangSecurity \nMy main point of why it's invalid is because rounding is inevitable and either choice is valid. If this issue is fixed (by rounding up), a new valid issue may be raised that user loses the same amount of funds due to APR rounding up. Why do you think that user must lose this amount, and not protocol (like it is now)? I believe this is the design choice and thus not valid issue.\n\nI can understand that low precision might be the core reason, but this, again, is a design choice to limit APR to 1/10000 precision.\n\nSo I disagree because I think this is simply design choice, not because the amount lost is too small.\n\nIf you do decide to validate this as medium, here are dups: #681, #684\n\n**panprog**\n\nTo add on - this issue recommends to revert if there is any rounding error at all (only make it work if it divides exactly), but I believe that this is, again, design decision (and in my opinion not the best one - why limit user to only specific percentages?).\n\nSince combinations are approved by admin, he should simply not approve combines which might lead to bad combined loan APR. So if the recommendation of this issue is implemented, then this means that this issue is simply admin mistake who approves the loan combine he it trusted to not approve.\n\n**CergyK**\n\n> To add on - this issue recommends to revert if there is any rounding error at all (only make it work if it divides exactly), but I believe that this is, again, design decision (and in my opinion not the best one - why limit user to only specific percentages?).\n> \n> Since combinations are approved by admin, he should simply not approve combines which might lead to bad combined loan APR. So if the recommendation of this issue is implemented, then this means that this issue is simply admin mistake who approves the loan combine he it trusted to not approve.\n\nThat's an interesting point, however please notice that even if underwriter approves a combine which does not lead to precision loss, a user can still put it into rounding down state by making a repayment on a loan\n\n**omar-ahsan**\n\n> If this issue is fixed (by rounding up), a new valid issue may be raised that user loses the same amount of funds due to APR rounding up. Why do you think that user must lose this amount, and not protocol (like it is now)? I believe this is the design choice and thus not valid issue.\n\nThe new valid issue which has been mentioned can be considered design decision as the protocol should not be losing funds via interests which they were receiving before combination is applied. Further more in situations like these, rounding up is considered in favor of the protocol.\n\nThe protocol should not be taking accruing losses per every approved combination, Consider 100 approved combinations and 100 borrowers accepts them, the protocol is now taking a loss per every combination, in the case of user, it is one single user overpaying a small amount per their combination. Borrowers will always accept the combination if they know they will have to pay less. The protocol suffers more here than each single user so this issue should be judged in the best interest of the protocol.\n\nIts a two step process, The underwriter has to approve and then the user has to accept, If the APR is rounded up and if the borrower does not want to overpay in exchange of combining their loan then they can let the combination expire and keep on paying in separate transactions. \n\n**WangSecurity**\n\nVery insightful comments and I think I confused you a bit with my wording. Firstly, I don't think the mitigation should effect the validity of the report. Secondly, great point about admin mistake, but as LSW said [here](https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/304#issuecomment-2117138506) can make it round down. But I actually would like to clarify if it can be done intentionally and asking to give a small numeric example? Thirdly, I agree that it's design to make such low precision, but if it can be done intentionally, leading to other users lose funds. Hence, I may reconsider my decision after getting the answer if it can be done intentionally.\n\n**CergyK**\n\n> Very insightful comments and I think I confused you a bit with my wording. Firstly, I don't think the mitigation should effect the validity of the report. Secondly, great point about admin mistake, but as LSW said [here](https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/304#issuecomment-2117138506) can make it round down. But I actually would like to clarify if it can be done intentionally and asking to give a small numeric example? Thirdly, I agree that it's design to make such low precision, but if it can be done intentionally, leading to other users lose funds. Hence, I may reconsider my decision after getting the answer if it can be done intentionally.\n\nYes a user can make a few repayments intentionally to make the combine round down again.\nThe case in which the combine does not round down is extremely specific, so any small deviation of the values will lead it to round down again\n\nLet's take an example:\n\nLoan A:\n100 repayments left\n100 principal\n20 APR\n\nLoan B:\n100 repayments left\n100 principal\n50 APR\n\na combination of these loans would yield an APR:\n(50x100+20x100)/(100+100)=35\n\nwithout losing precision, because the division is exact\n\nHowever once the combine is approved, the user can repay one payment on loan B (always can do this action):\n\nLoan B:\n99 repayments left\n99 principal\n50 APR\n\nnow the combination yields:\n(50x99+20x100)/(100+99) = 34\n\nWhereas the parameters of the loans have barely changed\n\n**WangSecurity**\n\nTherefore, I agree that this is the design decision to have small precision, but with the fact that it allows a user to intentionally make APR round down causing a loss of funds. Hence, I believe it's suitable for medium severity. Planning to accept the escalation and validate the report with medium severity.\n\n**panprog**\n\nAgree that as the user can influence this rounding in his favor, then this is a valid medium.\n\n**Evert0x**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [CergyK](https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/304/#issuecomment-2106005205): accepted\n\n**omar-ahsan**\n\n@Evert0x I think you have mistakenly set this as unique, The lead judge has identified #681 and #684 as duplicates in his comment [here](https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/304#issuecomment-2117092890)\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/280",
  "Code": [
    {
      "filename": "zivoe-core-foundry/src/lockers/OCC/OCC_Modular.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"../../ZivoeLocker.sol\";\n\nimport \"../../../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\n\ninterface IZivoeGlobals_OCC {\n    /// @notice Returns the address of the ZivoeYDL contract.\n    function YDL() external view returns (address);\n\n    /// @notice Returns the address of the Zivoe Laboratory.\n    function ZVL() external view returns (address);\n\n    /// @notice Returns the net defaults in the system.\n    function defaults() external view returns (uint256);\n\n    /// @notice Returns true if an address is whitelisted as a keeper.\n    function isKeeper(address) external view returns (bool);\n\n    /// @notice Returns \"true\" if a locker is whitelisted for DAO interactions and accounting accessibility.\n    /// @param  locker  The address of the locker to check for.\n    function isLocker(address locker) external view returns (bool);\n\n    /// @notice Handles WEI standardization of a given asset amount (i.e. 6 decimal precision => 18 decimal precision).\n    /// @param  amount The amount of a given \"asset\".\n    /// @param  asset The asset (ERC-20) from which to standardize the amount to WEI.\n    /// @return standardizedAmount The above amount standardized to 18 decimals.\n    function standardize(uint256 amount, address asset) external view returns (uint256 standardizedAmount);\n\n    /// @notice Call when a default is resolved, decreases net defaults system-wide.\n    /// @dev    The value \"amount\" should be standardized to WEI.\n    /// @param  amount The default amount that has been resolved.\n    function decreaseDefaults(uint256 amount) external;\n\n    /// @notice Call when a default occurs, increases net defaults system-wide.\n    /// @dev    The value \"amount\" should be standardized to WEI.\n    /// @param  amount The default amount.\n    function increaseDefaults(uint256 amount) external;\n}\n\ninterface IZivoeYDL_OCC {\n    /// @notice Returns the \"stablecoin\" that will be distributed via YDL.\n    /// @return asset The address of the \"stablecoin\" that will be distributed via YDL.\n    function distributedAsset() external view returns (address asset);\n}\n\n\n\n/// @notice  OCC stands for \"On-Chain Credit\".\n///          A \"Bullet\" loan is an interest-only loan, with principal repaid in full at the end.\n///          An \"Amortization\" loan is a principal and interest loan, with consistent payments until fully \"Repaid\".\n///          This locker is responsible for handling accounting of loans.\n///          This locker is responsible for handling payments and distribution of payments.\n///          This locker is responsible for handling defaults and liquidations (if needed).\ncontract OCC_Modular is ZivoeLocker, ReentrancyGuard {\n    \n    using SafeERC20 for IERC20;\n\n    // ---------------------\n    //    State Variables\n    // ---------------------\n\n    /// @dev Tracks payment schedule type of the loan.\n    enum LoanSchedule { Bullet, Amortization }\n\n    /// @dev    Tracks state of the loan, enabling or disabling certain actions (function calls).\n    /// @param  Null Default state, loan isn't offered yet.\n    /// @param  Offered Loan offer has been created, not accepted (it could have passed expiry date).\n    /// @param  Active Loan has been accepted, is currently receiving payments.\n    /// @param  Repaid Loan was accepted, and has been fully repaid.\n    /// @param  Defaulted Loan has defaulted, payments were missed, gracePeriod passed, and markDefault() called.\n    /// @param  Cancelled Loan offer was created, then cancelled prior to acceptance.\n    /// @param  Resolved Loan was accepted, then there was a default, then the full amount of principal was repaid.\n    /// @param  Combined Loan was accepted, then combined with other loans while active.\n    enum LoanState { \n        Null,\n        Offered,\n        Active,\n        Repaid,\n        Defaulted,\n        Cancelled,\n        Resolved,\n        Combined\n    }\n\n    /// @dev Tracks approved combination.\n    struct Combine {\n        uint256[] loans;                /// @dev The loans approved for combination.\n        uint256 APRLateFee;             /// @dev The late fee APR.\n        uint256 term;                   /// @dev The term of the resulting combined loan.\n        uint256 paymentInterval;        /// @dev The paymentInterval of the resulting combined loan.\n        uint256 gracePeriod;            /// @dev The gracePeriod of the resulting combined loan.\n        uint256 expires;                /// @dev The expiration of this combination.\n        int8 paymentSchedule;           /// @dev The paymentSchedule of the resulting combined loan.\n        bool valid;                     /// @dev The validity of the combination (if it can be executed).\n    }\n\n    /// @dev Tracks the loan.\n    struct Loan {\n        address borrower;               /// @dev The address that receives capital when the loan is accepted.\n        uint256 principalOwed;          /// @dev The amount of principal still owed on the loan.\n        uint256 APR;                    /// @dev The annualized percentage rate charged on the outstanding principal.\n        uint256 APRLateFee;             /// @dev The APR charged on the outstanding principal if payment is late.\n        uint256 paymentDueBy;           /// @dev The timestamp (in seconds) for when the next payment is due.\n        uint256 paymentsRemaining;      /// @dev The number of payments remaining until the loan is \"Repaid\".\n        uint256 term;                   /// @dev The number of paymentIntervals that will occur (e.g. 12, 24).\n        uint256 paymentInterval;        /// @dev The interval of time between payments (in seconds).\n        uint256 offerExpiry;            /// @dev The block.timestamp at which the offer for this loan expires.\n        uint256 gracePeriod;            /// @dev The number of seconds a borrower has to makePayment() before default.\n        int8 paymentSchedule;           /// @dev The payment schedule of the loan (0 = \"Bullet\" or 1 = \"Amortization\").\n        LoanState state;                /// @dev The state of the loan.\n    }\n\n    address public immutable GBL;               /// @dev The ZivoeGlobals contract.\n    address public immutable stablecoin;        /// @dev The stablecoin for this OCC contract.\n    address public immutable underwriter;       /// @dev The entity that is allowed to underwrite (a.k.a. issue) loans.\n\n    address public OCT_YDL;                     /// @dev Facilitates swaps and forwards distributedAsset() to YDL.\n    \n    uint256 public combineCounter;              /// @dev Incrementor for \"combinations\" mapping.\n    uint256 public loanCounter;                 /// @dev Incrementor for \"loans\" mapping.\n\n    uint256 private constant BIPS = 10000;\n\n    /// @dev Mapping of approved loan combinations.\n    mapping(uint256 => Combine) public combinations;\n\n    /// @dev Mapping of loans approved for conversion to amortization payment schedule.\n    mapping (uint256 => bool) public conversionToAmortization;\n    \n    /// @dev Mapping of loans approved for conversion to bullet payment schedule.\n    mapping (uint256 => bool) public conversionToBullet;\n\n    /// @dev Mapping of loans approved for extension, key is the loan ID, output is paymentIntervals extension.\n    mapping (uint256 => uint256) public extensions;\n\n    /// @dev Mapping of loans and their information, key is the ID of the loan, output is the Loan struct information.\n    mapping (uint256 => Loan) public loans;\n\n    /// @dev Mapping of loans approved for refinancing, key is the ID of the loan, output is APR it can refinance to.\n    mapping(uint256 => uint256) public refinancing;\n\n\n\n    // -----------------\n    //    Constructor\n    // -----------------\n\n    /// @notice Initializes the OCC_Modular contract.\n    /// @param  DAO The administrator of this contract (intended to be ZivoeDAO).\n    /// @param  _stablecoin The stablecoin for this OCC contract.\n    /// @param  _GBL The ZivoeGlobals contract.\n    /// @param  _underwriter The entity that is allowed to call createOffer() and markRepaid().\n    /// @param  _OCT_YDL The contract that facilitates swaps and forwards distributedAsset() to YDL.\n    constructor(address DAO, address _stablecoin, address _GBL, address _underwriter, address _OCT_YDL) {\n        transferOwnershipAndLock(DAO);\n        stablecoin = _stablecoin;\n        GBL = _GBL;\n        underwriter = _underwriter;\n        OCT_YDL = _OCT_YDL;\n    }\n\n\n\n    // ------------\n    //    Events\n    // ------------\n\n    /// @notice Emitted during applyCombine().\n    /// @param  borrower The borrower combining their loans.\n    /// @param  loanIDs The IDs of the loans that were combined.\n    /// @param  term The resulting term of the combined loan.\n    /// @param  paymentInterval The resulting paymentInterval of the combined loan.\n    /// @param  gracePeriod The resulting gracePeriod of the combined loan.\n    /// @param  paymentSchedule The payment schedule of the combined loan (0 = \"Bullet\" or 1 = \"Amortization\").\n    event CombineApplied(\n        address indexed borrower, \n        uint256[] loanIDs, \n        uint256 term,\n        uint256 paymentInterval,\n        uint256 gracePeriod,\n        int8 indexed paymentSchedule\n    );\n\n    /// @notice Emitted during approveCombine().\n    /// @param  id The ID of the combination approval in \"combinations\" mapping.\n    /// @param  loanIDs The IDs of the loans that can be combined.\n    /// @param  term The resulting term of the combined loan that is permitted.\n    /// @param  paymentInterval The resulting paymentInterval of the combined loan.\n    /// @param  gracePeriod The resulting gracePeriod of the combined loan that is permitted.\n    /// @param  expires The expiration of this combination.\n    /// @param  paymentSchedule The payment schedule of the combined loan (0 = \"Bullet\" or 1 = \"Amortization\").\n    event CombineApproved(\n        uint256 indexed id, \n        uint256[] loanIDs,\n        uint256 APRLateFee,\n        uint256 term,\n        uint256 paymentInterval, \n        uint256 gracePeriod,\n        uint256 expires,\n        int8 indexed paymentSchedule\n    );\n\n    /// @notice Emitted during applyCombine().\n    /// @param  borrower        The address borrowing (that will receive the loan).\n    /// @param  id              Identifier for the loan offer created.\n    /// @param  borrowAmount    The amount to borrow (in other words, initial principal).\n    /// @param  APR             The annualized percentage rate charged on the outstanding principal.\n    /// @param  APRLateFee      The APR charged for late payments.\n    /// @param  paymentDueBy    The timestamp (in seconds) for when the next payment is due.\n    /// @param  term            The term or \"duration\" of the loan (number of paymentIntervals that will occur).\n    /// @param  paymentInterval The interval of time between payments (in seconds).\n    /// @param  gracePeriod     The number of seconds a borrower has to makePayment() before loan could default.\n    /// @param  paymentSchedule The payment schedule type (\"Bullet\" or \"Amortization\").\n    event CombineLoanCreated(\n        address indexed borrower,\n        uint256 indexed id,\n        uint256 borrowAmount,\n        uint256 APR,\n        uint256 APRLateFee,\n        uint256 paymentDueBy,\n        uint256 term,\n        uint256 paymentInterval,\n        uint256 gracePeriod,\n        int8 indexed paymentSchedule\n    );\n\n    /// @notice Emitted during unapproveCombine().\n    /// @param  id The ID of the combine to unapprove.\n    event CombineUnapproved(uint256 id);\n\n    /// @notice Emitted during applyConversionToAmortization().\n    /// @param  id The loan ID converted to amortization payment schedule.\n    event ConversionToAmortizationApplied(uint256 indexed id);\n\n    /// @notice Emitted during unapproveConversionToAmortization().\n    /// @param  id The loan ID approved for conversion.\n    event ConversionToAmortizationApproved(uint256 indexed id);\n\n    /// @notice Emitted during approveConversionToBullet().\n    /// @param  id The loan ID unapproved for conversion.\n    event ConversionToAmortizationUnapproved(uint256 indexed id);\n\n    /// @notice Emitted during applyConversionToBullet().\n    /// @param  id The loan ID converted to bullet payment schedule.\n    event ConversionToBulletApplied(uint256 indexed id);\n\n    /// @notice Emitted during approveConversionToBullet().\n    /// @param  id The loan ID approved for conversion.\n    event ConversionToBulletApproved(uint256 indexed id);\n\n    /// @notice Emitted during unapproveConversionToBullet().\n    /// @param  id The loan ID unapproved for conversion.\n    event ConversionToBulletUnapproved(uint256 indexed id);\n\n    /// @notice Emitted during markDefault().\n    /// @param id Identifier for the loan which is now \"defaulted\".\n    /// @param principalDefaulted The amount defaulted on.\n    event DefaultMarked(uint256 indexed id, uint256 principalDefaulted);\n\n    /// @notice Emitted during resolveDefault().\n    /// @param id The identifier for the loan in default that is resolved (or partially).\n    /// @param amount The amount of principal paid back.\n    /// @param payee The address responsible for resolving the default.\n    /// @param resolved Denotes if the loan is fully resolved (false if partial).\n    event DefaultResolved(uint256 indexed id, uint256 amount, address indexed payee, bool resolved);\n\n    /// @notice Emitted during applyExtension().\n    /// @param  id The identifier of the loan extending its payment schedule.\n    /// @param  intervals The number of intervals the loan is extended for.\n    event ExtensionApplied(uint256 indexed id, uint256 intervals);\n\n    /// @notice Emitted during approveExtension().\n    /// @param  id The identifier of the loan receiving approval for extension.\n    /// @param  intervals The number of intervals the approved loan may be extended.\n    event ExtensionApproved(uint256 indexed id, uint256 intervals);\n\n    /// @notice Emitted during unapproveExtension().\n    /// @param  id The identifier of the loan losing approval for extension.\n    event ExtensionUnapproved(uint256 indexed id);\n\n    /// @notice Emitted during supplyInterest().\n    /// @param id The identifier for the loan that is supplied additional interest.\n    /// @param amount The amount of interest supplied.\n    /// @param payee The address responsible for supplying additional interest.\n    event InterestSupplied(uint256 indexed id, uint256 amount, address indexed payee);\n\n    /// @notice Emitted during callLoan().\n    /// @param id Identifier for the loan which is called.\n    /// @param amount The total amount of the payment.\n    /// @param interest The interest portion of \"amount\" paid.\n    /// @param principal The principal portion of \"amount\" paid.\n    /// @param lateFee The lateFee portion of \"amount\" paid.\n    event LoanCalled(uint256 indexed id, uint256 amount, uint256 principal, uint256 interest, uint256 lateFee);\n\n    /// @notice Emitted during acceptOffer().\n    /// @param  id Identifier for the offer accepted.\n    /// @param  principal The amount of stablecoin lent out.\n    /// @param  borrower The address borrowing the amount (principal).\n    /// @param  paymentDueBy Timestamp (unix seconds) by which next payment is due.\n    event OfferAccepted(uint256 indexed id, uint256 principal, address indexed borrower, uint256 paymentDueBy);\n\n    /// @notice Emitted during cancelOffer().\n    /// @param  id Identifier for the loan offer cancelled.\n    event OfferCancelled(uint256 indexed id);\n\n    /// @notice Emitted during createOffer().\n    /// @param  borrower        The address borrowing (that will receive the loan).\n    /// @param  id              Identifier for the loan offer created.\n    /// @param  borrowAmount    The amount to borrow (in other words, initial principal).\n    /// @param  APR             The annualized percentage rate charged on the outstanding principal.\n    /// @param  APRLateFee      The APR charged for late payments.\n    /// @param  term            The term or \"duration\" of the loan (number of paymentIntervals that will occur).\n    /// @param  paymentInterval The interval of time between payments (in seconds).\n    /// @param  offerExpiry     The block.timestamp at which the offer for this loan expires (hardcoded 2 weeks).\n    /// @param  gracePeriod     The number of seconds a borrower has to makePayment() before loan could default.\n    /// @param  paymentSchedule The payment schedule type (\"Bullet\" or \"Amortization\").\n    event OfferCreated(\n        address indexed borrower,\n        uint256 indexed id,\n        uint256 borrowAmount,\n        uint256 APR,\n        uint256 APRLateFee,\n        uint256 term,\n        uint256 paymentInterval,\n        uint256 offerExpiry,\n        uint256 gracePeriod,\n        int8 indexed paymentSchedule\n    );\n\n    /// @notice Emitted during makePayment() and processPayment().\n    /// @param id Identifier for the loan on which payment is made.\n    /// @param payee The address which made payment on the loan.\n    /// @param amount The total amount of the payment.\n    /// @param principal The principal portion of \"amount\" paid.\n    /// @param interest The interest portion of \"amount\" paid.\n    /// @param lateFee The lateFee portion of \"amount\" paid.\n    /// @param nextPaymentDue The timestamp by which next payment is due.\n    event PaymentMade(\n        uint256 indexed id, \n        address indexed payee, \n        uint256 amount, \n        uint256 principal, \n        uint256 interest, \n        uint256 lateFee, \n        uint256 nextPaymentDue\n    );\n\n    /// @notice Emitted during applyRefinance().\n    /// @param  id The loan ID refinancing its APR.\n    /// @param  APRNew The new APR of the loan.\n    /// @param  APRPrior The prior APR of the loan.\n    event RefinanceApplied(uint256 indexed id, uint256 APRNew, uint256 APRPrior);\n\n    /// @notice Emitted during approveRefinance().\n    /// @param  id The loan ID approved for refinance.\n    /// @param  APR The APR the loan is approved to refinance to.\n    event RefinanceApproved(uint256 indexed id, uint256 APR);\n\n    /// @notice Emitted during unapproveRefinance().\n    /// @param  id The loan ID unapproved for refinance.\n    event RefinanceUnapproved(uint256 indexed id);\n\n    /// @notice Emitted during markRepaid().\n    /// @param id Identifier for loan which is now \"repaid\".\n    event RepaidMarked(uint256 indexed id);\n\n    /// @notice Emitted during updateOCTYDL().\n    /// @param  newOCT The new OCT_YDL contract.\n    /// @param  oldOCT The old OCT_YDL contract.\n    event UpdatedOCTYDL(address indexed newOCT, address indexed oldOCT);\n\n    \n\n    // ---------------\n    //    Modifiers\n    // ---------------\n\n    /// @notice This modifier ensures that the caller is the entity that is allowed to issue loans.\n    modifier isUnderwriter() {\n        require(_msgSender() == underwriter, \"OCC_Modular::isUnderwriter() _msgSender() != underwriter\");\n        _;\n    }\n\n\n\n    // ---------------\n    //    Functions\n    // ---------------\n\n    /// @notice Permission for owner to call pushToLocker().\n    function canPush() public override pure returns (bool) { return true; }\n\n    /// @notice Permission for owner to call pullFromLocker().\n    function canPull() public override pure returns (bool) { return true; }\n\n    /// @notice Permission for owner to call pushToLockerPartial().\n    function canPullPartial() public override pure returns (bool) { return true; }\n\n    /// @notice Returns information for a given loan.\n    /// @dev    Refer to documentation on Loan struct for return param information.\n    /// @param  id The ID of the loan.\n    /// @return borrower The borrower of the loan.\n    /// @return paymentSchedule The structure of the payment schedule.\n    /// @return info The remaining information for the loan:\n    ///                  info[0] = principalOwed\n    ///                  info[1] = APR\n    ///                  info[2] = APRLateFee\n    ///                  info[3] = paymentDueBy\n    ///                  info[4] = paymentsRemaining\n    ///                  info[5] = term\n    ///                  info[6] = paymentInterval\n    ///                  info[7] = offerExpiry\n    ///                  info[8] = gracePeriod\n    ///                  info[9] = loanState\n    function loanInfo(uint256 id) external view returns (\n        address borrower, int8 paymentSchedule, uint256[10] memory info\n    ) {\n        borrower = loans[id].borrower;\n        paymentSchedule = loans[id].paymentSchedule;\n        info[0] = loans[id].principalOwed;\n        info[1] = loans[id].APR;\n        info[2] = loans[id].APRLateFee;\n        info[3] = loans[id].paymentDueBy;\n        info[4] = loans[id].paymentsRemaining;\n        info[5] = loans[id].term;\n        info[6] = loans[id].paymentInterval;\n        info[7] = loans[id].offerExpiry;\n        info[8] = loans[id].gracePeriod;\n        info[9] = uint256(loans[id].state);\n    }\n\n    /// @notice Returns information for amount owed on next payment of a particular loan.\n    /// @param  id The ID of the loan.\n    /// @return principal The amount of principal owed.\n    /// @return interest The amount of interest owed.\n    /// @return lateFee The amount of late fees owed.\n    /// @return total Full amount owed, combining principal plus interest.\n    function amountOwed(uint256 id) public view returns (\n        uint256 principal, uint256 interest, uint256 lateFee, uint256 total\n    ) {\n        // 0 == Bullet.\n        if (loans[id].paymentSchedule == 0) {\n            if (loans[id].paymentsRemaining == 1) { principal = loans[id].principalOwed; }\n        }\n        // 1 == Amortization (only two options, use else here).\n        else { principal = loans[id].principalOwed / loans[id].paymentsRemaining; }\n\n        // Add late fee if past loans[id].paymentDueBy.\n        if (block.timestamp > loans[id].paymentDueBy && loans[id].state == LoanState.Active) {\n            lateFee = loans[id].principalOwed * (block.timestamp - loans[id].paymentDueBy) *\n                loans[id].APRLateFee / (86400 * 365 * BIPS);\n        }\n        interest = loans[id].principalOwed * loans[id].paymentInterval * loans[id].APR / (86400 * 365 * BIPS);\n        total = principal + interest + lateFee;\n    }\n\n    /// @notice Funds and initiates a loan.\n    /// @param  id The ID of the loan.\n    function acceptOffer(uint256 id) external nonReentrant {\n        require(\n            loans[id].state == LoanState.Offered, \n            \"OCC_Modular::acceptOffer() loans[id].state != LoanState.Offered\"\n        );\n        require(\n            block.timestamp < loans[id].offerExpiry, \n            \"OCC_Modular::acceptOffer() block.timestamp >= loans[id].offerExpiry\"\n        );\n        require(\n            _msgSender() == loans[id].borrower, \n            \"OCC_Modular::acceptOffer() _msgSender() != loans[id].borrower\"\n        );\n\n        // \"Friday\" Payment Standardization, minimum 7-day lead-time\n        // block.timestamp - block.timestamp % 7 days + 9 days + paymentInterval\n        emit OfferAccepted(\n            id, \n            loans[id].principalOwed, \n            loans[id].borrower, \n            block.timestamp - block.timestamp % 7 days + 9 days + loans[id].paymentInterval\n        );\n\n        loans[id].state = LoanState.Active;\n        loans[id].paymentDueBy = block.timestamp - block.timestamp % 7 days + 9 days + loans[id].paymentInterval;\n        IERC20(stablecoin).safeTransfer(loans[id].borrower, loans[id].principalOwed);\n    }\n\n    /// @notice Pays off the loan in full, plus additional interest for paymentInterval.\n    /// @dev    Only the \"borrower\" of the loan may elect this option.\n    /// @param  id The loan to pay off early.\n    function callLoan(uint256 id) external nonReentrant {\n        require(\n            _msgSender() == loans[id].borrower || IZivoeGlobals_OCC(GBL).isLocker(_msgSender()), \n            \"OCC_Modular::callLoan() _msgSender() != loans[id].borrower && !isLocker(_msgSender())\"\n        );\n        require(loans[id].state == LoanState.Active, \"OCC_Modular::callLoan() loans[id].state != LoanState.Active\");\n\n        uint256 principalOwed = loans[id].principalOwed;\n        (, uint256 interestOwed, uint256 lateFee,) = amountOwed(id);\n\n        emit LoanCalled(id, principalOwed + interestOwed + lateFee, principalOwed, interestOwed, lateFee);\n\n        // Transfer interest to YDL if in same format, otherwise keep here for 1INCH forwarding.\n        if (stablecoin == IZivoeYDL_OCC(IZivoeGlobals_OCC(GBL).YDL()).distributedAsset()) {\n            IERC20(stablecoin).safeTransferFrom(_msgSender(), IZivoeGlobals_OCC(GBL).YDL(), interestOwed + lateFee);\n        }\n        else {\n            IERC20(stablecoin).safeTransferFrom(_msgSender(), OCT_YDL, interestOwed + lateFee);\n        }\n\n        IERC20(stablecoin).safeTransferFrom(_msgSender(), owner(), principalOwed);\n\n        loans[id].principalOwed = 0;\n        loans[id].paymentDueBy = 0;\n        loans[id].paymentsRemaining = 0;\n        loans[id].state = LoanState.Repaid;\n    }\n\n    /// @notice Cancels a loan offer.\n    /// @param id The ID of the loan.\n    function cancelOffer(uint256 id) isUnderwriter external {\n        require(\n            loans[id].state == LoanState.Offered, \n            \"OCC_Modular::cancelOffer() loans[id].state != LoanState.Offered\"\n        );\n        emit OfferCancelled(id);\n        loans[id].state = LoanState.Cancelled;\n    }\n\n    /// @notice                 Create a loan offer.\n    /// @param  borrower        The address to borrow (that receives the loan).\n    /// @param  borrowAmount    The amount to borrow (in other words, initial principal).\n    /// @param  APR             The annualized percentage rate charged on the outstanding principal.\n    /// @param  APRLateFee      The APR charged for late payments.\n    /// @param  term            The term or \"duration\" of the loan (number of paymentIntervals that will occur).\n    /// @param  paymentInterval The interval of time between payments (in seconds).\n    /// @param  gracePeriod     The number of seconds a borrower has to makePayment() before loan could default.\n    /// @param  paymentSchedule The payment schedule type (\"Bullet\" or \"Amortization\").\n    function createOffer(\n        address borrower,\n        uint256 borrowAmount,\n        uint256 APR,\n        uint256 APRLateFee,\n        uint256 term,\n        uint256 paymentInterval,\n        uint256 gracePeriod,\n        int8 paymentSchedule\n    ) isUnderwriter external {\n        require(term > 0, \"OCC_Modular::createOffer() term == 0\");\n        require(\n            paymentInterval == 86400 * 7 || paymentInterval == 86400 * 14 || paymentInterval == 86400 * 28 || \n            paymentInterval == 86400 * 91 || paymentInterval == 86400 * 364, \n            \"OCC_Modular::createOffer() invalid paymentInterval value, try: 86400 * (7 || 14 || 28 || 91 || 364)\"\n        );\n        require(gracePeriod >= 7 days, \"OCC_Modular::createOffer() gracePeriod < 7 days\");\n        require(paymentSchedule <= 1, \"OCC_Modular::createOffer() paymentSchedule > 1\");\n\n        emit OfferCreated(\n            borrower, loanCounter, borrowAmount, APR, APRLateFee, term,\n            paymentInterval, block.timestamp + 3 days, gracePeriod, paymentSchedule\n        );\n\n        loans[loanCounter] = Loan(\n            borrower, borrowAmount, APR, APRLateFee, 0, term, term, paymentInterval, block.timestamp + 3 days,\n            gracePeriod, paymentSchedule, LoanState.Offered\n        );\n\n        loanCounter += 1;\n    }\n\n    /// @notice Make a payment on a loan.\n    /// @dev    Anyone is allowed to make a payment on someone's loan.\n    /// @param  id The ID of the loan.\n    function makePayment(uint256 id) external nonReentrant {\n        require(loans[id].state == LoanState.Active, \"OCC_Modular::makePayment() loans[id].state != LoanState.Active\");\n\n        (uint256 principalOwed, uint256 interestOwed, uint256 lateFee,) = amountOwed(id);\n\n        emit PaymentMade(\n            id, _msgSender(), principalOwed + interestOwed + lateFee, principalOwed,\n            interestOwed, lateFee, loans[id].paymentDueBy + loans[id].paymentInterval\n        );\n\n        // Transfer interest + lateFee to YDL if in same format, otherwise keep here for 1INCH forwarding.\n        if (stablecoin == IZivoeYDL_OCC(IZivoeGlobals_OCC(GBL).YDL()).distributedAsset()) {\n            IERC20(stablecoin).safeTransferFrom(_msgSender(), IZivoeGlobals_OCC(GBL).YDL(), interestOwed + lateFee);\n        }\n        else {\n            IERC20(stablecoin).safeTransferFrom(_msgSender(), OCT_YDL, interestOwed + lateFee);\n        }\n        if (principalOwed > 0) { IERC20(stablecoin).safeTransferFrom(_msgSender(), owner(), principalOwed); }\n\n        if (loans[id].paymentsRemaining == 1) {\n            loans[id].state = LoanState.Repaid;\n            loans[id].paymentDueBy = 0;\n        }\n        else { loans[id].paymentDueBy += loans[id].paymentInterval; }\n\n        loans[id].principalOwed -= principalOwed;\n        loans[id].paymentsRemaining -= 1;\n    }\n\n    /// @notice Mark a loan insolvent if a payment hasn't been made beyond the corresponding grace period.\n    /// @param  id The ID of the loan.\n    function markDefault(uint256 id) external isUnderwriter {\n        require(loans[id].state == LoanState.Active, \"OCC_Modular::markDefault() loans[id].state != LoanState.Active\");\n        require( \n            loans[id].paymentDueBy + loans[id].gracePeriod < block.timestamp, \n            \"OCC_Modular::markDefault() loans[id].paymentDueBy + loans[id].gracePeriod >= block.timestamp\"\n        );\n        \n        emit DefaultMarked(id, loans[id].principalOwed);\n        loans[id].state = LoanState.Defaulted;\n        IZivoeGlobals_OCC(GBL).increaseDefaults(\n            IZivoeGlobals_OCC(GBL).standardize(loans[id].principalOwed, stablecoin)\n        );\n    }\n\n    /// @notice Underwriter specifies a loan has been repaid fully via interest deposits in terms of off-chain debt.\n    /// @param  id The ID of the loan.\n    function markRepaid(uint256 id) external isUnderwriter {\n        require(\n            loans[id].state == LoanState.Resolved, \n            \"OCC_Modular::markRepaid() loans[id].state != LoanState.Resolved\"\n        );\n        emit RepaidMarked(id);\n        loans[id].state = LoanState.Repaid;\n        loans[id].paymentDueBy = 0;\n    }\n\n    /// @notice Process a payment for a loan, on behalf of another borrower.\n    /// @dev    Only \"keepeers\" and \"underwriter\" can call this function, taking payment from the \"borrower\".\n    /// @dev    Only allowed to call this if block.timestamp > paymentDueBy - 12 hours.\n    /// @param  id The ID of the loan.\n    function processPayment(uint256 id) external nonReentrant {\n        require(\n            _msgSender() == underwriter || IZivoeGlobals_OCC(GBL).isKeeper(_msgSender()),\n            \"OCC_Modular::processPayment() _msgSender() != underwriter && !IZivoeGlobals_OCC(GBL).isKeeper(_msgSender())\"\n        );\n        require(\n            loans[id].state == LoanState.Active, \n            \"OCC_Modular::processPayment() loans[id].state != LoanState.Active\"\n        );\n        require(\n            block.timestamp > loans[id].paymentDueBy - 12 hours, \n            \"OCC_Modular::processPayment() block.timestamp <= loans[id].paymentDueBy - 12 hours\"\n        );\n\n        (uint256 principalOwed, uint256 interestOwed, uint256 lateFee,) = amountOwed(id);\n\n        emit PaymentMade(\n            id, loans[id].borrower, principalOwed + interestOwed + lateFee, principalOwed,\n            interestOwed, lateFee, loans[id].paymentDueBy + loans[id].paymentInterval\n        );\n\n        // Transfer interest to YDL if in same format, otherwise keep here for 1INCH forwarding.\n        if (stablecoin == IZivoeYDL_OCC(IZivoeGlobals_OCC(GBL).YDL()).distributedAsset()) {\n            IERC20(stablecoin).safeTransferFrom(\n                loans[id].borrower, IZivoeGlobals_OCC(GBL).YDL(), interestOwed + lateFee\n            );\n        }\n        else {\n            IERC20(stablecoin).safeTransferFrom(loans[id].borrower, OCT_YDL, interestOwed + lateFee);\n        }\n        \n        if (principalOwed > 0) { IERC20(stablecoin).safeTransferFrom(loans[id].borrower, owner(), principalOwed); }\n\n        if (loans[id].paymentsRemaining == 1) {\n            loans[id].state = LoanState.Repaid;\n            loans[id].paymentDueBy = 0;\n        }\n        else { loans[id].paymentDueBy += loans[id].paymentInterval; }\n\n        loans[id].principalOwed -= principalOwed;\n        loans[id].paymentsRemaining -= 1;\n    }\n\n    /// @notice Make a full (or partial) payment to resolve an insolvent loan.\n    /// @param  id The ID of the loan.\n    /// @param  amount The amount of principal to pay down.\n    function resolveDefault(uint256 id, uint256 amount) external nonReentrant {"
    }
  ]
}