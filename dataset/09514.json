{
  "Title": "[H-08] StrategyPUSDConvex.balanceOfJPEG uses incorrect function signature while calling extraReward.earned, causing the function to unexpectedly revert everytime",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/strategies/StrategyPUSDConvex.sol#L234\n\n\n# Vulnerability details\n\n## Impact\n\nAs specified in Convex [BaseRewardPool.sol](https://github.com/convex-eth/platform/blob/main/contracts/contracts/BaseRewardPool.sol#L149) and [VirtualRewardPool.sol](https://github.com/convex-eth/platform/blob/main/contracts/contracts/VirtualBalanceRewardPool.sol#L127), the function signature of `earned` is `earned(address)`. However, `balanceOfJPEG` did not pass any arguments to `earned`, which would cause `balanceOfJPEG` to always revert.\n\nThis bug will propagate through `Controller` and `YVault` until finally reaching the source of the call in `YVaultLPFarming ._computeUpdate`, and render the entire farming contract unuseable.\n\n## Proof of Concept\n\nBoth `BaseRewardPool.earned` and `VirtualBalanceRewardPool.earned` takes an address as argument\n\n```\n    function earned(address account) public view returns (uint256) {\n        return\n            balanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            balanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n```\n\nBut `balanceOfJPEG` does not pass any address to `extraReward.earned`, causing the entire function to revert when called\n```\n    function balanceOfJPEG() external view returns (uint256) {\n        uint256 availableBalance = jpeg.balanceOf(address(this));\n\n        IBaseRewardPool baseRewardPool = convexConfig.baseRewardPool;\n        uint256 length = baseRewardPool.extraRewardsLength();\n        for (uint256 i = 0; i < length; i++) {\n            IBaseRewardPool extraReward = IBaseRewardPool(baseRewardPool.extraRewards(i));\n            if (address(jpeg) == extraReward.rewardToken()) {\n                availableBalance += extraReward.earned();\n                //we found jpeg, no need to continue the loop\n                break;\n            }\n        }\n\n        return availableBalance;\n    }\n```\n\n## Tools Used\n\nvim, ganache-cli\n\n## Recommended Mitigation Steps\n\nPass `address(this)` as argument of `earned`.\n\nNotice how we modify the fetching of reward. This is reported in a separate bug report, but for completeness, the entire fix is shown in both report entries.\n\n```\n    function balanceOfJPEG() external view returns (uint256) {\n        uint256 availableBalance = jpeg.balanceOf(address(this));\n\n        IBaseRewardPool baseRewardPool = convexConfig.baseRewardPool;\n        availableBalance += baseRewardPool.earned(address(this));\n        uint256 length = baseRewardPool.extraRewardsLength();\n        for (uint256 i = 0; i < length; i++) {\n            IBaseRewardPool extraReward = IBaseRewardPool(baseRewardPool.extraRewards(i));\n            if (address(jpeg) == extraReward.rewardToken()) {\n                availableBalance += extraReward.earned(address(this));\n            }\n        }\n\n        return availableBalance;\n    }\n```\n\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-04-jpegd-contest",
  "Code": [
    {
      "filename": "contracts/vaults/yVault/strategies/StrategyPUSDConvex.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../../interfaces/ISwapRouter.sol\";\nimport \"../../../interfaces/IUniswapV2Router.sol\";\nimport \"../../../interfaces/ICurve.sol\";\nimport \"../../../interfaces/IBooster.sol\";\nimport \"../../../interfaces/IBaseRewardPool.sol\";\n\nimport \"../../../interfaces/IController.sol\";\nimport \"../../../interfaces/IFungibleAssetVaultForDAO.sol\";\n\n/// @title JPEG'd PUSD Convex autocompounding strategy\n/// @notice This strategy autocompounds Convex rewards from the PUSD/USDC/USDT/MIM Curve pool.\n/// @dev The strategy deposits either USDC or PUSD in the Curve pool depending on which one has lower liquidity.\n/// The strategy sells reward tokens for USDC. If the pool has less PUSD than USDC, this contract uses the\n/// USDC {FungibleAssetVaultForDAO} to mint PUSD using USDC as collateral\ncontract StrategyPUSDConvex is AccessControl {\n    using SafeERC20 for IERC20;\n\n    event Harvested(uint256 wantEarned);\n\n    struct Rate {\n        uint128 numerator;\n        uint128 denominator;\n    }\n\n    /// @param booster Convex Booster's address\n    /// @param baseRewardPool Convex BaseRewardPool's address\n    /// @param pid The Convex pool id for PUSD/USDC/USDT/MIM LP tokens\n    struct ConvexConfig {\n        IBooster booster;\n        IBaseRewardPool baseRewardPool;\n        uint256 pid;\n    }\n\n    /// @param curve Curve's PUSD/USDC/USDT/MIM pool address\n    /// @param usdcIndex The USDC token index in curve's pool\n    /// @param pusdIndex The PUSD token index in curve's pool\n    struct CurveConfig {\n        ICurve curve;\n        uint256 usdcIndex;\n        uint256 pusdIndex;\n    }\n\n    /// @param uniswapV2 The UniswapV2 (or Sushiswap) router address\n    /// @param uniswapV3 The UniswapV3 router address\n    struct DexConfig {\n        IUniswapV2Router uniswapV2;\n        ISwapRouter uniswapV3;\n    }\n\n    /// @param rewardTokens The Convex reward tokens\n    /// @param controller The strategy controller\n    /// @param usdcVault The JPEG'd USDC {FungibleAssetVaultForDAO} address\n    struct StrategyConfig {\n        IERC20[] rewardTokens;\n        IController controller;\n        IFungibleAssetVaultForDAO usdcVault;\n    }\n\n    bytes32 public constant STRATEGIST_ROLE = keccak256(\"STRATEGIST_ROLE\");\n\n    /// @notice The PUSD/USDC/USDT/MIM Curve LP token\n    IERC20 public immutable want;\n    IERC20 public immutable jpeg;\n    IERC20 public immutable pusd;\n    IERC20 public immutable weth;\n    IERC20 public immutable usdc;\n\n    DexConfig public dexConfig;\n    CurveConfig public curveConfig;\n    ConvexConfig public convexConfig;\n    StrategyConfig public strategyConfig;\n\n    /// @notice The performance fee to be sent to the DAO/strategists\n    Rate public performanceFee;\n\n    /// @notice lifetime strategy earnings denominated in `want` token\n    uint256 public earned;\n\n    /// @param _want The PUSD/USDC/USDT/MIM Curve LP token\n    /// @param _jpeg The JPEG token address\n    /// @param _pusd The PUSD token address\n    /// @param _weth The WETH token address\n    /// @param _usdc The USDC token address\n    /// @param _dexConfig See {DexConfig} struct\n    /// @param _curveConfig See {CurveConfig} struct\n    /// @param _convexConfig See {ConvexConfig} struct\n    /// @param _strategyConfig See {StrategyConfig} struct\n    /// @param _performanceFee The rate of USDC to be sent to the DAO/strategists\n    constructor(\n        address _want,\n        address _jpeg,\n        address _pusd,\n        address _weth,\n        address _usdc,\n        DexConfig memory _dexConfig,\n        CurveConfig memory _curveConfig,\n        ConvexConfig memory _convexConfig,\n        StrategyConfig memory _strategyConfig,\n        Rate memory _performanceFee\n    ) {\n        require(_want != address(0), \"INVALID_WANT\");\n        require(_jpeg != address(0), \"INVALID_JPEG\");\n        require(_pusd != address(0), \"INVALID_PUSD\");\n        require(_weth != address(0), \"INVALID_WETH\");\n        require(_usdc != address(0), \"INVALID_USDC\");\n        require(\n            address(_dexConfig.uniswapV2) != address(0),\n            \"INVALID_UNISWAP_V2\"\n        );\n        require(\n            address(_dexConfig.uniswapV3) != address(0),\n            \"INVALID_UNISWAP_V3\"\n        );\n        require(address(_curveConfig.curve) != address(0), \"INVALID_CURVE\");\n        require(\n            _curveConfig.pusdIndex != _curveConfig.usdcIndex,\n            \"INVALID_CURVE_INDEXES\"\n        );\n        require(_curveConfig.pusdIndex < 4, \"INVALID_PUSD_CURVE_INDEX\");\n        require(_curveConfig.usdcIndex < 4, \"INVALID_USDC_CURVE_INDEX\");\n        require(\n            address(_convexConfig.booster) != address(0),\n            \"INVALID_CONVEX_BOOSTER\"\n        );\n        require(\n            address(_convexConfig.baseRewardPool) != address(0),\n            \"INVALID_CONVEX_BASE_REWARD_POOL\"\n        );\n        require(\n            address(_strategyConfig.controller) != address(0),\n            \"INVALID_CONTROLLER\"\n        );\n        require(\n            address(_strategyConfig.usdcVault) != address(0),\n            \"INVALID_USDC_VAULT\"\n        );\n\n        for (uint256 i = 0; i < _strategyConfig.rewardTokens.length; i++) {\n            require(\n                address(_strategyConfig.rewardTokens[i]) != address(0),\n                \"INVALID_REWARD_TOKEN\"\n            );\n        }\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        setPerformanceFee(_performanceFee);\n\n        want = IERC20(_want);\n        jpeg = IERC20(_jpeg);\n        pusd = IERC20(_pusd);\n        weth = IERC20(_weth);\n        usdc = IERC20(_usdc);\n\n        dexConfig = _dexConfig;\n        curveConfig = _curveConfig;\n        convexConfig = _convexConfig;\n        strategyConfig = _strategyConfig;\n    }\n\n    modifier onlyController() {\n        require(\n            msg.sender == address(strategyConfig.controller),\n            \"NOT_CONTROLLER\"\n        );\n        _;\n    }\n\n    /// @notice Allows the DAO to set the performance fee\n    /// @param _performanceFee The new performance fee\n    function setPerformanceFee(Rate memory _performanceFee)\n        public\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(\n            _performanceFee.denominator > 0 &&\n                _performanceFee.denominator >= _performanceFee.numerator,\n            \"INVALID_RATE\"\n        );\n        performanceFee = _performanceFee;\n    }\n\n    /// @notice Allows the DAO to set the strategy controller\n    /// @param _controller The new strategy controller\n    function setController(address _controller)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_controller != address(0), \"INVALID_CONTROLLER\");\n        strategyConfig.controller = IController(_controller);\n    }\n\n    /// @notice Allows the DAO to set the USDC vault\n    /// @param _vault The new USDC vault\n    function setUSDCVault(address _vault)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_vault != address(0), \"INVALID_USDC_VAULT\");\n        strategyConfig.usdcVault = IFungibleAssetVaultForDAO(_vault);\n    }\n\n    /// @return The strategy's name\n    function getName() external pure returns (string memory) {\n        return \"StrategyPUSDConvex\";\n    }\n\n    /// @return The amount of `want` tokens held by this contract\n    function balanceOfWant() public view returns (uint256) {\n        return want.balanceOf(address(this));\n    }\n\n    /// @return The amount of `want` tokens deposited in the Convex pool by this contract\n    function balanceOfPool() public view returns (uint256) {\n        return convexConfig.baseRewardPool.balanceOf(address(this));\n    }\n\n    /// @return The amount of JPEG currently held by this contract and the amount of JPEG\n    /// rewards available from Convex\n    function balanceOfJPEG() external view returns (uint256) {\n        uint256 availableBalance = jpeg.balanceOf(address(this));\n\n        IBaseRewardPool baseRewardPool = convexConfig.baseRewardPool;\n        uint256 length = baseRewardPool.extraRewardsLength();\n        for (uint256 i = 0; i < length; i++) {\n            IBaseRewardPool extraReward = IBaseRewardPool(baseRewardPool.extraRewards(i));\n            if (address(jpeg) == extraReward.rewardToken()) {\n                availableBalance += extraReward.earned();\n                //we found jpeg, no need to continue the loop\n                break;\n            }\n        }\n\n        return availableBalance;\n    }\n\n    /// @return The total amount of `want` tokens this contract manages (held + deposited)\n    function balanceOf() external view returns (uint256) {\n        return balanceOfWant() + balanceOfPool();\n    }\n\n    /// @notice Allows anyone to deposit the total amount of `want` tokens in this contract into Convex\n    function deposit() public {\n        uint256 balance = want.balanceOf(address(this));\n        ConvexConfig memory convex = convexConfig;\n        want.safeIncreaseAllowance(address(convex.booster), balance);\n        convex.booster.depositAll(convex.pid, true);\n    }\n\n    /// @notice Controller only function that allows to withdraw non-strategy tokens (e.g tokens sent accidentally)\n    function withdraw(IERC20 _asset)\n        external\n        onlyController\n        returns (uint256 balance)\n    {\n        require(want != _asset, \"want\");\n        require(pusd != _asset, \"pusd\");\n        require(usdc != _asset, \"usdc\");\n        require(weth != _asset, \"weth\");\n        require(jpeg != _asset, \"jpeg\");\n        balance = _asset.balanceOf(address(this));\n        _asset.safeTransfer(address(strategyConfig.controller), balance);\n    }\n\n    /// @notice Allows the controller to withdraw `want` tokens. Normally used with a vault withdrawal\n    /// @param _amount The amount of `want` tokens to withdraw\n    function withdraw(uint256 _amount) external onlyController {\n        address vault = strategyConfig.controller.vaults(address(want));\n        require(vault != address(0), \"ZERO_VAULT\"); // additional protection so we don't burn the funds\n\n        uint256 balance = want.balanceOf(address(this));\n        //if the contract doesn't have enough want, withdraw from Convex\n        if (balance < _amount)\n            convexConfig.baseRewardPool.withdrawAndUnwrap(\n                _amount - balance,\n                false\n            );\n\n        want.safeTransfer(vault, _amount);\n    }\n\n    /// @notice Allows the controller to withdraw all `want` tokens. Normally used when migrating strategies\n    /// @return balance The total amount of funds that have been withdrawn\n    function withdrawAll() external onlyController returns (uint256 balance) {\n        address vault = strategyConfig.controller.vaults(address(want));\n        require(vault != address(0), \"ZERO_VAULT\"); // additional protection so we don't burn the funds\n\n        convexConfig.baseRewardPool.withdrawAllAndUnwrap(false);\n\n        balance = want.balanceOf(address(this));\n        want.safeTransfer(vault, balance);\n    }\n\n    /// @notice Allows the controller to claim JPEG rewards from Convex\n    /// and withdraw JPEG to the `_to` address\n    /// @param _to The address to send JPEG to\n    function withdrawJPEG(address _to) external onlyController {\n        // claim from convex rewards pool\n        convexConfig.baseRewardPool.getReward(address(this), true);\n        jpeg.safeTransfer(_to, jpeg.balanceOf(address(this)));\n    }\n\n    /// @notice Allows members of the `STRATEGIST_ROLE` to compound Convex rewards into Curve\n    /// @param minOutCurve The minimum amount of `want` tokens to receive\n    function harvest(uint256 minOutCurve) external onlyRole(STRATEGIST_ROLE) {\n        convexConfig.baseRewardPool.getReward(address(this), true);\n\n        //Prevent `Stack too deep` errors\n        {\n            DexConfig memory dex = dexConfig;\n            IERC20[] memory rewardTokens = strategyConfig.rewardTokens;\n            IERC20 _weth = weth;\n            for (uint256 i = 0; i < rewardTokens.length; i++) {\n                uint256 balance = rewardTokens[i].balanceOf(address(this));\n\n                if (balance > 0)\n                    //minOut is not needed here, we already have it on the Curve deposit\n                    _swapUniswapV2(\n                        dex.uniswapV2,\n                        rewardTokens[i],\n                        _weth,\n                        balance,\n                        0\n                    );\n            }\n\n            uint256 wethBalance = _weth.balanceOf(address(this));\n            require(wethBalance > 0, \"NOOP\");\n\n            //handle sending jpeg here\n\n            _weth.safeIncreaseAllowance(address(dex.uniswapV3), wethBalance);\n\n            //minOut is not needed here, we already have it on the Curve deposit\n            ISwapRouter.ExactInputParams memory params = ISwapRouter\n                .ExactInputParams(\n                    abi.encodePacked(weth, uint24(500), usdc),\n                    address(this),\n                    block.timestamp,\n                    wethBalance,\n                    0\n                );\n\n            dex.uniswapV3.exactInput(params);\n        }\n\n        StrategyConfig memory strategy = strategyConfig;\n        CurveConfig memory curve = curveConfig;\n\n        uint256 usdcBalance = usdc.balanceOf(address(this));\n\n        //take the performance fee\n        uint256 fee = (usdcBalance * performanceFee.numerator) /\n            performanceFee.denominator;\n        usdc.safeTransfer(strategy.controller.feeAddress(), fee);\n        usdcBalance -= fee;\n\n        uint256 pusdCurveBalance = curve.curve.balances(curve.pusdIndex);\n        //USDC has 6 decimals while PUSD has 18. We need to convert the USDC\n        //balance to 18 decimals to compare it with the PUSD balance\n        uint256 usdcCurveBalance = curve.curve.balances(curve.usdcIndex) *\n            10**12;\n\n        //The curve pool has 4 tokens, we are doing a single asset deposit with either USDC or PUSD\n        uint256[4] memory liquidityAmounts = [uint256(0), 0, 0, 0];\n        if (usdcCurveBalance > pusdCurveBalance) {\n            //if there's more USDC than PUSD in the pool, use USDC as collateral to mint PUSD\n            //and deposit it into the Curve pool\n            usdc.safeIncreaseAllowance(\n                address(strategy.usdcVault),\n                usdcBalance\n            );\n            strategy.usdcVault.deposit(usdcBalance);\n\n            //check the vault's credit limit, it should be 1:1 for USDC\n            uint256 toBorrow = strategy.usdcVault.getCreditLimit(usdcBalance);\n\n            strategy.usdcVault.borrow(toBorrow);\n            liquidityAmounts[curve.pusdIndex] = toBorrow;\n\n            pusd.safeIncreaseAllowance(address(curve.curve), toBorrow);\n        } else {\n            //if there's more PUSD than USDC in the pool, deposit USDC\n            liquidityAmounts[curve.usdcIndex] = usdcBalance;\n            usdc.safeIncreaseAllowance(address(curve.curve), usdcBalance);\n        }\n\n        curve.curve.add_liquidity(liquidityAmounts, minOutCurve);\n\n        uint256 wantBalance = balanceOfWant();\n\n        deposit();\n\n        earned += wantBalance;\n        emit Harvested(wantBalance);\n    }\n\n    /// @dev Swaps `tokenIn` for `tokenOut` on UniswapV2 (or Sushiswap)\n    /// @param router The UniswapV2 (or Sushiswap) router\n    /// @param tokenIn The input token for the swap\n    /// @param tokenOut The output token for the swap\n    /// @param amountIn The amount of `tokenIn` to swap\n    /// @param minOut The minimum amount of `tokenOut` to receive for the TX not to revert\n    function _swapUniswapV2(\n        IUniswapV2Router router,\n        IERC20 tokenIn,\n        IERC20 tokenOut,\n        uint256 amountIn,\n        uint256 minOut\n    ) internal {\n        tokenIn.safeIncreaseAllowance(address(router), amountIn);\n\n        address[] memory path = new address[](2);\n        path[0] = address(tokenIn);\n        path[1] = address(tokenOut);\n\n        router.swapExactTokensForTokens(\n            amountIn,\n            minOut,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n}"
    }
  ]
}