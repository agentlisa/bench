{
  "Title": "M-3: Invalid oracle version can cause the `maker` position to exceed `makerLimit`, temporarily or permanently bricking the Market contract",
  "Content": "# Issue M-3: Invalid oracle version can cause the `maker` position to exceed `makerLimit`, temporarily or permanently bricking the Market contract \n\nSource: https://github.com/sherlock-audit/2023-10-perennial-judging/issues/24 \n\n## Found by \npanprog\n## Summary\n\nWhen invalid oracle version happens, positions pending at the oracle version are invalidated with the following pending positions increasing or decreasing in size. When this happens, all position limit checks are not applied (and can't be cancelled/modified), but they are still verified for the final positions in _invariant. This means that many checks are bypassed during such event. There is a protection against underflow due to this problem by enforcing the calculated `closable` value to be 0 or higher. However, exactly the same problem can happen with overflow and there is no protection against it. \n\n## Vulnerability Detail\n\nFor example:\n\n- Latest global maker = maker limit = 1000\n- Pending global maker = 500 [t=100]\n- Pending global maker = 1000 [t=200]\n\nIf oracle version at t = 100 is invalid, then pending global maker = 1500 (at t = 200). However, due to this check in _invariant:\n```solidity\nif (context.currentPosition.global.maker.gt(context.riskParameter.makerLimit))\n    revert MarketMakerOverLimitError();\n```\nall Market updates will revert except update to reduce maker position by 500+, which might not be even possible in 1 update depending on maker distribution between users. For example, if 5 users have maker = 300 (1500 total), then no single user can update to reduce maker by 500.\nThis will temporarily brick Market (all updates will revert) until coordinator increases maker limit. If the limit is already close to max possible (2^62-1), then the contract will be bricked permanently (all updates will revert regardless of maker limit, because global maker will exceed 2^62-1 in calculations and will revert when trying to store it).\n\nThe same issue can also cause the other problems, such as:\n- Bypassing the market utilization limit if long/short is increased above maker\n- User unexpectedly becomes liquidatable with too high position (for example: position 500 -> pending 0 -> pending 500 - will make current = 1000 if middle oracle version is invalid)\n\n## Impact\n\nIf current maker is close to maker limit, and some user(s) reduce their maker then immediately increase back, and the oracle version is invalid, maker will be above the maker limit and the Market will be temporarily bricked until coordinator increases the maker limit. Even though it's temporary, it still bricked for some time and coordinator is forced to increase maker limit, breaking the intended market config. Furthermore, once the maker limit is increased, there is no guarantee that the users will reduce it so that the limit can be reduced back.\n\nAlso, for some low-price tokens, the maker limit can be close to max possible value (2^62-1 is about `4*1e18` or `Fixed6(4*1e12)`). If the token price is about $0.00001, this means such maker limit allows `$4*1e7` or $40M. So, if low-value token with $40M maker limit is used, this issue will lead to maker overflow 2^62-1 and bricking the Market permanently, with all users being unable to withdraw their funds, losing everything.\n\nWhile this situation is not very likely, it's well possible. For example, if the maker is close to limit, any maker reducing the position will have some other user immediately take up the freed up maker space, so things like global maker change of: 1000->900->1000 are easily possible and any invalid oracle version will likely cause the maker overflowing the limit.\n\n## Code Snippet\n\n`_processPositionGlobal` invalidates the pending position if oracle version is invalid:\nhttps://github.com/sherlock-audit/2023-10-perennial/blob/main/perennial-v2/packages/perennial/contracts/Market.sol#L486\n\nThis is done by changing the `invalidation` accumulated values of the position. When each position is loaded, it's also adjusted by applying the difference between accumulated invalidation of the latest and the loaded position:\nhttps://github.com/sherlock-audit/2023-10-perennial/blob/main/perennial-v2/packages/perennial/contracts/Market.sol#L223-L229\n\nSuch invalidation change will update the current position ignoring any position limits. If global maker is increased above maker limit, then any `Market.update` call will revert at the following line:\nhttps://github.com/sherlock-audit/2023-10-perennial/blob/main/perennial-v2/packages/perennial/contracts/Market.sol#L586-L587\n\nAlternatively, if the new position size (maker, long or short) is above 2^62-1, the `Market.update` will permanently revert at the following lines when trying to store new position value:\nhttps://github.com/sherlock-audit/2023-10-perennial/blob/main/perennial-v2/packages/perennial/contracts/types/Position.sol#L533-L535\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe same issue for underflow is already resolved by using `closable` and enforcing such pending positions that no invalid oracle can cause the position to be less than 0. This issue can be resolved in the same way, by introducing some `opeanable` value (calculated similar to `closable`, but in reverse - when position is increased, it's increased, when position is decreased, it doesn't change) and enforcing different limits, such that `settled position + openable`:\n- can not exceed the max maker\n- can not break utilization\n- for local position - calculate maxMagnitude amount from `settled + local openable` instead of absolute pending position values for margined/maintained calculations.\n\n\n\n## Discussion\n\n**kbrizzle**\n\nInvariant bricking issue resolved via: https://github.com/equilibria-xyz/perennial-v2/pull/155.\n\nMargin using the incorrect maximum pending position resolved by: https://github.com/equilibria-xyz/perennial-v2/pull/168.\n\nWe chose to *not fix* the incorrect maximum `makerLimit` issue due to the complexity involved in implementing the above pending open calculation on the **global** pending positions compared to its relatively low severity since the error on the limit is capped. We will make a note of this property for parameter tuning, especially for markets with expected invalid versions.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/123",
  "Code": [
    {
      "filename": "perennial-v2/packages/perennial/contracts/Market.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"@equilibria/root/attribute/ReentrancyGuard.sol\";\nimport \"./interfaces/IMarket.sol\";\nimport \"./interfaces/IMarketFactory.sol\";\n\n/// @title Market\n/// @notice Manages logic and state for a single market.\n/// @dev Cloned by the Factory contract to launch new markets.\ncontract Market is IMarket, Instance, ReentrancyGuard {\n    Fixed6 private constant MAGIC_VALUE_WITHDRAW_ALL_COLLATERAL = Fixed6.wrap(type(int256).min);\n    UFixed6 private constant MAGIC_VALUE_UNCHANGED_POSITION = UFixed6.wrap(type(uint256).max);\n    UFixed6 private constant MAGIC_VALUE_FULLY_CLOSED_POSITION = UFixed6.wrap(type(uint256).max - 1);\n\n    /// @dev The underlying token that the market settles in\n    Token18 public token;\n\n    /// @dev The token that incentive rewards are paid in\n    Token18 public reward;\n\n    /// @dev The oracle that provides the market price\n    IOracleProvider public oracle;\n\n    /// @dev The payoff function over the underlying oracle\n    IPayoffProvider public payoff;\n\n    /// @dev Beneficiary of the market, receives donations\n    address public beneficiary;\n\n    /// @dev Risk coordinator of the market\n    address public coordinator;\n\n    /// @dev Risk parameters of the market\n    RiskParameterStorage private _riskParameter;\n\n    /// @dev Parameters of the market\n    MarketParameterStorage private _parameter;\n\n    /// @dev Current global state of the market\n    GlobalStorage private _global;\n\n    /// @dev Current global position of the market\n    PositionStorageGlobal private _position;\n\n    /// @dev The global pending versions for each id\n    mapping(uint256 => PositionStorageGlobal) private _pendingPosition;\n\n    /// @dev Current local state of each account\n    mapping(address => LocalStorage) private _locals;\n\n    /// @dev Current local position of each account\n    mapping(address => PositionStorageLocal) private _positions;\n\n    /// @dev The local pending versions for each id for each account\n    mapping(address => mapping(uint256 => PositionStorageLocal)) private _pendingPositions;\n\n    /// @dev The historical version accumulator data for each accessed version\n    mapping(uint256 => VersionStorage) private _versions;\n\n    /// @notice Initializes the contract state\n    /// @param definition_ The market definition\n    function initialize(IMarket.MarketDefinition calldata definition_) external initializer(1) {\n        __Instance__initialize();\n        __ReentrancyGuard__initialize();\n\n        token = definition_.token;\n        oracle = definition_.oracle;\n        payoff = definition_.payoff;\n    }\n\n    /// @notice Updates the account's position and collateral\n    /// @param account The account to operate on\n    /// @param newMaker The new maker position for the account\n    /// @param newMaker The new long position for the account\n    /// @param newMaker The new short position for the account\n    /// @param collateral The collateral amount to add or remove from the account\n    /// @param protect Whether to put the account into a protected status for liquidations\n    function update(\n        address account,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        Fixed6 collateral,\n        bool protect\n    ) external nonReentrant whenNotPaused {\n        Context memory context = _loadContext(account);\n        _settle(context, account);\n        _update(context, account, newMaker, newLong, newShort, collateral, protect);\n        _saveContext(context, account);\n    }\n\n    /// @notice Updates the beneficiary of the market\n    /// @param newBeneficiary The new beneficiary address\n    function updateBeneficiary(address newBeneficiary) external onlyOwner {\n        beneficiary = newBeneficiary;\n        emit BeneficiaryUpdated(newBeneficiary);\n    }\n\n    /// @notice Updates the coordinator of the market\n    /// @param newCoordinator The new coordinator address\n    function updateCoordinator(address newCoordinator) external onlyOwner {\n        coordinator = newCoordinator;\n        emit CoordinatorUpdated(newCoordinator);\n    }\n\n    /// @notice Updates the parameter set of the market\n    /// @param newParameter The new parameter set\n    function updateParameter(MarketParameter memory newParameter) external onlyOwner {\n        _parameter.validateAndStore(newParameter, IMarketFactory(address(factory())).parameter(), reward);\n        emit ParameterUpdated(newParameter);\n    }\n\n    /// @notice Updates the risk parameter set of the market\n    /// @param newRiskParameter The new risk parameter set\n    function updateRiskParameter(RiskParameter memory newRiskParameter) external onlyCoordinator {\n        _riskParameter.validateAndStore(newRiskParameter, IMarketFactory(address(factory())).parameter());\n        emit RiskParameterUpdated(newRiskParameter);\n    }\n\n    /// @notice Updates the reward token of the market\n    /// @param newReward The new reward token\n    function updateReward(Token18 newReward) public onlyOwner {\n        if (!reward.eq(Token18Lib.ZERO)) revert MarketRewardAlreadySetError();\n        if (newReward.eq(token)) revert MarketInvalidRewardError();\n\n        reward = newReward;\n        emit RewardUpdated(newReward);\n    }\n\n    /// @notice Claims any available fee that the sender has accrued\n    /// @dev Applicable fees include: protocol, oracle, risk, and donation\n    function claimFee() external {\n        Global memory newGlobal = _global.read();\n\n        if (_claimFee(factory().owner(), newGlobal.protocolFee)) newGlobal.protocolFee = UFixed6Lib.ZERO;\n        if (_claimFee(address(IMarketFactory(address(factory())).oracleFactory()), newGlobal.oracleFee))\n            newGlobal.oracleFee = UFixed6Lib.ZERO;\n        if (_claimFee(coordinator, newGlobal.riskFee)) newGlobal.riskFee = UFixed6Lib.ZERO;\n        if (_claimFee(beneficiary, newGlobal.donation)) newGlobal.donation = UFixed6Lib.ZERO;\n\n        _global.store(newGlobal);\n    }\n\n    /// @notice Helper function to handle a singular fee claim.\n    /// @param receiver The address to receive the fee\n    /// @param fee The amount of the fee to claim\n    function _claimFee(address receiver, UFixed6 fee) private returns (bool) {\n        if (msg.sender != receiver) return false;\n\n        token.push(receiver, UFixed18Lib.from(fee));\n        emit FeeClaimed(receiver, fee);\n        return true;\n    }\n\n    /// @notice Claims any available reward that the sender has accrued\n    function claimReward() external {\n        Local memory newLocal = _locals[msg.sender].read();\n\n        reward.push(msg.sender, UFixed18Lib.from(newLocal.reward));\n        emit RewardClaimed(msg.sender, newLocal.reward);\n\n        newLocal.reward = UFixed6Lib.ZERO;\n        _locals[msg.sender].store(newLocal);\n    }\n\n    /// @notice Returns the current parameter set\n    function parameter() external view returns (MarketParameter memory) {\n        return _parameter.read();\n    }\n\n    /// @notice Returns the current risk parameter set\n    function riskParameter() external view returns (RiskParameter memory) {\n        return _riskParameter.read();\n    }\n\n    /// @notice Returns the current global position\n    function position() external view returns (Position memory) {\n        return _position.read();\n    }\n\n    /// @notice Returns the current local position for the account\n    /// @param account The account to query\n    function positions(address account) external view returns (Position memory) {\n        return _positions[account].read();\n    }\n\n    /// @notice Returns the current global state\n    function global() external view returns (Global memory) {\n        return _global.read();\n    }\n\n    /// @notice Returns the historical version snapshot at the given timestamp\n    /// @param timestamp The timestamp to query\n    function versions(uint256 timestamp) external view returns (Version memory) {\n        return _versions[timestamp].read();\n    }\n\n    /// @notice Returns the local state for the given account\n    /// @param account The account to query\n    function locals(address account) external view returns (Local memory) {\n        return _locals[account].read();\n    }\n\n    /// @notice Returns the global pending position for the given id\n    /// @param id The id to query\n    function pendingPosition(uint256 id) external view returns (Position memory) {\n        return _pendingPosition[id].read();\n    }\n\n    /// @notice Returns the local pending position for the given account and id\n    /// @param account The account to query\n    /// @param id The id to query\n    function pendingPositions(address account, uint256 id) external view returns (Position memory) {\n        return _pendingPositions[account][id].read();\n    }\n\n    /// @notice Loads the specified global pending position from state and adjusts it\n    /// @param context The context to use\n    /// @param id The position id to load\n    /// @return newPendingPosition The loaded and global adjusted position\n    function _loadPendingPositionGlobal(\n        Context memory context,\n        uint256 id\n    ) private view returns (Position memory newPendingPosition) {\n        newPendingPosition = _pendingPosition[id].read();\n        newPendingPosition.adjust(context.latestPosition.global);\n    }\n\n    /// @notice Loads the specified local pending position from state and adjusts it\n    /// @param context The context to use\n    /// @param id The position id to load\n    /// @return newPendingPosition The loaded and local adjusted position\n    function _loadPendingPositionLocal(\n        Context memory context,\n        address account,\n        uint256 id\n    ) private view returns (Position memory newPendingPosition) {\n        newPendingPosition = _pendingPositions[account][id].read();\n        newPendingPosition.adjust(context.latestPosition.local);\n    }\n\n    /// @notice Loads the context information of a pending position\n    /// @dev Must process pending position in order from latest + 1 to current (post update)\n    /// @param context The context to use\n    /// @param newPendingPosition The pending position to process\n    function _processPendingPosition(Context memory context, Position memory newPendingPosition) private pure {\n        context.pendingCollateral = context.pendingCollateral\n            .sub(newPendingPosition.fee)\n            .sub(Fixed6Lib.from(newPendingPosition.keeper));\n\n        context.closable = context.closable\n            .sub(context.previousPendingMagnitude\n                .sub(newPendingPosition.magnitude().min(context.previousPendingMagnitude)));\n        context.previousPendingMagnitude = newPendingPosition.magnitude();\n\n        if (context.previousPendingMagnitude.gt(context.maxPendingMagnitude))\n            context.maxPendingMagnitude = newPendingPosition.magnitude();\n    }\n\n    /// @notice Loads the context for the update process\n    /// @param context The context to load to\n    /// @param account The account to query\n    function _loadUpdateContext(Context memory context, address account) private view {\n        // load latest position\n        context.pendingCollateral = context.local.collateral;\n        context.maxPendingMagnitude = context.previousPendingMagnitude = context.closable =\n            context.latestPosition.local.magnitude();\n\n        // load current position\n        context.currentPosition.global = _loadPendingPositionGlobal(context, context.global.currentId);\n        context.currentPosition.global.invalidation.update(context.latestPosition.global.invalidation);\n        context.currentPosition.local = _loadPendingPositionLocal(context, account, context.local.currentId);\n        context.currentPosition.local.invalidation.update(context.latestPosition.local.invalidation);\n\n        // advance to next id if applicable\n        if (context.currentTimestamp > context.currentPosition.local.timestamp) {\n            context.local.currentId++;\n            context.currentPosition.local.prepare();\n        }\n        if (context.currentTimestamp > context.currentPosition.global.timestamp) {\n            context.global.currentId++;\n            context.currentPosition.global.prepare();\n        }\n\n        // load pending positions\n        for (uint256 id = context.local.latestId + 1; id < context.local.currentId; id++)\n            _processPendingPosition(context, _loadPendingPositionLocal(context, account, id));\n    }\n\n    /// @notice Modifies the collateral input per magic values\n    /// @param context The context to use\n    /// @param collateral The collateral to process\n    /// @return The resulting collateral value\n    function _processCollateralMagicValue(Context memory context, Fixed6 collateral) private pure returns (Fixed6) {\n        if (collateral.eq(MAGIC_VALUE_WITHDRAW_ALL_COLLATERAL))\n            return context.local.collateral.mul(Fixed6Lib.NEG_ONE);\n        return collateral;\n    }\n\n    /// @notice Modifies the position input per magic values\n    /// @param context The context to use\n    /// @param currentPosition The current position prior to update\n    /// @param newPosition The position to process\n    /// @return The resulting position value\n    function _processPositionMagicValue(\n        Context memory context,\n        UFixed6 currentPosition,\n        UFixed6 newPosition\n    ) private pure returns (UFixed6) {\n        if (newPosition.eq(MAGIC_VALUE_UNCHANGED_POSITION))\n            return currentPosition;\n        if (newPosition.eq(MAGIC_VALUE_FULLY_CLOSED_POSITION)) {\n            if (currentPosition.isZero()) return currentPosition;\n            return context.previousPendingMagnitude.sub(context.closable.min(context.previousPendingMagnitude));\n        }\n        return newPosition;\n    }\n\n    /// @notice Updates the current position\n    /// @param context The context to use\n    /// @param account The account to update\n    /// @param newMaker The new maker position size\n    /// @param newLong The new long position size\n    /// @param newShort The new short position size\n    /// @param collateral The change in collateral\n    /// @param protect Whether to protect the position for liquidation\n    function _update(\n        Context memory context,\n        address account,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        Fixed6 collateral,\n        bool protect\n    ) private {\n        // load\n        _loadUpdateContext(context, account);\n\n        // magic values\n        collateral = _processCollateralMagicValue(context, collateral);\n        newMaker = _processPositionMagicValue(context, context.currentPosition.local.maker, newMaker);\n        newLong = _processPositionMagicValue(context, context.currentPosition.local.long, newLong);\n        newShort = _processPositionMagicValue(context, context.currentPosition.local.short, newShort);\n\n        // update position\n        Order memory newOrder =\n            context.currentPosition.local.update(context.currentTimestamp, newMaker, newLong, newShort);\n        context.currentPosition.global.update(context.currentTimestamp, newOrder, context.riskParameter);\n\n        // update fee\n        newOrder.registerFee(context.latestVersion, context.marketParameter, context.riskParameter);\n        context.currentPosition.local.registerFee(newOrder);\n        context.currentPosition.global.registerFee(newOrder);\n\n        // update collateral\n        context.local.update(collateral);\n        context.currentPosition.local.update(collateral);\n        context.pendingCollateral = context.pendingCollateral.add(collateral);\n\n        // process current position\n        _processPendingPosition(context, context.currentPosition.local);\n\n        // protect account\n        bool protected = context.local.protect(context.latestPosition.local, context.currentTimestamp, protect);\n\n        // request version\n        if (!newOrder.isEmpty()) oracle.request(IMarket(this), account);\n\n        // after\n        _invariant(context, account, newOrder, collateral, protected);\n\n        // store\n        _pendingPosition[context.global.currentId].store(context.currentPosition.global);\n        _pendingPositions[account][context.local.currentId].store(context.currentPosition.local);\n\n        // fund\n        if (collateral.sign() == 1) token.pull(msg.sender, UFixed18Lib.from(collateral.abs()));\n        if (collateral.sign() == -1) token.push(msg.sender, UFixed18Lib.from(collateral.abs()));\n\n        // events\n        emit Updated(msg.sender, account, context.currentTimestamp, newMaker, newLong, newShort, collateral, protect);\n    }\n\n    /// @notice Loads the context of the transaction\n    /// @param account The account to load the context of\n    /// @return context The loaded context\n    function _loadContext(address account) private view returns (Context memory context) {\n        // parameters\n        context.protocolParameter = IMarketFactory(address(factory())).parameter();\n        context.marketParameter = _parameter.read();\n        context.riskParameter = _riskParameter.read();\n\n        // state\n        context.global = _global.read();\n        context.local = _locals[account].read();\n\n        // oracle\n        (context.latestVersion, context.currentTimestamp) = _oracleVersion();\n        context.positionVersion = _oracleVersionAtPosition(context, _position.read());\n    }\n\n    /// @notice Stores the given context\n    /// @param context The context to store\n    /// @param account The account to store for\n    function _saveContext(Context memory context, address account) private {\n        _global.store(context.global);\n        _locals[account].store(context.local);\n    }\n\n    /// @notice Settles the account position up to the latest version\n    /// @param context The context to use\n    /// @param account The account to settle\n    function _settle(Context memory context, address account) private {\n        context.latestPosition.global = _position.read();\n        context.latestPosition.local = _positions[account].read();\n\n        Position memory nextPosition;\n\n        // settle\n        while (\n            context.global.currentId != context.global.latestId &&\n            (nextPosition = _loadPendingPositionGlobal(context, context.global.latestId + 1))\n                .ready(context.latestVersion)\n        ) _processPositionGlobal(context, context.global.latestId + 1, nextPosition);\n\n        while (\n            context.local.currentId != context.local.latestId &&\n            (nextPosition = _loadPendingPositionLocal(context, account, context.local.latestId + 1))\n                .ready(context.latestVersion)\n        ) {\n            Fixed6 previousDelta = _pendingPositions[account][context.local.latestId].read().delta;\n            _processPositionLocal(context, account, context.local.latestId + 1, nextPosition);\n            _checkpointCollateral(context, account, previousDelta, nextPosition);\n        }\n\n        // sync\n        if (context.latestVersion.timestamp > context.latestPosition.global.timestamp) {\n            nextPosition = _loadPendingPositionGlobal(context, context.global.latestId);\n            nextPosition.sync(context.latestVersion);\n            _processPositionGlobal(context, context.global.latestId, nextPosition);\n        }\n\n        if (context.latestVersion.timestamp > context.latestPosition.local.timestamp) {\n            nextPosition = _loadPendingPositionLocal(context, account, context.local.latestId);\n            nextPosition.sync(context.latestVersion);\n            _processPositionLocal(context, account, context.local.latestId, nextPosition);\n        }\n\n        // overwrite latestPrice if invalid\n        context.latestVersion.price = context.global.latestPrice;\n\n        _position.store(context.latestPosition.global);\n        _positions[account].store(context.latestPosition.local);\n    }\n\n    /// @notice Places a collateral checkpoint for the account on the given pending position\n    /// @param context The context to use\n    /// @param account The account to checkpoint for\n    /// @param previousDelta The previous pending position's delta value\n    /// @param nextPosition The next pending position\n    function _checkpointCollateral(\n        Context memory context,\n        address account,\n        Fixed6 previousDelta,\n        Position memory nextPosition\n    ) private {\n        Position memory latestAccountPosition = _pendingPositions[account][context.local.latestId].read();\n        Position memory currentAccountPosition = _pendingPositions[account][context.local.currentId].read();\n        latestAccountPosition.collateral = context.local.collateral\n            .sub(currentAccountPosition.delta.sub(previousDelta))         // deposits happen after snapshot point\n            .add(nextPosition.fee)                                        // position fee happens after snapshot point\n            .add(Fixed6Lib.from(nextPosition.keeper));                    // keeper fee happens after snapshot point\n        _pendingPositions[account][context.local.latestId].store(latestAccountPosition);\n    }\n\n    /// @notice Processes the given global pending position into the latest position\n    /// @param context The context to use\n    /// @param newPositionId The id of the pending position to process\n    /// @param newPosition The pending position to process\n    function _processPositionGlobal(Context memory context, uint256 newPositionId, Position memory newPosition) private {\n        Version memory version = _versions[context.latestPosition.global.timestamp].read();\n        OracleVersion memory oracleVersion = _oracleVersionAtPosition(context, newPosition);\n\n        if (!oracleVersion.valid) context.latestPosition.global.invalidate(newPosition);\n\n        (uint256 fromTimestamp, uint256 fromId) = (context.latestPosition.global.timestamp, context.global.latestId);\n        (VersionAccumulationResult memory accumulationResult, UFixed6 accumulatedFee) = version.accumulate(\n            context.global,\n            context.latestPosition.global,\n            newPosition,\n            context.positionVersion,\n            oracleVersion,\n            context.marketParameter,\n            context.riskParameter\n        );\n        context.latestPosition.global.update(newPosition);\n        context.global.update(newPositionId, oracleVersion.price);\n        context.global.incrementFees(\n            accumulatedFee,\n            newPosition.keeper,\n            context.marketParameter,\n            context.protocolParameter\n        );\n        context.positionVersion = oracleVersion;\n        _versions[newPosition.timestamp].store(version);\n\n        // events\n        emit PositionProcessed(\n            fromTimestamp,\n            newPosition.timestamp,\n            fromId,\n            newPositionId,\n            accumulationResult\n        );\n    }\n\n    /// @notice Processes the given local pending position into the latest position\n    /// @param context The context to use\n    /// @param account The account to process for\n    /// @param newPositionId The id of the pending position to process\n    /// @param newPosition The pending position to process\n    function _processPositionLocal(\n        Context memory context,\n        address account,\n        uint256 newPositionId,\n        Position memory newPosition\n    ) private {\n        Version memory version = _versions[newPosition.timestamp].read();\n        if (!version.valid) context.latestPosition.local.invalidate(newPosition);\n\n        (uint256 fromTimestamp, uint256 fromId) = (context.latestPosition.local.timestamp, context.local.latestId);\n        LocalAccumulationResult memory accumulationResult = context.local.accumulate(\n            newPositionId,\n            context.latestPosition.local,\n            newPosition,\n            _versions[context.latestPosition.local.timestamp].read(),\n            version\n        );\n        context.latestPosition.local.update(newPosition);\n\n        // events\n        emit AccountPositionProcessed(\n            account,\n            fromTimestamp,\n            newPosition.timestamp,\n            fromId,\n            newPositionId,\n            accumulationResult\n        );\n    }\n\n    /// @notice Verifies the invariant of the market\n    /// @param context The context to use\n    /// @param account The account to verify the invariant for\n    /// @param newOrder The order to verify the invariant for\n    /// @param collateral The collateral change to verify the invariant for\n    /// @param protected Whether the new position is protected\n    function _invariant(\n        Context memory context,\n        address account,\n        Order memory newOrder,\n        Fixed6 collateral,\n        bool protected\n    ) private view {\n        if (protected && (\n            !context.closable.isZero() ||\n            context.latestPosition.local.maintained(\n                context.latestVersion,\n                context.riskParameter,\n                context.pendingCollateral.sub(collateral)\n            ) ||\n            collateral.lt(Fixed6Lib.from(-1, _liquidationFee(context, newOrder)))\n        )) revert MarketInvalidProtectionError();\n\n        if (\n            !(context.currentPosition.local.magnitude().isZero() && context.latestPosition.local.magnitude().isZero()) &&   // sender has no position\n            !(newOrder.isEmpty() && collateral.gte(Fixed6Lib.ZERO)) &&                                                      // sender is depositing zero or more into account, without position change\n            (context.currentTimestamp - context.latestVersion.timestamp >= context.riskParameter.staleAfter)                // price is not stale\n        ) revert MarketStalePriceError();\n\n        if (context.marketParameter.closed && newOrder.increasesPosition())\n            revert MarketClosedError();\n\n        if (context.currentPosition.global.maker.gt(context.riskParameter.makerLimit))\n            revert MarketMakerOverLimitError();\n\n        if (!newOrder.singleSided(context.currentPosition.local) || !newOrder.singleSided(context.latestPosition.local))\n            revert MarketNotSingleSidedError();\n\n        if (protected) return; // The following invariants do not apply to protected position updates (liquidations)\n\n        if (\n            msg.sender != account &&                                                        // sender is operating on own account\n            !IMarketFactory(address(factory())).operators(account, msg.sender) &&           // sender is operator approved for account\n            !(newOrder.isEmpty() && collateral.gte(Fixed6Lib.ZERO))                         // sender is depositing zero or more into account, without position change\n        ) revert MarketOperatorNotAllowedError();\n\n        if (\n            context.global.currentId > context.global.latestId + context.marketParameter.maxPendingGlobal ||\n            context.local.currentId > context.local.latestId + context.marketParameter.maxPendingLocal\n        ) revert MarketExceedsPendingIdLimitError();\n\n        if (\n            !context.currentPosition.local.margined(context.latestVersion, context.riskParameter, context.pendingCollateral)\n        ) revert MarketInsufficientMarginError();\n\n        if (\n            !PositionLib.maintained(context.maxPendingMagnitude, context.latestVersion, context.riskParameter, context.pendingCollateral)\n        ) revert MarketInsufficientMaintenanceError();\n\n        if (\n            (context.local.protection > context.latestPosition.local.timestamp) &&\n            !newOrder.isEmpty()\n        ) revert MarketProtectedError();\n\n        if (\n            newOrder.liquidityCheckApplicable(context.marketParameter) &&\n            newOrder.efficiency.lt(Fixed6Lib.ZERO) &&\n            context.currentPosition.global.efficiency().lt(context.riskParameter.efficiencyLimit)\n        ) revert MarketEfficiencyUnderLimitError();\n\n        if (\n            newOrder.liquidityCheckApplicable(context.marketParameter) &&\n            context.currentPosition.global.socialized() &&\n            newOrder.decreasesLiquidity()\n        ) revert MarketInsufficientLiquidityError();\n\n        if (collateral.lt(Fixed6Lib.ZERO) && context.pendingCollateral.lt(Fixed6Lib.ZERO))\n            revert MarketInsufficientCollateralError();\n    }\n\n    /// @notice Computes the liquidation fee for the current latest local position\n    /// @param context The context to use\n    /// @param order The order to use\n    /// @return The liquidation fee\n    function _liquidationFee(Context memory context, Order memory order) private view returns (UFixed6) {\n        return order\n            .liquidationFee(context.latestVersion, context.riskParameter)\n            .min(UFixed6Lib.from(token.balanceOf()));\n    }\n\n    /// @notice Computes the current oracle status with the market's payoff\n    /// @return latestVersion The latest oracle version with payoff applied\n    /// @return currentTimestamp The current oracle timestamp\n    function _oracleVersion() private view returns (OracleVersion memory latestVersion, uint256 currentTimestamp) {\n        (latestVersion, currentTimestamp) = oracle.status();\n        _transform(latestVersion);\n    }\n\n    /// @notice Computes the latest oracle version at a given timestamp with the market's payoff\n    /// @param timestamp The timestamp to use\n    /// @return oracleVersion The oracle version at the given timestamp with payoff applied\n    function _oracleVersionAt(uint256 timestamp) private view returns (OracleVersion memory oracleVersion) {\n        oracleVersion = oracle.at(timestamp);\n        _transform(oracleVersion);\n    }\n\n    /// @notice Computes the latest oracle version at a given position with the market's payoff\n    /// @dev applies the latest valid price when the version at position is invalid\n    /// @param context The context to use\n    /// @param toPosition The position to use\n    /// @return oracleVersion The oracle version at the given position\n    function _oracleVersionAtPosition(\n        Context memory context,\n        Position memory toPosition\n    ) private view returns (OracleVersion memory oracleVersion) {\n        oracleVersion = _oracleVersionAt(toPosition.timestamp);\n        if (!oracleVersion.valid) oracleVersion.price = context.global.latestPrice;\n    }\n\n    /// @notice Applies the market's payoff to an oracle version\n    /// @param oracleVersion The oracle version to transform\n    function _transform(OracleVersion memory oracleVersion) private view {\n        if (address(payoff) != address(0)) oracleVersion.price = payoff.payoff(oracleVersion.price);\n    }\n\n    /// @notice Only the coordinator or the owner can call\n    modifier onlyCoordinator {\n        if (msg.sender != coordinator && msg.sender != factory().owner()) revert MarketNotCoordinatorError();\n        _;\n    }\n}"
    },
    {
      "filename": "perennial-v2/packages/perennial/contracts/Market.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"@equilibria/root/attribute/ReentrancyGuard.sol\";\nimport \"./interfaces/IMarket.sol\";\nimport \"./interfaces/IMarketFactory.sol\";\n\n/// @title Market\n/// @notice Manages logic and state for a single market.\n/// @dev Cloned by the Factory contract to launch new markets.\ncontract Market is IMarket, Instance, ReentrancyGuard {\n    Fixed6 private constant MAGIC_VALUE_WITHDRAW_ALL_COLLATERAL = Fixed6.wrap(type(int256).min);\n    UFixed6 private constant MAGIC_VALUE_UNCHANGED_POSITION = UFixed6.wrap(type(uint256).max);\n    UFixed6 private constant MAGIC_VALUE_FULLY_CLOSED_POSITION = UFixed6.wrap(type(uint256).max - 1);\n\n    /// @dev The underlying token that the market settles in\n    Token18 public token;\n\n    /// @dev The token that incentive rewards are paid in\n    Token18 public reward;\n\n    /// @dev The oracle that provides the market price\n    IOracleProvider public oracle;\n\n    /// @dev The payoff function over the underlying oracle\n    IPayoffProvider public payoff;\n\n    /// @dev Beneficiary of the market, receives donations\n    address public beneficiary;\n\n    /// @dev Risk coordinator of the market\n    address public coordinator;\n\n    /// @dev Risk parameters of the market\n    RiskParameterStorage private _riskParameter;\n\n    /// @dev Parameters of the market\n    MarketParameterStorage private _parameter;\n\n    /// @dev Current global state of the market\n    GlobalStorage private _global;\n\n    /// @dev Current global position of the market\n    PositionStorageGlobal private _position;\n\n    /// @dev The global pending versions for each id\n    mapping(uint256 => PositionStorageGlobal) private _pendingPosition;\n\n    /// @dev Current local state of each account\n    mapping(address => LocalStorage) private _locals;\n\n    /// @dev Current local position of each account\n    mapping(address => PositionStorageLocal) private _positions;\n\n    /// @dev The local pending versions for ea"
    }
  ]
}