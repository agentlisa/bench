{
  "Title": "[N-08] Use a more recent version of solidity",
  "Content": "\nUse a solidity version of at least 0.8.12 to get `string.concat()` to be used instead of `abi.encodePacked(,)`\n\n```solidity\nFile: contracts/actions/topup/handlers/CTokenRegistry.sol   #1\n\n2 pragma solidity 0.8.9;\n```\n\n<https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CTokenRegistry.sol#L2>\n\n```solidity\nFile: contracts/actions/topup/TopUpActionFeeHandler.sol   #2\n\n2 pragma solidity 0.8.9;\n```\n\n<https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpActionFeeHandler.sol#L2>\n\n```solidity\nFile: contracts/actions/topup/TopUpAction.sol   #3\n\n2 pragma solidity 0.8.9;\n```\n\n<https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L2>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-04-backd",
  "Code": [
    {
      "filename": "backd/contracts/actions/topup/handlers/CTokenRegistry.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"../../../../interfaces/vendor/CToken.sol\";\nimport \"../../../../interfaces/vendor/Comptroller.sol\";\nimport \"../../../../libraries/Errors.sol\";\n\ncontract CTokenRegistry {\n    Comptroller public immutable comptroller;\n\n    address public constant COMPTROLLER_MAINNET_ADDRESS =\n        address(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B);\n\n    mapping(address => address) internal _underlyingToCToken;\n\n    constructor(address comptrollerAddress) {\n        comptroller = Comptroller(comptrollerAddress);\n        _updateCTokenMapping();\n    }\n\n    /**\n     * @notice Tries to read the CToken contract address for a given underlying token address\n     * If not found, tries to fetch it from the Comptroller contract and fails if\n     * cannot find it in the comptroller either\n     */\n    function fetchCToken(address underlying) external returns (CToken) {\n        CToken ctoken = getCToken(underlying, false);\n        if (address(ctoken) != address(0)) {\n            return CToken(ctoken);\n        }\n\n        _updateCTokenMapping();\n        return getCToken(underlying, true);\n    }\n\n    /**\n     * @notice Reads the CToken contract address for a given underlying token address\n     * or fails if not found\n     */\n    function getCToken(address underlying) external view returns (CToken) {\n        return getCToken(underlying, true);\n    }\n\n    /**\n     * @notice Reads the CToken contract address for a given underlying token address\n     * If `ensureExists` is `true`, fails if not found, otherwise returns address 0\n     */\n    function getCToken(address underlying, bool ensureExists) public view returns (CToken) {\n        CToken ctoken = CToken(_underlyingToCToken[underlying]);\n        if (ensureExists && (address(ctoken) == address(0) || !_isCTokenUsable(ctoken))) {\n            revert(Error.UNDERLYING_NOT_SUPPORTED);\n        }\n        return ctoken;\n    }\n\n    /**\n     * @dev Updates the CToken mapping by fetching information from the Comptroller contract\n     */\n    function _updateCTokenMapping() internal {\n        CToken[] memory ctokens = comptroller.getAllMarkets();\n        for (uint256 i = 0; i < ctokens.length; i++) {\n            CToken ctoken = ctokens[i];\n            if (!_isCTokenUsable(ctoken)) {\n                continue;\n            }\n            if (\n                keccak256(abi.encodePacked(ctoken.symbol())) == keccak256(abi.encodePacked(\"cETH\"))\n            ) {\n                _underlyingToCToken[address(0)] = address(ctoken);\n            } else {\n                _underlyingToCToken[ctoken.underlying()] = address(ctoken);\n            }\n        }\n    }\n\n    function _isCTokenUsable(CToken ctoken) internal view returns (bool) {\n        (bool listed, , ) = comptroller.markets(address(ctoken));\n        // NOTE: comptroller.isDeprecated is not available on Kovan\n        bool deprecated = address(comptroller) == COMPTROLLER_MAINNET_ADDRESS &&\n            comptroller.isDeprecated(ctoken);\n        return listed && !deprecated;\n    }\n}"
    },
    {
      "filename": "backd/contracts/actions/topup/TopUpActionFeeHandler.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../../../interfaces/actions/IActionFeeHandler.sol\";\nimport \"../../../interfaces/IController.sol\";\nimport \"../../../interfaces/tokenomics/IKeeperGauge.sol\";\n\nimport \"../../../libraries/Errors.sol\";\nimport \"../../../libraries/ScaledMath.sol\";\nimport \"../../../libraries/AddressProviderHelpers.sol\";\n\nimport \"../../LpToken.sol\";\nimport \"../../access/Authorization.sol\";\nimport \"../../pool/LiquidityPool.sol\";\nimport \"../../utils/Preparable.sol\";\n\n/**\n * @notice Contract to manage the distribution protocol fees\n */\ncontract TopUpActionFeeHandler is IActionFeeHandler, Authorization, Preparable {\n    using ScaledMath for uint256;\n    using SafeERC20Upgradeable for LpToken;\n    using AddressProviderHelpers for IAddressProvider;\n\n    bytes32 internal constant _KEEPER_FEE_FRACTION_KEY = \"KeeperFee\";\n    bytes32 internal constant _KEEPER_GAUGE_KEY = \"KeeperGauge\";\n    bytes32 internal constant _TREASURY_FEE_FRACTION_KEY = \"TreasuryFee\";\n\n    address public immutable actionContract;\n    IController public immutable controller;\n\n    mapping(address => uint256) public treasuryAmounts;\n    mapping(address => mapping(address => uint256)) public keeperRecords;\n\n    event KeeperFeesClaimed(address indexed keeper, address token, uint256 totalClaimed);\n\n    event FeesPayed(\n        address indexed payer,\n        address indexed keeper,\n        address token,\n        uint256 amount,\n        uint256 keeperAmount,\n        uint256 lpAmount\n    );\n\n    constructor(\n        IController _controller,\n        address _actionContract,\n        uint256 keeperFee,\n        uint256 treasuryFee\n    ) Authorization(_controller.addressProvider().getRoleManager()) {\n        require(keeperFee + treasuryFee <= ScaledMath.ONE, Error.INVALID_AMOUNT);\n        actionContract = _actionContract;\n        controller = _controller;\n        _setConfig(_KEEPER_FEE_FRACTION_KEY, keeperFee);\n        _setConfig(_TREASURY_FEE_FRACTION_KEY, treasuryFee);\n    }\n\n    function setInitialKeeperGaugeForToken(address lpToken, address _keeperGauge)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        require(getKeeperGauge(lpToken) == address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        require(_keeperGauge != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        _setConfig(_getKeeperGaugeKey(lpToken), _keeperGauge);\n        return true;\n    }\n\n    /**\n     * @notice Transfers the keeper and treasury fees to the fee handler and burns LP fees.\n     * @param payer Account who's position the fees are charged on.\n     * @param beneficiary Beneficiary of the fees paid (usually this will be the keeper).\n     * @param amount Total fee value (both keeper and LP fees).\n     * @param lpTokenAddress Address of the lpToken used to pay fees.\n     * @return `true` if successful.\n     */\n    function payFees(\n        address payer,\n        address beneficiary,\n        uint256 amount,\n        address lpTokenAddress\n    ) external override returns (bool) {\n        require(msg.sender == actionContract, Error.UNAUTHORIZED_ACCESS);\n        // Handle keeper fees\n        uint256 keeperAmount = amount.scaledMul(getKeeperFeeFraction());\n        uint256 treasuryAmount = amount.scaledMul(getTreasuryFeeFraction());\n        LpToken lpToken = LpToken(lpTokenAddress);\n\n        lpToken.safeTransferFrom(msg.sender, address(this), amount);\n\n        address keeperGauge = getKeeperGauge(lpTokenAddress);\n        if (keeperGauge != address(0)) {\n            IKeeperGauge(keeperGauge).reportFees(beneficiary, keeperAmount, lpTokenAddress);\n        }\n\n        // Accrue keeper and treasury fees here for periodic claiming\n        keeperRecords[beneficiary][lpTokenAddress] += keeperAmount;\n        treasuryAmounts[lpTokenAddress] += treasuryAmount;\n\n        // Handle LP fees\n        uint256 lpAmount = amount - keeperAmount - treasuryAmount;\n        lpToken.burn(lpAmount);\n        emit FeesPayed(payer, beneficiary, lpTokenAddress, amount, keeperAmount, lpAmount);\n        return true;\n    }\n\n    /**\n     * @notice Claim all accrued fees for an LPToken.\n     * @param beneficiary Address to claim the fees for.\n     * @param token Address of the lpToken for claiming.\n     * @return `true` if successful.\n     */\n    function claimKeeperFeesForPool(address beneficiary, address token)\n        external\n        override\n        returns (bool)\n    {\n        uint256 totalClaimable = keeperRecords[beneficiary][token];\n        require(totalClaimable > 0, Error.NOTHING_TO_CLAIM);\n        keeperRecords[beneficiary][token] = 0;\n\n        LpToken lpToken = LpToken(token);\n        lpToken.safeTransfer(beneficiary, totalClaimable);\n\n        emit KeeperFeesClaimed(beneficiary, token, totalClaimable);\n        return true;\n    }\n\n    /**\n     * @notice Claim all accrued treasury fees for an LPToken.\n     * @param token Address of the lpToken for claiming.\n     * @return `true` if successful.\n     */\n    function claimTreasuryFees(address token) external override returns (bool) {\n        uint256 claimable = treasuryAmounts[token];\n        treasuryAmounts[token] = 0;\n        LpToken(token).safeTransfer(controller.addressProvider().getTreasury(), claimable);\n        return true;\n    }\n\n    /**\n     * @notice Prepare update of keeper fee (with time delay enforced).\n     * @param newKeeperFee New keeper fee value.\n     * @return `true` if successful.\n     */\n    function prepareKeeperFee(uint256 newKeeperFee) external onlyGovernance returns (bool) {\n        require(newKeeperFee <= ScaledMath.ONE, Error.INVALID_AMOUNT);\n        return _prepare(_KEEPER_FEE_FRACTION_KEY, newKeeperFee);\n    }\n\n    /**\n     * @notice Execute update of keeper fee (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New keeper fee.\n     */\n    function executeKeeperFee() external returns (uint256) {\n        require(\n            pendingUInts256[_TREASURY_FEE_FRACTION_KEY] +\n                pendingUInts256[_KEEPER_FEE_FRACTION_KEY] <=\n                ScaledMath.ONE,\n            Error.INVALID_AMOUNT\n        );\n        return _executeUInt256(_KEEPER_FEE_FRACTION_KEY);\n    }\n\n    function resetKeeperFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_KEEPER_FEE_FRACTION_KEY);\n    }\n\n    function prepareKeeperGauge(address lpToken, address newKeeperGauge)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_getKeeperGaugeKey(lpToken), newKeeperGauge);\n    }\n\n    function executeKeeperGauge(address lpToken) external returns (address) {\n        return _executeAddress(_getKeeperGaugeKey(lpToken));\n    }\n\n    function resetKeeperGauge(address lpToken) external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_getKeeperGaugeKey(lpToken));\n    }\n\n    /**\n     * @notice Prepare update of treasury fee (with time delay enforced).\n     * @param newTreasuryFee New treasury fee value.\n     * @return `true` if successful.\n     */\n    function prepareTreasuryFee(uint256 newTreasuryFee) external onlyGovernance returns (bool) {\n        require(newTreasuryFee <= ScaledMath.ONE, Error.INVALID_AMOUNT);\n        return _prepare(_TREASURY_FEE_FRACTION_KEY, newTreasuryFee);\n    }\n\n    /**\n     * @notice Execute update of treasury fee (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New treasury fee.\n     */\n    function executeTreasuryFee() external returns (uint256) {\n        require(\n            pendingUInts256[_TREASURY_FEE_FRACTION_KEY] +\n                pendingUInts256[_KEEPER_FEE_FRACTION_KEY] <=\n                ScaledMath.ONE,\n            Error.INVALID_AMOUNT\n        );\n        return _executeUInt256(_TREASURY_FEE_FRACTION_KEY);\n    }\n\n    function resetTreasuryFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_TREASURY_FEE_FRACTION_KEY);\n    }\n\n    function getKeeperFeeFraction() public view returns (uint256) {\n        return currentUInts256[_KEEPER_FEE_FRACTION_KEY];\n    }\n\n    function getKeeperGauge(address lpToken) public view returns (address) {\n        return currentAddresses[_getKeeperGaugeKey(lpToken)];\n    }\n\n    function getTreasuryFeeFraction() public view returns (uint256) {\n        return currentUInts256[_TREASURY_FEE_FRACTION_KEY];\n    }\n\n    function _getKeeperGaugeKey(address lpToken) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_KEEPER_GAUGE_KEY, lpToken));\n    }\n}"
    },
    {
      "filename": "backd/contracts/actions/topup/TopUpAction.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"../../../interfaces/IGasBank.sol\";\nimport \"../../../interfaces/pool/ILiquidityPool.sol\";\nimport \"../../../interfaces/ISwapperRegistry.sol\";\nimport \"../../../interfaces/IController.sol\";\nimport \"../../../interfaces/IStakerVault.sol\";\nimport \"../../../interfaces/ISwapper.sol\";\nimport \"../../../interfaces/actions/topup/ITopUpHandler.sol\";\nimport \"../../../interfaces/actions/topup/ITopUpAction.sol\";\nimport \"../../../interfaces/actions/IActionFeeHandler.sol\";\n\nimport \"../../../libraries/AddressProviderHelpers.sol\";\nimport \"../../../libraries/Errors.sol\";\nimport \"../../../libraries/ScaledMath.sol\";\nimport \"../../../libraries/EnumerableExtensions.sol\";\n\nimport \"../../access/Authorization.sol\";\nimport \"../../utils/Preparable.sol\";\n\n/**\n * @notice The logic here should really be part of the top-up action\n * but is split in a library to circumvent the byte-code size limit\n */\nlibrary TopUpActionLibrary {\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    function lockFunds(\n        address stakerVaultAddress,\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) external {\n        uint256 amountLeft = lockAmount;\n        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);\n\n        // stake deposit amount\n        if (depositAmount > 0) {\n            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;\n            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);\n            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);\n            stakerVault.stake(depositAmount);\n            stakerVault.increaseActionLockedBalance(payer, depositAmount);\n            amountLeft -= depositAmount;\n        }\n\n        // use stake vault allowance if available and required\n        if (amountLeft > 0) {\n            uint256 balance = stakerVault.balanceOf(payer);\n            uint256 allowance = stakerVault.allowance(payer, address(this));\n            uint256 availableFunds = balance < allowance ? balance : allowance;\n            if (availableFunds >= amountLeft) {\n                stakerVault.transferFrom(payer, address(this), amountLeft);\n                amountLeft = 0;\n            }\n        }\n\n        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);\n    }\n\n    /**\n     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.\n     */\n    function calcExchangeAmount(\n        IAddressProvider addressProvider,\n        address token,\n        address actionToken,\n        uint256 amount\n    ) external view returns (uint256) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        uint256 rate = pool.exchangeRate();\n        address underlying = pool.getUnderlying();\n        if (underlying == actionToken) {\n            return amount.scaledDivRoundUp(rate);\n        }\n\n        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);\n        uint256 swapperRate = swapper.getRate(underlying, actionToken);\n        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));\n    }\n\n    function getSwapper(\n        IAddressProvider addressProvider,\n        address underlying,\n        address actionToken\n    ) public view returns (ISwapper) {\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);\n        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);\n        return ISwapper(swapper);\n    }\n}\n\ncontract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {\n    using ScaledMath for uint256;\n    using ScaledMath for uint128;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n\n    /**\n     * @dev Temporary struct to hold local variables in execute\n     * and avoid the stack being \"too deep\"\n     */\n    struct ExecuteLocalVars {\n        uint256 minActionAmountToTopUp;\n        uint256 actionTokenAmount;\n        uint256 depositTotalFeesAmount;\n        uint256 actionAmountWithFees;\n        uint256 userFactor;\n        uint256 rate;\n        uint256 depositAmountWithFees;\n        uint256 depositAmountWithoutFees;\n        uint256 actionFee;\n        uint256 totalActionTokenAmount;\n        uint128 totalTopUpAmount;\n        bool success;\n        bytes topupResult;\n        uint256 gasBankBalance;\n        uint256 initialGas;\n        uint256 gasConsumed;\n        uint256 userGasPrice;\n        uint256 estimatedRequiredGas;\n        uint256 estimatedRequiredWeiForGas;\n        uint256 requiredWeiForGas;\n        uint256 reimbursedWeiForGas;\n        address underlying;\n        bool removePosition;\n    }\n\n    EnumerableSet.AddressSet private _usableTokens;\n\n    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;\n\n    bytes32 internal constant _ACTION_FEE_KEY = \"ActionFee\";\n    bytes32 internal constant _FEE_HANDLER_KEY = \"FeeHandler\";\n    bytes32 internal constant _TOP_UP_HANDLER_KEY = \"TopUpHandler\";\n    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = \"EstimatedGasUsage\";\n    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = \"MaxSwapperSlippage\";\n\n    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;\n    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;\n    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    EnumerableSet.Bytes32Set internal _supportedProtocols;\n\n    /// @notice mapping of (payer -> account -> protocol -> Record)\n    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;\n\n    mapping(address => RecordMeta[]) internal _userPositions;\n\n    EnumerableSet.AddressSet internal _usersWithPositions;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = controller.addressProvider();\n        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);\n    }\n\n    receive() external payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function initialize(\n        address feeHandler,\n        bytes32[] calldata protocols,\n        address[] calldata handlers\n    ) external initializer onlyGovernance {\n        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);\n        _setConfig(_FEE_HANDLER_KEY, feeHandler);\n        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);\n        for (uint256 i = 0; i < protocols.length; i++) {\n            bytes32 protocolKey = _getProtocolKey(protocols[i]);\n            _setConfig(protocolKey, handlers[i]);\n            _updateTopUpHandler(protocols[i], address(0), handlers[i]);\n        }\n    }\n\n    /**\n     * @notice Register a top up action.\n     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).\n     * @param account Account to be topped up (first 20 bytes will typically be the address).\n     * @param depositAmount Amount of `depositToken` that will be locked.\n     * @param protocol Protocol which holds position to be topped up.\n     * @param record containing the data for the position to register\n     */\n    function register(\n        bytes32 account,\n        bytes32 protocol,\n        uint128 depositAmount,\n        Record memory record\n    ) external payable returns (bool) {\n        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);\n        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);\n        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);\n        require(\n            _positions[msg.sender][account][protocol].threshold == 0,\n            Error.POSITION_ALREADY_EXISTS\n        );\n        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);\n        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);\n\n        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *\n            record.maxFee *\n            getEstimatedGasUsage();\n\n        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);\n\n        uint256 totalLockAmount = _calcExchangeAmount(\n            record.depositToken,\n            record.actionToken,\n            record.totalTopUpAmount\n        );\n        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);\n\n        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);\n\n        record.depositTokenBalance = uint128(totalLockAmount);\n        _positions[msg.sender][account][protocol] = record;\n        _userPositions[msg.sender].push(RecordMeta(account, protocol));\n        _usersWithPositions.add(msg.sender);\n\n        emit Register(\n            account,\n            protocol,\n            record.threshold,\n            msg.sender,\n            record.depositToken,\n            totalLockAmount,\n            record.actionToken,\n            record.singleTopUpAmount,\n            record.totalTopUpAmount,\n            record.maxFee,\n            record.extra\n        );\n        return true;\n    }\n\n    /**\n     * @notice See overloaded version of `execute` for more details.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol\n    ) external override returns (bool) {\n        return execute(payer, account, beneficiary, protocol, 0);\n    }\n\n    /**\n     * @notice Delete a position to back on the given protocol for `account`.\n     * @param account Account holding the position.\n     * @param protocol Protocol the position is held on.\n     * @param unstake If the tokens should be unstaked from vault.\n     * @return `true` if successful.\n     */\n    function resetPosition(\n        bytes32 account,\n        bytes32 protocol,\n        bool unstake\n    ) external override returns (bool) {\n        address payer = msg.sender;\n        Record memory position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n\n        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist\n        IStakerVault staker = IStakerVault(vault);\n        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);\n        if (unstake) {\n            staker.unstake(position.depositTokenBalance);\n            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);\n        } else {\n            staker.transfer(payer, position.depositTokenBalance);\n        }\n\n        _removePosition(payer, account, protocol);\n        addressProvider.getGasBank().withdrawUnused(payer);\n        return true;\n    }\n\n    /**\n     * @notice Execute top up handler update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @param protocol Protocol for which a new handler should be executed.\n     * @return Address of new handler.\n     */\n    function executeTopUpHandler(bytes32 protocol) external override returns (address) {\n        address oldHandler = _getHandler(protocol, false);\n        address newHandler = _executeAddress(_getProtocolKey(protocol));\n\n        _updateTopUpHandler(protocol, oldHandler, newHandler);\n        return newHandler;\n    }\n\n    /**\n     * @notice Reset new top up handler deadline for a protocol.\n     * @param protocol Protocol for which top up handler deadline should be reset.\n     * @return `true` if successful.\n     */\n    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_getProtocolKey(protocol));\n    }\n\n    /**\n     * @notice Prepare action fee update.\n     * @param newActionFee New fee to set.\n     * @return `true` if success.\n     */\n    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {\n        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);\n        return _prepare(_ACTION_FEE_KEY, newActionFee);\n    }\n\n    /**\n     * @notice Execute action fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return `true` if successful.\n     */\n    function executeActionFee() external override returns (uint256) {\n        return _executeUInt256(_ACTION_FEE_KEY);\n    }\n\n    /**\n     * @notice Reset action fee deadline.\n     * @return `true` if successful.\n     */\n    function resetActionFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ACTION_FEE_KEY);\n    }\n\n    /**\n     * @notice Prepare swapper slippage update.\n     * @param newSwapperSlippage New slippage to set.\n     * @return `true` if success.\n     */\n    function prepareSwapperSlippage(uint256 newSwapperSlippage)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        require(\n            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&\n                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,\n            Error.INVALID_AMOUNT\n        );\n        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);\n    }\n\n    /**\n     * @notice Execute swapper slippage update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return `true` if successful.\n     */\n    function executeSwapperSlippage() external override returns (uint256) {\n        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    /**\n     * @notice Reset action fee deadline.\n     * @return `true` if successful.\n     */\n    function resetSwapperSlippage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    /** Set fee handler */\n    /**\n     * @notice Prepare update of fee handler.\n     * @param handler New fee handler.\n     * @return `true` if success.\n     */\n    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {\n        return _prepare(_FEE_HANDLER_KEY, handler);\n    }\n\n    /**\n     * @notice Execute update of fee handler (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return `true` if successful.\n     */\n    function executeFeeHandler() external override returns (address) {\n        return _executeAddress(_FEE_HANDLER_KEY);\n    }\n\n    /**\n     * @notice Reset the handler deadline.\n     * @return `true` if success.\n     */\n    function resetFeeHandler() external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_FEE_HANDLER_KEY);\n    }\n\n    /**\n     * @notice Prepare update of estimated gas usage.\n     * @param gasUsage New estimated gas usage.\n     * @return `true` if success.\n     */\n    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {\n        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);\n    }\n\n    /**\n     * @notice Execute update of gas usage (with time delay enforced).\n     * @return `true` if successful.\n     */\n    function executeEstimatedGasUsage() external returns (uint256) {\n        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /**\n     * @notice Reset the gas usage deadline.\n     * @return `true` if success.\n     */\n    function resetGasUsage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /**\n     * @notice Add a new deposit token that is supported by the action.\n     * @dev There is a separate check for whether the usable token (i.e. deposit token)\n     *      is swappable for some action token.\n     * @param token Address of deposit token that can be used by the action.\n     */\n    function addUsableToken(address token) external override onlyGovernance returns (bool) {\n        return _usableTokens.add(token);\n    }\n\n    /**\n     * @notice Computes the total amount of ETH (as wei) required to pay for all\n     * the top-ups assuming the maximum gas price and the current estimated gas\n     * usage of a top-up\n     */\n    function getEthRequiredForGas(address payer) external view override returns (uint256) {\n        uint256 totalEthRequired = 0;\n        RecordMeta[] memory userRecordsMeta = _userPositions[payer];\n        uint256 gasUsagePerCall = getEstimatedGasUsage();\n        uint256 length = userRecordsMeta.length;\n        for (uint256 i = 0; i < length; i++) {\n            RecordMeta memory meta = userRecordsMeta[i];\n            Record memory record = _positions[payer][meta.account][meta.protocol];\n            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);\n            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;\n        }\n        return totalEthRequired;\n    }\n\n    /**\n     * @notice Returns a list of positions for the given payer\n     */\n    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {\n        return _userPositions[payer];\n    }\n\n    /**\n     * @notice Get a list supported protocols.\n     * @return List of supported protocols.\n     */\n    function getSupportedProtocols() external view override returns (bytes32[] memory) {\n        uint256 length = _supportedProtocols.length();\n        bytes32[] memory protocols = new bytes32[](length);\n        for (uint256 i = 0; i < length; i++) {\n            protocols[i] = _supportedProtocols.at(i);\n        }\n        return protocols;\n    }\n\n    /*\n     * @notice Gets a list of users that have an active position.\n     * @dev Uses cursor pagination.\n     * @param cursor The cursor for pagination (should start at 0 for first call).\n     * @param howMany Maximum number of users to return in this pagination request.\n     * @return users List of users that have an active position.\n     * @return nextCursor The cursor to use for the next pagination request.\n     */\n    function usersWithPositions(uint256 cursor, uint256 howMany)\n        external\n        view\n        override\n        returns (address[] memory users, uint256 nextCursor)\n    {\n        uint256 length = _usersWithPositions.length();\n        if (cursor >= length) return (new address[](0), 0);\n        if (howMany >= length - cursor) {\n            howMany = length - cursor;\n        }\n\n        address[] memory usersWithPositions_ = new address[](howMany);\n        for (uint256 i = 0; i < howMany; i++) {\n            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);\n        }\n\n        return (usersWithPositions_, cursor + howMany);\n    }\n\n    /**\n     * @notice Get a list of all tokens usable for this action.\n     * @dev This refers to all tokens that can be used as deposit tokens.\n     * @return Array of addresses of usable tokens.\n     */\n    function getUsableTokens() external view override returns (address[] memory) {\n        return _usableTokens.toArray();\n    }\n\n    /**\n     * @notice Retrieves the topup handler for the given `protocol`\n     */\n    function getTopUpHandler(bytes32 protocol) external view returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /**\n     * @notice Successfully tops up a position if it's conditions are met.\n     * @dev pool and vault funds are rebalanced after withdrawal for top up\n     * @param payer Account that pays for the top up.\n     * @param account Account owning the position for top up.\n     * @param beneficiary Address of the keeper's wallet for fee accrual.\n     * @param protocol Protocol of the top up position.\n     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas\n     * @return `true` if successful.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol,\n        uint256 maxWeiForGas\n    ) public override returns (bool) {\n        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENO"
    }
  ]
}