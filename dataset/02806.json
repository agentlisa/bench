{
  "Title": "H-13: Illuminate redemptions don't account for protocol pauses/temporary blocklistings",
  "Content": "# Issue H-13: Illuminate redemptions don't account for protocol pauses/temporary blocklistings \n\nSource: https://github.com/sherlock-audit/2022-10-illuminate-judging/issues/113 \n\n## Found by \nJeiwan, rvierdiiev, ak1, IllIllI, \\_\\_141345\\_\\_, cccz, ctf\\_sec, HonorLt, kenzo, Holmgren\n\n## Summary\n\nIlluminate redemptions don't account for protocol pauses/temporary blocklistings\n\n## Vulnerability Detail\n\nBy the time that Illuminate PTs have reached maturity, it's assumed that all external PTs will have been converted to underlying, so that the pool of combined underlying from the various protocols can be split on a per-Illuminate-PT-share basis. Unfortunately this may not be the case. Some of the protocol PTs that Illuminate supports as principals allow their own admins [to](https://docs.pendle.finance/docs/information/others/pausing-mechanism) [pause](https://docs.sense.finance/developers/security/#admin) [activity](# https://docs.notional.finance/developer-documentation/on-chain/notional-governance-reference#pauseability), and Illuminate has no way to protect users from redeeming while these protocol pauses are in effect. Unredeemed external PTs contribute zero underlying to the Illuminate PT's underlying balance, and when a user redeemes an Illuminate PT, the PT is burned for its share of what's available, not the total of what could be available in the future.\n\n\n## Impact\n\n_Permanent freezing of funds_\n\nIf a external PT is paused, or its PT is otherwise unable to be redeemed for the full amount when the user requests it, that unredeemed amount of underlying is not claimable (since the user's Illuminate PT is burned), and the user loses that amount of principal. If the external PT is later able to be redeemed, the remaining users will be given the principal that should have gon to the original user.\n\n\n## Code Snippet\n\nHoldings only increase when external PTs are redeemed successfully:\n```solidity\n// File: src/Redeemer.sol : Redeemer.redeem()   #1\n\n325            // Calculate how much underlying was redeemed\n326            uint256 redeemed = IERC20(u).balanceOf(address(this)) - starting;\n327    \n328            // Update the holding for this market\n329:           holdings[u][m] = holdings[u][m] + redeemed;\n```\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Redeemer.sol#L325-L329\n\n\n```solidity\n// File: src/Redeemer.sol : Redeemer.redeem()   #2\n\n385            // Get the amount received\n386            uint256 redeemed = IERC20(u).balanceOf(address(this)) - starting;\n387    \n388            // Verify that underlying are received 1:1 - cannot trust the adapter\n389            if (redeemed < amount) {\n390                revert Exception(13, 0, 0, address(0), address(0));\n391            }\n392    \n393            // Update the holdings for this market\n394:           holdings[u][m] = holdings[u][m] + redeemed;\n```\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Redeemer.sol#L385-L394\n\n\nAnd user redemptions of Illuminate PTs does not rely on external PT balances, only on the shares of what's available in the currently stored holdings balance at _any_ point after maturity:\n```solidity\n// File: src/Redeemer.sol : Redeemer.redeem()   #3\n\n413            // Verify the token has matured\n414            if (block.timestamp < token.maturity()) {\n415                revert Exception(7, block.timestamp, m, address(0), address(0));\n416            }\n417    \n418            // Get the amount of tokens to be redeemed from the sender\n419            uint256 amount = token.balanceOf(msg.sender);\n420    \n421            // Calculate how many tokens the user should receive\n422 @>         uint256 redeemed = (amount * holdings[u][m]) / token.totalSupply();\n423    \n424            // Update holdings of underlying\n425            holdings[u][m] = holdings[u][m] - redeemed;\n426    \n427            // Burn the user's principal tokens\n428:           token.authBurn(msg.sender, amount);\n```\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Redeemer.sol#L413-L428\n\n\n```solidity\n// File: src/Redeemer.sol : Redeemer.authRedeem()   #4\n\n457            // Make sure the market has matured\n458            uint256 maturity = pt.maturity();\n459            if (block.timestamp < maturity) {\n460                revert Exception(7, maturity, 0, address(0), address(0));\n461            }\n462    \n463            // Calculate the amount redeemed\n464 @>         uint256 redeemed = (a * holdings[u][m]) / pt.totalSupply();\n465    \n466            // Update holdings of underlying\n467            holdings[u][m] = holdings[u][m] - redeemed;\n468    \n469            // Burn the user's principal tokens\n470:           pt.authBurn(f, a);\n```\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Redeemer.sol#L449-L470\n\n\n```solidity\n// File: src/Redeemer.sol : Redeemer.autoRedeem()   #5\n\n485        function autoRedeem(\n486            address u,\n487            uint256 m,\n488            address[] calldata f\n489        ) external returns (uint256) {\n490            // Get the principal token for the given market\n491            IERC5095 pt = IERC5095(IMarketPlace(marketPlace).token(u, m, 0));\n492    \n493            // Make sure the market has matured\n494            uint256 maturity = pt.maturity();\n495            if (block.timestamp < maturity) {\n496                revert Exception(7, maturity, 0, address(0), address(0));\n497            }\n...\n514                uint256 amount = pt.balanceOf(f[i]);\n515    \n516                // Calculate how many tokens the user should receive\n517 @>             uint256 redeemed = (amount * holdings[u][m]) / pt.totalSupply();\n518    \n519                // Calculate the fees to be received (currently .025%)\n520                uint256 fee = redeemed / feenominator;\n521    \n522                // Verify allowance\n523                if (allowance < amount) {\n524                    revert Exception(20, allowance, amount, address(0), address(0));\n525                }\n526    \n527                // Burn the tokens from the user\n528:               pt.authBurn(f[i], amount);\n```\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Redeemer.sol#L485-L528\n\n\nThe Illuminate admin has no way to pause/disable redemption for users that try to redeem via `ERC5095.redeem()/withdraw()` or via `autoRedeem()`.\n\n`autoRedeem()` doesn't use the `unpaused` modifier, and does not rely on the normal `redeem()` for redemption:\n```solidity\n// File: src/Redeemer.sol : Redeemer.u   #6\n\n485        function autoRedeem(\n486            address u,\n487            uint256 m,\n488            address[] calldata f\n489 @>     ) external returns (uint256) {\n490            // Get the principal token for the given market\n491            IERC5095 pt = IERC5095(IMarketPlace(marketPlace).token(u, m, 0));\n492    \n493            // Make sure the market has matured\n494            uint256 maturity = pt.maturity();\n495            if (block.timestamp < maturity) {\n496:               revert Exception(7, maturity, 0, address(0), address(0));\n```\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Redeemer.sol#L485-L496\n\n\nThe ERC5095 also does not use the `unpaused` modifier. It uses `authRedeem()` for its post-maturity redemptions (the pre-maturity redemptions also are not pausable)...:\n```solidity\n// File: src/tokens/ERC5095.sol : ERC5095.redeem()   #7\n\n284        function redeem(\n285            uint256 s,\n286            address r,\n287            address o\n288 @>     ) external override returns (uint256) {\n...\n318                // Post-maturity\n319            } else {\n320                if (o == msg.sender) {\n321                    return\n322 @>                     IRedeemer(redeemer).authRedeem(\n323                            underlying,\n324                            maturity,\n325                            msg.sender,\n326                            r,\n327                            s\n328                        );\n329                } else {\n330                    uint256 allowance = _allowance[o][msg.sender];\n331                    if (allowance < s) {\n332                        revert Exception(20, allowance, s, address(0), address(0));\n333                    }\n334                    _allowance[o][msg.sender] = allowance - s;\n335                    return\n336 @>                     IRedeemer(redeemer).authRedeem(\n337                            underlying,\n338                            maturity,\n339                            o,\n340                            r,\n341                            s\n342                        );\n343                }\n344            }\n345:       }\n```\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/tokens/ERC5095.sol#L284-L345\n\n\n...and `authRedeem()` does not use the modifier either:\n\n```solidity\n// File: src/Redeemer.sol : Redeemer.authRedeem()   #8\n\n443        function authRedeem(\n444            address u,\n445            uint256 m,\n446            address f,\n447            address t,\n448            uint256 a\n449        )\n450            external\n451 @>         authorized(IMarketPlace(marketPlace).token(u, m, 0))\n452            returns (uint256)\n453        {\n454            // Get the principal token for the given market\n455            IERC5095 pt = IERC5095(IMarketPlace(marketPlace).token(u, m, 0));\n456    \n457            // Make sure the market has matured\n458            uint256 maturity = pt.maturity();\n459            if (block.timestamp < maturity) {\n460                revert Exception(7, maturity, 0, address(0), address(0));\n461:           }\n```\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Redeemer.sol#L443-L461\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nThis is hard to solve without missing corner cases, because each external PT may have its own idosyncratic reasons for delays, and there may be losses/slippage involved when redeeming for underlying. I believe the only way that wouldn't allow griefing, would be to track the number of external PTs of each type that were deposited for minting Illuminate PTs on a per-market basis, and `require()` that the number of each that have been redeemed equals the minting count, before allowing the redemption of any Illuminate PTs for that market. You would also need an administrator override that bypasses this check for specific external PTs of specific maturities. All of this assumes that none of the external PTs have rebasing functionality. Also, add the `unpaused` modifier to both `Redeemer.autoRedeem()` and `Redeemer.authRedeem()`.\n\n## Discussion\n\n**JTraversa**\n\nUnsure if this is being used as the main ticket for the authRedeem/autoRedeem when paused, as that issue is mentioned alongside the primary description of external PTs that may have been paused, preventing redemption in time for iPT maturity.\n\nIf this ticket is primarily regarding the latter, i'd probably contest and claim that we would have ample time between external PT maturity and our own maturity to pause ourselves and remediate any issues should there be external pauses. \n\nThis current implementation of manual pausing saves significant gas when compared to the suggested remediation given the additional storage required for individual market checks, so as long as we are not irresponsible / our keepers are operating, there are no additional risks introduced here that are remediated by checking balances and requiring 1:1 amounts.\n\n**0x00052**\n\nEscalate for 1 USDC\n\nReminder @Evert0x \n\n**sherlock-admin**\n\n > Escalate for 1 USDC\n> \n> Reminder @Evert0x \n\nYou've created a valid escalation for 1 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/12",
  "Code": [
    {
      "filename": "src/Redeemer.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\nimport 'src/MarketPlace.sol';\n\nimport 'src/lib/Safe.sol';\nimport 'src/errors/Exception.sol';\n\nimport 'src/interfaces/IERC5095.sol';\nimport 'src/interfaces/IERC20.sol';\nimport 'src/interfaces/ITempus.sol';\nimport 'src/interfaces/ITempusPool.sol';\nimport 'src/interfaces/ITempusToken.sol';\nimport 'src/interfaces/IAPWine.sol';\nimport 'src/interfaces/IAPWineController.sol';\nimport 'src/interfaces/IAPWineFutureVault.sol';\nimport 'src/interfaces/IAPWineToken.sol';\nimport 'src/interfaces/IAPWineAMMPool.sol';\nimport 'src/interfaces/ISwivel.sol';\nimport 'src/interfaces/ISwivelToken.sol';\nimport 'src/interfaces/IElementToken.sol';\nimport 'src/interfaces/IYieldToken.sol';\nimport 'src/interfaces/INotional.sol';\nimport 'src/interfaces/IPendle.sol';\nimport 'src/interfaces/IPendleForge.sol';\nimport 'src/interfaces/IPendleToken.sol';\nimport 'src/interfaces/ISenseDivider.sol';\nimport 'src/interfaces/ISenseAdapter.sol';\nimport 'src/interfaces/IYield.sol';\nimport 'src/interfaces/IConverter.sol';\n\nimport 'forge-std/Test.sol';\n\n/// @title Redeemer\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice The Redeemer contract is used to redeem the underlying lent capital of a loan.\n/// @notice Users may redeem their ERC-5095 tokens for the underlying asset represented by that token after maturity.\ncontract Redeemer {\n    /// @notice address that is allowed to set fees and contracts, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the MarketPlace contract, used to access the markets mapping\n    address public marketPlace;\n    /// @notice address that custodies principal tokens for all markets\n    address public lender;\n    /// @notice address that converts compounding tokens to their underlying\n    address public converter;\n\n    /// @notice third party contract needed to redeem Swivel PTs\n    address public immutable swivelAddr;\n    /// @notice third party contract needed to redeem Pendle PTs\n    address public immutable pendleAddr;\n    /// @notice third party contract needed to redeem Tempus PTs\n    address public immutable tempusAddr;\n\n    /// @notice this value determines the amount of fees paid on auto redemptions\n    uint256 public feenominator;\n    /// @notice represents a point in time where the feenominator may change\n    uint256 public feeChange;\n    /// @notice represents a minimum that the feenominator must exceed\n    uint256 public MIN_FEENOMINATOR = 500;\n\n    /// @notice mapping that indicates how much underlying has been redeemed by a market\n    mapping(address => mapping(uint256 => uint256)) public holdings;\n    /// @notice mapping that determines if a market's iPT can be redeemed\n    mapping(address => mapping(uint256 => bool)) public paused;\n\n    /// @notice emitted upon redemption of a loan\n    event Redeem(\n        uint8 principal,\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 amount,\n        address sender\n    );\n    /// @notice emitted upon changing the admin\n    event SetAdmin(address indexed admin);\n    /// @notice emitted upon changing the converter\n    event SetConverter(address indexed converter);\n    /// @notice emitted upon setting the fee rate\n    event SetFee(uint256 indexed fee);\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Exception(0, 0, 0, msg.sender, a);\n        }\n        _;\n    }\n\n    /// @notice reverts on all markets where the paused mapping returns true\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    modifier unpaused(address u, uint256 m) {\n        if (paused[u][m]) {\n            revert Exception(17, m, 0, u, address(0));\n        }\n        _;\n    }\n\n    /// @notice Initializes the Redeemer contract\n    /// @param l the lender contract\n    /// @param s the Swivel contract\n    /// @param p the Pendle contract\n    /// @param t the Tempus contract\n    constructor(\n        address l,\n        address s,\n        address p,\n        address t\n    ) {\n        admin = msg.sender;\n        lender = l;\n        swivelAddr = s;\n        pendleAddr = p;\n        tempusAddr = t;\n        feenominator = 4000;\n    }\n\n    /// @notice sets the admin address\n    /// @param a Address of a new admin\n    /// @return bool true if successful\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        emit SetAdmin(a);\n        return true;\n    }\n\n    /// @notice sets the address of the marketplace contract which contains the addresses of all the fixed rate markets\n    /// @param m the address of the marketplace contract\n    /// @return bool true if the address was set\n    function setMarketPlace(address m)\n        external\n        authorized(admin)\n        returns (bool)\n    {\n        if (marketPlace != address(0)) {\n            revert Exception(5, 0, 0, marketPlace, address(0));\n        }\n        marketPlace = m;\n        return true;\n    }\n\n    /// @notice sets the converter address\n    /// @param c address of the new converter\n    /// @return bool true if successful\n    function setConverter(address c) external authorized(admin) returns (bool) {\n        converter = c;\n        emit SetConverter(c);\n        return true;\n    }\n\n    /// @notice sets the address of the lender contract which contains the addresses of all the fixed rate markets\n    /// @param l the address of the lender contract\n    /// @return bool true if the address was set\n    function setLender(address l) external authorized(admin) returns (bool) {\n        if (lender != address(0)) {\n            revert Exception(8, 0, 0, address(lender), address(0));\n        }\n        lender = l;\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param f the new value of the feenominator, fees are not collected when the feenominator is 0\n    /// @return bool true if successful\n    function setFee(uint256 f) external authorized(admin) returns (bool) {\n        uint256 feeTime = feeChange;\n        if (feeTime == 0) {\n            revert Exception(23, 0, 0, address(0), address(0));\n        } else if (feeTime < block.timestamp) {\n            revert Exception(\n                24,\n                block.timestamp,\n                feeTime,\n                address(0),\n                address(0)\n            );\n        } else if (f < MIN_FEENOMINATOR) {\n            revert Exception(25, 0, 0, address(0), address(0));\n        }\n        feenominator = f;\n        delete feeChange;\n        emit SetFee(f);\n        return true;\n    }\n\n    /// @notice allows admin to stop redemptions of Illuminate PTs for a given market\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param b true to pause, false to unpause\n    function pauseRedemptions(\n        address u,\n        uint256 m,\n        bool b\n    ) external authorized(admin) {\n        paused[u][m] = b;\n    }\n\n    /// @notice approves the converter to spend the compounding asset\n    /// @param i an interest bearing token that must be approved for conversion\n    function approve(address i) external authorized(marketPlace) {\n        if (i != address(0)) {\n            Safe.approve(IERC20(i), address(converter), type(uint256).max);\n        }\n    }\n\n    /// @notice redeem method for Swivel, Yield, Element, Pendle, APWine, Tempus and Notional protocols\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m\n    ) external returns (bool) {\n        // Get the principal token that is being redeemed by the user\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Get the maturity for the given principal token\n        uint256 maturity;\n        if (p == uint8(MarketPlace.Principals.Swivel)) {\n            maturity = ISwivelToken(principal).maturity();\n        } else if (p == uint8(MarketPlace.Principals.Yield)) {\n            maturity = IYieldToken(principal).maturity();\n        } else if (p == uint8(MarketPlace.Principals.Element)) {\n            maturity = IElementToken(principal).unlockTimestamp();\n        } else if (p == uint8(MarketPlace.Principals.Pendle)) {\n            maturity = IPendleToken(principal).expiry();\n        } else if (p == uint8(MarketPlace.Principals.Tempus)) {\n            maturity = ITempusPool(ITempusToken(principal).pool())\n                .maturityTime();\n        } else if (p == uint8(MarketPlace.Principals.Apwine)) {\n            // APWine's maturity is retrieved indirectly via the PT's\n            // futureVault and Controller\n            address futureVault = IAPWineToken(principal).futureVault();\n\n            address controller = IAPWineFutureVault(futureVault)\n                .getControllerAddress();\n\n            uint256 duration = IAPWineFutureVault(futureVault)\n                .PERIOD_DURATION();\n\n            maturity = IAPWineController(controller).getNextPeriodStart(\n                duration\n            );\n        } else if (p == uint8(MarketPlace.Principals.Notional)) {\n            maturity = INotional(principal).getMaturity();\n        } else {\n            revert Exception(6, p, 0, address(0), address(0));\n        }\n\n        // Verify that the token has matured\n        if (maturity > block.timestamp) {\n            revert Exception(7, maturity, 0, address(0), address(0));\n        }\n\n        // Cache the lender to save gas on sload\n        address cachedLender = lender;\n\n        // Get the amount to be redeemed\n        uint256 amount = IERC20(principal).balanceOf(cachedLender);\n\n        // Receive the principal token from the lender contract\n        Safe.transferFrom(\n            IERC20(principal),\n            cachedLender,\n            address(this),\n            amount\n        );\n\n        // Get the starting balance of the underlying held by the redeemer\n        uint256 starting = IERC20(u).balanceOf(address(this));\n\n        if (p == uint8(MarketPlace.Principals.Swivel)) {\n            // Redeems principal tokens from Swivel\n            if (!ISwivel(swivelAddr).redeemZcToken(u, maturity, amount)) {\n                revert Exception(15, 0, 0, address(0), address(0));\n            }\n        } else if (p == uint8(MarketPlace.Principals.Yield)) {\n            // Redeems principal tokens from Yield\n            IYieldToken(principal).redeem(address(this), amount);\n        } else if (p == uint8(MarketPlace.Principals.Element)) {\n            // Redeems principal tokens from Element\n            IElementToken(principal).withdrawPrincipal(amount, address(this));\n        } else if (p == uint8(MarketPlace.Principals.Pendle)) {\n            // Get the forge contract for the principal token\n            address forge = IPendleToken(principal).forge();\n\n            // Get the forge ID of the principal token\n            bytes32 forgeId = IPendleForge(forge).forgeId();\n\n            // Redeem the tokens from the Pendle contract\n            IPendle(pendleAddr).redeemAfterExpiry(forgeId, u, maturity);\n\n            // Get the compounding asset for this market\n            address compounding = IPendleToken(principal)\n                .underlyingYieldToken();\n\n            // Redeem the compounding to token to the underlying\n            IConverter(converter).convert(\n                compounding,\n                u,\n                IERC20(compounding).balanceOf(address(this))\n            );\n        } else if (p == uint8(MarketPlace.Principals.Tempus)) {\n            // Retrieve the pool for the principal token\n            address pool = ITempusToken(principal).pool();\n\n            // Redeems principal tokens from Tempus\n            ITempus(tempusAddr).redeemToBacking(pool, amount, 0, address(this));\n        } else if (p == uint8(MarketPlace.Principals.Apwine)) {\n            apwineWithdraw(principal, u, amount);\n        } else if (p == uint8(MarketPlace.Principals.Notional)) {\n            // Redeems principal tokens from Notional\n            INotional(principal).redeem(\n                INotional(principal).maxRedeem(address(this)),\n                address(this),\n                address(this)\n            );\n        }\n\n        // Calculate how much underlying was redeemed\n        uint256 redeemed = IERC20(u).balanceOf(address(this)) - starting;\n\n        // Update the holding for this market\n        holdings[u][m] = holdings[u][m] + redeemed;\n\n        emit Redeem(p, u, m, redeemed, msg.sender);\n        return true;\n    }\n\n    /// @notice redeem method signature for Sense\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param s Sense's maturity is needed to extract the pt address\n    /// @param a Sense's adapter for this market\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 s,\n        address a\n    ) external returns (bool) {\n        // Check the principal is Sense\n        if (p != uint8(MarketPlace.Principals.Sense)) {\n            revert Exception(6, p, 0, address(0), address(0));\n        }\n\n        // Get Sense's principal token for this market\n        IERC20 token = IERC20(IMarketPlace(marketPlace).token(u, m, p));\n\n        // Cache the lender to save on SLOAD operations\n        address cachedLender = lender;\n\n        // Get the balance of tokens to be redeemed by the user\n        uint256 amount = token.balanceOf(cachedLender);\n\n        // Transfer the user's tokens to the redeem contract\n        Safe.transferFrom(token, cachedLender, address(this), amount);\n\n        // Get the starting balance to verify the amount received afterwards\n        uint256 starting = IERC20(u).balanceOf(address(this));\n\n        // Get the divider from the adapter\n        ISenseDivider divider = ISenseDivider(ISenseAdapter(a).divider());\n\n        // Redeem the tokens from the Sense contract\n        ISenseDivider(divider).redeem(a, s, amount);\n\n        // Get the compounding token that is redeemed by Sense\n        address compounding = ISenseAdapter(a).target();\n\n        // Redeem the compounding token back to the underlying\n        IConverter(converter).convert(\n            compounding,\n            u,\n            IERC20(compounding).balanceOf(address(this))\n        );\n\n        // Get the amount received\n        uint256 redeemed = IERC20(u).balanceOf(address(this)) - starting;\n\n        // Verify that underlying are received 1:1 - cannot trust the adapter\n        if (redeemed < amount) {\n            revert Exception(13, 0, 0, address(0), address(0));\n        }\n\n        // Update the holdings for this market\n        holdings[u][m] = holdings[u][m] + redeemed;\n\n        emit Redeem(p, u, m, redeemed, msg.sender);\n        return true;\n    }\n\n    /// @notice burns Illuminate principal tokens and sends underlying to user\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    function redeem(address u, uint256 m) external unpaused(u, m) {\n        // Get Illuminate's principal token for this market\n        IERC5095 token = IERC5095(\n            IMarketPlace(marketPlace).token(\n                u,\n                m,\n                uint8(MarketPlace.Principals.Illuminate)\n            )\n        );\n\n        // Verify the token has matured\n        if (block.timestamp < token.maturity()) {\n            revert Exception(7, block.timestamp, m, address(0), address(0));\n        }\n\n        // Get the amount of tokens to be redeemed from the sender\n        uint256 amount = token.balanceOf(msg.sender);\n\n        // Calculate how many tokens the user should receive\n        uint256 redeemed = (amount * holdings[u][m]) / token.totalSupply();\n\n        // Update holdings of underlying\n        holdings[u][m] = holdings[u][m] - redeemed;\n\n        // Burn the user's principal tokens\n        token.authBurn(msg.sender, amount);\n\n        // Transfer the original underlying token back to the user\n        Safe.transfer(IERC20(u), msg.sender, redeemed);\n\n        emit Redeem(0, u, m, redeemed, msg.sender);\n    }\n\n    /// @notice implements the redeem method for the contract to fulfill the ERC-5095 interface\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param f address from where the underlying asset will be burned\n    /// @param t address to where the underlying asset will be transferred\n    /// @param a amount of the Illuminate PT to be burned and redeemed\n    /// @return uint256 amount of the underlying asset that was burned\n    function authRedeem(\n        address u,\n        uint256 m,\n        address f,\n        address t,\n        uint256 a\n    )\n        external\n        authorized(IMarketPlace(marketPlace).token(u, m, 0))\n        returns (uint256)\n    {\n        // Get the principal token for the given market\n        IERC5095 pt = IERC5095(IMarketPlace(marketPlace).token(u, m, 0));\n\n        // Make sure the market has matured\n        uint256 maturity = pt.maturity();\n        if (block.timestamp < maturity) {\n            revert Exception(7, maturity, 0, address(0), address(0));\n        }\n\n        // Calculate the amount redeemed\n        uint256 redeemed = (a * holdings[u][m]) / pt.totalSupply();\n\n        // Update holdings of underlying\n        holdings[u][m] = holdings[u][m] - redeemed;\n\n        // Burn the user's principal tokens\n        pt.authBurn(f, a);\n\n        // Transfer the original underlying token back to the user\n        Safe.transfer(IERC20(u), t, redeemed);\n\n        emit Redeem(0, u, m, redeemed, msg.sender);\n        return a;\n    }\n\n    /// @notice implements a redeem method to enable third-party redemptions\n    /// @dev expects approvals from owners to redeemer\n    /// @param u address of the underlying asset\n    /// @param m maturity of the market\n    /// @param f address from where the principal token will be burned\n    /// @return uint256 amount of underlying yielded as a fee\n    function autoRedeem(\n        address u,\n        uint256 m,\n        address[] calldata f\n    ) external returns (uint256) {\n        // Get the principal token for the given market\n        IERC5095 pt = IERC5095(IMarketPlace(marketPlace).token(u, m, 0));\n\n        // Make sure the market has matured\n        uint256 maturity = pt.maturity();\n        if (block.timestamp < maturity) {\n            revert Exception(7, maturity, 0, address(0), address(0));\n        }\n\n        // Retrieve the underlying\n        IERC20 uToken = IERC20(u);\n\n        // Sum up the fees received by the caller\n        uint256 incentiveFee;\n\n        // Get the number of owners to loop through\n        uint256 length = f.length;\n\n        // Loop through the provided arrays and mature each individual position\n        for (uint256 i; i != length; ) {\n            // Fetch the allowance set by the holder of the principal tokens\n            uint256 allowance = uToken.allowance(f[i], address(this));\n\n            // Get the amount of tokens held by the owner\n            uint256 amount = pt.balanceOf(f[i]);\n\n            // Calculate how many tokens the user should receive\n            uint256 redeemed = (amount * holdings[u][m]) / pt.totalSupply();\n\n            // Calculate the fees to be received (currently .025%)\n            uint256 fee = redeemed / feenominator;\n\n            // Verify allowance\n            if (allowance < amount) {\n                revert Exception(20, allowance, amount, address(0), address(0));\n            }\n\n            // Burn the tokens from the user\n            pt.authBurn(f[i], amount);\n\n            // Update the holdings for this market\n            holdings[u][m] = holdings[u][m] - redeemed;\n\n            // Transfer the underlying to the user\n            Safe.transfer(uToken, f[i], redeemed - fee);\n\n            unchecked {\n                // Track the fees gained by the caller\n                incentiveFee += fee;\n\n                ++i;\n            }\n        }\n\n        // Transfer the fee to the caller\n        Safe.transfer(uToken, msg.sender, incentiveFee);\n\n        return incentiveFee;\n    }\n\n    /// @notice Execute the business logic for conducting an APWine redemption\n    function apwineWithdraw(\n        address p,\n        address u,\n        uint256 a\n    ) internal {\n        // Retrieve the vault which executes the redemption in APWine\n        address futureVault = IAPWineToken(p).futureVault();\n\n        // Retrieve the controller that will execute the withdrawal\n        address controller = IAPWineFutureVault(futureVault)\n            .getControllerAddress();\n\n        // Retrieve the next period index\n        uint256 index = IAPWineFutureVault(futureVault).getCurrentPeriodIndex();\n\n        // Get the FYT address for the current period\n        address fyt = IAPWineFutureVault(futureVault).getFYTofPeriod(index);\n\n        // Trigger claim to FYTs by executing transfer\n        // Safe.transferFrom(IERC20(fyt), address(lender), address(this), a);\n        ILender(lender).transferFYTs(fyt, a);\n\n        // Redeem the underlying token from APWine to Illuminate\n        IAPWineController(controller).withdraw(futureVault, a);\n\n        // Retrieve the interest bearing token\n        address ibt = IAPWineFutureVault(futureVault).getIBTAddress();\n\n        // Convert the interest bearing token to underlying\n        IConverter(converter).convert(\n            IAPWineFutureVault(futureVault).getIBTAddress(),\n            u,\n            IERC20(ibt).balanceOf(address(this))\n        );\n    }\n}"
    },
    {
      "filename": "src/Redeemer.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\nimport 'src/MarketPlace.sol';\n\nimport 'src/lib/Safe.sol';\nimport 'src/errors/Exception.sol';\n\nimport 'src/interfaces/IERC5095.sol';\nimport 'src/interfaces/IERC20.sol';\nimport 'src/interfaces/ITempus.sol';\nimport 'src/interfaces/ITempusPool.sol';\nimport 'src/interfaces/ITempusToken.sol';\nimport 'src/interfaces/IAPWine.sol';\nimport 'src/interfaces/IAPWineController.sol';\nimport 'src/interfaces/IAPWineFutureVault.sol';\nimport 'src/interfaces/IAPWineToken.sol';\nimport 'src/interfaces/IAPWineAMMPool.sol';\nimport 'src/interfaces/ISwivel.sol';\nimport 'src/interfaces/ISwivelToken.sol';\nimport 'src/interfaces/IElementToken.sol';\nimport 'src/interfaces/IYieldToken.sol';\nimport 'src/interfaces/INotional.sol';\nimport 'src/interfaces/IPendle.sol';\nimport 'src/interfaces/IPendleForge.sol';\nimport 'src/interfaces/IPendleToken.sol';\nimport 'src/interfaces/ISenseDivider.sol';\nimport 'src/interfaces/ISenseAdapter.sol';\nimport 'src/interfaces/IYield.sol';\nimport 'src/interfaces/IConverter.sol';\n\nimport 'forge-std/Test.sol';\n\n/// @title Redeemer\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice The Redeemer contract is used to redeem the underlying lent capital of a loan.\n/// @notice Users may redeem their ERC-5095 tokens for the underlying asset represented by that token after maturity.\ncontract Redeemer {\n    /// @notice address that is allowed to set fees and contracts, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the MarketPlace contract, used to access the markets mapping\n    address public marketPlace;\n    /// @notice address that custodies principal tokens for all markets\n    address public lender;\n    /// @notice address that converts compounding tokens to their underlying\n    address public converter;\n\n    /// @notice third party contract needed to redeem Swivel PTs\n    address public immutable swivelAddr;\n    /// @notice third party contract needed to redeem Pendle PTs\n    address public immutable pendleAddr;\n    /// @notice third party contract needed to redeem Tempus PTs\n    address public immutable tempusAddr;\n\n    /// @notice this value determines the amount of fees paid on auto redemptions\n    uint256 public feenominator;\n    /// @notice represents a point in time where the feenominator may change\n    uint256 public feeChange;\n    /// @notice represents a minimum that the feenominator must exceed\n    uint256 public MIN_FEENOMINATOR = 500;\n\n    /// @notice mapping that indicates how much underlying has been redeemed by a market\n    mapping(address => mapping(uint256 => uint256)) public holdings;\n    /// @notice mapping that determines if a market's iPT can be redeemed\n    mapping(address => mapping(uint256 => bool)) public paused;\n\n    /// @notice emitted upon redemption of a loan\n    event Redeem(\n        uint8 principal,\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 amount,\n        address sender\n    );\n    /// @notice emitted upon changing the admin\n    event SetAdmin(address indexed admin);\n    /// @notice emitted upon changing the converter\n    event SetConverter(address indexed converter);\n    /// @notice emitted upon setting the fee rate\n    event SetFee(uint256 indexed fee);\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Exception(0, 0, 0, msg.sender, a);\n        }\n        _;\n    }\n\n    /// @notice reverts on all markets where the paused mapping returns true\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    modifier unpaused(address u, uint256 m) {\n        if (paused[u][m]) {\n            revert Exception(17, m, 0, u, address(0));\n        }\n        _;\n    }\n\n    /// @notice Initializes the Redeemer contract\n    /// @param l the lender contract\n    /// @param s the Swivel contract\n    /// @param p the Pendle contract\n    /// @param t the Tempus contract\n    constructor(\n        address l,\n        address s,\n        address p,\n        address t\n    ) {\n        admin = msg.sender;\n        lender = l;\n        swivelAddr = s;\n        pendleAddr = p;\n        tempusAddr = t;\n        feenominator = 4000;\n    }\n\n    /// @notice sets the admin address\n    /// @param a Address of a new admin\n    /// @return bool true if successful\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        emit SetAdmin(a);\n        return true;\n    }\n\n    /// @notice sets the address of the marketplace contract which contains the addresses of all the fixed rate markets\n    /// @param m the address of the marketplace contract\n    /// @return bool true if the address was set\n    function setMarketPlace(address m)\n        external\n        authorized(admin)\n        returns (bool)\n    {\n        if (marketPlace != address(0)) {\n            revert Exception(5, 0, 0, marketPlace, address(0));\n        }\n        marketPlace = m;\n        return true;\n    }\n\n    /// @notice sets the converter address\n    /// @param c address of the new converter\n    /// @return bool true if successful\n    function setConverter(address c) external authorized(admin) returns (bool) {\n        converter = c;\n        emit SetConverter(c);\n        return true;\n    }\n\n    /// @notice sets the address of the lender contract which contains the addresses of all the fixed rate markets\n    /// @param l the address of the lender contract\n    /// @return bool true if the address was set\n    function setLender(address l) external authorized(admin) returns (bool) {\n        if (lender != address(0)) {\n            revert Exception(8, 0, 0, address(lender), address(0));\n        }\n        lender = l;\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param f the new value of the feenominator, fees are not collected when the feenominator is 0\n    /// @return bool true if successful\n    function setFee(uint256 f) external authorized(admin) returns (bool) {\n        uint256 feeTime = feeChange;\n        if (feeTime == 0) {\n            revert Exception(23, 0, 0, address(0), address(0));\n        } else if (feeTime < block.timestamp) {\n            revert Exception(\n                24,\n                block.timestamp,\n                feeTime,\n                address(0),\n                address(0)\n            );\n        } else if (f < MIN_FEENOMINATOR) {\n            revert Exception(25, 0, 0, address(0), address(0));\n        }\n        feenominator = f;\n        delete feeChange;\n        emit SetFee(f);\n        return true;\n    }\n\n    /// @notice allows admin to stop redemptions of Illuminate PTs for a given market\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param b true to pause, false to unpause\n    function pauseRedemptions(\n        address u,\n        uint256 m,\n        bool b\n    ) external authorized(admin) {\n        paused[u][m] = b;\n    }\n\n    /// @notice approves the converter to spend the compounding asset\n    /// @param i an interest bearing token that must be approved for conversion\n    function approve(address i) external authorized(marketPlace) {\n        if (i != address(0)) {\n            Safe.approve(IERC20(i), address(converter), type(uint256).max);\n        }\n    }\n\n    /// @notice redeem method for Swivel, Yield, Element, Pendle, APWine, Tempus and Notional protocols\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m\n    ) external returns (bool) {\n        // Get the principal token that is being redeemed by the user\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Get the maturity for the given principal token\n        uint256 maturity;\n        if (p == uint8(MarketPlace.Principals.Swivel)) {\n            maturity = ISwivelToken(principal).maturity();\n        } else if (p == uint8(MarketPlace.Principals.Yield)) {\n            maturity = IYieldToken(principal).maturity();\n        } else if (p == uint8(MarketPlace.Principals.Element)) {\n            maturity = IElementToken(principal).unlockTimestamp();\n        } else if (p == uint8(MarketPlace.Principals.Pendle)) {\n            maturity = IPendleToken(principal).expiry();\n        } else if (p == uint8(MarketPlace.Principals.Tempus)) {\n            maturity = ITempusPool(ITempusToken(principal).pool())\n                .maturityTime();\n        } else if (p == uint8(MarketPlace.Principals.Apwine)) {\n            // APWine's maturity is retrieved indirectly via the PT's\n            // futureVault and Controller\n            address futureVault = IAPWineToken(principal).futureVault();\n\n            address controller = IAPWineFutureVault(futureVault)\n                .getControllerAddress();\n\n            uint256 duration = IAPWineFutureVault(futureVault)\n                .PERIOD_DURATION();\n\n            maturity = IAPWineController(controller).getNextPeriodStart(\n                duration\n            );\n        } else if (p == uint8(MarketPlace.Principals.Notional)) {\n            maturity = INotional(principal).getMaturity();\n        } else {\n            revert Exception(6, p, 0, address(0), address(0));\n        }\n\n        // Verify that the token has matured\n        if (maturity > block.timestamp) {\n            revert Exception(7, maturity, 0, address(0), address(0));\n        }\n\n        // Cache the lender to save gas on sload\n        address cachedLender = lender;\n\n        // Get the amount to be redeemed\n        uint256 amount = IERC20(principal).balanceOf(cachedLender);\n\n        // Receive the principal token from the lender contract\n        Safe.transferFrom(\n            IERC20(principal),\n            cachedLender,\n            address(this),\n            amount\n        );\n\n        // Get the starting balance of the underlying held by the redeemer\n        uint256 starting = IERC20(u).balanceOf(address(this));\n\n        if (p == uint8(MarketPlace.Principals.Swivel)) {\n            // Redeems principal tokens from Swivel\n            if (!ISwivel(swivelAddr).redeemZcToken(u, maturity, amount)) {\n                revert Exception(15, 0, 0, address(0), address(0));\n            }\n        } else if (p == uint8(MarketPlace.Principals.Yield)) {\n            // Redeems principal tokens from Yield\n            IYieldToken(principal).redeem(address(this), amount);\n        } e"
    }
  ]
}