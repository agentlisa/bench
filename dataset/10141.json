{
  "Title": "[M-01] use of transfer() instead of call()  to send eth",
  "Content": "_Submitted by JMukesh_.\n\n#### Impact\n\nUse of `transfer()` might render ETH impossible to withdraw because after istanbul hardfork, there is an increase in the gas cost of the SLOAD operation and therefore breaks some existing smart contracts.Those contracts will break because their fallback functions used to consume less than 2300 gas, and they’ll now consume more, since 2300 the amount of gas a contract’s fallback function receives if it’s called via Solidity’s `transfer()` or `send()` methods.\nAny smart contract that uses `transfer()` or `send()` is taking a hard dependency on gas costs by forwarding a fixed amount of gas: 2300.\n\n- <https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/>\n\n- <https://blog.openzeppelin.com/opyn-gamma-protocol-audit/>\n\n#### Proof of Concept\n\n- <https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/MISOTokenFactory.sol#L242>\n\n- <https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/MISOMarket.sol#L256>\n\n- <https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/MISOLauncher.sol#L251>\n\n- <https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/MISOFarmFactory.sol#L244>\n\n#### Tools Used\n\nmanual review\n\n#### Recommended Mitigation Steps\n\nuse `call()` to send eth\n\n**[maxsam4 (Sushi Miso) disputed and commented](https://github.com/code-423n4/2021-09-sushimiso-findings/issues/87#issuecomment-920589153):**\n > This is intentional, not a risk. The contract does not want to give any gas stipend to the destination.\n> \n> Even if the user messes up, `misoDev` address can be changed to a proper address later.\n\n**[ghoul-sol (judge) commented](https://github.com/code-423n4/2021-09-sushimiso-findings/issues/87#issuecomment-934654221):**\n > using `.transfer` can make ETH transfer to a smart contract impossible. User can always change the address however I agree with warden that this is an issue.\n\n\n\n \n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2021-09-sushimiso",
  "Code": [
    {
      "filename": "contracts/MISOTokenFactory.sol",
      "content": "pragma solidity 0.6.12;\n\n//----------------------------------------------------------------------------------\n//    I n s t a n t\n//\n//        .:mmm.         .:mmm:.       .ii.  .:SSSSSSSSSSSSS.     .oOOOOOOOOOOOo.  \n//      .mMM'':Mm.     .:MM'':Mm:.     .II:  :SSs..........     .oOO'''''''''''OOo.\n//    .:Mm'   ':Mm.   .:Mm'   'MM:.    .II:  'sSSSSSSSSSSSSS:.  :OO.           .OO:\n//  .'mMm'     ':MM:.:MMm'     ':MM:.  .II:  .:...........:SS.  'OOo:.........:oOO'\n//  'mMm'        ':MMmm'         'mMm:  II:  'sSSSSSSSSSSSSS'     'oOOOOOOOOOOOO'  \n//\n//----------------------------------------------------------------------------------\n//\n// Chef Gonpachi's MISO Token Factory\n//\n// A factory to conveniently deploy your own source code verified  token contracts\n//\n// Inspired by Bokky's EtherVendingMachince.io\n// https://github.com/bokkypoobah/FixedSupplyTokenFactory\n// \n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// The above copyright notice and this permission notice shall be included \n// in all copies or substantial portions of the Software.\n//\n// Made for Sushi.com \n// \n// Enjoy. (c) Chef Gonpachi 2021 \n// <https://github.com/chefgonpachi/MISO/>\n//\n// ---------------------------------------------------------------------\n// SPDX-License-Identifier: GPL-3.0                        \n// ---------------------------------------------------------------------\n\n\nimport \"./Utils/CloneFactory.sol\";\nimport \"./interfaces/IMisoToken.sol\";\nimport \"./Access/MISOAccessControls.sol\";\nimport \"./Utils/SafeTransfer.sol\";\nimport \"./interfaces/IERC20.sol\";\n\ncontract MISOTokenFactory is CloneFactory, SafeTransfer{\n    \n    /// @notice Responsible for access rights to the contract\n    MISOAccessControls public accessControls;\n    bytes32 public constant TOKEN_MINTER_ROLE = keccak256(\"TOKEN_MINTER_ROLE\");\n\n    /// @notice Whether token factory has been initialized or not.\n    bool private initialised;\n\n    /// @notice Struct to track Token template.\n    struct Token {\n        bool exists;\n        uint256 templateId;\n        uint256 index;\n    }\n\n    /// @notice Mapping from auction address created through this contract to Auction struct.\n    mapping(address => Token) public tokenInfo;\n\n    /// @notice Array of tokens created using the factory.\n    address[] public tokens;\n\n    /// @notice Template id to track respective token template.\n    uint256 public tokenTemplateId;\n\n    /// @notice Mapping from token template id to token template address.\n    mapping(uint256 => address) private tokenTemplates;\n\n    /// @notice mapping from token template address to token template id\n    mapping(address => uint256) private tokenTemplateToId;\n\n    /// @notice mapping from template type to template id\n    mapping(uint256 => uint256) public currentTemplateId;\n\n    /// @notice Minimum fee to create a token through the factory.\n    uint256 public minimumFee;\n    uint256 public integratorFeePct;\n\n    /// @notice Contract locked status. If locked, only minters can deploy\n    bool public locked;\n\n    /// @notice Any MISO dividends collected are sent here.\n    address payable public misoDiv;\n\n    /// @notice Event emitted when first initializing Miso Token Factory.\n    event MisoInitTokenFactory(address sender);\n\n    /// @notice Event emitted when a token is created using template id.\n    event TokenCreated(address indexed owner, address indexed addr, address tokenTemplate);\n    \n    /// @notice event emitted when a token is initialized using template id\n    event TokenInitialized(address indexed addr, uint256 templateId, bytes data);\n\n    /// @notice Event emitted when a token template is added.\n    event TokenTemplateAdded(address newToken, uint256 templateId);\n\n    /// @notice Event emitted when a token template is removed.\n    event TokenTemplateRemoved(address token, uint256 templateId);\n\n    constructor() public {\n    }\n\n    /**\n     * @notice Single gateway to initialize the MISO Token Factory with proper address.\n     * @dev Can only be initialized once.\n     * @param _accessControls Sets address to get the access controls from.\n     */\n    /// @dev GP: Migrate to the BentoBox.\n    function initMISOTokenFactory(address _accessControls) external  {\n        require(!initialised);\n        initialised = true;\n        locked = true;\n        accessControls = MISOAccessControls(_accessControls);\n        emit MisoInitTokenFactory(msg.sender);\n    }\n\n    /**\n     * @notice Sets the minimum fee.\n     * @param _amount Fee amount.\n     */\n    function setMinimumFee(uint256 _amount) external {\n        require(\n            accessControls.hasAdminRole(msg.sender),\n            \"MISOTokenFactory: Sender must be operator\"\n        );\n        minimumFee = _amount;\n    }\n\n    /**\n     * @notice Sets integrator fee percentage.\n     * @param _amount Percentage amount.\n     */\n    function setIntegratorFeePct(uint256 _amount) external {\n        require(\n            accessControls.hasAdminRole(msg.sender),\n            \"MISOTokenFactory: Sender must be operator\"\n        );\n        /// @dev this is out of 1000, ie 25% = 250\n        require(\n            _amount <= 1000, \n            \"MISOTokenFactory: Range is from 0 to 1000\"\n        );\n        integratorFeePct = _amount;\n    }\n\n    /**\n     * @notice Sets dividend address.\n     * @param _divaddr Dividend address.\n     */\n    function setDividends(address payable _divaddr) external  {\n        require(\n            accessControls.hasAdminRole(msg.sender),\n            \"MISOTokenFactory: Sender must be operator\"\n        );\n        require(_divaddr != address(0));\n        misoDiv = _divaddr;\n    }    \n    \n    /**\n     * @notice Sets the factory to be locked or unlocked.\n     * @param _locked bool.\n     */\n    function setLocked(bool _locked) external {\n        require(\n            accessControls.hasAdminRole(msg.sender),\n            \"MISOTokenFactory: Sender must be admin\"\n        );\n        locked = _locked;\n    }\n\n\n    /**\n     * @notice Sets the current template ID for any type.\n     * @param _templateType Type of template.\n     * @param _templateId The ID of the current template for that type\n     */\n    function setCurrentTemplateId(uint256 _templateType, uint256 _templateId) external {\n        require(\n            accessControls.hasAdminRole(msg.sender) ||\n            accessControls.hasOperatorRole(msg.sender),\n            \"MISOTokenFactory: Sender must be admin\"\n        );\n        require(tokenTemplates[_templateId] != address(0), \"MISOMarket: incorrect _templateId\");\n        require(IMisoToken(tokenTemplates[_templateId]).tokenTemplate() == _templateType, \"MISOMarket: incorrect _templateType\");\n        currentTemplateId[_templateType] = _templateId;\n    }\n\n    /**\n     * @notice Used to check whether an address has the minter role\n     * @param _address EOA or contract being checked\n     * @return bool True if the account has the role or false if it does not\n     */\n    function hasTokenMinterRole(address _address) public view returns (bool) {\n        return accessControls.hasRole(TOKEN_MINTER_ROLE, _address);\n    }\n\n\n\n    /**\n     * @notice Creates a token corresponding to template id and transfers fees.\n     * @dev Initializes token with parameters passed\n     * @param _templateId Template id of token to create.\n     * @param _integratorFeeAccount Address to pay the fee to.\n     * @return token Token address.\n     */\n    function deployToken(\n        uint256 _templateId,\n        address payable _integratorFeeAccount\n    )\n        public payable returns (address token)\n    {\n        /// @dev If the contract is locked, only admin and minters can deploy. \n        if (locked) {\n            require(accessControls.hasAdminRole(msg.sender) \n                    || accessControls.hasMinterRole(msg.sender)\n                    || hasTokenMinterRole(msg.sender),\n                \"MISOTokenFactory: Sender must be minter if locked\"\n            );\n        }\n        require(msg.value >= minimumFee, \"MISOTokenFactory: Failed to transfer minimumFee\");\n        require(tokenTemplates[_templateId] != address(0));\n        uint256 integratorFee = 0;\n        uint256 misoFee = msg.value;\n        if (_integratorFeeAccount != address(0) && _integratorFeeAccount != misoDiv) {\n            integratorFee = misoFee * integratorFeePct / 1000;\n            misoFee = misoFee - integratorFee;\n        }\n        token = createClone(tokenTemplates[_templateId]);\n        /// @dev GP: Triple check the token index is correct.\n        tokenInfo[token] = Token(true, _templateId, tokens.length);\n        tokens.push(token);\n        emit TokenCreated(msg.sender, token, tokenTemplates[_templateId]);\n        if (misoFee > 0) {\n            misoDiv.transfer(misoFee);\n        }\n        if (integratorFee > 0) {\n            _integratorFeeAccount.transfer(integratorFee);\n        }\n    }\n\n    /**\n     * @notice Creates a token corresponding to template id.\n     * @dev Initializes token with parameters passed.\n     * @param _templateId Template id of token to create.\n     * @param _integratorFeeAccount Address to pay the fee to.\n     * @param _data Data to be passed to the token contract for init.\n     * @return token Token address.\n     */\n    function createToken(\n        uint256 _templateId,\n        address payable _integratorFeeAccount,\n        bytes calldata _data\n    )\n        external payable returns (address token)\n    {\n        emit TokenInitialized(address(token), _templateId, _data);\n        token = deployToken(_templateId, _integratorFeeAccount);\n        IMisoToken(token).initToken(_data);\n        uint256 initialTokens = IERC20(token).balanceOf(address(this));\n        if (initialTokens > 0 ) {\n            _safeTransfer(token, msg.sender, initialTokens);\n        }\n    }\n\n    /**\n     * @notice Function to add a token template to create through factory.\n     * @dev Should have operator access.\n     * @param _template Token template to create a token.\n     */\n    function addTokenTemplate(address _template) external {\n        require(\n            accessControls.hasAdminRole(msg.sender) ||\n            accessControls.hasOperatorRole(msg.sender),\n            \"MISOTokenFactory: Sender must be operator\"\n        );\n        uint256 templateType = IMisoToken(_template).tokenTemplate();\n        require(templateType > 0, \"MISOLauncher: Incorrect template code \");\n        require(tokenTemplateToId[_template] == 0, \"MISOTokenFactory: Template exists\");\n        tokenTemplateId++;\n        tokenTemplates[tokenTemplateId] = _template;\n        tokenTemplateToId[_template] = tokenTemplateId;\n        currentTemplateId[templateType] = tokenTemplateId;\n        emit TokenTemplateAdded(_template, tokenTemplateId);\n\n    }\n\n    /**\n     * @notice Function to remove a token template.\n     * @dev Should have operator access.\n     * @param _templateId Refers to template that is to be deleted.\n    */\n    function removeTokenTemplate(uint256 _templateId) external {\n        require(\n            accessControls.hasAdminRole(msg.sender) ||\n            accessControls.hasOperatorRole(msg.sender),\n            \"MISOTokenFactory: Sender must be operator\"\n        );\n        require(tokenTemplates[_templateId] != address(0));\n        address template = tokenTemplates[_templateId];\n        uint256 templateType = IMisoToken(tokenTemplates[_templateId]).tokenTemplate();\n        if (currentTemplateId[templateType] == _templateId) {\n            delete currentTemplateId[templateType];\n        }\n        tokenTemplates[_templateId] = address(0);\n        delete tokenTemplateToId[template];\n        emit TokenTemplateRemoved(template, _templateId);\n    }\n\n    /**\n     * @notice Get the total number of tokens in the factory.\n     * @return Token count.\n     */\n    function numberOfTokens() external view returns (uint256) {\n        return tokens.length;\n    }\n\n    function getTokens() external view returns (address[] memory) {\n        return tokens;\n    }\n\n    /**\n     * @notice Get the address based on template ID.\n     * @param _templateId Token template ID.\n     * @return Address of the required template ID.\n     */\n    function getTokenTemplate(uint256 _templateId) external view returns (address ) {\n        return tokenTemplates[_templateId];\n    }\n\n    /**\n     * @notice Get the ID based on template address.\n     * @param _tokenTemplate Token template address.\n     * @return ID of the required template address.\n     */\n    function getTemplateId(address _tokenTemplate) external view returns (uint256) {\n        return tokenTemplateToId[_tokenTemplate];\n    }\n}"
    },
    {
      "filename": "contracts/MISOMarket.sol",
      "content": "pragma solidity 0.6.12;\n\n//----------------------------------------------------------------------------------\n//    I n s t a n t\n//\n//        .:mmm.         .:mmm:.       .ii.  .:SSSSSSSSSSSSS.     .oOOOOOOOOOOOo.  \n//      .mMM'':Mm.     .:MM'':Mm:.     .II:  :SSs..........     .oOO'''''''''''OOo.\n//    .:Mm'   ':Mm.   .:Mm'   'MM:.    .II:  'sSSSSSSSSSSSSS:.  :OO.           .OO:\n//  .'mMm'     ':MM:.:MMm'     ':MM:.  .II:  .:...........:SS.  'OOo:.........:oOO'\n//  'mMm'        ':MMmm'         'mMm:  II:  'sSSSSSSSSSSSSS'     'oOOOOOOOOOOOO'  \n//\n//----------------------------------------------------------------------------------\n//\n// Chef Gonpachi's MISO Marketplace\n//\n// A factory to conveniently deploy your own source code verified auctions\n//\n// Inspired by Bokky's EtherVendingMachince.io\n// https://github.com/bokkypoobah/FixedSupplyTokenFactory\n// \n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// The above copyright notice and this permission notice shall be included \n// in all copies or substantial portions of the Software.\n//\n// Made for Sushi.com \n// \n// Enjoy. (c) Chef Gonpachi 2021 \n// <https://github.com/chefgonpachi/MISO/>\n//\n// ---------------------------------------------------------------------\n// SPDX-License-Identifier: GPL-3.0                        \n// ---------------------------------------------------------------------\n\nimport \"./Access/MISOAccessControls.sol\";\nimport \"./Utils/BoringMath.sol\";\nimport \"./Utils/SafeTransfer.sol\";\nimport \"./interfaces/IMisoMarket.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IBentoBoxFactory.sol\";\n\n\ncontract MISOMarket is SafeTransfer {\n\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using BoringMath64 for uint64;\n\n    /// @notice Responsible for access rights to the contract.\n    MISOAccessControls public accessControls;\n    bytes32 public constant MARKET_MINTER_ROLE = keccak256(\"MARKET_MINTER_ROLE\");\n\n    /// @notice Whether market has been initialized or not.\n    bool private initialised;\n\n    /// @notice Struct to track Auction template.\n    struct Auction {\n        bool exists;\n        uint64 templateId;\n        uint128 index;\n    }\n\n    /// @notice Auctions created using factory.\n    address[] public auctions;\n\n    /// @notice Template id to track respective auction template.\n    uint256 public auctionTemplateId;\n\n    IBentoBoxFactory public bentoBox;\n\n    /// @notice Mapping from market template id to market template address.\n    mapping(uint256 => address) private auctionTemplates;\n\n    /// @notice Mapping from market template address to market template id.\n    mapping(address => uint256) private auctionTemplateToId;\n\n    // /// @notice mapping from template type to template id\n    mapping(uint256 => uint256) public currentTemplateId;\n\n    /// @notice Mapping from auction created through this contract to Auction struct.\n    mapping(address => Auction) public auctionInfo;\n\n    /// @notice Struct to define fees.\n    struct MarketFees {\n        uint128 minimumFee;\n        uint32 integratorFeePct;\n    }\n\n    /// @notice Minimum fee to create a farm through the factory.\n    MarketFees public marketFees;\n\n    /// @notice Contract locked status. If locked, only minters can deploy\n    bool public locked;\n\n    ///@notice Any donations if set are sent here.\n    address payable public misoDiv;\n\n    ///@notice Event emitted when first initializing the Market factory.\n    event MisoInitMarket(address sender);\n\n    /// @notice Event emitted when template is added to factory.\n    event AuctionTemplateAdded(address newAuction, uint256 templateId);\n\n    /// @notice Event emitted when auction template is removed.\n    event AuctionTemplateRemoved(address auction, uint256 templateId);\n\n    /// @notice Event emitted when auction is created using template id.\n    event MarketCreated(address indexed owner, address indexed addr, address marketTemplate);\n\n    constructor() public {\n    }\n\n    /**\n     * @notice Initializes the market with a list of auction templates.\n     * @dev Can only be initialized once.\n     * @param _accessControls Sets address to get the access controls from.\n     * @param _templates Initial array of MISOMarket templates.\n     */\n    function initMISOMarket(address _accessControls, address _bentoBox, address[] memory _templates) external {\n        require(!initialised);\n        require(_accessControls != address(0), \"initMISOMarket: accessControls cannot be set to zero\");\n        require(_bentoBox != address(0), \"initMISOMarket: bentoBox cannot be set to zero\");\n\n        accessControls = MISOAccessControls(_accessControls);\n        bentoBox = IBentoBoxFactory(_bentoBox);\n\n        auctionTemplateId = 0;\n        for(uint i = 0; i < _templates.length; i++) {\n            _addAuctionTemplate(_templates[i]);\n        }\n        locked = true;\n        initialised = true;\n        emit MisoInitMarket(msg.sender);\n    }\n\n    /**\n     * @notice Sets the minimum fee.\n     * @param _amount Fee amount.\n     */\n    function setMinimumFee(uint256 _amount) external {\n        require(\n            accessControls.hasAdminRole(msg.sender),\n            \"MISOMarket: Sender must be operator\"\n        );\n        marketFees.minimumFee = BoringMath.to128(_amount);\n    }\n\n    /**\n     * @notice Sets the factory to be locked or unlocked.\n     * @param _locked bool.\n     */\n    function setLocked(bool _locked) external {\n        require(\n            accessControls.hasAdminRole(msg.sender),\n            \"MISOMarket: Sender must be admin\"\n        );\n        locked = _locked;\n    }\n\n\n    /**\n     * @notice Sets integrator fee percentage.\n     * @param _amount Percentage amount.\n     */\n    function setIntegratorFeePct(uint256 _amount) external {\n        require(\n            accessControls.hasAdminRole(msg.sender),\n            \"MISOMarket: Sender must be operator\"\n        );\n        /// @dev this is out of 1000, ie 25% = 250\n        require(_amount <= 1000, \"MISOMarket: Percentage is out of 1000\");\n        marketFees.integratorFeePct = BoringMath.to32(_amount);\n    }\n\n    /**\n     * @notice Sets dividend address.\n     * @param _divaddr Dividend address.\n     */\n    function setDividends(address payable _divaddr) external {\n        require(accessControls.hasAdminRole(msg.sender), \"MISOMarket.setDev: Sender must be operator\");\n        require(_divaddr != address(0));\n        misoDiv = _divaddr;\n    }\n\n    /**\n     * @notice Sets the current template ID for any type.\n     * @param _templateType Type of template.\n     * @param _templateId The ID of the current template for that type\n     */\n    function setCurrentTemplateId(uint256 _templateType, uint256 _templateId) external {\n        require(\n            accessControls.hasAdminRole(msg.sender),\n            \"MISOMarket: Sender must be admin\"\n        );\n        require(auctionTemplates[_templateId] != address(0), \"MISOMarket: incorrect _templateId\");\n        require(IMisoMarket(auctionTemplates[_templateId]).marketTemplate() == _templateType, \"MISOMarket: incorrect _templateType\");\n        currentTemplateId[_templateType] = _templateId;\n    }\n\n\n    /**\n     * @notice Used to check whether an address has the minter role\n     * @param _address EOA or contract being checked\n     * @return bool True if the account has the role or false if it does not\n     */\n    function hasMarketMinterRole(address _address) public view returns (bool) {\n        return accessControls.hasRole(MARKET_MINTER_ROLE, _address);\n    }\n\n\n    /**\n     * @notice Creates a new MISOMarket from template _templateId and transfers fees.\n     * @param _templateId Id of the crowdsale template to create.\n     * @param _integratorFeeAccount Address to pay the fee to.\n     * @return newMarket Market address.\n     */\n    function deployMarket(\n        uint256 _templateId,\n        address payable _integratorFeeAccount\n    )\n        public payable returns (address newMarket)\n    {\n        /// @dev If the contract is locked, only admin and minters can deploy. \n        if (locked) {\n            require(accessControls.hasAdminRole(msg.sender) \n                    || accessControls.hasMinterRole(msg.sender)\n                    || hasMarketMinterRole(msg.sender),\n                \"MISOMarket: Sender must be minter if locked\"\n            );\n        }\n\n        MarketFees memory _marketFees = marketFees;\n        address auctionTemplate = auctionTemplates[_templateId];\n        require(msg.value >= uint256(_marketFees.minimumFee), \"MISOMarket: Failed to transfer minimumFee\");\n        require(auctionTemplate != address(0), \"MISOMarket: Auction template doesn't exist\");\n        uint256 integratorFee = 0;\n        uint256 misoFee = msg.value;\n        if (_integratorFeeAccount != address(0) && _integratorFeeAccount != misoDiv) {\n            integratorFee = misoFee * uint256(_marketFees.integratorFeePct) / 1000;\n            misoFee = misoFee - integratorFee;\n        }\n\n        /// @dev Deploy using the BentoBox factory. \n        newMarket = bentoBox.deploy(auctionTemplate, \"\", false);\n        auctionInfo[newMarket] = Auction(true, BoringMath.to64(_templateId), BoringMath.to128(auctions.length));\n        auctions.push(newMarket);\n        emit MarketCreated(msg.sender, newMarket, auctionTemplate);\n        if (misoFee > 0) {\n            misoDiv.transfer(misoFee);\n        }\n        if (integratorFee > 0) {\n            _integratorFeeAccount.transfer(integratorFee);\n        }\n    }\n\n    /**\n     * @notice Creates a new MISOMarket using _templateId.\n     * @dev Initializes auction with the parameters passed.\n     * @param _templateId Id of the auction template to create.\n     * @param _token The token address to be sold.\n     * @param _tokenSupply Amount of tokens to be sold at market.\n     * @param _integratorFeeAccount Address to send refferal bonus, if set.\n     * @param _data Data to be sent to template on Init.\n     * @return newMarket Market address.\n     */\n    function createMarket(\n        uint256 _templateId,\n        address _token,\n        uint256 _tokenSupply,\n        address payable _integratorFeeAccount,\n        bytes calldata _data\n    )\n        external payable returns (address newMarket)\n    {\n        newMarket = deployMarket(_templateId, _integratorFeeAccount);\n        if (_tokenSupply > 0) {\n            _safeTransferFrom(_token, msg.sender, _tokenSupply);\n            require(IERC20(_token).approve(newMarket, _tokenSupply), \"1\");\n        }\n        IMisoMarket(newMarket).initMarket(_data);\n\n        if (_tokenSupply > 0) {\n            uint256 remainingBalance = IERC20(_token).balanceOf(address(this));\n            if (remainingBalance > 0) {\n                _safeTransfer(_token, msg.sender, remainingBalance);\n            }\n        }\n        return newMarket;\n    }\n\n    /**\n     * @notice Function to add an auction template to create through factory.\n     * @dev Should have operator access.\n     * @param _template Auction template to create an auction.\n     */\n    function addAuctionTemplate(address _template) external {\n        require(\n            accessControls.hasAdminRole(msg.sender) ||\n            accessControls.hasOperatorRole(msg.sender),\n            \"MISOMarket: Sender must be operator\"\n        );\n        _addAuctionTemplate(_template);    \n    }\n\n    /**\n     * @dev Function to remove an auction template.\n     * @dev Should have operator access.\n     * @param _templateId Refers to template that is to be deleted.\n     */\n    function removeAuctionTemplate(uint256 _templateId) external {\n        require(\n            accessControls.hasAdminRole(msg.sender) ||\n            accessControls.hasOperatorRole(msg.sender),\n            \"MISOMarket: Sender must be operator\"\n        );\n        address template = auctionTemplates[_templateId];\n        uint256 templateType = IMisoMarket(template).marketTemplate();\n        if (currentTemplateId[templateType] == _templateId) {\n            delete currentTemplateId[templateType];\n        }   \n        auctionTemplates[_templateId] = address(0);\n        delete auctionTemplateToId[template];\n        emit AuctionTemplateRemoved(template, _templateId);\n    }\n\n    /**\n     * @notice Function to add an auction template to create through factory.\n     * @param _template Auction template address to create an auction.\n     */\n    function _addAuctionTemplate(address _template) internal {\n        require(_template != address(0), \"MISOMarket: Incorrect template\");\n        require(auctionTemplateToId[_template] == 0, \"MISOMarket: Template already added\");\n        uint256 templateType = IMisoMarket(_template).marketTemplate();\n        require(templateType > 0, \"MISOMarket: Incorrect template code \");\n        auctionTemplateId++;\n\n        auctionTemplates[auctionTemplateId] = _template;\n        auctionTemplateToId[_template] = auctionTemplateId;\n        currentTemplateId[templateType] = auctionTemplateId;\n        emit AuctionTemplateAdded(_template, auctionTemplateId);\n    }\n\n    /**\n     * @notice Get the address based on template ID.\n     * @param _templateId Auction template ID.\n     * @return Address of the required template ID.\n     */\n    function getAuctionTemplate(uint256 _templateId) external view returns (address) {\n        return auctionTemplates[_templateId];\n    }\n\n    /**\n     * @notice Get the ID based on template address.\n     * @param _auctionTemplate Auction template address.\n     * @return ID of the required template address.\n     */\n    function getTemplateId(address _auctionTemplate) external view returns (uint256) {\n        return auctionTemplateToId[_auctionTemplate];\n    }\n\n    /**\n     * @notice Get the total number of auctions in the factory.\n     * @return Auction count.\n     */\n    function numberOfAuctions() external view returns (uint) {\n        return auctions.length;\n    }\n\n    function minimumFee() external view returns(uint128) {\n        return marketFees.minimumFee;\n    }\n\n    function getMarkets() external view returns(address[] memory) {\n        return auctions;\n    }\n\n    function getMarketTemplateId(address _auction) external view returns(uint64) {\n        return auctionInfo[_auction].templateId;\n    }\n}"
    },
    {
      "filename": "contracts/MISOLauncher.sol",
      "content": "pragma solidity 0.6.12;\n\n//----------------------------------------------------------------------------------\n//    I n s t a n t\n//\n//        .:mmm.         .:mmm:.       .ii.  .:SSSSSSSSSSSSS.     .oOOOOOOOOOOOo.  \n//      .mMM'':Mm.     .:MM'':Mm:.     .II:  :SSs..........     .oOO'''''''''''OOo.\n//    .:Mm'   ':Mm.   .:Mm'   'MM:.    .II:  'sSSSSSSSSSSSSS:.  :OO.           .OO:\n//  .'mMm'     ':MM:.:MMm'     ':MM:.  .II:  .:...........:SS.  'OOo:.........:oOO'\n//  'mMm'        ':MMmm'         'mMm:  II:  'sSSSSSSSSSSSSS'     'oOOOOOOOOOOOO'  \n//\n//----------------------------------------------------------------------------------\n//\n// Chef Gonpachi's MISO Launcher\n//\n// A factory to conveniently deploy your own liquidity contracts\n//\n// Inspired by Bokky's EtherVendingMachince.io\n// https://github.com/bokkypoobah/FixedSupplyTokenFactory\n// \n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// The above copyright notice and this permission notice shall be included \n// in all copies or substantial portions of the Software.\n//\n// Made for Sushi.com \n// \n// Enjoy. (c) Chef Gonpachi 2021 \n// <https://github.com/chefgonpachi/MISO/>\n//\n// ---------------------------------------------------------------------\n// SPDX-License-Identifier: GPL-3.0                        \n// ---------------------------------------------------------------------\n\nimport \"./Utils/SafeTransfer.sol\";\nimport \"./Utils/BoringMath.sol\";\nimport \"./Access/MISOAccessControls.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IMisoLiquidity.sol\";\nimport \"./interfaces/IBentoBoxFactory.sol\";\n\n\ncontract MISOLauncher is SafeTransfer {\n\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using BoringMath64 for uint64;\n\n    /// @notice Responsible for access rights to the contract.\n    MISOAccessControls public accessControls;\n    bytes32 public constant LAUNCHER_MINTER_ROLE = keccak256(\"LAUNCHER_MINTER_ROLE\");\n\n    /// @notice Whether launcher has been initialized or not.\n    bool private initialised;\n\n    /// @notice Struct to track Auction template.\n    struct Launcher {\n        bool exists;\n        uint64 templateId;\n        uint128 index;\n    }\n\n    /// @notice All the launchers created using factory.\n    address[] public launchers;\n\n    /// @notice Template id to track respective auction template.\n    uint256 public launcherTemplateId;\n\n    /// @notice Address for Wrapped Ether.\n    address public WETH;\n    IBentoBoxFactory public bentoBox;\n\n    /// @notice Mapping from template id to launcher template address.\n    mapping(uint256 => address) private launcherTemplates;\n\n    /// @notice mapping from launcher template address to launcher template id\n    mapping(address => uint256) private launcherTemplateToId;\n\n    // /// @notice mapping from template type to template id\n    mapping(uint256 => uint256) public currentTemplateId;\n\n    /// @notice Mapping from auction created through this contract to Auction struct.\n    mapping(address => Launcher) public launcherInfo;\n\n    /// @notice Struct to define fees.\n    struct LauncherFees {\n        uint128 minimumFee;\n        uint32 integratorFeePct;\n    }\n\n    /// @notice Minimum fee to create a launcher through the factory.\n    LauncherFees public launcherFees;\n\n    /// @notice Contract locked status. If locked, only minters can deploy\n    bool public locked;\n\n    ///@notice Any donations if set are sent here.\n    address payable public misoDiv;\n\n    /// @notice Event emitted when first intializing the liquidity launcher.\n    event MisoInitLauncher(address sender);\n\n    /// @notice Event emitted when launcher is created using template id.\n    event LauncherCreated(address indexed owner, address indexed addr, address launcherTemplate);\n\n    /// @notice Event emitted when launcher template is added to factory.\n    event LauncherTemplateAdded(address newLauncher, uint256 templateId);\n\n    /// @notice Event emitted when launcher template is removed.\n    event LauncherTemplateRemoved(address launcher, uint256 templateId);\n\n    constructor() public {\n    }\n\n    /**\n     * @notice Single gateway to initialize the MISO Launcher with proper address.\n     * @dev Can only be initialized once.\n     * @param _accessControls Sets address to get the access controls from.\n     */\n    function initMISOLauncher(address _accessControls, address _WETH, address _bentoBox) external {\n        require(!initialised);\n        require(_WETH != address(0), \"initMISOLauncher: WETH cannot be set to zero\");\n        require(_accessControls != address(0), \"initMISOLauncher: accessControls cannot be set to zero\");\n        require(_bentoBox != address(0), \"initMISOLauncher: bentoBox cannot be set to zero\");\n\n        accessControls = MISOAccessControls(_accessControls);\n        bentoBox = IBentoBoxFactory(_bentoBox); \n        WETH = _WE"
    }
  ]
}