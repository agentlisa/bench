{
  "Title": "[M-17] `AutoExit` could receive a reward calculated from the entire position's fund even if `onlyFee` is true in `AutoExit.execute()`",
  "Content": "\n<https://github.com/code-423n4/2024-03-revert-lend/blob/main/src/automators/AutoExit.sol#L100-L214>\n\n<https://github.com/code-423n4/2024-03-revert-lend/blob/main/src/automators/Automator.sol#L193-L215>\n\n### Impact\n\nThe owner of the NFT could end up paying more rewards to `AutoExit` than anticipated when `onlyFee` is set to true.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2024-03-revert-lend/blob/main/src/automators/AutoExit.sol#L155>\n\n```javascript\n\n    function execute(ExecuteParams calldata params) external {\n        [...]\n\n            // reward is taken before swap - if from fees only\n            if (config.onlyFees) {\n155             state.amount0 -= state.feeAmount0 * params.rewardX64 / Q64;\n                state.amount1 -= state.feeAmount1 * params.rewardX64 / Q64;\n            }\n\n        [...]\n    }\n```\n\n<https://github.com/code-423n4/2024-03-revert-lend/blob/main/src/automators/Automator.sol#L208>\n\n```javascript\n\n    function _decreaseFullLiquidityAndCollect(\n        uint256 tokenId,\n        uint128 liquidity,\n        uint256 amountRemoveMin0,\n        uint256 amountRemoveMin1,\n        uint256 deadline\n    ) internal returns (uint256 amount0, uint256 amount1, uint256 feeAmount0, uint256 feeAmount1) {\n        if (liquidity > 0) {\n            // store in temporarily \"misnamed\" variables - see comment below\n202         (feeAmount0, feeAmount1) = nonfungiblePositionManager.decreaseLiquidity(\n                INonfungiblePositionManager.DecreaseLiquidityParams(\n                    tokenId, liquidity, amountRemoveMin0, amountRemoveMin1, deadline\n                )\n            );\n        }\n208     (amount0, amount1) = nonfungiblePositionManager.collect(\n            INonfungiblePositionManager.CollectParams(tokenId, address(this), type(uint128).max, type(uint128).max)\n        );\n\n        // fee amount is what was collected additionally to liquidity amount\n        feeAmount0 = amount0 - feeAmount0;\n        feeAmount1 = amount1 - feeAmount1;\n    }\n```\n\nAs seen at `L208`, `feeAmount` represents the uncollected fees excluding assets from the current liquidity. However, it includes the `owed` amount, which comprises uncollected assets not just from fees but also from `nonfungiblePositionManager.decreaseLiquidity()` called earlier at `L202`. If the owner has already executed `nonfungiblePositionManager.decreaseLiquidity()`, the uncollected assets would consist of some assets withdrawn from their liquidity, possibly a significant portion. This implies that `onlyFee` configuration is not functioning effectively.\n\nHere is a simple scenario to highlight this issue:\n\n1. The owner invokes `nonfungiblePositionManager.approve(address(autoExit), NFT)` and sets `onlyFee` to true.\n2. The owner then calls `nonfungiblePositionManager.decreaseLiquidity()` to withdraw the majority of their liquidity..\n3. Subsequently, an operator calls `autoExit.execute()` and receives more rewards than anticipated.\n\n### Recommended Mitigation Steps\n\nIn [`Automator._decreaseFullLiquidityAndCollect()`](https://github.com/code-423n4/2024-03-revert-lend/blob/main/src/automators/Automator.sol#L202), `feeAmount0, feeAmount1` must only include the amount calculated from the `feeGrowthInside` of UniswapV3 position.\n\n**[mariorz (Revert) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2024-03-revert-lend-findings/issues/216#issuecomment-2024092091):**\n > Don't believe this should be a \"high risk\".\n> 1. Users calling `decreaseLiquidity` without calling collect is possible but non-standard and there is no real reason to do this.\n> 2. If this ever happened by some edge case, the `Operator` is an approved role that would be incentivized to return the extra fees to the affected user.\n> 3. There is no risk for other lenders or borrowers.\n> 4. Risk for the affected LP is limited to <2% of the position value.\n\n**[ronnyx2017 (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-03-revert-lend-findings/issues/216#issuecomment-2028803971):**\n > More like user error or a malicious operator.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-revert-lend",
  "Code": [
    {
      "filename": "src/automators/AutoExit.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./Automator.sol\";\n\n/// @title AutoExit\n/// @notice Lets a v3 position to be automatically removed (limit order) or swapped to the opposite token (stop loss order) when it reaches a certain tick.\n/// A revert controlled bot (operator) is responsable for the execution of optimized swaps (using external swap router)\n/// Positions need to be approved (approve or setApprovalForAll) for the contract and configured with configToken method\ncontract AutoExit is Automator {\n    event Executed(\n        uint256 indexed tokenId,\n        address account,\n        bool isSwap,\n        uint256 amountReturned0,\n        uint256 amountReturned1,\n        address token0,\n        address token1\n    );\n    event PositionConfigured(\n        uint256 indexed tokenId,\n        bool isActive,\n        bool token0Swap,\n        bool token1Swap,\n        int24 token0TriggerTick,\n        int24 token1TriggerTick,\n        uint64 token0SlippageX64,\n        uint64 token1SlippageX64,\n        bool onlyFees,\n        uint64 maxRewardX64\n    );\n\n    constructor(\n        INonfungiblePositionManager _npm,\n        address _operator,\n        address _withdrawer,\n        uint32 _TWAPSeconds,\n        uint16 _maxTWAPTickDifference,\n        address _zeroxRouter,\n        address _universalRouter\n    ) Automator(_npm, _operator, _withdrawer, _TWAPSeconds, _maxTWAPTickDifference, _zeroxRouter, _universalRouter) {}\n\n    // define how stoploss / limit should be handled\n    struct PositionConfig {\n        bool isActive; // if position is active\n        // should swap token to other token when triggered\n        bool token0Swap;\n        bool token1Swap;\n        // when should action be triggered (when this tick is reached - allow execute)\n        int24 token0TriggerTick; // when tick is below this one\n        int24 token1TriggerTick; // when tick is equal or above this one\n        // max price difference from current pool price for swap / Q64\n        uint64 token0SlippageX64; // when token 0 is swapped to token 1\n        uint64 token1SlippageX64; // when token 1 is swapped to token 0\n        bool onlyFees; // if only fees maybe used for protocol reward\n        uint64 maxRewardX64; // max allowed reward percentage of fees or full position\n    }\n\n    // configured tokens\n    mapping(uint256 => PositionConfig) public positionConfigs;\n\n    /// @notice params for execute()\n    struct ExecuteParams {\n        uint256 tokenId; // tokenid to process\n        bytes swapData; // if its a swap order - must include swap data\n        uint128 liquidity; // liquidity the calculations are based on\n        uint256 amountRemoveMin0; // min amount to be removed from liquidity\n        uint256 amountRemoveMin1; // min amount to be removed from liquidity\n        uint256 deadline; // for uniswap operations - operator promises fair value\n        uint64 rewardX64; // which reward will be used for protocol, can be max configured amount (considering onlyFees)\n    }\n\n    struct ExecuteState {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint128 liquidity;\n        uint256 amount0;\n        uint256 amount1;\n        uint256 feeAmount0;\n        uint256 feeAmount1;\n        uint256 amountOutMin;\n        uint256 amountInDelta;\n        uint256 amountOutDelta;\n        IUniswapV3Pool pool;\n        uint256 swapAmount;\n        int24 tick;\n        bool isSwap;\n        bool isAbove;\n        address owner;\n    }\n\n    /**\n     * @notice Handle token (must be in correct state)\n     * Can only be called only from configured operator account\n     * Swap needs to be done with max price difference from current pool price - otherwise reverts\n     */\n    function execute(ExecuteParams calldata params) external {\n        if (!operators[msg.sender]) {\n            revert Unauthorized();\n        }\n\n        ExecuteState memory state;\n        PositionConfig memory config = positionConfigs[params.tokenId];\n\n        if (!config.isActive) {\n            revert NotConfigured();\n        }\n\n        if (\n            config.onlyFees && params.rewardX64 > config.maxRewardX64\n                || !config.onlyFees && params.rewardX64 > config.maxRewardX64\n        ) {\n            revert ExceedsMaxReward();\n        }\n\n        // get position info\n        (,, state.token0, state.token1, state.fee, state.tickLower, state.tickUpper, state.liquidity,,,,) =\n            nonfungiblePositionManager.positions(params.tokenId);\n\n        // so can be executed only once\n        if (state.liquidity == 0) {\n            revert NoLiquidity();\n        }\n        if (state.liquidity != params.liquidity) {\n            revert LiquidityChanged();\n        }\n\n        state.pool = _getPool(state.token0, state.token1, state.fee);\n        (, state.tick,,,,,) = state.pool.slot0();\n\n        // not triggered\n        if (config.token0TriggerTick <= state.tick && state.tick < config.token1TriggerTick) {\n            revert NotReady();\n        }\n\n        state.isAbove = state.tick >= config.token1TriggerTick;\n        state.isSwap = !state.isAbove && config.token0Swap || state.isAbove && config.token1Swap;\n\n        // decrease full liquidity for given position - and return fees as well\n        (state.amount0, state.amount1, state.feeAmount0, state.feeAmount1) = _decreaseFullLiquidityAndCollect(\n            params.tokenId, state.liquidity, params.amountRemoveMin0, params.amountRemoveMin1, params.deadline\n        );\n\n        // swap to other token\n        if (state.isSwap) {\n            if (params.swapData.length == 0) {\n                revert MissingSwapData();\n            }\n\n            // reward is taken before swap - if from fees only\n            if (config.onlyFees) {\n                state.amount0 -= state.feeAmount0 * params.rewardX64 / Q64;\n                state.amount1 -= state.feeAmount1 * params.rewardX64 / Q64;\n            }\n\n            state.swapAmount = state.isAbove ? state.amount1 : state.amount0;\n\n            // checks if price in valid oracle range and calculates amountOutMin\n            (state.amountOutMin,,,) = _validateSwap(\n                !state.isAbove,\n                state.swapAmount,\n                state.pool,\n                TWAPSeconds,\n                maxTWAPTickDifference,\n                state.isAbove ? config.token1SlippageX64 : config.token0SlippageX64\n            );\n\n            (state.amountInDelta, state.amountOutDelta) = _routerSwap(\n                Swapper.RouterSwapParams(\n                    state.isAbove ? IERC20(state.token1) : IERC20(state.token0),\n                    state.isAbove ? IERC20(state.token0) : IERC20(state.token1),\n                    state.swapAmount,\n                    state.amountOutMin,\n                    params.swapData\n                )\n            );\n\n            state.amount0 = state.isAbove ? state.amount0 + state.amountOutDelta : state.amount0 - state.amountInDelta;\n            state.amount1 = state.isAbove ? state.amount1 - state.amountInDelta : state.amount1 + state.amountOutDelta;\n\n            // when swap and !onlyFees - protocol reward is removed only from target token (to incentivize optimal swap done by operator)\n            if (!config.onlyFees) {\n                if (state.isAbove) {\n                    state.amount0 -= state.amount0 * params.rewardX64 / Q64;\n                } else {\n                    state.amount1 -= state.amount1 * params.rewardX64 / Q64;\n                }\n            }\n        } else {\n            // reward is taken as configured\n            state.amount0 -= (config.onlyFees ? state.feeAmount0 : state.amount0) * params.rewardX64 / Q64;\n            state.amount1 -= (config.onlyFees ? state.feeAmount1 : state.amount1) * params.rewardX64 / Q64;\n        }\n\n        state.owner = nonfungiblePositionManager.ownerOf(params.tokenId);\n        if (state.amount0 > 0) {\n            _transferToken(state.owner, IERC20(state.token0), state.amount0, true);\n        }\n        if (state.amount1 > 0) {\n            _transferToken(state.owner, IERC20(state.token1), state.amount1, true);\n        }\n\n        // delete config for position\n        delete positionConfigs[params.tokenId];\n        emit PositionConfigured(params.tokenId, false, false, false, 0, 0, 0, 0, false, 0);\n\n        // log event\n        emit Executed(\n            params.tokenId, msg.sender, state.isSwap, state.amount0, state.amount1, state.token0, state.token1\n        );\n    }\n\n    // function to configure a token to be used with this runner\n    // it needs to have approvals set for this contract beforehand\n    function configToken(uint256 tokenId, PositionConfig calldata config) external {\n        address owner = nonfungiblePositionManager.ownerOf(tokenId);\n        if (owner != msg.sender) {\n            revert Unauthorized();\n        }\n\n        if (config.isActive) {\n            if (config.token0TriggerTick >= config.token1TriggerTick) {\n                revert InvalidConfig();\n            }\n        }\n\n        positionConfigs[tokenId] = config;\n\n        emit PositionConfigured(\n            tokenId,\n            config.isActive,\n            config.token0Swap,\n            config.token1Swap,\n            config.token0TriggerTick,\n            config.token1TriggerTick,\n            config.token0SlippageX64,\n            config.token1SlippageX64,\n            config.onlyFees,\n            config.maxRewardX64\n        );\n    }\n}"
    },
    {
      "filename": "src/automators/Automator.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"v3-core/interfaces/IUniswapV3Factory.sol\";\nimport \"v3-core/interfaces/IUniswapV3Pool.sol\";\nimport \"v3-core/libraries/TickMath.sol\";\nimport \"v3-core/libraries/FullMath.sol\";\n\nimport \"v3-periphery/interfaces/INonfungiblePositionManager.sol\";\n\nimport \"../../lib/IWETH9.sol\";\nimport \"../utils/Swapper.sol\";\nimport \"../interfaces/IVault.sol\";\n\nabstract contract Automator is Swapper, Ownable {\n    uint256 internal constant Q64 = 2 ** 64;\n    uint256 internal constant Q96 = 2 ** 96;\n\n    uint32 public constant MIN_TWAP_SECONDS = 60; // 1 minute\n    uint32 public constant MAX_TWAP_TICK_DIFFERENCE = 200; // 2%\n\n    // admin events\n    event OperatorChanged(address newOperator, bool active);\n    event VaultChanged(address newVault, bool active);\n\n    event WithdrawerChanged(address newWithdrawer);\n    event TWAPConfigChanged(uint32 TWAPSeconds, uint16 maxTWAPTickDifference);\n\n    // configurable by owner\n    mapping(address => bool) public operators;\n    mapping(address => bool) public vaults;\n\n    address public withdrawer;\n    uint32 public TWAPSeconds;\n    uint16 public maxTWAPTickDifference;\n\n    constructor(\n        INonfungiblePositionManager npm,\n        address _operator,\n        address _withdrawer,\n        uint32 _TWAPSeconds,\n        uint16 _maxTWAPTickDifference,\n        address _zeroxRouter,\n        address _universalRouter\n    ) Swapper(npm, _zeroxRouter, _universalRouter) {\n        setOperator(_operator, true);\n        setWithdrawer(_withdrawer);\n        setTWAPConfig(_maxTWAPTickDifference, _TWAPSeconds);\n    }\n\n    /**\n     * @notice Owner controlled function to set withdrawer address\n     * @param _withdrawer withdrawer\n     */\n    function setWithdrawer(address _withdrawer) public onlyOwner {\n        emit WithdrawerChanged(_withdrawer);\n        withdrawer = _withdrawer;\n    }\n\n    /**\n     * @notice Owner controlled function to activate/deactivate operator address\n     * @param _operator operator\n     * @param _active active or not\n     */\n    function setOperator(address _operator, bool _active) public onlyOwner {\n        emit OperatorChanged(_operator, _active);\n        operators[_operator] = _active;\n    }\n\n    /**\n     * @notice Owner controlled function to activate/deactivate vault address\n     * @param _vault vault\n     * @param _active active or not\n     */\n    function setVault(address _vault, bool _active) public onlyOwner {\n        emit VaultChanged(_vault, _active);\n        vaults[_vault] = _active;\n    }\n\n    /**\n     * @notice Owner controlled function to increase TWAPSeconds / decrease maxTWAPTickDifference\n     */\n    function setTWAPConfig(uint16 _maxTWAPTickDifference, uint32 _TWAPSeconds) public onlyOwner {\n        if (_TWAPSeconds < MIN_TWAP_SECONDS) {\n            revert InvalidConfig();\n        }\n        if (_maxTWAPTickDifference > MAX_TWAP_TICK_DIFFERENCE) {\n            revert InvalidConfig();\n        }\n        emit TWAPConfigChanged(_TWAPSeconds, _maxTWAPTickDifference);\n        TWAPSeconds = _TWAPSeconds;\n        maxTWAPTickDifference = _maxTWAPTickDifference;\n    }\n\n    /**\n     * @notice Withdraws token balance (accumulated protocol fee)\n     * @param tokens Addresses of tokens to withdraw\n     * @param to Address to send to\n     */\n    function withdrawBalances(address[] calldata tokens, address to) external virtual {\n        if (msg.sender != withdrawer) {\n            revert Unauthorized();\n        }\n\n        uint256 i;\n        uint256 count = tokens.length;\n        for (; i < count; ++i) {\n            uint256 balance = IERC20(tokens[i]).balanceOf(address(this));\n            if (balance > 0) {\n                _transferToken(to, IERC20(tokens[i]), balance, true);\n            }\n        }\n    }\n\n    /**\n     * @notice Withdraws ETH balance\n     * @param to Address to send to\n     */\n    function withdrawETH(address to) external {\n        if (msg.sender != withdrawer) {\n            revert Unauthorized();\n        }\n\n        uint256 balance = address(this).balance;\n        if (balance > 0) {\n            (bool sent,) = to.call{value: balance}(\"\");\n            if (!sent) {\n                revert EtherSendFailed();\n            }\n        }\n    }\n\n    // validate if swap can be done with specified oracle parameters - if not possible reverts\n    // if possible returns minAmountOut\n    function _validateSwap(\n        bool swap0For1,\n        uint256 amountIn,\n        IUniswapV3Pool pool,\n        uint32 twapPeriod,\n        uint16 maxTickDifference,\n        uint64 maxPriceDifferenceX64\n    ) internal view returns (uint256 amountOutMin, int24 currentTick, uint160 sqrtPriceX96, uint256 priceX96) {\n        // get current price and tick\n        (sqrtPriceX96, currentTick,,,,,) = pool.slot0();\n\n        // check if current tick not too far from TWAP\n        if (!_hasMaxTWAPTickDifference(pool, twapPeriod, currentTick, maxTickDifference)) {\n            revert TWAPCheckFailed();\n        }\n\n        // calculate min output price price and percentage\n        priceX96 = FullMath.mulDiv(sqrtPriceX96, sqrtPriceX96, Q96);\n        if (swap0For1) {\n            amountOutMin = FullMath.mulDiv(amountIn * (Q64 - maxPriceDifferenceX64), priceX96, Q96 * Q64);\n        } else {\n            amountOutMin = FullMath.mulDiv(amountIn * (Q64 - maxPriceDifferenceX64), Q96, priceX96 * Q64);\n        }\n    }\n\n    // Checks if there was not more tick difference\n    // returns false if not enough data available or tick difference >= maxDifference\n    function _hasMaxTWAPTickDifference(IUniswapV3Pool pool, uint32 twapPeriod, int24 currentTick, uint16 maxDifference)\n        internal\n        view\n        returns (bool)\n    {\n        (int24 twapTick, bool twapOk) = _getTWAPTick(pool, twapPeriod);\n        if (twapOk) {\n            return twapTick - currentTick >= -int16(maxDifference) && twapTick - currentTick <= int16(maxDifference);\n        } else {\n            return false;\n        }\n    }\n\n    // gets twap tick from pool history if enough history available\n    function _getTWAPTick(IUniswapV3Pool pool, uint32 twapPeriod) internal view returns (int24, bool) {\n        uint32[] memory secondsAgos = new uint32[](2);\n        secondsAgos[0] = 0; // from (before)\n        secondsAgos[1] = twapPeriod; // from (before)\n\n        // pool observe may fail when there is not enough history available\n        try pool.observe(secondsAgos) returns (int56[] memory tickCumulatives, uint160[] memory) {\n            return (int24((tickCumulatives[0] - tickCumulatives[1]) / int56(uint56(twapPeriod))), true);\n        } catch {\n            return (0, false);\n        }\n    }\n\n    function _decreaseFullLiquidityAndCollect(\n        uint256 tokenId,\n        uint128 liquidity,\n        uint256 amountRemoveMin0,\n        uint256 amountRemoveMin1,\n        uint256 deadline\n    ) internal returns (uint256 amount0, uint256 amount1, uint256 feeAmount0, uint256 feeAmount1) {\n        if (liquidity > 0) {\n            // store in temporarely \"misnamed\" variables - see comment below\n            (feeAmount0, feeAmount1) = nonfungiblePositionManager.decreaseLiquidity(\n                INonfungiblePositionManager.DecreaseLiquidityParams(\n                    tokenId, liquidity, amountRemoveMin0, amountRemoveMin1, deadline\n                )\n            );\n        }\n        (amount0, amount1) = nonfungiblePositionManager.collect(\n            INonfungiblePositionManager.CollectParams(tokenId, address(this), type(uint128).max, type(uint128).max)\n        );\n\n        // fee amount is what was collected additionally to liquidity amount\n        feeAmount0 = amount0 - feeAmount0;\n        feeAmount1 = amount1 - feeAmount1;\n    }\n\n    // transfers token (or unwraps WETH and sends ETH)\n    function _transferToken(address to, IERC20 token, uint256 amount, bool unwrap) internal {\n        if (address(weth) == address(token) && unwrap) {\n            weth.withdraw(amount);\n            (bool sent,) = to.call{value: amount}(\"\");\n            if (!sent) {\n                revert EtherSendFailed();\n            }\n        } else {\n            SafeERC20.safeTransfer(token, to, amount);\n        }\n    }\n\n    function _validateOwner(uint256 tokenId, address vault) internal returns (address owner) {\n        // msg.sender must not be a vault\n        if (vaults[msg.sender]) {\n            revert Unauthorized();\n        }\n\n        if (vault != address(0)) {\n            if (!vaults[vault]) {\n                revert Unauthorized();\n            }\n            owner = IVault(vault).ownerOf(tokenId);\n        } else {\n            owner = nonfungiblePositionManager.ownerOf(tokenId);\n        }\n\n        if (owner != msg.sender) {\n            revert Unauthorized();\n        }\n    }\n\n    // needed for WETH unwrapping\n    receive() external payable {\n        if (msg.sender != address(weth)) {\n            revert NotWETH();\n        }\n    }\n}"
    },
    {
      "filename": "src/automators/AutoExit.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./Automator.sol\";\n\n/// @title AutoExit\n/// @notice Lets a v3 position to be automatically removed (limit order) or swapped to the opposite token (stop loss order) when it reaches a certain tick.\n/// A revert controlled bot (operator) is responsable for the execution of optimized swaps (using external swap router)\n/// Positions need to be approved (approve or setApprovalForAll) for the contract and configured with configToken method\ncontract AutoExit is Automator {\n    event Executed(\n        uint256 indexed tokenId,\n        address account,\n        bool isSwap,\n        uint256 amountReturned0,\n        uint256 amountReturned1,\n        address token0,\n        address token1\n    );\n    event PositionConfigured(\n        uint256 indexed tokenId,\n        bool isActive,\n        bool token0Swap,\n        bool token1Swap,\n        int24 token0TriggerTick,\n        int24 token1TriggerTick,\n        uint64 token0SlippageX64,\n        uint64 token1SlippageX64,\n        bool onlyFees,\n        uint64 maxRewardX64\n    );\n\n    constructor(\n        INonfungiblePositionManager _npm,\n        address _operator,\n        address _withdrawer,\n        uint32 _TWAPSeconds,\n        uint16 _maxTWAPTickDifference,\n        address _zeroxRouter,\n        address _universalRouter\n    ) Automator(_npm, _operator, _withdrawer, _TWAPSeconds, _maxTWAPTickDifference, _zeroxRouter, _universalRouter) {}\n\n    // define how stoploss / limit should be handled\n    struct PositionConfig {\n        bool isActive; // if position is active\n        // should swap token to other token when triggered\n        bool token0Swap;\n        bool token1Swap;\n        // when should action be triggered (when this tick is reached - allow execute)\n        int24 token0TriggerTick; // when tick is below this one\n        int24 token1TriggerTick; // when tick is equal or above this one\n        // max price difference from current pool price for swap / Q64\n        uint64 token0SlippageX64; // when token 0 is swapped to token 1\n        uint64 token1SlippageX64; // when token 1 is swapped to token 0\n        bool onlyFees; // if only fees maybe used for protocol reward\n        uint64 maxRewardX64; // max allowed reward percentage of fees or full position\n    }\n\n    // configured tokens\n    mapping(uint256 => PositionConfig) public positionConfigs;\n\n    /// @notice params for execute()\n    struct ExecuteParams {\n        uint256 tokenId; // tokenid to process\n        bytes swapData; // if its a swap order - must include swap data\n        uint128 liquidity; // liquidity the calculations are based on\n        uint256 amountRemoveMin0; // min amount to be removed from liquidity\n        uint256 amountRemoveMin1; // min amount to be removed from liquidity\n        uint256 deadline; // for uniswap operations - operator promises fair value\n        uint64 rewardX64; // which reward will be used for protocol, can be max configured amount (considering onlyFees)\n    }\n\n    struct ExecuteState {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint128 liquidity;\n        uint256 amount0;\n        uint256 amount1;\n        uint256 feeAmount0;\n        uint256 feeAmount1;\n        uint256 amountOutMin;\n        uint256 amountInDelta;\n        uint256 amountOutDelta;\n        IUniswapV3Pool pool;\n        uint256 swapAmount;\n        int24 tick;\n        bool isSwap;\n        bool isAbove;\n        address owner;\n    }\n\n    /**\n     * @notice Handle token (must be in correct state)\n     * Can only be called only from configured operator account\n     * Swap needs to be done with max price difference from current pool price - otherwise reverts\n     */\n    function execute(ExecuteParams calldata params) external {\n        if (!operators[msg.sender]) {\n            revert Unauthorized();\n        }\n\n        ExecuteState memory state;\n        PositionConfig memory config = positionConfigs[params.tokenId];\n\n        if (!config.isActive) {\n            revert NotConfigured();\n        }\n\n        if (\n            config.onlyFees && params.rewardX64 > config.maxRewardX64\n                || !config.onlyFees && params.rewardX64 > config.maxRewardX64\n        ) {\n            revert ExceedsMaxReward();\n        }\n\n        // get position info\n        (,, state.token0, state.token1, state.fee, state.tickLower, state.tickUpper, state.liquidity,,,,) =\n            nonfungiblePositionManager.positions(params.tokenId);\n\n        // so can be executed only once\n        if (state.liquidity == 0) {\n            revert NoLiquidity();\n        }\n        if (state.liquidity != params.liquidity) {\n            revert LiquidityChanged();\n        }\n\n        state.pool = _getPool(state.token0, state.token1, state.fee);\n        (, state.tick,,,,,) = state.pool.slot0();\n\n        // not triggered\n        if (config.token0TriggerTick <= state.tick && state.tick < config.token1TriggerTick) {\n            revert NotReady();\n        }\n\n        state.isAbove = state.tick >= config.token1TriggerTick;\n        state.isSwap = !state.isAbove && config.token0Swap || state.isAbove && config.token1Swap;\n\n        // decrease full liquidity for given position - and return fees as well\n        (state.amount0, state.amount1, state.feeAmount0, state.feeAmount1) = _decreaseFullLiquidityAndCollect(\n            params.tokenId, state.liquidity, params.amountRemoveMin0, params.amountRemoveMin1, params.deadline\n        );\n\n        // swap to other token\n        if (state.isSwap) {\n            if (params.swapData.length == 0) {\n                revert MissingSwapData();\n            }\n\n            // reward is taken before swap - if from fees only\n            if (config.onlyFees) {\n                state.amount0 -= state.feeAmount0 * params.rewardX64 / Q64;\n                state.amount1 -= state.feeAmount1 * params.rewardX64 / Q64;\n            }\n\n            state.swapAmount = state.isAbove ? state.amount1 : state.amount0;\n\n            // checks if price in valid oracle range and calculates amountOutMin\n            (state.amountOutMin,,,) = _validateSwap(\n                !state.isAbove,\n                state.swapAmount,\n                state.pool,\n                TWAPSeconds,\n                maxTWAPTickDifference,\n                state.isAbove ? config.token1SlippageX64 : config.token0SlippageX64\n            );\n\n            (state.amountInDelta, state.amountOutDelta) = _routerSwap(\n                Swapper.RouterSwapParams(\n                    state.isAbove ? IERC20(state.token1) : IERC20(state.token0),\n                    state.isAbove ? IERC20(state.token0) : IERC20(state.token1),\n                    state.swapAmount,\n                    state.amountOutMin,\n                    params.swapData\n                )\n            );\n\n            state.amount0 = state.isAbove ? state.amount0 + state.amountOutDelta : state.amount0 - state.amountInDelta;\n            state.amount1 = state.isAbove ? state.amount1 - state.amountInDelta : state.amount1 + state.amountOutDelta;\n\n            // when swap and !onlyFees - protocol reward is removed only from target token (to incentivize optimal swap done by operator)\n            if (!config.onlyFees) {\n                if (state.isAbove) {\n                    state.amount0 -= state.amount0 * params.rewardX64 / Q64;\n                } else {\n                    state.amount1 -= state.amount1 * params.rewardX64 / Q64;\n                }\n            }\n        } else {\n            // reward is taken as configured\n            state.amount0 -= (config.onlyFees ? state.feeAmount0 : state.amount0) * params.rewardX64 / Q64;\n            state.amount1 -= (config.onlyFees ? state.feeAmount1 : state.amount1) * params.rewardX64 / Q64;\n        }\n\n        state.owner = nonfungiblePositionManager.ownerOf(params.tokenId);\n        if (state.amount0 > 0) {\n            _transferToken(state.owner, IERC20(state.token0), state.amount0, true);\n        }\n        if (state.amount1 > 0) {\n            _transferToken(state.owner, IERC20(state.token1), state.amount1, true);\n        }\n\n        // delete config for position\n        delete positionConfigs[params.tokenId];\n        emit PositionConfigured(params.tokenId, false, false, false, 0, 0, 0, 0, false, 0);\n\n        // log event\n        emit Executed(\n            params.tokenId, msg.sender, state.isSwap, state.amount0, state.amount1, state.token0, state.token1\n        );\n    }\n\n    // function to configure a token to be used with this runner\n    // it needs to have approvals set for this contract beforehand\n    function configToken(uint256 tokenId, PositionConfig calldata config) external {\n        address owner = nonfungiblePositionManager.ownerOf(tokenId);\n        if (owner != msg.sender) {\n            revert Unauthorized();\n        }\n\n        if (config.isActive) {\n            if (config.token0TriggerTick >= config.token1TriggerTick) {\n                revert InvalidConfig();\n            }\n        }\n\n        positionConfigs[tokenId] = config;\n\n        emit PositionConfigured(\n            tokenId,\n            config.isActive,\n            config.token0Swap,\n            config.token1Swap,\n            config.token0TriggerTick,\n            config.token1TriggerTick,\n            config.token0SlippageX64,\n            config.token1SlippageX64,\n            config.onlyFees,\n            config.maxRewardX64\n        );\n    }\n}"
    },
    {
      "filename": "src/automators/Automator.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"v3-core/interfaces/IUniswapV3Factory.sol\";\nimport \"v3-core/interfaces/IUniswapV3Pool.sol\";\nimport \"v3-core/libraries/TickMath.sol\";\nimport \"v3-core/libraries/FullMath.sol\";\n\nimport \"v3-periphery/interfaces/INonfungiblePositionManager.sol\";\n\nimport \"../../lib/IWETH9.sol\";\nimport \"../utils/Swapper.sol\";\nimport \"../interfaces/IVault.sol\";\n\nabstract contract Automator is Swapper, Ownable {\n    uint256 internal constant Q64 = 2 ** 64;\n    uint256 internal constant Q96 = 2 ** 96;\n\n    uint32 public constant MIN_TWAP_SECONDS = 60; // 1 minute\n    uint32 public constant MAX_TWAP_TICK_DIFFERENCE = 200; // 2%\n\n    // admin events\n    event OperatorChanged(address newOperator, bool active);\n    event VaultChanged(address newVault, bool active);\n\n    event WithdrawerChanged(address newWithdrawer);\n    event TWAPConfigChanged(uint32 TWAPSeconds, uint16 maxTWAPTickDifference);\n\n    // configurable by owner\n    mapping(address => bool) public operators;\n    mapping(address => bool) public vaults;\n\n    address public withdrawer;\n    uint32 public TWAPSeconds;\n    uint16 public maxTWAPTickDifference;\n\n    constructor(\n        INonfungiblePositionManager npm,\n        address _operator,\n        address _withdrawer,\n        uint32 _TWAPSeconds,\n        uint16 _maxTWAPTickDifference,\n        address _zeroxRouter,\n        address _universalRouter\n    ) Swapper(npm, _zeroxRouter, _universalRouter) {\n        setOperator(_operator, true);\n        setWithdrawer(_withdrawer);\n        setTWAPConfig(_maxTWAPTickDifference, _TWAPSeconds);\n    }\n\n    /**\n     * @notice Owner controlled function to set withdrawer address\n     * @param _withdrawer withdrawer\n     */\n    function setWithdrawer(address _withdrawer) public onlyOwner {\n        emit WithdrawerChanged(_withdrawer);\n        withdrawer = _withdrawer;\n    }\n\n    /**\n     * @notice Owner controlled function to activate/deactivate operator address\n     * @param _operator operator\n     * @param _active active or not\n     */\n    function setOperator(address _operator, bool _active) public onlyOwner {\n        emit OperatorChanged(_operator, _active);\n        operators[_operator] = _active;\n    }\n\n    /**\n     * @notice Owner controlled function to activate/deactivate vault address\n     * @param _vault vault\n     * @param _active active or not\n     */\n    function setVault(address _vault, bool _active) public onlyOwner {\n        emit VaultChanged(_vault, _active);\n        vaults[_vault] = _active;\n    }\n\n    /**\n     * @notice Owner controlled function to increase TWAPSeconds / decrease maxTWAPTickDifference\n     */\n    function setTWAPConfig(uint16 _maxTWAPTickDifference, uint32 _TWAPSeconds) public onlyOwner {\n        if (_TWAPSeconds < MIN_TWAP_SECONDS) {\n            revert InvalidConfig();\n        }\n        if (_maxTWAPTickDifference > MAX_TWAP_TICK_DIFFERENCE) {\n            revert InvalidConfig();\n        }\n        emit TWAPConfigChanged(_TWAPSeconds, _maxTWAPTickDifference);\n        TWAPSeconds = _TWAPSeconds;\n        maxTWAPTickDifference = _maxTWAPTickDifference;\n    }\n\n    /**\n     * @notice Withdraws token balance (accumulated protocol fee)\n     * @param tokens Addresses of tokens to withdraw\n     * @param to Address to send to\n     */\n    function withdrawBalances(address[] calldata tokens, address to) external virtual {\n        if (msg.sender != withdrawer) {\n            revert Unauthorized();\n        }\n\n        uint256 i;\n        uint256 count = tokens.length;\n        for (; i < count; ++i) {\n            uint256 balance = IERC20(tokens[i]).balanceOf(address(this));\n            if (balance > 0) {\n                _transferToken(to, IERC20(tokens[i]), balance, true);\n            }\n        }\n    }\n\n    /**\n     * @notice Withdraws ETH balance\n     * @param to Address to send to\n     */\n    function withdrawETH(address to) external {\n        if (msg.sender != withdrawer) {\n            revert Unauthorized();\n        }\n\n        uint256 balance = address(this).balance;\n        if (balance > 0) {\n            (bool sent,) = to.call{value: balance}(\"\");\n            if (!sent) {\n                revert EtherSendFailed();\n            }\n        }\n    }\n\n    // validate if swap can be done with specified oracle parameters - if not possible reverts\n    // if possible returns minAmountOut\n    function _validateSwap(\n        bool swap0For1,\n        uint256 amountIn,\n        IUniswapV3Pool pool,\n        uint32 twapPeriod,\n        uint16 maxTickDifference,\n        uint64 maxPriceDifferenceX64\n    ) internal vie"
    }
  ]
}