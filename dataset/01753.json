{
  "Title": "H-1: Unitas swap function is vulnerable to Sandwich Attack at oracle price update",
  "Content": "# Issue H-1: Unitas swap function is vulnerable to Sandwich Attack at oracle price update \n\nSource: https://github.com/sherlock-audit/2023-04-unitasprotocol-judging/issues/67 \n\n## Found by \nDevABDee, Dug, n33k, qpzm, sashik\\_eth, shogoki, vagrant\n\n## Summary\n\nWHen the oracle price is updates, an attacker can sandwich the update adderss with 2 swap transactions to gain a profit and drain the collateral.\n\n## Vulnerability Detail\n\nInside the `swap` function of the `Unitas` contract the `getLatestPrice` function of the  `XOracle` contract is used to fetch the current price of the USDx token to be swapped to/from.\nThe price has to be updated periodically because the currencies fluctuate against the USD price.\nA user could use these fluctuations to speculate on prices and gain a profit or loss.\n\nHowever,as the price for the oracle is updated by a transaction that is publicly visible inside the mempool, a malicious user or attacker can see the new price before it is active. As the oracle price is the only thing, which has influence of the token number to mint/burn on a swap call, an attacker can easily exploit a temporarily appreciation of an USDx token agains the USD1 (US Dollar price). \nThis can be achieved by \"sandwiching\" the price update transaction with a transaction to swap USD1 into the relevant USDx token first, and swap it back after the price update.\n\nExample: \nTHe price of USD91 (INR) is to be increased from 0.012 to 0.013\nAttacker already holds 10,000 of USD1 tokens.\n\n- The Feeder sends the transaction to update the oracle price, and it gets placed in the mempool.\n- Attacker sees these transaction, and sends himself 2 transactions.\n1. Swap 10,000 possible mount of USD1 to USD91\n2. Swap all USD91 to USD1\n- The attacker sets the gas to ensure that the first tx gets included before the price update, and the second one after the price update. \n- The executed Transactions in order will be:\n1. Attacker swaps 10,000 USD1 to USD91 (should receive: 10,000 / 0.012 = 833,333.333)\n2. FEEDER updates oracle price of USD91 to 0.013\n3. Attacker swaps all USD91 tokens to USD1 (should receive: 833,333.333 * 0.013 = 10,833.333)\n\nThe attacker just made 833 USD1 profit in these 2 transactions, and can redeem the USD1 tokens for USDT, which will deduct the collateral by this amount. \n \n\n## Impact\n\nAttacker can gain profit and \"steal\" collateral\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-unitasprotocol/blob/main/Unitas-Protocol/src/Unitas.sol#L439\n\nhttps://github.com/sherlock-audit/2023-04-unitasprotocol/blob/main/Unitas-Protocol/src/XOracle.sol#L26-L32\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe 2 way minting/burning mechanism by the orcale price might be dangerous.\nHowever to prevent the specific attack vector, maybe the minting can be paused and unpaused before and after the price update. (in separate transactions) \n\n\n\n## Discussion\n\n**SunXrex**\n\nSun & Lucas: To update prices, we can consider using an RPC (Remote Procedure Call) that helps prevent MEV (Miner Extractable Value). \n\nRisk should be **medium**.\n\nUsually, updates to the exchange rate for stablecoins result in less than a 1~1.6% change. Additionally, we apply a fee for minting and burning. This makes arbitrage difficult. To provide a perspective from the auditors' case, an increase from 0.012 to 0.013 represents an approximate growth of 8.33% which is almost impossible.\n\nAditya: Price update frequency is much lower for Unitas compared to other defi swaps like Uniswaps. Unitas update frequency could be as low as once per day. Also the expected users/minters of the protocol are low frequency but high ticket size. Chances of users mint request being in the mempool and Unitas price update happening at the same time given are fairly low. Also, unlike Uniswap any new trade does not move the price. The price is only updated at certain periods of the day or once a day.\n\n**ctf-sec**\n\nCan be a valid medium\n\n**0xffff11**\n\nI agree with a medium. Due to the current architecture of having a fee and the stability of the assets, the value it is quite limited. \n\n**hrishibhat**\n\nConsidering this a medium issue based on the above comments.\n\n**Shogoki**\n\nEscalate for 10USDC \nThis should be considered as High:\n\nI was thinking for a longer time on the comments and the reasons for this one to be downgraded to Medium. \nI even created another escalation on #88 referencing this reasoning. However, after i saw this [comment](https://github.com/sherlock-audit/2023-04-unitasprotocol-judging/issues/88#issuecomment-1605278986) \n \n> Hi @Shogoki glad to know your thoughts.\n> \n> This issue is a valid medium, because price is based on currency exchange rates and it is not fair to say the price is stable or not (depends on the currency itself).\n> \n> When EMC appriciates / depreciates, the sponsor **HAVE TO** update price or the protocol will not work properly.\n> \ni tend to agree with that. Given that it should bot be a lowering factor, that the prices **should** be stable. Therefore this should be a high, as reported!\n\n———-\nIf this gets accepted, i believe #88 is a valid medium.\n\nHowever, If judges decide to reject this escalation here, i think #88 should be rated as low, as stated in my other escalation.\n\n\n\n**sherlock-admin**\n\n > Escalate for 10USDC \n> This should be considered as High:\n> \n> I was thinking for a longer time on the comments and the reasons for this one to be downgraded to Medium. \n> I even created another escalation on #88 referencing this reasoning. However, after i saw this [comment](https://github.com/sherlock-audit/2023-04-unitasprotocol-judging/issues/88#issuecomment-1605278986) \n>  \n> > Hi @Shogoki glad to know your thoughts.\n> > \n> > This issue is a valid medium, because price is based on currency exchange rates and it is not fair to say the price is stable or not (depends on the currency itself).\n> > \n> > When EMC appriciates / depreciates, the sponsor **HAVE TO** update price or the protocol will not work properly.\n> > \n> i tend to agree with that. Given that it should bot be a lowering factor, that the prices **should** be stable. Therefore this should be a high, as reported!\n> \n> ———-\n> If this gets accepted, i believe #88 is a valid medium.\n> \n> However, If judges decide to reject this escalation here, i think #88 should be rated as low, as stated in my other escalation.\n> \n> \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**DevABDee**\n\nEscalate for 10 USDC\n\nI agree with @Shogoki that this should be considered as a High.\n\nI believe It's a High issue even if prices are not gonna updated frequently because It's not only that the attacker can make a profit from that. Tokens holders can prevent loss as well. And not just prevent the loss, they can turn it into profits by exploiting this loophole (I have provided a more detailed explanation of this in my submission #105 )\nAs the protocol team said \"updates to the exchange rate for stablecoins result in less than a 1~1.6% change\", I agree but we must also take into account unusual scenarios, particularly when dealing with EMC Markets. Who knows the market? Maybe the prices get updated frequently!\n\nI completely agree with the points @Shogoki has raised, If this issue is not deemed High, then it would be reasonable to classify #88 as a low priority. \n\nThanks!\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> I agree with @Shogoki that this should be considered as a High.\n> \n> I believe It's a High issue even if prices are not gonna updated frequently because It's not only that the attacker can make a profit from that. Tokens holders can prevent loss as well. And not just prevent the loss, they can turn it into profits by exploiting this loophole (I have provided a more detailed explanation of this in my submission #105 )\n> As the protocol team said \"updates to the exchange rate for stablecoins result in less than a 1~1.6% change\", I agree but we must also take into account unusual scenarios, particularly when dealing with EMC Markets. Who knows the market? Maybe the prices get updated frequently!\n> \n> I completely agree with the points @Shogoki has raised, If this issue is not deemed High, then it would be reasonable to classify #88 as a low priority. \n> \n> Thanks!\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nAgree with high\n\n**jacksanford1**\n\nThe case for Medium is that the frequency of being able to steal a material amount of funds seems very rare:\n\n- will be used for stablecoins (which can have large price swings, but the frequency of large prices swings is normally low)\n- there will be a fee for minting/burning which eats into profitability\n\nThe case for High is that the sponsor is:\n\n- not assuming prices are relatively stable in #88\n- Sponsor comment in #88 that \"sponsor HAVE TO update price or the protocol will not work properly\" means that the protocol's hand could be forced in making a large price update even if there's a scenario where it will get sandwiched\n\nI am fine with High unless someone makes a stronger case for Medium. \n\n\n**SunXrex**\n\nNo code change in this fix. We will update the price over Flashbot (private transaction).\n\n**jacksanford1**\n\nUnderstood. In that case, we'll change the label for this issue to \"Won't Fix\". cc @SunXrex \n\n**hrishibhat**\n\nResult:\nHigh\nHas duplicates\n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [Shogoki](https://github.com/sherlock-audit/2023-04-unitasprotocol-judging/issues/67/#issuecomment-1605595300): accepted\n- [DevABDee](https://github.com/sherlock-audit/2023-04-unitasprotocol-judging/issues/67/#issuecomment-1605621561): accepted\n\n**jacksanford1**\n\nAcknowledged by protocol team (won't fix). \n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/73",
  "Code": [
    {
      "filename": "Unitas-Protocol/src/Unitas.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport \"./interfaces/IERC20Token.sol\";\nimport \"./interfaces/IInsurancePool.sol\";\nimport \"./interfaces/IOracle.sol\";\nimport \"./interfaces/IUnitas.sol\";\nimport \"./utils/AddressUtils.sol\";\nimport \"./utils/Errors.sol\";\nimport \"./utils/ScalingUtils.sol\";\nimport \"./SwapFunctions.sol\";\nimport \"./PoolBalances.sol\";\n\n/**\n * @title Unitas\n * @notice This contract is primarily used for exchanging tokens and managing reserve assets\n */\ncontract Unitas is\n    Initializable,\n    PausableUpgradeable,\n    AccessControlUpgradeable,\n    ReentrancyGuardUpgradeable,\n    IUnitas,\n    PoolBalances,\n    SwapFunctions\n{\n    using MathUpgradeable for uint256;\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\");\n    bytes32 public constant GUARDIAN_ROLE = keccak256(\"GUARDIAN_ROLE\");\n    bytes32 public constant TIMELOCK_ROLE = keccak256(\"TIMELOCK_ROLE\");\n    bytes32 public constant PORTFOLIO_ROLE = keccak256(\"PORTFOLIO_ROLE\");\n\n    IOracle public oracle;\n    address public surplusPool;\n    address public insurancePool;\n    ITokenManager public tokenManager;\n\n    /**\n     * @notice Emitted when `oracle` is updated\n     */\n    event SetOracle(address indexed newOracle);\n    /**\n     * @notice Emitted when `surplusPool` is updated\n     */\n    event SetSurplusPool(address indexed newSurplusPool);\n    /**\n     * @notice Emitted when `insurancePool` is updated\n     */\n    event SetInsurancePool(address indexed newInsurancePool);\n    /**\n     * @notice Emitted when `tokenManager` is updated\n     */\n    event SetTokenManager(ITokenManager indexed newTokenManager);\n    /**\n     * @notice Emitted when `sender` swap tokens\n     */\n    event Swapped(\n        address indexed tokenIn,\n        address indexed tokenOut,\n        address indexed sender,\n        uint256 amountIn,\n        uint256 amountOut,\n        address feeToken,\n        uint256 fee,\n        uint24 feeNumerator,\n        uint256 price\n    );\n    /**\n     * @notice Emitted when swapping `fee` is sent to `receiver`\n     */\n    event SwapFeeSent(address indexed feeToken, address indexed receiver, uint256 fee);\n\n    // ============================== ERRORS ==============================\n\n    error NotTimelock(address caller);\n    error NotGuardian(address caller);\n    error NotPortfolio(address caller);\n\n    // ============================== MODIFIERS ==============================\n\n    /**\n     * @notice Reverts if `msg.sender` does not have `TIMELOCK_ROLE`\n     */\n    modifier onlyTimelock() {\n        if (!hasRole(TIMELOCK_ROLE, msg.sender))\n            revert NotTimelock(msg.sender);\n        _;\n    }\n\n    /**\n     * @notice Reverts if `msg.sender` does not have `GUARDIAN_ROLE`\n     */\n    modifier onlyGuardian() {\n        if (!hasRole(GUARDIAN_ROLE, msg.sender))\n            revert NotGuardian(msg.sender);\n        _;\n    }\n\n    /**\n     * @notice Reverts if `account` does not have `PORTFOLIO_ROLE`\n     */\n    modifier onlyPortfolio(address account) {\n        if (!hasRole(PORTFOLIO_ROLE, account)) {\n            revert NotPortfolio(account);\n        }\n        _;\n    }\n\n\n    // ============================== CONSTRUCTOR ==============================\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializes the contract\n     * @param config_ `InitializeConfig` to init states\n     */\n    function initialize(InitializeConfig calldata config_) public initializer {\n        __Pausable_init();\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n        _setRoleAdmin(GOVERNOR_ROLE, GOVERNOR_ROLE);\n        _setRoleAdmin(GUARDIAN_ROLE, GUARDIAN_ROLE);\n        _setRoleAdmin(TIMELOCK_ROLE, GOVERNOR_ROLE);\n        _setRoleAdmin(PORTFOLIO_ROLE, GUARDIAN_ROLE);\n\n        _grantRole(GOVERNOR_ROLE, config_.governor);\n        _grantRole(GUARDIAN_ROLE, config_.guardian);\n        _grantRole(TIMELOCK_ROLE, config_.timelock);\n        _grantRole(PORTFOLIO_ROLE, config_.guardian);\n\n        _setOracle(config_.oracle);\n        _setSurplusPool(config_.surplusPool);\n        _setInsurancePool(config_.insurancePool);\n        _setTokenManager(config_.tokenManager);\n    }\n\n    // ============================== Timelock FUNCTIONS ===========================\n\n    /**\n     * @notice Updates the address of `oracle` by `newOracle`\n     */\n    function setOracle(address newOracle) external onlyTimelock {\n        _setOracle(newOracle);\n    }\n\n    /**\n     * @notice Updates the address of `surplusPool` by `newSurplusPool`\n     */\n    function setSurplusPool(address newSurplusPool) external onlyTimelock {\n        _setSurplusPool(newSurplusPool);\n    }\n\n    /**\n     * @notice Updates the address of `insurancePool` by `newInsurancePool`\n     */\n    function setInsurancePool(address newInsurancePool) external onlyTimelock {\n        _setInsurancePool(newInsurancePool);\n    }\n\n    /**\n     * @notice Updates the address of `tokenManager`\n     */\n    function setTokenManager(ITokenManager newTokenManager) external onlyTimelock {\n        _setTokenManager(newTokenManager);\n    }\n\n    // ============================== GUARDIAN FUNCTIONS ===========================\n\n    /**\n     * @notice Pause token swapping\n     */\n    function pause() public onlyGuardian {\n        _pause();\n    }\n\n    /**\n     * @notice Resume token swapping\n     */\n    function unpause() public onlyGuardian {\n        _unpause();\n    }\n\n    // ============================== EXTERNAL FUNCTIONS ===========================\n\n    /**\n     * @notice Swaps tokens\n     * @param tokenIn The address of the token to be spent\n     * @param tokenOut The address of the token to be obtained\n     * @param amountType The type of the amount\n     * @param amount When `amountType` is `In`, it's the number of `tokenIn` that the user wants to spend.\n     *               When `amountType` is `Out`, it's the number of `tokenOut` that the user wants to obtain.\n     * @return amountIn The amount of `tokenIn` spent\n     * @return amountOut The amount of `tokenOut` obtained\n     */\n    function swap(address tokenIn, address tokenOut, AmountType amountType, uint256 amount)\n        external\n        whenNotPaused\n        nonReentrant\n        returns (uint256 amountIn, uint256 amountOut)\n    {\n        IERC20Token feeToken;\n        uint256 fee;\n        uint24 feeNumerator;\n        uint256 price;\n        ITokenManager.PairConfig memory pair = tokenManager.getPair(tokenIn, tokenOut);\n\n        (amountIn, amountOut, feeToken, fee, feeNumerator, price) = _getSwapResult(pair, tokenIn, tokenOut, amountType, amount);\n\n        _require(IERC20(tokenIn).balanceOf(msg.sender) >= amountIn, Errors.BALANCE_INSUFFICIENT);\n\n        _swapIn(tokenIn, msg.sender, amountIn);\n\n        _swapOut(tokenOut, msg.sender, amountOut);\n\n        if (fee > 0) {\n            address feeReceiver = surplusPool;\n            feeToken.mint(feeReceiver, fee);\n            emit SwapFeeSent(address(feeToken), feeReceiver, fee);\n        }\n\n        _checkReserveRatio(tokenOut == pair.baseToken ? pair.buyReserveRatioThreshold : pair.sellReserveRatioThreshold);\n\n        emit Swapped(tokenIn, tokenOut, msg.sender, amountIn, amountOut, address(feeToken), fee, feeNumerator, price);\n    }\n\n    /**\n     * @notice Receives the portfolio from caller\n     * @param token Address of the token\n     * @param amount Amount of the portfolio\n     */\n    function receivePortfolio(address token, uint256 amount)\n        external\n        onlyPortfolio(msg.sender)\n        nonReentrant\n    {\n        _receivePortfolio(token, msg.sender, amount);\n    }\n\n    /**\n     * @notice Sends the portfolio to the receiver\n     * @param token Address of the token\n     * @param receiver Account to receive the portfolio\n     * @param amount Amount of the portfolio\n     */\n    function sendPortfolio(address token, address receiver, uint256 amount)\n        external\n        onlyTimelock\n        onlyPortfolio(receiver)\n        nonReentrant\n    {\n        _sendPortfolio(token, receiver, amount);\n    }\n\n    /**\n     * @notice Estimates swapping result for quoting\n     * @param tokenIn The address of the token to be spent\n     * @param tokenOut The address of the token to be obtained\n     * @param amountType The type of the amount\n     * @param amount When `amountType` is `In`, it's the number of `tokenIn` that the user wants to spend.\n     *               When `amountType` is `Out`, it's the number of `tokenOut` that the user wants to obtain.\n     * @return amountIn The amount of `tokenIn` to be spent\n     * @return amountOut The amount of `tokenOut` to be obtained\n     * @return feeToken The fee token\n     * @return fee Swapping fee calculated in `feeToken`\n     * @return feeNumerator The numerator of the fee fraction\n     * @return price The price of `tokenIn`/`tokenOut`\n     */\n    function estimateSwapResult(address tokenIn, address tokenOut, AmountType amountType, uint256 amount)\n        external\n        view\n        returns (uint256 amountIn, uint256 amountOut, IERC20Token feeToken, uint256 fee, uint24 feeNumerator, uint256 price)\n    {\n        ITokenManager.PairConfig memory pair = tokenManager.getPair(tokenIn, tokenOut);\n\n        (amountIn, amountOut, feeToken, fee, feeNumerator, price) = _getSwapResult(pair, tokenIn, tokenOut, amountType, amount);\n    }\n\n    // ============================== PUBLIC FUNCTIONS ==============================\n\n    /**\n     * @notice Gets the reserve of `token`\n     */\n    function getReserve(address token) public view returns (uint256) {\n        return _getBalance(token);\n    }\n\n    /**\n     * @notice Gets the portfolio of `token`\n     */\n    function getPortfolio(address token) public view returns (uint256) {\n        return _getPortfolio(token);\n    }\n\n    /**\n     * @notice Gets the reserve status\n     * @return reserveStatus `Undefined` when `reserves`, `collaterals` and `liabilities` are zero.\n                              `Infinite` when `liabilities` is zero.\n                              Otherwise `Finite`.\n     * @return reserves Total reserves denominated in USD1\n     * @return collaterals Total collaterals denominated in USD1\n     * @return liabilities Total liabilities denominated in USD1\n     * @return reserveRatio The numerator of the reserve ratio is expressed in 18 decimal places\n     */\n    function getReserveStatus()\n        public\n        view\n        returns (ReserveStatus reserveStatus, uint256 reserves, uint256 collaterals, uint256 liabilities, uint256 reserveRatio)\n    {\n        (reserves, collaterals) = _getTotalReservesAndCollaterals();\n        liabilities = _getTotalLiabilities();\n\n        (reserveStatus, reserveRatio) = _getReserveStatus(reserves + collaterals, liabilities);\n    }\n\n    // ============================== INTERNAL FUNCTIONS ==============================\n\n    function _setOracle(address newOracle) internal {\n        AddressUtils.checkContract(newOracle);\n        oracle = IOracle(newOracle);\n        emit SetOracle(newOracle);\n    }\n\n    function _setSurplusPool(address newSurplusPool) internal {\n        _require(newSurplusPool != address(0), Errors.ADDRESS_ZERO);\n        surplusPool = newSurplusPool;\n        emit SetSurplusPool(newSurplusPool);\n    }\n\n    function _setInsurancePool(address newInsurancePool) internal {\n        AddressUtils.checkContract(newInsurancePool);\n        insurancePool = newInsurancePool;\n        emit SetInsurancePool(newInsurancePool);\n    }\n\n    function _setTokenManager(ITokenManager newTokenManager) internal {\n        AddressUtils.checkContract(address(newTokenManager));\n        tokenManager = newTokenManager;\n        emit SetTokenManager(newTokenManager);\n    }\n\n    /**\n     * @notice Spends tokens for swapping\n     * @param token The address of the token\n     * @param spender The account to spend tokens\n     * @param amount The amount to be consumed\n     */\n    function _swapIn(address token, address spender, uint256 amount) internal {\n        ITokenManager.TokenType tokenType = tokenManager.getTokenType(token);\n\n        require(tokenType != ITokenManager.TokenType.Undefined);\n\n        if (tokenType == ITokenManager.TokenType.Asset) {\n            _setBalance(token, _getBalance(token) + amount);\n            IERC20(token).safeTransferFrom(spender, address(this), amount);\n        } else {\n            IERC20Token(token).burn(spender, amount);\n        }\n    }\n\n    /**\n     * @notice Receives tokens for swapping\n     * @param token The address of the token\n     * @param receiver The account to receive tokens\n     * @param amount The amount to be obtained\n     */\n    function _swapOut(address token, address receiver, uint256 amount) internal {\n        ITokenManager.TokenType tokenType = tokenManager.getTokenType(token);\n\n        require(tokenType != ITokenManager.TokenType.Undefined);\n\n        if (tokenType == ITokenManager.TokenType.Asset) {\n            uint256 tokenReserve = _getBalance(token);\n            uint256 reserveAmount = amount.min(tokenReserve - _getPortfolio(token));\n\n            if (amount > reserveAmount) {\n                uint256 collateralAmount = amount - reserveAmount;\n\n                // Pull the collateral from insurance pool\n                IInsurancePool(insurancePool).withdrawCollateral(token, collateralAmount);\n            }\n\n            _setBalance(token, tokenReserve - reserveAmount);\n            IERC20(token).safeTransfer(receiver, amount);\n        } else {\n            IERC20Token(token).mint(receiver, amount);\n        }\n    }\n\n    /**\n     * @notice Gets the swapping result\n     * @param pair The setting of the pair\n     * @param tokenIn The address of the token to be spent\n     * @param tokenOut The address of the token to be obtained\n     * @param amountType The type of the amount\n     * @param amount When `amountType` is `In`, it's the number of `tokenIn` that the user wants to spend.\n     *               When `amountType` is `Out`, it's the number of `tokenOut` that the user wants to obtain.\n     * @return amountIn The amount of `tokenIn` to be spent\n     * @return amountOut The amount of `tokenOut` to be obtained\n     * @return feeToken The fee token is always USD1\n     * @return fee Swapping fee calculated in USD1\n     * @return feeNumerator The numerator of the fee fraction\n     * @return price The price of `tokenIn`/`tokenOut`\n     */\n    function _getSwapResult(\n        ITokenManager.PairConfig memory pair,\n        address tokenIn,\n        address tokenOut,\n        AmountType amountType,\n        uint256 amount\n    )\n        internal\n        view\n        returns (uint256 amountIn, uint256 amountOut, IERC20Token feeToken, uint256 fee, uint24 feeNumerator, uint256 price)\n    {\n        _checkAmountPositive(amount);\n\n        // Checks the tokens of the pair config are valid\n        bool isBuy = tokenOut == pair.baseToken;\n        _require(\n            (isBuy && tokenIn == pair.quoteToken) ||\n                (tokenOut == pair.quoteToken && tokenIn == pair.baseToken),\n            Errors.PAIR_INVALID\n        );\n\n        address priceQuoteToken = _getPriceQuoteToken(tokenIn, tokenOut);\n        price = oracle.getLatestPrice(priceQuoteToken);\n        _checkPrice(priceQuoteToken, price);\n\n        feeNumerator = isBuy ? pair.buyFee : pair.sellFee;\n        feeToken = IERC20Token(priceQuoteToken == tokenIn ? tokenOut : tokenIn);\n\n        SwapRequest memory request;\n        request.tokenIn = tokenIn;\n        request.tokenOut = tokenOut;\n        request.amountType = amountType;\n        request.amount = amount;\n        request.feeNumerator = feeNumerator;\n        request.feeBase = tokenManager.SWAP_FEE_BASE();\n        request.feeToken = address(feeToken);\n        request.price = price;\n        request.priceBase = 10 ** oracle.decimals();\n        request.quoteToken = priceQuoteToken;\n\n        (amountIn, amountOut, fee) = _calculateSwapResult(request);\n\n        _require(amountIn > 0 && amountOut > 0, Errors.SWAP_RESULT_INVALID);\n\n        if (tokenIn == priceQuoteToken) {\n            // The base currency of oracle price is USD1, inverts the price when buying USD1\n            price = request.priceBase * request.priceBase / price;\n        }\n    }\n\n    /**\n     * @notice Gets the reserve status and reserve ratio.\n     * @param allReserves Sum of the reserves and the collaterals denominated in USD1\n     * @param liabilities Total liabilities denominated in USD1\n     * @return reserveStatus `Undefined` when `allReserves` and `liabilities` are zero.\n                              `Infinite` when `liabilities` is zero.\n                              Otherwise `Finite`.\n     * @return reserveRatio The numerator of the reserve ratio is expressed in 18 decimal places\n     */\n    function _getReserveStatus(uint256 allReserves, uint256 liabilities)\n        internal\n        view\n        returns (ReserveStatus reserveStatus, uint256 reserveRatio)\n    {\n        if (liabilities == 0) {\n            reserveStatus = allReserves == 0 ? ReserveStatus.Undefined : ReserveStatus.Infinite;\n        } else {\n            reserveStatus = ReserveStatus.Finite;\n\n            // All decimals of parameters are the same as USD1\n            uint256 valueBase = 10 ** tokenManager.usd1().decimals();\n\n            reserveRatio = ScalingUtils.scaleByBases(\n                allReserves * valueBase / liabilities,\n                valueBase,\n                tokenManager.RESERVE_RATIO_BASE()\n            );\n        }\n    }\n\n    /**\n     * @notice Gets total reserves and total collaterals in USD1\n     */\n    function _getTotalReservesAndCollaterals() internal view returns (uint256 reserves, uint256 collaterals) {\n        address baseToken = address(tokenManager.usd1());\n        uint8 tokenTypeValue = uint8(ITokenManager.TokenType.Asset);\n        uint256 tokenCount = tokenManager.tokenLength(tokenTypeValue);\n        uint256 priceBase = 10 ** oracle.decimals();\n\n        for (uint256 i; i < tokenCount; i++) {\n            address token = tokenManager.tokenByIndex(tokenTypeValue, i);\n            uint256 tokenReserve = _getBalance(token);\n            uint256 tokenCollateral = IInsurancePool(insurancePool).getCollateral(token);\n\n            if (tokenReserve > 0 || tokenCollateral > 0) {\n                uint256 price = oracle.getLatestPrice(token);\n\n                reserves += _convert(\n                    token,\n                    baseToken,\n                    tokenReserve,\n                    MathUpgradeable.Rounding.Down,\n                    price,\n                    priceBase,\n                    token\n                );\n\n                collaterals += _convert(\n                    token,\n                    baseToken,\n                    tokenCollateral,\n                    MathUpgradeable.Rounding.Down,\n                    price,\n                    priceBase,\n                    token\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Gets total liabilities in USD1\n     */\n    function _getTotalLiabilities() internal view returns (uint256 liabilities) {\n        address baseToken = address(tokenManager.usd1());\n        uint8 tokenTypeValue = uint8(ITokenManager.TokenType.Stable);\n        uint256 tokenCount = tokenManager.tokenLength(tokenTypeValue);\n        uint256 priceBase = 10 ** oracle.decimals();\n\n        for (uint256 i; i < tokenCount; i++) {\n            address token = tokenManager.tokenByIndex(tokenTypeValue, i);\n            uint256 tokenSupply = IERC20Token(token).totalSupply();\n\n            if (token == baseToken) {\n                // Adds up directly when the token is USD1\n                liabilities += tokenSupply;\n            } else if (tokenSupply > 0) {\n                uint256 price = oracle.getLatestPrice(token);\n\n                liabilities += _convert(\n                    token,\n                    baseToken,\n                    tokenSupply,\n                    MathUpgradeable.Rounding.Down,\n                    price,\n                    priceBase,\n                    token\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Gets the quote token of oracle price by two token addresses.\n     *          Because of the base currencies of all oracle prices are always USD1 (e.g., USD1/USDT and USD1/USD91),\n     *          one of `tokenX` or `tokenY` must be USD1, and the other must not be USD1.\n     * @dev The caller must ensure that both tokens are in the pool\n     * @param tokenX Address of base currency or quote currency\n     * @param tokenY Address of base currency or quote currency\n     * @return quoteToken The quote currency of oracle price\n     */\n    function _getPriceQuoteToken(address tokenX, address tokenY) internal view returns (address quoteToken) {\n        _require(tokenX != tokenY, Errors.PAIR_INVALID);\n\n        address baseToken = address(tokenManager.usd1());\n        _require(baseToken != address(0), Errors.USD1_NOT_SET);\n\n        bool isXBase = tokenX == baseToken;\n        _require(isXBase || tokenY == baseToken, Errors.PAIR_INVALID);\n\n        quoteToken = isXBase ? tokenY : tokenX;\n    }\n\n    /**\n     * @notice Reverts if the price or the tolerance range is invalid\n     * @param quoteToken Address of quote token to get the tolerance range\n     * @param price The price of USD1/`quoteToken`\n     */\n    function _checkPrice(address quoteToken, uint256 price) internal view {\n        (uint256 minPrice, uint256 maxPrice) = tokenManager.getPriceTolerance(quoteToken);\n\n        _require(minPrice > 0 && maxPrice > 0, Errors.PRICE_TOLERANCE_INVALID);\n        _require(minPrice <= price && price <= maxPrice, Errors.PRICE_INVALID);\n    }\n\n    /**\n     * @notice Checks the reserve ratio is sufficient when `reserveRatioThreshold` is greater than zero\n     */\n    function _checkReserveRatio(uint232 reserveRatioThreshold) internal view {\n        if (reserveRatioThreshold == 0) {\n            return;\n        } else {\n            (uint256 reserves, uint256 collaterals) = _getTotalReservesAndCollaterals();\n            uint256 allReserves = reserves + collaterals;\n            uint256 liabilities = _getTotalLiabilities();\n\n            (ReserveStatus reserveStatus, uint256 reserveRatio) = _getReserveStatus(allReserves, liabilities);\n\n            if (reserveStatus != ReserveStatus.Infinite) {\n                _require(reserveRatio > reserveRatioThreshold, Errors.RESERVE_RATIO_NOT_GREATER_THAN_THRESHOLD);\n            }\n        }\n    }\n}"
    },
    {
      "filename": "Unitas-Protocol/src/XOracle.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./interfaces/IOracle.sol\";\n\ncontract XOracle is AccessControl {\n    bytes32 public constant FEEDER_ROLE = keccak256(\"FEEDER_ROLE\");\n    bytes32 public constant GUARDIAN_ROLE = keccak256(\"GUARDIAN_ROLE\");\n    mapping (address => IOracle.Price) public prices;\n\n    event newPrice(address indexed _asset, uint64 _timestamp, uint256 _price);\n\n    constructor() {\n        // Grant the contract deployer the default admin role: it will be able\n        // to grant and revoke any roles\n        _setRoleAdmin(GUARDIAN_ROLE, GUARDIAN_ROLE);\n        _setRoleAdmin(FEEDER_ROLE, GUARDIAN_ROLE);\n        \n        _grantRole(GUARDIAN_ROLE, msg.sender);\n        _grantRole(FEEDER_ROLE, msg.sender);\n    }\n\n    // ========================= FEEDER FUNCTIONS ====================================\n\n    function putPrice(address asset, uint64 timestamp, uint256 price) public onlyRole(FEEDER_ROLE) {\n        uint64 prev_timestamp = prices[asset].timestamp;\n        uint256 prev_price = prices[asset].price;\n        require(prev_timestamp < timestamp, \"Outdated timestamp\");\n        prices[asset] = IOracle.Price(asset, timestamp, prev_timestamp, price, prev_price);\n        emit newPrice(asset, timestamp, price);\n    }\n\n    function updatePrices(IOracle.NewPrice[] calldata _array) external onlyRole(FEEDER_ROLE) {\n        uint256 arrLength = _array.length;\n        for(uint256 i=0; i<arrLength; ){\n            address asset = _array[i].asset;\n            uint64 timestamp = _array[i].timestamp;\n            uint256 price = _array[i].price;\n            putPrice(asset, timestamp, price);\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    // ========================= VIEW FUNCTIONS ====================================\n\n    function getPrice(address asset) public view returns (uint64, uint64, uint256, uint256) {\n        return (\n            prices[asset].timestamp,\n            prices[asset].prev_timestamp,\n            prices[asset].price,\n            prices[asset].prev_price\n        );\n    }\n\n    function getLatestPrice(address asset) public view returns (uint256) {\n        return prices[asset].price;\n    }\n\n    // ========================= PURE FUNCTIONS ====================================\n\n    function decimals() public pure returns (uint8) {\n        return 18;\n    }\n}"
    }
  ]
}