{
  "Title": "[M-01] `MinterContract::payArtist` can result in double the intended payout",
  "Content": "\nThe royalty allocation within the protocol works like this:\n\nFirst, an admin sets the split between team and artist. Here it is validated that the artist and team allocations together fill up 100%:\n\n[`MinterContract::setPrimaryAndSecondarySplits`](https://github.com/code-423n4/2023-10-nextgen/blob/main/smart-contracts/MinterContract.sol#L369-L376):\n\n```solidity\nFile: smart-contracts/MinterContract.sol\n\n369:    function setPrimaryAndSecondarySplits(uint256 _collectionID, uint256 _artistPrSplit, uint256 _teamPrSplit, uint256 _artistSecSplit, uint256 _teamSecSplit) public FunctionAdminRequired(this.setPrimaryAndSecondarySplits.selector) {\n370:        require(_artistPrSplit + _teamPrSplit == 100, \"splits need to be 100%\");\n371:        require(_artistSecSplit + _teamSecSplit == 100, \"splits need to be 100%\");\n372:        collectionRoyaltiesPrimarySplits[_collectionID].artistPercentage = _artistPrSplit;\n373:        collectionRoyaltiesPrimarySplits[_collectionID].teamPercentage = _teamPrSplit;\n374:        collectionRoyaltiesSecondarySplits[_collectionID].artistPercentage = _artistSecSplit;\n375:        collectionRoyaltiesSecondarySplits[_collectionID].teamPercentage = _teamSecSplit;\n376:    }\n```\n\nThe artist can then propose a split between artist addresses, where it is validated that the different artist addresses together add up to the total artist allocation:\n\n[`MinterContract::proposePrimaryAddressesAndPercentages`](https://github.com/code-423n4/2023-10-nextgen/blob/main/smart-contracts/MinterContract.sol#L380-L382):\n\n```solidity\nFile: smart-contracts/MinterContract.sol\n\n380:    function proposePrimaryAddressesAndPercentages(uint256 _collectionID, address _primaryAdd1, address _primaryAdd2, address _primaryAdd3, uint256 _add1Percentage, uint256 _add2Percentage, uint256 _add3Percentage) public ArtistOrAdminRequired(_collectionID, this.proposePrimaryAddressesAndPercentages.selector) {\n381:        require (collectionArtistPrimaryAddresses[_collectionID].status == false, \"Already approved\");\n382:        require (_add1Percentage + _add2Percentage + _add3Percentage == collectionRoyaltiesPrimarySplits[_collectionID].artistPercentage, \"Check %\");\n```\n\nThen, also when paid out, there is a validation that the split between team and artist allocation adds up:\n\n[`MinterContract::payArtist`](https://github.com/code-423n4/2023-10-nextgen/blob/main/smart-contracts/MinterContract.sol#L415-L418):\n\n```solidity\nFile: smart-contracts/MinterContract.sol\n\n415:    function payArtist(uint256 _collectionID, address _team1, address _team2, uint256 _teamperc1, uint256 _teamperc2) public FunctionAdminRequired(this.payArtist.selector) {\n416:        require(collectionArtistPrimaryAddresses[_collectionID].status == true, \"Accept Royalties\");\n417:        require(collectionTotalAmount[_collectionID] > 0, \"Collection Balance must be greater than 0\");\n418:        require(collectionRoyaltiesPrimarySplits[_collectionID].artistPercentage + _teamperc1 + _teamperc2 == 100, \"Change percentages\");\n```\n\nThe issue is that here, it compares to the artist allocation from artist/team allocations. When the actual amount paid out is calculated, it uses the proposed (and accepted) artist address percentages:\n\n[`MinterContract::payArtist`](https://github.com/code-423n4/2023-10-nextgen/blob/main/smart-contracts/MinterContract.sol#L429-L431):\n\n```solidity\nFile: smart-contracts/MinterContract.sol\n\n429:        artistRoyalties1 = royalties * collectionArtistPrimaryAddresses[colId].add1Percentage / 100;\n430:        artistRoyalties2 = royalties * collectionArtistPrimaryAddresses[colId].add2Percentage / 100;\n431:        artistRoyalties3 = royalties * collectionArtistPrimaryAddresses[colId].add3Percentage / 100;\n```\n\nHence, there is a possibility that up to double the intended amount can be paid out, imagine this scenario:\n\n1. An admin sets artist/team allocation to 100% artist, 0% team.\n2. Artist proposes a split between addresses (for the total 100%), which is accepted.\n3. Admin then changes the allocation to 0% artist, 100% team.\n\nThey then call `payArtist` with the 100% team allocation. This will pass the check as `artistPercentage` will be `0`. However, the artist payouts will use the already proposed artist address allocations. Hence, double the amount will be paid out.\n\n### Impact\n\nAn admin can maliciously, or by mistake, manipulate the percentage allocation for a collections royalty to pay out up to double the amount of royalty. This could make it impossible to payout royalty later, as this steals royalty from other collections.\n\n### Proof of Concept\n\nPoC using foundry. Save file in `hardhat/test/MinterContractTest.t.sol`, also needs `forge-std` in `hardhat/lib`:\n\n```solidity\n// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {Test} from \"../lib/forge-std/src/Test.sol\";\nimport {NextGenMinterContract} from \"../smart-contracts/MinterContract.sol\";\nimport {NextGenAdmins} from \"../smart-contracts/NextGenAdmins.sol\";\nimport {INextGenCore} from \"../smart-contracts/INextGenCore.sol\";\n\ncontract MinterContractTest is Test {\n  \n  uint256 constant colId = 1;\n  \n  address team = makeAddr('team');\n  address artist = makeAddr('artist');\n\n  address core  = makeAddr('core');\n  address delegate = makeAddr('delegate');\n\n  NextGenAdmins admin = new NextGenAdmins();\n  NextGenMinterContract minter;\n\n  function setUp() public {\n    minter = new NextGenMinterContract(core, delegate, address(admin));\n\n    vm.mockCall(core, abi.encodeWithSelector(INextGenCore.retrievewereDataAdded.selector), abi.encode(true));\n    vm.mockCall(core, abi.encodeWithSelector(INextGenCore.viewMaxAllowance.selector), abi.encode(1));\n    vm.mockCall(core, abi.encodeWithSelector(INextGenCore.retrieveTokensMintedPublicPerAddress.selector), abi.encode(0));\n    vm.mockCall(core, abi.encodeWithSelector(INextGenCore.viewTokensIndexMin.selector), abi.encode(1));\n    vm.mockCall(core, abi.encodeWithSelector(INextGenCore.viewCirSupply.selector), abi.encode(0));\n    vm.mockCall(core, abi.encodeWithSelector(INextGenCore.viewTokensIndexMax.selector), abi.encode(1_000));\n    vm.mockCall(core, abi.encodeWithSelector(INextGenCore.retrieveArtistAddress.selector), abi.encode(artist));\n    vm.mockCall(core, abi.encodeWithSelector(INextGenCore.mint.selector), new bytes(0));\n\n    minter.setCollectionCosts(colId, 1 ether, 1 ether, 0, 100, 0, address(0));\n    minter.setCollectionPhases(colId, 0, 0, 1, 101, bytes32(0));\n\n    vm.warp(1); // jump one sec to enter public phase\n  }\n\n  function testFaultySplitResultsInDoubleRoyalty() public {\n    // needs to hold one extra eth for payout\n    vm.deal(address(minter),1 ether);\n\n    // mint to increase collectionTotalAmount\n    minter.mint{value: 1 ether}(colId, 1, 1, '', address(this), new bytes32[](0), address(0), 0);\n    assertEq(2 ether, address(minter).balance);\n\n    // begin with setting artist split to 100%, team 0%\n    minter.setPrimaryAndSecondarySplits(colId,\n      100, 0, // primary\n      100, 0  // secondary (not used)\n    );\n\n    // set the actual artist split\n    minter.proposePrimaryAddressesAndPercentages(colId,\n      artist, address(0), address(0),\n      100, 0, 0\n    );\n    minter.acceptAddressesAndPercentages(colId, true, true);\n\n    // set 100% to team, 0% to artist without changing artist address allocation\n    minter.setPrimaryAndSecondarySplits(colId,\n      0, 100, // primary\n      0, 100  // secondary (not used)\n    );\n\n    // when artist is paid, 2x the amount is paid out\n    minter.payArtist(colId, team, address(0), 100, 0);\n\n    // team gets 1 eth\n    assertEq(1 ether, team.balance);\n    // artist gets 1 eth\n    assertEq(1 ether, artist.balance);\n  }\n}\n```\n\n### Recommended Mitigation Steps\n\nConsider verifying that the artist allocations add up to the artist percentage when calling `payArtist`.\n\n### Assessed type\n\nInvalid Validation\n\n**[a2rocket (NextGen) disputed and commented via duplicate issue #1550](https://github.com/code-423n4/2023-10-nextgen-findings/issues/1550#issuecomment-1825358289)**:\n> The `payArtist` function allows to payments to artists between phases. Once a payment is made, the `collectionAmount` goes to `0` and then increases while the second minting starts, etc.\n\n**[0xsomeone (judge) commented](https://github.com/code-423n4/2023-10-nextgen-findings/issues/1686#issuecomment-1839570965):**\n > The Warden specifies that an overpayment of artist funds can be performed, resulting in fund loss for the system if the artist's percentage is ever reduced after having been configured.\n> \n> The submission is correct and the core flaw lies in that the `MinterContract::payArtist` function will utilize the **proposed percentages** instead of the accepted ones when performing the transfers, **incorrectly assuming that they equal the `collectionRoyaltiesPrimarySplits[_collectionID].artistPercentage` originally enforced when they were set**.\n> \n> The Warden's submission was selected as the best because it details the attack vector precisely, it includes an informative PoC, and provides an easy-to-follow textual description of the issue.\n> \n> I consider this to be a valid medium-severity issue as the fund loss can tap into the funds of other users and potentially the teams themselves given that the royalties for artists are distributed before the royalties for teams.\n\n**[MrPotatoMagic (warden) commented](https://github.com/code-423n4/2023-10-nextgen-findings/issues/1686#issuecomment-1848617783):**\n > @0xsomeone, here is why I believe this issue in not valid:\n> \n> 1. The issue assumes there will be a deviation from the original process of how royalties are set. That is, `setPrimaryAndSecondarySplits() => proposePrimaryAddressesAndPercentages() => acceptAddressesAndPercentages`.\n> 2. The warden mentions that the admin would be malicious or could input by mistake. Such instances are considered reckless admin mistakes as per the [C4 SC verdict in the docs](https://docs.code4rena.com/awarding/judging-criteria/supreme-court-decisions-fall-2023#verdict-severity-standardization-centralization-risks).\n> 3. There is no incorrect assumption being made by the NextGen team here since the process mentioned in point 1 is to be followed every time royalties are changed. [See Discord comment by sponsor](https://discord.com/channels/810916927919620096/1166760088963383336/1169637770155786271).\n\n**[0xsomeone (judge) commented](https://github.com/code-423n4/2023-10-nextgen-findings/issues/1686#issuecomment-1848651047):**\n > @MrPotatoMagic, thanks for contributing to this particular submission's Post-Judging QA process! Let me get back to each of your points:\n> \n> 1. The issue assumes that the artist is willing to break the flow which is a valid assessment.\n> 2. The Warden's submission does not rely on an egregious error or reckless mistake. It also does not rely on their input being incorrect maliciously as any update to the function will cause the bug to manifest at varying degrees. Invoking `setPrimaryAndSecondarySplits`, as its name implies, should overwrite the split percentages but it does not. This is a reasonable expectation of the function. \n> 3. The submission entails incorrect accounting in the `MinterContract`, rather than an administrative error. Additionally, its impact is significant, as it can touch into the funds of other collections as all funds are stored under a single contract.\n> \n> Combining the facts that this is a **critical vulnerability** with an **acceptable chance of happening**, I consider a medium-risk rating appropriate for it.\n> \n> Keep in mind that the `payArtist` function, while an administrative function, can be assigned to function-level administrators. Contrary to functions like `emergencyWithdraw` which clearly denote their purpose, the NextGen team will never reasonably expect that `payArtist` **can result in the contract's funds being siphoned**.\n> \n> As such, the accounting flaw must be corrected and constitutes a medium-risk vulnerability that should be rectified. \n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-nextgen",
  "Code": [
    {
      "filename": "smart-contracts/MinterContract.sol",
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n *\n *  @title: NextGen Minter Contract\n *  @date: 18-October-2023 \n *  @version: 1.8\n *  @author: 6529 team\n */\n\npragma solidity ^0.8.19;\n\nimport \"./INextGenCore.sol\";\nimport \"./Ownable.sol\";\nimport \"./IDelegationManagementContract.sol\";\nimport \"./MerkleProof.sol\";\nimport \"./INextGenAdmins.sol\";\nimport \"./IERC721.sol\";\n\ncontract NextGenMinterContract is Ownable {\n\n    // total amount collected during minting from collections\n    mapping (uint256 => uint256) public collectionTotalAmount;\n\n    // sales Option3 timestamp of last mint\n    mapping (uint256 => uint) public lastMintDate;\n\n    // burn or swap address for external collections\n    mapping (bytes32 => address) public burnOrSwapAddress;\n\n    // burn or swap external collection ids\n    mapping (bytes32 => uint256[2]) private burnOrSwapIds;\n\n    // mint tokens on a specific collection after burning a token on a NextGen collection\n    mapping (uint256 => mapping (uint256 => bool)) public burnToMintCollections;\n\n    // mint tokens on a specific collection after burning a token on an external collection\n    mapping (bytes32 => mapping (uint256 => bool)) public burnExternalToMintCollections;\n\n    // check if minting costs were set\n    mapping (uint256 => bool) private setMintingCosts;\n\n    // collectionPhasesData struct declaration\n    struct collectionPhasesDataStructure {\n        uint allowlistStartTime;\n        uint allowlistEndTime;\n        uint publicStartTime;\n        uint publicEndTime;\n        bytes32 merkleRoot;\n        uint256 collectionMintCost;\n        uint256 collectionEndMintCost;\n        uint256 timePeriod;\n        uint256 rate;\n        uint8 salesOption;\n        address delAddress;\n    }\n\n    // mapping of collectionPhasesData struct\n    mapping (uint256 => collectionPhasesDataStructure) private collectionPhases;\n\n    // royalties primary splits structure\n\n    struct royaltiesPrimarySplits {\n        uint256 artistPercentage;\n        uint256 teamPercentage;\n    }\n\n    // mapping of royaltiesPrimarySplits struct\n\n    mapping (uint256 => royaltiesPrimarySplits) private collectionRoyaltiesPrimarySplits;\n\n    // artists primary Addresses\n    struct collectionPrimaryAddresses {\n        address primaryAdd1;\n        address primaryAdd2;\n        address primaryAdd3;\n        uint256 add1Percentage;\n        uint256 add2Percentage;\n        uint256 add3Percentage;\n        bool status;\n    }\n\n    // mapping of collectionPrimaryAndSecondaryAddresses struct\n    mapping (uint256 => collectionPrimaryAddresses) private collectionArtistPrimaryAddresses;\n\n    // royalties secondary splits structure\n\n    struct royaltiesSecondarySplits {\n        uint256 artistPercentage;\n        uint256 teamPercentage;\n    }\n\n    // mapping of royaltiesSecondarySplits struct\n\n    mapping (uint256 => royaltiesSecondarySplits) private collectionRoyaltiesSecondarySplits;\n\n    // artists secondary Addresses\n    struct collectionSecondaryAddresses {\n        address secondaryAdd1;\n        address secondaryAdd2;\n        address secondaryAdd3;\n        uint256 add1Percentage;\n        uint256 add2Percentage;\n        uint256 add3Percentage;\n        bool status;\n    }\n\n    // mapping of collectionSecondaryAddresses struct\n    mapping (uint256 => collectionSecondaryAddresses) private collectionArtistSecondaryAddresses;\n\n    // mapping of token id and auction end time\n    mapping (uint256 => uint) private mintToAuctionData;\n\n    // mapping of token id and status\n    mapping (uint256 => bool) private mintToAuctionStatus;\n\n    //external contracts declaration\n    INextGenCore public gencore;\n    IDelegationManagementContract private dmc;\n    INextGenAdmins private adminsContract;\n\n    // events\n\n    event PayArtist(address indexed _add, bool status, uint256 indexed funds);\n    event PayTeam(address indexed _add, bool status, uint256 indexed funds);\n    event Withdraw(address indexed _add, bool status, uint256 indexed funds);\n\n    // constructor\n    constructor (address _gencore, address _del, address _adminsContract) {\n        gencore = INextGenCore(_gencore);\n        dmc = IDelegationManagementContract(_del);\n        adminsContract = INextGenAdmins(_adminsContract);\n    }\n\n    // certain functions can only be called by an admin or the artist\n    modifier ArtistOrAdminRequired(uint256 _collectionID, bytes4 _selector) {\n      require(msg.sender == gencore.retrieveArtistAddress(_collectionID) || adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true, \"Not allowed\");\n      _;\n    }\n\n    // certain functions can only be called by a global or function admin\n\n    modifier FunctionAdminRequired(bytes4 _selector) {\n      require(adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true , \"Not allowed\");\n      _;\n    }\n\n    // certain functions can only be called by a collection, global or function admin\n\n    modifier CollectionAdminRequired(uint256 _collectionID, bytes4 _selector) {\n      require(adminsContract.retrieveCollectionAdmin(msg.sender,_collectionID) == true || adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true, \"Not allowed\");\n      _;\n    }\n\n    // function to add a collection's minting costs\n\n    function setCollectionCosts(uint256 _collectionID, uint256 _collectionMintCost, uint256 _collectionEndMintCost, uint256 _rate, uint256 _timePeriod, uint8 _salesOption, address _delAddress) public CollectionAdminRequired(_collectionID, this.setCollectionCosts.selector) {\n        require(gencore.retrievewereDataAdded(_collectionID) == true, \"Add data\");\n        collectionPhases[_collectionID].collectionMintCost = _collectionMintCost;\n        collectionPhases[_collectionID].collectionEndMintCost = _collectionEndMintCost;\n        collectionPhases[_collectionID].rate = _rate;\n        collectionPhases[_collectionID].timePeriod = _timePeriod;\n        collectionPhases[_collectionID].salesOption = _salesOption;\n        collectionPhases[_collectionID].delAddress = _delAddress;\n        setMintingCosts[_collectionID] = true;\n    }\n\n    // function to add a collection's start/end times and merkleroot\n\n    function setCollectionPhases(uint256 _collectionID, uint _allowlistStartTime, uint _allowlistEndTime, uint _publicStartTime, uint _publicEndTime, bytes32 _merkleRoot) public CollectionAdminRequired(_collectionID, this.setCollectionPhases.selector) {\n        require(setMintingCosts[_collectionID] == true, \"Set Minting Costs\");\n        collectionPhases[_collectionID].allowlistStartTime = _allowlistStartTime;\n        collectionPhases[_collectionID].allowlistEndTime = _allowlistEndTime;\n        collectionPhases[_collectionID].merkleRoot = _merkleRoot;\n        collectionPhases[_collectionID].publicStartTime = _publicStartTime;\n        collectionPhases[_collectionID].publicEndTime = _publicEndTime;\n    }\n\n    // airdrop function\n    \n    function airDropTokens(address[] memory _recipients, string[] memory _tokenData, uint256[] memory _saltfun_o, uint256 _collectionID, uint256[] memory _numberOfTokens) public FunctionAdminRequired(this.airDropTokens.selector) {\n        require(gencore.retrievewereDataAdded(_collectionID) == true, \"Add data\");\n        uint256 collectionTokenMintIndex;\n        for (uint256 y=0; y< _recipients.length; y++) {\n            collectionTokenMintIndex = gencore.viewTokensIndexMin(_collectionID) + gencore.viewCirSupply(_collectionID) + _numberOfTokens[y] - 1;\n            require(collectionTokenMintIndex <= gencore.viewTokensIndexMax(_collectionID), \"No supply\");\n            for(uint256 i = 0; i < _numberOfTokens[y]; i++) {\n                uint256 mintIndex = gencore.viewTokensIndexMin(_collectionID) + gencore.viewCirSupply(_collectionID);\n                gencore.airDropTokens(mintIndex, _recipients[y], _tokenData[y], _saltfun_o[y], _collectionID);\n            }\n        }\n    }\n\n    // mint function\n\n    function mint(uint256 _collectionID, uint256 _numberOfTokens, uint256 _maxAllowance, string memory _tokenData, address _mintTo, bytes32[] calldata merkleProof, address _delegator, uint256 _saltfun_o) public payable {\n        require(setMintingCosts[_collectionID] == true, \"Set Minting Costs\");\n        uint256 col = _collectionID;\n        address mintingAddress;\n        uint256 phase;\n        string memory tokData = _tokenData;\n        if (block.timestamp >= collectionPhases[col].allowlistStartTime && block.timestamp <= collectionPhases[col].allowlistEndTime) {\n            phase = 1;\n            bytes32 node;\n            if (_delegator != 0x0000000000000000000000000000000000000000) {\n                bool isAllowedToMint;\n                isAllowedToMint = dmc.retrieveGlobalStatusOfDelegation(_delegator, 0x8888888888888888888888888888888888888888, msg.sender, 1) || dmc.retrieveGlobalStatusOfDelegation(_delegator, 0x8888888888888888888888888888888888888888, msg.sender, 2);\n                if (isAllowedToMint == false) {\n                isAllowedToMint = dmc.retrieveGlobalStatusOfDelegation(_delegator, collectionPhases[col].delAddress, msg.sender, 1) || dmc.retrieveGlobalStatusOfDelegation(_delegator, collectionPhases[col].delAddress, msg.sender, 2);    \n                }\n                require(isAllowedToMint == true, \"No delegation\");\n                node = keccak256(abi.encodePacked(_delegator, _maxAllowance, tokData));\n                require(_maxAllowance >= gencore.retrieveTokensMintedALPerAddress(col, _delegator) + _numberOfTokens, \"AL limit\");\n                mintingAddress = _delegator;\n            } else {\n                node = keccak256(abi.encodePacked(msg.sender, _maxAllowance, tokData));\n                require(_maxAllowance >= gencore.retrieveTokensMintedALPerAddress(col, msg.sender) + _numberOfTokens, \"AL limit\");\n                mintingAddress = msg.sender;\n            }\n            require(MerkleProof.verifyCalldata(merkleProof, collectionPhases[col].merkleRoot, node), 'invalid proof');\n        } else if (block.timestamp >= collectionPhases[col].publicStartTime && block.timestamp <= collectionPhases[col].publicEndTime) {\n            phase = 2;\n            require(_numberOfTokens <= gencore.viewMaxAllowance(col), \"Change no of tokens\");\n            require(gencore.retrieveTokensMintedPublicPerAddress(col, msg.sender) + _numberOfTokens <= gencore.viewMaxAllowance(col), \"Max\");\n            mintingAddress = msg.sender;\n            tokData = '\"public\"';\n        } else {\n            revert(\"No minting\");\n        }\n        uint256 collectionTokenMintIndex;\n        collectionTokenMintIndex = gencore.viewTokensIndexMin(col) + gencore.viewCirSupply(col) + _numberOfTokens - 1;\n        require(collectionTokenMintIndex <= gencore.viewTokensIndexMax(col), \"No supply\");\n        require(msg.value >= (getPrice(col) * _numberOfTokens), \"Wrong ETH\");\n        for(uint256 i = 0; i < _numberOfTokens; i++) {\n            uint256 mintIndex = gencore.viewTokensIndexMin(col) + gencore.viewCirSupply(col);\n            gencore.mint(mintIndex, mintingAddress, _mintTo, tokData, _saltfun_o, col, phase);\n        }\n        collectionTotalAmount[col] = collectionTotalAmount[col] + msg.value;\n        // control mechanism for sale option 3\n        if (collectionPhases[col].salesOption == 3) {\n            uint timeOfLastMint;\n            if (lastMintDate[col] == 0) {\n                // for public sale set the allowlist the same time as publicsale\n                timeOfLastMint = collectionPhases[col].allowlistStartTime - collectionPhases[col].timePeriod;\n            } else {\n                timeOfLastMint =  lastMintDate[col];\n            }\n            // uint calculates if period has passed in order to allow minting\n            uint tDiff = (block.timestamp - timeOfLastMint) / collectionPhases[col].timePeriod;\n            // users are able to mint after a day passes\n            require(tDiff>=1 && _numberOfTokens == 1, \"1 mint/period\");\n            lastMintDate[col] = collectionPhases[col].allowlistStartTime + (collectionPhases[col].timePeriod * (gencore.viewCirSupply(col) - 1));\n        }\n    }\n\n    // burn to mint function (does not require contract approval)\n\n    function burnToMint(uint256 _burnCollectionID, uint256 _tokenId, uint256 _mintCollectionID, uint256 _saltfun_o) public payable {\n        require(burnToMintCollections[_burnCollectionID][_mintCollectionID] == true, \"Initialize burn\");\n        require(block.timestamp >= collectionPhases[_mintCollectionID].publicStartTime && block.timestamp<=collectionPhases[_mintCollectionID].publicEndTime,\"No minting\");\n        require ((_tokenId >= gencore.viewTokensIndexMin(_burnCollectionID)) && (_tokenId <= gencore.viewTokensIndexMax(_burnCollectionID)), \"col/token id error\");\n        // minting new token\n        uint256 collectionTokenMintIndex;\n        collectionTokenMintIndex = gencore.viewTokensIndexMin(_mintCollectionID) + gencore.viewCirSupply(_mintCollectionID);\n        require(collectionTokenMintIndex <= gencore.viewTokensIndexMax(_mintCollectionID), \"No supply\");\n        require(msg.value >= getPrice(_mintCollectionID), \"Wrong ETH\");\n        uint256 mintIndex = gencore.viewTokensIndexMin(_mintCollectionID) + gencore.viewCirSupply(_mintCollectionID);\n        // burn and mint token\n        address burner = msg.sender;\n        gencore.burnToMint(mintIndex, _burnCollectionID, _tokenId, _mintCollectionID, _saltfun_o, burner);\n        collectionTotalAmount[_mintCollectionID] = collectionTotalAmount[_mintCollectionID] + msg.value;\n    }\n\n    // mint and auction\n    \n    function mintAndAuction(address _recipient, string memory _tokenData, uint256 _saltfun_o, uint256 _collectionID, uint _auctionEndTime) public FunctionAdminRequired(this.mintAndAuction.selector) {\n        require(gencore.retrievewereDataAdded(_collectionID) == true, \"Add data\");\n        uint256 collectionTokenMintIndex;\n        collectionTokenMintIndex = gencore.viewTokensIndexMin(_collectionID) + gencore.viewCirSupply(_collectionID);\n        require(collectionTokenMintIndex <= gencore.viewTokensIndexMax(_collectionID), \"No supply\");\n        uint256 mintIndex = gencore.viewTokensIndexMin(_collectionID) + gencore.viewCirSupply(_collectionID);\n        gencore.airDropTokens(mintIndex, _recipient, _tokenData, _saltfun_o, _collectionID);\n        uint timeOfLastMint;\n        // check 1 per period\n        if (lastMintDate[_collectionID] == 0) {\n        // for public sale set the allowlist the same time as publicsale\n            timeOfLastMint = collectionPhases[_collectionID].allowlistStartTime - collectionPhases[_collectionID].timePeriod;\n        } else {\n            timeOfLastMint =  lastMintDate[_collectionID];\n        }\n        // uint calculates if period has passed in order to allow minting\n        uint tDiff = (block.timestamp - timeOfLastMint) / collectionPhases[_collectionID].timePeriod;\n        // users are able to mint after a day passes\n        require(tDiff>=1, \"1 mint/period\");\n        lastMintDate[_collectionID] = collectionPhases[_collectionID].allowlistStartTime + (collectionPhases[_collectionID].timePeriod * (gencore.viewCirSupply(_collectionID) - 1));\n        mintToAuctionData[mintIndex] = _auctionEndTime;\n        mintToAuctionStatus[mintIndex] = true;\n    }\n\n    // function to update allowlist mint delegation collection\n\n    function updateDelegationCollection(uint256 _collectionID, address _collectionAddress) public FunctionAdminRequired(this.updateDelegationCollection.selector) { \n        collectionPhases[_collectionID].delAddress = _collectionAddress;\n    }\n\n    // function to initialize burn to mint for NextGen collections\n\n    function initializeBurn(uint256 _burnCollectionID, uint256 _mintCollectionID, bool _status) public FunctionAdminRequired(this.initializeBurn.selector) { \n        require((gencore.retrievewereDataAdded(_burnCollectionID) == true) && (gencore.retrievewereDataAdded(_mintCollectionID) == true), \"No data\");\n        burnToMintCollections[_burnCollectionID][_mintCollectionID] = _status;\n    }\n\n    // function to initialize external burn or swap to mint (requires contract approval)\n\n    function initializeExternalBurnOrSwap(address _erc721Collection, uint256 _burnCollectionID, uint256 _mintCollectionID, uint256 _tokmin, uint256 _tokmax, address _burnOrSwapAddress, bool _status) public FunctionAdminRequired(this.initializeExternalBurnOrSwap.selector) { \n        bytes32 externalCol = keccak256(abi.encodePacked(_erc721Collection,_burnCollectionID));\n        require((gencore.retrievewereDataAdded(_mintCollectionID) == true), \"No data\");\n        burnExternalToMintCollections[externalCol][_mintCollectionID] = _status;\n        burnOrSwapAddress[externalCol] = _burnOrSwapAddress;\n        burnOrSwapIds[externalCol][0] = _tokmin;\n        burnOrSwapIds[externalCol][1] = _tokmax;\n    }\n\n    // burn or swap to mint (requires contract approval)\n\n    function burnOrSwapExternalToMint(address _erc721Collection, uint256 _burnCollectionID, uint256 _tokenId, uint256 _mintCollectionID, string memory _tokenData, bytes32[] calldata merkleProof, uint256 _saltfun_o) public payable {\n        bytes32 externalCol = keccak256(abi.encodePacked(_erc721Collection,_burnCollectionID));\n        require(burnExternalToMintCollections[externalCol][_mintCollectionID] == true, \"Initialize external burn\");\n        require(setMintingCosts[_mintCollectionID] == true, \"Set Minting Costs\");\n        address ownerOfToken = IERC721(_erc721Collection).ownerOf(_tokenId);\n        if (msg.sender != ownerOfToken) {\n            bool isAllowedToMint;\n            isAllowedToMint = dmc.retrieveGlobalStatusOfDelegation(ownerOfToken, 0x8888888888888888888888888888888888888888, msg.sender, 1) || dmc.retrieveGlobalStatusOfDelegation(ownerOfToken, 0x8888888888888888888888888888888888888888, msg.sender, 2);\n            if (isAllowedToMint == false) {\n            isAllowedToMint = dmc.retrieveGlobalStatusOfDelegation(ownerOfToken, _erc721Collection, msg.sender, 1) || dmc.retrieveGlobalStatusOfDelegation(ownerOfToken, _erc721Collection, msg.sender, 2);    \n            }\n            require(isAllowedToMint == true, \"No delegation\");\n        }\n        require(_tokenId >= burnOrSwapIds[externalCol][0] && _tokenId <= burnOrSwapIds[externalCol][1], \"Token id does not match\");\n        IERC721(_erc721Collection).safeTransferFrom(ownerOfToken, burnOrSwapAddress[externalCol], _tokenId);\n        uint256 col = _mintCollectionID;\n        address mintingAddress;\n        uint256 phase;\n        string memory tokData = _tokenData;\n        if (block.timestamp >= collectionPhases[col].allowlistStartTime && block.timestamp <= collectionPhases[col].allowlistEndTime) {\n            phase = 1;\n            bytes32 node;\n            node = keccak256(abi.encodePacked(_tokenId, tokData));\n            mintingAddress = ownerOfToken;\n            require(MerkleProof.verifyCalldata(merkleProof, collectionPhases[col].merkleRoot, node), 'invalid proof');            \n        } else if (block.timestamp >= collectionPhases[col].publicStartTime && block.timestamp <= collectionPhases[col].publicEndTime) {\n            phase = 2;\n            mintingAddress = ownerOfToken;\n            tokData = '\"public\"';\n        } else {\n            revert(\"No minting\");\n        }\n        uint256 collectionTokenMintIndex;\n        collectionTokenMintIndex = gencore.viewTokensIndexMin(col) + gencore.viewCirSupply(col);\n        require(collectionTokenMintIndex <= gencore.viewTokensIndexMax(col), \"No supply\");\n        require(msg.value >= (getPrice(col) * 1), \"Wrong ETH\");\n        uint256 mintIndex = gencore.viewTokensIndexMin(col) + gencore.viewCirSupply(col);\n        gencore.mint(mintIndex, mintingAddress, ownerOfToken, tokData, _saltfun_o, col, phase);\n        collectionTotalAmount[col] = collectionTotalAmount[col] + msg.value;\n    }\n\n    // function to set primary splits\n\n    function setPrimaryAndSecondarySplits(uint256 _collectionID, uint256 _artistPrSplit, uint256 _teamPrSplit, uint256 _artistSecSplit, uint256 _teamSecSplit) public FunctionAdminRequired(this.setPrimaryAndSecondarySplits.selector) {\n        require(_artistPrSplit + _teamPrSplit == 100, \"splits need to be 100%\");\n        require(_artistSecSplit + _teamSecSplit == 100, \"splits need to be 100%\");\n        collectionRoyaltiesPrimarySplits[_collectionID].artistPercentage = _artistPrSplit;\n        collectionRoyaltiesPrimarySplits[_collectionID].teamPercentage = _teamPrSplit;\n        collectionRoyaltiesSecondarySplits[_collectionID].artistPercentage = _artistSecSplit;\n        collectionRoyaltiesSecondarySplits[_collectionID].teamPercentage = _teamSecSplit;\n    }\n\n    // function to propose primary addresses and percentages for each address\n\n    function proposePrimaryAddressesAndPercentages(uint256 _collectionID, address _primaryAdd1, address _primaryAdd2, address _primaryAdd3, uint256 _add1Percentage, uint256 _add2Percentage, uint256 _add3Percentage) public ArtistOrAdminRequired(_collectionID, this.proposePrimaryAddressesAndPercentages.selector) {\n        require (collectionArtistPrimaryAddresses[_collectionID].status == false, \"Already approved\");\n        require (_add1Percentage + _add2Percentage + _add3Percentage == collectionRoyaltiesPrimarySplits[_collectionID].artistPercentage, \"Check %\");\n        collectionArtistPrimaryAddresses[_collectionID].primaryAdd1 = _primaryAdd1;\n        collectionArtistPrimaryAddresses[_collectionID].primaryAdd2 = _primaryAdd2;\n        collectionArtistPrimaryAddresses[_collectionID].primaryAdd3 = _primaryAdd3;\n        collectionArtistPrimaryAddresses[_collectionID].add1Percentage = _add1Percentage;\n        collectionArtistPrimaryAddresses[_collectionID].add2Percentage = _add2Percentage;\n        collectionArtistPrimaryAddresses[_collectionID].add3Percentage = _add3Percentage;\n        collectionArtistPrimaryAddresses[_collectionID].status = false;\n    }\n\n    // function to propose secondary addresses and percentages for each address\n\n    function proposeSecondaryAddressesAndPercentages(uint256 _collectionID, address _secondaryAdd1, address _secondaryAdd2, address _secondaryAdd3, uint256 _add1Percentage, uint256 _add2Percentage, uint256 _add3Percentage) public ArtistOrAdminRequired(_collectionID, this.proposeSecondaryAddressesAndPercentages.selector) {\n        require (collectionArtistSecondaryAddresses[_collectionID].status == false, \"Already approved\");\n        require (_add1Percentage + _add2Percentage + _add3Percentage == collectionRoyaltiesSecondarySplits[_collectionID].artistPercentage, \"Check %\");\n        collectionArtistSecondaryAddresses[_collectionID].secondaryAdd1 = _secondaryAdd1;\n        collectionArtistSecondaryAddresses[_collectionID].secondaryAdd2 = _secondaryAdd2;\n        collectionArtistSecondaryAddresses[_collectionID].secondaryAdd3 = _secondaryAdd3;\n        collectionArtistSecondaryAddresses[_collectionID].add1Percentage = _add1Percentage;\n        collectionArtistSecondaryAddresses[_collectionID].add2Percentage = _add2Percentage;\n        collectionArtistSecondaryAddresses[_collectionID].add3Percentage = _add3Percentage;\n        collectionArtistSecondaryAddresses[_collectionID].status = false;\n    }\n\n    // function to accept primary addresses and percentages\n\n    function acceptAddressesAndPercentages(uint256 _collectionID, bool _statusPrimary, bool _statusSecondary) public FunctionAdminRequired(this.acceptAddressesAndPercentages.selector) {\n        collectionArtistPrimaryAddresses[_collectionID].status = _statusPrimary;\n        collectionArtistSecondaryAddresses[_collectionID].status = _statusSecondary;\n    }\n\n    // function to pay the artist\n\n    function payArtist(uint256 _collectionID, address _team1, address _team2, uint256 _teamperc1, uint256 _teamperc2) public FunctionAdminRequired(this.payArtist.selector) {\n        require(collectionArtistPrimaryAddresses[_collectionID].status == true, \"Accept Royalties\");\n        require(collectionTotalAmount[_collectionID] > 0, \"Collection Balance must be grater than 0\");\n        require(collectionRoyaltiesPrimarySplits[_collectionID].artistPercentage + _teamperc1 + _teamperc2 == 100, \"Change percentages\");\n        uint256 royalties = collectionTotalAmount[_collectionID];\n        collectionTotalAmount[_collectionID] = 0;\n        address tm1 = _team1;\n        address tm2 = _team2;\n        uint256 colId = _collectionID;\n        uint256 artistRoyalties1;\n        uint256 artistRoyalties2;\n        uint256 artistRoyalties3;\n        uint256 teamRoyalties1;\n        uint256 teamRoyalties2;\n        artistRoyalties1 = royalties * collectionArtistPrimaryAddresses[colId].add1Percentage / 100;\n        artistRoyalties2 = royalties * collectionArtistPrimaryAddresses[colId].add2Percentage / 100;\n        artistRoyalties3 = royalties * collectionArtistPrimaryAddresses[colId].add3Percentage / 100;\n        teamRoyalties1 = royalties * _teamperc1 / 100;\n        teamRoyalties2 = royalties * _teamperc2 / 100;\n        (bool success1, ) = payable(collectionArtistPrimaryAddresses[colId].primaryAdd1).call{value: artistRoyalties1}(\"\");\n        (bool success2, ) = payable(collectionArtistPrimaryAddresses[colId].primaryAdd2).call{value: artistRoyalties2}(\"\");\n        (bool success3, ) = payable(collectionArtistPrimaryAddresses[colId].primaryAdd3).call{value: artistRoyalties3}(\"\");\n        (bool success4, ) = payable(tm1).call{value: teamRoyalties1}(\"\");\n        (bool success5, ) = payable(tm2).call{value: teamRoyalties2}(\"\");\n        emit PayArtist(collectionArtistPrimaryAddresses[colId].primaryAdd1, success1, artistRoyalties1);\n        emit PayArtist(collectionArtistPrimaryAddresses[colId].primaryAdd2, success2, artistRoyalties2);\n        emit PayArtist(collectionArtistPrimaryAddresses[colId].primaryAdd3, success3, artistRoyalties3);\n        emit PayTeam(tm1, success4, teamRoyalties1);\n        emit PayTeam(tm2, success5, teamRoyalties2);\n    }\n\n    // function to update core contract\n\n    function updateCoreContract(address _gencore) public FunctionAdminRequired(this.updateCoreContract.selector) { \n        gencore = INextGenCore(_gencore);\n    }\n\n    // function to update admin contract\n\n    function updateAdminContract(address _newadminsContract) public FunctionAdminRequired(this.updateAdminContract.selector) {\n        require(INextGenAdmins(_newadminsContract).isAdminContract() == true, \"Contract is not Admin\");\n        adminsContract = INextGenAdmins(_newadminsContract);\n    }\n\n    // function to withdraw any balance from the smart contract\n\n    function emergencyWithdraw() public FunctionAdminRequired(this.emergencyWithdraw.selector) {\n        uint balance = address(this).balance;\n        address admin = adminsContract.owner();\n        (bool success, ) = payable(admin).call{value: balance}(\"\");\n        emit Withdraw(msg.sender, success, balance);\n    }\n\n    // function to retrieve primary splits between artist and team\n\n    function retrievePrimarySplits(uint256 _collectionID) public view returns(uint256, uint256){\n        return (collectionRoyaltiesPrimarySplits[_collectionID].artistPercentage, collectionRoyaltiesPrimarySplits[_collectionID].teamPercentage);\n    }\n\n    // function to retrieve primary addresses and percentages\n\n    function retrievePrimaryAddressesAndPercentages(uint256 _collectionID) public view returns(address, address, address, uint256, uint256, uint256, bool){\n        return (collectionArtistPrimaryAddresses[_collectionID].primaryAdd1, collectionArtistPrimaryAddresses[_collectionID].primaryAdd2, collectionArtistPrimaryAddresses[_collectionID].primaryAdd3, collectionArtistPrimaryAddresses[_collectionID].add1Percentage, collectionArtistPrimaryAddresses[_collectionID].add2Percentage, collectionArtistPrimaryAddresses[_collectionID].add3Percentage, collectionArtistPrimaryAddresses[_collectionID].status);\n    }\n\n    // function to retrieve secondary splits between artist and team\n\n    function retrieveSecondarySplits(uint256 _collectionID) public view returns(uint256, uint256){\n        return (collectionRoyaltiesSecondarySplits[_collectionID].artistPercentage, collectionRoyaltiesSecondarySplits[_collectionID].teamPercentage);\n    }\n\n    // function to retrieve secondary addresses and percentages\n\n    function retrieveSecondaryAddressesAndPercentages(uint256 _collectionID) public view returns(address, address, address, uint256, uint256, uint256, bool){\n        return (collectionArtistSecondaryAddresses[_collectionID].secondaryAdd1, collectionArtistSecondaryAddresses[_collectionID].secondaryAdd2, collectionArtistSecondaryAddresses[_collectionID].secondaryAdd3, collectionArtistSecondaryAddresses[_collectionID].add1Percentage, collectionArtistSecondaryAddresses[_collectionID].add2Percentage, collectionArtistSecondaryAddresses[_collectionID].add3Percentage, collectionArtistSecondaryAddresses[_collectionID].status);\n    }\n\n    // function to retrieve the Collection phases times and merkle root of a collection\n\n    function retrieveCollectionPhases(uint256 _collectionID) public view returns(uint, uint, bytes32, uint, uint){\n        return (collectionPhases[_collectionID].allowlistStartTime, collectionPhases[_collectionID].allowlistEndTime, collectionPhases[_collectionID].merkleRoot, collectionPhases[_collectionID].publicStartTime, collectionPhases[_collectionID].publicEndTime);\n    }\n\n    // function to retrieve the minting details of a collection\n\n    function retrieveCollectionMintingDetails(uint256 _collectionID) public view returns(uint256, uint256, uint256, uint256, uint8, address){\n        return (collectionPhases[_collectionID].collectionMintCost, collectionPhases[_collectionID].collectionEndMintCost, collectionPhases[_collectionID].rate, collectionPhases[_collectionID].timePeriod, collectionPhases[_collectionID].salesOption, collectionPhases[_collectionID].delAddress);\n    }\n\n    // get minter contract status\n\n    function isMinterContract() external view returns (bool) {\n        return true;\n    }\n\n    // get minting end time\n\n    function getEndTime(uint256 _collectionID) external view returns (uint) {\n        return collectionPhases[_collectionID].publicEndTime;\n    }\n\n    // get auction end time\n\n    function getAuctionEndTime(uint256 _tokenId) external view returns (uint) {\n        return mintToAuctionData[_tokenId];\n    }\n\n    // get auction status\n\n    function getAuctionStatus(uint256 _tokenId) external view  returns (bool) {\n        return mintToAuctionStatus[_tokenId];\n    }\n\n    // get the minting price of collection\n\n    function getPrice(uint256 _collectionId) public view returns (uint256) {\n        uint tDiff;\n        if (collectionPhases[_collectionId].salesOption == 3) {\n            // increase minting price by mintcost / collectionPhases[_collectionId].rate every mint (1mint/period)\n            // to get the price rate needs to be set\n            if (collectionPhases[_collectionId].rate > 0) {\n                return collectionPhases[_collectionId].collectionMintCost + ((collectionPhases[_collectionId].collectionMintCost / collectionPhases[_collectionId].rate) * gencore.viewCirSupply(_collectionId));\n            } else {\n                return collectionPhases[_collectionId].collectionMintCost;\n            }\n        } else if (collectionPhases[_collectionId].salesOption == 2 && block.timestamp > collectionPhases[_collectionId].allowlistStartTime && block.timestamp < collectionPhases[_collectionId].publicEndTime){\n            // decreases exponentially every time period\n            // collectionPhases[_collectionId].timePeriod sets the time period for decreasing the mintcost\n            // if just public mint set the publicStartTime = allowlistStartTime\n            // if rate = 0 exponetialy decrease\n            // if rate is set the linear decrase each period per rate\n            tDiff = (block.timestamp - collectionPhases[_collectionId].allowlistStartTime) / collectionPhases[_collectionId].timePeriod;\n            uint256 price;\n            uint256 decreaserate;\n            if (collectionPhases[_collectionId].rate == 0) {\n                price = collectionPhases[_collectionId].collectionMintCost / (tDiff + 1);\n                decreaserate = ((price - (collectionPhases[_collectionId].collectionMintCost / (tDiff + 2))) / collectionPhases[_collectionId].timePeriod) * ((block.timestamp - (tDiff * collectionPhases[_collectionId].timePeriod) - collectionPhases[_collectionId].allowlistStartTime));\n            } else {\n                if (((collectionPhases[_collectionId].collectionMintCost - collectionPhases[_collectionId].collectionEndMintCost) / (collectionPhases[_collectionId].rate)) > tDiff) {\n                    price = collectionPhases[_collectionId].collectionMintC"
    }
  ]
}