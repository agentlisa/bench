{
  "Title": "M-2: USD1 is priced as $1 instead of being pegged to USDT",
  "Content": "# Issue M-2: USD1 is priced as $1 instead of being pegged to USDT \n\nSource: https://github.com/sherlock-audit/2023-04-unitasprotocol-judging/issues/48 \n\n## Found by \nRuhum, carrotsmuggler\n## Summary\nThe system treats 1 USD1 = $1 instead of 1 USD1 = 1 USDT which allows arbitrage opportunities. \n\n## Vulnerability Detail\nTo swap from one token to another Unitas first get's the price of the quote token and then calculates the swap result. Given that we want to swap 1 USD1 for USDT, we have USDT as the quote token:\n\n```sol\n        address priceQuoteToken = _getPriceQuoteToken(tokenIn, tokenOut);\n        price = oracle.getLatestPrice(priceQuoteToken);\n        _checkPrice(priceQuoteToken, price);\n\n        feeNumerator = isBuy ? pair.buyFee : pair.sellFee;\n        feeToken = IERC20Token(priceQuoteToken == tokenIn ? tokenOut : tokenIn);\n\n        SwapRequest memory request;\n        request.tokenIn = tokenIn;\n        request.tokenOut = tokenOut;\n        request.amountType = amountType;\n        request.amount = amount;\n        request.feeNumerator = feeNumerator;\n        request.feeBase = tokenManager.SWAP_FEE_BASE();\n        request.feeToken = address(feeToken);\n        request.price = price;\n        request.priceBase = 10 ** oracle.decimals();\n        request.quoteToken = priceQuoteToken;\n\n        (amountIn, amountOut, fee) = _calculateSwapResult(request);\n```\n\nSince `amountType == AmountType.In`, it executes `_calculateSwapResultByAmountIn()`:\n\n```sol\n            // When tokenOut is feeToken, subtracts the fee after converting the amount\n            amountOut = _convert(\n                request.tokenIn,\n                request.tokenOut,\n                amountIn,\n                MathUpgradeable.Rounding.Down,\n                request.price,\n                request.priceBase,\n                request.quoteToken\n            );\n            fee = _getFeeByAmountWithFee(amountOut, request.feeNumerator, request.feeBase);\n            amountOut -= fee;\n```\n\nGiven that the price is 0.99e18, i.e. 1 USDT is worth $0.99, it calculates the amount of USDT we should receive as:\n\n```sol\n    function _convertByFromPrice(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        MathUpgradeable.Rounding rounding,\n        uint256 price,\n        uint256 priceBase\n    ) internal view virtual returns (uint256) {\n        uint256 fromBase = 10 ** IERC20Metadata(fromToken).decimals();\n        uint256 toBase = 10 ** IERC20Metadata(toToken).decimals();\n\n        return fromAmount.mulDiv(price * toBase, priceBase * fromBase, rounding);\n    }\n```\nGiven that:\n- toBase = 10**6 = 1e6 (USDT has 6 decimals)\n- fromBase = 10**18 = 1e18 (USD1 has 18 decimals)\n- priceBase = 1e18 \n- price = 0.99e18 (1 USDT = $0.99)\n- fromAmount = 1e18 (we swap 1 USD1)\nwe get: $1e18 * 0.99e18 * 1e6 / (1e18 * 1e18) = 0.99e6$\n\nSo by redeeming 1 USD1 I only get back 0.99 USDT. The other way around, trading USDT for USD1, would get you 1.01 USD1 for 1 USDT: $1e6 * 1e18 * 1e18 / (0.99e18 * 1e6) = 1.01e18$\n\nThe contract values USD1 at exactly $1 while USDT's price is variable. But, in reality, USD1 is not pegged to $1. It's pegged to USDT the only underlying asset.\n\nThat allows us to do the following:\n- Given that USDT loses its peg slightly, e.g. it goes down to 0.997, which happens quite regularly: https://coinmarketcap.com/currencies/tether/\n- we can swap a lot of USDT for USD1, wait for USDT to recover and swap back to USDT\n$100,000e6 * 1e18 * 1e18 / (0.997e18 * 1e6) = 1.003009e+23$\n\nWith USDT back to $1 we get:\n$1.003009e+23 * 1e18 * 1e6 / (1e18 * 1e18) = 100300.9e6$\n\nThat's a profit of 300 USDT. The profit is taken from other users of the protocol who deposited USDT to get access to the other stablecoins.\n\n## Impact\nAn attacker can abuse the price variation of USDT to buy USD1 for cheap.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-unitasprotocol/blob/main/Unitas-Protocol/src/SwapFunctions.sol#L28\nhttps://github.com/sherlock-audit/2023-04-unitasprotocol/blob/main/Unitas-Protocol/src/SwapFunctions.sol#L63\nhttps://github.com/sherlock-audit/2023-04-unitasprotocol/blob/main/Unitas-Protocol/src/SwapFunctions.sol#L203-L239\n## Tool used\n\nManual Review\n\n## Recommendation\n1 USDT should always be 1 USD1. You treat 1 USD1 as $1 but that's not the case.\n\n\n\n## Discussion\n\n**Adityaxrex**\n\nAditya: USD1 is pegged to USDT instead of 1 USD. This means the liability and asset accounting is done in USDT value.\n\n**SunXrex**\n\nThis should be invalid. because we design converting rate always USD1:USDT to 1:1.\n\n**0xruhum**\n\nEscalate for 10 USDC\n\nYou don't treat 1 USDT as 1 USD1. That's exactly what I'm describing here. If 1 USDT = 1 USD1 you wouldn't have to query the price of USDT to calculate the swap. The example calculation in the original issue shows how USDT slightly de-pegging opens up arbitrage opportunities. By USDT losing value you get more USD1. If USD1 were pegged to USDT you'd always get 1 USD1 for 1 USDT no matter the price of USDT.\n\nAlso, #79, #102, and #147 are not duplicates of this issue. Only #141 is a valid duplicate.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> You don't treat 1 USDT as 1 USD1. That's exactly what I'm describing here. If 1 USDT = 1 USD1 you wouldn't have to query the price of USDT to calculate the swap. The example calculation in the original issue shows how USDT slightly de-pegging opens up arbitrage opportunities. By USDT losing value you get more USD1. If USD1 were pegged to USDT you'd always get 1 USD1 for 1 USDT no matter the price of USDT.\n> \n> Also, #79, #102, and #147 are not duplicates of this issue. Only #141 is a valid duplicate.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nI actually agree with the escalation, https://github.com/sherlock-audit/2023-04-unitasprotocol-judging/issues/79, https://github.com/sherlock-audit/2023-04-unitasprotocol-judging/issues/102, and https://github.com/sherlock-audit/2023-04-unitasprotocol-judging/issues/147 are not duplicates of this issue and this issue itself can be a valid medium\n\n**Adityaxrex**\n\nLiability and asset are both calculated in USDT. \nCase: 1 USDT = 0.5 USD. Mint 100 USD1 from 100 USDT. Protocol liability = 100 USDT. In nowhere in our calculation we consider dollar value of USDT. If someone is able to make profit by getting cheap USDT, it is not at the cost of the protocol but USDT. \nIt still remains not a valid issue. \n\n**jacksanford1**\n\n@Adityaxrex Why is `oracle.getLatestPrice(priceQuoteToken)` being used in the swap request shown in @0xruhum's example above if it isn't being taken into account to swap between USD1 and USDT?\n\n@0xffff11 What is your understanding of this situation?\n\n\n\n**Adityaxrex**\n\n@jacksanford1 in this version our protocol's main backing asset is USDT. In all practical purpose we fix 1USDT=1USD1. Even if USDT depegs, we keep 1USDT=1USD1. It does not change accounting whether we check the price or not. This helps us keep the design simple. However, we eventually move towards diversifying to other assets. \n\n**0xruhum**\n\nAs shown in the code snippets and the example calculation, the price **does** have an effect on the swap. While the protocol team's intention might have been to treat 1 USD1 as 1 USDT, the actual implementation doesn't do that.\n\n**jacksanford1**\n\nOk, it seems we have a disagreement about how the actual implementation works. \n\n@ctf-sec @0xffff11 Can you please verify if the swap function above is swapping USD1 to USDT (or vice versa) using a fixed 1:1 ratio or if the swap is being done based on the price of USDT returned by Chainlink?\n\n**0xffff11**\n\n@jacksanford1 I did a deep research on the issue. It seems like it is not redeeming paired 1:1 usd1 for usdt or vice versa. The price of the `quote` token, in this case `usdt`, is used for the calculation of the amountOut instead of a 1:1 ratio. So the depeg of usdt, in my opinion, would affect the exchange rate. I think it is a valid issue and as a comment above, most dups are invalid\n\n**SunWeb3Sec**\n\nWe keep the swap logic consistent, so instead of hard-coding a 1:1 ratio in the code, we maintain it through our Oracle price updates.\n\n**Adityaxrex**\n\nAs mentioned by @SunWeb3Sec we keep the logic consistent and check the price for any pair periodically. However, our feeder logic keeps updating the price for USD1 and USDT price just like any other pair. As mentioned earlier we plan to keep USDT:USD1 = 1:1 for now through our feeder logic. This can be changed in future to reflect the true market price. \nThank you \n\n**0xruhum**\n\nThat wouldn't work. You price USDT as 1$ in that case without it being worth 1$ if it depegs. \n\nThe oracle price is used to calculate the protocol's collateral value: https://github.com/sherlock-audit/2023-04-unitasprotocol/blob/main/Unitas-Protocol/src/Unitas.sol#L512\n\nIf you don't update the price to keep the 1:1 ratio with USD1, `totalReserves` won't reflect the actual value of your collateral. That breaks the reserve ratio calculation.\n\n**Adityaxrex**\n\n@jacksanford1 @SunWeb3Sec the above argument is similar to issue  #145. Upto you to decide whether to accept this as duplicate or the other one. Thank you \n\n**0xruhum**\n\nThe argument for not keeping the price of USDT hardcoded as $1 is the same yeah. But the two reported issues are different. One describes the issue of assets being frozen because the swap functionality breaks in case the price outside the min/max values. The other shows how price movement in USDT causes the system to mint either more or less USD1 than it should. It's not a duplicate of #145 IMO.\n\nThe next time, these kinds of assumptions regarding off-chain mechanics, like the oracle values in this case, should be mentioned in the contest's README. Having them come up during the judging period is annoying for all parties.\n\n**Adityaxrex**\n\nPlease see that when user tries to redeem USDT, we also use 1:1. This way we avoid any loss to the protocol. If the user is able to obtain cheaper USDT compared to 1 USD it is at the cost of the USDT seller not the protocol. Thank you \n\n**Adityaxrex**\n\n@0xruhum essentially the minter is able to make profit but the loss is coming from anyone selling USDT for lesser than 1 USD. In terms of USD1:USDT, mint and burn are both at 1:1 so there is no need to worry from the protocol point of view. It can create a scenario that protocol owns a lot of USDT which is worth less because of USDT depeg but to the protocol that is not an issue because we only redeem USDT not USD\n\n**0xruhum**\n\nThe value of your tokens depends on the value of your underlying collateral. If the value of USDT falls below $1, your derivative tokens become unreserved. At that point, they will depeg as well. You can't just hardcode the price of USDT as $1. That's what I'm trying to explain here.\n\nHere's a small example:\nGiven that you have a reserve ratio threshold of 100%, e.g. you need 1$ of collateral to mint $1 of your tokens.\n\nAlice mints 100 USD1 using 100 USDT. She then swaps 100 USD1 for 8200 INR (the current exchange rate is 1:82). At this point you have 100 USDT covering 8200 INR. The INR token only has that value because I can use the Unitas protocol to get back the underlying USDT. Otherwise, INR is worth nothing because there's no asset backing it. Now let's say USDT depegs and is only worth $0.9. At this point, you have $90 worth of USDT backing 8200 INR tokens. That doesn't work, right? Because USDT the underlying asset lost 10% of its value, your INR token will also lose value. Its value will now move to 8200 * 0.9 = 7380 INR while the token amount stays the same. Since your whole protocol depends on these derivative tokens mimicking the price of the asset they try to represent, e.g. INR, everything breaks. The actual USD/INR ratio hasn't changed at all. But because your underlying asset depegged, your derivative token also depegs.\n\nKeeping USDT:USD1 at 1:1 won't protect your derivative tokens from depegging. What you do with that is to keep the reserve ratio artificially at a healthy ratio while the **real** reserve ratio keeps going down. So all the reserve ratio shenanigans of what tokens are supposed to be mintable and burnable at different stages won't really matter.\n\nTo sum up, if we assume that your oracle just says that USDT is worth $1 at any time, you've got the problem I've described above.\nIf your oracle returns the correct value for USDT, whether it depegs or not, your swap calculation causes you to mint the wrong amount of USD1 as seen in the original issue.\n\nSo no matter what you do, the current design is flawed.\n\n**jacksanford1**\n\nAgree that this is not a duplicate of #145, it describes a different part of the code as @0xruhum explains above. \n\nBased on @0xffff11's research, it seems like it was not obvious that a 1:1 ratio would be kept here. It was reasonable to assume the oracle would be using the latest trading price of the asset. So that makes this a Medium issue imo because the functioning of this oracle doesn't seem to have been clearly stated as being hardcoded 1:1. Open to correction on this. Here's a statement from the docs which makes it sound like the conversion would be value-based instead of 1:1:\n\n> USD91 minters need to provide USDT, the protocol will mint equivalent in value USD91 \n\nI'm unclear as to whether the 1:1 hardcoding will cause additional issues in the protocol, but the team is acknowledging that the protocol should function in a way that takes into account the ramifications of hardcoding the price. \n\n**0xruhum**\n\nYeah, the 1:1 conversion wasn't clearly stated. But, why does that change the severity of the issue?\n\nIf we go with the original assumption that the oracle will use the correct trading price of USDT, the swap calculation is broken. Because while using the real trading price for USDT, you continue to treat USD1 as worth $1. As described in the original issue, when the price of USDT drops you're able to mint more USD1 for any given amount of USDT. At the same time you're able to swap USD1 for any of the other derivative tokens at the actual conversion rate of those two assets, e.g. USD/INR. That's a HIGH. The core mechanics of the protocol are broken. \n\nIf we assume that the price is hardcoded to 1:1, we have a totally different situation. The reserve calculation breaks which causes the protocol to believe it's fully collateralized while it isn't. Even if USDT drops to $0.9, the protocol continues to treat it as $1 which keeps the reserve ratio above the threshold. But, that doesn't stop the derivative tokens from depegging. Since the value of each derivative token depends on the value of the underlying asset. Again, a HIGH severity issue since another core mechanic of the protocol (distribution of derivative tokens that represent currencies like INR and TRY) is broken.\n\n**jacksanford1**\n\n@Adityaxrex @lucas-xrex @SunXrex Any response to the second paragraph about the downside of hardcoding the oracle at a 1:1 ratio?\n\n@0xruhum If USD1 is hardcoded 1:1 to USDT, it wouldn't mean that USD91 depegs right? Because the conversion ratio between USD91 and USDT would take into account the fact that USDT is now trading at $0.90?\n\n**0xruhum**\n\nThere are no swaps from USDT to any of the other derivative tokens. There's only USDT/USD1. USD1 is then used to trade to the other derivative tokens. The conversion between USD1 and the other derivative tokens will represent the current exchange rate between USD and those other currencies not the actual conversion rate between the tokens themselves.\n\nUSDT depegging will cause all the derivative tokens to depeg. The only reason these tokens have any value is because they are backed by an asset with value. USDT is worth $1 because you can exchange it for $1 through Tether no matter what happens (at least that's the idea). That's the reason USDT is pegged at $1.\n\nUSD1 is only worth something because it's backed by USDT. I know my USD1 is worth something because I can trade it for USDT which the market agrees is worth X US Dollars. If the price of USDT drops, the price of USD1 will also drop.\n\nUSD91 is only worth something because it's backed by USD1. If USD1 loses value, e.g. through USDT depegging, USD91 will also lose value and depeg. Even if I trade my USD91 at the same rate I initially bought it for back to USD1, the asset I get is worth less than at the time of my trade. It doesn't matter that I get the same amount of USD1 back. It's simply not worth the same amount as back then. The same logic applies to all the other derivative tokens as well.\n\nThe system here is just one long chain: $1 -> USDT -> USD1 -> USD91. If any of the links break, the whole system will blow up. Meaning, as soon as USDT depegs and doesn't trade for $1, all of your tokens will depeg as well. USDT is the only thing that gave them value.\n\n\n**Adityaxrex**\n\nWe have discussed this internally and concluded that USDT depeg is not an\nissue for us. Thank you\n\nOn Sat, Jul 1, 2023 at 5:23 PM ruhum ***@***.***> wrote:\n\n> There are no swaps from USDT to any of the other derivative tokens.\n> There's only USDT/USD1. USD1 is then used to trade to the other derivative\n> tokens. The conversion between USD1 and the other derivative tokens will\n> represent the current exchange rate between USD and those other currencies\n> not the actual conversion rate between the tokens themselves.\n>\n> USDT depegging will cause all the derivative tokens to depeg. The only\n> reason these tokens have any value is because they are backed by an asset\n> with value. USDT is worth $1 because you can exchange it for $1 through\n> Tether no matter what happens (at least that's the idea). That's the reason\n> USDT is pegged at $1.\n>\n> USD1 is only worth something because it's backed by USDT. I know my USD1\n> is worth something because I can trade it for USDT which the market agrees\n> is worth X US Dollars. If the price of USDT drops, the price of USD1 will\n> also drop.\n>\n> USD91 is only worth something because it's backed by USD1. If USD1 loses\n> value, e.g. through USDT depegging, USD91 will also lose value and depeg.\n> Even if I trade my USD91 at the same rate I initially bought it for back to\n> USD1, the asset I get is worth less than at the time of my trade. It\n> doesn't matter that I get the same amount of USD1 back. It's simply not\n> worth the same amount as back then. The same logic applies to all the other\n> derivative tokens as well.\n>\n> The system here is just one long chain: $1 -> USDT -> USD1 -> USD91. If\n> any of the links break, the whole system will blow up. Meaning, as soon as\n> USDT depegs and doesn't trade for $1, all of your tokens will depeg as\n> well. USDT is the only thing that gave them value.\n>\n> —\n> Reply to this email directly, view it on GitHub\n> <https://github.com/sherlock-audit/2023-04-unitasprotocol-judging/issues/48#issuecomment-1615773614>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AXN5N655U56CPSLAAC4NNRLXN7UAPANCNFSM6AAAAAAZDTL374>\n> .\n> You are receiving this because you were mentioned.Message ID:\n> ***@***.***\n> .com>\n>\n\n\n**jacksanford1**\n\n@0xruhum @Adityaxrex @SunXrex Last question from me:\n\nWhen USD1 is being converted into USD91 and vice versa, how is the price determined? Is it using the exchange rate between USD and rupees? Or the exchange rate between USDT and rupees?\n\n**Adityaxrex**\n\nIt is with with exchange rate using USDT and INR. Thank you\n\nOn Tue, Jul 4, 2023 at 10:50 AM Jack Sanford ***@***.***>\nwrote:\n\n> @0xruhum <https://github.com/0xruhum> @Adityaxrex\n> <https://github.com/Adityaxrex> @SunXrex <https://github.com/SunXrex>\n> Last question from me:\n>\n> When USD1 is being converted into USD91 and vice versa, how is the price\n> determined? Is it using the exchange rate between USD and rupees? Or the\n> exchange rate between USDT and rupees?\n>\n> —\n> Reply to this email directly, view it on GitHub\n> <https://github.com/sherlock-audit/2023-04-unitasprotocol-judging/issues/48#issuecomment-1619388479>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AXN5N65W5EKTA3L2WCBBTPLXOOAG7ANCNFSM6AAAAAAZDTL374>\n> .\n> You are receiving this because you were mentioned.Message ID:\n> ***@***.***\n> .com>\n>\n\n\n**jacksanford1**\n\nOk, in that case I think @0xruhum's statement below would not be true:\n\n> The conversion between USD1 and the other derivative tokens will represent the current exchange rate between USD and those other currencies not the actual conversion rate between the tokens themselves.\n\nI think the problem is that @0xruhum assumes everything is based around the value of USD ($1) when in reality it's based around USDT (1 USDT). And so if USDT depegs, then it's correct that everything else (USD1, USD91) depegs from $1 but the system doesn't care because it's all based in USDT. So there's no problem. \n\nThis chain from @0xruhum would not be correct:\n\n> The system here is just one long chain: $1 -> USDT -> USD1 -> USD91. If any of the links break, the whole system will blow up. \n\nAnd instead the chain is simply USDT -> USD1 -> USD91. \n\nHowever, because it was not clear in the code or docs that the Chainlink oracle for USD/USDT would not be used in this specific case, the issue should stay a valid Medium imo. With #141 as a duplicate. \n\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0xruhum](https://github.com/sherlock-audit/2023-04-unitasprotocol-judging/issues/48/#issuecomment-1603206309): accepted\n\n**jacksanford1**\n\nAcknowledged by protocol team (won't fix). \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/73",
  "Code": [
    {
      "filename": "Unitas-Protocol/src/SwapFunctions.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport \"./interfaces/ISwapFunctions.sol\";\nimport \"./utils/Errors.sol\";\n\nabstract contract SwapFunctions is ISwapFunctions {\n    using MathUpgradeable for uint256;\n\n    /**\n     * @notice Calculates the swapping result\n     * @param request The struct of required parameters for computing the result\n     * @return amountIn The amount of `tokenIn` to be spent\n     * @return amountOut The amount of `tokenOut` to be obtained\n     * @return fee The amount of fee denominated in `feeToken`\n     */\n    function _calculateSwapResult(SwapRequest memory request)\n        internal\n        view\n        virtual\n        returns (uint256 amountIn, uint256 amountOut, uint256 fee)\n    {\n        _validateFeeFraction(request.feeNumerator, request.feeBase);\n\n        if (request.amountType == AmountType.In) {\n            return _calculateSwapResultByAmountIn(request);\n        } else {\n            return _calculateSwapResultByAmountOut(request);\n        }\n    }\n\n    /**\n     * @notice Calculates the swapping result when `amountType` is `In`\n     * @param request The struct of required parameters for computing the result\n     * @return amountIn The amount of `tokenIn` to be spent\n     * @return amountOut The amount of `tokenOut` to be obtained\n     * @return fee The amount of fee denominated in `feeToken`\n     */\n    function _calculateSwapResultByAmountIn(SwapRequest memory request)\n        internal\n        view\n        virtual\n        returns (uint256 amountIn, uint256 amountOut, uint256 fee)\n    {\n        amountIn = request.amount;\n\n        if (request.tokenIn == request.feeToken) {\n            // When tokenIn is feeToken, subtracts the fee before converting the amount\n            fee = _getFeeByAmountWithFee(amountIn, request.feeNumerator, request.feeBase);\n            amountOut = _convert(\n                request.tokenIn,\n                request.tokenOut,\n                amountIn - fee,\n                MathUpgradeable.Rounding.Down,\n                request.price,\n                request.priceBase,\n                request.quoteToken\n            );\n        } else {\n            // When tokenOut is feeToken, subtracts the fee after converting the amount\n            amountOut = _convert(\n                request.tokenIn,\n                request.tokenOut,\n                amountIn,\n                MathUpgradeable.Rounding.Down,\n                request.price,\n                request.priceBase,\n                request.quoteToken\n            );\n            fee = _getFeeByAmountWithFee(amountOut, request.feeNumerator, request.feeBase);\n            amountOut -= fee;\n        }\n    }\n\n    /**\n     * @notice Calculates the swapping result when `amountType` is `Out`\n     * @param request The struct of required parameters for computing the result\n     * @return amountIn The amount of `tokenIn` to be spent\n     * @return amountOut The amount of `tokenOut` to be obtained\n     * @return fee The amount of fee denominated in `feeToken`\n     */\n    function _calculateSwapResultByAmountOut(SwapRequest memory request)\n        internal\n        view\n        virtual\n        returns (uint256 amountIn, uint256 amountOut, uint256 fee)\n    {\n        amountOut = request.amount;\n\n        if (request.tokenIn == request.feeToken) {\n            // When tokenIn is feeToken, adds the fee after converting the amount\n            amountIn = _convert(\n                request.tokenOut,\n                request.tokenIn,\n                amountOut,\n                MathUpgradeable.Rounding.Up,\n                request.price,\n                request.priceBase,\n                request.quoteToken\n            );\n            fee = _getFeeByAmountWithoutFee(amountIn, request.feeNumerator, request.feeBase);\n            amountIn += fee;\n        } else {\n            // When tokenOut is feeToken, adds the fee before converting the amount\n            fee = _getFeeByAmountWithoutFee(amountOut, request.feeNumerator, request.feeBase);\n            amountIn = _convert(\n                request.tokenOut,\n                request.tokenIn,\n                amountOut + fee,\n                MathUpgradeable.Rounding.Up,\n                request.price,\n                request.priceBase,\n                request.quoteToken\n            );\n        }\n    }\n\n    /**\n     * @notice Reverts if the fee fraction is invalid. A valid swapping fee must be zero or less than the amount.\n     * @param numerator Fee numerator\n     * @param denominator Fee denominator\n     */\n    function _validateFeeFraction(uint256 numerator, uint256 denominator) internal view virtual {\n        _require((numerator == 0 && denominator == 0) || numerator < denominator, Errors.FEE_FRACTION_INVALID);\n    }\n\n    /**\n     * @notice Calculates the fee based on `amount` that includes fee\n     */\n    function _getFeeByAmountWithFee(uint256 amount, uint256 feeNumerator, uint256 feeDenominator)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        if (feeDenominator == 0) {\n            return 0;\n        } else {\n            return (amount * feeNumerator).ceilDiv(feeDenominator);\n        }\n    }\n\n    /**\n     * @notice Calculates the fee based on `amount` that excludes fee\n     */\n    function _getFeeByAmountWithoutFee(uint256 amount, uint256 feeNumerator, uint256 feeDenominator)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        if (feeDenominator == 0) {\n            return 0;\n        } else {\n            uint256 amountWithFee = (amount * feeDenominator).ceilDiv(feeDenominator - feeNumerator);\n            return amountWithFee - amount;\n        }\n    }\n\n    /**\n     * @notice Converts the amount\n     * @param fromToken Address of source token\n     * @param toToken Address of target token\n     * @param fromAmount Amount of `fromToken`\n     * @param rounding Rounding mode to calculate return value\n     * @param price The exchange rate\n     * @param priceBase Ten to the power of the price decimal (10 ** price decimal)\n     * @param quoteToken The quote currency of the price\n     * @return Amount of `toToken`\n     */\n    function _convert(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        MathUpgradeable.Rounding rounding,\n        uint256 price,\n        uint256 priceBase,\n        address quoteToken\n    ) internal view virtual returns (uint256) {\n        if (fromToken == toToken) {\n            return fromAmount;\n        } else if (toToken == quoteToken) {\n            return _convertByFromPrice(fromToken, toToken, fromAmount, rounding, price, priceBase);\n        } else if (fromToken == quoteToken) {\n            return _convertByToPrice(fromToken, toToken, fromAmount, rounding, price, priceBase);\n        } else {\n            _revert(Errors.PARAMETER_INVALID);\n        }\n    }\n\n    /**\n     * @notice Converts the amount when the price is based on `fromToken`\n     * @param fromToken Address of source token\n     * @param toToken Address of target token\n     * @param fromAmount Amount of `fromToken`\n     * @param rounding Rounding mode to calculate return value\n     * @param price The exchange rate of `fromToken`/`toToken`\n     * @param priceBase Ten to the power of the price decimal (10 ** price decimal)\n     * @return Amount of `toToken`\n     */\n    function _convertByFromPrice(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        MathUpgradeable.Rounding rounding,\n        uint256 price,\n        uint256 priceBase\n    ) internal view virtual returns (uint256) {\n        uint256 fromBase = 10 ** IERC20Metadata(fromToken).decimals();\n        uint256 toBase = 10 ** IERC20Metadata(toToken).decimals();\n\n        return fromAmount.mulDiv(price * toBase, priceBase * fromBase, rounding);\n    }\n\n    /**\n     * @notice Converts the amount when the price is based on `toToken`, reverts if `price` is zero.\n     * @param fromToken Address of source token\n     * @param toToken Address of target token\n     * @param fromAmount Amount of `fromToken`\n     * @param rounding Rounding mode to calculate return value\n     * @param price The exchange rate of `toToken`/`fromToken`\n     * @param priceBase Ten to the power of the price decimal (10 ** price decimal)\n     * @return Amount of `toToken`\n     */\n    function _convertByToPrice(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        MathUpgradeable.Rounding rounding,\n        uint256 price,\n        uint256 priceBase\n    ) internal view virtual returns (uint256) {\n        uint256 fromBase = 10 ** IERC20Metadata(fromToken).decimals();\n        uint256 toBase = 10 ** IERC20Metadata(toToken).decimals();\n\n        return fromAmount.mulDiv(priceBase * toBase, price * fromBase, rounding);\n    }\n}"
    },
    {
      "filename": "Unitas-Protocol/src/SwapFunctions.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport \"./interfaces/ISwapFunctions.sol\";\nimport \"./utils/Errors.sol\";\n\nabstract contract SwapFunctions is ISwapFunctions {\n    using MathUpgradeable for uint256;\n\n    /**\n     * @notice Calculates the swapping result\n     * @param request The struct of required parameters for computing the result\n     * @return amountIn The amount of `tokenIn` to be spent\n     * @return amountOut The amount of `tokenOut` to be obtained\n     * @return fee The amount of fee denominated in `feeToken`\n     */\n    function _calculateSwapResult(SwapRequest memory request)\n        internal\n        view\n        virtual\n        returns (uint256 amountIn, uint256 amountOut, uint256 fee)\n    {\n        _validateFeeFraction(request.feeNumerator, request.feeBase);\n\n        if (request.amountType == AmountType.In) {\n            return _calculateSwapResultByAmountIn(request);\n        } else {\n            return _calculateSwapResultByAmountOut(request);\n        }\n    }\n\n    /**\n     * @notice Calculates the swapping result when `amountType` is `In`\n     * @param request The struct of required parameters for computing the result\n     * @return amountIn The amount of `tokenIn` to be spent\n     * @return amountOut The amount of `tokenOut` to be obtained\n     * @return fee The amount of fee denominated in `feeToken`\n     */\n    function _calculateSwapResultByAmountIn(SwapRequest memory request)\n        internal\n        view\n        virtual\n        returns (uint256 amountIn, uint256 amountOut, uint256 fee)\n    {\n        amountIn = request.amount;\n\n        if (request.tokenIn == request.feeToken) {\n            // When tokenIn is feeToken, subtracts the fee before converting the amount\n            fee = _getFeeByAmountWithFee(amountIn, request.feeNumerator, request.feeBase);\n            amountOut = _convert(\n                request.tokenIn,\n                request.tokenOut,\n                amountIn - fee,\n                MathUpgradeable.Rounding.Down,\n                request.price,\n                request.priceBase,\n                request.quoteToken\n            );\n        } else {\n            // When tokenOut is feeToken, subtracts the fee after converting the amount\n            amountOut = _convert(\n                request.tokenIn,\n                request.tokenOut,\n                amountIn,\n                MathUpgradeable.Rounding.Down,\n                request.price,\n                request.priceBase,\n                request.quoteToken\n            );\n            fee = _getFeeByAmountWithFee(amountOut, request.feeNumerator, request.feeBase);\n            amountOut -= fee;\n        }\n    }\n\n    /**\n     * @notice Calculates the swapping result when `amountType` is `Out`\n     * @param request The struct of required parameters for computing the result\n     * @return amountIn The amount of `tokenIn` to be spent\n     * @return amountOut The amount of `tokenOut` to be obtained\n     * @return fee The amount of fee denominated in `feeToken`\n     */\n    function _calculateSwapResultByAmountOut(SwapRequest memory request)\n        internal\n        view\n        virtual\n        returns (uint256 amountIn, uint256 amountOut, uint256 fee)\n    {\n        amountOut = request.amount;\n\n        if (request.tokenIn == request.feeToken) {\n            // When tokenIn is feeToken, adds the fee after converting the amount\n            amountIn = _convert(\n                request.tokenOut,\n                request.tokenIn,\n                amountOut,\n                MathUpgradeable.Rounding.Up,\n                request.price,\n                request.priceBase,\n                request.quoteToken\n            );\n            fee = _getFeeByAmountWithoutFee(amountIn, request.feeNumerator, request.feeBase);\n            amountIn += fee;\n        } else {\n            // When tokenOut is feeToken, adds the fee before converting the amount\n            fee = _getFeeByAmountWithoutFee(amountOut, request.feeNumerator, request.feeBase);\n            amountIn = _convert(\n                request.tokenOut,\n                request.tokenIn,\n                amountOut + fee,\n                MathUpgradeable.Rounding.Up,\n                request.price,\n                request.priceBase,\n                request.quoteToken\n            );\n        }\n    }\n\n    /**\n     * @notice Reverts if the fee fraction is invalid. A valid swapping fee must be zero or less than the amount.\n     * @param numerator Fee numerator\n     * @param denominator Fee denominator\n     */\n    function _validateFeeFraction(uint256 numerator, uint256 denominator) internal view virtual {\n        _require((numerator == 0 && denominator == 0) || numerator < denominator, Errors.FEE_FRACTION_INVALID);\n    }\n\n    /**\n     * @notice Calculates the fee based on `amount` that includes fee\n     */\n    function _getFeeByAmountWithFee(uint256 amount, uint256 feeNumerator, uint256 feeDenominator)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        if (feeDenominator == 0) {\n            return 0;\n        } else {\n            return (amount * feeNumerator).ceilDiv(feeDenominator);\n        }\n    }\n\n    /**\n     * @notice Calculates the fee based on `amount` that excludes fee\n     */\n    function _getFeeByAmountWithoutFee(uint256 amount, uint256 feeNumerator, uint256 feeDenominator)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        if (feeDenominator == 0) {\n            return 0;\n        } else {\n            uint256 amountWithFee = (amount * feeDenominator).ceilDiv(feeDenominator - feeNumerator);\n            return amountWithFee - amount;\n        }\n    }\n\n    /**\n     * @notice Converts the amount\n     * @param fromToken Address of source token\n     * @param toToken Address of target token\n     * @param fromAmount Amount of `fromToken`\n     * @param rounding Rounding mode to calculate return value\n     * @param price The exchange rate\n     * @param priceBase Ten to the power of the price decimal (10 ** price decimal)\n     * @param quoteToken The quote currency of the price\n     * @return Amount of `toToken`\n     */\n    function _convert(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        MathUpgradeable.Rounding rounding,\n        uint256 price,\n        uint256 priceBase,\n        address quoteToken\n    ) internal view virtual returns (uint256) {\n        if (fromToken == toToken) {\n            return fromAmount;\n        } else if (toToken == quoteToken) {\n            return _convertByFromPrice(fromToken, toToken, fromAmount, rounding, price, priceBase);\n        } else if (fromToken == quoteToken) {\n            return _convertByToPrice(fromToken, toToken, fromAmount, rounding, price, priceBase);\n        } else {\n            _revert(Errors.PARAMETER_INVALID);\n        }\n    }\n\n    /**\n     * @notice Converts the amount when the price is based on `fromToken`\n     * @param fromToken Address of source token\n     * @param toToken Address of target token\n     * @param fromAmount Amount of `fromToken`\n     * @param rounding Rounding mode to calculate return value\n     * @param price The exchange rate of `fromToken`/`toToken`\n     * @param priceBase Ten to the power of the price decimal (10 ** price decimal)\n     * @return Amount of `toToken`\n     */\n    function _convertByFromPrice(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        MathUpgradeable.Rounding rounding,\n        uint256 price,\n        uint256 priceBase\n    ) internal view virtual returns (uint256) {\n        uint256 fromBase = 10 ** IERC20Metadata(fromToken).decimals();\n        uint256 toBase = 10 ** IERC20Metadata(toToken).decimals();\n\n        return fromAmount.mulDiv(price * toBase, priceBase * fromBase, rounding);\n    }\n\n    /**\n     * @notice Converts the amount when the price is based on `toToken`, reverts if `price` is zero.\n     * @param fromToken Address of source token\n     * @param toToken Address of target token\n     * @param fromAmount Amount of `fromToken`\n     * @param rounding Rounding mode to calculate return value\n     * @param price The exchange rate of `toToken`/`fromToken`\n     * @param priceBase Ten to the power of the price decimal (10 ** price decimal)\n     * @return Amount of `toToken`\n     */\n    function _convertByToPrice(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        MathUpgradeable.Rounding rounding,\n        uint256 price,\n        uint256 priceBase\n    ) internal view virtual returns (uint256) {\n        uint256 fromBase = 10 ** IERC20Metadata(fromToken).decimals();\n        uint256 toBase = 10 ** IERC20Metadata(toToken).decimals();\n\n        return fromAmount.mulDiv(priceBase * toBase, price * fromBase, rounding);\n    }\n}"
    },
    {
      "filename": "Unitas-Protocol/src/SwapFunctions.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport \"./interfaces/ISwapFunctions.sol\";\nimport \"./utils/Errors.sol\";\n\nabstract contract SwapFunctions is ISwapFunctions {\n    using MathUpgradeable for uint256;\n\n    /**\n     * @notice Calculates the swapping result\n     * @param request The struct of required parameters for computing the result\n     * @return amountIn The amount of `tokenIn` to be spent\n     * @return amountOut The amount of `tokenOut` to be obtained\n     * @return fee The amount of fee denominated in `feeToken`\n     */\n    function _calculateSwapResult(SwapRequest memory request)\n        internal\n        view\n        virtual\n        returns (uint256 amountIn, uint256 amountOut, uint256 fee)\n    {\n        _validateFeeFraction(request.feeNumerator, request.feeBase);\n\n        if (request.amountType == AmountType.In) {\n            return _calculateSwapResultByAmountIn(request);\n        } else {\n            return _calculateSwapResultByAmountOut(request);\n        }\n    }\n\n    /**\n     * @notice Calculates the swapping result when `amountType` is `In`\n     * @param request The struct of required parameters for computing the result\n     * @return amountIn The amount of `tokenIn` to be spent\n     * @return amountOut The amount of `tokenOut` to be obtained\n     * @return fee The amount of fee denominated in `feeToken`\n     */\n    function _calculateSwapResultByAmountIn(SwapRequest memory request)\n        internal\n        view\n        virtual\n        returns (uint256 amountIn, uint256 amountOut, uint256 fee)\n    {\n        amountIn = request.amount;\n\n        if (request.tokenIn == request.feeToken) {\n            // When tokenIn is feeToken, subtracts the fee before converting the amount\n            fee = _getFeeByAmountWithFee(amountIn, request.feeNumerator, request.feeBase);\n            amountOut = _convert(\n                request.tokenIn,\n                request.tokenOut,\n                amountIn - fee,\n                MathUpgradeable.Rounding.Down,\n                request.price,\n                request.priceBase,\n                request.quoteToken\n            );\n        } else {\n            // When tokenOut is feeToken, subtracts the fee after converting the amount\n            amountOut = _convert(\n                request.tokenIn,\n                request.tokenOut,\n                amountIn,\n                MathUpgradeable.Rounding.Down,\n                request.price,\n                request.priceBase,\n                request.quoteToken\n            );\n            fee = _getFeeByAmountWithFee(amountOut, request.feeNumerator, request.feeBase);\n            amountOut -= fee;\n        }\n    }\n\n    /**\n     * @notice Calculates the swapping result when `amountType` is `Out`\n     * @param request The struct of required parameters for computing the result\n     * @return amountIn The amount of `tokenIn` to be spent\n     * @return amountOut The amount of `tokenOut` to be obtained\n     * @return fee The amount of fee denominated in `feeToken`\n     */\n    function _calculateSwapResultByAmountOut(SwapRequest memory request)\n        internal\n        view\n        virtual\n        returns (uint256 amountIn, uint256 amountOut, uint256 fee)\n    {\n        amountOut = request.amount;\n\n        if (request.tokenIn == request.feeToken) {\n            // When tokenIn is feeToken, adds the fee after converting the amount\n            amountIn = _convert(\n                request.tokenOut,\n                request.tokenIn,\n                amountOut,\n                MathUpgradeable.Rounding.Up,\n                request.price,\n                request.priceBase,\n                request.quoteToken\n            );\n            fee = _getFeeByAmountWithoutFee(amountIn, request.feeNumerator, request.feeBase);\n            amountIn += fee;\n        } else {\n            // When tokenOut is feeToken, adds the fee before converting the amount\n            fee = _getFeeByAmountWithoutFee(amountOut, request.feeNumerator, request.feeBase);\n            amountIn = _convert(\n                request.tokenOut,\n                request.tokenIn,\n                amountOut + fee,\n                MathUpgradeable.Rounding.Up,\n                request.price,\n                request.priceBase,\n                request.quoteToken\n            );\n        }\n    }\n\n    /**\n     * @notice Reverts if the fee fraction is invalid. A valid swapping fee must be zero or less than the amount.\n     * @param numerator Fee numerator\n     * @param denominator Fee denominator\n     */\n    function _validateFeeFraction(uint256 numerator, uint256 denominator) internal view virtual {\n        _require((numerator == 0 && denominator == 0) || numerator < denominator, Errors.FEE_FRACTION_INVALID);\n    }\n\n    /**\n     * @notice Calculates the fee based on `amount` that includes fee\n     */\n    function _getFeeByAmountWithFee(uint256 amount, uint256 feeNumerator, uint256 feeDenominator)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        if (feeDenominator == 0) {\n            return 0;\n        } else {\n            return (amount * feeNumerator).ceilDiv(feeDenominator);\n        }\n    }\n\n    /**\n     * @notice Calculates the fee based on `amount` that excludes fee\n     */\n    function _getFeeByAmountWithoutFee(uint256 amount, uint256 feeNumerator, uint256 feeDenominator)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        if (feeDenominator == 0) {\n            return 0;\n        } else {\n            uint256 amountWithFee = (amount * feeDenominator).ceilDiv(feeDenominator - feeNumerator);\n            return amountWithFee - amount;\n        }\n    }\n\n    /**\n     * @notice Converts the amount\n     * @param fromToken Address of source token\n     * @param toToken Address of target token\n     * @param fromAmount Amount of `fromToken`\n     * @param rounding Rounding mode to calculate return value\n     * @param price The exchange rate\n     * @param priceBase Ten to the power of the price decimal (10 ** price decimal)\n     * @param quoteToken The quote currency of the price\n     * @return Amount of `toToken`\n     */\n    function _convert(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        MathUpgradeable.Rounding rounding,\n        uint256 price,\n        uint256 priceBase,\n        address quoteToken\n    ) internal view virtual returns (uint256) {\n        if (fromToken == toToken) {\n            return fromAmount;\n        } else if (toToken == quoteToken) {\n            return _convertByFromPrice(fromToken, toToken, fromAmount, rounding, price, priceBase);\n        } else if (fromToken == quoteToken) {\n            return _convertByToPrice(fromToken, toToken, fromAmount, rounding, price, priceBase);\n        } else {\n            _revert(Errors.PARAMETER_INVALID);\n        }\n    }\n\n    /**\n     * @notice Converts the amount when the price is based on `fromToken`\n     * @param fromToken Address of source token\n     * @param toToken Address of target token\n     * @param fromAmount Amount of `fromToken`\n     * @param rounding Rounding mode to calculate return value\n     * @param price The exchange rate of `fromToken`/`toToken`\n     * @param priceBase Ten to the power of the price decimal (10 ** price decimal)\n     * @return Amount of `toToken`\n     */\n    function _convertByFromPrice(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        MathUpgradeable.Rounding rounding,\n        uint256 price,\n        uint256 priceBase\n    ) internal view virtual returns (uint256) {\n        uint256 fromBase = 10 ** IERC20Metadata(fromToken).decimals();\n        uint256 toBase = 10 ** IERC20Metadata(toToken).decimals();\n\n        return fromAmount.mulDiv(price * toBase, priceBase * fromBase, rounding);\n    }\n\n    /**\n     * @notice Converts the amount when the price is based on `toToken`, reverts if `price` is zero.\n     * @param fromToken Address of source token\n     * @param toToken Address of target token\n     * @param fromAmount Amount of `fromToken`\n     * @param rounding Rounding mode to calculate return value\n     * @param price The exchange rate of `toToken`/`fromToken`\n     * @param priceBase Ten to the power of the price decimal (10 ** price decimal)\n     * @return Amount of `toToken`\n     */\n    function _convertByToPrice(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        MathUpgradeable.Rounding rounding,\n        uint256 price,\n        uint256 priceBase\n    ) internal view virtual returns (uint256) {\n        uint256 fromBase = 10 ** IERC20Metadata(fromToken).decimals();\n        uint256 toBase = 10 ** IERC20Metadata(toToken).decimals();\n\n        return fromAmount.mulDiv(priceBase * toBase, price * fromBase, rounding);\n    }\n}"
    },
    {
      "filename": "Unitas-Protocol/src/Unitas.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport \"./interfaces/IERC20Token.sol\";\nimport \"./interfaces/IInsurancePool.sol\";\nimport \"./interfaces/IOracle.sol\";\nimport \"./interfaces/IUnitas.sol\";\nimport \"./utils/AddressUtils.sol\";\nimport \"./utils/Errors.sol\";\nimport \"./utils/ScalingUtils.sol\";\nimport \"./SwapFunctions.sol\";\nimport \"./PoolBalances.sol\";\n\n/**\n * @title Unitas\n * @notice This contract is primarily used for exchanging tokens and managing reserve assets\n */\ncontract Unitas is\n    Initializable,\n    PausableUpgradeable,\n    AccessControlUpgradeable,\n    ReentrancyGuardUpgradeable,\n    IUnitas,\n    PoolBalances,\n    SwapFunctions\n{\n    using MathUpgradeable for uint256;\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\");\n    bytes32 public constant GUARDIAN_ROLE = keccak256(\"GUARDIAN_ROLE\");\n    bytes32 public constant TIMELOCK_ROLE = keccak256(\"TIMELOCK_ROLE\");\n    bytes32 public constant PORTFOLIO_ROLE = keccak256(\"PORTFOLIO_ROLE\");\n\n    IOracle public oracle;\n    address public surplusPool;\n    address public insurancePool;\n    ITokenManager public tokenManager;\n\n    /**\n     * @notice Emitted when `oracle` is updated\n     */\n    event SetOracle(address indexed newOracle);\n    /**\n     * @notice Emitted when `surplusPool` is updated\n     */\n    event SetSurplusPool(address indexed newSurplusPool);\n    /**\n     * @notice Emitted when `insurancePool` is updated\n     */\n    event SetInsurancePool(address indexed newInsurancePool);\n    /**\n     * @notice Emitted when `tokenManager` is updated\n     */\n    event SetTokenManager(ITokenManager indexed newTokenManager);\n    /**\n     * @notice Emitted when `sender` swap tokens\n     */\n    event Swapped(\n        address indexed tokenIn,\n        address indexed tokenOut,\n        address indexed sender,\n        uint256 amountIn,\n        uint256 amountOut,\n        address feeToken,\n        uint256 fee,\n        uint24 feeNumerator,\n        uint256 price\n    );\n    /**\n     * @notice Emitted when swapping `fee` is sent to `receiver`\n     */\n    event SwapFeeSent(address indexed feeToken, address indexed receiver, uint256 fee);\n\n    // ============================== ERRORS ==============================\n\n    error NotTimelock(address caller);\n    error NotGuardian(address caller);\n    error NotPortfolio(address caller);\n\n    // ============================== MODIFIERS ==============================\n\n    /**\n     * @notice Reverts if `msg.sender` does not have `TIMELOCK_ROLE`\n     */\n    modifier onlyTimelock() {\n        if (!hasRole(TIMELOCK_ROLE, msg.sender))\n            revert NotTimelock(msg.sender);\n        _;\n    }\n\n    /**\n     * @notice Reverts if `msg.sender` does not have `GUARDIAN_ROLE`\n     */\n    modifier onlyGuardian() {\n        if (!hasRole(GUARDIAN_ROLE, msg.sender))\n            revert NotGuardian(msg.sender);\n        _;\n    }\n\n    /**\n     * @notice Reverts if `account` does not have `PORTFOLIO_ROLE`\n     */\n    modifier onlyPortfolio(address account) {\n        if (!hasRole(PORTFOLIO_ROLE, account)) {\n            revert NotPortfolio(account);\n        }\n        _;\n    }\n\n\n    // ============================== CONSTRUCTOR ==============================\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializes the contract\n     * @param config_ `InitializeConfig` to init states\n     */\n    function initialize(InitializeConfig calldata config_) public initializer {\n        __Pausable_init();\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n        _setRoleAdmin(GOVERNOR_ROLE, GOVERNOR_ROLE);\n        _setRoleAdmin(GUARDIAN_ROLE, GUARDIAN_ROLE);\n        _setRoleAdmin(TIMELOCK_ROLE, GOVERNOR_ROLE);\n        _setRoleAdmin(PORTFOLIO_ROLE, GUARDIAN_ROLE);\n\n        _grantRole(GOVERNOR_ROLE, config_.governor);\n        _grantRole(GUARDIAN_ROLE, config_.guardian);\n        _grantRole(TIMELOCK_ROLE, config_.timelock);\n        _grantRole(PORTFOLIO_ROLE, config_.guardian);\n\n        _setOracle(config_.oracle);\n        _setSurplusPool(config_.surplusPool);\n        _setInsurancePool(config_.insurancePool);\n        _setTokenManager(config_.tokenManager);\n    }\n\n    // ============================== Timelock FUNCTIONS ===========================\n\n    /**\n     * @notice Updates the address of `oracle` by `newOracle`\n     */\n    function setOracle(address newOracle) external onlyTimelock {\n        _setOracle(newOracle);\n    }\n\n    /**\n     * @notice Updates the address of `surplusPool` by `newSurplusPool`\n     */\n    function setSurplusPool(address newSurplusPool) external onlyTimelock {\n        _setSurplusPool(newSurplusPool);\n    }\n\n    /**\n     * @notice Updates the address of `insurancePool` by `newInsurancePool`\n     */\n    function setInsurancePool(address newInsurancePool) external onlyTimelock {\n        _setInsurancePool(newInsurancePool);\n    }\n\n    /**\n     * @notice Updates the address of `tokenManager`\n     */\n    function setTokenManager(ITokenManager newTokenManager) external onlyTimelock {\n        _setTokenManager(newTokenManager);\n    }\n\n    // ============================== GUARDIAN FUNCTIONS ===========================\n\n    /**\n     * @notice Pause token swapping\n     */\n    function paus"
    }
  ]
}