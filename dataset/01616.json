{
  "Title": "M-4: lockQuote() increaseNonce parameters do not work properly",
  "Content": "# Issue M-4: lockQuote() increaseNonce parameters do not work properly \n\nSource: https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/123 \n\n## Found by \nJuntao, Viktor\\_Cortess, bin2chen, cergyk, kutugu, n1punp, nobody2018, rvierdiiev, xiaoming90\n## Summary\nin `lockQuote()` will execute `partyBNonces[quote.partyB][quote.partyA] += 1` if increaseNonce == true\nBut this operation is executed before setting `quote.partyB`, resulting in actually setting `partyBNonces[address(0)][quote.partyA] += 1`\n\n## Vulnerability Detail\nin `lockQuote()`  , when execute `partyBNonces[quote.partyB][quote.partyA] += 1` , `quote.paryB` is address(0)\n\n```solidity\n    function lockQuote(uint256 quoteId, SingleUpnlSig memory upnlSig, bool increaseNonce) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        LibMuon.verifyPartyBUpnl(upnlSig, msg.sender, quote.partyA);\n        checkPartyBValidationToLockQuote(quoteId, upnlSig.upnl);\n        if (increaseNonce) {\n@>          accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        }\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.LOCKED;\n@>      quote.partyB = msg.sender;\n        // lock funds for partyB\n        accountLayout.partyBPendingLockedBalances[msg.sender][quote.partyA].addQuote(quote);\n        quoteLayout.partyBPendingQuotes[msg.sender][quote.partyA].push(quote.id);\n    }\n```\n\nactually setting `partyBNonces[address(0)][quote.partyA] += 1` \n\n\n\n## Impact\n\n increaseNonce parameters do not work properly\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/PartyB/PartyBFacetImpl.sol#L29-L38\n\n## Tool used\n\nManual Review\n\n## Recommendation\n```solidity\n    function lockQuote(uint256 quoteId, SingleUpnlSig memory upnlSig, bool increaseNonce) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        LibMuon.verifyPartyBUpnl(upnlSig, msg.sender, quote.partyA);\n        checkPartyBValidationToLockQuote(quoteId, upnlSig.upnl);\n        if (increaseNonce) {\n-           accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n+           accountLayout.partyBNonces[msg.sender][quote.partyA] += 1;\n        }\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.LOCKED;\n        quote.partyB = msg.sender;\n        // lock funds for partyB\n        accountLayout.partyBPendingLockedBalances[msg.sender][quote.partyA].addQuote(quote);\n        quoteLayout.partyBPendingQuotes[msg.sender][quote.partyA].push(quote.id);\n    }\n```\n\n\n\n## Discussion\n\n**MoonKnightDev**\n\nThe Party B can lock the quotes of only one Party A with a single signature and it cannot even open all of them. The sole repercussion would be the locking of the user's quotes. so we don't consider it as \"High\"\n\n**MoonKnightDev**\n\nFixed code PR link:\nhttps://github.com/SYMM-IO/symmio-core/pull/5\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/85",
  "Code": [
    {
      "filename": "symmio-core/contracts/facets/PartyB/PartyBFacetImpl.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../libraries/LibLockedValues.sol\";\nimport \"../../libraries/LibMuon.sol\";\nimport \"../../libraries/LibAccount.sol\";\nimport \"../../libraries/LibSolvency.sol\";\nimport \"../../libraries/LibQuote.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/QuoteStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../storages/GlobalAppStorage.sol\";\nimport \"../../storages/AccountStorage.sol\";\nimport \"../../storages/SymbolStorage.sol\";\n\nlibrary PartyBFacetImpl {\n    using LockedValuesOps for LockedValues;\n\n    function lockQuote(uint256 quoteId, SingleUpnlSig memory upnlSig, bool increaseNonce) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        LibMuon.verifyPartyBUpnl(upnlSig, msg.sender, quote.partyA);\n        checkPartyBValidationToLockQuote(quoteId, upnlSig.upnl);\n        if (increaseNonce) {\n            accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        }\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.LOCKED;\n        quote.partyB = msg.sender;\n        // lock funds for partyB\n        accountLayout.partyBPendingLockedBalances[msg.sender][quote.partyA].addQuote(quote);\n        quoteLayout.partyBPendingQuotes[msg.sender][quote.partyA].push(quote.id);\n    }\n\n    function unlockQuote(uint256 quoteId) internal returns (QuoteStatus) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        require(quote.quoteStatus == QuoteStatus.LOCKED, \"PartyBFacet: Invalid state\");\n        if (block.timestamp > quote.deadline) {\n            QuoteStatus result = LibQuote.expireQuote(quoteId);\n            return result;\n        } else {\n            accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n            quote.modifyTimestamp = block.timestamp;\n            quote.quoteStatus = QuoteStatus.PENDING;\n            accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(quote);\n            LibQuote.removeFromPartyBPendingQuotes(quote);\n            quote.partyB = address(0);\n            return QuoteStatus.PENDING;\n        }\n    }\n\n    function acceptCancelRequest(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        require(quote.quoteStatus == QuoteStatus.CANCEL_PENDING, \"PartyBFacet: Invalid state\");\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.CANCELED;\n        accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n        accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(quote);\n        // send trading Fee back to partyA\n        LibQuote.returnTradingFee(quoteId);\n\n        LibQuote.removeFromPendingQuotes(quote);\n    }\n\n    function checkPartyBValidationToLockQuote(uint256 quoteId, int256 upnl) internal view {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        require(quote.quoteStatus == QuoteStatus.PENDING, \"PartyBFacet: Invalid state\");\n        require(block.timestamp <= quote.deadline, \"PartyBFacet: Quote is expired\");\n        require(quoteId <= quoteLayout.lastId, \"PartyBFacet: Invalid quoteId\");\n        int256 availableBalance = LibAccount.partyBAvailableForQuote(\n            upnl,\n            msg.sender,\n            quote.partyA\n        );\n        require(availableBalance >= 0, \"PartyBFacet: Available balance is lower than zero\");\n        require(\n            uint256(availableBalance) >= quote.lockedValues.total(),\n            \"PartyBFacet: insufficient available balance\"\n        );\n        require(\n            !maLayout.partyBLiquidationStatus[msg.sender][quote.partyA],\n            \"PartyBFacet: PartyB isn't solvent\"\n        );\n        bool isValidPartyB;\n        if (quote.partyBsWhiteList.length == 0) {\n            require(msg.sender != quote.partyA, \"PartyBFacet: PartyA can't be partyB too\");\n            isValidPartyB = true;\n        } else {\n            for (uint8 index = 0; index < quote.partyBsWhiteList.length; index++) {\n                if (msg.sender == quote.partyBsWhiteList[index]) {\n                    isValidPartyB = true;\n                    break;\n                }\n            }\n        }\n        require(isValidPartyB, \"PartyBFacet: Sender isn't whitelisted\");\n    }\n\n    function openPosition(\n        uint256 quoteId,\n        uint256 filledAmount,\n        uint256 openedPrice,\n        PairUpnlAndPriceSig memory upnlSig\n    ) internal returns (uint256 currentId) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        require(\n            quote.quoteStatus == QuoteStatus.LOCKED ||\n            quote.quoteStatus == QuoteStatus.CANCEL_PENDING,\n            \"PartyBFacet: Invalid state\"\n        );\n        require(block.timestamp <= quote.deadline, \"PartyBFacet: Quote is expired\");\n        if (quote.orderType == OrderType.LIMIT) {\n            require(\n                quote.quantity >= filledAmount && filledAmount > 0,\n                \"PartyBFacet: Invalid filledAmount\"\n            );\n        } else {\n            require(quote.quantity == filledAmount, \"PartyBFacet: Invalid filledAmount\");\n        }\n        if (quote.positionType == PositionType.LONG) {\n            require(\n                openedPrice <= quote.requestedOpenPrice,\n                \"PartyBFacet: Opened price isn't valid\"\n            );\n        } else {\n            require(\n                openedPrice >= quote.requestedOpenPrice,\n                \"PartyBFacet: Opened price isn't valid\"\n            );\n        }\n        LibMuon.verifyPairUpnlAndPrice(upnlSig, quote.partyB, quote.partyA, quote.symbolId);\n\n        quote.openedPrice = openedPrice;\n        LibSolvency.isSolventAfterOpenPosition(quoteId, filledAmount, upnlSig);\n\n        accountLayout.partyANonces[quote.partyA] += 1;\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n\n        LibQuote.removeFromPendingQuotes(quote);\n\n        if (quote.quantity == filledAmount) {\n            accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n            accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(quote);\n\n            if (quote.orderType == OrderType.LIMIT) {\n                quote.lockedValues.mul(openedPrice).div(quote.requestedOpenPrice);\n            }\n            accountLayout.lockedBalances[quote.partyA].addQuote(quote);\n            accountLayout.partyBLockedBalances[quote.partyB][quote.partyA].addQuote(quote);\n        }\n        // partially fill\n        else {\n            currentId = ++quoteLayout.lastId;\n            QuoteStatus newStatus;\n            if (quote.quoteStatus == QuoteStatus.CANCEL_PENDING) {\n                newStatus = QuoteStatus.CANCELED;\n            } else {\n                newStatus = QuoteStatus.PENDING;\n                quoteLayout.partyAPendingQuotes[quote.partyA].push(currentId);\n            }\n            LockedValues memory filledLockedValues = LockedValues(\n                (quote.lockedValues.cva * filledAmount) / quote.quantity,\n                (quote.lockedValues.mm * filledAmount) / quote.quantity,\n                (quote.lockedValues.lf * filledAmount) / quote.quantity\n            );\n            LockedValues memory appliedFilledLockedValues = filledLockedValues;\n            appliedFilledLockedValues = appliedFilledLockedValues.mulMem(openedPrice);\n            appliedFilledLockedValues = appliedFilledLockedValues.divMem(quote.requestedOpenPrice);\n            // check that opened position is not minor position\n            require(\n                appliedFilledLockedValues.total() >=\n                SymbolStorage.layout().symbols[quote.symbolId].minAcceptableQuoteValue,\n                \"PartyBFacet: Quote value is low\"\n            );\n            // check that new pending position is not minor position\n            require(\n                (quote.lockedValues.total() - filledLockedValues.total()) >=\n                SymbolStorage.layout().symbols[quote.symbolId].minAcceptableQuoteValue,\n                \"PartyBFacet: Quote value is low\"\n            );\n\n            Quote memory q = Quote({\n                id: currentId,\n                partyBsWhiteList: quote.partyBsWhiteList,\n                symbolId: quote.symbolId,\n                positionType: quote.positionType,\n                orderType: quote.orderType,\n                openedPrice: 0,\n                requestedOpenPrice: quote.requestedOpenPrice,\n                marketPrice: quote.marketPrice,\n                quantity: quote.quantity - filledAmount,\n                closedAmount: 0,\n                lockedValues: LockedValues(0, 0, 0),\n                initialLockedValues: LockedValues(0, 0, 0),\n                maxInterestRate: quote.maxInterestRate,\n                partyA: quote.partyA,\n                partyB: address(0),\n                quoteStatus: newStatus,\n                avgClosedPrice: 0,\n                requestedClosePrice: 0,\n                parentId: quote.id,\n                createTimestamp: quote.createTimestamp,\n                modifyTimestamp: block.timestamp,\n                quantityToClose: 0,\n                deadline: quote.deadline\n            });\n\n            quoteLayout.quoteIdsOf[quote.partyA].push(currentId);\n            quoteLayout.quotes[currentId] = q;\n            Quote storage newQuote = quoteLayout.quotes[currentId];\n\n            if (newStatus == QuoteStatus.CANCELED) {\n                // send trading Fee back to partyA\n                LibQuote.returnTradingFee(currentId);\n                // part of quote has been filled and part of it has been canceled\n                accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n                accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(\n                    quote\n                );\n            } else {\n                accountLayout.pendingLockedBalances[quote.partyA].sub(filledLockedValues);\n                accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].sub(\n                    filledLockedValues\n                );\n            }\n            newQuote.lockedValues = quote.lockedValues.sub(filledLockedValues);\n            newQuote.initialLockedValues = newQuote.lockedValues;\n            quote.quantity = filledAmount;\n            quote.lockedValues = appliedFilledLockedValues;\n\n            // lock with amount of filledAmount\n            accountLayout.lockedBalances[quote.partyA].addQuote(quote);\n            accountLayout.partyBLockedBalances[quote.partyB][quote.partyA].addQuote(quote);\n        }\n        quote.quoteStatus = QuoteStatus.OPENED;\n        LibQuote.addToOpenPositions(quoteId);\n    }\n\n    function fillCloseRequest(\n        uint256 quoteId,\n        uint256 filledAmount,\n        uint256 closedPrice,\n        PairUpnlAndPriceSig memory upnlSig\n    ) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        require(\n            quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n            \"PartyBFacet: Invalid state\"\n        );\n        require(block.timestamp <= quote.deadline, \"PartyBFacet: Quote is expired\");\n        if (quote.positionType == PositionType.LONG) {\n            require(\n                closedPrice >= quote.requestedClosePrice,\n                \"PartyBFacet: Closed price isn't valid\"\n            );\n        } else {\n            require(\n                closedPrice <= quote.requestedClosePrice,\n                \"PartyBFacet: Closed price isn't valid\"\n            );\n        }\n        if (quote.orderType == OrderType.LIMIT) {\n            require(quote.quantityToClose >= filledAmount, \"PartyBFacet: Invalid filledAmount\");\n        } else {\n            require(quote.quantityToClose == filledAmount, \"PartyBFacet: Invalid filledAmount\");\n        }\n\n        LibMuon.verifyPairUpnlAndPrice(upnlSig, quote.partyB, quote.partyA, quote.symbolId);\n        LibSolvency.isSolventAfterClosePosition(quoteId, filledAmount, closedPrice, upnlSig);\n\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        accountLayout.partyANonces[quote.partyA] += 1;\n        LibQuote.closeQuote(quote, filledAmount, closedPrice);\n    }\n\n    function acceptCancelCloseRequest(uint256 quoteId) internal {\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n            \"PartyBFacet: Invalid state\"\n        );\n        AccountStorage.layout().partyBNonces[quote.partyB][quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.OPENED;\n        quote.requestedClosePrice = 0;\n        quote.quantityToClose = 0;\n    }\n\n    function emergencyClosePosition(uint256 quoteId, PairUpnlAndPriceSig memory upnlSig) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        require(quote.quoteStatus == QuoteStatus.OPENED, \"PartyBFacet: Invalid state\");\n        LibMuon.verifyPairUpnlAndPrice(upnlSig, quote.partyB, quote.partyA, quote.symbolId);\n        uint256 filledAmount = LibQuote.quoteOpenAmount(quote);\n        quote.quantityToClose = filledAmount;\n        quote.requestedClosePrice = upnlSig.price;\n        LibSolvency.isSolventAfterClosePosition(quoteId, filledAmount, upnlSig.price, upnlSig);\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        accountLayout.partyANonces[quote.partyA] += 1;\n        LibQuote.closeQuote(quote, filledAmount, upnlSig.price);\n    }\n\n}"
    }
  ]
}