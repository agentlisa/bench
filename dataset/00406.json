{
  "Title": "H-1: Unverified `_srcChainSender` parameter allows to impersonate the sender",
  "Content": "# Issue H-1: Unverified `_srcChainSender` parameter allows to impersonate the sender \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/14 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nComposableSecurity, bin2chen, cccz, cergyk\n## Summary\n\nThe `_toeComposeReceiver` function accepts the `_srcChainSender` parameter that represents the sender of cross-chain message (via LayerZero's OFT) on the source chain. The function executes modules depending on the `_msgType` parameter and some of them do not accept the `_srcChainSender` parameter. Lack of verification for `_srcChainSender` means that the attacker can execute those modules on behalf of different users.\n\n## Vulnerability Detail\n\nThe `_toeComposeReceiver` function is called by the LayerZero endpoint (indirectly) when there is a compose message to be executed. It gets three parameters:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/usdo/modules/UsdoReceiver.sol#L63-L100\n\nThe first patameter (`_msgType`) represents the type of message that should be executed on the destination chain. The second (`_srcChainSender`) is the sender of the message on the source chain and last one (`_toeComposeMsg`) contains the parameters for the executed operation.\n\nIn case of `MSG_TAP_EXERCISE` the `_srcChainSender` parameter is forwarded to the `UsdoOptionReceiver` module:\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/usdo/modules/UsdoReceiver.sol#L68-L75\n\nIn case of other types (`MSG_MARKET_REMOVE_ASSET`, `MSG_YB_SEND_SGL_LEND_OR_REPAY` and `MSG_DEPOSIT_LEND_AND_SEND_FOR_LOCK`) the `_srcChainSender` parameter is not forwarder and the attacker fully control the contents of `_toeComposeMsg`.\n\n**Let's take the `MSG_MARKET_REMOVE_ASSET` message as an example.**\n\n1. The `removeAssetReceiver` function from `UsdoMarketReceiverModule` is executed with `_toeComposeMsg` parameter.\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/usdo/modules/UsdoMarketReceiverModule.sol#L210-L241\n\n2. The `_toeComposeMsg` bytes (called `_data` in this function) are decoded and some values are extracted. The most important are: \n* `msg_.externalData.magnetar` on which the `burst` function is later called with specific magnetar calls (it is legitimate and whitelisted magnetar),\n* `msg_.user` on whose behalf the further operation is called,\n* `msg_.externalData` which is forwarder to further call,\n* `msg_.removeAndRepayData` which is forwarder to further call.\n\nThose parameters are used to prepare a call to `exitPositionAndRemoveCollateral` function from `OptionModule` module (defined in action's `id` param). \n\n3. Next, the `burst` function from magnetar contract is called and it executes the specific module depending on the `_action.id`:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/gitmodule/tapioca-periph/contracts/Magnetar/Magnetar.sol#L138-L141\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/gitmodule/tapioca-periph/contracts/Magnetar/modules/MagnetarOptionModule.sol#L58-L210\n\n4. The modules validates the sender passing the user address as the parameter.\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/gitmodule/tapioca-periph/contracts/Magnetar/modules/MagnetarOptionModule.sol#L60\n\n5. The `_checkSender` function does not revert if the user is the sender or the sender is whitelisted.\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/gitmodule/tapioca-periph/contracts/Magnetar/MagnetarStorage.sol#L93-L97\n\n6. In this case the sender is USDO contract which is whitelisted. This allows to continue operations from `exitPositionAndRemoveCollateral` function on behalf of the user (who is the victim).\n\n**Note:** *This is only one of possible attack scenarios that exploits lack of `_srcChainSender` parameter validation.*\n\n## Impact\n\nHIGH - The attacker can execute functions from `UsdoMarketReceiverModule` module on behalf of any user. \n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/usdo/modules/UsdoReceiver.sol#L79\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/usdo/modules/UsdoReceiver.sol#L85\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/usdo/modules/UsdoReceiver.sol#L92\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/contracts/tOFT/modules/BaseTOFTReceiver.sol#L70\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/contracts/tOFT/modules/BaseTOFTReceiver.sol#L76\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/contracts/tOFT/modules/BaseTOFTReceiver.sol#L98\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nValidate whether the user whose assets are being managed is the same address as the `_srcChainSender` parameter. \n\n\n\n## Discussion\n\n**nevillehuang**\n\n@0xRektora @maarcweiss \n\nDo you guys thinks this is a dupe of #111?\n\n**cryptotechmaker**\n\n@nevillehuang I think it's a dupe of https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/109 for which I submitted a fix already\n\nIt doesn't seem to be duplicate of #111 \n\n**nevillehuang**\n\n@cryptotechmaker Yes agree.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "Tapioca-bar/contracts/usdo/modules/UsdoReceiver.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// LZ\nimport {OFTMsgCodec} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTMsgCodec.sol\";\nimport {OFTCore} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/OFTCore.sol\";\nimport {Origin} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol\";\nimport {OFT} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/OFT.sol\";\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Tapioca\nimport {\n    IUsdo,\n    UsdoInitStruct,\n    YieldBoxApproveAllMsg,\n    MarketPermitActionMsg,\n    YieldBoxApproveAssetMsg\n} from \"tapioca-periph/interfaces/oft/IUsdo.sol\";\nimport {TapiocaOmnichainReceiver} from \"tapioca-periph/tapiocaOmnichainEngine/TapiocaOmnichainReceiver.sol\";\nimport {UsdoMarketReceiverModule} from \"./UsdoMarketReceiverModule.sol\";\nimport {UsdoOptionReceiverModule} from \"./UsdoOptionReceiverModule.sol\";\nimport {UsdoReceiver} from \"./UsdoReceiver.sol\";\nimport {BaseUsdo} from \"../BaseUsdo.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract UsdoReceiver is BaseUsdo, TapiocaOmnichainReceiver {\n    using OFTMsgCodec for bytes;\n    using OFTMsgCodec for bytes32;\n    using SafeERC20 for IERC20;\n\n    error InvalidApprovalTarget(address _target);\n\n    constructor(UsdoInitStruct memory _data) BaseUsdo(_data) {}\n\n    /**\n     * @inheritdoc TapiocaOmnichainReceiver\n     */\n    function _lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor, /*_executor*/ // @dev unused in the default implementation.\n        bytes calldata _extraData /*_extraData*/ // @dev unused in the default implementation.\n    ) internal virtual override(OFTCore, TapiocaOmnichainReceiver) {\n        TapiocaOmnichainReceiver._lzReceive(_origin, _guid, _message, _executor, _extraData);\n    }\n\n    /**\n     * @inheritdoc TapiocaOmnichainReceiver\n     */\n    function _toeComposeReceiver(uint16 _msgType, address _srcChainSender, bytes memory _toeComposeMsg)\n        internal\n        override\n        returns (bool success)\n    {\n        if (_msgType == MSG_TAP_EXERCISE) {\n            _executeModule(\n                uint8(IUsdo.Module.UsdoOptionReceiver),\n                abi.encodeWithSelector(\n                    UsdoOptionReceiverModule.exerciseOptionsReceiver.selector, _srcChainSender, _toeComposeMsg\n                ),\n                false\n            );\n        } else if (_msgType == MSG_MARKET_REMOVE_ASSET) {\n            _executeModule(\n                uint8(IUsdo.Module.UsdoMarketReceiver),\n                abi.encodeWithSelector(UsdoMarketReceiverModule.removeAssetReceiver.selector, _toeComposeMsg),\n                false\n            );\n        } else if (_msgType == MSG_YB_SEND_SGL_LEND_OR_REPAY) {\n            _executeModule(\n                uint8(IUsdo.Module.UsdoMarketReceiver),\n                abi.encodeWithSelector(UsdoMarketReceiverModule.lendOrRepayReceiver.selector, _toeComposeMsg),\n                false\n            );\n        } else if (_msgType == MSG_DEPOSIT_LEND_AND_SEND_FOR_LOCK) {\n            _executeModule(\n                uint8(IUsdo.Module.UsdoMarketReceiver),\n                abi.encodeWithSelector(\n                    UsdoMarketReceiverModule.depositLendAndSendForLockingReceiver.selector, _toeComposeMsg\n                ),\n                false\n            );\n        } else {\n            return false;\n        }\n        return true;\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/usdo/modules/UsdoReceiver.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// LZ\nimport {OFTMsgCodec} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTMsgCodec.sol\";\nimport {OFTCore} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/OFTCore.sol\";\nimport {Origin} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol\";\nimport {OFT} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/OFT.sol\";\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Tapioca\nimport {\n    IUsdo,\n    UsdoInitStruct,\n    YieldBoxApproveAllMsg,\n    MarketPermitActionMsg,\n    YieldBoxApproveAssetMsg\n} from \"tapioca-periph/interfaces/oft/IUsdo.sol\";\nimport {TapiocaOmnichainReceiver} from \"tapioca-periph/tapiocaOmnichainEngine/TapiocaOmnichainReceiver.sol\";\nimport {UsdoMarketReceiverModule} from \"./UsdoMarketReceiverModule.sol\";\nimport {UsdoOptionReceiverModule} from \"./UsdoOptionReceiverModule.sol\";\nimport {UsdoReceiver} from \"./UsdoReceiver.sol\";\nimport {BaseUsdo} from \"../BaseUsdo.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract UsdoReceiver is BaseUsdo, TapiocaOmnichainReceiver {\n    using OFTMsgCodec for bytes;\n    using OFTMsgCodec for bytes32;\n    using SafeERC20 for IERC20;\n\n    error InvalidApprovalTarget(address _target);\n\n    constructor(UsdoInitStruct memory _data) BaseUsdo(_data) {}\n\n    /**\n     * @inheritdoc TapiocaOmnichainReceiver\n     */\n    function _lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor, /*_executor*/ // @dev unused in the default implementation.\n        bytes calldata _extraData /*_extraData*/ // @dev unused in the default implementation.\n    ) internal virtual override(OFTCore, TapiocaOmnichainReceiver) {\n        TapiocaOmnichainReceiver._lzReceive(_origin, _guid, _message, _executor, _extraData);\n    }\n\n    /**\n     * @inheritdoc TapiocaOmnichainReceiver\n     */\n    function _toeComposeReceiver(uint16 _msgType, address _srcChainSender, bytes memory _toeComposeMsg)\n        internal\n        override\n        returns (bool success)\n    {\n        if (_msgType == MSG_TAP_EXERCISE) {\n            _executeModule(\n                uint8(IUsdo.Module.UsdoOptionReceiver),\n                abi.encodeWithSelector(\n                    UsdoOptionReceiverModule.exerciseOptionsReceiver.selector, _srcChainSender, _toeComposeMsg\n                ),\n                false\n            );\n        } else if (_msgType == MSG_MARKET_REMOVE_ASSET) {\n            _executeModule(\n                uint8(IUsdo.Module.UsdoMarketReceiver),\n                abi.encodeWithSelector(UsdoMarketReceiverModule.removeAssetReceiver.selector, _toeComposeMsg),\n                false\n            );\n        } else if (_msgType == MSG_YB_SEND_SGL_LEND_OR_REPAY) {\n            _executeModule(\n                uint8(IUsdo.Module.UsdoMarketReceiver),\n                abi.encodeWithSelector(UsdoMarketReceiverModule.lendOrRepayReceiver.selector, _toeComposeMsg),\n                false\n            );\n        } else if (_msgType == MSG_DEPOSIT_LEND_AND_SEND_FOR_LOCK) {\n            _executeModule(\n                uint8(IUsdo.Module.UsdoMarketReceiver),\n                abi.encodeWithSelector(\n                    UsdoMarketReceiverModule.depositLendAndSendForLockingReceiver.selector, _toeComposeMsg\n                ),\n                false\n            );\n        } else {\n            return false;\n        }\n        return true;\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/usdo/modules/UsdoMarketReceiverModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n// Tapioca\nimport {UsdoInitStruct, MarketRemoveAssetMsg, MarketLendOrRepayMsg} from \"tapioca-periph/interfaces/oft/IUsdo.sol\";\nimport {IDepositData, ICommonExternalContracts} from \"tapioca-periph/interfaces/common/ICommonData.sol\";\nimport {\n    IMagnetar,\n    MagnetarCall,\n    MagnetarAction,\n    DepositRepayAndRemoveCollateralFromMarketData,\n    MintFromBBAndLendOnSGLData,\n    ExitPositionAndRemoveCollateralData,\n    DepositAndSendForLockingData\n} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {MagnetarOptionModule} from \"tapioca-periph/Magnetar/modules/MagnetarOptionModule.sol\";\nimport {MagnetarAssetXChainModule} from \"tapioca-periph/Magnetar/modules/MagnetarAssetXChainModule.sol\";\nimport {MagnetarAssetModule} from \"tapioca-periph/Magnetar/modules/MagnetarAssetModule.sol\";\nimport {MagnetarMintModule} from \"tapioca-periph/Magnetar/modules/MagnetarMintModule.sol\";\nimport {IMagnetarHelper} from \"tapioca-periph/interfaces/periph/IMagnetarHelper.sol\";\nimport {IMintData} from \"tapioca-periph/interfaces/oft/IUsdo.sol\";\nimport {SafeApprove} from \"../../libraries/SafeApprove.sol\";\nimport {UsdoMsgCodec} from \"../libraries/UsdoMsgCodec.sol\";\nimport {BaseUsdo} from \"../BaseUsdo.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title UsdoMarketReceiverModule\n * @author TapiocaDAO\n * @notice Usdo Market module\n */\ncontract UsdoMarketReceiverModule is BaseUsdo {\n    using SafeERC20 for IERC20;\n    using BytesLib for bytes;\n    using SafeApprove for address;\n    using SafeCast for uint256;\n\n    error UsdoMarketReceiverModule_NotAuthorized(address invalidAddress);\n\n    event LeverageUpReceived(address indexed user, address indexed market, uint256 indexed amount);\n\n    constructor(UsdoInitStruct memory _data) BaseUsdo(_data) {}\n\n    /**\n     * @notice Execute `magnetar.depositLendAndSendForLocking`\n     * @dev Lend on SGL and send receipt token on another layer\n     * @param _data.user the user to perform the operation for\n     * @param _data.singularity the SGL address\n     * @param _data.lendAmount the amount to lend on SGL\n     * @param _data.depositData the data needed to deposit on YieldBox\n     * @param _data.lockAndParticipateSendParams LZ send params for the lock or/and the participate operations\n     */\n    function depositLendAndSendForLockingReceiver(bytes memory _data) public payable {\n        // Decode received message.\n        DepositAndSendForLockingData memory msg_ = UsdoMsgCodec.decodeDepositLendAndSendForLockingMsg(_data);\n\n        _checkWhitelistStatus(msg_.singularity);\n        _checkWhitelistStatus(msg_.magnetar);\n\n        if (msg_.lendAmount > 0) {\n            msg_.lendAmount = _toLD(msg_.lendAmount.toUint64());\n        }\n        if (msg_.depositData.amount > 0) {\n            msg_.depositData.amount = _toLD(msg_.depositData.amount.toUint64());\n        }\n\n        bytes memory call =\n            abi.encodeWithSelector(MagnetarAssetXChainModule.depositYBLendSGLLockXchainTOLP.selector, msg_);\n        MagnetarCall[] memory magnetarCall = new MagnetarCall[](1);\n        magnetarCall[0] = MagnetarCall({\n            id: MagnetarAction.AssetModule,\n            target: msg_.magnetar,\n            value: msg.value,\n            allowFailure: false,\n            call: call\n        });\n        IMagnetar(payable(msg_.magnetar)).burst{value: msg.value}(magnetarCall);\n    }\n\n    /**\n     * @notice Receiver for PT_YB_SEND_SGL_LEND_OR_REPAY\n     * @param _data The call data containing info about the operation.\n     *      - user::address: Address to leverage for.\n     *      - lendParams::struct: Struct containing data for the lend or the repay operations\n     *      - withdrawParams::struct: Struct containing data for the asset withdrawal operation\n     */\n    function lendOrRepayReceiver(bytes memory _data) public payable {\n        /// @dev decode received message\n        MarketLendOrRepayMsg memory msg_ = UsdoMsgCodec.decodeMarketLendOrRepayMsg(_data);\n\n        _checkWhitelistStatus(msg_.lendParams.magnetar);\n        _checkWhitelistStatus(msg_.lendParams.marketHelper);\n        _checkWhitelistStatus(msg_.lendParams.market);\n        if (msg_.lendParams.lockData.lock) {\n            _checkWhitelistStatus(msg_.lendParams.lockData.target);\n        }\n        if (msg_.lendParams.participateData.participate) {\n            _checkWhitelistStatus(msg_.lendParams.participateData.target);\n        }\n\n        {\n            if (msg_.lendParams.depositAmount > 0) {\n                msg_.lendParams.depositAmount = _toLD(msg_.lendParams.depositAmount.toUint64());\n            }\n            if (msg_.lendParams.repayAmount > 0) {\n                msg_.lendParams.repayAmount = _toLD(msg_.lendParams.repayAmount.toUint64());\n            }\n            if (msg_.lendParams.removeCollateralAmount > 0) {\n                msg_.lendParams.removeCollateralAmount = _toLD(msg_.lendParams.removeCollateralAmount.toUint64());\n            }\n            if (msg_.lendParams.lockData.amount > 0) {\n                msg_.lendParams.lockData.amount = _toLD(uint256(msg_.lendParams.lockData.amount).toUint64()).toUint128();\n            }\n            if (msg_.lendParams.lockData.fraction > 0) {\n                msg_.lendParams.lockData.fraction = _toLD(msg_.lendParams.lockData.fraction.toUint64());\n            }\n        }\n\n        // approve(address(msg_.lendParams.magnetar), msg_.lendParams.depositAmount);\n        approve(address(pearlmit), msg_.lendParams.depositAmount);\n        pearlmit.approve(\n            address(this),\n            0,\n            msg_.lendParams.magnetar,\n            uint200(msg_.lendParams.depositAmount),\n            uint48(block.timestamp + 1)\n        ); // Atomic approval\n        if (msg_.lendParams.repay) {\n            if (msg_.lendParams.repayAmount == 0) {\n                msg_.lendParams.repayAmount = IMagnetarHelper(IMagnetar(payable(msg_.lendParams.magnetar)).helper())\n                    .getBorrowPartForAmount(msg_.lendParams.market, msg_.lendParams.depositAmount);\n            }\n            bytes memory call = abi.encodeWithSelector(\n                MagnetarAssetModule.depositRepayAndRemoveCollateralFromMarket.selector,\n                DepositRepayAndRemoveCollateralFromMarketData({\n                    market: msg_.lendParams.market,\n                    marketHelper: msg_.lendParams.marketHelper,\n                    user: msg_.user,\n                    depositAmount: msg_.lendParams.depositAmount,\n                    repayAmount: msg_.lendParams.repayAmount,\n                    collateralAmount: msg_.lendParams.removeCollateralAmount,\n                    withdrawCollateralParams: msg_.withdrawParams\n                })\n            );\n            MagnetarCall[] memory magnetarCall = new MagnetarCall[](1);\n            magnetarCall[0] = MagnetarCall({\n                id: MagnetarAction.AssetModule,\n                target: msg_.lendParams.magnetar, //ignored in modules call\n                value: msg.value,\n                allowFailure: false,\n                call: call\n            });\n            IMagnetar(payable(msg_.lendParams.magnetar)).burst{value: msg.value}(magnetarCall);\n        } else {\n            MintFromBBAndLendOnSGLData memory _lendData = MintFromBBAndLendOnSGLData({\n                user: msg_.user,\n                lendAmount: msg_.lendParams.depositAmount,\n                mintData: IMintData({\n                    mint: false,\n                    mintAmount: 0,\n                    collateralDepositData: IDepositData({deposit: false, amount: 0})\n                }),\n                depositData: IDepositData({deposit: true, amount: msg_.lendParams.depositAmount}),\n                lockData: msg_.lendParams.lockData,\n                participateData: msg_.lendParams.participateData,\n                externalContracts: ICommonExternalContracts({\n                    magnetar: msg_.lendParams.magnetar,\n                    singularity: msg_.lendParams.market,\n                    bigBang: address(0),\n                    marketHelper: msg_.lendParams.marketHelper\n                })\n            });\n            bytes memory call = abi.encodeWithSelector(MagnetarMintModule.mintBBLendSGLLockTOLP.selector, _lendData);\n            MagnetarCall[] memory magnetarCall = new MagnetarCall[](1);\n            magnetarCall[0] = MagnetarCall({\n                id: MagnetarAction.MintModule,\n                target: msg_.lendParams.magnetar, //ignored in modules call\n                value: msg.value,\n                allowFailure: false,\n                call: call\n            });\n\n            IMagnetar(payable(msg_.lendParams.magnetar)).burst{value: msg.value}(magnetarCall);\n        }\n        approve(address(pearlmit), 0);\n    }\n\n    /**\n     * @notice Receiver for PT_MARKET_REMOVE_ASSET\n     * @param _data The call data containing info about the operation.\n     *      - user::address: Address to leverage for.\n     *      - externalData::struct: Struct containing addresses used by this operation.\n     *      - removeAndRepayData::struct: Struct containing data for the asset removal operation\n     */\n    function removeAssetReceiver(bytes memory _data) public payable {\n        /// @dev decode received message\n        MarketRemoveAssetMsg memory msg_ = UsdoMsgCodec.decodeMarketRemoveAssetMsg(_data);\n\n        _checkWhitelistStatus(msg_.externalData.magnetar);\n        _checkWhitelistStatus(msg_.externalData.singularity);\n        _checkWhitelistStatus(msg_.externalData.bigBang);\n\n        msg_.removeAndRepayData.removeAmount = _toLD(msg_.removeAndRepayData.removeAmount.toUint64());\n        msg_.removeAndRepayData.repayAmount = _toLD(msg_.removeAndRepayData.repayAmount.toUint64());\n        msg_.removeAndRepayData.collateralAmount = _toLD(msg_.removeAndRepayData.collateralAmount.toUint64());\n\n        {\n            bytes memory call = abi.encodeWithSelector(\n                MagnetarOptionModule.exitPositionAndRemoveCollateral.selector,\n                ExitPositionAndRemoveCollateralData({\n                    user: msg_.user,\n                    externalData: msg_.externalData,\n                    removeAndRepayData: msg_.removeAndRepayData\n                })\n            );\n            MagnetarCall[] memory magnetarCall = new MagnetarCall[](1);\n            magnetarCall[0] = MagnetarCall({\n                id: MagnetarAction.OptionModule,\n                target: address(this), //ignored in module calls\n                value: msg.value,\n                allowFailure: false,\n                call: call\n            });\n            IMagnetar(payable(msg_.externalData.magnetar)).burst{value: msg.value}(magnetarCall);\n        }\n    }\n\n    function _checkWhitelistStatus(address _addr) private view {\n        if (_addr != address(0)) {\n            if (!cluster.isWhitelisted(0, _addr)) {\n                revert UsdoMarketReceiverModule_NotAuthorized(_addr);\n            }\n        }\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/gitmodule/tapioca-periph/contracts/Magnetar/Magnetar.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// Tapioca\nimport {ITapiocaOptionBroker} from \"tapioca-periph/interfaces/tap-token/ITapiocaOptionBroker.sol\";\nimport {ITapiocaOptionLiquidityProvision} from\n    \"tapioca-periph/interfaces/tap-token/ITapiocaOptionLiquidityProvision.sol\";\nimport {MagnetarAction, MagnetarModule, MagnetarCall} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {IMagnetarModuleExtender} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {ISingularity} from \"tapioca-periph/interfaces/bar/ISingularity.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IPermitAll} from \"tapioca-periph/interfaces/common/IPermitAll.sol\";\nimport {ICluster} from \"tapioca-periph/interfaces/periph/ICluster.sol\";\nimport {IPearlmit} from \"tapioca-periph/pearlmit/PearlmitHandler.sol\";\nimport {IPermit} from \"tapioca-periph/interfaces/common/IPermit.sol\";\nimport {IMarket} from \"tapioca-periph/interfaces/bar/IMarket.sol\";\nimport {ITOFT} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {BaseMagnetar} from \"./BaseMagnetar.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title Magnetar\n * @author TapiocaDAO\n * @notice Magnetar helper contract\n */\ncontract Magnetar is BaseMagnetar {\n    error Magnetar_ValueMismatch(uint256 expected, uint256 received); // Value mismatch in the total value asked and the msg.value in burst\n    error Magnetar_ActionNotValid(MagnetarAction action, bytes actionCalldata); // Burst did not find what to execute\n\n    constructor(\n        ICluster _cluster,\n        address _owner,\n        address payable _assetModule,\n        address payable _assetXChainModule,\n        address payable _collateralModule,\n        address payable _mintModule,\n        address payable _mintXChainModule,\n        address payable _optionModule,\n        address payable _yieldBoxModule,\n        IPearlmit _pearlmit\n    ) BaseMagnetar(_cluster, _pearlmit, _owner) {\n        modules[MagnetarModule.AssetModule] = _assetModule;\n        modules[MagnetarModule.AssetXChainModule] = _assetXChainModule;\n        modules[MagnetarModule.CollateralModule] = _collateralModule;\n        modules[MagnetarModule.MintModule] = _mintModule;\n        modules[MagnetarModule.MintXChainModule] = _mintXChainModule;\n        modules[MagnetarModule.OptionModule] = _optionModule;\n        modules[MagnetarModule.YieldBoxModule] = _yieldBoxModule;\n    }\n\n    /// =====================\n    /// Public\n    /// =====================\n    /**\n     * @notice Batch multiple calls together\n     * @param calls The list of actions to perform\n     */\n    function burst(MagnetarCall[] calldata calls) external payable {\n        uint256 valAccumulator;\n\n        uint256 length = calls.length;\n\n        for (uint256 i; i < length; i++) {\n            MagnetarCall calldata _action = calls[i];\n            if (!_action.allowFailure) {\n                require(\n                    _action.call.length > 0,\n                    string.concat(\"Magnetar: Missing call for action with index\", string(abi.encode(i)))\n                );\n            }\n            valAccumulator += _action.value;\n\n            /// @dev Permit on YB, or an SGL/BB market\n            if (_action.id == MagnetarAction.Permit) {\n                _processPermitOperation(_action.target, _action.call, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Wrap/unwrap singular operations\n            if (_action.id == MagnetarAction.Wrap) {\n                _processWrapOperation(_action.target, _action.call, _action.value, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Market singular operations\n            if (_action.id == MagnetarAction.Market) {\n                _processMarketOperation(_action.target, _action.call, _action.value, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Tap singular operations\n            if (_action.id == MagnetarAction.TapToken) {\n                _processTapTokenOperation(_action.target, _action.call, _action.value, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.AssetModule) {\n                _executeModule(MagnetarModule.AssetModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.AssetXChainModule) {\n                _executeModule(MagnetarModule.AssetXChainModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.CollateralModule) {\n                _executeModule(MagnetarModule.CollateralModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.MintModule) {\n                _executeModule(MagnetarModule.MintModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.MintXChainModule) {\n                _executeModule(MagnetarModule.MintXChainModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.OptionModule) {\n                _executeModule(MagnetarModule.OptionModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.YieldBoxModule) {\n                _executeModule(MagnetarModule.YieldBoxModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            if (_action.id == MagnetarAction.OFT) {\n                _processOFTOperation(_action.target, _action.call, _action.value, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            // If no valid action was found, use the Magnetar module extender. Only if the action is valid.\n            if (\n                address(magnetarModuleExtender) != address(0)\n                    && magnetarModuleExtender.isValidActionId(uint8(_action.id))\n            ) {\n                bytes memory callData = abi.encodeWithSelector(IMagnetarModuleExtender.handleAction.selector, _action);\n                (bool success, bytes memory returnData) = address(magnetarModuleExtender).delegatecall(callData);\n                if (!success) {\n                    _getRevertMsg(returnData);\n                }\n            } else {\n                // If no valid action was found, revert\n                revert Magnetar_ActionNotValid(_action.id, _action.call);\n            }\n        }\n\n        if (msg.value != valAccumulator) revert Magnetar_ValueMismatch(msg.value, valAccumulator);\n    }\n\n    /// =====================\n    /// Private\n    /// =====================\n    /**\n     * @dev Process a permit operation, will only execute if the selector is allowed.\n     * @dev !!! WARNING !!! Make sure to check the Owner param and check that function definition didn't change.\n     *\n     * @param _target The contract address to call.\n     * @param _actionCalldata The calldata to send to the target.\n     * @param _allowFailure Whether to allow the call to fail.\n     */\n    function _processPermitOperation(address _target, bytes calldata _actionCalldata, bool _allowFailure) private {\n        if (!cluster.isWhitelisted(0, _target)) revert Magnetar_NotAuthorized(_target, _target);\n\n        /// @dev owner address should always be first param.\n        // permitAction(bytes,uint16)\n        // permit(address owner...)\n        // revoke(address owner...)\n        // permitAll(address from,..)\n        // permit(address from,...)\n        // setApprovalForAll(address from,...)\n        // setApprovalForAsset(address from,...)\n        bytes4 funcSig = bytes4(_actionCalldata[:4]);\n        if (\n            funcSig == IPermitAll.permitAll.selector || funcSig == IPermitAll.revokeAll.selector\n                || funcSig == IPermit.permit.selector || funcSig == IPermit.revoke.selector\n                || funcSig == IYieldBox.setApprovalForAll.selector || funcSig == IYieldBox.setApprovalForAsset.selector\n        ) {\n            /// @dev Owner param check. See Warning above.\n            _checkSender(abi.decode(_actionCalldata[4:36], (address)));\n            // No need to send value on permit\n            _executeCall(_target, _actionCalldata, 0, _allowFailure);\n            return;\n        }\n        revert Magnetar_ActionNotValid(MagnetarAction.Permit, _actionCalldata);\n    }\n\n    //TODO: decide\n    /**\n     * @dev Process a TOFT operation, will only execute if the selector is allowed.\n     * @dev !!! WARNING !!! Make sure to check the Owner param and check that function definition didn't change.\n     *\n     * @param _target The contract address to call.\n     * @param _actionCalldata The calldata to send to the target.\n     * @param _actionValue The value to send with the call.\n     * @param _allowFailure Whether to allow the call to fail.\n     */\n    function _processWrapOperation(\n        address _target,\n        bytes calldata _actionCalldata,\n        uint256 _actionValue,\n        bool _allowFailure\n    ) private {\n        if (!cluster.isWhitelisted(0, _target)) revert Magnetar_NotAuthorized(_target, _target);\n\n        /// @dev owner address should always be first param.\n        // wrap(address from,...)\n        // unwrap(address from,...)\n        bytes4 funcSig = bytes4(_actionCalldata[:4]);\n\n        if (funcSig == ITOFT.wrap.selector || funcSig == ITOFT.unwrap.selector) {\n            /// @dev Owner param check. See Warning above.\n            _checkSender(abi.decode(_actionCalldata[4:36], (address)));\n            _executeCall(_target, _actionCalldata, _actionValue, _allowFailure);\n            return;\n        }\n        revert Magnetar_ActionNotValid(MagnetarAction.Wrap, _actionCalldata);\n    }\n\n    /**\n     * @dev Process a market operation, will only execute if the selector is allowed.\n     * @dev !!! WARNING !!! Make sure to check the Owner param and check that function definition didn't change.\n     *\n     * @param _target The contract address to call.\n     * @param _actionCalldata The calldata to send to the target.\n     * @param _actionValue The value to send with the call.\n     * @param _allowFailure Whether to allow the call to fail.\n     */\n    function _processMarketOperation(\n        address _target,\n        bytes calldata _actionCalldata,\n        uint256 _actionValue,\n        bool _allowFailure\n    ) private {\n        if (!cluster.isWhitelisted(0, _target)) revert Magnetar_NotAuthorized(_target, _target);\n\n        /// @dev owner address should always be first param.\n        // addCollateral(address from,...)\n        // borrow(address from,...)\n        // addAsset(address from,...)\n        // repay(address _from,...)\n        // buyCollateral(address from,...)\n        // sellCollateral(address from,...)\n        bytes4 funcSig = bytes4(_actionCalldata[:4]);\n        if (\n            funcSig == IMarket.execute.selector || funcSig == ISingularity.addAsset.selector\n                || funcSig == ISingularity.removeAsset.selector\n        ) {\n            /// @dev Owner param check. See Warning above.\n            _checkSender(abi.decode(_actionCalldata[4:36], (address)));\n            _executeCall(_target, _actionCalldata, _actionValue, _allowFailure);\n            return;\n        }\n        revert Magnetar_ActionNotValid(MagnetarAction.Market, _actionCalldata);\n    }\n\n    /**\n     * @dev Process a TapToken operation, will only execute if the selector is allowed.\n     * @dev Different from the others. No need to check for sender.\n     *\n     * @param _target The contract address to call.\n     * @param _actionCalldata The calldata to send to the target.\n     * @param _actionValue The value to send with the call.\n     * @param _allowFailure Whether to allow the call to fail.\n     */\n    function _processTapTokenOperation(\n        address _target,\n        bytes calldata _actionCalldata,\n        uint256 _actionValue,\n        bool _allowFailure\n    ) private {\n        if (!cluster.isWhitelisted(0, _target)) revert Magnetar_NotAuthorized(_target, _target);\n\n        bytes4 funcSig = bytes4(_actionCalldata[:4]);\n        if (\n            funcSig == ITapiocaOptionBroker.exerciseOption.selector\n                || funcSig == ITapiocaOptionBroker.participate.selector\n                || funcSig == ITapiocaOptionBroker.exitPosition.selector\n                || funcSig == ITapiocaOptionLiquidityProvision.lock.selector\n                || funcSig == ITapiocaOptionLiquidityProvision.unlock.selector\n        ) {\n            _executeCall(_target, _actionCalldata, _actionValue, _allowFai"
    }
  ]
}