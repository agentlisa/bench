{
  "Title": "[M-12] Excess eth is not refunded",
  "Content": "# Lines of code\n\nhttps://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/proposals/ArbitraryCallsProposal.sol#L72\n\n\n# Vulnerability details\n\n## Impact\nThe ArbitraryCallsProposal contract requires sender to provide eth(msg.value) for each call. Now if user has provided more eth than combined call.value then this excess eth is not refunded back to user\n\n## Proof of Concept\n\n1. Observe the [_executeArbitraryCalls function](https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/proposals/ArbitraryCallsProposal.sol#L37)\n\n```\nfunction _executeArbitraryCalls(\n        IProposalExecutionEngine.ExecuteProposalParams memory params\n    )\n        internal\n        returns (bytes memory nextProgressData)\n    {\n\n...\nuint256 ethAvailable = msg.value;\n        for (uint256 i = 0; i < calls.length; ++i) {\n            // Execute an arbitrary call.\n            _executeSingleArbitraryCall(\n                i,\n                calls[i],\n                params.preciousTokens,\n                params.preciousTokenIds,\n                isUnanimous,\n                ethAvailable\n            );\n            // Update the amount of ETH available for the subsequent calls.\n            ethAvailable -= calls[i].value;\n            emit ArbitraryCallExecuted(params.proposalId, i, calls.length);\n        }\n....\n}\n```\n\n2. As we can see user provided msg.value is deducted with each calls[i].value\n3. Assume user provided 5 amount as msg.value and made a single call with calls[0].value as 4\n4. This means after calls have been completed ethAvailable will become 5-4=1\n5. Ideally this 1 eth should be refunded back to user but there is no provision for same and the fund will remain in contract\n\n\n## Recommended Mitigation Steps\nAt the end of _executeArbitraryCalls function, refund the remaining ethAvailable back to the user",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-09-partydao-contest",
  "Code": [
    {
      "filename": "contracts/proposals/ArbitraryCallsProposal.sol",
      "content": "// SPDX-License-Identifier: Beta Software\npragma solidity ^0.8;\n\nimport \"../tokens/IERC721.sol\";\nimport \"../tokens/IERC721Receiver.sol\";\nimport \"../utils/LibSafeERC721.sol\";\n\nimport \"./LibProposal.sol\";\nimport \"./IProposalExecutionEngine.sol\";\n\n// Implements arbitrary call proposals. Inherited by the `ProposalExecutionEngine`.\n// This contract will be delegatecall'ed into by `Party` proxy instances.\ncontract ArbitraryCallsProposal {\n    using LibSafeERC721 for IERC721;\n\n    struct ArbitraryCall {\n        // The call target.\n        address payable target;\n        // Amount of ETH to attach to the call.\n        uint256 value;\n        // Calldata.\n        bytes data;\n        // Hash of the successful return data of the call.\n        // If 0x0, no return data checking will occur for this call.\n        bytes32 expectedResultHash;\n    }\n\n    error PreciousLostError(IERC721 token, uint256 tokenId);\n    error CallProhibitedError(address target, bytes data);\n    error ArbitraryCallFailedError(bytes revertData);\n    error UnexpectedCallResultHashError(uint256 idx, bytes32 resultHash, bytes32 expectedResultHash);\n    error NotEnoughEthAttachedError(uint256 callValue, uint256 ethAvailable);\n    error InvalidApprovalCallLength(uint256 callDataLength);\n\n    event ArbitraryCallExecuted(uint256 proposalId, uint256 idx, uint256 count);\n\n    function _executeArbitraryCalls(\n        IProposalExecutionEngine.ExecuteProposalParams memory params\n    )\n        internal\n        returns (bytes memory nextProgressData)\n    {\n        // Get the calls to execute.\n        (ArbitraryCall[] memory calls) = abi.decode(params.proposalData, (ArbitraryCall[]));\n        // Check whether the proposal was unanimously passed.\n        bool isUnanimous = params.flags & LibProposal.PROPOSAL_FLAG_UNANIMOUS\n            == LibProposal.PROPOSAL_FLAG_UNANIMOUS;\n        // If not unanimous, keep track of which preciouses we had before the calls\n        // so we can check that we still have them later.\n        bool[] memory hadPreciouses = new bool[](params.preciousTokenIds.length);\n        if (!isUnanimous) {\n            for (uint256 i = 0; i < hadPreciouses.length; ++i) {\n                hadPreciouses[i] = _getHasPrecious(\n                    params.preciousTokens[i],\n                    params.preciousTokenIds[i]\n                );\n            }\n        }\n        // Can only forward ETH attached to the call.\n        uint256 ethAvailable = msg.value;\n        for (uint256 i = 0; i < calls.length; ++i) {\n            // Execute an arbitrary call.\n            _executeSingleArbitraryCall(\n                i,\n                calls[i],\n                params.preciousTokens,\n                params.preciousTokenIds,\n                isUnanimous,\n                ethAvailable\n            );\n            // Update the amount of ETH available for the subsequent calls.\n            ethAvailable -= calls[i].value;\n            emit ArbitraryCallExecuted(params.proposalId, i, calls.length);\n        }\n        // If not a unanimous vote and we had a precious beforehand,\n        // ensure that we still have it now.\n        if (!isUnanimous) {\n            for (uint256 i = 0; i < hadPreciouses.length; ++i) {\n                if (hadPreciouses[i]) {\n                    if (!_getHasPrecious(params.preciousTokens[i], params.preciousTokenIds[i])) {\n                        revert PreciousLostError(\n                            params.preciousTokens[i],\n                            params.preciousTokenIds[i]\n                        );\n                    }\n                }\n            }\n        }\n        // No next step, so no progressData.\n        return '';\n    }\n\n    function _executeSingleArbitraryCall(\n        uint256 idx,\n        ArbitraryCall memory call,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds,\n        bool isUnanimous,\n        uint256 ethAvailable\n    )\n        private\n    {\n        // Check that the call is not prohibited.\n        if (!_isCallAllowed(call, isUnanimous, preciousTokens, preciousTokenIds)) {\n            revert CallProhibitedError(call.target, call.data);\n        }\n        // Check that we have enough ETH to execute the call.\n        if (ethAvailable < call.value) {\n            revert NotEnoughEthAttachedError(call.value, ethAvailable);\n        }\n        // Execute the call.\n        (bool s, bytes memory r) = call.target.call{ value: call.value }(call.data);\n        if (!s) {\n            // Call failed. If not optional, revert.\n            revert ArbitraryCallFailedError(r);\n        } else {\n            // Call succeeded.\n            // If we have a nonzero expectedResultHash, check that the result data\n            // from the call has a matching hash.\n            if (call.expectedResultHash != bytes32(0)) {\n                bytes32 resultHash = keccak256(r);\n                if (resultHash != call.expectedResultHash) {\n                    revert UnexpectedCallResultHashError(\n                        idx,\n                        resultHash,\n                        call.expectedResultHash\n                    );\n                }\n            }\n        }\n    }\n\n    // Do we possess the precious?\n    function _getHasPrecious(IERC721 preciousToken, uint256 preciousTokenId)\n        private\n        view\n        returns (bool hasPrecious)\n    {\n        hasPrecious = preciousToken.safeOwnerOf(preciousTokenId) == address(this);\n    }\n\n    function _isCallAllowed(\n        ArbitraryCall memory call,\n        bool isUnanimous,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds\n    )\n        private\n        view\n        returns (bool isAllowed)\n    {\n        // Cannot call ourselves.\n        if (call.target == address(this)) {\n            return false;\n        }\n        if (call.data.length >= 4) {\n            // Get the function selector of the call (first 4 bytes of calldata).\n            bytes4 selector;\n            {\n                bytes memory callData = call.data;\n                assembly {\n                    selector := and(\n                        mload(add(callData, 32)),\n                        0xffffffff00000000000000000000000000000000000000000000000000000000\n                    )\n                }\n            }\n            // Non-unanimous proposals restrict what ways some functions can be\n            // called on a precious token.\n            if (!isUnanimous) {\n                // Cannot call `approve()` or `setApprovalForAll()` on the precious\n                // unless it's to revoke approvals.\n                if (selector == IERC721.approve.selector) {\n                    // Can only call `approve()` on the precious if the operator is null.\n                    (address op, uint256 tokenId) = _decodeApproveCallDataArgs(call.data);\n                    if (op != address(0)) {\n                        return !LibProposal.isTokenIdPrecious(\n                            IERC721(call.target),\n                            tokenId,\n                            preciousTokens,\n                            preciousTokenIds\n                        );\n                    }\n                // Can only call `setApprovalForAll()` on the precious if\n                // toggling off.\n                } else if (selector == IERC721.setApprovalForAll.selector) {\n                    (, bool isApproved) = _decodeSetApprovalForAllCallDataArgs(call.data);\n                    if (isApproved) {\n                        return !LibProposal.isTokenPrecious(IERC721(call.target), preciousTokens);\n                    }\n                }\n            }\n            // Can never call `onERC721Received()` on any target.\n            if (selector == IERC721Receiver.onERC721Received.selector) {\n               return false;\n           }\n        }\n        // All other calls are allowed.\n        return true;\n    }\n\n    // Get the `operator` and `tokenId` from the `approve()` call data.\n    function _decodeApproveCallDataArgs(bytes memory callData)\n        private\n        pure\n        returns (address operator, uint256 tokenId)\n    {\n        if (callData.length < 68) {\n            revert InvalidApprovalCallLength(callData.length);\n        }\n        assembly {\n            operator := and(\n                mload(add(callData, 36)),\n                0xffffffffffffffffffffffffffffffffffffffff\n            )\n            tokenId := mload(add(callData, 68))\n        }\n    }\n\n    // Get the `operator` and `tokenId` from the `setApprovalForAll()` call data.\n    function _decodeSetApprovalForAllCallDataArgs(bytes memory callData)\n        private\n        pure\n        returns (address operator, bool isApproved)\n    {\n        if (callData.length < 68) {\n            revert InvalidApprovalCallLength(callData.length);\n        }\n        assembly {\n            operator := and(\n                mload(add(callData, 36)),\n                0xffffffffffffffffffffffffffffffffffffffff\n            )\n            isApproved := xor(iszero(mload(add(callData, 68))), 1)\n        }\n    }\n\n}"
    }
  ]
}