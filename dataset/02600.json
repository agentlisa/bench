{
  "Title": "Missing ConfigurationManager check during vault initialization",
  "Content": "As part of the [`constructor`](https://github.com/pods-finance/yield-contracts/blob/c4b401ce674c24798de5f9d02c82e466ee0a2600/contracts/vaults/BaseVault.sol#L53) in the `BaseVault` contract, the `configuration` [state variable is set](https://github.com/pods-finance/yield-contracts/blob/c4b401ce674c24798de5f9d02c82e466ee0a2600/contracts/vaults/BaseVault.sol#L59). However, there is no check to ensure the passed-in `ConfigurationManager` address instance has the [`VAULT_CONTROLLER`](https://github.com/pods-finance/yield-contracts/blob/c4b401ce674c24798de5f9d02c82e466ee0a2600/contracts/vaults/BaseVault.sol#L290) parameter set for the vault contract that is being created. Having the `VAULT_CONTROLLER` parameter be the default value of the zero address for the new vault could result in a loss of the `fee` taken as part of the withdraw control flow, since that fee will be transferred to the `VAULT_CONTROLLER` address designated by the `ConfigurationManager`.\n\n\nConsider adding a check in the `constructor` of the `BaseVault` contract to ensure calling `getParameter` with the address of the vault being created, and `VAULT_CONTROLLER` does not return the zero address.\n\n\n***Update:** Acknowledged, not resolved. Pods Finance team stated:*\n\n\n\n> *Instead of enforcing it at the code level, that would require us to deploy the vault using CREATE2 in order to know in advance the vault address, we will monitor the VAULT\\_CONTROLLER variable to make sure that it was set after the deploy.*\n> \n> \n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/vaults/BaseVault.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { ERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport { IERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport { ERC4626 } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { EnumerableMap } from \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\nimport { IConfigurationManager } from \"../interfaces/IConfigurationManager.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { CastUint } from \"../libs/CastUint.sol\";\nimport { Capped } from \"../mixins/Capped.sol\";\n\n/**\n * @title BaseVault\n * @notice A Vault that tokenize shares of strategy\n * @author Pods Finance\n */\nabstract contract BaseVault is IVault, ERC20Permit, ERC4626, Capped {\n    using SafeERC20 for IERC20Metadata;\n    using Math for uint256;\n    using CastUint for uint256;\n    using EnumerableMap for EnumerableMap.AddressToUintMap;\n\n    /**\n     * @dev DENOMINATOR represents the precision for the following system variables:\n     * - MAX_WITHDRAW_FEE\n     * - INVESTOR_RATIO\n     */\n    uint256 public constant DENOMINATOR = 10000;\n    /**\n     * @dev MAX_WITHDRAW_FEE is a safe check in case the ConfigurationManager sets\n     * a fee high enough that can be used as a way to drain funds.\n     * The precision of this number is set by constant DENOMINATOR.\n     */\n    uint256 public constant MAX_WITHDRAW_FEE = 1000;\n    /**\n     * @notice Minimum asset amount for the first deposit\n     * @dev This amount that prevents the first depositor to steal funds from subsequent depositors.\n     * See https://code4rena.com/reports/2022-01-sherlock/#h-01-first-user-can-steal-everyone-elses-tokens\n     */\n    uint256 public immutable MIN_INITIAL_ASSETS;\n\n    IConfigurationManager public immutable configuration;\n    VaultState internal vaultState;\n    EnumerableMap.AddressToUintMap internal depositQueue;\n\n    constructor(\n        IConfigurationManager configuration_,\n        IERC20Metadata asset_,\n        string memory name_,\n        string memory symbol_\n    ) ERC20(name_, symbol_) ERC20Permit(name_) ERC4626(asset_) Capped(configuration_) {\n        configuration = configuration_;\n\n        // Vault starts in `start` state\n        emit RoundStarted(vaultState.currentRoundId, 0);\n        vaultState.lastEndRoundTimestamp = uint32(block.timestamp);\n\n        MIN_INITIAL_ASSETS = 10**uint256(asset_.decimals());\n    }\n\n    modifier onlyController() {\n        if (msg.sender != controller()) revert IVault__CallerIsNotTheController();\n        _;\n    }\n\n    modifier onlyRoundStarter() {\n        bool lastRoundEndedAWeekAgo = block.timestamp >= vaultState.lastEndRoundTimestamp + 1 weeks;\n\n        if (!lastRoundEndedAWeekAgo && msg.sender != controller()) {\n            revert IVault__CallerIsNotTheController();\n        }\n        _;\n    }\n\n    modifier whenNotProcessingDeposits() {\n        if (vaultState.isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\n        _;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function currentRoundId() external view returns (uint32) {\n        return vaultState.currentRoundId;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function isProcessingDeposits() external view returns (bool) {\n        return vaultState.isProcessingDeposits;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function processedDeposits() external view returns (uint256) {\n        return vaultState.processedDeposits;\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function deposit(uint256 assets, address receiver)\n        public\n        virtual\n        override(ERC4626, IERC4626)\n        whenNotProcessingDeposits\n        returns (uint256)\n    {\n        return super.deposit(assets, receiver);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function depositWithPermit(\n        uint256 assets,\n        address receiver,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override whenNotProcessingDeposits returns (uint256) {\n        IERC20Permit(asset()).permit(msg.sender, address(this), assets, deadline, v, r, s);\n        return super.deposit(assets, receiver);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function mint(uint256 shares, address receiver)\n        public\n        virtual\n        override(ERC4626, IERC4626)\n        whenNotProcessingDeposits\n        returns (uint256)\n    {\n        return super.mint(shares, receiver);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function mintWithPermit(\n        uint256 shares,\n        address receiver,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override whenNotProcessingDeposits returns (uint256) {\n        uint256 assets = previewMint(shares);\n        IERC20Permit(asset()).permit(msg.sender, address(this), assets, deadline, v, r, s);\n        return super.mint(shares, receiver);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual override(ERC4626, IERC4626) whenNotProcessingDeposits returns (uint256 assets) {\n        assets = convertToAssets(shares);\n\n        if (assets == 0) revert IVault__ZeroAssets();\n        (assets, ) = _withdrawWithFees(msg.sender, receiver, owner, assets, shares);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual override(ERC4626, IERC4626) whenNotProcessingDeposits returns (uint256 shares) {\n        shares = _convertToShares(assets, Math.Rounding.Up);\n        (, shares) = _withdrawWithFees(msg.sender, receiver, owner, assets, shares);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function previewWithdraw(uint256 assets) public view override(ERC4626, IERC4626) returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Up);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function previewRedeem(uint256 shares) public view override(ERC4626, IERC4626) returns (uint256) {\n        uint256 assets = _convertToAssets(shares, Math.Rounding.Down);\n        return assets - _getFee(assets);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function maxDeposit(address) public view override(ERC4626, IERC4626) returns (uint256) {\n        uint256 _availableCap = availableCap();\n        if (_availableCap != type(uint256).max) {\n            return previewMint(_availableCap);\n        }\n        return _availableCap;\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function maxMint(address) public view override(ERC4626, IERC4626) returns (uint256) {\n        return availableCap();\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function maxWithdraw(address owner) public view override(ERC4626, IERC4626) returns (uint256) {\n        return previewRedeem(balanceOf(owner));\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function getWithdrawFeeRatio() public view override returns (uint256) {\n        uint256 _withdrawFeeRatio = configuration.getParameter(address(this), \"WITHDRAW_FEE_RATIO\");\n        // Fee is limited to MAX_WITHDRAW_FEE\n        return Math.min(_withdrawFeeRatio, MAX_WITHDRAW_FEE);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function idleAssetsOf(address owner) public view virtual returns (uint256) {\n        (, uint256 assets) = depositQueue.tryGet(owner);\n        return assets;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function assetsOf(address owner) external view virtual returns (uint256) {\n        uint256 supply = totalSupply();\n        uint256 shares = balanceOf(owner);\n        uint256 committedAssets = supply == 0\n            ? 0\n            : shares.mulDiv(IERC20Metadata(asset()).balanceOf(address(this)), supply, Math.Rounding.Down);\n        return convertToAssets(shares) + idleAssetsOf(owner) + committedAssets;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function totalIdleAssets() public view virtual returns (uint256) {\n        return vaultState.totalIdleAssets;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function depositQueueSize() public view returns (uint256) {\n        return depositQueue.length();\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function queuedDeposits() public view returns (address[] memory) {\n        address[] memory addresses = new address[](depositQueue.length());\n        for (uint256 i = 0; i < addresses.length; i++) {\n            (address owner, ) = depositQueue.at(i);\n            addresses[i] = owner;\n        }\n        return addresses;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function controller() public view returns (address) {\n        return configuration.getParameter(address(this), \"VAULT_CONTROLLER\").toAddress();\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function startRound() external virtual onlyRoundStarter returns (uint32) {\n        if (!vaultState.isProcessingDeposits) revert IVault__NotProcessingDeposits();\n\n        vaultState.isProcessingDeposits = false;\n\n        _afterRoundStart();\n        emit RoundStarted(vaultState.currentRoundId, vaultState.processedDeposits);\n        vaultState.processedDeposits = 0;\n\n        return vaultState.currentRoundId;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function endRound() external virtual onlyController {\n        if (vaultState.isProcessingDeposits) revert IVault__AlreadyProcessingDeposits();\n\n        vaultState.isProcessingDeposits = true;\n        _afterRoundEnd();\n        vaultState.lastEndRoundTimestamp = uint32(block.timestamp);\n\n        emit RoundEnded(vaultState.currentRoundId);\n\n        vaultState.currentRoundId += 1;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function refund() external returns (uint256 assets) {\n        (, assets) = depositQueue.tryGet(msg.sender);\n        if (assets == 0) revert IVault__ZeroAssets();\n\n        if (depositQueue.remove(msg.sender)) {\n            vaultState.totalIdleAssets -= assets;\n            _restoreCap(convertToShares(assets));\n        }\n\n        emit DepositRefunded(msg.sender, vaultState.currentRoundId, assets);\n        IERC20Metadata(asset()).safeTransfer(msg.sender, assets);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function migrate(IVault newVault) external override {\n        if (!configuration.isVaultMigrationAllowed(address(this), address(newVault))) {\n            revert IVault__MigrationNotAllowed();\n        }\n\n        // Redeem owner assets from this Vault\n        uint256 shares = balanceOf(msg.sender);\n        uint256 assets = redeem(shares, address(this), msg.sender);\n\n        // Deposit assets to `newVault`\n        IERC20Metadata(asset()).safeApprove(address(newVault), assets);\n        newVault.handleMigration(assets, msg.sender);\n\n        emit Migrated(msg.sender, address(this), address(newVault), assets, shares);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function handleMigration(uint256 assets, address receiver) external override returns (uint256) {\n        if (!configuration.isVaultMigrationAllowed(msg.sender, address(this))) {\n            revert IVault__MigrationNotAllowed();\n        }\n\n        return deposit(assets, receiver);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function processQueuedDeposits(address[] calldata depositors) external {\n        if (!vaultState.isProcessingDeposits) revert IVault__NotProcessingDeposits();\n\n        for (uint256 i = 0; i < depositors.length; i++) {\n            if (depositQueue.contains(depositors[i])) {\n                vaultState.processedDeposits += _processDeposit(depositors[i]);\n            }\n        }\n    }\n\n    /** Internals **/\n\n    /**\n     * @notice Mint new shares, effectively representing user participation in the Vault.\n     */\n    function _processDeposit(address depositor) internal virtual returns (uint256) {\n        uint256 currentAssets = totalAssets();\n        uint256 supply = totalSupply();\n        uint256 assets = depositQueue.get(depositor);\n        uint256 shares = currentAssets == 0 || supply == 0\n            ? assets\n            : assets.mulDiv(supply, currentAssets, Math.Rounding.Down);\n\n        if (supply == 0 && assets < MIN_INITIAL_ASSETS) {\n            revert IVault__AssetsUnderMinimumAmount(assets);\n        }\n\n        depositQueue.remove(depositor);\n        vaultState.totalIdleAssets -= assets;\n        _mint(depositor, shares);\n        emit DepositProcessed(depositor, vaultState.currentRoundId, assets, shares);\n\n        return assets;\n    }\n\n    /**\n     * @notice Add a new entry to the deposit to queue\n     */\n    function _addToDepositQueue(address receiver, uint256 assets) internal {\n        (, uint256 previous) = depositQueue.tryGet(receiver);\n        vaultState.totalIdleAssets += assets;\n        depositQueue.set(receiver, previous + assets);\n    }\n\n    /**\n     * @notice Calculate the fee amount on withdraw.\n     */\n    function _getFee(uint256 assets) internal view returns (uint256) {\n        return assets.mulDiv(getWithdrawFeeRatio(), DENOMINATOR, Math.Rounding.Down);\n    }\n\n    /**\n     * @dev Pull assets from the caller and add it to the deposit queue\n     */\n    function _deposit(\n        address caller,\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual override {\n        IERC20Metadata(asset()).safeTransferFrom(caller, address(this), assets);\n\n        _spendCap(shares);\n        _addToDepositQueue(receiver, assets);\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @dev Burn shares from the caller and release assets to the receiver\n     */\n    function _withdrawWithFees(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual returns (uint256 receiverAssets, uint256 receiverShares) {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        _burn(owner, shares);\n        _restoreCap(shares);\n\n        // Apply custom withdraw logic\n        _beforeWithdraw(shares, assets);\n\n        uint256 fee = _getFee(assets);\n        receiverAssets = assets - fee;\n        receiverShares = shares;\n\n        emit Withdraw(caller, receiver, owner, receiverAssets, shares);\n        IERC20Metadata(asset()).safeTransfer(receiver, receiverAssets);\n\n        if (fee > 0) {\n            emit FeeCollected(fee);\n            IERC20Metadata(asset()).safeTransfer(controller(), fee);\n        }\n    }\n\n    /** Hooks **/\n\n    /* solhint-disable no-empty-blocks */\n\n    /**\n     * @dev This hook should be implemented in the contract implementation.\n     * It will trigger after the shares were burned\n     */\n    function _beforeWithdraw(uint256 shares, uint256 assets) internal virtual {}\n\n    /**\n     * @dev This hook should be implemented in the contract implementation.\n     * It will trigger after setting isProcessingDeposits to false\n     */\n    function _afterRoundStart() internal virtual {}\n\n    /**\n     * @dev This hook should be implemented in the contract implementation.\n     * It will trigger after setting isProcessingDeposits to true\n     */\n    function _afterRoundEnd() internal virtual {}\n\n    /* solhint-enable no-empty-blocks */\n}"
    }
  ]
}