{
  "Title": "[N-03] For functions, follow Solidity standard naming conventions (internal function style rule)",
  "Content": "\n### Description\nThe above codes don’t follow Solidity’s standard naming convention,\n\ninternal and private functions : the mixedCase format starting with an underscore (`_mixedCase` starting with an underscore)\n\n```solidity\nFile: 2023-04-ens/contracts/dnsregistrar/OffchainDNSResolver.sol\n\n136: function parseRR(\n        bytes memory data,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal view returns (address, bytes memory) {\n\n162: function readTXT(\n        bytes memory data,\n        uint256 startIdx,\n        uint256 lastIdx\n    ) internal pure returns (bytes memory) {\n\n173: function parseAndResolve(\n        bytes memory nameOrAddress,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal view returns (address) {\n\n190: function resolveName(\n        bytes memory name,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal view returns (address) {\n\n209: function textNamehash(\n        bytes memory name,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal view returns (bytes32) {\n\n```\n[OffchainDNSResolver.sol#L136-L140](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/OffchainDNSResolver.sol#L136-L140)\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/algorithms/RSAVerify.sol#L14-L18\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/algorithms/ModexpPrecompile.sol#L7-L11\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/algorithms/P256SHA256Algorithm.sol#L30-L32\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/algorithms/P256SHA256Algorithm.sol#L37-L39\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/utils/NameEncoder.sol#L9-L11\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/utils/HexUtils.sol#L11-L15\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/utils/HexUtils.sol#L68-L72\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/DNSClaimChecker.sol#L19-L22\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/DNSClaimChecker.sol#L46-L50\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/DNSClaimChecker.sol#L66-L70\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/BytesUtils.sol#L13-L17\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/BytesUtils.sol#L32-L35\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/BytesUtils.sol#L52-L59\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/BytesUtils.sol#L111-L117\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/BytesUtils.sol#L129-L134\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/BytesUtils.sol#L148-L152\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/BytesUtils.sol#L164-L167\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/BytesUtils.sol#L179-L182\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/BytesUtils.sol#L332-L336\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-04-ens",
  "Code": [
    {
      "filename": "contracts/dnsregistrar/OffchainDNSResolver.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../../contracts/resolvers/profiles/IAddrResolver.sol\";\nimport \"../../contracts/resolvers/profiles/IExtendedResolver.sol\";\nimport \"../../contracts/resolvers/profiles/IExtendedDNSResolver.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"../dnssec-oracle/BytesUtils.sol\";\nimport \"../dnssec-oracle/DNSSEC.sol\";\nimport \"../dnssec-oracle/RRUtils.sol\";\nimport \"../registry/ENSRegistry.sol\";\nimport \"../utils/HexUtils.sol\";\n\nerror OffchainLookup(\n    address sender,\n    string[] urls,\n    bytes callData,\n    bytes4 callbackFunction,\n    bytes extraData\n);\n\ninterface IDNSGateway {\n    function resolve(\n        bytes memory name,\n        uint16 qtype\n    ) external returns (DNSSEC.RRSetWithSignature[] memory);\n}\n\nuint16 constant CLASS_INET = 1;\nuint16 constant TYPE_TXT = 16;\n\ncontract OffchainDNSResolver is IExtendedResolver {\n    using RRUtils for *;\n    using BytesUtils for bytes;\n    using HexUtils for bytes;\n\n    ENS public immutable ens;\n    DNSSEC public immutable oracle;\n    string public gatewayURL;\n\n    error CouldNotResolve(bytes name);\n\n    constructor(ENS _ens, DNSSEC _oracle, string memory _gatewayURL) {\n        ens = _ens;\n        oracle = _oracle;\n        gatewayURL = _gatewayURL;\n    }\n\n    function resolve(\n        bytes calldata name,\n        bytes calldata data\n    ) external view returns (bytes memory) {\n        string[] memory urls = new string[](1);\n        urls[0] = gatewayURL;\n\n        revert OffchainLookup(\n            address(this),\n            urls,\n            abi.encodeCall(IDNSGateway.resolve, (name, TYPE_TXT)),\n            OffchainDNSResolver.resolveCallback.selector,\n            abi.encode(name, data)\n        );\n    }\n\n    function resolveCallback(\n        bytes calldata response,\n        bytes calldata extraData\n    ) external view returns (bytes memory) {\n        (bytes memory name, bytes memory query) = abi.decode(\n            extraData,\n            (bytes, bytes)\n        );\n        DNSSEC.RRSetWithSignature[] memory rrsets = abi.decode(\n            response,\n            (DNSSEC.RRSetWithSignature[])\n        );\n\n        (bytes memory data, ) = oracle.verifyRRSet(rrsets);\n        for (\n            RRUtils.RRIterator memory iter = data.iterateRRs(0);\n            !iter.done();\n            iter.next()\n        ) {\n            // Ignore records with wrong name, type, or class\n            bytes memory rrname = RRUtils.readName(iter.data, iter.offset);\n            if (\n                !rrname.equals(name) ||\n                iter.class != CLASS_INET ||\n                iter.dnstype != TYPE_TXT\n            ) {\n                continue;\n            }\n\n            // Look for a valid ENS-DNS TXT record\n            (address dnsresolver, bytes memory context) = parseRR(\n                iter.data,\n                iter.rdataOffset,\n                iter.nextOffset\n            );\n\n            // If we found a valid record, try to resolve it\n            if (dnsresolver != address(0)) {\n                if (\n                    IERC165(dnsresolver).supportsInterface(\n                        IExtendedDNSResolver.resolve.selector\n                    )\n                ) {\n                    return\n                        IExtendedDNSResolver(dnsresolver).resolve(\n                            name,\n                            query,\n                            context\n                        );\n                } else if (\n                    IERC165(dnsresolver).supportsInterface(\n                        IExtendedResolver.resolve.selector\n                    )\n                ) {\n                    return IExtendedResolver(dnsresolver).resolve(name, query);\n                } else {\n                    (bool ok, bytes memory ret) = address(dnsresolver)\n                        .staticcall(query);\n                    if (ok) {\n                        return ret;\n                    } else {\n                        revert CouldNotResolve(name);\n                    }\n                }\n            }\n        }\n\n        // No valid records; revert.\n        revert CouldNotResolve(name);\n    }\n\n    function parseRR(\n        bytes memory data,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal view returns (address, bytes memory) {\n        bytes memory txt = readTXT(data, idx, lastIdx);\n\n        // Must start with the magic word\n        if (txt.length < 5 || !txt.equals(0, \"ENS1 \", 0, 5)) {\n            return (address(0), \"\");\n        }\n\n        // Parse the name or address\n        uint256 lastTxtIdx = txt.find(5, txt.length - 5, \" \");\n        if (lastTxtIdx > txt.length) {\n            address dnsResolver = parseAndResolve(txt, 5, txt.length);\n            return (dnsResolver, \"\");\n        } else {\n            address dnsResolver = parseAndResolve(txt, 5, lastTxtIdx);\n            return (\n                dnsResolver,\n                txt.substring(lastTxtIdx + 1, txt.length - lastTxtIdx - 1)\n            );\n        }\n    }\n\n    function readTXT(\n        bytes memory data,\n        uint256 startIdx,\n        uint256 lastIdx\n    ) internal pure returns (bytes memory) {\n        // TODO: Concatenate multiple text fields\n        uint256 fieldLength = data.readUint8(startIdx);\n        assert(startIdx + fieldLength < lastIdx);\n        return data.substring(startIdx + 1, fieldLength);\n    }\n\n    function parseAndResolve(\n        bytes memory nameOrAddress,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal view returns (address) {\n        if (nameOrAddress[idx] == \"0\" && nameOrAddress[idx + 1] == \"x\") {\n            (address ret, bool valid) = nameOrAddress.hexToAddress(\n                idx + 2,\n                lastIdx\n            );\n            if (valid) {\n                return ret;\n            }\n        }\n        return resolveName(nameOrAddress, idx, lastIdx);\n    }\n\n    function resolveName(\n        bytes memory name,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal view returns (address) {\n        bytes32 node = textNamehash(name, idx, lastIdx);\n        address resolver = ens.resolver(node);\n        if (resolver == address(0)) {\n            return address(0);\n        }\n        return IAddrResolver(resolver).addr(node);\n    }\n\n    /**\n     * @dev Namehash function that operates on dot-separated names (not dns-encoded names)\n     * @param name Name to hash\n     * @param idx Index to start at\n     * @param lastIdx Index to end at\n     */\n    function textNamehash(\n        bytes memory name,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal view returns (bytes32) {\n        uint256 separator = name.find(idx, name.length - idx, bytes1(\".\"));\n        bytes32 parentNode = bytes32(0);\n        if (separator < lastIdx) {\n            parentNode = textNamehash(name, separator + 1, lastIdx);\n        } else {\n            separator = lastIdx;\n        }\n        return\n            keccak256(\n                abi.encodePacked(parentNode, name.keccak(idx, separator - idx))\n            );\n    }\n}"
    },
    {
      "filename": "contracts/dnssec-oracle/algorithms/RSAVerify.sol",
      "content": "pragma solidity ^0.8.4;\n\nimport \"../BytesUtils.sol\";\nimport \"./ModexpPrecompile.sol\";\n\nlibrary RSAVerify {\n    /**\n     * @dev Recovers the input data from an RSA signature, returning the result in S.\n     * @param N The RSA public modulus.\n     * @param E The RSA public exponent.\n     * @param S The signature to recover.\n     * @return True if the recovery succeeded.\n     */\n    function rsarecover(\n        bytes memory N,\n        bytes memory E,\n        bytes memory S\n    ) internal view returns (bool, bytes memory) {\n        return ModexpPrecompile.modexp(S, E, N);\n    }\n}"
    },
    {
      "filename": "contracts/dnssec-oracle/algorithms/ModexpPrecompile.sol",
      "content": "pragma solidity ^0.8.4;\n\nlibrary ModexpPrecompile {\n    /**\n     * @dev Computes (base ^ exponent) % modulus over big numbers.\n     */\n    function modexp(\n        bytes memory base,\n        bytes memory exponent,\n        bytes memory modulus\n    ) internal view returns (bool success, bytes memory output) {\n        bytes memory input = abi.encodePacked(\n            uint256(base.length),\n            uint256(exponent.length),\n            uint256(modulus.length),\n            base,\n            exponent,\n            modulus\n        );\n\n        output = new bytes(modulus.length);\n\n        assembly {\n            success := staticcall(\n                gas(),\n                5,\n                add(input, 32),\n                mload(input),\n                add(output, 32),\n                mload(modulus)\n            )\n        }\n    }\n}"
    },
    {
      "filename": "contracts/dnssec-oracle/algorithms/P256SHA256Algorithm.sol",
      "content": "pragma solidity ^0.8.4;\n\nimport \"./Algorithm.sol\";\nimport \"./EllipticCurve.sol\";\nimport \"../BytesUtils.sol\";\n\ncontract P256SHA256Algorithm is Algorithm, EllipticCurve {\n    using BytesUtils for *;\n\n    /**\n     * @dev Verifies a signature.\n     * @param key The public key to verify with.\n     * @param data The signed data to verify.\n     * @param signature The signature to verify.\n     * @return True iff the signature is valid.\n     */\n    function verify(\n        bytes calldata key,\n        bytes calldata data,\n        bytes calldata signature\n    ) external view override returns (bool) {\n        return\n            validateSignature(\n                sha256(data),\n                parseSignature(signature),\n                parseKey(key)\n            );\n    }\n\n    function parseSignature(\n        bytes memory data\n    ) internal pure returns (uint256[2] memory) {\n        require(data.length == 64, \"Invalid p256 signature length\");\n        return [uint256(data.readBytes32(0)), uint256(data.readBytes32(32))];\n    }\n\n    function parseKey(\n        bytes memory data\n    ) internal pure returns (uint256[2] memory) {\n        require(data.length == 68, \"Invalid p256 key length\");\n        return [uint256(data.readBytes32(4)), uint256(data.readBytes32(36))];\n    }\n}"
    },
    {
      "filename": "contracts/dnssec-oracle/algorithms/P256SHA256Algorithm.sol",
      "content": "pragma solidity ^0.8.4;\n\nimport \"./Algorithm.sol\";\nimport \"./EllipticCurve.sol\";\nimport \"../BytesUtils.sol\";\n\ncontract P256SHA256Algorithm is Algorithm, EllipticCurve {\n    using BytesUtils for *;\n\n    /**\n     * @dev Verifies a signature.\n     * @param key The public key to verify with.\n     * @param data The signed data to verify.\n     * @param signature The signature to verify.\n     * @return True iff the signature is valid.\n     */\n    function verify(\n        bytes calldata key,\n        bytes calldata data,\n        bytes calldata signature\n    ) external view override returns (bool) {\n        return\n            validateSignature(\n                sha256(data),\n                parseSignature(signature),\n                parseKey(key)\n            );\n    }\n\n    function parseSignature(\n        bytes memory data\n    ) internal pure returns (uint256[2] memory) {\n        require(data.length == 64, \"Invalid p256 signature length\");\n        return [uint256(data.readBytes32(0)), uint256(data.readBytes32(32))];\n    }\n\n    function parseKey(\n        bytes memory data\n    ) internal pure returns (uint256[2] memory) {\n        require(data.length == 68, \"Invalid p256 key length\");\n        return [uint256(data.readBytes32(4)), uint256(data.readBytes32(36))];\n    }\n}"
    },
    {
      "filename": "contracts/utils/NameEncoder.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {BytesUtils} from \"../wrapper/BytesUtils.sol\";\n\nlibrary NameEncoder {\n    using BytesUtils for bytes;\n\n    function dnsEncodeName(\n        string memory name\n    ) internal pure returns (bytes memory dnsName, bytes32 node) {\n        uint8 labelLength = 0;\n        bytes memory bytesName = bytes(name);\n        uint256 length = bytesName.length;\n        dnsName = new bytes(length + 2);\n        node = 0;\n        if (length == 0) {\n            dnsName[0] = 0;\n            return (dnsName, node);\n        }\n\n        // use unchecked to save gas since we check for an underflow\n        // and we check for the length before the loop\n        unchecked {\n            for (uint256 i = length - 1; i >= 0; i--) {\n                if (bytesName[i] == \".\") {\n                    dnsName[i + 1] = bytes1(labelLength);\n                    node = keccak256(\n                        abi.encodePacked(\n                            node,\n                            bytesName.keccak(i + 1, labelLength)\n                        )\n                    );\n                    labelLength = 0;\n                } else {\n                    labelLength += 1;\n                    dnsName[i + 1] = bytesName[i];\n                }\n                if (i == 0) {\n                    break;\n                }\n            }\n        }\n\n        node = keccak256(\n            abi.encodePacked(node, bytesName.keccak(0, labelLength))\n        );\n\n        dnsName[0] = bytes1(labelLength);\n        return (dnsName, node);\n    }\n}"
    },
    {
      "filename": "contracts/utils/HexUtils.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nlibrary HexUtils {\n    /**\n     * @dev Attempts to parse bytes32 from a hex string\n     * @param str The string to parse\n     * @param idx The offset to start parsing at\n     * @param lastIdx The (exclusive) last index in `str` to consider. Use `str.length` to scan the whole string.\n     */\n    function hexStringToBytes32(\n        bytes memory str,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal pure returns (bytes32 r, bool valid) {\n        valid = true;\n        assembly {\n            // check that the index to read to is not past the end of the string\n            if gt(lastIdx, mload(str)) {\n                revert(0, 0)\n            }\n\n            function getHex(c) -> ascii {\n                // chars 48-57: 0-9\n                if and(gt(c, 47), lt(c, 58)) {\n                    ascii := sub(c, 48)\n                    leave\n                }\n                // chars 65-70: A-F\n                if and(gt(c, 64), lt(c, 71)) {\n                    ascii := add(sub(c, 65), 10)\n                    leave\n                }\n                // chars 97-102: a-f\n                if and(gt(c, 96), lt(c, 103)) {\n                    ascii := add(sub(c, 97), 10)\n                    leave\n                }\n                // invalid char\n                ascii := 0xff\n            }\n\n            let ptr := add(str, 32)\n            for {\n                let i := idx\n            } lt(i, lastIdx) {\n                i := add(i, 2)\n            } {\n                let byte1 := getHex(byte(0, mload(add(ptr, i))))\n                let byte2 := getHex(byte(0, mload(add(ptr, add(i, 1)))))\n                // if either byte is invalid, set invalid and break loop\n                if or(eq(byte1, 0xff), eq(byte2, 0xff)) {\n                    valid := false\n                    break\n                }\n                let combined := or(shl(4, byte1), byte2)\n                r := or(shl(8, r), combined)\n            }\n        }\n    }\n\n    /**\n     * @dev Attempts to parse an address from a hex string\n     * @param str The string to parse\n     * @param idx The offset to start parsing at\n     * @param lastIdx The (exclusive) last index in `str` to consider. Use `str.length` to scan the whole string.\n     */\n    function hexToAddress(\n        bytes memory str,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal pure returns (address, bool) {\n        if (lastIdx - idx < 40) return (address(0x0), false);\n        (bytes32 r, bool valid) = hexStringToBytes32(str, idx, lastIdx);\n        return (address(uint160(uint256(r))), valid);\n    }\n}"
    },
    {
      "filename": "contracts/utils/HexUtils.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nlibrary HexUtils {\n    /**\n     * @dev Attempts to parse bytes32 from a hex string\n     * @param str The string to parse\n     * @param idx The offset to start parsing at\n     * @param lastIdx The (exclusive) last index in `str` to consider. Use `str.length` to scan the whole string.\n     */\n    function hexStringToBytes32(\n        bytes memory str,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal pure returns (bytes32 r, bool valid) {\n        valid = true;\n        assembly {\n            // check that the index to read to is not past the end of the string\n            if gt(lastIdx, mload(str)) {\n                revert(0, 0)\n            }\n\n            function getHex(c) -> ascii {\n                // chars 48-57: 0-9\n                if and(gt(c, 47), lt(c, 58)) {\n                    ascii := sub(c, 48)\n                    leave\n                }\n                // chars 65-70: A-F\n                if and(gt(c, 64), lt(c, 71)) {\n                    ascii := add(sub(c, 65), 10)\n                    leave\n                }\n                // chars 97-102: a-f\n                if and(gt(c, 96), lt(c, 103)) {\n                    ascii := add(sub(c, 97), 10)\n                    leave\n                }\n                // invalid char\n                ascii := 0xff\n            }\n\n            let ptr := add(str, 32)\n            for {\n                let i := idx\n            } lt(i, lastIdx) {\n                i := add(i, 2)\n            } {\n                let byte1 := getHex(byte(0, mload(add(ptr, i))))\n                let byte2 := getHex(byte(0, mload(add(ptr, add(i, 1)))))\n                // if either byte is invalid, set invalid and break loop\n                if or(eq(byte1, 0xff), eq(byte2, 0xff)) {\n                    valid := false\n                    break\n                }\n                let combined := or(shl(4, byte1), byte2)\n                r := or(shl(8, r), combined)\n            }\n        }\n    }\n\n    /**\n     * @dev Attempts to parse an address from a hex string\n     * @param str The string to parse\n     * @param idx The offset to start parsing at\n     * @param lastIdx The (exclusive) last index in `str` to consider. Use `str.length` to scan the whole string.\n     */\n    function hexToAddress(\n        bytes memory str,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal pure returns (address, bool) {\n        if (lastIdx - idx < 40) return (address(0x0), false);\n        (bytes32 r, bool valid) = hexStringToBytes32(str, idx, lastIdx);\n        return (address(uint160(uint256(r))), valid);\n    }\n}"
    },
    {
      "filename": "contracts/dnsregistrar/DNSClaimChecker.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../dnssec-oracle/DNSSEC.sol\";\nimport \"../dnssec-oracle/BytesUtils.sol\";\nimport \"../dnssec-oracle/RRUtils.sol\";\nimport \"../utils/HexUtils.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\nlibrary DNSClaimChecker {\n    using BytesUtils for bytes;\n    using HexUtils for bytes;\n    using RRUtils for *;\n    using Buffer for Buffer.buffer;\n\n    uint16 constant CLASS_INET = 1;\n    uint16 constant TYPE_TXT = 16;\n\n    function getOwnerAddress(\n        bytes memory name,\n        bytes memory data\n    ) internal pure returns (address, bool) {\n        // Add \"_ens.\" to the front of the name.\n        Buffer.buffer memory buf;\n        buf.init(name.length + 5);\n        buf.append(\"\\x04_ens\");\n        buf.append(name);\n\n        for (\n            RRUtils.RRIterator memory iter = data.iterateRRs(0);\n            !iter.done();\n            iter.next()\n        ) {\n            if (iter.name().compareNames(buf.buf) != 0) continue;\n            bool found;\n            address addr;\n            (addr, found) = parseRR(data, iter.rdataOffset, iter.nextOffset);\n            if (found) {\n                return (addr, true);\n            }\n        }\n\n        return (address(0x0), false);\n    }\n\n    function parseRR(\n        bytes memory rdata,\n        uint256 idx,\n        uint256 endIdx\n    ) internal pure returns (address, bool) {\n        while (idx < endIdx) {\n            uint256 len = rdata.readUint8(idx);\n            idx += 1;\n\n            bool found;\n            address addr;\n            (addr, found) = parseString(rdata, idx, len);\n\n            if (found) return (addr, true);\n            idx += len;\n        }\n\n        return (address(0x0), false);\n    }\n\n    function parseString(\n        bytes memory str,\n        uint256 idx,\n        uint256 len\n    ) internal pure returns (address, bool) {\n        // TODO: More robust parsing that handles whitespace and multiple key/value pairs\n        if (str.readUint32(idx) != 0x613d3078) return (address(0x0), false); // 0x613d3078 == 'a=0x'\n        return str.hexToAddress(idx + 4, idx + len);\n    }\n}"
    },
    {
      "filename": "contracts/dnsregistrar/DNSClaimChecker.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../dnssec-oracle/DNSSEC.sol\";\nimport \"../dnssec-oracle/BytesUtils.sol\";\nimport \"../dnssec-oracle/RRUtils.sol\";\nimport \"../utils/HexUtils.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\nlibrary DNSClaimChecker {\n    using BytesUtils for bytes;\n    using HexUtils for bytes;\n    using RRUtils for *;\n    using Buffer for Buffer.buffer;\n\n    uint16 constant CLASS_INET = 1;\n    uint16 constant TYPE_TXT = 16;\n\n    function getOwnerAddress(\n        bytes memory name,\n        bytes memory data\n    ) internal pure returns (address, bool) {\n        // Add \"_ens.\" to the front of the name.\n        Buffer.buffer memory buf;\n        buf.init(name.length + 5);\n        buf.append(\"\\x04_ens\");\n        buf.append(name);\n\n        for (\n            RRUtils.RRIterator memory iter = data.iterateRRs(0);\n            !iter.done();\n            iter.next()\n        ) {\n            if (iter.name().compareNames(buf.buf) != 0) continue;\n            bool found;\n            address addr;\n            (addr, found) = parseRR(data, iter.rdataOffset, iter.nextOffset);\n            if (found) {\n                return (addr, true);\n            }\n        }\n\n        return (address(0x0), false);\n    }\n\n    function parseRR(\n        bytes memory rdata,\n        uint256 idx,\n        uint256 endIdx\n    ) internal pure returns (address, bool) {\n        while (idx < endIdx) {\n            uint256 len = rdata.readUint8(idx);\n            idx += 1;\n\n            bool found;\n            address addr;\n            (addr, found) = parseString(rdata, idx, len);\n\n            if (found) return (addr, true);\n            idx += len;\n        }\n\n        return (address(0x0), false);\n    }\n\n    function parseString(\n        bytes memory str,\n        uint256 idx,\n        uint256 len\n    ) internal pure returns (address, bool) {\n        // TODO: More robust parsing that handles whitespace and multiple key/value pairs\n        if (str.readUint32(idx) != 0x613d3078) return (address(0x0), false); // 0x613d3078 == 'a=0x'\n        return str.hexToAddress(idx + 4, idx + len);\n    }\n}"
    },
    {
      "filename": "contracts/dnsregistrar/DNSClaimChecker.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../dnssec-oracle/DNSSEC.sol\";\nimport \"../dnssec-oracle/BytesUtils.sol\";\nimport \"../dnssec-oracle/RRUtils.sol\";\nimport \"../utils/HexUtils.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\nlibrary DNSClaimChecker {\n    using BytesUtils for bytes;\n    using HexUtils for bytes;\n    using RRUtils for *;\n    using Buffer for Buffer.buffer;\n\n    uint16 constant CLASS_INET = 1;\n    uint16 constant TYPE_TXT = 16;\n\n    function getOwnerAddress(\n        bytes memory name,\n        bytes memory data\n    ) internal pure returns (address, bool) {\n        // Add \"_ens.\" to the front of the name.\n        Buffer.buffer memory buf;\n        buf.init(name.length + 5);\n        buf.append(\"\\x04_ens\");\n        buf.append(name);\n\n        for (\n            RRUtils.RRIterator memory iter = data.iterateRRs(0);\n            !iter.done();\n            iter.next()\n        ) {\n            if (iter.name().compareNames(buf.buf) != 0) continue;\n            bool found;\n            address addr;\n            (addr, found) = parseRR(data, iter.rdataOffset, iter.nextOffset);\n            if (found) {\n                return (addr, true);\n            }\n        }\n\n        return (address(0x0), false);\n    }\n\n    function parseRR(\n        bytes memory rdata,\n        uint256 idx,\n        uint256 endIdx\n    ) internal pure returns (address, bool) {\n        while (idx < endIdx) {\n            uint256 len = rdata.readUint8(idx);\n            idx += 1;\n\n            bool found;\n            address addr;\n            (addr, found) = parseString(rdata, idx, len);\n\n            if (found) return (addr, true);\n            idx += len;\n        }\n\n        return (address(0x0), false);\n    }\n\n    function parseString(\n        bytes memory str,\n        uint256 idx,\n        uint256 len\n    ) internal pure returns (address, bool) {\n        // TODO: More robust parsing that handles whitespace and multiple key/value pairs\n        if (str.readUint32(idx) != 0x613d3078) return (address(0x0), false); // 0x613d3078 == 'a=0x'\n        return str.hexToAddress(idx + 4, idx + len);\n    }\n}"
    },
    {
      "filename": "contracts/dnssec-oracle/BytesUtils.sol",
      "content": "pragma solidity ^0.8.4;\n\nlibrary BytesUtils {\n    error OffsetOutOfBoundsError(uint256 offset, uint256 length);\n\n    /*\n     * @dev Returns the keccak-256 hash of a byte range.\n     * @param self The byte string to hash.\n     * @param offset The position to start hashing at.\n     * @param len The number of bytes to hash.\n     * @return The hash of the byte range.\n     */\n    function keccak(\n        bytes memory self,\n        uint256 offset,\n        uint256 len\n    ) internal pure returns (bytes32 ret) {\n        require(offset + len <= self.length);\n        assembly {\n            ret := keccak256(add(add(self, 32), offset), len)\n        }\n    }\n\n    /*\n     * @dev Returns a positive number if `other` comes lexicographically after\n     *      `self`, a negative number if it comes before, or zero if the\n     *      contents of the two bytes are equal.\n     * @param self The first bytes to compare.\n     * @param other The second bytes to compare.\n     * @return The result of the comparison.\n     */\n    function compare(\n        bytes memory self,\n        bytes memory other\n    ) internal pure returns (int256) {\n        return compare(self, 0, self.length, other, 0, other.length);\n    }\n\n    /*\n     * @dev Returns a positive number if `other` comes lexicographically after\n     *      `self`, a negative number if it comes before, or zero if the\n     *      contents of the two bytes are equal. Comparison is done per-rune,\n     *      on unicode codepoints.\n     * @param self The first bytes to compare.\n     * @param offset The offset of self.\n     * @param len    The length of self.\n     * @param other The second bytes to compare.\n     * @param otheroffset The offset of the other string.\n     * @param otherlen    The length of the other string.\n     * @return The result of the comparison.\n     */\n    function compare(\n        bytes memory self,\n        uint256 offset,\n        uint256 len,\n        bytes memory other,\n        uint256 otheroffset,\n        uint256 otherlen\n    ) internal pure returns (int256) {\n        if (offset + len > self.length) {\n            revert OffsetOutOfBoundsError(offset + len, self.length);\n        }\n        if (otheroffset + otherlen > other.length) {\n            revert OffsetOutOfBoundsError(otheroffset + otherlen, other.length);\n        }\n\n        uint256 shortest = len;\n        if (otherlen < len) shortest = otherlen;\n\n        uint256 selfptr;\n        uint256 otherptr;\n\n        assembly {\n            selfptr := add(self, add(offset, 32))\n            otherptr := add(other, add(otheroffset, 32))\n        }\n        for (uint256 idx = 0; idx < shortest; idx += 32) {\n            uint256 a;\n            uint256 b;\n            assembly {\n                a := mload(selfptr)\n                b := mload(otherptr)\n            }\n            if (a != b) {\n                // Mask out irrelevant bytes and check again\n                uint256 mask;\n                if (shortest - idx >= 32) {\n                    mask = type(uint256).max;\n                } else {\n                    mask = ~(2 ** (8 * (idx + 32 - shortest)) - 1);\n                }\n                int256 diff = int256(a & mask) - int256(b & mask);\n                if (diff != 0) return diff;\n            }\n            selfptr += 32;\n            otherptr += 32;\n        }\n\n        return int256(len) - int256(otherlen);\n    }\n\n    /*\n     * @dev Returns true if the two byte ranges are equal.\n     * @param self The first byte range to compare.\n     * @param offset The offset into the first byte range.\n     * @param other The second byte range to compare.\n     * @param otherOffset The offset into the second byte range.\n     * @param len The number of bytes to compare\n     * @return True if the byte ranges are equal, false otherwise.\n     */\n    function equals(\n        bytes memory self,\n        uint256 offset,\n        bytes memory other,\n        uint256 otherOffset,\n        uint256 len\n    ) internal pure returns (bool) {\n        return keccak(self, offset, len) == keccak(other, otherOffset, len);\n    }\n\n    /*\n     * @dev Returns true if the two byte ranges are equal with offsets.\n     * @param self The first byte range to compare.\n     * @param offset The offset into the first byte range.\n     * @param other The second byte range to compare.\n     * @param otherOffset The offset into the second byte range.\n     * @return True if the byte ranges are equal, false otherwise.\n     */\n    function equals(\n        bytes memory self,\n        uint256 offset,\n        bytes memory other,\n        uint256 otherOffset\n    ) internal pure returns (bool) {\n        return\n            keccak(self, offset, self.length - offset) ==\n            keccak(other, otherOffset, other.length - otherOffset);\n    }\n\n    /*\n     * @dev Compares a range of 'self' to all of 'other' and returns True iff\n     *      they are equal.\n     * @param self The first byte range to compare.\n     * @param offset The offset into the first byte range.\n     * @param other The second byte range to compare.\n     * @return True if the byte ranges are equal, false otherwise.\n     */\n    function equals(\n        bytes memory self,\n        uint256 offset,\n        bytes memory other\n    ) internal pure returns (bool) {\n        return\n            self.length == offset + other.length &&\n            equals(self, offset, other, 0, other.length);\n    }\n\n    /*\n     * @dev Returns true if the two byte ranges are equal.\n     * @param self The first byte range to compare.\n     * @param other The second byte range to compare.\n     * @return True if the byte ranges are equal, false otherwise.\n     */\n    function equals(\n        bytes memory self,\n        bytes memory other\n    ) internal pure returns (bool) {\n        return\n            self.length == other.length &&\n            equals(self, 0, other, 0, self.length);\n    }\n\n    /*\n     * @dev Returns the 8-bit number at the specified index of self.\n     * @param self The byte string.\n     * @param idx The index into the bytes\n     * @return The specified 8 bits of the string, interpreted as an integer.\n     */\n    function readUint8(\n        bytes memory self,\n        uint256 idx\n    ) internal pure returns (uint8 ret) {\n        return uint8(self[idx]);\n    }\n\n    /*\n     * @dev Returns the 16-bit number at the specified index of self.\n     * @param self The byte string.\n     * @param idx The index into the bytes\n     * @return The specified 16 bits of the string, interpreted as an integer.\n     */\n    function readUint16(\n        bytes memory self,\n        uint256 idx\n    ) internal pure returns (uint16 ret) {\n        require(idx + 2 <= self.length);\n        assembly {\n            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)\n        }\n    }\n\n    /*\n     * @dev Returns the 32-bit number at the specified index of self.\n     * @param self The byte string.\n     * @param idx The index into the bytes\n     * @return The specified 32 bits of the string, interpreted as an integer.\n     */\n    function readUint32(\n        bytes memory self,\n        uint256 idx\n    ) internal pure returns (uint32 ret) {\n        require(idx + 4 <= self.length);\n        assembly {\n            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)\n        }\n    }\n\n    /*\n     * @dev Returns the 32 byte value at the specified index of self.\n     * @param self The byte string.\n     * @param idx The index into the bytes\n     * @return The specified 32 bytes of the string.\n     */\n    function readBytes32(\n        bytes memory self,\n        uint256 idx\n    ) internal pure returns (bytes32 ret) {\n        require(idx + 32 <= self.length);\n        assembly {\n            ret := mload(add(add(self, 32), idx))\n        }\n    }\n\n    /*\n     * @dev Returns the 32 byte value at the specified index of self.\n     * @param self The byte string.\n     * @param idx The index into the bytes\n     * @return The specified 32 bytes of the string.\n     */\n    function readBytes20(\n        bytes memory self,\n        uint256 idx\n    ) internal pure retur"
    }
  ]
}