{
  "Title": "Token Bridging doesn't work with Wormhole fees",
  "Content": "##### Description\nLine \n- https://github.com/certusone/wormhole/blob/9bc408ca1912e7000c5c2085215be9d44713028b/ethereum/contracts/bridge/Bridge.sol#L93\nhas a `transferTokens ()` function of type `payable`. In the body of this function, on line 133, a call to the internal \nfunction `logTransfer ()` is made and one of the parameters `msg.value` is passed.\nAt line  \n- https://github.com/certusone/wormhole/blob/9bc408ca1912e7000c5c2085215be9d44713028b/ethereum/contracts/bridge/Bridge.sol#L151\nfrom the `logTransfer()` function, the `publishMessage()` function is called.\nThe `publishMessage()` function of type `payable` on the line:\n- https://github.com/certusone/wormhole/blob/9bc408ca1912e7000c5c2085215be9d44713028b/ethereum/contracts/Implementation.sol#L21\nthe condition for payment of the commission must be met.\n```\n   require(msg.value == messageFee(), \"invalid fee\");\n```\n\nIn the checked contract, at line \n- https://github.com/lidofinance/anchor-collateral-steth/blob/8d52ce72cb42d48dff1851222e3b624c941ddb30/contracts/BridgeConnectorWormhole.vy#L49\na call to the `transferTokens()` function from the `_transfer_asset()` function is made. \nBut there is no `@payable` modifier anywhere and no `msg.value` value handling.\nTherefore, the `_transfer_asset()` function will not work.\nAs a result, the `submit ()` and `collect_rewards ()` functions will not work in the `AnchorVault.vy` contract, \nbecause there is no commission fee for the `Wormhole` system.\n##### Recommendation\nIt is required to add a commission payment for the `Wormhole` system.",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "ethereum/contracts/bridge/Bridge.sol",
      "content": "// contracts/Bridge.sol\n// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libraries/external/BytesLib.sol\";\n\nimport \"./BridgeGetters.sol\";\nimport \"./BridgeSetters.sol\";\nimport \"./BridgeStructs.sol\";\nimport \"./BridgeGovernance.sol\";\n\nimport \"./token/Token.sol\";\nimport \"./token/TokenImplementation.sol\";\n\ncontract Bridge is BridgeGovernance {\n    using BytesLib for bytes;\n\n    // Produce a AssetMeta message for a given token\n    function attestToken(address tokenAddress, uint32 nonce) public payable returns (uint64 sequence){\n        // decimals, symbol & token are not part of the core ERC20 token standard, so we need to support contracts that dont implement them\n        (,bytes memory queriedDecimals) = tokenAddress.staticcall(abi.encodeWithSignature(\"decimals()\"));\n        (,bytes memory queriedSymbol) = tokenAddress.staticcall(abi.encodeWithSignature(\"symbol()\"));\n        (,bytes memory queriedName) = tokenAddress.staticcall(abi.encodeWithSignature(\"name()\"));\n\n        uint8 decimals = abi.decode(queriedDecimals, (uint8));\n\n        string memory symbolString = abi.decode(queriedSymbol, (string));\n        string memory nameString = abi.decode(queriedName, (string));\n\n        bytes32 symbol;\n        bytes32 name;\n        assembly {\n        // first 32 bytes hold string length\n            symbol := mload(add(symbolString, 32))\n            name := mload(add(nameString, 32))\n        }\n\n        BridgeStructs.AssetMeta memory meta = BridgeStructs.AssetMeta({\n        payloadID : 2,\n        // Address of the token. Left-zero-padded if shorter than 32 bytes\n        tokenAddress : bytes32(uint256(uint160(tokenAddress))),\n        // Chain ID of the token\n        tokenChain : chainId(),\n        // Number of decimals of the token (big-endian uint8)\n        decimals : decimals,\n        // Symbol of the token (UTF-8)\n        symbol : symbol,\n        // Name of the token (UTF-8)\n        name : name\n        });\n\n        bytes memory encoded = encodeAssetMeta(meta);\n\n        sequence = wormhole().publishMessage{\n        value : msg.value\n        }(nonce, encoded, 15);\n    }\n\n    function wrapAndTransferETH(uint16 recipientChain, bytes32 recipient, uint256 arbiterFee, uint32 nonce) public payable returns (uint64 sequence) {\n        uint wormholeFee = wormhole().messageFee();\n\n        require(wormholeFee < msg.value, \"value is smaller than wormhole fee\");\n\n        uint amount = msg.value - wormholeFee;\n\n        require(arbiterFee <= amount, \"fee is bigger than amount minus wormhole fee\");\n\n        uint normalizedAmount = amount / (10 ** 10);\n        uint normalizedArbiterFee = arbiterFee / (10 ** 10);\n\n        // refund dust\n        uint dust = amount - (normalizedAmount * (10 ** 10));\n        if (dust > 0) {\n            payable(msg.sender).transfer(dust);\n        }\n\n        // deposit into WETH\n        WETH().deposit{\n        value : amount - dust\n        }();\n\n        // track and check outstanding token amounts\n        bridgeOut(address(WETH()), normalizedAmount);\n\n        sequence = logTransfer(chainId(), bytes32(uint256(uint160(address(WETH())))), normalizedAmount, recipientChain, recipient, normalizedArbiterFee, wormholeFee, nonce);\n    }\n\n    // Initiate a Transfer\n    function transferTokens(address token, uint256 amount, uint16 recipientChain, bytes32 recipient, uint256 arbiterFee, uint32 nonce) public payable returns (uint64 sequence) {\n        // determine token parameters\n        uint16 tokenChain;\n        bytes32 tokenAddress;\n        if (isWrappedAsset(token)) {\n            tokenChain = TokenImplementation(token).chainId();\n            tokenAddress = TokenImplementation(token).nativeContract();\n        } else {\n            tokenChain = chainId();\n            tokenAddress = bytes32(uint256(uint160(token)));\n        }\n\n        // query tokens decimals\n        (,bytes memory queriedDecimals) = token.staticcall(abi.encodeWithSignature(\"decimals()\"));\n        uint8 decimals = abi.decode(queriedDecimals, (uint8));\n\n        // adjust decimals\n        uint256 normalizedAmount = amount;\n        uint256 normalizedArbiterFee = arbiterFee;\n        if (decimals > 8) {\n            uint multiplier = 10 ** (decimals - 8);\n\n            normalizedAmount /= multiplier;\n            normalizedArbiterFee /= multiplier;\n\n            // don't deposit dust that can not be bridged due to the decimal shift\n            amount = normalizedAmount * multiplier;\n        }\n\n        if (tokenChain == chainId()) {\n            SafeERC20.safeTransferFrom(IERC20(token), msg.sender, address(this), amount);\n\n            // track and check outstanding token amounts\n            bridgeOut(token, normalizedAmount);\n        } else {\n            SafeERC20.safeTransferFrom(IERC20(token), msg.sender, address(this), amount);\n\n            TokenImplementation(token).burn(address(this), amount);\n        }\n\n        sequence = logTransfer(tokenChain, tokenAddress, normalizedAmount, recipientChain, recipient, normalizedArbiterFee, msg.value, nonce);\n    }\n\n    function logTransfer(uint16 tokenChain, bytes32 tokenAddress, uint256 amount, uint16 recipientChain, bytes32 recipient, uint256 fee, uint256 callValue, uint32 nonce) internal returns (uint64 sequence) {\n        require(fee <= amount, \"fee exceeds amount\");\n\n        BridgeStructs.Transfer memory transfer = BridgeStructs.Transfer({\n        payloadID : 1,\n        amount : amount,\n        tokenAddress : tokenAddress,\n        tokenChain : tokenChain,\n        to : recipient,\n        toChain : recipientChain,\n        fee : fee\n        });\n\n        bytes memory encoded = encodeTransfer(transfer);\n\n        sequence = wormhole().publishMessage{\n        value : callValue\n        }(nonce, encoded, 15);\n    }\n\n    function updateWrapped(bytes memory encodedVm) external returns (address token) {\n        (IWormhole.VM memory vm, bool valid, string memory reason) = wormhole().parseAndVerifyVM(encodedVm);\n\n        require(valid, reason);\n        require(verifyBridgeVM(vm), \"invalid emitter\");\n\n        BridgeStructs.AssetMeta memory meta = parseAssetMeta(vm.payload);\n        return _updateWrapped(meta, vm.sequence);\n    }\n\n    function _updateWrapped(BridgeStructs.AssetMeta memory meta, uint64 sequence) internal returns (address token) {\n        address wrapped = wrappedAsset(meta.tokenChain, meta.tokenAddress);\n        require(wrapped != address(0), \"wrapped asset does not exists\");\n\n        // Update metadata\n        TokenImplementation(wrapped).updateDetails(bytes32ToString(meta.name), bytes32ToString(meta.symbol), sequence);\n\n        return wrapped;\n    }\n\n    function createWrapped(bytes memory encodedVm) external returns (address token) {\n        (IWormhole.VM memory vm, bool valid, string memory reason) = wormhole().parseAndVerifyVM(encodedVm);\n\n        require(valid, reason);\n        require(verifyBridgeVM(vm), \"invalid emitter\");\n\n        BridgeStructs.AssetMeta memory meta = parseAssetMeta(vm.payload);\n        return _createWrapped(meta, vm.sequence);\n    }\n\n    // Creates a wrapped asset using AssetMeta\n    function _createWrapped(BridgeStructs.AssetMeta memory meta, uint64 sequence) internal returns (address token) {\n        require(meta.tokenChain != chainId(), \"can only wrap tokens from foreign chains\");\n        require(wrappedAsset(meta.tokenChain, meta.tokenAddress) == address(0), \"wrapped asset already exists\");\n\n        // initialize the TokenImplementation\n        bytes memory initialisationArgs = abi.encodeWithSelector(\n            TokenImplementation.initialize.selector,\n            bytes32ToString(meta.name),\n            bytes32ToString(meta.symbol),\n            meta.decimals,\n            sequence,\n\n            address(this),\n\n            meta.tokenChain,\n            meta.tokenAddress\n        );\n\n        // initialize the BeaconProxy\n        bytes memory constructorArgs = abi.encode(address(this), initialisationArgs);\n\n        // deployment code\n        bytes memory bytecode = abi.encodePacked(type(BridgeToken).creationCode, constructorArgs);\n\n        bytes32 salt = keccak256(abi.encodePacked(meta.tokenChain, meta.tokenAddress));\n\n        assembly {\n            token := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\n\n            if iszero(extcodesize(token)) {\n                revert(0, 0)\n            }\n        }\n\n        setWrappedAsset(meta.tokenChain, meta.tokenAddress, token);\n    }\n\n    function completeTransfer(bytes memory encodedVm) public {\n        _completeTransfer(encodedVm, false);\n    }\n\n    function completeTransferAndUnwrapETH(bytes memory encodedVm) public {\n        _completeTransfer(encodedVm, true);\n    }\n\n    // Execute a Transfer message\n    function _completeTransfer(bytes memory encodedVm, bool unwrapWETH) internal {\n        (IWormhole.VM memory vm, bool valid, string memory reason) = wormhole().parseAndVerifyVM(encodedVm);\n\n        require(valid, reason);\n        require(verifyBridgeVM(vm), \"invalid emitter\");\n\n        BridgeStructs.Transfer memory transfer = parseTransfer(vm.payload);\n\n        require(!isTransferCompleted(vm.hash), \"transfer already completed\");\n        setTransferCompleted(vm.hash);\n\n        require(transfer.toChain == chainId(), \"invalid target chain\");\n\n        IERC20 transferToken;\n        if (transfer.tokenChain == chainId()) {\n            transferToken = IERC20(address(uint160(uint256(transfer.tokenAddress))));\n\n            // track outstanding token amounts\n            bridgedIn(address(transferToken), transfer.amount);\n        } else {\n            address wrapped = wrappedAsset(transfer.tokenChain, transfer.tokenAddress);\n            require(wrapped != address(0), \"no wrapper for this token created yet\");\n\n            transferToken = IERC20(wrapped);\n        }\n\n        require(unwrapWETH == false || address(transferToken) == address(WETH()), \"invalid token, can only unwrap WETH\");\n\n        // query decimals\n        (,bytes memory queriedDecimals) = address(transferToken).staticcall(abi.encodeWithSignature(\"decimals()\"));\n        uint8 decimals = abi.decode(queriedDecimals, (uint8));\n\n        // adjust decimals\n        uint256 nativeAmount = transfer.amount;\n        uint256 nativeFee = transfer.fee;\n        if (decimals > 8) {\n            uint multiplier = 10 ** (decimals - 8);\n            nativeAmount *= multiplier;\n            nativeFee *= multiplier;\n        }\n\n        // transfer fee to arbiter\n        if (nativeFee > 0) {\n            require(nativeFee <= nativeAmount, \"fee higher than transferred amount\");\n\n            if (unwrapWETH) {\n                WETH().withdraw(nativeFee);\n\n                payable(msg.sender).transfer(nativeFee);\n            } else {\n                if (transfer.tokenChain != chainId()) {\n                    // mint wrapped asset\n                    TokenImplementation(address(transferToken)).mint(msg.sender, nativeFee);\n                } else {\n                    SafeERC20.safeTransfer(transferToken, msg.sender, nativeFee);\n                }\n            }\n        }\n\n        // transfer bridged amount to recipient\n        uint transferAmount = nativeAmount - nativeFee;\n        address transferRecipient = address(uint160(uint256(transfer.to)));\n\n        if (unwrapWETH) {\n            WETH().withdraw(transferAmount);\n\n            payable(transferRecipient).transfer(transferAmount);\n        } else {\n            if (transfer.tokenChain != chainId()) {\n                // mint wrapped asset\n                TokenImplementation(address(transferToken)).mint(transferRecipient, transferAmount);\n            } else {\n                SafeERC20.safeTransfer(transferToken, transferRecipient, transferAmount);\n            }\n        }\n    }\n\n    function bridgeOut(address token, uint normalizedAmount) internal {\n        uint outstanding = outstandingBridged(token);\n        require(outstanding + normalizedAmount <= type(uint64).max, \"transfer exceeds max outstanding bridged token amount\");\n        setOutstandingBridged(token, outstanding + normalizedAmount);\n    }\n\n    function bridgedIn(address token, uint normalizedAmount) internal {\n        setOutstandingBridged(token, outstandingBridged(token) - normalizedAmount);\n    }\n\n    function verifyBridgeVM(IWormhole.VM memory vm) internal view returns (bool){\n        if (bridgeContracts(vm.emitterChainId) == vm.emitterAddress) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function encodeAssetMeta(BridgeStructs.AssetMeta memory meta) public pure returns (bytes memory encoded) {\n        encoded = abi.encodePacked(\n            meta.payloadID,\n            meta.tokenAddress,\n            meta.tokenChain,\n            meta.decimals,\n            meta.symbol,\n            meta.name\n        );\n    }\n\n    function encodeTransfer(BridgeStructs.Transfer memory transfer) public pure returns (bytes memory encoded) {\n        encoded = abi.encodePacked(\n            transfer.payloadID,\n            transfer.amount,\n            transfer.tokenAddress,\n            transfer.tokenChain,\n            transfer.to,\n            transfer.toChain,\n            transfer.fee\n        );\n    }\n\n    function parseAssetMeta(bytes memory encoded) public pure returns (BridgeStructs.AssetMeta memory meta) {\n        uint index = 0;\n\n        meta.payloadID = encoded.toUint8(index);\n        index += 1;\n\n        require(meta.payloadID == 2, \"invalid AssetMeta\");\n\n        meta.tokenAddress = encoded.toBytes32(index);\n        index += 32;\n\n        meta.tokenChain = encoded.toUint16(index);\n        index += 2;\n\n        meta.decimals = encoded.toUint8(index);\n        index += 1;\n\n        meta.symbol = encoded.toBytes32(index);\n        index += 32;\n\n        meta.name = encoded.toBytes32(index);\n        index += 32;\n\n        require(encoded.length == index, \"invalid AssetMeta\");\n    }\n\n    function parseTransfer(bytes memory encoded) public pure returns (BridgeStructs.Transfer memory transfer) {\n        uint index = 0;\n\n        transfer.payloadID = encoded.toUint8(index);\n        index += 1;\n\n        require(transfer.payloadID == 1, \"invalid Transfer\");\n\n        transfer.amount = encoded.toUint256(index);\n        index += 32;\n\n        transfer.tokenAddress = encoded.toBytes32(index);\n        index += 32;\n\n        transfer.tokenChain = encoded.toUint16(index);\n        index += 2;\n\n        transfer.to = encoded.toBytes32(index);\n        index += 32;\n\n        transfer.toChain = encoded.toUint16(index);\n        index += 2;\n\n        transfer.fee = encoded.toUint256(index);\n        index += 32;\n\n        require(encoded.length == index, \"invalid Transfer\");\n    }\n\n    function bytes32ToString(bytes32 input) internal pure returns (string memory) {\n        uint256 i;\n        while (i < 32 && input[i] != 0) {\n            i++;\n        }\n        bytes memory array = new bytes(i);\n        for (uint c = 0; c < i; c++) {\n            array[c] = input[c];\n        }\n        return string(array);\n    }\n\n    // we need to accept ETH sends to unwrap WETH\n    receive() external payable {}\n}"
    },
    {
      "filename": "ethereum/contracts/bridge/Bridge.sol",
      "content": "// contracts/Bridge.sol\n// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libraries/external/BytesLib.sol\";\n\nimport \"./BridgeGetters.sol\";\nimport \"./BridgeSetters.sol\";\nimport \"./BridgeStructs.sol\";\nimport \"./BridgeGovernance.sol\";\n\nimport \"./token/Token.sol\";\nimport \"./token/TokenImplementation.sol\";\n\ncontract Bridge is BridgeGovernance {\n    using BytesLib for bytes;\n\n    // Produce a AssetMeta message for a given token\n    function attestToken(address tokenAddress, uint32 nonce) public payable returns (uint64 sequence){\n        // decimals, symbol & token are not part of the core ERC20 token standard, so we need to support contracts that dont implement them\n        (,bytes memory queriedDecimals) = tokenAddress.staticcall(abi.encodeWithSignature(\"decimals()\"));\n        (,bytes memory queriedSymbol) = tokenAddress.staticcall(abi.encodeWithSignature(\"symbol()\"));\n        (,bytes memory queriedName) = tokenAddress.staticcall(abi.encodeWithSignature(\"name()\"));\n\n        uint8 decimals = abi.decode(queriedDecimals, (uint8));\n\n        string memory symbolString = abi.decode(queriedSymbol, (string));\n        string memory nameString = abi.decode(queriedName, (string));\n\n        bytes32 symbol;\n        bytes32 name;\n        assembly {\n        // first 32 bytes hold string length\n            symbol := mload(add(symbolString, 32))\n            name := mload(add(nameString, 32))\n        }\n\n        BridgeStructs.AssetMeta memory meta = BridgeStructs.AssetMeta({\n        payloadID : 2,\n        // Address of the token. Left-zero-padded if shorter than 32 bytes\n        tokenAddress : bytes32(uint256(uint160(tokenAddress))),\n        // Chain ID of the token\n        tokenChain : chainId(),\n        // Number of decimals of the token (big-endian uint8)\n        decimals : decimals,\n        // Symbol of the token (UTF-8)\n        symbol : symbol,\n        // Name of the token (UTF-8)\n        name : name\n        });\n\n        bytes memory encoded = encodeAssetMeta(meta);\n\n        sequence = wormhole().publishMessage{\n        value : msg.value\n        }(nonce, encoded, 15);\n    }\n\n    function wrapAndTransferETH(uint16 recipientChain, bytes32 recipient, uint256 arbiterFee, uint32 nonce) public payable returns (uint64 sequence) {\n        uint wormholeFee = wormhole().messageFee();\n\n        require(wormholeFee < msg.value, \"value is smaller than wormhole fee\");\n\n        uint amount = msg.value - wormholeFee;\n\n        require(arbiterFee <= amount, \"fee is bigger than amount minus wormhole fee\");\n\n        uint normalizedAmount = amount / (10 ** 10);\n        uint normalizedArbiterFee = arbiterFee / (10 ** 10);\n\n        // refund dust\n        uint dust = amount - (normalizedAmount * (10 ** 10));\n        if (dust > 0) {\n            payable(msg.sender).transfer(dust);\n        }\n\n        // deposit into WETH\n        WETH().deposit{\n        value : amount - dust\n        }();\n\n        // track and check outstanding token amounts\n        bridgeOut(address(WETH()), normalizedAmount);\n\n        sequence = logTransfer(chainId(), bytes32(uint256(uint160(address(WETH())))), normalizedAmount, recipientChain, recipient, normalizedArbiterFee, wormholeFee, nonce);\n    }\n\n    // Initiate a Transfer\n    function transferTokens(address token, uint256 amount, uint16 recipientChain, bytes32 recipient, uint256 arbiterFee, uint32 nonce) public payable returns (uint64 sequence) {\n        // determine token parameters\n        uint16 tokenChain;\n        bytes32 tokenAddress;\n        if (isWrappedAsset(token)) {\n            tokenChain = TokenImplementation(token).chainId();\n            tokenAddress = TokenImplementation(token).nativeContract();\n        } else {\n            tokenChain = chainId();\n            tokenAddress = bytes32(uint256(uint160(token)));\n        }\n\n        // query tokens decimals\n        (,bytes memory queriedDecimals) = token.staticcall(abi.encodeWithSignature(\"decimals()\"));\n        uint8 decimals = abi.decode(queriedDecimals, (uint8));\n\n        // adjust decimals\n        uint256 normalizedAmount = amount;\n        uint256 normalizedArbiterFee = arbiterFee;\n        if (decimals > 8) {\n            uint multiplier = 10 ** (decimals - 8);\n\n            normalizedAmount /= multiplier;\n            normalizedArbiterFee /= multiplier;\n\n            // don't deposit dust that can not be bridged due to the decimal shift\n            amount = normalizedAmount * multiplier;\n        }\n\n        if (tokenChain == chainId()) {\n            SafeERC20.safeTransferFrom(IERC20(token), msg.sender, address(this), amount);\n\n            // track and check outstanding token amounts\n            bridgeOut(token, normalizedAmount);\n        } else {\n            SafeERC20.safeTransferFrom(IERC20(token), msg.sender, address(this), amount);\n\n            TokenImplementation(token).burn(address(this), amount);\n        }\n\n        sequence = logTransfer(tokenChain, tokenAddress, normalizedAmount, recipientChain, recipient, normalizedArbiterFee, msg.value, nonce);\n    }\n\n    function logTransfer(uint16 tokenChain, bytes32 tokenAddress, uint256 amount, uint16 recipientChain, bytes32 recipient, uint256 fee, uint256 callValue, uint32 nonce) internal returns (uint64 sequence) {\n        require(fee <= amount, \"fee exceeds amount\");\n\n        BridgeStructs.Transfer memory transfer = BridgeStructs.Transfer({\n        payloadID : 1,\n        amount : amount,\n        tokenAddress : tokenAddress,\n        tokenChain : tokenChain,\n        to : recipient,\n        toChain : recipientChain,\n        fee : fee\n        });\n\n        bytes memory encoded = encodeTransfer(transfer);\n\n        sequence = wormhole().publishMessage{\n        value : callValue\n        }(nonce, encoded, 15);\n    }\n\n    function updateWrapped(bytes memory encodedVm) external returns (address token) {\n        (IWormhole.VM memory vm, bool valid, string memory reason) = wormhole().parseAndVerifyVM(encodedVm);\n\n        require(valid, reason);\n        require(verifyBridgeVM(vm), \"invalid emitter\");\n\n        BridgeStructs.AssetMeta memory meta = parseAssetMeta(vm.payload);\n        return _updateWrapped(meta, vm.sequence);\n    }\n\n    function _updateWrapped(BridgeStructs.AssetMeta memory meta, uint64 sequence) internal returns (address token) {\n        address wrapped = wrappedAsset(meta.tokenChain, meta.tokenAddress);\n        require(wrapped != address(0), \"wrapped asset does not exists\");\n\n        // Update metadata\n        TokenImplementation(wrapped).updateDetails(bytes32ToString(meta.name), bytes32ToString(meta.symbol), sequence);\n\n        return wrapped;\n    }\n\n    function createWrapped(bytes memory encodedVm) external returns (address token) {\n        (IWormhole.VM memory vm, bool valid, string memory reason) = wormhole().parseAndVerifyVM(encodedVm);\n\n        require(valid, reason);\n        require(verifyBridgeVM(vm), \"invalid emitter\");\n\n        BridgeStructs.AssetMeta memory meta = parseAssetMeta(vm.payload);\n        return _createWrapped(meta, vm.sequence);\n    }\n\n    // Creates a wrapped asset using AssetMeta\n    function _createWrapped(BridgeStructs.AssetMeta memory meta, uint64 sequence) internal returns (address token) {\n        require(meta.tokenChain != chainId(), \"can only wrap tokens from foreign chains\");\n        require(wrappedAsset(meta.tokenChain, meta.tokenAddress) == address(0), \"wrapped asset already exists\");\n\n        // initialize the TokenImplementation\n        bytes memory initialisationArgs = abi.encodeWithSelector(\n            TokenImplementation.initialize.selector,\n            bytes32ToString(meta.name),\n            bytes32ToString(meta.symbol),\n            meta.decimals,\n            sequence,\n\n            address(this),\n\n            meta.tokenChain,\n            meta.tokenAddress\n        );\n\n        // initialize the BeaconProxy\n        bytes memory constructorArgs = abi.encode(address(this), initialisationArgs);\n\n        // deployment code\n        bytes memory bytecode = abi.encodePacked(type(BridgeToken).creationCode, constructorArgs);\n\n        bytes32 salt = keccak256(abi.encodePacked(meta.tokenChain, meta.tokenAddress));\n\n        assembly {\n            token := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\n\n            if iszero(extcodesize(token)) {\n                revert(0, 0)\n            }\n        }\n\n        setWrappedAsset(meta.tokenChain, meta.tokenAddress, token);\n    }\n\n    function completeTransfer(bytes memory encodedVm) public {\n        _completeTransfer(encodedVm, false);\n    }\n\n    function completeTransferAndUnwrapETH(bytes memory encodedVm) public {\n        _completeTransfer(encodedVm, true);\n    }\n\n    // Execute a Transfer message\n    function _completeTransfer(bytes memory encodedVm, bool unwrapWETH) internal {\n        (IWormhole.VM memory vm, bool valid, string memory reason) = wormhole().parseAndVerifyVM(encodedVm);\n\n        require(valid, reason);\n        require(verifyBridgeVM(vm), \"invalid emitter\");\n\n        BridgeStructs.Transfer memory transfer = parseTransfer(vm.payload);\n\n        require(!isTransferCompleted(vm.hash), \"transfer already completed\");\n        setTransferCompleted(vm.hash);\n\n        require(transfer.toChain == chainId(), \"invalid target chain\");\n\n        IERC20 transferToken;\n        if (transfer.tokenChain == chainId()) {\n            transferToken = IERC20(address(uint160(uint256(transfer.tokenAddress))));\n\n            // track outstanding token amounts\n            bridgedIn(address(transferToken), transfer.amount);\n        } else {\n            address wrapped = wrappedAsset(transfer.tokenChain, transfer.tokenAddress);\n            require(wrapped != address(0), \"no wrapper for this token created yet\");\n\n            transferToken = IERC20(wrapped);\n        }\n\n        require(unwrapWETH == false || address(transferToken) == address(WETH()), \"invalid token, can only unwrap WETH\");\n\n        // query decimals\n        (,bytes memory queriedDecimals) = address(transferToken).staticcall(abi.encodeWithSignature(\"decimals()\"));\n        uint8 decimals = abi.decode(queriedDecimals, (uint8));\n\n        // adjust decimals\n        uint256 nativeAmount = transfer.amount;\n        uint256 nativeFee = transfer.fee;\n        if (decimals > 8) {\n            uint multiplier = 10 ** (decimals - 8);\n            nativeAmount *= multiplier;\n            nativeFee *= multiplier;\n        }\n\n        // transfer fee to arbiter\n        if (nativeFee > 0) {\n            require(nativeFee <= nativeAmount, \"fee higher than transferred amount\");\n\n            if (unwrapWETH) {\n                WETH().withdraw(nativeFee);\n\n                payable(msg.sender).transfer(nativeFee);\n            } else {\n                if (transfer.tokenChain != chainId()) {\n                    // mint wrapped asset\n                    TokenImplementation(address(transferToken)).mint(msg.sender, nativeFee);\n                } else {\n                    SafeERC20.safeTransfer(transferToken, msg.sender, nativeFee);\n                }\n            }\n        }\n\n        // transfer bridged amount to recipient\n        uint transferAmount = nativeAmount - nativeFee;\n        address transferRecipient = address(uint160(uint256(transfer.to)));\n\n        if (unwrapWETH) {\n            WETH().withdraw(transferAmount);\n\n            payable(transferRecipient).transfer(transferAmount);\n        } else {\n            if (transfer.tokenChain != chainId()) {\n                // mint wrapped asset\n                TokenImplementation(address(transferToken)).mint(transferRecipient, transferAmount);\n            } else {\n                SafeERC20.safeTransfer(transferToken, transferRecipient, transferAmount);\n            }\n        }\n    }\n\n    function bridgeOut(address token, uint normalizedAmount) internal {\n        uint outstanding = outstandingBridged(token);\n        require(outstanding + normalizedAmount <= type(uint64).max, \"transfer exceeds max outstanding bridged token amount\");\n        setOutstandingBridged(token, outstanding + normalizedAmount);\n    }\n\n    function bridgedIn(address token, uint normalizedAmount) internal {\n        setOutstandingBridged(token, outstandingBridged(token) - normalizedAmount);\n    }\n\n    function verifyBridgeVM(IWormhole.VM memory vm) internal view returns (bool){\n        if (bridgeContracts(vm.emitterChainId) == vm.emitterAddress) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function encodeAssetMeta(BridgeStructs.AssetMeta memory meta) public pure returns (bytes memory encoded) {\n        encoded = abi.encodePacked(\n            meta.payloadID,\n            meta.tokenAddress,\n            meta.tokenChain,\n            meta.decimals,\n            meta.symbol,\n            meta.name\n        );\n    }\n\n    function encodeTransfer(BridgeStructs.Transfer memory transfer) public pure returns (bytes memory encoded) {\n        encoded = abi.encodePacked(\n            transfer.payloadID,\n            transfer.amount,\n            transfer.tokenAddress,\n            transfer.tokenChain,\n            transfer.to,\n            transfer.toChain,\n            transfer.fee\n        );\n    }\n\n    function parseAssetMeta(bytes memory encoded) public pure returns (BridgeStructs.AssetMeta memory meta) {\n        uint index = 0;\n\n        meta.payloadID = encoded.toUint8(index);\n        index += 1;\n\n        require(meta.payloadID == 2, \"invalid AssetMeta\");\n\n        meta.tokenAddress = encoded.toBytes32(index);\n        index += 32;\n\n        meta.tokenChain = encoded.toUint16(index);\n        index += 2;\n\n        meta.decimals = encoded.toUint8(index);\n        index += 1;\n\n        meta.symbol = encoded.toBytes32(index);\n        index += 32;\n\n        meta.name = encoded.toBytes32(index);\n        index += 32;\n\n        require(encoded.length == index, \"invalid AssetMeta\");\n    }\n\n    function parseTransfer(bytes memory encoded) public pure returns (BridgeStructs.Transfer memory transfer) {\n        uint index = 0;\n\n        transfer.payloadID = encoded.toUint8(index);\n        index += 1;\n\n        require(transfer.payloadID == 1, \"invalid Transfer\");\n\n        transfer.amount = encoded.toUint256(index);\n        index += 32;\n\n        transfer.tokenAddress = encoded.toBytes32(index);\n        index += 32;\n\n        transfer.tokenChain = encoded.toUint16(index);\n        index += 2;\n\n        transfer.to = encoded.toBytes32(index);\n        index += 32;\n\n        transfer.toChain = encoded.toUint16(index);\n        index += 2;\n\n        transfer.fee = encoded.toUint256(index);\n        index += 32;\n\n        require(encoded.length == index, \"invalid Transfer\");\n    }\n\n    function bytes32ToString(bytes32 input) internal pure returns (string memory) {\n        uint256 i;\n        while (i < 32 && input[i] != 0) {\n            i++;\n        }\n        bytes memory array = new bytes(i);\n        for (uint c = 0; c < i; c++) {\n            array[c] = input[c];\n        }\n        return string(array);\n    }\n\n    // we need to accept ETH sends to unwrap WETH\n    receive() external payable {}\n}"
    },
    {
      "filename": "ethereum/contracts/Implementation.sol",
      "content": "// contracts/Implementation.sol\n// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"./Governance.sol\";\n\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\";\n\ncontract Implementation is Governance {\n    event LogMessagePublished(address indexed sender, uint64 sequence, uint32 nonce, bytes payload, uint8 consistencyLevel);\n\n    // Publish a message to be attested by the Wormhole network\n    function publishMessage(\n        uint32 nonce,\n        bytes memory payload,\n        uint8 consistencyLevel\n    ) public payable returns (uint64 sequence) {\n        // check fee\n        require(msg.value == messageFee(), \"invalid fee\");\n\n        sequence = useSequence(msg.sender);\n        // emit log\n        emit LogMessagePublished(msg.sender, sequence, nonce, payload, consistencyLevel);\n    }\n\n    function useSequence(address emitter) internal returns (uint64 sequence) {\n        sequence = nextSequence(emitter);\n        setNextSequence(emitter, sequence + 1);\n    }\n\n    modifier initializer() {\n        address implementation = ERC1967Upgrade._getImplementation();\n\n        require(\n            !isInitialized(implementation),\n            \"already initialized\"\n        );\n\n        setInitialized(implementation);\n\n        _;\n    }\n\n    fallback() external payable {revert(\"unsupported\");}\n\n    receive() external payable {revert(\"the Wormhole contract does not accept assets\");}\n}"
    },
    {
      "filename": "contracts/BridgeConnectorWormhole.vy",
      "content": "# @version 0.2.12\n# @author skozin <info@lido.fi>\n# @licence MIT\nfrom vyper.interfaces import ERC20\n\nBETH_TOKEN: constant(address) = 0x707F9118e33A9B8998beA41dd0d46f38bb963FC8\nUST_WRAPPER_TOKEN: constant(address) = 0xa47c8bf37f92aBed4A126BDA807A7b7498661acD\n\nTERRA_CHAIN_ID: constant(uint256) = 3\n\n# Max value of uint32 integer (4 bytes). Equivalent of 0xFFFFFFFF.\nMAX_UINT32: constant(uint256) = 4294967295\n\n# Address of currently used Wormhole token bridge implementation.\nwormhole_token_bridge: public(address)\n\n@external\ndef __init__(wormhole_token_bridge: address):\n    self.wormhole_token_bridge = wormhole_token_bridge\n\n\n# Prepares data and calls `Bridge.transferTokens()`.\n#\n# First 64 bytes of `_extra_data` argument are reserved for passing \n# `nonce` (first 32 bytes) and `arbiter_fee` (second 32 bytes) values.\n#\n# Vyper does not support few types (uint16 and uint32), that are available in Solidity.\n# We encode a call payload manually for compatibilit"
    }
  ]
}