{
  "Title": "Missing or Incorrect Docstrings",
  "Content": "Throughout the [codebase](https://github.com/Uniswap/UniswapX/tree/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/), there are several parts that have missing or incorrect docstrings:  \n  \n       • Missing docstrings for the [`ResolvedOrderLib`](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/lib/ResolvedOrderLib.sol#L6-L7) library.  \n       • Missing docstrings for the [`ExclusiveFillerValidation`](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/sample-validation-contracts/ExclusiveFillerValidation.sol#L6-L7) contract.  \n       • Incorrect order of parameters on [line 11-12](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/base/ReactorEvents.sol#L11-L12) in [`ReactorEvents.sol`](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/base/ReactorEvents.sol) . The `swapper`  \n         parameter should be described before `nonce`.  \n       • Missing description of [`callbackData`](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/interfaces/IReactor.sol#L13-L15) in [`IReactor.sol`](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/interfaces/IReactor.sol).  \n       • The [`parseRevertReason` function](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/lens/OrderQuoter.sol#L42) misses the `reason` parameter's docstring. The  \n         `@param order` docstring should be a `@return` stating it is the resolved order.\n\n\nConsider thoroughly documenting all functions and their parameters that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/develop/natspec-format.html) (NatSpec).\n\n\n***Update:** Resolved in [pull request #192](https://github.com/Uniswap/UniswapX/pull/192) at commit [ce6b1f5](https://github.com/Uniswap/UniswapX/commit/ce6b1f547b075e0dcece8c8c0b02d44c7f3d03f7).*\n\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/lib/ResolvedOrderLib.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {ResolvedOrder} from \"../base/ReactorStructs.sol\";\nimport {IValidationCallback} from \"../interfaces/IValidationCallback.sol\";\n\nlibrary ResolvedOrderLib {\n    /// @notice thrown when the order targets a different reactor\n    error InvalidReactor();\n\n    /// @notice thrown if the order has expired\n    error DeadlinePassed();\n\n    /// @notice Validates a resolved order, reverting if invalid\n    /// @param filler The filler of the order\n    function validate(ResolvedOrder memory resolvedOrder, address filler) internal view {\n        if (address(this) != address(resolvedOrder.info.reactor)) {\n            revert InvalidReactor();\n        }\n\n        if (block.timestamp > resolvedOrder.info.deadline) {\n            revert DeadlinePassed();\n        }\n\n        if (address(resolvedOrder.info.additionalValidationContract) != address(0)) {\n            resolvedOrder.info.additionalValidationContract.validate(filler, resolvedOrder);\n        }\n    }\n}"
    },
    {
      "filename": "src/sample-validation-contracts/ExclusiveFillerValidation.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {IValidationCallback} from \"../interfaces/IValidationCallback.sol\";\nimport {ResolvedOrder, OrderInfo} from \"../base/ReactorStructs.sol\";\n\ncontract ExclusiveFillerValidation is IValidationCallback {\n    /// @notice thrown if the filler does not have fill rights\n    error NotExclusiveFiller(address filler);\n\n    /// @notice verify that the filler exclusivity is satisfied\n    /// @dev reverts if invalid filler given the exclusivity parameters\n    /// @param filler The filler of the order\n    /// @param resolvedOrder The order data to validate\n    function validate(address filler, ResolvedOrder calldata resolvedOrder) external view {\n        (address exclusiveFiller, uint256 lastExclusiveTimestamp) =\n            abi.decode(resolvedOrder.info.additionalValidationData, (address, uint256));\n        if (lastExclusiveTimestamp >= block.timestamp && filler != exclusiveFiller) {\n            revert NotExclusiveFiller(filler);\n        }\n    }\n}"
    },
    {
      "filename": "src/base/ReactorEvents.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\n/// @notice standardized events that should be emitted by all reactors\n/// @dev collated into one library to help with forge expectEmit integration\n/// @dev and for reactors which dont use base\ninterface ReactorEvents {\n    /// @notice emitted when an order is filled\n    /// @param orderHash The hash of the order that was filled\n    /// @param filler The address which executed the fill\n    /// @param nonce The nonce of the filled order\n    /// @param swapper The swapper of the filled order\n    event Fill(bytes32 indexed orderHash, address indexed filler, address indexed swapper, uint256 nonce);\n}"
    },
    {
      "filename": "src/interfaces/IReactor.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {ResolvedOrder, SignedOrder} from \"../base/ReactorStructs.sol\";\nimport {IReactorCallback} from \"./IReactorCallback.sol\";\n\n/// @notice Interface for order execution reactors\ninterface IReactor {\n    /// @notice Execute a single order\n    /// @param order The order definition and valid signature to execute\n    function execute(SignedOrder calldata order) external payable;\n\n    /// @notice Execute a single order using the given callback data\n    /// @param order The order definition and valid signature to execute\n    function executeWithCallback(SignedOrder calldata order, bytes calldata callbackData) external payable;\n\n    /// @notice Execute the given orders at once\n    /// @param orders The order definitions and valid signatures to execute\n    function executeBatch(SignedOrder[] calldata orders) external payable;\n\n    /// @notice Execute the given orders at once using a callback with the given callback data\n    /// @param orders The order definitions and valid signatures to execute\n    /// @param callbackData The callbackData to pass to the callback\n    function executeBatchWithCallback(SignedOrder[] calldata orders, bytes calldata callbackData) external payable;\n}"
    },
    {
      "filename": "src/lens/OrderQuoter.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {IReactorCallback} from \"../interfaces/IReactorCallback.sol\";\nimport {IReactor} from \"../interfaces/IReactor.sol\";\nimport {BaseReactor} from \"../reactors/BaseReactor.sol\";\nimport {OrderInfo, ResolvedOrder, SignedOrder} from \"../base/ReactorStructs.sol\";\n\n/// @notice Quoter contract for orders\n/// @dev note this is meant to be used as an off-chain lens contract to pre-validate generic orders\ncontract OrderQuoter is IReactorCallback {\n    /// @notice thrown if reactorCallback receives more than one order\n    error OrdersLengthIncorrect();\n\n    uint256 constant ORDER_INFO_OFFSET = 64;\n\n    /// @notice Quote the given order, returning the ResolvedOrder object which defines\n    /// the current input and output token amounts required to satisfy it\n    /// Also bubbles up any reverts that would occur during the processing of the order\n    /// @param order abi-encoded order, including `reactor` as the first encoded struct member\n    /// @param sig The order signature\n    /// @return result The ResolvedOrder\n    function quote(bytes memory order, bytes memory sig) external returns (ResolvedOrder memory result) {\n        try IReactor(getReactor(order)).executeWithCallback(SignedOrder(order, sig), bytes(\"\")) {}\n        catch (bytes memory reason) {\n            result = parseRevertReason(reason);\n        }\n    }\n\n    /// @notice Return the reactor of a given order (abi.encoded bytes).\n    /// @param order abi-encoded order, including `reactor` as the first encoded struct member\n    /// @return reactor\n    function getReactor(bytes memory order) public pure returns (IReactor reactor) {\n        assembly {\n            let orderInfoOffsetPointer := add(order, ORDER_INFO_OFFSET)\n            reactor := mload(add(orderInfoOffsetPointer, mload(orderInfoOffsetPointer)))\n        }\n    }\n\n    /// @notice Return the order info of a given order (abi-encoded bytes).\n    /// @param order abi-encoded order, including `reactor` as the first encoded struct member\n    function parseRevertReason(bytes memory reason) private pure returns (ResolvedOrder memory order) {\n        if (reason.length < 192) {\n            assembly {\n                revert(add(32, reason), mload(reason))\n            }\n        } else {\n            return abi.decode(reason, (ResolvedOrder));\n        }\n    }\n\n    /// @notice Reactor callback function\n    /// @dev reverts with the resolved order as reason\n    /// @param resolvedOrders The resolved orders\n    function reactorCallback(ResolvedOrder[] memory resolvedOrders, bytes memory) external pure {\n        if (resolvedOrders.length != 1) {\n            revert OrdersLengthIncorrect();\n        }\n        bytes memory order = abi.encode(resolvedOrders[0]);\n        assembly {\n            revert(add(32, order), mload(order))\n        }\n    }\n}"
    }
  ]
}