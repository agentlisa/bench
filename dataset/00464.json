{
  "Title": "M-2: Not all ERC20 tokens can be bridged because of hardcoded `PREDICATE_ADDRESS`",
  "Content": "# Issue M-2: Not all ERC20 tokens can be bridged because of hardcoded `PREDICATE_ADDRESS` \n\nSource: https://github.com/sherlock-audit/2024-02-telcoin-platform-audit-update-judging/issues/26 \n\n## Found by \nZdravkoHr., bughuntoor, cawfree\n## Summary\n`PREDICATE_ADDRESS` in [`BridgeRelay.sol`](https://github.com/sherlock-audit/2024-02-telcoin-platform-audit-update/blob/21920190e0772afa18e7f856a036fea3ef5b9635/telcoin-contracts/contracts/bridge/BridgeRelay.sol#L32) is hardcoded to the [`ERC20Predicate`](https://github.com/maticnetwork/pos-portal/blob/master/contracts/root/TokenPredicates/ERC20Predicate.sol). This means that any tokens that use other predicates will not be bridgeable.\n\n## Vulnerability Detail\nWhen the [`BridgeRelay.transferERCToBridge`](https://github.com/sherlock-audit/2024-02-telcoin-platform-audit-update/blob/21920190e0772afa18e7f856a036fea3ef5b9635/telcoin-contracts/contracts/bridge/BridgeRelay.sol#L67-L81) gets called, it approves the hardcoded `ERC20Predicate` to use the ERC20 tokens. However, the bridge uses more than one predicate to lock the tokens. [Here](https://github.com/maticnetwork/pos-portal/blob/d6c21182b1c379a858cf4cf23d34837b199e4908/contracts/root/RootChainManager/RootChainManager.sol#L302) the bridge retrieves the predicate address based on the type of token to be bridged. If a token that uses different predicate than the hardcoded is sent to the `BridgeRelay`, it will be forever stuck there since the right predicate will not have approval to transfer it. There also exists a risk that a token can change its predicate at any time.\n\n## Impact\nTokens that use different predicate will be forever stuck in the contract.\n\n## Code Snippet\n```solidity\n    function transferERCToBridge(IERC20 token) internal {\n        //zero out approvals\n        token.forceApprove(PREDICATE_ADDRESS, 0);\n        // increase approval to necessary amount\n        token.safeIncreaseAllowance(\n            PREDICATE_ADDRESS,\n            token.balanceOf(address(this))\n        );\n        //deposit\n        POS_BRIDGE.depositFor(\n            address(this),\n            address(token),\n            abi.encodePacked(token.balanceOf(address(this)))\n        );\n    }\n```\n\n```solidity\n        address predicateAddress = typeToPredicate[tokenType];\n        require(\n            predicateAddress != address(0),\n            \"RootChainManager: INVALID_TOKEN_TYPE\"\n        );\n        require(\n            user != address(0),\n            \"RootChainManager: INVALID_USER\"\n        );\n\n        ITokenPredicate(predicateAddress).lockTokens(\n            _msgSender(),\n            user,\n            rootToken,\n            depositData\n        );\n```\n## Tool used\n\nManual Review\n\n## Recommendation\nInstead of hardcoding the predicate, query the bridge when transferring the ERC20 token.\n```diff\n    function transferERCToBridge(IERC20 token) internal {\n+      bytes32 tokenType = POS_BRIDGE.tokenToType(address(token));\n+      bytes32 predicateAddress= POS_BRIDGE.typeToPredicate(tokenType);\n        //zero out approvals\n        token.forceApprove(PREDICATE_ADDRESS, 0);\n        // increase approval to necessary amount\n        token.safeIncreaseAllowance(\n-           PREDICATE_ADDRESS,\n+           predicateAddress\n            token.balanceOf(address(this))\n        );\n        //deposit\n        POS_BRIDGE.depositFor(\n            address(this),\n            address(token),\n            abi.encodePacked(token.balanceOf(address(this)))\n        );\n    }\n```\n\n\n\n## Discussion\n\n**sherlock-admin3**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  invalid\n\n\n\n**amshirif**\n\nThis isnt an issue. So we dont provide bridging as a service. We use it as a recovery method for people who send their tokens on the wrong network as a means of recovering them. However, tokens that we dont support we dont do anything with. We just allow them to sit there. The reason being is that if we were to bridging them over they still couldnt send them on our platform. We dont support and bridged tokens that us different predicates. Whats more, since we'd have to provide information in such as which bridge to use, it would require it to be a privileged method, which is something we're actively avoiding. We wish the function to be callable to anyone who wishes to attempt to push their tokens across.\n\n**WangSecurity**\n\nAfter additional discussion we came to the conclusion that this issue is valid, cause the predicated address may be changed by polygon at any moment and users funds will be lost with to method to recover them.\nTherefore, it is a Medium.\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/telcoin/telcoin-contracts/pull/8.\n\n**ABDuullahi**\n\nescalate\n\nThis is invalid according to sherlock rules \n>Future issues: Issues that result out of a future integration/implementation that was not mentioned in the docs/README or because of a future change in the code (as a fix to another issue) are not valid issues.\n\npolygon changing the address is a future implementation i believe that no one is sure whether it can be change or not, and also the sponsor confirm that they don't provide it as a service but rather to help users in case of sending it to a wrong network which also falls under user mistake\n\n**sherlock-admin2**\n\n> escalate\n> \n> This is invalid according to sherlock rules \n> >Future issues: Issues that result out of a future integration/implementation that was not mentioned in the docs/README or because of a future change in the code (as a fix to another issue) are not valid issues.\n> \n> polygon changing the address is a future implementation i believe that no one is sure whether it can be change or not, and also the sponsor confirm that they don't provide it as a service but rather to help users in case of sending it to a wrong network which also falls under user mistake\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**WangSecurity**\n\nI can see where your assumption comes from and at some point I also thought it should be invalidated due to this rule. But, LSW explained what is meant why this rule cannot be applied here. The integration/implementation will remain the same - the code in scope will not change in any way. \n\nThe Future Issues rule means that the bug will arise due to changes in the code in scope of the contest. This time the issue might arise due to changes in the third party contract. It means telcoin contracts are not properly adjusted for the contract it interacts with. Since telcoin has no power over the polygon bridge, it might properly interact with it and account for its specifics.\n\nBecause of these reasons, we decided to keep it valid and medium severity. Hope it answers your questions.\n\n**ABDuullahi**\n\ni guess i misunderstood the `Future Issue` rule, but i will nonetheless leave it to the head of judging to interpret it more clearly or shed more light on what he thinks.\n\n**Czar102**\n\nFrom my understanding, despite this issue doesn't qualify for the rule mentioned in the escalation, it qualifies for another: opportunity loss.\n\nThe funds sent on other networks would normally be lost, but the protocol created a way to retrieve them. That may not work for some tokens, but it doesn't mean that the funds are lost â€“ they are simply not retrieved. They would normally be lost when sent to a wrong address.\n\nThe protocol could be allowing for a wider group of tokens to be retrieved, yes. The fact that it doesn't is grounds for a good informational issue.\n\nPlease let me know if I misunderstood anything and in case I didn't, I'm planning to accept the escalation and invalidate the issue.\n\n**deadrosesxyz**\n\n@czar102 I don't think this should fall under \"opportunity loss\". Predicates can be changed by the polygon team, meaning that it's not simply a case of \"it could support more tokens\". \n\nThe contract is supposed to be able to retrieve tokens X. In certain scenario, it can happen that there's no way to retrieve same said tokens X, although contract is supposed to be able to do so. Since the likelihood is somewhat low, but would break the whole contract's functionality, Medium seems appropriate.\n\n**ABDuullahi**\n\nThe whole report is based on the idea that `not all ERC20 can be bridged`. First the protocol doesn't provide the said bridging as a service, second is there is no `other token`. it should be invalidated i believe.\n\n**ZdravkoHr**\n\n@ABDuullahi, that's just the way i formatted the title. If the predicate is changed, no tokens at can be bridged at all, so \"not all\" is technically still true\n\n**amshirif**\n\nSo we will be implementing a fix, but in a slightly different way than recommended. We will not take the predicate as a param because this would then need to become a protected function. Instead the ERC20 rescue function will allow tokens to be removed, however it will require the current predicate to prevent bridging.\n\n**ABDuullahi**\n\n@ZdravkoHr  `Not all` in ur case means that all should be able to be bridged.\n\n**ZdravkoHr**\n\n@amshirif, thanks for your feedback. By the way, if you  imolememt the fix, the predicate will be loaded from the bridge's storage, it won't be passed from the user. So the function can continue being permisionless\n\n**Czar102**\n\n> In certain scenario, it can happen that there's no way to retrieve same said tokens X, although contract is supposed to be able to do so. Since the likelihood is somewhat low, but would break the whole contract's functionality, Medium seems appropriate.\n\nThe funds are normally lost, and no users should send funds on the wrong chain in the usage of the protocol. Not recovering them is opportunity loss. This is not loss of funds from this point of view.\n\nThis can also be considered breaking smart contract functionality, but this functionality isn't core, so I'll consider it Low on these grounds.\n\n**deadrosesxyz**\n\n>Breaks core contract functionality, rendering the contract useless or leading to loss of funds.\n\nHey, if I understand this requirement for Medium severity, this issues does in fact break the core functionality of this particular contract and does render it useless. \n\nCorrect me if I'm wrong, but the severity depends on whether the broken functionality is core for the said smart contract and not based on whether the broken smart contract is core of the project? \n\n**WangSecurity**\n\nI agree with deadroses above. Even if it's not the main feature of Telcoin and doesn't break core protocol's functionality, it definetely renders contract useless.\nThus, if the contract is useless, I assume it's equal to broken contract functionality of the particular contract (not the protocol). And as deadroses mentioned, the rule for medium is breaking the core functionality of the contract, not the protocol as a whole.\n\n**Czar102**\n\nAfter some internal discussions, I agree that this issue should stay as is. Planning to reject the escalation.\n\n**Czar102**\n\nResult:\nMedium\nHas duplicates\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [ABDUullahi](https://github.com/sherlock-audit/2024-02-telcoin-platform-audit-update-judging/issues/26/#issuecomment-1994363328): rejected\n\n**spacegliderrrr**\n\nFix looks good, stuck tokens can now be retrieved by contract owner.\n\n**sherlock-admin4**\n\nThe Lead Senior Watson signed off on the fix.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/196",
  "Code": [
    {
      "filename": "telcoin-contracts/contracts/bridge/BridgeRelay.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20Withdrawable} from \"./interfaces/IERC20Withdrawable.sol\";\nimport {IPOSBridge} from \"./interfaces/IPOSBridge.sol\";\n\n/**\n * @title RootBridgeRelay\n * @author Amir Shirif\n * @notice A Telcoin Contract\n * @notice This contract is meant for forwarding ERC20 and ETH accross the polygon bridge system\n */\ncontract BridgeRelay {\n    using SafeERC20 for IERC20;\n    // emitted attemped MATIC bridging\n    error MATICUnbridgeable();\n\n    //ETHER address\n    IERC20 public constant ETHER =\n        IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n    // WETH address\n    IERC20 public constant WETH =\n        IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    //MATIC address\n    IERC20 public constant MATIC =\n        IERC20(0x7D1AfA7B718fb893dB30A3aBc0Cfc608AaCfeBB0);\n    // mainnet PoS bridge\n    IPOSBridge public constant POS_BRIDGE =\n        IPOSBridge(0xA0c68C638235ee32657e8f720a23ceC1bFc77C77);\n    // mainnet predicate\n    address public constant PREDICATE_ADDRESS =\n        0x40ec5B33f54e0E8A33A975908C5BA1c14e5BbbDf;\n    // Owner address\n    address public constant OWNER_ADDRESS =\n        0xE075504E14bBB4d2aA6333DB5b8EFc1e8c2AE05B;\n\n    /**\n     * @notice calls Polygon POS bridge for deposit\n     * @dev the contract is designed in a way where anyone can call the function without risking funds\n     * @dev MATIC cannot be bridged\n     * @param token address of the token that is desired to be pushed accross the bridge\n     */\n    function bridgeTransfer(IERC20 token) external payable {\n        // revert if MATIC is attempted\n        if (token == MATIC) revert MATICUnbridgeable();\n        // unwrap WETH\n        if (token == WETH) {\n            IERC20Withdrawable(address(WETH)).withdraw(\n                WETH.balanceOf(address(this))\n            );\n            // transfer ERC20 tokens\n        } else if (token != ETHER) {\n            transferERCToBridge(token);\n            return;\n        }\n        // transfer ETHER\n        POS_BRIDGE.depositEtherFor{value: address(this).balance}(address(this));\n    }\n\n    /**\n     * @notice pushes token transfers through to the PoS bridge\n     * @dev this is for ERC20 tokens that are not the matic token\n     * @dev only tokens that are already mapped on the bridge will succeed\n     * @param token is address of the token that is desired to be pushed accross the bridge\n     */\n    function transferERCToBridge(IERC20 token) internal {\n        //zero out approvals\n        token.forceApprove(PREDICATE_ADDRESS, 0);\n        // increase approval to necessary amount\n        token.safeIncreaseAllowance(\n            PREDICATE_ADDRESS,\n            token.balanceOf(address(this))\n        );\n        //deposit\n        POS_BRIDGE.depositFor(\n            address(this),\n            address(token),\n            abi.encodePacked(token.balanceOf(address(this)))\n        );\n    }\n\n    /**\n     * @notice helps recover MATIC which cannot be bridged with POS bridge\n     * @dev only Owner may make function call\n     * @param destination address where funds are returned\n     */\n    function erc20Rescue(address destination) external {\n        // restrict to woner\n        require(\n            msg.sender == OWNER_ADDRESS,\n            \"BridgeRelay: caller must be owner\"\n        );\n        //transfer MATIC\n        MATIC.safeTransfer(destination, MATIC.balanceOf(address(this)));\n    }\n\n    /**\n     * @notice receives ETHER\n     */\n    receive() external payable {}\n}"
    },
    {
      "filename": "telcoin-contracts/contracts/bridge/BridgeRelay.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20Withdrawable} from \"./interfaces/IERC20Withdrawable.sol\";\nimport {IPOSBridge} from \"./interfaces/IPOSBridge.sol\";\n\n/**\n * @title RootBridgeRelay\n * @author Amir Shirif\n * @notice A Telcoin Contract\n * @notice This contract is meant for forwarding ERC20 and ETH accross the polygon bridge system\n */\ncontract BridgeRelay {\n    using SafeERC20 for IERC20;\n    // emitted attemped MATIC bridging\n    error MATICUnbridgeable();\n\n    //ETHER address\n    IERC20 public constant ETHER =\n        IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n    // WETH address\n    IERC20 public constant WETH =\n        IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    //MATIC address\n    IERC20 public constant MATIC =\n        IERC20(0x7D1AfA7B718fb893dB30A3aBc0Cfc608AaCfeBB0);\n    // mainnet PoS bridge\n    IPOSBridge public constant POS_BRIDGE =\n        IPOSBridge(0xA0c68C638235ee32657e8f720a23ceC1bFc77C77);\n    // mainnet predicate\n    address public constant PREDICATE_ADDRESS =\n        0x40ec5B33f54e0E8A33A975908C5BA1c14e5BbbDf;\n    // Owner address\n    address public constant OWNER_ADDRESS =\n        0xE075504E14bBB4d2aA6333DB5b8EFc1e8c2AE05B;\n\n    /**\n     * @notice calls Polygon POS bridge for deposit\n     * @dev the contract is designed in a way where anyone can call the function without risking funds\n     * @dev MATIC cannot be bridged\n     * @param token address of the token that is desired to be pushed accross the bridge\n     */\n    function bridgeTransfer(IERC20 token) external payable {\n        // revert if MATIC is attempted\n        if (token == MATIC) revert MATICUnbridgeable();\n        // unwrap WETH\n        if (token == WETH) {\n            IERC20Withdrawable(address(WETH)).withdraw(\n                WETH.balanceOf(address(this))\n            );\n            // transfer ERC20 tokens\n        } else if (token != ETHER) {\n            transferERCToBridge(token);\n            return;\n        }\n        // transfer ETHER\n        POS_BRIDGE.depositEtherFor{value: address(this).balance}(address(this));\n    }\n\n    /**\n     * @notice pushes token transfers through to the PoS bridge\n     * @dev this is for ERC20 tokens that are not the matic token\n     * @dev only tokens that are already mapped on the bridge will succeed\n     * @param token is address of the token that is desired to be pushed accross the bridge\n     */\n    function transferERCToBridge(IERC20 token) internal {\n        //zero out approvals\n        token.forceApprove(PREDICATE_ADDRESS, 0);\n        // increase approval to necessary amount\n        token.safeIncreaseAllowance(\n            PREDICATE_ADDRESS,\n            token.balanceOf(address(this))\n        );\n        //deposit\n        POS_BRIDGE.depositFor(\n            address(this),\n            address(token),\n            abi.encodePacked(token.balanceOf(address(this)))\n        );\n    }\n\n    /**\n     * @notice helps recover MATIC which cannot be bridged with POS bridge\n     * @dev only Owner may make function call\n     * @param destination address where funds are returned\n     */\n    function erc20Rescue(address destination) external {\n        // restrict to woner\n        require(\n            msg.sender == OWNER_ADDRESS,\n            \"BridgeRelay: caller must be owner\"\n        );\n        //transfer MATIC\n        MATIC.safeTransfer(destination, MATIC.balanceOf(address(this)));\n    }\n\n    /**\n     * @notice receives ETHER\n     */\n    receive() external payable {}\n}"
    }
  ]
}