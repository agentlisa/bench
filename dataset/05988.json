{
  "Title": "[06] Grammatical and spelling errors",
  "Content": "https://github.com/GenerationSoftware/pt-v5-cgda-liquidator/blob/7f95bcacd4a566c2becb98d55c1886cadbaa8897/src/LiquidationRouter.sol#L60\n\n```solidity\n      @ audit `exactly` --> `exact`\n  /// @param _amountOut The `exactly` amount of output tokens expected\n```\nhttps://github.com/GenerationSoftware/pt-v5-draw-auction/blob/f1c6d14a1772d6609de1870f8713fb79977d51c1/src/RngRelayAuction.sol#L74\n\n```solidity\n      @ audit `wil` --> `will`\n  /// @notice The PrizePool whose draw `wil` be closed.\n```\nhttps://github.com/GenerationSoftware/pt-v5-draw-auction/blob/f1c6d14a1772d6609de1870f8713fb79977d51c1/src/RngRelayAuction.sol#L48\n\n```solidity\n      @ audit `Not` --> `Note`\n  /// @dev `Not` that the reward fractions compound\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-08-pooltogether",
  "Code": [
    {
      "filename": "src/LiquidationRouter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport \"openzeppelin/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\n\nimport { LiquidationPair } from \"./LiquidationPair.sol\";\nimport { LiquidationPairFactory } from \"./LiquidationPairFactory.sol\";\n\nerror UndefinedLiquidationPairFactory();\nerror UnknownLiquidationPair(LiquidationPair liquidationPair);\n\n/// @title LiquidationRouter\n/// @author G9 Software Inc.\n/// @notice Serves as the user-facing swapping interface for Liquidation Pairs.\ncontract LiquidationRouter {\n  using SafeERC20 for IERC20;\n\n  /* ============ Events ============ */\n\n  /// @notice Emitted when the router is created\n  event LiquidationRouterCreated(LiquidationPairFactory indexed liquidationPairFactory);\n\n  /// @notice Emitted after a swap occurs\n  /// @param liquidationPair The pair that was swapped against\n  /// @param receiver The address that received the output tokens\n  /// @param amountOut The amount of output tokens received\n  /// @param amountInMax The maximum amount of input tokens that could have been used\n  /// @param amountIn The amount of input tokens that were actually used\n  event SwappedExactAmountOut(\n    LiquidationPair indexed liquidationPair,\n    address indexed receiver,\n    uint256 amountOut,\n    uint256 amountInMax,\n    uint256 amountIn\n  );\n\n  /* ============ Variables ============ */\n\n  /// @notice The LiquidationPairFactory that this router uses.\n  /// @dev LiquidationPairs will be checked to ensure they were created by the factory\n  LiquidationPairFactory internal immutable _liquidationPairFactory;\n\n  /// @notice Constructs a new LiquidationRouter\n  /// @param liquidationPairFactory_ The factory that pairs will be verified to have been created by\n  constructor(LiquidationPairFactory liquidationPairFactory_) {\n    if(address(liquidationPairFactory_) == address(0)) {\n      revert UndefinedLiquidationPairFactory();\n    }\n    _liquidationPairFactory = liquidationPairFactory_;\n\n    emit LiquidationRouterCreated(liquidationPairFactory_);\n  }\n\n  /* ============ External Methods ============ */\n\n  /// @notice Swaps the given amount of output tokens for at most input tokens\n  /// @param _liquidationPair The pair to swap against\n  /// @param _receiver The account to receive the output tokens\n  /// @param _amountOut The exactly amount of output tokens expected\n  /// @param _amountInMax The maximum of input tokens to spend\n  /// @return The actual number of input tokens used\n  function swapExactAmountOut(\n    LiquidationPair _liquidationPair,\n    address _receiver,\n    uint256 _amountOut,\n    uint256 _amountInMax\n  ) external onlyTrustedLiquidationPair(_liquidationPair) returns (uint256) {\n    IERC20(_liquidationPair.tokenIn()).safeTransferFrom(\n      msg.sender,\n      _liquidationPair.target(),\n      _liquidationPair.computeExactAmountIn(_amountOut)\n    );\n\n    uint256 amountIn = _liquidationPair.swapExactAmountOut(_receiver, _amountOut, _amountInMax);\n\n    emit SwappedExactAmountOut(_liquidationPair, _receiver, _amountOut, _amountInMax, amountIn);\n\n    return amountIn;\n  }\n\n  /// @notice Checks that the given pair was created by the factory\n  /// @param _liquidationPair The pair to check\n  modifier onlyTrustedLiquidationPair(LiquidationPair _liquidationPair) {\n    if (!_liquidationPairFactory.deployedPairs(_liquidationPair)) {\n      revert UnknownLiquidationPair(_liquidationPair);\n    }\n    _;\n  }\n}"
    },
    {
      "filename": "src/RngRelayAuction.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport { UD2x18 } from \"prb-math/UD2x18.sol\";\nimport { convert } from \"prb-math/UD60x18.sol\";\nimport { PrizePool } from \"pt-v5-prize-pool/PrizePool.sol\";\n\nimport { RewardLib } from \"./libraries/RewardLib.sol\";\nimport { IRngAuctionRelayListener } from \"./interfaces/IRngAuctionRelayListener.sol\";\nimport { IAuction, AuctionResult } from \"./interfaces/IAuction.sol\";\nimport { RngAuction } from \"./RngAuction.sol\";\n\n/* ============ Custom Errors ============ */\n\n/// @notice Thrown if the auction period is zero.\nerror AuctionDurationZero();\n\n/// @notice Thrown if the auction target time is zero.\nerror AuctionTargetTimeZero();\n\n/**\n  * @notice Thrown if the auction target time exceeds the auction duration.\n  * @param auctionTargetTime The auction target time to complete in seconds\n  * @param auctionDuration The auction duration in seconds\n  */\nerror AuctionTargetTimeExceedsDuration(uint64 auctionDuration, uint64 auctionTargetTime);\n\n/// @notice Thrown if the RngAuction address is the zero address.\nerror RngRelayerZeroAddress();\n\n/// @notice Thrown if the current sequence has already been completed.\nerror SequenceAlreadyCompleted();\n\n/// @notice Thrown if the current draw auction has expired.\nerror AuctionExpired();\n\n/// @notice Thrown if the PrizePool address is the zero address.\nerror PrizePoolZeroAddress();\n\n/**\n * @title   RngRelayAuction\n * @author  G9 Software Inc.\n * @notice  This contract auctions off the RNG relay, then closes the Prize Pool using the RNG results.\n */\ncontract RngRelayAuction is IRngAuctionRelayListener, IAuction {\n\n  /// @notice Emitted for each auction that is rewarded within the sequence.\n  /// @dev Not that the reward fractions compound\n  /// @param sequenceId The sequence ID of the auction\n  /// @param recipient The recipient of the reward\n  /// @param index The order in which this reward occurred\n  /// @param reward The reward amount\n  event AuctionRewardDistributed(\n    uint32 indexed sequenceId,\n    address indexed recipient,\n    uint32 index,\n    uint256 reward\n  );\n\n  /// @notice Emitted once when the sequence is completed and the Prize Pool draw is closed.\n  /// @param sequenceId The sequence id\n  /// @param drawId The draw id that was closed\n  /// @param rewardRecipient The recipient of the Rng Relay Reward\n  /// @param auctionElapsedSeconds The elapsed time of the Rng Relay Auction\n  /// @param rewardFraction The reward fraction of the Rng Relay Auction. Note that this fraction is applied after the Rng Auction fraction is taken.\n  event RngSequenceCompleted(\n    uint32 indexed sequenceId,\n    uint32 indexed drawId,\n    address indexed rewardRecipient,\n    uint64 auctionElapsedSeconds,\n    UD2x18 rewardFraction\n  );\n\n  /// @notice The PrizePool whose draw wil be closed.\n  PrizePool public immutable prizePool;\n\n  /// @notice The relayer that RNG results must originate from.\n  /// @dev Note that this may be a Remote Owner if relayed over an ERC-5164 bridge.\n  address public immutable rngAuctionRelayer;\n\n  /* ============ Variables ============ */\n\n  /// @notice The sequence ID that was used in the last auction\n  uint32 internal _lastSequenceId;\n\n  /// @notice The auction duration in seconds\n  uint64 internal _auctionDurationSeconds;\n\n  /// @notice The target time to complete the auction as a fraction of the auction duration\n  UD2x18 internal _auctionTargetTimeFraction;\n\n  /// @notice The last completed auction results\n  AuctionResult internal _auctionResults;\n\n  /* ============ Constructor ============ */\n\n  /// @notice Construct a new contract\n  /// @param prizePool_ The target Prize Pool to close draws for\n  /// @param _rngAuctionRelayer The relayer that RNG results must originate from\n  /// @param auctionDurationSeconds_ The auction duration in seconds\n  /// @param auctionTargetTime_ The target time to complete the auction\n  constructor(\n    PrizePool prizePool_,\n    address _rngAuctionRelayer,\n    uint64 auctionDurationSeconds_,\n    uint64 auctionTargetTime_\n  ) {\n    if (address(prizePool_) == address(0)) revert PrizePoolZeroAddress();\n    prizePool = prizePool_;\n    if (address(_rngAuctionRelayer) == address(0)) revert RngRelayerZeroAddress();\n    if (auctionDurationSeconds_ == 0) revert AuctionDurationZero();\n    if (auctionTargetTime_ == 0) revert AuctionTargetTimeZero();\n    if (auctionTargetTime_ > auctionDurationSeconds_) {\n      revert AuctionTargetTimeExceedsDuration(auctionDurationSeconds_, auctionTargetTime_);\n    }\n    rngAuctionRelayer = _rngAuctionRelayer;\n    _auctionDurationSeconds = auctionDurationSeconds_;\n    _auctionTargetTimeFraction = UD2x18.wrap(\n      uint64(convert(auctionTargetTime_).div(convert(_auctionDurationSeconds)).unwrap())\n    );\n  }\n\n  /* ============ External Functions ============ */\n\n  /// @notice Called by the relayer to complete the Rng relay auction.\n  /// @param _randomNumber The random number that was generated\n  /// @param _rngCompletedAt The timestamp that the RNG was completed at\n  /// @param _rewardRecipient The recipient of the relay auction reward\n  /// @param _sequenceId The sequence ID of the auction\n  /// @param _rngAuctionResult The result of the RNG auction\n  function rngComplete(\n    uint256 _randomNumber,\n    uint256 _rngCompletedAt,\n    address _rewardRecipient,\n    uint32 _sequenceId,\n    AuctionResult calldata _rngAuctionResult\n  ) external returns (bytes32) {\n    if (_sequenceHasCompleted(_sequenceId)) revert SequenceAlreadyCompleted();\n    uint64 _auctionElapsedSeconds = uint64(block.timestamp < _rngCompletedAt ? 0 : block.timestamp - _rngCompletedAt);\n    if (_auctionElapsedSeconds > (_auctionDurationSeconds-1)) revert AuctionExpired();\n    // Calculate the reward fraction and set the draw auction results\n    UD2x18 rewardFraction = _fractionalReward(_auctionElapsedSeconds);\n    _auctionResults.rewardFraction = rewardFraction;\n    _auctionResults.recipient = _rewardRecipient;\n    _lastSequenceId = _sequenceId;\n\n    AuctionResult[] memory auctionResults = new AuctionResult[](2);\n    auctionResults[0] = _rngAuctionResult;\n    auctionResults[1] = AuctionResult({\n      rewardFraction: rewardFraction,\n      recipient: _rewardRecipient\n    });\n\n    uint32 drawId = prizePool.closeDraw(_randomNumber);\n\n    uint256 futureReserve = prizePool.reserve() + prizePool.reserveForOpenDraw();\n    uint256[] memory _rewards = RewardLib.rewards(auctionResults, futureReserve);\n\n    emit RngSequenceCompleted(\n      _sequenceId,\n      drawId,\n      _rewardRecipient,\n      _auctionElapsedSeconds,\n      rewardFraction\n    );\n\n    for (uint8 i = 0; i < _rewards.length; i++) {\n      uint104 _reward = uint104(_rewards[i]);\n      if (_reward > 0) {\n        prizePool.withdrawReserve(auctionResults[i].recipient, _reward);\n        emit AuctionRewardDistributed(_sequenceId, auctionResults[i].recipient, i, _reward);\n      }\n    }\n\n    return bytes32(uint(drawId));\n  }\n\n  /// @notice Computes the actual rewards that will be distributed to the recipients using the current Prize Pool reserve.\n  /// @param __auctionResults The auction results to use for calculation\n  /// @return rewards The rewards that will be distributed\n  function computeRewards(AuctionResult[] calldata __auctionResults) external returns (uint256[] memory) {\n    uint256 totalReserve = prizePool.reserve() + prizePool.reserveForOpenDraw();\n    return _computeRewards(__auctionResults, totalReserve);\n  }\n\n  /// @notice Computes the actual rewards that will be distributed to the recipients given the passed total reserve\n  /// @param __auctionResults The auction results to use for calculation\n  /// @param _totalReserve The total reserve to use for calculation\n  /// @return rewards The rewards that will be distributed.\n  function computeRewardsWithTotal(AuctionResult[] calldata __auctionResults, uint256 _totalReserve) external returns (uint256[] memory) {\n    return _computeRewards(__auctionResults, _totalReserve);\n  }\n\n  /// @notice Returns whether the given sequence has complete.\n  /// @param _sequenceId The sequence to check\n  /// @return True if the sequence has already completed\n  function isSequenceCompleted(uint32 _sequenceId) external view returns (bool) {\n    return _sequenceHasCompleted(_sequenceId);\n  }\n\n  /// @notice Returns the duration of the auction in seconds. \n  function auctionDuration() external view returns (uint64) {\n    return _auctionDurationSeconds;\n  }\n\n  /// @notice Computes the reward fraction for the given auction elapsed time\n  /// @param _auctionElapsedTime The elapsed time of the auction\n  /// @return The reward fraction\n  function computeRewardFraction(uint64 _auctionElapsedTime) external view returns (UD2x18) {\n    return _fractionalReward(_auctionElapsedTime);\n  }\n\n  /// @notice Returns the last completed sequence id\n  function lastSequenceId() external view returns (uint32) {\n    return _lastSequenceId;\n  }\n\n  /// @notice Returns the last auction result\n  function getLastAuctionResult()\n    external\n    view\n    returns (AuctionResult memory)\n  {\n    return _auctionResults;\n  }\n\n  /* ============ Internal Functions ============ */\n\n  /// @notice Computes the rewards for each reward recipient based on their reward fraction.\n  /// @dev Note that the fractions compound, such that the second reward fraction is a fraction of the remained of the previous, etc.\n  /// @param __auctionResults The auction results to use for calculation\n  /// @param _totalReserve The total reserve to use for calculation\n  /// @return The actual rewards for each reward recipient\n  function _computeRewards(AuctionResult[] calldata __auctionResults, uint256 _totalReserve) internal returns (uint256[] memory) {\n    return RewardLib.rewards(__auctionResults, _totalReserve);\n  }\n\n  /// @notice Returns whether the given sequence has completed.\n  /// @param _sequenceId The sequence to check\n  /// @return True if the sequence has already completed, false otherwise\n  function _sequenceHasCompleted(uint32 _sequenceId) internal view returns (bool) {\n    return _lastSequenceId >= _sequenceId;\n  }\n\n  /**\n   * @notice Calculates the reward fraction for an auction if it were to be completed after the elapsed time.\n   * @dev Uses the last sold fraction as the target price for this auction.\n   * @return The reward fraction as a UD2x18 value\n   */\n  function _fractionalReward(uint64 _elapsedSeconds) internal view returns (UD2x18) {\n    return\n      RewardLib.fractionalReward(\n        _elapsedSeconds,\n        _auctionDurationSeconds,\n        _auctionTargetTimeFraction,\n        _auctionResults.rewardFraction\n      );\n  }\n}"
    },
    {
      "filename": "src/RngRelayAuction.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport { UD2x18 } from \"prb-math/UD2x18.sol\";\nimport { convert } from \"prb-math/UD60x18.sol\";\nimport { PrizePool } from \"pt-v5-prize-pool/PrizePool.sol\";\n\nimport { RewardLib } from \"./libraries/RewardLib.sol\";\nimport { IRngAuctionRelayListener } from \"./interfaces/IRngAuctionRelayListener.sol\";\nimport { IAuction, AuctionResult } from \"./interfaces/IAuction.sol\";\nimport { RngAuction } from \"./RngAuction.sol\";\n\n/* ============ Custom Errors ============ */\n\n/// @notice Thrown if the auction period is zero.\nerror AuctionDurationZero();\n\n/// @notice Thrown if the auction target time is zero.\nerror AuctionTargetTimeZero();\n\n/**\n  * @notice Thrown if the auction target time exceeds the auction duration.\n  * @param auctionTargetTime The auction target time to complete in seconds\n  * @param auctionDuration The auction duration in seconds\n  */\nerror AuctionTargetTimeExceedsDuration(uint64 auctionDuration, uint64 auctionTargetTime);\n\n/// @notice Thrown if the RngAuction address is the zero address.\nerror RngRelayerZeroAddress();\n\n/// @notice Thrown if the current sequence has already been completed.\nerror SequenceAlreadyCompleted();\n\n/// @notice Thrown if the current draw auction has expired.\nerror AuctionExpired();\n\n/// @notice Thrown if the PrizePool address is the zero address.\nerror PrizePoolZeroAddress();\n\n/**\n * @title   RngRelayAuction\n * @author  G9 Software Inc.\n * @notice  This contract auctions off the RNG relay, then closes the Prize Pool using the RNG results.\n */\ncontract RngRelayAuction is IRngAuctionRelayListener, IAuction {\n\n  /// @notice Emitted for each auction that is rewarded within the sequence.\n  /// @dev Not that the reward fractions compound\n  /// @param sequenceId The sequence ID of the auction\n  /// @param recipient The recipient of the reward\n  /// @param index The order in which this reward occurred\n  /// @param reward The reward amount\n  event AuctionRewardDistributed(\n    uint32 indexed sequenceId,\n    address indexed recipient,\n    uint32 index,\n    uint256 reward\n  );\n\n  /// @notice Emitted once when the sequence is completed and the Prize Pool draw is closed.\n  /// @param sequenceId The sequence id\n  /// @param drawId The draw id that was closed\n  /// @param rewardRecipient The recipient of the Rng Relay Reward\n  /// @param auctionElapsedSeconds The elapsed time of the Rng Relay Auction\n  /// @param rewardFraction The reward fraction of the Rng Relay Auction. Note that this fraction is applied after the Rng Auction fraction is taken.\n  event RngSequenceCompleted(\n    uint32 indexed sequenceId,\n    uint32 indexed drawId,\n    address indexed rewardRecipient,\n    uint64 auctionElapsedSeconds,\n    UD2x18 rewardFraction\n  );\n\n  /// @notice The PrizePool whose draw wil be closed.\n  PrizePool public immutable prizePool;\n\n  /// @notice The relayer that RNG results must originate from.\n  /// @dev Note that this may be a Remote Owner if relayed over an ERC-5164 bridge.\n  address public immutable rngAuctionRelayer;\n\n  /* ============ Variables ============ */\n\n  /// @notice The sequence ID that was used in the last auction\n  uint32 internal _lastSequenceId;\n\n  /// @notice The auction duration in seconds\n  uint64 internal _auctionDurationSeconds;\n\n  /// @notice The target time to complete the auction as a fraction of the auction duration\n  UD2x18 internal _auctionTargetTimeFraction;\n\n  /// @notice The last completed auction results\n  AuctionResult internal _auctionResults;\n\n  /* ============ Constructor ============ */\n\n  /// @notice Construct a new contract\n  /// @param prizePool_ The target Prize Pool to close draws for\n  /// @param _rngAuctionRelayer The relayer that RNG results must originate from\n  /// @param auctionDurationSeconds_ The auction duration in seconds\n  /// @param auctionTargetTime_ The target time to complete the auction\n  constructor(\n    PrizePool prizePool_,\n    address _rngAuctionRelayer,\n    uint64 auctionDurationSeconds_,\n    uint64 auctionTargetTime_\n  ) {\n    if (address(prizePool_) == address(0)) revert PrizePoolZeroAddress();\n    prizePool = prizePool_;\n    if (address(_rngAuctionRelayer) == address(0)) revert RngRelayerZeroAddress();\n    if (auctionDurationSeconds_ == 0) revert AuctionDurationZero();\n    if (auctionTargetTime_ == 0) revert AuctionTargetTimeZero();\n    if (auctionTargetTime_ > auctionDurationSeconds_) {\n      revert AuctionTargetTimeExceedsDuration(auctionDurationSeconds_, auctionTargetTime_);\n    }\n    rngAuctionRelayer = _rngAuctionRelayer;\n    _auctionDurationSeconds = auctionDurationSeconds_;\n    _auctionTargetTimeFraction = UD2x18.wrap(\n      uint64(convert(auctionTargetTime_).div(convert(_auctionDurationSeconds)).unwrap())\n    );\n  }\n\n  /* ============ External Functions ============ */\n\n  /// @notice Called by the relayer to complete the Rng relay auction.\n  /// @param _randomNumber The random number that was generated\n  /// @param _rngCompletedAt The timestamp that the RNG was completed at\n  /// @param _rewardRecipient The recipient of the relay auction reward\n  /// @param _sequenceId The sequence ID of the auction\n  /// @param _rngAuctionResult The result of the RNG auction\n  function rngComplete(\n    uint256 _randomNumber,\n    uint256 _rngCompletedAt,\n    address _rewardRecipient,\n    uint32 _sequenceId,\n    AuctionResult calldata _rngAuctionResult\n  ) external returns (bytes32) {\n    if (_sequenceHasCompleted(_sequenceId)) revert SequenceAlreadyCompleted();\n    uint64 _auctionElapsedSeconds = uint64(block.timestamp < _rngCompletedAt ? 0 : block.timestamp - _rngCompletedAt);\n    if (_auctionElapsedSeconds > (_auctionDurationSeconds-1)) revert AuctionExpired();\n    // Calculate the reward fraction and set the draw auction results\n    UD2x18 rewardFraction = _fractionalReward(_auctionElapsedSeconds);\n    _auctionResults.rewardFraction = rewardFraction;\n    _auctionResults.recipient = _rewardRecipient;\n    _lastSequenceId = _sequenceId;\n\n    AuctionResult[] memory auctionResults = new AuctionResult[](2);\n    auctionResults[0] = _rngAuctionResult;\n    auctionResults[1] = AuctionResult({\n      rewardFraction: rewardFraction,\n      recipient: _rewardRecipient\n    });\n\n    uint32 drawId = prizePool.closeDraw(_randomNumber);\n\n    uint256 futureReserve = prizePool.reserve() + prizePool.reserveForOpenDraw();\n    uint256[] memory _rewards = RewardLib.rewards(auctionResults, futureReserve);\n\n    emit RngSequenceCompleted(\n      _sequenceId,\n      drawId,\n      _rewardRecipient,\n      _auctionElapsedSeconds,\n      rewardFraction\n    );\n\n    for (uint8 i = 0; i < _rewards.length; i++) {\n      uint104 _reward = uint104(_rewards[i]);\n      if (_reward > 0) {\n        prizePool.withdrawReserve(auctionResults[i].recipient, _reward);\n        emit AuctionRewardDistributed(_sequenceId, auctionResults[i].recipient, i, _reward);\n      }\n    }\n\n    return bytes32(uint(drawId));\n  }\n\n  /// @notice Computes the actual rewards that will be distributed to the recipients using the current Prize Pool reserve.\n  /// @param __auctionResults The auction results to use for calculation\n  /// @return rewards The rewards that will be distributed\n  function computeRewards(AuctionResult[] calldata __auctionResults) external returns (uint256[] memory) {\n    uint256 totalReserve = prizePool.reserve() + prizePool.reserveForOpenDraw();\n    return _computeRewards(__auctionResults, totalReserve);\n  }\n\n  /// @notice Computes the actual rewards that will be distributed to the recipients given the passed total reserve\n  /// @param __auctionResults The auction results to use for calculation\n  /// @param _totalReserve The total reserve to use for calculation\n  /// @return rewards The rewards that will be distributed.\n  function computeRewardsWithTotal(AuctionResult[] calldata __auctionResults, uint256 _totalReserve) external returns (uint256[] memory) {\n    return _computeRewards(__auctionResults, _totalReserve);\n  }\n\n  /// @notice Returns whether the given sequence has complete.\n  /// @param _sequenceId The sequence to check\n  /// @return True if the sequence has already completed\n  function isSequenceCompleted(uint32 _sequenceId) external view returns (bool) {\n    return _sequenceHasCompleted(_sequenceId);\n  }\n\n  /// @notice Returns the duration of the auction in seconds. \n  function auctionDuration() external view returns (uint64) {\n    return _auctionDurationSeconds;\n  }\n\n  /// @notice Computes the reward fraction for the given auction elapsed time\n  /// @param _auctionElapsedTime The elapsed time of the auction\n  /// @return The reward fraction\n  function computeRewardFraction(uint64 _auctionElapsedTime) external view returns (UD2x18) {\n    return _fractionalReward(_auctionElapsedTime);\n  }\n\n  /// @notice Returns the last completed sequence id\n  function lastSequenceId() external view returns (uint32) {\n    return _lastSequenceId;\n  }\n\n  /// @notice Returns the last auction result\n  function getLastAuctionResult()\n    external\n    view\n    returns (AuctionResult memory)\n  {\n    return _auctionResults;\n  }\n\n  /* ============ Internal Functions ============ */\n\n  /// @notice Computes the rewards for each reward recipient based on their reward fraction.\n  /// @dev Note that the fractions compound, such that the second reward fraction is a fraction of the remained of the previous, etc.\n  /// @param __auctionResults The auction results to use for calculation\n  /// @param _totalReserve The total reserve to use for calculation\n  /// @return The actual rewards for each reward recipient\n  function _computeRewards(AuctionResult[] calldata __auctionResults, uint256 _totalReserve) internal returns (uint256[] memory) {\n    return RewardLib.rewards(__auctionResults, _totalReserve);\n  }\n\n  /// @notice Returns whether the given sequence has completed.\n  /// @param _sequenceId The sequence to check\n  /// @return True if the sequence has already completed, false otherwise\n  function _sequenceHasCompleted(uint32 _sequenceId) internal view returns (bool) {\n    return _lastSequenceId >= _sequenceId;\n  }\n\n  /**\n   * @notice Calculates the reward fraction for an auction if it were to be completed after the elapsed time.\n   * @dev Uses the last sold fraction as the target price for this auction.\n   * @return The reward fraction as a UD2x18 value\n   */\n  function _fractionalReward(uint64 _elapsedSeconds) internal view returns (UD2x18) {\n    return\n      RewardLib.fractionalReward(\n        _elapsedSeconds,\n        _auctionDurationSeconds,\n        _auctionTargetTimeFraction,\n        _auctionResults.rewardFraction\n      );\n  }\n}"
    }
  ]
}