{
  "Title": "[N-07]  Consider using `delete` rather than assigning zero to clear values",
  "Content": "The `delete` keyword more closely matches the semantics of what is being done, and draws more attention to the changing of state, which may lead to a more thorough audit of its associated logic.\n\n*There are 4 instances of this issue:*\n\n```solidity\nFile: src/modules/GroupBuy.sol\n\n253:                  bid.quantity = 0;\n\n```\nhttps://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L253\n\n```solidity\nFile: src/seaport/modules/OptimisticListingSeaport.sol\n\n293:              activeListing.collateral = 0;\n\n325:          pendingBalances[_vault][_to] = 0;\n\n437:          orderParams.totalOriginalConsiderationItems = 0;\n\n```\nhttps://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol#L293\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-12-tessera",
  "Code": [
    {
      "filename": "src/modules/GroupBuy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {ERC165Checker} from \"openzeppelin-contracts/utils/introspection/ERC165Checker.sol\";\nimport {MerkleBase} from \"../utils/MerkleBase.sol\";\nimport {MerkleProof} from \"openzeppelin-contracts/utils/cryptography/MerkleProof.sol\";\nimport {MinPriorityQueue, Bid} from \"../lib/MinPriorityQueue.sol\";\nimport {Minter} from \"../modules/Minter.sol\";\n\nimport {ICryptoPunk} from \"../punks/interfaces/ICryptoPunk.sol\";\nimport {IERC721} from \"../interfaces/IERC721.sol\";\nimport {IGroupBuy, PoolInfo} from \"../interfaces/IGroupBuy.sol\";\nimport {IMarketBuyer} from \"../interfaces/IMarketBuyer.sol\";\n\n/// @title GroupBuy\n/// @author Tessera\n/// @notice Module contract for pooling group funds to purchase and vault NFTs\n/// - The bidding mechanism used here is a slightly modified implementation of the\n///   Smart Batched Auction: https://github.com/FrankieIsLost/smart-batched-auction\ncontract GroupBuy is IGroupBuy, MerkleBase, Minter {\n    /// @dev Use MinPriorityQueue library for Queue types\n    using MinPriorityQueue for MinPriorityQueue.Queue;\n    /// @dev Interface ID for ERC-721 tokens\n    bytes4 constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n    /// @notice Current pool ID\n    uint256 public currentId;\n    /// @notice Mapping of pool ID to vault address\n    mapping(uint256 => address) public poolToVault;\n    /// @notice Mapping of pool ID to PoolInfo struct\n    mapping(uint256 => PoolInfo) public poolInfo;\n    /// @notice Mapping of pool ID to the priority queue of valid bids\n    mapping(uint256 => MinPriorityQueue.Queue) public bidPriorityQueues;\n    /// @notice Mapping of pool ID to amount of Raes currently filled for the pool\n    mapping(uint256 => uint256) public filledQuantities;\n    /// @notice Mapping of pool ID to minimum ether price of any bid\n    mapping(uint256 => uint256) public minBidPrices;\n    /// @notice Mapping of pool ID to minimum reserve prices\n    mapping(uint256 => uint256) public minReservePrices;\n    /// @notice Mapping of pool ID to total amount of ether contributed\n    mapping(uint256 => uint256) public totalContributions;\n    /// @notice Mapping of pool ID to user address to total amount of ether contributed\n    mapping(uint256 => mapping(address => uint256)) public userContributions;\n    /// @notice Mapping of user address to pending balance available for withdrawal\n    mapping(address => uint256) public pendingBalances;\n\n    /// @dev Initializes supply contract and minimum bid price\n    constructor(address _supply) Minter(_supply) {}\n\n    /// @notice Creates a new pool\n    /// @param _nftContract Address of the NFT contract\n    /// @param _tokenIds List of tokenIds permitted to be purchased\n    /// @param _initialPrice Initial price of the NFT(s)\n    /// @param _totalSupply Total amount of Raes to be minted\n    /// @param _duration Time period of pool existing before termination\n    /// @param _quantity Amount of Raes being bid on\n    /// @param _raePrice Ether price per Rae\n    function createPool(\n        address _nftContract,\n        uint256[] calldata _tokenIds,\n        uint256 _initialPrice,\n        uint48 _totalSupply,\n        uint40 _duration,\n        uint256 _quantity,\n        uint256 _raePrice\n    ) external payable {\n        // Reverts if list of tokenIds is empty\n        uint256 length = _tokenIds.length;\n        if (length == 0) revert InsufficientTokenIds();\n\n        // Generates merkle root based on list size of tokenIds\n        bytes32 merkleRoot = (length == 1) ? bytes32(_tokenIds[0]) : _generateRoot(_tokenIds);\n\n        // Sets mapping of poolId to PoolInfo\n        poolInfo[++currentId] = PoolInfo(\n            _nftContract,\n            _totalSupply,\n            uint40(block.timestamp) + _duration,\n            false,\n            merkleRoot\n        );\n\n        // Calculates minimum bid price based on initial price of NFT and desired total supply\n        minBidPrices[currentId] = _initialPrice / _totalSupply;\n\n        // Initializes first bid in queue\n        bidPriorityQueues[currentId].initialize();\n\n        // Emits event for creating new pool\n        emit Create(currentId, _nftContract, _tokenIds, msg.sender, _totalSupply, _duration);\n\n        // Contributes ether into new pool\n        contribute(currentId, _quantity, _raePrice);\n    }\n\n    /// @notice Contributes to an existing pool\n    /// @param _poolId ID of the pool\n    /// @param _quantity Amount of Raes being bid on\n    /// @param _price Ether price per Rae\n    function contribute(\n        uint256 _poolId,\n        uint256 _quantity,\n        uint256 _price\n    ) public payable {\n        // Reverts if pool ID is not valid\n        _verifyPool(_poolId);\n        // Reverts if NFT has already been purchased OR termination period has passed\n        (, uint48 totalSupply, , , ) = _verifyUnsuccessfulState(_poolId);\n        // Reverts if ether contribution amount per Rae is less than minimum bid price per Rae\n        if (msg.value < _quantity * minBidPrices[_poolId] || _quantity == 0)\n            revert InvalidContribution();\n        // Reverts if ether payment amount is not equal to total amount being contributed\n        if (msg.value != _quantity * _price) revert InvalidPayment();\n\n        // Updates user and pool contribution amounts\n        userContributions[_poolId][msg.sender] += msg.value;\n        totalContributions[_poolId] += msg.value;\n\n        // Calculates remaining supply based on total possible supply and current filled quantity amount\n        uint256 remainingSupply = totalSupply - filledQuantities[_poolId];\n        // Calculates quantity amount being filled at any price\n        uint256 fillAtAnyPriceQuantity = remainingSupply < _quantity ? remainingSupply : _quantity;\n\n        // Checks if quantity amount being filled is greater than 0\n        if (fillAtAnyPriceQuantity > 0) {\n            // Inserts bid into end of queue\n            bidPriorityQueues[_poolId].insert(msg.sender, _price, fillAtAnyPriceQuantity);\n            // Increments total amount of filled quantities\n            filledQuantities[_poolId] += fillAtAnyPriceQuantity;\n        }\n\n        // Calculates unfilled quantity amount based on desired quantity and actual filled quantity amount\n        uint256 unfilledQuantity = _quantity - fillAtAnyPriceQuantity;\n        // Processes bids in queue to recalculate unfilled quantity amount\n        unfilledQuantity = processBidsInQueue(_poolId, unfilledQuantity, _price);\n\n        // Recalculates filled quantity amount based on updated unfilled quantity amount\n        uint256 filledQuantity = _quantity - unfilledQuantity;\n        // Updates minimum reserve price if filled quantity amount is greater than 0\n        if (filledQuantity > 0) minReservePrices[_poolId] = getMinPrice(_poolId);\n\n        // Emits event for contributing ether to pool based on desired quantity amount and price per Rae\n        emit Contribute(\n            _poolId,\n            msg.sender,\n            msg.value,\n            _quantity,\n            _price,\n            minReservePrices[_poolId]\n        );\n    }\n\n    /// @notice Purchases NFT once contribution amount has been met\n    /// @param _poolId ID of the pool\n    /// @param _market Address of the market buyer contract\n    /// @param _nftContract Address of the NFT contract\n    /// @param _tokenId ID of the token\n    /// @param _price Total ether price of the listed NFT\n    /// @param _purchaseOrder Bytes data of the purchase order parameters\n    /// @param _purchaseProof Merkle proof of the tokenId in the list of permitted tokenIds\n    function purchase(\n        uint256 _poolId,\n        address _market,\n        address _nftContract,\n        uint256 _tokenId,\n        uint256 _price,\n        bytes memory _purchaseOrder,\n        bytes32[] memory _purchaseProof\n    ) external {\n        // Reverts if pool ID is not valid\n        _verifyPool(_poolId);\n        // Reverts if NFT has already been purchased OR termination period has passed\n        (\n            address nftContract,\n            uint48 totalSupply,\n            ,\n            ,\n            bytes32 merkleRoot\n        ) = _verifyUnsuccessfulState(_poolId);\n        // Reverts if NFT contract is not equalt to NFT contract set on pool creation\n        if (_nftContract != nftContract) revert InvalidContract();\n        // Reverts if price is greater than total contribution amount of pool\n        if (_price > minReservePrices[_poolId] * filledQuantities[_poolId])\n            revert InvalidPurchase();\n\n        // Checks merkle proof based on size of array\n        if (_purchaseProof.length == 0) {\n            // Hashes tokenId to verify merkle root if proof is empty\n            if (bytes32(_tokenId) != merkleRoot) revert InvalidProof();\n        } else {\n            // Verifies merkle proof based on position of leaf node in tree\n            bytes32 leaf = keccak256(abi.encode(_tokenId));\n            if (!MerkleProof.verify(_purchaseProof, merkleRoot, leaf)) revert InvalidProof();\n        }\n\n        // Decrements actual price from total pool contributions\n        totalContributions[_poolId] -= _price;\n\n        // Encodes NFT contract and tokenId into purchase order\n        bytes memory nftData = abi.encode(_nftContract, _tokenId);\n        // Encodes arbitrary amount of data based on market buyer to execute purchase\n        _purchaseOrder = abi.encodePacked(nftData, _purchaseOrder);\n\n        // Executes purchase order transaction through market buyer contract and deploys new vault\n        address vault = IMarketBuyer(_market).execute{value: _price}(_purchaseOrder);\n\n        // Checks if NFT contract supports ERC165 and interface ID of ERC721 tokens\n        if (ERC165Checker.supportsInterface(_nftContract, _INTERFACE_ID_ERC721)) {\n            // Verifes vault is owner of ERC-721 token\n            if (IERC721(_nftContract).ownerOf(_tokenId) != vault) revert UnsuccessfulPurchase();\n        } else {\n            // Verifies vault is owner of CryptoPunk token\n            if (ICryptoPunk(_nftContract).punkIndexToAddress(_tokenId) != vault)\n                revert UnsuccessfulPurchase();\n        }\n\n        // Stores mapping value of poolId to newly deployed vault\n        poolToVault[_poolId] = vault;\n        // Sets pool state to successful\n        poolInfo[_poolId].success = true;\n\n        // Emits event for purchasing NFT at given price\n        emit Purchase(_poolId, vault, _nftContract, _tokenId, _price);\n    }\n\n    /// @notice Mints Raes based on contribution amount and refunds remaining ether\n    /// @param _poolId ID of the pool\n    /// @param _mintProof Merkle proof for executing minting of Rae tokens\n    function claim(uint256 _poolId, bytes32[] calldata _mintProof) external {\n        // Reverts if pool ID is not valid\n        _verifyPool(_poolId);\n        // Reverts if purchase has not been made AND termination period has not passed\n        (, , , bool success, ) = _verifySuccessfulState(_poolId);\n        // Reverts if contribution balance of user is insufficient\n        uint256 contribution = userContributions[_poolId][msg.sender];\n        if (contribution == 0) revert InsufficientBalance();\n\n        // Deletes user contribution from storage\n        delete userContributions[_poolId][msg.sender];\n\n        // Set up scoped values for iteration\n        uint256 totalQty;\n        uint256 reservePrice = minReservePrices[_poolId];\n        uint256[] memory bidIds = getOwnerToBidIds(_poolId, msg.sender);\n        uint256 length = bidIds.length;\n\n        // Iterates through all active bidIds of the caller\n        if (success) {\n            for (uint256 i; i < length; ++i) {\n                // Gets bid quantity from storage\n                Bid storage bid = bidPriorityQueues[_poolId].bidIdToBidMap[bidIds[i]];\n                uint256 quantity = bid.quantity;\n                // Resets bid quantity amount\n                bid.quantity = 0;\n                // Increments total quantity of Raes to be minted\n                totalQty += quantity;\n                // Decrements quantity price from total user contribution balance\n                contribution -= quantity * reservePrice;\n            }\n\n            // Mints total quantity of Raes to caller\n            _mintRaes(poolToVault[_poolId], msg.sender, totalQty, _mintProof);\n        }\n\n        // Transfers remaining contribution balance back to caller\n        payable(msg.sender).call{value: contribution}(\"\");\n\n        // Withdraws pending balance of caller if available\n        if (pendingBalances[msg.sender] > 0) withdrawBalance();\n\n        // Emits event for claiming tokens and receiving ether refund\n        emit Claim(_poolId, msg.sender, totalQty, contribution);\n    }\n\n    function withdrawBalance() public {\n        // Reverts if caller balance is insufficient\n        uint256 balance = pendingBalances[msg.sender];\n        if (balance == 0) revert InsufficientBalance();\n\n        // Resets pending balance amount\n        delete pendingBalances[msg.sender];\n\n        // Transfers pending ether balance to caller\n        payable(msg.sender).call{value: balance}(\"\");\n    }\n\n    /// @notice Attempts to accept bid for specifc quantity and price\n    /// @param _poolId ID of the pool\n    /// @param _quantity Amount of Raes being filled\n    /// @param _price Price of ether per Rae token\n    /// @return quantity Unfilled quantity amount\n    function processBidsInQueue(\n        uint256 _poolId,\n        uint256 _quantity,\n        uint256 _price\n    ) private returns (uint256 quantity) {\n        quantity = _quantity;\n        while (quantity > 0) {\n            // Retrieves lowest bid in queue\n            Bid storage lowestBid = bidPriorityQueues[_poolId].getMin();\n            // Breaks out of while loop if given price is less than than lowest bid price\n            if (_price < lowestBid.price) {\n                break;\n            }\n\n            uint256 lowestBidQuantity = lowestBid.quantity;\n            // Checks if lowest bid quantity amount is greater than given quantity amount\n            if (lowestBidQuantity > quantity) {\n                // Decrements given quantity amount from lowest bid quantity\n                lowestBid.quantity -= quantity;\n                // Calculates partial contribution of bid by quantity amount and price\n                uint256 contribution = quantity * lowestBid.price;\n\n                // Decrements partial contribution amount of lowest bid from total and user contributions\n                totalContributions[_poolId] -= contribution;\n                userContributions[_poolId][lowestBid.owner] -= contribution;\n                // Increments pending balance of lowest bid owner\n                pendingBalances[lowestBid.owner] += contribution;\n\n                // Inserts new bid with given quantity amount into proper position of queue\n                bidPriorityQueues[_poolId].insert(msg.sender, _price, quantity);\n                // Resets quantity amount to exit while loop\n                quantity = 0;\n            } else {\n                // Calculates total contribution of bid by quantity amount and price\n                uint256 contribution = lowestBid.quantity * lowestBid.price;\n\n                // Decrements full contribution amount of lowest bid from total and user contributions\n                totalContributions[_poolId] -= contribution;\n                userContributions[_poolId][lowestBid.owner] -= contribution;\n                // Increments pending balance of lowest bid owner\n                pendingBalances[lowestBid.owner] += contribution;\n\n                // Removes lowest bid in queue\n                bidPriorityQueues[_poolId].delMin();\n                // Inserts new bid with lowest bid quantity amount into proper position of queue\n                bidPriorityQueues[_poolId].insert(msg.sender, _price, lowestBidQuantity);\n                // Decrements lowest bid quantity from total quantity amount\n                quantity -= lowestBidQuantity;\n            }\n        }\n    }\n\n    /// @notice Gets bid values in queue of given pool\n    /// @param _poolId ID of the pool\n    /// @param _bidId ID of the bid in queue\n    function getBidInQueue(uint256 _poolId, uint256 _bidId)\n        public\n        view\n        returns (\n            uint256 bidId,\n            address owner,\n            uint256 price,\n            uint256 quantity\n        )\n    {\n        Bid storage bid = bidPriorityQueues[_poolId].bidIdToBidMap[_bidId];\n        bidId = bid.bidId;\n        owner = bid.owner;\n        price = bid.price;\n        quantity = bid.quantity;\n    }\n\n    /// @notice Gets minimum bid price of queue for given pool\n    /// @param _poolId ID of the pool\n    function getMinPrice(uint256 _poolId) public view returns (uint256) {\n        return bidPriorityQueues[_poolId].getMin().price;\n    }\n\n    /// @notice Gets next bidId in queue of given pool\n    /// @param _poolId ID of the pool\n    function getNextBidId(uint256 _poolId) public view returns (uint256) {\n        return bidPriorityQueues[_poolId].nextBidId;\n    }\n\n    /// @notice Gets total number of bids in queue for given pool\n    /// @param _poolId ID of the pool\n    function getNumBids(uint256 _poolId) public view returns (uint256) {\n        return bidPriorityQueues[_poolId].numBids;\n    }\n\n    /// @notice Gets quantity of Raes for bid of given pool\n    /// @param _poolId ID of the pool\n    /// @param _bidId ID of the bid in queue\n    function getBidQuantity(uint256 _poolId, uint256 _bidId) public view returns (uint256) {\n        return bidPriorityQueues[_poolId].bidIdToBidMap[_bidId].quantity;\n    }\n\n    /// @notice Gets list of bidIds for address of given pool\n    /// @param _poolId ID of the pool\n    /// @param _owner Address of the owner\n    function getOwnerToBidIds(uint256 _poolId, address _owner)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        return bidPriorityQueues[_poolId].ownerToBidIds[_owner];\n    }\n\n    /// @notice Logs entire queue of given pool\n    /// @dev Must include console log to debug\n    /// @param _poolId ID of the pool\n    function printQueue(uint256 _poolId) public view {\n        uint256 counter;\n        uint256 index = 1;\n        MinPriorityQueue.Queue storage queue = bidPriorityQueues[_poolId];\n        uint256 numBids = queue.numBids;\n        while (counter < numBids) {\n            Bid memory bid = queue.bidIdToBidMap[index];\n            if (bid.bidId == 0) {\n                ++index;\n                continue;\n            }\n            ++index;\n            ++counter;\n        }\n    }\n\n    /// @dev Generates merkle root for list of tokenIds\n    function _generateRoot(uint256[] calldata _tokenIds)\n        internal\n        pure\n        returns (bytes32 merkleRoot)\n    {\n        // Creates empty leaf nodes array based on size of tokenIds\n        uint256 length = _tokenIds.length;\n        bytes32[] memory leaves = new bytes32[](length);\n        unchecked {\n            for (uint256 i; i < length; ++i) {\n                // Hashes each tokenId into leaf node and set at index position of array\n                leaves[i] = keccak256(abi.encode(_tokenIds[i]));\n            }\n        }\n        // Generates merkle root from given leaf nodes\n        merkleRoot = getRoot(leaves);\n    }\n\n    /// @dev Reverts if pool ID is not valid\n    function _verifyPool(uint256 _poolId) internal view {\n        if (_poolId == 0 || _poolId > currentId) revert InvalidPool();\n    }\n\n    // Reverts if NFT has already been purchased OR termination period has passed\n    function _verifyUnsuccessfulState(uint256 _poolId)\n        internal\n        view\n        returns (\n            address,\n            uint48,\n            uint40,\n            bool,\n            bytes32\n        )\n    {\n        PoolInfo memory pool = poolInfo[_poolId];\n        if (pool.success || block.timestamp > pool.terminationPeriod) revert InvalidState();\n        return (\n            pool.nftContract,\n            pool.totalSupply,\n            pool.terminationPeriod,\n            pool.success,\n            pool.merkleRoot\n        );\n    }\n\n    // Reverts if NFT has not been purchased AND termination period has not passed\n    function _verifySuccessfulState(uint256 _poolId)\n        internal\n        view\n        returns (\n            address,\n            uint48,\n            uint40,\n            bool,\n            bytes32\n        )\n    {\n        PoolInfo memory pool = poolInfo[_poolId];\n        if (!pool.success && block.timestamp < pool.terminationPeriod) revert InvalidState();\n        return (\n            pool.nftContract,\n            pool.totalSupply,\n            pool.terminationPeriod,\n            pool.success,\n            pool.merkleRoot\n        );\n    }\n}"
    },
    {
      "filename": "src/seaport/modules/OptimisticListingSeaport.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {Module} from \"../../modules/Module.sol\";\nimport {Multicall} from \"../../utils/Multicall.sol\";\nimport {NFTReceiver} from \"../../utils/NFTReceiver.sol\";\nimport {SafeSend} from \"../../utils/SafeSend.sol\";\nimport {SelfPermit} from \"../../utils/SelfPermit.sol\";\n\nimport {ConsiderationItem, ItemType, OfferItem, Order, OrderParameters, OrderComponents, OrderType} from \"seaport/lib/ConsiderationStructs.sol\";\nimport {ConsiderationInterface as ISeaport} from \"seaport/interfaces/ConsiderationInterface.sol\";\nimport {IERC1155} from \"../../interfaces/IERC1155.sol\";\nimport {IOptimisticListingSeaport, Listing} from \"../interfaces/IOptimisticListingSeaport.sol\";\nimport {IRae} from \"../../interfaces/IRae.sol\";\nimport {ISeaportLister} from \"../interfaces/ISeaportLister.sol\";\nimport {ISupply} from \"../../interfaces/ISupply.sol\";\nimport {IVault} from \"../../interfaces/IVault.sol\";\nimport {IVaultRegistry, Permission} from \"../../interfaces/IVaultRegistry.sol\";\n\n/// @title OptimisticListingSeaport\n/// @author Tessera\n/// @notice Module contract for listing vault assets through the Seaport protocol\ncontract OptimisticListingSeaport is\n    IOptimisticListingSeaport,\n    Module,\n    Multicall,\n    NFTReceiver,\n    SafeSend,\n    SelfPermit\n{\n    /// @notice Address of VaultRegistry contract\n    address public immutable registry;\n    /// @notice Address of the Seaport contract\n    address public immutable seaport;\n    /// @notice Address of the Zone to list items under\n    address public immutable zone;\n    /// @notice The conduit key used to deploy the conduit\n    bytes32 public immutable conduitKey;\n    /// @notice Address of Supply target contract\n    address public immutable supply;\n    /// @notice Address of the SeaportLister target contract\n    address public immutable seaportLister;\n    /// @notice Time period of a proposed listing\n    uint256 public immutable PROPOSAL_PERIOD;\n    /// @notice Address of the OpenSea recipient for receiving fees\n    address payable public immutable OPENSEA_RECIPIENT;\n    /// @notice Address of the protocol fee receiver\n    address payable public feeReceiver;\n    /// @notice Mapping of vault address to order hash\n    mapping(address => bytes32) public vaultOrderHash;\n    /// @notice Mapping of vault address to active listings on Seaport\n    mapping(address => Listing) public activeListings;\n    /// @notice Mapping of vault address to newly proposed listings\n    mapping(address => Listing) public proposedListings;\n    /// @notice Mapping of vault address to user address to collateral amount\n    mapping(address => mapping(address => uint256)) public pendingBalances;\n\n    /// @dev Initializes contract state\n    constructor(\n        address _registry,\n        address _seaport,\n        address _zone,\n        bytes32 _conduitKey,\n        address _supply,\n        address _seaportLister,\n        address payable _feeReceiver,\n        address payable _openseaRecipient,\n        uint256 _proposalPeriod,\n        address payable _weth\n    ) SafeSend(_weth) {\n        registry = _registry;\n        seaport = _seaport;\n        zone = _zone;\n        conduitKey = _conduitKey;\n        supply = _supply;\n        seaportLister = _seaportLister;\n        feeReceiver = _feeReceiver;\n        OPENSEA_RECIPIENT = _openseaRecipient;\n        PROPOSAL_PERIOD = _proposalPeriod;\n    }\n\n    /// @dev Callback for receiving ether when the calldata is empty\n    receive() external payable {}\n\n    /// @notice Proposes a new optimistic listing for a vault\n    /// @param _vault Address of the vault\n    /// @param _collateral Amount of tokens the proposer is risking\n    /// @param _pricePerToken Desired listing price of the vault assets divided by total supply\n    /// @param _offer List of items included in the offer to be listed\n    function propose(\n        address _vault,\n        uint256 _collateral,\n        uint256 _pricePerToken,\n        OfferItem[] calldata _offer\n    ) external {\n        // Reverts if vault is not registered\n        (address token, uint256 id) = _verifyVault(_vault);\n        // Reverts if vault is not current owner of the assets\n        if (_verifySale(_vault)) revert NotOwner();\n        // Reverts if caller has insufficient token balance\n        _verifyBalance(token, id, _collateral);\n        // Initializes the mappings if this is the first time a proposal is being submitted for the vault\n        Listing storage proposedListing = proposedListings[_vault];\n        Listing storage activeListing = activeListings[_vault];\n        if (\n            proposedListings[_vault].proposer == address(0) &&\n            activeListings[_vault].proposer == address(0)\n        ) {\n            _setListing(proposedListing, address(this), 0, type(uint256).max, 0);\n            _setListing(activeListing, address(this), 0, type(uint256).max, 0);\n        }\n        // Reverts if price per token is not lower than both the proposed and active listings\n        if (\n            _pricePerToken >= proposedListing.pricePerToken ||\n            _pricePerToken >= activeListings[_vault].pricePerToken\n        ) revert NotLower();\n\n        // Calculates listing price based on price per token and total supply of Raes\n        uint256 listingPrice = _pricePerToken * IRae(token).totalSupply(id);\n\n        // Constructs Seaport order and sets the proposed listing\n        _constructOrder(_vault, listingPrice, _offer);\n        _setListing(proposedListing, msg.sender, _collateral, _pricePerToken, block.timestamp);\n\n        // Sets collateral amount to pending balances for withdrawal\n        pendingBalances[_vault][proposedListing.proposer] += proposedListing.collateral;\n\n        // Transfers new collateral amount from caller to this contract\n        IERC1155(token).safeTransferFrom(msg.sender, address(this), id, _collateral, \"\");\n\n        // Emits event for proposing new listing\n        emit Propose(_vault, msg.sender, _collateral, _pricePerToken, proposedListing.order);\n    }\n\n    /// @notice Rejects a new listing proposal\n    /// @param _vault Address of the vault\n    /// @param _amount Amount of tokens being rejected\n    function rejectProposal(address _vault, uint256 _amount) external payable {\n        // Reverts if vault is not registered\n        (address token, uint256 id) = _verifyVault(_vault);\n        // Reverts if vault is not current owner of the assets\n        if (_verifySale(_vault)) revert NotOwner();\n        // Reverts if collateral is less than amount of rejected tokens\n        Listing storage proposedListing = proposedListings[_vault];\n        if (proposedListing.collateral < _amount) revert InsufficientCollateral();\n        // Reverts if payment amount is incorrect\n        if (proposedListing.pricePerToken * _amount != msg.value) revert InvalidPayment();\n\n        // Store proposer in memory\n        address proposer = proposedListing.proposer;\n\n        // Decrements collateral amount\n        proposedListing.collateral -= _amount;\n\n        // Checks if proposed listing has been rejected\n        if (proposedListing.collateral == 0) {\n            // Resets proposed listing to default\n            _setListing(proposedListing, address(this), 0, type(uint256).max, 0);\n        }\n\n        // Transfers tokens to caller\n        IERC1155(token).safeTransferFrom(address(this), msg.sender, id, _amount, \"\");\n        // Sends ether to proposer\n        _sendEthOrWeth(proposer, msg.value);\n\n        // Emits event for rejecting a proposed listing\n        emit RejectProposal(_vault, msg.sender, _amount, msg.value, proposedListing.order);\n    }\n\n    /// @notice Rejects an active listing\n    /// @param _vault Address of the vault\n    /// @param _amount Amount of tokens being rejected\n    /// @param _delistProof Merkle proof for executing the delisting of assets\n    function rejectActive(\n        address _vault,\n        uint256 _amount,\n        bytes32[] calldata _delistProof\n    ) external payable {\n        // Reverts if vault is not registered\n        (address token, uint256 id) = _verifyVault(_vault);\n        // Reverts if vault is not current owner of the assets\n        if (_verifySale(_vault)) revert NotOwner();\n        // Reverts if collateral is less than amount of rejected tokens\n        Listing storage activeListing = activeListings[_vault];\n        if (activeListing.collateral < _amount) revert InsufficientCollateral();\n        // Reverts if payment amount is incorrect\n        if (activeListing.pricePerToken * _amount != msg.value) revert InvalidPayment();\n\n        // Store proposer in memory\n        address proposer = activeListing.proposer;\n\n        // Decrements collateral amount\n        activeListing.collateral -= _amount;\n\n        // Checks if active listing has been rejected\n        if (activeListing.collateral == 0) {\n            // Cancels the Seaport Order\n            _delist(_vault, _delistProof);\n            // Resets active listing to default\n            delete activeListings[_vault];\n            _setListing(activeListing, address(this), 0, type(uint256).max, 0);\n            // Emits event for delisting assets\n            emit Delist(_vault, activeListing.order);\n        }\n\n        // Transfers tokens to caller\n        IERC1155(token).safeTransferFrom(address(this), msg.sender, id, _amount, \"\");\n        // Sends ether to proposer\n        _sendEthOrWeth(proposer, msg.value);\n\n        // Emits event for rejecting an active listing\n        emit RejectActive(_vault, msg.sender, _amount, msg.value, activeListing.order);\n    }\n\n    /// @notice Lists the assets for sale\n    /// @param _vault Address of the vault\n    /// @param _listProof Merkle proof for executing the listing of assets\n    function list(address _vault, bytes32[] calldata _listProof) public {\n        // Reverts if vault is not registered\n        (address token, uint256 id) = _verifyVault(_vault);\n        // Reverts if vault is not current owner of the assets\n        if (_verifySale(_vault)) revert NotOwner();\n        // Reverts if collateral of proposed listing has been rejected\n        Listing storage proposedListing = proposedListings[_vault];\n        if (proposedListing.collateral == 0) revert Rejected();\n        // Reverts if proposal period has not elapsed\n        if (proposedListing.proposalDate + PROPOSAL_PERIOD > block.timestamp)\n            revert TimeNotElapsed();\n\n        // Sets remaining collateral amount of proposer for withdrawal\n        Listing memory activeListing = activeListings[_vault];\n        pendingBalances[_vault][activeListing.proposer] = activeListing.collateral;\n\n        // Calculates new listing price\n        uint256 newPrice = proposedListing.pricePerToken * IRae(token).totalSupply(id);\n\n        // Structures the order array\n        Order[] memory order = new Order[](1);\n        order[0] = proposedListing.order;\n\n        // Replaces active listing with the successfully proposed listing\n        activeListings[_vault] = proposedListing;\n        // Resets proposed listing to default\n        _setListing(proposedListing, address(this), 0, type(uint256).max, 0);\n\n        // List order on Seaport\n        bytes memory data = abi.encodeCall(ISeaportLister.validateListing, (seaport, order));\n        IVault(payable(_vault)).execute(seaportLister, data, _listProof);\n\n        // Emits event for successful listing\n        emit List(_vault, newPrice, activeListings[_vault].order);\n    }\n\n    /// @notice Cancels an active listing from being on sale\n    /// @param _vault Address of the vault\n    /// @param _delistProof Merkle proof for executing the delisting of assets\n    function cancel(address _vault, bytes32[] calldata _delistProof) external {\n        // Reverts if vault is not registered\n        (address token, uint256 id) = _verifyVault(_vault);\n        // Reverts if vault is not current owner of the assets\n        if (_verifySale(_vault)) revert NotOwner();\n        // Reverts if caller is not proposer of active listing\n        Listing storage activeListing = activeListings[_vault];\n        if (activeListing.proposer != msg"
    }
  ]
}