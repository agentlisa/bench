{
  "Title": "H-7: `totalBPTSupply` will be excessively inflated",
  "Content": "# Issue H-7: `totalBPTSupply` will be excessively inflated \n\nSource: https://github.com/sherlock-audit/2022-12-notional-judging/issues/11 \n\n## Found by \nthekmj, xiaoming90\n\n## Summary\n\nThe `totalBPTSupply` will be excessively inflated as `totalSupply` was used instead of `virtualSupply`. This might cause a boosted balancer leverage vault not to be emergency settled in a timely manner and holds too large of a share of the liquidity within the pool, thus having problems exiting its position.\n\n## Vulnerability Detail\n\nBalancer's Boosted Pool uses Phantom BPT where all pool tokens are minted at the time of pool creation and are held by the pool itself. Therefore, `virtualSupply` should be used instead of `totalSupply` to determine the amount of BPT supply in circulation.\n\nHowever, within the `Boosted3TokenAuraVault.getEmergencySettlementBPTAmount` function, the `totalBPTSupply` at Line 169 is derived from the `totalSupply` instead of the `virtualSupply`.  As a result, `totalBPTSupply` will be excessively inflated (`2**(111)`).\n\nhttps://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/Boosted3TokenAuraVault.sol#L169\n\n```solidity\nFile: Boosted3TokenAuraVault.sol\n165:     function getEmergencySettlementBPTAmount(uint256 maturity) external view returns (uint256 bptToSettle) {\n166:         Boosted3TokenAuraStrategyContext memory context = _strategyContext();\n167:         bptToSettle = context.baseStrategy._getEmergencySettlementParams({\n168:             maturity: maturity, \n169:             totalBPTSupply: IERC20(context.poolContext.basePool.basePool.pool).totalSupply()\n170:         });\n171:     }\n```\n\nAs a result, the `emergencyBPTWithdrawThreshold` threshold will be extremely high. As such, the condition at Line 97 will always be evaluated as true and result in a revert.\n\nhttps://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/balancer/internal/settlement/SettlementUtils.sol#L86\n\n```solidity\nFile: SettlementUtils.sol\n86:     function _getEmergencySettlementParams(\n87:         StrategyContext memory strategyContext,\n88:         uint256 maturity,\n89:         uint256 totalBPTSupply\n90:     )  internal view returns(uint256 bptToSettle) {\n91:         StrategyVaultSettings memory settings = strategyContext.vaultSettings;\n92:         StrategyVaultState memory state = strategyContext.vaultState;\n93: \n94:         // Not in settlement window, check if BPT held is greater than maxBalancerPoolShare * total BPT supply\n95:         uint256 emergencyBPTWithdrawThreshold = settings._bptThreshold(totalBPTSupply);\n96: \n97:         if (strategyContext.vaultState.totalBPTHeld <= emergencyBPTWithdrawThreshold)\n98:             revert Errors.InvalidEmergencySettlement();\n```\n\nhttps://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/balancer/internal/BalancerVaultStorage.sol#L52\n\n```solidity\nFile: BalancerVaultStorage.sol\n52:     function _bptThreshold(StrategyVaultSettings memory strategyVaultSettings, uint256 totalBPTSupply)\n53:         internal pure returns (uint256) {\n54:         return (totalBPTSupply * strategyVaultSettings.maxBalancerPoolShare) / BalancerConstants.VAULT_PERCENT_BASIS;\n55:     }\n```\n\n## Impact\n\nAnyone (e.g. off-chain keeper or bot) that relies on the `SettlementUtils.getEmergencySettlementBPTAmount` to determine if an emergency settlement is needed would be affected. The caller will presume that since the function reverts, emergency settlement is not required and the BPT threshold is still within the healthy level. The caller will wrongly decided not to perform an emergency settlement on a vault that has already exceeded the BPT threshold.\n\nIf a boosted balancer leverage vault is not emergency settled in a timely manner and holds too large of a share of the liquidity within the pool, it will have problems exiting its position.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/Boosted3TokenAuraVault.sol#L169\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUpdate the function to compute the `totalBPTSupply` from the virtual supply.\n\n```diff\n    function getEmergencySettlementBPTAmount(uint256 maturity) external view returns (uint256 bptToSettle) {\n        Boosted3TokenAuraStrategyContext memory context = _strategyContext();\n        bptToSettle = context.baseStrategy._getEmergencySettlementParams({\n            maturity: maturity, \n-           totalBPTSupply: IERC20(context.poolContext.basePool.basePool.pool).totalSupply()\n+\t\t\ttotalBPTSupply: context.poolContext._getVirtualSupply(context.oracleContext)\n        });\n    }\n```\n\n## Discussion\n\n**weitianjie2000**\n\nvalid, will fix\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/31",
  "Code": [
    {
      "filename": "contracts/vaults/Boosted3TokenAuraVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {Errors} from \"../global/Errors.sol\";\nimport {Deployments} from \"../global/Deployments.sol\";\nimport {\n    DepositParams,\n    RedeemParams,\n    AuraVaultDeploymentParams,\n    InitParams,\n    ReinvestRewardParams,\n    StrategyVaultSettings,\n    StrategyVaultState,\n    PoolContext,\n    ThreeTokenPoolContext,\n    Boosted3TokenAuraStrategyContext,\n    StrategyContext\n} from \"./balancer/BalancerVaultTypes.sol\";\nimport {BalancerConstants} from \"./balancer/internal/BalancerConstants.sol\";\nimport {BalancerStrategyBase} from \"./balancer/BalancerStrategyBase.sol\";\nimport {Boosted3TokenPoolMixin} from \"./balancer/mixins/Boosted3TokenPoolMixin.sol\";\nimport {AuraStakingMixin} from \"./balancer/mixins/AuraStakingMixin.sol\";\nimport {NotionalProxy} from \"../../interfaces/notional/NotionalProxy.sol\";\nimport {BalancerVaultStorage} from \"./balancer/internal/BalancerVaultStorage.sol\";\nimport {StrategyUtils} from \"./balancer/internal/strategy/StrategyUtils.sol\";\nimport {SettlementUtils} from \"./balancer/internal/settlement/SettlementUtils.sol\";\nimport {Boosted3TokenPoolUtils} from \"./balancer/internal/pool/Boosted3TokenPoolUtils.sol\";\nimport {Boosted3TokenAuraHelper} from \"./balancer/external/Boosted3TokenAuraHelper.sol\";\nimport {IBalancerPool} from \"../../interfaces/balancer/IBalancerPool.sol\";\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\n\ncontract Boosted3TokenAuraVault is Boosted3TokenPoolMixin {\n    using Boosted3TokenPoolUtils for ThreeTokenPoolContext;\n    using StrategyUtils for StrategyContext;\n    using SettlementUtils for StrategyContext;\n    using BalancerVaultStorage for StrategyVaultState;\n    using Boosted3TokenAuraHelper for Boosted3TokenAuraStrategyContext;\n\n    constructor(NotionalProxy notional_, AuraVaultDeploymentParams memory params) \n        Boosted3TokenPoolMixin(notional_, params)\n    {}\n\n    function strategy() external override view returns (bytes4) {\n        return bytes4(keccak256(\"Boosted3TokenAuraVault\"));\n    }\n\n    function initialize(InitParams calldata params)\n        external\n        initializer\n        onlyNotionalOwner\n    {\n        __INIT_VAULT(params.name, params.borrowCurrencyId);\n        BalancerVaultStorage.setStrategyVaultSettings(params.settings);\n        (uint256[] memory balances, uint256[] memory scalingFactors) = _getBalancesAndScaleFactors();\n\n        _threeTokenPoolContext(balances, scalingFactors)._approveBalancerTokens(\n            address(_auraStakingContext().auraBooster)\n        );\n    }\n\n    function _depositFromNotional(\n        address /* account */,\n        uint256 deposit,\n        uint256 maturity,\n        bytes calldata data\n    ) internal override returns (uint256 strategyTokensMinted) {\n        strategyTokensMinted = _strategyContext().deposit(deposit, data);\n    }\n\n    function _redeemFromNotional(\n        address account,\n        uint256 strategyTokens,\n        uint256 maturity,\n        bytes calldata data\n    ) internal override returns (uint256 finalPrimaryBalance) {\n        finalPrimaryBalance = _strategyContext().redeem(strategyTokens, data);\n    }\n\n    function settleVaultNormal(\n        uint256 maturity,\n        uint256 strategyTokensToRedeem,\n        bytes calldata data\n    ) external onlyRole(NORMAL_SETTLEMENT_ROLE) {\n        if (maturity <= block.timestamp) {\n            revert Errors.PostMaturitySettlement();\n        }\n        if (block.timestamp < maturity - SETTLEMENT_PERIOD_IN_SECONDS) {\n            revert Errors.NotInSettlementWindow();\n        }\n        Boosted3TokenAuraStrategyContext memory context = _strategyContext();\n        SettlementUtils._validateCoolDown(\n            context.baseStrategy.vaultState.lastSettlementTimestamp,\n            context.baseStrategy.vaultSettings.settlementCoolDownInMinutes\n        );\n        RedeemParams memory params = SettlementUtils._decodeParamsAndValidate(\n            context.baseStrategy.vaultSettings.settlementSlippageLimitPercent,\n            data\n        );\n        Boosted3TokenAuraHelper.settleVault(\n            context, maturity, strategyTokensToRedeem, params\n        );\n        context.baseStrategy.vaultState.lastSettlementTimestamp = uint32(block.timestamp);\n        context.baseStrategy.vaultState.setStrategyVaultState();\n    }\n\n    function settleVaultPostMaturity(\n        uint256 maturity,\n        uint256 strategyTokensToRedeem,\n        bytes calldata data\n    ) external onlyRole(POST_MATURITY_SETTLEMENT_ROLE)  {\n        if (block.timestamp < maturity) {\n            revert Errors.HasNotMatured();\n        }\n        Boosted3TokenAuraStrategyContext memory context = _strategyContext();\n        RedeemParams memory params = SettlementUtils._decodeParamsAndValidate(\n            context.baseStrategy.vaultSettings.postMaturitySettlementSlippageLimitPercent,\n            data\n        );\n        Boosted3TokenAuraHelper.settleVault(\n            context, maturity, strategyTokensToRedeem, params\n        );\n    }\n\n    function settleVaultEmergency(uint256 maturity, bytes calldata data) \n        external onlyRole(EMERGENCY_SETTLEMENT_ROLE) {\n        // No need for emergency settlement during the settlement window\n        _revertInSettlementWindow(maturity);\n        Boosted3TokenAuraHelper.settleVaultEmergency(\n            _strategyContext(), maturity, data\n        );\n    }\n\n    function reinvestReward(ReinvestRewardParams calldata params) \n        external onlyRole(REWARD_REINVESTMENT_ROLE) {\n        Boosted3TokenAuraHelper.reinvestReward(_strategyContext(), params);\n    }\n\n    function convertStrategyToUnderlying(\n        address account,\n        uint256 strategyTokenAmount,\n        uint256 maturity\n    ) public view virtual override returns (int256 underlyingValue) {\n        Boosted3TokenAuraStrategyContext memory context = _strategyContext();\n        underlyingValue = context.convertStrategyToUnderlying(strategyTokenAmount);\n    }\n\n    /// @notice Updates the vault settings\n    /// @param settings vault settings\n    function setStrategyVaultSettings(StrategyVaultSettings calldata settings)\n        external\n        onlyNotionalOwner\n    {\n        BalancerVaultStorage.setStrategyVaultSettings(settings);\n    }\n    \n    function getStrategyContext() external view returns (Boosted3TokenAuraStrategyContext memory) {\n        return _strategyContext();\n    }\n\n    function getSpotPrice(uint8 tokenIndex) external view returns (uint256 spotPrice) {\n        Boosted3TokenAuraStrategyContext memory context = _strategyContext();\n        spotPrice = Boosted3TokenAuraHelper.getSpotPrice(context, tokenIndex);\n    }\n\n    function getEmergencySettlementBPTAmount(uint256 maturity) external view returns (uint256 bptToSettle) {\n        Boosted3TokenAuraStrategyContext memory context = _strategyContext();\n        bptToSettle = context.baseStrategy._getEmergencySettlementParams({\n            maturity: maturity, \n            totalBPTSupply: IERC20(context.poolContext.basePool.basePool.pool).totalSupply()\n        });\n    }\n}"
    },
    {
      "filename": "contracts/vaults/balancer/internal/settlement/SettlementUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {\n    RedeemParams, \n    TradeParams,\n    StrategyContext,\n    PoolContext,\n    StrategyVaultSettings,\n    StrategyVaultState\n} from \"../../BalancerVaultTypes.sol\";\nimport {VaultState} from \"../../../../global/Types.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {Constants} from \"../../../../global/Constants.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {StrategyUtils} from \"../strategy/StrategyUtils.sol\";\nimport {BalancerVaultStorage} from \"../BalancerVaultStorage.sol\";\n\nlibrary SettlementUtils {\n    using TypeConvert for uint256;\n    using TypeConvert for int256;\n    using StrategyUtils for StrategyContext;\n    using BalancerVaultStorage for StrategyVaultSettings;\n\n    /// @notice Validates that the slippage passed in by the caller\n    /// does not exceed the designated threshold.\n    /// @param slippageLimitPercent configured limit on the slippage from the oracle price allowed\n    /// @param data trade parameters passed into settlement\n    /// @return params abi decoded redemption parameters\n    function _decodeParamsAndValidate(\n        uint32 slippageLimitPercent,\n        bytes memory data\n    ) internal view returns (RedeemParams memory params) {\n        params = abi.decode(data, (RedeemParams));\n        TradeParams memory callbackData = abi.decode(\n            params.secondaryTradeParams, (TradeParams)\n        );\n\n        if (callbackData.oracleSlippagePercentOrLimit > slippageLimitPercent) {\n            revert Errors.SlippageTooHigh(callbackData.oracleSlippagePercentOrLimit, slippageLimitPercent);\n        }\n    }\n    \n    /// @notice Validates that the settlement is past a specified cool down period.\n    /// @param lastSettlementTimestamp the last time the vault was settled\n    /// @param coolDownInMinutes configured length of time required between settlements to ensure that\n    /// slippage thresholds are respected (gives the market time to arbitrage back into position)\n    function _validateCoolDown(uint32 lastSettlementTimestamp, uint32 coolDownInMinutes) internal view {\n        // Convert coolDown to seconds\n        if (lastSettlementTimestamp + (coolDownInMinutes * 60) > block.timestamp)\n            revert Errors.InSettlementCoolDown(lastSettlementTimestamp, coolDownInMinutes);\n    }\n\n    /// @notice Calculates the amount of BPT availTable for emergency settlement\n    function _getEmergencySettlementBPTAmount(\n        uint256 bptTotalSupply,\n        uint16 maxBalancerPoolShare,\n        uint256 totalBPTHeld,\n        uint256 bptHeldInMaturity\n    ) private pure returns (uint256 bptToSettle) {\n        // desiredPoolShare = maxPoolShare * bufferPercentage\n        uint256 desiredPoolShare = (maxBalancerPoolShare *\n            BalancerConstants.BALANCER_POOL_SHARE_BUFFER) /\n            BalancerConstants.VAULT_PERCENT_BASIS;\n        uint256 desiredBPTAmount = (bptTotalSupply * desiredPoolShare) /\n            BalancerConstants.VAULT_PERCENT_BASIS;\n        \n        bptToSettle = totalBPTHeld - desiredBPTAmount;\n\n        // Check to make sure we are not settling more than the amount of BPT\n        // available in the current maturity\n        // If more settlement is needed, call settleVaultEmergency\n        // again with a different maturity\n        if (bptToSettle > bptHeldInMaturity) {\n            bptToSettle = bptHeldInMaturity;\n        }\n    }\n\n    function _totalSupplyInMaturity(uint256 maturity) private view returns (uint256) {\n        VaultState memory vaultState = Deployments.NOTIONAL.getVaultState(address(this), maturity);\n        return vaultState.totalStrategyTokens;\n    }\n\n    function _getEmergencySettlementParams(\n        StrategyContext memory strategyContext,\n        uint256 maturity,\n        uint256 totalBPTSupply\n    )  internal view returns(uint256 bptToSettle) {\n        StrategyVaultSettings memory settings = strategyContext.vaultSettings;\n        StrategyVaultState memory state = strategyContext.vaultState;\n\n        // Not in settlement window, check if BPT held is greater than maxBalancerPoolShare * total BPT supply\n        uint256 emergencyBPTWithdrawThreshold = settings._bptThreshold(totalBPTSupply);\n\n        if (strategyContext.vaultState.totalBPTHeld <= emergencyBPTWithdrawThreshold)\n            revert Errors.InvalidEmergencySettlement();\n\n        uint256 bptHeldInMaturity = _getBPTHeldInMaturity(\n            state,\n            _totalSupplyInMaturity(maturity),\n            strategyContext.vaultState.totalBPTHeld\n        );\n\n        bptToSettle = _getEmergencySettlementBPTAmount({\n            bptTotalSupply: totalBPTSupply,\n            maxBalancerPoolShare: settings.maxBalancerPoolShare,\n            totalBPTHeld: strategyContext.vaultState.totalBPTHeld,\n            bptHeldInMaturity: bptHeldInMaturity\n        });\n    }\n\n    function _executeSettlement(\n        StrategyContext memory context,\n        uint256 maturity,\n        int256 expectedUnderlyingRedeemed,\n        uint256 redeemStrategyTokenAmount,\n        RedeemParams memory params\n    ) internal {\n        ( /* int256 assetCashRequiredToSettle */, int256 underlyingCashRequiredToSettle) \n            = Deployments.NOTIONAL.getCashRequiredToSettle(address(this), maturity);\n\n        // A negative surplus here means the account is insolvent\n        // (either expectedUnderlyingRedeemed is negative or\n        // expectedUnderlyingRedeemed is less than underlyingCashRequiredToSettle).\n        // If that's the case, we should just redeem and repay as much as possible (surplus\n        // check is ignored because maxUnderlyingSurplus can never be negative).\n        // If underlyingCashRequiredToSettle is negative, that means we already have surplus cash\n        // on the Notional side, it will just make the surplus larger and potentially\n        // cause it to go over maxUnderlyingSurplus.\n        int256 surplus = expectedUnderlyingRedeemed -\n            underlyingCashRequiredToSettle;\n\n        // Make sure we not redeeming too much to underlying\n        // This allows BPT to be accrued as the profit token.\n        if (surplus > context.vaultSettings.maxUnderlyingSurplus.toInt()) {\n            revert Errors.RedeemingTooMuch(\n                expectedUnderlyingRedeemed,\n                underlyingCashRequiredToSettle\n            );\n        }\n\n        ( /* int256 assetCashSurplus */, int256 underlyingCashSurplus) \n            = Deployments.NOTIONAL.redeemStrategyTokensToCash(\n                maturity, redeemStrategyTokenAmount, abi.encode(params)\n            );\n\n        if (underlyingCashSurplus <= 0 && maturity <= block.timestamp) {\n            Deployments.NOTIONAL.settleVault(address(this), maturity);\n        }\n    }\n\n    function _getBPTHeldInMaturity(\n        StrategyVaultState memory strategyVaultState, \n        uint256 totalSupplyInMaturity,\n        uint256 totalBPTHeld\n    ) private pure returns (uint256 bptHeldInMaturity) {\n        if (strategyVaultState.totalStrategyTokenGlobal == 0) return 0;\n        bptHeldInMaturity =\n            (totalBPTHeld * totalSupplyInMaturity) /\n            strategyVaultState.totalStrategyTokenGlobal;\n    }\n\n}"
    },
    {
      "filename": "contracts/vaults/balancer/internal/BalancerVaultStorage.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {StrategyVaultSettings, StrategyVaultState} from \"../BalancerVaultTypes.sol\";\nimport {BalancerEvents} from \"../BalancerEvents.sol\";\nimport {BalancerConstants} from \"./BalancerConstants.sol\";\n\nlibrary BalancerVaultStorage {\n    uint256 private constant STRATEGY_VAULT_SETTINGS_SLOT = 1000001;\n    uint256 private constant STRATEGY_VAULT_STATE_SLOT    = 1000002;\n\n    function _settings() private pure returns (mapping(uint256 => StrategyVaultSettings) storage store) {\n        assembly { store.slot := STRATEGY_VAULT_SETTINGS_SLOT }\n    }\n\n    function _state() private pure returns (mapping(uint256 => StrategyVaultState) storage store) {\n        assembly { store.slot := STRATEGY_VAULT_STATE_SLOT }\n    }\n\n    function getStrategyVaultSettings() internal view returns (StrategyVaultSettings memory) {\n        // Hardcode to the zero slot\n        return _settings()[0];\n    }\n\n    function setStrategyVaultSettings(StrategyVaultSettings memory settings) internal {\n        require(settings.settlementCoolDownInMinutes <= BalancerConstants.MAX_SETTLEMENT_COOLDOWN_IN_MINUTES);\n        require(settings.maxBalancerPoolShare <= BalancerConstants.VAULT_PERCENT_BASIS);\n        require(settings.settlementSlippageLimitPercent <= BalancerConstants.SLIPPAGE_LIMIT_PRECISION);\n        require(settings.postMaturitySettlementSlippageLimitPercent <= BalancerConstants.SLIPPAGE_LIMIT_PRECISION);\n        require(settings.emergencySettlementSlippageLimitPercent <= BalancerConstants.SLIPPAGE_LIMIT_PRECISION);\n        require(settings.oraclePriceDeviationLimitPercent <= BalancerConstants.VAULT_PERCENT_BASIS);\n        require(settings.balancerPoolSlippageLimitPercent <= BalancerConstants.VAULT_PERCENT_BASIS);\n\n        mapping(uint256 => StrategyVaultSettings) storage store = _settings();\n        // Hardcode to the zero slot\n        store[0] = settings;\n\n        emit BalancerEvents.StrategyVaultSettingsUpdated(settings);\n    }\n\n    function getStrategyVaultState() internal view returns (StrategyVaultState memory) {\n        // Hardcode to the zero slot\n        return _state()[0];\n    }\n\n    function setStrategyVaultState(StrategyVaultState memory state) internal {\n        mapping(uint256 => StrategyVaultState) storage store = _state();\n        // Hardcode to the zero slot\n        store[0] = state;\n    }\n\n    function _bptThreshold(StrategyVaultSettings memory strategyVaultSettings, uint256 totalBPTSupply) \n        internal pure returns (uint256) {\n        return (totalBPTSupply * strategyVaultSettings.maxBalancerPoolShare) / BalancerConstants.VAULT_PERCENT_BASIS;\n    }\n}"
    },
    {
      "filename": "contracts/vaults/Boosted3TokenAuraVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {Errors} from \"../global/Errors.sol\";\nimport {Deployments} from \"../global/Deployments.sol\";\nimport {\n    DepositParams,\n    RedeemParams,\n    AuraVaultDeploymentParams,\n    InitParams,\n    ReinvestRewardParams,\n    StrategyVaultSettings,\n    StrategyVaultState,\n    PoolContext,\n    ThreeTokenPoolContext,\n    Boosted3TokenAuraStrategyContext,\n    StrategyContext\n} from \"./balancer/BalancerVaultTypes.sol\";\nimport {BalancerConstants} from \"./balancer/internal/BalancerConstants.sol\";\nimport {BalancerStrategyBase} from \"./balancer/BalancerStrategyBase.sol\";\nimport {Boosted3TokenPoolMixin} from \"./balancer/mixins/Boosted3TokenPoolMixin.sol\";\nimport {AuraStakingMixin} from \"./balancer/mixins/AuraStakingMixin.sol\";\nimport {NotionalProxy} from \"../../interfaces/notional/NotionalProxy.sol\";\nimport {BalancerVaultStorage} from \"./balancer/internal/BalancerVaultStorage.sol\";\nimport {StrategyUtils} from \"./balancer/internal/strategy/StrategyUtils.sol\";\nimport {SettlementUtils} from \"./balancer/internal/settlement/SettlementUtils.sol\";\nimport {Boosted3TokenPoolUtils} from \"./balancer/internal/pool/Boosted3TokenPoolUtils.sol\";\nimport {Boosted3TokenAuraHelper} from \"./balancer/external/Boosted3TokenAuraHelper.sol\";\nimport {IBalancerPool} from \"../../interfaces/balancer/IBalancerPool.sol\";\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\n\ncontract Boosted3TokenAuraVault is Boosted3TokenPoolMixin {\n    using Boosted3TokenPoolUtils for ThreeTokenPoolContext;\n    using StrategyUtils for StrategyContext;\n    using SettlementUtils for StrategyContext;\n    using BalancerVaultStorage for StrategyVaultState;\n    using Boosted3TokenAuraHelper for Boosted3TokenAuraStrategyContext;\n\n    constructor(NotionalProxy notional_, AuraVaultDeploymentParams memory params) \n        Boosted3TokenPoolMixin(notional_, params)\n    {}\n\n    function strategy() external override view returns (bytes4) {\n        return bytes4(keccak256(\"Boosted3TokenAuraVault\"));\n    }\n\n    function initialize(InitParams calldata params)\n        external\n        initializer\n        onlyNotionalOwner\n    {\n        __INIT_VAULT(params.name, params.borrowCurrencyId);\n        BalancerVaultStorage.setStrategyVaultSettings(params.settings);\n        (uint256[] memory balances, uint256[] memory scalingFactors) = _getBalancesAndScaleFactors();\n\n        _threeTokenPoolContext(balances, scalingFactors)._approveBalancerTokens(\n            address(_auraStakingContext().auraBooster)\n        );\n    }\n\n    function _depositFromNotional(\n        address /* account */,\n        uint256 deposit,\n        uint256 maturity,\n        bytes calldata data\n    ) internal override returns (uint256 strategyTokensMinted) {\n        strategyTokensMinted = _strategyContext().deposit(deposit, data);\n    }\n\n    function _redeemFromNotional(\n        address account,\n        uint256 strategyTokens,\n        uint256 maturity,\n        bytes calldata data\n    ) internal override returns (uint256 finalPrimaryBalance) {\n        finalPrimaryBalance = _strategyContext().redeem(strategyTokens, data);\n    }\n\n    function settleVaultNormal(\n        uint256 maturity,\n        uint256 strategyTokensToRedeem,\n        bytes calldata data\n    ) external onlyRole(NORMAL_SETTLEMENT_ROLE) {\n        if (maturity <= block.timestamp) {\n            revert Errors.PostMaturitySettlement();\n        }\n        if (block.timestamp < maturity - SETTLEMENT_PERIOD_IN_SECONDS) {\n            revert Errors.NotInSettlementWindow();\n        }\n        Boosted3TokenAuraStrategyContext memory context = _strategyContext();\n        SettlementUtils._validateCoolDown(\n            context.baseStrategy.vaultState.lastSettlementTimestamp,\n            context.baseStrategy.vaultSettings.settlementCoolDownInMinutes\n        );\n        RedeemParams memory params = SettlementUtils._decodeParamsAndValidate(\n            context.baseStrategy.vaultSettings.settlementSlippageLimitPercent,\n            data\n        );\n        Boosted3TokenAuraHelper.settleVault(\n            context, maturity, strategyTokensToRedeem, params\n        );\n        context.baseStrategy.vaultState.lastSettlementTimestamp = uint32(block.timestamp);\n        context.baseStrategy.vaultState.setStrategyVaultState();\n    }\n\n    function settleVaultPostMaturity(\n        uint256 maturity,\n        uint256 strategyTokensToRedeem,\n        bytes calldata data\n    ) external onlyRole(POST_MATURITY_SETTLEMENT_ROLE)  {\n        if (block.timestamp < maturity) {\n            revert Errors.HasNotMatured();\n        }\n        Boosted3TokenAuraStrategyContext memory context = _strategyContext();\n        RedeemParams memory params = SettlementUtils._decodeParamsAndValidate(\n            context.baseStrategy.vaultSettings.postMaturitySettlementSlippageLimitPercent,\n            data\n        );\n        Boosted3TokenAuraHelper.settleVault(\n            context, maturity, strategyTokensToRedeem, params\n        );\n    }\n\n    function settleVaultEmergency(uint256 maturity, bytes calldata data) \n        external onlyRole(EMERGENCY_SETTLEMENT_ROLE) {\n        // No need for emergency settlement during the settlement window\n        _revertInSettlementWindow(maturity);\n        Boosted3TokenAuraHelper.settleVaultEmergency(\n            _strategyContext(), maturity, data\n        );\n    }\n\n    function reinvestReward(ReinvestRewardParams calldata params) \n        external onlyRole(REWARD_REINVESTMENT_ROLE) {\n        Boosted3TokenAuraHelper.reinvestReward(_strategyContext(), params);\n    }\n\n    function convertStrategyToUnderlying(\n        address account,\n        uint256 strategyTokenAmount,\n        uint256 maturity\n    ) public view virtual override returns (int256 underlyingValue) {\n        Boosted3TokenAuraStrategyContext memory context = _strategyContext();\n        underlyingValue = context.convertStrategyToUnderlying(strategyTokenAmount);\n    }\n\n    /// @notice Updates the vault settings\n    /// @param settings vault settings\n    function setStrategyVaultSettings(StrategyVaultSettings calldata settings)\n        external\n        onlyNotionalOwner\n    {\n        BalancerVaultStorage.setStrategyVaultSettings(settings);\n    }\n    \n    function getStrategyContext() external view returns (Boosted3TokenAuraStrategyContext memory) {\n        return _strategyContext();\n    }\n\n    function getSpotPrice(uint8 tokenIndex) external view returns (uint256 spotPrice) {\n        Boosted3TokenAuraStrategyContext memory context = _strategyContext();\n        spotPrice = Boosted3TokenAuraHelper.getSpotPrice(context, tokenIndex);\n    }\n\n    function getEmergencySettlementBPTAmount(uint256 maturity) external view returns (uint256 bptToSettle) {\n        Boosted3TokenAuraStrategyContext memory context = _strategyContext();\n        bptToSettle = context.baseStrategy._getEmergencySettlementParams({\n            maturity: maturity, \n            totalBPTSupply: IERC20(context.poolContext.basePool.basePool.pool).totalSupply()\n        });\n    }\n}"
    }
  ]
}