{
  "Title": "[M-05] Wrong aave usage of `claimRewards`",
  "Content": "_Submitted by jonah1005_\n\nAave yield manager claims rewards with the payment token. According to aave's document, aToken should be provided.\nThe aave rewards would be unclaimable.\n\nYieldManager's logic in [L161-L170](https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/YieldManagerAave.sol#L161-L170)\n\nReference: https://docs.aave.com/developers/guides/liquidity-mining#claimrewards\n\nRecommend changing to\n```solidity\n  address[] memory rewardsDepositedAssets = new address[](1);\n  rewardsDepositedAssets[0] = address(aToken);\n```\n\n**[DenhamPreen (Float) confirmed](https://github.com/code-423n4/2021-08-floatcapital-findings/issues/49#issuecomment-896811177):**\n > Great catch!\n>\n> This contract is going to be upgradable but really applicable within this context ðŸ‘\n\n**[moose-code (Float) commented](https://github.com/code-423n4/2021-08-floatcapital-findings/issues/49#issuecomment-896845365):**\n > Oof yeah! Good one :)\n>\n> Devil in those documentation details :)\n>\n> ![image](https://user-images.githubusercontent.com/20556729/129041188-b712e09a-f735-44d4-922f-328b156e2461.png)\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2021-08-floatcapital",
  "Code": [
    {
      "filename": "contracts/contracts/YieldManagerAave.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"./interfaces/IYieldManager.sol\";\nimport \"./interfaces/aave/ILendingPool.sol\";\nimport \"./interfaces/aave/IAaveIncentivesController.sol\";\n\n/** @title YieldManagerAave\n  @notice contract is used to manage the yield generated by the underlying tokens. \n  YieldManagerAave is an implementation of a yield manager that earns APY from the Aave protocol. \n  Each fund's payment token (such as DAI) has a corresponding aToken (such as aDAI) that \n  continuously accrues interest based on a lend/borrow liquidity ratio.\n  @dev https://docs.aave.com/portal/\n  */\ncontract YieldManagerAave is IYieldManager {\n  /*â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n    â•‘          VARIABLES          â•‘\n    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/\n\n  /// @notice address of longShort contract\n  address public longShort;\n  /// @notice address of treasury contract - this is the address that can claim aave incentives rewards\n  address public treasury;\n\n  /// @notice The payment token the yield manager supports\n  /// @dev DAI token\n  ERC20 public paymentToken;\n  /// @notice The token representing the interest accruing payment token position from Aave\n  /// @dev ADAI token\n  IERC20Upgradeable public aToken;\n  /// @notice The specific Aave lending pool contract\n  ILendingPool public lendingPool;\n  /// @notice The specific Aave incentives controller contract\n  IAaveIncentivesController public aaveIncentivesController;\n\n  /// @dev An aave specific referralCode that has been a depricated feature. This will be set to 0 for \"no referral\" at deployment\n  uint16 referralCode;\n\n  /// @notice distributed yield not yet transferred to the treasury\n  uint256 public override totalReservedForTreasury;\n\n  /// @dev This value will likely remain zero forever. It exists to handle the rare edge case that Aave doesn't have enough liquidity for a withdrawal.\n  ///      In this case this variable would keep track of that so that the withdrawal can happen after the fact when liquidity becomes available.\n  uint256 public amountReservedInCaseOfInsufficientAaveLiquidity;\n\n  /*â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n    â•‘           EVENTS            â•‘\n    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/\n\n  event ClaimAaveRewardTokenToTreasury(uint256 amount);\n\n  /*â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n    â•‘          MODIFIERS          â•‘\n    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/\n\n  /// @dev only allow longShort contract to execute modified functions\n  modifier longShortOnly() {\n    require(msg.sender == longShort, \"Not longShort\");\n    _;\n  }\n\n  /*â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n    â•‘       CONTRACT SET-UP       â•‘\n    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/\n\n  /** \n    @notice Constructor for initializing the aave yield manager with a given payment token and corresponding Aave contracts\n    @param _longShort address of the longShort contract\n    @param _treasury address of the treasury contract\n    @param _paymentToken address of the payment token\n    @param _aToken address of the interest accruing token linked to the payment token\n    @param _lendingPool address of the aave lending pool contract\n    @param _aaveReferralCode unique code for aave referrals\n    @dev referral code will be set to 0, depricated Aave feature\n  */\n  constructor(\n    address _longShort,\n    address _treasury,\n    address _paymentToken,\n    address _aToken,\n    address _lendingPool,\n    address _aaveIncentivesController,\n    uint16 _aaveReferralCode\n  ) {\n    longShort = _longShort;\n    treasury = _treasury;\n\n    referralCode = _aaveReferralCode;\n\n    paymentToken = ERC20(_paymentToken);\n    aToken = IERC20Upgradeable(_aToken);\n    lendingPool = ILendingPool(_lendingPool);\n    aaveIncentivesController = IAaveIncentivesController(_aaveIncentivesController);\n\n    // Approve tokens for aave lending pool maximally.\n    paymentToken.approve(address(lendingPool), type(uint256).max);\n  }\n\n  /*â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n    â•‘     IMPLEMENTATION     â•‘\n    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/\n\n  /** \n   @notice Allows the LongShort contract to deposit tokens into the aave pool\n   @param amount Amount of payment token to deposit\n  */\n  function depositPaymentToken(uint256 amount) external override longShortOnly {\n    // If amountReservedInCaseOfInsufficientAaveLiquidity isn't zero, then efficiently net the difference between the amount\n    //    It basically always be zero besides extreme and unlikely situations with aave.\n    if (amountReservedInCaseOfInsufficientAaveLiquidity != 0) {\n      if (amountReservedInCaseOfInsufficientAaveLiquidity > amount) {\n        amountReservedInCaseOfInsufficientAaveLiquidity -= amount;\n        // Return early, nothing to deposit into the lending pool\n        return;\n      } else {\n        amount -= amountReservedInCaseOfInsufficientAaveLiquidity;\n        amountReservedInCaseOfInsufficientAaveLiquidity = 0;\n      }\n    }\n\n    lendingPool.deposit(address(paymentToken), amount, address(this), referralCode);\n  }\n\n  /// @notice Allows the LongShort pay out a user from tokens already withdrawn from Aave\n  /// @param user User to recieve the payout\n  /// @param amount Amount of payment token to pay to user\n  function transferPaymentTokensToUser(address user, uint256 amount) external override longShortOnly {\n    try paymentToken.transfer(user, amount) returns (bool transferSuccess) {\n      if (transferSuccess) {\n        // If the transfer is successful return early, otherwise try pay the user out with the amountReservedInCaseOfInsufficientAaveLiquidity\n        return;\n      }\n    } catch {}\n\n    amountReservedInCaseOfInsufficientAaveLiquidity -= amount;\n\n    // If this reverts (ie aave unable to make payout), then the whole transaction will revent. User will have to wait until sufficient liquidity available.\n    lendingPool.withdraw(address(paymentToken), amount, user);\n  }\n\n  /// @notice Allows the LongShort contract to redeem aTokens for the payment token\n  /// @param amount Amount of payment token to withdraw\n  /// @dev This will update the amountReservedInCaseOfInsufficientAaveLiquidity if not enough liquidity is avaiable on aave.\n  ///      This means that our system can continue to operate even if there is insufficient liquidity in Aave for any reason.\n  function removePaymentTokenFromMarket(uint256 amount) external override longShortOnly {\n    try lendingPool.withdraw(address(paymentToken), amount, address(this)) {} catch {\n      // In theory we should only catch `VL_CURRENT_AVAILABLE_LIQUIDITY_NOT_ENOUGH` errors.\n      // Safe to revert on all errors, if aave completely blocks withdrawals the amountReservedInCaseOfInsufficientAaveLiquidity can grow until it is fixed without problems.\n      amountReservedInCaseOfInsufficientAaveLiquidity += amount;\n    }\n  }\n\n  /**  \n    @notice Allows for withdrawal of aave rewards to the treasury contract    \n    @dev This is specifically implemented to allow withdrawal of aave reward wMatic tokens accrued    \n  */\n  function claimAaveRewardsToTreasury() external {\n    uint256 amount = IAaveIncentivesController(aaveIncentivesController).getUserUnclaimedRewards(address(this));\n\n    address[] memory rewardsDepositedAssets = new address[](1);\n    rewardsDepositedAssets[0] = address(paymentToken);\n\n    IAaveIncentivesController(aaveIncentivesController).claimRewards(rewardsDepositedAssets, amount, treasury);\n\n    emit ClaimAaveRewardTokenToTreasury(amount);\n  }\n\n  /**    \n    @notice Calculates and updates the yield allocation to the treasury and the market\n    @dev treasuryPercent = 1 - marketPercent\n    @param totalValueRealizedForMarket total value of long and short side of the market\n    @param treasuryYieldPercent_e18 Percentage of yield in base 1e18 that is allocated to the treasury\n    @return The market allocation of the yield\n  */\n  function distributeYieldForTreasuryAndReturnMarketAllocation(\n    uint256 totalValueRealizedForMarket,\n    uint256 treasuryYieldPercent_e18\n  ) external override longShortOnly returns (uint256) {\n    uint256 totalHeld = aToken.balanceOf(address(this));\n\n    uint256 totalRealized = totalValueRealizedForMarket +\n      totalReservedForTreasury +\n      amountReservedInCaseOfInsufficientAaveLiquidity;\n\n    if (totalRealized == totalHeld) {\n      return 0;\n    }\n\n    // will revert in case totalRealized > totalHeld which should be never.\n    uint256 unrealizedYield = totalHeld - totalRealized;\n\n    uint256 amountForTreasury = (unrealizedYield * treasuryYieldPercent_e18) / 1e18;\n    uint256 amountForMarketIncentives = unrealizedYield - amountForTreasury;\n\n    totalReservedForTreasury += amountForTreasury;\n\n    emit YieldDistributed(unrealizedYield, treasuryYieldPercent_e18);\n\n    return amountForMarketIncentives;\n  }\n\n  /// @notice Withdraw treasury allocated accrued yield from the lending pool to the treasury contract\n  function withdrawTreasuryFunds() external override {\n    uint256 amountToWithdrawForTreasury = totalReservedForTreasury;\n    totalReservedForTreasury = 0;\n\n    // Redeem aToken for payment tokens.\n    lendingPool.withdraw(address(paymentToken), amountToWithdrawForTreasury, treasury);\n\n    emit WithdrawTreasuryFunds();\n  }\n}"
    }
  ]
}