{
  "Title": "[M-02] Chainlink Oracles may return stale prices or may be unusable when aggregator `roundId` is less than 50",
  "Content": "\n`WiseLending` calibrates Oracles to get a heartbeat which it uses for checking the staleness of prices returned from the Oracle.\n\nTo calibrate, it fetches between 3-50 inclusive historical prices and picks the second largest update time among those prices. It calls `_getIterationCount()` to know the number of historical prices it'll use. If the current `_latestAggregatorRoundId` is less than 50 (`MAX_ROUND_COUNT`) it uses `_latestAggregatorRoundId` else it uses 50.\n\n[OracleHelper.sol#L665-L667](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseOracleHub/OracleHelper.sol#L665-L667)\n\n            res = _latestAggregatorRoundId < MAX_ROUND_COUNT\n                ? _latestAggregatorRoundId\n                : MAX_ROUND_COUNT;\n\nThe issue with the snippet above is that `_latestAggregatorRoundId` will always be greater than 50 so the number of historical prices it uses will always be 50.\n\nIt's always greater than 50 because it is fetched from the aggregator's proxy contract. The `roundId`s returned from the proxy are a combination of the current aggregator's `roundId` and `phaseId`. Check [Chainlink docs](https://docs.chain.link/data-feeds/historical-data#roundid-in-proxy) for more info. `getLatestRoundId()` returns the `roundId`.\n\n[OracleHelper.sol#L708-L715](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseOracleHub/OracleHelper.sol#L708-L715)\n\n```solidity\n        (\n            roundId\n            ,\n            ,\n            ,\n            ,\n        ) = priceFeed[_tokenAddress].latestRoundData();\n```\n\nThe `roundId` returned is used in the `_recalibratePreview()` function below to get previous `roundIds`. The `iterationCount` as we already mentioned will always be 50.\n\n[OracleHelper.sol#L620C1-L630C15](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseOracleHub/OracleHelper.sol#L620C1-L630C15)\n\n            uint80 i = 1;\n            uint256 currentDiff;\n            uint256 currentBiggest;\n            uint256 currentSecondBiggest;\n\n     ❌      while (i < iterationCount) {\n\n                uint256 currentTimestamp = _getRoundTimestamp(\n                    _tokenAddress,\n     ❌              latestRoundId - i\n                );\n\nThe problem with the above call is that the argument, `latestRoundId-1` above may not have valid data for some rounds. So calls to the Chainlink Oracle for those rounds will revert.\n\nThis may occur because of the way proxy `roundIds` work.\n\nExample:\n\n- If the proxy returns 0x40000000000000010 as `roundId`.\n- The `phaseId` is 4 (`roundId` `>> 64`).\n- The aggregator `roundId` is 16 (uint64(`roundId`)).\n- After 16 iterations in `_recalibratePreview()`, the `latestRoundId` will have a value of `0x40000000000000000`. When the price feed is called, with this `roundId`, it will revert because it does not exist.\n\nCheck [Chainlink docs](https://docs.chain.link/data-feeds/historical-data#roundid-in-proxy) for more info.\n\nThus, if the aggregator `roundId` derived from the proxy `roundId` is less than 50, `_recalibratePreview()` will revert. The caller will have to wait until it is greater than 50.\n\n### Impact\n\n1. For new price feeds, OracleHub won't be able to set a heartbeat until the aggregator `roundId` is greater than 50. So the new price feed would be unusable for that period.\n2. For price feeds that already have a heartbeat, they won't be able to recalibrate during the period the aggregator `roundId` is less than 50. Which may allow the price feed return stale prices.\n\nIn both cases above the max amount of time user can wait for is 50x the official Chainlink heartbeat for the price feed, i.e. `price feed heartbeat * 50`.\n\nFor the BTC/ETH price feed this would be 50 days (`24 hours * 50`).\n\n### Recommended Mitigation Steps\n\nConsider deriving the aggregator `roundId` from the proxy `roundId` and using that instead of the proxy `roundId`.\n\n[OracleHelper.sol#L665-L667](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseOracleHub/OracleHelper.sol#L665-L667)\n\n```solidity\n-       res = _latestAggregatorRoundId < MAX_ROUND_COUNT\n-           ? _latestAggregatorRoundId\n+       res = uint64(_latestAggregatorRoundId) < MAX_ROUND_COUNT\n+           ? uint64(_latestAggregatorRoundId)\n            : MAX_ROUND_COUNT;\n```\n\n**[vonMangoldt (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/276#issuecomment-2009118941):**\n > I don't understand the recommended mitigation steps. Its just typecasting uint64 to a uint80.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/276#issuecomment-2021130680):**\n > Referring to [this](https://docs.chain.link/data-feeds/historical-data#roundid-in-proxy), it is clear the `roundId` needs to be trimmed to uint64. \n\n**[0xStalin (warden) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/276#issuecomment-2024116863):**\n > @Trust - I was checking and came to the realization that the [Chainlink Documentation](https://docs.chain.link/data-feeds/historical-data#historical-rounds) only explains how the proxy queries the `getRoundData` on the Aggregator. \n >\n > However, all this logic is implemented on the Proxy itself, the [`AggregatorProxy.getRoundData()`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.7/dev/AggregatorProxy.sol#L135-L153) is on charge of trimming the `roundId` down to `uint64` before querying the aggregator, but the proxy itself receives the `roundId` as an `uint80`. Thus, [the WiseOracle contract is correctly](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseOracleHub/OracleHelper.sol#L688-L690) integrated with the Chainlink contract. All the required logic to query the data from the aggregator is contained within the chainlink proxy, any contract interacting with the proxy doesn't need to trim the received `roundId`.\n> \n> Based on the Chainlink contracts and the way how WiseOracle queries the `getRoundData()`, I think there is not any issue at all. The integration looks perfectly fine, and there is no need to implement any changes. If the `roundId` were to be trimmed to uint64, it would disrupt the queries and it would be querying a total different values; therefore, this report looks to be invalid.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/276#issuecomment-2024131294):**\n > I believe the root cause of the issue is correct. It is not safe to use `latestRoundId - i` in calculations, as the `latestRoundId` is crafted of a `phaseID` and a uint64 counter. By decreasing by a flat amount, we could find ourselves querying for an incorrect `phaseID`. Essentially, it is a logical overflow not detected because it occurs in internal data of a larger data type (uint80).\n\n**[0xStalin (warden) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/276#issuecomment-2024275828):**\n > I see, then the root cause seems to be correct, but is the recommendation incomplete? If so, what would it be the correct way to mitigate this issue? \n> \n> At this point, I'm not arguing the validity of the report, but rather want to understand what needs to be done to fully mitigate the root cause of this issue.\n\n**[Wise Lending commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/276#issuecomment-2082905287):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-wise-lending",
  "Code": [
    {
      "filename": "contracts/WiseOracleHub/OracleHelper.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./Declarations.sol\";\n\nabstract contract OracleHelper is Declarations {\n\n    /**\n     * @dev Adds priceFeed for a given token.\n     */\n    function _addOracle(\n        address _tokenAddress,\n        IPriceFeed _priceFeedAddress,\n        address[] calldata _underlyingFeedTokens\n    )\n        internal\n    {\n        if (priceFeed[_tokenAddress] > ZERO_FEED) {\n            revert OracleAlreadySet();\n        }\n\n        priceFeed[_tokenAddress] = _priceFeedAddress;\n\n        _tokenDecimals[_tokenAddress] = IERC20(\n            _tokenAddress\n        ).decimals();\n\n        underlyingFeedTokens[_tokenAddress] = _underlyingFeedTokens;\n    }\n\n    function _addAggregator(\n        address _tokenAddress\n    )\n        internal\n    {\n        IAggregator tokenAggregator = IAggregator(\n            priceFeed[_tokenAddress].aggregator()\n        );\n\n        if (tokenAggregatorFromTokenAddress[_tokenAddress] > ZERO_AGGREGATOR) {\n            revert AggregatorAlreadySet();\n        }\n\n        if (_checkFunctionExistence(address(tokenAggregator)) == false) {\n            revert FunctionDoesntExist();\n        }\n\n        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[\n            _tokenAddress\n        ];\n\n        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {\n            revert AggregatorNotNecessary();\n        }\n\n        tokenAggregatorFromTokenAddress[_tokenAddress] = tokenAggregator;\n    }\n\n    function _checkFunctionExistence(\n        address _tokenAggregator\n    )\n        internal\n        returns (bool)\n    {\n        uint256 size;\n\n        assembly {\n            size := extcodesize(\n                _tokenAggregator\n            )\n        }\n\n        if (size == 0) {\n            return false;\n        }\n\n        (bool success, ) = _tokenAggregator.call(\n            abi.encodeWithSignature(\n                \"maxAnswer()\"\n            )\n        );\n\n        return success;\n    }\n\n    function _compareMinMax(\n        IAggregator _tokenAggregator,\n        int192 _answer\n    )\n        internal\n        view\n    {\n        int192 maxAnswer = _tokenAggregator.maxAnswer();\n        int192 minAnswer = _tokenAggregator.minAnswer();\n\n        if (_answer > maxAnswer || _answer < minAnswer) {\n            revert OracleIsDead();\n        }\n    }\n\n    /**\n     * @dev Returns Twaps latest USD value\n     * by passing the underlying token address.\n     */\n    function latestResolverTwap(\n        address _tokenAddress\n    )\n        public\n        view\n        returns (uint256)\n    {\n        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[\n            _tokenAddress\n        ];\n\n        if (uniTwapPoolInfoStruct.isUniPool == true) {\n\n            return _getTwapPrice(\n                _tokenAddress,\n                uniTwapPoolInfoStruct.oracle\n            ) / 10 ** (_decimalsWETH - decimals(_tokenAddress));\n        }\n\n        return _getTwapDerivatePrice(\n            _tokenAddress,\n            uniTwapPoolInfoStruct\n        ) / 10 ** (_decimalsWETH - decimals(_tokenAddress));\n    }\n\n    function _validateAnswer(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[\n            _tokenAddress\n        ];\n\n        uint256 fetchTwapValue;\n\n        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {\n            fetchTwapValue = latestResolverTwap(\n                _tokenAddress\n            );\n        }\n\n        uint256 answer = _getChainlinkAnswer(\n            _tokenAddress\n        );\n\n        if (tokenAggregatorFromTokenAddress[_tokenAddress] > ZERO_AGGREGATOR) {\n            _compareMinMax(\n                tokenAggregatorFromTokenAddress[_tokenAddress],\n                int192(uint192(answer))\n            );\n        }\n\n        if (fetchTwapValue > 0) {\n\n            uint256 relativeDifference = _getRelativeDifference(\n                answer,\n                fetchTwapValue\n            );\n\n            _compareDifference(\n                relativeDifference\n            );\n        }\n\n        return answer;\n    }\n\n    /**\n     * @dev Adds uniTwapPoolInfo for a given token.\n     */\n    function _writeUniTwapPoolInfoStruct(\n        address _tokenAddress,\n        address _oracle,\n        bool _isUniPool\n    )\n        internal\n    {\n        uniTwapPoolInfo[_tokenAddress] = UniTwapPoolInfo({\n            oracle: _oracle,\n            isUniPool: _isUniPool\n        });\n    }\n\n    /**\n     * @dev Adds uniTwapPoolInfo for a given token and its derivative.\n     */\n    function _writeUniTwapPoolInfoStructDerivative(\n        address _tokenAddress,\n        address _partnerTokenAddress,\n        address _oracleAddress,\n        address _partnerOracleAddress,\n        bool _isUniPool\n    )\n        internal\n    {\n        _writeUniTwapPoolInfoStruct(\n            _tokenAddress,\n            _oracleAddress,\n            _isUniPool\n        );\n\n        derivativePartnerTwap[_tokenAddress] = DerivativePartnerInfo(\n            _partnerTokenAddress,\n            _partnerOracleAddress\n        );\n    }\n\n    function _getRelativeDifference(\n        uint256 _answerUint256,\n        uint256 _fetchTwapValue\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        if (_answerUint256 > _fetchTwapValue) {\n            return _answerUint256\n                * PRECISION_FACTOR_E4\n                / _fetchTwapValue;\n        }\n\n        return _fetchTwapValue\n            * PRECISION_FACTOR_E4\n            / _answerUint256;\n    }\n\n    function _compareDifference(\n        uint256 _relativeDifference\n    )\n        internal\n        view\n    {\n        if (_relativeDifference > ALLOWED_DIFFERENCE) {\n            revert OraclesDeviate();\n        }\n    }\n\n    function _getChainlinkAnswer(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        (\n            ,\n            int256 answer,\n            ,\n            ,\n        ) = priceFeed[_tokenAddress].latestRoundData();\n\n        return uint256(\n            answer\n        );\n    }\n\n    function getETHPriceInUSD()\n        public\n        view\n        returns (uint256)\n    {\n        if (_chainLinkIsDead(ETH_USD_PLACEHOLDER) == true) {\n            revert OracleIsDead();\n        }\n\n        return _validateAnswer(\n            ETH_USD_PLACEHOLDER\n        );\n    }\n\n    /**\n    * @dev Retrieves the pool address for given\n    * tokens and fee from Uniswap V3 Factory.\n    */\n    function _getPool(\n        address _token0,\n        address _token1,\n        uint24 _fee\n    )\n        internal\n        view\n        returns (address pool)\n    {\n        return UNI_V3_FACTORY.getPool(\n            _token0,\n            _token1,\n            _fee\n        );\n    }\n\n    /**\n    * @dev Validates if the given token address\n    * is one of the two specified token addresses.\n    */\n    function _validateTokenAddress(\n        address _tokenAddress,\n        address _token0,\n        address _token1\n    )\n        internal\n        pure\n    {\n        if (_tokenAddress == ZERO_ADDRESS) {\n            revert ZeroAddressNotAllowed();\n        }\n\n        if (_tokenAddress != _token0 && _tokenAddress != _token1) {\n            revert TokenAddressMismatch();\n        }\n    }\n\n    /**\n    * @dev Validates if the given pool\n    * address matches the expected pool address.\n    */\n    function _validatePoolAddress(\n        address _pool,\n        address _expectedPool\n    )\n        internal\n        pure\n    {\n        if (_pool == ZERO_ADDRESS) {\n            revert PoolDoesNotExist();\n        }\n\n        if (_pool != _expectedPool) {\n            revert PoolAddressMismatch();\n        }\n    }\n\n    /**\n    * @dev Validates if the price feed for\n    * a given token address is set.\n    */\n    function _validatePriceFeed(\n        address _tokenAddress\n    )\n        internal\n        view\n    {\n        if (priceFeed[_tokenAddress] == ZERO_FEED) {\n            revert ChainLinkOracleNotSet();\n        }\n    }\n\n    /**\n    * @dev Validates if the TWAP oracle for\n    * a given token address is already set.\n    */\n    function _validateTwapOracle(\n        address _tokenAddress\n    )\n        internal\n        view\n    {\n        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {\n            revert TwapOracleAlreadySet();\n        }\n    }\n\n    /**\n     * @dev Returns twapPrice by passing\n     * the underlying token address.\n     */\n    function _getTwapPrice(\n        address _tokenAddress,\n        address _oracle\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return OracleLibrary.getQuoteAtTick(\n            _getAverageTick(\n                _oracle\n            ),\n            _getOneUnit(\n                _tokenAddress\n            ),\n            _tokenAddress,\n            WETH_ADDRESS\n        );\n    }\n\n    function _getOneUnit(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (uint128)\n    {\n        return uint128(\n            10 ** _tokenDecimals[_tokenAddress]\n        );\n    }\n\n    function _getAverageTick(\n        address _oracle\n    )\n        internal\n        view\n        returns (int24)\n    {\n        uint32[] memory secondsAgo = new uint32[](\n            2\n        );\n\n        secondsAgo[0] = TWAP_PERIOD;\n        secondsAgo[1] = 0;\n\n        (\n            int56[] memory tickCumulatives\n            ,\n        ) = IUniswapV3Pool(_oracle).observe(\n            secondsAgo\n        );\n\n        int56 twapPeriodInt56 = int56(\n            int32(TWAP_PERIOD)\n        );\n\n        int56 tickCumulativesDelta = tickCumulatives[1]\n            - tickCumulatives[0];\n\n        int24 tick = int24(\n            tickCumulativesDelta\n            / twapPeriodInt56\n        );\n\n        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % twapPeriodInt56 != 0)) {\n            tick--;\n        }\n\n        return tick;\n    }\n\n    /**\n     * @dev Returns priceFeed decimals by\n     * passing the underlying token address.\n     */\n    function decimals(\n        address _tokenAddress\n    )\n        public\n        view\n        returns (uint8)\n    {\n        return priceFeed[_tokenAddress].decimals();\n    }\n\n    function _getTwapDerivatePrice(\n        address _tokenAddress,\n        UniTwapPoolInfo memory _uniTwapPoolInfo\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        DerivativePartnerInfo memory partnerInfo = derivativePartnerTwap[\n            _tokenAddress\n        ];\n\n        uint256 firstQuote = OracleLibrary.getQuoteAtTick(\n            _getAverageTick(\n                _uniTwapPoolInfo.oracle\n            ),\n            _getOneUnit(\n                partnerInfo.partnerTokenAddress\n            ),\n            partnerInfo.partnerTokenAddress,\n            WETH_ADDRESS\n        );\n\n        uint256 secondQuote = OracleLibrary.getQuoteAtTick(\n            _getAverageTick(\n                partnerInfo.partnerOracleAddress\n            ),\n            _getOneUnit(\n                _tokenAddress\n            ),\n            _tokenAddress,\n            partnerInfo.partnerTokenAddress\n        );\n\n        return firstQuote\n            * secondQuote\n            / uint256(\n                _getOneUnit(\n                    partnerInfo.partnerTokenAddress\n                )\n            );\n    }\n\n    /**\n     * @dev Stores expected heartbeat\n     * value for a pricing feed token.\n     */\n    function _recalibrate(\n        address _tokenAddress\n    )\n        internal\n    {\n        heartBeat[_tokenAddress] = _recalibratePreview(\n            _tokenAddress\n        );\n    }\n\n    /**\n     * @dev Check if chainLink\n     * squencer is wroking.\n     */\n    function sequencerIsDead()\n        public\n        view\n        returns (bool)\n    {\n        if (IS_ARBITRUM_CHAIN == false) {\n            return false;\n        }\n\n        (\n            ,\n            int256 answer,\n            uint256 startedAt,\n            ,\n        ) = SEQUENCER.latestRoundData();\n\n        if (answer == 1) {\n            return true;\n        }\n\n        uint256 timeSinceUp = block.timestamp\n            - startedAt;\n\n        if (timeSinceUp <= GRACE_PEROID) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @dev Check if chainLink feed was\n     * updated within expected timeFrame\n     * for single {_tokenAddress}.\n     */\n    function _chainLinkIsDead(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (bool)\n    {\n        // @TODO: Add a check for TWAP comparison on 2.5%\n        // if TWAP exists for the token.\n\n        if (heartBeat[_tokenAddress] == 0) {\n            revert HeartBeatNotSet();\n        }\n\n        uint80 latestRoundId = getLatestRoundId(\n            _tokenAddress\n        );\n\n        uint256 upd = _getRoundTimestamp(\n            _tokenAddress,\n            latestRoundId\n        );\n\n        unchecked {\n            upd = block.timestamp < upd\n                ? block.timestamp\n                : block.timestamp - upd;\n\n            return upd > heartBeat[_tokenAddress];\n        }\n    }\n\n    /**\n     * @dev Recalibrates expected\n     * heartbeat for a pricing feed.\n     */\n    function _recalibratePreview(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint80 latestRoundId = getLatestRoundId(\n            _tokenAddress\n        );\n\n        uint256 latestTimestamp = _getRoundTimestamp(\n            _tokenAddress,\n            latestRoundId\n        );\n\n        uint80 iterationCount = _getIterationCount(\n            latestRoundId\n        );\n\n        if (iterationCount < MIN_ITERATION_COUNT) {\n            revert SampleTooSmall(\n                {\n                    size: iterationCount\n                }\n            );\n        }\n\n        uint80 i = 1;\n        uint256 currentDiff;\n        uint256 currentBiggest;\n        uint256 currentSecondBiggest;\n\n        while (i < iterationCount) {\n\n            uint256 currentTimestamp = _getRoundTimestamp(\n                _tokenAddress,\n                latestRoundId - i\n            );\n\n            currentDiff = latestTimestamp\n                - currentTimestamp;\n\n            latestTimestamp = currentTimestamp;\n\n            if (currentDiff >= currentBiggest) {\n\n                currentSecondBiggest = currentBiggest;\n                currentBiggest = currentDiff;\n\n            } else if (currentDiff > currentSecondBiggest) {\n                currentSecondBiggest = currentDiff;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return currentSecondBiggest;\n    }\n\n    /**\n     * @dev Determines number of iterations\n     * needed during heartbeat recalibration.\n     */\n    function _getIterationCount(\n        uint80 _latestAggregatorRoundId\n    )\n        internal\n        pure\n        returns (uint80 res)\n    {\n        res = _latestAggregatorRoundId < MAX_ROUND_COUNT\n            ? _latestAggregatorRoundId\n            : MAX_ROUND_COUNT;\n    }\n\n    /**\n     * @dev Fetches timestamp of a byteshifted\n     * aggregatorRound with specific _roundId.\n     */\n    function _getRoundTimestamp(\n        address _tokenAddress,\n        uint80 _roundId\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        (\n            ,\n            ,\n            ,\n            uint256 timestamp\n            ,\n        ) = priceFeed[_tokenAddress].getRoundData(\n                _roundId\n            );\n\n        return timestamp;\n    }\n\n    /**\n     * @dev Routing latest round data from chainLink.\n     * Returns latestRoundData by passing underlying token address.\n     */\n    function getLatestRoundId(\n        address _tokenAddress\n    )\n        public\n        view\n        returns (\n            uint80 roundId\n        )\n    {\n        (\n            roundId\n            ,\n            ,\n            ,\n            ,\n        ) = priceFeed[_tokenAddress].latestRoundData();\n    }\n}"
    },
    {
      "filename": "contracts/WiseOracleHub/OracleHelper.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./Declarations.sol\";\n\nabstract contract OracleHelper is Declarations {\n\n    /**\n     * @dev Adds priceFeed for a given token.\n     */\n    function _addOracle(\n        address _tokenAddress,\n        IPriceFeed _priceFeedAddress,\n        address[] calldata _underlyingFeedTokens\n    )\n        internal\n    {\n        if (priceFeed[_tokenAddress] > ZERO_FEED) {\n            revert OracleAlreadySet();\n        }\n\n        priceFeed[_tokenAddress] = _priceFeedAddress;\n\n        _tokenDecimals[_tokenAddress] = IERC20(\n            _tokenAddress\n        ).decimals();\n\n        underlyingFeedTokens[_tokenAddress] = _underlyingFeedTokens;\n    }\n\n    function _addAggregator(\n        address _tokenAddress\n    )\n        internal\n    {\n        IAggregator tokenAggregator = IAggregator(\n            priceFeed[_tokenAddress].aggregator()\n        );\n\n        if (tokenAggregatorFromTokenAddress[_tokenAddress] > ZERO_AGGREGATOR) {\n            revert AggregatorAlreadySet();\n        }\n\n        if (_checkFunctionExistence(address(tokenAggregator)) == false) {\n            revert FunctionDoesntExist();\n        }\n\n        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[\n            _tokenAddress\n        ];\n\n        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {\n            revert AggregatorNotNecessary();\n        }\n\n        tokenAggregatorFromTokenAddress[_tokenAddress] = tokenAggregator;\n    }\n\n    function _checkFunctionExistence(\n        address _tokenAggregator\n    )\n        internal\n        returns (bool)\n    {\n        uint256 size;\n\n        assembly {\n            size := extcodesize(\n                _tokenAggregator\n            )\n        }\n\n        if (size == 0) {\n            return false;\n        }\n\n        (bool success, ) = _tokenAggregator.call(\n            abi.encodeWithSignature(\n                \"maxAnswer()\"\n            )\n        );\n\n        return success;\n    }\n\n    function _compareMinMax(\n        IAggregator _tokenAggregator,\n        int192 _answer\n    )\n        internal\n        view\n    {\n        int192 maxAnswer = _tokenAggregator.maxAnswer();\n        int192 minAnswer = _tokenAggregator.minAnswer();\n\n        if (_answer > maxAnswer || _answer < minAnswer) {\n            revert OracleIsDead();\n        }\n    }\n\n    /**\n     * @dev Returns Twaps latest USD value\n     * by passing the underlying token address.\n     */\n    function latestResolverTwap(\n        address _tokenAddress\n    )\n        public\n        view\n        returns (uint256)\n    {\n        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[\n            _tokenAddress\n        ];\n\n        if (uniTwapPoolInfoStruct.isUniPool == true) {\n\n            return _getTwapPrice(\n                _tokenAddress,\n                uniTwapPoolInfoStruct.oracle\n            ) / 10 ** (_decimalsWETH - decimals(_tokenAddress));\n        }\n\n        return _getTwapDerivatePrice(\n            _tokenAddress,\n            uniTwapPoolInfoStruct\n        ) / 10 ** (_decimalsWETH - decimals(_tokenAddress));\n    }\n\n    function _validateAnswer(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[\n            _tokenAddress\n        ];\n\n        uint256 fetchTwapValue;\n\n        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {\n            fetchTwapValue = latestResolverTwap(\n                _tokenAddress\n            );\n        }\n\n        uint256 answer = _getChainlinkAnswer(\n            _tokenAddress\n        );\n\n        if (tokenAggregatorFromTokenAddress[_tokenAddress] > ZERO_AGGREGATOR) {\n            _compareMinMax(\n                tokenAggregatorFromTokenAddress[_tokenAddress],\n                int192(uint192(answer))\n            );\n        }\n\n        if (fetchTwapValue > 0) {\n\n            uint256 relativeDifference = _getRelativeDifference(\n                answer,\n                fetchTwapValue\n            );\n\n            _compareDifference(\n                relativeDifference\n            );\n        }\n\n        return answer;\n    }\n\n    /**\n     * @dev Adds uniTwapPoolInfo for a given token.\n     */\n    function _writeUniTwapPoolInfoStruct(\n        address _tokenAddress,\n        address _oracle,\n        bool _isUniPool\n    )\n        internal\n    {\n        uniTwapPoolInfo[_tokenAddress] = UniTwapPoolInfo({\n            oracle: _oracle,\n            isUniPool: _isUniPool\n        });\n    }\n\n    /**\n     * @dev Adds uniTwapPoolInfo for a given token and its derivative.\n     */\n    function _writeUniTwapPoolInfoStructDerivative(\n        address _tokenAddress,\n        address _partnerTokenAddress,\n        address _oracleAddress,\n        address _partnerOracleAddress,\n        bool _isUniPool\n    )\n        internal\n    {\n        _writeUniTwapPoolInfoStruct(\n            _tokenAddress,\n            _oracleAddress,\n            _isUniPool\n        );\n\n        derivativePartnerTwap[_tokenAddress] = DerivativePartnerInfo(\n            _partnerTokenAddress,\n            _partnerOracleAddress\n        );\n    }\n\n    function _getRelativeDifference(\n        uint256 _answerUint256,\n        uint256 _fetchTwapValue\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        if (_answerUint256 > _fetchTwapValue) {\n            return _answerUint256\n                * PRECISION_FACTOR_E4\n                / _fetchTwapValue;\n        }\n\n        return _fetchTwapValue\n            * PRECISION_FACTOR_E4\n            / _answerUint256;\n    }\n\n    function _compareDifference(\n        uint256 _relativeDifference\n    )\n        internal\n        view\n    {\n        if (_relativeDifference > ALLOWED_DIFFERENCE) {\n            revert OraclesDeviate();\n        }\n    }\n\n    function _getChainlinkAnswer(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        (\n            ,\n            int256 answer,\n            ,\n            ,\n        ) = priceFeed[_tokenAddress].latestRoundData();\n\n        return uint256(\n            answer\n        );\n    }\n\n    function getETHPriceInUSD()\n        public\n        view\n        returns (uint256)\n    {\n        if (_chainLinkIsDead(ETH_USD_PLACEHOLDER) == true) {\n            revert OracleIsDead();\n        }\n\n        return _validateAnswer(\n            ETH_USD_PLACEHOLDER\n        );\n    }\n\n    /**\n    * @dev Retrieves the pool address for given\n    * tokens and fee from Uniswap V3 Factory.\n    */\n    function _getPool(\n        address _token0,\n        address _token1,\n        uint24 _fee\n    )\n        internal\n        view\n        returns (address pool)\n    {\n        return UNI_V3_FACTORY.getPool(\n            _token0,\n            _token1,\n            _fee\n        );\n    }\n\n    /**\n    * @dev Validates if the given token address\n    * is one of the two specified token addresses.\n    */\n    function _validateTokenAddress(\n        address _tokenAddress,\n        address _token0,\n        address _token1\n    )\n        internal\n        pure\n    {\n        if (_tokenAddress == ZERO_ADDRESS) {\n            revert ZeroAddressNotAllowed();\n        }\n\n        if (_tokenAddress != _token0 && _tokenAddress != _token1) {\n            revert TokenAddressMismatch();\n        }\n    }\n\n    /**\n    * @dev Validates if the given pool\n    * address matches the expected pool address.\n    */\n    function _validatePoolAddress(\n        address _pool,\n        address _expectedPool\n    )\n        internal\n        pure\n    {\n        if (_pool == ZERO_ADDRESS) {\n            revert PoolDoesNotExist();\n        }\n\n        if (_pool != _expectedPool) {\n            revert PoolAddressMismatch();\n        }\n    }\n\n    /**\n    * @dev Validates if the price feed for\n    * a given token address is set.\n    */\n    function _validatePriceFeed(\n        address _tokenAddress\n    )\n        internal\n        view\n    {\n        if (priceFeed[_tokenAddress] == ZERO_FEED) {\n            revert ChainLinkOracleNotSet();\n        }\n    }\n\n    /**\n    * @dev Validates if the TWAP oracle for\n    * a given token address is already set.\n    */\n    function _validateTwapOracle(\n        address _tokenAddress\n    )\n        internal\n        view\n    {\n        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {\n            revert TwapOracleAlreadySet();\n        }\n    }\n\n    /**\n     * @dev Returns twapPrice by passing\n     * the underlying token address.\n     */\n    function _getTwapPrice(\n        address _tokenAddress,\n        address _oracle\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return OracleLibrary.getQuoteAtTick(\n            _getAverageTick(\n                _oracle\n            ),\n            _getOneUnit(\n                _tokenAddress\n            ),\n            _tokenAddress,\n            WETH_ADDRESS\n        );\n    }\n\n    function _getOneUnit(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (uint128)\n    {\n        return uint128(\n            10 ** _tokenDecimals[_tokenAddress]\n        );\n    }\n\n    function _getAverageTick(\n        address _oracle\n    )\n        internal\n        view\n        returns (int24)\n    {\n        uint32[] memory secondsAgo = new uint32[](\n            2\n        );\n\n        secondsAgo[0] = TWAP_PERIOD;\n        secondsAgo[1] = 0;\n\n        (\n            int56[] memory tickCumulatives\n            ,\n        ) = IUniswapV3Pool(_oracle).observe(\n            secondsAgo\n        );\n\n        int56 twapPeriodInt56 = int56(\n            int32(TWAP_PERIOD)\n        );\n\n        int56 tickCumulativesDelta = tickCumulatives[1]\n            - tickCumulatives[0];\n\n        int24 tick = int24(\n            tickCumulativesDelta\n            / twapPeriodInt56\n        );\n\n        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % twapPeriodInt56 != 0)) {\n            tick--;\n        }\n\n        return tick;\n    }\n\n    /**\n     * @dev Returns priceFeed decimals by\n     * passing the underlying token address.\n     */\n    function decimals(\n        address _tokenAddress\n    )\n        public\n        view\n        returns (uint8)\n    {\n        return priceFeed[_tokenAddress].decimals();\n    }\n\n    function _getTwapDerivatePrice(\n        address _tokenAddress,\n        UniTwapPoolInfo memory _uniTwapPoolInfo\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        DerivativePartnerInfo memory partnerInfo = derivativePartnerTwap[\n            _tokenAddress\n        ];\n\n        uint256 firstQuote = OracleLibrary.getQuoteAtTick(\n            _getAverageTick(\n                _uniTwapPoolInfo.oracle\n            ),\n            _getOneUnit(\n                partnerInfo.partnerTokenAddress\n            ),\n            partnerInfo.partnerTokenAddress,\n            WETH_ADDRESS\n        );\n\n        uint256 secondQuote = OracleLibrary.getQuoteAtTick(\n            _getAverageTick(\n                partnerInfo.partnerOracleAddress\n            ),\n            _getOneUnit(\n                _tokenAddress\n            ),\n            _tokenAddress,\n            partnerInfo.partnerTokenAddress\n        );\n\n        return firstQuote\n            * secondQuote\n            / uint256(\n                _getOneUnit(\n                    partnerInfo.partnerTokenAddress\n                )\n            );\n    }\n\n    /**\n     * @dev Stores expected heartbeat\n     * value for a pricing feed token.\n     */\n    function _recalibrate(\n        address _tokenAddress\n    )\n        internal\n    {\n        heartBeat[_tokenAddress] = _recalibratePreview(\n            _tokenAddress\n        );\n    }\n\n    /**\n     * @dev Check if chainLink\n     * squencer is wroking.\n     */\n    function sequencerIsDead()\n        public\n        view\n        returns (bool)\n    {\n        if (IS_ARBITRUM_CHAIN == false) {\n            return false;\n        }\n\n        (\n            ,\n            int256 answer,\n            uint256 startedAt,\n            ,\n        ) = SEQUENCER.latestRoundData();\n\n        if (answer == 1) {\n            return true;\n        }\n\n        uint256 timeSinceUp = block.timestamp\n            - startedAt;\n\n        if (timeSinceUp <= GRACE_PEROID) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @dev Check if chainLink feed was\n     * updated within expected timeFrame\n     * for single {_tokenAddress}.\n     */\n    function _chainLinkIsDead(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (bool)\n    {\n        // @TODO: Add a check for TWAP comparison on 2.5%\n        // if TWAP exists for the token.\n\n        if (heartBeat[_tokenAddress] == 0) {\n            revert HeartBeatNotSet();\n        }\n\n        uint80 latestRoundId = getLatestRoundId(\n            _tokenAddress\n        );\n\n        uint256 upd = _getRoundTimestamp(\n            _tokenAddress,\n            latestRoundId\n        );\n\n        unchecked {\n            upd = block.timestamp < upd\n                ? block.timestamp\n                : block.timestamp - upd;\n\n            return upd > heartBeat[_tokenAddress];\n        }\n    }\n\n    /**\n     * @dev Recalibrates expected\n     * heartbeat for a pricing feed.\n     */\n    function _recalibratePreview(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint80 latestRoundId = getLatestRoundId(\n            _tokenAddress\n        );\n\n        uint256 latestTimestamp = _getRoundTimestamp(\n            _tokenAddress,\n            latestRoundId\n        );\n\n        uint80 iterationCount = _getIterationCount(\n            latestRoundId\n        );\n\n        if (iterationCount < MIN_ITERATION_COUNT) {\n            revert SampleTooSmall(\n                {\n                    size: iterationCount\n                }\n            );\n        }\n\n        uint80 i = 1;\n        uint256 currentDiff;\n        uint256 currentBiggest;\n        uint256 currentSecondBiggest;\n\n        while (i < iterationCount) {\n\n            uint256 currentTimestamp = _getRoundTimestamp(\n                _tokenAddress,\n                latestRoundId - i\n            );\n\n            currentDiff = latestTimestamp\n                - currentTimestamp;\n\n            latestTimestamp = currentTimestamp;\n\n            if (currentDiff >= currentBiggest) {\n\n                currentSecondBiggest = currentBiggest;\n                currentBiggest = currentDiff;\n\n            } else if (currentDiff > currentSecondBiggest) {\n                currentSecondBiggest = currentDiff;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return currentSecondBiggest;\n    }\n\n    /**\n     * @dev Determines number of iterations\n     * needed during heartbeat recalibration.\n     */\n    function _getIterationCount(\n        uint80 _latestAggregatorRoundId\n    )\n        internal\n        pure\n        returns (uint80 res)\n    {\n        res = _latestAggregatorRoundId < MAX_ROUND_COUNT\n            ? _latestAggregatorRoundId\n            : MAX_ROUND_COUNT;\n    }\n\n    /**\n     * @dev Fetches timestamp of a byteshifted\n     * aggregatorRound with specific _roundId.\n     */\n    function _getRoundTimestamp(\n        address _tokenAddress,\n        uint80 _roundId\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        (\n            ,\n            ,\n            ,\n            uint256 timestamp\n            ,\n        ) = priceFeed[_tokenAddress].getRoundData(\n                _roundId\n            );\n\n        return timestamp;\n    }\n\n    /**\n     * @dev Routing latest round data from chainLink.\n     * Returns latestRoundData by passing underlying token address.\n     */\n    function getLatestRoundId(\n        address _tokenAddress\n    )\n        public\n        view\n        returns (\n            uint80 roundId\n        )\n    {\n        (\n            roundId\n            ,\n            ,\n            ,\n            ,\n        ) = priceFeed[_tokenAddress].latestRoundData();\n    }\n}"
    },
    {
      "filename": "contracts/WiseOracleHub/OracleHelper.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./Declarations.sol\";\n\nabstract contract OracleHelper is Declarations {\n\n    /**\n     * @dev Adds priceFeed for a given token.\n     */\n    function _addOracle(\n        address _tokenAddress,\n        IPriceFeed _priceFeedAddress,\n        address[] calldata _underlyingFeedTokens\n    )\n        internal\n    {\n        if (priceFeed[_tokenAddress] > ZERO_FEED) {\n            revert OracleAlreadySet();\n        }\n\n        priceFeed[_tokenAddress] = _priceFeedAddress;\n\n        _tokenDecimals[_tokenAddress] = IERC20(\n            _tokenAddress\n        ).decimals();\n\n        underlyingFeedTokens[_tokenAddress] = _underlyingFeedTokens;\n    }\n\n    function _addAggregator(\n        address _tokenAddress\n    )\n        internal\n    {\n        IAggregator tokenAggregator = IAggregator(\n            priceFeed[_tokenAddress].aggregato"
    }
  ]
}