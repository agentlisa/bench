{
  "Title": "[L-06] `zroPaymentAddress` should not be hardcoded to `address(0)`",
  "Content": "The [LayerZero integration checklist](https://layerzero.gitbook.io/docs/troubleshooting/layerzero-integration-checklist) says:\n\n> \"Do not hardcode address zero (`address(0)`) as `zroPaymentAddress` when estimating fees and sending messages. Pass it as a parameter instead.\"\n\nBut in [`MagnetarMarketModule.sol`](https://github.com/Tapioca-DAO/tapioca-periph/blob/d6cdac0d09c817f7b5c67e97f73defbae6c4aa01/contracts/Magnetar/modules/MagnetarMarketModule.sol#L801), `zroPaymentAddress` is hardcoded to `address(0)`:\n\n```solidity\n        // build LZ params\n        bytes memory _adapterParams;\n        ICommonOFT.LzCallParams memory callParams = ICommonOFT.LzCallParams({\n            refundAddress: msg.value == gas ? refundAddress : payable(this),\nâŒ          zroPaymentAddress: address(0), //@audit should not be hardcoded\n            adapterParams: ISendFrom(address(asset)).useCustomAdapterParams()\n                ? adapterParams\n                : _adapterParams\n        });\n```\n\nRemove the hardcoded `address(0)` and pass it as a parameter instead.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Magnetar/modules/MagnetarMarketModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n//LZ\nimport \"tapioca-sdk/dist/contracts/libraries/LzLib.sol\";\nimport {ICommonOFT} from \"tapioca-sdk/dist/contracts/token/oft/v2/ICommonOFT.sol\";\n\n//OZ\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\n//TAPIOCA\nimport \"../../interfaces/IYieldBoxBase.sol\";\nimport \"../../interfaces/ITapiocaOptions.sol\";\n\nimport \"../MagnetarV2Storage.sol\";\n\ncontract MagnetarMarketModule is Ownable, MagnetarV2Storage {\n    using SafeERC20 for IERC20;\n    using RebaseLibrary for Rebase;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error NotValid();\n    error tOLPTokenMismatch();\n    error LockTargetMismatch();\n    error Failed();\n\n    function withdrawToChain(\n        IYieldBoxBase yieldBox,\n        address from,\n        uint256 assetId,\n        uint16 dstChainId,\n        bytes32 receiver,\n        uint256 amount,\n        bytes memory adapterParams,\n        address payable refundAddress,\n        uint256 gas,\n        bool unwrap\n    ) external payable {\n        _withdrawToChain(\n            yieldBox,\n            from,\n            assetId,\n            dstChainId,\n            receiver,\n            amount,\n            adapterParams,\n            refundAddress,\n            gas,\n            unwrap\n        );\n    }\n\n    function depositAddCollateralAndBorrowFromMarket(\n        IMarket market,\n        address user,\n        uint256 collateralAmount,\n        uint256 borrowAmount,\n        bool extractFromSender,\n        bool deposit,\n        ICommonData.IWithdrawParams calldata withdrawParams,\n        uint256 valueAmount\n    ) external payable {\n        _depositAddCollateralAndBorrowFromMarket(\n            market,\n            user,\n            collateralAmount,\n            borrowAmount,\n            extractFromSender,\n            deposit,\n            withdrawParams,\n            valueAmount\n        );\n    }\n\n    function depositRepayAndRemoveCollateralFromMarket(\n        address market,\n        address user,\n        uint256 depositAmount,\n        uint256 repayAmount,\n        uint256 collateralAmount,\n        bool extractFromSender,\n        ICommonData.IWithdrawParams calldata withdrawCollateralParams,\n        uint256 valueAmount\n    ) external payable {\n        _depositRepayAndRemoveCollateralFromMarket(\n            market,\n            user,\n            depositAmount,\n            repayAmount,\n            collateralAmount,\n            extractFromSender,\n            withdrawCollateralParams,\n            valueAmount\n        );\n    }\n\n    function mintFromBBAndLendOnSGL(\n        address user,\n        uint256 lendAmount,\n        IUSDOBase.IMintData calldata mintData,\n        ICommonData.IDepositData calldata depositData,\n        ITapiocaOptionLiquidityProvision.IOptionsLockData calldata lockData,\n        ITapiocaOptionsBroker.IOptionsParticipateData calldata participateData,\n        ICommonData.ICommonExternalContracts calldata externalContracts,\n        ICluster _cluster\n    ) external payable {\n        _mintFromBBAndLendOnSGL(\n            user,\n            lendAmount,\n            mintData,\n            depositData,\n            lockData,\n            participateData,\n            externalContracts,\n            _cluster\n        );\n    }\n\n    function exitPositionAndRemoveCollateral(\n        address user,\n        ICommonData.ICommonExternalContracts calldata externalData,\n        IUSDOBase.IRemoveAndRepay calldata removeAndRepayData,\n        uint256 valueAmount,\n        ICluster _cluster\n    ) external payable {\n        _exitPositionAndRemoveCollateral(\n            user,\n            externalData,\n            removeAndRepayData,\n            valueAmount,\n            _cluster\n        );\n    }\n\n    // *********************** //\n    // *** PRIVATE METHODS *** //\n    // *********************** //\n    function _depositAddCollateralAndBorrowFromMarket(\n        IMarket market,\n        address user,\n        uint256 collateralAmount,\n        uint256 borrowAmount,\n        bool extractFromSender,\n        bool deposit,\n        ICommonData.IWithdrawParams calldata withdrawParams,\n        uint256 valueAmount\n    ) private {\n        IYieldBoxBase yieldBox = IYieldBoxBase(market.yieldBox());\n\n        uint256 collateralId = market.collateralId();\n        (, address collateralAddress, , ) = yieldBox.assets(collateralId);\n\n        uint256 _share = yieldBox.toShare(\n            collateralId,\n            collateralAmount,\n            false\n        );\n        //deposit to YieldBox\n        if (deposit) {\n            // transfers tokens from sender or from the user to this contract\n            collateralAmount = _extractTokens(\n                extractFromSender ? msg.sender : user,\n                collateralAddress,\n                collateralAmount\n            );\n            _share = yieldBox.toShare(collateralId, collateralAmount, false);\n\n            // deposit to YieldBox\n            IERC20(collateralAddress).approve(address(yieldBox), 0);\n            IERC20(collateralAddress).approve(\n                address(yieldBox),\n                collateralAmount\n            );\n            yieldBox.depositAsset(\n                collateralId,\n                address(this),\n                address(this),\n                collateralAmount,\n                0\n            );\n        }\n\n        // performs .addCollateral on market\n        if (collateralAmount > 0) {\n            _setApprovalForYieldBox(address(market), yieldBox);\n            market.addCollateral(\n                deposit ? address(this) : user,\n                user,\n                false,\n                collateralAmount,\n                _share\n            );\n        }\n\n        // performs .borrow on market\n        // if `withdraw` it uses `withdrawTo` to withdraw assets on the same chain or to another one\n        if (borrowAmount > 0) {\n            address borrowReceiver = withdrawParams.withdraw\n                ? address(this)\n                : user;\n            market.borrow(user, borrowReceiver, borrowAmount);\n\n            if (withdrawParams.withdraw) {\n                bytes memory withdrawAssetBytes = abi.encode(\n                    withdrawParams.withdrawOnOtherChain,\n                    withdrawParams.withdrawLzChainId,\n                    LzLib.addressToBytes32(user),\n                    withdrawParams.withdrawAdapterParams\n                );\n                _withdraw(\n                    borrowReceiver,\n                    withdrawAssetBytes,\n                    market,\n                    yieldBox,\n                    borrowAmount,\n                    false,\n                    valueAmount,\n                    false\n                );\n            }\n        }\n\n        _revertYieldBoxApproval(address(market), yieldBox);\n    }\n\n    function _depositRepayAndRemoveCollateralFromMarket(\n        address market,\n        address user,\n        uint256 depositAmount,\n        uint256 repayAmount,\n        uint256 collateralAmount,\n        bool extractFromSender,\n        ICommonData.IWithdrawParams calldata withdrawCollateralParams,\n        uint256 valueAmount\n    ) private {\n        IMarket marketInterface = IMarket(market);\n        IYieldBoxBase yieldBox = IYieldBoxBase(marketInterface.yieldBox());\n\n        uint256 assetId = marketInterface.assetId();\n        (, address assetAddress, , ) = yieldBox.assets(assetId);\n\n        // deposit to YieldBox\n        if (depositAmount > 0) {\n            depositAmount = _extractTokens(\n                extractFromSender ? msg.sender : user,\n                assetAddress,\n                depositAmount\n            );\n            IERC20(assetAddress).approve(address(yieldBox), 0);\n            IERC20(assetAddress).approve(address(yieldBox), depositAmount);\n            yieldBox.depositAsset(\n                assetId,\n                address(this),\n                address(this),\n                depositAmount,\n                0\n            );\n        }\n\n        // performs a repay operation for the specified market\n        if (repayAmount > 0) {\n            _setApprovalForYieldBox(market, yieldBox);\n            marketInterface.repay(\n                depositAmount > 0 ? address(this) : user,\n                user,\n                false,\n                repayAmount\n            );\n            _revertYieldBoxApproval(market, yieldBox);\n        }\n\n        // performs a removeCollateral operation on the market\n        // if `withdrawCollateralParams.withdraw` it uses `withdrawTo` to withdraw collateral on the same chain or to another one\n        if (collateralAmount > 0) {\n            address collateralWithdrawReceiver = withdrawCollateralParams\n                .withdraw\n                ? address(this)\n                : user;\n            uint256 collateralShare = yieldBox.toShare(\n                marketInterface.collateralId(),\n                collateralAmount,\n                false\n            );\n            marketInterface.removeCollateral(\n                user,\n                collateralWithdrawReceiver,\n                collateralShare\n            );\n\n            //withdraw\n            if (withdrawCollateralParams.withdraw) {\n                _withdrawToChain(\n                    yieldBox,\n                    collateralWithdrawReceiver,\n                    marketInterface.collateralId(),\n                    withdrawCollateralParams.withdrawLzChainId,\n                    LzLib.addressToBytes32(user),\n                    collateralAmount,\n                    withdrawCollateralParams.withdrawAdapterParams,\n                    valueAmount > 0 ? payable(msg.sender) : payable(this),\n                    valueAmount,\n                    withdrawCollateralParams.unwrap\n                );\n            }\n        }\n    }\n\n    function _mintFromBBAndLendOnSGL(\n        address user,\n        uint256 lendAmount,\n        IUSDOBase.IMintData memory mintData,\n        ICommonData.IDepositData memory depositData,\n        ITapiocaOptionLiquidityProvision.IOptionsLockData calldata lockData,\n        ITapiocaOptionsBroker.IOptionsParticipateData calldata participateData,\n        ICommonData.ICommonExternalContracts calldata externalContracts,\n        ICluster _cluster\n    ) private {\n        IMarket bigBang = IMarket(externalContracts.bigBang);\n        ISingularity singularity = ISingularity(externalContracts.singularity);\n        IYieldBoxBase yieldBox = IYieldBoxBase(singularity.yieldBox());\n\n        if (externalContracts.bigBang != address(0)) {\n            if (\n                !_cluster.isWhitelisted(\n                    _cluster.lzChainId(),\n                    externalContracts.bigBang\n                )\n            ) revert NotAuthorized();\n        }\n        if (externalContracts.singularity != address(0)) {\n            if (\n                !_cluster.isWhitelisted(\n                    _cluster.lzChainId(),\n                    externalContracts.singularity\n                )\n            ) revert NotAuthorized();\n        }\n\n        if (address(singularity) != address(0)) {\n            _setApprovalForYieldBox(address(singularity), yieldBox);\n        }\n        if (address(bigBang) != address(0)) {\n            _setApprovalForYieldBox(address(bigBang), yieldBox);\n        }\n\n        // if `mint` was requested the following actions are performed:\n        //  - extracts & deposits collateral to YB\n        //  - performs bigBang.addCollateral\n        //  - performs bigBang.borrow\n        if (mintData.mint) {\n            uint256 bbCollateralId = bigBang.collateralId();\n            (, address bbCollateralAddress, , ) = yieldBox.assets(\n                bbCollateralId\n            );\n            uint256 bbCollateralShare = yieldBox.toShare(\n                bbCollateralId,\n                mintData.collateralDepositData.amount,\n                false\n            );\n            // deposit collateral to YB\n            if (mintData.collateralDepositData.deposit) {\n                mintData.collateralDepositData.amount = _extractTokens(\n                    mintData.collateralDepositData.extractFromSender\n                        ? msg.sender\n                        : user,\n                    bbCollateralAddress,\n                    mintData.collateralDepositData.amount\n                );\n                bbCollateralShare = yieldBox.toShare(\n                    bbCollateralId,\n                    mintData.collateralDepositData.amount,\n                    false\n                );\n\n                IERC20(bbCollateralAddress).approve(address(yieldBox), 0);\n                IERC20(bbCollateralAddress).approve(\n                    address(yieldBox),\n                    mintData.collateralDepositData.amount\n                );\n                yieldBox.depositAsset(\n                    bbCollateralId,\n                    address(this),\n                    address(this),\n                    mintData.collateralDepositData.amount,\n                    0\n                );\n            }\n\n            // add collateral to BB\n            if (mintData.collateralDepositData.amount > 0) {\n                //add collateral to BingBang\n                _setApprovalForYieldBox(address(bigBang), yieldBox);\n                bigBang.addCollateral(\n                    mintData.collateralDepositData.deposit\n                        ? address(this)\n                        : user,\n                    user,\n                    false,\n                    mintData.collateralDepositData.amount,\n                    bbCollateralShare\n                );\n            }\n\n            // mints from BB\n            bigBang.borrow(user, user, mintData.mintAmount);\n        }\n\n        // if `depositData.deposit`:\n        //      - deposit SGL asset to YB for `user`\n        uint256 sglAssetId = singularity.assetId();\n        (, address sglAssetAddress, , ) = yieldBox.assets(sglAssetId);\n        if (depositData.deposit) {\n            depositData.amount = _extractTokens(\n                depositData.extractFromSender ? msg.sender : user,\n                sglAssetAddress,\n                depositData.amount\n            );\n\n            IERC20(sglAssetAddress).approve(address(yieldBox), 0);\n            IERC20(sglAssetAddress).approve(\n                address(yieldBox),\n                depositData.amount\n            );\n            yieldBox.depositAsset(\n                sglAssetId,\n                address(this),\n                user,\n                depositData.amount,\n                0\n            );\n        }\n\n        // if `lendAmount` > 0:\n        //      - add asset to SGL\n        uint256 fraction = 0;\n        if (lendAmount == 0 && depositData.deposit) {\n            lendAmount = depositData.amount;\n        }\n        if (lendAmount > 0) {\n            uint256 lendShare = yieldBox.toShare(sglAssetId, lendAmount, false);\n            fraction = singularity.addAsset(user, user, false, lendShare);\n        }\n\n        // if `lockData.lock`:\n        //      - transfer `fraction` from user to `address(this)\n        //      - deposits `fraction` to YB for `address(this)`\n        //      - performs tOLP.lock\n        uint256 tOLPTokenId = 0;\n        if (lockData.lock) {\n            if (!_cluster.isWhitelisted(_cluster.lzChainId(), lockData.target))\n                revert NotAuthorized();\n            if (lockData.fraction > 0) {\n                fraction = lockData.fraction;\n            }\n            // retrieve and deposit SGLAssetId registered in tOLP\n            (uint256 tOLPSglAssetId, , ) = ITapiocaOptionLiquidityProvision(\n                lockData.target\n            ).activeSingularities(address(singularity));\n            if (fraction == 0) revert NotValid();\n            IERC20(address(singularity)).safeTransferFrom(\n                user,\n                address(this),\n                fraction\n            );\n            IERC20(address(singularity)).approve(address(yieldBox), 0);\n            IERC20(address(singularity)).approve(address(yieldBox), fraction);\n            yieldBox.depositAsset(\n                tOLPSglAssetId,\n                address(this),\n                address(this),\n                fraction,\n                0\n            );\n\n            _setApprovalForYieldBox(lockData.target, yieldBox);\n            address lockTo = participateData.participate ? address(this) : user;\n            tOLPTokenId = ITapiocaOptionLiquidityProvision(lockData.target)\n                .lock(\n                    lockTo,\n                    address(singularity),\n                    lockData.lockDuration,\n                    lockData.amount\n                );\n            _revertYieldBoxApproval(lockData.target, yieldBox);\n        }\n\n        // if `participateData.participate`:\n        //      - verify tOLPTokenId\n        //      - performs tOB.participate\n        //      - transfer `oTAPTokenId` to user\n        if (participateData.participate) {\n            if (\n                !_cluster.isWhitelisted(\n                    _cluster.lzChainId(),\n                    participateData.target\n                )\n            ) revert NotAuthorized();\n\n            if (participateData.tOLPTokenId != 0) {\n                if (tOLPTokenId != 0) {\n                    if (participateData.tOLPTokenId != tOLPTokenId)\n                        revert tOLPTokenMismatch();\n                }\n\n                tOLPTokenId = participateData.tOLPTokenId;\n            }\n            if (lockData.target == address(0)) revert LockTargetMismatch();\n            if (tOLPTokenId == 0) revert NotValid();\n\n            IERC721(lockData.target).approve(\n                participateData.target,\n                tOLPTokenId\n            );\n            uint256 oTAPTokenId = ITapiocaOptionsBroker(participateData.target)\n                .participate(tOLPTokenId);\n\n            address oTapAddress = ITapiocaOptionsBroker(participateData.target)\n                .oTAP();\n            IERC721(oTapAddress).safeTransferFrom(\n                address(this),\n                user,\n                oTAPTokenId,\n                \"0x\"\n            );\n        }\n\n        if (address(singularity) != address(0)) {\n            _revertYieldBoxApproval(address(singularity), yieldBox);\n        }\n        if (address(bigBang) != address(0)) {\n            _revertYieldBoxApproval(address(bigBang), yieldBox);\n        }\n    }\n\n    function _exitPositionAndRemoveCollateral(\n        address user,\n        ICommonData.ICommonExternalContracts calldata externalData,\n        IUSDOBase.IRemoveAndRepay calldata removeAndRepayData,\n        uint256 valueAmount,\n        ICluster _cluster\n    ) private {\n        if (externalData.bigBang != address(0)) {\n            if (\n                !_cluster.isWhitelisted(\n                    _cluster.lzChainId(),\n                    externalData.bigBang\n                )\n            ) revert NotAuthorized();\n        }\n        if (externalData.singularity != address(0)) {\n            if (\n                !_cluster.isWhitelisted(\n                    _cluster.lzChainId(),\n                    externalData.singularity\n                )\n            ) revert NotAuthorized();\n        }\n\n        IMarket bigBang = IMarket(externalData.bigBang);\n        ISingularity singularity = ISingularity(externalData.singularity);\n        IYieldBoxBase yieldBox = IYieldBoxBase(singularity.yieldBox());\n\n        // if `removeAndRepayData.exitData.exit` the following operations are performed\n        //      - if ownerOfTapTokenId is user, transfers the oTAP token id to this contract\n        //      - tOB.exitPosition\n        //      - if `!removeAndRepayData.unlockData.unlock`, transfer the obtained tokenId to the user\n        uint256 tOLPId = 0;\n        if (removeAndRepayData.exitData.exit) {\n            if (removeAndRepayData.exitData.oTAPTokenID == 0) revert NotValid();\n            if (\n                !_cluster.isWhitelisted(\n                    _cluster.lzChainId(),\n                    removeAndRepayData.exitData.target\n                )\n            ) revert NotAuthorized();\n\n            address oTapAddress = ITapiocaOptionsBroker(\n                removeAndRepayData.exitData.target\n            ).oTAP();\n            (, ITapiocaOptions.TapOption memory oTAPPosition) = ITapiocaOptions(\n                oTapAddress\n            ).attributes(removeAndRepayData.exitData.oTAPTokenID);\n\n            tOLPId = oTAPPosition.tOLP;\n\n            address ownerOfTapTokenId = IERC721(oTapAddress).ownerOf(\n                removeAndRepayData.exitData.oTAPTokenID\n            );\n\n            if (ownerOfTapTokenId != user && ownerOfTapTokenId != address(this))\n                revert NotValid();\n            if (ownerOfTapTokenId == user) {\n                IERC721(oTapAddress).safeTransferFrom(\n                    user,\n                    address(this),\n                    removeAndRepayData.exitData.oTAPTokenID,\n                    \"0x\"\n                );\n            }\n            ITapiocaOptionsBroker(removeAndRepayData.exitData.target)\n                .exitPosition(removeAndRepayData.exitData.oTAPTokenID);\n\n            if (!removeAndRepayData.unlockData.unlock) {\n                address tOLPContract = ITapiocaOptionsBroker(\n                    removeAndRepayData.exitData.target\n                ).tOLP();\n\n                //transfer tOLP to the user\n                IERC721(tOLPContract).safeTransferFrom(\n                    address(this),\n                    user,\n                    tOLPId,\n                    \"0x\"\n                );\n            }\n        }\n\n        // performs a tOLP.unlock operation\n        if (removeAndRepayData.unlockData.unlock) {\n            if (\n                !_cluster.isWhitelisted(\n                    _cluster.lzChainId(),\n                    removeAndRepayData.unlockData.target\n                )\n            ) revert NotAuthorized();\n\n            if (removeAndRepayData.unlockData.tokenId != 0) {\n                if (tOLPId != 0) {\n                    if (tOLPId != removeAndRepayData.unlockData.tokenId)\n                        revert tOLPTokenMismatch();\n                }\n                tOLPId = removeAndRepayData.unlockData.tokenId;\n            }\n            ITapiocaOptionLiquidityProvision(\n                removeAndRepayData.unlockData.target\n            ).unlock(tOLPId, externalData.singularity, user);\n        }\n\n        // if `removeAndRepayData.removeAssetFromSGL` performs the follow operations:\n        //      - removeAsset from SGL\n        //      - if `removeAndRepayData.assetWithdrawData.withdraw` withdraws by using the `withdrawTo` operation\n        uint256 _removeAmount = removeAndRepayData.removeAmount;\n        if (removeAndRepayData.removeAssetFromSGL) {\n            uint256 share = yieldBox.toShare(\n                singularity.assetId(),\n                _removeAmount,\n                false\n            );\n\n            address removeAssetTo = removeAndRepayData\n                .assetWithdrawData\n                .withdraw || removeAndRepayData.repayAssetOnBB\n                ? address(this)\n                : user;\n\n            singularity.removeAsset(user, removeAssetTo, share);\n\n            //withdraw\n            if (removeAndRepayData.assetWithdrawData.withdraw) {\n                bytes memory withdrawAssetBytes = abi.encode(\n                    removeAndRepayData.assetWithdrawData.withdrawOnOtherChain,\n                    removeAndRepayData.assetWithdrawData.withdrawLzChainId,\n                    LzLib.addressToBytes32(user),\n                    removeAndRepayData.assetWithdrawData.withdrawAdapterParams\n                );\n                _withdraw(\n                    address(this),\n                    withdrawAssetBytes,\n                    singularity,\n                    yieldBox,\n                    _removeAmount,\n                    false,\n                    valueAmount,\n                    false\n                );\n            }\n        }\n\n        // performs a BigBang repay operation\n        if (\n            !removeAndRepayData.assetWithdrawData.withdraw &&\n            removeAndRepayData.repayAssetOnBB\n        ) {\n            _setApprovalForYieldBox(address(bigBang), yieldBox);\n            uint256 repayed = bigBang.repay(\n                address(this),\n                user,\n                false,\n                removeAndRepayData.repayAmount\n            );\n            // transfer excess amount to the user\n            if (repayed < _removeAmount) {\n                yieldBox.transfer(\n                    address(this),\n                    user,\n                    bigBang.assetId(),\n                    yieldBox.toShare(\n                        bigBang.assetId(),\n                        _removeAmount - repayed,\n                        false\n                    )\n                );\n            }\n        }\n\n        // performs a BigBang removeCollateral operation\n        // if `removeAndRepayData.collateralWithdrawData.withdraw` withdraws by using the `withdrawTo` method\n        if (removeAndRepayData.removeCollateralFromBB) {\n            uint256 collateralShare = yieldBox.toShare(\n                bigBang.collateralId(),\n                removeAndRepayData.collateralAmount,\n                false\n            );\n            address removeCollateralTo = removeAndRepayData\n                .collateralWithdrawData\n                .withdraw\n                ? address(this)\n                : user;\n            bigBang.removeCollateral(user, removeCollateralTo, collateralShare);\n\n            //withdraw\n            if (removeAndRepayData.collateralWithdrawData.withdraw) {\n                bytes memory withdrawCollateralBytes = abi.encode(\n                    removeAndRepayData\n                        .collateralWithdrawData\n                        .withdrawOnOtherChain,\n                    removeAndRepayData.collateralWithdrawData.withdrawLzChainId,\n                    LzLib.addressToBytes32(user),\n                    removeAndRepayData\n                        .collateralWithdrawData\n                        .withdrawAdapterParams\n                );\n                _withdraw(\n                    address(this),\n                    withdrawCollateralBytes,\n                    singularity,\n                    yieldBox,\n                    removeAndRepayData.collateralAmount,\n                    true,\n                    valueAmount,\n                    removeAndRepayData.collateralWithdrawData.unwrap\n                );\n            }\n        }\n        _revertYieldBoxApproval(address(bigBang), yieldBox);\n    }\n\n    function _withdrawToChain(\n        IYieldBoxBase yieldBox,\n        address from,\n        uint256 assetId,\n        uint16 dstChainId,\n        bytes32 receiver,\n        uint256 amount,\n        bytes memory adapterParams,\n        address payable refundAddress,\n        uint256 gas,\n        bool unwrap\n    ) private {\n        // perform a same chain withdrawal\n        if (dstChainId == 0) {\n            yieldBox.withdraw(\n                assetId,\n                from,\n                LzLib.bytes32ToAddress(receiver),\n                amount,\n                0\n            );\n            return;\n        }\n        // perform a cross chain withdrawal\n        (, address asset, , ) = yieldBox.assets(assetId);\n        // make sure the asset supports a cross chain operation\n        try\n            IERC165(address(asset)).supportsInterface(\n                type(ISendFrom).interfaceId\n            )\n        {} catch {\n            yieldBox.withdraw(\n                assetId,\n                from,\n                LzLib.bytes32ToAddress(receiver),\n                amount,\n                0\n            );\n            return;\n        }\n\n        // withdraw from YieldBox\n        yieldBox.withdraw(assetId, from, address(this), amount, 0);\n\n        // build LZ params\n        bytes memory _adapterParams;\n        ICommonOFT.LzCallParams memory callParams = ICommonOFT.LzCallParams({\n            refundAddress: msg.value == gas ? refundAddress : payable(this),\n            zroPaymentAddress: address(0),\n            adapterParams: ISendFrom(address(asset)).useCustomAdapterParams()\n                ? adapterParams\n                : _adapterParams\n        });\n\n        // sends the asset to another layer\n        if (unwrap) {\n            ICommonData.IApproval[]\n                memory approvals = new ICommonData.IApproval[](0);\n            ITapiocaOFT(address(asset)).triggerSendFromWithParams{value: gas}(\n                address(this),\n                dstChainId,\n                receiver,\n                amount,\n                callParams,\n                true,\n                approvals,\n                approvals\n            );\n        } else {\n            ISendFrom(address(asset)).sendFrom{value: gas}(\n                address(this),\n                dstChainId,\n                receiver,\n                amount,\n                callParams\n            );\n        }\n    }\n\n    function _withdraw(\n        address from,\n        bytes memory withdrawData,\n        IMarket market,\n        IYieldBoxBase yieldBox,\n        uint256 amount,\n        bool withdrawCollateral,\n        uint256 valueAmount,\n        bool unwrap\n    ) private {\n        if (withdrawData.length == 0) revert NotValid();\n        (\n            bool withdrawOnOtherChain,\n            uint16 destChain,\n            bytes32 receiver,\n            bytes memory adapterParams\n        ) = abi.decode(withdrawData, (bool, uint16, bytes32, bytes));\n\n        _withdrawToChain(\n            yieldBox,\n            from,\n            withdrawCollateral ? market.collateralId() : market.assetId(),\n            withdrawOnOtherChain ? destChain : 0,\n            receiver,\n            amount,\n            adapterParams,\n            valueAmount > 0 ? payable(msg.sender) : payable(this),\n            valueAmount,\n            unwrap\n        );\n    }\n\n    function _setApprovalForYieldBox(\n        address target,\n        IYieldBoxBase yieldBox\n    ) private {\n        bool isApproved = yieldBox.isApprovedForAll(address(this), target);\n        if (!isApproved) {\n            yieldBox.setApprovalForAll(target, true);\n        }\n    }\n\n    function _revertYieldBoxApproval(\n        address target,\n        IYieldBoxBase yieldBox\n    ) private {\n        bool isApproved = yieldBox.isApprovedForAll(\n            address(this),\n            address(target)\n        );\n        if (isApproved) {\n            yieldBox.setApprovalForAll(address(target), false);\n        }\n    }\n\n    function _extractTokens(\n        address _from,\n        address _token,\n        uint256 _amount\n    ) private returns (uint256) {\n        uint256 balanceBefore = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = IERC20(_token).balanceOf(address(this));\n        if (balanceAfter <= balanceBefore) revert Failed();\n        return balanceAfter - balanceBefore;\n    }\n}"
    }
  ]
}