{
  "Title": "[L-04] Collecting funds should be usable while the `DripsHub` contract is paused",
  "Content": "\nThe `DripsHub.collect` function is only callable when the `DripsHub` contract is not paused. This prevents a user from collecting accumulated funds. The admin of the `DripsHub` contract can potentially pause the contracts at any time, locking users out of their honestly earned funds.\n\n### Findings\n\n[DripsHub.sol#L388](https://github.com/code-423n4/2023-01-drips/blob/9fd776b50f4be23ca038b1d0426e63a69c7a511d/src/DripsHub.sol#L388)\n\n```solidity\n386: function collect(uint256 userId, IERC20 erc20)\n387:     public\n388:     whenNotPaused\n389:     onlyDriver(userId)\n390:     returns (uint128 amt)\n391: {\n392:     amt = Splits._collect(userId, _assetId(erc20));\n393:     _decreaseTotalBalance(erc20, amt);\n394:     erc20.safeTransfer(msg.sender, amt);\n395: }\n```\n\n### Recommended Mitigation Steps\n\nConsider removing the `whenNotPaused` modifier to allow collecting funds while the `DripsHub` contract is paused.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2023-01-drips-protocol-contest",
  "Code": [
    {
      "filename": "src/DripsHub.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.17;\n\nimport {Drips, DripsConfig, DripsHistory, DripsConfigImpl, DripsReceiver} from \"./Drips.sol\";\nimport {Managed} from \"./Managed.sol\";\nimport {Splits, SplitsReceiver} from \"./Splits.sol\";\nimport {IERC20} from \"openzeppelin-contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\n\nusing SafeERC20 for IERC20;\n\n/// @notice The user metadata.\n/// The key and the value are not standardized by the protocol, it's up to the user\n/// to establish and follow conventions to ensure compatibility with the consumers.\nstruct UserMetadata {\n    /// @param key The metadata key\n    bytes32 key;\n    /// @param value The metadata value\n    bytes value;\n}\n\n/// @notice Drips hub contract. Automatically drips and splits funds between users.\n///\n/// The user can transfer some funds to their drips balance in the contract\n/// and configure a list of receivers, to whom they want to drip these funds.\n/// As soon as the drips balance is enough to cover at least 1 second of dripping\n/// to the configured receivers, the funds start dripping automatically.\n/// Every second funds are deducted from the drips balance and moved to their receivers.\n/// The process stops automatically when the drips balance is not enough to cover another second.\n///\n/// Every user has a receiver balance, in which they have funds received from other users.\n/// The dripped funds are added to the receiver balances in global cycles.\n/// Every `cycleSecs` seconds the drips hub adds dripped funds to the receivers' balances,\n/// so recently dripped funds may not be receivable immediately.\n/// `cycleSecs` is a constant configured when the drips hub is deployed.\n/// The receiver balance is independent from the drips balance,\n/// to drip received funds they need to be first collected and then added to the drips balance.\n///\n/// The user can share collected funds with other users by using splits.\n/// When collecting, the user gives each of their splits receivers a fraction of the received funds.\n/// Funds received from splits are available for collection immediately regardless of the cycle.\n/// They aren't exempt from being split, so they too can be split when collected.\n/// Users can build chains and networks of splits between each other.\n/// Anybody can request collection of funds for any user,\n/// which can be used to enforce the flow of funds in the network of splits.\n///\n/// The concept of something happening periodically, e.g. every second or every `cycleSecs` are\n/// only high-level abstractions for the user, Ethereum isn't really capable of scheduling work.\n/// The actual implementation emulates that behavior by calculating the results of the scheduled\n/// events based on how many seconds have passed and only when the user needs their outcomes.\n///\n/// The contract can store at most `type(int128).max` which is `2 ^ 127 - 1` units of each token.\ncontract DripsHub is Managed, Drips, Splits {\n    /// @notice Maximum number of drips receivers of a single user.\n    /// Limits cost of changes in drips configuration.\n    uint256 public constant MAX_DRIPS_RECEIVERS = _MAX_DRIPS_RECEIVERS;\n    /// @notice The additional decimals for all amtPerSec values.\n    uint8 public constant AMT_PER_SEC_EXTRA_DECIMALS = _AMT_PER_SEC_EXTRA_DECIMALS;\n    /// @notice The multiplier for all amtPerSec values.\n    uint256 public constant AMT_PER_SEC_MULTIPLIER = _AMT_PER_SEC_MULTIPLIER;\n    /// @notice Maximum number of splits receivers of a single user. Limits the cost of splitting.\n    uint256 public constant MAX_SPLITS_RECEIVERS = _MAX_SPLITS_RECEIVERS;\n    /// @notice The total splits weight of a user\n    uint32 public constant TOTAL_SPLITS_WEIGHT = _TOTAL_SPLITS_WEIGHT;\n    /// @notice The offset of the controlling driver ID in the user ID.\n    /// In other words the controlling driver ID is the highest 32 bits of the user ID.\n    uint256 public constant DRIVER_ID_OFFSET = 224;\n    /// @notice The total amount the contract can store of each token.\n    /// It's the minimum of _MAX_TOTAL_DRIPS_BALANCE and _MAX_TOTAL_SPLITS_BALANCE.\n    uint256 public constant MAX_TOTAL_BALANCE = _MAX_TOTAL_DRIPS_BALANCE;\n    /// @notice The ERC-1967 storage slot holding a single `DripsHubStorage` structure.\n    bytes32 private immutable _dripsHubStorageSlot = _erc1967Slot(\"eip1967.dripsHub.storage\");\n\n    /// @notice Emitted when a driver is registered\n    /// @param driverId The driver ID\n    /// @param driverAddr The driver address\n    event DriverRegistered(uint32 indexed driverId, address indexed driverAddr);\n\n    /// @notice Emitted when a driver address is updated\n    /// @param driverId The driver ID\n    /// @param oldDriverAddr The old driver address\n    /// @param newDriverAddr The new driver address\n    event DriverAddressUpdated(\n        uint32 indexed driverId, address indexed oldDriverAddr, address indexed newDriverAddr\n    );\n\n    /// @notice Emitted by the user to broadcast metadata.\n    /// The key and the value are not standardized by the protocol, it's up to the user\n    /// to establish and follow conventions to ensure compatibility with the consumers.\n    /// @param userId The ID of the user emitting metadata\n    /// @param key The metadata key\n    /// @param value The metadata value\n    event UserMetadataEmitted(uint256 indexed userId, bytes32 indexed key, bytes value);\n\n    struct DripsHubStorage {\n        /// @notice The next driver ID that will be used when registering.\n        uint32 nextDriverId;\n        /// @notice Driver addresses. The key is the driver ID, the value is the driver address.\n        mapping(uint32 => address) driverAddresses;\n        /// @notice The total amount currently stored in DripsHub of each token.\n        mapping(IERC20 => uint256) totalBalances;\n    }\n\n    /// @param cycleSecs_ The length of cycleSecs to be used in the contract instance.\n    /// Low value makes funds more available by shortening the average time of funds being frozen\n    /// between being taken from the users' drips balances and being receivable by their receivers.\n    /// High value makes receiving cheaper by making it process less cycles for a given time range.\n    /// Must be higher than 1.\n    constructor(uint32 cycleSecs_)\n        Drips(cycleSecs_, _erc1967Slot(\"eip1967.drips.storage\"))\n        Splits(_erc1967Slot(\"eip1967.splits.storage\"))\n    {\n        return;\n    }\n\n    /// @notice A modifier making functions callable only by the driver controlling the user ID.\n    /// @param userId The user ID.\n    modifier onlyDriver(uint256 userId) {\n        uint32 driverId = uint32(userId >> DRIVER_ID_OFFSET);\n        _assertCallerIsDriver(driverId);\n        _;\n    }\n\n    function _assertCallerIsDriver(uint32 driverId) internal view {\n        require(driverAddress(driverId) == msg.sender, \"Callable only by the driver\");\n    }\n\n    /// @notice Registers a driver.\n    /// The driver is assigned a unique ID and a range of user IDs it can control.\n    /// That range consists of all 2^224 user IDs with highest 32 bits equal to the driver ID.\n    /// Multiple drivers can have the same address, that address can then control all of them.\n    /// @param driverAddr The address of the driver.\n    /// @return driverId The registered driver ID.\n    function registerDriver(address driverAddr) public whenNotPaused returns (uint32 driverId) {\n        DripsHubStorage storage dripsHubStorage = _dripsHubStorage();\n        driverId = dripsHubStorage.nextDriverId++;\n        dripsHubStorage.driverAddresses[driverId] = driverAddr;\n        emit DriverRegistered(driverId, driverAddr);\n    }\n\n    /// @notice Returns the driver address.\n    /// @param driverId The driver ID to look up.\n    /// @return driverAddr The address of the driver.\n    /// If the driver hasn't been registered yet, returns address 0.\n    function driverAddress(uint32 driverId) public view returns (address driverAddr) {\n        return _dripsHubStorage().driverAddresses[driverId];\n    }\n\n    /// @notice Updates the driver address. Must be called from the current driver address.\n    /// @param driverId The driver ID.\n    /// @param newDriverAddr The new address of the driver.\n    function updateDriverAddress(uint32 driverId, address newDriverAddr) public whenNotPaused {\n        _assertCallerIsDriver(driverId);\n        _dripsHubStorage().driverAddresses[driverId] = newDriverAddr;\n        emit DriverAddressUpdated(driverId, msg.sender, newDriverAddr);\n    }\n\n    /// @notice Returns the driver ID which will be assigned for the next registered driver.\n    /// @return driverId The next driver ID.\n    function nextDriverId() public view returns (uint32 driverId) {\n        return _dripsHubStorage().nextDriverId;\n    }\n\n    /// @notice Returns the cycle length in seconds.\n    /// On every timestamp `T`, which is a multiple of `cycleSecs`, the receivers\n    /// gain access to drips received during `T - cycleSecs` to `T - 1`.\n    /// Always higher than 1.\n    /// @return cycleSecs_ The cycle length in seconds.\n    function cycleSecs() public view returns (uint32 cycleSecs_) {\n        return Drips._cycleSecs;\n    }\n\n    /// @notice Returns the total amount currently stored in DripsHub of the given token.\n    /// @param erc20 The used ERC-20 token.\n    /// It must preserve amounts, so if some amount of tokens is transferred to\n    /// an address, then later the same amount must be transferrable from that address.\n    /// Tokens which rebase the holders' balances, collect taxes on transfers,\n    /// or impose any restrictions on holding or transferring tokens are not supported.\n    /// If you use such tokens in the protocol, they can get stuck or lost.\n    /// @return balance The balance of the token.\n    function totalBalance(IERC20 erc20) public view returns (uint256 balance) {\n        return _dripsHubStorage().totalBalances[erc20];\n    }\n\n    /// @notice Counts cycles from which drips can be collected.\n    /// This function can be used to detect that there are\n    /// too many cycles to analyze in a single transaction.\n    /// @param userId The user ID\n    /// @param erc20 The used ERC-20 token.\n    /// It must preserve amounts, so if some amount of tokens is transferred to\n    /// an address, then later the same amount must be transferrable from that address.\n    /// Tokens which rebase the holders' balances, collect taxes on transfers,\n    /// or impose any restrictions on holding or transferring tokens are not supported.\n    /// If you use such tokens in the protocol, they can get stuck or lost.\n    /// @return cycles The number of cycles which can be flushed\n    function receivableDripsCycles(uint256 userId, IERC20 erc20)\n        public\n        view\n        returns (uint32 cycles)\n    {\n        return Drips._receivableDripsCycles(userId, _assetId(erc20));\n    }\n\n    /// @notice Calculate effects of calling `receiveDrips` with the given parameters.\n    /// @param userId The user ID\n    /// @param erc20 The used ERC-20 token.\n    /// It must preserve amounts, so if some amount of tokens is transferred to\n    /// an address, then later the same amount must be transferrable from that address.\n    /// Tokens which rebase the holders' balances, collect taxes on transfers,\n    /// or impose any restrictions on holding or transferring tokens are not supported.\n    /// If you use such tokens in the protocol, they can get stuck or lost.\n    /// @param maxCycles The maximum number of received drips cycles.\n    /// If too low, receiving will be cheap, but may not cover many cycles.\n    /// If too high, receiving may become too expensive to fit in a single transaction.\n    /// @return receivableAmt The amount which would be received\n    function receiveDripsResult(uint256 userId, IERC20 erc20, uint32 maxCycles)\n        public\n        view\n        returns (uint128 receivableAmt)\n    {\n        (receivableAmt,,,,) = Drips._receiveDripsResult(userId, _assetId(erc20), maxCycles);\n    }\n\n    /// @notice Receive drips for the user.\n    /// Received drips cycles won't need to be analyzed ever again.\n    /// Calling this function does not collect but makes the funds ready to be split and collected.\n    /// @param userId The user ID\n    /// @param erc20 The used ERC-20 token.\n    /// It must preserve amounts, so if some amount of tokens is transferred to\n    /// an address, then later the same amount must be transferrable from that address.\n    /// Tokens which rebase the holders' balances, collect taxes on transfers,\n    /// or impose any restrictions on holding or transferring tokens are not supported.\n    /// If you use such tokens in the protocol, they can get stuck or lost.\n    /// @param maxCycles The maximum number of received drips cycles.\n    /// If too low, receiving will be cheap, but may not cover many cycles.\n    /// If too high, receiving may become too expensive to fit in a single transaction.\n    /// @return receivedAmt The received amount\n    function receiveDrips(uint256 userId, IERC20 erc20, uint32 maxCycles)\n        public\n        whenNotPaused\n        returns (uint128 receivedAmt)\n    {\n        uint256 assetId = _assetId(erc20);\n        receivedAmt = Drips._receiveDrips(userId, assetId, maxCycles);\n        if (receivedAmt > 0) {\n            Splits._addSplittable(userId, assetId, receivedAmt);\n        }\n    }\n\n    /// @notice Receive drips from the currently running cycle from a single sender.\n    /// It doesn't receive drips from the previous, finished cycles, to do that use `receiveDrips`.\n    /// Squeezed funds won't be received in the next calls to `squeezeDrips` or `receiveDrips`.\n    /// Only funds dripped before `block.timestamp` can be squeezed.\n    /// @param userId The ID of the user receiving drips to squeeze funds for.\n    /// @param erc20 The used ERC-20 token.\n    /// It must preserve amounts, so if some amount of tokens is transferred to\n    /// an address, then later the same amount must be transferrable from that address.\n    /// Tokens which rebase the holders' balances, collect taxes on transfers,\n    /// or impose any restrictions on holding or transferring tokens are not supported.\n    /// If you use such tokens in the protocol, they can get stuck or lost.\n    /// @param senderId The ID of the user sending drips to squeeze funds from.\n    /// @param historyHash The sender's history hash which was valid right before\n    /// they set up the sequence of configurations described by `dripsHistory`.\n    /// @param dripsHistory The sequence of the sender's drips configurations.\n    /// It can start at an arbitrary past configuration, but must describe all the configurations\n    /// which have been used since then including the current one, in the chronological order.\n    /// Only drips described by `dripsHistory` will be squeezed.\n    /// If `dripsHistory` entries have no receivers, they won't be squeezed.\n    /// @return amt The squeezed amount.\n    function squeezeDrips(\n        uint256 userId,\n        IERC20 erc20,\n        uint256 senderId,\n        bytes32 historyHash,\n        DripsHistory[] memory dripsHistory\n    ) public whenNotPaused returns (uint128 amt) {\n        uint256 assetId = _assetId(erc20);\n        amt = Drips._squeezeDrips(userId, assetId, senderId, historyHash, dripsHistory);\n        if (amt > 0) {\n            Splits._addSplittable(userId, assetId, amt);\n        }\n    }\n\n    /// @notice Calculate effects of calling `squeezeDrips` with the given parameters.\n    /// See its documentation for more details.\n    /// @param userId The ID of the user receiving drips to squeeze funds for.\n    /// @param erc20 The used ERC-20 token.\n    /// It must preserve amounts, so if some amount of tokens is transferred to\n    /// an address, then later the same amount must be transferrable from that address.\n    /// Tokens which rebase the holders' balances, collect taxes on transfers,\n    /// or impose any restrictions on holding or transferring tokens are not supported.\n    /// If you use such tokens in the protocol, they can get stuck or lost.\n    /// @param senderId The ID of the user sending drips to squeeze funds from.\n    /// @param historyHash The sender's history hash which was valid right before `dripsHistory`.\n    /// @param dripsHistory The sequence of the sender's drips configurations.\n    /// @return amt The squeezed amount.\n    function squeezeDripsResult(\n        uint256 userId,\n        IERC20 erc20,\n        uint256 senderId,\n        bytes32 historyHash,\n        DripsHistory[] memory dripsHistory\n    ) public view returns (uint128 amt) {\n        (amt,,,,) =\n            Drips._squeezeDripsResult(userId, _assetId(erc20), senderId, historyHash, dripsHistory);\n    }\n\n    /// @notice Returns user's received but not split yet funds.\n    /// @param userId The user ID\n    /// @param erc20 The used ERC-20 token.\n    /// It must preserve amounts, so if some amount of tokens is transferred to\n    /// an address, then later the same amount must be transferrable from that address.\n    /// Tokens which rebase the holders' balances, collect taxes on transfers,\n    /// or impose any restrictions on holding or transferring tokens are not supported.\n    /// If you use such tokens in the protocol, they can get stuck or lost.\n    /// @return amt The amount received but not split yet.\n    function splittable(uint256 userId, IERC20 erc20) public view returns (uint128 amt) {\n        return Splits._splittable(userId, _assetId(erc20));\n    }\n\n    /// @notice Calculate the result of splitting an amount using the current splits configuration.\n    /// @param userId The user ID\n    /// @param currReceivers The list of the user's current splits receivers.\n    /// @param amount The amount being split.\n    /// @return collectableAmt The amount made collectable for the user\n    /// on top of what was collectable before.\n    /// @return splitAmt The amount split to the user's splits receivers\n    function splitResult(uint256 userId, SplitsReceiver[] memory currReceivers, uint128 amount)\n        public\n        view\n        returns (uint128 collectableAmt, uint128 splitAmt)\n    {\n        return Splits._splitResult(userId, currReceivers, amount);\n    }\n\n    /// @notice Splits the user's splittable funds among receivers.\n    /// The entire splittable balance of the given asset is split.\n    /// All split funds are split using the current splits configuration.\n    /// Because the user can update their splits configuration at any time,\n    /// it is possible that calling this function will be frontrun,\n    /// and all the splittable funds will become splittable only using the new configuration.\n    /// The user must be trusted with how funds sent to them will be splits,\n    /// in the end they can do with their funds whatever they want by changing the configuration.\n    /// @param userId The user ID\n    /// @param erc20 The used ERC-20 token.\n    /// It must preserve amounts, so if some amount of tokens is transferred to\n    /// an address, then later the same amount must be transferrable from that address.\n    /// Tokens which rebase the holders' balances, collect taxes on transfers,\n    /// or impose any restrictions on holding or transferring tokens are not supported.\n    /// If you use such tokens in the protocol, they can get stuck or lost.\n    /// @param currReceivers The list of the user's current splits receivers.\n    /// @return collectableAmt The amount made collectable for the user\n    /// on top of what was collectable before.\n    /// @return splitAmt The amount split to the user's splits receivers\n    function split(uint256 userId, IERC20 erc20, SplitsReceiver[] memory currReceivers)\n        public\n        whenNotPaused\n        returns (uint128 collectableAmt, uint128 splitAmt)\n    {\n        return Splits._split(userId, _assetId(erc20), currReceivers);\n    }\n\n    /// @notice Returns user's received funds already split and ready to be collected.\n    /// @param userId The user ID\n    /// @param erc20 The used ERC-20 token.\n    /// It must preserve amounts, so if some amount of tokens is transferred to\n    /// an address, then later the same amount must be transferrable from that address.\n    /// Tokens which rebase the holders' balances, collect taxes on transfers,\n    /// or impose any restrictions on holding or transferring tokens are not supported.\n    /// If you use such tokens in the protocol, they can get stuck or lost.\n    /// @return amt The collectable amount.\n    function collectable(uint256 userId, IERC20 erc20) public view returns (uint128 amt) {\n        return Splits._collectable(userId, _assetId(erc20));\n    }\n\n    /// @notice Collects user's received already split funds\n    /// and transfers them out of the drips hub contract to msg.sender.\n    /// @param userId The user ID\n    /// @param erc20 The used ERC-20 token.\n    /// It must preserve amounts, so if some amount of tokens is transferred to\n    /// an address, then later the same amount must be transferrable from that address.\n    /// Tokens which rebase the holders' balances, collect taxes on transfers,\n    /// or impose any restrictions on holding or transferring tokens are not supported.\n    /// If you use such tokens in the protocol, they can get stuck or lost.\n    /// @return amt The collected amount\n    function collect(uint256 userId, IERC20 erc20)\n        public\n        whenNotPaused\n        onlyDriver(userId)\n        returns (uint128 amt)\n    {\n        amt = Splits._collect(userId, _assetId(erc20));\n        _decreaseTotalBalance(erc20, amt);\n        erc20.safeTransfer(msg.sender, amt);\n    }\n\n    /// @notice Gives funds from the user to the receiver.\n    /// The receiver can split and collect them immediately.\n    /// Transfers the funds to be given from the user's wallet to the drips hub contract.\n    /// @param userId The user ID\n    /// @param receiver The receiver\n    /// @param erc20 The used ERC-20 token.\n    /// It must preserve amounts, so if some amount of tokens is transferred to\n    /// an address, then later the same amount must be transferrable from that address.\n    /// Tokens which rebase the holders' balances, collect taxes on transfers,\n    /// or impose any restrictions on holding or transferring tokens are not supported.\n    /// If you use such tokens in the protocol, they can get stuck or lost.\n    /// @param amt The given amount\n    function give(uint256 userId, uint256 receiver, IERC20 erc20, uint128 amt)\n        public\n        whenNotPaused\n        onlyDriver(userId)\n    {\n        _increaseTotalBalance(erc20, amt);\n        Splits._give(userId, receiver, _assetId(erc20), amt);\n        erc20.safeTransferFrom(msg.sender, address(this), amt);\n    }\n\n    /// @notice Current user drips state.\n    /// @param userId The user ID\n    /// @param erc20 The used ERC-20 token.\n    /// It must preserve amounts, so if some amount of tokens is transferred to\n    /// an address, then later the same amount must be transferrable from that address.\n    /// Tokens which rebase the holders' balances, collect taxes on transfers,\n    /// or impose any restrictions on holding or transferring tokens are not supported.\n    /// If you use such tokens in the protocol, they can get stuck or lost.\n    /// @return dripsHash The current drips receivers list hash, see `hashDrips`\n    /// @return dripsHistoryHash The current drips history hash, see `hashDripsHistory`.\n    /// @return updateTime The time when drips have been configured for the last time\n    /// @return balance The balance when drips have been configured for the last time\n    /// @return maxEnd The current maximum end time of drips\n    function dripsState(uint256 userId, IERC20 erc20)\n        public\n        view\n        returns (\n            bytes32 dripsHash,\n            bytes32 dripsHistoryHash,\n            uint32 updateTime,\n            uint128 balance,\n            uint32 maxEnd\n        )\n    {\n        return Drips._dripsState(userId, _assetId(erc20));\n    }\n\n    /// @notice User drips balance at a given timestamp\n    /// @param userId The user ID\n    /// @param erc20 The used ERC-20 token.\n    /// It must preserve amounts, so if some amount of tokens is transferred to\n    /// an address, then later the same amount must be transferrable from that address.\n    /// Tokens which rebase the holders' balances, collect taxes on transfers,\n    /// or impose any restrictions on holding or transferring tokens are not supported.\n    /// If you use such tokens in the protocol, they can get stuck or lost.\n    /// @param receivers The current drips receivers list\n    /// @param timestamp The timestamps for which balance should be calculated.\n    /// It can't be lower than the timestamp of the last call to `setDrips`.\n    /// If it's bigger than `block.timestamp`, then it's a prediction assuming\n    /// that `setDrips` won't be called before `timestamp`.\n    /// @return balance The user balance on `timestamp`\n    function balanceAt(\n        uint256 userId,\n        IERC20 erc20,\n        DripsReceiver[] memory receivers,\n        uint32 timestamp\n    ) public view returns (uint128 balance) {\n        return Drips._balanceAt(userId, _assetId(erc20), receivers, timestamp);\n    }\n\n    /// @notice Sets the user's drips configuration.\n    /// Transfers funds between the user's wallet and the drips hub contract\n    /// to fulfill the change of the drips balance.\n    /// @param userId The user ID\n    /// @param erc20 The used ERC-20 token.\n    /// It must preserve amounts, so if some amount of tokens is transferred to\n    /// an address, then later the same amount must be transferrable from that address.\n    /// Tokens which rebase the holders' balances, collect taxes on transfers,\n    /// or impose any restrictions on holding or transferring tokens are not supported.\n    /// If you use such tokens in the protocol, they can get stuck or lost.\n    /// @param currReceivers The list of the drips receivers set in the last drips update\n    /// of the user.\n    /// If this is the first update, pass an empty array.\n    /// @param balanceDelta The drips balance change to be applied.\n    /// Positive to add funds to the drips balance, negative to remove them.\n    /// @param newReceivers The list of the drips receivers of the user to be set.\n    /// Must be sorted by the receivers' addresses, deduplicated and without 0 amtPerSecs.\n    /// @param maxEndHint1 An optional parameter allowing gas optimization, pass `0` to ignore it.\n    /// The first hint for finding the maximum end time when all drips stop due to funds\n    /// running out after the balance is updated and the new receivers list is applied.\n    /// Hints have no effect on the results of calling this function, except potentially saving gas.\n    /// Hints are Unix timestamps used as the starting points for binary search for the time\n    /// when funds run out in the range of timestamps from the current block's to `2^32`.\n    /// Hints lower than the current timestamp are ignored.\n    /// You can provide zero, one or two hints. The order of hints doesn't matter.\n    /// Hints are the most effective when one of them is lower than or equal to\n    /// the last timestamp when funds are still dripping, and the other one is strictly larger\n    /// than that timestamp,the smaller the difference between such hints, the higher gas savings.\n    /// The savings are the highest possible when one of the hints is equal to\n    /// the last timestamp when funds are still dripping, and the other one is larger by 1.\n    /// It's worth noting that the exact timestamp of the block in which this function is executed\n    /// may affect correctness of the hints, especially if they're precise.\n    /// Hints don't provide any benefits when balance is not enough to cover\n    /// a single second of dripping or is enough to cover all drips until timestamp `2^32`.\n    /// Even inaccurate hints can be useful, and providing a single hint\n    /// or two hints that don't enclose the time when funds run out can still save some gas.\n    /// Providing poor hints that don't reduce the number of binary search steps\n    /// may cause slightly higher gas usage than not providing any hints.\n    /// @param maxEndHint2 An optional parameter allowing gas optimization, pass `0` to ignore it.\n    /// The second hint for finding the maximum end time, see `maxEndHint1` docs for more details.\n    /// @return realBalanceDelta The actually applied drips balance change.\n    function setDrips(\n        uint256 userId,\n        IERC20 erc20,\n        DripsReceiver[] memory currReceivers,\n        int128 balanceDelta,\n        DripsReceiver[] memory newReceivers,\n        // slither-disable-next-line similar-names\n        uint32 maxEndHint1,\n        uint32 maxEndHint2\n    ) public whenNotPaused onlyDriver(userId) returns (int128 realBalanceDelta) {\n        if (balanceDelta > 0) {\n            _increaseTotalBalance(erc20, uint128(balanceDelta));\n        }\n        realBalanceDelta = Drips._setDrips(\n            userId,\n            _assetId(erc20),\n            currReceivers,\n            balanceDelta,\n            newReceivers,\n            maxEndHint1,\n            maxEndHint2\n        );\n        if (realBalanceDelta > 0) {\n            erc20.safeTransferFrom(msg.sender, address(this), uint128(realBalanceDelta));\n        } else if (realBalanceDelta < 0) {\n            _decreaseTotalBalance(erc20, uint128(-realBalanceDelta));\n            erc20.safeTransfer(msg.sender, uint128(-realBalanceDelta));\n        }\n    }\n\n    /// @notice Calculates the hash of the drips configuration.\n    /// It's used to verify if drips configuration is the previously set one.\n    /// @param receivers The list of the drips receivers.\n    /// Must be sorted by the receivers' addresses, deduplicated and without 0 amtPerSecs.\n    /// If the drips have never been updated, pass an empty array.\n    /// @return dripsHash The hash of the drips configuration\n    function hashDrips(DripsReceiver[] memory receivers) public pure returns (bytes32 dripsHash) {\n        return Drips._hashDrips(receivers);\n    }\n\n    /// @notice Calculates the hash of the drips history after the drips configuration is updated.\n    /// @param oldDripsHistoryHash The history hash which was valid before the drips were updated.\n    /// The `dripsHistoryHash` of a user before they set drips for the first time is `0`.\n    /// @param dripsHash The hash of the drips receivers being set.\n    /// @param updateTime The timestamp when the drips are updated.\n    /// @param maxEnd The maximum end of the drips being set.\n    /// @return dripsHistoryHash The hash of the updated drips history.\n    function hashDripsHistory(\n        bytes32 oldDripsHistoryHash,\n        bytes32 dripsHash,\n        uint32 updateTime,\n        uint32 maxEnd\n    ) public pure returns (bytes32 dripsHistoryHash) {\n        return Drips._hashDripsHistory(oldDripsHistoryHash, dripsHash, updateTime, maxEnd);\n    }\n\n    /// @notice Sets user splits configuration. The configuration is common for all assets.\n    /// Nothing happens to the currently splittable funds, but when they are split\n    /// after this function finishes, the new splits configuration will be used.\n    /// Because anybody can call `split`, calling this function may be frontrun\n    /// and all the currently splittable funds will be split using the old splits configuration.\n    /// @param userId The user ID\n    /// @param receivers The list of the user's splits receivers to be set.\n    /// Must be sorted by the splits receivers' addresses, deduplicated and without 0 weights.\n    /// Each splits receiver will be getting `weight / TOTAL_SPLITS_WEIGHT`\n    /// share of the funds collected by the user.\n    function setSplits(uint256 userId, SplitsReceiver[] memory receivers)\n        public\n        whenNotPaused\n        onlyDriver(userId)\n    {\n        Splits._setSplits(userId, receivers);\n    }\n\n    /// @notice Current user's splits hash, see `hashSplits`.\n    /// @param userId The user ID\n    /// @return currSplitsHash The current user's splits hash\n    function splitsHash(uint256 userId) public view returns (bytes32 currSplitsHash) {\n        return Splits._splitsHash(userId);\n    }\n\n    /// @notice Calculates the hash of the list of splits receivers.\n    /// @param receivers The list of the splits receivers.\n    /// Must be sorted by the splits receivers' addresses, deduplicated and without 0 weights.\n    /// @return receiversHash The hash of the list of splits receivers.\n    function hashSplits(SplitsReceiver[] memory receivers)\n        public\n        pure\n        returns (bytes32 receiversHash)\n    {\n        return Splits._hashSplits(receivers);\n    }\n\n    /// @notice Emits user metadata.\n    /// The keys and the values are not standardized by the protocol, it's up to the user\n    /// t"
    }
  ]
}