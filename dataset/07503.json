{
  "Title": "[H-01] selfdestruct may cause the funds to be lost",
  "Content": "\n<https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/FixedPrice.sol#L110>\n\n<https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/OpenEdition.sol#L122>\n\n### Impact\n\nAfter the contract is destroyed, the subsequent execution of the contract's `#buy()` will always succede, the msg.value will be locked in this address.\n\n### Proof of Concept\n\nWhen FixedPrice.sol and OpenEdition.sol are finished, `selfdestruct()` will be executed to destroy the contract.\n\nBut there is a problem with this:\n\nSuppose when Alice and Bob execute the purchase transaction at the same time, the transaction is in the memory pool (or Alice executes the transaction, but Bob is still operating the purchase in the UI, the UI does not know that the contract has been destroyed)\n\nIf Alice meets the finalId, the contract is destroyed after her transaction ends.\n\nNote: \"When there is no code at the address, the transaction will succeed, and the msg.value will be stored in the contract. Although no code is executed.\"\n\nAfter that, Bob's transaction will be executed.\n\nThis way the msg.value passed by Bob is lost and locked forever in the address of this empty code.\n\nSuggestion: don't use selfdestruct, use modified state to represent that the contract has completed the sale.\n\n### Recommended Mitigation Steps\n\n```solidity\ncontract FixedPrice is Initializable, OwnableUpgradeable, ISale {\n...\n    function _end(Sale memory _sale) internal {\n        emit End(_sale);\n        ISaleFactory(factory).feeReceiver().transfer(address(this).balance / 20);\n-       selfdestruct(_sale.saleReceiver); \n+       sale.finalId = sale.currentId\n+       sale.saleReceiver.transfer(address(this).balance);     \n\n    }\n```\n\n**[berndartmueller (judge) commented](https://github.com/code-423n4/2022-12-escher-findings/issues/296#issuecomment-1345628524):**\n > The warden demonstrates an issue that leads to loss of user funds in case the contract is destroyed with `selfdestruct`.\n> \n> This clearly differentiates from the other submissions outlining the deprecated use of `selfdestruct` due to [EIP-4758](https://eips.ethereum.org/EIPS/eip-4758).\n\n**[stevennevins (Escher) disputed and commented](https://github.com/code-423n4/2022-12-escher-findings/issues/296#issuecomment-1362962068):**\n > ```\n> // SPDX-License-Identifier: MIT\n> pragma solidity ^0.8.17;\n> \n> import \"forge-std/Test.sol\";\n> import {EscherTest, FixedPrice, FixedPriceFactory} from \"test/FixedPrice.t.sol\";\n> \n> contract Issue296Test is EscherTest {\n>     FixedPrice.Sale public fixedSale;\n>     FixedPriceFactory public fixedSales;\n> \n>     FixedPrice public sale;\n> \n>     function setUp() public virtual override {\n>         super.setUp();\n>         fixedSales = new FixedPriceFactory();\n>         fixedSale = FixedPrice.Sale({\n>             currentId: uint48(0),\n>             finalId: uint48(10),\n>             edition: address(edition),\n>             price: uint96(uint256(1 ether)),\n>             saleReceiver: payable(address(69)),\n>             startTime: uint96(block.timestamp)\n>         });\n>         sale = FixedPrice(fixedSales.createFixedSale(fixedSale));\n>         edition.grantRole(edition.MINTER_ROLE(), address(sale));\n>         sale.buy{value: 10 ether}(10);\n>     }\n> \n>     function test_RevertsWhenAfterSelfDestruct_Buy() public {\n>         vm.expectRevert();\n>         sale.buy{value: 1 ether}(1);\n>     }\n> }\n> ```\n> \n> Any purchases after the selfdestruct would revert as shown above.  In order to accurately mock this in Foundry, you can't perform the destruction within a test function since everything would be one large transaction and the code would still exist as far as Foundry is concerned because it's all in the same call context. So you have to move the purchase that selfdestructs the contract into the setup function to demonstrate the behavior.\n\n**[berndartmueller (judge) commented](https://github.com/code-423n4/2022-12-escher-findings/issues/296#issuecomment-1370711821):**\n > @stevennevins You're right with your Foundry example. However, there are subtle nuances to this that make this finding valid.\n> \n> In your Foundry test, the Solidity function call via `sale.buy{value: 1 ether}(1)` at the end, uses the `extcodesize` opcode to check that the contract that is about to be called actually exists and causes an exception if it does not.\n> \n> However, in the above demonstrated PoC, if a transaction gets executed _after_ the contract got destroyed (due to buying the final token id), the transaction does not revert and any value sent along with the transaction will be stored in the contract.\n> \n> I was able to reproduce this behavior with a minimal example contract on Goerli via Remix:\n> \n> ```solidity\n> // SPDX-License-Identifier: UNLICENSED\n> pragma solidity 0.8.7;\n> \n> contract Sale  {\n>     function buy() external payable {\n>         _end();\n>     }\n> \n>     function _end() internal {\n>         selfdestruct(payable(msg.sender));\n>     }\n> }\n> ```\n> \n> Calling the `Sale.buy()` function in Remix twice, once with a value of `1337 wei` and once with `333 wei`:\n> \n> 1) https://goerli.etherscan.io/tx/0x138d2c061ed547ec5bfd4d7d9b03b519f92b5f63a74b73c45a1af6efe202727c\n> 2) https://goerli.etherscan.io/tx/0x7ca9032cf79f0a8e29da17061e7eeafb46edfddff96633dc9bbf5957f1aff142\n> \n> As you can see, the first transaction will destroy the contract, `1337 wei` is sent to the beneficiary (caller). The second transaction succeeds as well. However, the value of `333 wei` is kept at the address of the destroyed contract.\n> \n> After many considerations, I consider **High** to be the appropriate severity. Multiple parallel transactions (e.g. front-runners) will likely try to buy the last NFT IDs, whereas all transactions executed after the last successful buy will render the sent `msg.value` locked in the destroyed contract. Those users lost funds while not receiving any NFTs.\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-12-escher-contest",
  "Code": [
    {
      "filename": "src/minters/FixedPrice.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ISale} from \"../interfaces/ISale.sol\";\nimport {ISaleFactory} from \"../interfaces/ISaleFactory.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract FixedPrice is Initializable, OwnableUpgradeable, ISale {\n    address public immutable factory;\n    /// store nextId and remainingSupply, where nextId increases and remainingSupply decreases to 0\n    /// avoids strict equality of current == final\n    struct Sale {\n        // slot 1\n        uint48 currentId;\n        uint48 finalId;\n        address edition;\n        // slot 2\n        uint96 price;\n        address payable saleReceiver;\n        // slot 3\n        uint96 startTime;\n    }\n\n    /// @notice sale info for this fixed price edition\n    Sale public sale;\n\n    /// @notice Event emitted when sale created\n    /// @param _saleInfo the sale info for the edition\n    event Start(Sale _saleInfo);\n    /// @notice Event emitted when sale ends\n    /// @param _saleInfo the sale info for the edition\n    event End(Sale _saleInfo);\n    /// @notice Event emitted when a user buys an edition\n    /// @param _buyer the address of the buyer\n    /// @param _amount the amount of editions bought\n    /// @param _value the total value of the purchase\n    /// @param _saleInfo the sale info for the edition\n    event Buy(address indexed _buyer, uint256 _amount, uint256 _value, Sale _saleInfo);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        factory = msg.sender;\n        _disableInitializers();\n        sale = Sale(0, 0, address(0), type(uint96).max, payable(0), type(uint96).max);\n    }\n\n    /// @notice Owner can cancel current sale\n    function cancel() external onlyOwner {\n        require(block.timestamp < sale.startTime, \"TOO LATE\");\n        _end(sale);\n    }\n\n    /// @notice buy from a fixed price sale after the sale starts\n    /// @param _amount the amount of editions to buy\n    function buy(uint256 _amount) external payable {\n        Sale memory sale_ = sale;\n        IEscher721 nft = IEscher721(sale_.edition);\n        require(block.timestamp >= sale_.startTime, \"TOO SOON\");\n        require(_amount * sale_.price == msg.value, \"WRONG PRICE\");\n        uint48 newId = uint48(_amount) + sale_.currentId;\n        require(newId <= sale_.finalId, \"TOO MANY\");\n\n        for (uint48 x = sale_.currentId + 1; x <= newId; x++) {\n            nft.mint(msg.sender, x);\n        }\n\n        sale.currentId = newId;\n\n        emit Buy(msg.sender, _amount, msg.value, sale);\n\n        if (newId == sale_.finalId) _end(sale);\n    }\n\n    /// @notice initialize the proxy sale contract\n    /// @param _sale the sale info\n    function initialize(Sale memory _sale) public initializer {\n        sale = _sale;\n        _transferOwnership(_sale.saleReceiver);\n        emit Start(_sale);\n    }\n\n    /// @notice cancel a fixed price sale\n    /// @notice the price of the sale\n    function getPrice() public view returns (uint256) {\n        return sale.price;\n    }\n\n    /// @notice the start time of the sale\n    function startTime() public view returns (uint256) {\n        return sale.startTime;\n    }\n\n    /// @notice the edition contract having the sale\n    function editionContract() public view returns (address) {\n        return sale.edition;\n    }\n\n    /// @notice the number of NFTs still available\n    function available() public view returns (uint256) {\n        return sale.finalId - sale.currentId;\n    }\n\n    /// @notice Owner can cancel current sale\n    /// @param _sale the sale info\n    function _end(Sale memory _sale) internal {\n        emit End(_sale);\n        ISaleFactory(factory).feeReceiver().transfer(address(this).balance / 20);\n        selfdestruct(_sale.saleReceiver);\n    }\n}"
    },
    {
      "filename": "src/minters/OpenEdition.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ISale} from \"../interfaces/ISale.sol\";\nimport {ISaleFactory} from \"../interfaces/ISaleFactory.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract OpenEdition is Initializable, OwnableUpgradeable, ISale {\n    address public immutable factory;\n    /// we use different uints and some weird ordering to pack variables into 32 bytes\n    struct Sale {\n        // slot 1\n        uint72 price;\n        uint24 currentId;\n        address edition;\n        // slot 2\n        uint96 startTime;\n        address payable saleReceiver;\n        // slot 3\n        uint96 endTime;\n    }\n\n    /// @notice sale info for this fixed price edition\n    Sale public sale;\n\n    /// @notice Event emitted when sale created\n    /// @param _saleInfo the sale info for the edition\n    event Start(Sale _saleInfo);\n    /// @notice Event emitted when sale ends\n    /// @param _saleInfo the sale info for the edition\n    event End(Sale _saleInfo);\n    /// @notice Event emitted when a user buys an edition\n    /// @param _buyer the address of the buyer\n    /// @param _amount the amount of editions bought\n    /// @param _value the total value of the purchase\n    /// @param _saleInfo the sale info for the edition\n    event Buy(address indexed _buyer, uint256 _amount, uint256 _value, Sale _saleInfo);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        factory = msg.sender;\n        _disableInitializers();\n        sale = Sale(\n            type(uint72).max,\n            type(uint24).max,\n            address(0),\n            type(uint96).max,\n            payable(0),\n            type(uint96).max\n        );\n    }\n\n    /// @notice buy from a fixed price sale after the sale starts\n    /// @param _amount the amount of editions to buy\n    function buy(uint256 _amount) external payable {\n        uint24 amount = uint24(_amount);\n        Sale memory temp = sale;\n        IEscher721 nft = IEscher721(temp.edition);\n        require(block.timestamp >= temp.startTime, \"TOO SOON\");\n        require(block.timestamp < temp.endTime, \"TOO LATE\");\n        require(amount * sale.price == msg.value, \"WRONG PRICE\");\n        uint24 newId = amount + temp.currentId;\n\n        for (uint24 x = temp.currentId + 1; x <= newId; x++) {\n            nft.mint(msg.sender, x);\n        }\n        sale.currentId = newId;\n\n        emit Buy(msg.sender, amount, msg.value, temp);\n    }\n\n    /// @notice cancel a fixed price sale\n    function cancel() external onlyOwner {\n        require(block.timestamp < sale.startTime, \"TOO LATE\");\n        _end(sale);\n    }\n\n    /// @notice initialize the proxy sale contract\n    /// @param _sale the sale info\n    function initialize(Sale memory _sale) public initializer {\n        sale = _sale;\n        _transferOwnership(sale.saleReceiver);\n        emit Start(_sale);\n    }\n\n    /// @notice finish an open edition and payout the artist\n    function finalize() public {\n        Sale memory temp = sale;\n        require(block.timestamp >= temp.endTime, \"TOO SOON\");\n        ISaleFactory(factory).feeReceiver().transfer(address(this).balance / 20);\n        _end(temp);\n    }\n\n    /// @notice the price of the sale\n    function getPrice() public view returns (uint256) {\n        return sale.price;\n    }\n\n    /// @notice the start time of the sale\n    function startTime() public view returns (uint256) {\n        return sale.startTime;\n    }\n\n    /// @notice how much time is left in the sale\n    function timeLeft() public view returns (uint256) {\n        return sale.endTime > block.timestamp ? sale.endTime - block.timestamp : 0;\n    }\n\n    /// @notice the edition contract having the sale\n    function editionContract() public view returns (address) {\n        return sale.edition;\n    }\n\n    function available() public view returns (uint256) {\n        return sale.endTime > block.timestamp ? type(uint24).max : 0;\n    }\n\n    function _end(Sale memory _sale) internal {\n        emit End(_sale);\n        selfdestruct(_sale.saleReceiver);\n    }\n}"
    }
  ]
}