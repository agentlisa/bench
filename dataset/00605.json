{
  "Title": "Misleading Documentation",
  "Content": "Throughout the codebase, there are multiple instances of misleading documentation:\n\n\n* In the [`loadField`](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/store/src/Storage.sol#L271) function of the `Storage` library, the documentation suggests that the bytes beyond the `length` parameter are zero. However, considering a storage slot as `[ aa..aa bb..bb cc..cc ]` and `bb..bb` being the desired field, then despite its respective `length`, the result would return `cc..cc` as part of the bytes response. As such, the documentation is misleading and can cause consecutive memory corruption. Consider cleaning up the memory space by applying a bitmask or updating the documentation.\n* In the [`zero` function](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/store/src/Storage.sol#L126) of the `Storage` library, the `length` parameter's documentation suggests it should be specified in words. However, in the code, the value is expected to be in bytes. This can lead to a shortcoming in overwrites to zero and therefore in preserving old data, which can lead to additional security issues. Furthermore, the length is rounded up to the nearest 32 bytes multiple which is not clear either. Consider clarifying the `length` documentation.\n* The [comments](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/store/src/Storage.sol#L211-L213) in the `Storage.load` function refer to the masking as \"middle part\" and \"surrounding parts\" whereas it is actually the left and right parts.\n* The code comments for all the `pack` functions of the `PackedCounterLib` library read \"Packs a single value into a PackedCounter\", but [most of them](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/store/src/PackedCounter.sol#L50-L129) pack multiple values.\n* The documentation of the `leftPaddingBits` parameter in the `TightCoder.encode` function is ambiguous. It says, \"The number of bits to pad on the left for each element\", but the code actually [shifts the values by that count to the left](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/store/src/tightcoder/TightCoder.sol#L56). For instance, this means when encoding a `uint120` value, the `leftPaddingBits` count would be 136 as seen in the [`EncodeArray` library](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/store/src/tightcoder/EncodeArray.sol#L199-L205).\n\n\nConsider correcting the documentation to align with the code's behavior. This will help improve the clarity and readability of the codebase.\n\n\n***Update:** Resolved in [pull request #2100](https://github.com/latticexyz/mud/pull/2100).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "packages/store/src/Storage.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { leftMask } from \"./leftMask.sol\";\nimport { Memory } from \"./Memory.sol\";\n\n/**\n * @title Storage Library\n * @dev Provides functions for low-level storage manipulation, including storing and retrieving bytes.\n */\nlibrary Storage {\n  /**\n   * @notice Store a single word of data at a specific storage pointer.\n   * @param storagePointer The location to store the data.\n   * @param data The 32-byte word of data to store.\n   */\n  function store(uint256 storagePointer, bytes32 data) internal {\n    assembly {\n      sstore(storagePointer, data)\n    }\n  }\n\n  /**\n   * @notice Store bytes of data at a specific storage pointer and offset.\n   * @param storagePointer The base storage location.\n   * @param offset Offset within the storage location.\n   * @param data Bytes to store.\n   */\n  function store(uint256 storagePointer, uint256 offset, bytes memory data) internal {\n    store(storagePointer, offset, Memory.dataPointer(data), data.length);\n  }\n\n  /**\n   * @notice Stores raw bytes to storage at a given pointer, offset, and length, keeping the rest of the word intact.\n   * @param storagePointer The base storage location.\n   * @param offset Offset within the storage location.\n   * @param memoryPointer Pointer to the start of the data in memory.\n   * @param length Length of the data in bytes.\n   */\n  function store(uint256 storagePointer, uint256 offset, uint256 memoryPointer, uint256 length) internal {\n    if (offset > 0) {\n      // Support offsets that are greater than 32 bytes by incrementing the storagePointer and decrementing the offset\n      if (offset >= 32) {\n        unchecked {\n          storagePointer += offset / 32;\n          offset %= 32;\n        }\n      }\n\n      // For the first word, if there is an offset, apply a mask to beginning\n      if (offset > 0) {\n        // Get the word's remaining length after the offset\n        uint256 wordRemainder;\n        // (safe because of `offset %= 32` at the start)\n        unchecked {\n          wordRemainder = 32 - offset;\n        }\n\n        uint256 mask = leftMask(length);\n        /// @solidity memory-safe-assembly\n        assembly {\n          // Load data from memory and offset it to match storage\n          let bitOffset := mul(offset, 8)\n          mask := shr(bitOffset, mask)\n          let offsetData := shr(bitOffset, mload(memoryPointer))\n\n          sstore(\n            storagePointer,\n            or(\n              // Store the middle part\n              and(offsetData, mask),\n              // Preserve the surrounding parts\n              and(sload(storagePointer), not(mask))\n            )\n          )\n        }\n        // Return if done\n        if (length <= wordRemainder) return;\n\n        // Advance pointers\n        // (safe because of `length <= wordRemainder` earlier)\n        unchecked {\n          storagePointer += 1;\n          memoryPointer += wordRemainder;\n          length -= wordRemainder;\n        }\n      }\n    }\n\n    // Store full words\n    while (length >= 32) {\n      /// @solidity memory-safe-assembly\n      assembly {\n        sstore(storagePointer, mload(memoryPointer))\n      }\n      unchecked {\n        storagePointer += 1;\n        memoryPointer += 32;\n        length -= 32;\n      }\n    }\n\n    // For the last partial word, apply a mask to the end\n    if (length > 0) {\n      uint256 mask = leftMask(length);\n      /// @solidity memory-safe-assembly\n      assembly {\n        sstore(\n          storagePointer,\n          or(\n            // store the left part\n            and(mload(memoryPointer), mask),\n            // preserve the right part\n            and(sload(storagePointer), not(mask))\n          )\n        )\n      }\n    }\n  }\n\n  /**\n   * @notice Set multiple storage locations to zero.\n   * @param storagePointer The starting storage location.\n   * @param length The number of storage locations to set to zero.\n   */\n  function zero(uint256 storagePointer, uint256 length) internal {\n    // Ceil division to round up to the nearest word\n    uint256 limit = storagePointer + (length + 31) / 32;\n    while (storagePointer < limit) {\n      /// @solidity memory-safe-assembly\n      assembly {\n        sstore(storagePointer, 0)\n        storagePointer := add(storagePointer, 1)\n      }\n    }\n  }\n\n  /**\n   * @notice Load a single word of data from a specific storage pointer.\n   * @param storagePointer The location to load the data from.\n   * @return word The loaded 32-byte word of data.\n   */\n  function load(uint256 storagePointer) internal view returns (bytes32 word) {\n    assembly {\n      word := sload(storagePointer)\n    }\n  }\n\n  /**\n   * @notice Load raw bytes from storage at a given pointer, offset, and length.\n   * @param storagePointer The base storage location.\n   * @param length Length of the data in bytes.\n   * @param offset Offset within the storage location.\n   * @return result The loaded bytes of data.\n   */\n  function load(uint256 storagePointer, uint256 length, uint256 offset) internal view returns (bytes memory result) {\n    uint256 memoryPointer;\n    /// @solidity memory-safe-assembly\n    assembly {\n      // Solidity's YulUtilFunctions::roundUpFunction\n      function round_up_to_mul_of_32(value) -> _result {\n        _result := and(add(value, 31), not(31))\n      }\n\n      // Allocate memory\n      result := mload(0x40)\n      memoryPointer := add(result, 0x20)\n      mstore(0x40, round_up_to_mul_of_32(add(memoryPointer, length)))\n      // Store length\n      mstore(result, length)\n    }\n    load(storagePointer, length, offset, memoryPointer);\n    return result;\n  }\n\n  /**\n   * @notice Append raw bytes from storage at a given pointer, offset, and length to a specific memory pointer.\n   * @param storagePointer The base storage location.\n   * @param length Length of the data in bytes.\n   * @param offset Offset within the storage location.\n   * @param memoryPointer Pointer to the location in memory to append the data.\n   */\n  function load(uint256 storagePointer, uint256 length, uint256 offset, uint256 memoryPointer) internal view {\n    if (offset > 0) {\n      // Support offsets that are greater than 32 bytes by incrementing the storagePointer and decrementing the offset\n      if (offset >= 32) {\n        unchecked {\n          storagePointer += offset / 32;\n          offset %= 32;\n        }\n      }\n\n      // For the first word, if there is an offset, apply a mask to beginning\n      if (offset > 0) {\n        // Get the word's remaining length after the offset\n        uint256 wordRemainder;\n        // (safe because of `offset %= 32` at the start)\n        unchecked {\n          wordRemainder = 32 - offset;\n        }\n\n        uint256 mask = leftMask(wordRemainder);\n        /// @solidity memory-safe-assembly\n        assembly {\n          // Load data from storage and offset it to match memory\n          let offsetData := shl(mul(offset, 8), sload(storagePointer))\n\n          mstore(\n            memoryPointer,\n            or(\n              // store the middle part\n              and(offsetData, mask),\n              // preserve the surrounding parts\n              and(mload(memoryPointer), not(mask))\n            )\n          )\n        }\n        // Return if done\n        if (length <= wordRemainder) return;\n\n        // Advance pointers\n        // (safe because of `length <= wordRemainder` earlier)\n        unchecked {\n          storagePointer += 1;\n          memoryPointer += wordRemainder;\n          length -= wordRemainder;\n        }\n      }\n    }\n\n    // Load full words\n    while (length >= 32) {\n      /// @solidity memory-safe-assembly\n      assembly {\n        mstore(memoryPointer, sload(storagePointer))\n      }\n      unchecked {\n        storagePointer += 1;\n        memoryPointer += 32;\n        length -= 32;\n      }\n    }\n\n    // For the last partial word, apply a mask to the end\n    if (length > 0) {\n      uint256 mask = leftMask(length);\n      /// @solidity memory-safe-assembly\n      assembly {\n        mstore(\n          memoryPointer,\n          or(\n            // store the left part\n            and(sload(storagePointer), mask),\n            // preserve the right part\n            and(mload(memoryPointer), not(mask))\n          )\n        )\n      }\n    }\n  }\n\n  /**\n   * @notice Load up to 32 bytes from storage at a given pointer and offset.\n   * @dev Since fields are tightly packed, they can span more than one slot.\n   * Since the they're max 32 bytes, they can span at most 2 slots.\n   * @param storagePointer The base storage location.\n   * @param length Length of the data in bytes.\n   * @param offset Offset within the storage location.\n   * @return result The loaded bytes, left-aligned bytes. Bytes beyond the length are zeroed.\n   */\n  function loadField(uint256 storagePointer, uint256 length, uint256 offset) internal view returns (bytes32 result) {\n    if (offset >= 32) {\n      unchecked {\n        storagePointer += offset / 32;\n        offset %= 32;\n      }\n    }\n\n    // Extra data past length is not truncated\n    // This assumes that the caller will handle the overflow bits appropriately\n    assembly {\n      result := shl(mul(offset, 8), sload(storagePointer))\n    }\n\n    uint256 wordRemainder;\n    // (safe because of `offset %= 32` at the start)\n    unchecked {\n      wordRemainder = 32 - offset;\n    }\n\n    // Read from the next slot if field spans 2 slots\n    if (length > wordRemainder) {\n      assembly {\n        result := or(result, shr(mul(wordRemainder, 8), sload(add(storagePointer, 1))))\n      }\n    }\n  }\n}"
    },
    {
      "filename": "packages/store/src/Storage.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { leftMask } from \"./leftMask.sol\";\nimport { Memory } from \"./Memory.sol\";\n\n/**\n * @title Storage Library\n * @dev Provides functions for low-level storage manipulation, including storing and retrieving bytes.\n */\nlibrary Storage {\n  /**\n   * @notice Store a single word of data at a specific storage pointer.\n   * @param storagePointer The location to store the data.\n   * @param data The 32-byte word of data to store.\n   */\n  function store(uint256 storagePointer, bytes32 data) internal {\n    assembly {\n      sstore(storagePointer, data)\n    }\n  }\n\n  /**\n   * @notice Store bytes of data at a specific storage pointer and offset.\n   * @param storagePointer The base storage location.\n   * @param offset Offset within the storage location.\n   * @param data Bytes to store.\n   */\n  function store(uint256 storagePointer, uint256 offset, bytes memory data) internal {\n    store(storagePointer, offset, Memory.dataPointer(data), data.length);\n  }\n\n  /**\n   * @notice Stores raw bytes to storage at a given pointer, offset, and length, keeping the rest of the word intact.\n   * @param storagePointer The base storage location.\n   * @param offset Offset within the storage location.\n   * @param memoryPointer Pointer to the start of the data in memory.\n   * @param length Length of the data in bytes.\n   */\n  function store(uint256 storagePointer, uint256 offset, uint256 memoryPointer, uint256 length) internal {\n    if (offset > 0) {\n      // Support offsets that are greater than 32 bytes by incrementing the storagePointer and decrementing the offset\n      if (offset >= 32) {\n        unchecked {\n          storagePointer += offset / 32;\n          offset %= 32;\n        }\n      }\n\n      // For the first word, if there is an offset, apply a mask to beginning\n      if (offset > 0) {\n        // Get the word's remaining length after the offset\n        uint256 wordRemainder;\n        // (safe because of `offset %= 32` at the start)\n        unchecked {\n          wordRemainder = 32 - offset;\n        }\n\n        uint256 mask = leftMask(length);\n        /// @solidity memory-safe-assembly\n        assembly {\n          // Load data from memory and offset it to match storage\n          let bitOffset := mul(offset, 8)\n          mask := shr(bitOffset, mask)\n          let offsetData := shr(bitOffset, mload(memoryPointer))\n\n          sstore(\n            storagePointer,\n            or(\n              // Store the middle part\n              and(offsetData, mask),\n              // Preserve the surrounding parts\n              and(sload(storagePointer), not(mask))\n            )\n          )\n        }\n        // Return if done\n        if (length <= wordRemainder) return;\n\n        // Advance pointers\n        // (safe because of `length <= wordRemainder` earlier)\n        unchecked {\n          storagePointer += 1;\n          memoryPointer += wordRemainder;\n          length -= wordRemainder;\n        }\n      }\n    }\n\n    // Store full words\n    while (length >= 32) {\n      /// @solidity memory-safe-assembly\n      assembly {\n        sstore(storagePointer, mload(memoryPointer))\n      }\n      unchecked {\n        storagePointer += 1;\n        memoryPointer += 32;\n        length -= 32;\n      }\n    }\n\n    // For the last partial word, apply a mask to the end\n    if (length > 0) {\n      uint256 mask = leftMask(length);\n      /// @solidity memory-safe-assembly\n      assembly {\n        sstore(\n          storagePointer,\n          or(\n            // store the left part\n            and(mload(memoryPointer), mask),\n            // preserve the right part\n            and(sload(storagePointer), not(mask))\n          )\n        )\n      }\n    }\n  }\n\n  /**\n   * @notice Set multiple storage locations to zero.\n   * @param storagePointer The starting storage location.\n   * @param length The number of storage locations to set to zero.\n   */\n  function zero(uint256 storagePointer, uint256 length) internal {\n    // Ceil division to round up to the nearest word\n    uint256 limit = storagePointer + (length + 31) / 32;\n    while (storagePointer < limit) {\n      /// @solidity memory-safe-assembly\n      assembly {\n        sstore(storagePointer, 0)\n        storagePointer := add(storagePointer, 1)\n      }\n    }\n  }\n\n  /**\n   * @notice Load a single word of data from a specific storage pointer.\n   * @param storagePointer The location to load the data from.\n   * @return word The loaded 32-byte word of data.\n   */\n  function load(uint256 storagePointer) internal view returns (bytes32 word) {\n    assembly {\n      word := sload(storagePointer)\n    }\n  }\n\n  /**\n   * @notice Load raw bytes from storage at a given pointer, offset, and length.\n   * @param storagePointer The base storage location.\n   * @param length Length of the data in bytes.\n   * @param offset Offset within the storage location.\n   * @return result The loaded bytes of data.\n   */\n  function load(uint256 storagePointer, uint256 length, uint256 offset) internal view returns (bytes memory result) {\n    uint256 memoryPointer;\n    /// @solidity memory-safe-assembly\n    assembly {\n      // Solidity's YulUtilFunctions::roundUpFunction\n      function round_up_to_mul_of_32(value) -> _result {\n        _result := and(add(value, 31), not(31))\n      }\n\n      // Allocate memory\n      result := mload(0x40)\n      memoryPointer := add(result, 0x20)\n      mstore(0x40, round_up_to_mul_of_32(add(memoryPointer, length)))\n      // Store length\n      mstore(result, length)\n    }\n    load(storagePointer, length, offset, memoryPointer);\n    return result;\n  }\n\n  /**\n   * @notice Append raw bytes from storage at a given pointer, offset, and length to a specific memory pointer.\n   * @param storagePointer The base storage location.\n   * @param length Length of the data in bytes.\n   * @param offset Offset within the storage location.\n   * @param memoryPointer Pointer to the location in memory to append the data.\n   */\n  function load(uint256 storagePointer, uint256 length, uint256 offset, uint256 memoryPointer) internal view {\n    if (offset > 0) {\n      // Support offsets that are greater than 32 bytes by incrementing the storagePointer and decrementing the offset\n      if (offset >= 32) {\n        unchecked {\n          storagePointer += offset / 32;\n          offset %= 32;\n        }\n      }\n\n      // For the first word, if there is an offset, apply a mask to beginning\n      if (offset > 0) {\n        // Get the word's remaining length after the offset\n        uint256 wordRemainder;\n        // (safe because of `offset %= 32` at the start)\n        unchecked {\n          wordRemainder = 32 - offset;\n        }\n\n        uint256 mask = leftMask(wordRemainder);\n        /// @solidity memory-safe-assembly\n        assembly {\n          // Load data from storage and offset it to match memory\n          let offsetData := shl(mul(offset, 8), sload(storagePointer))\n\n          mstore(\n            memoryPointer,\n            or(\n              // store the middle part\n              and(offsetData, mask),\n              // preserve the surrounding parts\n              and(mload(memoryPointer), not(mask))\n            )\n          )\n        }\n        // Return if done\n        if (length <= wordRemainder) return;\n\n        // Advance pointers\n        // (safe because of `length <= wordRemainder` earlier)\n        unchecked {\n          storagePointer += 1;\n          memoryPointer += wordRemainder;\n          length -= wordRemainder;\n        }\n      }\n    }\n\n    // Load full words\n    while (length >= 32) {\n      /// @solidity memory-safe-assembly\n      assembly {\n        mstore(memoryPointer, sload(storagePointer))\n      }\n      unchecked {\n        storagePointer += 1;\n        memoryPointer += 32;\n        length -= 32;\n      }\n    }\n\n    // For the last partial word, apply a mask to the end\n    if (length > 0) {\n      uint256 mask = leftMask(length);\n      /// @solidity memory-safe-assembly\n      assembly {\n        mstore(\n          memoryPointer,\n          or(\n            // store the left part\n            and(sload(storagePointer), mask),\n            // preserve the right part\n            and(mload(memoryPointer), not(mask))\n          )\n        )\n      }\n    }\n  }\n\n  /**\n   * @notice Load up to 32 bytes from storage at a given pointer and offset.\n   * @dev Since fields are tightly packed, they can span more than one slot.\n   * Since the they're max 32 bytes, they can span at most 2 slots.\n   * @param storagePointer The base storage location.\n   * @param length Length of the data in bytes.\n   * @param offset Offset within the storage location.\n   * @return result The loaded bytes, left-aligned bytes. Bytes beyond the length are zeroed.\n   */\n  function loadField(uint256 storagePointer, uint256 length, uint256 offset) internal view returns (bytes32 result) {\n    if (offset >= 32) {\n      unchecked {\n        storagePointer += offset / 32;\n        offset %= 32;\n      }\n    }\n\n    // Extra data past length is not truncated\n    // This assumes that the caller will handle the overflow bits appropriately\n    assembly {\n      result := shl(mul(offset, 8), sload(storagePointer))\n    }\n\n    uint256 wordRemainder;\n    // (safe because of `offset %= 32` at the start)\n    unchecked {\n      wordRemainder = 32 - offset;\n    }\n\n    // Read from the next slot if field spans 2 slots\n    if (length > wordRemainder) {\n      assembly {\n        result := or(result, shr(mul(wordRemainder, 8), sload(add(storagePointer, 1))))\n      }\n    }\n  }\n}"
    },
    {
      "filename": "packages/store/src/Storage.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { leftMask } from \"./leftMask.sol\";\nimport { Memory } from \"./Memory.sol\";\n\n/**\n * @title Storage Library\n * @dev Provides functions for low-level storage manipulation, including storing and retrieving bytes.\n */\nlibrary Storage {\n  /**\n   * @notice Store a single word of data at a specific storage pointer.\n   * @param storagePointer The location to store the data.\n   * @param data The 32-byte word of data to store.\n   */\n  function store(uint256 storagePointer, bytes32 data) internal {\n    assembly {\n      sstore(storagePointer, data)\n    }\n  }\n\n  /**\n   * @notice Store bytes of data at a specific storage pointer and offset.\n   * @param storagePointer The base storage location.\n   * @param offset Offset within the storage location.\n   * @param data Bytes to store.\n   */\n  function store(uint256 storagePointer, uint256 offset, bytes memory data) internal {\n    store(storagePointer, offset, Memory.dataPointer(data), data.length);\n  }\n\n  /**\n   * @notice Stores raw bytes to storage at a given pointer, offset, and length, keeping the rest of the word intact.\n   * @param storagePointer The base storage location.\n   * @param offset Offset within the storage location.\n   * @param memoryPointer Pointer to the start of the data in memory.\n   * @param length Length of the data in bytes.\n   */\n  function store(uint256 storagePointer, uint256 offset, uint256 memoryPointer, uint256 length) internal {\n    if (offset > 0) {\n      // Support offsets that are greater than 32 bytes by incrementing the storagePointer and decrementing the offset\n      if (offset >= 32) {\n        unchecked {\n          storagePointer += offset / 32;\n          offset %= 32;\n        }\n      }\n\n      // For the first word, if there is an offset, apply a mask to beginning\n      if (offset > 0) {\n        // Get the word's remaining length after the offset\n        uint256 wordRemainder;\n        // (safe because of `offset %= 32` at the start)\n        unchecked {\n          wordRemainder = 32 - offset;\n        }\n\n        uint256 mask = leftMask(length);\n        /// @solidity memory-safe-assembly\n        assembly {\n          // Load data from memory and offset it to match storage\n          let bitOffset := mul(offset, 8)\n          mask := shr(bitOffset, mask)\n          let offsetData := shr(bitOffset, mload(memoryPointer))\n\n          sstore(\n            storagePointer,\n            or(\n              // Store the middle part\n              and(offsetData, mask),\n              // Preserve the surrounding parts\n              and(sload(storagePointer), not(mask))\n            )\n          )\n        }\n        // Return if done\n        if (length <= wordRemainder) return;\n\n        // Advance pointers\n        // (safe because of `length <= wordRemainder` earlier)\n        unchecked {\n          storagePointer += 1;\n          memoryPointer += wordRemainder;\n          length -= wordRemainder;\n        }\n      }\n    }\n\n    // Store full words\n    while (length >= 32) {\n      /// @solidity memory-safe-assembly\n      assembly {\n        sstore(storagePointer, mload(memoryPointer))\n      }\n      unchecked {\n        storagePointer += 1;\n        memoryPointer += 32;\n        length -= 32;\n      }\n    }\n\n    // For the last partial word, apply a mask to the end\n    if (length > 0) {\n      uint256 mask = leftMask(length);\n      /// @solidity memory-safe-assembly\n      assembly {\n        sstore(\n          storagePointer,\n          or(\n            // store the left part\n            and(mload(memoryPointer), mask),\n            // preserve the right part\n            and(sload(storagePointer), not(mask))\n          )\n        )\n      }\n    }\n  }\n\n  /**\n   * @notice Set multiple storage locations to zero.\n   * @param storagePointer The starting storage location.\n   * @param length The number of storage locations to set to zero.\n   */\n  function zero(uint256 storagePointer, uint256 length) internal {\n    // Ceil division to round up to the nearest word\n    uint256 limit = storagePointer + (length + 31) / 32;\n    while (storagePointer < limit) {\n      /// @solidity memory-safe-assembly\n      assembly {\n        sstore(storagePointer, 0)\n        storagePointer := add(storagePointer, 1)\n      }\n    }\n  }\n\n  /**\n   * @notice Load a single word of data from a specific storage pointer.\n   * @param storagePointer The location to load the data from.\n   * @return word The loaded 32-byte word of data.\n   */\n  function load(uint256 storagePointer) internal view returns (bytes32 word) {\n    assembly {\n      word := sload(storagePointer)\n    }\n  }\n\n  /**\n   * @notice Load raw bytes from storage at a given pointer, offset, and length.\n   * @param storagePointer The base storage location.\n   * @param length Length of the data in bytes.\n   * @param offset Offset within the storage location.\n   * @return result The loaded bytes of data.\n   */\n  function load(uint256 storagePointer, uint256 length, uint256 offset) internal view returns (bytes memory result) {\n    uint256 memoryPointer;\n    /// @solidity memory-safe-assembly\n    assembly {\n      // Solidity's YulUtilFunctions::roundUpFunction\n      function round_up_to_mul_of_32(value) -> _result {\n        _result := and(add(value, 31), not(31))\n      }\n\n      // Allocate memory\n      result := mload(0x40)\n      memoryPointer := add(result, 0x20)\n      mstore(0x40, round_up_to_mul_of_32(add(memoryPointer, length)))\n      // Store length\n      mstore(result, length)\n    }\n    load(storagePointer, length, offset, memoryPointer);\n    return result;\n  }\n\n  /**\n   * @notice Append raw bytes from storage at a given pointer, offset, and length to a specific memory pointer.\n   * @param storagePointer The base storage location.\n   * @param length Length of the data in bytes.\n   * @param offset Offset within the storage location.\n   * @param memoryPointer Pointer to the location in memory to append the data.\n   */\n  function load(uint256 storagePointer, uint256 length, uint256 offset, uint256 memoryPointer) internal view {\n    if (offset > 0) {\n      // Support offsets that are greater than 32 bytes by incrementing the storagePointer and decrementing the offset\n      if (offset >= 32) {\n        unchecked {\n          storagePointer += offset / 32;\n          offset %= 32;\n        }\n      }\n\n      // For the first word, if there is an offset, apply a mask to beginning\n      if (offset > 0) {\n        // Get the word's remaining length after the offset\n        uint256 wordRemainder;\n        // (safe because of `offset %= 32` at the start)\n        unchecked {\n          wordRemainder = 32 - offset;\n        }\n\n        uint256 mask = leftMask(wordRemainder);\n        /// @solidity memory-safe-assembly\n        assembly {\n          // Load data from storage and offset it to match memory\n          let offsetData := shl(mul(offset, 8), sload(storagePointer))\n\n          mstore(\n            memoryPointer,\n            or(\n              // store the middle part\n              and(offsetData, mask),\n              // preserve the surrounding parts\n              and(mload(memoryPointer), not(mask))\n            )\n          )\n        }\n        // Return if done\n        if (length <= wordRemainder) return;\n\n        // Advance pointers\n        // (safe because of `length <= wordRemainder` earlier)\n        unchecked {\n          storagePointer += 1;\n          memoryPointer += wordRemainder;\n          length -= wordRemainder;\n        }\n      }\n    }\n\n    // Load full words\n    while (length >= 32) {\n      /// @solidity memory-safe-assembly\n      assembly {\n        mstore(memoryPointer, sload(storagePointer))\n      }\n      unchecked {\n        storagePointer += 1;\n        memoryPointer += 32;\n        length -= 32;\n      }\n    }\n\n    // For the last partial word, apply a mask to the end\n    if (length > 0) {\n      uint256 mask = leftMask(length);\n      /// @solidity memory-safe-assembly\n      assembly {\n        mstore(\n          memoryPointer,\n          or(\n            // store the left part\n            and(sload(storagePointer), mask),\n            // preserve the right part\n            and(mload(memoryPointer), not(mask))\n          )\n        )\n      }\n    }\n  }\n\n  /**\n   * @notice Load up to 32 bytes from storage at a given pointer and offset.\n   * @dev Since fields are tightly packed, they can span more than one slot.\n   * Since the they're max 32 bytes, they can span at most 2 slots.\n   * @param storagePointer The base storage location.\n   * @param length Length of the data in bytes.\n   * @param offset Offset within the storage location.\n   * @return result The loaded bytes, left-aligned bytes. Bytes beyond the length are zeroed.\n   */\n  function loadField(uint256 storagePointer, uint256 length, uint256 offset) internal view returns (bytes32 result) {\n    if (offset >= 32) {\n      unchecked {\n        storagePointer += offset / 32;\n        offset %= 32;\n      }\n    }\n\n    // Extra data past length is not truncated\n    // This assumes that the caller will handle the overflow bits appropriately\n    assembly {\n      result := shl(mul(offset, 8), sload(storagePointer))\n    }\n\n    uint256 wordRemainder;\n    // (safe because of `offset %= 32` at the start)\n    unchecked {\n      wordRemainder = 32 - offset;\n    }\n\n    // Read from the next slot if field spans 2 slots\n    if (length > wordRemainder) {\n      assembly {\n        result := or(result, shr(mul(wordRemainder, 8), sload(add(storagePointer, 1))))\n      }\n    }\n  }\n}"
    },
    {
      "filename": "packages/store/src/PackedCounter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\n/**\n * @title PackedCounter Type Definition\n * @dev Describes how the packed counter is structured.\n * - 0x00-0x06 The least significant 7 bytes (uint56) represent the total byte length of dynamic (variable length) data.\n * - 0x07-0xB The next five bytes (uint40) represent the length of the first dynamic field.\n * - 0x0C-0x10 Followed by the length of the second dynamic field\n * - 0x11-0x15 Length of the third dynamic field\n * - 0x16-0x1A Length of fourth dynamic field\n * - 0x1B-0x1F Length of fifth dynamic field\n */\ntype PackedCounter is bytes32;\n\nusing PackedCounterInstance for PackedCounter global;\n\n// Constants for packed counter handling:\n\n// Number of bits for the 7-byte accumulator\nuint256 constant ACC_BITS = 7 * 8;\n// Number of bits for the 5-byte sections\nuint256 constant VAL_BITS = 5 * 8;\n// Maximum value of a 5-byte section\nuint256 constant MAX_VAL = type(uint40).max;\n\n/**\n * @title PackedCounter Library\n * @notice Static functions for handling PackedCounter type.\n * @dev Provides utility functions to pack values into a PackedCounter.\n * The caller must ensure that the value arguments are <= MAX_VAL.\n */\nlibrary PackedCounterLib {\n  /**\n   * @notice Packs a single value into a PackedCounter.\n   * @dev Encodes the given value 'a' into the structure of a PackedCounter. The packed counter's accumulator\n   * will be set to 'a', and the first value slot of the PackedCounter will also be set to 'a'.\n   * @param a The length of the first dynamic field's data.\n   * @return The resulting PackedCounter containing the encoded value.\n   */\n  function pack(uint256 a) internal pure returns (PackedCounter) {\n    uint256 packedCounter;\n    unchecked {\n      packedCounter = a;\n      packedCounter |= (uint256(a) << (ACC_BITS + VAL_BITS * 0));\n    }\n    return PackedCounter.wrap(bytes32(packedCounter));\n  }\n\n  /**\n   * @notice Packs a single value into a PackedCounter.\n   * @dev Encodes the given values 'a'-'b' into the structure of a PackedCounter.\n   * @param a The length of the first dynamic field's data.\n   * @param b The length of the second dynamic field's data.\n   * @return The resulting PackedCounter containing the encoded values.\n   */\n  function pack(uint256 a, uint256 b) internal pure returns (PackedCounter) {\n    uint256 packedCounter;\n    unchecked {\n      packedCounter = a + b;\n      packedCounter |= (uint256(a) << (ACC_BITS + VAL_BITS * 0));\n      packedCounter |= (uint256(b) << (ACC_BITS + VAL_BITS * 1));\n    }\n    return PackedCounter.wrap(bytes32(packedCounter));\n  }\n\n  /**\n   * @notice Packs a single value into a PackedCounter.\n   * @dev Encodes the given values 'a'-'c' into the structure of a PackedCounter.\n   * @param a The length of the first dynamic field's data.\n   * @param b The length of the second dynamic field's data.\n   * @param c The length of the third dynamic field's data.\n   * @return The resulting PackedCounter containing the encoded values.\n   */\n  function pack(uint256 a, uint256 b, uint256 c) internal pure returns (PackedCounter) {\n    uint256 packedCounter;\n    unchecked {\n      packedCounter = a + b + c;\n      packedCounter |= (uint256(a) << (ACC_BITS + VAL_BITS * 0));\n      packedCounter |= (uint256(b) << (ACC_BITS + VAL_BITS * 1));\n      packedCounter |= (uint256(c) << (ACC_BITS + VAL_BITS * 2));\n    }\n    return PackedCounter.wrap(bytes32(packedCounter));\n  }\n\n  /**\n   * @notice Packs a single value into a PackedCounter.\n   * @dev Encodes the given values 'a'-'d' into the structure of a PackedCounter.\n   * @param a The length of the first dynamic field's data.\n   * @param b The length of the second dynamic field's data.\n   * @param c The length of the third dynamic field's data.\n   * @param d The length of the fourth dynamic field's data.\n   * @return The resulting PackedCounter containing the encoded values.\n   */\n  function pack(uint256 a, uint256 b, uint256 c, uint256 d) internal pure returns (PackedCounter) {\n    uint256 packedCounter;\n    unchecked {\n      packedCounter = a + b + c + d;\n      packedCounter |= (uint256(a) << (ACC_BITS + VAL_BITS * 0));\n      packedCounter |= (uint256(b) << (ACC_BITS + VAL_BITS *"
    }
  ]
}