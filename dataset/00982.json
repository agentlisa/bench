{
  "Title": "Incorrect depositable shortToken amount calculation in Delta neutral vaults",
  "Content": "# Incorrect depositable shortToken amount calculation in Delta neutral vaults\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXReader.sol#L264-L270\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXReader.sol#L264-L270</a>\n\n\n## Vulnerability Details\nWhen calculating the maximum possible depositable amount for delta neutral vaults, `_maxTokenBLending` is calculated incorrectly.\n```solidity\n    if (self.delta == GMXTypes.Delta.Neutral) {\n      (uint256 _tokenAWeight, ) = tokenWeights(self);\n\n\n      uint256 _maxTokenALending = convertToUsdValue(\n        self,\n        address(self.tokenA),\n        self.tokenALendingVault.totalAvailableAsset()\n      ) * SAFE_MULTIPLIER\n        / (self.leverage * _tokenAWeight / SAFE_MULTIPLIER);\n\n\n      uint256 _maxTokenBLending = convertToUsdValue(\n        self,\n        address(self.tokenB),\n        self.tokenBLendingVault.totalAvailableAsset()\n      ) * SAFE_MULTIPLIER\n        / (self.leverage * _tokenAWeight / SAFE_MULTIPLIER)\n        - 1e18;\n```\nhttps://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXReader.sol#L254-L270\n\nIf a user wants to deposit `v` value to a `l` leveraged delta neutral vault with token weights `a` and `b`, the calculation of required lending amount would be as follows:\n```\nTotal value to deposit to GMX = lv\nValue of tokens to short = lva\nHence this value will be borrowed from the tokenA lending vault\nRemaining value to borrow (from tokenB lending vault) = lv - lva - v (deposit value provided by user)\nHence if there is Tb value of tokens in tokenB lending vault, v <= Tb / (l - la - 1)\n``` \n\n## Impact\nDeposit attempts can revert even when there is enough tokens to lend causing inefficiency, loss of gas for depositors and deviation from the protocol specification.\n\n## Recommendations\nChange the formula to the correct one.\n```diff\ndiff --git a/contracts/strategy/gmx/GMXReader.sol b/contracts/strategy/gmx/GMXReader.sol\nindex 73bb111..ae819c4 100644\n--- a/contracts/strategy/gmx/GMXReader.sol\n+++ b/contracts/strategy/gmx/GMXReader.sol\n@@ -266,8 +266,7 @@ library GMXReader {\n         address(self.tokenB),\n         self.tokenBLendingVault.totalAvailableAsset()\n       ) * SAFE_MULTIPLIER\n-        / (self.leverage * _tokenAWeight / SAFE_MULTIPLIER)\n-        - 1e18;\n+        / (self.leverage - (self.leverage *_tokenAWeight / SAFE_MULTIPLIER) - 1e18);\n \n       _additionalCapacity = _maxTokenALending > _maxTokenBLending ? _maxTokenBLending : _maxTokenALending;\n     }\n\n```",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "contracts/strategy/gmx/GMXReader.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\n\n/**\n  * @title GMXReader\n  * @author Steadefi\n  * @notice Re-usable library functions for reading data and values for Steadefi leveraged vaults\n*/\nlibrary GMXReader {\n  using SafeCast for uint256;\n\n  /* =================== CONSTANTS FUNCTIONS ================= */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function svTokenValue(GMXTypes.Store storage self) public view returns (uint256) {\n    uint256 equityValue_ = equityValue(self);\n    uint256 totalSupply_ = IERC20(address(self.vault)).totalSupply();\n    if (equityValue_ == 0 || totalSupply_ == 0) return SAFE_MULTIPLIER;\n    return equityValue_ * SAFE_MULTIPLIER / totalSupply_;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function pendingFee(GMXTypes.Store storage self) public view returns (uint256) {\n    uint256 totalSupply_ = IERC20(address(self.vault)).totalSupply();\n    uint256 _secondsFromLastCollection = block.timestamp - self.lastFeeCollected;\n    return (totalSupply_ * self.feePerSecond * _secondsFromLastCollection) / SAFE_MULTIPLIER;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function valueToShares(\n    GMXTypes.Store storage self,\n    uint256 value,\n    uint256 currentEquity\n  ) public view returns (uint256) {\n    uint256 _sharesSupply = IERC20(address(self.vault)).totalSupply() + pendingFee(self);\n    if (_sharesSupply == 0 || currentEquity == 0) return value;\n    return value * _sharesSupply / currentEquity;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function convertToUsdValue(\n    GMXTypes.Store storage self,\n    address token,\n    uint256 amt\n  ) public view returns (uint256) {\n    return amt * 10**(18 - IERC20Metadata(token).decimals())\n                * self.chainlinkOracle.consultIn18Decimals(token)\n                / SAFE_MULTIPLIER;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function tokenWeights(GMXTypes.Store storage self) public view returns (uint256, uint256) {\n    // Get amounts of tokenA and tokenB in liquidity pool in token decimals\n    (uint256 _reserveA, uint256 _reserveB) = self.gmxOracle.getLpTokenReserves(\n      address(self.lpToken),\n      address(self.tokenA),\n      address(self.tokenA),\n      address(self.tokenB)\n    );\n\n    // Get value of tokenA and tokenB in 1e18\n    uint256 _tokenAValue = convertToUsdValue(self, address(self.tokenA), _reserveA);\n    uint256 _tokenBValue = convertToUsdValue(self, address(self.tokenB), _reserveB);\n\n    uint256 _totalLpValue = _tokenAValue + _tokenBValue;\n\n    return (\n      _tokenAValue * SAFE_MULTIPLIER / _totalLpValue,\n      _tokenBValue * SAFE_MULTIPLIER / _totalLpValue\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function assetValue(GMXTypes.Store storage self) public view returns (uint256) {\n    return lpAmt(self) * self.gmxOracle.getLpTokenValue(\n      address(self.lpToken),\n      address(self.tokenA),\n      address(self.tokenA),\n      address(self.tokenB),\n      false,\n      false\n    ) / SAFE_MULTIPLIER;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function debtValue(GMXTypes.Store storage self) public view returns (uint256, uint256) {\n    (uint256 _tokenADebtAmt, uint256 _tokenBDebtAmt) = debtAmt(self);\n    return (\n      convertToUsdValue(self, address(self.tokenA), _tokenADebtAmt),\n      convertToUsdValue(self, address(self.tokenB), _tokenBDebtAmt)\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function equityValue(GMXTypes.Store storage self) public view returns (uint256) {\n    (uint256 _tokenADebtAmt, uint256 _tokenBDebtAmt) = debtAmt(self);\n\n    uint256 assetValue_ = assetValue(self);\n\n    uint256 _debtValue = convertToUsdValue(self, address(self.tokenA), _tokenADebtAmt)\n                         + convertToUsdValue(self, address(self.tokenB), _tokenBDebtAmt);\n\n    // in underflow condition return 0\n    unchecked {\n      if (assetValue_ < _debtValue) return 0;\n\n      return assetValue_ - _debtValue;\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function assetAmt(GMXTypes.Store storage self) public view returns (uint256, uint256) {\n    (uint256 _reserveA, uint256 _reserveB) = self.gmxOracle.getLpTokenReserves(\n      address(self.lpToken),\n      address(self.tokenA),\n      address(self.tokenA),\n      address(self.tokenB)\n    );\n\n    return (\n      _reserveA * SAFE_MULTIPLIER * lpAmt(self) / self.lpToken.totalSupply() / SAFE_MULTIPLIER,\n      _reserveB * SAFE_MULTIPLIER * lpAmt(self) / self.lpToken.totalSupply() / SAFE_MULTIPLIER\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function debtAmt(GMXTypes.Store storage self) public view returns (uint256, uint256) {\n    return (\n      self.tokenALendingVault.maxRepay(address(self.vault)),\n      self.tokenBLendingVault.maxRepay(address(self.vault))\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function lpAmt(GMXTypes.Store storage self) public view returns (uint256) {\n    return self.lpToken.balanceOf(address(self.vault));\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function leverage(GMXTypes.Store storage self) public view returns (uint256) {\n    if (assetValue(self) == 0 || equityValue(self) == 0) return 0;\n    return assetValue(self) * SAFE_MULTIPLIER / equityValue(self);\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function delta(GMXTypes.Store storage self) public view returns (int256) {\n    (uint256 _tokenAAmt,) = assetAmt(self);\n    (uint256 _tokenADebtAmt,) = debtAmt(self);\n    uint256 equityValue_ = equityValue(self);\n\n    if (_tokenAAmt == 0 && _tokenADebtAmt == 0) return 0;\n    if (equityValue_ == 0) return 0;\n\n    bool _isPositive = _tokenAAmt >= _tokenADebtAmt;\n\n    uint256 _unsignedDelta = _isPositive ?\n      _tokenAAmt - _tokenADebtAmt :\n      _tokenADebtAmt - _tokenAAmt;\n\n    int256 signedDelta = (_unsignedDelta\n      * self.chainlinkOracle.consultIn18Decimals(address(self.tokenA))\n      / equityValue_).toInt256();\n\n    if (_isPositive) return signedDelta;\n    else return -signedDelta;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function debtRatio(GMXTypes.Store storage self) public view returns (uint256) {\n    (uint256 _tokenADebtValue, uint256 _tokenBDebtValue) = debtValue(self);\n    if (assetValue(self) == 0) return 0;\n    return (_tokenADebtValue + _tokenBDebtValue) * SAFE_MULTIPLIER / assetValue(self);\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function additionalCapacity(GMXTypes.Store storage self) public view returns (uint256) {\n    uint256 _additionalCapacity;\n\n    // Long strategy only borrows short token (typically stablecoin)\n    if (self.delta == GMXTypes.Delta.Long) {\n      _additionalCapacity = convertToUsdValue(\n        self,\n        address(self.tokenB),\n        self.tokenBLendingVault.totalAvailableAsset()\n      ) * SAFE_MULTIPLIER / (self.leverage - 1e18);\n    }\n\n    // Neutral strategy borrows both long (typical volatile) and short token (typically stablecoin)\n    // Amount of long token to borrow is equivalent to deposited value x leverage x longTokenWeight\n    // Amount of short token to borrow is remaining borrow value AFTER borrowing long token\n    // ---------------------------------------------------------------------------------------------\n    // E.g: 3x Neutral ETH-USDC with weight of ETH being 55%, USDC 45%\n    // A $1 equity deposit should result in a $2 borrow for a total of $3 assets\n    // Amount of ETH to borrow would be $3 x 55% = $1.65 worth of ETH\n    // Amount of USDC to borrow would be $3 (asset) - $1.65 (ETH borrowed) - $1 (equity) = $0.35\n    // ---------------------------------------------------------------------------------------------\n    // Note that for Neutral strategies, vault's leverage has to be 3x and above.\n    // A 2x leverage neutral strategy may not work to correctly to borrow enough long token to hedge\n    // while still adhering to the correct leverage factor.\n    if (self.delta == GMXTypes.Delta.Neutral) {\n      (uint256 _tokenAWeight, ) = tokenWeights(self);\n\n      uint256 _maxTokenALending = convertToUsdValue(\n        self,\n        address(self.tokenA),\n        self.tokenALendingVault.totalAvailableAsset()\n      ) * SAFE_MULTIPLIER\n        / (self.leverage * _tokenAWeight / SAFE_MULTIPLIER);\n\n      uint256 _maxTokenBLending = convertToUsdValue(\n        self,\n        address(self.tokenB),\n        self.tokenBLendingVault.totalAvailableAsset()\n      ) * SAFE_MULTIPLIER\n        / (self.leverage * _tokenAWeight / SAFE_MULTIPLIER)\n        - 1e18;\n\n      _additionalCapacity = _maxTokenALending > _maxTokenBLending ? _maxTokenBLending : _maxTokenALending;\n    }\n\n    return _additionalCapacity;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function capacity(GMXTypes.Store storage self) public view returns (uint256) {\n    return additionalCapacity(self) + equityValue(self);\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXReader.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\n\n/**\n  * @title GMXReader\n  * @author Steadefi\n  * @notice Re-usable library functions for reading data and values for Steadefi leveraged vaults\n*/\nlibrary GMXReader {\n  using SafeCast for uint256;\n\n  /* =================== CONSTANTS FUNCTIONS ================= */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function svTokenValue(GMXTypes.Store storage self) public view returns (uint256) {\n    uint256 equityValue_ = equityValue(self);\n    uint256 totalSupply_ = IERC20(address(self.vault)).totalSupply();\n    if (equityValue_ == 0 || totalSupply_ == 0) return SAFE_MULTIPLIER;\n    return equityValue_ * SAFE_MULTIPLIER / totalSupply_;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function pendingFee(GMXTypes.Store storage self) public view returns (uint256) {\n    uint256 totalSupply_ = IERC20(address(self.vault)).totalSupply();\n    uint256 _secondsFromLastCollection = block.timestamp - self.lastFeeCollected;\n    return (totalSupply_ * self.feePerSecond * _secondsFromLastCollection) / SAFE_MULTIPLIER;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function valueToShares(\n    GMXTypes.Store storage self,\n    uint256 value,\n    uint256 currentEquity\n  ) public view returns (uint256) {\n    uint256 _sharesSupply = IERC20(address(self.vault)).totalSupply() + pendingFee(self);\n    if (_sharesSupply == 0 || currentEquity == 0) return value;\n    return value * _sharesSupply / currentEquity;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function convertToUsdValue(\n    GMXTypes.Store storage self,\n    address token,\n    uint256 amt\n  ) public view returns (uint256) {\n    return amt * 10**(18 - IERC20Metadata(token).decimals())\n                * self.chainlinkOracle.consultIn18Decimals(token)\n                / SAFE_MULTIPLIER;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function tokenWeights(GMXTypes.Store storage self) public view returns (uint256, uint256) {\n    // Get amounts of tokenA and tokenB in liquidity pool in token decimals\n    (uint256 _reserveA, uint256 _reserveB) = self.gmxOracle.getLpTokenReserves(\n      address(self.lpToken),\n      address(self.tokenA),\n      address(self.tokenA),\n      address(self.tokenB)\n    );\n\n    // Get value of tokenA and tokenB in 1e18\n    uint256 _tokenAValue = convertToUsdValue(self, address(self.tokenA), _reserveA);\n    uint256 _tokenBValue = convertToUsdValue(self, address(self.tokenB), _reserveB);\n\n    uint256 _totalLpValue = _tokenAValue + _tokenBValue;\n\n    return (\n      _tokenAValue * SAFE_MULTIPLIER / _totalLpValue,\n      _tokenBValue * SAFE_MULTIPLIER / _totalLpValue\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function assetValue(GMXTypes.Store storage self) public view returns (uint256) {\n    return lpAmt(self) * self.gmxOracle.getLpTokenValue(\n      address(self.lpToken),\n      address(self.tokenA),\n      address(self.tokenA),\n      address(self.tokenB),\n      false,\n      false\n    ) / SAFE_MULTIPLIER;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function debtValue(GMXTypes.Store storage self) public view returns (uint256, uint256) {\n    (uint256 _tokenADebtAmt, uint256 _tokenBDebtAmt) = debtAmt(self);\n    return (\n      convertToUsdValue(self, address(self.tokenA), _tokenADebtAmt),\n      convertToUsdValue(self, address(self.tokenB), _tokenBDebtAmt)\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function equityValue(GMXTypes.Store storage self) public view returns (uint256) {\n    (uint256 _tokenADebtAmt, uint256 _tokenBDebtAmt) = debtAmt(self);\n\n    uint256 assetValue_ = assetValue(self);\n\n    uint256 _debtValue = convertToUsdValue(self, address(self.tokenA), _tokenADebtAmt)\n                         + convertToUsdValue(self, address(self.tokenB), _tokenBDebtAmt);\n\n    // in underflow condition return 0\n    unchecked {\n      if (assetValue_ < _debtValue) return 0;\n\n      return assetValue_ - _debtValue;\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function assetAmt(GMXTypes.Store storage self) public view returns (uint256, uint256) {\n    (uint256 _reserveA, uint256 _reserveB) = self.gmxOracle.getLpTokenReserves(\n      address(self.lpToken),\n      address(self.tokenA),\n      address(self.tokenA),\n      address(self.tokenB)\n    );\n\n    return (\n      _reserveA * SAFE_MULTIPLIER * lpAmt(self) / self.lpToken.totalSupply() / SAFE_MULTIPLIER,\n      _reserveB * SAFE_MULTIPLIER * lpAmt(self) / self.lpToken.totalSupply() / SAFE_MULTIPLIER\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function debtAmt(GMXTypes.Store storage self) public view returns (uint256, uint256) {\n    return (\n      self.tokenALendingVault.maxRepay(address(self.vault)),\n      self.tokenBLendingVault.maxRepay(address(self.vault))\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function lpAmt(GMXTypes.Store storage self) public view returns (uint256) {\n    return self.lpToken.balanceOf(address(self.vault));\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function leverage(GMXTypes.Store storage self) public view returns (uint256) {\n    if (assetValue(self) == 0 || equityValue(self) == 0) return 0;\n    return assetValue(self) * SAFE_MULTIPLIER / equityValue(self);\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function delta(GMXTypes.Store storage self) public view returns (int256) {\n    (uint256 _tokenAAmt,) = assetAmt(self);\n    (uint256 _tokenADebtAmt,) = debtAmt(self);\n    uint256 equityValue_ = equityValue(self);\n\n    if (_tokenAAmt == 0 && _tokenADebtAmt == 0) return 0;\n    if (equityValue_ == 0) return 0;\n\n    bool _isPositive = _tokenAAmt >= _tokenADebtAmt;\n\n    uint256 _unsignedDelta = _isPositive ?\n      _tokenAAmt - _tokenADebtAmt :\n      _tokenADebtAmt - _tokenAAmt;\n\n    int256 signedDelta = (_unsignedDelta\n      * self.chainlinkOracle.consultIn18Decimals(address(self.tokenA))\n      / equityValue_).toInt256();\n\n    if (_isPositive) return signedDelta;\n    else return -signedDelta;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function debtRatio(GMXTypes.Store storage self) public view returns (uint256) {\n    (uint256 _tokenADebtValue, uint256 _tokenBDebtValue) = debtValue(self);\n    if (assetValue(self) == 0) return 0;\n    return (_tokenADebtValue + _tokenBDebtValue) * SAFE_MULTIPLIER / assetValue(self);\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function additionalCapacity(GMXTypes.Store storage self) public view returns (uint256) {\n    uint256 _additionalCapacity;\n\n    // Long strategy only borrows short token (typically stablecoin)\n    if (self.delta == GMXTypes.Delta.Long) {\n      _additionalCapacity = convertToUsdValue(\n        self,\n        address(self.tokenB),\n        self.tokenBLendingVault.totalAvailableAsset()\n      ) * SAFE_MULTIPLIER / (self.leverage - 1e18);\n    }\n\n    // Neutral strategy borrows both long (typical volatile) and short token (typically stablecoin)\n    // Amount of long token to borrow is equivalent to deposited value x leverage x longTokenWeight\n    // Amount of short token to borrow is remaining borrow value AFTER borrowing long token\n    // ---------------------------------------------------------------------------------------------\n    // E.g: 3x Neutral ETH-USDC with weight of ETH being 55%, USDC 45%\n    // A $1 equity deposit should result in a $2 borrow for a total of $3 assets\n    // Amount of ETH to borrow would be $3 x 55% = $1.65 worth of ETH\n    // Amount of USDC to borrow would be $3 (asset) - $1.65 (ETH borrowed) - $1 (equity) = $0.35\n    // ---------------------------------------------------------------------------------------------\n    // Note that for Neutral strategies, vault's leverage has to be 3x and above.\n    // A 2x leverage neutral strategy may not work to correctly to borrow enough long token to hedge\n    // while still adhering to the correct leverage factor.\n    if (self.delta == GMXTypes.Delta.Neutral) {\n      (uint256 _tokenAWeight, ) = tokenWeights(self);\n\n      uint256 _maxTokenALending = convertToUsdValue(\n        self,\n        address(self.tokenA),\n        self.tokenALendingVault.totalAvailableAsset()\n      ) * SAFE_MULTIPLIER\n        / (self.leverage * _tokenAWeight / SAFE_MULTIPLIER);\n\n      uint256 _maxTokenBLending = convertToUsdValue(\n        self,\n        address(self.tokenB),\n        self.tokenBLendingVault.totalAvailableAsset()\n      ) * SAFE_MULTIPLIER\n        / (self.leverage * _tokenAWeight / SAFE_MULTIPLIER)\n        - 1e18;\n\n      _additionalCapacity = _maxTokenALending > _maxTokenBLending ? _maxTokenBLending : _maxTokenALending;\n    }\n\n    return _additionalCapacity;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function capacity(GMXTypes.Store storage self) public view returns (uint256) {\n    return additionalCapacity(self) + equityValue(self);\n  }\n}"
    }
  ]
}