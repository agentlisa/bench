{
  "Title": "[01] Several `InitialETHCrowdfund` and `ETHCrowdfundBase` functions can be called without passing by a proxy",
  "Content": "\nhttps://github.com/code-423n4/2023-10-party/blob/b23c65d62a20921c709582b0b76b387f2bb9ebb5/contracts/crowdfund/InitialETHCrowdfund.sol#L318<br>\nhttps://github.com/code-423n4/2023-10-party/blob/b23c65d62a20921c709582b0b76b387f2bb9ebb5/contracts/crowdfund/InitialETHCrowdfund.sol#L350\n\nThe `InitialETHCrowdfund` contract is meant to be used through a proxy, and many of its methods are decorated with the `onlyDelegateCall` modifier. However, several others don't, so they can be called directly.\nAlso, the Party contract and its parents are supposed to be used via a proxy, but they don't implement any `onlyDelegateCall` modifier.\n\nConsider adding the `onlyDelegateCall` modifier to:\n- `InitialETHCrowdfund.batchRefund`\n- `ETHCrowdfundBase.finalize`\n- `ETHCrowdfundBase.sendFundingSplit`\n- `ETHCrowdfundBase.emergencyExecute`\n- `ETHCrowdfundBase.disableEmergencyExecute`\n- all external methods of `PartyGovernance` and `PartyGovernanceNFT`\n\nAlso, add an ad-hoc modifier that allows delegate calls and regular calls where `msg.sender == address(this)` to `refund` to allow multicalls.\n\nNote that this applies to several initializers too, but this is reported separately with higher impact.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-10-party",
  "Code": [
    {
      "filename": "contracts/crowdfund/InitialETHCrowdfund.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport { ETHCrowdfundBase } from \"./ETHCrowdfundBase.sol\";\nimport { ProposalStorage } from \"../proposals/ProposalStorage.sol\";\nimport { LibAddress } from \"../utils/LibAddress.sol\";\nimport { LibRawResult } from \"../utils/LibRawResult.sol\";\nimport { LibSafeCast } from \"../utils/LibSafeCast.sol\";\nimport { Party, PartyGovernance } from \"../party/Party.sol\";\nimport { Crowdfund } from \"../crowdfund/Crowdfund.sol\";\nimport { MetadataProvider } from \"../renderers/MetadataProvider.sol\";\nimport { IGateKeeper } from \"../gatekeepers/IGateKeeper.sol\";\nimport { IGlobals } from \"../globals/IGlobals.sol\";\nimport { IERC721 } from \"../tokens/IERC721.sol\";\n\n/// @notice A crowdfund for raising the initial funds for new parties.\n///         Unlike other crowdfunds that are started for the purpose of\n///         acquiring NFT(s), this crowdfund simply bootstraps a party with\n///         funds and lets its members coordinate on what to do with it after.\ncontract InitialETHCrowdfund is ETHCrowdfundBase {\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n    using LibAddress for address payable;\n\n    // Options to be passed into `initialize()` when the crowdfund is created.\n    struct InitialETHCrowdfundOptions {\n        address payable initialContributor;\n        address initialDelegate;\n        uint96 minContribution;\n        uint96 maxContribution;\n        bool disableContributingForExistingCard;\n        uint96 minTotalContributions;\n        uint96 maxTotalContributions;\n        uint16 exchangeRateBps;\n        uint16 fundingSplitBps;\n        address payable fundingSplitRecipient;\n        uint40 duration;\n        IGateKeeper gateKeeper;\n        bytes12 gateKeeperId;\n    }\n\n    struct ETHPartyOptions {\n        // Name of the party.\n        string name;\n        // Symbol of the party.\n        string symbol;\n        // The ID of the customization preset to use for the party card.\n        uint256 customizationPresetId;\n        // Options to initialize party governance with.\n        Crowdfund.FixedGovernanceOpts governanceOpts;\n        // Options to initialize party proposal engine with.\n        ProposalStorage.ProposalEngineOpts proposalEngineOpts;\n        // The tokens that are considered precious by the party.These are\n        // protected assets and are subject to extra restrictions in proposals\n        // vs other assets.\n        IERC721[] preciousTokens;\n        // The IDs associated with each token in `preciousTokens`.\n        uint256[] preciousTokenIds;\n        // The timestamp until which ragequit is enabled.\n        uint40 rageQuitTimestamp;\n        // Initial authorities to set on the party\n        address[] authorities;\n    }\n\n    struct BatchContributeArgs {\n        // IDs of cards to credit the contributions to. When set to 0, it means\n        uint256[] tokenIds;\n        // The address to which voting power will be delegated for all contributions.\n        address delegate;\n        // The contribution amounts in wei. The length of this array must be\n        // equal to the length of `tokenIds`.\n        uint96[] values;\n        // The data required to be validated by the `gatekeeper`, if set. If no\n        // `gatekeeper` is set, this can be empty.\n        bytes[] gateDatas;\n    }\n\n    struct BatchContributeForArgs {\n        // IDs of cards to credit the contributions to. When set to 0, it means\n        // a new one should be minted.\n        uint256[] tokenIds;\n        // Addresses of to credit the contributions under. Each contribution\n        // amount in `values` corresponds to a recipient in this array.\n        address payable[] recipients;\n        // The delegate to set for each recipient if they have not delegated\n        // before.\n        address[] initialDelegates;\n        // The contribution amounts in wei. The length of this array must be\n        // equal to the length of `recipients`.\n        uint96[] values;\n        // The data required to be validated by the `gatekeeper`, if set. If no\n        // `gatekeeper` is set, this can be empty.\n        bytes[] gateDatas;\n    }\n\n    event Refunded(address indexed contributor, uint256 indexed tokenId, uint256 amount);\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) ETHCrowdfundBase(globals) {}\n\n    /// @notice Initializer to be delegatecalled by `Proxy` constructor. Will\n    ///         revert if called outside the constructor.\n    /// @param crowdfundOpts Options to initialize the crowdfund with.\n    /// @param partyOpts Options to initialize the party with.\n    /// @param customMetadataProvider Optional provider to use for the party for\n    ///                               rendering custom metadata.\n    /// @param customMetadata Optional custom metadata to use for the party.\n    function initialize(\n        InitialETHCrowdfundOptions memory crowdfundOpts,\n        ETHPartyOptions memory partyOpts,\n        MetadataProvider customMetadataProvider,\n        bytes memory customMetadata\n    ) external payable onlyInitialize {\n        // Create party the initial crowdfund will be for.\n        Party party_ = _createParty(partyOpts, customMetadataProvider, customMetadata);\n\n        // Initialize the crowdfund.\n        _initialize(\n            ETHCrowdfundOptions({\n                party: party_,\n                initialContributor: crowdfundOpts.initialContributor,\n                initialDelegate: crowdfundOpts.initialDelegate,\n                minContribution: crowdfundOpts.minContribution,\n                maxContribution: crowdfundOpts.maxContribution,\n                disableContributingForExistingCard: crowdfundOpts\n                    .disableContributingForExistingCard,\n                minTotalContributions: crowdfundOpts.minTotalContributions,\n                maxTotalContributions: crowdfundOpts.maxTotalContributions,\n                exchangeRateBps: crowdfundOpts.exchangeRateBps,\n                fundingSplitBps: crowdfundOpts.fundingSplitBps,\n                fundingSplitRecipient: crowdfundOpts.fundingSplitRecipient,\n                duration: crowdfundOpts.duration,\n                gateKeeper: crowdfundOpts.gateKeeper,\n                gateKeeperId: crowdfundOpts.gateKeeperId\n            })\n        );\n\n        // If the deployer passed in some ETH during deployment, credit them\n        // for the initial contribution.\n        uint96 initialContribution = msg.value.safeCastUint256ToUint96();\n        if (initialContribution > 0) {\n            // If this contract has ETH, either passed in during deployment or\n            // pre-existing, credit it to the `initialContributor`.\n            _contribute(\n                crowdfundOpts.initialContributor,\n                crowdfundOpts.initialDelegate,\n                initialContribution,\n                0,\n                \"\"\n            );\n        }\n\n        // Set up gatekeeper after initial contribution (initial always gets in).\n        gateKeeper = crowdfundOpts.gateKeeper;\n        gateKeeperId = crowdfundOpts.gateKeeperId;\n    }\n\n    /// @notice Contribute ETH to this crowdfund on behalf of a contributor.\n    /// @param delegate The address to which voting power will be delegated to\n    ///                 during the governance phase.\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility.\n    /// @return votingPower The voting power the contributor receives for their\n    ///                     contribution.\n    function contribute(\n        address delegate,\n        bytes memory gateData\n    ) public payable onlyDelegateCall returns (uint96 votingPower) {\n        return\n            _contribute(\n                payable(msg.sender),\n                delegate,\n                msg.value.safeCastUint256ToUint96(),\n                0, // Mint a new party card for the contributor.\n                gateData\n            );\n    }\n\n    /// @notice Contribute ETH to this crowdfund on behalf of a contributor.\n    /// @param tokenId The ID of the card the contribution is being made towards.\n    /// @param delegate The address to which voting power will be delegated to\n    ///                 during the governance phase.\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility.\n    /// @return votingPower The voting power the contributor receives for their\n    ///                     contribution.\n    function contribute(\n        uint256 tokenId,\n        address delegate,\n        bytes memory gateData\n    ) public payable onlyDelegateCall returns (uint96 votingPower) {\n        return\n            _contribute(\n                payable(msg.sender),\n                delegate,\n                msg.value.safeCastUint256ToUint96(),\n                tokenId,\n                gateData\n            );\n    }\n\n    /// @notice `contribute()` in batch form.\n    ///         May not revert if any individual contribution fails.\n    /// @param args The arguments to pass to each `contribute()` call.\n    /// @return votingPowers The voting power received for each contribution.\n    function batchContribute(\n        BatchContributeArgs calldata args\n    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {\n        uint256 numContributions = args.tokenIds.length;\n        votingPowers = new uint96[](numContributions);\n\n        uint256 ethAvailable = msg.value;\n        for (uint256 i; i < numContributions; ++i) {\n            ethAvailable -= args.values[i];\n\n            votingPowers[i] = _contribute(\n                payable(msg.sender),\n                args.delegate,\n                args.values[i],\n                args.tokenIds[i],\n                args.gateDatas[i]\n            );\n        }\n\n        // Refund any unused ETH.\n        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);\n    }\n\n    /// @notice Contribute to this crowdfund on behalf of another address.\n    /// @param tokenId The ID of the token to credit the contribution to, or\n    ///                zero to mint a new party card for the recipient\n    /// @param recipient The address to record the contribution under\n    /// @param initialDelegate The address to delegate to for the governance\n    ///                        phase if recipient hasn't delegated\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility\n    /// @return votingPower The voting power received for the contribution\n    function contributeFor(\n        uint256 tokenId,\n        address payable recipient,\n        address initialDelegate,\n        bytes memory gateData\n    ) external payable onlyDelegateCall returns (uint96 votingPower) {\n        return\n            _contribute(\n                recipient,\n                initialDelegate,\n                msg.value.safeCastUint256ToUint96(),\n                tokenId,\n                gateData\n            );\n    }\n\n    /// @notice `contributeFor()` in batch form.\n    ///         May not revert if any individual contribution fails.\n    /// @param args The arguments for the batched `contributeFor()` calls.\n    /// @return votingPowers The voting power received for each contribution.\n    function batchContributeFor(\n        BatchContributeForArgs calldata args\n    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {\n        votingPowers = new uint96[](args.recipients.length);\n        uint256 valuesSum;\n        for (uint256 i; i < args.recipients.length; ++i) {\n            votingPowers[i] = _contribute(\n                args.recipients[i],\n                args.initialDelegates[i],\n                args.values[i],\n                args.tokenIds[i],\n                args.gateDatas[i]\n            );\n            valuesSum += args.values[i];\n        }\n        if (msg.value != valuesSum) {\n            revert InvalidMessageValue();\n        }\n    }\n\n    function _contribute(\n        address payable contributor,\n        address delegate,\n        uint96 amount,\n        uint256 tokenId,\n        bytes memory gateData\n    ) private returns (uint96 votingPower) {\n        // Require a non-null delegate.\n        if (delegate == address(0)) {\n            revert InvalidDelegateError();\n        }\n\n        // Must not be blocked by gatekeeper.\n        IGateKeeper _gateKeeper = gateKeeper;\n        if (_gateKeeper != IGateKeeper(address(0))) {\n            if (!_gateKeeper.isAllowed(msg.sender, gateKeeperId, gateData)) {\n                revert NotAllowedByGateKeeperError(msg.sender, _gateKeeper, gateKeeperId, gateData);\n            }\n        }\n\n        votingPower = _processContribution(contributor, delegate, amount);\n\n        // OK to contribute with zero just to update delegate.\n        if (amount == 0) return 0;\n\n        if (tokenId == 0) {\n            // Mint contributor a new party card.\n            party.mint(contributor, votingPower, delegate);\n        } else if (disableContributingForExistingCard) {\n            revert ContributingForExistingCardDisabledError();\n        } else if (party.ownerOf(tokenId) == contributor) {\n            // Increase voting power of contributor's existing party card.\n            party.increaseVotingPower(tokenId, votingPower);\n        } else {\n            revert NotOwnerError(tokenId);\n        }\n    }\n\n    /// @notice Refund the owner of a party card and burn it. Only available if\n    ///         the crowdfund lost. Can be called to refund for self or on\n    ///         another's behalf.\n    /// @param tokenId The ID of the party card to refund the owner of then burn.\n    /// @return amount The amount of ETH refunded to the contributor.\n    function refund(uint256 tokenId) external returns (uint96 amount) {\n        // Check crowdfund lifecycle.\n        {\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\n            if (lc != CrowdfundLifecycle.Lost) {\n                revert WrongLifecycleError(lc);\n            }\n        }\n\n        // Get amount to refund.\n        uint96 votingPower = party.votingPowerByTokenId(tokenId).safeCastUint256ToUint96();\n        amount = convertVotingPowerToContribution(votingPower);\n\n        if (amount > 0) {\n            // Get contributor to refund.\n            address payable contributor = payable(party.ownerOf(tokenId));\n\n            // Burn contributor's party card.\n            party.burn(tokenId);\n\n            // Refund contributor.\n            contributor.transferEth(amount);\n\n            emit Refunded(contributor, tokenId, amount);\n        }\n    }\n\n    /// @notice `refund()` in batch form.\n    ///         May not revert if any individual refund fails.\n    /// @param tokenIds The IDs of the party cards to burn and refund the owners of.\n    /// @param revertOnFailure If true, revert if any refund fails.\n    /// @return amounts The amounts of ETH refunded for each refund.\n    function batchRefund(\n        uint256[] calldata tokenIds,\n        bool revertOnFailure\n    ) external returns (uint96[] memory amounts) {\n        uint256 numRefunds = tokenIds.length;\n        amounts = new uint96[](numRefunds);\n\n        for (uint256 i; i < numRefunds; ++i) {\n            (bool s, bytes memory r) = address(this).call(\n                abi.encodeCall(this.refund, (tokenIds[i]))\n            );\n\n            if (!s) {\n                if (revertOnFailure) {\n                    r.rawRevert();\n                }\n            } else {\n                amounts[i] = abi.decode(r, (uint96));\n            }\n        }\n    }\n\n    function _createParty(\n        ETHPartyOptions memory opts,\n        MetadataProvider customMetadataProvider,\n        bytes memory customMetadata\n    ) private returns (Party) {\n        uint256 authoritiesLength = opts.authorities.length + 1;\n        address[] memory authorities = new address[](authoritiesLength);\n        for (uint i = 0; i < authoritiesLength - 1; ++i) {\n            authorities[i] = opts.authorities[i];\n        }\n        authorities[authoritiesLength - 1] = address(this);\n\n        if (address(customMetadataProvider) == address(0)) {\n            return\n                opts.governanceOpts.partyFactory.createParty(\n                    opts.governanceOpts.partyImpl,\n                    authorities,\n                    Party.PartyOptions({\n                        name: opts.name,\n                        symbol: opts.symbol,\n                        customizationPresetId: opts.customizationPresetId,\n                        governance: PartyGovernance.GovernanceOpts({\n                            hosts: opts.governanceOpts.hosts,\n                            voteDuration: opts.governanceOpts.voteDuration,\n                            executionDelay: opts.governanceOpts.executionDelay,\n                            passThresholdBps: opts.governanceOpts.passThresholdBps,\n                            totalVotingPower: 0,\n                            feeBps: opts.governanceOpts.feeBps,\n                            feeRecipient: opts.governanceOpts.feeRecipient\n                        }),\n                        proposalEngine: opts.proposalEngineOpts\n                    }),\n                    opts.preciousTokens,\n                    opts.preciousTokenIds,\n                    opts.rageQuitTimestamp\n                );\n        } else {\n            return\n                opts.governanceOpts.partyFactory.createPartyWithMetadata(\n                    opts.governanceOpts.partyImpl,\n                    authorities,\n                    Party.PartyOptions({\n                        name: opts.name,\n                        symbol: opts.symbol,\n                        customizationPresetId: opts.customizationPresetId,\n                        governance: PartyGovernance.GovernanceOpts({\n                            hosts: opts.governanceOpts.hosts,\n                            voteDuration: opts.governanceOpts.voteDuration,\n                            executionDelay: opts.governanceOpts.executionDelay,\n                            passThresholdBps: opts.governanceOpts.passThresholdBps,\n                            totalVotingPower: 0,\n                            feeBps: opts.governanceOpts.feeBps,\n                            feeRecipient: opts.governanceOpts.feeRecipient\n                        }),\n                        proposalEngine: opts.proposalEngineOpts\n                    }),\n                    opts.preciousTokens,\n                    opts.preciousTokenIds,\n                    opts.rageQuitTimestamp,\n                    customMetadataProvider,\n                    customMetadata\n                );\n        }\n    }\n}"
    },
    {
      "filename": "contracts/crowdfund/InitialETHCrowdfund.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport { ETHCrowdfundBase } from \"./ETHCrowdfundBase.sol\";\nimport { ProposalStorage } from \"../proposals/ProposalStorage.sol\";\nimport { LibAddress } from \"../utils/LibAddress.sol\";\nimport { LibRawResult } from \"../utils/LibRawResult.sol\";\nimport { LibSafeCast } from \"../utils/LibSafeCast.sol\";\nimport { Party, PartyGovernance } from \"../party/Party.sol\";\nimport { Crowdfund } from \"../crowdfund/Crowdfund.sol\";\nimport { MetadataProvider } from \"../renderers/MetadataProvider.sol\";\nimport { IGateKeeper } from \"../gatekeepers/IGateKeeper.sol\";\nimport { IGlobals } from \"../globals/IGlobals.sol\";\nimport { IERC721 } from \"../tokens/IERC721.sol\";\n\n/// @notice A crowdfund for raising the initial funds for new parties.\n///         Unlike other crowdfunds that are started for the purpose of\n///         acquiring NFT(s), this crowdfund simply bootstraps a party with\n///         funds and lets its members coordinate on what to do with it after.\ncontract InitialETHCrowdfund is ETHCrowdfundBase {\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n    using LibAddress for address payable;\n\n    // Options to be passed into `initialize()` when the crowdfund is created.\n    struct InitialETHCrowdfundOptions {\n        address payable initialContributor;\n        address initialDelegate;\n        uint96 minContribution;\n        uint96 maxContribution;\n        bool disableContributingForExistingCard;\n        uint96 minTotalContributions;\n        uint96 maxTotalContributions;\n        uint16 exchangeRateBps;\n        uint16 fundingSplitBps;\n        address payable fundingSplitRecipient;\n        uint40 duration;\n        IGateKeeper gateKeeper;\n        bytes12 gateKeeperId;\n    }\n\n    struct ETHPartyOptions {\n        // Name of the party.\n        string name;\n        // Symbol of the party.\n        string symbol;\n        // The ID of the customization preset to use for the party card.\n        uint256 customizationPresetId;\n        // Options to initialize party governance with.\n        Crowdfund.FixedGovernanceOpts governanceOpts;\n        // Options to initialize party proposal engine with.\n        ProposalStorage.ProposalEngineOpts proposalEngineOpts;\n        // The tokens that are considered precious by the party.These are\n        // protected assets and are subject to extra restrictions in proposals\n        // vs other assets.\n        IERC721[] preciousTokens;\n        // The IDs associated with each token in `preciousTokens`.\n        uint256[] preciousTokenIds;\n        // The timestamp until which ragequit is enabled.\n        uint40 rageQuitTimestamp;\n        // Initial authorities to set on the party\n        address[] authorities;\n    }\n\n    struct BatchContributeArgs {\n        // IDs of cards to credit the contributions to. When set to 0, it means\n        uint256[] tokenIds;\n        // The address to which voting power will be delegated for all contributions.\n        address delegate;\n        // The contribution amounts in wei. The length of this array must be\n        // equal to the length of `tokenIds`.\n        uint96[] values;\n        // The data required to be validated by the `gatekeeper`, if set. If no\n        // `gatekeeper` is set, this can be empty.\n        bytes[] gateDatas;\n    }\n\n    struct BatchContributeForArgs {\n        // IDs of cards to credit the contributions to. When set to 0, it means\n        // a new one should be minted.\n        uint256[] tokenIds;\n        // Addresses of to credit the contributions under. Each contribution\n        // amount in `values` corresponds to a recipient in this array.\n        address payable[] recipients;\n        // The delegate to set for each recipient if they have not delegated\n        // before.\n        address[] initialDelegates;\n        // The contribution amounts in wei. The length of this array must be\n        // equal to the length of `recipients`.\n        uint96[] values;\n        // The data required to be validated by the `gatekeeper`, if set. If no\n        // `gatekeeper` is set, this can be empty.\n        bytes[] gateDatas;\n    }\n\n    event Refunded(address indexed contributor, uint256 indexed tokenId, uint256 amount);\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) ETHCrowdfundBase(globals) {}\n\n    /// @notice Initializer to be delegatecalled by `Proxy` constructor. Will\n    ///         revert if called outside the constructor.\n    /// @param crowdfundOpts Options to initialize the crowdfund with.\n    /// @param partyOpts Options to initialize the party with.\n    /// @param customMetadataProvider Optional provider to use for the party for\n    ///                               rendering custom metadata.\n    /// @param customMetadata Optional custom metadata to use for the party.\n    function initialize(\n        InitialETHCrowdfundOptions memory crowdfundOpts,\n        ETHPartyOptions memory partyOpts,\n        MetadataProvider customMetadataProvider,\n        bytes memory customMetadata\n    ) external payable onlyInitialize {\n        // Create party the initial crowdfund will be for.\n        Party party_ = _createParty(partyOpts, customMetadataProvider, customMetadata);\n\n        // Initialize the crowdfund.\n        _initialize(\n            ETHCrowdfundOptions({\n                party: party_,\n                initialContributor: crowdfundOpts.initialContributor,\n                initialDelegate: crowdfundOpts.initialDelegate,\n                minContribution: crowdfundOpts.minContribution,\n                maxContribution: crowdfundOpts.maxContribution,\n                disableContributingForExistingCard: crowdfundOpts\n                    .disableContributingForExistingCard,\n                minTotalContributions: crowdfundOpts.minTotalContributions,\n                maxTotalContributions: crowdfundOpts.maxTotalContributions,\n                exchangeRateBps: crowdfundOpts.exchangeRateBps,\n                fundingSplitBps: crowdfundOpts.fundingSplitBps,\n                fundingSplitRecipient: crowdfundOpts.fundingSplitRecipient,\n                duration: crowdfundOpts.duration,\n                gateKeeper: crowdfundOpts.gateKeeper,\n                gateKeeperId: crowdfundOpts.gateKeeperId\n            })\n        );\n\n        // If the deployer passed in some ETH during deployment, credit them\n        // for the initial contribution.\n        uint96 initialContribution = msg.value.safeCastUint256ToUint96();\n        if (initialContribution > 0) {\n            // If this contract has ETH, either passed in during deployment or\n            // pre-existing, credit it to the `initialContributor`.\n            _contribute(\n                crowdfundOpts.initialContributor,\n                crowdfundOpts.initialDelegate,\n                initialContribution,\n                0,\n                \"\"\n            );\n        }\n\n        // Set up gatekeeper after initial contribution (initial always gets in).\n        gateKeeper = crowdfundOpts.gateKeeper;\n        gateKeeperId = crowdfundOpts.gateKeeperId;\n    }\n\n    /// @notice Contribute ETH to this crowdfund on behalf of a contributor.\n    /// @param delegate The address to which voting power will be delegated to\n    ///                 during the governance phase.\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility.\n    /// @return votingPower The voting power the contributor receives for their\n    ///                     contribution.\n    function contribute(\n        address delegate,\n        bytes memory gateData\n    ) public payable onlyDelegateCall returns (uint96 votingPower) {\n        return\n            _contribute(\n                payable(msg.sender),\n                delegate,\n                msg.value.safeCastUint256ToUint96(),\n                0, // Mint a new party card for the contributor.\n                gateData\n            );\n    }\n\n    /// @notice Contribute ETH to this crowdfund on behalf of a contributor.\n    /// @param tokenId The ID of the card the contribution is being made towards.\n    /// @param delegate The address to which voting power will be delegated to\n    ///                 during the governance phase.\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility.\n    /// @return votingPower The voting power the contributor receives for their\n    ///                     contribution.\n    function contribute(\n        uint256 tokenId,\n        address delegate,\n        bytes memory gateData\n    ) public payable onlyDelegateCall returns (uint96 votingPower) {\n        return\n            _contribute(\n                payable(msg.sender),\n                delegate,\n                msg.value.safeCastUint256ToUint96(),\n                tokenId,\n                gateData\n            );\n    }\n\n    /// @notice `contribute()` in batch form.\n    ///         May not revert if any individual contribution fails.\n    /// @param args The arguments to pass to each `contribute()` call.\n    /// @return votingPowers The voting power received for each contribution.\n    function batchContribute(\n        BatchContributeArgs calldata args\n    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {\n        uint256 numContributions = args.tokenIds.length;\n        votingPowers = new uint96[](numContributions);\n\n        uint256 ethAvailable = msg.value;\n        for (uint256 i; i < numContributions; ++i) {\n            ethAvailable -= args.values[i];\n\n            votingPowers[i] = _contribute(\n                payable(msg.sender),\n                args.delegate,\n                args.values[i],\n                args.tokenIds[i],\n                args.gateDatas[i]\n            );\n        }\n\n        // Refund any unused ETH.\n        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);\n    }\n\n    /// @notice Contribute to this crowdfund on behalf of another address.\n    /// @param tokenId The ID of the token to credit the contribution to, or\n    ///                zero to mint a new party card for the recipient\n    /// @param recipient The address to record the contribution under\n    /// @param initialDelegate The address to delegate to for the governance\n    ///                        phase if recipient hasn't delegated\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility\n    /// @return votingPower The voting power received for the contribution\n    function contributeFor(\n        uint256 tokenId,\n        address payable recipient,\n        address initialDelegate,\n        bytes memory gateData\n    ) external payable onlyDelegateCall returns (uint96 votingPower) {\n        return\n            _contribute(\n                recipient,\n                initialDelegate,\n                msg.value.safeCastUint256ToUint96(),\n                tokenId,\n                gateData\n            );\n    }\n\n    /// @notice `contributeFor()` in batch form.\n    ///         May not revert if any individual contribution fails.\n    /// @param args The arguments for the batched `contributeFor()` calls.\n    /// @return votingPowers The voting power received for each contribution.\n    function batchContributeFor(\n        BatchContributeForArgs calldata args\n    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {\n        votingPowers = new uint96[](args.recipients.length);\n        uint256 valuesSum;\n        for (uint256 i; i < args.recipients.length; ++i) {\n            votingPowers[i] = _contribute(\n                args.recipients[i],\n                args.initialDelegates[i],\n                args.values[i],\n                args.tokenIds[i],\n                args.gateDatas[i]\n            );\n            valuesSum += args.values[i];\n        }\n        if (msg.value != valuesSum) {\n            revert InvalidMessageValue();\n        }\n    }\n\n    function _contribute(\n        address payable contributor,\n        address delegate,\n        uint96 amount,\n        uint256 tokenId,\n        bytes memory gateData\n    ) private returns (uint96 votingPower) {\n        // Require a non-null delegate.\n        if (delegate == address(0)) {\n            revert InvalidDelegateError();\n        }\n\n        // Must not be blocked by gatekeeper.\n        IGateKeeper _gateKeeper = gateKeeper;\n        if (_gateKeeper != IGateKeeper(address(0))) {\n            if (!_gateKeeper.isAllowed(msg.sender, gateKeeperId, gateData)) {\n                revert NotAllowedByGateKeeperError(msg.sender, _gateKeeper, gateKeeperId, gateData);\n            }\n        }\n\n        votingPower = _processContribution(contributor, delegate, amount);\n\n        // OK to contribute with zero just to update delegate.\n        if (amount == 0) return 0;\n\n        if (tokenId == 0) {\n            // Mint contributor a new party card.\n            party.mint(contributor, votingPower, delegate);\n        } else if (disableContributingForExistingCard) {\n            revert ContributingForExistingCardDisabledError();\n        } else if (party.ownerOf(tokenId) == contributor) {\n            // Increase voting power of contributor's existing party card.\n            party.increaseVotingPower(tokenId, votingPower);\n        } else {\n            revert NotOwnerError(tokenId);\n        }\n    }\n\n    /// @notice Refund the owner of a party card and burn it. Only available if\n    ///         the crowdfund lost. Can be called to refund for self or on\n    ///         another's behalf.\n    /// @param tokenId The ID of the party card to refund the owner of then burn.\n    /// @return amount The amount of ETH refunded to the contributor.\n    function refund(uint256 tokenId) external returns (uint96 amount) {\n        // Check crowdfund lifecycle.\n        {\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\n            if (lc != CrowdfundLifecycle.Lost) {\n                revert WrongLifecycleError(lc);\n            }\n        }\n\n        // Get amount to refund.\n        uint96 votingPower = party.votingPowerByTokenId(tokenId).safeCastUint256ToUint96();\n        amount = convertVotingPowerToContribution(votingPower);\n\n        if (amount > 0) {\n            // Get contributor to refund.\n            address payable contributor = payable(party.ownerOf(tokenId));\n\n            // Burn contributor's party card.\n            party.burn(tokenId);"
    }
  ]
}