{
  "Title": "[L04] Inconsistent minimum stake delay [core]",
  "Content": "The `StakeManager` contract specifies a [minimum unstake delay](https://github.com/eth-infinitism/account-abstraction/blob/8832d6e04b9f4f706f612261c6e46b3f1745d61a/contracts/StakeManager.sol#L13) for paymasters to withdraw their stake, but this minimum is not enforced [when staking](https://github.com/eth-infinitism/account-abstraction/blob/8832d6e04b9f4f706f612261c6e46b3f1745d61a/contracts/StakeManager.sol#L87).\n\n\nThe Ethereum Foundation has indicated that they intend to remove the minimum entirely, and instead allow it to be a floating parameter, negotiated between miners and paymasters. To this end, they will introduce two unused parameters to the `handleOps` function call, set by the miner, specifying their minimum acceptable stake and delay values. These are merely signals that won’t be enforced by the contract. Note that this solution would also involve removing the `EntryPoint` contract’s [`paymasterStake` parameter](https://github.com/eth-infinitism/account-abstraction/blob/8832d6e04b9f4f706f612261c6e46b3f1745d61a/contracts/EntryPoint.sol#L22) and modifying the[`isPaymasterStaked` function](https://github.com/eth-infinitism/account-abstraction/blob/8832d6e04b9f4f706f612261c6e46b3f1745d61a/contracts/EntryPoint.sol#L353) to accept a delay variable.\n\n\nWhile we acknowledge and endorse this solution, we would still recommend ensuring the stake delay is non-zero, since this parameter is semantically overloaded as a [flag to indicate if the paymaster is staked](https://github.com/eth-infinitism/account-abstraction/blob/8832d6e04b9f4f706f612261c6e46b3f1745d61a/contracts/StakeManager.sol#L103).\n\n\n***Update**: Fixed in pull request [#59](https://github.com/eth-infinitism/account-abstraction/pull/59/files). Checks have been added to ensure that the `unstakeDelaySec` value in `StakeManager` is non-zero and that the individual `unstakeDelaySec` value for each user stake is greater than or equal to the minimum value specified in `StakeManager`. Note that this does not implement the floating parameter mechanism.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/StakeManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8;\n\nimport \"hardhat/console.sol\";\n\n/**\n * manage deposit of sender or paymaster, to pay for gas.\n * paymaster must stake some of the deposit.\n */\ncontract StakeManager {\n\n    /// minimum number of blocks to after 'unlock' before amount can be withdrawn.\n    uint32 immutable public unstakeDelaySec;\n\n    constructor(uint32 _unstakeDelaySec) {\n        unstakeDelaySec = _unstakeDelaySec;\n    }\n\n    event Deposited(\n        address indexed account,\n        uint256 totalDeposit,\n        uint256 unstakeDelaySec\n    );\n\n\n    /// Emitted once a stake is scheduled for withdrawal\n    event DepositUnstaked(\n        address indexed account,\n        uint256 withdrawTime\n    );\n\n    event Withdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 withdrawAmount\n    );\n\n    /// @param amount of ether deposited for this account\n    /// @param unstakeDelaySec - time the deposit is locked, after calling unlock (or zero if deposit is not locked)\n    /// @param withdrawTime - first block timestamp where 'withdrawTo' will be callable, or zero if not locked\n    struct DepositInfo {\n        uint112 amount;\n        uint32 unstakeDelaySec;\n        uint64 withdrawTime;\n    }\n\n    /// maps accounts to their deposits\n    mapping(address => DepositInfo) public deposits;\n\n    function getDepositInfo(address account) external view returns (DepositInfo memory info) {\n        return deposits[account];\n    }\n\n    function balanceOf(address account) public view returns (uint) {\n        return deposits[account].amount;\n    }\n\n    receive() external payable {\n        depositTo(msg.sender);\n    }\n\n    function internalIncrementDeposit(address account, uint amount) internal {\n        deposits[account].amount += uint112(amount);\n    }\n\n    function internalDecrementDeposit(address account, uint amount) internal {\n        deposits[account].amount -= uint112(amount);\n    }\n\n    /**\n     * add to the deposit of the given account\n     */\n    function depositTo(address account) public payable {\n        internalIncrementDeposit(account, msg.value);\n        DepositInfo storage info = deposits[account];\n        emit Deposited(msg.sender, info.amount, info.unstakeDelaySec);\n    }\n\n    /**\n     * stake the account's deposit.\n     * any pending unstakeDeposit is first cancelled.\n     * can also set (or increase) the deposit with call.\n     * @param _unstakeDelaySec the new lock time before the deposit can be withdrawn.\n     */\n    function addStakeTo(address account, uint32 _unstakeDelaySec) public payable {\n        DepositInfo storage info = deposits[account];\n        require(_unstakeDelaySec >= info.unstakeDelaySec, \"cannot decrease unstake time\");\n        uint112 amount = deposits[msg.sender].amount + uint112(msg.value);\n        deposits[account] = DepositInfo(\n            amount,\n            _unstakeDelaySec,\n            0);\n        emit Deposited(account, amount, _unstakeDelaySec);\n    }\n\n    /**\n     * attempt to unstake the deposit.\n     * the value can be withdrawn (using withdrawTo) after the unstake delay.\n     */\n    function unstakeDeposit() external {\n        DepositInfo storage info = deposits[msg.sender];\n        require(info.withdrawTime == 0, \"already unstaking\");\n        require(info.unstakeDelaySec != 0, \"not staked\");\n        uint64 withdrawTime = uint64(block.timestamp) + info.unstakeDelaySec;\n        info.withdrawTime = withdrawTime;\n        emit DepositUnstaked(msg.sender, withdrawTime);\n    }\n\n    /**\n     * withdraw from the deposit.\n     * will fail if the deposit is already staked or too low.\n     * after a paymaster unlocks and withdraws some of the value, it must call addStake() to stake the value again.\n     * @param withdrawAddress the address to send withdrawn value.\n     * @param withdrawAmount the amount to withdraw.\n     */\n    function withdrawTo(address payable withdrawAddress, uint withdrawAmount) external {\n        DepositInfo memory info = deposits[msg.sender];\n        if (info.unstakeDelaySec != 0) {\n            require(info.withdrawTime > 0, \"must call unstakeDeposit() first\");\n            require(info.withdrawTime <= block.timestamp, \"Withdrawal is not due\");\n        }\n        require(withdrawAmount <= info.amount, \"Withdraw amount too large\");\n\n        // store the remaining value, with stake info cleared.\n        deposits[msg.sender] = DepositInfo(\n            info.amount - uint112(withdrawAmount),\n            0,\n            0);\n        withdrawAddress.transfer(withdrawAmount);\n        emit Withdrawn(msg.sender, withdrawAddress, withdrawAmount);\n    }\n\n    /**\n     * check if the given account is staked and didn't unlock it yet.\n     * @param account the account (paymaster) to check\n     * @param requiredStake the minimum deposit\n     * @param requiredDelaySec the minimum required stake time.\n     */\n    function isStaked(address account, uint requiredStake, uint requiredDelaySec) public view returns (bool) {\n        DepositInfo memory info = deposits[account];\n        return info.amount >= requiredStake &&\n        info.unstakeDelaySec >= requiredDelaySec &&\n        info.withdrawTime == 0;\n    }\n}"
    },
    {
      "filename": "contracts/EntryPoint.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.7;\n\nimport \"./StakeManager.sol\";\nimport \"./UserOperation.sol\";\nimport \"./IWallet.sol\";\nimport \"./IPaymaster.sol\";\n\ninterface ICreate2Deployer {\n    function deploy(bytes memory _initCode, bytes32 _salt) external returns (address);\n}\n\ncontract EntryPoint is StakeManager {\n\n    using UserOperationLib for UserOperation;\n\n    enum PaymentMode {\n        paymasterStake, // if paymaster is set, use paymaster's stake to pay.\n        walletStake // pay with wallet deposit.\n    }\n\n    uint public immutable paymasterStake;\n    address public immutable create2factory;\n\n    event UserOperationEvent(bytes32 indexed requestId, address indexed sender, address indexed paymaster, uint nonce, uint actualGasCost, uint actualGasPrice, bool success);\n    event UserOperationRevertReason(bytes32 indexed requestId, address indexed sender, uint nonce, bytes revertReason);\n\n    //handleOps reverts with this error struct, to mark the offending op\n    // NOTE: if simulateOp passes successfully, there should be no reason for handleOps to fail on it.\n    // @param opIndex - index into the array of ops to the failed one (in simulateOp, this is always zero)\n    // @param paymaster - if paymaster.validatePaymasterUserOp fails, this will be the paymaster's address. if validateUserOp failed,\n    //      this value will be zero (since it failed before accessing the paymaster)\n    // @param reason - revert reason\n    //  only to aid troubleshooting of wallet/paymaster reverts\n    error FailedOp(uint opIndex, address paymaster, string reason);\n\n    /**\n     * @param _create2factory - contract to \"create2\" wallets (not the EntryPoint itself, so that it can be upgraded)\n     * @param _paymasterStake - locked stake of paymaster (actual value should also cover TX cost)\n     * @param _unstakeDelaySec - minimum time (in seconds) a paymaster stake must be locked\n     */\n    constructor(address _create2factory, uint _paymasterStake, uint32 _unstakeDelaySec) StakeManager(_unstakeDelaySec) {\n        create2factory = _create2factory;\n        paymasterStake = _paymasterStake;\n    }\n\n    /**\n     * Execute the given UserOperation.\n     * @param op the operation to execute\n     * @param beneficiary the address to receive the fees\n     */\n    function handleOp(UserOperation calldata op, address payable beneficiary) public {\n\n        uint preGas = gasleft();\n\n    unchecked {\n        bytes32 requestId = getRequestId(op);\n        (uint256 prefund, PaymentMode paymentMode, bytes memory context) = _validatePrepayment(0, op, requestId);\n        UserOpInfo memory opInfo = UserOpInfo(\n            requestId,\n            prefund,\n            paymentMode,\n            0,\n            preGas - gasleft() + op.preVerificationGas\n        );\n\n        uint actualGasCost;\n\n        try this.internalHandleOp(op, opInfo, context) returns (uint _actualGasCost) {\n            actualGasCost = _actualGasCost;\n        } catch {\n            uint actualGas = preGas - gasleft() + opInfo.preOpGas;\n            actualGasCost = handlePostOp(0, IPaymaster.PostOpMode.postOpReverted, op, opInfo, context, actualGas);\n        }\n\n        compensate(beneficiary, actualGasCost);\n    } // unchecked\n    }\n\n    function compensate(address payable beneficiary, uint amount) internal {\n        (bool success,) = beneficiary.call{value : amount}(\"\");\n        require(success);\n    }\n\n    /**\n     * Execute a batch of UserOperation.\n     * @param ops the operations to execute\n     * @param beneficiary the address to receive the fees\n     */\n    function handleOps(UserOperation[] calldata ops, address payable beneficiary) public {\n\n        uint opslen = ops.length;\n        UserOpInfo[] memory opInfos = new UserOpInfo[](opslen);\n\n    unchecked {\n        for (uint i = 0; i < opslen; i++) {\n            uint preGas = gasleft();\n            UserOperation calldata op = ops[i];\n\n            bytes memory context;\n            uint contextOffset;\n            bytes32 requestId = getRequestId(op);\n            uint prefund;\n            PaymentMode paymentMode;\n            (prefund, paymentMode, context) = _validatePrepayment(i, op, requestId);\n            assembly {contextOffset := context}\n            opInfos[i] = UserOpInfo(\n                requestId,\n                prefund,\n                paymentMode,\n                contextOffset,\n                preGas - gasleft() + op.preVerificationGas\n            );\n        }\n\n        uint collected = 0;\n\n        for (uint i = 0; i < ops.length; i++) {\n            uint preGas = gasleft();\n            UserOperation calldata op = ops[i];\n            UserOpInfo memory opInfo = opInfos[i];\n            uint contextOffset = opInfo._context;\n            bytes memory context;\n            assembly {context := contextOffset}\n\n            try this.internalHandleOp(op, opInfo, context) returns (uint _actualGasCost) {\n                collected += _actualGasCost;\n            } catch {\n                uint actualGas = preGas - gasleft() + opInfo.preOpGas;\n                collected += handlePostOp(i, IPaymaster.PostOpMode.postOpReverted, op, opInfo, context, actualGas);\n            }\n        }\n\n        compensate(beneficiary, collected);\n    } //unchecked\n    }\n\n    struct UserOpInfo {\n        bytes32 requestId;\n        uint prefund;\n        PaymentMode paymentMode;\n        uint _context;\n        uint preOpGas;\n    }\n\n    function internalHandleOp(UserOperation calldata op, UserOpInfo calldata opInfo, bytes calldata context) external returns (uint actualGasCost) {\n        uint preGas = gasleft();\n        require(msg.sender == address(this));\n\n        IPaymaster.PostOpMode mode = IPaymaster.PostOpMode.opSucceeded;\n        if (op.callData.length > 0) {\n\n            (bool success,bytes memory result) = address(op.getSender()).call{gas : op.callGas}(op.callData);\n            if (!success) {\n                if (result.length > 0) {\n                    emit UserOperationRevertReason(opInfo.requestId, op.getSender(), op.nonce, result);\n                }\n                mode = IPaymaster.PostOpMode.opReverted;\n            }\n        }\n\n    unchecked {\n        uint actualGas = preGas - gasleft() + opInfo.preOpGas;\n        return handlePostOp(0, mode, op, opInfo, context, actualGas);\n    }\n    }\n\n    /**\n     * generate a request Id - unique identifier for this request.\n     * the request ID is a hash over the content of the userOp (except the signature).\n     */\n    function getRequestId(UserOperation calldata userOp) public view returns (bytes32) {\n        return keccak256(abi.encode(userOp.hash(), address(this), block.chainid));\n    }\n\n    /**\n    * Simulate a call to wallet.validateUserOp and paymaster.validatePaymasterUserOp.\n    * Validation succeeds of the call doesn't revert.\n    * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage outside the wallet's data.\n     *      In order to split the running opcodes of the wallet (validateUserOp) from the paymaster's validatePaymasterUserOp,\n     *      it should look for the NUMBER opcode at depth=1 (which itself is a banned opcode)\n     * @return preOpGas total gas used by validation (including contract creation)\n     * @return prefund the amount the wallet had to prefund (zero in case a paymaster pays)\n     */\n    function simulateValidation(UserOperation calldata userOp) external returns (uint preOpGas, uint prefund) {\n        uint preGas = gasleft();\n\n        bytes32 requestId = getRequestId(userOp);\n        (prefund,,) = _validatePrepayment(0, userOp, requestId);\n        preOpGas = preGas - gasleft() + userOp.preVerificationGas;\n\n        require(msg.sender == address(0), \"must be called off-chain with from=zero-addr\");\n    }\n\n    function _getPaymentInfo(UserOperation calldata userOp) internal view returns (uint requiredPrefund, PaymentMode paymentMode) {\n        requiredPrefund = userOp.requiredPreFund();\n        if (userOp.hasPaymaster()) {\n            paymentMode = PaymentMode.paymasterStake;\n        } else {\n            paymentMode = PaymentMode.walletStake;\n        }\n    }\n\n    // create the sender's contract if needed.\n    function _createSenderIfNeeded(UserOperation calldata op) internal {\n        if (op.initCode.length != 0) {\n            // note that we're still under the gas limit of validate, so probably\n            // this create2 creates a proxy account.\n            // @dev initCode must be unique (e.g. contains the signer address), to make sure\n            //   it can only be executed from the entryPoint, and called with its initialization code (callData)\n            address sender1 = ICreate2Deployer(create2factory).deploy(op.initCode, bytes32(op.nonce));\n            require(sender1 != address(0), \"create2 failed\");\n            require(sender1 == op.getSender(), \"sender doesn't match create2 address\");\n        }\n    }\n\n    /// Get counterfactual sender address.\n    ///  Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\n    function getSenderAddress(bytes memory initCode, uint _salt) public view returns (address) {\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0xff),\n                address(create2factory),\n                _salt,\n                keccak256(initCode)\n            )\n        );\n\n        // NOTE: cast last 20 bytes of hash to address\n        return address(uint160(uint256(hash)));\n    }\n\n    //call wallet.validateUserOp, and validate that it paid as needed.\n    // return actual value sent from wallet to \"this\"\n    function _validateWalletPrepayment(uint opIndex, UserOperation calldata op, bytes32 requestId, uint requiredPrefund, PaymentMode paymentMode) internal returns (uint gasUsedByValidateUserOp, uint prefund) {\n    unchecked {\n        uint preGas = gasleft();\n        _createSenderIfNeeded(op);\n        uint missingWalletFunds = 0;\n        address sender = op.getSender();\n        if (paymentMode != PaymentMode.paymasterStake) {\n            uint bal = balanceOf(sender);\n            missingWalletFunds = bal > requiredPrefund ? 0 : requiredPrefund - bal;\n        }\n        try IWallet(sender).validateUserOp{gas : op.verificationGas}(op, requestId, missingWalletFunds) {\n        } catch Error(string memory revertReason) {\n            revert FailedOp(opIndex, address(0), revertReason);\n        } catch {\n            revert FailedOp(opIndex, address(0), \"\");\n        }\n        if (paymentMode != PaymentMode.paymasterStake) {\n            if (requiredPrefund > balanceOf(sender)) {\n                revert FailedOp(opIndex, address(0), \"wallet didn't pay prefund\");\n            }\n            internalDecrementDeposit(sender, requiredPrefund);\n            prefund = requiredPrefund;\n        } else {\n            prefund = 0;\n        }\n        gasUsedByValidateUserOp = preGas - gasleft();\n    }\n    }\n\n    //validate paymaster.validatePaymasterUserOp\n    function _validatePaymasterPrepayment(uint opIndex, UserOperation calldata op, bytes32 requestId, uint requiredPreFund, uint gasUsedByValidateUserOp) internal view returns (bytes memory context) {\n    unchecked {\n        //validate a paymaster has enough stake (including for payment for this TX)\n        // NOTE: when submitting a batch, caller has to make sure a paymaster has enough stake to cover\n        // all its transactions in the batch.\n        if (!isPaymasterStaked(op.paymaster, paymasterStake + requiredPreFund)) {\n            revert FailedOp(opIndex, op.paymaster, \"not enough stake\");\n        }\n        //no pre-pay from paymaster\n        uint gas = op.verificationGas - gasUsedByValidateUserOp;\n        try IPaymaster(op.paymaster).validatePaymasterUserOp{gas : gas}(op, requestId, requiredPreFund) returns (bytes memory _context){\n            context = _context;\n        } catch Error(string memory revertReason) {\n            revert FailedOp(opIndex, op.paymaster, revertReason);\n        } catch {\n            revert FailedOp(opIndex, op.paymaster, \"\");\n        }\n    }\n    }\n\n    function _validatePrepayment(uint opIndex, UserOperation calldata userOp, bytes32 requestId) private returns (uint prefund, PaymentMode paymentMode, bytes memory context){\n\n        uint preGas = gasleft();\n        uint maxGasValues = userOp.preVerificationGas | userOp.verificationGas |\n        userOp.callGas | userOp.maxFeePerGas | userOp.maxPriorityFeePerGas;\n        require(maxGasValues < type(uint120).max, \"gas values overflow\");\n        uint gasUsedByValidateUserOp;\n        uint requiredPreFund;\n        (requiredPreFund, paymentMode) = _getPaymentInfo(userOp);\n\n        (gasUsedByValidateUserOp, prefund) = _validateWalletPrepayment(opIndex, userOp, requestId, requiredPreFund, paymentMode);\n\n        //a \"marker\" where wallet opcode validation is done, by paymaster opcode validation is about to start\n        // (used only by off-chain simulateValidation)\n        uint marker = block.number;\n        (marker);\n\n        if (paymentMode == PaymentMode.paymasterStake) {\n            (context) = _validatePaymasterPrepayment(opIndex, userOp, requestId, requiredPreFund, gasUsedByValidateUserOp);\n        } else {\n            context = \"\";\n        }\n    unchecked {\n        uint gasUsed = preGas - gasleft();\n\n        if (userOp.verificationGas < gasUsed) {\n            revert FailedOp(opIndex, userOp.paymaster, \"Used more than verificationGas\");\n        }\n    }\n    }\n\n    function handlePostOp(uint opIndex, IPaymaster.PostOpMode mode, UserOperation calldata op, UserOpInfo memory opInfo, bytes memory context, uint actualGas) private returns (uint actualGasCost) {\n        uint preGas = gasleft();\n        uint gasPrice = UserOperationLib.gasPrice(op);\n    unchecked {\n        actualGasCost = actualGas * gasPrice;\n        if (opInfo.paymentMode != PaymentMode.paymasterStake) {\n            if (opInfo.prefund < actualGasCost) {\n                revert (\"wallet prefund below actualGasCost\");\n            }\n            uint refund = opInfo.prefund - actualGasCost;\n            internalIncrementDeposit(op.getSender(), refund);\n        } else {\n            if (context.length > 0) {\n                if (mode != IPaymaster.PostOpMode.postOpReverted) {\n                    IPaymaster(op.paymaster).postOp{gas : op.verificationGas}(mode, context, actualGasCost);\n                } else {\n                    try IPaymaster(op.paymaster).postOp{gas : op.verificationGas}(mode, context, actualGasCost) {}\n                    catch Error(string memory reason) {\n                        revert FailedOp(opIndex, op.paymaster, reason);\n                    }\n                    catch {\n                        revert FailedOp(opIndex, op.paymaster, \"postOp revert\");\n                    }\n                }\n            }\n            //paymaster pays for full gas, including for postOp\n            actualGas += preGas - gasleft();\n            actualGasCost = actualGas * gasPrice;\n            //paymaster balance known to be high enough, and to be locked for this block\n            internalDecrementDeposit(op.paymaster, actualGasCost);\n        }\n        bool success = mode == IPaymaster.PostOpMode.opSucceeded;\n        emit UserOperationEvent(opInfo.requestId, op.getSender(), op.paymaster, op.nonce, actualGasCost, gasPrice, success);\n    } // unchecked\n    }\n\n\n    function isPaymasterStaked(address paymaster, uint stake) public view returns (bool) {\n        return isStaked(paymaster, stake, unstakeDelaySec);\n    }\n}"
    },
    {
      "filename": "contracts/StakeManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8;\n\nimport \"hardhat/console.sol\";\n\n/**\n * manage deposit of sender or paymaster, to pay for gas.\n * paymaster must stake some of the deposit.\n */\ncontract StakeManager {\n\n    /// minimum number of blocks to after 'unlock' before amount can be withdrawn.\n    uint32 immutable public unstakeDelaySec;\n\n    constructor(uint32 _unstakeDelaySec) {\n        unstakeDelaySec = _unstakeDelaySec;\n    }\n\n    event Deposited(\n        address indexed account,\n        uint256 totalDeposit,\n        uint256 unstakeDelaySec\n    );\n\n\n    /// Emitted once a stake is scheduled for withdrawal\n    event DepositUnstaked(\n        address indexed account,\n        uint256 withdrawTime\n    );\n\n    event Withdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 withdrawAmount\n    );\n\n    /// @param amount of ether deposited for this account\n    /// @param unstakeDelaySec - time the deposit is locked, after calling unlock (or zero if deposit is not locked)\n    /// @param withdrawTime - first block timestamp where 'withdrawTo' will be callable, or zero if not locked\n    struct DepositInfo {\n        uint112 amount;\n        uint32 unstakeDelaySec;\n        uint64 withdrawTime;\n    }\n\n    /// maps accounts to their deposits\n    mapping(address => DepositInfo) public deposits;\n\n    function getDepositInfo(address account) external view returns (DepositInfo memory info) {\n        return deposits[account];\n    }\n\n    function balanceOf(address account) public view returns (uint) {\n        return deposits[account].amount;\n    }\n\n    receive() external payable {\n        depositTo(msg.sender);\n    }\n\n    function internalIncrementDeposit(address account, uint amount) internal {\n        deposits[account].amount += uint112(amount);\n    }\n\n    function internalDecrementDeposit(address account, uint amount) internal {\n        deposits[account].amount -= uint112(amount);\n    }\n\n    /**\n     * add to the deposit of the given account\n     */\n    function depositTo(address account) public payable {\n        internalIncrementDeposit(account, msg.value);\n        DepositInfo storage info = deposits[account];\n        emit Deposited(msg.sender, info.amount, info.unstakeDelaySec);\n    }\n\n    /**\n     * stake the account's deposit.\n     * any pending unstakeDeposit is first cancelled.\n     * can also set (or increase) the deposit with call.\n     * @param _unstakeDelaySec the new lock time before the deposit can be withdrawn.\n     */\n    function addStakeTo(address account, uint32 _unstakeDelaySec) public payable {\n        DepositInfo storage info = deposits[account];\n        require(_unstakeDelaySec >= info.unstakeDelaySec, \"cannot decrease unstake time\");\n        uint112 amount = deposits[msg.sender].amount + uint112(msg.value);\n        deposits[account] = DepositInfo(\n            amount,\n            _unstakeDelaySec,\n            0);\n        emit Deposited(account, amount, _unstakeDelaySec);\n    }\n\n    /**\n     * attempt to unstake the deposit.\n     * the value can be withdrawn (using withdrawTo) after the unstake delay.\n     */\n    function unstakeDeposit() external {\n        DepositInfo storage info = deposits[msg.sender];\n        require(info.withdrawTime == 0, \"already unstaking\");\n        require(info.unstakeDelaySec != 0, \"not staked\");\n        uint64 withdrawTime = uint64(block.timestamp) + info.unstakeDelaySec;\n        info.withdrawTime = withdrawTime;\n        emit DepositUnstaked(msg.sender, withdrawTime);\n    }\n\n    /**\n     * withdraw from the deposit.\n     * will fail if the deposit is already staked or too low.\n     * after a paymaster unlocks and withdraws some of the value, it must call addStake() to stake the value again.\n     * @param withdrawAddress the address to send withdrawn value.\n     * @param withdrawAmount the amount to withdraw.\n     */\n    function withdrawTo(address payable withdrawAddress, uint withdrawAmount) external {\n        DepositInfo memory info = deposits[msg.sender];\n        if (info.unstakeDelaySec != 0) {\n            require(info.withdrawTime > 0, \"must call unstakeDeposit() first\");\n            require(info.withdrawTime <= block.timestamp, \"Withdrawal is not due\");\n        }\n        require(withdrawAmount <= info.amount, \"Withdraw amount too large\");\n\n        // store the remaining value, with stake info cleared.\n        deposits[msg.sender] = DepositInfo(\n            info.amount - uint112(withdrawAmount),\n            0,\n            0);\n        withdrawAddress.transfer(withdrawAmount);\n        emit Withdrawn(msg.sender, withdrawAddress, withdrawAmount);\n    }\n\n    /**\n     * check if the given account is staked and didn't unlock it yet.\n     * @param account the account (paymaster) to check\n     * @param requiredStake the minimum deposit\n     * @param requiredDelaySec the minimum required stake time.\n     */\n    function isStaked(address account, uint requiredStake, uint requiredDelaySec) public view returns (bool) {\n        DepositInfo memory info = deposits[account];\n        return info.amount >= requiredStake &&\n        info.unstakeDelaySec >= requiredDelaySec &&\n        info.withdrawTime == 0;\n    }\n}"
    }
  ]
}