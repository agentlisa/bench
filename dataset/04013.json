{
  "Title": "[L14] Solidity compiler version is not pinned and it is not the same for all contracts",
  "Content": "The version of Solidity used throughout the codebase is not pinned to the same nor the latest stable version.  \n\nConsider pinning the version of the [Solidity compiler](https://github.com/celo-org/celo-monorepo/blob/b2f0a58fcc7667d41585123aae5b24c47aa894f6/packages/protocol/contracts/common/TransferWhitelist.sol#L1) to its same and latest stable version to prevent introducing unexpected bugs due to incompatible future releases. To choose a specific version, developers should consider both the compilerâ€™s features needed by the project and [the list of known bugs](https://solidity.readthedocs.io/en/latest/bugs.html) associated with each Solidity compiler version.\n\n\n***Update**: Partially fixed on [pull request 5032](https://github.com/celo-org/celo-monorepo/pull/5032). The Solidity compiler is not pinned in the code base and [some new contracts added on pull request 5194](https://github.com/celo-org/celo-monorepo/blob/c7a72358c09204de371d82ddc5f89ea819cb1b8a/packages/protocol/contracts/common/proxies/FixidityLibProxy.sol) do not have the same version of Solidity.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/common/TransferWhitelist.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"./UsingRegistry.sol\";\n\n/**\n * @title Holds a whitelist of addresses for which transfers should not be\n * frozen so that network initialization can take place.\n */\ncontract TransferWhitelist is Ownable, UsingRegistry {\n  using SafeMath for uint256;\n\n  address[] private directlyWhitelistedAddresses;\n  bytes32[] public whitelistedContractIdentifiers;\n\n  event WhitelistedAddress(address indexed addr);\n  event WhitelistedAddressRemoved(address indexed addr);\n  event WhitelistedContractIdentifier(bytes32 indexed contractIdentifier);\n\n  constructor(address registryAddress) public {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n  }\n\n  /**\n   * @notice Add an address to the whitelist.\n   * @param newAddress The address to add.\n   */\n  function whitelistAddress(address newAddress) public onlyOwner {\n    directlyWhitelistedAddresses.push(newAddress);\n    emit WhitelistedAddress(newAddress);\n  }\n\n  /**\n   * @notice Remove an address from the whitelist.\n   * @param removedAddress The address to add.\n   * @param index Index of address in the whitelist.\n   */\n  function removeAddress(address removedAddress, uint256 index) external onlyOwner {\n    require(index < directlyWhitelistedAddresses.length, \"Whitelist index out of range\");\n    require(directlyWhitelistedAddresses[index] == removedAddress, \"Bad whitelist index\");\n    uint256 tailIndex = directlyWhitelistedAddresses.length.sub(1);\n    if (index != tailIndex) {\n      directlyWhitelistedAddresses[index] = directlyWhitelistedAddresses[tailIndex];\n    }\n    directlyWhitelistedAddresses.length = tailIndex;\n    emit WhitelistedAddressRemoved(removedAddress);\n  }\n\n  /**\n   * @notice Adds the registry id of a whitelisted contract.\n   * @param contractIdentifier The id of the contract to be added.\n   */\n  function whitelistRegisteredContract(bytes32 contractIdentifier) external onlyOwner {\n    require(\n      registry.getAddressFor(contractIdentifier) != address(0),\n      \"contractIdentifier does not correspond to a registered address\"\n    );\n    whitelistedContractIdentifiers.push(contractIdentifier);\n    emit WhitelistedContractIdentifier(contractIdentifier);\n  }\n\n  /**\n   * @notice Gets the number of registered contracts\n   * @return The length of whitelistedContractIdentifiers\n   */\n  function getNumberOfWhitelistedContractIdentifiers() external view returns (uint256 length) {\n    return whitelistedContractIdentifiers.length;\n  }\n\n  /**\n   * @notice Set the whitelist of addresses.\n   * @param  _whitelist The new whitelist of addresses.\n   */\n  function setDirectlyWhitelistedAddresses(address[] calldata _whitelist) external onlyOwner {\n    for (uint256 i = 0; i < directlyWhitelistedAddresses.length; i = i.add(1)) {\n      emit WhitelistedAddressRemoved(directlyWhitelistedAddresses[i]);\n    }\n    directlyWhitelistedAddresses.length = 0;\n    for (uint256 i = 0; i < _whitelist.length; i = i.add(1)) {\n      whitelistAddress(_whitelist[i]);\n    }\n  }\n\n  /**\n   * @notice Set the whitelist of registered contracts.\n   * @param  _registeredContracts The new whitelist of registered contract ids.\n   */\n  function setWhitelistedContractIdentifiers(bytes32[] calldata _registeredContracts)\n    external\n    onlyOwner\n  {\n    whitelistedContractIdentifiers = _registeredContracts;\n  }\n\n  /**\n   * @notice Appends the addresses of registered contracts to the\n   * whitelist before returning the list.\n   * @dev If a registry id is not yet registered, the null address\n   * will be appended to the list instead.\n   * @return  The full whitelist of addresses.\n   */\n  function getWhitelist() external view returns (address[] memory) {\n    uint256 len = directlyWhitelistedAddresses.length.add(whitelistedContractIdentifiers.length);\n    address[] memory _whitelist = new address[](len);\n    uint256 i = 0;\n    while (i < directlyWhitelistedAddresses.length) {\n      _whitelist[i] = directlyWhitelistedAddresses[i];\n      i = i.add(1);\n    }\n    for (uint256 j = 0; j < whitelistedContractIdentifiers.length; j = j.add(1)) {\n      _whitelist[i] = registry.getAddressFor(whitelistedContractIdentifiers[j]);\n      i = i.add(1);\n    }\n    return _whitelist;\n  }\n\n  /**\n   * @notice Clears all data (storage and bytecode) at this contract's address.\n   * @dev The balance of this contract is returned to the owner.\n   */\n  function selfDestruct() external onlyOwner {\n    selfdestruct(msg.sender);\n  }\n}"
    }
  ]
}