{
  "Title": "[G-02] Multiple `address` mappings can be combined into a single `mapping` of an `address` to a `struct`, where appropriate",
  "Content": "\nSaves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (20000 gas) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot\n\n*There are 8 instances of this issue:*\n\n```solidity\nFile: contracts/ExtraRewardsDistributor.sol\n\n20        mapping(address => mapping(uint256 => uint256)) public rewardData;\n21        // token -> epochList\n22        mapping(address => uint256[]) public rewardEpochs;\n23        // token -> account -> last claimed epoch index\n24:       mapping(address => mapping(address => uint256)) public userClaims;\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/ExtraRewardsDistributor.sol#L20-L24>\n\n```solidity\nFile: contracts/AuraBalRewardPool.sol\n\n44        mapping(address => uint256) public userRewardPerTokenPaid;\n45        mapping(address => uint256) public rewards;\n46:       mapping(address => uint256) private _balances;\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraBalRewardPool.sol#L44-L46>\n\n```solidity\nFile: contracts/AuraLocker.sol\n\n91        mapping(address => Balances) public balances;\n92        mapping(address => LockedBalance[]) public userLocks;\n93    \n94        // Voting\n95        //     Stored delegations\n96        mapping(address => address) private _delegates;\n97        //     Checkpointed votes\n98        mapping(address => DelegateeCheckpoint[]) private _checkpointedVotes;\n99        //     Delegatee balances (user -> unlock timestamp -> amount)\n100:      mapping(address => mapping(uint256 => uint256)) public delegateeUnlocks;\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraLocker.sol#L91-L100>\n\n```solidity\nFile: contracts/AuraVestedEscrow.sol\n\n35        mapping(address => uint256) public totalLocked;\n36:       mapping(address => uint256) public totalClaimed;\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraVestedEscrow.sol#L35-L36>\n\n```solidity\nFile: convex-platform/contracts/contracts/VoterProxy.sol\n\n35        mapping (address => bool) private stashPool;\n36:       mapping (address => bool) private protectedTokens;\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/VoterProxy.sol#L35-L36>\n\n```solidity\nFile: convex-platform/contracts/contracts/BaseRewardPool.sol\n\n80        mapping(address => uint256) public userRewardPerTokenPaid;\n81        mapping(address => uint256) public rewards;\n82:       mapping(address => uint256) private _balances;\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/BaseRewardPool.sol#L80-L82>\n\n```solidity\nFile: convex-platform/contracts/contracts/VirtualBalanceRewardPool.sol\n\n97        mapping(address => uint256) public userRewardPerTokenPaid;\n98:       mapping(address => uint256) public rewards;\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/VirtualBalanceRewardPool.sol#L97-L98>\n\n```solidity\nFile: convex-platform/contracts/contracts/RewardFactory.sol\n\n27        mapping (address => bool) private rewardAccess;\n28:       mapping(address => uint256[]) public rewardActiveList;\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/RewardFactory.sol#L27-L28>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-05-aura",
  "Code": [
    {
      "filename": "contracts/ExtraRewardsDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport { IExtraRewardsDistributor, IAuraLocker } from \"./Interfaces.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol\";\n\n/**\n * @title   ExtraRewardsDistributor\n * @author  adapted from ConvexFinance\n * @notice  Allows anyone to distribute rewards to the AuraLocker at a given epoch.\n */\ncontract ExtraRewardsDistributor is ReentrancyGuard, IExtraRewardsDistributor {\n    using SafeERC20 for IERC20;\n\n    IAuraLocker public immutable auraLocker;\n\n    // token -> epoch -> amount\n    mapping(address => mapping(uint256 => uint256)) public rewardData;\n    // token -> epochList\n    mapping(address => uint256[]) public rewardEpochs;\n    // token -> account -> last claimed epoch index\n    mapping(address => mapping(address => uint256)) public userClaims;\n\n    /* ========== EVENTS ========== */\n\n    event RewardAdded(address indexed token, uint256 indexed epoch, uint256 reward);\n    event RewardPaid(address indexed user, address indexed token, uint256 reward, uint256 index);\n    event RewardForfeited(address indexed user, address indexed token, uint256 index);\n\n    /**\n     * @dev Simple constructoor\n     * @param _auraLocker Aura Locker address\n     */\n    constructor(address _auraLocker) {\n        auraLocker = IAuraLocker(_auraLocker);\n    }\n\n    /* ========== ADD REWARDS ========== */\n\n    /**\n     * @notice Add a reward to the current epoch. can be called multiple times for the same reward token\n     * @param _token    Reward token address\n     * @param _amount   Amount of reward tokenÏ€\n     */\n    function addReward(address _token, uint256 _amount) external {\n        auraLocker.checkpointEpoch();\n\n        uint256 latestEpoch = auraLocker.epochCount() - 1;\n        _addReward(_token, _amount, latestEpoch);\n    }\n\n    /**\n     * @notice Add reward token to a specific epoch\n     * @param _token    Reward token address\n     * @param _amount   Amount of reward tokens to add\n     * @param _epoch    Which epoch to add to (must be less than the previous epoch)\n     */\n    function addRewardToEpoch(\n        address _token,\n        uint256 _amount,\n        uint256 _epoch\n    ) external {\n        auraLocker.checkpointEpoch();\n\n        uint256 latestEpoch = auraLocker.epochCount() - 1;\n        require(_epoch <= latestEpoch, \"Cannot assign to the future\");\n\n        if (_epoch == latestEpoch) {\n            _addReward(_token, _amount, latestEpoch);\n        } else {\n            uint256 len = rewardEpochs[_token].length;\n            require(len == 0 || rewardEpochs[_token][len - 1] < _epoch, \"Cannot backdate to this epoch\");\n\n            _addReward(_token, _amount, _epoch);\n        }\n    }\n\n    /**\n     * @notice  Transfer reward tokens from sender to contract for vlCVX holders\n     * @dev     Add reward token for specific epoch\n     * @param _token    Reward token address\n     * @param _amount   Amount of reward tokens\n     * @param _epoch    Epoch to add tokens to\n     */\n    function _addReward(\n        address _token,\n        uint256 _amount,\n        uint256 _epoch\n    ) internal nonReentrant {\n        // Pull before reward accrual\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n\n        //convert to reward per token\n        uint256 supply = auraLocker.totalSupplyAtEpoch(_epoch);\n        uint256 rPerT = (_amount * 1e20) / supply;\n        rewardData[_token][_epoch] += rPerT;\n\n        //add epoch to list\n        uint256 len = rewardEpochs[_token].length;\n        if (len == 0 || rewardEpochs[_token][len - 1] < _epoch) {\n            rewardEpochs[_token].push(_epoch);\n        }\n\n        //event\n        emit RewardAdded(_token, _epoch, _amount);\n    }\n\n    /* ========== GET REWARDS ========== */\n\n    /**\n     * @notice Claim rewards for a specific token since the first epoch.\n     * @param _account  Address of vlCVX holder\n     * @param _token    Reward token address\n     */\n    function getReward(address _account, address _token) public {\n        _getReward(_account, _token, 0);\n    }\n\n    /**\n     * @notice Claim rewards for a specific token at a specific epoch\n     * @param _account      Address of vlCVX holder\n     * @param _token        Reward token address\n     * @param _startIndex   Index of rewardEpochs[_token] to start checking for rewards from\n     */\n    function getReward(\n        address _account,\n        address _token,\n        uint256 _startIndex\n    ) public {\n        _getReward(_account, _token, _startIndex);\n    }\n\n    /**\n     * @notice Claim rewards for a specific token at a specific epoch\n     * @param _account     Address of vlCVX holder\n     * @param _token       Reward token address\n     * @param _startIndex  Index of rewardEpochs[_token] to start checking for rewards from\n     */\n    function _getReward(\n        address _account,\n        address _token,\n        uint256 _startIndex\n    ) public {\n        //get claimable tokens\n        (uint256 claimableTokens, uint256 index) = _allClaimableRewards(_account, _token, _startIndex);\n\n        if (claimableTokens > 0) {\n            //set claim checkpoint\n            userClaims[_token][_account] = index;\n\n            //send\n            IERC20(_token).safeTransfer(_account, claimableTokens);\n\n            //event\n            emit RewardPaid(_account, _token, claimableTokens, index);\n        }\n    }\n\n    /**\n     * @notice  Allow a user to set their claimed index forward without claiming rewards\n     *          Because claims cycle through all periods that a specific reward was given\n     *          there becomes a situation where, for example, a new user could lock\n     *          2 years from now and try to claim a token that was given out every week prior.\n     *          This would result in a 2mil gas checkpoint.(about 20k gas * 52 weeks * 2 years)\n     * @param _token  Reward token to forfeit\n     * @param _index  Epoch index to forfeit from\n     */\n    function forfeitRewards(address _token, uint256 _index) external {\n        require(_index > 0 && _index < rewardEpochs[_token].length - 1, \"!past\");\n        require(_index >= userClaims[_token][msg.sender], \"already claimed\");\n\n        //set claim checkpoint. next claim starts from index+1\n        userClaims[_token][msg.sender] = _index + 1;\n\n        emit RewardForfeited(msg.sender, _token, _index);\n    }\n\n    /* ========== VIEW REWARDS ========== */\n\n    /**\n     * @notice Get claimable rewards (rewardToken) for vlCVX holder\n     * @param _account  Address of vlCVX holder\n     * @param _token    Reward token address\n     */\n    function claimableRewards(address _account, address _token) external view returns (uint256) {\n        (uint256 rewards, ) = _allClaimableRewards(_account, _token, 0);\n        return rewards;\n    }\n\n    /**\n     * @notice Get claimable rewards for a token at a specific epoch\n     * @param _account     Address of vlCVX holder\n     * @param _token       Reward token address\n     * @param _epoch       The epoch to check for rewards\n     */\n    function claimableRewardsAtEpoch(\n        address _account,\n        address _token,\n        uint256 _epoch\n    ) external view returns (uint256) {\n        return _claimableRewards(_account, _token, _epoch);\n    }\n\n    /**\n     * @notice  Get all claimable rewards by looping through each epoch starting with the latest\n     *          saved epoch the user last claimed from\n     * @param _account  Address of vlCVX holder\n     * @param _token    Reward token\n     * @param _startIndex  Index of rewardEpochs[_token] to start checking for rewards from\n     */\n    function _allClaimableRewards(\n        address _account,\n        address _token,\n        uint256 _startIndex\n    ) internal view returns (uint256, uint256) {\n        uint256 latestEpoch = auraLocker.epochCount() - 1;\n        // e.g. tokenEpochs = 31, 21\n        uint256 tokenEpochs = rewardEpochs[_token].length;\n\n        // e.g. epochIndex = 0\n        uint256 epochIndex = userClaims[_token][_account];\n        // e.g. epochIndex = 27 > 0 ? 27 : 0 = 27\n        epochIndex = _startIndex > epochIndex ? _startIndex : epochIndex;\n\n        if (epochIndex >= tokenEpochs) {\n            return (0, tokenEpochs);\n        }\n\n        uint256 claimableTokens = 0;\n\n        for (uint256 i = epochIndex; i < tokenEpochs; i++) {\n            //only claimable after rewards are \"locked in\"\n            if (rewardEpochs[_token][i] < latestEpoch) {\n                claimableTokens += _claimableRewards(_account, _token, rewardEpochs[_token][i]);\n                //return index user claims should be set to\n                epochIndex = i + 1;\n            }\n        }\n        return (claimableTokens, epochIndex);\n    }\n\n    /**\n     * @notice Get claimable rewards for a token at a specific epoch\n     * @param _account     Address of vlCVX holder\n     * @param _token       Reward token address\n     * @param _epoch       The epoch to check for rewards\n     */\n    function _claimableRewards(\n        address _account,\n        address _token,\n        uint256 _epoch\n    ) internal view returns (uint256) {\n        //get balance and calc share\n        uint256 balance = auraLocker.balanceAtEpochOf(_epoch, _account);\n        return (balance * rewardData[_token][_epoch]) / 1e20;\n    }\n\n    /**\n     * @notice Simply gets the current epoch count for a given reward token\n     * @param _token    Reward token address\n     * @return _epochs  Number of epochs\n     */\n    function rewardEpochsCount(address _token) external view returns (uint256) {\n        return rewardEpochs[_token].length;\n    }\n}"
    },
    {
      "filename": "contracts/AuraBalRewardPool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport { AuraMath } from \"./AuraMath.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts-0.8/utils/math/SafeMath.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IAuraLocker } from \"./Interfaces.sol\";\n\n/**\n * @title   AuraBalRewardPool\n * @author  Synthetix -> ConvexFinance -> adapted\n * @notice  This AuraBalRewardPool is deployed to support auraBAL deposits during the first 2\n *          weeks of system operation. After which, the BaseRewardPool hooked into the Booster (lockRewards)\n *          will be used for auraBAL farming.\n * @dev     Modifications from convex-platform/contracts/contracts/BaseRewardPool.sol:\n *            - Delayed start (tokens transferred then delay is enforced before notification)\n *            - One time duration of 14 days\n *            - Remove child reward contracts\n *            - Penalty on claim at 20%\n */\ncontract AuraBalRewardPool {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable rewardToken;\n    IERC20 public immutable stakingToken;\n    uint256 public constant duration = 14 days;\n\n    address public immutable rewardManager;\n\n    IAuraLocker public immutable auraLocker;\n    address public immutable penaltyForwarder;\n    uint256 public pendingPenalty = 0;\n    uint256 public immutable startTime;\n\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    uint256 private _totalSupply;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) private _balances;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward, bool locked);\n    event PenaltyForwarded(uint256 amount);\n\n    /**\n     * @dev Simple constructoor\n     * @param _stakingToken  Pool LP token\n     * @param _rewardToken   $AURA\n     * @param _rewardManager Depositor\n     * @param _auraLocker    $AURA lock contract\n     * @param _penaltyForwarder Address to which penalties are sent\n     */\n    constructor(\n        address _stakingToken,\n        address _rewardToken,\n        address _rewardManager,\n        address _auraLocker,\n        address _penaltyForwarder,\n        uint256 _startDelay\n    ) {\n        stakingToken = IERC20(_stakingToken);\n        rewardToken = IERC20(_rewardToken);\n        rewardManager = _rewardManager;\n        auraLocker = IAuraLocker(_auraLocker);\n        penaltyForwarder = _penaltyForwarder;\n        rewardToken.safeApprove(_auraLocker, type(uint256).max);\n\n        require(_startDelay < 2 weeks, \"!delay\");\n        startTime = block.timestamp + _startDelay;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return AuraMath.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(totalSupply())\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            balanceOf(account).mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(\n                rewards[account]\n            );\n    }\n\n    function stake(uint256 _amount) public updateReward(msg.sender) returns (bool) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[msg.sender] = _balances[msg.sender].add(_amount);\n\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(msg.sender, _amount);\n\n        return true;\n    }\n\n    function stakeAll() external returns (bool) {\n        uint256 balance = stakingToken.balanceOf(msg.sender);\n        stake(balance);\n        return true;\n    }\n\n    function stakeFor(address _for, uint256 _amount) public updateReward(_for) returns (bool) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //give to _for\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[_for] = _balances[_for].add(_amount);\n\n        //take away from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(_for, _amount);\n\n        return true;\n    }\n\n    function withdraw(\n        uint256 amount,\n        bool claim,\n        bool lock\n    ) public updateReward(msg.sender) returns (bool) {\n        require(amount > 0, \"RewardPool : Cannot withdraw 0\");\n\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        stakingToken.safeTransfer(msg.sender, amount);\n        emit Withdrawn(msg.sender, amount);\n\n        if (claim) {\n            getReward(lock);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Gives a staker their rewards\n     * @param _lock Lock the rewards? If false, takes a 20% haircut\n     */\n    function getReward(bool _lock) public updateReward(msg.sender) returns (bool) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            if (_lock) {\n                auraLocker.lock(msg.sender, reward);\n            } else {\n                uint256 penalty = (reward * 2) / 10;\n                pendingPenalty += penalty;\n                rewardToken.safeTransfer(msg.sender, reward - penalty);\n            }\n            emit RewardPaid(msg.sender, reward, _lock);\n        }\n        return true;\n    }\n\n    /**\n     * @dev Forwards to the penalty forwarder for distro to Aura Lockers\n     */\n    function forwardPenalty() public {\n        uint256 toForward = pendingPenalty;\n        pendingPenalty = 0;\n        rewardToken.safeTransfer(penaltyForwarder, toForward);\n        emit PenaltyForwarded(toForward);\n    }\n\n    /**\n     * @dev Called once to initialise the rewards based on balance of stakeToken\n     */\n    function initialiseRewards() external returns (bool) {\n        require(msg.sender == rewardManager || block.timestamp > startTime, \"!authorized\");\n        require(rewardRate == 0, \"!one time\");\n\n        uint256 rewardsAvailable = rewardToken.balanceOf(address(this));\n        require(rewardsAvailable > 0, \"!balance\");\n\n        rewardRate = rewardsAvailable.div(duration);\n\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(duration);\n\n        emit RewardAdded(rewardsAvailable);\n\n        return true;\n    }\n}"
    },
    {
      "filename": "contracts/AuraLocker.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\npragma experimental ABIEncoderV2;\n\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts-0.8/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol\";\nimport { AuraMath, AuraMath32, AuraMath112, AuraMath224 } from \"./AuraMath.sol\";\nimport \"./Interfaces.sol\";\n\ninterface IRewardStaking {\n    function stakeFor(address, uint256) external;\n}\n\n/**\n * @title   AuraLocker\n * @author  ConvexFinance\n * @notice  Effectively allows for rolling 16 week lockups of CVX, and provides balances available\n *          at each epoch (1 week). Also receives cvxCrv from `CvxStakingProxy` and redistributes\n *          to depositors.\n * @dev     Invdividual and delegatee vote power lookups both use independent accounting mechanisms.\n */\ncontract AuraLocker is ReentrancyGuard, Ownable, IAuraLocker {\n    using AuraMath for uint256;\n    using AuraMath224 for uint224;\n    using AuraMath112 for uint112;\n    using AuraMath32 for uint32;\n    using SafeERC20 for IERC20;\n\n    /* ==========     STRUCTS     ========== */\n\n    struct RewardData {\n        /// Timestamp for current period finish\n        uint32 periodFinish;\n        /// Last time any user took action\n        uint32 lastUpdateTime;\n        /// RewardRate for the rest of the period\n        uint96 rewardRate;\n        /// Ever increasing rewardPerToken rate, based on % of total supply\n        uint96 rewardPerTokenStored;\n    }\n    struct UserData {\n        uint128 rewardPerTokenPaid;\n        uint128 rewards;\n    }\n    struct EarnedData {\n        address token;\n        uint256 amount;\n    }\n    struct Balances {\n        uint112 locked;\n        uint32 nextUnlockIndex;\n    }\n    struct LockedBalance {\n        uint112 amount;\n        uint32 unlockTime;\n    }\n    struct Epoch {\n        uint224 supply;\n        uint32 date; //epoch start date\n    }\n    struct DelegateeCheckpoint {\n        uint224 votes;\n        uint32 epochStart;\n    }\n\n    /* ========== STATE VARIABLES ========== */\n\n    // Rewards\n    address[] public rewardTokens;\n    uint256 public queuedCvxCrvRewards = 0;\n    uint256 public constant newRewardRatio = 830;\n    //     Core reward data\n    mapping(address => RewardData) public rewardData;\n    //     Reward token -> distributor -> is approved to add rewards\n    mapping(address => mapping(address => bool)) public rewardDistributors;\n    //     User -> reward token -> amount\n    mapping(address => mapping(address => UserData)) public userData;\n    //     Duration that rewards are streamed over\n    uint256 public constant rewardsDuration = 86400 * 7;\n    //     Duration of lock/earned penalty period\n    uint256 public constant lockDuration = rewardsDuration * 17;\n\n    // Balances\n    //     Supplies and historic supply\n    uint256 public lockedSupply;\n    //     Epochs contains only the tokens that were locked at that epoch, not a cumulative supply\n    Epoch[] public epochs;\n    //     Mappings for balance data\n    mapping(address => Balances) public balances;\n    mapping(address => LockedBalance[]) public userLocks;\n\n    // Voting\n    //     Stored delegations\n    mapping(address => address) private _delegates;\n    //     Checkpointed votes\n    mapping(address => DelegateeCheckpoint[]) private _checkpointedVotes;\n    //     Delegatee balances (user -> unlock timestamp -> amount)\n    mapping(address => mapping(uint256 => uint256)) public delegateeUnlocks;\n\n    // Config\n    //     Tokens\n    IERC20 public immutable stakingToken;\n    address public immutable cvxCrv;\n    //     Denom for calcs\n    uint256 public constant denominator = 10000;\n    //     Staking cvxCrv\n    address public immutable cvxcrvStaking;\n    //     Incentives\n    uint256 public kickRewardPerEpoch = 100;\n    uint256 public kickRewardEpochDelay = 3;\n    //     Shutdown\n    bool public isShutdown = false;\n\n    // Basic token data\n    string private _name;\n    string private _symbol;\n    uint8 private immutable _decimals;\n\n    /* ========== EVENTS ========== */\n\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n    event DelegateCheckpointed(address indexed delegate);\n\n    event Recovered(address _token, uint256 _amount);\n    event RewardPaid(address indexed _user, address indexed _rewardsToken, uint256 _reward);\n    event Staked(address indexed _user, uint256 _paidAmount, uint256 _lockedAmount);\n    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);\n    event KickReward(address indexed _user, address indexed _kicked, uint256 _reward);\n    event RewardAdded(address indexed _token, uint256 _reward);\n\n    event KickIncentiveSet(uint256 rate, uint256 delay);\n    event Shutdown();\n\n    /***************************************\n                    CONSTRUCTOR\n    ****************************************/\n\n    /**\n     * @param _nameArg          Token name, simples\n     * @param _symbolArg        Token symbol\n     * @param _stakingToken     CVX (0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B)\n     * @param _cvxCrv           cvxCRV (0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7)\n     * @param _cvxCrvStaking    cvxCRV rewards (0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e)\n     */\n    constructor(\n        string memory _nameArg,\n        string memory _symbolArg,\n        address _stakingToken,\n        address _cvxCrv,\n        address _cvxCrvStaking\n    ) Ownable() {\n        _name = _nameArg;\n        _symbol = _symbolArg;\n        _decimals = 18;\n\n        stakingToken = IERC20(_stakingToken);\n        cvxCrv = _cvxCrv;\n        cvxcrvStaking = _cvxCrvStaking;\n\n        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        epochs.push(Epoch({ supply: 0, date: uint32(currentEpoch) }));\n    }\n\n    /***************************************\n                    MODIFIER\n    ****************************************/\n\n    modifier updateReward(address _account) {\n        {\n            Balances storage userBalance = balances[_account];\n            uint256 rewardTokensLength = rewardTokens.length;\n            for (uint256 i = 0; i < rewardTokensLength; i++) {\n                address token = rewardTokens[i];\n                uint256 newRewardPerToken = _rewardPerToken(token);\n                rewardData[token].rewardPerTokenStored = newRewardPerToken.to96();\n                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(rewardData[token].periodFinish).to32();\n                if (_account != address(0)) {\n                    userData[_account][token] = UserData({\n                        rewardPerTokenPaid: newRewardPerToken.to128(),\n                        rewards: _earned(_account, token, userBalance.locked).to128()\n                    });\n                }\n            }\n        }\n        _;\n    }\n\n    /***************************************\n                    ADMIN\n    ****************************************/\n\n    // Add a new reward token to be distributed to stakers\n    function addReward(address _rewardsToken, address _distributor) external onlyOwner {\n        require(rewardData[_rewardsToken].lastUpdateTime == 0, \"Reward already exists\");\n        require(_rewardsToken != address(stakingToken), \"Cannot add StakingToken as reward\");\n        rewardTokens.push(_rewardsToken);\n        rewardData[_rewardsToken].lastUpdateTime = uint32(block.timestamp);\n        rewardData[_rewardsToken].periodFinish = uint32(block.timestamp);\n        rewardDistributors[_rewardsToken][_distributor] = true;\n    }\n\n    // Modify approval for an address to call notifyRewardAmount\n    function approveRewardDistributor(\n        address _rewardsToken,\n        address _distributor,\n        bool _approved\n    ) external onlyOwner {\n        require(rewardData[_rewardsToken].lastUpdateTime > 0, \"Reward does not exist\");\n        rewardDistributors[_rewardsToken][_distributor] = _approved;\n    }\n\n    //set kick incentive\n    function setKickIncentive(uint256 _rate, uint256 _delay) external onlyOwner {\n        require(_rate <= 500, \"over max rate\"); //max 5% per epoch\n        require(_delay >= 2, \"min delay\"); //minimum 2 epochs of grace\n        kickRewardPerEpoch = _rate;\n        kickRewardEpochDelay = _delay;\n\n        emit KickIncentiveSet(_rate, _delay);\n    }\n\n    //shutdown the contract. unstake all tokens. release all locks\n    function shutdown() external onlyOwner {\n        isShutdown = true;\n        emit Shutdown();\n    }\n\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {\n        require(_tokenAddress != address(stakingToken), \"Cannot withdraw staking token\");\n        require(rewardData[_tokenAddress].lastUpdateTime == 0, \"Cannot withdraw reward token\");\n        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);\n        emit Recovered(_tokenAddress, _tokenAmount);\n    }\n\n    // Set approvals for staking cvx and cvxcrv\n    function setApprovals() external {\n        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);\n        IERC20(cvxCrv).safeApprove(cvxcrvStaking, type(uint256).max);\n    }\n\n    /***************************************\n                    ACTIONS\n    ****************************************/\n\n    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards\n    function lock(address _account, uint256 _amount) external nonReentrant updateReward(_account) {\n        //pull tokens\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        //lock\n        _lock(_account, _amount);\n    }\n\n    //lock tokens\n    function _lock(address _account, uint256 _amount) internal {\n        require(_amount > 0, \"Cannot stake 0\");\n        require(!isShutdown, \"shutdown\");\n\n        Balances storage bal = balances[_account];\n\n        //must try check pointing epoch first\n        _checkpointEpoch();\n\n        //add user balances\n        uint112 lockAmount = _amount.to112();\n        bal.locked = bal.locked.add(lockAmount);\n\n        //add to total supplies\n        lockedSupply = lockedSupply.add(_amount);\n\n        //add user lock records or add to current\n        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 unlockTime = currentEpoch.add(lockDuration);\n        uint256 idx = userLocks[_account].length;\n        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {\n            userLocks[_account].push(LockedBalance({ amount: lockAmount, unlockTime: uint32(unlockTime) }));\n        } else {\n            LockedBalance storage userL = userLocks[_account][idx - 1];\n            userL.amount = userL.amount.add(lockAmount);\n        }\n\n        address delegatee = delegates(_account);\n        if (delegatee != address(0)) {\n            delegateeUnlocks[delegatee][unlockTime] += lockAmount;\n            _checkpointDelegate(delegatee, lockAmount, 0);\n        }\n\n        //update epoch supply, epoch checkpointed above so safe to add to latest\n        Epoch storage e = epochs[epochs.length - 1];\n        e.supply = e.supply.add(lockAmount);\n\n        emit Staked(_account, lockAmount, lockAmount);\n    }\n\n    // claim all pending rewards\n    function getReward(address _account) external {\n        getReward(_account, false);\n    }\n\n    // Claim all pending rewards\n    function getReward(address _account, bool _stake) public nonReentrant updateReward(_account) {\n        uint256 rewardTokensLength = rewardTokens.length;\n        for (uint256 i; i < rewardTokensLength; i++) {\n            address _rewardsToken = rewardTokens[i];\n            uint256 reward = userData[_account][_rewardsToken].rewards;\n            if (reward > 0) {\n                userData[_account][_rewardsToken].rewards = 0;\n                if (_rewardsToken == cvxCrv && _stake && _account == msg.sender) {\n                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);\n                } else {\n                    IERC20(_rewardsToken).safeTransfer(_account, reward);\n                }\n                emit RewardPaid(_account, _rewardsToken, reward);\n            }\n        }\n    }\n\n    function checkpointEpoch() external {\n        _checkpointEpoch();\n    }\n\n    //insert a new epoch if needed. fill in any gaps\n    function _checkpointEpoch() internal {\n        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 epochindex = epochs.length;\n\n        //first epoch add in constructor, no need to check 0 length\n        //check to add\n        if (epochs[epochindex - 1].date < currentEpoch) {\n            //fill any epoch gaps until the next epoch date.\n            while (epochs[epochs.length - 1].date != currentEpoch) {\n                uint256 nextEpochDate = uint256(epochs[epochs.length - 1].date).add(rewardsDuration);\n                epochs.push(Epoch({ supply: 0, date: uint32(nextEpochDate) }));\n            }\n        }\n    }\n\n    // Withdraw/relock all currently locked tokens where the unlock time has passed\n    function processExpiredLocks(bool _relock) external nonReentrant {\n        _processExpiredLocks(msg.sender, _relock, msg.sender, 0);\n    }\n\n    function kickExpiredLocks(address _account) external nonReentrant {\n        //allow kick after grace period of 'kickRewardEpochDelay'\n        _processExpiredLocks(_account, false, msg.sender, rewardsDuration.mul(kickRewardEpochDelay));\n    }\n\n    // Withdraw without checkpointing or accruing any rewards, providing system is shutdown\n    function emergencyWithdraw() external nonReentrant {\n        require(isShutdown, \"Must be shutdown\");\n\n        LockedBalance[] memory locks = userLocks[msg.sender];\n        Balances storage userBalance = balances[msg.sender];\n\n        uint256 amt = userBalance.locked;\n        require(amt > 0, \"Nothing locked\");\n\n        userBalance.locked = 0;\n        userBalance.nextUnlockIndex = locks.length.to32();\n        lockedSupply -= amt;\n\n        emit Withdrawn(msg.sender, amt, false);\n\n        stakingToken.safeTransfer(msg.sender, amt);\n    }\n\n    // Withdraw all currently locked tokens where the unlock time has passed\n    function _processExpiredLocks(\n        address _account,\n        bool _relock,\n        address _rewardAddress,\n        uint256 _checkDelay\n    ) internal updateReward(_account) {\n        LockedBalance[] storage locks = userLocks[_account];\n        Balances storage userBalance = balances[_account];\n        uint112 locked;\n        uint256 length = locks.length;\n        uint256 reward = 0;\n        uint256 expiryTime = _checkDelay == 0 && _relock\n            ? block.timestamp.add(rewardsDuration)\n            : block.timestamp.sub(_checkDelay);\n        require(length > 0, \"no locks\");\n        // e.g. now = 16\n        // if contract is shutdown OR latest lock unlock time (e.g. 17) <= now - (1)\n        // e.g. 17 <= (16 + 1)\n        if (isShutdown || locks[length - 1].unlockTime <= expiryTime) {\n            //if time is beyond last lock, can just bundle everything together\n            locked = userBalance.locked;\n\n            //dont delete, just set next index\n            userBalance.nextUnlockIndex = length.to32();\n\n            //check for kick reward\n            //this wont have the exact rewar"
    }
  ]
}