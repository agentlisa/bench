{
  "Title": "[M-08] USDT is not supported because of approval mechanism",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathHouse.sol#L180\nhttps://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L157\nhttps://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathToken.sol#L256\n\n\n# Vulnerability details\n\nWhen using the approval mechanism in USDT, the approval must be set to 0 before it is updated.\nIn Rubicon, when creating a pair, the paired asset's approval is not set to 0 before it is updated.\n\n## Impact\nCan't create pairs with USDT, the most popular stablecoin, as as the approval will revert.\n\n## Proof of Concept\n[USDT](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code) reverts on approval if previous allowance is not 0:\n```\nrequire(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\n```\nWhen creating a pair, Rubicon [approves](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathHouse.sol#L180) the paired asset without first setting it to 0:\n```\ndesiredPairedAsset.approve(pairedPool, initialLiquidityExistingBathToken);\n```\nTherefore, if desiredPairedAsset is USDT, the function will revert, and pairs with USDT can not be created.\n\nThis problem will also manifest in RubiconMarket's [approval function](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L157) and BathToken's [approval function](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathToken.sol#L256), \n\n## Recommended Mitigation Steps\nSet the allowance to 0 before setting it to the new value.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-rubicon-contest",
  "Code": [
    {
      "filename": "contracts/rubiconPools/BathHouse.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/// @title  The administrator contract of Rubicon Pools\n/// @author Rubicon DeFi Inc. - bghughes.eth\n/// @notice The BathHouse initializes proxy-wrapped bathTokens, manages approved strategists, and sets system variables\n\npragma solidity =0.7.6;\n\nimport \"./BathToken.sol\";\nimport \"../interfaces/IBathPair.sol\";\nimport \"../interfaces/IBathToken.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol\";\n\ncontract BathHouse {\n    /// *** Storage Variables ***\n\n    /// @notice Rubicon Bath House\n    string public name;\n\n    /// @notice The administrator of the Bath House contract\n    address public admin;\n\n    /// @notice The proxy administrator of Bath Tokens\n    address public proxyManager;\n\n    /// @notice The core Rubicon Market of the Pools system\n    address public RubiconMarketAddress;\n\n    /// @notice A mapping of approved strategists to access Pools liquidity\n    mapping(address => bool) public approvedStrategists;\n\n    /// @notice The initialization status of BathHouse\n    bool public initialized;\n\n    /// @notice If true, strategists are permissioned and must be approved by admin\n    bool public permissionedStrategists;\n\n    /// @notice Key, system-wide risk parameter for all liquity Pools\n    /// @notice This represents the proportion of a pool's underlying assets that must remain in the pool\n    /// @dev This protects a run on the bank scenario and ensures users can withdraw while allowing funds to be utilized for yield in the market\n    uint256 public reserveRatio;\n\n    /// @notice A variable time delay after which a strategist must return funds to the Bath Token\n    uint256 public timeDelay;\n\n    /// @notice The lone Bath Pair contract of the system which acts as the strategist entry point and logic contract\n    address public approvedPairContract;\n\n    /// @notice The basis point fee that is paid to strategists from LPs on capital that is successfully rebalanced to a Bath Token\n    uint8 public bpsToStrategists;\n\n    /// @notice Key mapping for determining the address of a Bath Token based on its underlying asset\n    /// @dev Source of truth mapping that logs all ERC20 Liquidity pools underlying asset => bathToken Address\n    mapping(address => address) public tokenToBathToken;\n\n    /// @notice The BathToken.sol implementation that any new bathTokens inherit\n    /// @dev The implementation of any ~newly spawned~ proxy-wrapped Bath Tokens via _createBathToken\n    address public newBathTokenImplementation;\n\n    /// *** Events ***\n\n    /// @notice An event that signals the creation of a new Bath Token\n    event LogNewBathToken(\n        address underlyingToken,\n        address bathTokenAddress,\n        address bathTokenFeeAdmin,\n        uint256 timestamp,\n        address bathTokenCreator\n    );\n\n    /// @notice An event that signals the permissionless spawning of a new Bath Token\n    event LogOpenCreationSignal(\n        ERC20 newERC20Underlying,\n        address spawnedBathToken,\n        uint256 initialNewBathTokenDeposit,\n        ERC20 pairedExistingAsset,\n        address pairedExistingBathToken,\n        uint256 pairedBathTokenDeposit,\n        address signaler\n    );\n\n    /// *** Modifiers ***\n\n    /// @notice This modifier enforces that only the admin can call these functions\n    modifier onlyAdmin() {\n        require(msg.sender == admin);\n        _;\n    }\n\n    /// *** External Functions ***\n\n    /// @notice The constructor-like initialization function\n    /// @dev Proxy-safe initialization of storage that sets key storage variables\n    /// @dev Admin is set to msg.sender\n    function initialize(\n        address market,\n        uint256 _reserveRatio,\n        uint256 _timeDelay,\n        address _newBathTokenImplementation,\n        address _proxyAdmin\n    ) external {\n        require(!initialized);\n        name = \"Rubicon Bath House\";\n        admin = msg.sender;\n        timeDelay = _timeDelay;\n\n        // Set Bath Token reserve ratio globally\n        require(_reserveRatio <= 100);\n        require(_reserveRatio > 0);\n        reserveRatio = _reserveRatio;\n\n        // Set BPS reward fee for successful strategist market-making\n        /// @notice [(10000 - {bpsToStrategists}) / 10000] BPS of MM-ing activity is passed to users\n        bpsToStrategists = 20;\n\n        // Set key storage variables\n        RubiconMarketAddress = market;\n        permissionedStrategists = true;\n        newBathTokenImplementation = _newBathTokenImplementation;\n        proxyManager = _proxyAdmin;\n\n        // Automatically approve admin as an approved strategist\n        approveStrategist(admin);\n\n        // Complete contract instantiation\n        initialized = true;\n    }\n\n    /// @notice Permissionless entry point to spawn a Bath Token while posting liquidity to a ~pair of Bath Tokens~\n    /// @notice Please note, creating a Bath Token in this fashion ~does not~ gaurentee markets will be made for the new pair. This function signals the desire to have a new pair supported on Rubicon for strategists to consider market-making for\n    /// @notice The best desiredPairedAsset to select is a popular quote currency. Many traditional systems quote in USD while the ETH quote is superior - the choice is yours sweet msg.sender\n    /// @dev The user must approve the bathHouse to spend their ERC20s\n    /// @dev The user can only spawn a Bath Token for an ERC20 that is not yet in the Pools system and they must post liquidity on the other side of the pair for an ~extant Bath Token~\n    function openBathTokenSpawnAndSignal(\n        ERC20 newBathTokenUnderlying,\n        uint256 initialLiquidityNew, // Must approve this contract to spend\n        ERC20 desiredPairedAsset, // Must be paired with an existing quote for v1\n        uint256 initialLiquidityExistingBathToken\n    ) external returns (address newBathToken) {\n        // Check that it doesn't already exist\n        require(\n            getBathTokenfromAsset(newBathTokenUnderlying) == address(0),\n            \"bathToken already exists for that ERC20\"\n        );\n        require(\n            getBathTokenfromAsset(desiredPairedAsset) != address(0),\n            \"bathToken does not exist for that desiredPairedAsset\"\n        );\n\n        // Spawn a bathToken for the new asset\n        address newOne = _createBathToken(newBathTokenUnderlying, address(0)); // NOTE: address(0) as feeAdmin means fee is paid to pool holders\n\n        // Deposit initial liquidity posted of newBathTokenUnderlying\n        require(\n            newBathTokenUnderlying.transferFrom(\n                msg.sender,\n                address(this),\n                initialLiquidityNew\n            ),\n            \"Couldn't transferFrom your initial liquidity - make sure to approve BathHouse.sol\"\n        );\n\n        newBathTokenUnderlying.approve(newOne, initialLiquidityNew);\n\n        // Deposit assets and send Bath Token shares to msg.sender\n        IBathToken(newOne).deposit(initialLiquidityNew, msg.sender);\n\n        // desiredPairedAsset must be pulled and deposited into bathToken\n        require(\n            desiredPairedAsset.transferFrom(\n                msg.sender,\n                address(this),\n                initialLiquidityExistingBathToken\n            ),\n            \"Couldn't transferFrom your initial liquidity - make sure to approve BathHouse.sol\"\n        );\n        address pairedPool = getBathTokenfromAsset((desiredPairedAsset));\n        desiredPairedAsset.approve(\n            pairedPool,\n            initialLiquidityExistingBathToken\n        );\n\n        // Deposit assets and send Bath Token shares to msg.sender\n        IBathToken(pairedPool).deposit(\n            initialLiquidityExistingBathToken,\n            msg.sender\n        );\n\n        // emit an event describing the new pair, underlyings and bathTokens\n        emit LogOpenCreationSignal(\n            newBathTokenUnderlying,\n            newOne,\n            initialLiquidityNew,\n            desiredPairedAsset,\n            pairedPool,\n            initialLiquidityExistingBathToken,\n            msg.sender\n        );\n\n        newBathToken = newOne;\n    }\n\n    /// ** Admin-Only Functions **\n\n    /// @notice An admin-only function to create a new Bath Token for any ERC20\n    function createBathToken(ERC20 underlyingERC20, address _feeAdmin)\n        external\n        onlyAdmin\n        returns (address newBathTokenAddress)\n    {\n        newBathTokenAddress = _createBathToken(underlyingERC20, _feeAdmin);\n    }\n\n    /// @notice A migration function that allows the admin to write arbitrarily to tokenToBathToken\n    function adminWriteBathToken(ERC20 overwriteERC20, address newBathToken)\n        external\n        onlyAdmin\n    {\n        tokenToBathToken[address(overwriteERC20)] = newBathToken;\n        emit LogNewBathToken(\n            address(overwriteERC20),\n            newBathToken,\n            address(0),\n            block.timestamp,\n            msg.sender\n        );\n    }\n\n    /// @notice Function to initialize and store the address of the ~lone~ bathPair contract for the Rubicon protocol\n    function initBathPair(\n        address _bathPairAddress,\n        uint256 _maxOrderSizeBPS,\n        int128 _shapeCoefNum\n    ) external onlyAdmin returns (address newPair) {\n        require(\n            approvedPairContract == address(0),\n            \"BathPair already approved\"\n        );\n        require(\n            IBathPair(_bathPairAddress).initialized() != true,\n            \"BathPair already initialized\"\n        );\n        newPair = _bathPairAddress;\n\n        IBathPair(newPair).initialize(_maxOrderSizeBPS, _shapeCoefNum);\n\n        approvedPairContract = newPair;\n    }\n\n    /// @notice Admin-only function to set a new Admin\n    function setBathHouseAdmin(address newAdmin) external onlyAdmin {\n        admin = newAdmin;\n    }\n\n    /// @notice Admin-only function to set a new Bath Token implementation\n    /// @dev Please note that all bathTokens created will use this abi\n    function setNewBathTokenImplementation(address newImplementation) external onlyAdmin {\n        newBathTokenImplementation = newImplementation;\n    }\n\n    /// @notice Admin-only function to approve a new permissioned strategist\n    function approveStrategist(address strategist) public onlyAdmin {\n        approvedStrategists[strategist] = true;\n    }\n\n    /// @notice Admin-only function to set whether or not strategists are permissioned\n    function setPermissionedStrategists(bool _new) external onlyAdmin {\n        permissionedStrategists = _new;\n    }\n\n    /// @notice Admin-only function to set timeDelay\n    function setCancelTimeDelay(uint256 value) external onlyAdmin {\n        timeDelay = value;\n    }\n\n    /// @notice Admin-only function to set reserveRatio\n    function setReserveRatio(uint256 rr) external onlyAdmin {\n        require(rr <= 100);\n        require(rr > 0);\n        reserveRatio = rr;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's timeDelay\n    function setBathTokenMarket(address bathToken, address newMarket)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setMarket(newMarket);\n    }\n\n    /// @notice Admin-only function to add a bonus token to a Bath Token's reward schema\n    function setBonusToken(address bathToken, address newBonusToken)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setBonusToken(newBonusToken);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's Bath House admin\n    function setBathTokenBathHouse(address bathToken, address newAdmin)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setBathHouse(newAdmin);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's feeBPS\n    function setBathTokenFeeBPS(address bathToken, uint256 newBPS)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setFeeBPS(newBPS);\n    }\n\n    /// @notice Admin-only function to approve the Bath Token's underlying token on the assigned market\n    /// @dev required in case the market address ever changes.. #battleScars\n    function bathTokenApproveSetMarket(address targetBathToken)\n        external\n        onlyAdmin\n    {\n        IBathToken(targetBathToken).approveMarket();\n    }\n\n    /// @notice Admin-only function to set a Bath Token's fee recipient (typically the Bath Token itself)\n    function setBathTokenFeeTo(address bathToken, address feeTo)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setFeeTo(feeTo);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's target Rubicon Market\n    function setMarket(address newMarket) external onlyAdmin {\n        RubiconMarketAddress = newMarket;\n    }\n\n    /// *** View Functions ***\n\n    // Getter Functions for parameters\n    function getMarket() external view returns (address) {\n        return RubiconMarketAddress;\n    }\n\n    function getReserveRatio() external view returns (uint256) {\n        return reserveRatio;\n    }\n\n    function getCancelTimeDelay() external view returns (uint256) {\n        return timeDelay;\n    }\n\n    /// @notice Returns the address of any bathToken in the system based on its corresponding underlying asset\n    function getBathTokenfromAsset(ERC20 asset) public view returns (address) {\n        return tokenToBathToken[address(asset)];\n    }\n\n    function getBPSToStrats() public view returns (uint8) {\n        return bpsToStrategists;\n    }\n\n    /// *** System Security Checks ***\n\n    /// @notice A function to check whether or not an address is an approved strategist\n    function isApprovedStrategist(address wouldBeStrategist)\n        external\n        view\n        returns (bool)\n    {\n        if (\n            approvedStrategists[wouldBeStrategist] == true ||\n            !permissionedStrategists\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /// @notice A function to check whether or not an address is the approved system instance of BathPair.sol\n    function isApprovedPair(address pair) public view returns (bool outcome) {\n        pair == approvedPairContract ? outcome = true : outcome = false;\n    }\n\n    /// *** Internal Functions ***\n\n    /// @dev Low-level functionality to spawn a Bath Token using the OZ Transparent Upgradeable Proxy standard\n    /// @param underlyingERC20 The underlying ERC-20 asset that underlies the newBathTokenAddress\n    /// @param _feeAdmin Recipient of pool withdrawal fees, typically the pool itself\n    function _createBathToken(ERC20 underlyingERC20, address _feeAdmin)\n        internal\n        returns (address newBathTokenAddress)\n    {\n        require(initialized, \"BathHouse not initialized\");\n        address _underlyingERC20 = address(underlyingERC20);\n        require(\n            _underlyingERC20 != address(0),\n            \"Cant create bathToken for zero address\"\n        );\n\n        // Check that it isn't already logged in the registry\n        require(\n            tokenToBathToken[_underlyingERC20] == address(0),\n            \"bathToken already exists\"\n        );\n\n        // Creates a new bathToken that is upgradeable by the proxyManager\n        require(\n            newBathTokenImplementation != address(0),\n            \"no implementation set for bathTokens\"\n        );\n\n        // Note, the option of a fee recipient for pool withdrawls exists. For all pools this is set to the pool itself in production and is visible via ~feeTo~ on any respective contract\n        // Note, fee admin presently ignored in the Bath Token initialization() call via defaulting to itself; though, this is still upgradeable by the Bath House admin via\n        bytes memory _initData = abi.encodeWithSignature(\n            \"initialize(address,address,address)\",\n            _underlyingERC20,\n            (RubiconMarketAddress),\n            (_feeAdmin)\n        );\n\n\n            TransparentUpgradeableProxy newBathToken\n         = new TransparentUpgradeableProxy(\n            newBathTokenImplementation,\n            proxyManager,\n            _initData\n        );\n\n        // New Bath Token Address\n        newBathTokenAddress = address(newBathToken);\n\n        // Write to source-of-truth router mapping for this ERC-20 => Bath Token\n        tokenToBathToken[_underlyingERC20] = newBathTokenAddress;\n\n        // Log Data\n        emit LogNewBathToken(\n            _underlyingERC20,\n            newBathTokenAddress,\n            _feeAdmin,\n            block.timestamp,\n            msg.sender\n        );\n    }\n}"
    },
    {
      "filename": "contracts/RubiconRouter.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/// @author Benjamin Hughes - Rubicon\n/// @notice This contract is a router to interact with the low-level functions present in RubiconMarket and Pools\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"./RubiconMarket.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./peripheral_contracts/WETH9.sol\"; // @unsupported: ovm\nimport \"./interfaces/IBathToken.sol\";\n\n///@dev this contract is a high-level router that utilizes Rubicon smart contracts to provide\n///@dev added convenience and functionality when interacting with the Rubicon protocol\ncontract RubiconRouter {\n    using SafeMath for uint256;\n\n    address public RubiconMarketAddress;\n\n    address payable public wethAddress;\n\n    bool public started;\n\n    event LogNote(string, uint256);\n\n    event LogSwap(\n        uint256 inputAmount,\n        address inputERC20,\n        uint256 hurdleBuyAmtMin,\n        address targetERC20,\n        bytes32 indexed pair,\n        uint256 realizedFill,\n        address recipient\n    );\n\n    receive() external payable {}\n\n    fallback() external payable {}\n\n    function startErUp(address _theTrap, address payable _weth) external {\n        require(!started);\n        RubiconMarketAddress = _theTrap;\n        wethAddress = _weth;\n        started = true;\n    }\n\n    /// @notice Get the outstanding best N orders from both sides of the order book for a given pair\n    /// @dev The asset/quote pair ordering will affect return values - asset should be the top of the pair: for example, (ETH, USDC, 10) will return (10 best ETH asks, 10 best USDC bids, 10)\n    /// @param asset the ERC20 token that represents the ask/sell side of the order book\n    /// @param quote the ERC20 token that represents the bid/buy side of the order book\n    /// @param topNOrders the depth of the order book the caller would like to query/view for the asset-quote pair\n    /// @dev \"best\" orders are determined by proximity to the midpoint of the pair. Closest to the midpoint is best order.\n    /// @return Fixed arrays (of topNOrders length) in \"best\" order (returned asks/bids[0] is best and asks/bids[topNOrders] is worst) of asks and bids + topNOrders. Each offer array item is: [pay, buy, offerId]\n    function getBookFromPair(\n        ERC20 asset,\n        ERC20 quote,\n        uint256 topNOrders\n    )\n        public\n        view\n        returns (\n            uint256[3][] memory,\n            uint256[3][] memory,\n            uint256\n        )\n    {\n        uint256[3][] memory asks = new uint256[3][](topNOrders);\n        uint256[3][] memory bids = new uint256[3][](topNOrders);\n        address _RubiconMarketAddress = RubiconMarketAddress;\n\n        //1. Get best offer for each asset\n        uint256 bestAskID = RubiconMarket(_RubiconMarketAddress).getBestOffer(\n            asset,\n            quote\n        );\n        uint256 bestBidID = RubiconMarket(_RubiconMarketAddress).getBestOffer(\n            quote,\n            asset\n        );\n\n        uint256 lastBid = 0;\n        uint256 lastAsk = 0;\n        //2. Iterate from that offer down the book until topNOrders\n        for (uint256 index = 0; index < topNOrders; index++) {\n            if (index == 0) {\n                lastAsk = bestAskID;\n                lastBid = bestBidID;\n\n                (\n                    uint256 _ask_pay_amt,\n                    ,\n                    uint256 _ask_buy_amt,\n\n                ) = RubiconMarket(_RubiconMarketAddress).getOffer(bestAskID);\n                (\n                    uint256 _bid_pay_amt,\n                    ,\n                    uint256 _bid_buy_amt,\n\n                ) = RubiconMarket(_RubiconMarketAddress).getOffer(bestBidID);\n                asks[index] = [_ask_pay_amt, _ask_buy_amt, bestAskID];\n                bids[index] = [_bid_pay_amt, _bid_buy_amt, bestBidID];\n                continue;\n            }\n            uint256 nextBestAsk = RubiconMarket(_RubiconMarketAddress)\n            .getWorseOffer(lastAsk);\n            uint256 nextBestBid = RubiconMarket(_RubiconMarketAddress)\n            .getWorseOffer(lastBid);\n            (uint256 ask_pay_amt, , uint256 ask_buy_amt, ) = RubiconMarket(\n                _RubiconMarketAddress\n            ).getOffer(nextBestAsk);\n            (uint256 bid_pay_amt, , uint256 bid_buy_amt, ) = RubiconMarket(\n                _RubiconMarketAddress\n            ).getOffer(nextBestBid);\n\n            asks[index] = [ask_pay_amt, ask_buy_amt, nextBestAsk];\n            bids[index] = [bid_pay_amt, bid_buy_amt, nextBestBid];\n            // bids[index] = nextBestBid;\n            lastBid = nextBestBid;\n            lastAsk = nextBestAsk;\n        }\n\n        //3. Return those topNOrders for either side of the order book\n        return (asks, bids, topNOrders);\n    }\n\n    /// @dev this function returns the best offer for a pair's id and info\n    function getBestOfferAndInfo(address asset, address quote)\n        public\n        view\n        returns (\n            uint256, //id\n            uint256,\n            ERC20,\n            uint256,\n            ERC20\n        )\n    {\n        address _market = RubiconMarketAddress;\n        uint256 offer = RubiconMarket(_market).getBestOffer(\n            ERC20(asset),\n            ERC20(quote)\n        );\n        (\n            uint256 pay_amt,\n            ERC20 pay_gem,\n            uint256 buy_amt,\n            ERC20 buy_gem\n        ) = RubiconMarket(_market).getOffer(offer);\n        return (offer, pay_amt, pay_gem, buy_amt, buy_gem);\n    }\n\n    // function for infinite approvals of Rubicon Market\n    function approveAssetOnMarket(address toApprove) public {\n        // Approve exchange\n        ERC20(toApprove).approve(RubiconMarketAddress, 2**256 - 1);\n    }\n\n    /// @dev this function takes the same parameters of swap and returns the expected amount\n    function getExpectedSwapFill(\n        uint256 pay_amt,\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS //20\n    ) public view returns (uint256 fill_amt) {\n        address _market = RubiconMarketAddress;\n        uint256 currentAmount = 0;\n        for (uint256 i = 0; i < route.length - 1; i++) {\n            (address input, address output) = (route[i], route[i + 1]);\n            uint256 _pay = i == 0\n                ? pay_amt\n                : (\n                    currentAmount.sub(\n                        currentAmount.mul(expectedMarketFeeBPS).div(10000)\n                    )\n                );\n            uint256 wouldBeFillAmount = RubiconMarket(_market).getBuyAmount(\n                ERC20(output),\n                ERC20(input),\n                _pay\n            );\n            currentAmount = wouldBeFillAmount;\n        }\n        require(currentAmount >= buy_amt_min, \"didnt clear buy_amt_min\");\n\n        // Return the wouldbe resulting swap amount\n        return (currentAmount);\n    }\n\n    /// @dev This function lets a user swap from route[0] -> route[last] at some minimum expected rate\n    /// @dev pay_amt - amount to be swapped away from msg.sender of *first address in path*\n    /// @dev buy_amt_min - target minimum received of *last address in path*\n    function swap(\n        uint256 pay_amt,\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS //20\n    ) public returns (uint256) {\n        //**User must approve this contract first**\n        //transfer needed amount here first\n        ERC20(route[0]).transferFrom(\n            msg.sender,\n            address(this),\n            pay_amt.add(pay_amt.mul(expectedMarketFeeBPS).div(10000)) // Account for expected fee\n        );\n        return\n            _swap(\n                pay_amt,\n                buy_amt_min,\n                route,\n                expectedMarketFeeBPS,\n                msg.sender\n            );\n    }\n\n    // Internal function requires that ERC20s are here before execution\n    function _swap(\n        uint256 pay_amt,\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS,\n        address to // Recipient of swap outputs!\n    ) internal returns (uint256) {\n        address _market = RubiconMarketAddress;\n        uint256 currentAmount = 0;\n        for (uint256 i = 0; i < route.length - 1; i++) {\n            (address input, address output) = (route[i], route[i + 1]);\n            uint256 _pay = i == 0\n                ? pay_amt\n                : (\n                    currentAmount.sub(\n                        currentAmount.mul(expectedMarketFeeBPS).div(10000)\n                    )\n                );\n            if (ERC20(input).allowance(address(this), _market) == 0) {\n                approveAssetOnMarket(input);\n            }\n            uint256 fillAmount = RubiconMarket(_market).sellAllAmount(\n                ERC20(input),\n                _pay,\n                ERC20(output),\n                0 //naively assume no fill_amt here for loop purposes?\n            );\n            currentAmount = fillAmount;\n        }\n        require(currentAmount >= buy_amt_min, \"didnt clear buy_amt_min\");\n\n        // send tokens back to sender if not keeping here\n        if (to != address(this)) {\n            ERC20(route[route.length - 1]).transfer(to, currentAmount);\n        }\n\n        emit LogSwap(\n            pay_amt,\n            route[0],\n            buy_amt_min,\n            route[route.length - 1],\n            keccak256(abi.encodePacked(route[0], route[route.length - 1])),\n            currentAmount,\n            to\n        );\n        return currentAmount;\n    }\n\n    /// @dev this function takes a user's entire balance for the trade in case they want to do a max trade so there's no leftover dust\n    function swapEntireBalance(\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS\n    ) external returns (uint256) {\n        //swaps msg.sender entire balance in the trade\n        uint256 maxAmount = ERC20(route[0]).balanceOf(msg.sender);\n        ERC20(route[0]).transferFrom(\n            msg.sender,\n            address(this),\n            maxAmount // Account for expected fee\n        );\n        return\n            _swap(\n                maxAmount,\n                maxAmount.sub(buy_amt_min.mul(expectedMarketFeeBPS).div(10000)), //account for fee\n                route,\n                expectedMarketFeeBPS,\n                msg.sender\n            );\n    }\n\n    /// @dev this function takes a user's entire balance for the trade in case they want to do a max trade so there's no leftover dust\n    function maxBuyAllAmount(\n        ERC20 buy_gem,\n        ERC20 pay_gem,\n        uint256 max_fill_amount\n    ) external returns (uint256 fill) {\n        //swaps msg.sender's entire balance in the trade\n        uint256 maxAmount = ERC20(buy_gem).balanceOf(msg.sender);\n        fill = RubiconMarket(RubiconMarketAddress).buyAllAmount(\n            buy_gem,\n            maxAmount,\n            pay_gem,\n            max_fill_amount\n        );\n        ERC20(buy_gem).transfer(msg.sender, fill);\n    }\n\n    /// @dev this function takes a user's entire balance for the trade in case they want to do a max trade so there's no leftover dust\n    function maxSellAllAmount(\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint256 min_fill_amount\n    ) external returns (uint256 fill) {\n        //swaps msg.sender entire balance in the trade\n        uint256 maxAmount = ERC20(buy_gem).balanceOf(msg.sender);\n        fill = RubiconMarket(RubiconMarketAddress).sellAllAmount(\n            pay_gem,\n            maxAmount,\n            buy_gem,\n            min_fill_amount\n        );\n        ERC20(buy_gem).transfer(msg.sender, fill);\n    }\n\n    // ** Native ETH Wrapper Functions **\n    /// @dev WETH wrapper functions to obfuscate WETH complexities from ETH holders\n    function buyAllAmountWithETH(\n        ERC20 buy_gem,\n        uint256 buy_amt,\n        uint256 max_fill_amount,\n        uint256 expectedMarketFeeBPS\n    ) external payable returns (uint256 fill) {\n        address _weth = address(wethAddress);\n        uint256 _before = ERC20(_weth).balanceOf(address(this));\n        uint256 max_fill_withFee = max_fill_amount.add(\n            max_fill_amount.mul(expectedMarketFeeBPS).div(10000)\n        );\n        require(\n            msg.value >= max_fill_withFee,\n            \"must send as much ETH as max_fill_withFee\"\n        );\n        WETH9(wethAddress).deposit{value: max_fill_withFee}(); // Pay with native ETH -> WETH\n        // An amount in WETH\n        fill = RubiconMarket(RubiconMarketAddress).buyAllAmount(\n            buy_gem,\n            buy_amt,\n            ERC20(wethAddress),\n            max_fill_amount\n        );\n        ERC20(buy_gem).transfer(msg.sender, buy_amt);\n\n        uint256 _after = ERC20(_weth).balanceOf(address(this));\n        uint256 delta = _after - _before;\n\n        // Return unspent coins to sender\n        if (delta > 0) {\n            WETH9(wethAddress).withdraw(delta);\n            msg.sender.transfer(delta);\n        }\n    }\n\n    // Paying ERC20 to buy native ETH\n    function buyAllAmountForETH(\n        uint256 buy_amt,\n        ERC20 pay_gem,\n        uint256 max_fill_amount\n    ) external returns (uint256 fill) {\n        ERC20(pay_gem).transferFrom(msg.sender, address(this), max_fill_amount); //transfer pay here\n        fill = RubiconMarket(RubiconMarketAddress).buyAllAmount(\n            ERC20(wethAddress),\n            buy_amt,\n            pay_gem,\n            max_fill_amount\n        );\n        WETH9(wethAddress).withdraw(buy_amt); // Fill in WETH\n        msg.sender.transfer(buy_amt); // Return native ETH\n        // Return unspent coins to sender\n        if (max_fill_amount > fill) {\n            ERC20(pay_gem).transfer(msg.sender, max_fill_amount - fill);\n        }\n        return fill;\n    }\n\n    // Pay in native ETH\n    function offerWithETH(\n        uint256 pay_amt, //maker (ask) sell how much\n        // ERC20 nativeETH, //maker (ask) sell which token\n        uint256 buy_amt, //maker (ask) buy how much\n        ERC20 buy_gem, //maker (ask) buy which token\n        uint256 pos //position to insert offer, 0 should be used if unknown\n    ) external payable returns (uint256) {\n        require(\n            msg.value >= pay_amt,\n            \"didnt send enough native ETH for WETH offer\"\n        );\n        uint256 _before = ERC20(buy_gem).balanceOf(address(this));\n        WETH9(wethAddress).deposit{value: pay_amt}();\n        uint256 id = RubiconMarket(RubiconMarketAddress).offer(\n            pay_amt,\n            ERC20(wethAddress),\n            buy_amt,\n            buy_gem,\n            pos\n        );\n        uint256 _after = ERC20(buy_gem).balanceOf(address(this));\n        if (_after > _before) {\n            //return any potential fill amount on the offer\n            ERC20(buy_gem).transfer(msg.sender, _after - _before);\n        }\n        return id;\n    }\n\n    // Pay in native ETH\n    function offerForETH(\n        uint256 pay_amt, //maker (ask) sell how much\n        ERC20 pay_gem, //maker (ask) sell which token\n        uint256 buy_amt, //maker (ask) buy how much\n        // ERC20 nativeETH, //maker (ask) buy which token\n        uint256 pos //position to insert offer, 0 should be used if unknown\n    ) external returns (uint256) {\n        ERC20(pay_gem).transferFrom(msg.sender, address(this), pay_amt);\n\n        uint256 _before = ERC20(wethAddress).balanceOf(address(this));\n        uint256 id = RubiconMarket(RubiconMarketAddress).offer(\n            pay_amt,\n            pay_gem,\n            buy_amt,\n            ERC20(wethAddress),\n            pos\n        );\n        uint256 _after = ERC20(wethAddress).balanceOf(address(this));\n        if (_after > _before) {\n            //return any potential fill amount on the offer as native ETH\n            uint256 delta = _after - _before;\n            WETH9(wethAddress).withdraw(delta);\n            msg.sender."
    }
  ]
}