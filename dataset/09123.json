{
  "Title": "[M-07] Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed",
  "Content": "_Submitted by Chom_\n\n[ExtraRewardsDistributor.sol#L233-L240](https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/ExtraRewardsDistributor.sol#L233-L240)<br>\n[AuraLocker.sol#L334-L337](https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraLocker.sol#L334-L337)<br>\n\nReward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed. The platform then forced to reimburse reward to the user that got their reward locked. Causing huge economics loss.\n\n### Proof of Concept\n\nCan be done by reverse engineering from the affected code\n\n            for (uint256 i = epochIndex; i < tokenEpochs; i++) {\n                //only claimable after rewards are \"locked in\"\n                if (rewardEpochs[_token][i] < latestEpoch) {\n                    claimableTokens += _claimableRewards(_account, _token, rewardEpochs[_token][i]);\n                    //return index user claims should be set to\n                    epochIndex = i + 1;\n                }\n            }\n\nFrom this line you will see a loop from epochIndex to tokenEpochs which loop tokenEpochs - epochIndex times.<br>\nIf tokenEpochs - epochIndex value goes high, it will consume too much gas which go beyond the limit of the chain and cause the transaction to be always failed. As a result, reward may be locked forever.\n\n            uint256 latestEpoch = auraLocker.epochCount() - 1;\n            // e.g. tokenEpochs = 31, 21\n            uint256 tokenEpochs = rewardEpochs[_token].length;\n\n            // e.g. epochIndex = 0\n            uint256 epochIndex = userClaims[_token][_account];\n            // e.g. epochIndex = 27 > 0 ? 27 : 0 = 27\n            epochIndex = _startIndex > epochIndex ? _startIndex : epochIndex;\n\n*   epochIndex is the maximum of \\_startIndex and latest index of rewardEpochs that user has claim the reward\n*   tokenEpochs is the number of epochs that has reward, can be added through `addRewardToEpoch` function up to latest epoch count of auraLocker\n*   latestEpoch is epoch count of auraLocker\n\nIf you specified too high \\_startIndex, the reward may be skipped and these skipped reward are lost forever as the \\_getReward function set latest epoch that user has claim to the lastest index of rewardEpochs that can be claimed.\n\nthe aura locker epoch can be added by using `checkpointEpoch` function which will automatically add epochs up to current timestamp. Imagine today is 100 years from latest checkpoint and rewardsDuration is 1 day, the total of around 36500 epochs needed to be pushed into the array in single transaction which always failed due to gasLimit. The code that responsible for pushing new epochs below (in AuraLocker file)\n\n                while (epochs[epochs.length - 1].date != currentEpoch) {\n                    uint256 nextEpochDate = uint256(epochs[epochs.length - 1].date).add(rewardsDuration);\n                    epochs.push(Epoch({ supply: 0, date: uint32(nextEpochDate) }));\n                }\n\nEven if these line are passed because the nature that checkpointEpoch is likely to be called daily and reward are added daily. if user doesn't claim the reward for 100 years, `rewardEpochs[_token].length = 36500 where epochIndex = 0. Which cause an impossible loop that run 36500 times`. In this case this transaction will always be failed due to gas limit. In the worst case, If this problem cause staking fund to be frozen, the only way is to trash the reward and use `emergencyWithdraw` to withdraw staked fund.\n\nFrom above statement, we can proof that there exists a case that user reward may be locked forever due to looping too many times causing gas to be used beyond the limit thus transaction always failed.\n\n### Tools Used\n\nReverse engineering using the help of IDE.\n\n### Recommended Mitigation Steps\n\nUser should be able to supply endEpochIndex to the claim reward functions. And only calculate reward from startIndex to min(auraLocker.epochCount() - 1, endEpochIndex). And also add support for partial reward claiming.\n\n**[0xMaharishi (Aura Finance) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2022-05-aura-findings/issues/240#issuecomment-1139746911):**\n > Valid report although given these are reward tokens and the max amount of entries is one per week, it would take some years for this to run over gas limit, during which time the contract could easily be changed.\n\n**[LSDan (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-05-aura-findings/issues/240#issuecomment-1160632546):**\n > I'm downgrading this to medium severity. It is unreasonable to expect contracts to be future proof to the tune of a hundred years or more, but if the frequency had been unreasonably fast this issue could have kicked in.\n\n**[0xMaharishi (Aura Finance) resolved and commented](https://github.com/code-423n4/2022-05-aura-findings/issues/240#issuecomment-1141476132):**\n > [code-423n4/2022-05-aura#6](https://github.com/code-423n4/2022-05-aura/pull/6)<br>\n > [code4rena aurafinance/aura-contracts#84](https://github.com/aurafinance/aura-contracts/pull/84)\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-05-aura",
  "Code": [
    {
      "filename": "contracts/ExtraRewardsDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport { IExtraRewardsDistributor, IAuraLocker } from \"./Interfaces.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol\";\n\n/**\n * @title   ExtraRewardsDistributor\n * @author  adapted from ConvexFinance\n * @notice  Allows anyone to distribute rewards to the AuraLocker at a given epoch.\n */\ncontract ExtraRewardsDistributor is ReentrancyGuard, IExtraRewardsDistributor {\n    using SafeERC20 for IERC20;\n\n    IAuraLocker public immutable auraLocker;\n\n    // token -> epoch -> amount\n    mapping(address => mapping(uint256 => uint256)) public rewardData;\n    // token -> epochList\n    mapping(address => uint256[]) public rewardEpochs;\n    // token -> account -> last claimed epoch index\n    mapping(address => mapping(address => uint256)) public userClaims;\n\n    /* ========== EVENTS ========== */\n\n    event RewardAdded(address indexed token, uint256 indexed epoch, uint256 reward);\n    event RewardPaid(address indexed user, address indexed token, uint256 reward, uint256 index);\n    event RewardForfeited(address indexed user, address indexed token, uint256 index);\n\n    /**\n     * @dev Simple constructoor\n     * @param _auraLocker Aura Locker address\n     */\n    constructor(address _auraLocker) {\n        auraLocker = IAuraLocker(_auraLocker);\n    }\n\n    /* ========== ADD REWARDS ========== */\n\n    /**\n     * @notice Add a reward to the current epoch. can be called multiple times for the same reward token\n     * @param _token    Reward token address\n     * @param _amount   Amount of reward tokenÏ€\n     */\n    function addReward(address _token, uint256 _amount) external {\n        auraLocker.checkpointEpoch();\n\n        uint256 latestEpoch = auraLocker.epochCount() - 1;\n        _addReward(_token, _amount, latestEpoch);\n    }\n\n    /**\n     * @notice Add reward token to a specific epoch\n     * @param _token    Reward token address\n     * @param _amount   Amount of reward tokens to add\n     * @param _epoch    Which epoch to add to (must be less than the previous epoch)\n     */\n    function addRewardToEpoch(\n        address _token,\n        uint256 _amount,\n        uint256 _epoch\n    ) external {\n        auraLocker.checkpointEpoch();\n\n        uint256 latestEpoch = auraLocker.epochCount() - 1;\n        require(_epoch <= latestEpoch, \"Cannot assign to the future\");\n\n        if (_epoch == latestEpoch) {\n            _addReward(_token, _amount, latestEpoch);\n        } else {\n            uint256 len = rewardEpochs[_token].length;\n            require(len == 0 || rewardEpochs[_token][len - 1] < _epoch, \"Cannot backdate to this epoch\");\n\n            _addReward(_token, _amount, _epoch);\n        }\n    }\n\n    /**\n     * @notice  Transfer reward tokens from sender to contract for vlCVX holders\n     * @dev     Add reward token for specific epoch\n     * @param _token    Reward token address\n     * @param _amount   Amount of reward tokens\n     * @param _epoch    Epoch to add tokens to\n     */\n    function _addReward(\n        address _token,\n        uint256 _amount,\n        uint256 _epoch\n    ) internal nonReentrant {\n        // Pull before reward accrual\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n\n        //convert to reward per token\n        uint256 supply = auraLocker.totalSupplyAtEpoch(_epoch);\n        uint256 rPerT = (_amount * 1e20) / supply;\n        rewardData[_token][_epoch] += rPerT;\n\n        //add epoch to list\n        uint256 len = rewardEpochs[_token].length;\n        if (len == 0 || rewardEpochs[_token][len - 1] < _epoch) {\n            rewardEpochs[_token].push(_epoch);\n        }\n\n        //event\n        emit RewardAdded(_token, _epoch, _amount);\n    }\n\n    /* ========== GET REWARDS ========== */\n\n    /**\n     * @notice Claim rewards for a specific token since the first epoch.\n     * @param _account  Address of vlCVX holder\n     * @param _token    Reward token address\n     */\n    function getReward(address _account, address _token) public {\n        _getReward(_account, _token, 0);\n    }\n\n    /**\n     * @notice Claim rewards for a specific token at a specific epoch\n     * @param _account      Address of vlCVX holder\n     * @param _token        Reward token address\n     * @param _startIndex   Index of rewardEpochs[_token] to start checking for rewards from\n     */\n    function getReward(\n        address _account,\n        address _token,\n        uint256 _startIndex\n    ) public {\n        _getReward(_account, _token, _startIndex);\n    }\n\n    /**\n     * @notice Claim rewards for a specific token at a specific epoch\n     * @param _account     Address of vlCVX holder\n     * @param _token       Reward token address\n     * @param _startIndex  Index of rewardEpochs[_token] to start checking for rewards from\n     */\n    function _getReward(\n        address _account,\n        address _token,\n        uint256 _startIndex\n    ) public {\n        //get claimable tokens\n        (uint256 claimableTokens, uint256 index) = _allClaimableRewards(_account, _token, _startIndex);\n\n        if (claimableTokens > 0) {\n            //set claim checkpoint\n            userClaims[_token][_account] = index;\n\n            //send\n            IERC20(_token).safeTransfer(_account, claimableTokens);\n\n            //event\n            emit RewardPaid(_account, _token, claimableTokens, index);\n        }\n    }\n\n    /**\n     * @notice  Allow a user to set their claimed index forward without claiming rewards\n     *          Because claims cycle through all periods that a specific reward was given\n     *          there becomes a situation where, for example, a new user could lock\n     *          2 years from now and try to claim a token that was given out every week prior.\n     *          This would result in a 2mil gas checkpoint.(about 20k gas * 52 weeks * 2 years)\n     * @param _token  Reward token to forfeit\n     * @param _index  Epoch index to forfeit from\n     */\n    function forfeitRewards(address _token, uint256 _index) external {\n        require(_index > 0 && _index < rewardEpochs[_token].length - 1, \"!past\");\n        require(_index >= userClaims[_token][msg.sender], \"already claimed\");\n\n        //set claim checkpoint. next claim starts from index+1\n        userClaims[_token][msg.sender] = _index + 1;\n\n        emit RewardForfeited(msg.sender, _token, _index);\n    }\n\n    /* ========== VIEW REWARDS ========== */\n\n    /**\n     * @notice Get claimable rewards (rewardToken) for vlCVX holder\n     * @param _account  Address of vlCVX holder\n     * @param _token    Reward token address\n     */\n    function claimableRewards(address _account, address _token) external view returns (uint256) {\n        (uint256 rewards, ) = _allClaimableRewards(_account, _token, 0);\n        return rewards;\n    }\n\n    /**\n     * @notice Get claimable rewards for a token at a specific epoch\n     * @param _account     Address of vlCVX holder\n     * @param _token       Reward token address\n     * @param _epoch       The epoch to check for rewards\n     */\n    function claimableRewardsAtEpoch(\n        address _account,\n        address _token,\n        uint256 _epoch\n    ) external view returns (uint256) {\n        return _claimableRewards(_account, _token, _epoch);\n    }\n\n    /**\n     * @notice  Get all claimable rewards by looping through each epoch starting with the latest\n     *          saved epoch the user last claimed from\n     * @param _account  Address of vlCVX holder\n     * @param _token    Reward token\n     * @param _startIndex  Index of rewardEpochs[_token] to start checking for rewards from\n     */\n    function _allClaimableRewards(\n        address _account,\n        address _token,\n        uint256 _startIndex\n    ) internal view returns (uint256, uint256) {\n        uint256 latestEpoch = auraLocker.epochCount() - 1;\n        // e.g. tokenEpochs = 31, 21\n        uint256 tokenEpochs = rewardEpochs[_token].length;\n\n        // e.g. epochIndex = 0\n        uint256 epochIndex = userClaims[_token][_account];\n        // e.g. epochIndex = 27 > 0 ? 27 : 0 = 27\n        epochIndex = _startIndex > epochIndex ? _startIndex : epochIndex;\n\n        if (epochIndex >= tokenEpochs) {\n            return (0, tokenEpochs);\n        }\n\n        uint256 claimableTokens = 0;\n\n        for (uint256 i = epochIndex; i < tokenEpochs; i++) {\n            //only claimable after rewards are \"locked in\"\n            if (rewardEpochs[_token][i] < latestEpoch) {\n                claimableTokens += _claimableRewards(_account, _token, rewardEpochs[_token][i]);\n                //return index user claims should be set to\n                epochIndex = i + 1;\n            }\n        }\n        return (claimableTokens, epochIndex);\n    }\n\n    /**\n     * @notice Get claimable rewards for a token at a specific epoch\n     * @param _account     Address of vlCVX holder\n     * @param _token       Reward token address\n     * @param _epoch       The epoch to check for rewards\n     */\n    function _claimableRewards(\n        address _account,\n        address _token,\n        uint256 _epoch\n    ) internal view returns (uint256) {\n        //get balance and calc share\n        uint256 balance = auraLocker.balanceAtEpochOf(_epoch, _account);\n        return (balance * rewardData[_token][_epoch]) / 1e20;\n    }\n\n    /**\n     * @notice Simply gets the current epoch count for a given reward token\n     * @param _token    Reward token address\n     * @return _epochs  Number of epochs\n     */\n    function rewardEpochsCount(address _token) external view returns (uint256) {\n        return rewardEpochs[_token].length;\n    }\n}"
    },
    {
      "filename": "contracts/AuraLocker.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\npragma experimental ABIEncoderV2;\n\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts-0.8/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol\";\nimport { AuraMath, AuraMath32, AuraMath112, AuraMath224 } from \"./AuraMath.sol\";\nimport \"./Interfaces.sol\";\n\ninterface IRewardStaking {\n    function stakeFor(address, uint256) external;\n}\n\n/**\n * @title   AuraLocker\n * @author  ConvexFinance\n * @notice  Effectively allows for rolling 16 week lockups of CVX, and provides balances available\n *          at each epoch (1 week). Also receives cvxCrv from `CvxStakingProxy` and redistributes\n *          to depositors.\n * @dev     Invdividual and delegatee vote power lookups both use independent accounting mechanisms.\n */\ncontract AuraLocker is ReentrancyGuard, Ownable, IAuraLocker {\n    using AuraMath for uint256;\n    using AuraMath224 for uint224;\n    using AuraMath112 for uint112;\n    using AuraMath32 for uint32;\n    using SafeERC20 for IERC20;\n\n    /* ==========     STRUCTS     ========== */\n\n    struct RewardData {\n        /// Timestamp for current period finish\n        uint32 periodFinish;\n        /// Last time any user took action\n        uint32 lastUpdateTime;\n        /// RewardRate for the rest of the period\n        uint96 rewardRate;\n        /// Ever increasing rewardPerToken rate, based on % of total supply\n        uint96 rewardPerTokenStored;\n    }\n    struct UserData {\n        uint128 rewardPerTokenPaid;\n        uint128 rewards;\n    }\n    struct EarnedData {\n        address token;\n        uint256 amount;\n    }\n    struct Balances {\n        uint112 locked;\n        uint32 nextUnlockIndex;\n    }\n    struct LockedBalance {\n        uint112 amount;\n        uint32 unlockTime;\n    }\n    struct Epoch {\n        uint224 supply;\n        uint32 date; //epoch start date\n    }\n    struct DelegateeCheckpoint {\n        uint224 votes;\n        uint32 epochStart;\n    }\n\n    /* ========== STATE VARIABLES ========== */\n\n    // Rewards\n    address[] public rewardTokens;\n    uint256 public queuedCvxCrvRewards = 0;\n    uint256 public constant newRewardRatio = 830;\n    //     Core reward data\n    mapping(address => RewardData) public rewardData;\n    //     Reward token -> distributor -> is approved to add rewards\n    mapping(address => mapping(address => bool)) public rewardDistributors;\n    //     User -> reward token -> amount\n    mapping(address => mapping(address => UserData)) public userData;\n    //     Duration that rewards are streamed over\n    uint256 public constant rewardsDuration = 86400 * 7;\n    //     Duration of lock/earned penalty period\n    uint256 public constant lockDuration = rewardsDuration * 17;\n\n    // Balances\n    //     Supplies and historic supply\n    uint256 public lockedSupply;\n    //     Epochs contains only the tokens that were locked at that epoch, not a cumulative supply\n    Epoch[] public epochs;\n    //     Mappings for balance data\n    mapping(address => Balances) public balances;\n    mapping(address => LockedBalance[]) public userLocks;\n\n    // Voting\n    //     Stored delegations\n    mapping(address => address) private _delegates;\n    //     Checkpointed votes\n    mapping(address => DelegateeCheckpoint[]) private _checkpointedVotes;\n    //     Delegatee balances (user -> unlock timestamp -> amount)\n    mapping(address => mapping(uint256 => uint256)) public delegateeUnlocks;\n\n    // Config\n    //     Tokens\n    IERC20 public immutable stakingToken;\n    address public immutable cvxCrv;\n    //     Denom for calcs\n    uint256 public constant denominator = 10000;\n    //     Staking cvxCrv\n    address public immutable cvxcrvStaking;\n    //     Incentives\n    uint256 public kickRewardPerEpoch = 100;\n    uint256 public kickRewardEpochDelay = 3;\n    //     Shutdown\n    bool public isShutdown = false;\n\n    // Basic token data\n    string private _name;\n    string private _symbol;\n    uint8 private immutable _decimals;\n\n    /* ========== EVENTS ========== */\n\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n    event DelegateCheckpointed(address indexed delegate);\n\n    event Recovered(address _token, uint256 _amount);\n    event RewardPaid(address indexed _user, address indexed _rewardsToken, uint256 _reward);\n    event Staked(address indexed _user, uint256 _paidAmount, uint256 _lockedAmount);\n    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);\n    event KickReward(address indexed _user, address indexed _kicked, uint256 _reward);\n    event RewardAdded(address indexed _token, uint256 _reward);\n\n    event KickIncentiveSet(uint256 rate, uint256 delay);\n    event Shutdown();\n\n    /***************************************\n                    CONSTRUCTOR\n    ****************************************/\n\n    /**\n     * @param _nameArg          Token name, simples\n     * @param _symbolArg        Token symbol\n     * @param _stakingToken     CVX (0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B)\n     * @param _cvxCrv           cvxCRV (0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7)\n     * @param _cvxCrvStaking    cvxCRV rewards (0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e)\n     */\n    constructor(\n        string memory _nameArg,\n        string memory _symbolArg,\n        address _stakingToken,\n        address _cvxCrv,\n        address _cvxCrvStaking\n    ) Ownable() {\n        _name = _nameArg;\n        _symbol = _symbolArg;\n        _decimals = 18;\n\n        stakingToken = IERC20(_stakingToken);\n        cvxCrv = _cvxCrv;\n        cvxcrvStaking = _cvxCrvStaking;\n\n        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        epochs.push(Epoch({ supply: 0, date: uint32(currentEpoch) }));\n    }\n\n    /***************************************\n                    MODIFIER\n    ****************************************/\n\n    modifier updateReward(address _account) {\n        {\n            Balances storage userBalance = balances[_account];\n            uint256 rewardTokensLength = rewardTokens.length;\n            for (uint256 i = 0; i < rewardTokensLength; i++) {\n                address token = rewardTokens[i];\n                uint256 newRewardPerToken = _rewardPerToken(token);\n                rewardData[token].rewardPerTokenStored = newRewardPerToken.to96();\n                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(rewardData[token].periodFinish).to32();\n                if (_account != address(0)) {\n                    userData[_account][token] = UserData({\n                        rewardPerTokenPaid: newRewardPerToken.to128(),\n                        rewards: _earned(_account, token, userBalance.locked).to128()\n                    });\n                }\n            }\n        }\n        _;\n    }\n\n    /***************************************\n                    ADMIN\n    ****************************************/\n\n    // Add a new reward token to be distributed to stakers\n    function addReward(address _rewardsToken, address _distributor) external onlyOwner {\n        require(rewardData[_rewardsToken].lastUpdateTime == 0, \"Reward already exists\");\n        require(_rewardsToken != address(stakingToken), \"Cannot add StakingToken as reward\");\n        rewardTokens.push(_rewardsToken);\n        rewardData[_rewardsToken].lastUpdateTime = uint32(block.timestamp);\n        rewardData[_rewardsToken].periodFinish = uint32(block.timestamp);\n        rewardDistributors[_rewardsToken][_distributor] = true;\n    }\n\n    // Modify approval for an address to call notifyRewardAmount\n    function approveRewardDistributor(\n        address _rewardsToken,\n        address _distributor,\n        bool _approved\n    ) external onlyOwner {\n        require(rewardData[_rewardsToken].lastUpdateTime > 0, \"Reward does not exist\");\n        rewardDistributors[_rewardsToken][_distributor] = _approved;\n    }\n\n    //set kick incentive\n    function setKickIncentive(uint256 _rate, uint256 _delay) external onlyOwner {\n        require(_rate <= 500, \"over max rate\"); //max 5% per epoch\n        require(_delay >= 2, \"min delay\"); //minimum 2 epochs of grace\n        kickRewardPerEpoch = _rate;\n        kickRewardEpochDelay = _delay;\n\n        emit KickIncentiveSet(_rate, _delay);\n    }\n\n    //shutdown the contract. unstake all tokens. release all locks\n    function shutdown() external onlyOwner {\n        isShutdown = true;\n        emit Shutdown();\n    }\n\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {\n        require(_tokenAddress != address(stakingToken), \"Cannot withdraw staking token\");\n        require(rewardData[_tokenAddress].lastUpdateTime == 0, \"Cannot withdraw reward token\");\n        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);\n        emit Recovered(_tokenAddress, _tokenAmount);\n    }\n\n    // Set approvals for staking cvx and cvxcrv\n    function setApprovals() external {\n        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);\n        IERC20(cvxCrv).safeApprove(cvxcrvStaking, type(uint256).max);\n    }\n\n    /***************************************\n                    ACTIONS\n    ****************************************/\n\n    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards\n    function lock(address _account, uint256 _amount) external nonReentrant updateReward(_account) {\n        //pull tokens\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        //lock\n        _lock(_account, _amount);\n    }\n\n    //lock tokens\n    function _lock(address _account, uint256 _amount) internal {\n        require(_amount > 0, \"Cannot stake 0\");\n        require(!isShutdown, \"shutdown\");\n\n        Balances storage bal = balances[_account];\n\n        //must try check pointing epoch first\n        _checkpointEpoch();\n\n        //add user balances\n        uint112 lockAmount = _amount.to112();\n        bal.locked = bal.locked.add(lockAmount);\n\n        //add to total supplies\n        lockedSupply = lockedSupply.add(_amount);\n\n        //add user lock records or add to current\n        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 unlockTime = currentEpoch.add(lockDuration);\n        uint256 idx = userLocks[_account].length;\n        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {\n            userLocks[_account].push(LockedBalance({ amount: lockAmount, unlockTime: uint32(unlockTime) }));\n        } else {\n            LockedBalance storage userL = userLocks[_account][idx - 1];\n            userL.amount = userL.amount.add(lockAmount);\n        }\n\n        address delegatee = delegates(_account);\n        if (delegatee != address(0)) {\n            delegateeUnlocks[delegatee][unlockTime] += lockAmount;\n            _checkpointDelegate(delegatee, lockAmount, 0);\n        }\n\n        //update epoch supply, epoch checkpointed above so safe to add to latest\n        Epoch storage e = epochs[epochs.length - 1];\n        e.supply = e.supply.add(lockAmount);\n\n        emit Staked(_account, lockAmount, lockAmount);\n    }\n\n    // claim all pending rewards\n    function getReward(address _account) external {\n        getReward(_account, false);\n    }\n\n    // Claim all pending rewards\n    function getReward(address _account, bool _stake) public nonReentrant updateReward(_account) {\n        uint256 rewardTokensLength = rewardTokens.length;\n        for (uint256 i; i < rewardTokensLength; i++) {\n            address _rewardsToken = rewardTokens[i];\n            uint256 reward = userData[_account][_rewardsToken].rewards;\n            if (reward > 0) {\n                userData[_account][_rewardsToken].rewards = 0;\n                if (_rewardsToken == cvxCrv && _stake && _account == msg.sender) {\n                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);\n                } else {\n                    IERC20(_rewardsToken).safeTransfer(_account, reward);\n                }\n                emit RewardPaid(_account, _rewardsToken, reward);\n            }\n        }\n    }\n\n    function checkpointEpoch() external {\n        _checkpointEpoch();\n    }\n\n    //insert a new epoch if needed. fill in any gaps\n    function _checkpointEpoch() internal {\n        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 epochindex = epochs.length;\n\n        //first epoch add in constructor, no need to check 0 length\n        //check to add\n        if (epochs[epochindex - 1].date < currentEpoch) {\n            //fill any epoch gaps until the next epoch date.\n            while (epochs[epochs.length - 1].date != currentEpoch) {\n                uint256 nextEpochDate = uint256(epochs[epochs.length - 1].date).add(rewardsDuration);\n                epochs.push(Epoch({ supply: 0, date: uint32(nextEpochDate) }));\n            }\n        }\n    }\n\n    // Withdraw/relock all currently locked tokens where the unlock time has passed\n    function processExpiredLocks(bool _relock) external nonReentrant {\n        _processExpiredLocks(msg.sender, _relock, msg.sender, 0);\n    }\n\n    function kickExpiredLocks(address _account) external nonReentrant {\n        //allow kick after grace period of 'kickRewardEpochDelay'\n        _processExpiredLocks(_account, false, msg.sender, rewardsDuration.mul(kickRewardEpochDelay));\n    }\n\n    // Withdraw without checkpointing or accruing any rewards, providing system is shutdown\n    function emergencyWithdraw() external nonReentrant {\n        require(isShutdown, \"Must be shutdown\");\n\n        LockedBalance[] memory locks = userLocks[msg.sender];\n        Balances storage userBalance = balances[msg.sender];\n\n        uint256 amt = userBalance.locked;\n        require(amt > 0, \"Nothing locked\");\n\n        userBalance.locked = 0;\n        userBalance.nextUnlockIndex = locks.length.to32();\n        lockedSupply -= amt;\n\n        emit Withdrawn(msg.sender, amt, false);\n\n        stakingToken.safeTransfer(msg.sender, amt);\n    }\n\n    // Withdraw all currently locked tokens where the unlock time has passed\n    function _processExpiredLocks(\n        address _account,\n        bool _relock,\n        address _rewardAddress,\n        uint256 _checkDelay\n    ) internal updateReward(_account) {\n        LockedBalance[] storage locks = userLocks[_account];\n        Balances storage userBalance = balances[_account];\n        uint112 locked;\n        uint256 length = locks.length;\n        uint256 reward = 0;\n        uint256 expiryTime = _checkDelay == 0 && _relock\n            ? block.timestamp.add(rewardsDuration)\n            : block.timestamp.sub(_checkDelay);\n        require(length > 0, \"no locks\");\n        // e.g. now = 16\n        // if contract is shutdown OR latest lock unlock time (e.g. 17) <= now - (1)\n        // e.g. 17 <= (16 + 1)\n        if (isShutdown || locks[length - 1].unlockTime <= expiryTime) {\n            //if time is beyond last lock, can just bundle everything together\n            locked = userBalance.locked;\n\n            //dont delete, just set next index\n            userBalance.nextUnlockIndex = length.to32();\n\n            //check for kick reward\n            //this wont have the exact reward rate that you would get if looped through\n            //but this section is supposed to be for quick and easy low gas processing of all locks\n            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch\n            if (_checkDelay > 0) {\n                uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);\n                uint256 epochsover = currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(rewardsDuration);\n                uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);\n                reward = uint256(locks[length - 1].amount).mul(rRate).div(denominator);\n            }\n        } else {\n            //use a processed index(nextUnlockIndex) to not loop as much\n            //deleting does not change array length\n            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;\n            for (uint256 i = nextUnlockIndex; i < length; i++) {\n                //unlock time must be less or equal to time\n                if (locks[i].unlockTime > expiryTime) break;\n\n                //add to cumulative amounts\n                locked = locked.add(locks[i].amount);\n\n                //check for kick reward\n                //each epoch over due increases reward\n                if (_checkDelay > 0) {\n                    uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);\n                    uint256 epochsover = currentEpoch.sub(uint256(locks[i].unlockTime)).div(rewardsDuration);\n                    uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);\n                    reward = reward.add(uint256(locks[i].amount).mul(rRate).div(denominator));\n                }\n                //set next unlock index\n                nextUnlockIndex++;\n            }\n            //update next unlock index\n            userBalance.nextUnlockIndex = nextUnlockIndex;\n        }\n        require(locked > 0, \"no exp locks\");\n\n        //update user balances and total supplies\n        userBalance.locked = userBalance.locked.sub(locked);\n        lockedSupply = lockedSupply.sub(locked);\n\n        //checkpoint the delegatee\n        _checkpointDelegate(delegates(_account), 0, 0);\n\n        emit Withdrawn(_account, locked, _relock);\n\n        //send process incentive\n        if (reward > 0) {\n            //reduce return amount by the kick reward\n            locked = locked.sub(reward.to112());\n\n            //transfer reward\n            stakingToken.safeTransfer(_rewardAddress, reward);\n            emit KickReward(_rewardAddress, _account, reward);\n        }\n\n        //relock or return to user\n        if (_relock) {\n            _lock(_account, locked);\n        } else {\n            stakingToken.safeTransfer(_account, locked);\n        }\n    }\n\n    /***************************************\n            DELEGATION & VOTE BALANCE\n    ****************************************/\n\n    /**\n     * @dev Delegate votes from the sender to `newDelegatee`.\n     */\n    function delegate(address newDelegatee) external virtual nonReentrant {\n        // Step 1: Get lock data\n        LockedBalance[] storage locks = userLocks[msg.sender];\n        uint256 len = locks.length;\n        require(len > 0, \"Nothing to delegate\");\n        require(newDelegatee != address(0), \"Must delegate to someone\");\n\n        // Step 2: Update delegatee storage\n        address oldDelegatee = delegates(msg.sender);\n        require(newDelegatee != oldDelegatee, \"Must choose new delegatee\");\n        _delegates[msg.sender] = newDelegatee;\n\n        emit DelegateChanged(msg.sender, oldDelegatee, newDelegatee);\n\n        // Step 3: Move balances around\n        //         Delegate for the upcoming epoch\n        uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);\n        uint256 i = len - 1;\n        uint256 futureUnlocksSum = 0;\n        LockedBalance memory currentLock = locks[i];\n        // Step 3.1: Add future unlocks and sum balances\n        while (currentLock.unlockTime > upcomingEpoch) {\n            futureUnlocksSum += currentLock.amount;\n\n            if (oldDelegatee != address(0)) {\n                delegateeUnlocks[oldDelegatee][currentLock.unlockTime] -= currentLock.amount;\n            }\n            delegateeUnlocks[newDelegatee][currentLock.unlockTime] += currentLock.amount;\n\n            if (i > 0) {\n                i--;\n                currentLock = locks[i];\n            } else {\n                break;\n            }\n        }\n\n        // Step 3.2: Checkpoint old delegatee\n        _checkpointDelegate(oldDelegatee, 0, futureUnlocksSum);\n\n        // Step 3.3: Checkpoint new delegatee\n        _checkpointDelegate(newDelegatee, futureUnlocksSum, 0);\n    }\n\n    function _checkpointDelegate(\n        address _account,\n        uint256 _upcomingAddition,\n        uint256 _upcomingDeduction\n    ) internal {\n        // This would only skip on first checkpointing\n        if (_account != address(0)) {\n            uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);\n            DelegateeCheckpoint[] storage ckpts = _checkpointedVotes[_account];\n            if (ckpts.length > 0) {\n                DelegateeCheckpoint memory prevCkpt = ckpts[ckpts.length - 1];\n                // If there has already been a record for the upcoming epoch, no need to deduct the unlocks\n                if (prevCkpt.epochStart == upcomingEpoch) {\n                    ckpts[ckpts.length - 1] = DelegateeCheckpoint({\n                        votes: (prevCkpt.votes + _upcomingAddition - _upcomingDeduction).to224(),\n                        epochStart: upcomingEpoch.to32()\n                    });\n                }\n                // else if it has been over 16 weeks since the previous checkpoint, all locks have since expired\n                // e.g. week 1 + 17 <= 18\n                else if (prevCkpt.epochStart + lockDuration <= upcomingEpoch) {\n                    ckpts.push(\n                        DelegateeCheckpoint({\n                            votes: (_upcomingAddition - _upcomingDeduction).to224(),\n                            epochStart: upcomingEpoch.to32()\n                        })\n                    );\n                } else {\n                    uint256 nextEpoch = upcomingEpoch;\n                    uint256 unlocksSinceLatestCkpt = 0;\n                    // Should be maximum 18 iterations\n                    while (nextEpoch > prevCkpt.epochStart) {\n                        unlocksSinceLatestCkpt += delegateeUnlocks[_account][nextEpoch];\n                        nextEpoch -= rewardsDuration;\n                    }\n                    ckpts.push(\n                        DelegateeCheckpoint({\n                            votes: (prevCkpt.votes - unlocksSinceLatestCkpt + _upcomingAddition - _upcomingDeduction)\n                                .to224(),\n                            epochStart: upcomingEpoch.to32()\n                        })\n                    );\n                }\n            } else {\n                ckpts.push(\n                    DelegateeCheckpoint({\n                        votes: (_upcomingAddition - _upcomingDeduction).to224(),\n                        epochStart: upcomingEpoch.to32()\n                    })\n                );\n            }\n            emit DelegateCheckpointed(_account);\n        }\n    }\n\n    /**\n     * @dev Get the address `account` i"
    }
  ]
}