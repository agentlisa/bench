{
  "Title": "[H-13] Anyone can wipe complete state of any collateral at any point",
  "Content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/ClearingHouse.sol#L114-L167><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L524-L545><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L497-L510><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L623-L656>\n\nThe Clearing House is implemented as an ERC1155. This is used to settle up at the end of an auction. The Clearing House's token is listed as one of the Consideration Items, and when Seaport goes to transfer it, it triggers the settlement process.\n\nThis settlement process includes deleting the collateral state hash from LienToken.sol, burning all lien tokens, deleting the idToUnderlying mapping, and burning the collateral token. **These changes effectively wipe out all record of the liens, as well as removing any claim the borrower has on their underlying collateral.**\n\nAfter an auction, this works as intended. The function verifies that sufficient payment has been made to meet the auction criteria, and therefore all these variables should be zeroed out.\n\nHowever, the issue is that there is no check that this safeTransferFrom function is being called after an auction has completed. In the case that it is called when there is no auction, all the auction criteria will be set to 0, and therefore the above deletions can be performed with a payment of 0.\n\nThis allows any user to call the `safeTransferFrom()` function for any other user's collateral. This will wipe out all the liens on that collateral, and burn the borrower's collateral token, and with it their ability to ever reclaim their collateral.\n\n### Proof of Concept\n\nThe flow is as follows:\n\n*   safeTransferFrom(offerer, buyer, paymentToken, amount, data)\n*   \\_execute(offerer, buyer, paymentToken, amount)\n*   using the auctionStack in storage, it calculates the amount the auction would currently be listed at\n*   it confirms that the Clearing House has already received sufficient paymentTokens for this amount\n*   it then transfers the liquidator their payment (currently 13%)\n*   it calls `LienToken#payDebtViaClearingHouse()`, which pays back all liens, zeros out all lien storage and deletes the collateralStateHash\n*   if there is any remaining balance of paymentToken, it transfers it to the owner of the collateral\n*   it then calls `Collateral#settleAuction()`, which deletes idToUnderlying, collateralIdToAuction and burns the collateral token\n\nIn the case where the auction hasn't started, the `auctionStack` in storage is all set to zero. When it calculates the payment that should be made, it uses `_locateCurrentAmount`, which simply returns `endAmount` if `startAmount == endAmount`. In the case where they are all 0, this returns 0.\n\nThe second check that should catch this occurs in `settleAuction()`:\n\n        if (\n          s.collateralIdToAuction[collateralId] == bytes32(0) &&\n          ERC721(s.idToUnderlying[collateralId].tokenContract).ownerOf(\n            s.idToUnderlying[collateralId].tokenId\n          ) !=\n          s.clearingHouse[collateralId]\n        ) {\n          revert InvalidCollateralState(InvalidCollateralStates.NO_AUCTION);\n        }\n\nHowever, this check accidentally uses an `&&` operator instead of a `||`. The result is that, even if the auction hasn't started, only the first criteria is false. The second is checking whether the Clearing House owns the underlying collateral, which happens as soon as the collateral is deposited in `CollateralToken.sol#onERC721Received()`:\n\n          ERC721(msg.sender).safeTransferFrom(\n            address(this),\n            s.clearingHouse[collateralId],\n            tokenId_\n          );\n\n### Recommended Mitigation Steps\n\nChange the check in `settleAuction()` from an AND to an OR, which will block any collateralId that isn't currently at auction from being settled:\n\n        if (\n          s.collateralIdToAuction[collateralId] == bytes32(0) ||\n          ERC721(s.idToUnderlying[collateralId].tokenContract).ownerOf(\n            s.idToUnderlying[collateralId].tokenId\n          ) !=\n          s.clearingHouse[collateralId]\n        ) {\n          revert InvalidCollateralState(InvalidCollateralStates.NO_AUCTION);\n        }\n\n**[SantiagoGregory (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/287)**\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-01-astaria",
  "Code": [
    {
      "filename": "src/ClearingHouse.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**\n *  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗\n * ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n * ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n * ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n * ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n *\n * Astaria Labs, Inc\n */\n\npragma solidity =0.8.17;\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {WETH} from \"solmate/tokens/WETH.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {Clone} from \"clones-with-immutable-args/Clone.sol\";\nimport {IERC1155} from \"core/interfaces/IERC1155.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\nimport {Bytes32AddressLib} from \"solmate/utils/Bytes32AddressLib.sol\";\nimport {\n  ConduitControllerInterface\n} from \"seaport/interfaces/ConduitControllerInterface.sol\";\nimport {AmountDeriver} from \"seaport/lib/AmountDeriver.sol\";\nimport {Order} from \"seaport/lib/ConsiderationStructs.sol\";\nimport {IERC721Receiver} from \"core/interfaces/IERC721Receiver.sol\";\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\n\ncontract ClearingHouse is AmountDeriver, Clone, IERC1155, IERC721Receiver {\n  using Bytes32AddressLib for bytes32;\n  using SafeTransferLib for ERC20;\n\n  struct ClearingHouseStorage {\n    ILienToken.AuctionData auctionStack;\n  }\n\n  uint256 private constant CLEARING_HOUSE_STORAGE_SLOT =\n    uint256(keccak256(\"xyz.astaria.ClearingHouse.storage.location\")) - 1;\n\n  function ROUTER() public pure returns (IAstariaRouter) {\n    return IAstariaRouter(_getArgAddress(0));\n  }\n\n  function COLLATERAL_ID() public pure returns (uint256) {\n    return _getArgUint256(21);\n  }\n\n  function IMPL_TYPE() public pure returns (uint8) {\n    return _getArgUint8(20);\n  }\n\n  function _getStorage()\n    internal\n    pure\n    returns (ClearingHouseStorage storage s)\n  {\n    uint256 slot = CLEARING_HOUSE_STORAGE_SLOT;\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  function setAuctionData(ILienToken.AuctionData calldata auctionData)\n    external\n  {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0)); // get the router from the immutable arg\n\n    //only execute from the conduit\n    require(msg.sender == address(ASTARIA_ROUTER.LIEN_TOKEN()));\n\n    ClearingHouseStorage storage s = _getStorage();\n    s.auctionStack = auctionData;\n  }\n\n  function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n    return interfaceId == type(IERC1155).interfaceId;\n  }\n\n  function balanceOf(address account, uint256 id)\n    external\n    view\n    returns (uint256)\n  {\n    return type(uint256).max;\n  }\n\n  function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n    external\n    view\n    returns (uint256[] memory output)\n  {\n    output = new uint256[](accounts.length);\n    for (uint256 i; i < accounts.length; ) {\n      output[i] = type(uint256).max;\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function setApprovalForAll(address operator, bool approved) external {}\n\n  function isApprovedForAll(address account, address operator)\n    external\n    view\n    returns (bool)\n  {\n    return true;\n  }\n\n  function _execute(\n    address tokenContract, // collateral token sending the fake nft\n    address to, // buyer\n    uint256 encodedMetaData, //retrieve token address from the encoded data\n    uint256 // space to encode whatever is needed,\n  ) internal {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0)); // get the router from the immutable arg\n\n    ClearingHouseStorage storage s = _getStorage();\n    address paymentToken = bytes32(encodedMetaData).fromLast20Bytes();\n\n    uint256 currentOfferPrice = _locateCurrentAmount({\n      startAmount: s.auctionStack.startAmount,\n      endAmount: s.auctionStack.endAmount,\n      startTime: s.auctionStack.startTime,\n      endTime: s.auctionStack.endTime,\n      roundUp: true //we are a consideration we round up\n    });\n    uint256 payment = ERC20(paymentToken).balanceOf(address(this));\n\n    require(payment >= currentOfferPrice, \"not enough funds received\");\n\n    uint256 collateralId = _getArgUint256(21);\n    // pay liquidator fees here\n\n    ILienToken.AuctionStack[] storage stack = s.auctionStack.stack;\n\n    uint256 liquidatorPayment = ASTARIA_ROUTER.getLiquidatorFee(payment);\n\n    ERC20(paymentToken).safeTransfer(\n      s.auctionStack.liquidator,\n      liquidatorPayment\n    );\n\n    ERC20(paymentToken).safeApprove(\n      address(ASTARIA_ROUTER.TRANSFER_PROXY()),\n      payment - liquidatorPayment\n    );\n\n    ASTARIA_ROUTER.LIEN_TOKEN().payDebtViaClearingHouse(\n      paymentToken,\n      collateralId,\n      payment - liquidatorPayment,\n      s.auctionStack.stack\n    );\n\n    if (ERC20(paymentToken).balanceOf(address(this)) > 0) {\n      ERC20(paymentToken).safeTransfer(\n        ASTARIA_ROUTER.COLLATERAL_TOKEN().ownerOf(collateralId),\n        ERC20(paymentToken).balanceOf(address(this))\n      );\n    }\n    ASTARIA_ROUTER.COLLATERAL_TOKEN().settleAuction(collateralId);\n  }\n\n  function safeTransferFrom(\n    address from, // the from is the offerer\n    address to,\n    uint256 identifier,\n    uint256 amount,\n    bytes calldata data //empty from seaport\n  ) public {\n    //data is empty and useless\n    _execute(from, to, identifier, amount);\n  }\n\n  function safeBatchTransferFrom(\n    address from,\n    address to,\n    uint256[] calldata ids,\n    uint256[] calldata amounts,\n    bytes calldata data\n  ) public {}\n\n  function onERC721Received(\n    address operator_,\n    address from_,\n    uint256 tokenId_,\n    bytes calldata data_\n  ) external override returns (bytes4) {\n    return IERC721Receiver.onERC721Received.selector;\n  }\n\n  function validateOrder(Order memory order) external {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0));\n    require(msg.sender == address(ASTARIA_ROUTER.COLLATERAL_TOKEN()));\n    Order[] memory listings = new Order[](1);\n    listings[0] = order;\n\n    ERC721(order.parameters.offer[0].token).approve(\n      ASTARIA_ROUTER.COLLATERAL_TOKEN().getConduit(),\n      order.parameters.offer[0].identifierOrCriteria\n    );\n    ASTARIA_ROUTER.COLLATERAL_TOKEN().SEAPORT().validate(listings);\n  }\n\n  function transferUnderlying(\n    address tokenContract,\n    uint256 tokenId,\n    address target\n  ) external {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0));\n    require(msg.sender == address(ASTARIA_ROUTER.COLLATERAL_TOKEN()));\n    ERC721(tokenContract).safeTransferFrom(address(this), target, tokenId);\n  }\n\n  function settleLiquidatorNFTClaim() external {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0));\n\n    require(msg.sender == address(ASTARIA_ROUTER.COLLATERAL_TOKEN()));\n    ClearingHouseStorage storage s = _getStorage();\n    ASTARIA_ROUTER.LIEN_TOKEN().payDebtViaClearingHouse(\n      address(0),\n      COLLATERAL_ID(),\n      0,\n      s.auctionStack.stack\n    );\n  }\n}"
    },
    {
      "filename": "src/CollateralToken.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**\n *  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗\n * ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n * ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n * ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n * ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n *\n * Astaria Labs, Inc\n */\n\npragma solidity =0.8.17;\n\npragma experimental ABIEncoderV2;\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {ICollateralToken} from \"core/interfaces/ICollateralToken.sol\";\nimport {IERC165} from \"core/interfaces/IERC165.sol\";\nimport {IERC721} from \"core/interfaces/IERC721.sol\";\nimport {IERC721Receiver} from \"core/interfaces/IERC721Receiver.sol\";\nimport {IFlashAction} from \"core/interfaces/IFlashAction.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\nimport {ISecurityHook} from \"core/interfaces/ISecurityHook.sol\";\nimport {ITransferProxy} from \"core/interfaces/ITransferProxy.sol\";\nimport {Authority} from \"solmate/auth/Auth.sol\";\nimport {CollateralLookup} from \"core/libraries/CollateralLookup.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC721} from \"gpl/ERC721.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {VaultImplementation} from \"core/VaultImplementation.sol\";\nimport {ZoneInterface} from \"seaport/interfaces/ZoneInterface.sol\";\nimport {Bytes32AddressLib} from \"solmate/utils/Bytes32AddressLib.sol\";\nimport {\n  ClonesWithImmutableArgs\n} from \"clones-with-immutable-args/ClonesWithImmutableArgs.sol\";\n\nimport {\n  ConduitControllerInterface\n} from \"seaport/interfaces/ConduitControllerInterface.sol\";\nimport {\n  ConsiderationInterface\n} from \"seaport/interfaces/ConsiderationInterface.sol\";\nimport {\n  AdvancedOrder,\n  CriteriaResolver,\n  OfferItem,\n  ConsiderationItem,\n  ItemType,\n  OrderParameters,\n  OrderComponents,\n  OrderType,\n  Order\n} from \"seaport/lib/ConsiderationStructs.sol\";\n\nimport {Consideration} from \"seaport/lib/Consideration.sol\";\nimport {SeaportInterface} from \"seaport/interfaces/SeaportInterface.sol\";\nimport {ClearingHouse} from \"core/ClearingHouse.sol\";\nimport {AuthInitializable} from \"core/AuthInitializable.sol\";\n\ncontract CollateralToken is\n  AuthInitializable,\n  ERC721,\n  IERC721Receiver,\n  ICollateralToken,\n  ZoneInterface\n{\n  using SafeTransferLib for ERC20;\n  using CollateralLookup for address;\n  using FixedPointMathLib for uint256;\n  uint256 private constant COLLATERAL_TOKEN_SLOT =\n    uint256(keccak256(\"xyz.astaria.CollateralToken.storage.location\")) - 1;\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize(\n    Authority AUTHORITY_,\n    ITransferProxy TRANSFER_PROXY_,\n    ILienToken LIEN_TOKEN_,\n    ConsiderationInterface SEAPORT_\n  ) public initializer {\n    __initAuth(msg.sender, address(AUTHORITY_));\n    __initERC721(\"Astaria Collateral Token\", \"ACT\");\n    CollateralStorage storage s = _loadCollateralSlot();\n    s.TRANSFER_PROXY = TRANSFER_PROXY_;\n    s.LIEN_TOKEN = LIEN_TOKEN_;\n    s.SEAPORT = SEAPORT_;\n    (, , address conduitController) = s.SEAPORT.information();\n    bytes32 CONDUIT_KEY = Bytes32AddressLib.fillLast12Bytes(address(this));\n    s.CONDUIT_KEY = CONDUIT_KEY;\n    s.CONDUIT_CONTROLLER = ConduitControllerInterface(conduitController);\n\n    s.CONDUIT = s.CONDUIT_CONTROLLER.createConduit(CONDUIT_KEY, address(this));\n    s.CONDUIT_CONTROLLER.updateChannel(\n      address(s.CONDUIT),\n      address(SEAPORT_),\n      true\n    );\n  }\n\n  function SEAPORT() public view returns (ConsiderationInterface) {\n    return _loadCollateralSlot().SEAPORT;\n  }\n\n  function liquidatorNFTClaim(OrderParameters memory params) external {\n    CollateralStorage storage s = _loadCollateralSlot();\n\n    uint256 collateralId = params.offer[0].token.computeId(\n      params.offer[0].identifierOrCriteria\n    );\n    address liquidator = s.LIEN_TOKEN.getAuctionLiquidator(collateralId);\n    if (\n      s.collateralIdToAuction[collateralId] == bytes32(0) ||\n      liquidator == address(0)\n    ) {\n      //revert no auction\n      revert InvalidCollateralState(InvalidCollateralStates.NO_AUCTION);\n    }\n    if (\n      s.collateralIdToAuction[collateralId] != keccak256(abi.encode(params))\n    ) {\n      //revert auction params dont match\n      revert InvalidCollateralState(\n        InvalidCollateralStates.INVALID_AUCTION_PARAMS\n      );\n    }\n\n    if (block.timestamp < params.endTime) {\n      //auction hasn't ended yet\n      revert InvalidCollateralState(InvalidCollateralStates.AUCTION_ACTIVE);\n    }\n\n    Asset memory underlying = s.idToUnderlying[collateralId];\n    address tokenContract = underlying.tokenContract;\n    uint256 tokenId = underlying.tokenId;\n    ClearingHouse CH = ClearingHouse(payable(s.clearingHouse[collateralId]));\n    CH.settleLiquidatorNFTClaim();\n    _releaseToAddress(s, underlying, collateralId, liquidator);\n  }\n\n  function _loadCollateralSlot()\n    internal\n    pure\n    returns (CollateralStorage storage s)\n  {\n    uint256 slot = COLLATERAL_TOKEN_SLOT;\n\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  function isValidOrder(\n    bytes32 orderHash,\n    address caller,\n    address offerer,\n    bytes32 zoneHash\n  ) external view returns (bytes4 validOrderMagicValue) {\n    CollateralStorage storage s = _loadCollateralSlot();\n    return\n      s.collateralIdToAuction[uint256(zoneHash)] == orderHash\n        ? ZoneInterface.isValidOrder.selector\n        : bytes4(0xffffffff);\n  }\n\n  // Called by Consideration whenever any extraData is provided by the caller.\n  function isValidOrderIncludingExtraData(\n    bytes32 orderHash,\n    address caller,\n    AdvancedOrder calldata order,\n    bytes32[] calldata priorOrderHashes,\n    CriteriaResolver[] calldata criteriaResolvers\n  ) external view returns (bytes4 validOrderMagicValue) {\n    CollateralStorage storage s = _loadCollateralSlot();\n    return\n      s.collateralIdToAuction[uint256(order.parameters.zoneHash)] == orderHash\n        ? ZoneInterface.isValidOrder.selector\n        : bytes4(0xffffffff);\n  }\n\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC721, IERC165)\n    returns (bool)\n  {\n    return\n      interfaceId == type(ICollateralToken).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  function fileBatch(File[] calldata files) external requiresAuth {\n    uint256 i;\n    for (; i < files.length; ) {\n      _file(files[i]);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function file(File calldata incoming) public requiresAuth {\n    _file(incoming);\n  }\n\n  function _file(File calldata incoming) internal {\n    CollateralStorage storage s = _loadCollateralSlot();\n\n    FileType what = incoming.what;\n    bytes memory data = incoming.data;\n    if (what == FileType.AstariaRouter) {\n      address addr = abi.decode(data, (address));\n      s.ASTARIA_ROUTER = IAstariaRouter(addr);\n    } else if (what == FileType.SecurityHook) {\n      (address target, address hook) = abi.decode(data, (address, address));\n      s.securityHooks[target] = hook;\n    } else if (what == FileType.FlashEnabled) {\n      (address target, bool enabled) = abi.decode(data, (address, bool));\n      s.flashEnabled[target] = enabled;\n    } else if (what == FileType.Seaport) {\n      s.SEAPORT = ConsiderationInterface(abi.decode(data, (address)));\n      (, , address conduitController) = s.SEAPORT.information();\n      if (s.CONDUIT_KEY == bytes32(0)) {\n        s.CONDUIT_KEY = Bytes32AddressLib.fillLast12Bytes(address(this));\n      }\n      s.CONDUIT_CONTROLLER = ConduitControllerInterface(conduitController);\n      (address conduit, bool exists) = s.CONDUIT_CONTROLLER.getConduit(\n        s.CONDUIT_KEY\n      );\n      if (!exists) {\n        s.CONDUIT = s.CONDUIT_CONTROLLER.createConduit(\n          s.CONDUIT_KEY,\n          address(this)\n        );\n      } else {\n        s.CONDUIT = conduit;\n      }\n      s.CONDUIT_CONTROLLER.updateChannel(\n        address(s.CONDUIT),\n        address(s.SEAPORT),\n        true\n      );\n    } else {\n      revert UnsupportedFile();\n    }\n    emit FileUpdated(what, data);\n  }\n\n  modifier releaseCheck(uint256 collateralId) {\n    CollateralStorage storage s = _loadCollateralSlot();\n\n    if (s.LIEN_TOKEN.getCollateralState(collateralId) != bytes32(0)) {\n      revert InvalidCollateralState(InvalidCollateralStates.ACTIVE_LIENS);\n    }\n    if (s.collateralIdToAuction[collateralId] != bytes32(0)) {\n      revert InvalidCollateralState(InvalidCollateralStates.AUCTION_ACTIVE);\n    }\n    _;\n  }\n\n  modifier onlyOwner(uint256 collateralId) {\n    require(ownerOf(collateralId) == msg.sender);\n    _;\n  }\n\n  function flashAction(\n    IFlashAction receiver,\n    uint256 collateralId,\n    bytes calldata data\n  ) external onlyOwner(collateralId) {\n    address addr;\n    uint256 tokenId;\n    CollateralStorage storage s = _loadCollateralSlot();\n    (addr, tokenId) = getUnderlying(collateralId);\n\n    if (!s.flashEnabled[addr]) {\n      revert InvalidCollateralState(InvalidCollateralStates.FLASH_DISABLED);\n    }\n\n    if (\n      s.LIEN_TOKEN.getCollateralState(collateralId) == bytes32(\"ACTIVE_AUCTION\")\n    ) {\n      revert InvalidCollateralState(InvalidCollateralStates.AUCTION_ACTIVE);\n    }\n\n    bytes32 preTransferState;\n    //look to see if we have a security handler for this asset\n\n    address securityHook = s.securityHooks[addr];\n    if (securityHook != address(0)) {\n      preTransferState = ISecurityHook(securityHook).getState(addr, tokenId);\n    }\n    // transfer the NFT to the destination optimistically\n\n    ClearingHouse(s.clearingHouse[collateralId]).transferUnderlying(\n      addr,\n      tokenId,\n      address(receiver)\n    );\n\n    //trigger the flash action on the receiver\n    if (\n      receiver.onFlashAction(\n        IFlashAction.Underlying(s.clearingHouse[collateralId], addr, tokenId),\n        data\n      ) != keccak256(\"FlashAction.onFlashAction\")\n    ) {\n      revert FlashActionCallbackFailed();\n    }\n\n    if (\n      securityHook != address(0) &&\n      preTransferState != ISecurityHook(securityHook).getState(addr, tokenId)\n    ) {\n      revert FlashActionSecurityCheckFailed();\n    }\n\n    // validate that the NFT returned after the call\n\n    if (\n      IERC721(addr).ownerOf(tokenId) != address(s.clearingHouse[collateralId])\n    ) {\n      revert FlashActionNFTNotReturned();\n    }\n  }\n\n  function releaseToAddress(uint256 collateralId, address releaseTo)\n    public\n    releaseCheck(collateralId)\n    onlyOwner(collateralId)\n  {\n    CollateralStorage storage s = _loadCollateralSlot();\n\n    if (msg.sender != ownerOf(collateralId)) {\n      revert InvalidSender();\n    }\n    Asset memory underlying = s.idToUnderlying[collateralId];\n    address tokenContract = underlying.tokenContract;\n    _burn(collateralId);\n    delete s.idToUnderlying[collateralId];\n    _releaseToAddress(s, underlying, collateralId, releaseTo);\n  }\n\n  /**\n   * @dev Transfers locked collateral to a specified address and deletes the reference to the CollateralToken for that NFT.\n   * @param releaseTo The address to send the NFT to.\n   */\n  function _releaseToAddress(\n    CollateralStorage storage s,\n    Asset memory underlyingAsset,\n    uint256 collateralId,\n    address releaseTo\n  ) internal {\n    ClearingHouse(s.clearingHouse[collateralId]).transferUnderlying(\n      underlyingAsset.tokenContract,\n      underlyingAsset.tokenId,\n      releaseTo\n    );\n    emit ReleaseTo(\n      underlyingAsset.tokenContract,\n      underlyingAsset.tokenId,\n      releaseTo\n    );\n  }\n\n  function getConduitKey() public view returns (bytes32) {\n    CollateralStorage storage s = _loadCollateralSlot();\n    return s.CONDUIT_KEY;\n  }\n\n  function getConduit() public view returns (address) {\n    CollateralStorage storage s = _loadCollateralSlot();\n    return s.CONDUIT;\n  }\n\n  /**\n   * @notice Retrieve the address and tokenId of the underlying NFT of a CollateralToken.\n   * @param collateralId The ID of the CollateralToken wrapping the NFT.\n   * @return The address and tokenId of the underlying NFT.\n   */\n  function getUnderlying(uint256 collateralId)\n    public\n    view\n    returns (address, uint256)\n  {\n    Asset memory underlying = _loadCollateralSlot().idToUnderlying[\n      collateralId\n    ];\n    return (underlying.tokenContract, underlying.tokenId);\n  }\n\n  /**\n   * @notice Retrieve the tokenURI for a CollateralToken.\n   * @param collateralId The ID of the CollateralToken.\n   * @return the URI of the CollateralToken.\n   */\n  function tokenURI(uint256 collateralId)\n    public\n    view\n    virtual\n    override(ERC721, IERC721)\n    returns (string memory)\n  {\n    (address underlyingAsset, uint256 assetId) = getUnderlying(collateralId);\n    return ERC721(underlyingAsset).tokenURI(assetId);\n  }\n\n  function securityHooks(address target) public view returns (address) {\n    return _loadCollateralSlot().securityHooks[target];\n  }\n\n  function getClearingHouse(uint256 collateralId)\n    external\n    view\n    returns (ClearingHouse)\n  {\n    return\n      ClearingHouse(payable(_loadCollateralSlot().clearingHouse[collateralId]));\n  }\n\n  function _generateValidOrderParameters(\n    CollateralStorage storage s,\n    address settlementToken,\n    uint256 collateralId,\n    uint256[] memory prices,\n    uint256 maxDuration\n  ) internal returns (OrderParameters memory orderParameters) {\n    OfferItem[] memory offer = new OfferItem[](1);\n\n    Asset memory underlying = s.idToUnderlying[collateralId];\n\n    offer[0] = OfferItem(\n      ItemType.ERC721,\n      underlying.tokenContract,\n      underlying.tokenId,\n      1,\n      1\n    );\n\n    ConsiderationItem[] memory considerationItems = new ConsiderationItem[](2);\n    considerationItems[0] = ConsiderationItem(\n      ItemType.ERC20,\n      settlementToken,\n      uint256(0),\n      prices[0],\n      prices[1],\n      payable(address(s.clearingHouse[collateralId]))\n    );\n    considerationItems[1] = ConsiderationItem(\n      ItemType.ERC1155,\n      s.clearingHouse[collateralId],\n      uint256(uint160(settlementToken)),\n      prices[0],\n      prices[1],\n      payable(s.clearingHouse[collateralId])\n    );\n\n    orderParameters = OrderParameters({\n      offerer: s.clearingHouse[collateralId],\n      zone: address(this), // 0x20\n      offer: offer,\n      consideration: considerationItems,\n      orderType: OrderType.FULL_OPEN,\n      startTime: uint256(block.timestamp),\n      endTime: uint256(block.timestamp + maxDuration),\n      zoneHash: bytes32(collateralId),\n      salt: uint256(blockhash(block.number)),\n      conduitKey: s.CONDUIT_KEY, // 0x120\n      totalOriginalConsiderationItems: considerationItems.length\n    });\n  }\n\n  function auctionVault(AuctionVaultParams calldata params)\n    external\n    requiresAuth\n    returns (OrderParameters memory orderParameters)\n  {\n    CollateralStorage storage s = _loadCollateralSlot();\n\n    uint256[] memory prices = new uint256[](2);\n    prices[0] = params.startingPrice;\n    prices[1] = params.endingPrice;\n    orderParameters = _generateValidOrderParameters(\n      s,\n      params.settlementToken,\n      params.collateralId,\n      prices,\n      params.maxDuration\n    );\n\n    _listUnderlyingOnSeaport(\n      s,\n      params.collateralId,\n      Order(orderParameters, new bytes(0))\n    );\n  }\n\n  function _listUnderlyingOnSeaport(\n    CollateralStorage storage s,\n    uint256 collateralId,\n    Order memory listingOrder\n  ) internal {\n    //get total Debt and ensure its being sold for more than that\n\n    if (listingOrder.parameters.conduitKey != s.CONDUIT_KEY) {\n      revert InvalidConduitKey();\n    }\n    if (listingOrder.parameters.zone != address(this)) {\n      revert InvalidZone();\n    }\n\n    ClearingHouse(s.clearingHouse[collateralId]).validateOrder(listingOrder);\n    emit ListedOnSeaport(collateralId, listingOrder);\n\n    s.collateralIdToAuction[collateralId] = keccak256(\n      abi.encode(listingOrder.parameters)\n    );\n  }\n\n  function settleAuction(uint256 collateralId) public {\n    CollateralStorage storage s = _loadCollateralSlot();\n    if (\n      s.collateralIdToAuction[collateralId] == bytes32(0) &&\n      ERC721(s.idToUnderlying[collateralId].tokenContract).ownerOf(\n        s.idToUnderlying[collateralId].tokenId\n      ) !=\n      s.clearingHouse[collateralId]\n    ) {\n      revert InvalidCollateralState(InvalidCollateralStates.NO_AUCTION);\n    }\n    require(msg.sender == s.clearingHouse[collateralId]);\n    _settleAuction(s, collateralId);\n    delete s.idToUnderlying[collateralId];\n    _burn(collateralId);\n  }\n\n  function _settleAuction(CollateralStorage storage s, uint256 collateralId)\n    internal\n  {\n    delete s.collateralIdToAuction[collateralId];\n  }\n\n  /**\n   * @dev Mints a new CollateralToken wrapping an NFT.\n   * @param from_ the owner of the collateral deposited\n   * @param tokenId_ The NFT token ID\n   * @return a static return of the receive signature\n   */\n  function onERC721Received(\n    address, /* operator_ */\n    address from_,\n    uint256 tokenId_,\n    bytes calldata // calldata data_\n  ) external override whenNotPaused returns (bytes4) {\n    CollateralStorage storage s = _loadCollateralSlot();\n    uint256 collateralId = msg.sender.computeId(tokenId_);\n\n    Asset memory incomingAsset = s.idToUnderlying[collateralId];\n    if (incomingAsset.tokenContract == address(0)) {\n      require(ERC721(msg.sender).ownerOf(tokenId_) == address(this));\n\n      if (s.clearingHouse[collateralId] == address(0)) {\n        address clearingHouse = ClonesWithImmutableArgs.clone(\n          s.ASTARIA_ROUTER.BEACON_PROXY_IMPLEMENTATION(),\n          abi.encodePacked(\n            address(s.ASTARIA_ROUTER),\n            uint8(IAstariaRouter.ImplementationType.ClearingHouse),\n            collateralId\n          )\n        );\n\n        s.clearingHouse[collateralId] = clearingHouse;\n      }\n      ERC721(msg.sender).safeTransferFrom(\n        address(this),\n        s.clearingHouse[collateralId],\n        tokenId_\n      );\n\n      if (msg.sender == address(this) || msg.sender == address(s.LIEN_TOKEN)) {\n        revert InvalidCollateral();\n      }\n\n      _mint(from_, collateralId);\n\n      s.idToUnderlying[collateralId] = Asset({\n        tokenContract: msg.sender,\n        tokenId: tokenId_\n      });\n\n      emit Deposit721(msg.sender, tokenId_, collateralId, from_);\n      return IERC721Receiver.onERC721Received.selector;\n    } else {\n      revert();\n    }\n  }\n\n  modifier whenNotPaused() {\n    if (_loadCollateralSlot().ASTARIA_ROUTER.paused()) {\n      revert ProtocolPaused();\n    }\n    _;\n  }\n}"
    },
    {
      "filename": "src/LienToken.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**                                                     \n*  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗ \n* ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n* ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n* ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n* ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n* ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n*\n* Astaria Labs, Inc\n*/\n\npragma solidity =0.8.17;\n\npragma experimental ABIEncoderV2;\n\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport {ERC721} from \"gpl/ERC721.sol\";\nimport {IERC721} from \"core/interfaces/IERC721.sol\";\nimport {IERC165} from \"core/interfaces/IERC165.sol\";\nimport {ITransferProxy} from \"core/interfaces/ITransferProxy.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\nimport {CollateralLookup} from \"core/libraries/CollateralLookup.sol\";\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {ICollateralToken} from \"core/interfaces/ICollateralToken.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\n\nimport {IPublicVault} from \"core/interfaces/IPublicVault.sol\";\nimport {VaultImplementation} from \"./VaultImplementation.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {AuthInitializable} from \"core/AuthInitializable.sol\";\nimport {Initializable} from \"./utils/Initializable.sol\";\n\n/**\n * @title LienToken\n * @notice This contract handles the creation, payments, buyouts, and liquidations of tokenized NFT-collateralized debt (liens). Vaults which originate loans against supported collateral are issued a LienToken representing the right to loan repayments and auctioned funds on liquidation.\n */\ncontract LienToken is ERC721, ILienToken, AuthInitializable {\n  using FixedPointMathLib for uint256;\n  using CollateralLookup for address;\n  using SafeCastLib for uint256;\n  using SafeTransferLib for ERC20;\n\n  uint256 private constant LIEN_SLOT =\n    uint256(keccak256(\"xyz.astaria.LienToken.storage.location\")) - 1;\n\n  bytes32 constant ACTIVE_AUCTION = bytes32(\"ACTIVE_AUCTION\");\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize(Authority _AUTHORITY, ITransferProxy _TRANSFER_PROXY)\n    public\n    initializer\n  {\n    __initAuth(msg.sender, address(_AUTHORITY));\n    __initERC721(\"Astaria Lien Token\", \"ALT\");\n    LienStorage storage s = _loadLienStorageSlot();\n    s.TRANSFER_PROXY = _TRANSFER_PROXY;\n    s.maxLiens = uint8(5);\n  }\n\n  function _loadLienStorageSlot()\n    internal\n    pure\n    returns (LienStorage storage s)\n  {\n    uint256 slot = LIEN_SLOT;\n\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  function file(File calldata incoming) external requiresAuth {\n    FileType what = incoming.what;\n    bytes memory data = incoming.data;\n    LienStorage storage s = _loadLienStorageSlot();\n    if (what == FileType.CollateralToken) {\n      s.COLLATERAL_TOKEN = ICollateralToken(abi.decode(data, (address)));\n    } else if (what == FileType.AstariaRouter) {\n      s.ASTARIA_ROUTER = IAstariaRouter(abi.decode(data, (address)));\n    } else {\n      revert UnsupportedFile();\n    }\n    emit FileUpdated(what, data);\n  }\n\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC721, IERC165)\n    returns (bool)\n  {\n    return\n      interfaceId == type(ILienToken).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  function buyoutLien(ILienToken.LienActionBuyout calldata params)\n    external\n    validateStack(params.encumber.lien.collateralId, params.encumber.stack)\n    returns (Stack[] memory, Stack memory newStack)\n  {\n    if (block.timestamp >= params.encumber.stack[params.position].point.end) {\n      revert InvalidState(InvalidStates.EXPIRED_LIEN);\n    }\n    LienStorage storage s = _loadLienStorageSlot();\n    if (!s.ASTARIA_ROUTER.isValidVault(msg.sender)) {\n      revert InvalidSender();\n    }\n    return _buyoutLien(s, params);\n  }\n\n  function _buyoutLien(\n    LienStorage storage s,\n    ILienToken.LienActionBuyout calldata params\n  ) internal returns (Stack[] memory newStack, Stack memory newLien) {\n    //the borrower shouldn't incur more debt from the buyout than they already owe\n    (, newLien) = _createLien(s, params.encumber);\n    if (\n      !s.ASTARIA_ROUTER.isValidRefinance({\n        newLien: params.encumber.lien,\n        position: params.position,\n        stack: params.encumber.stack\n      })\n    ) {\n      revert InvalidRefinance();\n    }\n\n    if (\n      s.collateralStateHash[params.encumber.lien.collateralId] == ACTIVE_AUCTION\n    ) {\n      revert InvalidState(InvalidStates.COLLATERAL_AUCTION);\n    }\n    (uint256 owed, uint256 buyout) = _getBuyout(\n      s,\n      params.encumber.stack[params.position]\n    );\n\n    if (params.encumber.lien.details.maxAmount < owed) {\n      revert InvalidBuyoutDetails(params.encumber.lien.details.maxAmount, owed);\n    }\n\n    uint256 potentialDebt = 0;\n    for (uint256 i = params.encumber.stack.length; i > 0; ) {\n      uint256 j = i - 1;\n      // should not be able to purchase lien if any lien in the stack is expired (and will be liquidated)\n      if (block.timestamp >= params.encumber.stack[j].point.end) {\n        revert InvalidState(InvalidStates.EXPIRED_LIEN);\n      }\n\n      potentialDebt += _getOwed(\n        params.encumber.stack[j],\n        params.encumber.stack[j].point.end\n      );\n\n      if (\n        potentialDebt >\n        params.encumber.stack[j].lien.details.liquidationInitialAsk\n      ) {\n        revert InvalidState(InvalidStates.INITIAL_ASK_EXCEEDED);\n      }\n\n      unchecked {\n        --i;\n      }\n    }\n\n    address payee = _getPayee(\n      s,\n      params.encumber.stack[params.position].point.lienId\n    );\n    s.TRANSFER_PROXY.tokenTransferFrom(\n      params.encumber.stack[params.position].lien.token,\n      msg.sender,\n      payee,\n      buyout\n    );\n\n    if (_isPublicVault(s, payee)) {\n      IPublicVault(payee).handleBuyoutLien(\n        IPublicVault.BuyoutLienParams({\n          lienSlope: calculateSlope(params.encumber.stack[params.position]),\n          lienEnd: params.encumber.stack[params.position].point.end,\n          increaseYIntercept: buyout -\n            params.encumber.stack[params.position].point.amount\n        })\n      );\n    }\n\n    newStack = _replaceStackAtPositionWithNewLien(\n      s,\n      params.encumber.stack,\n      params.position,\n      newLien,\n      params.encumber.stack[params.position].point.lienId\n    );\n    uint256 maxPotentialDebt;\n    uint256 n = newStack.length;\n    uint256 i;\n    for (i; i < n; ) {\n      maxPotentialDebt += _getOwed(newStack[i], newStack[i].point.end);\n      //no need to check validity before the position we're buying\n      if (i == params.position) {\n        if (maxPotentialDebt > params.encumber.lien.details.maxPotentialDebt) {\n          revert InvalidState(InvalidStates.DEBT_LIMIT);\n        }\n      }\n      if (\n        i > params.position &&\n        (maxPotentialDebt > newStack[i].lien.details.maxPotentialDebt)\n      )"
    }
  ]
}