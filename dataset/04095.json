{
  "Title": "It is necessary to check the correctness of the variable value",
  "Content": "##### Description\n* At the line https://github.com/pie-dao/ExperiPie/blob/facf3c246d9c43f5b1e0bad7dc2b0a9a2a2393c5/contracts/facets/ERC20/LibERC20.sol#L25 the `burn()` function decreases the value of the amount of `es.balances` tokens for the`_from` wallet. We recommend adding a check of the current value of the `_from` variable for zero:\n```require(_from != address(0), \"burn from the zero address\");```\n* At the line https://github.com/pie-dao/ExperiPie/blob/facf3c246d9c43f5b1e0bad7dc2b0a9a2a2393c5/contracts/facets/ERC20/ERC20Facet.sol#L57 the `approve()` function gives a permission to dispose of own tokens for the `_spender` wallet. We recommend adding a check of the current value of the `_spender` variable to zero:\n```require(_spender != address(0), \"approve to the zero address\");```\n* At the line https://github.com/pie-dao/ExperiPie/blob/facf3c246d9c43f5b1e0bad7dc2b0a9a2a2393c5/contracts/facets/ERC20/ERC20Facet.sol#L79 in the `transferFrom()` function, there is a decrease in the value of the amount tokens allowed to the sender`msg.sender` for the `_from` wallet. We recommend adding a check of the current value of the `_from` variable for zero:\n```require(_from != address(0), \"transfer from the zero address\");```\n* At the line https://github.com/pie-dao/ExperiPie/blob/facf3c246d9c43f5b1e0bad7dc2b0a9a2a2393c5/contracts/facets/ERC20/ERC20Facet.sol#L115 in the `_transfer ()` function, the value of the amount of tokens for the `_from` wallet is decreasing. We recommend adding a check of the current value of the `_from` variable for zero: \n```require(_from != address(0), \"transfer from the zero address\");```\n\n##### Recommendation\nWe recommend adding a the particular checks.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/facets/ERC20/LibERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\n\nimport \"./LibERC20Storage.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nlibrary LibERC20 {\n  using SafeMath for uint256;\n\n  // Need to include events locally because `emit Interface.Event(params)` does not work\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  function mint(address _to, uint256 _amount) internal {\n    LibERC20Storage.ERC20Storage storage es = LibERC20Storage.erc20Storage();\n\n    es.balances[_to] = es.balances[_to].add(_amount);\n    es.totalSupply = es.totalSupply.add(_amount);\n    emit Transfer(address(0), _to, _amount);\n  }\n\n  function burn(address _from, uint256 _amount) internal {\n    LibERC20Storage.ERC20Storage storage es = LibERC20Storage.erc20Storage();\n\n    es.balances[_from] = es.balances[_from].sub(_amount);\n    es.totalSupply = es.totalSupply.sub(_amount);\n    emit Transfer(_from, address(0), _amount);\n  }\n}"
    },
    {
      "filename": "contracts/facets/ERC20/ERC20Facet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"diamond-2/contracts/libraries/LibDiamond.sol\";\n\nimport \"../../interfaces/IERC20Facet.sol\";\nimport \"./LibERC20Storage.sol\";\nimport \"./LibERC20.sol\";\nimport \"../shared/Access/CallProtection.sol\";\n\ncontract ERC20Facet is IERC20, IERC20Facet, CallProtection {\n  using SafeMath for uint256;\n\n  function initialize(\n    uint256 _initialSupply,\n    string memory _name,\n    string memory _symbol\n  ) external override {\n    LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n    LibERC20Storage.ERC20Storage storage es = LibERC20Storage.erc20Storage();\n\n    require(msg.sender == ds.contractOwner, \"Must own the contract.\");\n\n    LibERC20.mint(msg.sender, _initialSupply);\n\n    es.name = _name;\n    es.symbol = _symbol;\n  }\n\n  function name() external view override returns (string memory) {\n    return LibERC20Storage.erc20Storage().name;\n  }\n\n  function symbol() external view override returns (string memory) {\n    return LibERC20Storage.erc20Storage().symbol;\n  }\n\n  function decimals() external pure override returns (uint8) {\n    return 18;\n  }\n\n  function mint(address _receiver, uint256 _amount) external override protectedCall {\n    LibERC20.mint(_receiver, _amount);\n  }\n\n  function burn(address _from, uint256 _amount) external override protectedCall {\n    LibERC20.burn(_from, _amount);\n  }\n\n  function approve(address _spender, uint256 _amount)\n    external\n    override\n    returns (bool)\n  {\n    LibERC20Storage.erc20Storage().allowances[msg.sender][_spender] = _amount;\n    emit Approval(msg.sender, _spender, _amount);\n    return true;\n  }\n\n  function transfer(address _to, uint256 _amount)\n    external\n    override\n    returns (bool)\n  {\n    _transfer(msg.sender, _to, _amount);\n    return true;\n  }\n\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _amount\n  ) external override returns (bool) {\n    LibERC20Storage.ERC20Storage storage es = LibERC20Storage.erc20Storage();\n\n    // Update approval if not set to max uint256\n    if (es.allowances[_from][msg.sender] != uint256(-1)) {\n      uint256 newApproval = es.allowances[_from][msg.sender].sub(_amount);\n      es.allowances[_from][msg.sender] = newApproval;\n      emit Approval(_from, msg.sender, newApproval);\n    }\n\n    _transfer(_from, _to, _amount);\n  }\n\n  function allowance(address _owner, address _spender)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return LibERC20Storage.erc20Storage().allowances[_owner][_spender];\n  }\n\n  function balanceOf(address _of) external view override returns (uint256) {\n    return LibERC20Storage.erc20Storage().balances[_of];\n  }\n\n  function totalSupply() external view override returns (uint256) {\n    return LibERC20Storage.erc20Storage().totalSupply;\n  }\n\n  function _transfer(\n    address _from,\n    address _to,\n    uint256 _amount\n  ) internal {\n    if (_to == address(0)) {\n      return LibERC20.burn(msg.sender, _amount);\n    }\n    LibERC20Storage.ERC20Storage storage es = LibERC20Storage.erc20Storage();\n\n    es.balances[_from] = es.balances[_from].sub(_amount);\n    es.balances[_to] = es.balances[_to].add(_amount);\n\n    emit Transfer(_from, _to, _amount);\n  }\n}"
    },
    {
      "filename": "contracts/facets/ERC20/ERC20Facet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"diamond-2/contracts/libraries/LibDiamond.sol\";\n\nimport \"../../interfaces/IERC20Facet.sol\";\nimport \"./LibERC20Storage.sol\";\nimport \"./LibERC20.sol\";\nimport \"../shared/Access/CallProtection.sol\";\n\ncontract ERC20Facet is IERC20, IERC20Facet, CallProtection {\n  using SafeMath for uint256;\n\n  function initialize(\n    uint256 _initialSupply,\n    string memory _name,\n    string memory _symbol\n  ) external override {\n    LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n    LibERC20Storage.ERC20Storage storage es = LibERC20Storage.erc20Storage();\n\n    require(msg.sender == ds.contractOwner, \"Must own the contract.\");\n\n    LibERC20.mint(msg.sender, _initialSupply);\n\n    es.name = _name;\n    es.symbol = _symbol;\n  }\n\n  function name() external view override returns (string memory) {\n    return LibERC20Storage.erc20Storage().name;\n  }\n\n  function symbol() external view override returns (string memory) {\n    return LibERC20Storage.erc20Storage().symbol;\n  }\n\n  function decimals() external pure override returns (uint8) {\n    return 18;\n  }\n\n  function mint(address _receiver, uint256 _amount) external override protectedCall {\n    LibERC20.mint(_receiver, _amount);\n  }\n\n  function burn(address _from, uint256 _amount) external override protectedCall {\n    LibERC20.burn(_from, _amount);\n  }\n\n  function approve(address _spender, uint256 _amount)\n    external\n    override\n    returns (bool)\n  {\n    LibERC20Storage.erc20Storage().allowances[msg.sender][_spender] = _amount;\n    emit Approval(msg.sender, _spender, _amount);\n    return true;\n  }\n\n  function transfer(address _to, uint256 _amount)\n    external\n    override\n    returns (bool)\n  {\n    _transfer(msg.sender, _to, _amount);\n    return true;\n  }\n\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _amount\n  ) external override returns (bool) {\n    LibERC20Storage.ERC20Storage storage es = LibERC20Storage.erc20Storage();\n\n    // Update approval if not set to max uint256\n    if (es.allowances[_from][msg.sender] != uint256(-1)) {\n      uint256 newApproval = es.allowances[_from][msg.sender].sub(_amount);\n      es.allowances[_from][msg.sender] = newApproval;\n      emit Approval(_from, msg.sender, newApproval);\n    }\n\n    _transfer(_from, _to, _amount);\n  }\n\n  function allowance(address _owner, address _spender)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return LibERC20Storage.erc20Storage().allowances[_owner][_spender];\n  }\n\n  function balanceOf(address _of) external view override returns (uint256) {\n    return LibERC20Storage.erc20Storage().balances[_of];\n  }\n\n  function totalSupply() external view override returns (uint256) {\n    return LibERC20Storage.erc20Storage().totalSupply;\n  }\n\n  function _transfer(\n    address _from,\n    address _to,\n    uint256 _amount\n  ) internal {\n    if (_to == address(0)) {\n      return LibERC20.burn(msg.sender, _amount);\n    }\n    LibERC20Storage.ERC20Storage storage es = LibERC20Storage.erc20Storage();\n\n    es.balances[_from] = es.balances[_from].sub(_amount);\n    es.balances[_to] = es.balances[_to].add(_amount);\n\n    emit Transfer(_from, _to, _amount);\n  }\n}"
    },
    {
      "filename": "contracts/facets/ERC20/ERC20Facet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"diamond-2/contracts/libraries/LibDiamond.sol\";\n\nimport \"../../interfaces/IERC20Facet.sol\";\nimport \"./LibERC20Storage.sol\";\nimport \"./LibERC20.sol\";\nimport \"../shared/Access/CallProtection.sol\";\n\ncontract ERC20Facet is IERC20, IERC20Facet, CallProtection {\n  using SafeMath for uint256;\n\n  function initialize(\n    uint256 _initialSupply,\n    string memory _name,\n    string memory _symbol\n  ) external override {\n    LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n    LibERC20Storage.ERC20Storage storage es = LibERC20Storage.erc20Storage();\n\n    require(msg.sender == ds.contractOwner, \"Must own the contract.\");\n\n    LibERC20.mint(msg.sender, _initialSupply);\n\n    es.name = _name;\n    es.symbol = _symbol;\n  }\n\n  function name() external view override returns (string memory) {\n    return LibERC20Storage.erc20Storage().name;\n  }\n\n  function symbol() external view override returns (string memory) {\n    return LibERC20Storage.erc20Storage().symbol;\n  }\n\n  function decimals() external pure override returns (uint8) {\n    return 18;\n  }\n\n  function mint(address _receiver, uint256 _amount) external override protectedCall {\n    LibERC20.mint(_receiver, _amount);\n  }\n\n  function burn(address _from, uint256 _amount) external override protectedCall {\n    LibERC20.burn(_from, _amount);\n  }\n\n  function approve(address _spender, uint256 _amount)\n    external\n    override\n    returns (bool)\n  {\n    LibERC20Storage.erc20Storage().allowances[msg.sender][_spender] = _amount;\n    emit Approval(msg.sender, _spender, _amount);\n    return true;\n  }\n\n  function transfer(address _to, uint256 _amount)\n    external\n    override\n    returns (bool)\n  {\n    _transfer(msg.sender, _to, _amount);\n    return true;\n  }\n\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _amount\n  ) external override returns (bool) {\n    LibERC20Storage.ERC20Storage storage es = LibERC20Storage.erc20Storage();\n\n    // Update approval if not set to max uint256\n    if (es.allowances[_from][msg.sender] != uint256(-1)) {\n      uint256 newApproval = es.allowances[_from][msg.sender].sub(_amount);\n      es.allowances[_from][msg.sender] = newApproval;\n      emit Approval(_from, msg.sender, newApproval);\n    }\n\n    _transfer(_from, _to, _amount);\n  }\n\n  function allowance(address _owner, address _spender)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return LibERC20Storage.erc20Storage().allowances[_owner][_spender];\n  }\n\n  function balanceOf(address _of) external view override returns (uint256) {\n    return LibERC20Storage.erc20Storage().balances[_of];\n  }\n\n  function totalSupply() external view override returns (uint256) {\n    return LibERC20Storage.erc20Storage().totalSupply;\n  }\n\n  function _transfer(\n    address _from,\n    address _to,\n    uint256 _amount\n  ) internal {\n    if (_to == address(0)) {\n      return LibERC20.burn(msg.sender, _amount);\n    }\n    LibERC20Storage.ERC20Storage storage es = LibERC20Storage.erc20Storage();\n\n    es.balances[_from] = es.balances[_from].sub(_amount);\n    es.balances[_to] = es.balances[_to].add(_amount);\n\n    emit Transfer(_from, _to, _amount);\n  }\n}"
    }
  ]
}