{
  "Title": "[13] Accumulator code depends on memory usage",
  "Content": "\nThe accumulator is used in [`BasicOrderFulfiller`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/BasicOrderFulfiller.sol#L196), [`OrderFulfiller`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/OrderFulfiller.sol#L175) and [`OrderCombiner`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/OrderCombiner.sol#L618). It is a variable length array, but does not have a properly allocated memory space. It can be grown using [`_insert`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/Executor.sol#L588) and [`_trigger`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/Executor.sol#L456) will \"flush\" it.\n\nThe problem is it is placed at the free memory pointer, but the pointer is not increment if it would grow beyond its initial capacity. The initial capacity is `AccumulatorDisarmed` aka 32. In the use cases it seems at most 2 entries are inserted.\n\nInstead of relying that this memory space is never overwritten, it may make sense pre-allocating a fixed structure. The current implementation can break on compiler upgrades or changes in the function layouts.\n\n### Proof of Concept\n**Context:** [`BasicOrderFulfiller`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/BasicOrderFulfiller.sol#L196), [`OrderFulfiller`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/OrderFulfiller.sol#L175), [`OrderCombiner`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/OrderCombiner.sol#L618), [`_insert`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/Executor.sol#L588), [`_trigger`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/Executor.sol#L456)\n\n### Recommended Mitigation Steps\n\nAvoid using the non-memory allocating accumulator design.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-opensea-seaport",
  "Code": [
    {
      "filename": "contracts/lib/BasicOrderFulfiller.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport { ConduitInterface } from \"../interfaces/ConduitInterface.sol\";\n\n// prettier-ignore\nimport {\n    OrderType,\n    ItemType,\n    BasicOrderRouteType\n} from \"./ConsiderationEnums.sol\";\n\n// prettier-ignore\nimport {\n    AdditionalRecipient,\n    BasicOrderParameters,\n    OfferItem,\n    ConsiderationItem,\n    SpentItem,\n    ReceivedItem\n} from \"./ConsiderationStructs.sol\";\n\nimport { OrderValidator } from \"./OrderValidator.sol\";\n\nimport \"./ConsiderationConstants.sol\";\n\n/**\n * @title BasicOrderFulfiller\n * @author 0age\n * @notice BasicOrderFulfiller contains functionality for fulfilling \"basic\"\n *         orders with minimal overhead. See documentation for details on what\n *         qualifies as a basic order.\n */\ncontract BasicOrderFulfiller is OrderValidator {\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController) OrderValidator(conduitController) {}\n\n    /**\n     * @dev Internal function to fulfill an order offering an ERC20, ERC721, or\n     *      ERC1155 item by supplying Ether (or other native tokens), ERC20\n     *      tokens, an ERC721 item, or an ERC1155 item as consideration. Six\n     *      permutations are supported: Native token to ERC721, Native token to\n     *      ERC1155, ERC20 to ERC721, ERC20 to ERC1155, ERC721 to ERC20, and\n     *      ERC1155 to ERC20 (with native tokens supplied as msg.value). For an\n     *      order to be eligible for fulfillment via this method, it must\n     *      contain a single offer item (though that item may have a greater\n     *      amount if the item is not an ERC721). An arbitrary number of\n     *      \"additional recipients\" may also be supplied which will each receive\n     *      native tokens or ERC20 items from the fulfiller as consideration.\n     *      Refer to the documentation for a more comprehensive summary of how\n     *      to utilize this method and what orders are compatible with it.\n     *\n     * @param parameters Additional information on the fulfilled order. Note\n     *                   that the offerer and the fulfiller must first approve\n     *                   this contract (or their chosen conduit if indicated)\n     *                   before any tokens can be transferred. Also note that\n     *                   contract recipients of ERC1155 consideration items must\n     *                   implement `onERC1155Received` in order to receive those\n     *                   items.\n     *\n     * @return A boolean indicating whether the order has been fulfilled.\n     */\n    function _validateAndFulfillBasicOrder(\n        BasicOrderParameters calldata parameters\n    ) internal returns (bool) {\n        // Declare enums for order type & route to extract from basicOrderType.\n        BasicOrderRouteType route;\n        OrderType orderType;\n\n        // Declare additional recipient item type to derive from the route type.\n        ItemType additionalRecipientsItemType;\n\n        // Utilize assembly to extract the order type and the basic order route.\n        assembly {\n            // Mask all but 2 least-significant bits to derive the order type.\n            orderType := and(calldataload(BasicOrder_basicOrderType_cdPtr), 3)\n\n            // Divide basicOrderType by four to derive the route.\n            route := div(calldataload(BasicOrder_basicOrderType_cdPtr), 4)\n\n            // If route > 1 additionalRecipient items are ERC20 (1) else Eth (0)\n            additionalRecipientsItemType := gt(route, 1)\n        }\n\n        {\n            // Declare temporary variable for enforcing payable status.\n            bool correctPayableStatus;\n\n            // Utilize assembly to compare the route to the callvalue.\n            assembly {\n                // route 0 and 1 are payable, otherwise route is not payable.\n                correctPayableStatus := eq(\n                    additionalRecipientsItemType,\n                    iszero(callvalue())\n                )\n            }\n\n            // Revert if msg.value has not been supplied as part of payable\n            // routes or has been supplied as part of non-payable routes.\n            if (!correctPayableStatus) {\n                revert InvalidMsgValue(msg.value);\n            }\n        }\n\n        // Declare more arguments that will be derived from route and calldata.\n        address additionalRecipientsToken;\n        ItemType receivedItemType;\n        ItemType offeredItemType;\n\n        // Utilize assembly to retrieve function arguments and cast types.\n        assembly {\n            // Determine if offered item type == additional recipient item type.\n            let offerTypeIsAdditionalRecipientsType := gt(route, 3)\n\n            // If route > 3 additionalRecipientsToken is at 0xc4 else 0x24.\n            additionalRecipientsToken := calldataload(\n                add(\n                    BasicOrder_considerationToken_cdPtr,\n                    mul(offerTypeIsAdditionalRecipientsType, FiveWords)\n                )\n            )\n\n            // If route > 2, receivedItemType is route - 2. If route is 2, then\n            // receivedItemType is ERC20 (1). Otherwise, it is Eth (0).\n            receivedItemType := add(\n                mul(sub(route, 2), gt(route, 2)),\n                eq(route, 2)\n            )\n\n            // If route > 3, offeredItemType is ERC20 (1). If route is 2 or 3,\n            // offeredItemType = route. If route is 0 or 1, it is route + 2.\n            offeredItemType := sub(\n                add(route, mul(iszero(additionalRecipientsItemType), 2)),\n                mul(\n                    offerTypeIsAdditionalRecipientsType,\n                    add(receivedItemType, 1)\n                )\n            )\n        }\n\n        // Derive & validate order using parameters and update order status.\n        _prepareBasicFulfillmentFromCalldata(\n            parameters,\n            orderType,\n            receivedItemType,\n            additionalRecipientsItemType,\n            additionalRecipientsToken,\n            offeredItemType\n        );\n\n        // Read offerer from calldata and place on the stack.\n        address payable offerer = parameters.offerer;\n\n        // Declare conduitKey argument used by transfer functions.\n        bytes32 conduitKey;\n\n        // Utilize assembly to derive conduit (if relevant) based on route.\n        assembly {\n            // use offerer conduit for routes 0-3, fulfiller conduit otherwise.\n            conduitKey := calldataload(\n                add(BasicOrder_offererConduit_cdPtr, mul(gt(route, 3), OneWord))\n            )\n        }\n\n        // Transfer tokens based on the route.\n        if (additionalRecipientsItemType == ItemType.NATIVE) {\n            _transferIndividual721Or1155Item(\n                offeredItemType,\n                parameters.offerToken,\n                offerer,\n                msg.sender,\n                parameters.offerIdentifier,\n                parameters.offerAmount,\n                conduitKey\n            );\n\n            // Transfer native to recipients, return excess to caller & wrap up.\n            _transferEthAndFinalize(\n                parameters.considerationAmount,\n                offerer,\n                parameters.additionalRecipients\n            );\n        } else {\n            // Initialize an accumulator array. From this point forward, no new\n            // memory regions can be safely allocated until the accumulator is\n            // no longer being utilized, as the accumulator operates in an\n            // open-ended fashion from this memory pointer; existing memory may\n            // still be accessed and modified, however.\n            bytes memory accumulator = new bytes(AccumulatorDisarmed);\n\n            if (route == BasicOrderRouteType.ERC20_TO_ERC721) {\n                // Transfer ERC721 to caller using offerer's conduit preference.\n                _transferERC721(\n                    parameters.offerToken,\n                    offerer,\n                    msg.sender,\n                    parameters.offerIdentifier,\n                    parameters.offerAmount,\n                    conduitKey,\n                    accumulator\n                );\n\n                // Transfer ERC20 tokens to all recipients and wrap up.\n                _transferERC20AndFinalize(\n                    msg.sender,\n                    offerer,\n                    parameters.considerationToken,\n                    parameters.considerationAmount,\n                    parameters.additionalRecipients,\n                    false, // Send full amount indicated by consideration items.\n                    accumulator\n                );\n            } else if (route == BasicOrderRouteType.ERC20_TO_ERC1155) {\n                // Transfer ERC1155 to caller with offerer's conduit preference.\n                _transferERC1155(\n                    parameters.offerToken,\n                    offerer,\n                    msg.sender,\n                    parameters.offerIdentifier,\n                    parameters.offerAmount,\n                    conduitKey,\n                    accumulator\n                );\n\n                // Transfer ERC20 tokens to all recipients and wrap up.\n                _transferERC20AndFinalize(\n                    msg.sender,\n                    offerer,\n                    parameters.considerationToken,\n                    parameters.considerationAmount,\n                    parameters.additionalRecipients,\n                    false, // Send full amount indicated by consideration items.\n                    accumulator\n                );\n            } else if (route == BasicOrderRouteType.ERC721_TO_ERC20) {\n                // Transfer ERC721 to offerer using caller's conduit preference.\n                _transferERC721(\n                    parameters.considerationToken,\n                    msg.sender,\n                    offerer,\n                    parameters.considerationIdentifier,\n                    parameters.considerationAmount,\n                    conduitKey,\n                    accumulator\n                );\n\n                // Transfer ERC20 tokens to all recipients and wrap up.\n                _transferERC20AndFinalize(\n                    offerer,\n                    msg.sender,\n                    parameters.offerToken,\n                    parameters.offerAmount,\n                    parameters.additionalRecipients,\n                    true, // Reduce fulfiller amount sent by additional amounts.\n                    accumulator\n                );\n            } else {\n                // route == BasicOrderRouteType.ERC1155_TO_ERC20\n\n                // Transfer ERC1155 to offerer with caller's conduit preference.\n                _transferERC1155(\n                    parameters.considerationToken,\n                    msg.sender,\n                    offerer,\n                    parameters.considerationIdentifier,\n                    parameters.considerationAmount,\n                    conduitKey,\n                    accumulator\n                );\n\n                // Transfer ERC20 tokens to all recipients and wrap up.\n                _transferERC20AndFinalize(\n                    offerer,\n                    msg.sender,\n                    parameters.offerToken,\n                    parameters.offerAmount,\n                    parameters.additionalRecipients,\n                    true, // Reduce fulfiller amount sent by additional amounts.\n                    accumulator\n                );\n            }\n\n            // Trigger any remaining accumulated transfers via call to conduit.\n            _triggerIfArmed(accumulator);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Internal function to prepare fulfillment of a basic order with\n     *      manual calldata and memory access. This calculates the order hash,\n     *      emits an OrderFulfilled event, and asserts basic order validity.\n     *      Note that calldata offsets must be validated as this function\n     *      accesses constant calldata pointers for dynamic types that match\n     *      default ABI encoding, but valid ABI encoding can use arbitrary\n     *      offsets. Checking that the offsets were produced by default encoding\n     *      will ensure that other functions using Solidity's calldata accessors\n     *      (which calculate pointers from the stored offsets) are reading the\n     *      same data as the order hash is derived from. Also note that This\n     *      function accesses memory directly. It does not clear the expanded\n     *      memory regions used, nor does it update the free memory pointer, so\n     *      other direct memory access must not assume that unused memory is\n     *      empty.\n     *\n     * @param parameters                   The parameters of the basic order.\n     * @param orderType                    The order type.\n     * @param receivedItemType             The item type of the initial\n     *                                     consideration item on the order.\n     * @param additionalRecipientsItemType The item type of any additional\n     *                                     consideration item on the order.\n     * @param additionalRecipientsToken    The ERC20 token contract address (if\n     *                                     applicable) for any additional\n     *                                     consideration item on the order.\n     * @param offeredItemType              The item type of the offered item on\n     *                                     the order.\n     */\n    function _prepareBasicFulfillmentFromCalldata(\n        BasicOrderParameters calldata parameters,\n        OrderType orderType,\n        ItemType receivedItemType,\n        ItemType additionalRecipientsItemType,\n        address additionalRecipientsToken,\n        ItemType offeredItemType\n    ) internal {\n        // Ensure this function cannot be triggered during a reentrant call.\n        _setReentrancyGuard();\n\n        // Ensure current timestamp falls between order start time and end time.\n        _verifyTime(parameters.startTime, parameters.endTime, true);\n\n        // Verify that calldata offsets for all dynamic types were produced by\n        // default encoding. This ensures that the constants we use for calldata\n        // pointers to dynamic types are the same as those calculated by\n        // Solidity using their offsets.\n        _assertValidBasicOrderParameterOffsets();\n\n        // Ensure supplied consideration array length is not less than original.\n        _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength(\n            parameters.additionalRecipients.length + 1,\n            parameters.totalOriginalAdditionalRecipients\n        );\n\n        // Declare stack element for the order hash.\n        bytes32 orderHash;\n\n        {\n            /**\n             * First, handle consideration items. Memory Layout:\n             *  0x60: final hash of the array of consideration item hashes\n             *  0x80-0x160: reused space for EIP712 hashing of each item\n             *   - 0x80: ConsiderationItem EIP-712 typehash (constant)\n             *   - 0xa0: itemType\n             *   - 0xc0: token\n             *   - 0xe0: identifier\n             *   - 0x100: startAmount\n             *   - 0x120: endAmount\n             *   - 0x140: recipient\n             *  0x160-END_ARR: array of consideration item hashes\n             *   - 0x160: primary consideration item EIP712 hash\n             *   - 0x180-END_ARR: additional recipient item EIP712 hashes\n             *  END_ARR: beginning of data for OrderFulfilled event\n             *   - END_ARR + 0x120: length of ReceivedItem array\n             *   - END_ARR + 0x140: beginning of data for first ReceivedItem\n             * (Note: END_ARR = 0x180 + RECIPIENTS_LENGTH * 0x20)\n             */\n\n            // Load consideration item typehash from runtime and place on stack.\n            bytes32 typeHash = _CONSIDERATION_ITEM_TYPEHASH;\n\n            // Utilize assembly to enable reuse of memory regions and use\n            // constant pointers when possible.\n            assembly {\n                /*\n                 * 1. Calculate the EIP712 ConsiderationItem hash for the\n                 * primary consideration item of the basic order.\n                 */\n\n                // Write ConsiderationItem type hash and item type to memory.\n                mstore(BasicOrder_considerationItem_typeHash_ptr, typeHash)\n                mstore(\n                    BasicOrder_considerationItem_itemType_ptr,\n                    receivedItemType\n                )\n\n                // Copy calldata region with (token, identifier, amount) from\n                // BasicOrderParameters to ConsiderationItem. The\n                // considerationAmount is written to startAmount and endAmount\n                // as basic orders do not have dynamic amounts.\n                calldatacopy(\n                    BasicOrder_considerationItem_token_ptr,\n                    BasicOrder_considerationToken_cdPtr,\n                    ThreeWords\n                )\n\n                // Copy calldata region with considerationAmount and offerer\n                // from BasicOrderParameters to endAmount and recipient in\n                // ConsiderationItem.\n                calldatacopy(\n                    BasicOrder_considerationItem_endAmount_ptr,\n                    BasicOrder_considerationAmount_cdPtr,\n                    TwoWords\n                )\n\n                // Calculate EIP712 ConsiderationItem hash and store it in the\n                // array of EIP712 consideration hashes.\n                mstore(\n                    BasicOrder_considerationHashesArray_ptr,\n                    keccak256(\n                        BasicOrder_considerationItem_typeHash_ptr,\n                        EIP712_ConsiderationItem_size\n                    )\n                )\n\n                /*\n                 * 2. Write a ReceivedItem struct for the primary consideration\n                 * item to the consideration array in OrderFulfilled.\n                 */\n\n                // Get the length of the additional recipients array.\n                let totalAdditionalRecipients := calldataload(\n                    BasicOrder_additionalRecipients_length_cdPtr\n                )\n\n                // Calculate pointer to length of OrderFulfilled consideration\n                // array.\n                let eventConsiderationArrPtr := add(\n                    OrderFulfilled_consideration_length_baseOffset,\n                    mul(totalAdditionalRecipients, OneWord)\n                )\n\n                // Set the length of the consideration array to the number of\n                // additional recipients, plus one for the primary consideration\n                // item.\n                mstore(\n                    eventConsiderationArrPtr,\n                    add(\n                        calldataload(\n                            BasicOrder_additionalRecipients_length_cdPtr\n                        ),\n                        1\n                    )\n                )\n\n                // Overwrite the consideration array pointer so it points to the\n                // body of the first element\n                eventConsiderationArrPtr := add(\n                    eventConsiderationArrPtr,\n                    OneWord\n                )\n\n                // Set itemType at start of the ReceivedItem memory region.\n                mstore(eventConsiderationArrPtr, receivedItemType)\n\n                // Copy calldata region (token, identifier, amount & recipient)\n                // from BasicOrderParameters to ReceivedItem memory.\n                calldatacopy(\n                    add(eventConsiderationArrPtr, Common_token_offset),\n                    BasicOrder_considerationToken_cdPtr,\n                    FourWords\n                )\n\n                /*\n                 * 3. Calculate EIP712 ConsiderationItem hashes for original\n                 * additional recipients and add a ReceivedItem for each to the\n                 * consideration array in the OrderFulfilled event. The original\n                 * additional recipients are all the considerations signed by\n                 * the offerer aside from the primary consideration of the\n                 * order. Uses memory region from 0x80-0x160 as a buffer for\n                 * calculating EIP712 ConsiderationItem hashes.\n                 */\n\n                // Put pointer to consideration hashes array on the stack.\n                // This will be updated as each additional recipient is hashed\n                let\n                    considerationHashesPtr\n                := BasicOrder_considerationHashesArray_ptr\n\n                // Write item type, token, & identifier for additional recipient\n                // to memory region for hashing EIP712 ConsiderationItem; these\n                // values will be reused for each recipient.\n                mstore(\n                    BasicOrder_considerationItem_itemType_ptr,\n                    additionalRecipientsItemType\n                )\n                mstore(\n                    BasicOrder_considerationItem_token_ptr,\n                    additionalRecipientsToken\n                )\n                mstore(BasicOrder_considerationItem_identifier_ptr, 0)\n\n                // Read length of the additionalRecipients array from calldata\n                // and iterate.\n                totalAdditionalRecipients := calldataload(\n                    BasicOrder_totalOriginalAdditionalRecipients_cdPtr\n                )\n                let i := 0\n                // prettier-ignore\n                for {} lt(i, totalAdditionalRecipients) {\n                    i := add(i, 1)\n                } {\n                    /*\n                     * Calculate EIP712 ConsiderationItem hash for recipient.\n                     */\n\n                    // Retrieve calldata pointer for additional recipient.\n                    let additionalRecipientCdPtr := add(\n                        BasicOrder_additionalRecipients_data_cdPtr,\n                        mul(AdditionalRecipients_size, i)\n                    )\n\n                    // Copy startAmount from calldata to the ConsiderationItem\n                    // struct.\n                    calldatacopy(\n                        BasicOrder_considerationItem_startAmount_ptr,\n                        additionalRecipientCdPtr,\n                        OneWord\n                    )\n\n                    // Copy endAmount and recipient from calldata to the\n                    // ConsiderationItem struct.\n                    calldatacopy(\n                        BasicOrder_considerationItem_endAmount_ptr,\n                        additionalRecipientCdPtr,\n                        AdditionalRecipients_size\n                    )\n\n                    // Add 1 word to the pointer as part of each loop to reduce\n                    // operations needed to get local offset into the array.\n                    considerationHashesPtr := add(\n                        considerationHashesPtr,\n                        OneWord\n                    )\n\n                    // Calculate EIP712 ConsiderationItem hash and store it in\n                    // the array of consideration hashes.\n                    mstore(\n                        considerationHashesPtr,\n                        keccak256(\n                            BasicOrder_considerationItem_typeHash_ptr,\n                            EIP712_ConsiderationItem_size\n                        )\n                    )\n\n                    /*\n                     * Write ReceivedItem to OrderFulfilled data.\n                     */\n\n                    // At this point, eventConsiderationArrPtr points to the\n                    // beginning of the ReceivedItem struct of the previous\n                    // element in the array. Increase it by the size of the\n                    // struct to arrive at the pointer for the current element.\n                    eventConsiderationArrPtr := add(\n                        eventConsiderationArrPtr,\n                        ReceivedItem_size\n                    )\n\n                    // Write itemType to the ReceivedItem struct.\n                    mstore(\n                        eventConsiderationArrPtr,\n                        additionalRecipientsItemType\n                    )\n\n                    // Write token to the next word of the ReceivedItem struct.\n                    mstore(\n                        add(eventConsiderationArrPtr, OneWord),\n                        additionalRecipientsToken\n                    )\n\n                    // Copy endAmount & recipient words to ReceivedItem struct.\n                    calldatacopy(\n                        add(\n                            eventConsiderationArrPtr,\n                            ReceivedItem_amount_offset\n                        ),\n                        additionalRecipientCdPtr,\n                        TwoWords\n                    )\n                }\n\n                /*\n                 * 4. Hash packed array of ConsiderationItem EIP712 hashes:\n                 *   `keccak256(abi.encodePacked(receivedItemHashes))`\n                 * Note that it is set at 0x60 â€” all other memory begins at\n                 * 0x80. 0x60 is the \"zero slot\" and will be restored at the end\n                 * of the assembly section and before required by the compiler.\n                 */\n                mstore(\n                    receivedItemsHash_ptr,\n                    keccak256(\n                        BasicOrder_considerationHashesArray_ptr,\n                        mul(add(totalAdditionalRecipients, 1), OneWord)\n                    )\n                )\n\n                /*\n                 * 5. Add a ReceivedItem for each tip to the consideration array\n                 * in the OrderFulfilled event. The tips are all the\n                 * consideration items that were not signed by the offerer and\n                 * were provided by the fulfiller.\n                 */\n\n                // Overwrite length to length of the additionalRecipients array.\n                totalAdditionalRecipients := calldataload(\n                    BasicOrder_additionalRecipients_length_cdPtr\n                )\n                // prettier-ignore\n                for {} lt(i, totalAdditionalRecipients) {\n                    i := add(i, 1)\n                } {\n                    // Retrieve calldata pointer for additional recipient.\n                    let additionalRecipientCdPtr := add(\n                        BasicOrder_additionalRecipients_data_cdPtr,\n                        mul(AdditionalRecipients_size, i)\n                    )\n\n                    // At this point, eventConsiderationArrPtr points to the\n                    // beginning of the ReceivedItem struct of the previous\n                    // element in the array. Increase it by the size of the\n                    // struct to arrive at the pointer for the current element.\n                    eventConsiderationArrPtr := add(\n                        eventConsiderationArrPtr,\n                        ReceivedItem_size\n                    )\n\n                    // Write itemType to the ReceivedItem struct.\n                    mstore(\n                        eventConsiderationArrPtr,\n                        additionalRecipientsItemType\n                    )\n\n                    // Write token to the next word of the ReceivedItem struct.\n                    mstore(\n                        add(eventConsiderationArrPtr, OneWord),\n                        additionalRecipientsToken\n                    )\n\n                    // Copy endAmount & recipient words to ReceivedItem struct.\n                    calldatacopy(\n                        add(\n                            eventConsiderationArrPtr,\n                            ReceivedItem_amount_offset\n                        ),\n                        additionalRecipientCdPtr,\n                        TwoWords\n                    )\n                }\n            }\n        }\n\n        {\n            /**\n             * Next, handle offered items. Memory Layout:\n             *  EIP712 data for OfferItem\n             *   - 0x80:  OfferItem EIP-712 typehash (constant)\n             *   - 0xa0:  itemType\n             *   - 0xc0:  token\n             *   - 0xe0:  identifier (reused for offeredItemsHash)\n             *   - 0x100: startAmount\n             *   - 0x120: endAmount\n             */\n\n            // Place offer item typehash on the stack.\n            bytes32 typeHash = _OFFER_ITEM_TYPEHASH;\n\n            // Utilize assembly to enable reuse of memory regions when possible.\n            assembly {\n                /*\n                 * 1. Calculate OfferItem EIP712 hash\n                 */\n\n                // Write the OfferItem typeHash to memory.\n                mstore(BasicOrder_offerItem_typeHash_ptr, typeHash)\n\n                // Write the OfferItem item type to memory.\n                mstore(BasicOrder_offerItem_itemType_ptr, offeredItemType)\n\n                // Copy calldata region with (offerToken, offerIdentifier,\n                // offerAmount) from OrderParameters to (token, identifier,\n                // startAmount) in OfferItem struct. The offerAmount is written\n                // to startAmount and endAmount as basic orders do not have\n                // dynamic amounts.\n                calldatacopy(\n                    BasicOrder_offerItem_token_ptr,\n                    BasicOrder_offerToken_cdPtr,\n                    ThreeWords\n                )\n\n                // Copy offerAmount from calldata to endAmount in OfferItem\n                // struct.\n                calldatacopy(\n                    BasicOrder_offerItem_endAmount_ptr,\n                    BasicOrder_offerAmount_cdPtr,\n                    OneWord\n                )\n\n                // Compute EIP712 OfferItem hash, write result to scratch space:\n                //   `keccak256(abi.encode(offeredItem))`\n                mstore(\n                    0,\n                    keccak256(\n                        BasicOrder_offerItem_typeHash_ptr,\n                        EIP712_OfferItem_size\n                    )\n                )\n\n                /*\n                 * 2. Calculate hash of array of EIP712 hashes and write the\n                 * result to the corresponding OfferItem struct:\n                 *   `keccak256(abi.encodePacked(offerItemHashes))`\n                 */\n                mstore(BasicOrder_order_offerHashes_ptr, keccak256(0, OneWord))\n\n                /*\n                 * 3. Write SpentItem to offer array in OrderFulfilled event.\n                 */\n                let eventConsiderationArrPtr := add(\n                    OrderFulfilled_offer_length_baseOffset,\n                    mul(\n                        calldataload(\n                            BasicOrder_additionalRecipients_length_cdPtr\n                        ),\n                        OneWord\n                    )\n                )\n\n                // Set a length of 1 for the offer array.\n                mstore(eventConsiderationArrPtr, 1)\n\n                // Write itemType to the SpentItem struct.\n                mstore(add(eventConsiderationArrPtr, OneWord), offeredItemType)\n\n                // Copy calldata region with (offerToken, offerIdentifier,\n                // offerAmount) from OrderParameters to (token, identifier,\n                // amount) in SpentItem struct.\n                calldatacopy(\n                    add(eventConsiderationArrPtr, AdditionalRecipients_size),\n                    BasicOrder_offerToken_cdPtr,\n                    ThreeWords\n                )\n            }\n        }\n\n        {\n            /**\n             * Once consideration items and offer items have been handled,\n             * derive the final order hash. Memory Layout:\n             *  0x80-0x1c0: EIP712 data for order\n             *   - 0x80:   Order EIP-712 typehash (constant)\n             *   - 0xa0:   orderParameters.offerer\n             *   - 0xc0:   orderParameters.zone\n             *   - 0xe0:   keccak256(abi.encodePacked(offerHashes))\n             *   - 0x100:  keccak256(abi.encodePacked(considerationHashes))\n             *   - 0x120:  orderParameters.basicOrderType (% 4 = orderType)\n             *   - 0x140:  orderParameters.startTime\n             *   - 0x160:  orderParameters.endTime\n             *   - 0x180:  orderParameters.zoneHash\n             *   - 0x1a0:  orderParameters.salt\n             *   - 0x1c0:  orderParameters.co"
    }
  ]
}