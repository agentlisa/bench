{
  "Title": "Maximum value in function `approve()`",
  "Content": "##### Description\nSetting a maximum value for the amount of tokens that can be manipulated after calling the `approve()` function could cause an attacker to invoke his transaction for his profit.\nSuch calls are now in the following places:\n https://github.com/Grandthrax/yearnV2-generic-lender-strat/blob/979ef2f0e5da39ca59a5907c37ba2064fcd6be82/contracts/GenericLender/GenericCream.sol#L39\n https://github.com/Grandthrax/yearnV2-generic-lender-strat/blob/979ef2f0e5da39ca59a5907c37ba2064fcd6be82/contracts/GenericLender/GenericLenderBase.sol#L45\n https://github.com/Grandthrax/yearnV2-generic-lender-strat/blob/979ef2f0e5da39ca59a5907c37ba2064fcd6be82/contracts/GenericLender/GenericCompound.sol#L46\n https://github.com/Grandthrax/yearnV2-generic-lender-strat/blob/979ef2f0e5da39ca59a5907c37ba2064fcd6be82/contracts/GenericLender/GenericDyDx.sol#L34\n\n##### Recommendation\nWhen calling the `approve()` function, set the actual value for the amount of tokens. \n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/GenericLender/GenericCream.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../Interfaces/Compound/CErc20I.sol\";\nimport \"../Interfaces/Compound/InterestRateModel.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./GenericLenderBase.sol\";\n\n/********************\n *   A lender plugin for LenderYieldOptimiser for any erc20 asset on Cream (not eth)\n *   Made by SamPriestley.com\n *   https://github.com/Grandthrax/yearnv2/blob/master/contracts/GenericLender/GenericCream.sol\n *\n ********************* */\n\ncontract GenericCream is GenericLenderBase {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    uint256 private constant blocksPerYear = 2_300_000;\n\n    CErc20I public cToken;\n\n    constructor(\n        address _strategy,\n        string memory name,\n        address _cToken\n    ) public GenericLenderBase(_strategy, name) {\n        cToken = CErc20I(_cToken);\n\n        require(cToken.underlying() == address(want), \"WRONG CTOKEN\");\n\n        want.approve(_cToken, uint256(-1));\n    }\n\n    function nav() external view override returns (uint256) {\n        return _nav();\n    }\n\n    function _nav() internal view returns (uint256) {\n        return want.balanceOf(address(this)).add(underlyingBalanceStored());\n    }\n\n    function underlyingBalanceStored() public view returns (uint256 balance) {\n        uint256 currentCr = cToken.balanceOf(address(this));\n        if (currentCr == 0) {\n            balance = 0;\n        } else {\n            balance = currentCr.mul(cToken.exchangeRateStored()).div(1e18);\n        }\n    }\n\n    function apr() external view override returns (uint256) {\n        return _apr();\n    }\n\n    function _apr() internal view returns (uint256) {\n        return cToken.supplyRatePerBlock().mul(blocksPerYear);\n    }\n\n    function weightedApr() external view override returns (uint256) {\n        uint256 a = _apr();\n        return a.mul(_nav());\n    }\n\n    function withdraw(uint256 amount) external override management returns (uint256) {\n        return _withdraw(amount);\n    }\n\n    //emergency withdraw. sends balance plus amount to governance\n    function emergencyWithdraw(uint256 amount) external override management {\n        cToken.redeemUnderlying(amount);\n\n        want.safeTransfer(vault.governance(), want.balanceOf(address(this)));\n    }\n\n    //withdraw an amount including any want balance\n    function _withdraw(uint256 amount) internal returns (uint256) {\n        uint256 balanceUnderlying = cToken.balanceOfUnderlying(address(this));\n        uint256 looseBalance = want.balanceOf(address(this));\n        uint256 total = balanceUnderlying.add(looseBalance);\n\n        if (amount > total) {\n            //cant withdraw more than we own\n            amount = total;\n        }\n        if (looseBalance >= amount) {\n            want.safeTransfer(address(strategy), amount);\n            return amount;\n        }\n\n        //not state changing but OK because of previous call\n        uint256 liquidity = want.balanceOf(address(cToken));\n\n        if (liquidity > 1) {\n            uint256 toWithdraw = amount.sub(looseBalance);\n\n            if (toWithdraw <= liquidity) {\n                //we can take all\n                cToken.redeemUnderlying(toWithdraw);\n            } else {\n                //take all we can\n                cToken.redeemUnderlying(liquidity);\n            }\n        }\n        looseBalance = want.balanceOf(address(this));\n        want.safeTransfer(address(strategy), looseBalance);\n        return looseBalance;\n    }\n\n    function deposit() external override management {\n        uint256 balance = want.balanceOf(address(this));\n        cToken.mint(balance);\n    }\n\n    function withdrawAll() external override management returns (bool) {\n        uint256 invested = _nav();\n        uint256 returned = _withdraw(invested);\n        return returned >= invested;\n    }\n\n    //think about this\n    function enabled() external view override returns (bool) {\n        return true;\n    }\n\n    function hasAssets() external view override returns (bool) {\n        return cToken.balanceOf(address(this)) > 0;\n    }\n\n    function aprAfterDeposit(uint256 amount) external view override returns (uint256) {\n        uint256 cashPrior = want.balanceOf(address(cToken));\n\n        uint256 borrows = cToken.totalBorrows();\n        uint256 reserves = cToken.totalReserves();\n\n        uint256 reserverFactor = cToken.reserveFactorMantissa();\n        InterestRateModel model = cToken.interestRateModel();\n\n        //the supply rate is derived from the borrow rate, reserve factor and the amount of total borrows.\n        uint256 supplyRate = model.getSupplyRate(cashPrior.add(amount), borrows, reserves, reserverFactor);\n\n        return supplyRate.mul(blocksPerYear);\n    }\n\n    function protectedTokens() internal view override returns (address[] memory) {\n        address[] memory protected = new address[](2);\n        protected[0] = address(want);\n        protected[1] = address(cToken);\n        return protected;\n    }\n}"
    },
    {
      "filename": "contracts/GenericLender/GenericLenderBase.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.6.12;\n\nimport {VaultAPI} from \"@yearnvaults/contracts/BaseStrategy.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./IGenericLender.sol\";\n\ninterface IBaseStrategy {\n    function apiVersion() external pure returns (string memory);\n\n    function name() external pure returns (string memory);\n\n    function vault() external view returns (address);\n\n    function keeper() external view returns (address);\n\n    function tendTrigger(uint256 callCost) external view returns (bool);\n\n    function tend() external;\n\n    function harvestTrigger(uint256 callCost) external view returns (bool);\n\n    function harvest() external;\n\n    function strategist() external view returns (address);\n}\n\nabstract contract GenericLenderBase is IGenericLender {\n    VaultAPI public vault;\n    address public override strategy;\n    IERC20 public want;\n    string public override lenderName;\n\n    uint256 public dust;\n\n    constructor(address _strategy, string memory name) public {\n        strategy = _strategy;\n        vault = VaultAPI(IBaseStrategy(strategy).vault());\n        want = IERC20(vault.token());\n        lenderName = name;\n        dust = 10000;\n\n        want.approve(_strategy, uint256(-1));\n    }\n\n    function setDust(uint256 _dust) external virtual override management {\n        dust = _dust;\n    }\n\n    function sweep(address _token) external virtual override management {\n        address[] memory _protectedTokens = protectedTokens();\n        for (uint256 i; i < _protectedTokens.length; i++) require(_token != _protectedTokens[i], \"!protected\");\n\n        IERC20(_token).transfer(vault.governance(), IERC20(_token).balanceOf(address(this)));\n    }\n\n    function protectedTokens() internal view virtual returns (address[] memory);\n\n    //make sure to use\n    modifier management() {\n        require(\n            msg.sender == address(strategy) || msg.sender == vault.governance() || msg.sender == IBaseStrategy(strategy).strategist(),\n            \"!management\"\n        );\n        _;\n    }\n}"
    },
    {
      "filename": "contracts/GenericLender/GenericCompound.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../Interfaces/Compound/CErc20I.sol\";\nimport \"../Interfaces/Compound/InterestRateModel.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../Interfaces/UniswapInterfaces/IUniswapV2Router02.sol\";\n\nimport \"./GenericLenderBase.sol\";\n\n/********************\n *   A lender plugin for LenderYieldOptimiser for any erc20 asset on compound (not eth)\n *   Made by SamPriestley.com\n *   https://github.com/Grandthrax/yearnv2/blob/master/contracts/GenericDyDx/GenericCompound.sol\n *\n ********************* */\n\ncontract GenericCompound is GenericLenderBase {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    uint256 private constant blocksPerYear = 2_300_000;\n    address public constant uniswapRouter = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    address public constant comp = address(0xc00e94Cb662C3520282E6f5717214004A7f26888);\n    address public constant weth = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    uint256 public minCompToSell = 0.5 ether;\n\n    CErc20I public cToken;\n\n    constructor(\n        address _strategy,\n        string memory name,\n        address _cToken\n    ) public GenericLenderBase(_strategy, name) {\n        cToken = CErc20I(_cToken);\n\n        require(cToken.underlying() == address(want), \"WRONG CTOKEN\");\n\n        want.approve(_cToken, uint256(-1));\n    }\n\n    function nav() external view override returns (uint256) {\n        return _nav();\n    }\n\n    function _nav() internal view returns (uint256) {\n        return want.balanceOf(address(this)).add(underlyingBalanceStored());\n    }\n\n    function underlyingBalanceStored() public view returns (uint256 balance) {\n        uint256 currentCr = cToken.balanceOf(address(this));\n        if (currentCr == 0) {\n            balance = 0;\n        } else {\n            balance = currentCr.mul(cToken.exchangeRateStored()).div(1e18);\n        }\n    }\n\n    function apr() external view override returns (uint256) {\n        return _apr();\n    }\n\n    function _apr() internal view returns (uint256) {\n        return cToken.supplyRatePerBlock().mul(blocksPerYear);\n    }\n\n    function weightedApr() external view override returns (uint256) {\n        uint256 a = _apr();\n        return a.mul(_nav());\n    }\n\n    function withdraw(uint256 amount) external override management returns (uint256) {\n        return _withdraw(amount);\n    }\n\n    //emergency withdraw. sends balance plus amount to governance\n    function emergencyWithdraw(uint256 amount) external override management {\n        cToken.redeemUnderlying(amount);\n\n        want.safeTransfer(vault.governance(), want.balanceOf(address(this)));\n    }\n\n    //withdraw an amount including any want balance\n    function _withdraw(uint256 amount) internal returns (uint256) {\n        uint256 balanceUnderlying = cToken.balanceOfUnderlying(address(this));\n        uint256 looseBalance = want.balanceOf(address(this));\n        uint256 total = balanceUnderlying.add(looseBalance);\n\n        if (amount > total) {\n            //cant withdraw more than we own\n            amount = total;\n        }\n        if (looseBalance >= amount) {\n            want.safeTransfer(address(strategy), amount);\n            return amount;\n        }\n\n        //not state changing but OK because of previous call\n        uint256 liquidity = want.balanceOf(address(cToken));\n\n        if (liquidity > 1) {\n            uint256 toWithdraw = amount.sub(looseBalance);\n\n            if (toWithdraw <= liquidity) {\n                //we can take all\n                cToken.redeemUnderlying(toWithdraw);\n            } else {\n                //take all we can\n                cToken.redeemUnderlying(liquidity);\n            }\n        }\n        _disposeOfComp();\n        looseBalance = want.balanceOf(address(this));\n        want.safeTransfer(address(strategy), looseBalance);\n        return looseBalance;\n    }\n\n    function _disposeOfComp() internal {\n        uint256 _comp = IERC20(comp).balanceOf(address(this));\n\n        if (_comp > minCompToSell) {\n            address[] memory path = new address[](3);\n            path[0] = comp;\n            path[1] = weth;\n            path[2] = address(want);\n\n            IUniswapV2Router02(uniswapRouter).swapExactTokensForTokens(_comp, uint256(0), path, address(this), now);\n        }\n    }\n\n    function deposit() external override management {\n        uint256 balance = want.balanceOf(address(this));\n        cToken.mint(balance);\n    }\n\n    function withdrawAll() external override management returns (bool) {\n        uint256 invested = _nav();\n        uint256 returned = _withdraw(invested);\n        return returned >= invested;\n    }\n\n    //think about this\n    function enabled() external view override returns (bool) {\n        return true;\n    }\n\n    function hasAssets() external view override returns (bool) {\n        //return cToken.balanceOf(address(this)) > 0;\n        return cToken.balanceOf(address(this)) > 0 || want.balanceOf(address(this)) > 0;\n    }\n\n    function aprAfterDeposit(uint256 amount) external view override returns (uint256) {\n        uint256 cashPrior = want.balanceOf(address(cToken));\n\n        uint256 borrows = cToken.totalBorrows();\n\n        uint256 reserves = cToken.totalReserves();\n\n        uint256 reserverFactor = cToken.reserveFactorMantissa();\n\n        InterestRateModel model = cToken.interestRateModel();\n\n        //the supply rate is derived from the borrow rate, reserve factor and the amount of total borrows.\n        uint256 supplyRate = model.getSupplyRate(cashPrior.add(amount), borrows, reserves, reserverFactor);\n\n        return supplyRate.mul(blocksPerYear);\n    }\n\n    function protectedTokens() internal view override returns (address[] memory) {\n        address[] memory protected = new address[](3);\n        protected[0] = address(want);\n        protected[1] = address(cToken);\n        protected[2] = comp;\n        return protected;\n    }\n}"
    },
    {
      "filename": "contracts/GenericLender/GenericDyDx.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../Interfaces/DyDx/ISoloMargin.sol\";\nimport \"../Interfaces/DyDx/IInterestSetter.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../Interfaces/UniswapInterfaces/IUniswapV2Router02.sol\";\n\nimport \"./GenericLenderBase.sol\";\n\n/********************\n *   A lender plugin for LenderYieldOptimiser for DyDx\n *   Made by SamPriestley.com\n *   https://github.com/Grandthrax/yearnv2/blob/master/contracts/GenericLender/GenericDyDx.sol\n *\n ********************* */\n\ncontract GenericDyDx is GenericLenderBase {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    uint256 private constant secondPerYear = 31_153_900; //todo\n    address private constant SOLO = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;\n    uint256 public dydxMarketId;\n\n    constructor(address _strategy, string memory name) public GenericLenderBase(_strategy, name) {\n        want.approve(SOLO, uint256(-1));\n\n        ISoloMargin solo = ISoloMargin(SOLO);\n        uint256 numMarkets = solo.getNumMarkets();\n        address curToken;\n        for (uint256 i = 0; i < numMarkets; i++) {\n            curToken = solo.getMarketTokenAddress(i);\n\n            if (curToken == address(want)) {\n                dydxMarketId = i;\n                return;\n            }\n        }\n        revert(\"No marketId found for provided token\");\n    }\n\n    function nav() external view override returns (uint256) {\n        return _nav();\n    }\n\n    function _nav() internal view returns (uint256) {\n        uint256 underlying = underlyingBalanceStored();\n        return want.balanceOf(address(this)).add(underlying);\n    }\n\n    function underlyingBalanceStored() public view returns (uint256) {\n        (address[] memory cur, , Types.Wei[] memory balance) = ISoloMargin(SOLO).getAccountBalances(_getAccountInfo());\n\n        for (uint256 i = 0; i < cur.length; i++) {\n            if (cur[i] == address(want)) {\n                return balance[i].value;\n            }\n        }\n    }\n\n    function apr() external view override returns (uint256) {\n        return _apr(0);\n    }\n\n    function weightedApr() external view override returns (uint256) {\n        uint256 a = _apr(0);\n        return a.mul(_nav());\n    }\n\n    function withdraw(uint256 amount) external override management returns (uint256) {\n        return _withdraw(amount);\n    }\n\n    //emergency withdraw. sends balance plus amount to governance\n    function emergencyWithdraw(uint256 amount) external override management {\n        _withdraw(amount);\n        want.safeTransfer(vault.governance(), want.balanceOf(address(this)));\n    }\n\n    //withdraw an amount including any want balance\n    function _withdraw(uint256 amount) internal returns (uint256) {\n        uint256 balanceUnderlying = underlyingBalanceStored();\n        uint256 looseBalance = want.balanceOf(address(this));\n        uint256 total = balanceUnderlying.add(looseBalance);\n\n        if (amount > total) {\n            //cant withdraw more than we own\n            amount = total;\n        }\n        if (looseBalance >= amount) {\n            want.safeTransfer(address(strategy), amount);\n            return amount;\n        }\n\n        //not state changing but OK because of previous call\n        uint256 liquidity = want.balanceOf(SOLO);\n\n        if (liquidity > 1) {\n            uint256 toWithdraw = amount.sub(looseBalance);\n\n            if (toWithdraw <= liquidity) {\n                //we can take all\n                dydxWithdraw(toWithdraw);\n            } else {\n                //take all we can\n                dydxWithdraw(liquidity);\n            }\n        }\n        looseBalance = want.balanceOf(address(this));\n        want.safeTransfer(address(strategy), looseBalance);\n        return looseBalance;\n    }\n\n    function dydxDeposit(uint256 depositAmount) internal {\n        ISoloMargin solo = ISoloMargin(SOLO);\n\n        Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](1);\n\n        operations[0] = _getDepositAction(dydxMarketId, depositAmount);\n\n        Account.Info[] memory accountInfos = new Account.Info[](1);\n        accountInfos[0] = _getAccountInfo();\n\n        solo.operate(accountInfos, operations);\n    }\n\n    function dydxWithdraw(uint256 amount) internal {\n        ISoloMargin solo = ISoloMargin(SOLO);\n\n        Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](1);\n\n        operations[0] = _getWithdrawAction(dydxMarketId, amount);\n\n        Account.Info[] memory accountInfos = new Account.Info[](1);\n        accountInfos[0] = _getAccountInfo();\n\n        solo.operate(accountInfos, operations);\n    }\n\n    function deposit() external override management {\n        uint256 balance = want.balanceOf(address(this));\n        dydxDeposit(balance);\n    }\n\n    function withdrawAll() external override management returns (bool) {\n        uint256 balance = _nav();\n        uint256 returned = _withdraw(balance);\n        return returned >= balance;\n    }\n\n    //think about this\n    function enabled() external view override returns (bool) {\n        return true;\n    }\n\n    function hasAssets() external view override returns (bool) {\n        return underlyingBalanceStored() > 0;\n    }\n\n    function aprAfterDeposit(uint256 amount) external view override returns (uint256) {\n        return _apr(amount);\n    }\n\n    function _apr(uint256 extraSupply) internal view returns (uint256) {\n        ISoloMargin solo = ISoloMargin(SOLO);\n        Types.TotalPar memory par = solo.getMarketTotalPar(dydxMarketId);\n        Interest.Index memory index = solo.getMarketCurrentIndex(dydxMarketId);\n        address interestSetter = solo.getMarketInterestSetter(dydxMarketId);\n        uint256 borrow = uint256(par.borrow).mul(index.borrow).div(1e18);\n        uint256 supply = (uint256(par.supply).mul(index.supply).div(1e18)).add(extraSupply);\n\n        uint256 borrowInterestRate = IInterestSetter(interestSetter).getInterestRate(address(want), borrow, supply).value;\n        uint256 lendInterestRate = borrowInterestRate.mul(borrow).div(supply);\n        return lendInterestRate.mul(secondPerYear);\n    }\n\n    function protectedTokens() internal view override returns (address[] memory) {\n        address[] memory protected = new address[](1);\n        protected[0] = address(want);\n        return protected;\n    }\n\n    function _getWithdrawAction(uint256 marketId, uint256 amount) internal view returns (Actions.ActionArgs memory) {\n        return\n            Actions.ActionArgs({\n                actionType: Actions.ActionType.Withdraw,\n                accountId: 0,\n                amount: Types.AssetAmount({\n                    sign: false,\n                    denomination: Types.AssetDenomination.Wei,\n                    ref: Types.AssetReference.Delta,\n                    value: amount\n                }),\n                primaryMarketId: marketId,\n                secondaryMarketId: 0,\n                otherAddress: address(this),\n                otherAccountId: 0,\n                data: \"\"\n            });\n    }\n\n    function _getDepositAction(uint256 marketId, uint256 amount) internal view returns (Actions.ActionArgs memory) {\n        return\n            Actions.ActionArgs({\n                actionType: Actions.ActionType.Deposit,\n                accountId: 0,\n                amount: Types.AssetAmount({\n                    sign: true,\n                    denomination: Types.AssetDenomination.Wei,\n                    ref: Types.AssetReference.Delta,\n                    value: amount\n                }),\n                primaryMarketId: marketId,\n                secondaryMarketId: 0,\n                otherAddress: address(this),\n                otherAccountId: 0,\n                data: \"\"\n            });\n    }\n\n    function _getAccountInfo() internal view returns (Account.Info memory) {\n        return Account.Info({owner: address(this), number: 0});\n    }\n}"
    }
  ]
}