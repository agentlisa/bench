{
  "Title": "M-1: Donating (and syncing) tokens to an Aerodrome allows to bypass exposure limits",
  "Content": "# Issue M-1: Donating (and syncing) tokens to an Aerodrome allows to bypass exposure limits \n\nSource: https://github.com/sherlock-audit/2024-04-arcadia-pricing-module-judging/issues/17 \n\n## Found by \nzzykxx\n## Summary\nAn attacker can bypass the exposure limits by donating tokens to an Aerodrome pool in which he owns ~100% of the liquidity, this will inflate reserves which will increase the value of the collateral and the attacker won't lose capital because he owns ~100% of the liquidity.\n\n## Vulnerability Detail\nAttack scenario:\n1. Create a new Aerodrome pool, let's suppose an STG/WETH pool\n2. Provide liquidity to the pool and mint LPs, let's suppose we mint ~1000$ worth of liquidity\n3. Deposit the LP in an Arcadia account, the collateral is worth ~1000$\n4. Send STG and WETH directly to the Aerodrome pool, let's suppose we send ~500_000$ worth of tokens\n5. Call [sync()](https://github.com/aerodrome-finance/contracts/blob/main/contracts/Pool.sol#L397-L399) on the Aerodrome pool\n6. The pool reserves are increased and the collateral is now worth ~501_000$\n\nBy doing this an attacker can bypass exposure limits. Note that Arcadia allows the use of any volatile Aerodrome pool LPs as collateral, as long as the underlying tokens are allowed.\n\n## Impact\nAn attacker can bypass the exposure limits set by a creditor. \n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**shealtielanz** commented:\n>  dup of #018\n\n\n\n**Thomas-Smets**\n\nValid, think it is not a duplicate of 18 tho\n\n**sherlock-admin3**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/arcadia-finance/accounts-v2/pull/201\n\n\n**midori-fuse**\n\nI understand that the escalation phase is over, and I fully accept that the result cannot be changed further. However I do think this is a dupe of #18 for the following reasons.\n\nEssentially both attacks involve opening a new Aerodrome pool, and increasing the LP position's underlying worth using fees. When you donate your assets into the pool, it has the same effect as when you swap back and forth within the pool (whatever stays in the pool gets counted as fees). Therefore the two issues are a dupe because:\n- While the root causes can be considered different, the differences lie in the Aerodrome pool, not the Arcadia pricing module. What enabled this attack within the pricing module are the same: fees are always applied directly and fully without capping.\n- I can't identify a fix that would fix one problem but without fixing the other.\n  - Note that the sponsor making the same PR isn't a factor, there may still be a fix that separates these two issues that we failed to identify.\n\nAm I missing anything? Is there a difference in root cause/impact/fix that makes the two issues different?\n\nWe shall still respect the current/final judgement regardless. Even if the \"ideal\" result is different from currently, it was fully on us to not have examined the issues diligently in the 48-hour escalation period that we were given.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/321",
  "Code": [
    {
      "filename": "contracts/Pool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IPool} from \"./interfaces/IPool.sol\";\nimport {IVoter} from \"./interfaces/IVoter.sol\";\nimport {IPoolCallee} from \"./interfaces/IPoolCallee.sol\";\nimport {IPoolFactory} from \"./interfaces/factories/IPoolFactory.sol\";\nimport {PoolFees} from \"./PoolFees.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @title Pool\n/// @author velodrome.finance, @figs999, @pegahcarter\n/// @notice Protocol token pool, either stable or volatile\ncontract Pool is IPool, ERC20Permit, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    string private _name;\n    string private _symbol;\n    address private _voter;\n\n    /// @inheritdoc IPool\n    bool public stable;\n\n    uint256 internal constant MINIMUM_LIQUIDITY = 10 ** 3;\n    uint256 internal constant MINIMUM_K = 10 ** 10;\n\n    /// @inheritdoc IPool\n    address public token0;\n    /// @inheritdoc IPool\n    address public token1;\n    /// @inheritdoc IPool\n    address public poolFees;\n    /// @inheritdoc IPool\n    address public factory;\n\n    /// @inheritdoc IPool\n    uint256 public constant periodSize = 1800;\n\n    Observation[] public observations;\n\n    uint256 internal decimals0;\n    uint256 internal decimals1;\n\n    /// @inheritdoc IPool\n    uint256 public reserve0;\n    /// @inheritdoc IPool\n    uint256 public reserve1;\n    /// @inheritdoc IPool\n    uint256 public blockTimestampLast;\n\n    /// @inheritdoc IPool\n    uint256 public reserve0CumulativeLast;\n    /// @inheritdoc IPool\n    uint256 public reserve1CumulativeLast;\n\n    /// @inheritdoc IPool\n    uint256 public index0 = 0;\n    /// @inheritdoc IPool\n    uint256 public index1 = 0;\n\n    /// @inheritdoc IPool\n    mapping(address => uint256) public supplyIndex0;\n    /// @inheritdoc IPool\n    mapping(address => uint256) public supplyIndex1;\n\n    /// @inheritdoc IPool\n    mapping(address => uint256) public claimable0;\n    /// @inheritdoc IPool\n    mapping(address => uint256) public claimable1;\n\n    constructor() ERC20(\"\", \"\") ERC20Permit(\"\") {}\n\n    /// @inheritdoc IPool\n    function initialize(address _token0, address _token1, bool _stable) external {\n        if (factory != address(0)) revert FactoryAlreadySet();\n        factory = _msgSender();\n        _voter = IPoolFactory(factory).voter();\n        (token0, token1, stable) = (_token0, _token1, _stable);\n        poolFees = address(new PoolFees(_token0, _token1));\n        string memory symbol0 = ERC20(_token0).symbol();\n        string memory symbol1 = ERC20(_token1).symbol();\n        if (_stable) {\n            _name = string(abi.encodePacked(\"Stable AMM - \", symbol0, \"/\", symbol1));\n            _symbol = string(abi.encodePacked(\"sAMM-\", symbol0, \"/\", symbol1));\n        } else {\n            _name = string(abi.encodePacked(\"Volatile AMM - \", symbol0, \"/\", symbol1));\n            _symbol = string(abi.encodePacked(\"vAMM-\", symbol0, \"/\", symbol1));\n        }\n\n        decimals0 = 10 ** ERC20(_token0).decimals();\n        decimals1 = 10 ** ERC20(_token1).decimals();\n\n        observations.push(Observation(block.timestamp, 0, 0));\n    }\n\n    /// @inheritdoc IPool\n    function setName(string calldata __name) external {\n        if (msg.sender != IVoter(_voter).emergencyCouncil()) revert NotEmergencyCouncil();\n        _name = __name;\n    }\n\n    /// @inheritdoc IPool\n    function setSymbol(string calldata __symbol) external {\n        if (msg.sender != IVoter(_voter).emergencyCouncil()) revert NotEmergencyCouncil();\n        _symbol = __symbol;\n    }\n\n    /// @inheritdoc IPool\n    function observationLength() external view returns (uint256) {\n        return observations.length;\n    }\n\n    /// @inheritdoc IPool\n    function lastObservation() public view returns (Observation memory) {\n        return observations[observations.length - 1];\n    }\n\n    /// @inheritdoc IPool\n    function metadata()\n        external\n        view\n        returns (uint256 dec0, uint256 dec1, uint256 r0, uint256 r1, bool st, address t0, address t1)\n    {\n        return (decimals0, decimals1, reserve0, reserve1, stable, token0, token1);\n    }\n\n    /// @inheritdoc IPool\n    function tokens() external view returns (address, address) {\n        return (token0, token1);\n    }\n\n    /// @inheritdoc IPool\n    function getK() external nonReentrant returns (uint256) {\n        return _k(reserve0, reserve1);\n    }\n\n    /// @inheritdoc IPool\n    function claimFees() external returns (uint256 claimed0, uint256 claimed1) {\n        address sender = _msgSender();\n        _updateFor(sender);\n\n        claimed0 = claimable0[sender];\n        claimed1 = claimable1[sender];\n\n        if (claimed0 > 0 || claimed1 > 0) {\n            claimable0[sender] = 0;\n            claimable1[sender] = 0;\n\n            PoolFees(poolFees).claimFeesFor(sender, claimed0, claimed1);\n\n            emit Claim(sender, sender, claimed0, claimed1);\n        }\n    }\n\n    /// @dev Accrue fees on token0\n    function _update0(uint256 amount) internal {\n        // Only update on this pool if there is a fee\n        if (amount == 0) return;\n        IERC20(token0).safeTransfer(poolFees, amount); // transfer the fees out to PoolFees\n        uint256 _ratio = (amount * 1e18) / totalSupply(); // 1e18 adjustment is removed during claim\n        if (_ratio > 0) {\n            index0 += _ratio;\n        }\n        emit Fees(_msgSender(), amount, 0);\n    }\n\n    /// @dev Accrue fees on token1\n    function _update1(uint256 amount) internal {\n        // Only update on this pool if there is a fee\n        if (amount == 0) return;\n        IERC20(token1).safeTransfer(poolFees, amount);\n        uint256 _ratio = (amount * 1e18) / totalSupply();\n        if (_ratio > 0) {\n            index1 += _ratio;\n        }\n        emit Fees(_msgSender(), 0, amount);\n    }\n\n    /// @dev This function MUST be called on any balance changes, otherwise can be used to infinitely claim fees\n    ///      Fees are segregated from core funds, so fees can never put liquidity at risk.\n    function _updateFor(address recipient) internal {\n        uint256 _supplied = balanceOf(recipient); // get LP balance of `recipient`\n        if (_supplied > 0) {\n            uint256 _supplyIndex0 = supplyIndex0[recipient]; // get last adjusted index0 for recipient\n            uint256 _supplyIndex1 = supplyIndex1[recipient];\n            uint256 _index0 = index0; // get global index0 for accumulated fees\n            uint256 _index1 = index1;\n            supplyIndex0[recipient] = _index0; // update user current position to global position\n            supplyIndex1[recipient] = _index1;\n            uint256 _delta0 = _index0 - _supplyIndex0; // see if there is any difference that need to be accrued\n            uint256 _delta1 = _index1 - _supplyIndex1;\n            if (_delta0 > 0) {\n                uint256 _share = (_supplied * _delta0) / 1e18; // add accrued difference for each supplied token\n                claimable0[recipient] += _share;\n            }\n            if (_delta1 > 0) {\n                uint256 _share = (_supplied * _delta1) / 1e18;\n                claimable1[recipient] += _share;\n            }\n        } else {\n            supplyIndex0[recipient] = index0; // new users are set to the default global state\n            supplyIndex1[recipient] = index1;\n        }\n    }\n\n    /// @inheritdoc IPool\n    function getReserves() public view returns (uint256 _reserve0, uint256 _reserve1, uint256 _blockTimestampLast) {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    /// @dev update reserves and, on the first call per block, price accumulators\n    function _update(uint256 balance0, uint256 balance1, uint256 _reserve0, uint256 _reserve1) internal {\n        uint256 blockTimestamp = block.timestamp;\n        uint256 timeElapsed = blockTimestamp - blockTimestampLast;\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            reserve0CumulativeLast += _reserve0 * timeElapsed;\n            reserve1CumulativeLast += _reserve1 * timeElapsed;\n        }\n\n        Observation memory _point = lastObservation();\n        timeElapsed = blockTimestamp - _point.timestamp; // compare the last observation with current timestamp, if greater than 30 minutes, record a new event\n        if (timeElapsed > periodSize) {\n            observations.push(Observation(blockTimestamp, reserve0CumulativeLast, reserve1CumulativeLast));\n        }\n        reserve0 = balance0;\n        reserve1 = balance1;\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    }\n\n    /// @inheritdoc IPool\n    function currentCumulativePrices()\n        public\n        view\n        returns (uint256 reserve0Cumulative, uint256 reserve1Cumulative, uint256 blockTimestamp)\n    {\n        blockTimestamp = block.timestamp;\n        reserve0Cumulative = reserve0CumulativeLast;\n        reserve1Cumulative = reserve1CumulativeLast;\n\n        // if time has elapsed since the last update on the pool, mock the accumulated price values\n        (uint256 _reserve0, uint256 _reserve1, uint256 _blockTimestampLast) = getReserves();\n        if (_blockTimestampLast != blockTimestamp) {\n            // subtraction overflow is desired\n            uint256 timeElapsed = blockTimestamp - _blockTimestampLast;\n            reserve0Cumulative += _reserve0 * timeElapsed;\n            reserve1Cumulative += _reserve1 * timeElapsed;\n        }\n    }\n\n    /// @inheritdoc IPool\n    function quote(address tokenIn, uint256 amountIn, uint256 granularity) external view returns (uint256 amountOut) {\n        uint256[] memory _prices = sample(tokenIn, amountIn, granularity, 1);\n        uint256 priceAverageCumulative;\n        uint256 _length = _prices.length;\n        for (uint256 i = 0; i < _length; i++) {\n            priceAverageCumulative += _prices[i];\n        }\n        return priceAverageCumulative / granularity;\n    }\n\n    /// @inheritdoc IPool\n    function prices(address tokenIn, uint256 amountIn, uint256 points) external view returns (uint256[] memory) {\n        return sample(tokenIn, amountIn, points, 1);\n    }\n\n    /// @inheritdoc IPool\n    function sample(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 points,\n        uint256 window\n    ) public view returns (uint256[] memory) {\n        uint256[] memory _prices = new uint256[](points);\n\n        uint256 length = observations.length - 1;\n        uint256 i = length - (points * window);\n        uint256 nextIndex = 0;\n        uint256 index = 0;\n\n        for (; i < length; i += window) {\n            nextIndex = i + window;\n            uint256 timeElapsed = observations[nextIndex].timestamp - observations[i].timestamp;\n            uint256 _reserve0 = (observations[nextIndex].reserve0Cumulative - observations[i].reserve0Cumulative) /\n                timeElapsed;\n            uint256 _reserve1 = (observations[nextIndex].reserve1Cumulative - observations[i].reserve1Cumulative) /\n                timeElapsed;\n            _prices[index] = _getAmountOut(amountIn, tokenIn, _reserve0, _reserve1);\n            // index < length; length cannot overflow\n            unchecked {\n                index = index + 1;\n            }\n        }\n        return _prices;\n    }\n\n    /// @inheritdoc IPool\n    function mint(address to) external nonReentrant returns (uint256 liquidity) {\n        (uint256 _reserve0, uint256 _reserve1) = (reserve0, reserve1);\n        uint256 _balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 _balance1 = IERC20(token1).balanceOf(address(this));\n        uint256 _amount0 = _balance0 - _reserve0;\n        uint256 _amount1 = _balance1 - _reserve1;\n\n        uint256 _totalSupply = totalSupply(); // gas savings, must be defined here since totalSupply can update in _mintFee\n        if (_totalSupply == 0) {\n            liquidity = Math.sqrt(_amount0 * _amount1) - MINIMUM_LIQUIDITY;\n            _mint(address(1), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens - cannot be address(0)\n            if (stable) {\n                if ((_amount0 * 1e18) / decimals0 != (_amount1 * 1e18) / decimals1) revert DepositsNotEqual();\n                if (_k(_amount0, _amount1) <= MINIMUM_K) revert BelowMinimumK();\n            }\n        } else {\n            liquidity = Math.min((_amount0 * _totalSupply) / _reserve0, (_amount1 * _totalSupply) / _reserve1);\n        }\n        if (liquidity == 0) revert InsufficientLiquidityMinted();\n        _mint(to, liquidity);\n\n        _update(_balance0, _balance1, _reserve0, _reserve1);\n        emit Mint(_msgSender(), _amount0, _amount1);\n    }\n\n    /// @inheritdoc IPool\n    function burn(address to) external nonReentrant returns (uint256 amount0, uint256 amount1) {\n        (uint256 _reserve0, uint256 _reserve1) = (reserve0, reserve1);\n        (address _token0, address _token1) = (token0, token1);\n        uint256 _balance0 = IERC20(_token0).balanceOf(address(this));\n        uint256 _balance1 = IERC20(_token1).balanceOf(address(this));\n        uint256 _liquidity = balanceOf(address(this));\n\n        uint256 _totalSupply = totalSupply(); // gas savings, must be defined here since totalSupply can update in _mintFee\n        amount0 = (_liquidity * _balance0) / _totalSupply; // using balances ensures pro-rata distribution\n        amount1 = (_liquidity * _balance1) / _totalSupply; // using balances ensures pro-rata distribution\n        if (amount0 == 0 || amount1 == 0) revert InsufficientLiquidityBurned();\n        _burn(address(this), _liquidity);\n        IERC20(_token0).safeTransfer(to, amount0);\n        IERC20(_token1).safeTransfer(to, amount1);\n        _balance0 = IERC20(_token0).balanceOf(address(this));\n        _balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(_balance0, _balance1, _reserve0, _reserve1);\n        emit Burn(_msgSender(), to, amount0, amount1);\n    }\n\n    /// @inheritdoc IPool\n    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external nonReentrant {\n        if (IPoolFactory(factory).isPaused()) revert IsPaused();\n        if (amount0Out == 0 && amount1Out == 0) revert InsufficientOutputAmount();\n        (uint256 _reserve0, uint256 _reserve1) = (reserve0, reserve1);\n        if (amount0Out >= _reserve0 || amount1Out >= _reserve1) revert InsufficientLiquidity();\n\n        uint256 _balance0;\n        uint256 _balance1;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            (address _token0, address _token1) = (token0, token1);\n            if (to == _token0 || to == _token1) revert InvalidTo();\n            if (amount0Out > 0) IERC20(_token0).safeTransfer(to, amount0Out); // optimistically transfer tokens\n            if (amount1Out > 0) IERC20(_token1).safeTransfer(to, amount1Out); // optimistically transfer tokens\n            if (data.length > 0) IPoolCallee(to).hook(_msgSender(), amount0Out, amount1Out, data); // callback, used for flash loans\n            _balance0 = IERC20(_token0).balanceOf(address(this));\n            _balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint256 amount0In = _balance0 > _reserve0 - amount0Out ? _balance0 - (_reserve0 - amount0Out) : 0;\n        uint256 amount1In = _balance1 > _reserve1 - amount1Out ? _balance1 - (_reserve1 - amount1Out) : 0;\n        if (amount0In == 0 && amount1In == 0) revert InsufficientInputAmount();\n        {\n            // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n            (address _token0, address _token1) = (token0, token1);\n            if (amount0In > 0) _update0((amount0In * IPoolFactory(factory).getFee(address(this), stable)) / 10000); // accrue fees for token0 and move them out of pool\n            if (amount1In > 0) _update1((amount1In * IPoolFactory(factory).getFee(address(this), stable)) / 10000); // accrue fees for token1 and move them out of pool\n            _balance0 = IERC20(_token0).balanceOf(address(this)); // since we removed tokens, we need to reconfirm balances, can also simply use previous balance - amountIn/ 10000, but doing balanceOf again as safety check\n            _balance1 = IERC20(_token1).balanceOf(address(this));\n            // The curve, either x3y+y3x for stable pools, or x*y for volatile pools\n            if (_k(_balance0, _balance1) < _k(_reserve0, _reserve1)) revert K();\n        }\n\n        _update(_balance0, _balance1, _reserve0, _reserve1);\n        emit Swap(_msgSender(), to, amount0In, amount1In, amount0Out, amount1Out);\n    }\n\n    /// @inheritdoc IPool\n    function skim(address to) external nonReentrant {\n        (address _token0, address _token1) = (token0, token1);\n        IERC20(_token0).safeTransfer(to, IERC20(_token0).balanceOf(address(this)) - (reserve0));\n        IERC20(_token1).safeTransfer(to, IERC20(_token1).balanceOf(address(this)) - (reserve1));\n    }\n\n    /// @inheritdoc IPool\n    function sync() external nonReentrant {\n        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);\n    }\n\n    function _f(uint256 x0, uint256 y) internal pure returns (uint256) {\n        uint256 _a = (x0 * y) / 1e18;\n        uint256 _b = ((x0 * x0) / 1e18 + (y * y) / 1e18);\n        return (_a * _b) / 1e18;\n    }\n\n    function _d(uint256 x0, uint256 y) internal pure returns (uint256) {\n        return (3 * x0 * ((y * y) / 1e18)) / 1e18 + ((((x0 * x0) / 1e18) * x0) / 1e18);\n    }\n\n    function _get_y(uint256 x0, uint256 xy, uint256 y) internal view returns (uint256) {\n        for (uint256 i = 0; i < 255; i++) {\n            uint256 k = _f(x0, y);\n            if (k < xy) {\n                // there are two cases where dy == 0\n                // case 1: The y is converged and we find the correct answer\n                // case 2: _d(x0, y) is too large compare to (xy - k) and the rounding error\n                //         screwed us.\n                //         In this case, we need to increase y by 1\n                uint256 dy = ((xy - k) * 1e18) / _d(x0, y);\n                if (dy == 0) {\n                    if (k == xy) {\n                        // We found the correct answer. Return y\n                        return y;\n                    }\n                    if (_k(x0, y + 1) > xy) {\n                        // If _k(x0, y + 1) > xy, then we are close to the correct answer.\n                        // There's no closer answer than y + 1\n                        return y + 1;\n                    }\n                    dy = 1;\n                }\n                y = y + dy;\n            } else {\n                uint256 dy = ((k - xy) * 1e18) / _d(x0, y);\n                if (dy == 0) {\n                    if (k == xy || _f(x0, y - 1) < xy) {\n                        // Likewise, if k == xy, we found the correct answer.\n                        // If _f(x0, y - 1) < xy, then we are close to the correct answer.\n                        // There's no closer answer than \"y\"\n                        // It's worth mentioning that we need to find y where f(x0, y) >= xy\n                        // As a result, we can't return y - 1 even it's closer to the correct answer\n                        return y;\n                    }\n                    dy = 1;\n                }\n                y = y - dy;\n            }\n        }\n        revert(\"!y\");\n    }\n\n    /// @inheritdoc IPool\n    function getAmountOut(uint256 amountIn, address tokenIn) external view returns (uint256) {\n        (uint256 _reserve0, uint256 _reserve1) = (reserve0, reserve1);\n        amountIn -= (amountIn * IPoolFactory(factory).getFee(address(this), stable)) / 10000; // remove fee from amount received\n        return _getAmountOut(amountIn, tokenIn, _reserve0, _reserve1);\n    }\n\n    function _getAmountOut(\n        uint256 amountIn,\n        address tokenIn,\n        uint256 _reserve0,\n        uint256 _reserve1\n    ) internal view returns (uint256) {\n        if (stable) {\n            uint256 xy = _k(_reserve0, _reserve1);\n            _reserve0 = (_reserve0 * 1e18) / decimals0;\n            _reserve1 = (_reserve1 * 1e18) / decimals1;\n            (uint256 reserveA, uint256 reserveB) = tokenIn == token0 ? (_reserve0, _reserve1) : (_reserve1, _reserve0);\n            amountIn = tokenIn == token0 ? (amountIn * 1e18) / decimals0 : (amountIn * 1e18) / decimals1;\n            uint256 y = reserveB - _get_y(amountIn + reserveA, xy, reserveB);\n            return (y * (tokenIn == token0 ? decimals1 : decimals0)) / 1e18;\n        } else {\n            (uint256 reserveA, uint256 reserveB) = tokenIn == token0 ? (_reserve0, _reserve1) : (_reserve1, _reserve0);\n            return (amountIn * reserveB) / (reserveA + amountIn);\n        }\n    }\n\n    function _k(uint256 x, uint256 y) internal view returns (uint256) {\n        if (stable) {\n            uint256 _x = (x * 1e18) / decimals0;\n            uint256 _y = (y * 1e18) / decimals1;\n            uint256 _a = (_x * _y) / 1e18;\n            uint256 _b = ((_x * _x) / 1e18 + (_y * _y) / 1e18);\n            return (_a * _b) / 1e18; // x3y+y3x >= k\n        } else {\n            return x * y; // xy >= k\n        }\n    }\n\n    /*\n    @dev OZ inheritance overrides\n    These are needed as _name and _symbol are set privately before\n    logic is executed within the constructor to set _name and _symbol.\n    */\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view override returns (string memory) {\n        return _symbol;\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256) internal override {\n        _updateFor(from);\n        _updateFor(to);\n    }\n}"
    }
  ]
}