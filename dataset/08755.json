{
  "Title": "[H-02] Loss of funds in `matchOneToManyOrders()` and `takeOrders()` and `matchOrders()` because code don't check that different ids in one collection are different, so it's possible to sell one id multiple time instead of selling multiple id one time in one collection of order (lack of checks in `doTokenIdsIntersect()` especially for ERC1155 tokens)",
  "Content": "_Submitted by unforgiven_\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L271-L312>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L59-L116>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L245-L294>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L118-L143>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L330-L364>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L934-L951>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L145-L164>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L171-L243>\n\n### Impact\n\nFunction `matchOneToManyOrders()` and `takeOrders()` and `matchOrders()` suppose to match `sell order` to `buy order` and should perform some checks to ensure that user specified parameters in orders which are signed are not violated when order matching happens. but There is no check in their execution flow to check that an `order` has different `NFT token ids` in each one of it's collections, so even so number of tokens could be valid in `order` to `order` transfer but the number of real transferred tokens and their IDs can be different than what user specified and signed. and user funds would be lost. (because of `ERC1155` there can be more than one token for a `tokenId`, so it would be possible to transfer it)\n\n### Proof of Concept\n\nThis is `_takeOrders()` and `and` code:\n\n      /**\n       * @notice Internal helper function to take orders\n       * @dev verifies whether order can be executed\n       * @param makerOrder the maker order\n       * @param takerItems nfts to be transferred\n       * @param execPrice execution price\n       */\n      function _takeOrders(\n        OrderTypes.MakerOrder calldata makerOrder,\n        OrderTypes.OrderItem[] calldata takerItems,\n        uint256 execPrice\n      ) internal {\n        bytes32 makerOrderHash = _hash(makerOrder);\n        bool makerOrderValid = isOrderValid(makerOrder, makerOrderHash);\n        bool executionValid = IComplication(makerOrder.execParams[0]).canExecTakeOrder(makerOrder, takerItems);\n        require(makerOrderValid && executionValid, 'order not verified');\n        _execTakeOrders(makerOrderHash, makerOrder, takerItems, makerOrder.isSellOrder, execPrice);\n      }\n\nAs you can see it uses `canExecTakeOrder()` to check that it is valid to perform matching. This is `canExecTakeOrder()` and `areTakerNumItemsValid()` and `doTokenIdsIntersect()` code which are used in execution flow to check orders and matching validity:\n\n      /**\n       * @notice Checks whether take orders with a higher order intent can be executed\n       * @dev This function is called by the main exchange to check whether take orders with a higher order intent can be executed.\n              It checks whether orders have the right constraints - i.e they have the right number of items, whether time is still valid\n              and whether the nfts intersect\n       * @param makerOrder the maker order\n       * @param takerItems the taker items specified by the taker\n       * @return returns whether order can be executed\n       */\n      function canExecTakeOrder(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)\n        external\n        view\n        override\n        returns (bool)\n      {\n        return (makerOrder.constraints[3] <= block.timestamp &&\n          makerOrder.constraints[4] >= block.timestamp &&\n          areTakerNumItemsValid(makerOrder, takerItems) &&\n          doItemsIntersect(makerOrder.nfts, takerItems));\n      }\n\n      /// @dev sanity check to make sure that a taker is specifying the right number of items\n      function areTakerNumItemsValid(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)\n        public\n        pure\n        returns (bool)\n      {\n        uint256 numTakerItems = 0;\n        uint256 nftsLength = takerItems.length;\n        for (uint256 i = 0; i < nftsLength; ) {\n          unchecked {\n            numTakerItems += takerItems[i].tokens.length;\n            ++i;\n          }\n        }\n        return makerOrder.constraints[0] == numTakerItems;\n      }\n\n      /**\n       * @notice Checks whether tokenIds intersect\n       * @dev This function checks whether there are intersecting tokenIds between two order items\n       * @param item1 first item\n       * @param item2 second item\n       * @return returns whether tokenIds intersect\n       */\n      function doTokenIdsIntersect(OrderTypes.OrderItem calldata item1, OrderTypes.OrderItem calldata item2)\n        public\n        pure\n        returns (bool)\n      {\n        uint256 item1TokensLength = item1.tokens.length;\n        uint256 item2TokensLength = item2.tokens.length;\n        // case where maker/taker didn't specify any tokenIds for this collection\n        if (item1TokensLength == 0 || item2TokensLength == 0) {\n          return true;\n        }\n        uint256 numTokenIdsPerCollMatched = 0;\n        for (uint256 k = 0; k < item2TokensLength; ) {\n          for (uint256 l = 0; l < item1TokensLength; ) {\n            if (\n              item1.tokens[l].tokenId == item2.tokens[k].tokenId && item1.tokens[l].numTokens == item2.tokens[k].numTokens\n            ) {\n              // increment numTokenIdsPerCollMatched\n              unchecked {\n                ++numTokenIdsPerCollMatched;\n              }\n              // short circuit\n              break;\n            }\n            unchecked {\n              ++l;\n            }\n          }\n          unchecked {\n            ++k;\n          }\n        }\n\n        return numTokenIdsPerCollMatched == item2TokensLength;\n      }\n\nAs you can see there is no logic to check that `token IDs` in one collection of order are different and code only checks that total number of tokens in one `order` matches the number of tokens specified and the ids in one order exists in other list defined. function `doTokenIdsIntersect()` checks to see that `tokens ids` in one collection can match list of specified tokens. because of this check lacking there are some scenarios that can cause fund lose for `ERC1155` tokens (normal `ERC721` requires more strange conditions). here is first example:\n\n1.  For simplicity, let's assume collection and timestamp are valid and match for orders and token is `ERC1155`\n2.  `user1` has signed this order: A:`(user1 BUY 3 NFT IDs[(1,1),(2,1),(3,1)] at 15 ETH)` (buy `1` token of each `id=1,2,3`)\n3.  `NFT ID[1]` fair price is `1 ETH`, `NFT ID[2]` fair price is `2 ETH`, `NFT ID[3]` fair price is `12 ETH`\n4.  `attacker` who has 3 of `NFT ID[1]` create this list: B:`(NFT IDs[(1,1), (1,1), (1,1)] )` (list to trade `1`token of `id=1` for 3 times)\n5.  Attacker call `takeOrders()` with this parameters: makerOrder: A , takerNfts: B\n6.  Contract logic would check all the conditions and validate and verify orders and their matching (they intersect and total number of token to sell is equal to total number of tokens to buy and all of the B list is inside A list) and perform the transaction.\n7.  `attacker` would receive `15 ETH` for his 3 token of `NFT ID[1]` and steal `user1` funds. `user1` would receive 3 of `NFT ID[1]` and pays `15 ETH` and even so his order A has been executed he doesn't receive `NFT IDs[(2,1),(3,1)]` and contract would violates his signed parameters.\n\nThis examples shows that in verifying one to many order code should verify that one order's one  collection's token ids are not duplicates. (the function `doTokenIdsIntersect()` doesn't check for this).\n\nThis scenario is performable to `matchOneToManyOrders()` and `matchOrders()` and but exists in their code (related check logics) too. more important things about this scenario is that it doesn't require off-chain maching engine to make mistake or malicious act, anyone can call `takeOrders()` if NFT tokens are `ERC1155`. for other `NFT` tokens to perform this attack it requires that `seller==buyer` or some other strange cases (like auto selling when receiving in one contract).\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nAdd checks to ensure `order`'s one `collection`'s token ids are not duplicate in `doTokenIdsIntersect()`\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/135#issuecomment-1162878540):**\n > Agree with assessment. Fixed. https://github.com/infinitydotxyz/exchange-contracts-v2/commit/c3c0684ac02e0cf1c03cdbee7e68c5a37fa334a8 and removed support for ERC1155\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/135#issuecomment-1179823515):**\n > This is an interesting scenario where the same NFT appears multiple times in a match and results in one order being under filled, leading to potential losses for the user. And the attack does not depend on the matching engine. Agree this is High risk.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-06-infinity-nft-marketplace-contest",
  "Code": [
    {
      "filename": "contracts/core/InfinityOrderBookComplication.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\n\nimport {OrderTypes} from '../libs/OrderTypes.sol';\nimport {IComplication} from '../interfaces/IComplication.sol';\n\n/**\n * @title InfinityOrderBookComplication\n * @author nneverlander. Twitter @nneverlander\n * @notice Complication to execute orderbook orders\n */\ncontract InfinityOrderBookComplication is IComplication, Ownable {\n  // ======================================================= EXTERNAL FUNCTIONS ==================================================\n\n  /**\n   * @notice Checks whether one to one matches can be executed\n   * @dev This function is called by the main exchange to check whether one to one matches can be executed.\n          It checks whether orders have the right constraints - i.e they have one NFT only, whether time is still valid,\n          prices are valid and whether the nfts intersect\n   * @param makerOrder1 first makerOrder\n   * @param makerOrder2 second makerOrder\n   * @return returns whether the order can be executed and the execution price\n   */\n  function canExecMatchOneToOne(OrderTypes.MakerOrder calldata makerOrder1, OrderTypes.MakerOrder calldata makerOrder2)\n    external\n    view\n    override\n    returns (bool, uint256)\n  {\n    bool numItemsValid = makerOrder2.constraints[0] == makerOrder1.constraints[0] &&\n      makerOrder2.constraints[0] == 1 &&\n      makerOrder2.nfts.length == 1 &&\n      makerOrder2.nfts[0].tokens.length == 1 &&\n      makerOrder1.nfts.length == 1 &&\n      makerOrder1.nfts[0].tokens.length == 1;\n    bool _isTimeValid = makerOrder2.constraints[3] <= block.timestamp &&\n      makerOrder2.constraints[4] >= block.timestamp &&\n      makerOrder1.constraints[3] <= block.timestamp &&\n      makerOrder1.constraints[4] >= block.timestamp;\n    bool _isPriceValid = false;\n    uint256 makerOrder1Price = _getCurrentPrice(makerOrder1);\n    uint256 makerOrder2Price = _getCurrentPrice(makerOrder2);\n    uint256 execPrice;\n    if (makerOrder1.isSellOrder) {\n      _isPriceValid = makerOrder2Price >= makerOrder1Price;\n      execPrice = makerOrder1Price;\n    } else {\n      _isPriceValid = makerOrder1Price >= makerOrder2Price;\n      execPrice = makerOrder2Price;\n    }\n    return (\n      numItemsValid && _isTimeValid && doItemsIntersect(makerOrder1.nfts, makerOrder2.nfts) && _isPriceValid,\n      execPrice\n    );\n  }\n\n  /**\n   * @notice Checks whether one to matches matches can be executed\n   * @dev This function is called by the main exchange to check whether one to many matches can be executed.\n          It checks whether orders have the right constraints - i.e they have the right number of items, whether time is still valid,\n          prices are valid and whether the nfts intersect\n   * @param makerOrder the one makerOrder\n   * @param manyMakerOrders many maker orders\n   * @return returns whether the order can be executed\n   */\n  function canExecMatchOneToMany(\n    OrderTypes.MakerOrder calldata makerOrder,\n    OrderTypes.MakerOrder[] calldata manyMakerOrders\n  ) external view override returns (bool) {\n    uint256 numItems;\n    bool isOrdersTimeValid = true;\n    bool itemsIntersect = true;\n    uint256 ordersLength = manyMakerOrders.length;\n    for (uint256 i = 0; i < ordersLength; ) {\n      if (!isOrdersTimeValid || !itemsIntersect) {\n        return false; // short circuit\n      }\n\n      uint256 nftsLength = manyMakerOrders[i].nfts.length;\n      for (uint256 j = 0; j < nftsLength; ) {\n        numItems += manyMakerOrders[i].nfts[j].tokens.length;\n        unchecked {\n          ++j;\n        }\n      }\n\n      isOrdersTimeValid =\n        isOrdersTimeValid &&\n        manyMakerOrders[i].constraints[3] <= block.timestamp &&\n        manyMakerOrders[i].constraints[4] >= block.timestamp;\n\n      itemsIntersect = itemsIntersect && doItemsIntersect(makerOrder.nfts, manyMakerOrders[i].nfts);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    bool _isTimeValid = isOrdersTimeValid &&\n      makerOrder.constraints[3] <= block.timestamp &&\n      makerOrder.constraints[4] >= block.timestamp;\n\n    uint256 currentMakerOrderPrice = _getCurrentPrice(makerOrder);\n    uint256 sumCurrentOrderPrices = _sumCurrentPrices(manyMakerOrders);\n\n    bool _isPriceValid = false;\n    if (makerOrder.isSellOrder) {\n      _isPriceValid = sumCurrentOrderPrices >= currentMakerOrderPrice;\n    } else {\n      _isPriceValid = sumCurrentOrderPrices <= currentMakerOrderPrice;\n    }\n\n    return (numItems == makerOrder.constraints[0]) && _isTimeValid && itemsIntersect && _isPriceValid;\n  }\n\n  /**\n   * @notice Checks whether match orders with a higher order intent can be executed\n   * @dev This function is called by the main exchange to check whether one to one matches can be executed.\n          It checks whether orders have the right constraints - i.e they have the right number of items, whether time is still valid,\n          prices are valid and whether the nfts intersect\n   * @param sell sell order\n   * @param buy buy order\n   * @param constructedNfts - nfts constructed by the off chain matching engine\n   * @return returns whether the order can be executed and the execution price\n   */\n  function canExecMatchOrder(\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    OrderTypes.OrderItem[] calldata constructedNfts\n  ) external view override returns (bool, uint256) {\n    (bool _isPriceValid, uint256 execPrice) = isPriceValid(sell, buy);\n    return (\n      isTimeValid(sell, buy) &&\n        _isPriceValid &&\n        areNumItemsValid(sell, buy, constructedNfts) &&\n        doItemsIntersect(sell.nfts, constructedNfts) &&\n        doItemsIntersect(buy.nfts, constructedNfts) &&\n        doItemsIntersect(sell.nfts, buy.nfts),\n      execPrice\n    );\n  }\n\n  /**\n   * @notice Checks whether take orders with a higher order intent can be executed\n   * @dev This function is called by the main exchange to check whether take orders with a higher order intent can be executed.\n          It checks whether orders have the right constraints - i.e they have the right number of items, whether time is still valid\n          and whether the nfts intersect\n   * @param makerOrder the maker order\n   * @param takerItems the taker items specified by the taker\n   * @return returns whether order can be executed\n   */\n  function canExecTakeOrder(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)\n    external\n    view\n    override\n    returns (bool)\n  {\n    return (makerOrder.constraints[3] <= block.timestamp &&\n      makerOrder.constraints[4] >= block.timestamp &&\n      areTakerNumItemsValid(makerOrder, takerItems) &&\n      doItemsIntersect(makerOrder.nfts, takerItems));\n  }\n\n  // ======================================================= PUBLIC FUNCTIONS ==================================================\n\n  /// @dev checks whether the orders are active and not expired\n  function isTimeValid(OrderTypes.MakerOrder calldata sell, OrderTypes.MakerOrder calldata buy)\n    public\n    view\n    returns (bool)\n  {\n    return\n      sell.constraints[3] <= block.timestamp &&\n      sell.constraints[4] >= block.timestamp &&\n      buy.constraints[3] <= block.timestamp &&\n      buy.constraints[4] >= block.timestamp;\n  }\n\n  /// @dev checks whether the price is valid; a buy order should always have a higher price than a sell order\n  function isPriceValid(OrderTypes.MakerOrder calldata sell, OrderTypes.MakerOrder calldata buy)\n    public\n    view\n    returns (bool, uint256)\n  {\n    (uint256 currentSellPrice, uint256 currentBuyPrice) = (_getCurrentPrice(sell), _getCurrentPrice(buy));\n    return (currentBuyPrice >= currentSellPrice, currentSellPrice);\n  }\n\n  /// @dev sanity check to make sure the constructed nfts conform to the user signed constraints\n  function areNumItemsValid(\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    OrderTypes.OrderItem[] calldata constructedNfts\n  ) public pure returns (bool) {\n    uint256 numConstructedItems = 0;\n    uint256 nftsLength = constructedNfts.length;\n    for (uint256 i = 0; i < nftsLength; ) {\n      unchecked {\n        numConstructedItems += constructedNfts[i].tokens.length;\n        ++i;\n      }\n    }\n    return numConstructedItems >= buy.constraints[0] && buy.constraints[0] <= sell.constraints[0];\n  }\n\n  /// @dev sanity check to make sure that a taker is specifying the right number of items\n  function areTakerNumItemsValid(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)\n    public\n    pure\n    returns (bool)\n  {\n    uint256 numTakerItems = 0;\n    uint256 nftsLength = takerItems.length;\n    for (uint256 i = 0; i < nftsLength; ) {\n      unchecked {\n        numTakerItems += takerItems[i].tokens.length;\n        ++i;\n      }\n    }\n    return makerOrder.constraints[0] == numTakerItems;\n  }\n\n  /**\n   * @notice Checks whether nfts intersect\n   * @dev This function checks whether there are intersecting nfts between two orders\n   * @param order1Nfts nfts in the first order\n   * @param order2Nfts nfts in the second order\n   * @return returns whether items intersect\n   */\n  function doItemsIntersect(OrderTypes.OrderItem[] calldata order1Nfts, OrderTypes.OrderItem[] calldata order2Nfts)\n    public\n    pure\n    returns (bool)\n  {\n    uint256 order1NftsLength = order1Nfts.length;\n    uint256 order2NftsLength = order2Nfts.length;\n    // case where maker/taker didn't specify any items\n    if (order1NftsLength == 0 || order2NftsLength == 0) {\n      return true;\n    }\n\n    uint256 numCollsMatched = 0;\n    // check if taker has all items in maker\n    for (uint256 i = 0; i < order2NftsLength; ) {\n      for (uint256 j = 0; j < order1NftsLength; ) {\n        if (order1Nfts[j].collection == order2Nfts[i].collection) {\n          // increment numCollsMatched\n          unchecked {\n            ++numCollsMatched;\n          }\n          // check if tokenIds intersect\n          bool tokenIdsIntersect = doTokenIdsIntersect(order1Nfts[j], order2Nfts[i]);\n          require(tokenIdsIntersect, 'tokenIds dont intersect');\n          // short circuit\n          break;\n        }\n        unchecked {\n          ++j;\n        }\n      }\n      unchecked {\n        ++i;\n      }\n    }\n\n    return numCollsMatched == order2NftsLength;\n  }\n\n  /**\n   * @notice Checks whether tokenIds intersect\n   * @dev This function checks whether there are intersecting tokenIds between two order items\n   * @param item1 first item\n   * @param item2 second item\n   * @return returns whether tokenIds intersect\n   */\n  function doTokenIdsIntersect(OrderTypes.OrderItem calldata item1, OrderTypes.OrderItem calldata item2)\n    public\n    pure\n    returns (bool)\n  {\n    uint256 item1TokensLength = item1.tokens.length;\n    uint256 item2TokensLength = item2.tokens.length;\n    // case where maker/taker didn't specify any tokenIds for this collection\n    if (item1TokensLength == 0 || item2TokensLength == 0) {\n      return true;\n    }\n    uint256 numTokenIdsPerCollMatched = 0;\n    for (uint256 k = 0; k < item2TokensLength; ) {\n      for (uint256 l = 0; l < item1TokensLength; ) {\n        if (\n          item1.tokens[l].tokenId == item2.tokens[k].tokenId && item1.tokens[l].numTokens == item2.tokens[k].numTokens\n        ) {\n          // increment numTokenIdsPerCollMatched\n          unchecked {\n            ++numTokenIdsPerCollMatched;\n          }\n          // short circuit\n          break;\n        }\n        unchecked {\n          ++l;\n        }\n      }\n      unchecked {\n        ++k;\n      }\n    }\n\n    return numTokenIdsPerCollMatched == item2TokensLength;\n  }\n\n  // ======================================================= UTILS ============================================================\n\n  /// @dev returns the sum of current order prices; used in match one to many orders\n  function _sumCurrentPrices(OrderTypes.MakerOrder[] calldata orders) internal view returns (uint256) {\n    uint256 sum = 0;\n    uint256 ordersLength = orders.length;\n    for (uint256 i = 0; i < ordersLength; ) {\n      sum += _getCurrentPrice(orders[i]);\n      unchecked {\n        ++i;\n      }\n    }\n    return sum;\n  }\n\n  /// @dev Gets current order price for orders that vary in price over time (dutch and reverse dutch auctions)\n  function _getCurrentPrice(OrderTypes.MakerOrder calldata order) internal view returns (uint256) {\n    (uint256 startPrice, uint256 endPrice) = (order.constraints[1], order.constraints[2]);\n    uint256 duration = order.constraints[4] - order.constraints[3];\n    uint256 priceDiff = startPrice > endPrice ? startPrice - endPrice : endPrice - startPrice;\n    if (priceDiff == 0 || duration == 0) {\n      return startPrice;\n    }\n    uint256 elapsedTime = block.timestamp - order.constraints[3];\n    uint256 PRECISION = 10**4; // precision for division; similar to bps\n    uint256 portionBps = elapsedTime > duration ? PRECISION : ((elapsedTime * PRECISION) / duration);\n    priceDiff = (priceDiff * portionBps) / PRECISION;\n    return startPrice > endPrice ? startPrice - priceDiff : startPrice + priceDiff;\n  }\n}"
    },
    {
      "filename": "contracts/core/InfinityOrderBookComplication.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\n\nimport {OrderTypes} from '../libs/OrderTypes.sol';\nimport {IComplication} from '../interfaces/IComplication.sol';\n\n/**\n * @title InfinityOrderBookComplication\n * @author nneverlander. Twitter @nneverlander\n * @notice Complication to execute orderbook orders\n */\ncontract InfinityOrderBookComplication is IComplication, Ownable {\n  // ======================================================= EXTERNAL FUNCTIONS ==================================================\n\n  /**\n   * @notice Checks whether one to one matches can be executed\n   * @dev This function is called by the main exchange to check whether one to one matches can be executed.\n          It checks whether orders have the right constraints - i.e they have one NFT only, whether time is still valid,\n          prices are valid and whether the nfts intersect\n   * @param makerOrder1 first makerOrder\n   * @param makerOrder2 second makerOrder\n   * @return returns whether the order can be executed and the execution price\n   */\n  function canExecMatchOneToOne(OrderTypes.MakerOrder calldata makerOrder1, OrderTypes.MakerOrder calldata makerOrder2)\n    external\n    view\n    override\n    returns (bool, uint256)\n  {\n    bool numItemsValid = makerOrder2.constraints[0] == makerOrder1.constraints[0] &&\n      makerOrder2.constraints[0] == 1 &&\n      makerOrder2.nfts.length == 1 &&\n      makerOrder2.nfts[0].tokens.length == 1 &&\n      makerOrder1.nfts.length == 1 &&\n      makerOrder1.nfts[0].tokens.length == 1;\n    bool _isTimeValid = makerOrder2.constraints[3] <= block.timestamp &&\n      makerOrder2.constraints[4] >= block.timestamp &&\n      makerOrder1.constraints[3] <= block.timestamp &&\n      makerOrder1.constraints[4] >= block.timestamp;\n    bool _isPriceValid = false;\n    uint256 makerOrder1Price = _getCurrentPrice(makerOrder1);\n    uint256 makerOrder2Price = _getCurrentPrice(makerOrder2);\n    uint256 execPrice;\n    if (makerOrder1.isSellOrder) {\n      _isPriceValid = makerOrder2Price >= makerOrder1Price;\n      execPrice = makerOrder1Price;\n    } else {\n      _isPriceValid = makerOrder1Price >= makerOrder2Price;\n      execPrice = makerOrder2Price;\n    }\n    return (\n      numItemsValid && _isTimeValid && doItemsIntersect(makerOrder1.nfts, makerOrder2.nfts) && _isPriceValid,\n      execPrice\n    );\n  }\n\n  /**\n   * @notice Checks whether one to matches matches can be executed\n   * @dev This function is called by the main exchange to check whether one to many matches can be executed.\n          It checks whether orders have the right constraints - i.e they have the right number of items, whether time is still valid,\n          prices are valid and whether the nfts intersect\n   * @param makerOrder the one makerOrder\n   * @param manyMakerOrders many maker orders\n   * @return returns whether the order can be executed\n   */\n  function canExecMatchOneToMany(\n    OrderTypes.MakerOrder calldata makerOrder,\n    OrderTypes.MakerOrder[] calldata manyMakerOrders\n  ) external view override returns (bool) {\n    uint256 numItems;\n    bool isOrdersTimeValid = true;\n    bool itemsIntersect = true;\n    uint256 ordersLength = manyMakerOrders.length;\n    for (uint256 i = 0; i < ordersLength; ) {\n      if (!isOrdersTimeValid || !itemsIntersect) {\n        return false; // short circuit\n      }\n\n      uint256 nftsLength = manyMakerOrders[i].nfts.length;\n      for (uint256 j = 0; j < nftsLength; ) {\n        numItems += manyMakerOrders[i].nfts[j].tokens.length;\n        unchecked {\n          ++j;\n        }\n      }\n\n      isOrdersTimeValid =\n        isOrdersTimeValid &&\n        manyMakerOrders[i].constraints[3] <= block.timestamp &&\n        manyMakerOrders[i].constraints[4] >= block.timestamp;\n\n      itemsIntersect = itemsIntersect && doItemsIntersect(makerOrder.nfts, manyMakerOrders[i].nfts);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    bool _isTimeValid = isOrdersTimeValid &&\n      makerOrder.constraints[3] <= block.timestamp &&\n      makerOrder.constraints[4] >= block.timestamp;\n\n    uint256 currentMakerOrderPrice = _getCurrentPrice(makerOrder);\n    uint256 sumCurrentOrderPrices = _sumCurrentPrices(manyMakerOrders);\n\n    bool _isPriceValid = false;\n    if (makerOrder.isSellOrder) {\n      _isPriceValid = sumCurrentOrderPrices >= currentMakerOrderPrice;\n    } else {\n      _isPriceValid = sumCurrentOrderPrices <= currentMakerOrderPrice;\n    }\n\n    return (numItems == makerOrder.constraints[0]) && _isTimeValid && itemsIntersect && _isPriceValid;\n  }\n\n  /**\n   * @notice Checks whether match orders with a higher order intent can be executed\n   * @dev This function is called by the main exchange to check whether one to one matches can be executed.\n          It checks whether orders have the right constraints - i.e they have the right number of items, whether time is still valid,\n          prices are valid and whether the nfts intersect\n   * @param sell sell order\n   * @param buy buy order\n   * @param constructedNfts - nfts constructed by the off chain matching engine\n   * @return returns whether the order can be executed and the execution price\n   */\n  function canExecMatchOrder(\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    OrderTypes.OrderItem[] calldata constructedNfts\n  ) external view override returns (bool, uint256) {\n    (bool _isPriceValid, uint256 execPrice) = isPriceValid(sell, buy);\n    return (\n      isTimeValid(sell, buy) &&\n        _isPriceValid &&\n        areNumItemsValid(sell, buy, constructedNfts) &&\n        doItemsIntersect(sell.nfts, constructedNfts) &&\n        doItemsIntersect(buy.nfts, constructedNfts) &&\n        doItemsIntersect(sell.nfts, buy.nfts),\n      execPrice\n    );\n  }\n\n  /**\n   * @notice Checks whether take orders with a higher order intent can be executed\n   * @dev This function is called by the main exchange to check whether take orders with a higher order intent can be executed.\n          It checks whether orders have the right constraints - i.e they have the right number of items, whether time is still valid\n          and whether the nfts intersect\n   * @param makerOrder the maker order\n   * @param takerItems the taker items specified by the taker\n   * @return returns whether order can be executed\n   */\n  function canExecTakeOrder(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)\n    external\n    view\n    override\n    returns (bool)\n  {\n    return (makerOrder.constraints[3] <= block.timestamp &&\n      makerOrder.constraints[4] >= block.timestamp &&\n      areTakerNumItemsValid(makerOrder, takerItems) &&\n      doItemsIntersect(makerOrder.nfts, takerItems));\n  }\n\n  // ======================================================= PUBLIC FUNCTIONS ==================================================\n\n  /// @dev checks whether the orders are active and not expired\n  function isTimeValid(OrderTypes.MakerOrder calldata sell, OrderTypes.MakerOrder calldata buy)\n    public\n    view\n    returns (bool)\n  {\n    return\n      sell.constraints[3] <= block.timestamp &&\n      sell.constraints[4] >= block.timestamp &&\n      buy.constraints[3] <= block.timestamp &&\n      buy.constraints[4] >= block.timestamp;\n  }\n\n  /// @dev checks whether the price is valid; a buy order should always have a higher price than a sell order\n  function isPriceValid(OrderTypes.MakerOrder calldata sell, OrderTypes.MakerOrder calldata buy)\n    public\n    view\n    returns (bool, uint256)\n  {\n    (uint256 currentSellPrice, uint256 currentBuyPrice) = (_getCurrentPrice(sell), _getCurrentPrice(buy));\n    return (currentBuyPrice >= currentSellPrice, currentSellPrice);\n  }\n\n  /// @dev sanity check to make sure the constructed nfts conform to the user signed constraints\n  function areNumItemsValid(\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    OrderTypes.OrderItem[] calldata constructedNfts\n  ) public pure returns (bool) {\n    uint256 numConstructedItems = 0;\n    uint256 nftsLength = constructedNfts.length;\n    for (uint256 i = 0; i < nftsLength; ) {\n      unchecked {\n        numConstructedItems += constructedNfts[i].tokens.length;\n        ++i;\n      }\n    }\n    return numConstructedItems >= buy.constraints[0] && buy.constraints[0] <= sell.constraints[0];\n  }\n\n  /// @dev sanity check to make sure that a taker is specifying the right number of items\n  function areTakerNumItemsValid(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)\n    public\n    pure\n    returns (bool)\n  {\n    uint256 numTakerItems = 0;\n    uint256 nftsLength = takerItems.length;\n    for (uint256 i = 0; i < nftsLength; ) {\n      unchecked {\n        numTakerItems += takerItems[i].tokens.length;\n        ++i;\n      }\n    }\n    return makerOrder.constraints[0] == numTakerItems;\n  }\n\n  /**\n   * @notice Checks whether nfts intersect\n   * @dev This function checks whether there are intersecting nfts between two orders\n   * @param order1Nfts nfts in the first order\n   * @param order2Nfts nfts in the second order\n   * @return returns whether items intersect\n   */\n  function doItemsIntersect(OrderTypes.OrderItem[] calldata order1Nfts, OrderTypes.OrderItem[] calldata order2Nfts)\n    public\n    pure\n    returns (bool)\n  {\n    uint256 order1NftsLength = order1Nfts.length;\n    uint256 order2NftsLength = order2Nfts.length;\n    // case where maker/taker didn't specify any items\n    if (order1NftsLength == 0 || order2NftsLength == 0) {\n      return true;\n    }\n\n    uint256 numCollsMatched = 0;\n    // check if taker has all items in maker\n    for (uint256 i = 0; i < order2NftsLength; ) {\n      for (uint256 j = 0; j < order1NftsLength; ) {\n        if (order1Nfts[j].collection == order2Nfts[i].collection) {\n          // increment numCollsMatched\n          unchecked {\n            ++numCollsMatched;\n          }\n          // check if tokenIds intersect\n          bool tokenIdsIntersect = doTokenIdsIntersect(order1Nfts[j], order2Nfts[i]);\n          require(tokenIdsIntersect, 'tokenIds dont intersect');\n          // short circuit\n          break;\n        }\n        unchecked {\n          ++j;\n        }\n      }\n      unchecked {\n        ++i;\n      }\n    }\n\n    return numCollsMatched == order2NftsLength;\n  }\n\n  /**\n   * @notice Checks whether tokenIds intersect\n   * @dev This function checks whether there are intersecting tokenIds between two order items\n   * @param item1 first item\n   * @param item2 second item\n   * @return returns whether tokenIds intersect\n   */\n  function doTokenIdsIntersect(OrderTypes.OrderItem calldata item1, OrderTypes.OrderItem calldata item2)\n    public\n    pure\n    returns (bool)\n  {\n    uint256 item1TokensLength = item1.tokens.length;\n    uint256 item2TokensLength = item2.tokens.length;\n    // case where maker/taker didn't specify any tokenIds for this collection\n    if (item1TokensLength == 0 || item2TokensLength == 0) {\n      return true;\n    }\n    uint256 numTokenIdsPerCollMatched = 0;\n    for (uint256 k = 0; k < item2TokensLength; ) {\n      for (uint256 l = 0; l < item1TokensLength; ) {\n        if (\n          item1.tokens[l].tokenId == item2.tokens[k].tokenId && item1.tokens[l].numTokens == item2.tokens[k].numTokens\n        ) {\n          // increment numTokenIdsPerCollMatched\n          unchecked {\n            ++numTokenIdsPerCollMatched;\n          }\n          // short circuit\n          break;\n        }\n        unchecked {\n          ++l;\n        }\n      }\n      unchecked {\n        ++k;\n      }\n    }\n\n    return numTokenIdsPerCollMatched == item2TokensLength;\n  }\n\n  // ======================================================= UTILS ============================================================\n\n  /// @dev returns the sum of current order prices; used in match one to many orders\n  function _sumCurrentPrices(OrderTypes.MakerOrder[] calldata orders) internal view returns (uint256) {\n    uint256 sum = 0;\n    uint256 ordersLength = orders.length;\n    for (uint256 i = 0; i < ordersLength; ) {\n      sum += _getCurrentPrice(orders[i]);\n      unchecked {\n        ++i;\n      }\n    }\n    return sum;\n  }\n\n  /// @dev Gets current order price for orders that vary in price over time (dutch and reverse dutch auctions)\n  function _getCurrentPrice(OrderTypes.MakerOrder calldata order) internal view returns (uint256) {\n    (uint256 startPrice, uint256 endPrice) = (order.constraints[1], order.constraints[2]);\n    uint256 duration = order.constraints[4] - order.constraints[3];\n    uint256 priceDiff = startPrice > endPrice ? startPrice - endPrice : endPrice - startPrice;\n    if (priceDiff == 0 || duration == 0) {\n      return startPrice;\n    }\n    uint256 elapsedTime = block.timestamp - order.constraints[3];\n    uint256 PRECISION = 10**4; // precision for division; similar to bps\n    uint256 portionBps = elapsedTime > duration ? PRECISION : ((elapsedTime * PRECISION) / duration);\n    priceDiff = (priceDiff * portionBps) / PRECISION;\n    return startPrice > endPrice ? startPrice - priceDiff : startPrice + priceDiff;\n  }\n}"
    },
    {
      "filename": "contracts/core/InfinityExchange.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\n// external imports\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport {IERC165} from '@openzeppelin/contracts/interfaces/IERC165.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {IERC1155} from '@openzeppelin/contracts/token/ERC1155/IERC1155.sol';\nimport {IERC20, SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\n\n// internal imports\nimport {OrderTypes} from '../libs/OrderTypes.sol';\nimport {IComplication} from '../interfaces/IComplication.sol';\nimport {SignatureChecker} from '../libs/SignatureChecker.sol';\n\n/**\n@title InfinityExchange\n@author nneverlander. Twitter @nneverlander\n@notice The main NFT exchange contract that holds state and does asset transfers\n@dev This contract can be extended via 'complications' - strategies that let the exchange execute various types of orders\n      like dutch auctions, reverse dutch auctions, floor price orders, private sales, etc.\n\nNFTNFTNFT...........................................NFTNFTNFT\nNFTNFT                                                 NFTNFT\nNFT                                                       NFT\n.                                                           .\n.                                                           .\n.                                                           .\n.                                                           .\n.               NFTNFTNFT            NFTNFTNFT              .\n.            NFTNFTNFTNFTNFT      NFTNFTNFTNFTNFT           .\n.           NFTNFTNFTNFTNFTNFT   NFTNFTNFTNFTNFTNFT         .\n.         NFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFT        .\n.         NFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFT        .\n.         NFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFT        .\n.          NFTNFTNFTNFTNFTNFTN   NFTNFTNFTNFTNFTNFT         .\n.            NFTNFTNFTNFTNFT      NFTNFTNFTNFTNFT           .\n.               NFTNFTNFT            NFTNFTNFT              .\n.                                                           .\n.                                                           .\n.                                                           .\n.                                                           .\nNFT                                                       NFT\nNFTNFT                                                 NFTNFT\nNFTNFTNFT...........................................NFTNFTNFT \n\n*/\ncontract InfinityExchange is ReentrancyGuard, Ownable {\n  using SafeERC20 for IERC20;\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  /// @dev WETH address of a chain; set at deploy time to the WETH address of the chain that this contract is deployed to\n  address public immutable WETH;\n  /// @dev Used in order signing with EIP-712\n  bytes32 public immutable DOMAIN_SEPARATOR;\n  /// @dev This is the adress that is used to send auto sniped orders for execution on chain\n  address public MATCH_EXECUTOR;\n  /// @dev Gas cost for auto sniped orders are paid by the buyers and refunded to this contract in the form of WETH\n  uint32 public WETH_TRANSFER_GAS_UNITS = 50000;\n  /// @notice Exchange fee in basis points (250 bps = 2.5%)\n  uint16 public PROTOCOL_FEE_BPS = 250;\n\n  /**\n   @dev All orders should have a nonce >= to this value. \n        Any orders with nonce value less than this are non-executable. \n        Used for cancelling all outstanding orders.\n  */\n  mapping(address => uint256) public userMinOrderNonce;\n\n  /// @dev This records already executed or cancelled orders to prevent replay attacks.\n  mapping(address => mapping(uint256 => bool)) public isUserOrderNonceExecutedOrCancelled;\n\n  /// @dev Storage variable that keeps track of valid complications (order execution strategies)\n  EnumerableSet.AddressSet private _complications;\n  /// @dev Storate variable that keeps track of valid currencies (tokens)\n  EnumerableSet.AddressSet private _currencies;\n\n  event CancelAllOrders(address user, uint256 newMinNonce);\n  event CancelMultipleOrders(address user, uint256[] orderNonces);\n  event NewWethTransferGasUnits(uint32 wethTransferGasUnits);\n  event NewProtocolFee(uint16 protocolFee);\n\n  event MatchOrderFulfilled(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    address seller,\n    address buyer,\n    address complication, // address of the complication that defines the execution\n    address currency, // token address of the transacting currency\n    uint256 amount // amount spent on the order\n  );\n\n  event TakeOrderFulfilled(\n    bytes32 orderHash,\n    address seller,\n    address buyer,\n    address complication, // address of the complication that defines the execution\n    address currency, // token address of the transacting currency\n    uint256 amount // amount spent on the order\n  );\n\n  constructor(address _WETH, address _matchExecutor) {\n    // Calculate the domain separator\n    DOMAIN_SEPARATOR = keccak256(\n      abi.encode(\n        keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n        keccak256('InfinityExchange'),\n        keccak256(bytes('1')), // for versionId = 1\n        block.chainid,\n        address(this)\n      )\n    );\n    WETH = _WETH;\n    MATCH_EXECUTOR = _matchExecutor;\n  }\n\n  fallback() external payable {}\n\n  receive() external payable {}\n\n  // =================================================== USER FUNCTIONS =======================================================\n\n  /**\n   @notice Matches orders one to one where each order has 1 NFT. Example: Match 1 specific NFT buy with one specific NFT sell.\n   @dev Can execute orders in batches for gas efficiency. Can only be called by the match executor. Refunds gas cost incurred by the\n        match executor to this contract. Checks whether the given complication can execute the match.\n   @param makerOrders1 Maker order 1\n   @param makerOrders2 Maker order 2\n  */\n  function matchOneToOneOrders(\n    OrderTypes.MakerOrder[] calldata makerOrders1,\n    OrderTypes.MakerOrder[] calldata makerOrders2\n  ) external {\n    uint256 startGas = gasleft();\n    uint256 numMakerOrders = makerOrders1.length;\n    require(msg.sender == MATCH_EXECUTOR, 'OME');\n    require(numMakerOrders == makerOrders2.length, 'mismatched lengths');\n\n    // the below 3 variables are copied to me"
    }
  ]
}