{
  "Title": "H-2: Many cases `stEth::transferFrom` will transfer 1-2 less way, which would result in revert in consequent functions, because of not enough balance",
  "Content": "# Issue H-2: Many cases `stEth::transferFrom` will transfer 1-2 less way, which would result in revert in consequent functions, because of not enough balance \n\nSource: https://github.com/sherlock-audit/2024-05-sophon-judging/issues/63 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nBauchibred, EgisSecurity, zzykxx\n## Summary\nWhen user calls `depositStEth`, he passes `_amount` param, which is set to `IERC20(stETH).safeTransferFrom()` func and then the sam `_amount` is passed down the chain:\n```solidity\n        IERC20(stETH).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        _depositPredefinedAsset(_amount, _amount, _boostAmount, PredefinedPool.wstETH);\n ```\n## Vulnerability Detail\nThe probability of issue appearing is high and you can check in the following discussion. It has also been classified as a High severity on past contests:\nhttps://github.com/lidofinance/lido-dao/issues/442\n\n`stETH` is using shares for tracking balances and it is a known issue that due to rounding error, transferred shares may be 1-2 wei less than `_amount` passed.\nThis would revert on the following line as we have transferred `_amount - 1` and farming contract do not hold `stEth` funds:\n```solidity\n    function _stEthTOwstEth(uint256 _amount) internal returns (uint256) {\n        // wrap returns exact amount of wstETH\n        return IwstETH(wstETH).wrap(_amount);\n    }\n```\nThe impact may be bigger if the staking contract is implemented by 3rd party protocol and expect this the function to be always fine.\n## Impact\n- Contract functionality DoS \n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-05-sophon/blob/05059e53755f24ae9e3a3bb2996de15df0289a6c/farming-contracts/contracts/farm/SophonFarming.sol#L474-L478\n## Tool used\n\nManual Review\n\n## Recommendation\nUse lido recommendation to utilize `transferShares` function, so the `_amount` is realistic, or implement FoT approach, which compares the balance before and after the transfer. \n\n\n\n## Discussion\n\n**sherlock-admin4**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**0xmystery** commented:\n>  valid because this parallels FOT as documented by Lido (best because the report is succinct and well documented)\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/376",
  "Code": [
    {
      "filename": "farming-contracts/contracts/farm/SophonFarming.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.25;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./interfaces/IWeth.sol\";\nimport \"./interfaces/IstETH.sol\";\nimport \"./interfaces/IwstETH.sol\";\nimport \"./interfaces/IsDAI.sol\";\nimport \"./interfaces/IeETHLiquidityPool.sol\";\nimport \"./interfaces/IweETH.sol\";\nimport \"../proxies/Upgradeable2Step.sol\";\nimport \"./SophonFarmingState.sol\";\n\n/**\n * @title Sophon Farming Contract\n * @author Sophon\n */\ncontract SophonFarming is Upgradeable2Step, SophonFarmingState {\n    using SafeERC20 for IERC20;\n\n    /// @notice Emitted when a new pool is added\n    event Add(address indexed lpToken, uint256 indexed pid, uint256 allocPoint);\n\n    /// @notice Emitted when a pool is updated\n    event Set(address indexed lpToken, uint256 indexed pid, uint256 allocPoint);\n\n    /// @notice Emitted when a user deposits to a pool\n    event Deposit(address indexed user, uint256 indexed pid, uint256 depositAmount, uint256 boostAmount);\n\n    /// @notice Emitted when a user withdraws from a pool\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n\n    /// @notice Emitted when a user increases the boost of an existing deposit\n    event IncreaseBoost(address indexed user, uint256 indexed pid, uint256 boostAmount);\n\n    /// @notice Emitted when all pool funds are bridged to Sophon blockchain\n    event Bridge(address indexed user, uint256 indexed pid, uint256 amount);\n\n    /// @notice Emitted when the admin withdraws booster proceeds\n    event WithdrawProceeds(uint256 indexed pid, uint256 proceeds);\n\n    error PoolExists();\n    error PoolDoesNotExist();\n    error AlreadyInitialized();\n    error NotFound(address lpToken);\n    error FarmingIsStarted();\n    error FarmingIsEnded();\n    error InvalidStartBlock();\n    error InvalidEndBlock();\n    error InvalidDeposit();\n    error InvalidBooster();\n    error WithdrawNotAllowed();\n    error WithdrawTooHigh(uint256 maxAllowed);\n    error WithdrawIsZero();\n    error NothingInPool();\n    error NoEthSent();\n    error BoostTooHigh(uint256 maxAllowed);\n    error BoostIsZero();\n    error BridgeInvalid();\n\n    address public immutable dai;\n    address public immutable sDAI;\n    address public immutable weth;\n    address public immutable stETH;\n    address public immutable wstETH;\n    address public immutable eETH;\n    address public immutable eETHLiquidityPool;\n    address public immutable weETH;\n\n    /**\n     * @notice Construct SophonFarming\n     * @param tokens_ Immutable token addresses\n     * @dev 0:dai, 1:sDAI, 2:weth, 3:stETH, 4:wstETH, 5:eETH, 6:eETHLiquidityPool, 7:weETH\n     */\n    constructor(address[8] memory tokens_) {\n        dai = tokens_[0];\n        sDAI = tokens_[1];\n        weth = tokens_[2];\n        stETH = tokens_[3];\n        wstETH = tokens_[4];\n        eETH = tokens_[5];\n        eETHLiquidityPool = tokens_[6];\n        weETH = tokens_[7];\n    }\n\n    /**\n     * @notice Allows direct deposits of ETH for deposit to the wstETH pool\n     */\n    receive() external payable {\n        if (msg.sender == weth) {\n            return;\n        }\n\n        depositEth(0, PredefinedPool.wstETH);\n    }\n\n    /**\n     * @notice Initialize the farm\n     * @param ethAllocPoint_ eth alloc points\n     * @param sDAIAllocPoint_ sdai alloc points\n     * @param _pointsPerBlock points per block\n     * @param _startBlock start block\n     * @param _boosterMultiplier booster multiplier\n     */\n    function initialize(uint256 ethAllocPoint_, uint256 sDAIAllocPoint_, uint256 _pointsPerBlock, uint256 _startBlock, uint256 _boosterMultiplier) public virtual onlyOwner {\n        if (_initialized) {\n            revert AlreadyInitialized();\n        }\n\n        pointsPerBlock = _pointsPerBlock;\n\n        if (_startBlock == 0) {\n            revert InvalidStartBlock();\n        }\n        startBlock = _startBlock;\n\n        if (_boosterMultiplier < 1e18) {\n            revert InvalidBooster();\n        }\n        boosterMultiplier = _boosterMultiplier;\n\n        poolExists[dai] = true;\n        poolExists[weth] = true;\n        poolExists[stETH] = true;\n        poolExists[eETH] = true;\n\n        // sDAI\n        typeToId[PredefinedPool.sDAI] = add(sDAIAllocPoint_, sDAI, \"sDAI\", false);\n        IERC20(dai).approve(sDAI, 2**256-1);\n\n        // wstETH\n        typeToId[PredefinedPool.wstETH] = add(ethAllocPoint_, wstETH, \"wstETH\", false);\n        IERC20(stETH).approve(wstETH, 2**256-1);\n\n        // weETH\n        typeToId[PredefinedPool.weETH] = add(ethAllocPoint_, weETH, \"weETH\", false);\n        IERC20(eETH).approve(weETH, 2**256-1);\n\n        _initialized = true;\n    }\n\n    /**\n     * @notice Adds a new pool to the farm. Can only be called by the owner.\n     * @param _allocPoint alloc point for new pool\n     * @param _lpToken lpToken address\n     * @param _description description of new pool\n     * @param _withUpdate True will update accounting for all pools\n     * @return uint256 The pid of the newly created asset\n     */\n    function add(uint256 _allocPoint, address _lpToken, string memory _description, bool _withUpdate) public onlyOwner returns (uint256) {\n        if (poolExists[_lpToken]) {\n            revert PoolExists();\n        }\n        if (isFarmingEnded()) {\n            revert FarmingIsEnded();\n        }\n        if (_withUpdate) {\n            massUpdatePools();\n        }\n        uint256 lastRewardBlock =\n            getBlockNumber() > startBlock ? getBlockNumber() : startBlock;\n        totalAllocPoint = totalAllocPoint + _allocPoint;\n        poolExists[_lpToken] = true;\n\n        uint256 pid = poolInfo.length;\n\n        poolInfo.push(\n            PoolInfo({\n                lpToken: IERC20(_lpToken),\n                l2Farm: address(0),\n                amount: 0,\n                boostAmount: 0,\n                depositAmount: 0,\n                allocPoint: _allocPoint,\n                lastRewardBlock: lastRewardBlock,\n                accPointsPerShare: 0,\n                description: _description\n            })\n        );\n\n        emit Add(_lpToken, pid, _allocPoint);\n\n        return pid;\n    }\n\n    /**\n     * @notice Updates the given pool's allocation point. Can only be called by the owner.\n     * @param _pid The pid to update\n     * @param _allocPoint The new alloc point to set for the pool\n     * @param _withUpdate True will update accounting for all pools\n     */\n    function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner {\n        if (isFarmingEnded()) {\n            revert FarmingIsEnded();\n        }\n        if (_withUpdate) {\n            massUpdatePools();\n        }\n\n        PoolInfo storage pool = poolInfo[_pid];\n        address lpToken = address(pool.lpToken);\n        if (lpToken == address(0) || !poolExists[lpToken]) {\n            revert PoolDoesNotExist();\n        }\n        totalAllocPoint = totalAllocPoint - pool.allocPoint + _allocPoint;\n        pool.allocPoint = _allocPoint;\n\n        if (getBlockNumber() < pool.lastRewardBlock) {\n            pool.lastRewardBlock = startBlock;\n        }\n\n        emit Set(lpToken, _pid, _allocPoint);\n    }\n\n    /**\n     * @notice Returns the number of pools in the farm\n     * @return uint256 number of pools\n     */\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    /**\n     * @notice Checks if farming is ended\n     * @return bool True if farming is ended\n     */\n    function isFarmingEnded() public view returns (bool) {\n        uint256 _endBlock = endBlock;\n        if (_endBlock != 0 && getBlockNumber() > _endBlock) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @notice Checks if the withdrawal period is ended\n     * @return bool True if withdrawal period is ended\n     */\n    function isWithdrawPeriodEnded() public view returns (bool) {\n        uint256 _endBlockForWithdrawals = endBlockForWithdrawals;\n        if (_endBlockForWithdrawals != 0 && getBlockNumber() > _endBlockForWithdrawals) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @notice Updates the bridge contract\n     */\n    function setBridge(BridgeLike _bridge) public onlyOwner {\n        bridge = _bridge;\n    }\n\n    /**\n     * @notice Updates the L2 Farm for the pool\n     * @param _pid the pid\n     * @param _l2Farm the l2Farm address\n     */\n    function setL2FarmForPool(uint256 _pid, address _l2Farm) public onlyOwner {\n        poolInfo[_pid].l2Farm = _l2Farm;\n    }\n\n    /**\n     * @notice Set the start block of the farm\n     * @param _startBlock the start block\n     */\n    function setStartBlock(uint256 _startBlock) public onlyOwner {\n        if (_startBlock == 0 || (endBlock != 0 && _startBlock >= endBlock)) {\n            revert InvalidStartBlock();\n        }\n        if (getBlockNumber() > startBlock) {\n            revert FarmingIsStarted();\n        }\n        startBlock = _startBlock;\n    }\n\n    /**\n     * @notice Set the end block of the farm\n     * @param _endBlock the end block\n     * @param _withdrawalBlocks the last block that withdrawals are allowed\n     */\n    function setEndBlock(uint256 _endBlock, uint256 _withdrawalBlocks) public onlyOwner {\n        uint256 _endBlockForWithdrawals;\n        if (_endBlock != 0) {\n            if (_endBlock <= startBlock || getBlockNumber() > _endBlock) {\n                revert InvalidEndBlock();\n            }\n            if (isFarmingEnded()) {\n                revert FarmingIsEnded();\n            }\n            _endBlockForWithdrawals = _endBlock + _withdrawalBlocks;\n        } else {\n            // withdrawal blocks needs an endBlock\n            _endBlockForWithdrawals = 0;\n        }\n        massUpdatePools();\n        endBlock = _endBlock;\n        endBlockForWithdrawals = _endBlockForWithdrawals;\n    }\n\n    /**\n     * @notice Set points per block\n     * @param _pointsPerBlock points per block to set\n     */\n    function setPointsPerBlock(uint256 _pointsPerBlock) public onlyOwner {\n        if (isFarmingEnded()) {\n            revert FarmingIsEnded();\n        }\n        massUpdatePools();\n        pointsPerBlock = _pointsPerBlock;\n    }\n\n    /**\n     * @notice Set booster multiplier\n     * @param _boosterMultiplier booster multiplier to set\n     */\n    function setBoosterMultiplier(uint256 _boosterMultiplier) public onlyOwner {\n        if (_boosterMultiplier < 1e18) {\n            revert InvalidBooster();\n        }\n        if (isFarmingEnded()) {\n            revert FarmingIsEnded();\n        }\n        massUpdatePools();\n        boosterMultiplier = _boosterMultiplier;\n    }\n\n    /**\n     * @notice Returns the block multiplier\n     * @param _from from block\n     * @param _to to block\n     * @return uint256 The block multiplier\n     */\n    function _getBlockMultiplier(uint256 _from, uint256 _to) internal view returns (uint256) {\n        uint256 _endBlock = endBlock;\n        if (_endBlock != 0) {\n            _to = Math.min(_to, _endBlock);\n        }\n        if (_to > _from) {\n            return (_to - _from) * 1e18;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Returns pending points for user in a pool\n     * @param _pid pid of the pool\n     * @param _user user in the pool\n     * @return uint256 pendings points\n     */\n    function _pendingPoints(uint256 _pid, address _user) internal view returns (uint256) {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n\n        uint256 accPointsPerShare = pool.accPointsPerShare * 1e18;\n\n        uint256 lpSupply = pool.amount;\n        if (getBlockNumber() > pool.lastRewardBlock && lpSupply != 0) {\n            uint256 blockMultiplier = _getBlockMultiplier(pool.lastRewardBlock, getBlockNumber());\n\n            uint256 pointReward =\n                blockMultiplier *\n                pointsPerBlock *\n                pool.allocPoint /\n                totalAllocPoint;\n\n            accPointsPerShare = pointReward *\n                1e18 /\n                lpSupply +\n                accPointsPerShare;\n        }\n\n        return user.amount *\n            accPointsPerShare /\n            1e36 +\n            user.rewardSettled -\n            user.rewardDebt;\n    }\n\n    /**\n     * @notice Returns pending points for user in a pool\n     * @param _pid pid of the pool\n     * @param _user user in the pool\n     * @return uint256 pendings points\n     */\n    function pendingPoints(uint256 _pid, address _user) external view returns (uint256) {\n        return _pendingPoints(_pid, _user);\n    }\n\n    /**\n     * @notice Update accounting of all pools\n     */\n    function massUpdatePools() public {\n        uint256 length = poolInfo.length;\n        for(uint256 pid = 0; pid < length;) {\n            updatePool(pid);\n            unchecked { ++pid; }\n        }\n    }\n\n    /**\n     * @notice Updating accounting of a single pool\n     * @param _pid pid to update\n     */\n    function updatePool(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (getBlockNumber() <= pool.lastRewardBlock) {\n            return;\n        }\n        uint256 lpSupply = pool.amount;\n        uint256 _pointsPerBlock = pointsPerBlock;\n        uint256 _allocPoint = pool.allocPoint;\n        if (lpSupply == 0 || _pointsPerBlock == 0 || _allocPoint == 0) {\n            pool.lastRewardBlock = getBlockNumber();\n            return;\n        }\n        uint256 blockMultiplier = _getBlockMultiplier(pool.lastRewardBlock, getBlockNumber());\n        uint256 pointReward =\n            blockMultiplier *\n            _pointsPerBlock *\n            _allocPoint /\n            totalAllocPoint;\n\n        pool.accPointsPerShare = pointReward /\n            lpSupply +\n            pool.accPointsPerShare;\n\n        pool.lastRewardBlock = getBlockNumber();\n    }\n\n    /**\n     * @notice Deposit assets to SophonFarming\n     * @param _pid pid of the pool\n     * @param _amount amount of the deposit\n     * @param _boostAmount amount to boost\n     */\n    function deposit(uint256 _pid, uint256 _amount, uint256 _boostAmount) external {\n        poolInfo[_pid].lpToken.safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        _deposit(_pid, _amount, _boostAmount);\n    }\n\n    /**\n     * @notice Deposit DAI to SophonFarming\n     * @param _amount amount of the deposit\n     * @param _boostAmount amount to boost\n     */\n    function depositDai(uint256 _amount, uint256 _boostAmount) external {\n        IERC20(dai).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        _depositPredefinedAsset(_amount, _amount, _boostAmount, PredefinedPool.sDAI);\n    }\n\n    /**\n     * @notice Deposit stETH to SophonFarming\n     * @param _amount amount of the deposit\n     * @param _boostAmount amount to boost\n     */\n    function depositStEth(uint256 _amount, uint256 _boostAmount) external {\n        IERC20(stETH).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        _depositPredefinedAsset(_amount, _amount, _boostAmount, PredefinedPool.wstETH);\n    }\n\n    /**\n     * @notice Deposit eETH to SophonFarming\n     * @param _amount amount of the deposit\n     * @param _boostAmount amount to boost\n     */\n    function depositeEth(uint256 _amount, uint256 _boostAmount) external {\n        IERC20(eETH).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        _depositPredefinedAsset(_amount, _amount, _boostAmount, PredefinedPool.weETH);\n    }\n\n    /**\n     * @notice Deposit ETH to SophonFarming when specifying a pool\n     * @param _boostAmount amount to boost\n     * @param _predefinedPool specific pool type to deposit to\n     */\n    function depositEth(uint256 _boostAmount, PredefinedPool _predefinedPool) public payable {\n        if (msg.value == 0) {\n            revert NoEthSent();\n        }\n\n        uint256 _finalAmount = msg.value;\n        if (_predefinedPool == PredefinedPool.wstETH) {\n            _finalAmount = _ethTOstEth(_finalAmount);\n        } else if (_predefinedPool == PredefinedPool.weETH) {\n            _finalAmount = _ethTOeEth(_finalAmount);\n        }\n\n        _depositPredefinedAsset(_finalAmount, msg.value, _boostAmount, _predefinedPool);\n    }\n\n    /**\n     * @notice Deposit WETH to SophonFarming when specifying a pool\n     * @param _amount amount of the deposit\n     * @param _boostAmount amount to boost\n     * @param _predefinedPool specific pool type to deposit to\n     */\n    function depositWeth(uint256 _amount, uint256 _boostAmount, PredefinedPool _predefinedPool) external {\n        IERC20(weth).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        uint256 _finalAmount = _wethTOEth(_amount);\n        if (_predefinedPool == PredefinedPool.wstETH) {\n            _finalAmount = _ethTOstEth(_finalAmount);\n        } else if (_predefinedPool == PredefinedPool.weETH) {\n            _finalAmount = _ethTOeEth(_finalAmount);\n        }\n\n        _depositPredefinedAsset(_finalAmount, _amount, _boostAmount, _predefinedPool);\n    }\n\n    /**\n     * @notice Deposit a predefined asset to SophonFarming\n     * @param _amount amount of the deposit\n     * @param _initalAmount amount of the deposit prior to conversions\n     * @param _boostAmount amount to boost\n     * @param _predefinedPool specific pool type to deposit to\n     */\n    function _depositPredefinedAsset(uint256 _amount, uint256 _initalAmount, uint256 _boostAmount, PredefinedPool _predefinedPool) internal {\n\n        uint256 _finalAmount;\n\n        if (_predefinedPool == PredefinedPool.sDAI) {\n            _finalAmount = _daiTOsDai(_amount);\n        } else if (_predefinedPool == PredefinedPool.wstETH) {\n            _finalAmount = _stEthTOwstEth(_amount);\n        } else if (_predefinedPool == PredefinedPool.weETH) {\n            _finalAmount = _eethTOweEth(_amount);\n        } else {\n            revert InvalidDeposit();\n        }\n\n        // adjust boostAmount for the new asset\n        _boostAmount = _boostAmount * _finalAmount / _initalAmount;\n\n        _deposit(typeToId[_predefinedPool], _finalAmount, _boostAmount);\n    }\n\n    /**\n     * @notice Deposit an asset to SophonFarming\n     * @param _pid pid of the deposit\n     * @param _depositAmount amount of the deposit\n     * @param _boostAmount amount to boost\n     */\n    function _deposit(uint256 _pid, uint256 _depositAmount, uint256 _boostAmount) internal {\n        if (isFarmingEnded()) {\n            revert FarmingIsEnded();\n        }\n        if (_depositAmount == 0) {\n            revert InvalidDeposit();\n        }\n        if (_boostAmount > _depositAmount) {\n            revert BoostTooHigh(_depositAmount);\n        }\n\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        updatePool(_pid);\n\n        uint256 userAmount = user.amount;\n        user.rewardSettled =\n            userAmount *\n            pool.accPointsPerShare /\n            1e18 +\n            user.rewardSettled -\n            user.rewardDebt;\n\n        // booster purchase proceeds\n        heldProceeds[_pid] = heldProceeds[_pid] + _boostAmount;\n\n        // deposit amount is reduced by amount of the deposit to boost\n        _depositAmount = _depositAmount - _boostAmount;\n\n        // set deposit amount\n        user.depositAmount = user.depositAmount + _depositAmount;\n        pool.depositAmount = pool.depositAmount + _depositAmount;\n\n        // apply the boost multiplier\n        _boostAmount = _boostAmount * boosterMultiplier / 1e18;\n\n        user.boostAmount = user.boostAmount + _boostAmount;\n        pool.boostAmount = pool.boostAmount + _boostAmount;\n\n        // userAmount is increased by remaining deposit amount + full boosted amount\n        userAmount = userAmount + _depositAmount + _boostAmount;\n\n        user.amount = userAmount;\n        pool.amount = pool.amount + _depositAmount + _boostAmount;\n\n        user.rewardDebt = userAmount *\n            pool.accPointsPerShare /\n            1e18;\n\n        emit Deposit(msg.sender, _pid, _depositAmount, _boostAmount);\n    }\n\n    /**\n     * @notice Increase boost from existing deposits\n     * @param _pid pid to pool\n     * @param _boostAmount amount to boost\n     */\n    function increaseBoost(uint256 _pid, uint256 _boostAmount) external {\n        if (isFarmingEnded()) {\n            revert FarmingIsEnded();\n        }\n\n        if (_boostAmount == 0) {\n            revert BoostIsZero();\n        }\n\n        uint256 maxAdditionalBoost = getMaxAdditionalBoost(msg.sender, _pid);\n        if (_boostAmount > maxAdditionalBoost) {\n            revert BoostTooHigh(maxAdditionalBoost);\n        }\n\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        updatePool(_pid);\n\n        uint256 userAmount = user.amount;\n        user.rewardSettled =\n            userAmount *\n            pool.accPointsPerShare /\n            1e18 +\n            user.rewardSettled -\n            user.rewardDebt;\n\n        // booster purchase proceeds\n        heldProceeds[_pid] = heldProceeds[_pid] + _boostAmount;\n\n        // user's remaining deposit is reduced by amount of the deposit to boost\n        user.depositAmount = user.depositAmount - _boostAmount;\n        pool.depositAmount = pool.depositAmount - _boostAmount;\n\n        // apply the multiplier\n        uint256 finalBoostAmount = _boostAmount * boosterMultiplier / 1e18;\n\n        user.boostAmount = user.boostAmount + finalBoostAmount;\n        pool.boostAmount = pool.boostAmount + finalBoostAmount;\n\n        // user amount is increased by the full boosted amount - deposit amount used to boost\n        userAmount = userAmount + finalBoostAmount - _boostAmount;\n\n        user.amount = userAmount;\n        pool.amount = pool.amount + finalBoostAmount - _boostAmount;\n\n        user.rewardDebt = userAmount *\n            pool.accPointsPerShare /\n            1e18;\n\n        emit IncreaseBoost(msg.sender, _pid, finalBoostAmount);\n    }\n\n    /**\n     * @notice Returns max additional boost amount allowed to boost current deposits\n     * @dev total allowed boost is 100% of total deposit\n     * @param _user user in pool\n     * @param _pid pid of pool\n     * @return uint256 max additional boost\n     */\n    function getMaxAdditionalBoost(address _user, uint256 _pid) public view returns (uint256) {\n        return userInfo[_pid][_user].depositAmount;\n    }\n\n    /**\n     * @notice Withdraw an asset to SophonFarming\n     * @param _pid pid of the withdraw\n     * @param _withdrawAmount amount of the withdraw\n     */\n    function withdraw(uint256 _pid, uint256 _withdrawAmount) external {\n        if (isWithdrawPeriodEnded()) {\n            revert WithdrawNotAllowed();\n        }\n        if (_withdrawAmount == 0) {\n            revert WithdrawIsZero();\n        }\n\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        updatePool(_pid);\n\n        uint256 userDepositAmount = user.depositAmount;\n\n        if (_withdrawAmount == type(uint256).max) {\n            _withdrawAmount = userDepositAmount;\n        } else if (_withdrawAmount > userDepositAmount) {\n            revert WithdrawTooHigh(userDepositAmount);\n        }\n\n        uint256 userAmount = user.amount;\n        user.rewardSettled =\n            userAmount *\n            pool.accPointsPerShare /\n            1e18 +\n            user.rewardSettled -\n            user.rewardDebt;\n\n        user.depositAmount = userDepositAmount - _withdrawAmount;\n        pool.depositAmount = pool.depositAmount - _withdrawAmount;\n\n        userAmount = userAmount - _withdrawAmount;\n\n        user.amount = userAmount;\n        pool.amount = pool.amount - _withdrawAmount;\n\n        pool.lpToken.safeTransfer(msg.sender, _withdrawAmount);\n\n        user.rewardDebt = userAmount *\n            pool.accPointsPerShare /\n            1e18;\n\n        emit Withdraw(msg.sender, _pid, _withdrawAmount);\n    }\n\n    /**\n     * @notice Permissionless function to allow anyone to bridge during the correct period\n     * @param _pid pid to bridge\n     */\n    function bridgePool(uint256 _pid) external {\n        if (!isFarmingEnded() || !isWithdrawPeriodEnded() || isBridged[_pid]) {\n            revert Unauthorized();\n        }\n\n        updatePool(_pid);\n        PoolInfo storage pool = poolInfo[_pid];\n\n        uint256 depositAmount = pool.depositAmount;\n        if (depositAmount == 0 || address(bridge) == address(0) || pool.l2Farm == address(0)) {\n            revert BridgeInvalid();\n        }\n\n        IERC20 lpToken = pool.lpToken;\n        lpToken.approve(address(bridge), depositAmount);\n\n        // TODO: change _refundRecipient, verify l2Farm, _l2TxGasLimit and _l2TxGasPerPubdataByte\n        // These are pending the launch of Sophon testnet\n        bridge.deposit(\n            pool.l2Farm,            // _l2Receiver\n            address(lpToken),       // _l1Token\n            depositAmount,          // _amount\n            200000,                 // _l2TxGasLimit\n            0,                      // _l2TxGasPerPubdataByte\n            owner()                 // _refundRecipient\n        );\n\n        isBridged[_pid] = true;\n\n        emit Bridge(msg.sender, _pid, depositAmount);\n    }\n\n    // TODO: does this function need to call claimFailedDeposit on the bridge?\n    // This is pending the launch of Sophon testnet\n    /**\n     * @notice Called by an admin if a bridge process to Sophon fails\n     * @param _pid pid of the failed bridge to revert\n     */\n    function revertFailedBridge(uint256 _pid) external onlyOwner {\n        isBridged[_pid] = false;\n    }\n\n    /**\n     * @notice Converts WETH to ETH\n     * @dev WETH withdrawl\n     * @param _amount in amount\n     * @return uint256 out amount\n     */\n    function _wethTOEth(uint256 _amount) internal returns (uint256) {\n        // unwrap weth to eth\n        IWeth(weth).withdraw(_amount);\n        return _amount;\n    }\n\n    /**\n     * @notice Converts ETH to stETH\n     * @dev Lido\n     * @param _amount in amount\n     * @return uint256 out amount\n     */\n    function _ethTOstEth(uint256 _amount) internal returns (uint256) {\n        // submit function does not return exact amount of stETH so we need to check balances\n        uint256 balanceBefore = IERC20(stETH).balanceOf(address(this));\n        IstETH(stETH).submit{value: _amount}(address(this));\n        return (IERC20(stETH).balanceOf(address(this)) - balanceBefore);\n    }\n\n    /**\n     * @notice Converts stETH to wstETH\n     * @dev Lido\n     * @param _amount in amount\n     * @return uint256 out amount\n     */\n    function _stEthTOwstEth(uint256 _amount) internal returns (uint256) {\n        // wrap returns exact amount of wstETH\n        return IwstETH(wstETH).wrap(_amount);\n    }\n\n    /**\n     * @notice Converts ETH to eETH\n     * @dev ether.fi\n     * @param _amount in amount\n     * @return uint256 out amount\n     */\n    function _ethTOeEth(uint256 _amount) internal returns (uint256) {\n        // deposit returns exact amount of eETH\n        return IeETHLiquidityPool(eETHLiquidityPool).deposit{value: _amount}(address(this));\n    }\n\n    /**\n     * @notice Converts eETH to weETH\n     * @dev ether.fi\n     * @param _amount in amount\n     * @return uint256 out amount\n     */\n    function _eethTOweEth(uint256 _amount) internal returns (uint256) {\n        // wrap returns exact amount of weETH\n        return IweETH(weETH).wrap(_amount);\n    }\n\n    /**\n     * @notice Converts DAI to sDAI\n     * @dev MakerDao\n     * @param _amount in amount\n     * @return uint256 out amount\n     */\n    function _daiTOsDai(uint256 _amount) internal returns (uint256) {\n        // deposit DAI to sDAI\n        return IsDAI(sDAI).deposit(_amount, address(this));\n    }\n\n    /**\n     * @notice Allows an admin to withdraw booster proceeds\n     * @param _pid pid to withdraw proceeds from\n     */\n    function withdrawProceeds(uint256 _pid) external onlyOwner {\n        PoolInfo storage pool = poolInfo[_pid];\n        uint256 _proceeds = heldProceeds[_pid];\n        heldProceeds[_pid] = 0;\n        pool.lpToken.safeTransfer(msg.sender, _proceeds);\n        emit WithdrawProceeds(_pid, _proceeds);\n    }\n\n    /**\n     * @notice Returns the current block number\n     * @dev Included to help with testing since it can be overridden for custom functionality\n     * @return uint256 current block number\n     */\n    function getBlockNumber() virtual public view returns (uint256) {\n        return block.number;\n    }\n\n    /**\n     * @notice Returns info about each pool\n     * @return poolInfos all pool info\n     */\n    function getPoolInfo() external view returns (PoolInfo[] memory poolInfos) {\n        uint256 length = poolInfo.length;\n        poolInfos = new PoolInfo[](length);\n        for(uint256 pid = 0; pid < length;) {\n            poolInfos[pid] = poolInfo[pid];\n            unchecked { ++pid; }\n        }\n    }\n\n    /**\n     * @notice Returns user info for a list of users\n     * @param _users list of users\n     * @return userInfos optimized user info\n     */\n    function getOptimizedUserInfo(address[] memory _users) external view returns (uint256[4][][] memory userInfos) {\n        userInfos = new uint256[4][][](_users.length);\n        uint256 len = poolInfo.length;\n        for(uint256 i = 0; i < _users.length;) {\n            address _user = _users[i];\n            userInfos[i] = new uint256[4][](len);\n            for(uint256 pid = 0; pid < len;) {\n                UserInfo memory uinfo = userInfo[pid][_user];\n                userInfos[i][pid][0] = uinfo.amount;\n                userInfos[i][pid][1] = uinfo.boostAmount;\n                userInfos[i][pid][2] = uinfo.depositAmount;\n                userInfos[i][pid][3] = _pendingPoints(pid, _user);\n                unchecked { ++pid; }\n            }\n            unchecked { i++; }\n        }\n    }\n\n    /**\n     * @notice Returns accrued points for a list of users\n     * @param _users list of users\n     * @return pendings accured points for user\n     */\n    function getPendingPoints(address[] memory _users) external view returns (uint256[][] memory pendings) {\n        pendings = new uint256[][](_users.length);\n        uint256 len = poolInfo.length;\n        for(uint256 i = 0; i < _users.length;) {\n            address _user = _users[i];\n            pendings[i] = new uint256[](len);\n            for(uint256 pid = 0; pid < len;) {\n                pendings[i][pid] = _pendingPoints(pid, _user);\n                unchecked { ++pid; }\n            }\n            unchecked { i++; }\n        }\n    }\n}"
    }
  ]
}