{
  "Title": "M-2: Vault can experience long downtime periods",
  "Content": "# Issue M-2: Vault can experience long downtime periods \n\nSource: https://github.com/sherlock-audit/2023-02-olympus-judging/issues/210 \n\n## Found by \nBahurum\n\n## Summary\nThe chainlink price could stay up to 24 hours (heartbeat period) outside the boundaries defined by `THRESHOLD` but within the chainlink deviation threshold. Deposits and withdrawals will not be possible during this period of time.\n\n## Vulnerability Detail\nThe `_isPoolSafe()` function checks if the balancer pool spot price is within the boundaries defined by `THRESHOLD` respect to the last fetched chainlink price. \n\nSince in `_valueCollateral()` the `updateThreshold` should be 24 hours (as in the tests), then the OHM derived oracle price could stay at up to 2% from the on-chain trusted price. The value is 2% because in [WstethLiquidityVault.sol#L223](https://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/WstethLiquidityVault.sol#L223):\n```solidity\nreturn (amount_ * stethPerWsteth * stethUsd * decimalAdjustment) / (ohmEth * ethUsd * 1e18);\n```\n`stethPerWsteth` is mostly stable and changes in `stethUsd` and `ethUsd` will cancel out, so the return value changes will be close to changes in `ohmEth`, so up to 2% from the on-chain trusted price.\n\nIf `THRESHOLD` < 2%, say 1% as in the tests, then the Chainlink price can deviate by more than 1% from the pool spot price and less than 2% from the on-chain trusted price fro up to 24 h. During this period withdrawals and deposits will revert.\n\n## Impact\nWithdrawals and deposits can be often unavailable for several hours.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L411-L421\n\n## Tool used\n\nManual Review\n\n## Recommendation\n`THRESHOLD` is not fixed and can be changed by the admin, meaning that it can take different values over time.Only a tight range of values around 2% should be allowed to avoid the scenario above.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/50",
  "Code": [
    {
      "filename": "src/policies/lending/WstethLiquidityVault.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// Import system dependencies\nimport \"src/Kernel.sol\";\nimport {SingleSidedLiquidityVault} from \"policies/lending/abstracts/SingleSidedLiquidityVault.sol\";\n\n// Import external dependencies\nimport {AggregatorV3Interface} from \"src/interfaces/AggregatorV2V3Interface.sol\";\nimport {JoinPoolRequest, ExitPoolRequest, IVault, IBasePool, IBalancerHelper} from \"policies/lending/interfaces/IBalancer.sol\";\nimport {IAuraBooster, IAuraRewardPool} from \"policies/lending/interfaces/IAura.sol\";\nimport {IWsteth} from \"policies/lending/interfaces/ILido.sol\";\n\n// Import types\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\n/// @title Olympus wstETH Single-Sided Liquidity Vault\ncontract WstethLiquidityVault is SingleSidedLiquidityVault {\n    // ========= EVENTS ========= //\n\n    event LiquidityVault_ExternalAccumulationError(address token);\n\n    // ========= DATA STRUCTURES ========= //\n\n    struct OracleFeed {\n        AggregatorV3Interface feed;\n        uint48 updateThreshold;\n    }\n\n    struct AuraPool {\n        uint256 pid;\n        IAuraBooster booster;\n        IAuraRewardPool rewardsPool;\n    }\n\n    // ========= STATE ========= //\n\n    // Balancer Contracts\n    IVault public vault;\n    IBalancerHelper public balancerHelper;\n\n    // Aura Pool Info\n    AuraPool public auraPool;\n\n    // Price Feeds\n    OracleFeed public ohmEthPriceFeed;\n    OracleFeed public ethUsdPriceFeed;\n    OracleFeed public stethUsdPriceFeed;\n\n    // Price Feed Decimals\n    uint32 public immutable ohmEthPriceFeedDecimals;\n    uint32 public immutable ethUsdPriceFeedDecimals;\n    uint32 public immutable stethUsdPriceFeedDecimals;\n\n    //============================================================================================//\n    //                                      POLICY SETUP                                          //\n    //============================================================================================//\n\n    constructor(\n        Kernel kernel_,\n        address ohm_,\n        address wsteth_,\n        address vault_,\n        address balancerHelper_,\n        address liquidityPool_,\n        OracleFeed memory ohmEthPriceFeed_,\n        OracleFeed memory ethUsdPriceFeed_,\n        OracleFeed memory stethUsdPriceFeed_,\n        AuraPool memory auraPool_\n    ) SingleSidedLiquidityVault(kernel_, ohm_, wsteth_, liquidityPool_) {\n        // Set Balancer vault\n        vault = IVault(vault_);\n        balancerHelper = IBalancerHelper(balancerHelper_);\n\n        // Set price feeds\n        ohmEthPriceFeed = ohmEthPriceFeed_;\n        ethUsdPriceFeed = ethUsdPriceFeed_;\n        stethUsdPriceFeed = stethUsdPriceFeed_;\n\n        // Set price feed decimals\n        ohmEthPriceFeedDecimals = ohmEthPriceFeed_.feed.decimals();\n        ethUsdPriceFeedDecimals = ethUsdPriceFeed_.feed.decimals();\n        stethUsdPriceFeedDecimals = stethUsdPriceFeed_.feed.decimals();\n\n        // Set Aura pool info\n        auraPool = auraPool_;\n\n        // Set exchange name\n        EXCHANGE = \"Balancer\";\n    }\n\n    //============================================================================================//\n    //                                   BASE OVERRIDE FUNCTIONS                                  //\n    //============================================================================================//\n\n    // ========= CORE FUNCTIONS ========= //\n\n    /// @notice                 Deposits OHM and wstETH into the Balancer pool. Deposits the received BPT into Aura to accrue rewards\n    /// @param ohmAmount_       Amount of OHM to deposit\n    /// @param pairAmount_      Amount of wstETH to deposit\n    /// @param slippageParam_   Minimum amount of BPT to receive (prior to staking into Aura)\n    /// @return uint256         Amount of BPT received\n    function _deposit(\n        uint256 ohmAmount_,\n        uint256 pairAmount_,\n        uint256 slippageParam_\n    ) internal override returns (uint256) {\n        // Cast pool address from abstract to Balancer Base Pool\n        IBasePool pool = IBasePool(liquidityPool);\n\n        // OHM-wstETH BPT before\n        uint256 bptBefore = pool.balanceOf(address(this));\n\n        // Build join pool request\n        address[] memory assets = new address[](2);\n        assets[0] = address(ohm);\n        assets[1] = address(pairToken);\n\n        uint256[] memory maxAmountsIn = new uint256[](2);\n        maxAmountsIn[0] = ohmAmount_;\n        maxAmountsIn[1] = pairAmount_;\n\n        JoinPoolRequest memory joinPoolRequest = JoinPoolRequest({\n            assets: assets,\n            maxAmountsIn: maxAmountsIn,\n            userData: abi.encode(1, maxAmountsIn, slippageParam_),\n            fromInternalBalance: false\n        });\n\n        // Join Balancer pool\n        ohm.approve(address(vault), ohmAmount_);\n        pairToken.approve(address(vault), pairAmount_);\n        vault.joinPool(pool.getPoolId(), address(this), address(this), joinPoolRequest);\n\n        // OHM-PAIR BPT after\n        uint256 lpAmountOut = pool.balanceOf(address(this)) - bptBefore;\n\n        // Stake into Aura\n        pool.approve(address(auraPool.booster), lpAmountOut);\n        auraPool.booster.deposit(auraPool.pid, lpAmountOut, true);\n\n        return lpAmountOut;\n    }\n\n    /// @notice                 Withdraws BPT from Aura. Exchanges BPT for OHM and wstETH to leave the Balancer pool\n    /// @param lpAmount_        Amount of BPT to withdraw\n    /// @param minTokenAmounts_ Minimum amounts of OHM and wstETH to receive ([OHM, wstETH])\n    /// @return uint256         Amount of OHM received\n    /// @return uint256         Amount of wstETH received\n    function _withdraw(uint256 lpAmount_, uint256[] calldata minTokenAmounts_)\n        internal\n        override\n        returns (uint256, uint256)\n    {\n        // Cast pool adress from abstract to Balancer Base Pool\n        IBasePool pool = IBasePool(liquidityPool);\n\n        // OHM and pair token amounts before\n        uint256 ohmBefore = ohm.balanceOf(address(this));\n        uint256 pairTokenBefore = pairToken.balanceOf(address(this));\n\n        // Build exit pool request\n        address[] memory assets = new address[](2);\n        assets[0] = address(ohm);\n        assets[1] = address(pairToken);\n\n        ExitPoolRequest memory exitPoolRequest = ExitPoolRequest({\n            assets: assets,\n            minAmountsOut: minTokenAmounts_,\n            userData: abi.encode(1, lpAmount_),\n            toInternalBalance: false\n        });\n\n        // Unstake from Aura\n        auraPool.rewardsPool.withdrawAndUnwrap(lpAmount_, false);\n\n        // Exit Balancer pool\n        pool.approve(address(vault), lpAmount_);\n        vault.exitPool(pool.getPoolId(), address(this), payable(address(this)), exitPoolRequest);\n\n        // OHM and pair token amounts received\n        uint256 ohmReceived = ohm.balanceOf(address(this)) - ohmBefore;\n        uint256 pairTokenReceived = pairToken.balanceOf(address(this)) - pairTokenBefore;\n\n        return (ohmReceived, pairTokenReceived);\n    }\n\n    // ========= REWARDS FUNCTIONS ========= //\n\n    /// @notice                 Harvests rewards from Aura\n    /// @return uint256[]       Amounts of each reward token harvested\n    function _accumulateExternalRewards() internal override returns (uint256[] memory) {\n        uint256 numExternalRewards = externalRewardTokens.length;\n\n        auraPool.rewardsPool.getReward(address(this), true);\n\n        uint256[] memory rewards = new uint256[](numExternalRewards);\n        for (uint256 i; i < numExternalRewards; ) {\n            ExternalRewardToken storage rewardToken = externalRewardTokens[i];\n            uint256 newBalance = ERC20(rewardToken.token).balanceOf(address(this));\n\n            // This shouldn't happen but adding a sanity check in case\n            if (newBalance < rewardToken.lastBalance) {\n                emit LiquidityVault_ExternalAccumulationError(rewardToken.token);\n                continue;\n            }\n\n            rewards[i] = newBalance - rewardToken.lastBalance;\n            rewardToken.lastBalance = newBalance;\n\n            unchecked {\n                ++i;\n            }\n        }\n        return rewards;\n    }\n\n    // ========= UTILITY FUNCTIONS ========= //\n\n    /// @notice                 Calculates the OHM equivalent quantity for the wstETH deposit\n    /// @param amount_          Amount of wstETH to calculate OHM equivalent for\n    /// @return uint256         OHM equivalent quantity\n    function _valueCollateral(uint256 amount_) public view override returns (uint256) {\n        uint256 stethPerWsteth = IWsteth(address(pairToken)).stEthPerToken();\n\n        // This is returned in 18 decimals and represents ETH per OHM\n        uint256 ohmEth = _validatePrice(\n            address(ohmEthPriceFeed.feed),\n            uint256(ohmEthPriceFeed.updateThreshold)\n        );\n\n        // This is returned in 8 decimals and represents USD per ETH\n        uint256 ethUsd = _validatePrice(\n            address(ethUsdPriceFeed.feed),\n            uint256(ethUsdPriceFeed.updateThreshold)\n        );\n\n        // This is returned in 8 decimals and represents USD per stETH\n        uint256 stethUsd = _validatePrice(\n            address(stethUsdPriceFeed.feed),\n            uint256(stethUsdPriceFeed.updateThreshold)\n        );\n\n        // Amount is 18 decimals in the case of wstETH and OHM has 9 decimals so to get a result with 9\n        // decimals we need to use this decimal adjustment\n        uint8 ohmDecimals = 9;\n        uint256 decimalAdjustment = 10 **\n            (ohmEthPriceFeedDecimals +\n                ethUsdPriceFeedDecimals +\n                ohmDecimals -\n                stethUsdPriceFeedDecimals -\n                pairTokenDecimals);\n\n        return (amount_ * stethPerWsteth * stethUsd * decimalAdjustment) / (ohmEth * ethUsd * 1e18);\n    }\n\n    /// @notice                 Calculates the prevailing OHM/wstETH ratio of the Balancer pool\n    /// @return uint256         OHM/wstETH ratio\n    function _getPoolPrice() internal view override returns (uint256) {\n        (, uint256[] memory balances_, ) = vault.getPoolTokens(\n            IBasePool(liquidityPool).getPoolId()\n        );\n\n        // In Balancer pools the tokens are listed in alphabetical order (numbers before letters)\n        // OHM is listed first, wstETH is listed second so this calculates OHM/wstETH which is then\n        // used to compare against the oracle calculation OHM/wstETH price\n        // Hard coding decimals is fine here because it is a specific implementation and we know the\n        // decimals of the tokens in the pool\n        return (balances_[0] * 1e18) / balances_[1];\n    }\n\n    /// @notice                 Calculates the vault's claim on OHM in the Balancer pool\n    /// @return uint256         OHM claim\n    function _getPoolOhmShare() internal view override returns (uint256) {\n        // Cast pool address from abstract to Balancer Base Pool\n        IBasePool pool = IBasePool(liquidityPool);\n\n        (, uint256[] memory balances_, ) = vault.getPoolTokens(pool.getPoolId());\n        uint256 bptTotalSupply = pool.totalSupply();\n\n        if (totalLP == 0) return 0;\n        else return (balances_[0] * totalLP) / bptTotalSupply;\n    }\n\n    //============================================================================================//\n    //                                      VIEW FUNCTIONS                                        //\n    //============================================================================================//\n\n    /// @notice                 Calculates the expected amount of Balancer Pool Tokens that would be received\n    ///                         for depositing a certain amount of wstETH\n    /// @param amount_          Amount of wstETH to calculate BPT for\n    /// @return bptAmount       Amount of BPT that would be received\n    /// @dev                    This function is not meant to be called within a transaction and it will always revert.\n    ///                         It is meant to be called off-chain (by the frontend) using a call request.\n    function getExpectedLPAmount(uint256 amount_) public override returns (uint256 bptAmount) {\n        // Cast pool address from abstract to Balancer Base pool\n        IBasePool pool = IBasePool(liquidityPool);\n\n        // Get amount of OHM that would be borrowed\n        uint256 ohmAmount = _valueCollateral(amount_);\n\n        // Build join pool request\n        address[] memory assets = new address[](2);\n        assets[0] = address(ohm);\n        assets[1] = address(pairToken);\n\n        uint256[] memory maxAmountsIn = new uint256[](2);\n        maxAmountsIn[0] = ohmAmount;\n        maxAmountsIn[1] = amount_;\n\n        JoinPoolRequest memory joinPoolRequest = JoinPoolRequest({\n            assets: assets,\n            maxAmountsIn: maxAmountsIn,\n            userData: abi.encode(1, maxAmountsIn, 0),\n            fromInternalBalance: false\n        });\n\n        (bptAmount, ) = balancerHelper.queryJoin(\n            pool.getPoolId(),\n            address(this),\n            address(this),\n            joinPoolRequest\n        );\n    }\n\n    function getUserWstethShare(address user_) internal view returns (uint256) {\n        // Cast pool address from abstract to Balancer Base pool\n        IBasePool pool = IBasePool(liquidityPool);\n\n        // Get user's LP balance\n        uint256 userLpBalance = lpPositions[user_];\n\n        (, uint256[] memory balances_, ) = vault.getPoolTokens(pool.getPoolId());\n        uint256 bptTotalSupply = pool.totalSupply();\n        return (balances_[1] * userLpBalance) / bptTotalSupply;\n    }\n\n    //============================================================================================//\n    //                                      ADMIN FUNCTIONS                                       //\n    //============================================================================================//\n\n    /// @notice                 Updates the minimum update frequency for each price feed needed for it to not be considered stale\n    function changeUpdateThresholds(\n        uint48 ohmEthPriceFeedUpdateThreshold_,\n        uint48 ethUsdPriceFeedUpdateThreshold_,\n        uint48 stethUsdPriceFeedUpdateThreshold_\n    ) external onlyRole(\"liquidityvault_admin\") {\n        ohmEthPriceFeed.updateThreshold = ohmEthPriceFeedUpdateThreshold_;\n        ethUsdPriceFeed.updateThreshold = ethUsdPriceFeedUpdateThreshold_;\n        stethUsdPriceFeed.updateThreshold = stethUsdPriceFeedUpdateThreshold_;\n    }\n\n    /// @notice                 Rescue funds from Aura in the event the contract was shut off due to a bug\n    /// @dev                    This function can only be accessed by the liquidityvault_admin role and only when\n    ///                         the vault is deactivated. This acts as an emergency migration function in the event\n    ///                         that the vault is compromised.\n    function rescueFundsFromAura() external onlyRole(\"liquidityvault_admin\") {\n        if (isVaultActive) revert LiquidityVault_StillActive();\n\n        uint256 auraBalance = auraPool.rewardsPool.balanceOf(address(this));\n        auraPool.rewardsPool.withdrawAndUnwrap(auraBalance, false);\n    }\n}"
    },
    {
      "filename": "src/policies/lending/abstracts/SingleSidedLiquidityVault.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// Import system dependencies\nimport {MINTRv1} from \"src/modules/MINTR/MINTR.v1.sol\";\nimport {LQREGv1} from \"src/modules/LQREG/LQREG.v1.sol\";\nimport {ROLESv1, RolesConsumer} from \"src/modules/ROLES/OlympusRoles.sol\";\nimport \"src/Kernel.sol\";\n\n// Import external dependencies\nimport {AggregatorV3Interface} from \"src/interfaces/AggregatorV2V3Interface.sol\";\n\n// Import internal dependencies\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\n// Import types\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {OlympusERC20Token} from \"src/external/OlympusERC20.sol\";\n\n// Import utilities\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\n\n/// @title  Olympus Base Single Sided Liquidity Vault Contract\n/// @dev    Some caveats around this contract:\n///         - No internal reward token should also be an external reward token\n///         - No pair token should also be an external reward token\n///         - No pair, internal reward, or external reward tokens should be ERC777s or non-standard ERC20s\nabstract contract SingleSidedLiquidityVault is Policy, ReentrancyGuard, RolesConsumer {\n    using TransferHelper for ERC20;\n\n    // ========= ERRORS ========= //\n\n    error LiquidityVault_Inactive();\n    error LiquidityVault_StillActive();\n    error LiquidityVault_LimitViolation();\n    error LiquidityVault_PoolImbalanced();\n    error LiquidityVault_BadPriceFeed();\n    error LiquidityVault_InvalidRemoval();\n    error LiquidityVault_InvalidParams();\n\n    // ========= EVENTS ========= //\n\n    event Deposit(address indexed user, uint256 pairAmount, uint256 ohmMinted);\n    event Withdraw(address indexed user, uint256 pairAmount, uint256 ohmBurned);\n    event RewardsClaimed(address indexed user, address indexed token, uint256 amount);\n\n    // ========= DATA STRUCTURES ========= //\n\n    struct InternalRewardToken {\n        address token;\n        uint256 decimalsAdjustment;\n        uint256 rewardsPerSecond;\n        uint256 lastRewardTime;\n        uint256 accumulatedRewardsPerShare;\n    }\n\n    struct ExternalRewardToken {\n        address token;\n        uint256 decimalsAdjustment;\n        uint256 accumulatedRewardsPerShare;\n        uint256 lastBalance;\n    }\n\n    // ========= STATE ========= //\n\n    // Modules\n    MINTRv1 public MINTR;\n    LQREGv1 public LQREG;\n\n    // Tokens\n    OlympusERC20Token public ohm;\n    ERC20 public pairToken;\n\n    // Token Decimals\n    uint256 public pairTokenDecimals;\n\n    // Pool\n    address public liquidityPool;\n\n    // Aggregate Contract State\n    uint256 public totalLP;\n    uint256 public ohmMinted;\n    uint256 public ohmRemoved;\n    mapping(address => uint256) public accumulatedFees;\n\n    // User State\n    mapping(address => uint256) public pairTokenDeposits;\n    mapping(address => uint256) public lpPositions;\n    mapping(address => mapping(address => uint256)) public userRewardDebts; // Rewards accumulated prior to user's joining (MasterChef V2 math)\n    mapping(address => mapping(address => uint256)) public cachedUserRewards; // Rewards that have been accumulated but not claimed (avoids underflow errors)\n    mapping(address => bool) internal _hasDeposited; // Used to determine if a user has ever deposited\n    address[] public users; // Used to track users that have interacted with this contract (for migration in the event of a bug)\n\n    // Reward Token State\n    /// @notice An internal reward token is a token where the vault is the only source of rewards and the\n    ///         vault handles all accounting around how many reward tokens to distribute over time\n    InternalRewardToken[] public internalRewardTokens;\n\n    /// @notice An external reward token is a token where the primary accrual of reward tokens occurs outside\n    ///         the scope of this contract in a system like Convex or Aura. The vault is responsible for harvesting\n    ///         rewards back to the vault and then distributing them proportionally to users\n    ExternalRewardToken[] public externalRewardTokens;\n\n    // Exchange Name (used by frontend)\n    string public EXCHANGE;\n\n    // Configuration values\n    uint256 public LIMIT;\n    uint256 public THRESHOLD;\n    uint256 public FEE;\n    uint256 public constant PRECISION = 1000;\n    bool public isVaultActive;\n\n    //============================================================================================//\n    //                                      POLICY SETUP                                          //\n    //============================================================================================//\n\n    constructor(\n        Kernel kernel_,\n        address ohm_,\n        address pairToken_,\n        address liquidityPool_\n    ) Policy(kernel_) {\n        // Set tokens\n        ohm = OlympusERC20Token(ohm_);\n        pairToken = ERC20(pairToken_);\n\n        // Set token decimals\n        pairTokenDecimals = pairToken.decimals();\n\n        // Set pool\n        liquidityPool = liquidityPool_;\n    }\n\n    /// @inheritdoc Policy\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](3);\n        dependencies[0] = toKeycode(\"MINTR\");\n        dependencies[1] = toKeycode(\"LQREG\");\n        dependencies[2] = toKeycode(\"ROLES\");\n\n        MINTR = MINTRv1(getModuleAddress(dependencies[0]));\n        LQREG = LQREGv1(getModuleAddress(dependencies[1]));\n        ROLES = ROLESv1(getModuleAddress(dependencies[2]));\n    }\n\n    /// @inheritdoc Policy\n    function requestPermissions()\n        external\n        view\n        override\n        returns (Permissions[] memory permissions)\n    {\n        Keycode mintrKeycode = MINTR.KEYCODE();\n        Keycode lqregKeycode = LQREG.KEYCODE();\n\n        permissions = new Permissions[](5);\n        permissions[0] = Permissions(mintrKeycode, MINTR.mintOhm.selector);\n        permissions[1] = Permissions(mintrKeycode, MINTR.burnOhm.selector);\n        permissions[2] = Permissions(mintrKeycode, MINTR.increaseMintApproval.selector);\n        permissions[3] = Permissions(lqregKeycode, LQREG.addVault.selector);\n        permissions[4] = Permissions(lqregKeycode, LQREG.removeVault.selector);\n    }\n\n    //============================================================================================//\n    //                                           MODIFIERS                                        //\n    //============================================================================================//\n\n    modifier onlyWhileActive() {\n        if (!isVaultActive) revert LiquidityVault_Inactive();\n        _;\n    }\n\n    //============================================================================================//\n    //                                       CORE FUNCTIONS                                       //\n    //============================================================================================//\n\n    /// @notice                 Deposits pair tokens, mints OHM against the deposited pair tokens, and deposits the\n    ///                         pair token and OHM into a liquidity pool and receives LP tokens in return\n    /// @param  amount_         The amount of pair tokens to deposit\n    /// @param  slippageParam_  Represents the slippage on joining the liquidity pool. Can either be the minimum LP token\n    ///                         amount to receive in the cases of Balancer or Curve, or can be a value (in thousandths) which\n    ///                         will be used to calculate the minimum amount of OHM and pair tokens to use in the case of Uniswap,\n    ///                         Sushiswap, Fraxswap, etc.\n    /// @dev                    This needs to be non-reentrant since the contract only knows the amount of LP tokens it\n    ///                         receives after an external interaction with the liquidity pool\n    function deposit(uint256 amount_, uint256 slippageParam_)\n        external\n        onlyWhileActive\n        nonReentrant\n        returns (uint256 lpAmountOut)\n    {\n        // If this is a new user, add them to the users array in case we need to migrate\n        // their state in the future\n        if (!_hasDeposited[msg.sender]) {\n            _hasDeposited[msg.sender] = true;\n            users.push(msg.sender);\n        }\n\n        // Calculate amount of OHM to borrow\n        uint256 ohmToBorrow = _valueCollateral(amount_);\n\n        // Cache pair token and OHM balance before deposit\n        uint256 pairTokenBalanceBefore = pairToken.balanceOf(address(this));\n        uint256 ohmBalanceBefore = ohm.balanceOf(address(this));\n\n        // The pool being imbalanced is less of a concern here on deposit than on withdrawal,\n        // but in the event the frontend miscalculates the expected LP amount to receive, we want\n        // to reduce the risk of entering a manipulated pool at a bad price\n        if (!_isPoolSafe()) revert LiquidityVault_PoolImbalanced();\n        if (!_canDeposit(ohmToBorrow)) revert LiquidityVault_LimitViolation();\n\n        _depositUpdateRewardState();\n\n        // Gather tokens for deposit\n        pairToken.safeTransferFrom(msg.sender, address(this), amount_);\n        _borrow(ohmToBorrow);\n\n        uint256 lpReceived = _deposit(ohmToBorrow, amount_, slippageParam_);\n\n        // Calculate amount of pair tokens and OHM unused in deposit\n        uint256 unusedPairToken = pairToken.balanceOf(address(this)) - pairTokenBalanceBefore;\n        uint256 unusedOhm = ohm.balanceOf(address(this)) - ohmBalanceBefore;\n\n        // Return unused pair tokens to user\n        if (unusedPairToken > 0) pairToken.safeTransfer(msg.sender, unusedPairToken);\n\n        // Burn unused OHM\n        if (unusedOhm > 0) _repay(unusedOhm);\n\n        uint256 pairTokenUsed = amount_ - unusedPairToken;\n        uint256 ohmUsed = ohmToBorrow - unusedOhm;\n\n        ohmMinted += ohmUsed;\n        totalLP += lpReceived;\n\n        pairTokenDeposits[msg.sender] += pairTokenUsed;\n        lpPositions[msg.sender] += lpReceived;\n\n        // Update user's reward debts\n        _depositUpdateRewardDebts(lpReceived);\n\n        emit Deposit(msg.sender, pairTokenUsed, ohmUsed);\n    }\n\n    /// @notice                     Withdraws pair tokens and OHM from a liquidity pool, returns any received pair tokens to the\n    ///                             user, and burns any received OHM\n    /// @param  lpAmount_           The amount of LP tokens to withdraw\n    /// @param  minTokenAmounts_    The minimum amounts of pair tokens and OHM to receive\n    /// @dev                        This needs to be non-reentrant since the contract only knows the amount of OHM and\n    ///                             pair tokens it receives after an external call to withdraw liquidity\n    function withdraw(\n        uint256 lpAmount_,\n        uint256[] calldata minTokenAmounts_,\n        bool claim_\n    ) external onlyWhileActive nonReentrant returns (uint256) {\n        // Liquidity vaults should always be built around a two token pool so we can assume\n        // the array will always have two elements\n        if (lpAmount_ == 0 || minTokenAmounts_[0] == 0 || minTokenAmounts_[1] == 0)\n            revert LiquidityVault_InvalidParams();\n        if (!_isPoolSafe()) revert LiquidityVault_PoolImbalanced();\n\n        _withdrawUpdateRewardState(lpAmount_, claim_);\n\n        totalLP -= lpAmount_;\n        lpPositions[msg.sender] -= lpAmount_;\n\n        // Withdraw OHM and pairToken from LP\n        (uint256 ohmReceived, uint256 pairTokenReceived) = _withdraw(lpAmount_, minTokenAmounts_);\n\n        // Reduce deposit values\n        uint256 userDeposit = pairTokenDeposits[msg.sender];\n        pairTokenDeposits[msg.sender] -= pairTokenReceived > userDeposit\n            ? userDeposit\n            : pairTokenReceived;\n        ohmMinted -= ohmReceived > ohmMinted ? ohmMinted : ohmReceived;\n        ohmRemoved += ohmReceived > ohmMinted ? ohmReceived - ohmMinted : 0;\n\n        // Return assets\n        _repay(ohmReceived);\n        pairToken.safeTransfer(msg.sender, pairTokenReceived);\n\n        emit Withdraw(msg.sender, pairTokenReceived, ohmReceived);\n        return pairTokenReceived;\n    }\n\n    /// @notice                     Claims user's rewards for all reward tokens\n    function claimRewards() external onlyWhileActive nonReentrant {\n        uint256 numInternalRewardTokens = internalRewardTokens.length;\n        uint256 numExternalRewardTokens = externalRewardTokens.length;\n\n        uint256[] memory accumulatedRewards = _accumulateExternalRewards();\n\n        for (uint256 i; i < numInternalRewardTokens; ) {\n            _claimInternalRewards(i);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        for (uint256 i; i < numExternalRewardTokens; ) {\n            _updateExternalRewardState(i, accumulatedRewards[i]);\n            _claimExternalRewards(i);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    //============================================================================================//\n    //                                       VIEW FUNCTIONS                                       //\n    //============================================================================================//\n\n    /// @notice                         Gets the max amount of pair tokens that can be deposited currently\n    /// @return uint256                 The max amount of pair tokens that can be deposited currently\n    function getMaxDeposit() public view returns (uint256) {\n        uint256 currentPoolOhmShare = _getPoolOhmShare();\n        uint256 emitted;\n\n        // Calculate max OHM mintable amount\n        if (ohmMinted > currentPoolOhmShare) emitted = ohmMinted - currentPoolOhmShare;\n        uint256 maxOhmAmount = LIMIT + ohmRemoved - ohmMinted - emitted;\n\n        // Convert max OHM mintable amount to pair token amount\n        uint256 ohmPerPairToken = _valueCollateral(1e18); // OHM per 1 pairToken\n        uint256 pairTokenDecimalAdjustment = 10**pairToken.decimals();\n        return (maxOhmAmount * pairTokenDecimalAdjustment) / ohmPerPairToken;\n    }\n\n    /// @notice                         Gets all users that have deposited into the vault\n    /// @return address[]               An array of all users that have deposited into the vault\n    function getUsers() public view returns (address[] memory) {\n        return users;\n    }\n\n    /// @notice                         Gets a list of all the internal reward tokens\n    /// @return InternalRewardToken[]   An array of all the internal reward tokens\n    function getInternalRewardTokens() public view returns (InternalRewardToken[] memory) {\n        return internalRewardTokens;\n    }\n\n    /// @notice                         Gets a list of all the external reward tokens\n    /// @return ExternalRewardToken[]   An array of all the external reward tokens\n    function getExternalRewardTokens() public view returns (ExternalRewardToken[] memory) {\n        return externalRewardTokens;\n    }\n\n    /// @notice                         Returns the amount of rewards a user has earned for a given reward token\n    /// @param  id_                     The ID of the reward token\n    /// @param  user_                   The user's address to check rewards for\n    /// @return uint256                 The amount of rewards the user has earned\n    function internalRewardsForToken(uint256 id_, address user_) public view returns (uint256) {\n        InternalRewardToken memory rewardToken = internalRewardTokens[id_];\n        uint256 lastRewardTime = rewardToken.lastRewardTime;\n        uint256 accumulatedRewardsPerShare = rewardToken.accumulatedRewardsPerShare;\n\n        if (block.timestamp > lastRewardTime && totalLP != 0) {\n            uint256 timeDiff = block.timestamp - lastRewardTime;\n            uint256 totalRewards = timeDiff * rewardToken.rewardsPerSecond;\n\n            // This correctly uses 1e18 because the LP tokens of all major DEXs have 18 decimals\n            accumulatedRewardsPerShare += (totalRewards * 1e18) / totalLP;\n        }\n\n        // This correctly uses 1e18 because the LP tokens of all major DEXs have 18 decimals\n        uint256 totalAccumulatedRewards = (lpPositions[user_] * accumulatedRewardsPerShare) -\n            userRewardDebts[user_][rewardToken.token];\n\n        return (cachedUserRewards[user_][rewardToken.token] + totalAccumulatedRewards) / 1e18;\n    }\n\n    /// @notice                         Returns the amount of rewards a user has earned for a given external reward token\n    /// @param  id_                     The ID of the external reward token\n    /// @param  user_                   The user's address to check rewards for\n    /// @return uint256                 The amount of rewards the user has earned\n    function externalRewardsForToken(uint256 id_, address user_) public view returns (uint256) {\n        ExternalRewardToken memory rewardToken = externalRewardTokens[id_];\n\n        // This correctly uses 1e18 because the LP tokens of all major DEXs have 18 decimals\n        uint256 totalAccumulatedRewards = (lpPositions[user_] *\n            rewardToken.accumulatedRewardsPerShare) - userRewardDebts[user_][rewardToken.token];\n\n        return (cachedUserRewards[user_][rewardToken.token] + totalAccumulatedRewards) / 1e18;\n    }\n\n    /// @notice                         Calculates the net amount of OHM that this contract has emitted to or removed from the broader market\n    /// @return emitted                 The amount of OHM that"
    }
  ]
}