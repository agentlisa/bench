{
  "Title": "[L08] Getter for REP total theoretical supply may be inaccurate",
  "Content": "The `ReputationToken` contract implements the [`getTotalTheoreticalSupply`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L164) [public getter function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L164) to retrieve the value of the token’s [totalTheoreticalSuppy](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L24). While the `totalTheoreticalSuppy` is a [fixed value in the genesis universe](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L154-L155), it is [variable in a child universe whose parent universe fork is already finished](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L156-L157). However, for the `totalTheoreticalSupply` to change, the [`updateTotalTheoreticalSupply`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L153) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L153) must be manually called. Therefore, if the total supply of REP tokens has changed over a period of time during which the `updateTotalTheoreticalSupply` function was never called, the value returned by the `getTotalTheoreticalSupply` function will be outdated and potentially inaccurate.\n\n\nConsider implementing a more general approach to always keep in sync the `totalTheoreticalSupply` with the total supply of REP tokens in a child universe whose parent’s fork has already finished, as described in the reported **“[L09] System relies on off-chain clients calling unrestricted functions to stay up-to-date”** issue. For this case in particular, the `updateTotalTheoreticalSupply` function could be called before returning the `totalTheoreticalSupply` inside the `getTotalTheoreticalSupply` function.\n\n\n***Update****: fixed in* [*`48744d6`*](https://github.com/AugurProject/augur/commit/48744d6948c017dff747cf58e9efba2b6681b43e) *. The* *`getTotalTheoreticalSupply`* *function now calculates and returns the updated value of the total theoretical supply of REP tokens.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/augur-core/source/contracts/reporting/ReputationToken.sol",
      "content": "pragma solidity 0.5.4;\n\nimport 'ROOT/libraries/IERC820Registry.sol';\nimport 'ROOT/reporting/IV2ReputationToken.sol';\nimport 'ROOT/libraries/ITyped.sol';\nimport 'ROOT/libraries/token/VariableSupplyToken.sol';\nimport 'ROOT/libraries/token/ERC20Token.sol';\nimport 'ROOT/reporting/IUniverse.sol';\nimport 'ROOT/reporting/IMarket.sol';\nimport 'ROOT/reporting/Reporting.sol';\nimport 'ROOT/reporting/IDisputeWindow.sol';\nimport 'ROOT/reporting/IDisputeCrowdsourcer.sol';\nimport 'ROOT/libraries/math/SafeMathUint256.sol';\n\n\ncontract ReputationToken is ITyped, VariableSupplyToken, IV2ReputationToken {\n    using SafeMathUint256 for uint256;\n\n    string constant public name = \"Reputation\";\n    string constant public symbol = \"REP\";\n    IUniverse internal universe;\n    IUniverse internal parentUniverse;\n    uint256 internal totalMigrated;\n    uint256 internal totalTheoreticalSupply;\n    ERC20Token public legacyRepToken;\n    IAugur public augur;\n\n    constructor(IAugur _augur, IUniverse _universe, IUniverse _parentUniverse, address _erc820RegistryAddress) public {\n        require(_universe != IUniverse(0));\n        augur = _augur;\n        universe = _universe;\n        parentUniverse = _parentUniverse;\n        legacyRepToken = ERC20Token(augur.lookup(\"LegacyReputationToken\"));\n        updateTotalTheoreticalSupply();\n        erc820Registry = IERC820Registry(_erc820RegistryAddress);\n        initialize820InterfaceImplementations();\n    }\n\n    function migrateOutByPayout(uint256[] memory _payoutNumerators, uint256 _attotokens) public returns (bool) {\n        require(_attotokens > 0);\n        IUniverse _destinationUniverse = universe.createChildUniverse(_payoutNumerators);\n        IReputationToken _destination = _destinationUniverse.getReputationToken();\n        burn(msg.sender, _attotokens);\n        _destination.migrateIn(msg.sender, _attotokens);\n        return true;\n    }\n\n    function migrateOut(IReputationToken _destination, uint256 _attotokens) public returns (bool) {\n        require(_attotokens > 0);\n        assertReputationTokenIsLegitSibling(_destination);\n        burn(msg.sender, _attotokens);\n        _destination.migrateIn(msg.sender, _attotokens);\n        return true;\n    }\n\n    function migrateIn(address _reporter, uint256 _attotokens) public returns (bool) {\n        IUniverse _parentUniverse = universe.getParentUniverse();\n        require(ReputationToken(msg.sender) == _parentUniverse.getReputationToken());\n        require(augur.getTimestamp() < _parentUniverse.getForkEndTime());\n        mint(_reporter, _attotokens);\n        totalMigrated += _attotokens;\n        // Update the fork tenative winner and finalize if we can\n        if (!_parentUniverse.getForkingMarket().isFinalized()) {\n            _parentUniverse.updateTentativeWinningChildUniverse(universe.getParentPayoutDistributionHash());\n        }\n        return true;\n    }\n\n    function mintForReportingParticipant(uint256 _amountMigrated) public returns (bool) {\n        IUniverse _parentUniverse = universe.getParentUniverse();\n        IReportingParticipant _reportingParticipant = IReportingParticipant(msg.sender);\n        require(_parentUniverse.isContainerForReportingParticipant(_reportingParticipant));\n        uint256 _bonus = _amountMigrated.mul(2) / 5;\n        mint(address(_reportingParticipant), _bonus);\n        return true;\n    }\n\n    function mintForAuction(uint256 _amountToMint) public returns (bool) {\n        require(universe.getAuction() == IAuction(msg.sender));\n        mint(msg.sender, _amountToMint);\n        return true;\n    }\n\n    function burnForAuction(uint256 _amountToBurn) public returns (bool) {\n        require(universe.getAuction() == IAuction(msg.sender));\n        burn(msg.sender, _amountToBurn);\n        return true;\n    }\n\n    function burnForMarket(uint256 _amountToBurn) public returns (bool) {\n        require(universe.isContainerForMarket(IMarket(msg.sender)));\n        burn(msg.sender, _amountToBurn);\n        return true;\n    }\n\n    function transfer(address _to, uint _value) public returns (bool) {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function trustedUniverseTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(IUniverse(msg.sender) == universe);\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function trustedMarketTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(universe.isContainerForMarket(IMarket(msg.sender)));\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function trustedReportingParticipantTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(universe.isContainerForReportingParticipant(IReportingParticipant(msg.sender)));\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function trustedAuctionTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(universe.getAuction() == (IAuction(msg.sender)));\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function trustedDisputeWindowTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(universe.isContainerForDisputeWindow(IDisputeWindow(msg.sender)));\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function assertReputationTokenIsLegitSibling(IReputationToken _shadyReputationToken) private view returns (bool) {\n        IUniverse _shadyUniverse = _shadyReputationToken.getUniverse();\n        require(universe.isParentOf(_shadyUniverse));\n        IUniverse _legitUniverse = _shadyUniverse;\n        require(_legitUniverse.getReputationToken() == _shadyReputationToken);\n        return true;\n    }\n\n    function getTypeName() public view returns (bytes32) {\n        return \"ReputationToken\";\n    }\n\n    function getUniverse() public view returns (IUniverse) {\n        return universe;\n    }\n\n    function getTotalMigrated() public view returns (uint256) {\n        return totalMigrated;\n    }\n\n    function getLegacyRepToken() public view returns (ERC20Token) {\n        return legacyRepToken;\n    }\n\n    function updateTotalTheoreticalSupply() public returns (bool) {\n        if (parentUniverse == IUniverse(0)) {\n            totalTheoreticalSupply = Reporting.getInitialREPSupply();\n        } else if (augur.getTimestamp() >= parentUniverse.getForkEndTime()) {\n            totalTheoreticalSupply = totalSupply();\n        } else {\n            totalTheoreticalSupply = totalSupply() + parentUniverse.getReputationToken().totalSupply();\n        }\n        return true;\n    }\n\n    function getTotalTheoreticalSupply() public view returns (uint256) {\n        return totalTheoreticalSupply;\n    }\n\n    function onTokenTransfer(address _from, address _to, uint256 _value) internal returns (bool) {\n        augur.logReputationTokensTransferred(universe, _from, _to, _value, balances[_from], balances[_to]);\n        return true;\n    }\n\n    function onMint(address _target, uint256 _amount) internal returns (bool) {\n        augur.logReputationTokensMinted(universe, _target, _amount, totalSupply());\n        return true;\n    }\n\n    function onBurn(address _target, uint256 _amount) internal returns (bool) {\n        augur.logReputationTokensBurned(universe, _target, _amount, totalSupply());\n        return true;\n    }\n\n    function migrateFromLegacyReputationToken() public returns (bool) {\n        uint256 _legacyBalance = legacyRepToken.balanceOf(msg.sender);\n        require(legacyRepToken.transferFrom(msg.sender, address(0), _legacyBalance));\n        mint(msg.sender, _legacyBalance);\n        return true;\n    }\n}"
    }
  ]
}