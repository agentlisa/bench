{
  "Title": "Temporary denial-of-service when in-flight messages are not executed before a deprecated Wormhole Guardian set expires",
  "Content": "**Description:** Wormhole exposes a governance action in [`Governance::submitNewGuardianSet`](https://github.com/wormhole-foundation/wormhole/blob/eee4641f55954d2d0db47831688a2e97eb20f7ee/ethereum/contracts/Governance.sol#L76-L112) to update the Guardian set via Governance VAA.\n\n```solidity\nfunction submitNewGuardianSet(bytes memory _vm) public {\n    ...\n\n    // Trigger a time-based expiry of current guardianSet\n    expireGuardianSet(getCurrentGuardianSetIndex());\n\n    // Add the new guardianSet to guardianSets\n    storeGuardianSet(upgrade.newGuardianSet, upgrade.newGuardianSetIndex);\n\n    // Makes the new guardianSet effective\n    updateGuardianSetIndex(upgrade.newGuardianSetIndex);\n}\n```\n\nWhen this function is called, [`Setters:: expireGuardianSet`](https://github.com/wormhole-foundation/wormhole/blob/main/ethereum/contracts/Setters.sol#L13-L15) initiates a 24-hour timeframe after which the current guardian set expires.\n\n```solidity\nfunction expireGuardianSet(uint32 index) internal {\n    _state.guardianSets[index].expirationTime = uint32(block.timestamp) + 86400;\n}\n```\n\nHence, any in-flight VAAs that utilize the deprecated Guardian set index will fail to be executed given the validation present in [`Messages::verifyVMInternal`](https://github.com/wormhole-foundation/wormhole/blob/main/ethereum/contracts/Messages.sol).\n\n```solidity\n/// @dev Checks if VM guardian set index matches the current index (unless the current set is expired).\nif(vm.guardianSetIndex != getCurrentGuardianSetIndex() && guardianSet.expirationTime < block.timestamp){\n    return (false, \"guardian set has expired\");\n}\n```\n\nConsidering there is no automatic relaying of Wormhole CCTP messages, counter to what is specified in the [documentation](https://docs.wormhole.com/wormhole/quick-start/tutorials/cctp) (unless an integrator implements their own relayer), there are no guarantees that an in-flight message which utilizes an old Guardian set index will be executed by the `mintRecipient` on the target domain within its 24-hour expiration period. This could occur, for example, in cases such as:\n1. Integrator messages are blocked by their use of the Wormhole nonce/sequence number.\n2. CCTP contracts are paused on the target domain, causing all redemptions to revert.\n3. L2 sequencer downtime, since the Wormhole CCTP integration contracts do not consider aliased addresses for forced inclusion.\n4. The `mintRecipient` is a contract that has been paused following an exploit, temporarily restricting all incoming and outgoing transfers.\n\nIn the current design, it is not possible to update the `mintRecipient` for a given deposit due to the multicast nature of VAAs. CCTP exposes [`MessageTransmitter::replaceMessage`](https://github.com/circlefin/evm-cctp-contracts/blob/1662356f9e60bb3f18cb6d09f95f628f0cc3637f/src/MessageTransmitter.sol#L129-L181) which allows the original source caller to update the destination caller for a given message and its corresponding attestation; however, the Wormhole CCTP integration currently provides no access to this function and has no similar functionality of its own to allow updates to the target `mintRecipient` of the VAA.\n\nAdditionally, there is no method for forcibly executing the redemption of USDC/EURC to the `mintRecipient`, which is the only address allowed to execute the VAA on the target domain, as validated in [`Logic::redeemTokensWithPayload`](https://github.com/wormhole-foundation/wormhole-circle-integration/blob/f7df33b159a71b163b8b5c7e7381c0d8f193da99/evm/src/contracts/CircleIntegration/Logic.sol#L61-L108).\n\n```solidity\n// Confirm that the caller is the `mintRecipient` to ensure atomic execution.\nrequire(\n    msg.sender.toUniversalAddress() == deposit.mintRecipient, \"caller must be mintRecipient\"\n);\n```\n\nWithout any programmatic method for replacing expired VAAs with new VAAs signed by the updated Guardian set, the source USDC/EURC will be burnt, but it will not be possible for the expired VAAs to be executed, leading to denial-of-service on the `mintRecipient` receiving tokens on the target domain. The Wormhole CCTP integration does, however, inherit some mitigations already in place for this type of scenario where the Guardian set is updated, as explained in the [Wormhole whitepaper](https://github.com/wormhole-foundation/wormhole/blob/eee4641f55954d2d0db47831688a2e97eb20f7ee/whitepapers/0003_token_bridge.md#caveats), meaning that it is possible to repair or otherwise replace the expired VAA for execution using signatures from the new Guardian set. In all cases, the original VAA metadata remains intact since the new VAA Guardian signatures refer to an event that has already been emitted, so none of the contents of the VAA payload besides the Guardian set index and associated signatures change on re-observation. This means that the new VAA can be safely paired with the existing Circle attestation for execution on the target domain by the original `mintRecipient`.\n\n**Impact:** There is only a single address that is permitted to execute a given VAA on the target domain; however, there are several scenarios that have been identified where this `mintReceipient` may be unable to perform redemption for a period in excess of 24 hours following an update to the Guardian set while the VAA is in-flight. Fortunately, Wormhole Governance has a well-defined path to resolution, so the impact is limited.\n\n**Proof of Concept:**\n1. Alice burns 100 USDC to be transferred to dApp X from CCTP Domain A to CCTP Domain B.\n2. Wormhole executes a Governance VAA to update the Guardian set.\n3. 24 hours pass, causing the previous Guardian set to expire.\n4. dApp X attempts to redeem 100 USDC on CCTP Domain B, but VAA verification fails because the message was signed using the expired Guardian set.\n5. The 100 USDC remains burnt and cannot be minted on the target domain by executing the attested CCTP message until the expired VAA is reobserved by members of the new Guardian set.\n\n**Recommended Mitigation:** The practicality of executing the proposed Governance mitigations at scale should be carefully considered, given the extent to which USDC is entrenched within the wider DeFi ecosystem. There is a high likelihood of temporary widespread, high-impact DoS, although this is somewhat limited by the understanding that Guardian set updates are expected to occur relatively infrequently, given there have only been three updates in the lifetime of Wormhole so far. There is also potentially insufficient tooling for the detailed VAA re-observation scenarios, which should handle the recombination of the signed CCTP message with the new VAA and clearly communicate these considerations to integrators.\n\n**Wormhole Foundation:** This is the same as how the Wormhole token bridge operates.\n\n**Cyfrin:** Acknowledged.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "ethereum/contracts/Governance.sol",
      "content": "// contracts/Governance.sol\n// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.0;\n\nimport \"./Structs.sol\";\nimport \"./GovernanceStructs.sol\";\nimport \"./Messages.sol\";\nimport \"./Setters.sol\";\n\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\";\n\n/**\n * @dev `Governance` defines a means to enacting changes to the core bridge contract,\n * guardianSets, message fees, and transfer fees\n */\nabstract contract Governance is GovernanceStructs, Messages, Setters, ERC1967Upgrade {\n    event ContractUpgraded(address indexed oldContract, address indexed newContract);\n    event GuardianSetAdded(uint32 indexed index);\n\n    // \"Core\" (left padded)\n    bytes32 constant module = 0x00000000000000000000000000000000000000000000000000000000436f7265;\n\n    /**\n     * @dev Upgrades a contract via Governance VAA/VM\n     */\n    function submitContractUpgrade(bytes memory _vm) public {\n        require(!isFork(), \"invalid fork\");\n\n        Structs.VM memory vm = parseVM(_vm);\n\n        // Verify the VAA is valid before processing it\n        (bool isValid, string memory reason) = verifyGovernanceVM(vm);\n        require(isValid, reason);\n\n        GovernanceStructs.ContractUpgrade memory upgrade = parseContractUpgrade(vm.payload);\n\n        // Verify the VAA is for this module\n        require(upgrade.module == module, \"Invalid Module\");\n\n        // Verify the VAA is for this chain\n        require(upgrade.chain == chainId(), \"Invalid Chain\");\n\n        // Record the governance action as consumed\n        setGovernanceActionConsumed(vm.hash);\n\n        // Upgrades the implementation to the new contract\n        upgradeImplementation(upgrade.newContract);\n    }\n\n    /**\n     * @dev Sets a `messageFee` via Governance VAA/VM\n     */\n    function submitSetMessageFee(bytes memory _vm) public {\n        Structs.VM memory vm = parseVM(_vm);\n\n        // Verify the VAA is valid before processing it\n        (bool isValid, string memory reason) = verifyGovernanceVM(vm);\n        require(isValid, reason);\n\n        GovernanceStructs.SetMessageFee memory upgrade = parseSetMessageFee(vm.payload);\n\n        // Verify the VAA is for this module\n        require(upgrade.module == module, \"Invalid Module\");\n\n        // Verify the VAA is for this chain\n        require(upgrade.chain == chainId() && !isFork(), \"Invalid Chain\");\n\n        // Record the governance action as consumed to prevent reentry\n        setGovernanceActionConsumed(vm.hash);\n\n        // Updates the messageFee\n        setMessageFee(upgrade.messageFee);\n    }\n\n    /**\n     * @dev Deploys a new `guardianSet` via Governance VAA/VM\n     */\n    function submitNewGuardianSet(bytes memory _vm) public {\n        Structs.VM memory vm = parseVM(_vm);\n\n        // Verify the VAA is valid before processing it\n        (bool isValid, string memory reason) = verifyGovernanceVM(vm);\n        require(isValid, reason);\n\n        GovernanceStructs.GuardianSetUpgrade memory upgrade = parseGuardianSetUpgrade(vm.payload);\n\n        // Verify the VAA is for this module\n        require(upgrade.module == module, \"invalid Module\");\n\n        // Verify the VAA is for this chain\n        require((upgrade.chain == chainId() && !isFork()) || upgrade.chain == 0, \"invalid Chain\");\n\n        // Verify the Guardian Set keys are not empty, this guards\n        // against the accidential upgrade to an empty GuardianSet\n        require(upgrade.newGuardianSet.keys.length > 0, \"new guardian set is empty\");\n\n        // Verify that the index is incrementing via a predictable +1 pattern\n        require(upgrade.newGuardianSetIndex == getCurrentGuardianSetIndex() + 1, \"index must increase in steps of 1\");\n\n        // Record the governance action as consumed to prevent reentry\n        setGovernanceActionConsumed(vm.hash);\n\n        // Trigger a time-based expiry of current guardianSet\n        expireGuardianSet(getCurrentGuardianSetIndex());\n\n        // Add the new guardianSet to guardianSets\n        storeGuardianSet(upgrade.newGuardianSet, upgrade.newGuardianSetIndex);\n\n        // Makes the new guardianSet effective\n        updateGuardianSetIndex(upgrade.newGuardianSetIndex);\n    }\n\n    /**\n     * @dev Submits transfer fees to the recipient via Governance VAA/VM\n     */\n    function submitTransferFees(bytes memory _vm) public {\n        Structs.VM memory vm = parseVM(_vm);\n\n        // Verify the VAA is valid before processing it\n        (bool isValid, string memory reason) = verifyGovernanceVM(vm);\n        require(isValid, reason);\n\n        // Obtains the transfer from the VAA payload\n        GovernanceStructs.TransferFees memory transfer = parseTransferFees(vm.payload);\n\n        // Verify the VAA is for this module\n        require(transfer.module == module, \"invalid Module\");\n\n        // Verify the VAA is for this chain\n        require((transfer.chain == chainId() && !isFork()) || transfer.chain == 0, \"invalid Chain\");\n\n        // Record the governance action as consumed to prevent reentry\n        setGovernanceActionConsumed(vm.hash);\n\n        // Obtains the recipient address to be paid transfer fees\n        address payable recipient = payable(address(uint160(uint256(transfer.recipient))));\n\n        // Transfers transfer fees to the recipient\n        recipient.transfer(transfer.amount);\n    }\n\n    /**\n    * @dev Updates the `chainId` and `evmChainId` on a forked chain via Governance VAA/VM\n    */\n    function submitRecoverChainId(bytes memory _vm) public {\n        require(isFork(), \"not a fork\");\n\n        Structs.VM memory vm = parseVM(_vm);\n\n        // Verify the VAA is valid before processing it\n        (bool isValid, string memory reason) = verifyGovernanceVM(vm);\n        require(isValid, reason);\n\n        GovernanceStructs.RecoverChainId memory rci = parseRecoverChainId(vm.payload);\n\n        // Verify the VAA is for this module\n        require(rci.module == module, \"invalid Module\");\n\n        // Verify the VAA is for this chain\n        require(rci.evmChainId == block.chainid, \"invalid EVM Chain\");\n\n        // Record the governance action as consumed to prevent reentry\n        setGovernanceActionConsumed(vm.hash);\n\n        // Update the chainIds\n        setEvmChainId(rci.evmChainId);\n        setChainId(rci.newChainId);\n    }\n\n    /**\n     * @dev Upgrades the `currentImplementation` with a `newImplementation`\n     */\n    function upgradeImplementation(address newImplementation) internal {\n        address currentImplementation = _getImplementation();\n\n        _upgradeTo(newImplementation);\n\n        // Call initialize function of the new implementation\n        (bool success, bytes memory reason) = newImplementation.delegatecall(abi.encodeWithSignature(\"initialize()\"));\n\n        require(success, string(reason));\n\n        emit ContractUpgraded(currentImplementation, newImplementation);\n    }\n\n    /**\n     * @dev Verifies a Governance VAA/VM is valid\n     */\n    function verifyGovernanceVM(Structs.VM memory vm) internal view returns (bool, string memory){\n        // Verify the VAA is valid\n        (bool isValid, string memory reason) = verifyVM(vm);\n        if (!isValid){\n            return (false, reason);\n        }\n\n        // only current guardianset can sign governance packets\n        if (vm.guardianSetIndex != getCurrentGuardianSetIndex()) {\n            return (false, \"not signed by current guardian set\");\n        }\n\n        // Verify the VAA is from the governance chain (Solana)\n        if (uint16(vm.emitterChainId) != governanceChainId()) {\n            return (false, \"wrong governance chain\");\n        }\n\n        // Verify the emitter contract is the governance contract (0x4 left padded)\n        if (vm.emitterAddress != governanceContract()) {\n            return (false, \"wrong governance contract\");\n        }\n\n        // Verify this governance action hasn't already been\n        // consumed to prevent reentry and replay\n        if (governanceActionIsConsumed(vm.hash)){\n            return (false, \"governance action already consumed\");\n        }\n\n        // Confirm the governance VAA/VM is valid\n        return (true, \"\");\n    }\n}"
    },
    {
      "filename": "ethereum/contracts/Setters.sol",
      "content": "// contracts/Setters.sol\n// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.0;\n\nimport \"./State.sol\";\n\ncontract Setters is State {\n    function updateGuardianSetIndex(uint32 newIndex) internal {\n        _state.guardianSetIndex = newIndex;\n    }\n\n    function expireGuardianSet(uint32 index) internal {\n        _state.guardianSets[index].expirationTime = uint32(block.timestamp) + 86400;\n    }\n\n    function storeGuardianSet(Structs.GuardianSet memory set, uint32 index) internal {\n        uint setLength = set.keys.length;\n        for (uint i = 0; i < setLength; i++) {\n            require(set.keys[i] != address(0), \"Invalid key\");\n        }\n        _state.guardianSets[index] = set;\n    }\n\n    function setInitialized(address implementatiom) internal {\n        _state.initializedImplementations[implementatiom] = true;\n    }\n\n    function setGovernanceActionConsumed(bytes32 hash) internal {\n        _state.consumedGovernanceActions[hash] = true;\n    }\n\n    function setChainId(uint16 chainId) internal {\n        _state.provider.chainId = chainId;\n    }\n\n    function setGovernanceChainId(uint16 chainId) internal {\n        _state.provider.governanceChainId = chainId;\n    }\n\n    function setGovernanceContract(bytes32 governanceContract) internal {\n        _state.provider.governanceContract = governanceContract;\n    }\n\n    function setMessageFee(uint256 newFee) internal {\n        _state.messageFee = newFee;\n    }\n\n    function setNextSequence(address emitter, uint64 sequence) internal {\n        _state.sequences[emitter] = sequence;\n    }\n\n    function setEvmChainId(uint256 evmChainId) internal {\n        require(evmChainId == block.chainid, \"invalid evmChainId\");\n        _state.evmChainId = evmChainId;\n    }\n}"
    },
    {
      "filename": "src/MessageTransmitter.sol",
      "content": "/*\n * Copyright (c) 2022, Circle Internet Financial Limited.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npragma solidity 0.7.6;\n\nimport \"@memview-sol/contracts/TypedMemView.sol\";\nimport \"./interfaces/IMessageTransmitter.sol\";\nimport \"./interfaces/IMessageHandler.sol\";\nimport \"./messages/Message.sol\";\nimport \"./roles/Pausable.sol\";\nimport \"./roles/Rescuable.sol\";\nimport \"./roles/Attestable.sol\";\n\n/**\n * @title MessageTransmitter\n * @notice Contract responsible for sending and receiving messages across chains.\n */\ncontract MessageTransmitter is\n    IMessageTransmitter,\n    Pausable,\n    Rescuable,\n    Attestable\n{\n    // ============ Events ============\n    /**\n     * @notice Emitted when a new message is dispatched\n     * @param message Raw bytes of message\n     */\n    event MessageSent(bytes message);\n\n    /**\n     * @notice Emitted when a new message is received\n     * @param caller Caller (msg.sender) on destination domain\n     * @param sourceDomain The source domain this message originated from\n     * @param nonce The nonce unique to this message\n     * @param sender The sender of this message\n     * @param messageBody message body bytes\n     */\n    event MessageReceived(\n        address indexed caller,\n        uint32 sourceDomain,\n        uint64 indexed nonce,\n        bytes32 sender,\n        bytes messageBody\n    );\n\n    /**\n     * @notice Emitted when max message body size is updated\n     * @param newMaxMessageBodySize new maximum message body size, in bytes\n     */\n    event MaxMessageBodySizeUpdated(uint256 newMaxMessageBodySize);\n\n    // ============ Libraries ============\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n    using Message for bytes29;\n\n    // ============ State Variables ============\n    // Domain of chain on which the contract is deployed\n    uint32 public immutable localDomain;\n\n    // Message Format version\n    uint32 public immutable version;\n\n    // Maximum size of message body, in bytes.\n    // This value is set by owner.\n    uint256 public maxMessageBodySize;\n\n    // Next available nonce from this source domain\n    uint64 public nextAvailableNonce;\n\n    // Maps a bytes32 hash of (sourceDomain, nonce) -> uint256 (0 if unused, 1 if used)\n    mapping(bytes32 => uint256) public usedNonces;\n\n    // ============ Constructor ============\n    constructor(\n        uint32 _localDomain,\n        address _attester,\n        uint32 _maxMessageBodySize,\n        uint32 _version\n    ) Attestable(_attester) {\n        localDomain = _localDomain;\n        maxMessageBodySize = _maxMessageBodySize;\n        version = _version;\n    }\n\n    // ============ External Functions  ============\n    /**\n     * @notice Send the message to the destination domain and recipient\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination chain as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessage(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes calldata messageBody\n    ) external override whenNotPaused returns (uint64) {\n        bytes32 _emptyDestinationCaller = bytes32(0);\n        uint64 _nonce = _reserveAndIncrementNonce();\n        bytes32 _messageSender = Message.addressToBytes32(msg.sender);\n\n        _sendMessage(\n            destinationDomain,\n            recipient,\n            _emptyDestinationCaller,\n            _messageSender,\n            _nonce,\n            messageBody\n        );\n\n        return _nonce;\n    }\n\n    /**\n     * @notice Replace a message with a new message body and/or destination caller.\n     * @dev The `originalAttestation` must be a valid attestation of `originalMessage`.\n     * Reverts if msg.sender does not match sender of original message, or if the source domain of the original message\n     * does not match this MessageTransmitter's local domain.\n     * @param originalMessage original message to replace\n     * @param originalAttestation attestation of `originalMessage`\n     * @param newMessageBody new message body of replaced message\n     * @param newDestinationCaller the new destination caller, which may be the\n     * same as the original destination caller, a new destination caller, or an empty\n     * destination caller (bytes32(0), indicating that any destination caller is valid.)\n     */\n    function replaceMessage(\n        bytes calldata originalMessage,\n        bytes calldata originalAttestation,\n        bytes calldata newMessageBody,\n        bytes32 newDestinationCaller\n    ) external override whenNotPaused {\n        // Validate each signature in the attestation\n        _verifyAttestationSignatures(originalMessage, originalAttestation);\n\n        bytes29 _originalMsg = originalMessage.ref(0);\n\n        // Validate message format\n        _originalMsg._validateMessageFormat();\n\n        // Validate message sender\n        bytes32 _sender = _originalMsg._sender();\n        require(\n            msg.sender == Message.bytes32ToAddress(_sender),\n            \"Sender not permitted to use nonce\"\n        );\n\n        // Validate source domain\n        uint32 _sourceDomain = _originalMsg._sourceDomain();\n        require(\n            _sourceDomain == localDomain,\n            \"Message not originally sent from this domain\"\n        );\n\n        uint32 _destinationDomain = _originalMsg._destinationDomain();\n        bytes32 _recipient = _originalMsg._recipient();\n        uint64 _nonce = _originalMsg._nonce();\n\n        _sendMessage(\n            _destinationDomain,\n            _recipient,\n            newDestinationCaller,\n            _sender,\n            _nonce,\n            newMessageBody\n        );\n    }\n\n    /**\n     * @notice Send the message to the destination domain and recipient, for a specified `destinationCaller` on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external override whenNotPaused returns (uint64) {\n        require(\n            destinationCaller != bytes32(0),\n            \"Destination caller must be nonzero\"\n        );\n\n        uint64 _nonce = _reserveAndIncrementNonce();\n        bytes32 _messageSender = Message.addressToBytes32(msg.sender);\n\n        _sendMessage(\n            destinationDomain,\n            recipient,\n            destinationCaller,\n            _messageSender,\n            _nonce,\n            messageBody\n        );\n\n        return _nonce;\n    }\n\n    /**\n     * @notice Receive a message. Messages with a given nonce\n     * can only be broadcast once for a (sourceDomain, destinationDomain)\n     * pair. The message body of a valid message is passed to the\n     * specified recipient for further processing.\n     *\n     * @dev Attestation format:\n     * A valid attestation is the concatenated 65-byte signature(s) of exactly\n     * `thresholdSignature` signatures, in increasing order of attester address.\n     * ***If the attester addresses recovered from signatures are not in\n     * increasing order, signature verification will fail.***\n     * If incorrect number of signatures or duplicate signatures are supplied,\n     * signature verification will fail.\n     *\n     * Message format:\n     * Field                 Bytes      Type       Index\n     * version               4          uint32     0\n     * sourceDomain          4          uint32     4\n     * destinationDomain     4          uint32     8\n     * nonce                 8          uint64     12\n     * sender                32         bytes32    20\n     * recipient             32         bytes32    52\n     * messageBody           dynamic    bytes      84\n     * @param message Message bytes\n     * @param attestation Concatenated 65-byte signature(s) of `message`, in increasing order\n     * of the attester address recovered from signatures.\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata attestation)\n        external\n        override\n        whenNotPaused\n        returns (bool success)\n    {\n        // Validate each signature in the attestation\n        _verifyAttestationSignatures(message, attestation);\n\n        bytes29 _msg = message.ref(0);\n\n        // Validate message format\n        _msg._validateMessageFormat();\n\n        // Validate domain\n        require(\n            _msg._destinationDomain() == localDomain,\n            \"Invalid destination domain\"\n        );\n\n        // Validate destination caller\n        if (_msg._destinationCaller() != bytes32(0)) {\n            require(\n                _msg._destinationCaller() ==\n                    Message.addressToBytes32(msg.sender),\n                \"Invalid caller for message\"\n            );\n        }\n\n        // Validate version\n        require(_msg._version() == version, \"Invalid message version\");\n\n        // Validate nonce is available\n        uint32 _sourceDomain = _msg._sourceDomain();\n        uint64 _nonce = _msg._nonce();\n        bytes32 _sourceAndNonce = _hashSourceAndNonce(_sourceDomain, _nonce);\n        require(usedNonces[_sourceAndNonce] == 0, \"Nonce already used\");\n        // Mark nonce used\n        usedNonces[_sourceAndNonce] = 1;\n\n        // Handle receive message\n        bytes32 _sender = _msg._sender();\n        bytes memory _messageBody = _msg._messageBody().clone();\n        require(\n            IMessageHandler(Message.bytes32ToAddress(_msg._recipient()))\n                .handleReceiveMessage(_sourceDomain, _sender, _messageBody),\n            \"handleReceiveMessage() failed\"\n        );\n\n        // Emit MessageReceived event\n        emit MessageReceived(\n            msg.sender,\n            _sourceDomain,\n            _nonce,\n            _sender,\n            _messageBody\n        );\n        return true;\n    }\n\n    /**\n     * @notice Sets the max message body size\n     * @dev This value should not be reduced without good reason,\n     * to avoid impacting users who rely on large messages.\n     * @param newMaxMessageBodySize new max message body size, in bytes\n     */\n    function setMaxMessageBodySize(uint256 newMaxMessageBodySize)\n        external\n        onlyOwner\n    {\n        maxMessageBodySize = newMaxMessageBodySize;\n        emit MaxMessageBodySizeUpdated(maxMessageBodySize);\n    }\n\n    // ============ Internal Utils ============\n    /**\n     * @notice Send the message to the destination domain and recipient. If `_destinationCaller` is not equal to bytes32(0),\n     * the message can only be received on the destination chain when called by `_destinationCaller`.\n     * @dev Format the message and emit `MessageSent` event with message information.\n     * @param _destinationDomain Domain of destination chain\n     * @param _recipient Address of message recipient on destination domain as bytes32\n     * @param _destinationCaller caller on the destination domain, as bytes32\n     * @param _sender message sender, as bytes32\n     * @param _nonce nonce reserved for message\n     * @param _messageBody Raw bytes content of message\n     */\n    function _sendMessage(\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        bytes32 _destinationCaller,\n        bytes32 _sender,\n        uint64 _nonce,\n        bytes calldata _messageBody\n    ) internal {\n        // Validate message body length\n        require(\n            _messageBody.length <= maxMessageBodySize,\n            \"Message body exceeds max size\"\n        );\n\n        require(_recipient != bytes32(0), \"Recipient must be nonzero\");\n\n        // serialize message\n        bytes memory _message = Message._formatMessage(\n            version,\n            localDomain,\n            _destinationDomain,\n            _nonce,\n            _sender,\n            _recipient,\n            _destinationCaller,\n            _messageBody\n        );\n\n        // Emit MessageSent event\n        emit MessageSent(_message);\n    }\n\n    /**\n     * @notice hashes `_source` and `_nonce`.\n     * @param _source Domain of chain where the transfer originated\n     * @param _nonce The unique identifier for the message from source to\n              destination\n     * @return hash of source and nonce\n     */\n    function _hashSourceAndNonce(uint32 _source, uint64 _nonce)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_source, _nonce));\n    }\n\n    /**\n     * Reserve and increment next available nonce\n     * @return nonce reserved\n     */\n    function _reserveAndIncrementNonce() internal returns (uint64) {\n        uint64 _nonceReserved = nextAvailableNonce;\n        nextAvailableNonce = nextAvailableNonce + 1;\n        return _nonceReserved;\n    }\n}"
    },
    {
      "filename": "evm/src/contracts/CircleIntegration/Logic.sol",
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.19;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {IWormhole} from \"src/interfaces/IWormhole.sol\";\nimport {IMessageTransmitter} from \"src/interfaces/IMessageTransmitter.sol\";\nimport {ITokenMessenger} from \"src/interfaces/ITokenMessenger.sol\";\nimport {ITokenMinter} from \"src/interfaces/ITokenMinter.sol\";\nimport {ICircleIntegration} from \"src/interfaces/ICircleIntegration.sol\";\n\nimport {Utils} from \"src/libraries/Utils.sol\";\nimport {WormholeCctpMessages} from \"src/libraries/WormholeCctpMessages.sol\";\n\nimport {Governance} from \"./Governance.sol\";\nimport {\n    getChainToDomain,\n    getConsumedVaas,\n    getDomainToChain,\n    getInitializedImplementations,\n    getRegisteredEmitters\n} from \"./Storage.sol\";\n\nabstract contract Logic is ICircleIntegration, Governance {\n    using Utils for address;\n    using SafeERC20 for IERC20;\n    using WormholeCctpMessages for *;\n\n    /// @inheritdoc ICircleIntegration\n    function transferTokensWithPayload(\n        TransferParameters calldata transferParams,\n        uint32 wormholeNonce,\n        bytes calldata payload\n    ) public payable returns (uint64 wormholeSequence) {\n        // Is the foreign Wormhole Circle Integration registered?\n        bytes32 destinationCaller = getRegisteredEmitters()[transferParams.targetChain];\n        require(destinationCaller != 0, \"target contract not registered\");\n\n        // Deposit tokens into this contract to prepare for burning.\n        IERC20(transferParams.token).safeTransferFrom(\n            msg.sender, address(this), transferParams.amount\n        );\n\n        // Approve the Token Messenger to spend tokens.\n        setTokenMessengerApproval(transferParams.token, transferParams.amount);\n\n        // Invoke Token Messenger to burn tokens and emit a CCTP token burn message.\n        (wormholeSequence,) = burnAndPublish(\n            destinationCaller,\n            getChainToDomain()[transferParams.targetChain],\n            transferParams.token,\n            transferParams.amount,\n            transferParams.mintRecipient,\n            wormholeNonce,\n            payload,\n            msg.value\n        );\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function redeemTokensWithPayload(RedeemParameters calldata params)\n        public\n        returns (DepositWithPayload memory deposit)\n    {\n        // This check prevents this contract existing on this network's potential fork, where it was\n        // not freshly deployed. This is a safety measure to prevent replay attacks on the forked\n        // network.\n        require(evmChain() == block.chainid, \"invalid evm chain\");\n\n        // Verify the VAA and mint tokens. Set the deposit struct with WormholeCctpTokenMessenger's\n        // return values.\n        IWormhole.VM memory vaa;\n        (\n            vaa,\n            deposit.token,\n            deposit.amount,\n            deposit.sourceDomain,\n            deposit.targetDomain,\n            deposit.nonce,\n            deposit.fromAddress,\n            deposit.mintRecipient,\n            deposit.payload\n        ) = verifyVaaAndMintLegacy(\n            params.encodedCctpMessage, params.cctpAttestation, params.encodedVaa\n        );\n\n        // Confirm that the caller is the `mintRecipient` to ensure atomic execution.\n        require(\n            msg.sender.toUniversalAddress() == deposit.mintRecipient, \"caller must be mintRecipient\"\n        );\n\n        // If this VAA does not come from a registered Wormhole Circle Integration contract, revert.\n        requireEmitterLegacy(vaa, getRegisteredEmitters()[vaa.emitterChainId]);\n\n        mapping(bytes32 => bool) storage consumedVaas = getConsumedVaas();\n\n        // Revert if this message has been consumed already. This check is meant to prevent replay\n        // attacks, but it may not be necessary because the CCTP Message Transmitter already keeps\n        // track of used nonces.\n        require(!consumedVaas[vaa.hash], \"message already consumed\");\n\n        // Mark as consumed.\n        consumedVaas[vaa.hash] = true;\n\n        // Emit Redeemed event.\n        emit Redeemed(vaa.emitterChainId, vaa.emitterAddress, vaa.sequence);\n    }\n\n    // getters\n\n    /// @inheritdoc ICircleIntegration\n    function fetchLocalTokenAddress(uint32 remoteDomain, bytes32 remoteToken)\n        public\n        view\n        returns (bytes32)\n    {\n        return fetchLocalToken(remoteDomain, remoteToken);\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function addressToBytes32(address evmAddr) public pure returns (bytes32 converted) {\n        converted = evmAddr.toUniversalAddress();\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function decodeDepositWithPayload(bytes memory encoded)\n        public\n        pure\n        returns (DepositWithPayload memory deposit)\n    {\n        // This is a hack to get around using the decodeDeposit method. This is not a real VM\n        // obviously.\n        //\n        // Plus, this getter should never be used in practice.\n        IWormhole.VM memory fakeVaa;\n        fakeVaa.payload = encoded;\n        (\n            deposit.token,\n            deposit.amount,\n            deposit.sourceDomain,\n            deposit.targetDomain,\n            deposit.nonce,\n            deposit.fromAddress,\n            deposit.mintRecipient,\n            deposit.payload\n        ) = fakeVaa.decodeDeposit();\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function encodeDepositWithPayload(DepositWithPayload memory message)\n        public\n        pure\n        returns (bytes memory encoded)\n    {\n        encoded = message.token.encodeDeposit(\n            message.amount,\n            message.sourceDomain,\n            message.targetDomain,\n            message.nonce,\n            message.fromAddress,\n            message.mintRecipient,\n            message.payload\n        );\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function isInitialized(address impl) public view returns (bool) {\n        return getInitializedImplementations()[impl];\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function wormhole() public view returns (IWormhole) {\n        return _wormhole;\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function chainId() public view returns (uint16) {\n        return _chainId;\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function wormholeFinality() public pure returns (uint8) {\n        return _MESSAGE_FINALITY;\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function circleBridge() public view returns (ITokenMessenger) {\n        return _tokenMessenger;\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function circleTokenMinter() public view returns (ITokenMinter) {\n        return _tokenMinter;\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function circleTransmitter() public view returns (IMessageTransmitter) {\n        return _messageTransmitter;\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function getRegisteredEmitter(uint16 chain) public view returns (bytes32) {\n        return getRegisteredEmitters()[chain];\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function isAcceptedToken(address token) public view returns (bool) {\n        return _tokenMinter.burnLimitsPerMessage(token) > 0;\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function getDomainFromChainId(uint16 chain) public view returns (uint32) {\n        return getChainToDomain()[chain];\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function getChainIdFromDomain(uint32 cctpDomain) public view returns (uint16) {\n        return getDomainToChain()[cctpDomain];\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function isMessageConsumed(bytes32 vaaHash) public view returns (bool) {\n        return getConsumedVaas()[vaaHash];\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function localDomain() public view returns (uint32) {\n        return _localCctpDomain;\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function evmChain() public view returns (uint256) {\n        return _evmChain;\n    }\n}"
    },
    {
      "filename": "whitepapers/0003_token_bridge.md",
      "content": "# Token Bridge App\n\n[TOC]\n\n## Objective\n\nTo use the Wormhole message passing protocol to transfer tokens between different connected chains.\n\n## Background\n\nThe decentralized finance ecosystem is developing into a direction where different chains with different strengths\nbecome the home for various protocols. However, a token is usually only minted on a single chain and therefore\ndisconnected from the ecosystem and protocols on other chains.\n\nEach chain typically has one de-facto standard for token issuance, like ERC-20 on Ethereum and SPL on Solana. Those\nstandards, while not identical, all implement"
    }
  ]
}