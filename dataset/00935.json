{
  "Title": "depositors face immediate loss in case `equity = 0`",
  "Content": "# depositors face immediate loss in case `equity = 0`\n\n### Severity\nHigh Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/strategy/gmx/GMXReader.sol#L48\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/strategy/gmx/GMXReader.sol#L48</a>\n\n\n## Summary\n\nThe vulnerability in the `valueToShares` function exposes users to significant losses in case the equity `(currentAllAssetValue - debtBorrowed)` becomes zero due to strategy losses, users receive disproportionately low shares, and take a loss Immediately.\n\n## Vulnerability Details\n\n- When a user deposits to the contract, the calculation of the shares to be minted depends on the value of equity added to the contract after a successful deposit. In other words:\n  - `value` = `equityAfter` - `equityBefore`, while:\n  - `equity` = `totalAssetValue` - `totalDebtValue`.\n    and we can see that here :\n\n```solidity\n   function processDeposit(GMXTypes.Store storage self) external {\n        self.depositCache.healthParams.equityAfter = GMXReader.equityValue(self);\n>>        self.depositCache.sharesToUser = GMXReader.valueToShares(\n            self,\n            self.depositCache.healthParams.equityAfter - self.depositCache.healthParams.equityBefore,\n            self.depositCache.healthParams.equityBefore\n        );\n\n        GMXChecks.afterDepositChecks(self);\n    }\n    // value to shares function :\n\n     function valueToShares(GMXTypes.Store storage self, uint256 value, uint256 currentEquity)\n        public\n        view\n        returns (uint256)\n    {\n\n        uint256 _sharesSupply = IERC20(address(self.vault)).totalSupply() + pendingFee(self); // shares is added\n>>        if (_sharesSupply == 0 || currentEquity == 0) return value;\n>>        return value * _sharesSupply / currentEquity;\n    }\n```\n\n- **NOTICE:** When the equity value is `0`, the shares minted to the user equal the deposited value itself. The equity value can become zero due to various factors such as strategy losses or accumulated lending interests... ect\n- In this scenario, the user immediately incurs a loss, depending on the total supply of `svToken` (shares).\n- Consider the following simplified example:\n  - The total supply of `svToken` is (1,000,000 \\* 1e18) (indicating users holding these shares).\n  - the equity value drops to zero due to strategy losses and a user deposits 100 USD worth of value,\n  - Due to the zero equity value, the user is minted 100 shares (100 \\* 1e18).\n  - Consequently, the value the user owns with these shares immediately reduces to 0.001 USD.\n    `100 * 100 * 1e18 / 1,000,000 = 0.001 USD` (value \\* equity / totalSupply).\n- In this case, the user immediately shares their entire deposited value with these old minted shares and loses their deposit, whereas those old shares should be liquidated some how.\n  > Notice: If the total supply is higher, the user loses more value, and vice versa.\n\n## Impact\n\n- users face immediate loss of funds in case equity drops to zero\n\n## Tools Used\n\nmanual review\n\n## Recommendations\n\n- use a liquidation mechanism that burns the shares of all users when equity drops to zero.",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "contracts/strategy/gmx/GMXReader.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\n\n/**\n  * @title GMXReader\n  * @author Steadefi\n  * @notice Re-usable library functions for reading data and values for Steadefi leveraged vaults\n*/\nlibrary GMXReader {\n  using SafeCast for uint256;\n\n  /* =================== CONSTANTS FUNCTIONS ================= */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function svTokenValue(GMXTypes.Store storage self) public view returns (uint256) {\n    uint256 equityValue_ = equityValue(self);\n    uint256 totalSupply_ = IERC20(address(self.vault)).totalSupply();\n    if (equityValue_ == 0 || totalSupply_ == 0) return SAFE_MULTIPLIER;\n    return equityValue_ * SAFE_MULTIPLIER / totalSupply_;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function pendingFee(GMXTypes.Store storage self) public view returns (uint256) {\n    uint256 totalSupply_ = IERC20(address(self.vault)).totalSupply();\n    uint256 _secondsFromLastCollection = block.timestamp - self.lastFeeCollected;\n    return (totalSupply_ * self.feePerSecond * _secondsFromLastCollection) / SAFE_MULTIPLIER;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function valueToShares(\n    GMXTypes.Store storage self,\n    uint256 value,\n    uint256 currentEquity\n  ) public view returns (uint256) {\n    uint256 _sharesSupply = IERC20(address(self.vault)).totalSupply() + pendingFee(self);\n    if (_sharesSupply == 0 || currentEquity == 0) return value;\n    return value * _sharesSupply / currentEquity;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function convertToUsdValue(\n    GMXTypes.Store storage self,\n    address token,\n    uint256 amt\n  ) public view returns (uint256) {\n    return amt * 10**(18 - IERC20Metadata(token).decimals())\n                * self.chainlinkOracle.consultIn18Decimals(token)\n                / SAFE_MULTIPLIER;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function tokenWeights(GMXTypes.Store storage self) public view returns (uint256, uint256) {\n    // Get amounts of tokenA and tokenB in liquidity pool in token decimals\n    (uint256 _reserveA, uint256 _reserveB) = self.gmxOracle.getLpTokenReserves(\n      address(self.lpToken),\n      address(self.tokenA),\n      address(self.tokenA),\n      address(self.tokenB)\n    );\n\n    // Get value of tokenA and tokenB in 1e18\n    uint256 _tokenAValue = convertToUsdValue(self, address(self.tokenA), _reserveA);\n    uint256 _tokenBValue = convertToUsdValue(self, address(self.tokenB), _reserveB);\n\n    uint256 _totalLpValue = _tokenAValue + _tokenBValue;\n\n    return (\n      _tokenAValue * SAFE_MULTIPLIER / _totalLpValue,\n      _tokenBValue * SAFE_MULTIPLIER / _totalLpValue\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function assetValue(GMXTypes.Store storage self) public view returns (uint256) {\n    return lpAmt(self) * self.gmxOracle.getLpTokenValue(\n      address(self.lpToken),\n      address(self.tokenA),\n      address(self.tokenA),\n      address(self.tokenB),\n      false,\n      false\n    ) / SAFE_MULTIPLIER;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function debtValue(GMXTypes.Store storage self) public view returns (uint256, uint256) {\n    (uint256 _tokenADebtAmt, uint256 _tokenBDebtAmt) = debtAmt(self);\n    return (\n      convertToUsdValue(self, address(self.tokenA), _tokenADebtAmt),\n      convertToUsdValue(self, address(self.tokenB), _tokenBDebtAmt)\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function equityValue(GMXTypes.Store storage self) public view returns (uint256) {\n    (uint256 _tokenADebtAmt, uint256 _tokenBDebtAmt) = debtAmt(self);\n\n    uint256 assetValue_ = assetValue(self);\n\n    uint256 _debtValue = convertToUsdValue(self, address(self.tokenA), _tokenADebtAmt)\n                         + convertToUsdValue(self, address(self.tokenB), _tokenBDebtAmt);\n\n    // in underflow condition return 0\n    unchecked {\n      if (assetValue_ < _debtValue) return 0;\n\n      return assetValue_ - _debtValue;\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function assetAmt(GMXTypes.Store storage self) public view returns (uint256, uint256) {\n    (uint256 _reserveA, uint256 _reserveB) = self.gmxOracle.getLpTokenReserves(\n      address(self.lpToken),\n      address(self.tokenA),\n      address(self.tokenA),\n      address(self.tokenB)\n    );\n\n    return (\n      _reserveA * SAFE_MULTIPLIER * lpAmt(self) / self.lpToken.totalSupply() / SAFE_MULTIPLIER,\n      _reserveB * SAFE_MULTIPLIER * lpAmt(self) / self.lpToken.totalSupply() / SAFE_MULTIPLIER\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function debtAmt(GMXTypes.Store storage self) public view returns (uint256, uint256) {\n    return (\n      self.tokenALendingVault.maxRepay(address(self.vault)),\n      self.tokenBLendingVault.maxRepay(address(self.vault))\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function lpAmt(GMXTypes.Store storage self) public view returns (uint256) {\n    return self.lpToken.balanceOf(address(self.vault));\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function leverage(GMXTypes.Store storage self) public view returns (uint256) {\n    if (assetValue(self) == 0 || equityValue(self) == 0) return 0;\n    return assetValue(self) * SAFE_MULTIPLIER / equityValue(self);\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function delta(GMXTypes.Store storage self) public view returns (int256) {\n    (uint256 _tokenAAmt,) = assetAmt(self);\n    (uint256 _tokenADebtAmt,) = debtAmt(self);\n    uint256 equityValue_ = equityValue(self);\n\n    if (_tokenAAmt == 0 && _tokenADebtAmt == 0) return 0;\n    if (equityValue_ == 0) return 0;\n\n    bool _isPositive = _tokenAAmt >= _tokenADebtAmt;\n\n    uint256 _unsignedDelta = _isPositive ?\n      _tokenAAmt - _tokenADebtAmt :\n      _tokenADebtAmt - _tokenAAmt;\n\n    int256 signedDelta = (_unsignedDelta\n      * self.chainlinkOracle.consultIn18Decimals(address(self.tokenA))\n      / equityValue_).toInt256();\n\n    if (_isPositive) return signedDelta;\n    else return -signedDelta;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function debtRatio(GMXTypes.Store storage self) public view returns (uint256) {\n    (uint256 _tokenADebtValue, uint256 _tokenBDebtValue) = debtValue(self);\n    if (assetValue(self) == 0) return 0;\n    return (_tokenADebtValue + _tokenBDebtValue) * SAFE_MULTIPLIER / assetValue(self);\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function additionalCapacity(GMXTypes.Store storage self) public view returns (uint256) {\n    uint256 _additionalCapacity;\n\n    // Long strategy only borrows short token (typically stablecoin)\n    if (self.delta == GMXTypes.Delta.Long) {\n      _additionalCapacity = convertToUsdValue(\n        self,\n        address(self.tokenB),\n        self.tokenBLendingVault.totalAvailableAsset()\n      ) * SAFE_MULTIPLIER / (self.leverage - 1e18);\n    }\n\n    // Neutral strategy borrows both long (typical volatile) and short token (typically stablecoin)\n    // Amount of long token to borrow is equivalent to deposited value x leverage x longTokenWeight\n    // Amount of short token to borrow is remaining borrow value AFTER borrowing long token\n    // ---------------------------------------------------------------------------------------------\n    // E.g: 3x Neutral ETH-USDC with weight of ETH being 55%, USDC 45%\n    // A $1 equity deposit should result in a $2 borrow for a total of $3 assets\n    // Amount of ETH to borrow would be $3 x 55% = $1.65 worth of ETH\n    // Amount of USDC to borrow would be $3 (asset) - $1.65 (ETH borrowed) - $1 (equity) = $0.35\n    // ---------------------------------------------------------------------------------------------\n    // Note that for Neutral strategies, vault's leverage has to be 3x and above.\n    // A 2x leverage neutral strategy may not work to correctly to borrow enough long token to hedge\n    // while still adhering to the correct leverage factor.\n    if (self.delta == GMXTypes.Delta.Neutral) {\n      (uint256 _tokenAWeight, ) = tokenWeights(self);\n\n      uint256 _maxTokenALending = convertToUsdValue(\n        self,\n        address(self.tokenA),\n        self.tokenALendingVault.totalAvailableAsset()\n      ) * SAFE_MULTIPLIER\n        / (self.leverage * _tokenAWeight / SAFE_MULTIPLIER);\n\n      uint256 _maxTokenBLending = convertToUsdValue(\n        self,\n        address(self.tokenB),\n        self.tokenBLendingVault.totalAvailableAsset()\n      ) * SAFE_MULTIPLIER\n        / (self.leverage * _tokenAWeight / SAFE_MULTIPLIER)\n        - 1e18;\n\n      _additionalCapacity = _maxTokenALending > _maxTokenBLending ? _maxTokenBLending : _maxTokenALending;\n    }\n\n    return _additionalCapacity;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function capacity(GMXTypes.Store storage self) public view returns (uint256) {\n    return additionalCapacity(self) + equityValue(self);\n  }\n}"
    }
  ]
}