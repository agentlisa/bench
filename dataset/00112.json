{
  "Title": "The previous milestone stem should be scaled for use with the new gauge point system which uses untruncated values moving forward",
  "Content": "**Description:** Within the Beanstalk Silo, the milestone stem for a given token is the cumulative amount of grown stalk per BDV for this token at the last `stalkEarnedPerSeason` update. Previously, the milestone stem was stored in its truncated representation; however, the seed gauge system now stores the value in its untruncated form due to the new granularity of grown stalk and the frequency with which these values are updated.\n\nAt the time of upgrade, the previous (truncated) milestone stem for each token should be scaled for use with the gauge point system by multiplying up by a factor of `1e6`. Otherwise, there will be a mismatch in decimals when [calculating the stem tip](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/libraries/Silo/LibTokenSilo.sol#L388-L391).\n\n```solidity\n_stemTipForToken = s.ss[token].milestoneStem +\n    int96(s.ss[token].stalkEarnedPerSeason).mul(\n        int96(s.season.current).sub(int96(s.ss[token].milestoneSeason))\n    );\n```\n\n**Impact:** The mixing of decimals between the old milestone stem (truncated) and the new milestone stem (untruncated, after the first `gm` call following the BIP-39 upgrade) breaks the existing grown stalk accounting, resulting in a loss of grown stalk for depositors.\n\n**Proof of Concept:** The [previous implementation](https://github.com/BeanstalkFarms/Beanstalk/blob/7606673/protocol/contracts/libraries/Silo/LibTokenSilo.sol#L376-L391) returns the cumulative stalk per BDV with 4 decimals:\n```solidity\n    function stemTipForToken(address token)\n        internal\n        view\n        returns (int96 _stemTipForToken)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        // SafeCast unnecessary because all casted variables are types smaller that int96.\n        _stemTipForToken = s.ss[token].milestoneStem +\n        int96(s.ss[token].stalkEarnedPerSeason).mul(\n            int96(s.season.current).sub(int96(s.ss[token].milestoneSeason))\n        ).div(1e6); //round here\n    }\n```\n\nWhich can be mathematically abstracted to:\n$$StemTip(token) = getMilestonStem(token) + (current \\ season - getMilestonStemSeason(token)) \\times \\frac{stalkEarnedPerSeason(token)}{10^{6}}$$\n\nThis division by $10^{6}$ happens because the stem tip previously had just 4 decimals. This division allows backward compatibility by not considering the final 6 decimals. Therefore, the stem tip **MUST ALWAYS** have 4 decimals.\n\nThe milestone stem is now [updated in each `gm` call](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/libraries/LibGauge.sol#L265-L268) so long as all [LP price oracles pass their respective checks](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/libraries/LibGauge.sol#L65-L67). Notably, the milestone stem is now stored with 10 decimals (untruncated), hence why the second term of the abstraction has omitted the `10^{6}` division in `LibTokenSilo::stemTipForTokenUntruncated`.\n\nHowever, if the existing milestone stem is not escalated by $10^{6}$ then the addition performed during the upgrade and in subsequent `gm` calls makes no sense. This is mandatory to be handled within the upgrade otherwise every part of the protocol which calls `LibTokenSilo.stemTipForToken` will receive an incorrect value, except for BEAN:ETH Well LP (given it was created after the Silo v3 upgrade).\n\nSome instances where this function is used include:\n* [`EnrootFacet::enrootDeposit`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/beanstalk/silo/EnrootFacet.sol#L91)\n* [`EnrootFacet::enrootDeposits`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/beanstalk/silo/EnrootFacet.sol#L131)\n* [`MetaFacet::uri`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/beanstalk/metadata/MetadataFacet.sol#L36)\n* [`ConvertFacet::_withdrawTokens`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/beanstalk/silo/ConvertFacet.sol#L129-148)\n* [`LibSilo::__mow`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/libraries/Silo/LibSilo.sol#L382)\n* [`LibSilo::_removeDepositFromAccount`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/libraries/Silo/LibSilo.sol#L545)\n* [`LibSilo::_removeDepositsFromAccount`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/libraries/Silo/LibSilo.sol#L604)\n* [`Silo::_plant`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/beanstalk/silo/SiloFacet/Silo.sol#L110)\n* [`TokenSilo::_deposit`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/beanstalk/silo/SiloFacet/TokenSilo.sol#L173)\n* [`TokenSilo::_transferDeposits`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/beanstalk/silo/SiloFacet/TokenSilo.sol#L367)\n* [`LibLegacyTokenSilo::_mowAndMigrate`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/libraries/Silo/LibLegacyTokenSilo.sol#L306)\n* [`LibTokenSilo::_mowAndMigrate`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/libraries/Silo/LibLegacyTokenSilo.sol#L306)\n\nAs can be observed, critical parts of the protocol are compromised, leading to further cascading issues.\n\n**Recommended Mitigation:** Scale up the existing milestone stem for each token:\n```diff\nfor (uint i = 0; i < siloTokens.length; i++) {\n+   s.ss[siloTokens[i]].milestoneStem = int96(s.ss[siloTokens[i]].milestoneStem.mul(1e6));\n```\n\n\\clearpage",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/libraries/Silo/LibTokenSilo.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"../LibAppStorage.sol\";\nimport \"../../C.sol\";\nimport \"contracts/libraries/LibSafeMath32.sol\";\nimport \"contracts/libraries/LibSafeMath128.sol\";\nimport \"contracts/libraries/LibSafeMathSigned128.sol\";\nimport \"contracts/libraries/LibSafeMathSigned96.sol\";\nimport \"contracts/libraries/LibBytes.sol\";\n\n\n/**\n * @title LibTokenSilo\n * @author Publius, Pizzaman1337\n * @notice Contains functions for depositing, withdrawing and claiming\n * whitelisted Silo tokens.\n *\n * For functionality related to Stalk, and Roots, see {LibSilo}.\n */\nlibrary LibTokenSilo {\n    using SafeMath for uint256;\n    using LibSafeMath128 for uint128;\n    using LibSafeMath32 for uint32;\n    using LibSafeMathSigned128 for int128;\n    using SafeCast for int128;\n    using SafeCast for uint256;\n    using LibSafeMathSigned96 for int96;\n\n\n    //////////////////////// ENUM ////////////////////////\n    /**\n     * @dev when a user deposits or withdraws a deposit, the\n     * {TrasferSingle} event is emitted. However, in the case\n     * of a transfer, this emission is ommited. This enum is\n     * used to determine if the event should be emitted.\n     */\n    enum Transfer {\n        emitTransferSingle,\n        noEmitTransferSingle\n    }\n\n    //////////////////////// EVENTS ////////////////////////\n\n    /**\n     * @dev IMPORTANT: copy of {TokenSilo-AddDeposit}, check there for details.\n     */\n    event AddDeposit(\n        address indexed account,\n        address indexed token,\n        int96 stem,\n        uint256 amount,\n        uint256 bdv\n    );\n\n    // added as the ERC1155 deposit upgrade\n    event TransferSingle(\n        address indexed operator, \n        address indexed sender, \n        address indexed recipient, \n        uint256 depositId, \n        uint256 amount\n    );\n\n\n    //////////////////////// ACCOUNTING: TOTALS ////////////////////////\n    \n    /**\n     * @dev Increment the total amount and bdv of `token` deposited in the Silo.\n     */\n    function incrementTotalDeposited(address token, uint256 amount, uint256 bdv) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.siloBalances[token].deposited = s.siloBalances[token].deposited.add(\n            amount.toUint128()\n        );\n        s.siloBalances[token].depositedBdv = s.siloBalances[token].depositedBdv.add(\n            bdv.toUint128()\n        );\n    }\n\n    /**\n     * @dev Decrement the total amount and bdv of `token` deposited in the Silo.\n     */\n    function decrementTotalDeposited(address token, uint256 amount, uint256 bdv) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.siloBalances[token].deposited = s.siloBalances[token].deposited.sub(\n            amount.toUint128()\n        );\n        s.siloBalances[token].depositedBdv = s.siloBalances[token].depositedBdv.sub(\n            bdv.toUint128()\n        );\n    }\n\n    /**\n     * @dev Increment the total bdv of `token` deposited in the Silo. Used in Enroot.\n     */\n    function incrementTotalDepositedBdv(address token, uint256 bdv) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.siloBalances[token].depositedBdv = s.siloBalances[token].depositedBdv.add(\n            bdv.toUint128()\n        );\n    }\n\n    //////////////////////// ADD DEPOSIT ////////////////////////\n\n    /**\n     * @return stalk The amount of Stalk received for this Deposit.\n     * \n     * @dev Calculate the current BDV for `amount` of `token`, then perform \n     * Deposit accounting.\n     */\n    function deposit(\n        address account,\n        address token,\n        int96 stem,\n        uint256 amount\n    ) internal returns (uint256) {\n        uint256 bdv = beanDenominatedValue(token, amount);\n        return depositWithBDV(account, token, stem, amount, bdv);\n    }\n\n    /**\n     * @dev Once the BDV received for Depositing `amount` of `token` is known, \n     * add a Deposit for `account` and update the total amount Deposited.\n     *\n     * `s.ss[token].stalkIssuedPerBdv` stores the number of Stalk per BDV for `token`.\n     */\n    function depositWithBDV(\n        address account,\n        address token,\n        int96 stem,\n        uint256 amount,\n        uint256 bdv\n    ) internal returns (uint256 stalk) {\n        require(bdv > 0, \"Silo: No Beans under Token.\");\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        \n        incrementTotalDeposited(token, amount, bdv);\n        addDepositToAccount(\n            account, \n            token, \n            stem, \n            amount, \n            bdv, \n            Transfer.emitTransferSingle  \n        ); \n        stalk = bdv.mul(s.ss[token].stalkIssuedPerBdv);\n    }\n\n    /**\n     * @dev Add `amount` of `token` to a user's Deposit in `stemTipForToken`. Requires a\n     * precalculated `bdv`.\n     *\n     * If a Deposit doesn't yet exist, one is created. Otherwise, the existing\n     * Deposit is updated.\n     * \n     * `amount` & `bdv` are downcasted uint256 -> uint128 to optimize storage cost,\n     * since both values can be packed into one slot.\n     * \n     * Unlike {removeDepositFromAccount}, this function DOES EMIT an \n     * {AddDeposit} event. See {removeDepositFromAccount} for more details.\n     */\n    function addDepositToAccount(\n        address account,\n        address token,\n        int96 stem,\n        uint256 amount,\n        uint256 bdv,\n        Transfer transferType\n    ) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 depositId = LibBytes.packAddressAndStem(\n            token,\n            stem\n        );\n\n        // add amount to the deposits, and update the deposit.\n        s.a[account].deposits[depositId].amount = \n            s.a[account].deposits[depositId].amount.add(amount.toUint128());\n        s.a[account].deposits[depositId].bdv = \n            s.a[account].deposits[depositId].bdv.add(bdv.toUint128());\n        \n        // update the mow status (note: mow status is per token, not per depositId)\n        // SafeMath not necessary as the bdv is already checked to be <= type(uint128).max\n        s.a[account].mowStatuses[token].bdv = uint128(s.a[account].mowStatuses[token].bdv.add(uint128(bdv)));\n\n        /** \n         *  {addDepositToAccount} is used for both depositing and transferring deposits.\n         *  In the case of a deposit, only the {TransferSingle} Event needs to be emitted.\n         *  In the case of a transfer, a different {TransferSingle}/{TransferBatch} \n         *  Event is emitted in {TokenSilo._transferDeposit(s)}, \n         *  and thus, this event is ommited.\n         */\n        if(transferType == Transfer.emitTransferSingle){\n            emit TransferSingle(\n                msg.sender, // operator\n                address(0), // from\n                account, // to\n                uint256(depositId), // depositID\n                amount // token amount\n            );\n        }\n        emit AddDeposit(account, token, stem, amount, bdv);\n    }\n\n    //////////////////////// REMOVE DEPOSIT ////////////////////////\n\n    /**\n     * @dev Remove `amount` of `token` from a user's Deposit in `stem`.\n     *\n     * A \"Crate\" refers to the existing Deposit in storage at:\n     *  `s.a[account].deposits[token][stem]`\n     *\n     * Partially removing a Deposit should scale its BDV proportionally. For ex.\n     * removing 80% of the tokens from a Deposit should reduce its BDV by 80%.\n     *\n     * During an update, `amount` & `bdv` are cast uint256 -> uint128 to\n     * optimize storage cost, since both values can be packed into one slot.\n     *\n     * This function DOES **NOT** EMIT a {RemoveDeposit} event. This\n     * asymmetry occurs because {removeDepositFromAccount} is called in a loop\n     * in places where multiple deposits are removed simultaneously, including\n     * {TokenSilo-removeDepositsFromAccount} and {TokenSilo-_transferDeposits}.\n     */\n\n    function removeDepositFromAccount(\n        address account,\n        address token,\n        int96 stem,\n        uint256 amount\n    ) internal returns (uint256 crateBDV) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 depositId = LibBytes.packAddressAndStem(token,stem);\n\n        uint256 crateAmount = s.a[account].deposits[depositId].amount;\n        crateBDV = s.a[account].deposits[depositId].bdv;\n\n        require(amount <= crateAmount, \"Silo: Crate balance too low.\");\n\n        // Partial remove\n        if (amount < crateAmount) {\n            uint256 removedBDV = amount.mul(crateBDV).div(crateAmount);\n            uint256 updatedBDV = crateBDV.sub(removedBDV);\n            uint256 updatedAmount = crateAmount.sub(amount);\n\n            // SafeCast unnecessary b/c updatedAmount <= crateAmount and updatedBDV <= crateBDV, which are both <= type(uint128).max\n            s.a[account].deposits[depositId].amount = uint128(updatedAmount);\n            s.a[account].deposits[depositId].bdv = uint128(updatedBDV);\n            //remove from the mow status bdv amount, which keeps track of total token deposited per farmer\n            s.a[account].mowStatuses[token].bdv = s.a[account].mowStatuses[token].bdv.sub(\n                removedBDV.toUint128()\n            );\n            return removedBDV;\n        }\n        // Full remove\n        if (crateAmount > 0) delete s.a[account].deposits[depositId];\n\n\n        // SafeMath unnecessary b/c crateBDV <= type(uint128).max\n        s.a[account].mowStatuses[token].bdv = s.a[account].mowStatuses[token].bdv.sub(\n            uint128(crateBDV)\n        );\n    }\n\n    //////////////////////// GETTERS ////////////////////////\n\n    /**\n     * @dev Calculate the BDV (\"Bean Denominated Value\") for `amount` of `token`.\n     * \n     * Makes a call to a BDV function defined in the SiloSettings for this \n     * `token`. See {AppStorage.sol:Storage-SiloSettings} for more information.\n     */\n    function beanDenominatedValue(address token, uint256 amount)\n        internal\n        view\n        returns (uint256 bdv)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        require(s.ss[token].selector != bytes4(0), \"Silo: Token not whitelisted\");\n\n        (bool success, bytes memory data) = address(this).staticcall(\n            encodeBdvFunction(\n                token,\n                s.ss[token].encodeType,\n                s.ss[token].selector,\n                amount\n            )\n        );\n\n        if (!success) {\n            if (data.length == 0) revert();\n            assembly {\n                revert(add(32, data), mload(data))\n            }\n        }\n\n        assembly {\n            bdv := mload(add(data, add(0x20, 0)))\n        }\n    }\n\n    function encodeBdvFunction(\n        address token,\n        bytes1 encodeType,\n        bytes4 selector,\n        uint256 amount\n    )\n        internal\n        pure\n        returns (bytes memory callData)\n    {\n        if (encodeType == 0x00) {\n            callData = abi.encodeWithSelector(\n                selector,\n                amount\n            );\n        } else if (encodeType == 0x01) {\n            callData = abi.encodeWithSelector(\n                selector,\n                token,\n                amount\n            );\n        } else {\n            revert(\"Silo: Invalid encodeType\");\n        }\n    }\n\n    /**\n     * @dev Locate the `amount` and `bdv` for a user's Deposit in storage.\n     * \n     * Silo V3 Deposits are stored within each {Account} as a mapping of:\n     *  `uint256 DepositID => { uint128 amount, uint128 bdv }`\n     *  The DepositID is the concatination of the token address and the stem.\n     * \n     * Silo V2 deposits are only usable after a successful migration, see\n     * mowAndMigrate within the Migration facet.\n     *\n     */\n    function getDeposit(\n        address account,\n        address token,\n        int96 stem\n    ) internal view returns (uint256 amount, uint256 bdv) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 depositId = LibBytes.packAddressAndStem(\n            token,\n            stem\n        );\n        amount = s.a[account].deposits[depositId].amount;\n        bdv = s.a[account].deposits[depositId].bdv;\n    }\n    \n    /**\n     * @dev Get the number of Stalk per BDV per Season for a whitelisted token. Formerly just seeds.\n     * Note this is stored as 1e6, i.e. 1_000_000 units of this is equal to 1 old seed.\n     */\n    function stalkEarnedPerSeason(address token) internal view returns (uint256) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return uint256(s.ss[token].stalkEarnedPerSeason);\n    }\n\n    /**\n     * @dev Get the number of Stalk per BDV for a whitelisted token. Formerly just stalk.\n     */\n    function stalkIssuedPerBdv(address token) internal view returns (uint256) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return uint256(s.ss[token].stalkIssuedPerBdv);\n    }\n\n    /**\n     * @dev returns the cumulative stalk per BDV (stemTip) for a whitelisted token. \n     * Does not truncate the value, i.e. divide by 1e6\n     */\n    function stemTipForTokenUntruncated(address token)\n        internal\n        view\n        returns (int96 _stemTipForToken)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        \n        // SafeCast unnecessary because all casted variables are types smaller that int96.\n        _stemTipForToken = s.ss[token].milestoneStem +\n        int96(s.ss[token].stalkEarnedPerSeason).mul(\n            int96(s.season.current).sub(int96(s.ss[token].milestoneSeason))\n        );\n    }\n\n    /**\n     * @dev returns the cumulative stalk per BDV (stemTip) for a whitelisted token.\n     */\n    function stemTipForToken(address token)\n        internal\n        view\n        returns (int96 _stemTipForToken)\n    {\n        return stemTipForTokenUntruncated(token).div(1e6);\n    }\n\n    /**\n     * @dev returns the amount of grown stalk a deposit has earned.\n     */\n    function grownStalkForDeposit(\n        address account,\n        address token,\n        int96 stem\n    )\n        internal\n        view\n        returns (uint grownStalk)\n    {\n        // stemTipForToken(token) > depositGrownStalkPerBdv for all valid Deposits\n        int96 _stemTip = stemTipForToken(token);\n        require(stem <= _stemTip, \"Silo: Invalid Deposit\");\n         // The check in the above line guarantees that subtraction result is positive\n         // and thus the cast to `uint256` is safe.\n        uint deltaStemTip = uint256(_stemTip.sub(stem));\n        (, uint bdv) = getDeposit(account, token, stem);\n\n        grownStalk = deltaStemTip.mul(bdv);\n    }\n\n    /**\n     * @dev returns the amount of grown stalk a deposit would have, based on the stem of the deposit.\n     */\n    function calculateStalkFromStemAndBdv(address token, int96 grownStalkIndexOfDeposit, uint256 bdv)\n        internal\n        view\n        returns (int96 grownStalk)\n    {\n        // current latest grown stalk index\n        int96 _stemTipForToken = stemTipForToken(address(token));\n\n        return _stemTipForToken.sub(grownStalkIndexOfDeposit).mul(toInt96(bdv));\n    }\n\n    /**\n     * @dev returns the stem of a deposit, based on the amount of grown stalk it has earned.\n     */\n    function calculateGrownStalkAndStem(address token, uint256 grownStalk, uint256 bdv)\n        internal\n        view \n        returns (uint256 _grownStalk, int96 stem)\n    {\n        int96 _stemTipForToken = stemTipForToken(token);\n        stem = _stemTipForToken.sub(toInt96(grownStalk.div(bdv)));\n        _grownStalk = uint256(_stemTipForToken.sub(stem).mul(toInt96(bdv)));\n    }\n\n\n    /**\n     * @dev returns the amount of grown stalk a deposit would have, based on the stem of the deposit.\n     * Similar to calculateStalkFromStemAndBdv, but has an additional check to prevent division by 0.\n     */\n    function grownStalkAndBdvToStem(address token, uint256 grownStalk, uint256 bdv)\n        internal\n        view\n        returns (int96 cumulativeGrownStalk)\n    {\n        // first get current latest grown stalk index\n        int96 _stemTipForToken = stemTipForToken(token);\n        // then calculate how much stalk each individual bdv has grown\n        // there's a > 0 check here, because if you have a small amount of unripe bean deposit, the bdv could\n        // end up rounding to zero, then you get a divide by zero error and can't migrate without losing that deposit\n\n        // prevent divide by zero error\n        int96 grownStalkPerBdv = bdv > 0 ? toInt96(grownStalk.div(bdv)) : 0;\n\n        // subtract from the current latest index, so we get the index the deposit should have happened at\n        return _stemTipForToken.sub(grownStalkPerBdv);\n    }\n\n    function toInt96(uint256 value) internal pure returns (int96) {\n        require(value <= uint256(type(int96).max), \"SafeCast: value doesn't fit in an int96\");\n        return int96(value);\n    }\n}"
    },
    {
      "filename": "protocol/contracts/libraries/Silo/LibTokenSilo.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"../LibAppStorage.sol\";\nimport \"../../C.sol\";\nimport \"contracts/libraries/LibSafeMath32.sol\";\nimport \"contracts/libraries/LibSafeMath128.sol\";\nimport \"contracts/libraries/LibSafeMathSigned128.sol\";\nimport \"contracts/libraries/LibSafeMathSigned96.sol\";\nimport \"contracts/libraries/LibBytes.sol\";\n\n\n/**\n * @title LibTokenSilo\n * @author Publius, Pizzaman1337\n * @notice Contains functions for depositing, withdrawing and claiming\n * whitelisted Silo tokens.\n *\n * For functionality related to Stalk, and Roots, see {LibSilo}.\n */\nlibrary LibTokenSilo {\n    using SafeMath for uint256;\n    using LibSafeMath128 for uint128;\n    using LibSafeMath32 for uint32;\n    using LibSafeMathSigned128 for int128;\n    using SafeCast for int128;\n    using SafeCast for uint256;\n    using LibSafeMathSigned96 for int96;\n\n\n    //////////////////////// ENUM ////////////////////////\n    /**\n     * @dev when a user deposits or withdraws a deposit, the\n     * {TrasferSingle} event is emitted. However, in the case\n     * of a transfer, this emission is ommited. This enum is\n     * used to determine if the event should be emitted.\n     */\n    enum Transfer {\n        emitTransferSingle,\n        noEmitTransferSingle\n    }\n\n    //////////////////////// EVENTS ////////////////////////\n\n    /**\n     * @dev IMPORTANT: copy of {TokenSilo-AddDeposit}, check there for details.\n     */\n    event AddDeposit(\n        address indexed account,\n        address indexed token,\n        int96 stem,\n        uint256 amount,\n        uint256 bdv\n    );\n\n    // added as the ERC1155 deposit upgrade\n    event TransferSingle(\n        address indexed operator, \n        address indexed sender, \n        address indexed recipient, \n        uint256 depositId, \n        uint256 amount\n    );\n\n\n    //////////////////////// ACCOUNTING: TOTALS ////////////////////////\n    \n    /**\n     * @dev Increment the total amount and bdv of `token` deposited in the Silo.\n     */\n    function incrementTotalDeposited(address token, uint256 amount, uint256 bdv) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.siloBalances[token].deposited = s.siloBalances[token].deposited.add(\n            amount.toUint128()\n        );\n        s.siloBalances[token].depositedBdv = s.siloBalances[token].depositedBdv.add(\n            bdv.toUint128()\n        );\n    }\n\n    /**\n     * @dev Decrement the total amount and bdv of `token` deposited in the Silo.\n     */\n    function decrementTotalDeposited(address token, uint256 amount, uint256 bdv) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.siloBalances[token].deposited = s.siloBalances[token].deposited.sub(\n            amount.toUint128()\n        );\n        s.siloBalances[token].depositedBdv = s.siloBalances[token].depositedBdv.sub(\n            bdv.toUint128()\n        );\n    }\n\n    /**\n     * @dev Increment the total bdv of `token` deposited in the Silo. Used in Enroot.\n     */\n    function incrementTotalDepositedBdv(address token, uint256 bdv) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.siloBalances[token].depositedBdv = s.siloBalances[token].depositedBdv.add(\n            bdv.toUint128()\n        );\n    }\n\n    //////////////////////// ADD DEPOSIT ////////////////////////\n\n    /**\n     * @return stalk The amount of Stalk received for this Deposit.\n     * \n     * @dev Calculate the current BDV for `amount` of `token`, then perform \n     * Deposit accounting.\n     */\n    function deposit(\n        address account,\n        address token,\n        int96 stem,\n        uint256 amount\n    ) internal returns (uint256) {\n        uint256 bdv = beanDenominatedValue(token, amount);\n        return depositWithBDV(account, token, stem, amount, bdv);\n    }\n\n    /**\n     * @dev Once the BDV received for Depositing `amount` of `token` is known, \n     * add a Deposit for `account` and update the total amount Deposited.\n     *\n     * `s.ss[token].stalkIssuedPerBdv` stores the number of Stalk per BDV for `token`.\n     */\n    function depositWithBDV(\n        address account,\n        address token,\n        int96 stem,\n        uint256 amount,\n        uint256 bdv\n    ) internal returns (uint256 stalk) {\n        require(bdv > 0, \"Silo: No Beans under Token.\");\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        \n        incrementTotalDeposited(token, amount, bdv);\n        addDepositToAccount(\n            account, \n            token, \n            stem, \n            amount, \n            bdv, \n            Transfer.emitTransferSingle  \n        ); \n        stalk = bdv.mul(s.ss[token].stalkIssuedPerBdv);\n    }\n\n    /**\n     * @dev Add `amount` of `token` to a user's Deposit in `stemTipForToken`. Requires a\n     * precalculated `bdv`.\n     *\n     * If a Deposit doesn't yet exist, one is created. Otherwise, the existing\n     * Deposit is updated.\n     * \n     * `amount` & `bdv` are downcasted uint256 -> uint128 to optimize storage cost,\n     * since both values can be packed into one slot.\n     * \n     * Unlike {removeDepositFromAccount}, this function DOES EMIT an \n     * {AddDeposit} event. See {removeDepositFromAccount} for more details.\n     */\n    function addDepositToAccount(\n        address account,\n        address token,\n        int96 stem,\n        uint256 amount,\n        uint256 bdv,\n        Transfer transferType\n    ) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 depositId = LibBytes.packAddressAndStem(\n            token,\n            stem\n        );\n\n        // add amount to the deposits, and update the deposit.\n        s.a[account].deposits[depositId].amount = \n            s.a[account].deposits[depositId].amount.add(amount.toUint128());\n        s.a[account].deposits[depositId].bdv = \n            s.a[account].deposits[depositId].bdv.add(bdv.toUint128());\n        \n        // update the mow status (note: mow status is per token, not per depositId)\n        // SafeMath not necessary as the bdv is already checked to be <= type(uint128).max\n        s.a[account].mowStatuses[token].bdv = uint128(s.a[account].mowStatuses[token].bdv.add(uint128(bdv)));\n\n        /** \n         *  {addDepositToAccount} is used for both depositing and transferring deposits.\n         *  In the case of a deposit, only the {TransferSingle} Event needs to be emitted.\n         *  In the case of a transfer, a different {TransferSingle}/{TransferBatch} \n         *  Event is emitted in {TokenSilo._transferDeposit(s)}, \n         *  and thus, this event is ommited.\n         */\n        if(transferType == Transfer.emitTransferSingle){\n            emit TransferSingle(\n                msg.sender, // operator\n                address(0), // from\n                account, // to\n                uint256(depositId), // depositID\n                amount // token amount\n            );\n        }\n        emit AddDeposit(account, token, stem, amount, bdv);\n    }\n\n    //////////////////////// REMOVE DEPOSIT ////////////////////////\n\n    /**\n     * @dev Remove `amount` of `token` from a user's Deposit in `stem`.\n     *\n     * A \"Crate\" refers to the existing Deposit in storage at:\n     *  `s.a[account].deposits[token][stem]`\n     *\n     * Partially removing a Deposit should scale its BDV proportionally. For ex.\n     * removing 80% of the tokens from a Deposit should reduce its BDV by 80%.\n     *\n     * During an update, `amount` & `bdv` are cast uint256 -> uint128 to\n     * optimize storage cost, since both values can be packed into one slot.\n     *\n     * This function DOES **NOT** EMIT a {RemoveDeposit} event. This\n     * asymmetry occurs because {removeDepositFromAccount} is called in a loop\n     * in places where multiple deposits are removed simultaneously, including\n     * {TokenSilo-removeDepositsFromAccount} and {TokenSilo-_transferDeposits}.\n     */\n\n    function removeDepositFromAccount(\n        address account,\n        address token,\n        int96 stem,\n        uint256 amount\n    ) internal returns (uint256 crateBDV) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 depositId = LibBytes.packAddressAndStem(token,stem);\n\n        uint256 crateAmount = s.a[account].deposits[depositId].amount;\n        crateBDV = s.a[account].deposits[depositId].bdv;\n\n        require(amount <= crateAmount, \"Silo: Crate balance too low.\");\n\n        // Partial remove\n        if (amount < crateAmount) {\n            uint256 removedBDV = amount.mul(crateBDV).div(crateAmount);\n            uint256 updatedBDV = crateBDV.sub(removedBDV);\n            uint256 updatedAmount = crateAmount.sub(amount);\n\n            // SafeCast unnecessary b/c updatedAmount <= crateAmount and updatedBDV <= crateBDV, which are both <= type(uint128).max\n            s.a[account].deposits[depositId].amount = uint128(updatedAmount);\n            s.a[account].deposits[depositId].bdv = uint128(updatedBDV);\n            //remove from the mow status bdv amount, which keeps track of total token deposited per farmer\n            s.a[account].mowStatuses[token].bdv = s.a[account].mowStatuses[token].bdv.sub(\n                removedBDV.toUint128()\n            );\n            return removedBDV;\n        }\n        // Full remove\n        if (crateAmount > 0) delete s.a[account].deposits[depositId];\n\n\n        // SafeMath unnecessary b/c crateBDV <= type(uint128).max\n        s.a[account].mowStatuses[token].bdv = s.a[account].mowStatuses[token].bdv.sub(\n            uint128(crateBDV)\n        );\n    }\n\n    //////////////////////// GETTERS ////////////////////////\n\n    /**\n     * @dev Calculate the BDV (\"Bean Denominated Value\") for `amount` of `token`.\n     * \n     * Makes a call to a BDV function defined in the SiloSettings for this \n     * `token`. See {AppStorage.sol:Storage-SiloSettings} for more information.\n     */\n    function beanDenominatedValue(address token, uint256 amount)\n        internal\n        view\n        returns (uint256 bdv)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        require(s.ss[token].selector != bytes4(0), \"Silo: Token not whitelisted\");\n\n        (bool success, bytes memory data) = address(this).staticcall(\n            encodeBdvFunction(\n                token,\n                s.ss[token].encodeType,\n                s.ss[token].selector,\n                amount\n            )\n        );\n\n        if (!success) {\n            if (data.length == 0) revert();\n            assembly {\n                revert(add(32, data), mload(data))\n            }\n        }\n\n        assembly {\n            bdv := mload(add(data, add(0x20, 0)))\n        }\n    }\n\n    function encodeBdvFunction(\n        address token,\n        bytes1 encodeType,\n        bytes4 selector,\n        uint256 amount\n    )\n        internal\n        pure\n        returns (bytes memory callData)\n    {\n        if (encodeType == 0x00) {\n            callData = abi.encodeWithSelector(\n                selector,\n                amount\n            );\n        } else if (encodeType == 0x01) {\n            callData = abi.encodeWithSelector(\n                selector,\n                token,\n                amount\n            );\n        } else {\n            revert(\"Silo: Invalid encodeType\");\n        }\n    }\n\n    /**\n     * @dev Locate the `amount` and `bdv` for a user's Deposit in storage.\n     * \n     * Silo V3 Deposits are stored within each {Account} as a mapping of:\n     *  `uint256 DepositID => { uint128 amount, uint128 bdv }`\n     *  The DepositID is the concatination of the token address and the stem.\n     * \n     * Silo V2 deposits are only usable after a successful migration, see\n     * mowAndMigrate within the Migration facet.\n     *\n     */\n    function getDeposit(\n        address account,\n        address token,\n        int96 stem\n    ) internal view returns (uint256 amount, uint256 bdv) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 depositId = LibBytes.packAddressAndStem(\n            token,\n            stem\n        );\n        amount = s.a[account].deposits[depositId].amount;\n        bdv = s.a[account].deposits[depositId].bdv;\n    }\n    \n    /**\n     * @dev Get the number of Stalk per BDV per Season for a whitelisted token. Formerly just seeds.\n     * Note this is stored as 1e6, i.e. 1_000_000 units of this is equal to 1 old seed.\n     */\n    function stalkEarnedPerSeason(address token) internal view returns (uint256) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return uint256(s.ss[token].stalkEarnedPerSeason);\n    }\n\n    /**\n     * @dev Get the number of Stalk per BDV for a whitelisted token. Formerly just stalk.\n     */\n    function stalkIssuedPerBdv(address token) internal view returns (uint256) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return uint256(s.ss[token].stalkIssuedPerBdv);\n    }\n\n    /**\n     * @dev returns the cumulative stalk per BDV (stemTip) for a whitelisted token.\n     */\n    function stemTipForToken(address token)\n        internal\n        view\n        returns (int96 _stemTipForToken)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        \n        // SafeCast unnecessary because all casted variables are types smaller that int96.\n        _stemTipForToken = s.ss[token].milestoneStem +\n        int96(s.ss[token].stalkEarnedPerSeason).mul(\n            int96(s.season.current).sub(int96(s.ss[token].milestoneSeason))\n        ).div(1e6); //round here \n    }\n\n    /**\n     * @dev returns the amount of grown stalk a deposit has earned.\n     */\n    function grownStalkForDeposit(\n        address account,\n        address token,\n        int96 stem\n    )\n        internal\n        view\n        returns (uint grownStalk)\n    {\n        // stemTipForToken(token) > depositGrownStalkPerBdv for all valid Deposits\n        int96 _stemTip = stemTipForToken(token);\n        require(stem <= _stemTip, \"Silo: Invalid Deposit\");\n         // The check in the above line guarantees that subtraction result is positive\n         // and thus the cast to `uint256` is safe.\n        uint deltaStemTip = uint256(_stemTip.sub(stem));\n        (, uint bdv) = getDeposit(account, token, stem);\n\n        grownStalk = deltaStemTip.mul(bdv);\n    }\n\n    /**\n     * @dev returns the amount of grown stalk a deposit would have, based on the stem of the deposit.\n     */\n    function calculateStalkFromStemAndBdv(address token, int96 grownStalkIndexOfDeposit, uint256 bdv)\n        internal\n        view\n        returns (int96 grownStalk)\n    {\n        // current latest grown stalk index\n        int96 _stemTipForToken = stemTipForToken(address(token));\n\n        return _stemTipForToken.sub(grownStalkIndexOfDeposit).mul(toInt96(bdv));\n    }\n\n    /**\n     * @dev returns the stem of a deposit, based on the amount of grown stalk it has earned.\n     */\n    function calculateGrownStalkAndStem(address token, uint256 grownStalk, uint256 bdv)\n        internal\n        view \n        returns (uint256 _grownStalk, int96 stem)\n    {\n        int96 _stemTipForToken = stemTipForToken(token);\n        stem = _stemTipForToken.sub(toInt96(grownStalk.div(bdv)));\n        _grownStalk = uint256(_stemTipForToken.sub(stem).mul(toInt96(bdv)));\n    }\n\n\n    /**\n     * @dev returns the amount of grown stalk a deposit would have, based on the stem of the deposit.\n     * Similar to calculateStalkFromStemAndBdv, but has an additional check to prevent division by 0."
    }
  ]
}