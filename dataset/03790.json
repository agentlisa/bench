{
  "Title": "[L12] Order of arithmetic operations reduces the outcome’s precision",
  "Content": "In the [`Oracle` contract](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/oracle/Oracle.sol#L34) the [price update](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/oracle/Oracle.sol#L196) is done by first dividing the difference between the current accumulated price and the stored one by the elapsed time, and then dividing again by `2**112`, using the [`ratio` method from the `Decimal` library](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/lib/Decimal.sol#L101), to get the output in price units.\n\n\nHowever, the precision of the outcome could be increased by altering the order of the operations by multiplying the time elapsed and the `2**112` factor to then take the ratio of it, which internally multiplies first the numerator with the [`BASE` constant](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/lib/Decimal.sol#L38).\n\n\nConsider changing the order of the arithmetic operations to improve the outcome’s precision.\n\n\n***Update**: Acknowledged. The EmptySetSquad team statement for this issue:*\n\n\n\n> \n> *Won’t fix – effect on oracle is negligible, so we’d prefer to leave as is to increase readability by separating the numeric computation from the base conversion.*\n> \n> \n> \n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/src/oracle/Oracle.sol",
      "content": "/*\n    Copyright 2020, 2021 Empty Set Squad <emptysetsquad@protonmail.com>\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\nimport '../lib/UniswapV2OracleLibrary.sol';\nimport '../lib/UniswapV2Library.sol';\nimport \"../lib/Decimal.sol\";\nimport \"../Interfaces.sol\";\n\n/**\n * @title Oracle\n * @notice Generic ownable USDC-based Uniswap V2 TWAP oracle\n * @dev Tracks the USDC price for any registered ERC20 token\n *      The owner may capture TWAP updates at any interval\n */\ncontract Oracle is IOracle, Ownable {\n    using Decimal for Decimal.D256;\n\n    /**\n     * @notice Uniswap V2 factory address\n     */\n    address private constant UNISWAP_FACTORY = address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\n\n    /**\n     * @notice Minimum USDC liquidity for a pool to be considered healthy\n     */\n    uint256 private constant ORACLE_RESERVE_MINIMUM = 1e10; // 10,000 USDC\n\n    /**\n     * @notice State for a single ERC20 token's TWAP oracle\n     */\n    struct Market {\n\n        /**\n         * @notice ERC20 token that is being tracked\n         */\n        address token;\n\n        /**\n         * @notice Corresponding Uniswap V2 USDC-token pair\n         */\n        IUniswapV2Pair pair;\n\n        /**\n         * @notice Index of token in the pair: 0, token == token0; 1, token == token1\n         */\n        uint256 index;\n\n        /**\n         * @notice Has this market been initialized\n         */\n        bool initialized;\n\n        /**\n         * @notice The last recorded cumulative price counter\n         */\n        uint256 cumulative;\n\n        /**\n         * @notice The timestamp of the last recorded cumulative price counter\n         */\n        uint32 timestamp;\n    }\n\n    /**\n     * @notice Address of the USDC token\n     */\n    address public usdc;\n\n    /**\n     * @notice Mapping of all registered markets\n     */\n    mapping(address => Market) internal _markets;\n\n    /**\n     * @notice Construct the oracle contract\n     * @param usdc_ Address of the USDC token\n     */\n    constructor(address usdc_) public {\n        usdc = usdc_;\n    }\n\n    /**\n     * @notice Setup the token for price tracking\n     * @dev Owner only\n     *      Must be called before capture will return a healthy state for the token\n     * @param token EC20 token to register\n     */\n    function setup(address token) public onlyOwner {\n        _markets[token].token = token;\n        _markets[token].pair = _createOrGetPair(token);\n\n        IUniswapV2Pair pair = pairFor(token);\n        (address token0, address token1) = (pair.token0(), pair.token1());\n        _markets[token].index = token == token0 ? 0 : 1;\n\n        require(token == token0 || token == token1, \"Oracle: token not found\");\n        require(usdc == token0 || usdc == token1, \"Oracle: USDC not found\");\n        require(token0 != token1, \"Oracle: token is USDC\");\n    }\n\n    /**\n     * @notice Capture the TWAP price since last capture\n     * @dev Owner only\n     *\n     *      Can be called at any cadence by the owner, returns the elapsed seconds since last call\n     *      for further computation by the consumer\n     *\n     *      Trades/Liquidity: (1) Initializes reserve and blockTimestampLast (can calculate a price)\n     *                        (2) Has non-zero cumulative prices\n     *\n     *      Steps: (1) Captures a reference blockTimestampLast\n     *             (2) First reported value\n     *\n     * @param token EC20 token to capture\n     * @return The price decimal-normalized as a Decimal.256, seconds since last capture, and oracle health flag\n     */\n    function capture(address token) public onlyOwner returns (Decimal.D256 memory, uint256, bool) {\n\n        // The owner has not yet setup this market\n        if (!setupFor(token)) {\n            return (Decimal.one(), 0, false);\n        }\n\n        // This is the first capture call for the market, initialize\n        if (!initializedFor(token)) {\n            _initializeOracle(token);\n            return (Decimal.one(), 0, false);\n        }\n\n        // Market is setup and initialized, proceed as normal\n        return _updateOracle(token);\n    }\n\n    /**\n     * @notice Capture the initial window and initial state for the specific market\n     * @dev Internal only - helper\n     *      Is called on the first capture for each market\n     * @param token EC20 token to initialize\n     */\n    function _initializeOracle(address token) private {\n        IUniswapV2Pair pair = pairFor(token);\n        uint256 priceCumulative = _choose(token, pair.price0CumulativeLast(), pair.price1CumulativeLast());\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = pair.getReserves();\n        if(reserve0 != 0 && reserve1 != 0 && blockTimestampLast != 0) {\n            _updateMarket(token, priceCumulative, blockTimestampLast);\n            _markets[token].initialized = true;\n        }\n    }\n\n    /**\n    /**\n     * @notice Captures TWAP data then checks the health of the oracle\n     * @dev Internal only - helper\n     * @param token EC20 token to capture\n     * @return The price decimal-normalized as a Decimal.256, seconds since last capture, and oracle health flag\n     */\n    function _updateOracle(address token) private returns (Decimal.D256 memory price, uint256 elapsed, bool valid) {\n        (price, elapsed) = _updatePrice(token);\n        bool isBlacklisted = IUSDC(usdc).isBlacklisted(address(pairFor(token)));\n        valid = !isBlacklisted && (_liquidity(token) >= ORACLE_RESERVE_MINIMUM);\n    }\n\n    /**\n     * @notice Captures oracle data from Uniswap V2, computes and stores the new TWAP oracle state\n     * @dev Internal only - helper\n     *      If no time has passed, returns a default 1.00 price\n     * @param token EC20 token to capture\n     * @return The price decimal-normalized as a Decimal.256, seconds since last capture\n     */\n    function _updatePrice(address token) private returns (Decimal.D256 memory, uint256) {\n        (uint256 price0Cumulative, uint256 price1Cumulative, uint32 blockTimestamp) =\n            UniswapV2OracleLibrary.currentCumulativePrices(address(pairFor(token)));\n        uint32 timeElapsed = blockTimestamp - timestampFor(token); // overflow is desired\n        if (timeElapsed == 0) return (Decimal.one(), 0);\n\n        uint256 priceCumulative = _choose(token, price0Cumulative, price1Cumulative);\n        Decimal.D256 memory price = Decimal.ratio((priceCumulative - cumulativeFor(token)) / timeElapsed, 2**112);\n\n        _updateMarket(token, priceCumulative, blockTimestamp);\n\n        return (_normalize(token, price), uint256(timeElapsed));\n    }\n\n    // GETTERS\n\n    /**\n     * @notice Whether the `token` has been setup by the owner\n     * @param token EC20 token to check\n     * @return token setup status\n     */\n    function setupFor(address token) public view returns (bool) {\n        return _markets[token].token != address(0);\n    }\n\n    /**\n     * @notice Whether the market for `token` has been initialized\n     * @param token EC20 token to check\n     * @return token initialization status\n     */\n    function initializedFor(address token) public view returns (bool) {\n        return _markets[token].initialized;\n    }\n\n    /**\n     * @notice The cumulative price counter for the `token` market\n     * @param token EC20 token to check\n     * @return Cumulative price counter\n     */\n    function cumulativeFor(address token) public view returns (uint256) {\n        return _markets[token].cumulative;\n    }\n\n    /**\n     * @notice The last timestamp cumulative price counter was updated for the `token` market\n     * @param token EC20 token to check\n     * @return Last update timestamp\n     */\n    function timestampFor(address token) public view returns (uint32) {\n        return _markets[token].timestamp;\n    }\n\n    /**\n     * @notice The address of the USDC-`token` Uniswap V2 pair\n     * @param token EC20 token to check\n     * @return Uniswap V2 pair address\n     */\n    function pairFor(address token) public view returns (IUniswapV2Pair) {\n        return _markets[token].pair;\n    }\n\n    // INTERNAL\n\n    /**\n     * @notice Creates the USDC-`token` Uniswap V2 if it does not already exist\n     * @dev Internal only - helper\n     * @param token EC20 token to create for\n     * @return The existing or new pair address\n     */\n    function _createOrGetPair(address token) internal returns (IUniswapV2Pair) {\n        address pair = IUniswapV2Factory(UNISWAP_FACTORY).getPair(usdc, token);\n        if (pair == address(0)) {\n            return IUniswapV2Pair(IUniswapV2Factory(UNISWAP_FACTORY).createPair(usdc, token));\n        }\n        return IUniswapV2Pair(pair);\n    }\n\n    /**\n     * @notice Stores the new `cumulative` and `timestamp` state for the `token` market\n     * @dev Internal only\n     * @param token EC20 token to update\n     * @param cumulative New cumulative price counter value\n     * @param timestamp New latest updated timestamp value\n     */\n    function _updateMarket(address token, uint256 cumulative, uint32 timestamp) private {\n        _markets[token].timestamp = timestamp;\n        _markets[token].cumulative = cumulative;\n    }\n\n    /**\n     * @notice Normalizes `price` for the difference in decimals between USDC and `token`\n     * @dev Internal only - helper\n     * @param token EC20 token for the price that is being normalized\n     * @param price Decimal.D256 price to normalize\n     * @return normalized Decimal.D256 price\n     */\n    function _normalize(address token, Decimal.D256 memory price) private view returns (Decimal.D256 memory) {\n        uint8 decimals = IToken(token).decimals();\n        if (decimals > 6) {\n            return price.mul(10 ** (uint256(decimals) - 6));\n        } else if (decimals < 6) {\n            return price.mul(10 ** (6 - uint256(decimals)));\n        }\n        return price;\n    }\n\n    /**\n     * @notice Retrieve the total amount of USDC liquidity currently in the `token` market\n     * @dev Internal only - helper\n     * @param token EC20 token to retrieve liquidity for\n     * @return total USDC supplied to USDC-`token` market\n     */\n    function _liquidity(address token) private view returns (uint256) {\n        (uint112 reserve0, uint112 reserve1,) = _markets[token].pair.getReserves();\n        return _choose(token, uint256(reserve1), uint256(reserve0)); // get counter's reserve\n    }\n\n    /**\n     * @notice Choose between two values based on the index of the `token` market\n     * @dev Internal only - helper\n     * @param token EC20 token to choose for\n     * @param index0Value Value if market index is 0\n     * @param index1Value Value if market index is 1\n     * @return index == 0, index0Value; index == 1, index1Value\n     */\n    function _choose(address token, uint256 index0Value, uint256 index1Value) private view returns (uint256) {\n        return _markets[token].index == 0 ? index0Value : index1Value;\n    }\n}"
    },
    {
      "filename": "protocol/contracts/src/lib/Decimal.sol",
      "content": "/*\n    Copyright 2019 dYdX Trading Inc.\n    Copyright 2020, 2021 Empty Set Squad <emptysetsquad@protonmail.com>\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/**\n * @title Decimal\n * @notice Library that defines a fixed-point number with 18 decimal places.\n *\n * audit-info: Extended from dYdX's Decimal library:\n *             https://github.com/dydxprotocol/solo/blob/master/contracts/protocol/lib/Decimal.sol\n */\nlibrary Decimal {\n    using SafeMath for uint256;\n\n    // ============ Constants ============\n\n    /**\n     * @notice Fixed-point base for Decimal.D256 values\n     */\n    uint256 constant BASE = 10**18;\n\n    // ============ Structs ============\n\n\n    /**\n     * @notice Main struct to hold Decimal.D256 state\n     * @dev Represents the number value / BASE\n     */\n    struct D256 {\n        /**\n         * @notice Underlying value of the Decimal.D256\n         */\n        uint256 value;\n    }\n\n    // ============ Static Functions ============\n\n    /**\n     * @notice Returns a new Decimal.D256 struct initialized to represent 0.0\n     * @return Decimal.D256 representation of 0.0\n     */\n    function zero()\n    internal\n    pure\n    returns (D256 memory)\n    {\n        return D256({ value: 0 });\n    }\n\n    /**\n     * @notice Returns a new Decimal.D256 struct initialized to represent 1.0\n     * @return Decimal.D256 representation of 1.0\n     */\n    function one()\n    internal\n    pure\n    returns (D256 memory)\n    {\n        return D256({ value: BASE });\n    }\n\n    /**\n     * @notice Returns a new Decimal.D256 struct initialized to represent `a`\n     * @param a Integer to transform to Decimal.D256 type\n     * @return Decimal.D256 representation of integer`a`\n     */\n    function from(\n        uint256 a\n    )\n    internal\n    pure\n    returns (D256 memory)\n    {\n        return D256({ value: a.mul(BASE) });\n    }\n\n    /**\n     * @notice Returns a new Decimal.D256 struct initialized to represent `a` / `b`\n     * @param a Numerator of ratio to transform to Decimal.D256 type\n     * @param b Denominator of ratio to transform to Decimal.D256 type\n     * @return Decimal.D256 representation of ratio `a` / `b`\n     */\n    function ratio(\n        uint256 a,\n        uint256 b\n    )\n    internal\n    pure\n    returns (D256 memory)\n    {\n        return D256({ value: getPartial(a, BASE, b) });\n    }\n\n    // ============ Self Functions ============\n\n    /**\n     * @notice Adds integer `b` to Decimal.D256 `self`\n     * @param self Original Decimal.D256 number\n     * @param b Integer to add to `self`\n     * @return Resulting Decimal.D256\n     */\n    function add(\n        D256 memory self,\n        uint256 b\n    )\n    internal\n    pure\n    returns (D256 memory)\n    {\n        return D256({ value: self.value.add(b.mul(BASE)) });\n    }\n\n    /**\n     * @notice Subtracts integer `b` from Decimal.D256 `self`\n     * @param self Original Decimal.D256 number\n     * @param b Integer to subtract from `self`\n     * @return Resulting Decimal.D256\n     */\n    function sub(\n        D256 memory self,\n        uint256 b\n    )\n    internal\n    pure\n    returns (D256 memory)\n    {\n        return D256({ value: self.value.sub(b.mul(BASE)) });\n    }\n\n    /**\n     * @notice Subtracts integer `b` from Decimal.D256 `self`\n     * @dev Reverts on underflow with reason `reason`\n     * @param self Original Decimal.D256 number\n     * @param b Integer to subtract from `self`\n     * @param reason Revert reason\n     * @return Resulting Decimal.D256\n     */\n    function sub(\n        D256 memory self,\n        uint256 b,\n        string memory reason\n    )\n    internal\n    pure\n    returns (D256 memory)\n    {\n        return D256({ value: self.value.sub(b.mul(BASE), reason) });\n    }\n\n    /**\n     * @notice Subtracts integer `b` from Decimal.D256 `self`\n     * @param self Original Decimal.D256 number\n     * @param b Integer to subtract from `self`\n     * @return 0 on underflow, or the Resulting Decimal.D256\n     */\n    function subOrZero(\n        D256 memory self,\n        uint256 b\n    )\n    internal\n    pure\n    returns (D256 memory)\n    {\n        uint256 amount = b.mul(BASE);\n        return D256({ value: self.value > amount ? self.value.sub(amount) : 0 });\n    }\n\n    /**\n     * @notice Multiplies Decimal.D256 `self` by integer `b`\n     * @param self Original Decimal.D256 number\n     * @param b Integer to multiply `self` by\n     * @return Resulting Decimal.D256\n     */\n    function mul(\n        D256 memory self,\n        uint256 b\n    )\n    internal\n    pure\n    returns (D256 memory)\n    {\n        return D256({ value: self.value.mul(b) });\n    }\n\n    /**\n     * @notice Divides Decimal.D256 `self` by integer `b`\n     * @param self Original Decimal.D256 number\n     * @param b Integer to divide `self` by\n     * @return Resulting Decimal.D256\n     */\n    function div(\n        D256 memory self,\n        uint256 b\n    )\n    internal\n    pure\n    returns (D256 memory)\n    {\n        return D256({ value: self.value.div(b) });\n    }\n\n    /**\n     * @notice Divides Decimal.D256 `self` by integer `b`\n     * @dev Reverts on divide-by-zero with reason `reason`\n     * @param self Original Decimal.D256 number\n     * @param b Integer to divide `self` by\n     * @param reason Revert reason\n     * @return Resulting Decimal.D256\n     */\n    function div(\n        D256 memory self,\n        uint256 b,\n        string memory reason\n    )\n    internal\n    pure\n    returns (D256 memory)\n    {\n        return D256({ value: self.value.div(b, reason) });\n    }\n\n    /**\n     * @notice Exponentiates Decimal.D256 `self` to the power of integer `b`\n     * @dev Not optimized - is only suitable to use with small exponents\n     * @param self Original Decimal.D256 number\n     * @param b Integer exponent\n     * @return Resulting Decimal.D256\n     */\n    function pow(\n        D256 memory self,\n        uint256 b\n    )\n    internal\n    pure\n    returns (D256 memory)\n    {\n        if (b == 0) {\n            return from(1);\n        }\n\n        D256 memory temp = D256({ value: self.value });\n        for (uint256 i = 1; i < b; i++) {\n            temp = mul(temp, self);\n        }\n\n        return temp;\n    }\n\n    /**\n     * @notice Adds Decimal.D256 `b` to Decimal.D256 `self`\n     * @param self Original Decimal.D256 number\n     * @param b Decimal.D256 to add to `self`\n     * @return Resulting Decimal.D256\n     */\n    function add(\n        D256 memory self,\n        D256 memory b\n    )\n    internal\n    pure\n    returns (D256 memory)\n    {\n        return D256({ value: self.value.add(b.value) });\n    }\n\n    /**\n     * @notice Subtracts Decimal.D256 `b` from Decimal.D256 `self`\n     * @param self Original Decimal.D256 number\n     * @param b Decimal.D256 to subtract from `self`\n     * @return Resulting Decimal.D256\n     */\n    function sub(\n        D256 memory self,\n        D256 memory b\n    )\n    internal\n    pure\n    returns (D256 memory)\n    {\n        return D256({ value: self.value.sub(b.value) });\n    }\n\n    /**\n     * @notice Subtracts Decimal.D256 `b` from Decimal.D256 `self`\n     * @dev Reverts on underflow with reason `reason`\n     * @param self Original Decimal.D256 number\n     * @param b Decimal.D256 to subtract from `self`\n     * @param reason Revert reason\n     * @return Resulting Decimal.D256\n     */\n    function sub(\n        D256 memory self,\n        D256 memory b,\n        string memory reason\n    )\n    internal\n    pure\n    returns (D256 memory)\n    {\n        return D256({ value: self.value.sub(b.value, reason) });\n    }\n\n    /**\n     * @notice Subtracts Decimal.D256 `b` from Decimal.D256 `self`\n     * @param self Original Decimal.D256 number\n     * @param b Decimal.D256 to subtract from `self`\n     * @return 0 on underflow, or the Resulting Decimal.D256\n     */\n    function subOrZero(\n        D256 memory self,\n        D256 memory b\n    )\n    internal\n    pure\n    returns (D256 memory)\n    {\n        return D256({ value: self.value > b.value ? self.value.sub(b.value) : 0 });\n    }\n\n    /**\n     * @notice Multiplies Decimal.D256 `self` by Decimal.D256 `b`\n     * @param self Original Decimal.D256 number\n     * @param b Decimal.D256 to multiply `self` by\n     * @return Resulting Decimal.D256\n     */\n    function mul(\n        D256 memory self,\n        D256 memory b\n    )\n    internal\n    pure\n    returns (D256 memory)\n    {\n        return D256({ value: getPartial(self.value, b.value, BASE) });\n    }\n\n    /**\n     * @notice Divides Decimal.D256 `self` by Decimal.D256 `b`\n     * @param self Original Decimal.D256 number\n     * @param b Decimal.D256 to divide `self` by\n     * @return Resulting Decimal.D256\n     */\n    function div(\n        D256 memory self,\n        D256 memory b\n    )\n    internal\n    pure\n    returns (D256 memory)\n    {\n        return D256({ value: getPartial(self.value, BASE, b.value) });\n    }\n\n    /**\n     * @notice Divides Decimal.D256 `self` by Decimal.D256 `b`\n     * @dev Reverts on divide-by-zero with reason `reason`\n     * @param self Original Decimal.D256 number\n     * @param b Decimal.D256 to divide `self` by\n     * @param reason Revert reason\n     * @return Resulting Decimal.D256\n     */\n    function div(\n        D256 memory self,\n        D256 memory b,\n        string memory reason\n    )\n    internal\n    pure\n    returns (D256 memory)\n    {\n        return D256({ value: getPartial(self.value, BASE, b.value, reason) });\n    }\n\n    /**\n     * @notice Checks if `b` is equal to `self`\n     * @param self Original Decimal.D256 number\n     * @param b Decimal.D256 to compare\n     * @return Whether `b` is equal to `self`\n     */\n    function equals(D256 memory self, D256 memory b) internal pure returns (bool) {\n        return self.value == b.value;\n    }\n\n    /**\n     * @notice Checks if `b` is greater than `self`\n     * @param self Original Decimal.D256 number\n     * @param b Decimal.D256 to compare\n     * @return Whether `b` is greater than `self`\n     */\n    function greaterThan(D256 memory self, D256 memory b) internal pure returns (bool) {\n        return compareTo(self, b) == 2;\n    }\n\n    /**\n     * @notice Checks if `b` is less than `self`\n     * @param self Original Decimal.D256 number\n     * @param b Decimal.D256 to compare\n     * @return Whether `b` is less than `self`\n     */\n    function lessThan(D256 memory self, D256 memory b) internal pure returns (bool) {\n        return compareTo(self, b) == 0;\n    }\n\n    /**\n     * @notice Checks if `b` is greater than or equal to `self`\n     * @param self Original Decimal.D256 number\n     * @param b Decimal.D256 to compare\n     * @return Whether `b` is greater than or equal to `self`\n     */\n    function greaterThanOrEqualTo(D256 memory self, D256 memory b) internal pure returns (bool) {\n        return compareTo(self, b) > 0;\n    }\n\n    /**\n     * @notice Checks if `b` is less than or equal to `self`\n     * @param self Original Decimal.D256 number\n     * @param b Decimal.D256 to compare\n     * @return Whether `b` is less than or equal to `self`\n     */\n    function lessThanOrEqualTo(D256 memory self, D256 memory b) internal pure returns (bool) {\n        return compareTo(self, b) < 2;\n    }\n\n    /**\n     * @notice Checks if `self` is equal to 0\n     * @param self Original Decimal.D256 number\n     * @return Whether `self` is equal to 0\n     */\n    function isZero(D256 memory self) internal pure returns (bool) {\n        return self.value == 0;\n    }\n\n    /**\n     * @notice Truncates the decimal part of `self` and returns the integer value as a uint256\n     * @param self Original Decimal.D256 number\n     * @return Truncated Integer value as a uint256\n     */\n    function asUint256(D256 memory self) internal pure returns (uint256) {\n        return self.value.div(BASE);\n    }\n\n    // ============ General Math ============\n\n    /**\n     * @notice Determines the minimum of `a` and `b`\n     * @param a First Decimal.D256 number to compare\n     * @param b Second Decimal.D256 number to compare\n     * @return Resulting minimum Decimal.D256\n     */\n    function min(D256 memory a, D256 memory b) internal pure returns (Decimal.D256 memory) {\n        return lessThan(a, b) ? a : b;\n    }\n\n    /**\n     * @notice Determines the maximum of `a` and `b`\n     * @param a First Decimal.D256 number to compare\n     * @param b Second Decimal.D256 number to compare\n     * @return Resulting maximum Decimal.D256\n     */\n    function max(D256 memory a, D256 memory b) internal pure returns (Decimal.D256 memory) {\n        return greaterThan(a, b) ? a : b;\n    }\n\n    // ============ Core Methods ============\n\n    /**\n     * @notice Multiplies `target` by ratio `numerator` / `denominator`\n     * @dev Internal only - helper\n     * @param target Original Integer number\n     * @param numerator Integer numerator of ratio\n     * @param denominator Integer denominator of ratio\n     * @return Resulting Decimal.D256 number\n     */\n    function getPartial(\n        uint256 target,\n        uint256 numerator,\n        uint256 denominator\n    )\n    private\n    pure\n    returns (uint256)\n    {\n        return target.mul(numerator).div(denominator);\n    }\n\n    /**\n     * @notice Multiplies `target` by ratio `numerator` / `denominator`\n     * @dev Internal only - helper\n     *      Reverts on divide-by-zero with reason `reason`\n     * @param target Original Integer number\n     * @param numerator Integer numerator of ratio\n     * @param denominator Integer denominator of ratio\n     * @param reason Revert reason\n     * @return Resulting Decimal.D256 number\n     */\n    function getPartial(\n        uint256 target,\n        uint256 numerator,\n        uint256 denominator,\n        string memory reason\n    )\n    private\n    pure\n    returns (uint256)\n    {\n        return target.mul(numerator).div(denominator, reason);\n    }\n\n    /**\n     * @notice Compares Decimal.D256 `a` to Decimal.D256 `b`\n     * @dev Internal only - helper\n     * @param a First Decimal.D256 number to compare\n     * @param b Second Decimal.D256 number to compare\n     * @return 0 if a < b, 1 if a == b, 2 if a > b\n     */\n    function compareTo(\n        D256 memory a,\n        D256 memory b\n    )\n    private\n    pure\n    returns (uint256)\n    {\n        if (a.value == b.value) {\n            return 1;\n        }\n        return a.value > b.value ? 2 : 0;\n    }\n}"
    }
  ]
}