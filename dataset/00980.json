{
  "Title": "Yield in trove is lost when closing a strategy vault",
  "Content": "# Yield in trove is lost when closing a strategy vault\n\n### Severity\nHigh Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXDeposit.sol#L61-L66\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXDeposit.sol#L61-L66</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXWithdraw.sol#L47-L52\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXWithdraw.sol#L47-L52</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXCompound.sol#L40-L53\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXCompound.sol#L40-L53</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXChecks.sol#L341-L344\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXChecks.sol#L341-L344</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXEmergency.sol#L47-L66\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXEmergency.sol#L47-L66</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXEmergency.sol#L111-L156\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXEmergency.sol#L111-L156</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXTrove.sol#L19-L41\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXTrove.sol#L19-L41</a>\n\n\n## Summary\n\nThe funds in the trove contract are not claimed during the emergency close flow and can not be claimed in a normal way during this situation, because of a status change. Therefore, all the acquired yield will be lost.\n\n## Vulnerability Details\n\nWhen users deposit, or withdraw tokens, all acquired yield from GMX is sent to the trove contract:\n\n```jsx\nfunction deposit(\n  GMXTypes.Store storage self,\n  GMXTypes.DepositParams memory dp,\n  bool isNative\n) external {\n  // Sweep any tokenA/B in vault to the temporary trove for future compouding and to prevent\n  // it from being considered as part of depositor's assets\n  if (self.tokenA.balanceOf(address(this)) > 0) {\n    self.tokenA.safeTransfer(self.trove, self.tokenA.balanceOf(address(this)));\n  }\n  if (self.tokenB.balanceOf(address(this)) > 0) {\n    self.tokenB.safeTransfer(self.trove, self.tokenB.balanceOf(address(this)));\n  }\n\t...\n}\n```\n\n```jsx\nfunction withdraw(\n  GMXTypes.Store storage self,\n  GMXTypes.WithdrawParams memory wp\n) external {\n  // Sweep any tokenA/B in vault to the temporary trove for future compouding and to prevent\n  // it from being considered as part of withdrawers assets\n  if (self.tokenA.balanceOf(address(this)) > 0) {\n    self.tokenA.safeTransfer(self.trove, self.tokenA.balanceOf(address(this)));\n  }\n  if (self.tokenB.balanceOf(address(this)) > 0) {\n    self.tokenB.safeTransfer(self.trove, self.tokenB.balanceOf(address(this)));\n  }\n\t...\n}\n```\n\nThe only way in the system to claim these yield is the compound function, which calls the beforeCompoundChecks function:\n\n```jsx\nfunction compound(\n  GMXTypes.Store storage self,\n  GMXTypes.CompoundParams memory cp\n) external {\n  // Transfer any tokenA/B from trove to vault\n  if (self.tokenA.balanceOf(address(self.trove)) > 0) {\n    self.tokenA.safeTransferFrom(\n      address(self.trove),\n      address(this),\n      self.tokenA.balanceOf(address(self.trove))\n    );\n  }\n  if (self.tokenB.balanceOf(address(self.trove)) > 0) {\n    self.tokenB.safeTransferFrom(\n      address(self.trove),\n      address(this),\n      self.tokenB.balanceOf(address(self.trove))\n    );\n  }\n\t...\n\tGMXChecks.beforeCompoundChecks(self);\n\t...\n}\n```\n\nThis function reverts if the current status of the system is not Open or Compound_Failed:\n\n```jsx\nfunction beforeCompoundChecks(\n  GMXTypes.Store storage self\n) external view {\n  if (\n    self.status != GMXTypes.Status.Open &&\n    self.status != GMXTypes.Status.Compound_Failed\n  ) revert Errors.NotAllowedInCurrentVaultStatus();\n\t...\n}\n```\n\nAs the emergency close flow updates this status to Paused and later to Closed, calling compound will revert:\n\n```jsx\nfunction emergencyPause(\n  GMXTypes.Store storage self\n) external {\n  self.refundee = payable(msg.sender);\n\n  GMXTypes.RemoveLiquidityParams memory _rlp;\n\n  // Remove all of the vault's LP tokens\n  _rlp.lpAmt = self.lpToken.balanceOf(address(this));\n  _rlp.executionFee = msg.value;\n\n  GMXManager.removeLiquidity(\n    self,\n    _rlp\n  );\n\n  self.status = GMXTypes.Status.Paused;\n\n  emit EmergencyPause();\n}\n```\n\n```jsx\nfunction emergencyClose(\n  GMXTypes.Store storage self,\n  uint256 deadline\n) external {\n  GMXChecks.beforeEmergencyCloseChecks(self);\n\n  // Repay all borrowed assets; 1e18 == 100% shareRatio to repay\n  GMXTypes.RepayParams memory _rp;\n  (\n    _rp.repayTokenAAmt,\n    _rp.repayTokenBAmt\n  ) = GMXManager.calcRepay(self, 1e18);\n\n  (\n    bool _swapNeeded,\n    address _tokenFrom,\n    address _tokenTo,\n    uint256 _tokenToAmt\n  ) = GMXManager.calcSwapForRepay(self, _rp);\n\n  if (_swapNeeded) {\n    ISwap.SwapParams memory _sp;\n\n    _sp.tokenIn = _tokenFrom;\n    _sp.tokenOut = _tokenTo;\n    _sp.amountIn = IERC20(_tokenFrom).balanceOf(address(this));\n    _sp.amountOut = _tokenToAmt;\n    _sp.slippage = self.minSlippage;\n    _sp.deadline = deadline;\n\n    GMXManager.swapTokensForExactTokens(self, _sp);\n  }\n\n  GMXManager.repay(\n    self,\n    _rp.repayTokenAAmt,\n    _rp.repayTokenBAmt\n  );\n\n  self.status = GMXTypes.Status.Closed;\n\n  emit EmergencyClose(\n    _rp.repayTokenAAmt,\n    _rp.repayTokenBAmt\n  );\n}\n```\n\nAnd as we can see during these process the funds inside the trove contract are never claimed and as the strategy vault is the only address that can claim the funds of the trove, all funds are gone.\n\n```jsx\ncontract GMXTrove {\n\n  /* ==================== STATE VARIABLES ==================== */\n\n  // Address of the vault this trove handler is for\n  IGMXVault public vault;\n\n  /* ====================== CONSTRUCTOR ====================== */\n\n  /**\n    * @notice Initialize trove contract with associated vault address\n    * @param _vault Address of vault\n  */\n  constructor (address _vault) {\n    vault = IGMXVault(_vault);\n\n    GMXTypes.Store memory _store = vault.store();\n\n    // Set token approvals for this trove's vault contract\n    _store.tokenA.approve(address(vault), type(uint256).max);\n    _store.tokenB.approve(address(vault), type(uint256).max);\n  }\n}\n```\n\n## Impact\n\nIf a strategy vault is closed, all funds in the trove are lost.\n\n## Tools Used\n\nManual Review\n\n## Recommendations\n\nTransfer the funds inside the trove into the vault during the emergency close process.",
  "Impact": "HIGH",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "contracts/strategy/gmx/GMXDeposit.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IDeposit } from \"../../interfaces/protocols/gmx/IDeposit.sol\";\nimport { IWithdrawal } from \"../../interfaces/protocols/gmx/IWithdrawal.sol\";\nimport { IEvent } from \"../../interfaces/protocols/gmx/IEvent.sol\";\nimport { IOrder } from \"../../interfaces/protocols/gmx/IOrder.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\nimport { GMXProcessDeposit } from \"./GMXProcessDeposit.sol\";\n\n/**\n  * @title GMXDeposit\n  * @author Steadefi\n  * @notice Re-usable library functions for deposit operations for Steadefi leveraged vaults\n*/\nlibrary GMXDeposit {\n  using SafeERC20 for IERC20;\n\n  /* ======================= CONSTANTS ======================= */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ======================== EVENTS ========================= */\n\n  event DepositCreated(\n    address indexed user,\n    address asset,\n    uint256 assetAmt\n  );\n  event DepositCompleted(\n    address indexed user,\n    uint256 shareAmt,\n    uint256 equityBefore,\n    uint256 equityAfter\n  );\n  event DepositCancelled(\n    address indexed user\n  );\n  event DepositFailed(bytes reason);\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n    * @param isNative Boolean as to whether user is depositing native asset (e.g. ETH, AVAX, etc.)\n  */\n  function deposit(\n    GMXTypes.Store storage self,\n    GMXTypes.DepositParams memory dp,\n    bool isNative\n  ) external {\n    // Sweep any tokenA/B in vault to the temporary trove for future compouding and to prevent\n    // it from being considered as part of depositor's assets\n    if (self.tokenA.balanceOf(address(this)) > 0) {\n      self.tokenA.safeTransfer(self.trove, self.tokenA.balanceOf(address(this)));\n    }\n    if (self.tokenB.balanceOf(address(this)) > 0) {\n      self.tokenB.safeTransfer(self.trove, self.tokenB.balanceOf(address(this)));\n    }\n\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.HealthParams memory _hp;\n\n    _hp.equityBefore = GMXReader.equityValue(self);\n    _hp.lpAmtBefore = GMXReader.lpAmt(self);\n    _hp.debtRatioBefore = GMXReader.debtRatio(self);\n    _hp.deltaBefore = GMXReader.delta(self);\n\n    // Transfer assets from user to vault\n    if (isNative) {\n      GMXChecks.beforeNativeDepositChecks(self, dp);\n\n      self.WNT.deposit{ value: dp.amt }();\n    } else {\n      IERC20(dp.token).safeTransferFrom(msg.sender, address(this), dp.amt);\n    }\n\n    GMXTypes.DepositCache memory _dc;\n\n    _dc.user = payable(msg.sender);\n\n    if (dp.token == address(self.lpToken)) {\n      // If LP token deposited\n      _dc.depositValue = self.gmxOracle.getLpTokenValue(\n        address(self.lpToken),\n        address(self.tokenA),\n        address(self.tokenA),\n        address(self.tokenB),\n        false,\n        false\n      )\n      * dp.amt\n      / SAFE_MULTIPLIER;\n    } else {\n      // If tokenA or tokenB deposited\n      _dc.depositValue = GMXReader.convertToUsdValue(\n        self,\n        address(dp.token),\n        dp.amt\n      );\n    }\n    _dc.depositParams = dp;\n    _dc.healthParams = _hp;\n\n    self.depositCache = _dc;\n\n    GMXChecks.beforeDepositChecks(self, _dc.depositValue);\n\n    self.status = GMXTypes.Status.Deposit;\n\n    self.vault.mintFee();\n\n    // Borrow assets and create deposit in GMX\n    (\n      uint256 _borrowTokenAAmt,\n      uint256 _borrowTokenBAmt\n    ) = GMXManager.calcBorrow(self, _dc.depositValue);\n\n    _dc.borrowParams.borrowTokenAAmt = _borrowTokenAAmt;\n    _dc.borrowParams.borrowTokenBAmt = _borrowTokenBAmt;\n\n    GMXManager.borrow(self, _borrowTokenAAmt, _borrowTokenBAmt);\n\n    GMXTypes.AddLiquidityParams memory _alp;\n\n    _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n    _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n    _alp.minMarketTokenAmt = GMXManager.calcMinMarketSlippageAmt(\n      self,\n      _dc.depositValue,\n      dp.slippage\n    );\n    _alp.executionFee = dp.executionFee;\n\n    _dc.depositKey = GMXManager.addLiquidity(\n      self,\n      _alp\n    );\n\n    self.depositCache = _dc;\n\n    emit DepositCreated(\n      _dc.user,\n      _dc.depositParams.token,\n      _dc.depositParams.amt\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDeposit(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessDepositChecks(self);\n\n    // We transfer the core logic of this function to GMXProcessDeposit.processDeposit()\n    // to allow try/catch here to catch for any issues or any checks in afterDepositChecks() failing.\n    // If there are any issues, a DepositFailed event will be emitted and processDepositFailure()\n    // should be triggered to refund assets accordingly and reset the vault status to Open again.\n    try GMXProcessDeposit.processDeposit(self) {\n      // Mint shares to depositor\n      self.vault.mint(self.depositCache.user, self.depositCache.sharesToUser);\n\n      self.status = GMXTypes.Status.Open;\n\n      emit DepositCompleted(\n        self.depositCache.user,\n        self.depositCache.sharesToUser,\n        self.depositCache.healthParams.equityBefore,\n        self.depositCache.healthParams.equityAfter\n      );\n    } catch (bytes memory reason) {\n      self.status = GMXTypes.Status.Deposit_Failed;\n\n      emit DepositFailed(reason);\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDepositCancellation(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessDepositCancellationChecks(self);\n\n    // Repay borrowed assets\n    GMXManager.repay(\n      self,\n      self.depositCache.borrowParams.borrowTokenAAmt,\n      self.depositCache.borrowParams.borrowTokenBAmt\n    );\n\n    // Return user's deposited asset\n    // If native token is being withdrawn, we convert wrapped to native\n    if (self.depositCache.depositParams.token == address(self.WNT)) {\n      self.WNT.withdraw(self.WNT.balanceOf(address(this)));\n      (bool success, ) = self.depositCache.user.call{value: address(this).balance}(\"\");\n      require(success, \"Transfer failed.\");\n    } else {\n      // Transfer requested withdraw asset to user\n      IERC20(self.depositCache.depositParams.token).safeTransfer(\n        self.depositCache.user,\n        self.depositCache.depositParams.amt\n      );\n    }\n\n    self.status = GMXTypes.Status.Open;\n\n    emit DepositCancelled(self.depositCache.user);\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDepositFailure(\n    GMXTypes.Store storage self,\n    uint256 slippage,\n    uint256 executionFee\n  ) external {\n    GMXChecks.beforeProcessAfterDepositFailureChecks(self);\n\n    GMXTypes.RemoveLiquidityParams memory _rlp;\n\n    // If current LP amount is somehow less or equal to amount before, we do not remove any liquidity\n    if (GMXReader.lpAmt(self) <= self.depositCache.healthParams.lpAmtBefore) {\n      processDepositFailureLiquidityWithdrawal(self);\n    } else {\n      // Remove only the newly added LP amount\n      _rlp.lpAmt = GMXReader.lpAmt(self) - self.depositCache.healthParams.lpAmtBefore;\n\n      // If delta strategy is Long, remove all in tokenB to make it more\n      // efficent to repay tokenB debt as Long strategy only borrows tokenB\n      if (self.delta == GMXTypes.Delta.Long) {\n        address[] memory _tokenASwapPath = new address[](1);\n        _tokenASwapPath[0] = address(self.lpToken);\n        _rlp.tokenASwapPath = _tokenASwapPath;\n\n        (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n          self,\n          _rlp.lpAmt,\n          address(self.tokenB),\n          address(self.tokenB),\n          slippage\n        );\n      } else {\n        (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n          self,\n          _rlp.lpAmt,\n          address(self.tokenA),\n          address(self.tokenB),\n          slippage\n        );\n      }\n\n      _rlp.executionFee = executionFee;\n\n      // Remove liqudity\n      self.depositCache.withdrawKey = GMXManager.removeLiquidity(\n        self,\n        _rlp\n      );\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDepositFailureLiquidityWithdrawal(\n    GMXTypes.Store storage self\n  ) public {\n    GMXChecks.beforeProcessAfterDepositFailureLiquidityWithdrawal(self);\n\n    GMXTypes.RepayParams memory _rp;\n\n    _rp.repayTokenAAmt = self.depositCache.borrowParams.borrowTokenAAmt;\n    _rp.repayTokenBAmt = self.depositCache.borrowParams.borrowTokenBAmt;\n\n    // Check if swap between assets are needed for repayment based on previous borrow\n    (\n      bool _swapNeeded,\n      address _tokenFrom,\n      address _tokenTo,\n      uint256 _tokenToAmt\n    ) = GMXManager.calcSwapForRepay(self, _rp);\n\n    if (_swapNeeded) {\n      ISwap.SwapParams memory _sp;\n\n      _sp.tokenIn = _tokenFrom;\n      _sp.tokenOut = _tokenTo;\n      _sp.amountIn = IERC20(_tokenFrom).balanceOf(address(this));\n      _sp.amountOut = _tokenToAmt;\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = block.timestamp;\n      // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n      // We allow deadline to be set as the current block timestamp whenever this function\n      // is called because this function is triggered as a follow up function (by a callback/keeper)\n      // and not directly by a user/keeper. If this follow on function flow reverts due to this tx\n      // being processed after a set deadline, this will cause the vault to be in a \"stuck\" state.\n      // To resolve this, this function will have to be called again with an updated deadline until it\n      // succeeds/a miner processes the tx.\n\n      GMXManager.swapTokensForExactTokens(self, _sp);\n    }\n\n    // Adjust amount to repay for both tokens due to slight differences\n    // from liqudiity withdrawal and swaps. If the amount to repay based on previous borrow\n    // is more than the available balance vault has, we simply repay what the vault has\n    uint256 _repayTokenAAmt;\n    uint256 _repayTokenBAmt;\n\n    if (self.depositCache.borrowParams.borrowTokenAAmt > self.tokenA.balanceOf(address(this))) {\n      _repayTokenAAmt = self.tokenA.balanceOf(address(this));\n    } else {\n      _repayTokenAAmt = self.depositCache.borrowParams.borrowTokenAAmt;\n    }\n\n    if (self.depositCache.borrowParams.borrowTokenBAmt > self.tokenB.balanceOf(address(this))) {\n      _repayTokenBAmt = self.tokenB.balanceOf(address(this));\n    } else {\n      _repayTokenBAmt = self.depositCache.borrowParams.borrowTokenBAmt;\n    }\n\n    // Repay borrowed assets\n    GMXManager.repay(\n      self,\n      _repayTokenAAmt,\n      _repayTokenBAmt\n    );\n\n    // Refund user the rest of the remaining withdrawn LP assets\n    // Will be in tokenA/tokenB only; so if user deposited LP tokens\n    // they will still be refunded in tokenA/tokenB\n    self.tokenA.safeTransfer(self.depositCache.user, self.tokenA.balanceOf(address(this)));\n    self.tokenB.safeTransfer(self.depositCache.user, self.tokenB.balanceOf(address(this)));\n\n    self.status = GMXTypes.Status.Open;\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXWithdraw.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\nimport { GMXProcessWithdraw } from \"./GMXProcessWithdraw.sol\";\n\n/**\n  * @title GMXWithdraw\n  * @author Steadefi\n  * @notice Re-usable library functions for withdraw operations for Steadefi leveraged vaults\n*/\nlibrary GMXWithdraw {\n  using SafeERC20 for IERC20;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ======================== EVENTS ========================= */\n\n  event WithdrawCreated(address indexed user, uint256 shareAmt);\n  event WithdrawCompleted(\n    address indexed user,\n    address token,\n    uint256 tokenAmt\n  );\n  event WithdrawCancelled(address indexed user);\n  event WithdrawFailed(bytes reason);\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function withdraw(\n    GMXTypes.Store storage self,\n    GMXTypes.WithdrawParams memory wp\n  ) external {\n    // Sweep any tokenA/B in vault to the temporary trove for future compouding and to prevent\n    // it from being considered as part of withdrawers assets\n    if (self.tokenA.balanceOf(address(this)) > 0) {\n      self.tokenA.safeTransfer(self.trove, self.tokenA.balanceOf(address(this)));\n    }\n    if (self.tokenB.balanceOf(address(this)) > 0) {\n      self.tokenB.safeTransfer(self.trove, self.tokenB.balanceOf(address(this)));\n    }\n\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.HealthParams memory _hp;\n\n    _hp.equityBefore = GMXReader.equityValue(self);\n    _hp.lpAmtBefore = GMXReader.lpAmt(self);\n    _hp.debtRatioBefore = GMXReader.debtRatio(self);\n    _hp.deltaBefore = GMXReader.delta(self);\n\n    GMXTypes.WithdrawCache memory _wc;\n\n    _wc.user = payable(msg.sender);\n\n    _wc.shareRatio = wp.shareAmt\n      * SAFE_MULTIPLIER\n      / IERC20(address(self.vault)).totalSupply();\n    _wc.lpAmt = _wc.shareRatio\n      * GMXReader.lpAmt(self)\n      / SAFE_MULTIPLIER;\n    _wc.withdrawValue = _wc.lpAmt\n      * self.gmxOracle.getLpTokenValue(\n        address(self.lpToken),\n        address(self.tokenA),\n        address(self.tokenA),\n        address(self.tokenB),\n        false,\n        false\n      )\n      / SAFE_MULTIPLIER;\n\n    _wc.withdrawParams = wp;\n    _wc.healthParams = _hp;\n\n    (\n      uint256 _repayTokenAAmt,\n      uint256 _repayTokenBAmt\n    ) = GMXManager.calcRepay(self, _wc.shareRatio);\n\n    _wc.repayParams.repayTokenAAmt = _repayTokenAAmt;\n    _wc.repayParams.repayTokenBAmt = _repayTokenBAmt;\n\n    self.withdrawCache = _wc;\n\n    GMXChecks.beforeWithdrawChecks(self);\n\n    self.status = GMXTypes.Status.Withdraw;\n\n    self.vault.mintFee();\n\n    GMXTypes.RemoveLiquidityParams memory _rlp;\n\n    // If user wants to withdraw LP tokens, only remove liquidity of\n    // LP tokens that are proportionately borrowed to repay debt\n    // If not, we just remove all LP tokens computed in _wc.lpAmt\n    if (wp.token == address(self.lpToken)) {\n      // LP amount to be removed for leverage debt repayment\n      // Multiply LP amt to remove by 2% to account for price differential,\n      // fees on LP removal, slippages to ensure payment of debt is covered\n      // Excess tokenA/B will be returned to the user regardless\n      uint256 _lpAmtToRemove = _wc.lpAmt\n        * (self.leverage - SAFE_MULTIPLIER)\n        / self.leverage\n        * 10200 / 10000;\n\n      _wc.tokensToUser = _wc.lpAmt - _lpAmtToRemove;\n      _wc.lpAmt = _lpAmtToRemove;\n    }\n\n\n    // If delta strategy is Long, remove all in tokenB to make it more\n    // efficent to repay tokenB debt as Long strategy only borrows tokenB\n    if (self.delta == GMXTypes.Delta.Long) {\n      address[] memory _tokenASwapPath = new address[](1);\n      _tokenASwapPath[0] = address(self.lpToken);\n      _rlp.tokenASwapPath = _tokenASwapPath;\n\n      (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n        self,\n        _wc.lpAmt,\n        address(self.tokenB),\n        address(self.tokenB),\n        wp.slippage\n      );\n    } else {\n      (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n        self,\n        _wc.lpAmt,\n        address(self.tokenA),\n        address(self.tokenB),\n        wp.slippage\n      );\n    }\n\n    _rlp.lpAmt = _wc.lpAmt;\n    _rlp.executionFee = wp.executionFee;\n\n    _wc.withdrawKey = GMXManager.removeLiquidity(\n      self,\n      _rlp\n    );\n\n    // Add withdrawKey to store\n    self.withdrawCache = _wc;\n\n    emit WithdrawCreated(\n      _wc.user,\n      _wc.withdrawParams.shareAmt\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdraw(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessWithdrawChecks(self);\n\n    // We transfer the core logic of this function to GMXProcessWithdraw.processWithdraw()\n    // to allow try/catch here to catch for any issues such as any token swaps failing or\n    // debt repayment failing, or any checks in afterWithdrawChecks() failing.\n    // If there are any issues, a WithdrawFailed event will be emitted and processWithdrawFailure()\n    // should be triggered to refund assets accordingly and reset the vault status to Open again.\n    try GMXProcessWithdraw.processWithdraw(self) {\n      // If native token is being withdrawn, we convert wrapped to native\n      if (self.withdrawCache.withdrawParams.token == address(self.WNT)) {\n        self.WNT.withdraw(self.withdrawCache.tokensToUser);\n        (bool success, ) = self.withdrawCache.user.call{value: address(this).balance}(\"\");\n        require(success, \"Transfer failed.\");\n      } else {\n        // Transfer requested withdraw asset to user\n        IERC20(self.withdrawCache.withdrawParams.token).safeTransfer(\n          self.withdrawCache.user,\n          self.withdrawCache.tokensToUser\n        );\n      }\n\n      // Transfer any remaining tokenA/B that was unused (due to slippage) to user as well\n      self.tokenA.safeTransfer(self.withdrawCache.user, self.tokenA.balanceOf(address(this)));\n      self.tokenB.safeTransfer(self.withdrawCache.user, self.tokenB.balanceOf(address(this)));\n\n      // Burn user shares\n      self.vault.burn(self.withdrawCache.user, self.withdrawCache.withdrawParams.shareAmt);\n\n      self.status = GMXTypes.Status.Open;\n\n      emit WithdrawCompleted(\n        self.withdrawCache.user,\n        self.withdrawCache.withdrawParams.token,\n        self.withdrawCache.tokensToUser\n      );\n    } catch (bytes memory reason) {\n      self.status = GMXTypes.Status.Withdraw_Failed;\n\n      emit WithdrawFailed(reason);\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdrawCancellation(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessWithdrawCancellationChecks(self);\n\n    self.status = GMXTypes.Status.Open;\n\n    emit WithdrawCancelled(self.withdrawCache.user);\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdrawFailure(\n    GMXTypes.Store storage self,\n    uint256 slippage,\n    uint256 executionFee\n  ) external {\n    GMXChecks.beforeProcessAfterWithdrawFailureChecks(self);\n\n    // Re-borrow assets based on the repaid amount\n    GMXManager.borrow(\n      self,\n      self.withdrawCache.repayParams.repayTokenAAmt,\n      self.withdrawCache.repayParams.repayTokenBAmt\n    );\n\n    // Re-add liquidity using all available tokenA/B in vault\n    GMXTypes.AddLiquidityParams memory _alp;\n\n    _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n    _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n\n    // Calculate slippage\n    uint256 _depositValue = GMXReader.convertToUsdValue(\n      self,\n      address(self.tokenA),\n      self.tokenA.balanceOf(address(this))\n    )\n    + GMXReader.convertToUsdValue(\n      self,\n      address(self.tokenB),\n      self.tokenB.balanceOf(address(this))\n    );\n\n    _alp.minMarketTokenAmt = GMXManager.calcMinMarketSlippageAmt(\n      self,\n      _depositValue,\n      slippage\n    );\n    _alp.executionFee = executionFee;\n\n    // Re-add liquidity with all tokenA/tokenB in vault\n    self.withdrawCache.depositKey = GMXManager.addLiquidity(\n      self,\n      _alp\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdrawFailureLiquidityAdded(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessAfterWithdrawFailureLiquidityAdded(self);\n\n    self.status = GMXTypes.Status.Open;\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXCompound.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\n\n/**\n  * @title GMXCompound\n  * @author Steadefi\n  * @notice Re-usable library functions for compound operations for Steadefi leveraged vaults\n*/\nlibrary GMXCompound {\n  using SafeERC20 for IERC20;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ======================== EVENTS ========================= */\n\n  event CompoundCompleted();\n  event CompoundCancelled();\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function compound(\n    GMXTypes.Store storage self,\n    GMXTypes.CompoundParams memory cp\n  ) external {\n    // Transfer any tokenA/B from trove to vault\n    if (self.tokenA.balanceOf(address(self.trove)) > 0) {\n      self.tokenA.safeTransferFrom(\n        address(self.trove),\n        address(this),\n        self.tokenA.balanceOf(address(self.trove))\n      );\n    }\n    if (self.tokenB.balanceOf(address(self.trove)) > 0) {\n      self.tokenB.safeTransferFrom(\n        address(self.trove),\n        address(this),\n        self.tokenB.balanceOf(address(self.trove))\n      );\n    }\n\n    uint256 _tokenInAmt = IERC20(cp.tokenIn).balanceOf(address(this));\n\n    // Only compound if tokenIn amount is more than 0\n    if (_tokenInAmt > 0) {\n      self.refundee = payable(msg.sender);\n\n      self.compoundCache.compoundParams = cp;\n\n      ISwap.SwapParams memory _sp;\n\n      _sp.tokenIn = cp.tokenIn;\n      _sp.tokenOut = cp.tokenOut;\n      _sp.amountIn = _tokenInAmt;\n      _sp.amountOut = 0; // amount out minimum calculated in Swap\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = cp.deadline;\n\n      GMXManager.swapExactTokensForTokens(self, _sp);\n\n      GMXTypes.AddLiquidityParams memory _alp;\n\n      _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n      _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n\n      self.compoundCache.depositValue = GMXReader.convertToUsdValue(\n        self,\n        address(self.tokenA),\n        self.tokenA.balanceOf(address(this))\n      )\n      + GMXReader.convertToUsdValue(\n        self,\n        address(self.tokenB),\n        self.tokenB.balanceOf(address(this))\n      );\n\n      GMXChecks.beforeCompoundChecks(self);\n\n      self.status = GMXTypes.Status.Compound;\n\n      _alp.minMarketTokenAmt = GMXManager.calcMinMarketSlippageAmt(\n        self,\n        self.compoundCache.depositValue,\n        cp.slippage\n      );\n\n      _alp.executionFee = cp.executionFee;\n\n      self.compoundCache.depositKey = GMXManager.addLiquidity(\n        self,\n        _alp\n      );\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processCompound(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessCompoundChecks(self);\n\n    self.status = GMXTypes.Status.Open;\n\n    emit CompoundCompleted();\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processCompoundCancellation(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessCompoundCancellationChecks(self);\n\n    self.status = GMXTypes.Status.Compound_Failed;\n\n    emit CompoundCancelled();\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXChecks.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IDeposit } from \"../../interfaces/protocols/gmx/IDeposit.sol\";\nimport { IWithdrawal } from \"../../interfaces/protocols/gmx/IWithdrawal.sol\";\nimport { IEvent } from \"../../interfaces/protocols/gmx/IEvent.sol\";\nimport { IOrder } from \"../../interfaces/protocols/gmx/IOrder.sol\";\nimport { Errors } from \"../../utils/Errors.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\n\n/**\n  * @title GMXChecks\n  * @author Steadefi\n  * @notice Re-usable library functions for require function checks for Steadefi leveraged vaults\n*/\nlibrary GMXChecks {\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n  uint256 public constant MINIMUM_VALUE = 9e16;\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice Checks before native token deposit\n    * @param self GMXTypes.Store\n    * @param dp GMXTypes.DepositParams\n  */\n  function beforeNativeDepositChecks(\n    GMXTypes.Store storage self,\n    GMXTypes.DepositParams memory dp\n  ) external view {\n    if (dp.token != address(self.WNT))\n      revert Errors.InvalidNativeTokenAddress();\n\n    if (\n      address(self.tokenA) != address(self.WNT) &&\n      address(self.tokenB) != address(self.WNT)\n    ) revert Errors.OnlyNonNativeDepositToken();\n\n    if (dp.amt == 0) revert Errors.EmptyDepositAmount();\n\n    if (dp.amt + dp.executionFee != msg.value)\n      revert Errors.DepositAndExecutionFeeDoesNotMatchMsgValue();\n  }\n\n  /**\n    * @notice Checks before token deposit\n    * @param self GMXTypes.Store\n    * @param depositValue USD value in 1e18\n  */\n  function beforeDepositChecks(\n    GMXTypes.Store storage self,\n    uint256 depositValue\n  ) external view {\n    if (self.status != GMXTypes.Status.Open)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n\n    if (self.depositCache.depositParams.executionFee < self.minExecutionFee)\n      revert Errors.InsufficientExecutionFeeAmount();\n\n    if (!self.vault.isTokenWhitelisted(self.depositCache.depositParams.token))\n      revert Errors.InvalidDepositToken();\n\n    if (self.depositCache.depositParams.amt == 0)\n      revert Errors.InsufficientDepositAmount();\n\n    if (self.depositCache.depositParams.slippage < self.minSlippage)\n      revert Errors.InsufficientSlippageAmount();\n\n    if (depositValue == 0)\n      revert Errors.InsufficientDepositAmount();\n\n    if (depositValue < MINIMUM_VALUE)\n      revert Errors.InsufficientDepositAmount();\n\n    if (depositValue > GMXReader.additionalCapacity(self))\n      revert Errors.InsufficientLendingLiquidity();\n  }\n\n  /**\n    * @notice Checks before processing deposit\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessDepositChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Deposit)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks after deposit\n    * @param self GMXTypes.Store\n  */\n  function afterDepositChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    // Guards: revert if lpAmt did not increase at all\n    if (GMXReader.lpAmt(self) <= self.depositCache.healthParams.lpAmtBefore)\n      revert Errors.InsufficientLPTokensMinted();\n\n    // Guards: check that debt ratio is within step change range\n    if (!_isWithinStepChange(\n      self.depositCache.healthParams.debtRatioBefore,\n      GMXReader.debtRatio(self),\n      self.debtRatioStepThreshold\n    )) revert Errors.InvalidDebtRatio();\n\n    // Slippage: Check whether user received enough shares as expected\n    if (\n      self.depositCache.sharesToUser <\n      self.depositCache.depositParams.minSharesAmt\n    ) revert Errors.InsufficientSharesMinted();\n  }\n\n  /**\n    * @notice Checks before processing deposit cancellation\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessDepositCancellationChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Deposit)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before processing after deposit check failure\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessAfterDepositFailureChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Deposit_Failed)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before processing after deposit failure's liquidity withdrawn\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessAfterDepositFailureLiquidityWithdrawal(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Deposit_Failed)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before vault withdrawal\n    * @param self GMXTypes.Store\n\n  */\n  function beforeWithdrawChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Open)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n\n    if (!self.vault.isTokenWhitelisted(self.withdrawCache.withdrawParams.token))\n      revert Errors.InvalidWithdrawToken();\n\n    if (self.withdrawCache.withdrawParams.shareAmt == 0)\n      revert Errors.EmptyWithdrawAmount();\n\n    if (\n      self.withdrawCache.withdrawParams.shareAmt >\n      IERC20(address(self.vault)).balanceOf(self.withdrawCache.user)\n    ) revert Errors.InsufficientWithdrawBalance();\n\n    if (self.withdrawCache.withdrawValue < MINIMUM_VALUE)\n      revert Errors.InsufficientWithdrawAmount();\n\n    if (self.withdrawCache.withdrawParams.slippage < self.minSlippage)\n      revert Errors.InsufficientSlippageAmount();\n\n    if (self.withdrawCache.withdrawParams.executionFee < self.minExecutionFee)\n      revert Errors.InsufficientExecutionFeeAmount();\n\n    if (self.withdrawCache.withdrawParams.executionFee != msg.value)\n      revert Errors.InvalidExecutionFeeAmount();\n  }\n\n  /**\n    * @notice Checks before processing vault withdrawal\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessWithdrawChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Withdraw)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks after token withdrawal\n    * @param self GMXTypes.Store\n  */\n  function afterWithdrawChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    // Guards: revert if lpAmt did not decrease at all\n    if (GMXReader.lpAmt(self) >= self.withdrawCache.healthParams.lpAmtBefore)\n      revert Errors.InsufficientLPTokensBurned();\n\n    // Guards: revert if equity did not decrease at all\n    if (\n      self.withdrawCache.healthParams.equityAfter >=\n      self.withdrawCache.healthParams.equityBefore\n    ) revert Errors.InvalidEquityAfterWithdraw();\n\n    // Guards: check that debt ratio is within step change range\n    if (!_isWithinStepChange(\n      self.withdrawCache.healthParams.debtRatioBefore,\n      GMXReader.debtRatio(self),\n      self.debtRatioStepThreshold\n    )) revert Errors.InvalidDebtRatio();\n\n    // Check that user received enough assets as expected\n    if (\n      self.withdrawCache.tokensToUser <\n      self.withdrawCache.withdrawParams.minWithdrawTokenAmt\n    ) revert Errors.InsufficientAssetsReceived();\n  }\n\n  /**\n    * @notice Checks before processing withdrawal cancellation\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessWithdrawCancellationChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Withdraw)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before processing after withdrawal failure\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessAfterWithdrawFailureChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Withdraw_Failed)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before processing after withdraw failure's liquidity added\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessAfterWithdrawFailureLiquidityAdded(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Withdraw_Failed)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before rebalancing\n    * @param self GMXTypes.Store\n    * @param rebalanceType GMXTypes.RebalanceType\n  */\n  function beforeRebalanceChecks(\n    GMXTypes.Store storage self,\n    GMXTypes.RebalanceType rebalanceTy"
    }
  ]
}