{
  "Title": "[M-07] Low-level transfer via call() can fail silently",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/timelock/TimelockController.sol#L414-L415\n\n\n# Vulnerability details\n\n## Impact\nIn the `_call()` function in `TimelockController.sol`, a call is executed with the following code:\n\n```\nfunction _call(\n        bytes32 id,\n        uint256 index,\n        address target,\n        uint256 value,\n        bytes memory data\n    ) private {\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = target.call{value: value}(data);\n        require(success, \"TimelockController: underlying transaction reverted\");\n\n        emit CallExecuted(id, index, target, value, data);\n    }\n```\n\nPer the Solidity docs:\n\n\"The low-level functions call, delegatecall and staticcall return true as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed.\"\n\n\nTherefore, transfers may fail silently.\n\n## Proof of Concept\nPlease find the documentation here: https://docs.soliditylang.org/en/develop/control-structures.html#error-handling-assert-require-revert-and-exceptions\n\n## Tools Used\nManual review.\n\n## Recommended Mitigation Steps\nCheck for the account's existence prior to transferring.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-03-rolla-contest",
  "Code": [
    {
      "filename": "quant-protocol/contracts/timelock/TimelockController.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\n/**\n * @dev Contract module which acts as a timelocked controller. When set as the\n * owner of an `Ownable` smart contract, it enforces a timelock on all\n * `onlyOwner` maintenance operations. This gives time for users of the\n * controlled contract to exit before a potentially dangerous maintenance\n * operation is applied.\n *\n * By default, this contract is self administered, meaning administration tasks\n * have to go through the timelock process. The proposer (resp executor) role\n * is in charge of proposing (resp executing) operations. A common use case is\n * to position this {TimelockController} as the owner of a smart contract, with\n * a multisig or a DAO as the sole proposer.\n *\n * _Available since v3.3._\n */\nabstract contract TimelockController is AccessControl {\n    bytes32 public constant TIMELOCK_ADMIN_ROLE =\n        keccak256(\"TIMELOCK_ADMIN_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    uint256 internal constant _DONE_TIMESTAMP = uint256(1);\n\n    mapping(bytes32 => uint256) private _timestamps;\n    uint256 private _minDelay;\n\n    /**\n     * @dev Emitted when a call is scheduled as part of operation `id`.\n     */\n    event CallScheduled(\n        bytes32 indexed id,\n        uint256 indexed index,\n        address target,\n        uint256 value,\n        bytes data,\n        bytes32 predecessor,\n        uint256 delay\n    );\n\n    /**\n     * @dev Emitted when a call is performed as part of operation `id`.\n     */\n    event CallExecuted(\n        bytes32 indexed id,\n        uint256 indexed index,\n        address target,\n        uint256 value,\n        bytes data\n    );\n\n    /**\n     * @dev Emitted when operation `id` is cancelled.\n     */\n    event Cancelled(bytes32 indexed id);\n\n    /**\n     * @dev Emitted when the minimum delay for future operations is modified.\n     */\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\n\n    /**\n     * @dev Initializes the contract with a given `minDelay`.\n     */\n    constructor(\n        uint256 minDelay,\n        address[] memory proposers,\n        address[] memory executors\n    ) {\n        _setRoleAdmin(TIMELOCK_ADMIN_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(PROPOSER_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(EXECUTOR_ROLE, TIMELOCK_ADMIN_ROLE);\n\n        // deployer + self administration\n        _setupRole(TIMELOCK_ADMIN_ROLE, _msgSender());\n        _setupRole(TIMELOCK_ADMIN_ROLE, address(this));\n\n        // register proposers\n        for (uint256 i = 0; i < proposers.length; ++i) {\n            _setupRole(PROPOSER_ROLE, proposers[i]);\n        }\n\n        // register executors\n        for (uint256 i = 0; i < executors.length; ++i) {\n            _setupRole(EXECUTOR_ROLE, executors[i]);\n        }\n\n        _minDelay = minDelay;\n        emit MinDelayChange(0, minDelay);\n    }\n\n    /**\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\n     */\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n\n    /**\n     * @dev Changes the minimum timelock duration for future operations.\n     *\n     * Emits a {MinDelayChange} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\n     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\n     */\n    function updateDelay(uint256 newDelay) external virtual {\n        require(\n            msg.sender == address(this),\n            \"TimelockController: caller must be timelock\"\n        );\n        emit MinDelayChange(_minDelay, newDelay);\n        _minDelay = newDelay;\n    }\n\n    /**\n     * @dev Schedule an operation containing a single transaction.\n     *\n     * Emits a {CallScheduled} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function schedule(\n        address target,\n        uint256 value,\n        bytes memory data,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay,\n        bool ignoreMinDelay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _schedule(id, delay, ignoreMinDelay);\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\n    }\n\n    /**\n     * @dev Schedule an operation containing a batch of transactions.\n     *\n     * Emits one {CallScheduled} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function scheduleBatch(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory datas,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        require(\n            targets.length == values.length,\n            \"TimelockController: length mismatch\"\n        );\n        require(\n            targets.length == datas.length,\n            \"TimelockController: length mismatch\"\n        );\n\n        bytes32 id = hashOperationBatch(\n            targets,\n            values,\n            datas,\n            predecessor,\n            salt\n        );\n        _schedule(id, delay, false);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            emit CallScheduled(\n                id,\n                i,\n                targets[i],\n                values[i],\n                datas[i],\n                predecessor,\n                delay\n            );\n        }\n    }\n\n    /**\n     * @dev Cancel an operation.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function cancel(bytes32 id) public virtual onlyRole(PROPOSER_ROLE) {\n        require(\n            isOperationPending(id),\n            \"TimelockController: operation cannot be cancelled\"\n        );\n        delete _timestamps[id];\n\n        emit Cancelled(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a single transaction.\n     *\n     * Emits a {CallExecuted} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    function execute(\n        address target,\n        uint256 value,\n        bytes memory data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRole(EXECUTOR_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _beforeCall(id, predecessor);\n        _call(id, 0, target, value, data);\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a batch of transactions.\n     *\n     * Emits one {CallExecuted} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    function executeBatch(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory datas,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRole(EXECUTOR_ROLE) {\n        require(\n            targets.length == values.length,\n            \"TimelockController: length mismatch\"\n        );\n        require(\n            targets.length == datas.length,\n            \"TimelockController: length mismatch\"\n        );\n\n        bytes32 id = hashOperationBatch(\n            targets,\n            values,\n            datas,\n            predecessor,\n            salt\n        );\n        _beforeCall(id, predecessor);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            _call(id, i, targets[i], values[i], datas[i]);\n        }\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Returns whether an id correspond to a registered operation. This\n     * includes both Pending, Ready and Done operations.\n     */\n    function isOperation(bytes32 id)\n        public\n        view\n        virtual\n        returns (bool pending)\n    {\n        return getTimestamp(id) > 0;\n    }\n\n    /**\n     * @dev Returns whether an operation is pending or not.\n     */\n    function isOperationPending(bytes32 id)\n        public\n        view\n        virtual\n        returns (bool pending)\n    {\n        return getTimestamp(id) > _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns whether an operation is ready or not.\n     */\n    function isOperationReady(bytes32 id)\n        public\n        view\n        virtual\n        returns (bool ready)\n    {\n        uint256 timestamp = getTimestamp(id);\n        // solhint-disable-next-line not-rely-on-time\n        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;\n    }\n\n    /**\n     * @dev Returns whether an operation is done or not.\n     */\n    function isOperationDone(bytes32 id)\n        public\n        view\n        virtual\n        returns (bool done)\n    {\n        return getTimestamp(id) == _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns the timestamp at with an operation becomes ready (0 for\n     * unset operations, 1 for done operations).\n     */\n    function getTimestamp(bytes32 id)\n        public\n        view\n        virtual\n        returns (uint256 timestamp)\n    {\n        return _timestamps[id];\n    }\n\n    /**\n     * @dev Returns the minimum delay for an operation to become valid.\n     *\n     * This value can be changed by executing an operation that calls `updateDelay`.\n     */\n    function getMinDelay() public view virtual returns (uint256 duration) {\n        return _minDelay;\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a single\n     * transaction.\n     */\n    function hashOperation(\n        address target,\n        uint256 value,\n        bytes memory data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a batch of\n     * transactions.\n     */\n    function hashOperationBatch(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory datas,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(targets, values, datas, predecessor, salt));\n    }\n\n    /**\n     * @dev Schedule an operation that is to becomes valid after a given delay.\n     */\n    function _schedule(\n        bytes32 id,\n        uint256 delay,\n        bool ignoreMinDelay\n    ) private {\n        require(\n            !isOperation(id),\n            \"TimelockController: operation already scheduled\"\n        );\n        require(\n            ignoreMinDelay || delay >= getMinDelay(),\n            \"TimelockController: insufficient delay\"\n        );\n        // solhint-disable-next-line not-rely-on-time\n        _timestamps[id] = block.timestamp + delay;\n    }\n\n    /**\n     * @dev Checks after execution of an operation's calls.\n     */\n    function _afterCall(bytes32 id) private {\n        require(\n            isOperationReady(id),\n            \"TimelockController: operation is not ready\"\n        );\n        _timestamps[id] = _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Execute an operation's call.\n     *\n     * Emits a {CallExecuted} event.\n     */\n    function _call(\n        bytes32 id,\n        uint256 index,\n        address target,\n        uint256 value,\n        bytes memory data\n    ) private {\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = target.call{value: value}(data);\n        require(success, \"TimelockController: underlying transaction reverted\");\n\n        emit CallExecuted(id, index, target, value, data);\n    }\n\n    /**\n     * @dev Checks before execution of an operation's calls.\n     */\n    function _beforeCall(bytes32 id, bytes32 predecessor) private view {\n        require(\n            isOperationReady(id),\n            \"TimelockController: operation is not ready\"\n        );\n        require(\n            predecessor == bytes32(0) || isOperationDone(predecessor),\n            \"TimelockController: missing dependency\"\n        );\n    }\n}"
    }
  ]
}