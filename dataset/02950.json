{
  "Title": "Lack of input validation",
  "Content": "* The [`mustNotExceedNpmThreshold`](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/delegates/VaultDelegateBase.sol#L246) function should validate [`npmStakeToAdd`](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/delegates/VaultDelegateBase.sol#L237) instead of `amount`.\n* The [`setPolicyRatesByKey`](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/policy/PolicyAdmin.sol#L68) function in the `PolicyAdmin` contract does not check that `ceiling` is greater than `floor`, while a similar function [`setPolicyRates`](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/policy/PolicyAdmin.sol#L43) does.\n* The [`initialize`](https://github.com/neptune-mutual-blue/protocol/blob/rc2/audit-start/contracts/core/Protocol.sol#L51-L113) function in the `Protocol` contract does not check the length of the input `values` array.\n* When [computing unstaking rewards](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/GovernanceUtilV1.sol#L430) after an incident resolution, the sum of the `toBurn` and `toReporter` rates are not validated to be bounded above by `ProtoUtilV1.MULTIPLIER`.\n\n\nConsider including the corresponding validations.\n\n\n**Update:** *Fixed as of commit `5ce4b8d3ff0b0a7eb4f0265b4201c93c43af4f30` in [pull request #172](https://github.com/neptune-mutual-blue/protocol/pull/172) and commit `4b929c274100a981107e35d40fbf5b57fabc9be4` in [pull request #196](https://github.com/neptune-mutual-blue/protocol/pull/196).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/core/delegates/VaultDelegateBase.sol",
      "content": "// Neptune Mutual Protocol (https://neptunemutual.com)\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\nimport \"../Recoverable.sol\";\nimport \"../../interfaces/IVaultDelegate.sol\";\nimport \"../../libraries/ProtoUtilV1.sol\";\nimport \"../../libraries/CoverUtilV1.sol\";\nimport \"../../libraries/VaultLibV1.sol\";\nimport \"../../libraries/ValidationLibV1.sol\";\nimport \"../../libraries/StrategyLibV1.sol\";\nimport \"../../libraries/NTransferUtilV2.sol\";\n\n/**\n * Important: This contract is not intended to be accessed\n * by anyone/anything except individual vault contracts.\n *\n * @title Vault Delegate Base Contract\n *\n *\n * @dev The vault delegate base contract includes pre and post hooks.\n * The hooks are accessible only to vault contracts.\n *\n */\nabstract contract VaultDelegateBase is IVaultDelegate, Recoverable {\n  using ProtoUtilV1 for bytes;\n  using ProtoUtilV1 for IStore;\n  using VaultLibV1 for IStore;\n  using ValidationLibV1 for IStore;\n  using RoutineInvokerLibV1 for IStore;\n  using StoreKeyUtil for IStore;\n  using StrategyLibV1 for IStore;\n  using CoverUtilV1 for IStore;\n  using NTransferUtilV2 for IERC20;\n\n  /**\n   * @dev Constructs this contract\n   *\n   * @param store Provide the store contract instance\n   */\n  constructor(IStore store) Recoverable(store) {} // solhint-disable-line\n\n  /**\n   * @dev This hook runs before `transferGovernance` implementation on vault(s).\n   *\n   * @custom:suppress-acl This function is only callable by the claims processor contract through the vault contract\n   * @custom:note Please note the following:\n   *\n   * - Governance transfers are allowed via claims processor contract only.\n   * - This function's caller must be the vault of the specified coverKey.\n   *\n   * @param caller Enter your msg.sender value.\n   * @param coverKey Provide your vault's cover key.\n   *\n   * @return stablecoin Returns address of the protocol stablecoin if the hook validation passes.\n   *\n   */\n  function preTransferGovernance(\n    address caller,\n    bytes32 coverKey,\n    address, /*to*/\n    uint256 /*amount*/\n  ) external override nonReentrant returns (address stablecoin) {\n    // @suppress-zero-value-check This function does not transfer any values\n    s.mustNotBePaused();\n    s.mustBeProtocolMember(caller);\n    s.mustBeProtocolMember(msg.sender);\n    s.senderMustBeVaultContract(coverKey);\n    s.callerMustBeClaimsProcessorContract(caller);\n\n    stablecoin = s.getStablecoin();\n  }\n\n  /**\n   * @dev This hook runs after `transferGovernance` implementation on vault(s)\n   * and performs cleanup and/or validation if needed.\n   *\n   * @custom:suppress-acl This function is only callable by the claims processor contract through the vault contract\n   * @custom:note do not update state and liquidity since `transferGovernance` is an internal contract-only function\n   * @custom:suppress-reentrancy The `postTransferGovernance` hook is executed under the same context of `preTransferGovernance`.\n   *\n   * @param caller Enter your msg.sender value.\n   * @param coverKey Provide your vault's cover key.\n   *\n   */\n  function postTransferGovernance(\n    address caller,\n    bytes32 coverKey,\n    address, /*to*/\n    uint256 /*amount*/\n  ) external view override {\n    s.mustNotBePaused();\n    s.mustBeProtocolMember(caller);\n    s.mustBeProtocolMember(msg.sender);\n    s.senderMustBeVaultContract(coverKey);\n    s.callerMustBeClaimsProcessorContract(caller);\n  }\n\n  /**\n   * @dev This hook runs before `transferToStrategy` implementation on vault(s)\n   *\n   * @custom:suppress-acl This function is only callable by a strategy contract through vault contract\n   * @custom:note Please note the following:\n   *\n   * - Transfers are allowed to exact strategy contracts only\n   * where the strategy can perform lending.\n   *\n   * @param caller Enter your msg.sender value\n   * @param token Provide the ERC20 token you'd like to transfer to the given strategy\n   * @param coverKey Provide your vault's cover key\n   * @param strategyName Enter the strategy name\n   * @param amount Enter the amount to transfer\n   *\n   */\n  function preTransferToStrategy(\n    address caller,\n    IERC20 token,\n    bytes32 coverKey,\n    bytes32 strategyName,\n    uint256 amount\n  ) external override nonReentrant {\n    // @suppress-zero-value-check Checked\n    s.mustNotBePaused();\n    s.mustBeProtocolMember(caller);\n    s.mustBeProtocolMember(msg.sender);\n    s.senderMustBeVaultContract(coverKey);\n    s.callerMustBeSpecificStrategyContract(caller, strategyName);\n\n    s.preTransferToStrategyInternal(token, coverKey, strategyName, amount);\n  }\n\n  /**\n   * @dev This hook runs after `transferToStrategy` implementation on vault(s)\n   * and performs cleanup and/or validation if needed.\n   *\n   * @custom:suppress-acl This function is only callable by a strategy contract through vault contract\n   * @custom:suppress-reentrancy Not required. The `postTransferToStrategy` hook is executed under the same context of `preTransferToStrategy`.\n   * @custom:note Do not update state and liquidity since `transferToStrategy` itself is a part of the state update\n   *\n   * @param caller Enter your msg.sender value\n   * @param coverKey Enter the coverKey\n   * @param strategyName Enter the strategy name\n   *\n   */\n  function postTransferToStrategy(\n    address caller,\n    IERC20, /*token*/\n    bytes32 coverKey,\n    bytes32 strategyName,\n    uint256 /*amount*/\n  ) external view override {\n    s.mustNotBePaused();\n    s.mustBeProtocolMember(caller);\n    s.mustBeProtocolMember(msg.sender);\n    s.senderMustBeVaultContract(coverKey);\n    s.callerMustBeSpecificStrategyContract(caller, strategyName);\n  }\n\n  /**\n   * @dev This hook runs before `receiveFromStrategy` implementation on vault(s)\n   *\n   * @custom:note Please note the following:\n   *\n   * - Access is allowed to exact strategy contracts only\n   * - The caller must be the strategy contract\n   * - msg.sender must be the correct vault contract\n   *\n   * @param caller Enter your msg.sender value\n   * @param coverKey Provide your vault's cover key\n   * @param strategyName Enter the strategy name\n   *\n   */\n  function preReceiveFromStrategy(\n    address caller,\n    IERC20, /*token*/\n    bytes32 coverKey,\n    bytes32 strategyName,\n    uint256 /*amount*/\n  ) external override nonReentrant {\n    // @suppress-zero-value-check This function does not transfer any tokens\n    s.mustNotBePaused();\n    s.mustBeProtocolMember(caller);\n    s.mustBeProtocolMember(msg.sender);\n    s.senderMustBeVaultContract(coverKey);\n    s.callerMustBeSpecificStrategyContract(caller, strategyName);\n  }\n\n  /**\n   * @dev This hook runs after `receiveFromStrategy` implementation on vault(s)\n   * and performs cleanup and/or validation if needed.\n   *\n   * @custom:note Do not update state and liquidity since `receiveFromStrategy` itself is a part of the state update\n   * @custom:suppress-reentrancy Not required. The `postReceiveFromStrategy` hook is executed under the same context of `preReceiveFromStrategy`.\n   *\n   * @param caller Enter your msg.sender value\n   * @param token Enter the token your vault received from strategy\n   * @param coverKey Enter the coverKey\n   * @param strategyName Enter the strategy name\n   * @param amount Enter the amount received\n   *\n   */\n  function postReceiveFromStrategy(\n    address caller,\n    IERC20 token,\n    bytes32 coverKey,\n    bytes32 strategyName,\n    uint256 amount\n  ) external override returns (uint256 income, uint256 loss) {\n    // @suppress-zero-value-check This call does not perform any transfers\n    s.mustNotBePaused();\n    s.mustBeProtocolMember(caller);\n    s.mustBeProtocolMember(msg.sender);\n    s.senderMustBeVaultContract(coverKey);\n    s.callerMustBeSpecificStrategyContract(caller, strategyName);\n\n    (income, loss) = s.postReceiveFromStrategyInternal(token, coverKey, strategyName, amount);\n  }\n\n  /**\n   * @dev This hook runs before `addLiquidity` implementation on vault(s)\n   *\n   * @custom:suppress-acl No need to define ACL as this function is only accessible to associated vault contract of the coverKey\n   * @custom:note Please note the following:\n   *\n   * - msg.sender must be correct vault contract\n   *\n   * @param coverKey Enter the cover key\n   * @param amount Enter the amount of liquidity token to supply.\n   * @param npmStakeToAdd Enter the amount of NPM token to stake.\n   *\n   */\n  function preAddLiquidity(\n    address caller,\n    bytes32 coverKey,\n    uint256 amount,\n    uint256 npmStakeToAdd\n  ) external override nonReentrant returns (uint256 podsToMint, uint256 previousNpmStake) {\n    // @suppress-zero-value-check This call does not transfer any tokens\n    s.mustNotBePaused();\n    s.mustBeProtocolMember(msg.sender);\n    s.senderMustBeVaultContract(coverKey);\n    s.mustEnsureAllProductsAreNormal(coverKey);\n\n    ValidationLibV1.mustNotExceedStablecoinThreshold(s, amount);\n    GovernanceUtilV1.mustNotExceedNpmThreshold(amount);\n\n    address pod = msg.sender;\n    (podsToMint, previousNpmStake) = s.preAddLiquidityInternal(coverKey, pod, caller, amount, npmStakeToAdd);\n  }\n\n  /**\n   * @dev This hook runs after `addLiquidity` implementation on vault(s)\n   * and performs cleanup and/or validation if needed.\n   *\n   * @custom:suppress-acl No need to define ACL as this function is only accessible to associated vault contract of the coverKey\n   * @custom:suppress-reentrancy Not required. The `postAddLiquidity` hook is executed under the same context of `preAddLiquidity`.\n   *\n   * @param coverKey Enter the coverKey\n   *\n   */\n  function postAddLiquidity(\n    address, /*caller*/\n    bytes32 coverKey,\n    uint256, /*amount*/\n    uint256 /*npmStakeToAdd*/\n  ) external override {\n    // @suppress-zero-value-check This function does not transfer any tokens\n    s.mustNotBePaused();\n    s.mustBeProtocolMember(msg.sender);\n    s.senderMustBeVaultContract(coverKey);\n    s.mustEnsureAllProductsAreNormal(coverKey);\n    s.updateStateAndLiquidity(coverKey);\n  }\n\n  /**\n   * @dev This implemention enables liquidity manages to\n   * accrue interests on a vault before withdrawals are allowed.\n   *\n   * @custom:suppress-acl This function is only accessible to the vault contract\n   * @custom:note Please note the following:\n   *\n   * - Caller must be a liquidity manager\n   * - msg.sender must the correct vault contract\n   *\n   * @param caller Enter your msg.sender value\n   * @param coverKey Provide your vault's cover key\n   *\n   */\n  function accrueInterestImplementation(address caller, bytes32 coverKey) external override {\n    s.mustNotBePaused();\n    s.senderMustBeVaultContract(coverKey);\n    AccessControlLibV1.callerMustBeLiquidityManager(s, caller);\n\n    s.accrueInterestInternal(coverKey);\n  }\n\n  /**\n   * @dev This hook runs before `removeLiquidity` implementation on vault(s)\n   *\n   * @custom:suppress-acl No need to define ACL as this function is only accessible to associated vault contract of the coverKey\n   * @custom:note Please note the following:\n   *\n   * - msg.sender must be the correct vault contract\n   * - Must have at couple of block height offset following a deposit.\n   * - Must be done during withdrawal period\n   * - Must have no balance in strategies\n   * - Cover status should be normal\n   * - Interest should already be accrued\n   *\n   * @param caller Enter your msg.sender value\n   * @param coverKey Enter the cover key\n   * @param podsToRedeem Enter the amount of pods to redeem\n   * @param npmStakeToRemove Enter the amount of NPM stake to remove.\n   * @param exit If this is set to true, LPs can remove their entire NPM stake during a withdrawal period. No restriction.\n   *\n   */\n  function preRemoveLiquidity(\n    address caller,\n    bytes32 coverKey,\n    uint256 podsToRedeem,\n    uint256 npmStakeToRemove,\n    bool exit\n  ) external override nonReentrant returns (address stablecoin, uint256 stablecoinToRelease) {\n    // @suppress-zero-value-check This call does not transfer any tokens\n    s.mustNotBePaused();\n    s.mustBeProtocolMember(msg.sender);\n    s.senderMustBeVaultContract(coverKey);\n    s.mustMaintainBlockHeightOffset(coverKey);\n    s.mustEnsureAllProductsAreNormal(coverKey);\n    s.mustBeDuringWithdrawalPeriod(coverKey);\n    s.mustHaveNoBalanceInStrategies(coverKey, stablecoin);\n    s.mustBeAccrued(coverKey);\n\n    address pod = msg.sender; // The sender is vault contract\n    return s.preRemoveLiquidityInternal(coverKey, pod, caller, podsToRedeem, npmStakeToRemove, exit);\n  }\n\n  /**\n   * @dev This hook runs after `removeLiquidity` implementation on vault(s)\n   * and performs cleanup and/or validation if needed.\n   *\n   * @custom:suppress-acl No need to define ACL as this function is only accessible to associated vault contract of the coverKey\n   * @custom:suppress-reentrancy Not required. The `postRemoveLiquidity` hook is executed under the same context as `preRemoveLiquidity`.\n   *\n   * @param coverKey Enter the coverKey\n   *\n   */\n  function postRemoveLiquidity(\n    address, /*caller*/\n    bytes32 coverKey,\n    uint256, /*podsToRedeem*/\n    uint256, /*npmStakeToRemove*/\n    bool /*exit*/\n  ) external override {\n    // @suppress-zero-value-check The uint values are not used and therefore not checked\n    s.mustNotBePaused();\n    s.mustBeProtocolMember(msg.sender);\n    s.senderMustBeVaultContract(coverKey);\n    s.updateStateAndLiquidity(coverKey);\n  }\n\n  /**\n   * @dev Calculates the amount of PODs to mint for the given amount of stablecoin\n   *\n   * @param coverKey Enter the cover for which you want to calculate PODs\n   * @param stablecoinIn Enter the amount in the stablecoin units\n   *\n   * @return Returns the units of PODs to be minted if this stablecoin liquidity was supplied.\n   * Be warned that this value may change based on the cover vault's usage.\n   *\n   */\n  function calculatePodsImplementation(bytes32 coverKey, uint256 stablecoinIn) external view override returns (uint256) {\n    s.senderMustBeVaultContract(coverKey);\n\n    address pod = msg.sender;\n\n    return s.calculatePodsInternal(coverKey, pod, stablecoinIn);\n  }\n\n  /**\n   * @dev Calculates the amount of stablecoin units to receive for the given amount of PODs to redeem\n   *\n   * @param coverKey Enter the cover for which you want to calculate PODs\n   * @param podsToBurn Enter the amount in the POD units to redeem\n   *\n   * @return Returns the units of stablecoins to redeem if the specified PODs were burned.\n   * Be warned that this value may change based on the cover's vault usage.\n   *\n   */\n  function calculateLiquidityImplementation(bytes32 coverKey, uint256 podsToBurn) external view override returns (uint256) {\n    s.senderMustBeVaultContract(coverKey);\n    address pod = msg.sender;\n    return s.calculateLiquidityInternal(coverKey, pod, podsToBurn);\n  }\n\n  /**\n   * @dev Returns the stablecoin balance of this vault\n   * This also includes amounts lent out in lending strategies by this vault\n   *\n   * Warning: this function does not validate the cover key supplied.\n   *\n   * @param coverKey Enter the cover for which you want to get the stablecoin balance\n   */\n  function getStablecoinBalanceOfImplementation(bytes32 coverKey) external view override returns (uint256) {\n    s.senderMustBeVaultContract(coverKey);\n    return s.getStablecoinOwnedByVaultInternal(coverKey);\n  }\n\n  /**\n   * @dev Gets information of a given vault by the cover key\n   *\n   * Warning: this function does not validate the cover key and account supplied.\n   *\n   * @param coverKey Specify cover key to obtain the info of\n   * @param you The address for which the info will be customized\n   * @param values[0] totalPods --> Total PODs in existence\n   * @param values[1] balance --> Stablecoins held in the vault\n   * @param values[2] extendedBalance --> Stablecoins lent outside of the protocol\n   * @param values[3] totalReassurance -- > Total reassurance for this cover\n   * @param values[4] myPodBalance --> Your POD Balance\n   * @param values[5] myShare --> My share of the liquidity pool (in stablecoin)\n   * @param values[6] withdrawalOpen --> The timestamp when withdrawals are opened\n   * @param values[7] withdrawalClose --> The timestamp when withdrawals are closed again\n   *\n   */\n  function getInfoImplementation(bytes32 coverKey, address you) external view override returns (uint256[] memory values) {\n    s.senderMustBeVaultContract(coverKey);\n    address pod = msg.sender;\n    return s.getInfoInternal(coverKey, pod, you);\n  }\n\n  /**\n   * @dev Version number of this contract\n   */\n  function version() external pure override returns (bytes32) {\n    return \"v0.1\";\n  }\n\n  /**\n   * @dev Name of this contract\n   */\n  function getName() external pure override returns (bytes32) {\n    return ProtoUtilV1.CNAME_VAULT_DELEGATE;\n  }\n}"
    },
    {
      "filename": "contracts/core/policy/PolicyAdmin.sol",
      "content": "// Neptune Mutual Protocol (https://neptunemutual.com)\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\nimport \"../../interfaces/IStore.sol\";\nimport \"../../interfaces/IPolicyAdmin.sol\";\nimport \"../../libraries/PolicyHelperV1.sol\";\nimport \"../../libraries/StoreKeyUtil.sol\";\nimport \"../../libraries/ProtoUtilV1.sol\";\nimport \"../Recoverable.sol\";\n\n/**\n * @title Policy Admin Contract\n * @dev The policy admin contract enables the owner (governance)\n * to set the policy rate and fee info.\n */\ncontract PolicyAdmin is IPolicyAdmin, Recoverable {\n  using ProtoUtilV1 for bytes;\n  using PolicyHelperV1 for IStore;\n  using ProtoUtilV1 for IStore;\n  using ValidationLibV1 for IStore;\n  using CoverUtilV1 for IStore;\n  using StoreKeyUtil for IStore;\n  using NTransferUtilV2 for IERC20;\n  using RoutineInvokerLibV1 for IStore;\n\n  /**\n   * @dev Constructs this contract\n   * @param store Provide the store contract instance\n   */\n  constructor(IStore store) Recoverable(store) {} // solhint-disable-line\n\n  /**\n   * @dev Sets policy rates. This feature is only accessible by cover manager.\n   * @param floor The lowest cover fee rate fallback\n   * @param ceiling The highest cover fee rate fallback\n   */\n  function setPolicyRates(uint256 floor, uint256 ceiling) external override nonReentrant {\n    s.mustNotBePaused();\n    AccessControlLibV1.mustBeCoverManager(s);\n\n    require(floor > 0, \"Please specify floor\");\n    require(ceiling > floor, \"Invalid ceiling\");\n\n    s.setUintByKey(ProtoUtilV1.NS_COVER_POLICY_RATE_FLOOR, floor);\n    s.setUintByKey(ProtoUtilV1.NS_COVER_POLICY_RATE_CEILING, ceiling);\n\n    s.updateStateAndLiquidity(0);\n\n    emit PolicyRateSet(floor, ceiling);\n  }\n\n  /**\n   * @dev Sets policy rates for the given cover key. This feature is only accessible by cover manager.\n   * @param floor The lowest cover fee rate for this cover\n   * @param ceiling The highest cover fee rate for this cover\n   */\n  function setPolicyRatesByKey(\n    bytes32 coverKey,\n    uint256 floor,\n    uint256 ceiling\n  ) external override nonReentrant {\n    s.mustNotBePaused();\n    AccessControlLibV1.mustBeCoverManager(s);\n    s.mustBeValidCoverKey(coverKey);\n\n    require(floor > 0, \"Please specify floor\");\n    require(ceiling > 0, \"Invalid ceiling\");\n\n    s.setUintByKeys(ProtoUtilV1.NS_COVER_POLICY_RATE_FLOOR, coverKey, floor);\n    s.setUintByKeys(ProtoUtilV1.NS_COVER_POLICY_RATE_CEILING, coverKey, ceiling);\n\n    s.updateStateAndLiquidity(coverKey);\n\n    emit CoverPolicyRateSet(coverKey, floor, ceiling);\n  }\n\n  /**\n   * @dev The coverage of a policy begins at the EOD timestamp\n   * of the policy purchase date plus the coverage lag.\n   *\n   * Coverage lag is a specified time period that can be set globally\n   * or on a per-cover basis to delay the start of coverage.\n   *\n   * This allows us to defend against time-based opportunistic attacks,\n   * which occur when an attacker purchases coverage after\n   * an incident has occurred but before the incident has been reported.\n   */\n  function setCoverageLag(bytes32 coverKey, uint256 window) external override {\n    require(window >= 1 days, \"Enter at least 1 day\");\n\n    s.mustNotBePaused();\n    AccessControlLibV1.mustBeCoverManager(s);\n\n    if (coverKey > 0) {\n      s.mustBeValidCoverKey(coverKey);\n      s.setUintByKeys(ProtoUtilV1.NS_COVERAGE_LAG, coverKey, window);\n\n      emit CoverageLagSet(coverKey, window);\n      return;\n    }\n\n    s.setUintByKey(ProtoUtilV1.NS_COVERAGE_LAG, window);\n    emit CoverageLagSet(coverKey, window);\n  }\n\n  /**\n   * @dev Gets the cover policy rates for the given cover key\n   *\n   * Warning: this function does not validate the cover key supplied.\n   *\n   */\n  function getPolicyRates(bytes32 coverKey) external view override returns (uint256 floor, uint256 ceiling) {\n    return s.getPolicyRatesInternal(coverKey);\n  }\n\n  /**\n   * @dev Gets the policy lag for the given cover key\n   *\n   * Warning: this function does not validate the cover key supplied.\n   *\n   */\n  function getCoverageLag(bytes32 coverKey) external view override returns (uint256) {\n    return s.getCoverageLagInternal(coverKey);\n  }\n\n  /**\n   * @dev Version number of this contract\n   */\n  function version() external pure override returns (bytes32) {\n    return \"v0.1\";\n  }\n\n  /**\n   * @dev Name of this contract\n   */\n  function getName() external pure override returns (bytes32) {\n    return ProtoUtilV1.CNAME_POLICY_ADMIN;\n  }\n}"
    },
    {
      "filename": "audit-start/contracts/core/Protocol.sol",
      "content": "// Neptune Mutual Protocol (https://neptunemutual.com)\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"../interfaces/IStore.sol\";\nimport \"../interfaces/IProtocol.sol\";\nimport \"../libraries/ProtoUtilV1.sol\";\nimport \"../libraries/StoreKeyUtil.sol\";\nimport \"./ProtoBase.sol\";\n\ncontract Protocol is IProtocol, ProtoBase {\n  using ProtoUtilV1 for bytes;\n  using RegistryLibV1 for IStore;\n  using ProtoUtilV1 for IStore;\n  using ValidationLibV1 for IStore;\n  using StoreKeyUtil for IStore;\n\n  bool public initialized = false;\n\n  constructor(IStore store) ProtoBase(store) {} // solhint-disable-line\n\n  /**\n   * @dev Initializes the protocol once. There is only one instance of the protocol\n   * that can function.\n   *\n   * @custom:suppress-acl Can only be called by the deployer or an admin\n   * @custom:suppress-initialization Can only be initialized by the deployer or an admin\n   * @custom:note Burner isn't necessarily the zero address. The tokens to be burned are sent to an address,\n   * bridged back to the Ethereum mainnet (if on a different chain), and burned on a period but random basis.\n   *\n   *\n   * @param addresses[0] burner\n   * @param addresses[1] uniswapV2RouterLike\n   * @param addresses[2] uniswapV2FactoryLike\n   * @param addresses[3] npm\n   * @param addresses[4] treasury\n   * @param addresses[5] npm price oracle\n   * @param values[0] coverCreationFee\n   * @param values[1] minCoverCreationStake\n   * @param values[2] firstReportingStake\n   * @param values[3] claimPeriod\n   * @param values[4] reportingBurnRate\n   * @param values[5] governanceReporterCommission\n   * @param values[6] claimPlatformFee\n   * @param values[7] claimReporterCommission\n   * @param values[8] flashLoanFee\n   * @param values[9] flashLoanFeeProtocol\n   * @param values[10] resolutionCoolDownPeriod\n   * @param values[11] state and liquidity update interval\n   * @param values[12] max lending ratio\n   */\n  function initialize(address[] calldata addresses, uint256[] calldata values) external override nonReentrant whenNotPaused {\n    s.mustBeProtocolMember(msg.sender);\n\n    require(addresses[0] != address(0), \"Invalid Burner\");\n    // require(addresses[1] != address(0), \"Invalid Uniswap V2 Router\");\n    // require(addresses[2] != address(0), \"Invalid Uniswap V2 Factory\");\n    // require(addresses[3] != address(0), \"Invalid NPM\"); // @note: check validation below\n    require(addresses[4] != address(0), \"Invalid Treasury\");\n    // require(addresses[5] != address(0), \"Invalid NPM Price Oracle\");\n\n    // @suppress-zero-value-check @suppress-accidental-zero Some zero values are allowed\n    // These checks are disabled as this function is only accessible to an admin\n    // require(values[0] > 0, \"Invalid cover creation fee\");\n    // require(values[1] > 0, \"Invalid cover creation stake\");\n    // require(values[2] > 0, \"Invalid first reporting stake\");\n    // require(values[3] > 0, \"Invalid claim period\");\n    // require(values[4] > 0, \"Invalid reporting burn rate\");\n    // require(values[5] > 0, \"Invalid reporter income: NPM\");\n    // require(values[6] > 0, \"Invalid platform fee: claims\");\n    // require(values[7] > 0, \"Invalid reporter income: claims\");\n    // require(values[8] > 0, \"Invalid vault fee: flashloan\");\n    // require(values[9] > 0, \"Invalid platform fee: flashloan\");\n    // require(values[10] >= 24 hours, \"Invalid cooldown period\");\n    // require(values[11] > 0, \"Invalid state update interval\");\n    // require(values[12] > 0, \"Invalid max lending ratio\");\n\n    if (initialized == true) {\n      AccessControlLibV1.mustBeAdmin(s);\n      require(addresses[3] == address(0), \"Can't change NPM\");\n    } else {\n      require(addresses[3] != address(0), \"Invalid NPM\");\n\n      s.setAddressByKey(ProtoUtilV1.CNS_CORE, address(this));\n      s.setBoolByKeys(ProtoUtilV1.NS_CONTRACTS, address(this), true);\n\n      s.setAddressByKey(ProtoUtilV1.CNS_NPM, addresses[3]);\n    }\n\n    s.setAddressByKey(ProtoUtilV1.CNS_BURNER, addresses[0]);\n\n    s.setAddressByKey(ProtoUtilV1.CNS_UNISWAP_V2_ROUTER, addresses[1]);\n    s.setAddressByKey(ProtoUtilV1.CNS_UNISWAP_V2_FACTORY, addresses[2]);\n    s.setAddressByKey(ProtoUtilV1.CNS_TREASURY, addresses[4]);\n    s.setAddressByKey(ProtoUtilV1.CNS_NPM_PRICE_ORACLE, addresses[5]);\n\n    s.setUintByKey(ProtoUtilV1.NS_COVER_CREATION_FEE, values[0]);\n    s.setUintByKey(ProtoUtilV1.NS_COVER_CREATION_MIN_STAKE, values[1]);\n    s.setUintByKey(ProtoUtilV1.NS_GOVERNANCE_REPORTING_MIN_FIRST_STAKE, values[2]);\n    s.setUintByKey(ProtoUtilV1.NS_CLAIM_PERIOD, values[3]);\n    s.setUintByKey(ProtoUtilV1.NS_GOVERNANCE_REPORTING_BURN_RATE, values[4]);\n    s.setUintByKey(ProtoUtilV1.NS_GOVERNANCE_REPORTER_COMMISSION, values[5]);\n    s.setUintByKey(ProtoUtilV1.NS_COVER_PLATFORM_FEE, values[6]);\n    s.setUintByKey(ProtoUtilV1.NS_CLAIM_REPORTER_COMMISSION, values[7]);\n    s.setUintByKey(ProtoUtilV1.NS_COVER_LIQUIDITY_FLASH_LOAN_FEE, values[8]);\n    s.setUintByKey(ProtoUtilV1.NS_COVER_LIQUIDITY_FLASH_LOAN_FEE_PROTOCOL, values[9]);\n    s.setUintByKey(ProtoUtilV1.NS_RESOLUTION_COOL_DOWN_PERIOD, values[10]);\n    s.setUintByKey(ProtoUtilV1.NS_LIQUIDITY_STATE_UPDATE_INTERVAL, values[11]);\n    s.setUintByKey(ProtoUtilV1.NS_COVER_LIQUIDITY_MAX_LENDING_RATIO, values[12]);\n    s.setUintByKey(ProtoUtilV1.NS_COVERAGE_LAG, 1 days);\n\n    initialized = true;\n    emit Initialized(addresses, values);\n  }\n\n  /**\n   * @dev Adds member to the protocol\n   *\n   * A member is a trusted EOA or a contract that was added to the protocol using `addContract`\n   * function. When a contract is removed using `upgradeContract` function, the membership of previous\n   * contract is also removed.\n   *\n   * @custom:warning Warning:\n   *\n   * This feature is only accessible to an upgrade agent.\n   * Since adding member to the protocol is a highy risky activity,\n   * the role `Upgrade Agent` is considered to be one of the most `Critical` roles.\n   *\n   * Using Tenderly War Rooms/Web3 Actions or OZ Defender, the protocol needs to be paused\n   * when this function is invoked.\n   *\n   * @custom:suppress-address-trust-issue The address `member` can be trusted because this can only come from upgrade agents.\n   *\n   * @param member Enter an address to add as a protocol member\n   */\n  function addMember(address member) external override nonReentrant whenNotPaused {\n    s.mustNotBePaused();\n    AccessControlLibV1.mustBeUpgradeAgent(s);\n\n    AccessControlLibV1.addMemberInternal(s, member);\n    emit MemberAdded(member);\n  }\n\n  /**\n   * @dev Removes a member from the protocol. This function is only accessible\n   * to an upgrade agent.\n   *\n   * @custom:suppress-address-trust-issue The address `member` can be trusted because of the ACL requirement.\n   *\n   * @param member Enter an address to remove as a protocol member\n   */\n  function removeMember(address member) external override nonReentrant whenNotPaused {\n    ProtoUtilV1.mustBeProtocolMember(s, member);\n    s.mustNotBePaused();\n    AccessControlLibV1.mustBeUpgradeAgent(s);\n\n    AccessControlLibV1.removeMemberInternal(s, member);\n    emit MemberRemoved(member);\n  }\n\n  /**\n   * @dev Adds a contract to the protocol. See `addContractWithKey` for more info.\n   * @custom:suppress-acl This function is just an intermediate\n   * @custom:suppress-pausable This function is just an intermediate\n   */\n  function addContract(bytes32 namespace, address contractAddress) external override {\n    addContractWithKey(namespace, ProtoUtilV1.KEY_INTENTIONALLY_EMPTY, contractAddress);\n  }\n\n  /**\n   * @dev Adds a contract to the protocol using a namespace and key.\n   *\n   * The contracts that are added using this function are also added as protocol members.\n   * Each contract you add to the protocol needs to also specify the namespace and also\n   * key if applicable. The key is useful when multiple instances of a contract can\n   * be deployed. For example, multiple instances of cxTokens and Vaults can be deployed on demand.\n   *\n   * Tip: find out how the `getVaultFactoryContract().deploy` function is being used.\n   *\n   * @custom:warning Warning:\n   *\n   * This feature is only accessible to an upgrade agent.\n   * Since adding member to the protocol is a highy risky activity,\n   * the role `Upgrade Agent` is considered to be one of the most `Critical` roles.\n   *\n   * Using Tenderly War Rooms/Web3 Actions or OZ Defender, the protocol needs to be paused\n   * when this function is invoked.\n   *\n   * @custom:suppress-address-trust-issue Although the `contractAddress` can't be trusted,\n   * an upgrade admin has to check the contract code manually.\n   *\n   * @param namespace Enter a unique namespace for this contract\n   * @param key Enter a key if this contract has siblings\n   * @param contractAddress Enter the contract address to add.\n   *\n   */\n  function addContractWithKey(\n    bytes32 namespace,\n    bytes32 key,\n    address contractAddress\n  ) public override nonReentrant whenNotPaused {\n    require(contractAddress != address(0), \"Invalid contract\");\n\n    s.mustNotBePaused();\n    AccessControlLibV1.mustBeUpgradeAgent(s);\n    address current = s.getProtocolContract(namespace);\n\n    require(current == address(0), \"Please upgrade contract\");\n\n    AccessControlLibV1.addContractInternal(s, namespace, key, contractAddress);\n    emit ContractAdded(namespace, key, contractAddress);\n  }\n\n  /**\n   * @dev Upgrades a contract at the given namespace. See `upgradeContractWithKey` for more info.\n   *\n   * @custom:suppress-acl This function is just an intermediate\n   * @custom:suppress-pausable This function is just an intermediate\n   *\n   */\n  function upgradeContract(\n    bytes32 namespace,\n    address previous,\n    address current\n  ) external override {\n    upgradeContractWithKey(namespace, ProtoUtilV1.KEY_INTENTIONALLY_EMPTY, previous, current);\n  }\n\n  /**\n   * @dev Upgrades a contract at the given namespace and key.\n   *\n   * The previous contract's protocol membership is revoked and\n   * the current immediately starts assuming responsbility of\n   * whatever the contract needs to do at the supplied namespace and key.\n   *\n   * @custom:warning Warning:\n   *\n   * This feature is only accessible to an upgrade agent.\n   * Since adding member to the protocol is a highy risky activity,\n   * the role `Upgrade Agent` is considered to be one of the most `Critical` roles.\n   *\n   * Using Tenderly War Rooms/Web3 Actions or OZ Defender, the protocol needs to be paused\n   * when this function is invoked.\n   *\n   * @custom:suppress-address-trust-issue Can only be invoked by an upgrade agent.\n   *\n   * @param namespace Enter a unique namespace for this contract\n   * @param key Enter a key if this contract has siblings\n   * @param previous Enter the existing contract address at this namespace and key.\n   * @param current Enter the contract address which will replace the previous contract.\n   */\n  function upgradeContractWithKey(\n    bytes32 namespace,\n    bytes32 key,\n    address previous,\n    address current\n  ) public override nonReentrant whenNotPaused {\n    require(current != address(0), \"Invalid contract\");\n\n    ProtoUtilV1.mustBeProtocolMember(s, previous);\n    ProtoUtilV1.mustBeExactContract(s, namespace, key, previous);\n    s.mustNotBePaused();\n    AccessControlLibV1.mustBeUpgradeAgent(s);\n\n    AccessControlLibV1.upgradeContractInternal(s, namespace, key, previous, current);\n    emit ContractUpgraded(namespace, key, previous, current);\n  }\n\n  /**\n   * @dev Grants"
    }
  ]
}