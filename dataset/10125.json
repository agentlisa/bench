{
  "Title": "[M-06] ConcentratedLiquidityPoolManager.sol `claimReward()` and `reclaimIncentive()` will fail when `incentive.token` is `token0` or `token1`",
  "Content": "_Submitted by WatchPug_\n\nIn `ConcentratedLiquidityPosition.collect()`, balances of `token0` and `token1` in bento will be used to pay the fees.\n\n[`ConcentratedLiquidityPosition.sol#L103` L116](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPosition.sol#L103-L116)\n\n```solidity\nuint256 balance0 = bento.balanceOf(token0, address(this));\nuint256 balance1 = bento.balanceOf(token1, address(this));\nif (balance0 < token0amount || balance1 < token1amount) {\n    (uint256 amount0fees, uint256 amount1fees) = position.pool.collect(position.lower, position.upper, address(this), false);\n\n    uint256 newBalance0 = amount0fees + balance0;\n    uint256 newBalance1 = amount1fees + balance1;\n\n    /// @dev Rounding errors due to frequent claiming of other users in the same position may cost us some raw\n    if (token0amount > newBalance0) token0amount = newBalance0;\n    if (token1amount > newBalance1) token1amount = newBalance1;\n}\n_transfer(token0, address(this), recipient, token0amount, unwrapBento);\n_transfer(token1, address(this), recipient, token1amount, unwrapBento);\n\n```\n\nIn the case of someone add an incentive with `token0` or `token1`, the incentive in the balance of bento will be used to pay fees until the balance is completely consumed.\n\nAs a result, when a user calls `claimReward()`, the contract may not have enough balance to pay (it supposed to have it), cause the transaction to fail.\n\n[`ConcentratedLiquidityPoolManager.sol#L78` L100](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L78-L100)\n```solidity\nfunction claimReward(\n    uint256 positionId,\n    uint256 incentiveId,\n    address recipient,\n    bool unwrapBento\n) public {\n    require(ownerOf[positionId] == msg.sender, \"OWNER\");\n    Position memory position = positions[positionId];\n    IConcentratedLiquidityPool pool = position.pool;\n    Incentive storage incentive = incentives[position.pool][positionId];\n    Stake storage stake = stakes[positionId][incentiveId];\n    require(stake.initialized, \"UNINITIALIZED\");\n    uint256 secondsPerLiquidityInside = pool.rangeSecondsInside(position.lower, position.upper) - stake.secondsInsideLast;\n    uint256 secondsInside = secondsPerLiquidityInside * position.liquidity;\n    uint256 maxTime = incentive.endTime < block.timestamp ? block.timestamp : incentive.endTime;\n    uint256 secondsUnclaimed = (maxTime - incentive.startTime) << (128 - incentive.secondsClaimed);\n    uint256 rewards = (incentive.rewardsUnclaimed * secondsInside) / secondsUnclaimed;\n    incentive.rewardsUnclaimed -= rewards;\n    incentive.secondsClaimed += uint160(secondsInside);\n    stake.secondsInsideLast += uint160(secondsPerLiquidityInside);\n    _transfer(incentive.token, address(this), recipient, rewards, unwrapBento);\n    emit ClaimReward(positionId, incentiveId, recipient);\n}\n```\nThe same issue applies to `reclaimIncentive()` as well.\n[`ConcentratedLiquidityPoolManager.sol` L49 L62](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L49-L62)\n\n```solidity\nfunction reclaimIncentive(\n    IConcentratedLiquidityPool pool,\n    uint256 incentiveId,\n    uint256 amount,\n    address receiver,\n    bool unwrapBento\n) public {\n    Incentive storage incentive = incentives[pool][incentiveId];\n    require(incentive.owner == msg.sender, \"NOT_OWNER\");\n    require(incentive.expiry < block.timestamp, \"EXPIRED\");\n    require(incentive.rewardsUnclaimed >= amount, \"ALREADY_CLAIMED\");\n    _transfer(incentive.token, address(this), receiver, amount, unwrapBento);\n    emit ReclaimIncentive(pool, incentiveId);\n}\n```\n\n#### Recommendation\nConsider making adding `token0` or `token1` as incentives disallowed, or keep a record of total remaining incentive amounts for the incentive tokens and avoid consuming these revered balances when `collect()`.\n\n**[sarangparikh22 (Sushi) confirmed](https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/23)**\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2021-09-sushitrident-2",
  "Code": [
    {
      "filename": "contracts/pool/concentrated/ConcentratedLiquidityPosition.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"../../interfaces/IBentoBoxMinimal.sol\";\nimport \"../../interfaces/IConcentratedLiquidityPool.sol\";\nimport \"../../interfaces/IMasterDeployer.sol\";\nimport \"../../interfaces/ITridentRouter.sol\";\nimport \"../../libraries/concentratedPool/FullMath.sol\";\nimport \"./TridentNFT.sol\";\nimport \"hardhat/console.sol\";\n\n/// @notice Trident Concentrated Liquidity Pool periphery contract that combines non-fungible position management and staking.\nabstract contract ConcentratedLiquidityPosition is TridentNFT {\n    event Mint(address indexed pool, address indexed recipient, uint256 indexed positionId);\n    event Burn(address indexed pool, address indexed owner, uint256 indexed positionId);\n\n    address public immutable wETH;\n    IBentoBoxMinimal public immutable bento;\n    IMasterDeployer public immutable masterDeployer;\n\n    mapping(uint256 => Position) public positions;\n\n    struct Position {\n        IConcentratedLiquidityPool pool;\n        uint128 liquidity;\n        int24 lower;\n        int24 upper;\n        uint256 feeGrowthInside0; /// @dev Per unit of liquidity.\n        uint256 feeGrowthInside1;\n    }\n\n    constructor(address _wETH, address _masterDeployer) {\n        wETH = _wETH;\n        masterDeployer = IMasterDeployer(_masterDeployer);\n        bento = IBentoBoxMinimal(IMasterDeployer(_masterDeployer).bento());\n    }\n\n    function positionMintCallback(\n        address recipient,\n        int24 lower,\n        int24 upper,\n        uint128 amount,\n        uint256 feeGrowthInside0,\n        uint256 feeGrowthInside1\n    ) external returns (uint256 positionId) {\n        require(IMasterDeployer(masterDeployer).pools(msg.sender), \"NOT_POOL\");\n        positions[totalSupply] = Position(IConcentratedLiquidityPool(msg.sender), amount, lower, upper, feeGrowthInside0, feeGrowthInside1);\n        positionId = totalSupply;\n        _mint(recipient);\n        emit Mint(msg.sender, recipient, positionId);\n    }\n\n    function burn(\n        uint256 tokenId,\n        uint128 amount,\n        address recipient,\n        bool unwrapBento\n    ) external {\n        require(msg.sender == ownerOf[tokenId], \"NOT_ID_OWNER\");\n        Position storage position = positions[tokenId];\n        if (position.liquidity < amount) amount = position.liquidity;\n\n        position.pool.burn(abi.encode(position.lower, position.upper, amount, recipient, unwrapBento));\n\n        if (amount < position.liquidity) {\n            position.liquidity -= amount;\n        } else {\n            delete positions[tokenId];\n            _burn(tokenId);\n        }\n        emit Burn(address(position.pool), msg.sender, tokenId);\n    }\n\n    function collect(\n        uint256 tokenId,\n        address recipient,\n        bool unwrapBento\n    ) external returns (uint256 token0amount, uint256 token1amount) {\n        require(msg.sender == ownerOf[tokenId], \"NOT_ID_OWNER\");\n\n        Position storage position = positions[tokenId];\n\n        (address token0, address token1) = _getAssets(position.pool);\n\n        {\n            (uint256 feeGrowthInside0, uint256 feeGrowthInside1) = position.pool.rangeFeeGrowth(position.lower, position.upper);\n            token0amount = FullMath.mulDiv(\n                feeGrowthInside0 - position.feeGrowthInside0,\n                position.liquidity,\n                0x100000000000000000000000000000000\n            );\n            token1amount = FullMath.mulDiv(\n                feeGrowthInside1 - position.feeGrowthInside1,\n                position.liquidity,\n                0x100000000000000000000000000000000\n            );\n\n            position.feeGrowthInside0 = feeGrowthInside0;\n            position.feeGrowthInside1 = feeGrowthInside1;\n        }\n\n        uint256 balance0 = bento.balanceOf(token0, address(this));\n        uint256 balance1 = bento.balanceOf(token1, address(this));\n        if (balance0 < token0amount || balance1 < token1amount) {\n            (uint256 amount0fees, uint256 amount1fees) = position.pool.collect(position.lower, position.upper, address(this), false);\n\n            uint256 newBalance0 = amount0fees + balance0;\n            uint256 newBalance1 = amount1fees + balance1;\n\n            /// @dev Rounding errors due to frequent claiming of other users in the same position may cost us some raw\n            if (token0amount > newBalance0) token0amount = newBalance0;\n            if (token1amount > newBalance1) token1amount = newBalance1;\n        }\n        _transfer(token0, address(this), recipient, token0amount, unwrapBento);\n        _transfer(token1, address(this), recipient, token1amount, unwrapBento);\n    }\n\n    function _getAssets(IConcentratedLiquidityPool pool) internal view returns (address token0, address token1) {\n        address[] memory pair = pool.getAssets();\n        token0 = pair[0];\n        token1 = pair[1];\n    }\n\n    function _transfer(\n        address token,\n        address from,\n        address to,\n        uint256 shares,\n        bool unwrapBento\n    ) internal {\n        if (unwrapBento) {\n            bento.withdraw(token, from, to, 0, shares);\n        } else {\n            bento.transfer(token, from, to, shares);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"../../interfaces/IConcentratedLiquidityPool.sol\";\nimport \"./ConcentratedLiquidityPosition.sol\";\n\n/// @notice Trident Concentrated Liquidity Pool periphery contract that combines non-fungible position management and staking.\ncontract ConcentratedLiquidityPoolManager is ConcentratedLiquidityPosition {\n    event AddIncentive(IConcentratedLiquidityPool indexed pool, Incentive indexed incentive);\n    event ReclaimIncentive(IConcentratedLiquidityPool indexed pool, uint256 indexed incentiveId);\n    event Subscribe(uint256 indexed positionId, uint256 indexed incentiveId);\n    event ClaimReward(uint256 indexed positionId, uint256 indexed incentiveId, address indexed recipient);\n\n    struct Incentive {\n        address owner;\n        address token;\n        uint256 rewardsUnclaimed;\n        uint160 secondsClaimed; // @dev x128.\n        uint32 startTime;\n        uint32 endTime;\n        uint32 expiry;\n    }\n\n    struct Stake {\n        uint160 secondsInsideLast; // @dev x128.\n        bool initialized;\n    }\n\n    mapping(IConcentratedLiquidityPool => uint256) public incentiveCount;\n    mapping(IConcentratedLiquidityPool => mapping(uint256 => Incentive)) public incentives;\n    mapping(uint256 => mapping(uint256 => Stake)) public stakes;\n\n    constructor(address wETH, address _masterDeployer) ConcentratedLiquidityPosition(wETH, _masterDeployer) {}\n\n    function addIncentive(IConcentratedLiquidityPool pool, Incentive memory incentive) public {\n        uint32 current = uint32(block.timestamp);\n        require(current <= incentive.startTime, \"ALREADY_STARTED\");\n        require(current <= incentive.endTime, \"ALREADY_ENDED\");\n        require(incentive.startTime < incentive.endTime, \"START_PAST_END\");\n        require(incentive.endTime + 5 weeks < incentive.expiry, \"END_PAST_BUFFER\");\n        require(incentive.rewardsUnclaimed != 0, \"NO_REWARDS\");\n        incentives[pool][incentiveCount[pool]++] = incentive;\n        _transfer(incentive.token, msg.sender, address(this), incentive.rewardsUnclaimed, false);\n        emit AddIncentive(pool, incentive);\n    }\n\n    /// @dev Withdraws any unclaimed incentive rewards.\n    function reclaimIncentive(\n        IConcentratedLiquidityPool pool,\n        uint256 incentiveId,\n        uint256 amount,\n        address receiver,\n        bool unwrapBento\n    ) public {\n        Incentive storage incentive = incentives[pool][incentiveId];\n        require(incentive.owner == msg.sender, \"NOT_OWNER\");\n        require(incentive.expiry < block.timestamp, \"EXPIRED\");\n        require(incentive.rewardsUnclaimed >= amount, \"ALREADY_CLAIMED\");\n        _transfer(incentive.token, address(this), receiver, amount, unwrapBento);\n        emit ReclaimIncentive(pool, incentiveId);\n    }\n\n    /// @dev Subscribes a non-fungible position token to an incentive.\n    function subscribe(uint256 positionId, uint256 incentiveId) public {\n        Position memory position = positions[positionId];\n        IConcentratedLiquidityPool pool = position.pool;\n        Incentive memory incentive = incentives[pool][positionId];\n        Stake storage stake = stakes[positionId][incentiveId];\n        require(position.liquidity != 0, \"INACTIVE\");\n        require(stake.secondsInsideLast == 0, \"SUBSCRIBED\");\n        require(incentiveId <= incentiveCount[pool], \"NOT_INCENTIVE\");\n        require(block.timestamp > incentive.startTime && block.timestamp < incentive.endTime, \"TIMED_OUT\");\n        stakes[positionId][incentiveId] = Stake(uint160(pool.rangeSecondsInside(position.lower, position.upper)), true);\n        emit Subscribe(positionId, incentiveId);\n    }\n\n    function claimReward(\n        uint256 positionId,\n        uint256 incentiveId,\n        address recipient,\n        bool unwrapBento\n    ) public {\n        require(ownerOf[positionId] == msg.sender, \"OWNER\");\n        Position memory position = positions[positionId];\n        IConcentratedLiquidityPool pool = position.pool;\n        Incentive storage incentive = incentives[position.pool][positionId];\n        Stake storage stake = stakes[positionId][incentiveId];\n        require(stake.initialized, \"UNINITIALIZED\");\n        uint256 secondsPerLiquidityInside = pool.rangeSecondsInside(position.lower, position.upper) - stake.secondsInsideLast;\n        uint256 secondsInside = secondsPerLiquidityInside * position.liquidity;\n        uint256 maxTime = incentive.endTime < block.timestamp ? block.timestamp : incentive.endTime;\n        uint256 secondsUnclaimed = (maxTime - incentive.startTime) << (128 - incentive.secondsClaimed);\n        uint256 rewards = (incentive.rewardsUnclaimed * secondsInside) / secondsUnclaimed;\n        incentive.rewardsUnclaimed -= rewards;\n        incentive.secondsClaimed += uint160(secondsInside);\n        stake.secondsInsideLast += uint160(secondsPerLiquidityInside);\n        _transfer(incentive.token, address(this), recipient, rewards, unwrapBento);\n        emit ClaimReward(positionId, incentiveId, recipient);\n    }\n\n    function getReward(uint256 positionId, uint256 incentiveId) public view returns (uint256 rewards, uint256 secondsInside) {\n        Position memory position = positions[positionId];\n        IConcentratedLiquidityPool pool = position.pool;\n        Incentive memory incentive = incentives[pool][positionId];\n        Stake memory stake = stakes[positionId][incentiveId];\n        if (stake.initialized) {\n            secondsInside = (pool.rangeSecondsInside(position.lower, position.upper) - stake.secondsInsideLast) * position.liquidity;\n            uint256 maxTime = incentive.endTime < block.timestamp ? block.timestamp : incentive.endTime;\n            uint256 secondsUnclaimed = (maxTime - incentive.startTime) << (128 - incentive.secondsClaimed);\n            rewards = (incentive.rewardsUnclaimed * secondsInside) / secondsUnclaimed;\n        }\n    }\n}"
    },
    {
      "filename": "contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"../../interfaces/IConcentratedLiquidityPool.sol\";\nimport \"./ConcentratedLiquidityPosition.sol\";\n\n/// @notice Trident Concentrated Liquidity Pool periphery contract that combines non-fungible position management and staking.\ncontract ConcentratedLiquidityPoolManager is ConcentratedLiquidityPosition {\n    event AddIncentive(IConcentratedLiquidityPool indexed pool, Incentive indexed incentive);\n    event ReclaimIncentive(IConcentratedLiquidityPool indexed pool, uint256 indexed incentiveId);\n    event Subscribe(uint256 indexed positionId, uint256 indexed incentiveId);\n    event ClaimReward(uint256 indexed positionId, uint256 indexed incentiveId, address indexed recipient);\n\n    struct Incentive {\n        address owner;\n        address token;\n        uint256 rewardsUnclaimed;\n        uint160 secondsClaimed; // @dev x128.\n        uint32 startTime;\n        uint32 endTime;\n        uint32 expiry;\n    }\n\n    struct Stake {\n        uint160 secondsInsideLast; // @dev x128.\n        bool initialized;\n    }\n\n    mapping(IConcentratedLiquidityPool => uint256) public incentiveCount;\n    mapping(IConcentratedLiquidityPool => mapping(uint256 => Incentive)) public incentives;\n    mapping(uint256 => mapping(uint256 => Stake)) public stakes;\n\n    constructor(address wETH, address _masterDeployer) ConcentratedLiquidityPosition(wETH, _masterDeployer) {}\n\n    function addIncentive(IConcentratedLiquidityPool pool, Incentive memory incentive) public {\n        uint32 current = uint32(block.timestamp);\n        require(current <= incentive.startTime, \"ALREADY_STARTED\");\n        require(current <= incentive.endTime, \"ALREADY_ENDED\");\n        require(incentive.startTime < incentive.endTime, \"START_PAST_END\");\n        require(incentive.endTime + 5 weeks < incentive.expiry, \"END_PAST_BUFFER\");\n        require(incentive.rewardsUnclaimed != 0, \"NO_REWARDS\");\n        incentives[pool][incentiveCount[pool]++] = incentive;\n        _transfer(incentive.token, msg.sender, address(this), incentive.rewardsUnclaimed, false);\n        emit AddIncentive(pool, incentive);\n    }\n\n    /// @dev Withdraws any unclaimed incentive rewards.\n    function reclaimIncentive(\n        IConcentratedLiquidityPool pool,\n        uint256 incentiveId,\n        uint256 amount,\n        address receiver,\n        bool unwrapBento\n    ) public {\n        Incentive storage incentive = incentives[pool][incentiveId];\n        require(incentive.owner == msg.sender, \"NOT_OWNER\");\n        require(incentive.expiry < block.timestamp, \"EXPIRED\");\n        require(incentive.rewardsUnclaimed >= amount, \"ALREADY_CLAIMED\");\n        _transfer(incentive.token, address(this), receiver, amount, unwrapBento);\n        emit ReclaimIncentive(pool, incentiveId);\n    }\n\n    /// @dev Subscribes a non-fungible position token to an incentive.\n    function subscribe(uint256 positionId, uint256 incentiveId) public {\n        Position memory position = positions[positionId];\n        IConcentratedLiquidityPool pool = position.pool;\n        Incentive memory incentive = incentives[pool][positionId];\n        Stake storage stake = stakes[positionId][incentiveId];\n        require(position.liquidity != 0, \"INACTIVE\");\n        require(stake.secondsInsideLast == 0, \"SUBSCRIBED\");\n        require(incentiveId <= incentiveCount[pool], \"NOT_INCENTIVE\");\n        require(block.timestamp > incentive.startTime && block.timestamp < incentive.endTime, \"TIMED_OUT\");\n        stakes[positionId][incentiveId] = Stake(uint160(pool.rangeSecondsInside(position.lower, position.upper)), true);\n        emit Subscribe(positionId, incentiveId);\n    }\n\n    function claimReward(\n        uint256 positionId,\n        uint256 incentiveId,\n        address recipient,\n        bool unwrapBento\n    ) public {\n        require(ownerOf[positionId] == msg.sender, \"OWNER\");\n        Position memory position = positions[positionId];\n        IConcentratedLiquidityPool pool = position.pool;\n        Incentive storage incentive = incentives[position.pool][positionId];\n        Stake storage stake = stakes[positionId][incentiveId];\n        require(stake.initialized, \"UNINITIALIZED\");\n        uint256 secondsPerLiquidityInside = pool.rangeSecondsInside(position.lower, position.upper) - stake.secondsInsideLast;\n        uint256 secondsInside = secondsPerLiquidityInside * position.liquidity;\n        uint256 maxTime = incentive.endTime < block.timestamp ? block.timestamp : incentive.endTime;\n        uint256 secondsUnclaimed = (maxTime - incentive.startTime) << (128 - incentive.secondsClaimed);\n        uint256 rewards = (incentive.rewardsUnclaimed * secondsInside) / secondsUnclaimed;\n        incentive.rewardsUnclaimed -= rewards;\n        incentive.secondsClaimed += uint160(secondsInside);\n        stake.secondsInsideLast += uint160(secondsPerLiquidityInside);\n        _transfer(incentive.token, address(this), recipient, rewards, unwrapBento);\n        emit ClaimReward(positionId, incentiveId, recipient);\n    }\n\n    function getReward(uint256 positionId, uint256 incentiveId) public view returns (uint256 rewards, uint256 secondsInside) {\n        Position memory position = positions[positionId];\n        IConcentratedLiquidityPool pool = position.pool;\n        Incentive memory incentive = incentives[pool][positionId];\n        Stake memory stake = stakes[positionId][incentiveId];\n        if (stake.initialized) {\n            secondsInside = (pool.rangeSecondsInside(position.lower, position.upper) - stake.secondsInsideLast) * position.liquidity;\n            uint256 maxTime = incentive.endTime < block.timestamp ? block.timestamp : incentive.endTime;\n            uint256 secondsUnclaimed = (maxTime - incentive.startTime) << (128 - incentive.secondsClaimed);\n            rewards = (incentive.rewardsUnclaimed * secondsInside) / secondsUnclaimed;\n        }\n    }\n}"
    }
  ]
}