{
  "Title": "[L09] System relies on off-chain clients calling unrestricted functions to stay up-to-date",
  "Content": "The Augur system relies on off-chain clients to call unrestricted functions in order to update and sync system parameters. In particular, public functions whose purpose is to update state, like [`updateTotalTheoreticalSupply`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L153) and [`updateForkValues`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L79) may be dangerous if called at an unexpected time. If the contract relies on a certain state during various stages of execution, having these functions available to be called by anyone may result in an undesired state change that may render the system inconsistent or vulnerable to an attack. Consequences of this issue can be seen in **“[C08] Fork reputation goal threshold can be decreased during fork”** or **“[L08] Getter for REP total theoretical supply may be inaccurate”**.\n\n\nConsider removing any state variables used to store dynamically calculated values such as `totalTheoreticalSupply` in the [`updateTotalTheoreticalSupply`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L153) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L153) and `forkReputationGoal` and `disputeThresholdForFork` in the [`updateForkValues`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L79) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L79). Instead, access these values through getter functions that recalculate the values as needed. This will guarantee they are up to date and accurate and remove any dependencies on off-chain systems.\n\n\n***Update****:* *fixed in* [*`48744d6`*](https://github.com/AugurProject/augur/commit/48744d6948c017dff747cf58e9efba2b6681b43e) *by removing the* *`totalTheoreticalSupply`* *state variable from the* *`ReputationToken`* *contract and modifying the* *`getTotalTheoreticalSupply`* *to recalculate and return the updated value of the total theoretical supply of REP tokens every time it is called.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/augur-core/source/contracts/reporting/ReputationToken.sol",
      "content": "pragma solidity 0.5.4;\n\nimport 'ROOT/libraries/IERC820Registry.sol';\nimport 'ROOT/reporting/IV2ReputationToken.sol';\nimport 'ROOT/libraries/ITyped.sol';\nimport 'ROOT/libraries/token/VariableSupplyToken.sol';\nimport 'ROOT/libraries/token/ERC20Token.sol';\nimport 'ROOT/reporting/IUniverse.sol';\nimport 'ROOT/reporting/IMarket.sol';\nimport 'ROOT/reporting/Reporting.sol';\nimport 'ROOT/reporting/IDisputeWindow.sol';\nimport 'ROOT/reporting/IDisputeCrowdsourcer.sol';\nimport 'ROOT/libraries/math/SafeMathUint256.sol';\n\n\ncontract ReputationToken is ITyped, VariableSupplyToken, IV2ReputationToken {\n    using SafeMathUint256 for uint256;\n\n    string constant public name = \"Reputation\";\n    string constant public symbol = \"REP\";\n    IUniverse internal universe;\n    IUniverse internal parentUniverse;\n    uint256 internal totalMigrated;\n    uint256 internal totalTheoreticalSupply;\n    ERC20Token public legacyRepToken;\n    IAugur public augur;\n\n    constructor(IAugur _augur, IUniverse _universe, IUniverse _parentUniverse, address _erc820RegistryAddress) public {\n        require(_universe != IUniverse(0));\n        augur = _augur;\n        universe = _universe;\n        parentUniverse = _parentUniverse;\n        legacyRepToken = ERC20Token(augur.lookup(\"LegacyReputationToken\"));\n        updateTotalTheoreticalSupply();\n        erc820Registry = IERC820Registry(_erc820RegistryAddress);\n        initialize820InterfaceImplementations();\n    }\n\n    function migrateOutByPayout(uint256[] memory _payoutNumerators, uint256 _attotokens) public returns (bool) {\n        require(_attotokens > 0);\n        IUniverse _destinationUniverse = universe.createChildUniverse(_payoutNumerators);\n        IReputationToken _destination = _destinationUniverse.getReputationToken();\n        burn(msg.sender, _attotokens);\n        _destination.migrateIn(msg.sender, _attotokens);\n        return true;\n    }\n\n    function migrateOut(IReputationToken _destination, uint256 _attotokens) public returns (bool) {\n        require(_attotokens > 0);\n        assertReputationTokenIsLegitSibling(_destination);\n        burn(msg.sender, _attotokens);\n        _destination.migrateIn(msg.sender, _attotokens);\n        return true;\n    }\n\n    function migrateIn(address _reporter, uint256 _attotokens) public returns (bool) {\n        IUniverse _parentUniverse = universe.getParentUniverse();\n        require(ReputationToken(msg.sender) == _parentUniverse.getReputationToken());\n        require(augur.getTimestamp() < _parentUniverse.getForkEndTime());\n        mint(_reporter, _attotokens);\n        totalMigrated += _attotokens;\n        // Update the fork tenative winner and finalize if we can\n        if (!_parentUniverse.getForkingMarket().isFinalized()) {\n            _parentUniverse.updateTentativeWinningChildUniverse(universe.getParentPayoutDistributionHash());\n        }\n        return true;\n    }\n\n    function mintForReportingParticipant(uint256 _amountMigrated) public returns (bool) {\n        IUniverse _parentUniverse = universe.getParentUniverse();\n        IReportingParticipant _reportingParticipant = IReportingParticipant(msg.sender);\n        require(_parentUniverse.isContainerForReportingParticipant(_reportingParticipant));\n        uint256 _bonus = _amountMigrated.mul(2) / 5;\n        mint(address(_reportingParticipant), _bonus);\n        return true;\n    }\n\n    function mintForAuction(uint256 _amountToMint) public returns (bool) {\n        require(universe.getAuction() == IAuction(msg.sender));\n        mint(msg.sender, _amountToMint);\n        return true;\n    }\n\n    function burnForAuction(uint256 _amountToBurn) public returns (bool) {\n        require(universe.getAuction() == IAuction(msg.sender));\n        burn(msg.sender, _amountToBurn);\n        return true;\n    }\n\n    function burnForMarket(uint256 _amountToBurn) public returns (bool) {\n        require(universe.isContainerForMarket(IMarket(msg.sender)));\n        burn(msg.sender, _amountToBurn);\n        return true;\n    }\n\n    function transfer(address _to, uint _value) public returns (bool) {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function trustedUniverseTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(IUniverse(msg.sender) == universe);\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function trustedMarketTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(universe.isContainerForMarket(IMarket(msg.sender)));\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function trustedReportingParticipantTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(universe.isContainerForReportingParticipant(IReportingParticipant(msg.sender)));\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function trustedAuctionTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(universe.getAuction() == (IAuction(msg.sender)));\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function trustedDisputeWindowTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(universe.isContainerForDisputeWindow(IDisputeWindow(msg.sender)));\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function assertReputationTokenIsLegitSibling(IReputationToken _shadyReputationToken) private view returns (bool) {\n        IUniverse _shadyUniverse = _shadyReputationToken.getUniverse();\n        require(universe.isParentOf(_shadyUniverse));\n        IUniverse _legitUniverse = _shadyUniverse;\n        require(_legitUniverse.getReputationToken() == _shadyReputationToken);\n        return true;\n    }\n\n    function getTypeName() public view returns (bytes32) {\n        return \"ReputationToken\";\n    }\n\n    function getUniverse() public view returns (IUniverse) {\n        return universe;\n    }\n\n    function getTotalMigrated() public view returns (uint256) {\n        return totalMigrated;\n    }\n\n    function getLegacyRepToken() public view returns (ERC20Token) {\n        return legacyRepToken;\n    }\n\n    function updateTotalTheoreticalSupply() public returns (bool) {\n        if (parentUniverse == IUniverse(0)) {\n            totalTheoreticalSupply = Reporting.getInitialREPSupply();\n        } else if (augur.getTimestamp() >= parentUniverse.getForkEndTime()) {\n            totalTheoreticalSupply = totalSupply();\n        } else {\n            totalTheoreticalSupply = totalSupply() + parentUniverse.getReputationToken().totalSupply();\n        }\n        return true;\n    }\n\n    function getTotalTheoreticalSupply() public view returns (uint256) {\n        return totalTheoreticalSupply;\n    }\n\n    function onTokenTransfer(address _from, address _to, uint256 _value) internal returns (bool) {\n        augur.logReputationTokensTransferred(universe, _from, _to, _value, balances[_from], balances[_to]);\n        return true;\n    }\n\n    function onMint(address _target, uint256 _amount) internal returns (bool) {\n        augur.logReputationTokensMinted(universe, _target, _amount, totalSupply());\n        return true;\n    }\n\n    function onBurn(address _target, uint256 _amount) internal returns (bool) {\n        augur.logReputationTokensBurned(universe, _target, _amount, totalSupply());\n        return true;\n    }\n\n    function migrateFromLegacyReputationToken() public returns (bool) {\n        uint256 _legacyBalance = legacyRepToken.balanceOf(msg.sender);\n        require(legacyRepToken.transferFrom(msg.sender, address(0), _legacyBalance));\n        mint(msg.sender, _legacyBalance);\n        return true;\n    }\n}"
    },
    {
      "filename": "packages/augur-core/source/contracts/reporting/ReputationToken.sol",
      "content": "pragma solidity 0.5.4;\n\nimport 'ROOT/libraries/IERC820Registry.sol';\nimport 'ROOT/reporting/IV2ReputationToken.sol';\nimport 'ROOT/libraries/ITyped.sol';\nimport 'ROOT/libraries/token/VariableSupplyToken.sol';\nimport 'ROOT/libraries/token/ERC20Token.sol';\nimport 'ROOT/reporting/IUniverse.sol';\nimport 'ROOT/reporting/IMarket.sol';\nimport 'ROOT/reporting/Reporting.sol';\nimport 'ROOT/reporting/IDisputeWindow.sol';\nimport 'ROOT/reporting/IDisputeCrowdsourcer.sol';\nimport 'ROOT/libraries/math/SafeMathUint256.sol';\n\n\ncontract ReputationToken is ITyped, VariableSupplyToken, IV2ReputationToken {\n    using SafeMathUint256 for uint256;\n\n    string constant public name = \"Reputation\";\n    string constant public symbol = \"REP\";\n    IUniverse internal universe;\n    IUniverse internal parentUniverse;\n    uint256 internal totalMigrated;\n    uint256 internal totalTheoreticalSupply;\n    ERC20Token public legacyRepToken;\n    IAugur public augur;\n\n    constructor(IAugur _augur, IUniverse _universe, IUniverse _parentUniverse, address _erc820RegistryAddress) public {\n        require(_universe != IUniverse(0));\n        augur = _augur;\n        universe = _universe;\n        parentUniverse = _parentUniverse;\n        legacyRepToken = ERC20Token(augur.lookup(\"LegacyReputationToken\"));\n        updateTotalTheoreticalSupply();\n        erc820Registry = IERC820Registry(_erc820RegistryAddress);\n        initialize820InterfaceImplementations();\n    }\n\n    function migrateOutByPayout(uint256[] memory _payoutNumerators, uint256 _attotokens) public returns (bool) {\n        require(_attotokens > 0);\n        IUniverse _destinationUniverse = universe.createChildUniverse(_payoutNumerators);\n        IReputationToken _destination = _destinationUniverse.getReputationToken();\n        burn(msg.sender, _attotokens);\n        _destination.migrateIn(msg.sender, _attotokens);\n        return true;\n    }\n\n    function migrateOut(IReputationToken _destination, uint256 _attotokens) public returns (bool) {\n        require(_attotokens > 0);\n        assertReputationTokenIsLegitSibling(_destination);\n        burn(msg.sender, _attotokens);\n        _destination.migrateIn(msg.sender, _attotokens);\n        return true;\n    }\n\n    function migrateIn(address _reporter, uint256 _attotokens) public returns (bool) {\n        IUniverse _parentUniverse = universe.getParentUniverse();\n        require(ReputationToken(msg.sender) == _parentUniverse.getReputationToken());\n        require(augur.getTimestamp() < _parentUniverse.getForkEndTime());\n        mint(_reporter, _attotokens);\n        totalMigrated += _attotokens;\n        // Update the fork tenative winner and finalize if we can\n        if (!_parentUniverse.getForkingMarket().isFinalized()) {\n            _parentUniverse.updateTentativeWinningChildUniverse(universe.getParentPayoutDistributionHash());\n        }\n        return true;\n    }\n\n    function mintForReportingParticipant(uint256 _amountMigrated) public returns (bool) {\n        IUniverse _parentUniverse = universe.getParentUniverse();\n        IReportingParticipant _reportingParticipant = IReportingParticipant(msg.sender);\n        require(_parentUniverse.isContainerForReportingParticipant(_reportingParticipant));\n        uint256 _bonus = _amountMigrated.mul(2) / 5;\n        mint(address(_reportingParticipant), _bonus);\n        return true;\n    }\n\n    function mintForAuction(uint256 _amountToMint) public returns (bool) {\n        require(universe.getAuction() == IAuction(msg.sender));\n        mint(msg.sender, _amountToMint);\n        return true;\n    }\n\n    function burnForAuction(uint256 _amountToBurn) public returns (bool) {\n        require(universe.getAuction() == IAuction(msg.sender));\n        burn(msg.sender, _amountToBurn);\n        return true;\n    }\n\n    function burnForMarket(uint256 _amountToBurn) public returns (bool) {\n        require(universe.isContainerForMarket(IMarket(msg.sender)));\n        burn(msg.sender, _amountToBurn);\n        return true;\n    }\n\n    function transfer(address _to, uint _value) public returns (bool) {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function trustedUniverseTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(IUniverse(msg.sender) == universe);\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function trustedMarketTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(universe.isContainerForMarket(IMarket(msg.sender)));\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function trustedReportingParticipantTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(universe.isContainerForReportingParticipant(IReportingParticipant(msg.sender)));\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function trustedAuctionTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(universe.getAuction() == (IAuction(msg.sender)));\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function trustedDisputeWindowTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(universe.isContainerForDisputeWindow(IDisputeWindow(msg.sender)));\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function assertReputationTokenIsLegitSibling(IReputationToken _shadyReputationToken) private view returns (bool) {\n        IUniverse _shadyUniverse = _shadyReputationToken.getUniverse();\n        require(universe.isParentOf(_shadyUniverse));\n        IUniverse _legitUniverse = _shadyUniverse;\n        require(_legitUniverse.getReputationToken() == _shadyReputationToken);\n        return true;\n    }\n\n    function getTypeName() public view returns (bytes32) {\n        return \"ReputationToken\";\n    }\n\n    function getUniverse() public view returns (IUniverse) {\n        return universe;\n    }\n\n    function getTotalMigrated() public view returns (uint256) {\n        return totalMigrated;\n    }\n\n    function getLegacyRepToken() public view returns (ERC20Token) {\n        return legacyRepToken;\n    }\n\n    function updateTotalTheoreticalSupply() public returns (bool) {\n        if (parentUniverse == IUniverse(0)) {\n            totalTheoreticalSupply = Reporting.getInitialREPSupply();\n        } else if (augur.getTimestamp() >= parentUniverse.getForkEndTime()) {\n            totalTheoreticalSupply = totalSupply();\n        } else {\n            totalTheoreticalSupply = totalSupply() + parentUniverse.getReputationToken().totalSupply();\n        }\n        return true;\n    }\n\n    function getTotalTheoreticalSupply() public view returns (uint256) {\n        return totalTheoreticalSupply;\n    }\n\n    function onTokenTransfer(address _from, address _to, uint256 _value) internal returns (bool) {\n        augur.logReputationTokensTransferred(universe, _from, _to, _value, balances[_from], balances[_to]);\n        return true;\n    }\n\n    function onMint(address _target, uint256 _amount) internal returns (bool) {\n        augur.logReputationTokensMinted(universe, _target, _amount, totalSupply());\n        return true;\n    }\n\n    function onBurn(address _target, uint256 _amount) internal returns (bool) {\n        augur.logReputationTokensBurned(universe, _target, _amount, totalSupply());\n        return true;\n    }\n\n    function migrateFromLegacyReputationToken() public returns (bool) {\n        uint256 _legacyBalance = legacyRepToken.balanceOf(msg.sender);\n        require(legacyRepToken.transferFrom(msg.sender, address(0), _legacyBalance));\n        mint(msg.sender, _legacyBalance);\n        return true;\n    }\n}"
    }
  ]
}