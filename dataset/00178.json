{
  "Title": "M-8: Malicious users can block creators from acknowledging or deacknowledging an edge",
  "Content": "# Issue M-8: Malicious users can block creators from acknowledging or deacknowledging an edge \n\nSource: https://github.com/sherlock-audit/2024-04-titles-judging/issues/273 \n\n## Found by \n0x73696d616f, 1337, Bigsam, ComposableSecurity, Krace, KupiaSec, Yu3H0, alexzoid, cryptic, fibonacci, fugazzi, jecikpo, jennifer37, juan, kennedy1030, mt030d, xiaoming90, zoyi\n## Summary\n\nMalicious users can block someone from acknowledging or deacknowledging an edge, affecting the sanctity of the data in the Graph.\n\n## Vulnerability Detail\n\n> [!IMPORTANT]\n>\n> The following is an extract from the [contest's README](https://audits.sherlock.xyz/contests/326):\n>\n> > Additional audit information.\n> >\n> > In addition to the security of funds, we would also like there to be focus on the sanctity of the data in the TitlesGraph and the permissioning around it (only the appropriate people/contracts can signal reference and acknowledgement of reference).\n>\n> The contest's README stated that apart from the loss of assets, the protocol team would like there to be a focus on the sanctity of the data. Thus, any issues related to the sanctity of the data in the Graph would be considered a valid Medium issue in the context of this audit contest, as the Contest's README supersede Sherlock's judging rules per Sherlock's Hierarchy of truth.\n\nBoth `acknowledgeEdge` and `unacknowledgeEdge` functions rely on the same modifier (`checkSignature`) to verify the signature validity. Thus, the signature used for acknowledgment and deacknowledgment of an edge follows the same format and can be used interchangeably. However, this design creates an issue, as described next.\n\n1. Assume that Bob wants to acknowledge an edge. Thus, Bob calls the `acknowledgeEdge` function with his signature $Sig_1$.\n\n2. A malicious user can always front-run Bob, take his signature ($Sig_1$) and sent to the `unacknowledgeEdge` function instead. When the `unacknowledgeEdge` function is executed with $Sig_1$, the signature will be marked as used by the code `_isUsed[keccak256(signature)] = true;`.\n\n3. When Bob's `acknowledgeEdge` transaction gets executed, it will revert because his signature ($Sig_1$) has already been used.\n\nThe malicious users can keep repeating as the chain's gas fees on L2 are cheap.\n\nThe same trick can also be used to block someone from deacknowledge an edge.\n\nhttps://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/src/graph/TitlesGraph.sol#L118\n\n```solidity\nFile: TitlesGraph.sol\n118:     function acknowledgeEdge(bytes32 edgeId_, bytes calldata data_, bytes calldata signature_)\n119:         external\n120:         checkSignature(edgeId_, data_, signature_)\n121:         returns (Edge memory edge)\n122:     {\n123:         return _setAcknowledged(edgeId_, data_, true);\n124:     }\n```\n\nhttps://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/src/graph/TitlesGraph.sol#L146\n\n```solidity\nFile: TitlesGraph.sol\n146:     function unacknowledgeEdge(bytes32 edgeId_, bytes calldata data_, bytes calldata signature_)\n147:         external\n148:         checkSignature(edgeId_, data_, signature_)\n149:         returns (Edge memory edge)\n150:     {\n151:         return _setAcknowledged(edgeId_, data_, false);\n152:     }\n```\n\nhttps://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/src/graph/TitlesGraph.sol#L40\n\n```solidity\nFile: TitlesGraph.sol\n39:     /// @notice Modified to check the signature for a proxied acknowledgment.\n40:     modifier checkSignature(bytes32 edgeId, bytes calldata data, bytes calldata signature) {\n41:         bytes32 digest = _hashTypedData(keccak256(abi.encode(ACK_TYPEHASH, edgeId, data)));\n42:         if (\n43:             !edges[edgeId].to.creator.target.isValidSignatureNowCalldata(digest, signature)\n44:                 || _isUsed[keccak256(signature)]\n45:         ) {\n46:             revert Unauthorized();\n47:         }\n48:         _;\n49:         _isUsed[keccak256(signature)] = true;\n50:     }\n```\n\n## Impact\n\nMalicious users can block someone from acknowledging or deacknowledging an edge, affecting the sanctity of the data in the Graph.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/src/graph/TitlesGraph.sol#L118\n\nhttps://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/src/graph/TitlesGraph.sol#L146\n\nhttps://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/src/graph/TitlesGraph.sol#L40\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n```solidity\nbytes32 public constant ACK_TYPEHASH = keccak256(\"Ack(bytes32 edgeId,bytes data)\");\nbytes32 public constant DEACK_TYPEHASH = keccak256(\"Deack(bytes32 edgeId,bytes data)\");\n\nbytes32 digest = _hashTypedData(keccak256(abi.encode(ACK_TYPEHASH, edgeId, data)));\nbytes32 digest = _hashTypedData(keccak256(abi.encode(DEACK_TYPEHASH, edgeId, data)));\n```\n\nConsider using two different hash types for acknowledging or deacknowledging within the signature and use a different modifier for checking the signature. This will prevent malicious users from taking the signature intended for `acknowledgeEdge` and submitting it to `unacknowledgeEdge`, and vice versa.\n\n```solidity\nmodifier checkSignatureForAck(bytes32 edgeId, bytes calldata data, bytes calldata signature) {\n    bytes32 digest = _hashTypedData(keccak256(abi.encode(ACK_TYPEHASH, edgeId, data)));\n    ..SNIP..\n}\n\nmodifier checkSignatureForDeack(bytes32 edgeId, bytes calldata data, bytes calldata signature) {\n    bytes32 digest = _hashTypedData(keccak256(abi.encode(DEACK_TYPEHASH, edgeId, data)));\n    ..SNIP..\n}\n```\n\n```diff\nfunction acknowledgeEdge(bytes32 edgeId_, bytes calldata data_, bytes calldata signature_)\n    external\n-   checkSignature(edgeId_, data_, signature_)\n+   checkSignatureForAck(edgeId_, data_, signature_)\n    returns (Edge memory edge)\n{\n\nfunction unacknowledgeEdge(bytes32 edgeId_, bytes calldata data_, bytes calldata signature_)\n    external\n-   checkSignature(edgeId_, data_, signature_)\n+\t\tcheckSignatureForDeack(edgeId_, data_, signature_)\n    returns (Edge memory edge)\n{\n```\n\nWith this design, if a creator creates a signature intended for `acknowledgeEdge` function, and a malicious user front-runs and copies the signature and submits it to `acknowledgeEdge` function, no harm is done as the malicious user is simply executing the task on behalf of the creator. The edge will still be acknowledged at the end.\n\n\n\n## Discussion\n\n**pqseags**\n\nWill investigate\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/326",
  "Code": [
    {
      "filename": "wallflower-contract-v2/src/graph/TitlesGraph.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {OwnableRoles} from \"lib/solady/src/auth/OwnableRoles.sol\";\nimport {EnumerableSet} from \"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\";\nimport {EIP712} from \"lib/solady/src/utils/EIP712.sol\";\nimport {SignatureCheckerLib} from \"lib/solady/src/utils/SignatureCheckerLib.sol\";\nimport {UUPSUpgradeable} from \"lib/solady/src/utils/UUPSUpgradeable.sol\";\n\nimport {IOpenGraph} from \"src/interfaces/IOpenGraph.sol\";\nimport {IEdgeManager} from \"src/interfaces/IEdgeManager.sol\";\nimport {ADMIN_ROLE, Edge, Node, Unauthorized} from \"src/shared/Common.sol\";\n\n/// @title TitlesGraph\n/// @notice Titles.xyz implementation of the OpenGraph standard\n/// @dev The TitlesGraph contract implements the OpenGraph standard and is responsible for managing the creation and acknowledgment of {Node}s and {Edge}s in the graph.\ncontract TitlesGraph is IOpenGraph, IEdgeManager, OwnableRoles, EIP712, UUPSUpgradeable {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using SignatureCheckerLib for address;\n\n    error Exists();\n    error NotFound();\n\n    /// @notice The set of edge IDs in the graph. Enumerable to enable on-chain graph traversal in the future.\n    EnumerableSet.Bytes32Set private _edgeIds;\n\n    /// @notice Edges are relationships between two nodes in the graph.\n    mapping(bytes32 id => Edge edge) public edges;\n\n    /// @notice An internal mapping to prevent signature reuse.\n    mapping(bytes32 signature => bool used) private _isUsed;\n\n    // @notice The hash of the acknowledgement struct. Used for EIP-712.\n    bytes32 public constant ACK_TYPEHASH = keccak256(\"Ack(bytes32 edgeId,bytes data)\");\n\n    // @notice The EIP-712 domain type hash. (Exposed here for convenience.)\n    bytes32 public constant DOMAIN_TYPEHASH = _DOMAIN_TYPEHASH;\n\n    /// @notice Modified to check the signature for a proxied acknowledgment.\n    modifier checkSignature(bytes32 edgeId, bytes calldata data, bytes calldata signature) {\n        bytes32 digest = _hashTypedData(keccak256(abi.encode(ACK_TYPEHASH, edgeId, data)));\n        if (\n            !edges[edgeId].to.creator.target.isValidSignatureNowCalldata(digest, signature)\n                || _isUsed[keccak256(signature)]\n        ) {\n            revert Unauthorized();\n        }\n        _;\n        _isUsed[keccak256(signature)] = true;\n    }\n\n    constructor(address owner_, address admin_) {\n        _initializeOwner(owner_);\n        _grantRoles(admin_, ADMIN_ROLE);\n    }\n\n    /// @inheritdoc IOpenGraph\n    /// @notice Create a new {Edge} between two {Node}s in the graph.\n    /// @param from_ The {Node} from which the edge originates.\n    /// @param to_ The {Node} to which the edge points.\n    /// @param data_ Metadata associated with the edge.\n    /// @return edge The created edge.\n    /// @dev This function is used to create a new edge between two nodes in the graph and will revert if not unique or if called by any address other than the contract referenced as the `from` node. A {NodeTouched} event is emitted for each node and an {EdgeCreated} event is emitted for the edge itself.\n    function createEdge(Node calldata from_, Node calldata to_, bytes calldata data_)\n        external\n        override\n        returns (Edge memory edge)\n    {\n        if (!_isEntity(from_, msg.sender)) revert Unauthorized();\n        return _createEdge(from_, to_, data_);\n    }\n\n    /// @notice Create multiple edges within the graph.\n    /// @param edges_ The edges to create.\n    /// @dev This function is used to create multiple edges within the graph and will revert if any of the edges are not unique. It emits a {NodeTouched} event for each node and an {EdgeCreated} event for each edge.\n    function createEdges(Edge[] calldata edges_) external onlyRolesOrOwner(ADMIN_ROLE) {\n        for (uint256 i = 0; i < edges_.length; i++) {\n            _createEdge(edges_[i].from, edges_[i].to, edges_[i].data);\n        }\n    }\n\n    function _createEdge(Node memory from_, Node memory to_, bytes memory data_)\n        internal\n        returns (Edge memory edge)\n    {\n        bytes32 edgeId = keccak256(abi.encode(from_, to_));\n        if (!_edgeIds.add(edgeId)) revert Exists();\n\n        edge = Edge({from: from_, to: to_, acknowledged: false, data: data_});\n        edges[edgeId] = edge;\n\n        emit NodeTouched(from_, data_);\n        emit NodeTouched(to_, data_);\n        emit EdgeCreated(edge, data_);\n    }\n\n    /// @inheritdoc IEdgeManager\n    /// @notice Acknowledge an edge.\n    /// @param edgeId_ The ID of the edge to acknowledge.\n    /// @param data_ Additional data to include with the acknowledgment.\n    /// @return edge The acknowledged edge.\n    /// @dev This function is used to acknowledge an edge that was previously created and will revert if the edge does not exist. It emits an {EdgeAcknowledged} event for the edge.\n    function acknowledgeEdge(bytes32 edgeId_, bytes calldata data_)\n        external\n        override\n        returns (Edge memory edge)\n    {\n        if (!_isCreatorOrEntity(edges[edgeId_].to, msg.sender)) revert Unauthorized();\n        return _setAcknowledged(edgeId_, data_, true);\n    }\n\n    /// @notice Acknowledge an edge using an ECDSA signature.\n    /// @param edgeId_ The ID of the edge to acknowledge.\n    /// @param data_ Additional data to include with the acknowledgment.\n    /// @param signature_ The ECDSA signature to verify.\n    /// @dev The request is valid if the given signature was produced using the edge ID as the message and the creator of the `to` node as the signer.\n    /// @dev This function is used to acknowledge an edge that was previously created and will revert if the edge does not exist or if the signature is invalid. It emits an {EdgeAcknowledged} event for the edge.\n    function acknowledgeEdge(bytes32 edgeId_, bytes calldata data_, bytes calldata signature_)\n        external\n        checkSignature(edgeId_, data_, signature_)\n        returns (Edge memory edge)\n    {\n        return _setAcknowledged(edgeId_, data_, true);\n    }\n\n    /// @inheritdoc IEdgeManager\n    /// @notice Unacknowledge an edge.\n    /// @param edgeId_ The ID of the edge to unacknowledge.\n    /// @param data_ Additional data to include with the unacknowledgment.\n    /// @dev This function is used to unacknowledge an edge that was previously acknowledged.\n    function unacknowledgeEdge(bytes32 edgeId_, bytes calldata data_)\n        external\n        override\n        returns (Edge memory edge)\n    {\n        if (!_isCreatorOrEntity(edges[edgeId_].to, msg.sender)) revert Unauthorized();\n        return _setAcknowledged(edgeId_, data_, false);\n    }\n\n    /// @notice Unacknowledge an edge using an ECDSA signature.\n    /// @param edgeId_ The ID of the edge to unacknowledge.\n    /// @param data_ Additional data to include with the unacknowledgment.\n    /// @param signature_ The ECDSA signature to verify.\n    /// @dev The request is valid if the given signature was produced using the edge ID as the message and the creator of the `to` node as the signer.\n    /// @dev This function is used to unacknowledge an edge that was previously acknowledged and will revert if the edge does not exist or if the signature is invalid. It emits an {EdgeUnacknowledged} event for the edge.\n    function unacknowledgeEdge(bytes32 edgeId_, bytes calldata data_, bytes calldata signature_)\n        external\n        checkSignature(edgeId_, data_, signature_)\n        returns (Edge memory edge)\n    {\n        return _setAcknowledged(edgeId_, data_, false);\n    }\n\n    /// @notice Override the {OwnableRoles} implementation to extend access to the `ADMIN_ROLE`.\n    /// @param guy The address to grant the roles.\n    /// @param roles The roles to grant.\n    /// @dev This function is used to grant roles to an address and will revert if the caller is not the owner and does not have the `ADMIN_ROLE`.\n    function grantRoles(address guy, uint256 roles)\n        public\n        payable\n        override\n        onlyOwnerOrRoles(ADMIN_ROLE)\n    {\n        _grantRoles(guy, roles);\n    }\n\n    /// @notice Override the {OwnableRoles} implementation to extend access to the `ADMIN_ROLE`.\n    /// @param guy The address from which to revoke the roles.\n    /// @param roles The roles to revoke.\n    /// @dev This function is used to revoke roles from an address and will revert if the caller is not the owner and does not have the `ADMIN_ROLE`.\n    function revokeRoles(address guy, uint256 roles)\n        public\n        payable\n        override\n        onlyOwnerOrRoles(ADMIN_ROLE)\n    {\n        _removeRoles(guy, roles);\n    }\n\n    /// @notice Get the ID of an edge given the source and target nodes.\n    /// @param from_ The source node of the edge.\n    /// @param to_ The target node of the edge.\n    /// @return edgeId The ID of the edge (i.e. the keccak256 hash of the `from` and `to` nodes).\n    function getEdgeId(Node memory from_, Node memory to_) public pure returns (bytes32) {\n        return keccak256(abi.encode(from_, to_));\n    }\n\n    /// @notice Get the ID of an edge.\n    /// @param edge_ The edge for which to get the ID.\n    /// @return edgeId The ID of the edge (i.e. the keccak256 hash of the `from` and `to` nodes).\n    function getEdgeId(Edge memory edge_) public pure returns (bytes32) {\n        return getEdgeId(edge_.from, edge_.to);\n    }\n\n    /// @notice Set the acknowledged status of an edge.\n    /// @param edgeId_ The ID of the edge to set the acknowledged status for.\n    /// @param data_ Additional data to include with the acknowledgment.\n    /// @param acknowledged_ The new acknowledged status of the edge.\n    /// @return edge The edge with the updated acknowledged status.\n    function _setAcknowledged(bytes32 edgeId_, bytes calldata data_, bool acknowledged_)\n        internal\n        returns (Edge memory edge)\n    {\n        if (!_edgeIds.contains(edgeId_)) revert NotFound();\n        edge = edges[edgeId_];\n        edge.acknowledged = acknowledged_;\n\n        if (acknowledged_) {\n            emit EdgeAcknowledged(edge, msg.sender, data_);\n        } else {\n            emit EdgeUnacknowledged(edge, msg.sender, data_);\n        }\n    }\n\n    /// @notice Allows the admin to upgrade the contract.\n    /// @dev This function overrides the {UUPSUpgradeable} implementation to restrict upgrade rights to the graph owner.\n    function _authorizeUpgrade(address) internal view override onlyOwnerOrRoles(ADMIN_ROLE) {\n        // The modifier handles the authorization.\n    }\n\n    /// @notice Returns the domain name and version for EIP-712.\n    function _domainNameAndVersion()\n        internal\n        pure\n        override\n        returns (string memory name, string memory version)\n    {\n        name = \"TitlesGraph\";\n        version = \"1\";\n    }\n\n    /// @notice Checks if the given address is the creator of a node.\n    /// @param node The node to check.\n    /// @param guy The address to check.\n    /// @return True if the address is the creator of the node, false otherwise.\n    function _isCreator(Node memory node, address guy) internal pure returns (bool) {\n        return node.creator.target == guy;\n    }\n\n    /// @notice Checks if the given address is the on-chain entity represented by a node.\n    /// @param node The node to check.\n    /// @param guy The address to check.\n    /// @return True if the address is the entity of the node, false otherwise.\n    function _isEntity(Node memory node, address guy) internal pure returns (bool) {\n        return node.entity.target == guy;\n    }\n\n    /// @notice Checks if the given address is either the creator or on-chain entity represented by a node.\n    /// @param node The node to check.\n    /// @param guy The address to check.\n    /// @return True if the address is the creator or entity of the node, false otherwise.\n    function _isCreatorOrEntity(Node memory node, address guy) internal pure returns (bool) {\n        return _isCreator(node, guy) || _isEntity(node, guy);\n    }\n}"
    },
    {
      "filename": "wallflower-contract-v2/src/graph/TitlesGraph.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {OwnableRoles} from \"lib/solady/src/auth/OwnableRoles.sol\";\nimport {EnumerableSet} from \"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\";\nimport {EIP712} from \"lib/solady/src/utils/EIP712.sol\";\nimport {SignatureCheckerLib} from \"lib/solady/src/utils/SignatureCheckerLib.sol\";\nimport {UUPSUpgradeable} from \"lib/solady/src/utils/UUPSUpgradeable.sol\";\n\nimport {IOpenGraph} from \"src/interfaces/IOpenGraph.sol\";\nimport {IEdgeManager} from \"src/interfaces/IEdgeManager.sol\";\nimport {ADMIN_ROLE, Edge, Node, Unauthorized} from \"src/shared/Common.sol\";\n\n/// @title TitlesGraph\n/// @notice Titles.xyz implementation of the OpenGraph standard\n/// @dev The TitlesGraph contract implements the OpenGraph standard and is responsible for managing the creation and acknowledgment of {Node}s and {Edge}s in the graph.\ncontract TitlesGraph is IOpenGraph, IEdgeManager, OwnableRoles, EIP712, UUPSUpgradeable {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using SignatureCheckerLib for address;\n\n    error Exists();\n    error NotFound();\n\n    /// @notice The set of edge IDs in the graph. Enumerable to enable on-chain graph traversal in the future.\n    EnumerableSet.Bytes32Set private _edgeIds;\n\n    /// @notice Edges are relationships between two nodes in the graph.\n    mapping(bytes32 id => Edge edge) public edges;\n\n    /// @notice An internal mapping to prevent signature reuse.\n    mapping(bytes32 signature => bool used) private _isUsed;\n\n    // @notice The hash of the acknowledgement struct. Used for EIP-712.\n    bytes32 public constant ACK_TYPEHASH = keccak256(\"Ack(bytes32 edgeId,bytes data)\");\n\n    // @notice The EIP-712 domain type hash. (Exposed here for convenience.)\n    bytes32 public constant DOMAIN_TYPEHASH = _DOMAIN_TYPEHASH;\n\n    /// @notice Modified to check the signature for a proxied acknowledgment.\n    modifier checkSignature(bytes32 edgeId, bytes calldata data, bytes calldata signature) {\n        bytes32 digest = _hashTypedData(keccak256(abi.encode(ACK_TYPEHASH, edgeId, data)));\n        if (\n            !edges[edgeId].to.creator.target.isValidSignatureNowCalldata(digest, signature)\n                || _isUsed[keccak256(signature)]\n        ) {\n            revert Unauthorized();\n        }\n        _;\n        _isUsed[keccak256(signature)] = true;\n    }\n\n    constructor(address owner_, address admin_) {\n        _initializeOwner(owner_);\n        _grantRoles(admin_, ADMIN_ROLE);\n    }\n\n    /// @inheritdoc IOpenGraph\n    /// @notice Create a new {Edge} between two {Node}s in the graph.\n    /// @param from_ The {Node} from which the edge originates.\n    /// @param to_ The {Node} to which the edge points.\n    /// @param data_ Metadata associated with the edge.\n    /// @return edge The created edge.\n    /// @dev This function is used to create a new edge between two nodes in the graph and will revert if not unique or if called by any address other than the contract referenced as the `from` node. A {NodeTouched} event is emitted for each node and an {EdgeCreated} event is emitted for the edge itself.\n    function createEdge(Node calldata from_, Node calldata to_, bytes calldata data_)\n        external\n        override\n        returns (Edge memory edge)\n    {\n        if (!_isEntity(from_, msg.sender)) revert Unauthorized();\n        return _createEdge(from_, to_, data_);\n    }\n\n    /// @notice Create multiple edges within the graph.\n    /// @param edges_ The edges to create.\n    /// @dev This function is used to create multiple edges within the graph and will revert if any of the edges are not unique. It emits a {NodeTouched} event for each node and an {EdgeCreated} event for each edge.\n    function createEdges(Edge[] calldata edges_) external onlyRolesOrOwner(ADMIN_ROLE) {\n        for (uint256 i = 0; i < edges_.length; i++) {\n            _createEdge(edges_[i].from, edges_[i].to, edges_[i].data);\n        }\n    }\n\n    function _createEdge(Node memory from_, Node memory to_, bytes memory data_)\n        internal\n        returns (Edge memory edge)\n    {\n        bytes32 edgeId = keccak256(abi.encode(from_, to_));\n        if (!_edgeIds.add(edgeId)) revert Exists();\n\n        edge = Edge({from: from_, to: to_, acknowledged: false, data: data_});\n        edges[edgeId] = edge;\n\n        emit NodeTouched(from_, data_);\n        emit NodeTouched(to_, data_);\n        emit EdgeCreated(edge, data_);\n    }\n\n    /// @inheritdoc IEdgeManager\n    /// @notice Acknowledge an edge.\n    /// @param edgeId_ The ID of the edge to acknowledge.\n    /// @param data_ Additional data to include with the acknowledgment.\n    /// @return edge The acknowledged edge.\n    /// @dev This function is used to acknowledge an edge that was previously created and will revert if the edge does not exist. It emits an {EdgeAcknowledged} event for the edge.\n    function acknowledgeEdge(bytes32 edgeId_, bytes calldata data_)\n        external\n        override\n        returns (Edge memory edge)\n    {\n        if (!_isCreatorOrEntity(edges[edgeId_].to, msg.sender)) revert Unauthorized();\n        return _setAcknowledged(edgeId_, data_, true);\n    }\n\n    /// @notice Acknowledge an edge using an ECDSA signature.\n    /// @param edgeId_ The ID of the edge to acknowledge.\n    /// @param data_ Additional data to include with the acknowledgment.\n    /// @param signature_ The ECDSA signature to verify.\n    /// @dev The request is valid if the given signature was produced using the edge ID as the message and the creator of the `to` node as the signer.\n    /// @dev This function is used to acknowledge an edge that was previously created and will revert if the edge does not exist or if the signature is invalid. It emits an {EdgeAcknowledged} event for the edge.\n    function acknowledgeEdge(bytes32 edgeId_, bytes calldata data_, bytes calldata signature_)\n        external\n        checkSignature(edgeId_, data_, signature_)\n        returns (Edge memory edge)\n    {\n        return _setAcknowledged(edgeId_, data_, true);\n    }\n\n    /// @inheritdoc IEdgeManager\n    /// @notice Unacknowledge an edge.\n    /// @param edgeId_ The ID of the edge to unacknowledge.\n    /// @param data_ Additional data to include with the unacknowledgment.\n    /// @dev This function is used to unacknowledge an edge that was previously acknowledged.\n    function unacknowledgeEdge(bytes32 edgeId_, bytes calldata data_)\n        external\n        override\n        returns (Edge memory edge)\n    {\n        if (!_isCreatorOrEntity(edges[edgeId_].to, msg.sender)) revert Unauthorized();\n        return _setAcknowledged(edgeId_, data_, false);\n    }\n\n    /// @notice Unacknowledge an edge using an ECDSA signature.\n    /// @param edgeId_ The ID of the edge to unacknowledge.\n    /// @param data_ Additional data to include with the unacknowledgment.\n    /// @param signature_ The ECDSA signature to verify.\n    /// @dev The request is valid if the given signature was produced using the edge ID as the message and the creator of the `to` node as the signer.\n    /// @dev This function is used to unacknowledge an edge that was previously acknowledged and will revert if the edge does not exist or if the signature is invalid. It emits an {EdgeUnacknowledged} event for the edge.\n    function unacknowledgeEdge(bytes32 edgeId_, bytes calldata data_, bytes calldata signature_)\n        external\n        checkSignature(edgeId_, data_, signature_)\n        returns (Edge memory edge)\n    {\n        return _setAcknowledged(edgeId_, data_, false);\n    }\n\n    /// @notice Override the {OwnableRoles} implementation to extend access to the `ADMIN_ROLE`.\n    /// @param guy The address to grant the roles.\n    /// @param roles The roles to grant.\n    /// @dev This function is used to grant roles to an address and will revert if the caller is not the owner and does not have the `ADMIN_ROLE`.\n    function grantRoles(address guy, uint256 roles)\n        public\n        payable\n        override\n        onlyOwnerOrRoles(ADMIN_ROLE)\n    {\n        _grantRoles(guy, roles);\n    }\n\n    /// @notice Override the {OwnableRoles} implementation to extend access to the `ADMIN_ROLE`.\n    /// @param guy The address from which to revoke the roles.\n    /// @param roles The roles to revoke.\n    /// @dev This function is used to revoke roles from an address and will revert if the caller is not the owner and does not have the `ADMIN_ROLE`.\n    function revokeRoles(address guy, uint256 roles)\n        public\n        payable\n        override\n        onlyOwnerOrRoles(ADMIN_ROLE)\n    {\n        _removeRoles(guy, roles);\n    }\n\n    /// @notice Get the ID of an edge given the source and target nodes.\n    /// @param from_ The source node of the edge.\n    /// @param to_ The target node of the edge.\n    /// @return edgeId The ID of the edge (i.e. the keccak256 hash of the `from` and `to` nodes).\n    function getEdgeId(Node memory from_, Node memory to_) public pure returns (bytes32) {\n        return keccak256(abi.encode(from_, to_));\n    }\n\n    /// @notice Get the ID of an edge.\n    /// @param edge_ The edge for which to get the ID.\n    /// @return edgeId The ID of the edge (i.e. the keccak256 hash of the `from` and `to` nodes).\n    function getEdgeId(Edge memory edge_) public pure returns (bytes32) {\n        return getEdgeId(edge_.from, edge_.to);\n    }\n\n    /// @notice Set the acknowledged status of an edge.\n    /// @param edgeId_ The ID of the edge to set the acknowledged status for.\n    /// @param data_ Additional data to include with the acknowledgment.\n    /// @param acknowledged_ The new acknowledged status of the edge.\n    /// @return edge The edge with the updated acknowledged status.\n    function _setAcknowledged(bytes32 edgeId_, bytes calldata data_, bool acknowledged_)\n        internal\n        returns (Edge memory edge)\n    {\n        if (!_edgeIds.contains(edgeId_)) revert NotFound();\n        edge = edges[edgeId_];\n        edge.acknowledged = acknowledged_;\n\n        if (acknowledged_) {\n            emit EdgeAcknowledged(edge, msg.sender, data_);\n        } else {\n            emit EdgeUnacknowledged(edge, msg.sender, data_);\n        }\n    }\n\n    /// @notice Allows the admin to upgrade the contract.\n    /// @dev This function overrides the {UUPSUpgradeable} implementation to restrict upgrade rights to the graph owner.\n    function _authorizeUpgrade(address) internal view override onlyOwnerOrRoles(ADMIN_ROLE) {\n        // The modifier handles the authorization.\n    }\n\n    /// @notice Returns the domain name and version for EIP-712.\n    function _domainNameAndVersion()\n        internal\n        pure\n        override\n        returns (string memory name, string memory version)\n    {\n        name = \"TitlesGraph\";\n        version = \"1\";\n    }\n\n    /// @notice Checks if the given address is the creator of a node.\n    /// @param node The node to check.\n    /// @param guy The address to check.\n    /// @return True if the address is the creator of the node, false otherwise.\n    function _isCreator(Node memory node, address guy) internal pure returns (bool) {\n        return node.creator.target == guy;\n    }\n\n    /// @notice Checks if the given address is the on-chain entity represented by a node.\n    /// @param node The node to check.\n    /// @param guy The address to check.\n    /// @return True if the address is the entity of the node, false otherwise.\n    function _isEntity(Node memory node, address guy) internal pure returns (bool) {\n        return node.entity.target == guy;\n    }\n\n    /// @notice Checks if the given address is either the creator or on-chain entity represented by a node.\n    /// @param node The node to check.\n    /// @param guy The address to check.\n    /// @return True if the address is the creator or entity of the node, false otherwise.\n    function _isCreatorOrEntity(Node memory node, address guy) internal pure returns (bool) {\n        return _isCreator(node, guy) || _isEntity(node, guy);\n    }\n}"
    },
    {
      "filename": "wallflower-contract-v2/src/graph/TitlesGraph.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {OwnableRoles} from \"lib/solady/src/auth/OwnableRoles.sol\";\nimport {EnumerableSet} from \"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\";\nimport {EIP712} from \"lib/solady/src/utils/EIP712.sol\";\nimport {SignatureCheckerLib} from \"lib/solady/src/utils/SignatureCheckerLib.sol\";\nimport {UUPSUpgradeable} from \"lib/solady/src/utils/UUPSUpgradeable.sol\";\n\nimport {IOpenGraph} from \"src/interfaces/IOpenGraph.sol\";\nimport {IEdgeManager} from \"src/interfaces/IEdgeManager.sol\";\nimport {ADMIN_ROLE, Edge, Node, Unauthorized} from \"src/shared/Common.sol\";\n\n/// @title TitlesGraph\n/// @notice Titles.xyz implementation of the OpenGraph standard\n/// @dev The TitlesGraph contract implements the OpenGraph standard and is responsible for managing the creation and acknowledgment of {Node}s and {Edge}s in the graph.\ncontract TitlesGraph is IOpenGraph, IEdgeManager, OwnableRoles, EIP712, UUPSUpgradeable {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using SignatureCheckerLib for address;\n\n    error Exists();\n    error NotFound();\n\n    /// @notice The set of edge IDs in the graph. Enumerable to enable on-chain graph traversal in the future.\n    EnumerableSet.Bytes32Set private _edgeIds;\n\n    /// @notice Edges are relationships between two nodes in the graph.\n    mapping(bytes32 id => Edge edge) public edges;\n\n    /// @notice An internal mapping to prevent signature reuse.\n    mapping(bytes32 signature => bool used) private _isUsed;\n\n    // @notice The hash of the acknowledgement struct. Used for EIP-712.\n    bytes32 public constant ACK_TYPEHASH = keccak256(\"Ack(bytes32 edgeId,bytes data)\");\n\n    // @notice The EIP-712 domain type hash. (Exposed here for convenience.)\n    bytes32 public constant DOMAIN_TYPEHASH = _DOMAIN_TYPEHASH;\n\n    /// @notice Modified to check the signature for a proxied acknowledgment.\n    modifier checkSignature(bytes32 edgeId, bytes calldata data, bytes calldata signature) {\n        bytes32 digest = _hashTypedData(keccak256(abi.encode(ACK_TYPEHASH, edgeId, data)));\n        if (\n            !edges[edgeId].to.creator.target.isValidSignatureNowCalldata(digest, signature)\n                || _isUsed[keccak256(signature)]\n        ) {\n            revert Unauthorized();\n        }\n        _;\n        _isUsed[keccak256(signature)] = true;\n    }\n\n    constructor(address owner_, address admin_) {\n        _initializeOwner(owner_);\n        _grantRoles(admin_, ADMIN_ROLE);\n    }\n\n    /// @inheritdoc IOpenGraph\n    /// @notice Create a new {Edge} between two {Node}s in the graph.\n    /// @param from_ The {Node} from which the edge originates.\n    /// @param to_ The {Node} to which the edge points.\n    /// @param data_ Metadata associated with the edge.\n    /// @return edge The created edge.\n    /// @dev This function is used to create a new edge between two nodes in the graph and will revert if not unique or if called by any address other than the contract referenced as the `from` node. A {NodeTouched} event is emitted for each node and an {EdgeCreated} event is emitted for the edge itself.\n    function createEdge(Node calldata from_, Node calldata to_, bytes calldata data_)\n        external\n        override\n        returns (Edge memory edge)\n    {\n        if (!_isEntity(from_, msg.sender)) revert Unauthorized();\n        return _createEdge(from_, to_, data_);\n    }\n\n    /// @notice Create multiple edges within the graph.\n    /// @param edges_ The edges to create.\n    /// @dev This function is used to create multiple edges within the graph and will revert if any of the edges are not unique. It emits a {NodeTouched} event for each node and an {EdgeCreated} event for each edge.\n    function createEdges(Edge[] calldata edges_) external onlyRolesOrOwner(ADMIN_ROLE) {\n        for (uint256 i = 0; i < edges_.length; i++) {\n            _createEdge(edges_[i].from, edges_[i].to, edges_[i].data);\n        }\n    }\n\n    function _createEdge(Node memory from_, Node memory to_, bytes memory data_)\n        internal\n        returns (Edge memory edge)\n    {\n        bytes32 edgeId = keccak256(abi.encode(from_, to_));\n        if (!_edgeIds.add(edgeId)) revert Exists();\n\n        edge = Edge({from: from_, to: to_, acknowledged: false, data: data_});\n        edges[edgeId] = edge;\n\n        emit NodeTouched(from_, data_);\n        emit NodeTouched(to_, data_);\n        emit EdgeCreated(edge, data_);\n    }\n\n    /// @inheritdoc IEdgeManager\n    /// @notice Acknowledge an edge.\n    /// @param edgeId_ The ID of the edge to acknowledge.\n    /// @param data_ Additional data to include with the acknowledgment.\n    /// @return edge The acknowledged edge.\n    /// @dev This function is used to acknowledge an edge that was previously created and will revert if the edge does not exist. It emits an {EdgeAcknowledged} event for the edge.\n    function acknowledgeEdge(bytes32 edgeId_, bytes calldata data_)\n        external\n        override\n        returns (Edge memory edge)\n    {\n        if (!_isCreatorOrEntity(edges[edgeId_].to, msg.sender)) revert Unauthorized();\n        return _setAcknowledged(edgeId_, data_, true);\n    }\n\n    /// @notice Acknowledge an edge using an ECDSA signature.\n    /// @param edgeId_ The ID of the edge to acknowledge.\n    /// @param data_ Additional data to include with the acknowledgment.\n    /// @param signature_ The ECDSA signature to verify.\n    /// @dev The request is valid if the given signature was produced using the edge ID as the message and the creator of the `to` node as the signer.\n    /// @dev This function is used to acknowledge an edge that was previously created and will revert if the edge does not exist or if the signature is invalid. It emits an {EdgeAcknowledged} event for the edge.\n    function acknowledgeEdge(bytes32 edgeId_, bytes calldata data_, bytes calldata signature_)\n        external\n        checkSignature(edgeId_, data_, signature_)\n        returns (Edge memory edge)\n    {\n        return _setAcknowledged(edgeId_, data_, true);\n    }\n\n    /// @inheritdoc IEdgeManager\n    /// @notice Unacknowledge an edge.\n    /// @param edgeId_ The ID of the edge to unacknowledge.\n    /// @param data_ Additional data to include with the unacknowledgment.\n    /// @dev This function is used to unacknowledge an edge that was previously acknowledged.\n    function unacknowledgeEdge(bytes32 edgeId_, bytes calldata data_)\n        external\n        override\n        returns (Edge memory edge)\n    {\n        if (!_isCreatorOrEntity(edges[edgeId_].to, msg.sender)) revert Unauthorized();\n        return _setAcknowledged(edgeId_, data_, false);\n    }\n\n    /// @notice Unacknowledge an edge using an ECDSA signature.\n    /// @param edgeId_ The ID of the edge to unacknowledge.\n    /// @param data_ Additional data to include with the unacknowledgment.\n    /// @param signature_ The ECDSA signature to verify.\n    /// @dev The request is valid if the given signature was produced using the edge ID as the message and the creator of the `to` node as the signer.\n    /// @dev This function is used to unacknowledge an edge that was previously acknowledged and will revert if the edge does not exist or if the signature is invalid. It emits an {EdgeUnacknowledged} event for the edge.\n    function unacknowledgeEdge(bytes32 edgeId_, bytes calldata data_, bytes calldata signature_)\n        external\n        checkSignature(edgeId_, data_, signature_)\n        returns (Edge memory edge)\n    {\n        return _setAcknowledged(edgeId_, data_, false);\n    }\n\n    /// @notice Override the {OwnableRoles} implementation to extend access to the `ADMIN_ROLE`.\n    /// @param guy The address to grant the roles.\n    /// @param roles The roles to grant.\n    /// @dev This function is used to grant roles to an address and will revert if the caller is not the owner and does not have the `ADMIN_ROLE`.\n    function grantRoles(address guy, uint256 roles)\n        public\n        payable\n        override\n        onlyOwnerOrRoles(ADMIN_ROLE)\n    {\n        _grantRoles(guy, roles);\n    }\n\n    /// @notice Override the {OwnableRoles} implementation to extend access to the `ADMIN_ROLE`.\n    /// @param guy The address from which to revoke the roles.\n    /// @param roles The roles to revoke.\n    /// @dev This function is used to revoke roles from an address and will revert if the caller is not the owner and does not have the `ADMIN_ROLE`.\n    function revokeRoles(address guy, uint256 roles)\n        public\n        payable\n        override\n        onlyOwnerOrRoles(ADMIN_ROLE)\n    {\n        _removeRoles(guy, roles);\n    }\n\n    /// @notice Get the ID of an edge given the source and target nodes.\n    /// @param from_ The source node of the edge.\n    /// @param"
    }
  ]
}