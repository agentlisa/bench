{
  "Title": "[H-01] No withdrawal possible for ETH TOKE pool",
  "Content": "_Submitted by Lambda_\n\nThe `withdraw` function of the ETH Tokemak pool has an additional parameter `asEth`. This can be seen in the Tokemak [Github repository](https://github.com/Tokemak/tokemak-smart-contracts-public/blob/2f54689d5d16ddfd1751493b161a049d6c98c382/contracts/pools/EthPool.sol#L94) or also when looking at the deployed code of the [ETH pool](https://etherscan.io/address/0xb104A7fA1041168556218DDb40Fe2516F88246d5#code). Compare that to e.g. the [USDC pool](https://etherscan.io/address/0xca5e07804beef19b6e71b9db18327d215cd58d4e#code), which does not have this parameter.\n\nThis means that the call to `withdraw` will when the staking token is ETH / WETH and no withdrawals would be possible.\n\n### Proof of Concept\n\nA new `Staking` contract with ETH / WETH as the staking token is deployed. Deposits in Tokemak work fine, so users stake their tokens. However, because of the previously described issue, no withdrawal is possible, leaving the funds locked.\n\n### Recommended Mitigation Steps\n\nHandle the case where the underlying asset is WETH / ETH separately and pass this boolean in that case.\n\n**[toshiSat (Yieldy) confirmed and resolved](https://github.com/code-423n4/2022-06-yieldy-findings/issues/87)** \n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-06-yieldy-contest",
  "Code": [
    {
      "filename": "contracts/pools/EthPool.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"../interfaces/ILiquidityEthPool.sol\";\nimport \"../interfaces/IManager.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport {AddressUpgradeable as Address} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {MathUpgradeable as Math} from \"@openzeppelin/contracts-upgradeable/math/MathUpgradeable.sol\";\nimport {SafeMathUpgradeable as SafeMath} from \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport {OwnableUpgradeable as Ownable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {ERC20Upgradeable as ERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable as SafeERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\nimport {PausableUpgradeable as Pausable} from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"../interfaces/events/BalanceUpdateEvent.sol\";\nimport \"../interfaces/events/Destinations.sol\";\nimport \"../interfaces/events/IEventSender.sol\";\n\ncontract EthPool is ILiquidityEthPool, Initializable, ERC20, Ownable, Pausable, IEventSender {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using Address for address payable;\n\n    /// @dev TODO: Hardcode addresses, make immuatable, remove from initializer\n    IWETH public override weth;\n    IManager public manager;\n\n    // implied: deployableLiquidity = underlyer.balanceOf(this) - withheldLiquidity\n    uint256 public override withheldLiquidity;\n\n    // fAsset holder -> WithdrawalInfo\n    mapping(address => WithdrawalInfo) public override requestedWithdrawals;\n\n    // NonReentrant\n    bool private _entered;\n\n    bool public _eventSend;\n    Destinations public destinations;\n\n    modifier nonReentrant() {\n        require(!_entered, \"ReentrancyGuard: reentrant call\");\n        _entered = true;\n        _;\n        _entered = false;\n    }\n\n    modifier onEventSend() {\n        if (_eventSend) {\n            _;\n        }\n    }\n\n    /// @dev necessary to receive ETH\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n\n    function initialize(\n        IWETH _weth,\n        IManager _manager,\n        string memory _name,\n        string memory _symbol\n    ) public initializer {\n        require(address(_weth) != address(0), \"ZERO_ADDRESS\");\n        require(address(_manager) != address(0), \"ZERO_ADDRESS\");\n\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n        __Pausable_init_unchained();\n        __ERC20_init_unchained(_name, _symbol);\n        weth = _weth;\n        manager = _manager;\n        withheldLiquidity = 0;\n    }\n\n    function deposit(uint256 amount) external payable override whenNotPaused {\n        _deposit(msg.sender, msg.sender, amount, msg.value);\n    }\n\n    function depositFor(address account, uint256 amount) external payable override whenNotPaused {\n        _deposit(msg.sender, account, amount, msg.value);\n    }\n\n    function underlyer() external view override returns (address) {\n        return address(weth);\n    }\n\n    /// @dev References the WithdrawalInfo for how much the user is permitted to withdraw\n    /// @dev No withdrawal permitted unless currentCycle >= minCycle\n    /// @dev Decrements withheldLiquidity by the withdrawn amount\n    function withdraw(uint256 requestedAmount, bool asEth) external override whenNotPaused nonReentrant {\n        require(\n            requestedAmount <= requestedWithdrawals[msg.sender].amount,\n            \"WITHDRAW_INSUFFICIENT_BALANCE\"\n        );\n        require(requestedAmount > 0, \"NO_WITHDRAWAL\");\n        require(weth.balanceOf(address(this)) >= requestedAmount, \"INSUFFICIENT_POOL_BALANCE\");\n\n        require(\n            requestedWithdrawals[msg.sender].minCycle <= manager.getCurrentCycleIndex(),\n            \"INVALID_CYCLE\"\n        );\n\n        requestedWithdrawals[msg.sender].amount = requestedWithdrawals[msg.sender].amount.sub(\n            requestedAmount\n        );\n\n        // Delete if all assets withdrawn\n        if (requestedWithdrawals[msg.sender].amount == 0) {\n            delete requestedWithdrawals[msg.sender];\n        }\n\n        withheldLiquidity = withheldLiquidity.sub(requestedAmount);\n        _burn(msg.sender, requestedAmount);\n\n        bytes32 eventSig = \"Withdraw\";\n        encodeAndSendData(eventSig, msg.sender);\n\n        if (asEth) { // Convert to eth\n            weth.withdraw(requestedAmount);\n            msg.sender.sendValue(requestedAmount);\n        } else { // Send as WETH\n            IERC20(weth).safeTransfer(msg.sender, requestedAmount);\n        }\n    }\n\n    /// @dev Adjusts the withheldLiquidity as necessary\n    /// @dev Updates the WithdrawalInfo for when a user can withdraw and for what requested amount\n    function requestWithdrawal(uint256 amount) external override {\n        require(amount > 0, \"INVALID_AMOUNT\");\n        require(amount <= balanceOf(msg.sender), \"INSUFFICIENT_BALANCE\");\n\n        //adjust withheld liquidity by removing the original withheld amount and adding the new amount\n        withheldLiquidity = withheldLiquidity.sub(requestedWithdrawals[msg.sender].amount).add(\n            amount\n        );\n        requestedWithdrawals[msg.sender].amount = amount;\n        if (manager.getRolloverStatus()) {  // If manager is in the middle of a cycle rollover, add two cycles\n            requestedWithdrawals[msg.sender].minCycle = manager.getCurrentCycleIndex().add(2);\n        } else {  // If the manager is not in the middle of a rollover, add one cycle\n            requestedWithdrawals[msg.sender].minCycle = manager.getCurrentCycleIndex().add(1);\n        }\n\n        emit WithdrawalRequested(msg.sender, amount);\n    }\n\n    function preTransferAdjustWithheldLiquidity(address sender, uint256 amount) internal {\n        if (requestedWithdrawals[sender].amount > 0) {\n            //reduce requested withdraw amount by transferred amount;\n            uint256 newRequestedWithdrawl = requestedWithdrawals[sender].amount.sub(\n                Math.min(amount, requestedWithdrawals[sender].amount)\n            );\n\n            //subtract from global withheld liquidity (reduce) by removing the delta of (requestedAmount - newRequestedAmount)\n            withheldLiquidity = withheldLiquidity.sub(\n                requestedWithdrawals[sender].amount.sub(newRequestedWithdrawl)\n            );\n\n            //update the requested withdraw for user\n            requestedWithdrawals[sender].amount = newRequestedWithdrawl;\n\n            //if the withdraw request is 0, empty it out\n            if (requestedWithdrawals[sender].amount == 0) {\n                delete requestedWithdrawals[sender];\n            }\n        }\n    }\n\n    function approveManager(uint256 amount) public override onlyOwner {\n        uint256 currentAllowance = IERC20(weth).allowance(address(this), address(manager));\n        if (currentAllowance < amount) {\n            uint256 delta = amount.sub(currentAllowance);\n            IERC20(weth).safeIncreaseAllowance(address(manager), delta);\n        } else {\n            uint256 delta = currentAllowance.sub(amount);\n            IERC20(weth).safeDecreaseAllowance(address(manager), delta);\n        }\n    }\n\n    /// @dev Adjust withheldLiquidity and requestedWithdrawal if sender does not have sufficient unlocked balance for the transfer\n    function transfer(address recipient, uint256 amount) public override whenNotPaused nonReentrant returns (bool) {\n        preTransferAdjustWithheldLiquidity(msg.sender, amount);\n        (bool success) = super.transfer(recipient, amount);\n\n        bytes32 eventSig = \"Transfer\";\n        encodeAndSendData(eventSig, msg.sender);\n        encodeAndSendData(eventSig, recipient);\n\n        return success;\n    }\n\n    /// @dev Adjust withheldLiquidity and requestedWithdrawal if sender does not have sufficient unlocked balance for the transfer\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public override whenNotPaused nonReentrant returns (bool) {\n        preTransferAdjustWithheldLiquidity(sender, amount);\n        (bool success) = super.transferFrom(sender, recipient, amount);\n\n        bytes32 eventSig = \"Transfer\";\n        encodeAndSendData(eventSig, sender);\n        encodeAndSendData(eventSig, recipient);\n\n        return success;\n    }\n\n    function pause() external override onlyOwner {\n        _pause();\n    }\n\n    function unpause() external override onlyOwner {\n        _unpause();\n    }\n\n    function setDestinations(address _fxStateSender, address _destinationOnL2) external override onlyOwner {\n        require(_fxStateSender != address(0), \"INVALID_ADDRESS\");\n        require(_destinationOnL2 != address(0), \"INVALID_ADDRESS\");\n\n        destinations.fxStateSender = IFxStateSender(_fxStateSender);\n        destinations.destinationOnL2 = _destinationOnL2;\n\n        emit DestinationsSet(_fxStateSender, _destinationOnL2);\n    }\n\n    function setEventSend(bool _eventSendSet) external override onlyOwner {\n        require(destinations.destinationOnL2 != address(0), \"DESTINATIONS_NOT_SET\");\n\n        _eventSend = _eventSendSet;\n\n        emit EventSendSet(_eventSendSet);\n    }\n\n    function _deposit(\n        address fromAccount,\n        address toAccount,\n        uint256 amount,\n        uint256 msgValue\n    ) internal {\n        require(amount > 0, \"INVALID_AMOUNT\");\n        require(toAccount != address(0), \"INVALID_ADDRESS\");\n\n        _mint(toAccount, amount);\n        if (msgValue > 0) { // If ether get weth\n            require(msgValue == amount, \"AMT_VALUE_MISMATCH\");\n            weth.deposit{value: amount}();\n        } else { // Else go ahead and transfer weth from account to pool\n            IERC20(weth).safeTransferFrom(fromAccount, address(this), amount);\n        }\n\n        bytes32 eventSig = \"Deposit\";\n        encodeAndSendData(eventSig, toAccount);\n    }\n\n    function encodeAndSendData(bytes32 _eventSig, address _user) private onEventSend {\n        require(address(destinations.fxStateSender) != address(0), \"ADDRESS_NOT_SET\");\n        require(destinations.destinationOnL2 != address(0), \"ADDRESS_NOT_SET\");\n\n        uint256 userBalance = balanceOf(_user);\n        bytes memory data = abi.encode(BalanceUpdateEvent({\n            eventSig: _eventSig,\n            account: _user, \n            token: address(this), \n            amount: userBalance\n        }));\n\n        destinations.fxStateSender.sendMessageToChild(destinations.destinationOnL2, data);\n    }\n}"
    }
  ]
}