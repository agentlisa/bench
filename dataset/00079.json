{
  "Title": "Missing Check if the Returned Value From Price Oracle Is Zero",
  "Content": "The [`GenericFactory`](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/GenericFactory/GenericFactory.sol#L12-L138) allows the deployment of a vault with any price oracle. This means that there might be vaults created with custom-built oracles that do not correctly check for the calculated value, which could be zero.\n\n\nConsider validating the value received from price oracle functions such as `getQuote` and `getQuotes` in [`getLiabilityValue`](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/shared/LiquidityUtils.sol#L86),[`getCollateralValue`](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/shared/LiquidityUtils.sol#L103), and [`calculateMaxLiquidation`](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/modules/Liquidation.sol#L136-L150) functions to ensure that it is not equal to zero.\n\n\n***Update:** Acknowledged, not resolved. The Euler team stated:*\n\n\n\n> *We acknowledge the issue. Zero values returned from the oracle calls do not signify an error. In the `IPriceOracle` interface, for the specified `amountIn`, the returned `amountOut` could be zero when either the base token is actually worthless or the value in quote token is not representable, both cases are valid. It is the vault’s governor’s responsibility to properly select and configure the oracle. The vault itself has no means to verify the oracle’s suitability on-chain.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/GenericFactory/GenericFactory.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {BeaconProxy} from \"./BeaconProxy.sol\";\nimport {MetaProxyDeployer} from \"./MetaProxyDeployer.sol\";\n\ninterface IComponent {\n    function initialize(address creator) external;\n}\n\ncontract GenericFactory is MetaProxyDeployer {\n    // Constants\n\n    uint256 constant REENTRANCYLOCK__UNLOCKED = 1;\n    uint256 constant REENTRANCYLOCK__LOCKED = 2;\n\n    // State\n\n    struct ProxyConfig {\n        bool upgradeable;\n        address implementation; // may be an out-of-date value, if upgradeable (handled by getProxyConfig)\n        bytes trailingData;\n    }\n\n    uint256 private reentrancyLock;\n\n    address public upgradeAdmin;\n    address public implementation;\n    mapping(address proxy => ProxyConfig) internal proxyLookup;\n    address[] public proxyList;\n\n    // Events\n\n    event Genesis();\n\n    event ProxyCreated(address indexed proxy, bool upgradeable, address implementation, bytes trailingData);\n\n    event SetImplementation(address indexed newImplementation);\n    event SetUpgradeAdmin(address indexed newUpgradeAdmin);\n\n    // Errors\n\n    error E_Reentrancy();\n    error E_Unauthorized();\n    error E_Implementation();\n    error E_BadAddress();\n    error E_BadQuery();\n\n    // Modifiers\n\n    modifier nonReentrant() {\n        if (reentrancyLock == REENTRANCYLOCK__LOCKED) revert E_Reentrancy();\n\n        reentrancyLock = REENTRANCYLOCK__LOCKED;\n        _;\n        reentrancyLock = REENTRANCYLOCK__UNLOCKED;\n    }\n\n    modifier adminOnly() {\n        if (msg.sender != upgradeAdmin) revert E_Unauthorized();\n        _;\n    }\n\n    constructor(address admin) {\n        emit Genesis();\n\n        reentrancyLock = REENTRANCYLOCK__UNLOCKED;\n\n        upgradeAdmin = admin;\n\n        emit SetUpgradeAdmin(admin);\n    }\n\n    function createProxy(bool upgradeable, bytes memory trailingData) external nonReentrant returns (address) {\n        if (implementation == address(0)) revert E_Implementation();\n\n        address proxy;\n\n        if (upgradeable) {\n            proxy = address(new BeaconProxy(trailingData));\n        } else {\n            proxy = deployMetaProxy(implementation, trailingData);\n        }\n\n        proxyLookup[proxy] =\n            ProxyConfig({upgradeable: upgradeable, implementation: implementation, trailingData: trailingData});\n\n        proxyList.push(proxy);\n\n        IComponent(proxy).initialize(msg.sender);\n\n        emit ProxyCreated(proxy, upgradeable, implementation, trailingData);\n\n        return proxy;\n    }\n\n    // EVault beacon upgrade\n\n    function setImplementation(address newImplementation) external nonReentrant adminOnly {\n        if (newImplementation == address(0)) revert E_BadAddress();\n        implementation = newImplementation;\n        emit SetImplementation(newImplementation);\n    }\n\n    // Admin role\n\n    function setUpgradeAdmin(address newUpgradeAdmin) external nonReentrant adminOnly {\n        if (newUpgradeAdmin == address(0)) revert E_BadAddress();\n        upgradeAdmin = newUpgradeAdmin;\n        emit SetUpgradeAdmin(newUpgradeAdmin);\n    }\n\n    // Proxy getters\n\n    function getProxyConfig(address proxy) external view returns (ProxyConfig memory config) {\n        config = proxyLookup[proxy];\n        if (config.upgradeable) config.implementation = implementation;\n    }\n\n    function isProxy(address proxy) external view returns (bool) {\n        return proxyLookup[proxy].implementation != address(0);\n    }\n\n    function getProxyListLength() external view returns (uint256) {\n        return proxyList.length;\n    }\n\n    function getProxyListSlice(uint256 start, uint256 end) external view returns (address[] memory list) {\n        if (end == type(uint256).max) end = proxyList.length;\n        if (end < start || end > proxyList.length) revert E_BadQuery();\n\n        list = new address[](end - start);\n        for (uint256 i; i < end - start; ++i) {\n            list[i] = proxyList[start + i];\n        }\n    }\n}"
    },
    {
      "filename": "src/EVault/shared/LiquidityUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {BorrowUtils} from \"./BorrowUtils.sol\";\nimport {LTVUtils} from \"./LTVUtils.sol\";\n\nimport \"./types/Types.sol\";\n\n/// @title LiquidityUtils\n/// @author Euler Labs (https://www.eulerlabs.com/)\n/// @notice Utilities for calculating account liquidity and health status\nabstract contract LiquidityUtils is BorrowUtils, LTVUtils {\n    using TypesLib for uint256;\n\n    // Calculate the value of liabilities, and the liquidation or borrowing LTV adjusted collateral value.\n    function calculateLiquidity(\n        VaultCache memory vaultCache,\n        address account,\n        address[] memory collaterals,\n        LTVType ltvType\n    ) internal view virtual returns (uint256 collateralValue, uint256 liabilityValue) {\n        validateOracle(vaultCache);\n\n        for (uint256 i; i < collaterals.length; ++i) {\n            collateralValue += getCollateralValue(vaultCache, account, collaterals[i], ltvType);\n        }\n\n        liabilityValue = getLiabilityValue(vaultCache, account, vaultStorage.users[account].getOwed());\n    }\n\n    // Check that the value of the collateral, adjusted for borrowing LTV, is equal or greater than the liability value.\n    function checkLiquidity(VaultCache memory vaultCache, address account, address[] memory collaterals)\n        internal\n        view\n        virtual\n    {\n        validateOracle(vaultCache);\n\n        Owed owed = vaultStorage.users[account].getOwed();\n        if (owed.isZero()) return;\n\n        uint256 liabilityValue = getLiabilityValue(vaultCache, account, owed);\n\n        uint256 collateralValue;\n        for (uint256 i; i < collaterals.length; ++i) {\n            collateralValue += getCollateralValue(vaultCache, account, collaterals[i], LTVType.BORROWING);\n            if (collateralValue > liabilityValue) return;\n        }\n\n        revert E_AccountLiquidity();\n    }\n\n    // Check if the account has no collateral balance left, used for debt socialization\n    // If LTV is zero, the collateral can still be liquidated.\n    // If the price of collateral is zero, liquidations are not executed, so the check won't be performed.\n    // If there is no collateral balance at all, then debt socialization can happen.\n    function checkNoCollateral(address account, address[] memory collaterals) internal view virtual returns (bool) {\n        for (uint256 i; i < collaterals.length; ++i) {\n            address collateral = collaterals[i];\n\n            if (!isRecognizedCollateral(collateral)) continue;\n\n            uint256 balance = IERC20(collateral).balanceOf(account);\n            if (balance > 0) return false;\n        }\n\n        return true;\n    }\n\n    function getLiabilityValue(VaultCache memory vaultCache, address account, Owed owed)\n        internal\n        view\n        virtual\n        returns (uint256 value)\n    {\n        // update owed with interest accrued\n        uint256 owedAssets = getCurrentOwed(vaultCache, account, owed).toAssetsUp().toUint();\n\n        if (owedAssets == 0) return 0;\n\n        if (address(vaultCache.asset) == vaultCache.unitOfAccount) {\n            value = owedAssets;\n        } else {\n            // ask price for liability\n            (, value) = vaultCache.oracle.getQuotes(owedAssets, address(vaultCache.asset), vaultCache.unitOfAccount);\n        }\n    }\n\n    function getCollateralValue(VaultCache memory vaultCache, address account, address collateral, LTVType ltvType)\n        internal\n        view\n        virtual\n        returns (uint256 value)\n    {\n        ConfigAmount ltv = getLTV(collateral, ltvType);\n        if (ltv.isZero()) return 0;\n\n        uint256 balance = IERC20(collateral).balanceOf(account);\n        if (balance == 0) return 0;\n\n        // bid price for collateral\n        (uint256 currentCollateralValue,) = vaultCache.oracle.getQuotes(balance, collateral, vaultCache.unitOfAccount);\n\n        return ltv.mul(currentCollateralValue);\n    }\n\n    function validateOracle(VaultCache memory vaultCache) internal pure {\n        if (address(vaultCache.oracle) == address(0)) revert E_NoPriceOracle();\n    }\n}"
    }
  ]
}