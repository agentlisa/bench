{
  "Title": "Flood mechanism is susceptible to DoS attacks by a frontrunner, breaking re-peg mechanism when BEAN is above 1 USD",
  "Content": "**Description:** A [call](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/Weather.sol#L276) to the BEAN/3CRV Metapool is made within`Weather::sop`, swapping Beans for 3CRV, to aid in returning Beanstalk to peg via a mechanism known as \"Flood\" (formerly Season of Plenty, or sop) when the Beanstalk Farm has been \"Oversaturated\" ($P > 1$; $Pod Rate < 5\\%$) for more than one Season and for each additional Season in which it continues to be Oversaturated. This is achieved by minting additional Beans and selling them directly on Curve, distributing the proceeds from the sale as 3CRV to Stalkholders.\n\nUnlike [`Oracle::stepOracle`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/SeasonFacet.sol#L57), which returns the [aggregate time-weighted `deltaB`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/Oracle.sol#L42-L46) value across both the BEAN/3CRVÂ Metapool and BEAN/ETH Well, the current shortage/excess of Beans during the [handling of Rain](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/Weather.sol#L243) in [`Weather::stepWeather`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/Weather.sol#L192) are [calculated directly](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/Weather.sol#L260) from the Curve Metapool via [`LibBeanMetaCurve::getDeltaB`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/Weather.sol#L260).\n\n```solidity\n    function getDeltaB() internal view returns (int256 deltaB) {\n        uint256[2] memory balances = C.curveMetapool().get_balances();\n        uint256 d = getDFroms(balances);\n        deltaB = getDeltaBWithD(balances[0], d);\n    }\n```\n\nThis introduces the possibility that a long-tail MEV bot could perform a denial-of-service attack on the Flood mechanism by performing a sandwich attack on `SeasonFacet::gm` whenever the conditions are met such that `Weather::sop` is called. The attacker would first front-run the transaction by selling BEAN for 3CRV, bringing the price of BEAN back to peg, which could result in [`newBeans <= 0`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/Weather.sol#L261), thus bypassing the subsequent logic, and then back-running to repurchase their sold BEAN effectively maintaining the price of BEAN above peg.\n\nThe cost for performing this attack is 0.08% of the utilized funds. However, not accounting for other mechanisms (such as Convert) designed to return the price of Bean to peg, Beanstalk would need to wait the Season duration of 1 hour before making another effective `SeasonFacet::gm`, provided that the previous transaction did not revert. In the subsequent call, the attacker can replicate this action at the same cost, and it is possible that the price of BEAN may have increased further during this hour.\n\n**Impact:** Attempts by Beanstalk to restore peg via the Flood mechanism are susceptible to denial-of-service attacks by a sufficiently well-funded sandwich attacker through frontrunning of `SeasonFacet::gm`.\n\n**Recommended Mitigation:** Consider the use of an oracle to determine how many new Beans should be minted and sold for 3CRV. This implies the following modification:\n```diff\n    function sop() private {\n-       int256 newBeans = LibBeanMetaCurve.getDeltaB();\n+       int256 currentDeltaB = LibBeanMetaCurve.getDeltaB();\n+       (int256 deltaBFromOracle,)  = - LibCurveMinting.twaDeltaB();\n+       // newBeans = max(currentDeltaB, deltaBFromOracle)\n+       newBeans = currentDeltaB > deltaBFromOracle ? currentDeltaB : deltaBFromOracle;\n\n        if (newBeans <= 0) return;\n\n        uint256 sopBeans = uint256(newBeans);\n        uint256 newHarvestable;\n\n        // Pay off remaining Pods if any exist.\n        if (s.f.harvestable < s.r.pods) {\n            newHarvestable = s.r.pods - s.f.harvestable;\n            s.f.harvestable = s.f.harvestable.add(newHarvestable);\n            C.bean().mint(address(this), newHarvestable.add(sopBeans));\n        } else {\n            C.bean().mint(address(this), sopBeans);\n        }\n\n        // Swap Beans for 3CRV.\n        uint256 amountOut = C.curveMetapool().exchange(0, 1, sopBeans, 0);\n\n        rewardSop(amountOut);\n        emit SeasonOfPlenty(s.season.current, amountOut, newHarvestable);\n    }\n```\n\nThe motivation for using the maximum value between the current `deltaB` and that calculated from time-weighted average balances is that the action of an attacker increasing `deltaB` to carry out a sandwich attack would be nonsensical as excess Bean minted by the Flood mechanism would be sold for additional 3CRV. In this way, anyone attempting to increase `deltaB` would essentially be giving away their 3CRV LP tokens to Stalkholders. Therefore, by using the maximum `deltaB`, it is ensured that the impact of any attempt to execute the attack described above would be minimal and economically unattractive. If no one attempts the attack, the behavior will remain as originally intended.\n\n\\clearpage",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/beanstalk/sun/SeasonFacet/Weather.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"contracts/libraries/Decimal.sol\";\nimport \"contracts/libraries/Curve/LibBeanMetaCurve.sol\";\nimport \"./Sun.sol\";\n\nlibrary DecimalExtended {\n    uint256 private constant PERCENT_BASE = 1e18;\n\n    function toDecimal(uint256 a) internal pure returns (Decimal.D256 memory) {\n        return Decimal.D256({ value: a });\n    }\n}\n\n/**\n * @title Weather\n * @author Publius\n * @notice Weather controls the Temperature on the Farm.\n */\ncontract Weather is Sun {\n    using SafeMath for uint256;\n    using DecimalExtended for uint256;\n    using LibSafeMath32 for uint32;\n    using Decimal for Decimal.D256;\n\n    /// @dev If all Soil is Sown faster than this, Beanstalk considers demand for Soil to be increasing.\n    uint256 private constant SOW_TIME_DEMAND_INCR = 600; // seconds\n\n    uint32 private constant SOW_TIME_STEADY = 60; // seconds\n\n    uint256 private constant POD_RATE_LOWER_BOUND = 0.05e18; // 5%\n    uint256 private constant POD_RATE_OPTIMAL = 0.15e18; // 15%\n    uint256 private constant POD_RATE_UPPER_BOUND = 0.25e18; // 25%\n\n    uint256 private constant DELTA_POD_DEMAND_LOWER_BOUND = 0.95e18; // 95%\n    uint256 private constant DELTA_POD_DEMAND_UPPER_BOUND = 1.05e18; // 105%\n    \n    /**\n     * @notice Emitted when the Temperature (fka \"Weather\") changes.\n     * @param season The current Season\n     * @param caseId The Weather case, which determines how much the Temperature is adjusted.\n     * @param change The change in Temperature as a delta from the previous value\n     * @dev The name {WeatherChange} is kept for backwards compatibility, \n     * however the state variable included as `change` is now called Temperature.\n     * \n     * `change` is emitted as a delta for gas efficiency.\n     */\n    event WeatherChange(\n        uint256 indexed season,\n        uint256 caseId,\n        int8 change\n    );\n\n    /**\n     * @notice Emitted when Beans are minted during the Season of Plenty.\n     * @param season The Season in which Beans were minted for distribution.\n     * @param amount The amount of 3CRV which was received for swapping Beans.\n     * @param toField The amount of Beans which were distributed to remaining Pods in the Field.\n     */\n    event SeasonOfPlenty(\n        uint256 indexed season,\n        uint256 amount,\n        uint256 toField\n    );\n\n\n    //////////////////// WEATHER GETTERS ////////////////////\n\n    /**\n     * @notice Returns the current Weather struct. See {AppStorage:Storage.Weather}.\n     */\n    function weather() public view returns (Storage.Weather memory) {\n        return s.w;\n    }\n\n    /**\n     * @notice Returns the current Rain struct. See {AppStorage:Storage.Rain}.\n     */\n    function rain() public view returns (Storage.Rain memory) {\n        return s.r;\n    }\n\n    /**\n     * @notice Returns the Plenty per Root for `season`.\n     */\n    function plentyPerRoot(uint32 season) external view returns (uint256) {\n        return s.sops[season];\n    }\n\n    //////////////////// WEATHER INTERNAL ////////////////////\n\n    /**\n     * @param deltaB Pre-calculated deltaB from {Oracle.stepOracle}.\n     * @dev A detailed explanation of the Weather mechanism can be found in the\n     * Beanstalk whitepaper. An explanation of state variables can be found in {AppStorage}.\n     */\n    function stepWeather(int256 deltaB) internal returns (uint256 caseId) {\n        uint256 beanSupply = C.bean().totalSupply();\n\n        // Prevent infinite pod rate\n        if (beanSupply == 0) {\n            s.w.t = 1;\n            return 8; // Reasonably low\n        }\n\n        // Calculate Pod Rate\n        Decimal.D256 memory podRate = Decimal.ratio(\n            s.f.pods.sub(s.f.harvestable), // same as totalUnharvestable()\n            beanSupply\n        );\n\n        // Calculate Delta Soil Demand\n        uint256 dsoil = s.f.beanSown;\n        s.f.beanSown = 0;\n    \n        Decimal.D256 memory deltaPodDemand;\n\n        // `s.w.thisSowTime` is set to the number of seconds in it took for \n        // Soil to sell out during the current Season. If Soil didn't sell out,\n        // it remains `type(uint32).max`.\n        if (s.w.thisSowTime < type(uint32).max) {\n            if (\n                s.w.lastSowTime == type(uint32).max || // Didn't Sow all last Season\n                s.w.thisSowTime < SOW_TIME_DEMAND_INCR || // Sow'd all instantly this Season\n                (s.w.lastSowTime > SOW_TIME_STEADY &&\n                    s.w.thisSowTime < s.w.lastSowTime.sub(SOW_TIME_STEADY)) // Sow'd all faster\n            ) {\n                deltaPodDemand = Decimal.from(1e18);\n            } else if (\n                s.w.thisSowTime <= s.w.lastSowTime.add(SOW_TIME_STEADY)\n            ) {\n                // Sow'd all in same time\n                deltaPodDemand = Decimal.one();\n            } else { \n                deltaPodDemand = Decimal.zero();\n            }\n\n            s.w.lastSowTime = s.w.thisSowTime;  // Overwrite last Season\n            s.w.thisSowTime = type(uint32).max; // Reset for next Season\n        } \n\n        // Soil didn't sell out\n        else {\n            uint256 lastDSoil = s.w.lastDSoil;\n\n            if (dsoil == 0) {\n                deltaPodDemand = Decimal.zero(); // If no one sow'd\n            } else if (lastDSoil == 0) {\n                deltaPodDemand = Decimal.from(1e18); // If no one sow'd last Season\n            } else { \n                deltaPodDemand = Decimal.ratio(dsoil, lastDSoil);\n            }\n\n            if (s.w.lastSowTime != type(uint32).max) {\n                s.w.lastSowTime = type(uint32).max;\n            }\n        }\n        \n        // Calculate Weather Case\n        caseId = 0;\n\n        // Evaluate Pod Rate\n        if (podRate.greaterThanOrEqualTo(POD_RATE_UPPER_BOUND.toDecimal())) {\n            caseId = 24;\n        } else if (podRate.greaterThanOrEqualTo(POD_RATE_OPTIMAL.toDecimal())) {\n            caseId = 16;\n        } else if (podRate.greaterThanOrEqualTo(POD_RATE_LOWER_BOUND.toDecimal())) {\n            caseId = 8;\n        }\n\n        // Evaluate Price\n        if (\n            deltaB > 0 ||\n            (deltaB == 0 && podRate.lessThanOrEqualTo(POD_RATE_OPTIMAL.toDecimal()))\n        ) {\n            caseId += 4;\n        }\n\n        // Evaluate Delta Soil Demand\n        if (deltaPodDemand.greaterThanOrEqualTo(DELTA_POD_DEMAND_UPPER_BOUND.toDecimal())) {\n            caseId += 2;\n        } else if (deltaPodDemand.greaterThanOrEqualTo(DELTA_POD_DEMAND_LOWER_BOUND.toDecimal())) {\n            caseId += 1;\n        }\n\n        s.w.lastDSoil = uint128(dsoil); // SafeCast not necessary as `s.f.beanSown` is uint128.\n        \n        changeWeather(caseId);\n        handleRain(caseId);\n    }\n\n    /**\n     * @dev Changes the current Temperature `s.w.t` based on the Weather Case.\n     */\n    function changeWeather(uint256 caseId) private {\n        int8 change = s.cases[caseId];\n        uint32 t = s.w.t;\n\n        if (change < 0) {\n            if (t <= (uint32(-change))) {\n                // if (change < 0 && t <= uint32(-change)),\n                // then 0 <= t <= type(int8).max because change is an int8.\n                // Thus, downcasting t to an int8 will not cause overflow.\n                change = 1 - int8(t);\n                s.w.t = 1;\n            } else {\n                s.w.t = t - (uint32(-change));\n            }\n        } else {\n            s.w.t = t + (uint32(change));\n        }\n\n        emit WeatherChange(s.season.current, caseId, change);\n    }\n\n    /**\n     * @dev Oversaturated was previously referred to as Raining and thus code\n     * references mentioning Rain really refer to Oversaturation. If P > 1 and the\n     * Pod Rate is less than 5%, the Farm is Oversaturated. If it is Oversaturated\n     * for a Season, each Season in which it continues to be Oversaturated, it Floods.\n     */\n    function handleRain(uint256 caseId) internal {\n        // cases 4-7 represent the case where the pod rate is less than 5% and P > 1.\n        if (caseId < 4 || caseId > 7) {\n            if (s.season.raining) {\n                s.season.raining = false;\n            }\n            return;\n        } else if (!s.season.raining) {\n            s.season.raining = true;\n            // Set the plenty per root equal to previous rain start.\n            s.sops[s.season.current] = s.sops[s.season.rainStart];\n            s.season.rainStart = s.season.current;\n            s.r.pods = s.f.pods;\n            s.r.roots = s.s.roots;\n        } else if (\n            s.season.current >= s.season.rainStart.add(s.season.withdrawSeasons - 1)\n        ) {\n            if (s.r.roots > 0) {\n                sop();\n            }\n        }\n    }\n\n    /**\n     * @dev Flood was previously called a \"Season of Plenty\" (SOP for short).\n     * When Beanstalk has been Oversaturated for a Season, Beanstalk returns the\n     * Bean price to its peg by minting additional Beans and selling them directly\n     * on Curve. Proceeds  from the sale in the form of 3CRV are distributed to\n     * Stalkholders at the beginning of a Season in proportion to their Stalk\n     * ownership when the Farm became Oversaturated. Also, at the beginning of the\n     * Flood, all Pods that were minted before the Farm became Oversaturated Ripen\n     * and become Harvestable.\n     * For more information On Oversaturation see {Weather.handleRain}.\n     */\n    function sop() private {\n        int256 newBeans = LibBeanMetaCurve.getDeltaB();\n        if (newBeans <= 0) return;\n\n        uint256 sopBeans = uint256(newBeans);\n        uint256 newHarvestable;\n\n        // Pay off remaining Pods if any exist.\n        if (s.f.harvestable < s.r.pods) {\n            newHarvestable = s.r.pods - s.f.harvestable;\n            s.f.harvestable = s.f.harvestable.add(newHarvestable);\n            C.bean().mint(address(this), newHarvestable.add(sopBeans));\n        } else {\n            C.bean().mint(address(this), sopBeans);\n        }\n\n        // Swap Beans for 3CRV.\n        uint256 amountOut = C.curveMetapool().exchange(0, 1, sopBeans, 0);\n\n        rewardSop(amountOut);\n        emit SeasonOfPlenty(s.season.current, amountOut, newHarvestable);\n    }\n\n    /**\n     * @dev Allocate 3CRV during a Season of Plenty.\n     */\n    function rewardSop(uint256 amount) private {\n        s.sops[s.season.rainStart] = s.sops[s.season.lastSop].add(\n            amount.mul(C.SOP_PRECISION).div(s.r.roots)\n        );\n        s.season.lastSop = s.season.rainStart;\n        s.season.lastSopSeason = s.season.current;\n    }\n}"
    },
    {
      "filename": "protocol/contracts/beanstalk/sun/SeasonFacet/SeasonFacet.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"contracts/libraries/Token/LibTransfer.sol\";\nimport \"contracts/libraries/LibIncentive.sol\";\nimport \"./Weather.sol\";\n\n/**\n * @title SeasonFacet\n * @author Publius, Chaikitty\n * @notice Holds the Sunrise function and handles all logic for Season changes.\n */\ncontract SeasonFacet is Weather {\n    using SafeMath for uint256;\n\n    /**\n     * @notice Emitted when the Season changes.\n     * @param season The new Season number\n     */\n    event Sunrise(uint256 indexed season);\n\n    /**\n     * @notice Emitted when Beanstalk pays `beans` to `account` as a reward for calling `sunrise()`.\n     * @param account The address to which the reward Beans were sent\n     * @param beans The amount of Beans paid as a reward\n     */\n    event Incentivization(address indexed account, uint256 beans);\n\n    //////////////////// SUNRISE ////////////////////\n\n    /**\n     * @notice Advances Beanstalk to the next Season, sending reward Beans to the caller's circulating balance.\n     * @return reward The number of beans minted to the caller.\n     */\n    function sunrise() external payable returns (uint256) {\n        return gm(msg.sender, LibTransfer.To.EXTERNAL);\n    }\n\n    /**\n     * @notice Advances Beanstalk to the next Season, sending reward Beans to a specified address & balance.\n     * @param account Indicates to which address reward Beans should be sent\n     * @param mode Indicates whether the reward beans are sent to internal or circulating balance\n     * @return reward The number of Beans minted to the caller.\n     */\n    function gm(\n        address account,\n        LibTransfer.To mode\n    ) public payable returns (uint256) {\n        uint256 initialGasLeft = gasleft();\n\n        require(!paused(), \"Season: Paused.\");\n        require(seasonTime() > season(), \"Season: Still current Season.\");\n\n        stepSeason();\n        int256 deltaB = stepOracle();\n        uint256 caseId = stepWeather(deltaB);\n        stepSun(deltaB, caseId);\n\n        return incentivize(account, initialGasLeft, mode);\n    }\n\n    //////////////////// SEASON GETTERS ////////////////////\n\n    /**\n     * @notice Returns the current Season number.\n     */\n    function season() public view returns (uint32) {\n        return s.season.current;\n    }\n\n    /**\n     * @notice Returns whether Beanstalk is Paused. When Paused, the `sunrise()` function cannot be called.\n     */\n    function paused() public view returns (bool) {\n        return s.paused;\n    }\n\n    /**\n     * @notice Returns the Season struct. See {Storage.Season}.\n     */\n    function time() external view returns (Storage.Season memory) {\n        return s.season;\n    }\n\n    /**\n     * @notice Returns whether Beanstalk started this Season above or below peg.\n     */\n    function abovePeg() external view returns (bool) {\n        return s.season.abovePeg;\n    }\n\n    /**\n     * @notice Returns the block during which the current Season started.\n     */\n    function sunriseBlock() external view returns (uint32){\n        return s.season.sunriseBlock;\n    }\n\n    /**\n     * @notice Returns the expected Season number given the current block timestamp.\n     * {sunrise} can be called when `seasonTime() > season()`.\n     */\n    function seasonTime() public view virtual returns (uint32) {\n        if (block.timestamp < s.season.start) return 0;\n        if (s.season.period == 0) return type(uint32).max;\n        return uint32((block.timestamp - s.season.start) / s.season.period); // Note: SafeMath is redundant here.\n    }\n\n    //////////////////// SEASON INTERNAL ////////////////////\n\n    /**\n     * @dev Moves the Season forward by 1.\n     */\n    function stepSeason() private {\n        s.season.current += 1;\n        s.season.sunriseBlock = uint32(block.number); // Note: Will overflow in the year 3650.\n        emit Sunrise(season());\n    }\n\n    /**\n     * @param account The address to which the reward beans are sent, may or may not\n     * be the same as the caller of `sunrise()`\n     * @param initialGasLeft The amount of gas left at the start of the transaction\n     * @param mode Send reward beans to Internal or Circulating balance\n     * @dev Mints Beans to `account` as a reward for calling {sunrise()}.\n     */\n    function incentivize(\n        address account,\n        uint256 initialGasLeft,\n        LibTransfer.To mode\n    ) private returns (uint256) {\n        // Number of blocks the sunrise is late by\n        // Assumes that each block timestamp is exactly `C.BLOCK_LENGTH_SECONDS` apart.\n        uint256 blocksLate = block.timestamp.sub(\n            s.season.start.add(s.season.period.mul(season()))\n        )\n        .div(C.BLOCK_LENGTH_SECONDS);\n        \n        uint256 incentiveAmount = LibIncentive.determineReward(initialGasLeft, blocksLate);\n\n        LibTransfer.mintToken(C.bean(), incentiveAmount, account, mode);\n        \n        emit Incentivization(account, incentiveAmount);\n        return incentiveAmount;\n    }\n\n\n}"
    },
    {
      "filename": "protocol/contracts/beanstalk/sun/SeasonFacet/Weather.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"contracts/libraries/Decimal.sol\";\nimport \"contracts/libraries/Curve/LibBeanMetaCurve.sol\";\nimport \"./Sun.sol\";\n\nlibrary DecimalExtended {\n    uint256 private constant PERCENT_BASE = 1e18;\n\n    function toDecimal(uint256 a) internal pure returns (Decimal.D256 memory) {\n        return Decimal.D256({ value: a });\n    }\n}\n\n/**\n * @title Weather\n * @author Publius\n * @notice Weather controls the Temperature on the Farm.\n */\ncontract Weather is Sun {\n    using SafeMath for uint256;\n    using DecimalExtended for uint256;\n    using LibSafeMath32 for uint32;\n    using Decimal for Decimal.D256;\n\n    /// @dev If all Soil is Sown faster than this, Beanstalk considers demand for Soil to be increasing.\n    uint256 private constant SOW_TIME_DEMAND_INCR = 600; // seconds\n\n    uint32 private constant SOW_TIME_STEADY = 60; // seconds\n\n    uint256 private constant POD_RATE_LOWER_BOUND = 0.05e18; // 5%\n    uint256 private constant POD_RATE_OPTIMAL = 0.15e18; // 15%\n    uint256 private constant POD_RATE_UPPER_BOUND = 0.25e18; // 25%\n\n    uint256 private constant DELTA_POD_DEMAND_LOWER_BOUND = 0.95e18; // 95%\n    uint256 private constant DELTA_POD_DEMAND_UPPER_BOUND = 1.05e18; // 105%\n    \n    /**\n     * @notice Emitted when the Temperature (fka \"Weather\") changes.\n     * @param season The current Season\n     * @param caseId The Weather case, which determines how much the Temperature is adjusted.\n     * @param change The change in Temperature as a delta from the previous value\n     * @dev The name {WeatherChange} is kept for backwards compatibility, \n     * however the state variable included as `change` is now called Temperature.\n     * \n     * `change` is emitted as a delta for gas efficiency.\n     */\n    event WeatherChange(\n        uint256 indexed season,\n        uint256 caseId,\n        int8 change\n    );\n\n    /**\n     * @notice Emitted when Beans are minted during the Season of Plenty.\n     * @param season The Season in which Beans were minted for distribution.\n     * @param amount The amount of 3CRV which was received for swapping Beans.\n     * @param toField The amount of Beans which were distributed to remaining Pods in the Field.\n     */\n    event SeasonOfPlenty(\n        uint256 indexed season,\n        uint256 amount,\n        uint256 toField\n    );\n\n\n    //////////////////// WEATHER GETTERS ////////////////////\n\n    /**\n     * @notice Returns the current Weather struct. See {AppStorage:Storage.Weather}.\n     */\n    function weather() public view returns (Storage.Weather memory) {\n        return s.w;\n    }\n\n    /**\n     * @notice Returns the current Rain struct. See {AppStorage:Storage.Rain}.\n     */\n    function rain() public view returns (Storage.Rain memory) {\n        return s.r;\n    }\n\n    /**\n     * @notice Returns the Plenty per Root for `season`.\n     */\n    function plentyPerRoot(uint32 season) external view returns (uint256) {\n        return s.sops[season];\n    }\n\n    //////////////////// WEATHER INTERNAL ////////////////////\n\n    /**\n     * @param deltaB Pre-calculated deltaB from {Oracle.stepOracle}.\n     * @dev A detailed explanation of the Weather mechanism can be found in the\n     * Beanstalk whitepaper. An explanation of state variables can be found in {AppStorage}.\n     */\n    function stepWeather(int256 deltaB) internal returns (uint256 caseId) {\n        uint256 beanSupply = C.bean().totalSupply();\n\n        // Prevent infinite pod rate\n        if (beanSupply == 0) {\n            s.w.t = 1;\n            return 8; // Reasonably low\n        }\n\n        // Calculate Pod Rate\n        Decimal.D256 memory podRate = Decimal.ratio(\n            s.f.pods.sub(s.f.harvestable), // same as totalUnharvestable()\n            beanSupply\n        );\n\n        // Calculate Delta Soil Demand\n        uint256 dsoil = s.f.beanSown;\n        s.f.beanSown = 0;\n    \n        Decimal.D256 memory deltaPodDemand;\n\n        // `s.w.thisSowTime` is set to the number of seconds in it took for \n        // Soil to sell out during the current Season. If Soil didn't sell out,\n        // it remains `type(uint32).max`.\n        if (s.w.thisSowTime < type(uint32).max) {\n            if (\n                s.w.lastSowTime == type(uint32).max || // Didn't Sow all last Season\n                s.w.thisSowTime < SOW_TIME_DEMAND_INCR || // Sow'd all instantly this Season\n                (s.w.lastSowTime > SOW_TIME_STEADY &&\n                    s.w.thisSowTime < s.w.lastSowTime.sub(SOW_TIME_STEADY)) // Sow'd all faster\n            ) {\n                deltaPodDemand = Decimal.from(1e18);\n            } else if (\n                s.w.thisSowTime <= s.w.lastSowTime.add(SOW_TIME_STEADY)\n            ) {\n                // Sow'd all in same time\n                deltaPodDemand = Decimal.one();\n            } else { \n                deltaPodDemand = Decimal.zero();\n            }\n\n            s.w.lastSowTime = s.w.thisSowTime;  // Overwrite last Season\n            s.w.thisSowTime = type(uint32).max; // Reset for next Season\n        } \n\n        // Soil didn't sell out\n        else {\n            uint256 lastDSoil = s.w.lastDSoil;\n\n            if (dsoil == 0) {\n                deltaPodDemand = Decimal.zero(); // If no one sow'd\n            } else if (lastDSoil == 0) {\n                deltaPodDemand = Decimal.from(1e18); // If no one sow'd last Season\n            } else { \n                deltaPodDemand = Decimal.ratio(dsoil, lastDSoil);\n            }\n\n            if (s.w.lastSowTime != type(uint32).max) {\n                s.w.lastSowTime = type(uint32).max;\n            }\n        }\n        \n        // Calculate Weather Case\n        caseId = 0;\n\n        // Evaluate Pod Rate\n        if (podRate.greaterThanOrEqualTo(POD_RATE_UPPER_BOUND.toDecimal())) {\n            caseId = 24;\n        } else if (podRate.greaterThanOrEqualTo(POD_RATE_OPTIMAL.toDecimal())) {\n            caseId = 16;\n        } else if (podRate.greaterThanOrEqualTo(POD_RATE_LOWER_BOUND.toDecimal())) {\n            caseId = 8;\n        }\n\n        // Evaluate Price\n        if (\n            deltaB > 0 ||\n            (deltaB == 0 && podRate.lessThanOrEqualTo(POD_RATE_OPTIMAL.toDecimal()))\n        ) {\n            caseId += 4;\n        }\n\n        // Evaluate Delta Soil Demand\n        if (deltaPodDemand.greaterThanOrEqualTo(DELTA_POD_DEMAND_UPPER_BOUND.toDecimal())) {\n            caseId += 2;\n        } else if (deltaPodDemand.greaterThanOrEqualTo(DELTA_POD_DEMAND_LOWER_BOUND.toDecimal())) {\n            caseId += 1;\n        }\n\n        s.w.lastDSoil = uint128(dsoil); // SafeCast not necessary as `s.f.beanSown` is uint128.\n        \n        changeWeather(caseId);\n        handleRain(caseId);\n    }\n\n    /**\n     * @dev Changes the current Temperature `s.w.t` based on the Weather Case.\n     */\n    function changeWeather(uint256 caseId) private {\n        int8 change = s.cases[caseId];\n        uint32 t = s.w.t;\n\n        if (change < 0) {\n            if (t <= (uint32(-change))) {\n                // if (change < 0 && t <= uint32(-change)),\n                // then 0 <= t <= type(int8).max because change is an int8.\n                // Thus, downcasting t to an int8 will not cause overflow.\n                change = 1 - int8(t);\n                s.w.t = 1;\n            } else {\n                s.w.t = t - (uint32(-change));\n            }\n        } else {\n            s.w.t = t + (uint32(change));\n        }\n\n        emit WeatherChange(s.season.current, caseId, change);\n    }\n\n    /**\n     * @dev Oversaturated was previously referred to as Raining and thus code\n     * references mentioning Rain really refer to Oversaturation. If P > 1 and the\n     * Pod Rate is less than 5%, the Farm is Oversaturated. If it is Oversaturated\n     * for a Season, each Season in which it continues to be Oversaturated, it Floods.\n     */\n    function handleRain(uint256 caseId) internal {\n        // cases 4-7 represent the case where the pod rate is less than 5% and P > 1.\n        if (caseId < 4 || caseId > 7) {\n            if (s.season.raining) {\n                s.season.raining = false;\n            }\n            return;\n        } else if (!s.season.raining) {\n            s.season.raining = true;\n            // Set the plenty per root equal to previous rain start.\n            s.sops[s.season.current] = s.sops[s.season.rainStart];\n            s.season.rainStart = s.season.current;\n            s.r.pods = s.f.pods;\n            s.r.roots = s.s.roots;\n        } else if (\n            s.season.current >= s.season.rainStart.add(s.season.withdrawSeasons - 1)\n        ) {\n            if (s.r.roots > 0) {\n                sop();\n            }\n        }\n    }\n\n    /**\n     * @dev Flood was previously called a \"Season of Plenty\" (SOP for short).\n     * When Beanstalk has been Oversaturated for a Season, Beanstalk returns the\n     * Bean price to its peg by minting additional Beans and selling them directly\n     * on Curve. Proceeds  from the sale in the form of 3CRV are distributed to\n     * Stalkholders at the beginning of a Season in proportion to their Stalk\n     * ownership when the Farm became Oversaturated. Also, at the beginning of the\n     * Flood, all Pods that were minted before the Farm became Oversaturated Ripen\n     * and become Harvestable.\n     * For more information On Oversaturation see {Weather.handleRain}.\n     */\n    function sop() private {\n        int256 newBeans = LibBeanMetaCurve.getDeltaB();\n        if (newBeans <= 0) return;\n\n        uint256 sopBeans = uint256(newBeans);\n        uint256 newHarvestable;\n\n        // Pay off remaining Pods if any exist.\n        if (s.f.harvestable < s.r.pods) {\n            newHarvestable = s.r.pods - s.f.harvestable;\n            s.f.harvestable = s.f.harvestable.add(newHarvestable);\n            C.bean().mint(address(this), newHarvestable.add(sopBeans));\n        } else {\n            C.bean().mint(address(this), sopBeans);\n        }\n\n        // Swap Beans for 3CRV.\n        uint256 amountOut = C.curveMetapool().exchange(0, 1, sopBeans, 0);\n\n        rewardSop(amountOut);\n        emit SeasonOfPlenty(s.season.current, amountOut, newHarvestable);\n    }\n\n    /**\n     * @dev Allocate 3CRV during a Season of Plenty.\n     */\n    function rewardSop(uint256 amount) private {\n        s.sops[s.season.rainStart] = s.sops[s.season.lastSop].add(\n            amount.mul(C.SOP_PRECISION).div(s.r.roots)\n        );\n        s.season.lastSop = s.season.rainStart;\n        s.season.lastSopSeason = s.season.current;\n    }\n}"
    }
  ]
}