{
  "Title": "M-12: The pool verification in `NapierRouter` is prone to collision attacks",
  "Content": "# Issue M-12: The pool verification in `NapierRouter` is prone to collision attacks \n\nSource: https://github.com/sherlock-audit/2024-01-napier-judging/issues/111 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nArabadzhiev\n## Summary\n\nUsing computed pool addresses to verify the callback function callers is collision attack prone and can be abused in order to steal all token allowances of the `NapierRouter` contract\n\n## Vulnerability Detail\n\nWith the current state of the `NapierRouter` contract implementation, both the `mintCallback` and `swapCallback` use the `_verifyCallback` function in order to verify that the address that called them is a Napier pool deployed by the `PoolFactory` attached to the router. This is done by computing the Create2 pool address using the `basePool` and `underlying` values passed in to either of the callbacks as arguments and the comparing that address to the `msg.sender`.\n\nHowever, this method of verifying the caller address is collision prone, as the computation of the Create2 address is done by truncating a 256 bit keccak256 hash to 160 bits, meaning that for each address there are 2^96 possible hashes that will result in it after being truncated. Furthermore, what this means is that if a `basePool` and `underlying` combination that results in an address controlled by a malicious user is found, all token allowances given to the `NapierRouter` contract can be stolen.\n\nIn this [article](https://mystenlabs.com/blog/ambush-attacks-on-160bit-objectids-addresses) and this [report](https://github.com/sherlock-audit/2023-07-kyber-swap-judging/issues/90) from a past Sherlock contest, it is shown that this vulnerability will likely cost a few million dollars as of today, but due to the rapid advancement in computing capabilities, it is likely that it will cost much less a few years down the line.\n\n## Impact\n\nAll token allowances of the `NapierRouter` can be stolen\n\n## Code Snippet\n\n[NapierRouter.sol#L65-L68](https://github.com/sherlock-audit/2024-01-napier/blob/main/v1-pool/src/NapierRouter.sol#L65-L68)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIn the `PoolFactory` contract, create a function that verifies that a given pool address has been deployed by it using the `_pools` mapping. Example implementation:\n\n```diff\ncontract PoolFactory is IPoolFactory, Ownable2Step {\n    ...\n    /// @notice Mapping of NapierPool to PoolAssets\n    mapping(address => PoolAssets) internal _pools;\n    ...\n+   function isFactoryDeployedPool(address poolAddress) external view returns (bool) {\n+       PoolAssets memory poolAssets = _pools[poolAddress];\n+       return (\n+           poolAssets.basePool != address(0) &&\n+           poolAssets.underlying != address(0) &&\n+           poolAssets.principalTokens.length != 0\n+       );\n    }\n}\n```\n\nAnd then use it in the `NapierRouter::_verifyCallback` function in place of the computed address comparison logic:\n\n```diff\n    function _verifyCallback(address basePool, address underlying) internal view {\n-       if (\n-           PoolAddress.computeAddress(basePool, underlying, POOL_CREATION_HASH, address(factory))\n-               != INapierPool(msg.sender)\n-       ) revert Errors.RouterCallbackNotNapierPool();\n+       if (factory.isFactoryDeployedPool(msg.sender)) revert Errors.RouterCallbackNotNapierPool();\n    }\n```\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\n> Escalate\n> \n> Invalid. Both the mentioned report requires only 2^80 computation to find a collision hash because of the birthday paradox. In this issue, the attacker needs approx 2^160 computation to find the exact match with the specific napier pool deployed.\n\nYou've deleted an escalation for this issue.\n\n**Arabadzhiew**\n\n> Escalate\n> \n> Invalid. Both the mentioned report requires only 2^80 computation to find a collision hash because of the birthday paradox. In this issue, the attacker needs approx 2^160 computation to find the exact match with the specific napier pool deployed.\n\nHow exactly did you come to that conclusion? The goal of this exploit is not to find a match with a specific Napier pool, but instead a match with an EOA controlled by the attacker. The case is the same in the mentioned report. If anything, in the case of the `NapierRouter` the collision would be theoretically more likely to happen, since here we have two address arguments (320 bits) that can be played with when trying to find а collision, while in the Kyberswap issue there is an address + uint24 (184 bits).\n\n**Coareal**\n\n > How exactly did you come to that conclusion? The goal of this exploit is not to find a match with a specific Napier pool, but instead a match with an EOA controlled by the attacker. The case is the same in the mentioned report. If anything, in the case of the `NapierRouter` the collision would be theoretically more likely to happen, since here we have two address arguments (320 bits) that can be played with when trying to find а collision, while in the Kyberswap issue there is an address + uint24 (184 bits).\n\nRemoved escalation. Agree that issue is similar to Kyberswap's.\n\n**nevillehuang**\n\nEscalate\n\nHow would the allowances be stolen here? Wouldn’t a user be only approving specified PT amounts wherein every swap will consume the approval, thus making this attack not profitable?\n\nAdditionally, This issue seems to lack a further description/explanation of the attack vector specific to napier as opposed to the linked issue:\n\n> token0 can be constant and we can achieve the variation in the hash by changing token1. The attacker could use token0 = WETH and vary token1. This would allow them to steal all allowances of WETH.\n\nPerhaps the watsons @Arabadzhiew @xiaoming9090 can clarify better\n\n**sherlock-admin2**\n\n> Escalate\n> \n> How would the allowances be stolen here? Wouldn’t a user be only approving specified PT amounts wherein every swap will consume the approval, thus making this attack not profitable?\n> \n> Additionally, This issue seems to lack a further description/explanation of the attack vector specific to napier as opposed to the linked issue:\n> \n> > token0 can be constant and we can achieve the variation in the hash by changing token1. The attacker could use token0 = WETH and vary token1. This would allow them to steal all allowances of WETH.\n> \n> Perhaps the watsons @Arabadzhiew @xiaoming9090 can clarify better\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Arabadzhiew**\n\n> Escalate\n> \n> How would the allowances be stolen here? Wouldn’t a user be only approving specified PT amounts wherein every swap will consume the approval, thus making this attack not profitable?\n> \n> Additionally, This issue seems to lack a further description/explanation of the attack vector specific to napier as opposed to the linked issue:\n> \n> > token0 can be constant and we can achieve the variation in the hash by changing token1. The attacker could use token0 = WETH and vary token1. This would allow them to steal all allowances of WETH.\n> \n> Perhaps the watsons @Arabadzhiew @xiaoming9090 can clarify better\n\nMost of the users that will perform more than 1 swap with a specific token using the router will simply give max approval to it. This is because:\n1. It saves gas by not having to make a separate approve call for each swap;\n2. By default, this is what you are prompted to do by Metamask when you are required to give token allowance to some dapp;\n\nAdditionally, I have only given a high level overview of the issue, since it is very similar to the one reported in the Kyberswap contest, and I thought that a more in-depth explanation would simply be redundant. But since you are asking about it, I'm going  to provide a short explanation on one of the ways of how this vulnerability can be exploited in the context of Napier:\n\nTaking the `NapierRouter::swapCallback` function:\n\n```solidity\n    function swapCallback(int256 underlyingDelta, int256 ptDelta, bytes calldata data) external override {\n        // `data` is encoded as follows:\n        // [0x00: 0x20] CallbackType (uint8)\n        // [0x20: 0x40] Underlying (address)\n        // [0x40: 0x60] BasePool (address)\n        // [0x60:  ~  ] Custom data (based on CallbackType)\n        (address underlying, address basePool) = abi.decode(data[0x20:0x60], (address, address));\n        _verifyCallback(basePool, underlying);\n\n        CallbackType _type = CallbackDataTypes.getCallbackType(data);\n\n        if (_type == CallbackType.SwapPtForUnderlying) {\n            CallbackDataTypes.SwapPtForUnderlyingData memory params =\n                abi.decode(data[0x60:], (CallbackDataTypes.SwapPtForUnderlyingData));\n            params.pt.safeTransferFrom(params.payer, msg.sender, uint256(-ptDelta));\n        ...\n    }\n```\n\nAs it can be seen in this snippet, the `basePool` and `underlying` values are only used for the pool address verification. Furthermore, we can see that in the first `if` block of the function there is a single `safeTransferFrom` call that sends a concrete **amount** of a concrete **token** from a concrete **address** to the  `msg.sender`. All the values in bold are passed in as function arguments and are not used for the CREATE2 pool address computation. What we can conclude from this is that if someone manages to find a combination of `basePool` and `underlying` that passes the `_verifyCallback` check for their EOA, then they can easily steal all of the token allowances given to the router contract.   \n\n**0xMR0**\n\n`msg.sender` is already being validated as napier pool address.\n\n```solidity\n    /// @dev Revert if `msg.sender` is not a Napier pool.\n    function _verifyCallback(address basePool, address underlying) internal view {\n        if (\n            PoolAddress.computeAddress(basePool, underlying, POOL_CREATION_HASH, address(factory))\n                != INapierPool(msg.sender)\n        ) revert Errors.RouterCallbackNotNapierPool();\n    }\n```\n\nIt would revert for non-existent napier pool address. How the recommendation is different from the above check?\n\n**Arabadzhiew**\n\n@0xMR0 Quoting what is stated in my report:\n\n>However, this method of verifying the caller address is collision prone, as the computation of the Create2 address is done by truncating a 256 bit keccak256 hash to 160 bits, meaning that for each address there are 2^96 possible hashes that will result in it after being truncated. Furthermore, what this means is that if a basePool and underlying combination that results in an address controlled by a malicious user is found, all token allowances given to the NapierRouter contract can be stolen.\n\nAdditionally, the recommendation is different from the current approach of verification in that, it will verify whether the `msg.sender` is a legit Nepier pool by checking that it was deployed by the `PoolFactory` rather than comparing it to a computed Create2 address, which is collision prone.\n\nPlease read the full report and the resources attached to it in order to gain a deeper understanding of the vulnerability in question. \n\n\n**massun-onibakuchi**\n\nI think CREATE2 with Factory pattern can be found in well-known UniswapV3, and I believe Uniswap v3 don't need to fix it because the issue seems to be mostly impossible to happen in reality. Therefore, this issue should be considered as a low or non-issue.\nReferences:\nhttps://github.com/Uniswap/v3-periphery/blob/main/contracts/SwapRouter.sol#L65\nhttps://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/CallbackValidation.sol#L21\n\nAlso, the attack cost makes a strong external condition, which requires a very big upfront cost with no certainty on pay out as attacker.\n\n**nevillehuang**\n\nTo keep consistency of results, I think this issue should remain valid, but I am keeping my escalation up for @Czar102 to revisit this type of issues. I believe based on sponsor comments [here](https://github.com/sherlock-audit/2024-01-napier-judging/issues/111#issuecomment-1986784248) and the assumption that all users make max approvals towards the router, this type of issues should have a better sherlock rule catering to this and/or make known to sponsors to be aware as a known accepted risk.\n\n**Arabadzhiew**\n\nThe reason why such a vulnerability has not been exploited in the wild yet is that as @massun-onibakuchi mentioned, the attack requires a big upfront cost as of today. However, given the fact that `NapierRouter` is an immutable contract and taking into consideration the rapid advancement of computing capabilities (the Bitcoin hashrate alone has almost doubled since the Kyberswap issue was reported - it has raised from 4.71e20 to 7.68e20), we can see how this exploit might become much more profitable and very realistically feasible in the not so distant future. And as of now, the Sherlock rulebook does not have a fixed timeline within which an issue must occur, in order for it to be considered valid.\n\nAlso, the allowances that are going to be given to the contract are not an assumption, but rather a \"fact of life\" for such kind of contracts. Pretty much all DEX router contracts have token allowances in the magnitudes of millions of dollars. And that is because understandably, nobody wants to pay extra gas fees when possible.\n\nOn a final note, in the particular case of the `NapierRouter` **all** token allowances given to it can be stolen with a single address collision, while in the case of the Kyberswap issue, a separate collision has to be found for each token. That is because the CREATE2 addresses of the Napier pools are not computed based on all token addresses used within them.\n\nI will refrain from commenting on this issue any further. I believe that enough has been said in order for the Head of Judging to be able to make an informed decision.\n\n\n\n\n**xiaoming9090**\n\nA note to the judges. The risk profile of this issue is the same as the Arcadia's Contest (https://github.com/sherlock-audit/2023-12-arcadia-judging/issues/59). Thus, the risk rating of this issue should be aligned for consistency. Thanks.\n\n**cvetanovv**\n\nThis issue should remain Medium. The report is similar to the Arcadia contest from a few weeks ago. It wouldn't be fair for it to be Low here. However, I suggest that Sherlock include it in the documentation as a known issue in the future.\n\n**Czar102**\n\nTo exploit this, an attacker would need to find a collision between an owned address and a potentially deployed pool (if there is less than 10^12 pools deployed then the attack is definitely unfeasible). So, the attacker needs to make the owner deploy a pool. The attacker needs to be the owner.\n\nThe issue by itself is a borderline Med/Low, so I believe, considering this additional constraint needed to execute it, this issue should be of Low severity.\n\nPlease correct me if I'm understanding something wrongly.\n\n**Arabadzhiew**\n\n@Czar102 There doesn't have to be a deployed pool at the given address. The goal of the exploit is to find a combination of the `basePool` and `underlying` values that results in an address that is equal to an EOA controlled by the malicious user. Then, that user will be able to call any one of the two callbacks through that EOA and steal the token allowances given to the router contract.\n\n**Czar102**\n\n@Arabadzhiew indeed, thank you for correcting me!\n\nI'm planning to reject the escalation and leave this a valid Medium severity issue.\n\n**Czar102**\n\nOn second thoughts, @Arabadzhiew can you elaborate how much computation needs to be done having ~2^50 memory available?\n\nIf an algorithm for finding this collision is not provided, I'm planning to invalidate this finding, similarly to findings that do not describe the algorithm in the future. (full feasibility analysis should have been done)\n\n**Arabadzhiew**\n\nUsing the so-called \"naive\" collision finding algorithm, which is the one in question in all of the resources I have attached to my report requires at least 2^80 of storage available. And because that is an enormous amount as of today's standards, this is the biggest bottleneck of this exploit. What this essentially means is that with 2^50 of memory, the exploit will be practically impossible to execute using this algorithm.\n\nTo show how much more computation will have to be made with this amount of memory, let's look at some math. I'm going to use the following formula to calculate the hash collision probabilities:\n\n$$ k^2 \\over 2N $$\n\nWhere **k** is the number of computed hashes and **N** is the total number of possible hashes (2^160 in our case).\n\nYou can read more about it [here](https://preshing.com/20110504/hash-collision-probabilities/), but essentially, it is a very simplified version of a more complex hash collision probability formula, that works well with very big numbers. This is the least accurate formula from all of the mentioned ones in the article, but it is the only one that will return a probability value that is different from 0 with such a low **k** value being passed in to it.\n\nSo for the scenario where we have 2^50 of memory available, we will first generate 2^50 public addresses, store those in our memory and then compute another set of 2^50 different pool addresses (by using different `basePool` and `underlying` values for each one). In that case, we will have **k = 2^51**. The output that we will get for this value from the above formula is the following: **1.7347235e-18** - a very small decimal value. This is our probability value between 0 and 1, where 0 = 0% probability and 1 = 100% probability. So to get how many times we will have to make 2^50 computations in order to have ~100% probability of collision, we have to divide 1 by that value. This results in the following value: **5.7646075e+17** which is exactly equal to 2^59. What we can derive from that is that to have approximately 100% probability of finding a collision in a 160 bit space, with only 2^50 of memory available, we will have to perform **2^50 * 2^59 = 2^109** computations. Obviously, this is a massive amount of computations. To put into perspective how big it actually is, if we had the full Bitcoin computation power at the hashrate of 7.68e20, it would take us **26797.9 years** to make this many computations.\n\nOn the other hand though, if we had 2^80 of memory available, then the probability values will look completely differently. We will perform the exact same procedure as above, but this time we will generate two sets of 2^80 addresses. So our value of **k** will be equal to **2^81** this time around. And because that value is much bigger than 2^51, it allows us to use the other more accurate formulas. I will be using the following formula for this probability calculation, which is simply a more accurate version of the one used above:\n\n$$ 1 - e ^ {-k(k-1) \\over 2N } $$\n\nThe output that we get from that formula is **0.86466471676** which represents **~86.46%** chance of collision for the computation of 2^81 addresses. That is much better than than the previous example. And if we bump up our computations to 2^82, then we will get **0.99966453737** as an output, which represents **~99.96** chance of collision for that many computations. And for the sake of comparison, 2^81 computations can be performed in **0.87** hours by the Bitcoin network at the hashrate of 7.68e20 and 2^82 in **1.74** hours.\n\nOn a final note, I'd like to mention once again that this is the simplest form of a hash collision finding algorithm, which does not make use of any memory saving optimizations. There are potential ways to bring down the amount of memory required for performing it, such as using bloom filters as mentioned in [this comment](https://github.com/sherlock-audit/2023-07-kyber-swap-judging/issues/90#issuecomment-1750097871) under the Kyberswap issue, so I'm sure that with time we will see more and more feasible implementations of that algorithm.\n\n@Czar102 I hope this clarifies things further.\n\n\n\n**Czar102**\n\n> On a final note, I'd like to mention once again that this is the simplest form of a hash collision finding algorithm, which does not make use of any memory saving optimizations. There are potential ways to bring down the amount of memory required for performing it, such as using bloom filters as mentioned in [this comment](https://github.com/sherlock-audit/2023-07-kyber-swap-judging/issues/90#issuecomment-1750097871) under the Kyberswap issue, so I'm sure that with time we will see more and more feasible implementations of that algorithm.\n\nUnless these optimizations are shared, I believe address collision to be a non-issue. Bloom filter can optimize storage down to 1 bit, but I don't think it's possible to go much further based on information-theoretic limitations: when a function $`f: \\;\\mathbb{B}^{20}\\rightarrow \\{ 0, 1\\}`$ (describing whether a hash was already yielded) has at most $2^{2^{50}}$ configurations, the \"expected value of information\" about any random hash can't be larger than $2^{-110}$, even with fractional information (probabilistic approaches).\n\nOf course, my rough understanding may be wrong, so I'm open to having my mind changed. For now, this attack seems to be impossible to carry out. Hence, I'm planning to invalidate this finding.\n\n**midori-fuse**\n\nAs the submitter of the same issue in Arcadia, this conversation has been quite helpful, and we'd like to share our thoughts.\n\nWhen we investigated the issue in Arcadia, we only really thought of the time complexity of $O(2^{N/2})$, which is possible, but not the memory complexity, which is indeed impossible as of now. The head of judging's question made us realize the additional constraint, and we apologize for not realizing it earlier during the Arcadia contest.\n\nHowever, as the head of judging stated himself in the Sherlock discord, I do believe the continuous development of available resources and what's at stake makes this issue worth mitigating. This is the kind of issue that's of critical impact if were to happen, and while it's impossible as of now, there's no telling *when* it will be possible in the future.\n\nHence, while I believe this issue is true, I don't have opinions about its severity. What I would consider is what are the odds it becomes realistic in the lifetime of this protocol, not just at this current moment. \n- In other words we're betting on how much can the storage problem can be solved, and how much funds are still at stake by then. This is also one of the discussion points from the Kyber issue.\n\nI do believe, however, that it's the responsibility of the issue author to outline the constraints related to the attack, and these kind of issues will likely need a revisit in the future given technological advancements.\n\n**Arabadzhiew**\n\nAfter doing some further research on the topic, I came across [this paper](https://hackmd.io/Vzhp5YJyTT-LhWm_s0JQpA), which describes a much more sophisticated collision finding algorithm. It requires 160 Terabytes (~2^47) of memory and 2^92 computations. Now, in my eyes, this looks like a much more feasible implementation. The number of computations is quite a bit higher, but it is still well within the realm of feasibility. Using the analogy that I've used above, the Bitcoin network will need ~0.2 years at the hashrate of 7.68e20 to make that many computations.\n\nThe thing is, if someone decides to try and perform this exploit in the future, they won't be targeting a single protocol. They will be targeting as much protocols as they possibly can. So the more protocols there are with this vulnerability in them, the more likely it will be that this gets exploited. \n\n**Czar102**\n\n> The thing is, if someone decides to try and perform this exploit in the future, they won't be targeting a single protocol. They will be targeting as much protocols as they possibly can. So the more protocols there are with this vulnerability in them, the more likely it will be that this gets exploited.\n\nI don't think that's true given the memory complexity of this attack.\n\nNevertheless, the linked paper does present a way to optimize the memory complexity beyond the approach outlined in the previous comments.\nA large ($2^{11}$) multiplier in the above example is due to the increased difficulty of computing the elliptic point operations, which isn't needed in this attack – the attacker can simply deploy a wallet controlled by them using CREATE2.\nThis will make the computational complexity of around $2^{81}$ and would require giga-terabytes of memory, which means this attack is possible to execute with ~34 minutes of the current Bitcoin's hashrate, assuming keccak256 is as easy to calculate as SHA-2. The current cost of this attack would be less than $1.5m with the current prices. This, of course, doesn't take into account the fact that keccak256 mining is a niche field, so the extent of cost optimization is much worse.\n\nI'd also like @midori-fuse to sign off on my reasoning – would you agree that it's possible to execute this attack?\n\nI think this finding was correctly judged as a Medium severity one.\n\n**midori-fuse**\n\nThis is a really cool algorithm. Massive kudos to @Arabadzhiew for finding this paper. \n\nIndeed that since we're looking for a contract-contract collision and not an EOA-contract collision, no EC multiplication is needed, making $f_1$ and $f_2$ purely keccak256 just with different inputs, and the cost of the attack is about $2^{81}$ calls to $f$ (which is, again, just keccak256).\n\nSince both functions are of the same weight now, we can set $m = \\frac{1}{\\theta} = 2^{40}$ and achieve the same execution time, but with $\\sim 16$ times lower processor count and memory cost than outlined. Of course, the real attack time would take longer depending on how many parallel processes you have, but taking 0.02% of this power for 5000x the duration (while also lowering the memory cost by 5000x) and it's still not unrealistically long. The total number of hashing calls across all processors is the same, so the attack cost is the same as outlined. \n\nUnder the assumption that a standard computer can perform $2^{30}$ operations per second which is reasonable, @Czar102 's calculation is on point. Taking technological advancements into consideration, the computing power here does not have to be solely keccak256 mining, but also overall processor improvements as well.\n\n**nevillehuang**\n\nMaybe off topic and not relevant to finding but Curious why nobody tried to exploit uniswapv3\n\n**Czar102**\n\n@nevillehuang probably because you would need to create your own ASIC just for this (millions) or pay a quarter billion dollars for many, many GPU-hours.\n\n**nevillehuang**\n\n@Czar102 Surely its worth it for say a 400+ million USDC/ETH univ3 pool right?\n\n**Czar102**\n\nResult:\nMedium\nUnique\n\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [nevillehuang](https://github.com/sherlock-audit/2024-01-napier-judging/issues/111/#issuecomment-1984957406): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/171",
  "Code": [
    {
      "filename": "v1-pool/src/NapierRouter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\n// external interfaces\nimport {IERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/IERC20.sol\";\nimport {IWETH9} from \"./interfaces/external/IWETH9.sol\";\nimport {CurveTricryptoOptimizedWETH} from \"./interfaces/external/CurveTricryptoOptimizedWETH.sol\";\nimport {ITranche} from \"@napier/napier-v1/src/interfaces/ITranche.sol\";\nimport {IBaseAdapter} from \"@napier/napier-v1/src/interfaces/IBaseAdapter.sol\";\nimport {INapierPool} from \"./interfaces/INapierPool.sol\";\nimport {IPoolFactory} from \"./interfaces/IPoolFactory.sol\";\n// implements\nimport {INapierRouter} from \"./interfaces/INapierRouter.sol\";\nimport {INapierMintCallback} from \"./interfaces/INapierMintCallback.sol\";\nimport {INapierSwapCallback} from \"./interfaces/INapierSwapCallback.sol\";\n\n// libraries\nimport {SafeERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/utils/SafeERC20.sol\";\nimport {CallbackDataTypes, CallbackType} from \"./libs/CallbackDataTypes.sol\";\nimport {PoolAddress} from \"./libs/PoolAddress.sol\";\nimport {MAX_BPS} from \"@napier/napier-v1/src/Constants.sol\";\nimport {Errors} from \"./libs/Errors.sol\";\n\n// inherits\nimport {PeripheryImmutableState} from \"./base/PeripheryImmutableState.sol\";\nimport {PeripheryPayments} from \"./base/PeripheryPayments.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts@4.9.3/security/ReentrancyGuard.sol\";\nimport {Multicallable} from \"./base/Multicallable.sol\";\n\n/// @notice Router for Napier pools\n/// @dev This contract provides a single entry point for Napier pools. Accepts native ETH.\n/// @dev Multicallable is used to batch multiple operations. E.g. Swap Principal Tokens for WETH and unwrap WETH to ETH with a single transaction.\n/// See each function for more details.\ncontract NapierRouter is\n    INapierRouter,\n    INapierSwapCallback,\n    INapierMintCallback,\n    PeripheryPayments,\n    ReentrancyGuard,\n    Multicallable\n{\n    using SafeERC20 for IERC20;\n    using SafeERC20 for ITranche;\n\n    /// @notice Napier Pool Factory\n    /// @dev pool passed as functions parameter must be deployed by this factory\n    IPoolFactory public immutable factory;\n\n    bytes32 internal immutable POOL_CREATION_HASH;\n\n    /// @notice If the transaction is too old, revert.\n    /// @param deadline Transaction deadline in unix timestamp\n    modifier checkDeadline(uint256 deadline) {\n        if (block.timestamp > deadline) revert Errors.RouterTransactionTooOld();\n        _;\n    }\n\n    constructor(IPoolFactory _factory, IWETH9 _WETH9) PeripheryImmutableState(_WETH9) {\n        factory = _factory;\n        POOL_CREATION_HASH = _factory.POOL_CREATION_HASH();\n    }\n\n    /// @dev Revert if `msg.sender` is not a Napier pool.\n    function _verifyCallback(address basePool, address underlying) internal view {\n        if (\n            PoolAddress.computeAddress(basePool, underlying, POOL_CREATION_HASH, address(factory))\n                != INapierPool(msg.sender)\n        ) revert Errors.RouterCallbackNotNapierPool();\n    }\n\n    function mintCallback(uint256 underlyingDelta, uint256 baseLptDelta, bytes calldata data) external override {\n        // `data` is encoded as follows:\n        // [0x00: 0x20] CallbackType (uint8)\n        // [0x20:  ~  ] Custom data (based on CallbackType)\n        CallbackDataTypes.AddLiquidityData memory params = abi.decode(data[0x20:], (CallbackDataTypes.AddLiquidityData));\n        _verifyCallback(params.basePool, params.underlying);\n\n        // In all addLiquidity functions of router, underlying tokens are saved in payer and baseLpTokens are saved in router.\n        // So in this callback function, we don't need to get CallbackTypes.\n        // If this contract holds enough ETH, wrap it. Otherwise, transfer from the caller.\n        _pay(params.underlying, params.payer, msg.sender, underlyingDelta);\n        IERC20(params.basePool).safeTransfer(msg.sender, baseLptDelta);\n    }\n\n    function swapCallback(int256 underlyingDelta, int256 ptDelta, bytes calldata data) external override {\n        // `data` is encoded as follows:\n        // [0x00: 0x20] CallbackType (uint8)\n        // [0x20: 0x40] Underlying (address)\n        // [0x40: 0x60] BasePool (address)\n        // [0x60:  ~  ] Custom data (based on CallbackType)\n        (address underlying, address basePool) = abi.decode(data[0x20:0x60], (address, address));\n        _verifyCallback(basePool, underlying);\n\n        CallbackType _type = CallbackDataTypes.getCallbackType(data);\n\n        if (_type == CallbackType.SwapPtForUnderlying) {\n            CallbackDataTypes.SwapPtForUnderlyingData memory params =\n                abi.decode(data[0x60:], (CallbackDataTypes.SwapPtForUnderlyingData));\n            params.pt.safeTransferFrom(params.payer, msg.sender, uint256(-ptDelta));\n        } else if (_type == CallbackType.SwapUnderlyingForPt) {\n            // Decode callback data\n            CallbackDataTypes.SwapUnderlyingForPtData memory params =\n                abi.decode(data[0x60:], (CallbackDataTypes.SwapUnderlyingForPtData));\n\n            // Check slippage. Revert if exceeded max underlying in\n            if (uint256(-underlyingDelta) > params.underlyingInMax) revert Errors.RouterExceededLimitUnderlyingIn();\n            _pay(underlying, params.payer, msg.sender, uint256(-underlyingDelta));\n        } else if (_type == CallbackType.SwapYtForUnderlying) {\n            // Decode callback data\n            CallbackDataTypes.SwapYtForUnderlyingData memory params =\n                abi.decode(data[0x60:], (CallbackDataTypes.SwapYtForUnderlyingData));\n\n            uint256 uRepay = uint256(-underlyingDelta); // unsafe cast is okay because always negative in this branch\n            uint256 pyRedeem; // amount of PT (YT) to be redeemed\n            // Assign the minimum amount of (ytIn, ptDelta) to `pyRedeem`\n            if (params.ytIn >= uint256(ptDelta)) {\n                // If the actual amount of PT received is less than the requested amount, use the actual amount\n                pyRedeem = uint256(ptDelta);\n            } else {\n                pyRedeem = params.ytIn;\n                // Surplus of `ptDelta` - `params.ytIn` should be refunded to the payer\n                // no underflow because of the if statement above\n                IERC20(params.pt).safeTransfer(params.payer, uint256(ptDelta) - params.ytIn); // non-zero\n            }\n\n            // Transfer YT from caller to this contract\n            IERC20(params.pt.yieldToken()).safeTransferFrom(params.payer, address(this), pyRedeem);\n\n            // Optimistically redeem any amount of PT and YT for underlying\n            // Later, we will check if the amount of underlying redeemed is enough to cover the underlying to be repaid\n            uint256 uRedeemed = params.pt.redeemWithYT({\n                pyAmount: pyRedeem,\n                to: address(this),\n                from: address(this) // At this point, the YT is already in this contract\n            });\n            if (uRedeemed < uRepay) revert Errors.RouterInsufficientUnderlyingRepay();\n            // Check slippage\n            uint256 underlyingToRecipient = uRedeemed - uRepay; // no underflow because of the if statement above\n            if (underlyingToRecipient < params.underlyingOutMin) revert Errors.RouterInsufficientUnderlyingOut();\n\n            // Repay underlying to Napier pool and transfer the rest to recipient\n            IERC20(underlying).safeTransfer(msg.sender, uRepay);\n            IERC20(underlying).safeTransfer(params.recipient, underlyingToRecipient);\n        } else if (_type == CallbackType.SwapUnderlyingForYt) {\n            // Decode callback data\n            CallbackDataTypes.SwapUnderlyingForYtData memory params =\n                abi.decode(data[0x60:], (CallbackDataTypes.SwapUnderlyingForYtData));\n\n            uint256 uReceived = uint256(underlyingDelta); // unsafe cast is okay because always positive in this branch.\n            uint256 pyDesired = uint256(-ptDelta); // principal token to be repaid and yield token to be issued\n\n            // Pull underlying from payer.\n            // Economically, it's almost unlikely that the payer doesn't need to pay underlying asset.\n            // But if the above case happens, it would be reverted.\n            if (params.underlyingDeposit <= uReceived) revert Errors.RouterNonSituationSwapUnderlyingForYt();\n            uint256 uPull = params.underlyingDeposit - uReceived;\n            if (uPull > params.maxUnderlyingPull) revert Errors.RouterExceededLimitUnderlyingIn();\n            _pay(underlying, params.payer, address(this), uPull);\n\n            IERC20(underlying).forceApprove(address(params.pt), params.underlyingDeposit);\n            uint256 pyIssued = params.pt.issue({to: address(this), underlyingAmount: params.underlyingDeposit});\n\n            // Repay the PT to Napier pool\n            if (pyIssued < pyDesired) revert Errors.RouterInsufficientPtRepay();\n            params.pt.safeTransfer(msg.sender, pyDesired);\n            // Transfer the remaining PT to payer\n            params.pt.safeTransfer(params.payer, pyIssued - pyDesired);\n            // Transfer the YT to recipient\n            params.yt.safeTransfer(params.recipient, pyIssued);\n        }\n    }\n\n    /// @inheritdoc INapierRouter\n    /// @notice Swap exact amount of Principal Token (PT) for Underlying.\n    /// @notice Caller must approve the router to spend PTs prior to calling this method.\n    /// @notice Revert if the pool is not deployed by the factory set in the constructor.\n    /// @notice Revert if maturity has passed for the pool.\n    /// @notice Revert if deadline has passed.\n    /// @notice Revert if the amount of underlying asset received is less than the minimum amount specified.\n    /// @param pool The address of the pool.\n    /// @param index The index of the PT. (0, 1, 2)\n    /// @param ptInDesired The amount of PT to swap.\n    /// @param underlyingOutMin The minimum amount of underlying asset to receive.\n    /// @param recipient The recipient of the swapped underlying asset.\n    /// @param deadline The deadline for the swap.\n    /// @return The amount of underlying asset received.\n    function swapPtForUnderlying(\n        address pool,\n        uint256 index,\n        uint256 ptInDesired,\n        uint256 underlyingOutMin,\n        address recipient,\n        uint256 deadline\n    ) external override nonReentrant checkDeadline(deadline) returns (uint256) {\n        // dev: Optimistically call to the `pool` provided by the untrusted caller.\n        // And then verify the pool using CREATE2.\n        (address underlying, address basePool) = INapierPool(pool).getAssets();\n\n        // if `pool` doesn't matched, it would be reverted.\n        if (INapierPool(pool) != PoolAddress.computeAddress(basePool, underlying, POOL_CREATION_HASH, address(factory)))\n        {\n            revert Errors.RouterPoolNotFound();\n        }\n\n        address pt = address(INapierPool(pool).principalTokens()[index]);\n\n        // Abi encode callback data to be used in swapCallback\n        bytes memory data = new bytes(0xa0);\n\n        uint256 callbackType = uint256(CallbackType.SwapPtForUnderlying);\n        assembly {\n            // Equivanlent to:\n            // data = abi.encode(CallbackType.SwapUnderlyingForPt, underlying, basePool, CallbackDataTypes.SwapUnderlyingForPtData({payer: msg.sender, underlyingInMax: underlyingInMax}))\n            mstore(add(data, 0x20), callbackType)\n            mstore(add(data, 0x40), underlying)\n            mstore(add(data, 0x60), basePool)\n            mstore(add(data, 0x80), caller()) // dev: Ensure 'payer' is always 'msg.sender' to prevent allowance theft on callback.\n            mstore(add(data, 0xa0), pt)\n        }\n        uint256 underlyingOut = INapierPool(pool).swapPtForUnderlying(index, ptInDesired, recipient, data);\n        if (underlyingOut < underlyingOutMin) revert Errors.RouterInsufficientUnderlyingOut();\n\n        return underlyingOut;\n    }\n\n    /// @inheritdoc INapierRouter\n    /// @notice Swap underlying for PT.\n    /// @notice Caller must approve the router to spend underlying asset prior to calling this method.\n    /// @dev If caller calls with ether, the ether will be wrapped to WETH9.\n    /// Note: the remaining ether is NOT returned automatically. Caller must call refundETH to get the remaining ether back.\n    /// @dev Revert conditions are the same as swapPtForUnderlying.\n    /// @param pool The address of the pool.\n    /// @param index The index of the PT.\n    /// @param ptOutDesired The amount of PT to receive.\n    /// @param underlyingInMax The maximum amount of underlying asset to spend.\n    /// @param recipient The recipient of the PT.\n    /// @param deadline The deadline for the swap.\n    /// @return The amount of underlying asset spent.\n    function swapUnderlyingForPt(\n        address pool,\n        uint256 index,\n        uint256 ptOutDesired,\n        uint256 underlyingInMax,\n        address recipient,\n        uint256 deadline\n    ) external payable override nonReentrant checkDeadline(deadline) returns (uint256) {\n        // dev: Optimistically call to the `pool` provided by the untrusted caller.\n        // And then verify the pool using CREATE2.\n        (address underlying, address basePool) = INapierPool(pool).getAssets();\n\n        // if `pool` doesn't matched, it would be reverted.\n        if (INapierPool(pool) != PoolAddress.computeAddress(basePool, underlying, POOL_CREATION_HASH, address(factory)))\n        {\n            revert Errors.RouterPoolNotFound();\n        }\n\n        IERC20 pt = INapierPool(pool).principalTokens()[index];\n\n        // Abi encode callback data to be used in swapCallback\n        bytes memory data = new bytes(0xa0);\n        {\n            uint256 callbackType = uint256(CallbackType.SwapUnderlyingForPt);\n            assembly {\n                // Equivanlent to:\n                // data = abi.encode(CallbackType.SwapUnderlyingForPt, underlying, basePool, CallbackDataTypes.SwapUnderlyingForPtData({payer: msg.sender, underlyingInMax: underlyingInMax}))\n                mstore(add(data, 0x20), callbackType)\n                mstore(add(data, 0x40), underlying)\n                mstore(add(data, 0x60), basePool)\n                mstore(add(data, 0x80), caller()) // dev: Ensure 'payer' is always 'msg.sender' to prevent allowance theft on callback.\n                mstore(add(data, 0xa0), underlyingInMax)\n            }\n        }\n\n        uint256 prevBalance = pt.balanceOf(address(this));\n        uint256 underlyingUsed = INapierPool(pool).swapUnderlyingForPt(\n            index,\n            ptOutDesired,\n            address(this), // this contract will receive principal token from pool\n            data\n        );\n\n        pt.safeTransfer(recipient, pt.balanceOf(address(this)) - prevBalance);\n        return underlyingUsed;\n    }\n\n    /// @inheritdoc INapierRouter\n    /// @notice Swap underlying asset for YT.\n    /// @dev Under the hood, Router receives underlying asset from `pool` with flash swap and issues PT and YT.\n    /// After that, pay back the PT to `pool` and transfer the issued YT to `recipient`.\n    /// @param pool The address of the pool.\n    /// @param index The index of principal token / yield token.\n    /// @param ytOutDesired The amount of YT to receive. (at least `ytOutDesired` amount of PT and YT should be issued)\n    /// @param underlyingInMax The maximum amount of underlying asset to spend.\n    /// @param recipient The recipient of the YT.\n    /// @param deadline The deadline for the swap.\n    /// @return The amount of underlying asset recipient spent.\n    function swapUnderlyingForYt(\n        address pool,\n        uint256 index,\n        uint256 ytOutDesired,\n        uint256 underlyingInMax,\n        address recipient,\n        uint256 deadline\n    ) external payable override nonReentrant checkDeadline(deadline) returns (uint256) {\n        // dev: Optimistically call to the `pool` provided by the untrusted caller.\n        // And then verify the pool using CREATE2.\n        (address underlying, address basePool) = INapierPool(pool).getAssets();\n\n        // if `pool` doesn't matched, it would be reverted.\n        if (INapierPool(pool) != PoolAddress.computeAddress(basePool, underlying, POOL_CREATION_HASH, address(factory)))\n        {\n            revert Errors.RouterPoolNotFound();\n        }\n\n        ITranche pt = ITranche(address(INapierPool(pool).principalTokens()[index]));\n\n        uint256 uDeposit; // underlying asset to be deposited to Tranche\n        {\n            // This section of code aims to calculate the amount of underlying asset (`uDeposit`) required to issue a specific amount of PT and YT (`ytOutDesired`).\n            // The calculations are based on the formula used in the `Tranche.issue` function.\n\n            ITranche.Series memory series = pt.getSeries();\n\n            // Update maxscale if current scale is greater than maxscale\n            uint256 maxscale = series.maxscale;\n            uint256 cscale = IBaseAdapter(series.adapter).scale();\n            if (cscale > maxscale) {\n                maxscale = cscale;\n            }\n            // Variable Definitions:\n            // - `uDeposit`: The amount of underlying asset that needs to be deposited to issue PT and YT.\n            // - `ytOutDesired`: The desired amount of PT and YT to be issued.\n            // - `cscale`: Current scale of the Tranche.\n            // - `maxscale`: Maximum scale of the Tranche (denoted as 'S' in the formula).\n            // - `issuanceFee`: Issuance fee in basis points. (10000 =100%).\n\n            // Formula for `Tranche.issue`:\n            // ```\n            // shares = uDeposit / s\n            // fee = shares * issuanceFeeBps / 10000\n            // pyIssue = (shares - fee) * S\n            // ```\n\n            // Solving for `uDeposit`:\n            // ```\n            // uDeposit = (pyIssue * s / S) / (1 - issuanceFeeBps / 10000)\n            // ```\n            // Hack:\n            // Buffer is added to the denominator.\n            // This ensures that at least `ytOutDesired` amount of PT and YT are issued.\n            // If maximum scale and current scale are significantly different or `ytOutDesired` is small, the function might fail.\n            // Without this buffer, any rounding errors that reduce the issued PT and YT could lead to an insufficient amount of PT to be repaid to the pool.\n            uint256 uDepositNoFee = cscale * ytOutDesired / maxscale;\n            uDeposit = uDepositNoFee * MAX_BPS / (MAX_BPS - (series.issuanceFee + 1)); // 0.01 bps buffer\n        }\n\n        // Abi encode callback data to be used in swapCallback\n        bytes memory data = new bytes(0x120);\n        {\n            uint256 callbackType = uint256(CallbackType.SwapUnderlyingForYt);\n            address yt = pt.yieldToken();\n            assembly {\n                // Equivanlent to:\n                // abi.encode(CallbackType.SwapUnderlyingForYt, underlying, basePool, CallbackDataTypes.SwapUnderlyingForYtData({pt: pt, yt: yt, payer: msg.sender, recipient: recipient, underlyingDeposit: uDeposit, maxUnderlyingPull: underlyingInMax}))\n                mstore(add(data, 0x20), callbackType)\n                mstore(add(data, 0x40), underlying)\n                mstore(add(data, 0x60), basePool)\n                mstore(add(data, 0x80), caller()) // dev: Ensure 'payer' is always 'msg.sender' to prevent allowance theft on callback.\n                mstore(add(data, 0xa0), pt)\n                mstore(add(data, 0xc0), yt)\n                mstore(add(data, 0xe0), recipient)\n                mstore(add(data, 0x100), uDeposit)\n                mstore(add(data, 0x120), underlyingInMax)\n            }\n        }\n        uint256 received = INapierPool(pool).swapPtForUnderlying(\n            index,\n            ytOutDesired, // ptInDesired\n            address(this), // this contract will receive underlying token from pool\n            data\n        );\n\n        // Underlying pulled = underlying deposited - underlying received from swap\n        return uDeposit - received;\n    }\n\n    /// @inheritdoc INapierRouter\n    /// @notice Swap YT for underlying asset.\n    /// @dev Under the hood, Router receives principal token from `pool` with flash swap and redeem it with YT for underlying asset.\n    /// After that, pay back the underlying asset to `pool` and transfer the remaining underlying asset to `recipient`.\n    /// @param pool The address of the pool.\n    /// @param index The index of the YT.\n    /// @param ytIn The amount of YT to swap.\n    /// @param underlyingOutMin The minimum amount of underlying asset to receive.\n    /// @param recipient The recipient of the underlying asset.\n    /// @param deadline The deadline for the swap.\n    /// @return The amount of underlying asset recipient received.\n    function swapYtForUnderlying(\n        address pool,\n        uint256 index,\n        uint256 ytIn,\n        uint256 underlyingOutMin,\n        address recipient,\n        uint256 deadline\n    ) external override nonReentrant checkDeadline(deadline) returns (uint256) {\n        // dev: Optimistically call to the `pool` provided by the untrusted caller.\n        // And then verify the pool using CREATE2.\n        (address underlying, address basePool) = INapierPool(pool).getAssets();\n\n        // if `pool` doesn't matched, it would be reverted.\n        if (INapierPool(pool) != PoolAddress.computeAddress(basePool, underlying, POOL_CREATION_HASH, address(factory)))\n        {\n            revert Errors.RouterPoolNotFound();\n        }\n\n        ITranche pt = ITranche(address(INapierPool(pool).principalTokens()[index]));\n\n        uint256 prevBalance = IERC20(underlying).balanceOf(recipient);\n\n        // Abi encode callback data to be used in swapCallback\n        bytes memory data = new bytes(0x100);\n        uint256 callbackType = uint256(CallbackType.SwapYtForUnderlying);\n        assembly {\n            // Equivanlent to:\n            // data = abi.encode(CallbackType.SwapYtForUnderlying, underlying, basePool, CallbackDataTypes.SwapYtForUnderlyingData({pt: pt, payer: msg.sender, ytIn: ytIn, recipient: recipient, underlyingOutMin: underlyingOutMin}))\n            mstore(add(data, 0x20), callbackType)\n            mstore(add(data, 0x40), underlying)\n            mstore(add(data, 0x60), basePool)\n            mstore(add(data, 0x80), caller()) // dev: Ensure 'payer' is always 'msg.sender' to prevent allowance theft on callback.\n            mstore(add(data, 0xa0), pt)\n            mstore(add(data, 0xc0), ytIn)\n            mstore(add(data, 0xe0), recipient)\n            mstore(add(data, 0x100), underlyingOutMin)\n        }\n        // Note: swap for PT approximate equal to `ytIn`\n        INapierPool(pool).swapUnderlyingForPt(\n            index,\n            ytIn, // ptOutDesired\n            address(this), // this contract will receive principal token from pool\n            data\n        );\n\n        // Underlying received = balance after swap - balance before swap\n        return IERC20(underlying).balanceOf(recipient) - prevBalance;\n    }\n\n    /// @inheritdoc INapierRouter\n    /// @notice Caller must approve the router to spend underlying asset and PTs prior to calling this method.\n    /// @notice Revert if the pool is not deployed by the factory set in the constructor\n    /// @notice Revert if maturity has passed for the pool\n    /// @notice Revert if deadline has passed\n    /// @notice Revert if the amount of liquidity tokens received is less than the minimum amount specified\n    /// @notice It will refund the remaining tokens (Native ETH or Base LP token) to the caller if any.\n    /// @param pool The address of the pool.\n    /// @param underlyingIn The amount of underlying asset to deposit.\n    /// @param ptsIn The amounts of PTs to deposit. Can be zero but at least one must be non-zero. Otherwise, revert in the Curve pool.\n    /// @param liquidityMin The minimum amount of liquidity tokens to receive.\n    /// @param recipient The recipient of the liquidity tokens.\n    /// @param deadline The deadline for adding liquidity.\n    /// @return The amount of liquidity tokens received.\n    function addLiquidity(\n        address pool,\n        uint256 underlyingIn,\n        uint256[3] calldata ptsIn,\n        uint256 liquidityMin,\n        address recipient,\n        uint256 deadline\n    ) external payable override nonReentrant checkDeadline(deadline) returns (uint256) {\n        // dev: Optimistically call to the `pool` provided by the untrusted caller.\n        // And then verify the pool using CREATE2.\n        (address underlying, address basePool) = INapierPool(pool).getAssets();\n\n        // if `pool` doesn't matched, it would be reverted.\n        if (INapierPool(pool) != PoolAddress.computeAddress(basePool, underlying, POOL_CREATION_HASH, address(factory)))\n        {\n            revert Errors.RouterPoolNotFound();\n        }\n\n        IERC20[3] memory pts = INapierPool(pool).principalTokens();\n\n        // Loop unrolling for gas optimization\n        pts[0].safeTransferFrom(msg.sender, address(this), ptsIn[0]);\n        pts[1].safeTransferFrom(msg.sender, address(this), ptsIn[1]);\n        pts[2].safeTransferFrom(msg.sender, address(this), ptsIn[2]);\n        // approve max to Tricrypto pool\n        if (pts[0].allowance(address(this), basePool) < ptsIn[0]) pts[0].approve(basePool, type(uint256).max); // dev: Principal token will revert if failed to approve\n        if (pts[1].allowance(address(this), basePool) < ptsIn[1]) pts[1].approve(basePool, type(uint256).max);\n        if (pts[2].allowance(address(this), basePool) < ptsIn[2]) pts[2].approve(basePool, type(uint256).max);\n\n        uint256 baseLptIn = CurveTricryptoOptimizedWETH(basePool).add_liquidity(ptsIn, 0);\n        // Add liquidity to Napier pool\n        uint256 liquidity = INapierPool(pool).addLiquidity(\n            underlyingIn,\n            baseLptIn,\n            recipient,\n            abi.encode(\n                CallbackType.AddLiquidityPts,\n                CallbackDataTypes.AddLiquidityData({payer: msg.sender, underlying: underlying, basePool: basePool})\n            )\n        );\n        if (liquidity < liquidityMin) revert Errors.RouterInsufficientLpOut();\n\n        // Sweep remaining tokens if any.\n        uint256 bBalance = IERC20(basePool).balanceOf(address(this));\n        if (bBalance > 0) IERC20(basePool).safeTransfer(msg.sender, bBalance);\n        // If WETH or ERC20 tokens are used, the exact amount is pulled from the caller. So, no need to sweep.\n        // If caller sent native ETH, make sure to send remaining ETH back to caller.\n        if (address(this).balance > 0) _safeTransferETH(msg.sender, address(this).balance);\n\n        return liquidity;\n    }\n\n    /// @inheritdoc INapierRouter\n    /// @notice Add liquidity to Napier pool from one principal token proportionally as possible as it can.\n    /// @notice Deadline should be tightly set.\n    /// @notice Caller must approve the router to spend PT prior to calling this method.\n    /// @dev Caller must specify the amount of base LP token to be swapped for underlying asset using off-chain calculation.\n    /// @dev Remaining base LP token and underlying asset are swept to the caller if any.\n    /// @param pool The address of the pool.\n    /// @param index The index of the PT.\n    /// @param amountIn The amount of PT to deposit.\n    /// @param liquidityMin The minimum amount of liquidity tokens to receive.\n    /// @param recipient The recipient of the liquidity tokens.\n    /// @param deadline The deadline for adding liquidity.\n    /// @param baseLpTokenSwap The estimated baseLpt amount to swap with underlying tokens.\n    /// @return The amount of liquidity tokens received.\n    function addLiquidityOnePt(\n        address pool,\n        uint256 index,\n        uint256 amountIn,\n        uint256 liquidityMin,\n        address recipient,\n        uint256 deadline,\n        uint256 baseLpTokenSwap\n    ) external override nonReentrant checkDeadline(deadline) returns (uint256) {\n        // dev: Optimistically call to the `pool` provided by the untrusted caller.\n        // And then verify the pool using CREATE2.\n        (address underlying, address basePool) = INapierPool(pool).getAssets();\n\n        // if `pool` doesn't matched, it would be reverted.\n        if (INapierPool(pool) != PoolAddress.computeAddress(basePool, underlying, POOL_CREATION_HASH, address(factory)))\n        {\n            revert Errors.RouterPoolNotFound();\n        }\n\n        IERC20[3] memory pts = INapierPool(pool).principalTokens();\n        pts[index].safeTransferFrom(msg.sender, address(this), amountIn);\n        if (pts[index].allowance(address(this), basePool) < amountIn) pts[index].approve(basePool, type(uint256).max);\n\n        uint256[3] memory ptsIn;\n        ptsIn[index] = amountIn;\n        uint256 baseLptIn = CurveTricryptoOptimizedWETH(basePool).add_liquidity(ptsIn, 0);\n        IERC20(basePool).forceApprove(address(pool), baseLptIn);\n\n        // Swap some base LP token for underlying\n        uint256 underlyingIn = INapierPool(pool).swapExactBaseLpTokenForUnderlying(baseLpTokenSwap, address(this));\n\n        // Add liquidity to Napier pool\n        uint256 liquidity = INapierPool(pool).addLiquidity(\n            underlyingIn,\n            baseLptIn - baseLpTokenSwap,\n            recipient,\n            abi.encode(\n                CallbackType.AddLiquidityOnePt,\n                CallbackDataTypes.AddLiquidityData({\n                    payer: address(this), // Router has already had both tokens at this point\n                    underlying: underlying,\n                    basePool: basePool\n                })\n            )\n        );\n        if (liquidity < liquidityMin) revert Errors.RouterInsufficientLpOut();\n\n        // Sweep remaining tokens if any.\n        uint256 bBalance = IERC20(basePool).balanceOf(address(this));\n        if (bBalance > 0) IERC20(basePool).safeTransfer(msg.sender, bBalance);\n        uint256 uBalance = IERC20(underlying).balanceOf(address(this));\n        if (uBalance > 0) IERC20(underlying).safeTransfer(msg.sender, uBalance);\n\n        return liquidity;\n    }\n\n    /// @inheritdoc INapierRouter\n    /// @notice Add liquidity to NapierPool with one underlying asset.\n    /// @notice Deadline should be tightly set.\n    /// @notice Caller must approve the router to spend underlying asset prior to calling this method.\n    /// @dev Under the hood, router swap some underlying asset for Base pool LP token.\n    /// @dev Caller must specify the amount of base LP token to be swapped for underlying asset using off-chain calculation.\n    /// @dev Remaining base LP token and underlying asset are swept to the caller if any.\n    /// @param pool The address of the pool.\n    /// @param underlyingIn The amount of underlying asset to deposit.\n    /// @param liquidityMin The minimum amount of liquidity tokens to receive.\n    /// @param recipient The recipient of the liquidity tokens.\n    /// @param deadline The deadline for adding liquidity.\n    /// @param baseLpTokenSwap The estimated baseLpTokenSwap amount to swap with underlying tokens.\n    /// @return The amount of liquidity tokens received.\n    function addLiquidityOneUnderlying(\n        address pool,\n        uint256 underlyingIn,\n        uint256 liquidityMin,\n        address recipient,\n        uint256 deadline,\n        uint256 baseLpTokenSwap\n    ) external override nonReentrant checkDeadline(deadline) returns (uint256) {\n        // dev: Optimistically call to the `pool` provided by the untrusted caller.\n        // And then verify the pool using CREATE2.\n        (address underlying, address basePool) = INapierPool(pool).getAssets();\n\n        // if `pool` doesn't matched, it would be reverted.\n        if (INapierPool(pool) != PoolAddress.computeAddress(basePool, underlying, POOL_CREATION_HASH, address(factory)))\n        {\n            revert Errors.RouterPoolNotFound();\n        }\n\n        IERC20(underlying).safeTransferFrom(msg.sender, address(this), underlyingIn);\n\n        // Swap some underlying for baseLpt\n        // At this point, Router doesn't know how much underlying is needed to get `baseLpTokenSwap` amount of base LP token.\n        // So, Router just approve pool to spend all underlying asset and let pool to spend as much as it needs.\n        // approve max\n        if (IERC20(underlying).allowance(address(this), pool) < underlyingIn) {\n            IERC20(underlying).forceApprove(pool, type(uint256).max);\n        }\n        uint256 uSpent = INapierPool(pool).swapUnderlyingForExactBaseLpToken(baseLpTokenSwap, address(this));\n\n        // Add liquidity to Napier pool\n        uint256 liquidity = INapierPool(pool).addLiquidity(\n            underlyingIn - uSpent, // remaining underlying asset\n            baseLpTokenSwap, // base LP token from swap\n            recipient,\n            abi.encode("
    }
  ]
}