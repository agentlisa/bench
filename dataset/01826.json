{
  "Title": "Specified `minOutput` will remain locked in `LSSVMRouter::swapNFTsForSpecificNFTsThroughETH`",
  "Content": "**Description:**\nThe Cyfrin team understands that `LSSVMRouter` is slightly out of scope for this audit, given that it is intended to be deprecated and replaced by `VeryFastRouter`; however, a slightly modified version of this contract is currently deployed and [live on mainnet](https://etherscan.io/address/0x2b2e8cda09bba9660dca5cb6233787738ad68329#code). We have found a bug in [`LSSVMRouter::swapNFTsForSpecificNFTsThroughETH`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMRouter.sol#L88) and `LSSVMRouter::swapNFTsForAnyNFTsThroughETH` which has been validated against a mainnet fork to lock user funds sent with the function call as specified by the [`minOutput`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMRouter.sol#L90) parameter. In other words, users attempting to protect themselves from slippage will find that this causes their funds to become locked - the higher the minimum expected output specified, the higher value of funds locked.\n\nUsers specifying a non-zero `minOutput` value will have this amount [deducted](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMRouter.sol#L105) from the `inputAmount` sent on the second half of the swap, from ETH to NFTs, handled by the internal functions [`LSSVMRouter::_swapETHForSpecificNFTs`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMRouter.sol#L560) and `LSSVMRouter::_swapETHForAnyNFTs`. Given that it is the responsibility of these internal functions to issue a refund of any unspent ETH based on this [`inputAmount`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMRouter.sol#L562) parameter, the excess value represented by `minOutput` is not included in the [`remainingValue`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMRouter.sol#L566) [calculation](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMRouter.sol#L582) and so will not be included in the subsequent [ETH transfer](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMRouter.sol#L591-L595). If there are no intermediate underflows (due to a sufficiently large value of `minOutput`) then any excess ETH as specified by `minOutput` will therefore remain locked in the router forever.\n\nFortunately, it appears these functions have never actually been called on the mainnet deployment as they have not been connected to the Sudoswap front end. While Sudoswap doesn't use these functions on the client, contract-level integrators may find themselves with potentially lost funds, so the Sudorandom Labs team has attempted to reach out to those potentially affected.\n\n**Proof of Concept:**\nApply the following git diff:\n\n```diff\ndiff --git a/src/test/interfaces/ILSSVMPairFactoryMainnet.sol b/src/test/interfaces/ILSSVMPairFactoryMainnet.sol\nnew file mode 100644\nindex 0000000..3cdea5b\n--- /dev/null\n+++ b/src/test/interfaces/ILSSVMPairFactoryMainnet.sol\n@@ -0,0 +1,20 @@\n+// SPDX-License-Identifier: MIT\n+pragma solidity ^0.8.0;\n+\n+import {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n+import {ICurve} from \"../../bonding-curves/ICurve.sol\";\n+import {LSSVMPair} from \"../../LSSVMPair.sol\";\n+import {LSSVMPairETH} from \"../../LSSVMPairETH.sol\";\n+\n+interface ILSSVMPairFactoryMainnet {\n+    function createPairETH(\n+        IERC721 _nft,\n+        ICurve _bondingCurve,\n+        address payable _assetRecipient,\n+        LSSVMPair.PoolType _poolType,\n+        uint128 _delta,\n+        uint96 _fee,\n+        uint128 _spotPrice,\n+        uint256[] calldata _initialNFTIDs\n+    ) external payable returns (LSSVMPairETH pair);\n+}\ndiff --git a/src/test/mixins/UsingETH.sol b/src/test/mixins/UsingETH.sol\nindex 0e5cb40..8fecb1e 100644\n--- a/src/test/mixins/UsingETH.sol\n+++ b/src/test/mixins/UsingETH.sol\n@@ -14,6 +14,8 @@ import {LSSVMPairFactory} from \"../../LSSVMPairFactory.sol\";\n import {LSSVMPairERC721} from \"../../erc721/LSSVMPairERC721.sol\";\n import {LSSVMPairERC1155} from \"../../erc1155/LSSVMPairERC1155.sol\";\n\n+import {ILSSVMPairFactoryMainnet} from \"../interfaces/ILSSVMPairFactoryMainnet.sol\";\n+\n abstract contract UsingETH is Configurable, RouterCaller {\n     function modifyInputAmount(uint256 inputAmount) public pure override returns (uint256) {\n         return inputAmount;\n@@ -46,6 +48,25 @@ abstract contract UsingETH is Configurable, RouterCaller {\n         return pair;\n     }\n\n+    function setupPairERC721Mainnet(\n+        ILSSVMPairFactoryMainnet factory,\n+        IERC721 nft,\n+        ICurve bondingCurve,\n+        address payable assetRecipient,\n+        LSSVMPair.PoolType poolType,\n+        uint128 delta,\n+        uint96 fee,\n+        uint128 spotPrice,\n+        uint256[] memory _idList,\n+        uint256,\n+        address\n+    ) public payable returns (LSSVMPair) {\n+        LSSVMPairETH pair = factory.createPairETH{value: msg.value}(\n+            nft, bondingCurve, assetRecipient, poolType, delta, fee, spotPrice, _idList\n+        );\n+        return pair;\n+    }\n+\n     function setupPairERC1155(CreateERC1155PairParams memory params) public payable override returns (LSSVMPair) {\n         LSSVMPairETH pair = params.factory.createPairERC1155ETH{value: msg.value}(\n             params.nft,\ndiff --git a/src/test/single-test-cases/CyfrinLSSVMRouterPoC.t.sol b/src/test/single-test-cases/CyfrinLSSVMRouterPoC.t.sol\nnew file mode 100644\nindex 0000000..596da45\n--- /dev/null\n+++ b/src/test/single-test-cases/CyfrinLSSVMRouterPoC.t.sol\n@@ -0,0 +1,114 @@\n+// SPDX-License-Identifier: AGPL-3.0\n+pragma solidity ^0.8.0;\n+\n+import \"forge-std/Test.sol\";\n+\n+import {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n+import {Test721} from \"../../mocks/Test721.sol\";\n+\n+import {ICurve} from \"../../bonding-curves/ICurve.sol\";\n+import {ILSSVMPairFactoryMainnet} from \"../interfaces/ILSSVMPairFactoryMainnet.sol\";\n+\n+import {UsingETH} from \"../mixins/UsingETH.sol\";\n+import {ConfigurableWithRoyalties} from \"../mixins/ConfigurableWithRoyalties.sol\";\n+import {LinearCurve, UsingLinearCurve} from \"../../test/mixins/UsingLinearCurve.sol\";\n+\n+import {LSSVMPair} from \"../../LSSVMPair.sol\";\n+import {LSSVMPairETH} from \"../../LSSVMPairETH.sol\";\n+import {LSSVMRouter} from \"../../LSSVMRouter.sol\";\n+import {RoyaltyEngine} from \"../../RoyaltyEngine.sol\";\n+import {LSSVMPairFactory} from \"../../LSSVMPairFactory.sol\";\n+\n+\n+contract CyfrinLSSVMRouterPoC is Test, ConfigurableWithRoyalties, UsingLinearCurve, UsingETH {\n+    IERC721 test721;\n+    address payable alice;\n+\n+    LSSVMRouter constant LSSVM_ROUTER = LSSVMRouter(payable(address(0x2B2e8cDA09bBA9660dCA5cB6233787738Ad68329)));\n+    LSSVMPairFactory constant LSSVM_PAIR_FACTORY = LSSVMPairFactory(payable(address(0xb16c1342E617A5B6E4b631EB114483FDB289c0A4)));\n+    LinearCurve constant LINEAR_CURVE = LinearCurve(payable(address(0x5B6aC51d9B1CeDE0068a1B26533CAce807f883Ee)));\n+\n+    function setUp() public {\n+        vm.createSelectFork(vm.envOr(\"MAINNET_RPC_URL\", string.concat(\"https://rpc.ankr.com/eth\")));\n+\n+        test721 = setup721();\n+        alice = payable(makeAddr(\"alice\"));\n+        deal(alice, 1 ether);\n+    }\n+\n+    function test_minOutputIsLockedInRouterWhenCallingswapNFTsForSpecificNFTsThroughETH() public {\n+        Test721(address(test721)).mint(alice, 1);\n+        uint256[] memory nftToTokenTradesIds = new uint256[](1);\n+        nftToTokenTradesIds[0] = 1;\n+        Test721(address(test721)).mint(address(this), 2);\n+        Test721(address(test721)).mint(address(this), 3);\n+        Test721(address(test721)).mint(address(this), 4);\n+        uint256[] memory ids = new uint256[](3);\n+        ids[0] = 2;\n+        ids[1] = 3;\n+        ids[2] = 4;\n+        uint256[] memory tokenToNFTTradesIds = new uint256[](1);\n+        tokenToNFTTradesIds[0] = ids[ids.length - 1];\n+\n+        test721.setApprovalForAll(address(LSSVM_PAIR_FACTORY), true);\n+        LSSVMPair pair721 = this.setupPairERC721Mainnet{value: 10 ether}(\n+            ILSSVMPairFactoryMainnet(address(LSSVM_PAIR_FACTORY)),\n+            test721,\n+            LINEAR_CURVE,\n+            payable(address(0)),\n+            LSSVMPair.PoolType.TRADE,\n+            0.1 ether, // delta\n+            0.1 ether, // 10% for trade fee\n+            1 ether, // spot price\n+            ids,\n+            10 ether,\n+            address(0)\n+        );\n+\n+        uint256 pairETHBalanceBefore = address(pair721).balance;\n+        uint256 aliceETHBalanceBefore = address(alice).balance;\n+        uint256 routerETHBalanceBefore = address(LSSVM_ROUTER).balance;\n+\n+        emit log_named_uint(\"pairETHBalanceBefore\", pairETHBalanceBefore);\n+        emit log_named_uint(\"aliceETHBalanceBefore\", aliceETHBalanceBefore);\n+        emit log_named_uint(\"routerETHBalanceBefore\", routerETHBalanceBefore);\n+\n+        uint256 minOutput;\n+        {\n+            LSSVMRouter.PairSwapSpecific[] memory nftToTokenTrades = new LSSVMRouter.PairSwapSpecific[](1);\n+            nftToTokenTrades[0] = LSSVMRouter.PairSwapSpecific({\n+                pair: pair721,\n+                nftIds: nftToTokenTradesIds\n+            });\n+\n+            LSSVMRouter.PairSwapSpecific[] memory tokenToNFTTrades = new LSSVMRouter.PairSwapSpecific[](1);\n+            tokenToNFTTrades[0] = LSSVMRouter.PairSwapSpecific({\n+                pair: pair721,\n+                nftIds: tokenToNFTTradesIds\n+            });\n+\n+            LSSVMRouter.NFTsForSpecificNFTsTrade memory trade = LSSVMRouter.NFTsForSpecificNFTsTrade({\n+                nftToTokenTrades: nftToTokenTrades,\n+                tokenToNFTTrades: tokenToNFTTrades\n+            });\n+\n+\n+            vm.startPrank(alice);\n+            test721.setApprovalForAll(address(LSSVM_ROUTER), true);\n+            minOutput = 0.79 ether;\n+            LSSVM_ROUTER.swapNFTsForSpecificNFTsThroughETH{value: 1 ether}(trade, minOutput, alice, alice, block.timestamp + 10);\n+        }\n+\n+        uint256 pairETHBalanceAfter = address(pair721).balance;\n+        uint256 aliceETHBalanceAfter = address(alice).balance;\n+        uint256 routerETHBalanceAfter = address(LSSVM_ROUTER).balance;\n+\n+        assertTrue(test721.ownerOf(tokenToNFTTradesIds[0]) == alice);\n+        assertGt(pairETHBalanceAfter, pairETHBalanceBefore);\n+        assertEq(routerETHBalanceAfter, minOutput);\n+\n+        emit log_named_uint(\"pairETHBalanceAfter\", pairETHBalanceAfter);\n+        emit log_named_uint(\"aliceETHBalanceAfter\", aliceETHBalanceAfter);\n+        emit log_named_uint(\"routerETHBalanceAfter\", routerETHBalanceAfter);\n+    }\n+}\n```\n\n**Impact:**\nThis vulnerability results in the locking of user funds with high impact and likelihood. If the problematic functions were integrated into a UI, then this would be evaluated as CRITICAL, but given that the current integrations significantly reduce the likelihood, we evaluate the severity as HIGH.\n\n**Recommended Mitigation:**\nPass `minOutput` through to the internal functions to be used in refund calculations and correctly reflect the true contract balance, validating that this amount is not exceeded. This way, the [`outputAmount`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMRouter.sol#L94) [return value](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMRouter.sol#L104-L106) will correctly reflect the excess ETH transferred to the caller.\n\n**Sudoswap:**\nAcknowledged. This issue is present in current implementation of the Router, but no UIs are currently integrated to interact with this specific function. The contract is expected to be deprecated soon in favour of the VeryFastRouter.\n\n**Cyfrin:**\nAcknowledged.",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "src/LSSVMRouter.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\nimport {LSSVMPair} from \"./LSSVMPair.sol\";\nimport {ILSSVMPairFactoryLike} from \"./ILSSVMPairFactoryLike.sol\";\nimport {CurveErrorCodes} from \"./bonding-curves/CurveErrorCodes.sol\";\n\ncontract LSSVMRouter {\n    using SafeTransferLib for address payable;\n    using SafeTransferLib for ERC20;\n\n    struct PairSwapSpecific {\n        LSSVMPair pair;\n        uint256[] nftIds;\n    }\n\n    struct RobustPairSwapSpecific {\n        PairSwapSpecific swapInfo;\n        uint256 maxCost;\n    }\n\n    struct RobustPairSwapSpecificForToken {\n        PairSwapSpecific swapInfo;\n        uint256 minOutput;\n    }\n\n    struct NFTsForSpecificNFTsTrade {\n        PairSwapSpecific[] nftToTokenTrades;\n        PairSwapSpecific[] tokenToNFTTrades;\n    }\n\n    struct RobustPairNFTsFoTokenAndTokenforNFTsTrade {\n        RobustPairSwapSpecific[] tokenToNFTTrades;\n        RobustPairSwapSpecificForToken[] nftToTokenTrades;\n        uint256 inputAmount;\n        address payable tokenRecipient;\n        address nftRecipient;\n    }\n\n    modifier checkDeadline(uint256 deadline) {\n        _checkDeadline(deadline);\n        _;\n    }\n\n    ILSSVMPairFactoryLike public immutable factory;\n\n    constructor(ILSSVMPairFactoryLike _factory) {\n        factory = _factory;\n    }\n\n    /**\n     * ETH swaps\n     */\n\n    /**\n     * @notice Swaps ETH into specific NFTs using multiple pairs.\n     *     @param swapList The list of pairs to trade with and the IDs of the NFTs to buy from each.\n     *     @param ethRecipient The address that will receive the unspent ETH input\n     *     @param nftRecipient The address that will receive the NFT output\n     *     @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\n     *     @return remainingValue The unspent ETH amount\n     */\n    function swapETHForSpecificNFTs(\n        PairSwapSpecific[] calldata swapList,\n        address payable ethRecipient,\n        address nftRecipient,\n        uint256 deadline\n    ) external payable checkDeadline(deadline) returns (uint256 remainingValue) {\n        return _swapETHForSpecificNFTs(swapList, msg.value, ethRecipient, nftRecipient);\n    }\n\n    /**\n     * @notice Swaps one set of NFTs into another set of specific NFTs using multiple pairs, using\n     *     ETH as the intermediary.\n     *     @param trade The struct containing all NFT-to-ETH swaps and ETH-to-NFT swaps.\n     *     @param minOutput The minimum acceptable total excess ETH received\n     *     @param ethRecipient The address that will receive the ETH output\n     *     @param nftRecipient The address that will receive the NFT output\n     *     @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\n     *     @return outputAmount The total ETH received\n     */\n    function swapNFTsForSpecificNFTsThroughETH(\n        NFTsForSpecificNFTsTrade calldata trade,\n        uint256 minOutput,\n        address payable ethRecipient,\n        address nftRecipient,\n        uint256 deadline\n    ) external payable checkDeadline(deadline) returns (uint256 outputAmount) {\n        // Swap NFTs for ETH\n        // minOutput of swap set to 0 since we're doing an aggregate slippage check\n        outputAmount = _swapNFTsForToken(trade.nftToTokenTrades, 0, payable(address(this)));\n\n        // Add extra value to buy NFTs\n        outputAmount += msg.value;\n\n        // Swap ETH for specific NFTs\n        // cost <= inputValue = outputAmount - minOutput, so outputAmount' = (outputAmount - minOutput - cost) + minOutput >= minOutput\n        outputAmount = _swapETHForSpecificNFTs(\n            trade.tokenToNFTTrades, outputAmount - minOutput, ethRecipient, nftRecipient\n        ) + minOutput;\n    }\n\n    /**\n     * ERC20 swaps\n     *\n     *     Note: All ERC20 swaps assume that a single ERC20 token is used for all the pairs involved.\n     *     Swapping using multiple tokens in the same transaction is possible, but the slippage checks\n     *     & the return values will be meaningless, and may lead to undefined behavior.\n     *\n     *     Note: The sender should ideally grant infinite token approval to the router in order for NFT-to-NFT\n     *     swaps to work smoothly.\n     */\n\n    /**\n     * @notice Swaps ERC20 tokens into specific NFTs using multiple pairs.\n     *     @param swapList The list of pairs to trade with and the IDs of the NFTs to buy from each.\n     *     @param inputAmount The amount of ERC20 tokens to add to the ERC20-to-NFT swaps\n     *     @param nftRecipient The address that will receive the NFT output\n     *     @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\n     *     @return remainingValue The unspent token amount\n     */\n    function swapERC20ForSpecificNFTs(\n        PairSwapSpecific[] calldata swapList,\n        uint256 inputAmount,\n        address nftRecipient,\n        uint256 deadline\n    ) external checkDeadline(deadline) returns (uint256 remainingValue) {\n        return _swapERC20ForSpecificNFTs(swapList, inputAmount, nftRecipient);\n    }\n\n    /**\n     * @notice Swaps NFTs into ETH/ERC20 using multiple pairs.\n     *     @param swapList The list of pairs to trade with and the IDs of the NFTs to sell to each.\n     *     @param minOutput The minimum acceptable total tokens received\n     *     @param tokenRecipient The address that will receive the token output\n     *     @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\n     *     @return outputAmount The total tokens received\n     */\n    function swapNFTsForToken(\n        PairSwapSpecific[] calldata swapList,\n        uint256 minOutput,\n        address tokenRecipient,\n        uint256 deadline\n    ) external checkDeadline(deadline) returns (uint256 outputAmount) {\n        return _swapNFTsForToken(swapList, minOutput, payable(tokenRecipient));\n    }\n\n    /**\n     * @notice Swaps one set of NFTs into another set of specific NFTs using multiple pairs, using\n     *     an ERC20 token as the intermediary.\n     *     @param trade The struct containing all NFT-to-ERC20 swaps and ERC20-to-NFT swaps.\n     *     @param inputAmount The amount of ERC20 tokens to add to the ERC20-to-NFT swaps\n     *     @param minOutput The minimum acceptable total excess tokens received\n     *     @param nftRecipient The address that will receive the NFT output\n     *     @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\n     *     @return outputAmount The total ERC20 tokens received\n     */\n    function swapNFTsForSpecificNFTsThroughERC20(\n        NFTsForSpecificNFTsTrade calldata trade,\n        uint256 inputAmount,\n        uint256 minOutput,\n        address nftRecipient,\n        uint256 deadline\n    ) external checkDeadline(deadline) returns (uint256 outputAmount) {\n        // Swap NFTs for ERC20\n        // minOutput of swap set to 0 since we're doing an aggregate slippage check\n        // output tokens are sent to msg.sender\n        outputAmount = _swapNFTsForToken(trade.nftToTokenTrades, 0, payable(msg.sender));\n\n        // Add extra value to buy NFTs\n        outputAmount += inputAmount;\n\n        // Swap ERC20 for specific NFTs\n        // cost <= maxCost = outputAmount - minOutput, so outputAmount' = outputAmount - cost >= minOutput\n        // input tokens are taken directly from msg.sender\n        outputAmount =\n            _swapERC20ForSpecificNFTs(trade.tokenToNFTTrades, outputAmount - minOutput, nftRecipient) + minOutput;\n    }\n\n    /**\n     * Robust Swaps\n     *     These are \"robust\" versions of the NFT<>Token swap functions which will never revert due to slippage\n     *     Instead, users specify a per-swap max cost. If the price changes more than the user specifies, no swap is attempted. This allows users to specify a batch of swaps, and execute as many of them as possible.\n     */\n\n    /**\n     * @dev Ensure msg.value >= sum of values in maxCostPerPair to make sure the transaction doesn't revert\n     *     @param swapList The list of pairs to trade with and the IDs of the NFTs to buy from each.\n     *     @param ethRecipient The address that will receive the unspent ETH input\n     *     @param nftRecipient The address that will receive the NFT output\n     *     @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\n     *     @return remainingValue The unspent token amount\n     */\n    function robustSwapETHForSpecificNFTs(\n        RobustPairSwapSpecific[] calldata swapList,\n        address payable ethRecipient,\n        address nftRecipient,\n        uint256 deadline\n    ) public payable virtual checkDeadline(deadline) returns (uint256 remainingValue) {\n        remainingValue = msg.value;\n        uint256 pairCost;\n        CurveErrorCodes.Error error;\n\n        // Try doing each swap\n        uint256 numSwaps = swapList.length;\n        for (uint256 i; i < numSwaps;) {\n            // Calculate actual cost per swap\n            (error,,, pairCost,,) = swapList[i].swapInfo.pair.getBuyNFTQuote(\n                swapList[i].swapInfo.nftIds[0], swapList[i].swapInfo.nftIds.length\n            );\n\n            // If within our maxCost and no error, proceed\n            if (pairCost <= swapList[i].maxCost && error == CurveErrorCodes.Error.OK) {\n                // We know how much ETH to send because we already did the math above\n                // So we just send that much\n                remainingValue -= swapList[i].swapInfo.pair.swapTokenForSpecificNFTs{value: pairCost}(\n                    swapList[i].swapInfo.nftIds, pairCost, nftRecipient, true, msg.sender\n                );\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Return remaining value to sender\n        if (remainingValue > 0) {\n            ethRecipient.safeTransferETH(remainingValue);\n        }\n    }\n\n    /**\n     * @notice Swaps as many ERC20 tokens for specific NFTs as possible, respecting the per-swap max cost.\n     *     @param swapList The list of pairs to trade with and the IDs of the NFTs to buy from each.\n     *     @param inputAmount The amount of ERC20 tokens to add to the ERC20-to-NFT swaps\n     *\n     *     @param nftRecipient The address that will receive the NFT output\n     *     @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\n     *     @return remainingValue The unspent token amount\n     */\n    function robustSwapERC20ForSpecificNFTs(\n        RobustPairSwapSpecific[] calldata swapList,\n        uint256 inputAmount,\n        address nftRecipient,\n        uint256 deadline\n    ) public virtual checkDeadline(deadline) returns (uint256 remainingValue) {\n        remainingValue = inputAmount;\n        uint256 pairCost;\n        CurveErrorCodes.Error error;\n\n        // Try doing each swap\n        uint256 numSwaps = swapList.length;\n        for (uint256 i; i < numSwaps;) {\n            // Calculate actual cost per swap\n            (error,,, pairCost,,) = swapList[i].swapInfo.pair.getBuyNFTQuote(\n                swapList[i].swapInfo.nftIds[0], swapList[i].swapInfo.nftIds.length\n            );\n\n            // If within our maxCost and no error, proceed\n            if (pairCost <= swapList[i].maxCost && error == CurveErrorCodes.Error.OK) {\n                remainingValue -= swapList[i].swapInfo.pair.swapTokenForSpecificNFTs(\n                    swapList[i].swapInfo.nftIds, pairCost, nftRecipient, true, msg.sender\n                );\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Swaps as many NFTs for tokens as possible, respecting the per-swap min output\n     *     @param swapList The list of pairs to trade with and the IDs of the NFTs to sell to each.\n     *     @param tokenRecipient The address that will receive the token output\n     *     @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\n     *     @return outputAmount The total ETH/ERC20 received\n     */\n    function robustSwapNFTsForToken(\n        RobustPairSwapSpecificForToken[] calldata swapList,\n        address payable tokenRecipient,\n        uint256 deadline\n    ) public virtual checkDeadline(deadline) returns (uint256 outputAmount) {\n        // Try doing each swap\n        uint256 numSwaps = swapList.length;\n        for (uint256 i; i < numSwaps;) {\n            uint256 pairOutput;\n\n            // Locally scoped to avoid stack too deep error\n            {\n                CurveErrorCodes.Error error;\n                uint256[] memory nftIds = swapList[i].swapInfo.nftIds;\n                if (nftIds.length == 0) {\n                    unchecked {\n                        ++i;\n                    }\n                    continue;\n                }\n                (error,,, pairOutput,,) = swapList[i].swapInfo.pair.getSellNFTQuote(nftIds[0], nftIds.length);\n                if (error != CurveErrorCodes.Error.OK) {\n                    unchecked {\n                        ++i;\n                    }\n                    continue;\n                }\n            }\n\n            // If at least equal to our minOutput, proceed\n            if (pairOutput >= swapList[i].minOutput) {\n                // Do the swap and update outputAmount with how many tokens we got\n                outputAmount += swapList[i].swapInfo.pair.swapNFTsForToken(\n                    swapList[i].swapInfo.nftIds, 0, tokenRecipient, true, msg.sender\n                );\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Buys NFTs with ETH and sells them for tokens in one transaction\n     *     @param params All the parameters for the swap (packed in struct to avoid stack too deep), containing:\n     *     - ethToNFTSwapList The list of NFTs to buy\n     *     - nftToTokenSwapList The list of NFTs to sell\n     *     - inputAmount The max amount of tokens to send (if ERC20)\n     *     - tokenRecipient The address that receives tokens from the NFTs sold\n     *     - nftRecipient The address that receives NFTs\n     *     - deadline UNIX timestamp deadline for the swap\n     */\n    function robustSwapETHForSpecificNFTsAndNFTsToToken(RobustPairNFTsFoTokenAndTokenforNFTsTrade calldata params)\n        external\n        payable\n        virtual\n        returns (uint256 remainingValue, uint256 outputAmount)\n    {\n        {\n            remainingValue = msg.value;\n            uint256 pairCost;\n            CurveErrorCodes.Error error;\n\n            // Try doing each swap\n            uint256 numSwaps = params.tokenToNFTTrades.length;\n            for (uint256 i; i < numSwaps;) {\n                // Calculate actual cost per swap\n                (error,,, pairCost,,) = params.tokenToNFTTrades[i].swapInfo.pair.getBuyNFTQuote(\n                    params.tokenToNFTTrades[i].swapInfo.nftIds[0], params.tokenToNFTTrades[i].swapInfo.nftIds.length\n                );\n\n                // If within our maxCost and no error, proceed\n                if (pairCost <= params.tokenToNFTTrades[i].maxCost && error == CurveErrorCodes.Error.OK) {\n                    // We know how much ETH to send because we already did the math above\n                    // So we just send that much\n                    remainingValue -= params.tokenToNFTTrades[i].swapInfo.pair.swapTokenForSpecificNFTs{value: pairCost}(\n                        params.tokenToNFTTrades[i].swapInfo.nftIds, pairCost, params.nftRecipient, true, msg.sender\n                    );\n                }\n\n                unchecked {\n                    ++i;\n                }\n            }\n\n            // Return remaining value to sender\n            if (remainingValue > 0) {\n                params.tokenRecipient.safeTransferETH(remainingValue);\n            }\n        }\n        {\n            // Try doing each swap\n            uint256 numSwaps = params.nftToTokenTrades.length;\n            for (uint256 i; i < numSwaps;) {\n                uint256 pairOutput;\n\n                // Locally scoped to avoid stack too deep error\n                {\n                    CurveErrorCodes.Error error;\n                    uint256 assetId = params.nftToTokenTrades[i].swapInfo.nftIds[0];\n                    (error,,, pairOutput,,) = params.nftToTokenTrades[i].swapInfo.pair.getSellNFTQuote(\n                        assetId, params.nftToTokenTrades[i].swapInfo.nftIds.length\n                    );\n                    if (error != CurveErrorCodes.Error.OK) {\n                        unchecked {\n                            ++i;\n                        }\n                        continue;\n                    }\n                }\n\n                // If at least equal to our minOutput, proceed\n                if (pairOutput >= params.nftToTokenTrades[i].minOutput) {\n                    // Do the swap and update outputAmount with how many tokens we got\n                    outputAmount += params.nftToTokenTrades[i].swapInfo.pair.swapNFTsForToken(\n                        params.nftToTokenTrades[i].swapInfo.nftIds, 0, params.tokenRecipient, true, msg.sender\n                    );\n                }\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Buys NFTs with ERC20, and sells them for tokens in one transaction\n     *     @param params All the parameters for the swap (packed in struct to avoid stack too deep), containing:\n     *     - ethToNFTSwapList The list of NFTs to buy\n     *     - nftToTokenSwapList The list of NFTs to sell\n     *     - inputAmount The max amount of tokens to send (if ERC20)\n     *     - tokenRecipient The address that receives tokens from the NFTs sold\n     *     - nftRecipient The address that receives NFTs\n     *     - deadline UNIX timestamp deadline for the swap\n     */\n    function robustSwapERC20ForSpecificNFTsAndNFTsToToken(RobustPairNFTsFoTokenAndTokenforNFTsTrade calldata params)\n        external\n        virtual\n        returns (uint256 remainingValue, uint256 outputAmount)\n    {\n        {\n            remainingValue = params.inputAmount;\n            uint256 pairCost;\n            CurveErrorCodes.Error error;\n\n            // Try doing each swap\n            uint256 numSwaps = params.tokenToNFTTrades.length;\n            for (uint256 i; i < numSwaps;) {\n                // Calculate actual cost per swap\n                (error,,, pairCost,,) = params.tokenToNFTTrades[i].swapInfo.pair.getBuyNFTQuote(\n                    params.tokenToNFTTrades[i].swapInfo.nftIds[0], params.tokenToNFTTrades[i].swapInfo.nftIds.length\n                );\n\n                // If within our maxCost and no error, proceed\n                if (pairCost <= params.tokenToNFTTrades[i].maxCost && error == CurveErrorCodes.Error.OK) {\n                    remainingValue -= params.tokenToNFTTrades[i].swapInfo.pair.swapTokenForSpecificNFTs(\n                        params.tokenToNFTTrades[i].swapInfo.nftIds, pairCost, params.nftRecipient, true, msg.sender\n                    );\n                }\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n        {\n            // Try doing each swap\n            uint256 numSwaps = params.nftToTokenTrades.length;\n            for (uint256 i; i < numSwaps;) {\n                uint256 pairOutput;\n\n                // Locally scoped to avoid stack too deep error\n                {\n                    CurveErrorCodes.Error error;\n                    uint256 assetId = params.nftToTokenTrades[i].swapInfo.nftIds[0];\n                    (error,,, pairOutput,,) = params.nftToTokenTrades[i].swapInfo.pair.getSellNFTQuote(\n                        assetId, params.nftToTokenTrades[i].swapInfo.nftIds.length\n                    );\n                    if (error != CurveErrorCodes.Error.OK) {\n                        unchecked {\n                            ++i;\n                        }\n                        continue;\n                    }\n                }\n\n                // If at least equal to our minOutput, proceed\n                if (pairOutput >= params.nftToTokenTrades[i].minOutput) {\n                    // Do the swap and update outputAmount with how many tokens we got\n                    outputAmount += params.nftToTokenTrades[i].swapInfo.pair.swapNFTsForToken(\n                        params.nftToTokenTrades[i].swapInfo.nftIds, 0, params.tokenRecipient, true, msg.sender\n                    );\n                }\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n    }\n\n    receive() external payable {}\n\n    /**\n     * Restricted functions\n     */\n\n    /**\n     * @dev Allows an ERC20 pair contract to transfer ERC20 tokens directly from\n     *     the sender, in order to minimize the number of token transfers. Only callable by an ERC20 pair.\n     *     @param token The ERC20 token to transfer\n     *     @param from The address to transfer tokens from\n     *     @param to The address to transfer tokens to\n     *     @param amount The amount of tokens to transfer\n     */\n    function pairTransferERC20From(ERC20 token, address from, address to, uint256 amount) external {\n        // verify caller is a trusted pair contract\n        require(factory.isValidPair(msg.sender), \"Not pair\");\n        // verify caller is an ERC20 pair\n        require(factory.getPairTokenType(msg.sender) == ILSSVMPairFactoryLike.PairTokenType.ERC20, \"Not ERC20 pair\");\n\n        // transfer tokens to pair\n        token.safeTransferFrom(from, to, amount);\n    }\n\n    /**\n     * @dev Allows a pair contract to transfer ERC721 NFTs directly from\n     *     the sender, in order to minimize the number of token transfers. Only callable by a pair.\n     *     @param nft The ERC721 NFT to transfer\n     *     @param from The address to transfer tokens from\n     *     @param to The address to transfer tokens to\n     *     @param id The ID of the NFT to transfer\n     */\n    function pairTransferNFTFrom(IERC721 nft, address from, address to, uint256 id) external {\n        // verify caller is a trusted pair contract\n        require(factory.isValidPair(msg.sender), \"Not pair\");\n\n        // transfer NFTs to pair\n        nft.transferFrom(from, to, id);\n    }\n\n    function pairTransferERC1155From(\n        IERC1155 nft,\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) external {\n        // verify caller is a trusted pair contract\n        require(factory.isValidPair(msg.sender), \"Not pair\");\n\n        nft.safeBatchTransferFrom(from, to, ids, amounts, bytes(\"\"));\n    }\n\n    /**\n     * Internal functions\n     */\n\n    /**\n     * @param deadline The last valid time for a swap\n     */\n    function _checkDeadline(uint256 deadline) internal view {\n        require(block.timestamp <= deadline, \"Deadline passed\");\n    }\n\n    /**\n     * @notice Internal function used to swap ETH for a specific set of NFTs\n     *     @param swapList The list of pairs and swap calldata\n     *     @param inputAmount The total amount of ETH to send\n     *     @param ethRecipient The address receiving excess ETH\n     *     @param nftRecipient The address receiving the NFTs from the pairs\n     *     @return remainingValue The unspent token amount\n     */\n    function _swapETHForSpecificNFTs(\n        PairSwapSpecific[] calldata swapList,\n        uint256 inputAmount,\n        address payable ethRecipient,\n        address nftRecipient\n    ) internal virtual returns (uint256 remainingValue) {\n        remainingValue = inputAmount;\n\n        uint256 pairCost;\n        CurveErrorCodes.Error error;\n\n        // Do swaps\n        uint256 numSwaps = swapList.length;\n        for (uint256 i; i < numSwaps;) {\n            // Calculate the cost per swap first to send exact amount of ETH over, saves gas by avoiding the need to send back excess ETH\n            (error,,, pairCost,,) = swapList[i].pair.getBuyNFTQuote(swapList[i].nftIds[0], swapList[i].nftIds.length);\n\n            // Require no errors\n            require(error == CurveErrorCodes.Error.OK, \"Bonding curve error\");\n\n            // Total ETH taken from sender cannot exceed inputAmount\n            // because otherwise the deduction from remainingValue will fail\n            remainingValue -= swapList[i].pair.swapTokenForSpecificNFTs{value: pairCost}(\n                swapList[i].nftIds, remainingValue, nftRecipient, true, msg.sender\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Return remaining value to sender\n        if (remainingValue > 0) {\n            ethRecipient.safeTransferETH(remainingValue);\n        }\n    }\n\n    /**\n     * @notice Internal function used to swap an ERC20 token for specific NFTs\n     *     @dev Note that we don't need to query the pair's bonding curve first for pricing data because\n     *     we just calculate and take the required amount from the caller during swap time.\n     *     However, we can't \"pull\" ETH, which is why for the ETH->NFT swaps, we need to calculate the pricing info\n     *     to figure out how much the router should send to the pool.\n     *     @param swapList The list of pairs and swap calldata\n     *     @param inputAmount The total amount of ERC20 tokens to send\n     *     @param nftRecipient The address receiving the NFTs from the pairs\n     *     @return remainingValue The unspent token amount\n     */\n    function _swapERC20ForSpecificNFTs(PairSwapSpecific[] calldata swapList, uint256 inputAmount, address nftRecipient)\n        internal\n        virtual\n        returns (uint256 remainingValue)\n    {\n        remainingValue = inputAmount;\n\n        // Do swaps\n        uint256 numSwaps = swapList.length;\n        for (uint256 i; i < numSwaps;) {\n            // Tokens are transferred in by the pair calling router.pairTransferERC20From\n            // Total tokens taken from sender cannot exceed inputAmount\n            // because otherwise the deduction from remainingValue will fail\n            remainingValue -= swapList[i].pair.swapTokenForSpecificNFTs(\n                swapList[i].nftIds, remainingValue, nftRecipient, true, msg.sender\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Swaps NFTs for tokens, designed to be used for 1 token at a time\n     *     @dev Calling with multiple tokens is permitted, BUT minOutput will be\n     *     far from enough of a safety check because different tokens almost certainly have different unit prices.\n     *     @param swapList The list of pairs and swap calldata\n     *     @param minOutput The minimum number of tokens to be receieved from the swaps\n     *     @param tokenRecipient The address that receives the tokens\n     *     @return outputAmount The number of tokens to be received\n     */\n    function _swapNFTsForToken(PairSwapSpecific[] calldata swapList, uint256 minOutput, address payable tokenRecipient)\n        internal\n        virtual\n        returns (uint256 outputAmount)\n    {\n        // Do swaps\n        uint256 numSwaps = swapList.length;\n        for (uint256 i; i < numSwaps;) {\n            // Do the swap for token and then update outputAmount\n            // Note: minExpectedTokenOutput is set to 0 since we're doing an aggregate slippage check below\n            outputAmount += swapList[i].pair.swapNFTsForToken(swapList[i].nftIds, 0, tokenRecipient, true, msg.sender);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Aggregate slippage check\n        require(outputAmount >= minOutput, \"outputAmount too low\");\n    }\n}"
    },
    {
      "filename": "src/LSSVMRouter.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\nimport {LSSVMPair} from \"./LSSVMPair.sol\";\nimport {ILSSVMPairFactoryLike} from \"./ILSSVMPairFactoryLike.sol\";\nimport {CurveErrorCodes} from \"./bonding-curves/CurveErrorCodes.sol\";\n\ncontract LSSVMRouter {\n    using SafeTransferLib for address payable;\n    using SafeTransferLib for ERC20;\n\n    struct PairSwapSpecific {\n        LSSVMPair pair;\n        uint256[] nftIds;\n    }\n\n    struct RobustPairSwapSpecific {\n        PairSwapSpecific swapInfo;\n        uint256 maxCost;\n    }\n\n    struct RobustPairSwapSpecificForToken {\n        PairSwapSpecific swapInfo;\n        uint256 minOutput;\n    }\n\n    struct NFTsForSpecificNFTsTrade {\n        PairSwapSpecific[] nftToTokenTrades;\n        PairSwapSpecific[] tokenToNFTTrades;\n    }\n\n    struct RobustPairNFTsFoTokenAndTokenforNFTsTrade {\n        RobustPairSwapSpecific[] tokenToNFTTrades;\n        RobustPairSwapSpecificForToken[] nftToTokenTrades;\n        uint256 inputAmount;\n        address payable tokenRecipient;\n        address nftRecipient;\n    }\n\n    modifier checkDeadline(uint256 deadline) {\n        _checkDeadline(deadline);\n        _;\n    }\n\n    ILSSVMPairFactoryLike public immutable factory;\n\n    constructor(ILSSVMPairFactoryLike _factory) {\n        factory = _factory;\n    }\n\n    /**\n     * ETH swaps\n     */\n\n    /**\n     * @notice Swaps ETH into specific NFTs using multiple pairs.\n     *     @param swapList The list of pairs to trade with and the IDs of the NFTs to buy from each.\n     *     @param ethRecipient The address that will receive the unspent ETH input\n     *     @param nftRecipient The address that will receive the NFT output\n     *     @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\n     *     @return remainingValue The unspent ETH amount\n     */\n    function swapETHForSpecificNFTs(\n        PairSwapSpecific[] calldata swapList,\n        address payable ethRecipient,\n        address nftRecipient,\n        uint256 deadline\n    ) external payable checkDeadline(deadline) returns (uint256 remainingValue) {\n        return _swapETHForSpecificNFTs(swapList, msg.value, ethRecipient, nftRecipient);\n    }\n\n    /**\n     * @notice Swaps one set of NFTs into another set of specific NFTs using multiple pairs, using\n     *     ETH as the intermediary.\n     *     @param trade The struct containing all NFT-to-ETH swaps and ETH-to-NFT swaps.\n     *     @param minOutput The minimum acceptable total excess ETH received\n     *     @param ethRecipient The address that will receive the ETH output\n     *     @param nftRecipient The address that will receive the NFT output\n     *     @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\n     *     @return outputAmount The total ETH received\n     */\n    function swapNFTsForSpecificNFTsThroughETH(\n        NFTsForSpecificNFTsTrade calldata trade,\n        uint256 minOutput,\n        address payable ethRecipient,\n        address nftRecipient,\n        uint256 deadline\n    ) external payable checkDeadline(deadline) returns (uint256 outputAmount) {\n        // Swap NFTs for ETH\n        // minOutput of swap set to 0 since we're doing an aggregate slippage check\n        outputAmount = _swapNFTsForToken(trade.nftToTokenTrades, 0, payable(address(this)));\n\n        // Add extra value to buy NFTs\n        outputAmount += msg.value;\n\n        // Swap ETH for specific NFTs\n        // cost <= inputValue = outputAmount - minOutput, so outputAmount' = (outputAmount - minOutput - cost) + minOutput >= minOutput\n        outputAmount = _swapETHForSpecificNFTs(\n            trade.tokenToNFTTrades, outputAmount - minOutput, ethRecipient, nftRecipient\n        ) + minOutput;\n    }\n\n    /**\n     * ERC20 swaps\n     *\n     *     Note: All ERC20 swaps assume that a single ERC20 token is used for all the pairs involved.\n     *     Swapping using multiple tokens in the same transaction is possible, but the slippage checks\n     *     & the return values will be meaningless, and may lead to undefined behavior.\n     *\n     *     Note: The sender should ideally grant infinite token approval to the router in order for NFT-to-NFT\n     *     swaps to work smoothly.\n     */\n\n    /**\n     * @notice Swaps ERC20 tokens into specific NFTs using multiple pairs.\n     *     @param swapList The list of pairs to trade with and the IDs of the NFTs to buy from each.\n     *     @param inputAmount The amount of ERC20 tokens to add to the ERC20-to-NFT swaps\n     *     @param nftRecipient The address that will receive the NFT output\n     *     @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\n     *     @return remainingValue The unspent token"
    }
  ]
}