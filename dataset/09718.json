{
  "Title": "[H-04] EIP712MetaTransaction.executeMetaTransaction() failed txs are open to replay attacks",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L86\n\n\n# Vulnerability details\n\nAny transactions that fail based on some conditions that may change in the future are not safe to be executed again later (e.g. transactions that are based on others actions, or time-dependent etc).\n\nIn the current implementation, once the low-level call is failed, the whole tx will be reverted and so that `_nonces[metaAction.from]` will remain unchanged.\n\nAs a result, the same tx can be replayed by anyone, using the same signature.\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L86\n\n```solidity\n    function executeMetaTransaction(\n        MetaAction memory metaAction,\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) external payable returns (bytes memory) {\n        require(\n            _verify(metaAction.from, metaAction, r, s, v),\n            \"signer and signature don't match\"\n        );\n\n        uint256 currentNonce = _nonces[metaAction.from];\n\n        // intentionally allow this to overflow to save gas,\n        // and it's impossible for someone to do 2 ^ 256 - 1 meta txs\n        unchecked {\n            _nonces[metaAction.from] = currentNonce + 1;\n        }\n\n        // Append the metaAction.from at the end so that it can be extracted later\n        // from the calling context (see _msgSender() below)\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(\n                abi.encodeWithSelector(\n                    IController(address(this)).operate.selector,\n                    metaAction.actions\n                ),\n                metaAction.from\n            )\n        );\n\n        require(success, \"unsuccessful function call\");\n        emit MetaTransactionExecuted(\n            metaAction.from,\n            payable(msg.sender),\n            currentNonce\n        );\n        return returnData;\n    }\n```\n\nSee also the implementation of OpenZeppelin's `MinimalForwarder`:\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/metatx/MinimalForwarder.sol#L42-L66\n\n### PoC\n\nGiven:\n\n- The collateral is USDC;\n- Alice got `10,000 USDC` in the wallet.\n\n1. Alice submitted a MetaTransaction to `operate()` and `_mintOptionsPosition()` with `10,000 USDC`;\n2. Before the MetaTransaction get executed, Alice sent `1,000 USDC` to Bob;\n3. The MetaTransaction submited by Alice in step 1 get executed but failed;\n4. A few days later, Bob sent `1,000 USDC` to Alice;\n5. The attacker can replay the MetaTransaction failed to execute at step 3 and succeed.\n\nAlice's `10,000 USDC` is now been spent unexpectedly against her will and can potentially cause fund loss depends on the market situation.\n\n### Recommendation\n\nFailed txs should still increase the nonce.\n\nWhile implementating the change above, consider adding one more check to require sufficient gas to be paid, to prevent \"insufficient gas griefing attack\" as described in [this article](https://ipfs.io/ipfs/QmbbYTGTeot9ic4hVrsvnvVuHw4b5P7F5SeMSNX9TYPGjY/blog/ethereum-gas-dangers/).\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-03-rolla-contest",
  "Code": [
    {
      "filename": "quant-protocol/contracts/utils/EIP712MetaTransaction.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"../interfaces/IEIP712MetaTransaction.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../libraries/Actions.sol\";\nimport {ActionArgs} from \"../libraries/Actions.sol\";\n\n/// @title Contract to be inherited by contracts that want to support meta transactions.\n/// @author Rolla\ncontract EIP712MetaTransaction is EIP712Upgradeable {\n    using ECDSA for bytes32;\n\n    struct MetaAction {\n        uint256 nonce;\n        uint256 deadline;\n        address from;\n        ActionArgs[] actions;\n    }\n\n    bytes32 private constant _META_ACTION_TYPEHASH =\n        keccak256(\n            // solhint-disable-next-line max-line-length\n            \"MetaAction(uint256 nonce,uint256 deadline,address from,ActionArgs[] actions)ActionArgs(uint8 actionType,address qToken,address secondaryAddress,address receiver,uint256 amount,uint256 collateralTokenId,bytes data)\"\n        );\n    bytes32 private constant _ACTION_TYPEHASH =\n        keccak256(\n            // solhint-disable-next-line max-line-length\n            \"ActionArgs(uint8 actionType,address qToken,address secondaryAddress,address receiver,uint256 amount,uint256 collateralTokenId,bytes data)\"\n        );\n\n    mapping(address => uint256) private _nonces;\n\n    /// @notice user readable name of signing domain for EIP712 (the protocol name)\n    string public name;\n\n    /// @notice the current major version of the signing domain for EIP712\n    string public version;\n\n    /// @notice emitted when a meta transaction is executed\n    event MetaTransactionExecuted(\n        address indexed userAddress,\n        address payable indexed relayerAddress,\n        uint256 nonce\n    );\n\n    /// @notice Given an encoded action and a signature, executes the action on behalf of the signer.\n    /// @param metaAction The encoded action to be executed.\n    /// @param r The r-value of the signature.\n    /// @param s The s-value of the signature.\n    /// @param v The v-value of the signature.\n    /// @return The returned data from the low-level call.\n    function executeMetaTransaction(\n        MetaAction memory metaAction,\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) external payable returns (bytes memory) {\n        require(\n            _verify(metaAction.from, metaAction, r, s, v),\n            \"signer and signature don't match\"\n        );\n\n        uint256 currentNonce = _nonces[metaAction.from];\n\n        // intentionally allow this to overflow to save gas,\n        // and it's impossible for someone to do 2 ^ 256 - 1 meta txs\n        unchecked {\n            _nonces[metaAction.from] = currentNonce + 1;\n        }\n\n        // Append the metaAction.from at the end so that it can be extracted later\n        // from the calling context (see _msgSender() below)\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(\n                abi.encodeWithSelector(\n                    IController(address(this)).operate.selector,\n                    metaAction.actions\n                ),\n                metaAction.from\n            )\n        );\n\n        require(success, \"unsuccessful function call\");\n        emit MetaTransactionExecuted(\n            metaAction.from,\n            payable(msg.sender),\n            currentNonce\n        );\n        return returnData;\n    }\n\n    /// @notice Returns the current nonce for a user.\n    /// @param user the address of the user to get the nonce for.\n    /// @return nonce the current nonce for the user.\n    function getNonce(address user) external view returns (uint256 nonce) {\n        nonce = _nonces[user];\n    }\n\n    /// @notice initialize method for EIP712Upgradeable\n    /// @dev called once after initial deployment and every upgrade.\n    /// @param _name the user readable name of the signing domain for EIP712\n    /// @param _version the current major version of the signing domain for EIP712\n    function initializeEIP712(string memory _name, string memory _version)\n        public\n        initializer\n    {\n        name = _name;\n        version = _version;\n\n        __EIP712_init(_name, _version);\n    }\n\n    /// @notice Returns the address of the signer when called from this contract,\n    /// otherwise returns the msg.sender\n    /// @return sender the address of the signer or msg.sender\n    function _msgSender() internal view returns (address sender) {\n        if (msg.sender == address(this)) {\n            bytes memory array = msg.data;\n            uint256 index = msg.data.length;\n            assembly {\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\n                sender := and(\n                    mload(add(array, index)),\n                    0xffffffffffffffffffffffffffffffffffffffff\n                )\n            }\n        } else {\n            sender = msg.sender;\n        }\n        return sender;\n    }\n\n    /// @notice Verifies that the signature is valid for a given user and action.\n    /// @param user the address to check as the signer.\n    /// @param metaAction the action struct to check.\n    /// @param r the r-value of the signature.\n    /// @param s the s-value of the signature.\n    /// @param v the v-value of the signature.\n    function _verify(\n        address user,\n        MetaAction memory metaAction,\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) internal view returns (bool) {\n        require(metaAction.nonce == _nonces[user], \"invalid nonce\");\n\n        require(metaAction.deadline >= block.timestamp, \"expired deadline\");\n\n        address signer = _hashTypedDataV4(_hashMetaAction(metaAction)).recover(\n            v,\n            r,\n            s\n        );\n\n        return signer == user;\n    }\n\n    /// @notice Hashes a given ActionArgs struct to be used with EIP712.\n    /// @param action the ActionArgs struct to hash.\n    /// @return the hash of the ActionArgs struct.\n    function _hashAction(ActionArgs memory action)\n        private\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(\n                    _ACTION_TYPEHASH,\n                    action.actionType,\n                    action.qToken,\n                    action.secondaryAddress,\n                    action.receiver,\n                    action.amount,\n                    action.collateralTokenId,\n                    keccak256(action.data)\n                )\n            );\n    }\n\n    /// @notice Hashes an array of ActionArgs structs to be used with EIP712.\n    /// @param actions the array of ActionArgs structs to hash.\n    /// @return the array of hashes for the ActionArgs structs.\n    function _hashActions(ActionArgs[] memory actions)\n        private\n        pure\n        returns (bytes32[] memory)\n    {\n        bytes32[] memory hashedActions = new bytes32[](actions.length);\n        uint256 length = actions.length;\n        for (uint256 i = 0; i < length; ) {\n            hashedActions[i] = _hashAction(actions[i]);\n            unchecked {\n                ++i;\n            }\n        }\n        return hashedActions;\n    }\n\n    /// @notice Hashes a MetaAction struct to be used with EIP712.\n    /// @param metaAction the MetaAction struct to hash.\n    /// @return the hash of the MetaAction struct.\n    function _hashMetaAction(MetaAction memory metaAction)\n        private\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(\n                    _META_ACTION_TYPEHASH,\n                    metaAction.nonce,\n                    metaAction.deadline,\n                    metaAction.from,\n                    keccak256(\n                        abi.encodePacked(_hashActions(metaAction.actions))\n                    )\n                )\n            );\n    }\n}"
    }
  ]
}