{
  "Title": "Blocked LP tokens on contract",
  "Content": "##### Description\nAt the line https://github.com/bondappetit/bondappetit-protocol/blob/355180f0aca0b29d60d808f761052956b7a3a159/contracts/profit/UniswapMarketMaker.sol#L85 contract changes `incoming` token to another one, while transferring contract sends all remaining `incoming` tokens to `_recipient`, but contract never check remaining incoming <> support LP tokens on contract side. That tokens cannot be rescued anymore after changing incoming.\n\n##### Recommendation\nWe recommend to remove all liquidity before changing `incoming` token\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/profit/UniswapMarketMaker.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../utils/OwnablePausable.sol\";\nimport \"../uniswap/IUniswapV2Router02.sol\";\nimport \"../uniswap/IUniswapV2Factory.sol\";\n\ncontract UniswapMarketMaker is OwnablePausable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n\n    /// @notice Incoming token.\n    ERC20 public incoming;\n\n    /// @notice Support token.\n    ERC20 public support;\n\n    /// @notice Uniswap router contract address.\n    IUniswapV2Router02 public uniswapRouter;\n\n    /// @notice An event thats emitted when an token transferred to recipient.\n    event TokenTransfer(address token, address recipient, uint256 amount);\n\n    /// @notice An event thats emitted when an uniswap router contract address changed.\n    event UniswapRouterChanged(address newUniswapRouter);\n\n    /// @notice An event thats emitted when an incoming token changed.\n    event IncomingChanged(address newIncoming);\n\n    /// @notice An event thats emitted when an liquidity added.\n    event LiquidityIncreased(uint256 incoming, uint256 support);\n\n    /// @notice An event thats emitted when an liquidity removed.\n    event LiquidityReduced(uint256 lp, uint256 incoming, uint256 support);\n\n    /**\n     * @param _incoming Address of incoming token.\n     * @param _support Address of support token.\n     * @param _uniswapRouter Address of Uniswap router contract.\n     */\n    constructor(\n        address _incoming,\n        address _support,\n        address _uniswapRouter\n    ) public {\n        incoming = ERC20(_incoming);\n        support = ERC20(_support);\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n    }\n\n    /**\n     * @notice Transfer incoming token to recipient.\n     * @param token Address of transferred token.\n     * @param recipient Address of recipient.\n     * @param amount Amount of transferred token.\n     */\n    function transfer(\n        address token,\n        address recipient,\n        uint256 amount\n    ) external onlyOwner {\n        require(recipient != address(0), \"UniswapMarketMaker::transfer: cannot transfer to the zero address\");\n\n        ERC20(token).safeTransfer(recipient, amount);\n        emit TokenTransfer(token, recipient, amount);\n    }\n\n    /**\n     * @notice Changed uniswap router contract address.\n     * @param _uniswapRouter Address new uniswap router contract.\n     */\n    function changeUniswapRouter(address _uniswapRouter) external onlyOwner {\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n        emit UniswapRouterChanged(_uniswapRouter);\n    }\n\n    /**\n     * @notice Change incoming token address.\n     * @param _incoming New incoming token address.\n     * @param _recipient Address of recipient.\n     */\n    function changeIncoming(address _incoming, address _recipient) external onlyOwner {\n        require(address(incoming) != _incoming, \"UniswapMarketMaker::changeIncoming: duplicate incoming token address\");\n\n        uint256 balance = incoming.balanceOf(address(this));\n        if (balance > 0) {\n            incoming.safeTransfer(_recipient, balance);\n        }\n        incoming = ERC20(_incoming);\n        emit IncomingChanged(_incoming);\n    }\n\n    /**\n     * @notice Buy support token and add liquidity.\n     * @param amount Amount of incoming token.\n     */\n    function buyLiquidity(uint256 amount) external whenNotPaused {\n        if (amount > 0) {\n            incoming.safeTransferFrom(_msgSender(), address(this), amount);\n        }\n\n        address[] memory path = new address[](2);\n        path[0] = address(incoming);\n        path[1] = address(support);\n\n        uint256 amountIn = incoming.balanceOf(address(this)).div(2);\n        require(amountIn > 0, \"UniswapMarketMaker::buyLiquidity: not enough funds to buy back\");\n        uint256[] memory amountsOut = uniswapRouter.getAmountsOut(amountIn, path);\n        require(amountsOut.length != 0, \"UniswapMarketMaker::buyLiquidity: invalid amounts out length\");\n        uint256 amountOut = amountsOut[amountsOut.length - 1];\n        require(amountOut > 0, \"UniswapMarketMaker::buyLiquidity: liquidity pool is empty\");\n\n        incoming.safeApprove(address(uniswapRouter), amountIn);\n        uniswapRouter.swapExactTokensForTokens(amountIn, amountOut, path, address(this), block.timestamp);\n\n        uint256 incomingBalance = incoming.balanceOf(address(this));\n        require(incomingBalance > 0, \"UniswapMarketMaker::buyLiquidity: incoming token balance is empty\");\n        uint256 supportBalance = support.balanceOf(address(this));\n        require(supportBalance > 0, \"UniswapMarketMaker::buyLiquidity: support token balance is empty\");\n\n        incoming.safeApprove(address(uniswapRouter), incomingBalance);\n        support.safeApprove(address(uniswapRouter), supportBalance);\n        (uint256 amountA, uint256 amountB, ) = uniswapRouter.addLiquidity(address(incoming), address(support), incomingBalance, supportBalance, 0, 0, address(this), block.timestamp);\n        emit LiquidityIncreased(amountA, amountB);\n\n        incoming.safeApprove(address(uniswapRouter), 0);\n        support.safeApprove(address(uniswapRouter), 0);\n    }\n\n    /**\n     * @notice Add liquidity.\n     * @param incomingAmount Amount of incoming token.\n     * @param supportAmount Amount of support token.\n     */\n    function addLiquidity(uint256 incomingAmount, uint256 supportAmount) external whenNotPaused {\n        if (incomingAmount > 0) {\n            incoming.safeTransferFrom(_msgSender(), address(this), incomingAmount);\n        }\n        if (supportAmount > 0) {\n            support.safeTransferFrom(_msgSender(), address(this), supportAmount);\n        }\n\n        uint256 incomingBalance = incoming.balanceOf(address(this));\n        require(incomingBalance > 0, \"UniswapMarketMaker::addLiquidity: incoming token balance is empty\");\n        uint256 supportBalance = support.balanceOf(address(this));\n        require(supportBalance > 0, \"UniswapMarketMaker::addLiquidity: support token balance is empty\");\n\n        incoming.safeApprove(address(uniswapRouter), incomingBalance);\n        support.safeApprove(address(uniswapRouter), supportBalance);\n        (uint256 amountA, uint256 amountB, ) = uniswapRouter.addLiquidity(address(incoming), address(support), incomingBalance, supportBalance, 0, 0, address(this), block.timestamp);\n        emit LiquidityIncreased(amountA, amountB);\n\n        incoming.safeApprove(address(uniswapRouter), 0);\n        support.safeApprove(address(uniswapRouter), 0);\n    }\n\n    /**\n     * @notice Return liquidity pair address.\n     * @return Liquidity pair address.\n     */\n    function liquidityPair() public view returns (address) {\n        IUniswapV2Factory uniswapFactory = IUniswapV2Factory(uniswapRouter.factory());\n        return uniswapFactory.getPair(address(incoming), address(support));\n    }\n\n    /**\n     * @notice Remove liquidity.\n     * @param amount Amount of liquidity pool token.\n     */\n    function removeLiquidity(uint256 amount) external onlyOwner {\n        address pair = liquidityPair();\n        require(pair != address(0), \"UniswapMarketMaker::removeLiquidity: liquidity pair not found\");\n\n        uint256 lpBalance = ERC20(pair).balanceOf(address(this));\n        amount = lpBalance < amount ? lpBalance : amount;\n        require(amount > 0, \"UniswapMarketMaker::removeLiquidity: zero amount\");\n\n        ERC20(pair).safeApprove(address(uniswapRouter), amount);\n        (uint256 incomingAmount, uint256 supportAmount) = uniswapRouter.removeLiquidity(address(incoming), address(support), amount, 0, 0, address(this), block.timestamp);\n        emit LiquidityReduced(amount, incomingAmount, supportAmount);\n    }\n}"
    }
  ]
}