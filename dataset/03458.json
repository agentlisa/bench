{
  "Title": "[L02] SafeGuardâ€™s admin can assign the role of creator to any address",
  "Content": "The `SafeGuard` contract defines the role of a [`CREATOR_ROLE`](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuard.sol#L16) which, as the name suggests, is assigned to the creator of the safeguard.\n\n\nHowever, by invoking [the `grantRole` function of the `AccessControlEnumerable` contract](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControlEnumerable.sol#L51-L54) in the OpenZeppelin contract library, an admin can grant this role to any address. This could cause confusion because the [creator of the `SafeGuard` can only be the `SafeGuardFactory`](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuardFactory.sol#L36).\n\n\nThroughout the codebase, this role has been used only to restrict users from interacting with the [`setTimelock` function](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuard.sol#L55) of the `SafeGuard` contract. By design, the system ensures that `setTimelock` function [can be called only once](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuard.sol#L56), from [within the `SafeGuardFactory` contract](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuardFactory.sol#L38).\n\n\nConsider removing the `CREATOR_ROLE` role from the `SafeGuard` contract and using the [`onlyOwner` modifier](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol#L41-L44) in the `setTimelock` function.\n\n\n**Update:** *Fixed in [PR #10](https://github.com/withtally/safeguard/pull/10).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/SafeGuard.sol",
      "content": "pragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"./ITimelock.sol\";\nimport \"hardhat/console.sol\";\n\ncontract SafeGuard is AccessControlEnumerable {\n\n    // Request info event\n    event QueueTransactionWithDescription(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta, string description);\n\n    bytes32 public constant SAFEGUARD_ADMIN_ROLE = keccak256(\"SAFEGUARD_ADMIN_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    bytes32 public constant CANCELER_ROLE = keccak256(\"CANCELER_ROLE\");\n    bytes32 public constant CREATOR_ROLE = keccak256(\"CREATOR_ROLE\");\n\n    ///@dev The address of the Timelock\n    ITimelock public timelock;\n\n    /**\n     * @dev Initializes the contract with a given Timelock address and administrator address.\n     */\n    constructor (address _admin, bytes32[] memory roles, address[] memory rolesAssignees) {\n        require(roles.length == rolesAssignees.length, \"SafeGuard::constructor: roles assignment arity mismatch\");\n        // set roles administrator\n        _setRoleAdmin(SAFEGUARD_ADMIN_ROLE, SAFEGUARD_ADMIN_ROLE);\n        _setRoleAdmin(PROPOSER_ROLE, SAFEGUARD_ADMIN_ROLE);\n        _setRoleAdmin(EXECUTOR_ROLE, SAFEGUARD_ADMIN_ROLE);\n        _setRoleAdmin(CANCELER_ROLE, SAFEGUARD_ADMIN_ROLE);\n        _setRoleAdmin(CREATOR_ROLE, SAFEGUARD_ADMIN_ROLE);\n\n        // assign roles \n        for (uint i = 0; i < roles.length; i++) {\n            _setupRole(roles[i], rolesAssignees[i]);\n        }\n\n        // set admin rol to an address\n        _setupRole(SAFEGUARD_ADMIN_ROLE, _admin);\n        _setupRole(CREATOR_ROLE, msg.sender);\n    }\n\n    /**\n     * @dev Modifier to make a function callable just by a certain role.\n     */\n    modifier justByRole(bytes32 role) {\n        require(hasRole(role, _msgSender()), \"SafeGuard: sender requires permission\");\n        _;\n    }\n\n    /**\n     * @notice Sets the timelock address this safeGuard contract is gonna use\n     * @param _timelock The address of the timelock contract\n     */\n    function setTimelock(address _timelock) public justByRole(CREATOR_ROLE) {\n        require(address(timelock) == address(0), \"SafeGuard::setTimelock: Timelock address already defined\");\n        // set timelock address\n        timelock = ITimelock(_timelock);\n    }\n\n    function queueTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 eta) public justByRole(PROPOSER_ROLE) {\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        _queueTimelockTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function queueTransactionWithDescription(address target, uint256 value, string memory signature, bytes memory data, uint256 eta, string memory description) public justByRole(PROPOSER_ROLE) {\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        _queueTimelockTransaction(txHash, target, value, signature, data, eta);\n        emit QueueTransactionWithDescription(txHash, target, value, signature, data, eta, description);\n    }\n\n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public justByRole(CANCELER_ROLE) {\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        _cancelTimelockTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(address target, uint256 _value, string memory signature, bytes memory data, uint256 eta) public payable justByRole(EXECUTOR_ROLE) {\n        bytes32 txHash = keccak256(abi.encode(target, _value, signature, data, eta));\n        require(timelock.queuedTransactions(txHash), \"SafeGuard::executeTransaction: transaction should be queued\");\n        timelock.executeTransaction{value: _value, gas: gasleft()}(target, _value, signature, data, eta);\n    }\n\n    function _queueTimelockTransaction(bytes32 txHash, address target, uint256 value, string memory signature, bytes memory data, uint256 eta) private {\n        require(!timelock.queuedTransactions(txHash), \"SafeGuard::queueTransaction: transaction already queued at eta\");\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\n    function _cancelTimelockTransaction(bytes32 txHash, address target, uint256 value, string memory signature, bytes memory data, uint256 eta) private {\n        require(timelock.queuedTransactions(txHash), \"SafeGuard::cancelTransaction: transaction should be queued\");\n        timelock.cancelTransaction(target, value, signature, data, eta);\n    }\n}"
    },
    {
      "filename": "contracts/SafeGuard.sol",
      "content": "pragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"./ITimelock.sol\";\nimport \"hardhat/console.sol\";\n\ncontract SafeGuard is AccessControlEnumerable {\n\n    // Request info event\n    event QueueTransactionWithDescription(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta, string description);\n\n    bytes32 public constant SAFEGUARD_ADMIN_ROLE = keccak256(\"SAFEGUARD_ADMIN_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    bytes32 public constant CANCELER_ROLE = keccak256(\"CANCELER_ROLE\");\n    bytes32 public constant CREATOR_ROLE = keccak256(\"CREATOR_ROLE\");\n\n    ///@dev The address of the Timelock\n    ITimelock public timelock;\n\n    /**\n     * @dev Initializes the contract with a given Timelock address and administrator address.\n     */\n    constructor (address _admin, bytes32[] memory roles, address[] memory rolesAssignees) {\n        require(roles.length == rolesAssignees.length, \"SafeGuard::constructor: roles assignment arity mismatch\");\n        // set roles administrator\n        _setRoleAdmin(SAFEGUARD_ADMIN_ROLE, SAFEGUARD_ADMIN_ROLE);\n        _setRoleAdmin(PROPOSER_ROLE, SAFEGUARD_ADMIN_ROLE);\n        _setRoleAdmin(EXECUTOR_ROLE, SAFEGUARD_ADMIN_ROLE);\n        _setRoleAdmin(CANCELER_ROLE, SAFEGUARD_ADMIN_ROLE);\n        _setRoleAdmin(CREATOR_ROLE, SAFEGUARD_ADMIN_ROLE);\n\n        // assign roles \n        for (uint i = 0; i < roles.length; i++) {\n            _setupRole(roles[i], rolesAssignees[i]);\n        }\n\n        // set admin rol to an address\n        _setupRole(SAFEGUARD_ADMIN_ROLE, _admin);\n        _setupRole(CREATOR_ROLE, msg.sender);\n    }\n\n    /**\n     * @dev Modifier to make a function callable just by a certain role.\n     */\n    modifier justByRole(bytes32 role) {\n        require(hasRole(role, _msgSender()), \"SafeGuard: sender requires permission\");\n        _;\n    }\n\n    /**\n     * @notice Sets the timelock address this safeGuard contract is gonna use\n     * @param _timelock The address of the timelock contract\n     */\n    function setTimelock(address _timelock) public justByRole(CREATOR_ROLE) {\n        require(address(timelock) == address(0), \"SafeGuard::setTimelock: Timelock address already defined\");\n        // set timelock address\n        timelock = ITimelock(_timelock);\n    }\n\n    function queueTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 eta) public justByRole(PROPOSER_ROLE) {\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        _queueTimelockTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function queueTransactionWithDescription(address target, uint256 value, string memory signature, bytes memory data, uint256 eta, string memory description) public justByRole(PROPOSER_ROLE) {\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        _queueTimelockTransaction(txHash, target, value, signature, data, eta);\n        emit QueueTransactionWithDescription(txHash, target, value, signature, data, eta, description);\n    }\n\n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public justByRole(CANCELER_ROLE) {\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        _cancelTimelockTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(address target, uint256 _value, string memory signature, bytes memory data, uint256 eta) public payable justByRole(EXECUTOR_ROLE) {\n        bytes32 txHash = keccak256(abi.encode(target, _value, signature, data, eta));\n        require(timelock.queuedTransactions(txHash), \"SafeGuard::executeTransaction: transaction should be queued\");\n        timelock.executeTransaction{value: _value, gas: gasleft()}(target, _value, signature, data, eta);\n    }\n\n    function _queueTimelockTransaction(bytes32 txHash, address target, uint256 value, string memory signature, bytes memory data, uint256 eta) private {\n        require(!timelock.queuedTransactions(txHash), \"SafeGuard::queueTransaction: transaction already queued at eta\");\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\n    function _cancelTimelockTransaction(bytes32 txHash, address target, uint256 value, string memory signature, bytes memory data, uint256 eta) private {\n        require(timelock.queuedTransactions(txHash), \"SafeGuard::cancelTransaction: transaction should be queued\");\n        timelock.cancelTransaction(target, value, signature, data, eta);\n    }\n}"
    },
    {
      "filename": "contracts/access/Ownable.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}"
    }
  ]
}