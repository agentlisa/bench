{
  "Title": "[M-01] Zero amount token transfers may cause a denial of service during liquidations",
  "Content": "\nSome ERC20 implementations revert on zero value transfers. Since liquidation rewards are based on a fraction of the available position's premiums, this may cause an accidental denial of service that prevents the successful execution of liquidations.\n\n### Impact\n\nLiquidations in the LAMM protocol are incentivized by a reward that is calculated as a fraction of the premiums available in the position.\n\n<https://github.com/code-423n4/2023-12-particle/blob/a3af40839b24aa13f5764d4f84933dbfa8bc8134/contracts/protocol/ParticlePositionManager.sol#L348-L354>\n\n```solidity\n348:         // calculate liquidation reward\n349:         liquidateCache.liquidationRewardFrom =\n350:             ((closeCache.tokenFromPremium) * LIQUIDATION_REWARD_FACTOR) /\n351:             uint128(Base.BASIS_POINT);\n352:         liquidateCache.liquidationRewardTo =\n353:             ((closeCache.tokenToPremium) * LIQUIDATION_REWARD_FACTOR) /\n354:             uint128(Base.BASIS_POINT);\n```\n\nThese amounts are later transferred to the caller, the liquidator, at the end of the `liquidatePosition()` function.\n\n<https://github.com/code-423n4/2023-12-particle/blob/a3af40839b24aa13f5764d4f84933dbfa8bc8134/contracts/protocol/ParticlePositionManager.sol#L376-L378>\n\n```solidity\n376:         // reward liquidator\n377:         TransferHelper.safeTransfer(closeCache.tokenFrom, msg.sender, liquidateCache.liquidationRewardFrom);\n378:         TransferHelper.safeTransfer(closeCache.tokenTo, msg.sender, liquidateCache.liquidationRewardTo);\n```\n\nReward amounts, `liquidationRewardFrom` and `liquidationRewardTo`, can be calculated as zero if `tokenFromPremium` or `tokenToPremium` are zero, if the liquidation ratio gets rounded down to zero, or if `LIQUIDATION_REWARD_FACTOR` is zero.\n\nCoupled with that fact that some ERC20 implementations [revert on zero value transfers](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#revert-on-zero-value-transfers), this can cause an accidental denial of service in the implementation of `liquidatePosition()`, blocking certain positions from being liquidated.\n\n### Recommendation\n\nCheck that the amounts are greater than zero before executing the transfer.\n\n```diff\n        // reward liquidator\n+       if (liquidateCache.liquidationRewardFrom > 0) {\n          TransferHelper.safeTransfer(closeCache.tokenFrom, msg.sender, liquidateCache.liquidationRewardFrom);\n+       }\n+       if (liquidateCache.liquidationRewardTo > 0) {\n          TransferHelper.safeTransfer(closeCache.tokenTo, msg.sender, liquidateCache.liquidationRewardTo);\n+       }\n```\n\n\n**[0xleastwood (Judge) commented](https://github.com/code-423n4/2023-12-particle-findings/issues/61#issuecomment-1866972456):**\n > Unlikely token type to even support in the first place. Probably more of a QA issue.\n\n**[wukong-particle (Particle) commented](https://github.com/code-423n4/2023-12-particle-findings/issues/61#issuecomment-1868223734):**\n > Agree with the judge. Though we can add a zero check to all transfers to potentially save gas. \n\n**[adriro (Warden) commented](https://github.com/code-423n4/2023-12-particle-findings/issues/61#issuecomment-1872538647):**\n > I believe this is similar to the issue that mentions tokens with blocklists (#31, judged as high) as both of these are non standard (in the strict sense of the standard), though it is of course fair to say that blocklists are more frequent (eg usdc, usdt). \n> \n> Note that the protocol doesn't have any sort of allow list to control which ERC20 tokens are supported inside the protocol, and anyone can open a position using any Uniswap pool, which also means any token. The main problem here is that liquidations can be blocked after a position is open, that's why I consider the med severity justified.\n\n**[0xleastwood (Judge) commented](https://github.com/code-423n4/2023-12-particle-findings/issues/61#issuecomment-1872943231):**\n > The difference being that there are little to no tokens supported across all lending platforms which revert on zero token transfer where there are almost always tokens supported with blocklists. \n >\n > I guess this can remain medium because anyone can LP into a position and protocol liveness should be highlighted here.\n\n **[wukong-particle (Particle) confirmed](https://github.com/code-423n4/2023-12-particle-findings/issues/61#issuecomment-1889804514)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-particle",
  "Code": [
    {
      "filename": "contracts/protocol/ParticlePositionManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IERC721Receiver} from \"../../lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {Multicall} from \"../../lib/openzeppelin-contracts/contracts/utils/Multicall.sol\";\nimport {ReentrancyGuard} from \"../../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport {Ownable2StepUpgradeable} from \"../../lib/openzeppelin-contracts-upgradeable/contracts/access/Ownable2StepUpgradeable.sol\";\nimport {UUPSUpgradeable} from \"../../lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol\";\nimport {TransferHelper} from \"../../lib/v3-periphery/contracts/libraries/TransferHelper.sol\";\n\nimport {IParticlePositionManager} from \"../interfaces/IParticlePositionManager.sol\";\nimport {Base} from \"../libraries/Base.sol\";\nimport {LiquidityPosition} from \"../libraries/LiquidityPosition.sol\";\nimport {Lien} from \"../libraries/Lien.sol\";\nimport {SwapPosition} from \"../libraries/SwapPosition.sol\";\nimport {DataStruct, DataCache} from \"../libraries/Structs.sol\";\nimport {Errors} from \"../libraries/Errors.sol\";\n\ncontract ParticlePositionManager is\n    IParticlePositionManager,\n    Ownable2StepUpgradeable,\n    UUPSUpgradeable,\n    IERC721Receiver,\n    ReentrancyGuard,\n    Multicall\n{\n    using LiquidityPosition for mapping(uint256 => LiquidityPosition.Info);\n    using Lien for mapping(bytes32 => Lien.Info);\n    using SwapPosition for mapping(bytes32 => SwapPosition.Info);\n\n    /* Constants */\n    uint256 private constant _TREASURY_RATE_MAX = 500_000;\n    uint256 private constant _FEE_FACTOR_MAX = 1_000;\n    uint128 private constant _LIQUIDATION_REWARD_FACTOR_MAX = 100_000;\n    uint256 private constant _LOAN_TERM_MAX = 30 days;\n\n    /* Variables */\n    uint96 private _nextRecordId; ///@dev used for both lien and swap\n    uint256 private _treasuryRate;\n    // solhint-disable var-name-mixedcase\n    address public DEX_AGGREGATOR;\n    uint256 public FEE_FACTOR;\n    uint128 public LIQUIDATION_REWARD_FACTOR;\n    uint256 public LOAN_TERM;\n    // solhint-enable var-name-mixedcase\n\n    /* Storage */\n    mapping(uint256 => LiquidityPosition.Info) public lps; ///@dev tokenId => liquidity position\n    mapping(bytes32 => Lien.Info) public liens; ///@dev (address, lienId) => lien\n    mapping(address => uint256) private _treasury; ///@dev address => amount\n\n    // required by openzeppelin UUPS module\n    // solhint-disable-next-line no-empty-blocks\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address dexAggregator,\n        uint256 feeFactor,\n        uint128 liquidationRewardFactor,\n        uint256 loanTerm,\n        uint256 treasuryRate\n    ) external initializer {\n        __UUPSUpgradeable_init();\n        __Ownable_init();\n        DEX_AGGREGATOR = dexAggregator;\n        FEE_FACTOR = feeFactor;\n        LIQUIDATION_REWARD_FACTOR = liquidationRewardFactor;\n        LOAN_TERM = loanTerm;\n        _treasuryRate = treasuryRate;\n    }\n\n    /*==============================================================\n                        Liquidity Provision Logic\n    ==============================================================*/\n\n    /// @inheritdoc IParticlePositionManager\n    function mint(\n        DataStruct.MintParams calldata params\n    )\n        external\n        override\n        nonReentrant\n        returns (uint256 tokenId, uint128 liquidity, uint256 amount0Minted, uint256 amount1Minted)\n    {\n        (tokenId, liquidity, amount0Minted, amount1Minted) = lps.mint(params);\n    }\n\n    /**\n     * @notice Receiver function upon ERC721 LP position transfer\n     * @dev LP must use safeTransferFrom to trigger onERC721Received\n     * @param from the address which previously owned the NFT\n     * @param tokenId the NFT identifier which is being transferred\n     */\n    function onERC721Received(\n        address,\n        address from,\n        uint256 tokenId,\n        bytes calldata\n    ) external override returns (bytes4) {\n        if (msg.sender == Base.UNI_POSITION_MANAGER_ADDR) {\n            // matched with Uniswap v3 position NFTs\n            lps[tokenId] = LiquidityPosition.Info({owner: from, renewalCutoffTime: 0, token0Owed: 0, token1Owed: 0});\n            (, , , , , , , uint128 liquidity, , , , ) = Base.UNI_POSITION_MANAGER.positions(tokenId);\n            emit LiquidityPosition.SupplyLiquidity(tokenId, from, liquidity);\n        }\n        return this.onERC721Received.selector;\n    }\n\n    /*==============================================================\n                       Liquidity Management Logic\n    ==============================================================*/\n\n    /// @inheritdoc IParticlePositionManager\n    function increaseLiquidity(\n        uint256 tokenId,\n        uint256 amount0,\n        uint256 amount1\n    ) external override nonReentrant returns (uint128 liquidity, uint256 amount0Added, uint256 amount1Added) {\n        (liquidity, amount0Added, amount1Added) = lps.increaseLiquidity(tokenId, amount0, amount1);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function decreaseLiquidity(\n        uint256 tokenId,\n        uint128 liquidity\n    ) external override nonReentrant returns (uint256 amount0Decreased, uint256 amount1Decreased) {\n        (amount0Decreased, amount1Decreased) = lps.decreaseLiquidity(tokenId, liquidity);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function collectLiquidity(\n        uint256 tokenId\n    ) external override nonReentrant returns (uint256 amount0Collected, uint256 amount1Collected) {\n        (amount0Collected, amount1Collected) = lps.collectLiquidity(tokenId);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function reclaimLiquidity(uint256 tokenId) external override nonReentrant {\n        lps.reclaimLiquidity(tokenId);\n    }\n\n    /*=============================================================\n                             Open Position\n    ==============================================================*/\n\n    /// @inheritdoc IParticlePositionManager\n    function openPosition(\n        DataStruct.OpenPositionParams calldata params\n    ) public override nonReentrant returns (uint96 lienId, uint256 collateralTo) {\n        if (params.liquidity == 0) revert Errors.InsufficientBorrow();\n\n        // local cache to avoid stack too deep\n        DataCache.OpenPositionCache memory cache;\n\n        // prepare data for swap\n        (\n            cache.tokenFrom,\n            cache.tokenTo,\n            cache.feeGrowthInside0LastX128,\n            cache.feeGrowthInside1LastX128,\n            cache.collateralFrom,\n            collateralTo\n        ) = Base.prepareLeverage(params.tokenId, params.liquidity, params.zeroForOne);\n\n        // decrease liquidity from LP position, pull the amount to this contract\n        (cache.amountFromBorrowed, cache.amountToBorrowed) = LiquidityPosition.decreaseLiquidity(\n            params.tokenId,\n            params.liquidity\n        );\n        LiquidityPosition.collectLiquidity(\n            params.tokenId,\n            uint128(cache.amountFromBorrowed),\n            uint128(cache.amountToBorrowed),\n            address(this)\n        );\n        if (!params.zeroForOne)\n            (cache.amountFromBorrowed, cache.amountToBorrowed) = (cache.amountToBorrowed, cache.amountFromBorrowed);\n\n        // transfer in enough collateral\n        if (params.marginFrom > 0) {\n            TransferHelper.safeTransferFrom(cache.tokenFrom, msg.sender, address(this), params.marginFrom);\n        }\n        if (params.marginTo > 0) {\n            TransferHelper.safeTransferFrom(cache.tokenTo, msg.sender, address(this), params.marginTo);\n        }\n\n        // pay for fee\n        if (FEE_FACTOR > 0) {\n            cache.feeAmount = ((params.marginFrom + cache.amountFromBorrowed) * FEE_FACTOR) / Base.BASIS_POINT;\n            cache.treasuryAmount = (cache.feeAmount * _treasuryRate) / Base.BASIS_POINT;\n            _treasury[cache.tokenFrom] += cache.treasuryAmount;\n            if (params.zeroForOne) {\n                lps.addTokensOwed(params.tokenId, uint128(cache.feeAmount - cache.treasuryAmount), 0);\n            } else {\n                lps.addTokensOwed(params.tokenId, 0, uint128(cache.feeAmount - cache.treasuryAmount));\n            }\n        }\n\n        // cannot swap more than available amount\n        if (params.amountSwap > params.marginFrom + cache.amountFromBorrowed - cache.feeAmount)\n            revert Errors.OverSpend();\n\n        // swap to meet the collateral requirement\n        (cache.amountSpent, cache.amountReceived) = Base.swap(\n            cache.tokenFrom,\n            cache.tokenTo,\n            params.amountSwap,\n            collateralTo - cache.amountToBorrowed - params.marginTo, // amount needed to meet requirement\n            DEX_AGGREGATOR,\n            params.data\n        );\n\n        // leftover amounts from the collateral are now premiums, and ensure enough premium is stored\n        if (params.zeroForOne) {\n            cache.token0PremiumPortion = Base.uint256ToUint24(\n                ((params.marginFrom + cache.amountFromBorrowed - cache.feeAmount - cache.amountSpent) *\n                    Base.BASIS_POINT) / cache.collateralFrom\n            );\n            cache.token1PremiumPortion = Base.uint256ToUint24(\n                ((cache.amountReceived + cache.amountToBorrowed + params.marginTo - collateralTo) * Base.BASIS_POINT) /\n                    collateralTo\n            );\n            if (\n                cache.token0PremiumPortion < params.tokenFromPremiumPortionMin ||\n                cache.token1PremiumPortion < params.tokenToPremiumPortionMin\n            ) revert Errors.InsufficientPremium();\n        } else {\n            cache.token1PremiumPortion = Base.uint256ToUint24(\n                ((params.marginFrom + cache.amountFromBorrowed - cache.feeAmount - cache.amountSpent) *\n                    Base.BASIS_POINT) / cache.collateralFrom\n            );\n            cache.token0PremiumPortion = Base.uint256ToUint24(\n                ((cache.amountReceived + cache.amountToBorrowed + params.marginTo - collateralTo) * Base.BASIS_POINT) /\n                    collateralTo\n            );\n            if (\n                cache.token0PremiumPortion < params.tokenToPremiumPortionMin ||\n                cache.token1PremiumPortion < params.tokenFromPremiumPortionMin\n            ) revert Errors.InsufficientPremium();\n        }\n\n        // create a new lien\n        liens[keccak256(abi.encodePacked(msg.sender, lienId = _nextRecordId++))] = Lien.Info({\n            tokenId: uint40(params.tokenId),\n            liquidity: params.liquidity,\n            token0PremiumPortion: cache.token0PremiumPortion,\n            token1PremiumPortion: cache.token1PremiumPortion,\n            startTime: uint32(block.timestamp),\n            feeGrowthInside0LastX128: cache.feeGrowthInside0LastX128,\n            feeGrowthInside1LastX128: cache.feeGrowthInside1LastX128,\n            zeroForOne: params.zeroForOne\n        });\n\n        emit OpenPosition(msg.sender, lienId, collateralTo);\n    }\n\n    /*=============================================================\n                             Close Position\n    ==============================================================*/\n\n    /// @inheritdoc IParticlePositionManager\n    function closePosition(DataStruct.ClosePositionParams calldata params) external override nonReentrant {\n        bytes32 lienKey = keccak256(abi.encodePacked(msg.sender, params.lienId));\n        Lien.Info memory lien = liens.getInfo(lienKey);\n\n        // check lien is valid\n        if (lien.liquidity == 0) revert Errors.RecordEmpty();\n\n        // delete lien from storage\n        delete liens[lienKey];\n\n        // local cache to avoid stack too deep\n        DataCache.ClosePositionCache memory cache;\n\n        // prepare data for swap back\n        ///@dev the token/collateralFrom and token/collateralTo are swapped compared to openPosition\n        (cache.tokenTo, cache.tokenFrom, , , cache.collateralTo, cache.collateralFrom) = Base.prepareLeverage(\n            lien.tokenId,\n            lien.liquidity,\n            lien.zeroForOne\n        );\n\n        // get the amount of premium in the lien\n        if (lien.zeroForOne) {\n            (cache.tokenToPremium, cache.tokenFromPremium) = Base.getPremium(\n                cache.collateralTo,\n                cache.collateralFrom,\n                lien.token0PremiumPortion,\n                lien.token1PremiumPortion\n            );\n        } else {\n            (cache.tokenFromPremium, cache.tokenToPremium) = Base.getPremium(\n                cache.collateralFrom,\n                cache.collateralTo,\n                lien.token0PremiumPortion,\n                lien.token1PremiumPortion\n            );\n        }\n\n        // execute actual position closing\n        _closePosition(params, cache, lien, msg.sender);\n\n        emit ClosePosition(msg.sender, lien.tokenId, cache.amountFromAdd, cache.amountToAdd);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function liquidatePosition(\n        DataStruct.ClosePositionParams calldata params,\n        address borrower\n    ) external override nonReentrant {\n        bytes32 lienKey = keccak256(abi.encodePacked(borrower, params.lienId));\n        Lien.Info memory lien = liens.getInfo(lienKey);\n\n        // check lien is valid\n        if (lien.liquidity == 0) revert Errors.RecordEmpty();\n\n        // local cache to avoid stack too deep\n        DataCache.ClosePositionCache memory closeCache;\n        DataCache.LiquidatePositionCache memory liquidateCache;\n\n        // get liquidation parameters\n        ///@dev calculate premium outside of _closePosition to allow liquidatePosition to take reward from premium\n        (\n            closeCache.tokenFrom,\n            closeCache.tokenTo,\n            liquidateCache.tokenFromOwed,\n            liquidateCache.tokenToOwed,\n            closeCache.tokenFromPremium,\n            closeCache.tokenToPremium,\n            closeCache.collateralFrom,\n\n        ) = Base.getOwedInfoConverted(\n            DataStruct.OwedInfoParams({\n                tokenId: lien.tokenId,\n                liquidity: lien.liquidity,\n                feeGrowthInside0LastX128: lien.feeGrowthInside0LastX128,\n                feeGrowthInside1LastX128: lien.feeGrowthInside1LastX128,\n                token0PremiumPortion: lien.token0PremiumPortion,\n                token1PremiumPortion: lien.token1PremiumPortion\n            }),\n            lien.zeroForOne\n        );\n\n        // calculate liquidation reward\n        liquidateCache.liquidationRewardFrom =\n            ((closeCache.tokenFromPremium) * LIQUIDATION_REWARD_FACTOR) /\n            uint128(Base.BASIS_POINT);\n        liquidateCache.liquidationRewardTo =\n            ((closeCache.tokenToPremium) * LIQUIDATION_REWARD_FACTOR) /\n            uint128(Base.BASIS_POINT);\n        closeCache.tokenFromPremium -= liquidateCache.liquidationRewardFrom;\n        closeCache.tokenToPremium -= liquidateCache.liquidationRewardTo;\n\n        // check for liquidation condition\n        ///@dev the liquidation condition is that\n        ///     (EITHER premium is not enough) OR (cutOffTime > startTime AND currentTime > startTime + LOAN_TERM)\n        if (\n            !((closeCache.tokenFromPremium < liquidateCache.tokenFromOwed ||\n                closeCache.tokenToPremium < liquidateCache.tokenToOwed) ||\n                (lien.startTime < lps.getRenewalCutoffTime(lien.tokenId) &&\n                    lien.startTime + LOAN_TERM < block.timestamp))\n        ) {\n            revert Errors.LiquidationNotMet();\n        }\n\n        // delete lien from storage\n        delete liens[lienKey];\n\n        // execute actual position closing\n        _closePosition(params, closeCache, lien, borrower);\n\n        // reward liquidator\n        TransferHelper.safeTransfer(closeCache.tokenFrom, msg.sender, liquidateCache.liquidationRewardFrom);\n        TransferHelper.safeTransfer(closeCache.tokenTo, msg.sender, liquidateCache.liquidationRewardTo);\n\n        emit LiquidatePosition(borrower, lien.tokenId, closeCache.amountFromAdd, closeCache.amountToAdd);\n    }\n\n    /**\n     * @notice Internal function to close a position\n     * @dev Caller must ensure either the msg.sender is borrower or liquidation condition is met\n     * @param params close position parameters\n     * @param cache local cache to avoid stack too deep\n     * @param lien lien info\n     * @param borrower borrower address\n     */\n    function _closePosition(\n        DataStruct.ClosePositionParams calldata params,\n        DataCache.ClosePositionCache memory cache,\n        Lien.Info memory lien,\n        address borrower\n    ) internal {\n        // optimistically use the input numbers to swap for repay\n        /// @dev amountSwap overspend will be caught by refundWithCheck step in below\n        (cache.amountSpent, cache.amountReceived) = Base.swap(\n            cache.tokenFrom,\n            cache.tokenTo,\n            params.amountSwap,\n            0, /// @dev we check cache.amountReceived is sufficient to repay LP in below\n            DEX_AGGREGATOR,\n            params.data\n        );\n\n        // based on borrowed liquidity, compute the required return amount\n        /// @dev the from-to swapping direction is reverted compared to openPosition\n        (cache.amountToAdd, cache.amountFromAdd) = Base.getRequiredRepay(lien.liquidity, lien.tokenId);\n        if (!lien.zeroForOne) (cache.amountToAdd, cache.amountFromAdd) = (cache.amountFromAdd, cache.amountToAdd);\n\n        // the liquidity to add must be no less than the available amount\n        /// @dev the max available amount contains the tokensOwed, will have another check in below at refundWithCheck\n        if (\n            cache.amountFromAdd > cache.collateralFrom + cache.tokenFromPremium - cache.amountSpent ||\n            cache.amountToAdd > cache.amountReceived + cache.tokenToPremium\n        ) {\n            revert Errors.InsufficientRepay();\n        }\n\n        // add liquidity back to borrower\n        if (lien.zeroForOne) {\n            (cache.liquidityAdded, cache.amountToAdd, cache.amountFromAdd) = LiquidityPosition.increaseLiquidity(\n                cache.tokenTo,\n                cache.tokenFrom,\n                lien.tokenId,\n                cache.amountToAdd,\n                cache.amountFromAdd\n            );\n        } else {\n            (cache.liquidityAdded, cache.amountFromAdd, cache.amountToAdd) = LiquidityPosition.increaseLiquidity(\n                cache.tokenFrom,\n                cache.tokenTo,\n                lien.tokenId,\n                cache.amountFromAdd,\n                cache.amountToAdd\n            );\n        }\n\n        // obtain the position's latest FeeGrowthInside after increaseLiquidity\n        (, , , , , , , , cache.feeGrowthInside0LastX128, cache.feeGrowthInside1LastX128, , ) = Base\n            .UNI_POSITION_MANAGER\n            .positions(lien.tokenId);\n\n        // caculate the amounts owed since last fee collection during the borrowing period\n        (cache.token0Owed, cache.token1Owed) = Base.getOwedFee(\n            cache.feeGrowthInside0LastX128,\n            cache.feeGrowthInside1LastX128,\n            lien.feeGrowthInside0LastX128,\n            lien.feeGrowthInside1LastX128,\n            lien.liquidity\n        );\n\n        // calculate the the amounts owed to LP up to the premium in the lien\n        // must ensure enough amount is left to pay for interest first, then send gains and fund left to borrower\n        ///@dev refundWithCheck ensures actual cannot be more than expected, since amount owed to LP is in actual,\n        ///     it ensures (1) on the collateralFrom part of refund, tokenOwed is covered, and (2) on the amountReceived\n        ///      part, received is no less than liquidity addback + token owed.\n        if (lien.zeroForOne) {\n            cache.token0Owed = cache.token0Owed < cache.tokenToPremium ? cache.token0Owed : cache.tokenToPremium;\n            cache.token1Owed = cache.token1Owed < cache.tokenFromPremium ? cache.token1Owed : cache.tokenFromPremium;\n            Base.refundWithCheck(\n                borrower,\n                cache.tokenFrom,\n                cache.collateralFrom + cache.tokenFromPremium,\n                cache.amountSpent + cache.amountFromAdd + cache.token1Owed\n            );\n            Base.refundWithCheck(\n                borrower,\n                cache.tokenTo,\n                cache.amountReceived + cache.tokenToPremium,\n                cache.amountToAdd + cache.token0Owed\n            );\n        } else {\n            cache.token0Owed = cache.token0Owed < cache.tokenFromPremium ? cache.token0Owed : cache.tokenFromPremium;\n            cache.token1Owed = cache.token1Owed < cache.tokenToPremium ? cache.token1Owed : cache.tokenToPremium;\n            Base.refundWithCheck(\n                borrower,\n                cache.tokenFrom,\n                cache.collateralFrom + cache.tokenFromPremium,\n                cache.amountSpent + cache.amountFromAdd + cache.token0Owed\n            );\n            Base.refundWithCheck(\n                borrower,\n                cache.tokenTo,\n                cache.amountReceived + cache.tokenToPremium,\n                cache.amountToAdd + cache.token1Owed\n            );\n        }\n\n        // pay for interest\n        lps.addTokensOwed(lien.tokenId, cache.token0Owed, cache.token1Owed);\n    }\n\n    /*=============================================================\n                             Premium Logic\n    ==============================================================*/\n\n    /// @inheritdoc IParticlePositionManager\n    function addPremium(uint96 lienId, uint128 premium0, uint128 premium1) external override nonReentrant {\n        bytes32 lienKey = keccak256(abi.encodePacked(msg.sender, lienId));\n        Lien.Info memory lien = liens.getInfo(lienKey);\n\n        // check lien is valid\n        if (lien.liquidity == 0) revert Errors.RecordEmpty();\n\n        // check LP allows extension of this lien\n        if (lps.getRenewalCutoffTime(lien.tokenId) > lien.startTime) revert Errors.RenewalDisabled();\n\n        (, , address token0, address token1, , int24 tickLower, int24 tickUpper, , , , , ) = Base\n            .UNI_POSITION_MANAGER\n            .positions(lien.tokenId);\n        (uint256 collateral0, uint256 collateral1) = Base.getRequiredCollateral(lien.liquidity, tickLower, tickUpper);\n\n        (uint128 token0Premium, uint128 token1Premium) = Base.getPremium(\n            collateral0,\n            collateral1,\n            lien.token0PremiumPortion,\n            lien.token1PremiumPortion\n        );\n\n        liens.updatePremium(\n            lienKey,\n            uint24(((token0Premium + premium0) * Base.BASIS_POINT) / collateral0),\n            uint24(((token1Premium + premium1) * Base.BASIS_POINT) / collateral1)\n        );\n\n        // transfer in added premium\n        if (premium0 > 0) {\n            TransferHelper.safeTransferFrom(token0, msg.sender, address(this), premium0);\n        }\n        if (premium1 > 0) {\n            TransferHelper.safeTransferFrom(token1, msg.sender, address(this), premium1);\n        }\n\n        emit AddPremium(msg.sender, lienId, premium0, premium1);\n    }\n\n    /*=============================================================\n                              Vanilla Swap\n    ==============================================================*/\n\n    /// @inheritdoc IParticlePositionManager\n    function swap(\n        address token0,\n        address token1,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        bytes calldata data\n    ) external override nonReentrant returns (uint256 amount0, uint256 amount1) {\n        (amount0, amount1) = SwapPosition.swap(token0, token1, amountIn, amountOutMinimum, DEX_AGGREGATOR, data);\n    }\n\n    /*=============================================================\n                              Admin logic\n    ==============================================================*/\n\n    /// @inheritdoc IParticlePositionManager\n    function updateDexAggregator(address dexAggregator) external override onlyOwner {\n        if (dexAggregator == address(0)) revert Errors.InvalidValue();\n        DEX_AGGREGATOR = dexAggregator;\n        emit UpdateDexAggregator(dexAggregator);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function updateLiquidationRewardFactor(uint128 liquidationRewardFactor) external override onlyOwner {\n        if (liquidationRewardFactor > _LIQUIDATION_REWARD_FACTOR_MAX) revert Errors.InvalidValue();\n        LIQUIDATION_REWARD_FACTOR = liquidationRewardFactor;\n        emit UpdateLiquidationRewardFactor(liquidationRewardFactor);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function updateFeeFactor(uint256 feeFactor) external override onlyOwner {\n        if (feeFactor > _FEE_FACTOR_MAX) revert Errors.InvalidValue();\n        FEE_FACTOR = feeFactor;\n        emit UpdateFeeFactor(feeFactor);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function updateLoanTerm(uint256 loanTerm) external override onlyOwner {\n        if (loanTerm > _LOAN_TERM_MAX) revert Errors.InvalidValue();\n        LOAN_TERM = loanTerm;\n        emit UpdateLoanTerm(loanTerm);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function updateTreasuryRate(uint256 treasuryRate) external override onlyOwner {\n        if (treasuryRate > _TREASURY_RATE_MAX) revert Errors.InvalidValue();\n        _treasuryRate = treasuryRate;\n        emit UpdateTreasuryRate(treasuryRate);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function withdrawTreasury(address token, address recipient) external override onlyOwner nonReentrant {\n        uint256 withdrawAmount = _treasury[token];\n        if (withdrawAmount > 0) {\n            if (recipient == address(0)) {\n                revert Errors.InvalidRecipient();\n            }\n            _treasury[token] = 0;\n            TransferHelper.safeTransfer(token, recipient, withdrawAmount);\n            emit WithdrawTreasury(token, recipient, withdrawAmount);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/protocol/ParticlePositionManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IERC721Receiver} from \"../../lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {Multicall} from \"../../lib/openzeppelin-contracts/contracts/utils/Multicall.sol\";\nimport {ReentrancyGuard} from \"../../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport {Ownable2StepUpgradeable} from \"../../lib/openzeppelin-contracts-upgradeable/contracts/access/Ownable2StepUpgradeable.sol\";\nimport {UUPSUpgradeable} from \"../../lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol\";\nimport {TransferHelper} from \"../../lib/v3-periphery/contracts/libraries/TransferHelper.sol\";\n\nimport {IParticlePositionManager} from \"../interfaces/IParticlePositionManager.sol\";\nimport {Base} from \"../libraries/Base.sol\";\nimport {LiquidityPosition} from \"../libraries/LiquidityPosition.sol\";\nimport {Lien} from \"../libraries/Lien.sol\";\nimport {SwapPosition} from \"../libraries/SwapPosition.sol\";\nimport {DataStruct, DataCache} from \"../libraries/Structs.sol\";\nimport {Errors} from \"../libraries/Errors.sol\";\n\ncontract ParticlePositionManager is\n    IParticlePositionManager,\n    Ownable2StepUpgradeable,\n    UUPSUpgradeable,\n    IERC721Receiver,\n    ReentrancyGuard,\n    Multicall\n{\n    using LiquidityPosition for mapping(uint256 => LiquidityPosition.Info);\n    using Lien for mapping(bytes32 => Lien.Info);\n    using SwapPosition for mapping(bytes32 => SwapPosition.Info);\n\n    /* Constants */\n    uint256 private constant _TREASURY_RATE_MAX = 500_000;\n    uint256 private constant _FEE_FACTOR_MAX = 1_000;\n    uint128 private constant _LIQUIDATION_REWARD_FACTOR_MAX = 100_000;\n    uint256 private constant _LOAN_TERM_MAX = 30 days;\n\n    /* Variables */\n    uint96 private _nextRecordId; ///@dev used for both lien and swap\n    uint256 private _treasuryRate;\n    // solhint-disable var-name-mixedcase\n    address public DEX_AGGREGATOR;\n    uint256 public FEE_FACTOR;\n    uint128 public LIQUIDATION_REWARD_FACTOR;\n    uint256 public LOAN_TERM;\n    // solhint-enable var-name-mixedcase\n\n    /* Storage */\n    mapping(uint256 => LiquidityPosition.Info) public lps; ///@dev tokenId => liquidity position\n    mapping(bytes32 => Lien.Info) public liens; ///@dev (address, lienId) => lien\n    mapping(address => uint256) private _treasury; ///@dev address => amount\n\n    // required by openzeppelin UUPS module\n    // solhint-disable-next-line no-empty-blocks\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address dexAggregator,\n        uint256 feeFactor,\n        uint128 liquidationRewardFactor,\n        uint256 loanTerm,\n        uint256 treasuryRate\n    ) external initializer {\n        __UUPSUpgradeable_init();\n        __Ownable_init();\n        DEX_AGGREGATOR = dexAggregator;\n        FEE_FACTOR = feeFactor;\n        LIQUIDATION_REWARD_FACTOR = liquidationRewardFactor;\n        LOAN_TERM = loanTerm;\n        _treasuryRate = treasuryRate;\n    }\n\n    /*==============================================================\n                        Liquidity Provision Logic\n    ==============================================================*/\n\n    /// @inheritdoc IParticlePositionManager\n    function mint(\n        DataStruct.MintParams calldata params\n    )\n        external\n        override\n        nonReentrant\n        returns (uint256 tokenId, uint128 liquidity, uint256 amount0Minted, uint256 amount1Minted)\n    {\n        (tokenId, liquidity, amount0Minted, amount1Minted) = lps.mint(params);\n    }\n\n    /**\n     * @notice Receiver function upon ERC721 LP position transfer\n     * @dev LP must use safeTransferFrom to trigger onERC721Received\n     * @param from the address which previously owned the NFT\n     * @param tokenId the NFT identifier which is being transferred\n     */\n    function onERC721Received(\n        address,\n        address from,\n        uint256 tokenId,\n        bytes calldata\n    ) external override returns (bytes4) {\n        if (msg.sender == Base.UNI_POSITION_MANAGER_ADDR) {\n            // matched with Uniswap v3 position NFTs\n            lps[tokenId] = LiquidityPosition.Info({owner: from, renewalCutoffTime: 0, token0Owed: 0, token1Owed: 0});\n            (, , , , , , , uint128 liquidity, , , , ) = Base.UNI_POSITION_MANAGER.positions(tokenId);\n            emit LiquidityPosition.SupplyLiquidity(tokenId, from, liquidity);\n        }\n        return this.onERC721Received.selector;\n    }\n\n    /*==============================================================\n                       Liquidity Management Logic\n    ==============================================================*/\n\n    /// @inheritdoc IParticlePositionManager\n    function increaseLiquidity(\n        uint256 tokenId,\n        uint256 amount0,\n        uint256 amount1\n    ) external override nonReentrant returns (uint128 liquidity, uint256 amount0Added, uint256 amount1Added) {\n        (liquidity, amount0Added, amount1Added) = lps.increaseLiquidity(tokenId, amount0, amount1);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function decreaseLiquidity(\n        uint256 tokenId,\n        uint128 liquidity\n    ) external override nonReentrant returns (uint256 amount0Decreased, uint256 amount1Decreased) {\n        (amount0Decreased, amount1Decreased) = lps.decreaseLiquidity(tokenId, liquidity);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function collectLiquidity(\n        uint256 tokenId\n    ) external override nonReentrant returns (uint256 amount0Collected, uint256 amount1Collected) {\n        (amount0Collected, amount1Collected) = lps.collectLiquidity(tokenId);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function reclaimLiquidity(uint256 tokenId) external override nonReentrant {\n        lps.reclaimLiquidity(tokenId);\n    }\n\n    /*=============================================================\n                             Open Position\n    ==============================================================*/\n\n    /// @inheritdoc IParticlePositionManager\n    function openPosition(\n        DataStruct.OpenPositionParams calldata params\n    ) public override nonReentrant returns (uint96 lienId, uint256 collateralTo) {\n        if (params.liquidity == 0) revert Errors.InsufficientBorrow();\n\n        // local cache to avoid stack too deep\n        DataCache.OpenPositionCache memory cache;\n\n        // prepare data for swap\n        (\n            cache.tokenFrom,\n            cache.tokenTo,\n            cache.feeGrowthInside0LastX128,\n            cache.feeGrowthInside1LastX128,\n            cache.collateralFrom,"
    }
  ]
}