{
  "Title": "[M-02] NFT creator sales revenue recipients can steal gas",
  "Content": "_Submitted by berndartmueller, also found by 0xHarry, peritoflores, and shenwilly_\n\nSelling a NFT with `NFTDropMarketFixedPriceSale.mintFromFixedPriceSale` distributes the revenue from the sale to various recipients with the `MarketFees._distributeFunds` function.\n\nRecipients:\n\n*   NFT creator(s)\n*   NFT seller\n*   Protocol\n*   Buy referrer (optional)\n\nIt is possible to have multiple NFT creators. Sale revenue will be distributed to each NFT creator address. Revenue distribution is done by calling `SendValueWithFallbackWithdraw._sendValueWithFallbackWithdraw` and providing an appropriate gas limit to prevent consuming too much gas. For the revenue distribution to the seller, protocol and the buy referrer, a gas limit of `SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT = 20_000` is used. However, for the creators, a limit of `SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS = 210_000` is used. This higher amount of gas is used if `PercentSplitETH` is used as a recipient.\n\nA maximum of `MAX_ROYALTY_RECIPIENTS = 5` NFT creator recipients are allowed.\n\nFor example, a once honest NFT collection and its 5 royalty creator recipients could turn \"malicious\" and could \"steal\" gas from NFT buyers on each NFT sale and therefore grief NFT sales. On each NFT sell, the 5 creator recipients (smart contracts) could consume the full amount of `SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS = 210_000` forwarded gas. Totalling `5 * 210_000 = 1_050_000` gas. With a gas price of e.g. `20 gwei`, this equals to additional gas costs of `21_000_000 gwei = 0.028156 eth`, with a `ETH` price of `2000`, this would total to \\~`56.31 $` additional costs.\n\n### Proof of Concept\n\n[mixins/shared/MarketFees.sol#L130](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/shared/MarketFees.sol#L130)\n\n```solidity\n/**\n  * @notice Distributes funds to foundation, creator recipients, and NFT owner after a sale.\n  */\nfunction _distributeFunds(\n  address nftContract,\n  uint256 tokenId,\n  address payable seller,\n  uint256 price,\n  address payable buyReferrer\n)\n  internal\n  returns (\n    uint256 totalFees,\n    uint256 creatorRev,\n    uint256 sellerRev\n  )\n{\n  address payable[] memory creatorRecipients;\n  uint256[] memory creatorShares;\n\n  uint256 buyReferrerFee;\n  (totalFees, creatorRecipients, creatorShares, sellerRev, buyReferrerFee) = _getFees(\n    nftContract,\n    tokenId,\n    seller,\n    price,\n    buyReferrer\n  );\n\n  // Pay the creator(s)\n  unchecked {\n    for (uint256 i = 0; i < creatorRecipients.length; ++i) {\n      _sendValueWithFallbackWithdraw(\n        creatorRecipients[i],\n        creatorShares[i],\n        SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS // @audit-info A higher amount of gas is forwarded to creator recipients\n      );\n      // Sum the total creator rev from shares\n      // creatorShares is in ETH so creatorRev will not overflow here.\n      creatorRev += creatorShares[i];\n    }\n  }\n\n  // Pay the seller\n  _sendValueWithFallbackWithdraw(seller, sellerRev, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n\n  // Pay the protocol fee\n  _sendValueWithFallbackWithdraw(getFoundationTreasury(), totalFees, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n\n  // Pay the buy referrer fee\n  if (buyReferrerFee != 0) {\n    _sendValueWithFallbackWithdraw(buyReferrer, buyReferrerFee, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n    emit BuyReferralPaid(nftContract, tokenId, buyReferrer, buyReferrerFee, 0);\n    unchecked {\n      // Add the referrer fee back into the total fees so that all 3 return fields sum to the total price for events\n      totalFees += buyReferrerFee;\n    }\n  }\n}\n```\n\n### Recommended Mitigation Steps\n\nConsider only providing a higher amount of gas (`SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS`) for the first creator recipient. For all following creator recipients, only forward the reduced amount of gas `SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT`.\n\n**[HardlyDifficult (Foundation) confirmed and commented](https://github.com/code-423n4/2022-08-foundation-findings/issues/165#issuecomment-1220553946):**\n > We will be making changes here.\n> \n> This seems like a Low risk issue since only gas is at risk, but protecting our collectors is an important goal so we are comfortable with Medium here.\n> \n> As the warden has noted, we use gas caps consistently when interacting with external addresses/contracts. This is important to ensure that the cost to collectors does not become unwieldy.. and that the calls cannot revert (e.g. if the receiver gets stuck in a loop).\n> \n> The gas limits we set are high enough to allow some custom logic to be performed, and to support smart contract wallets such as Gnosis Safe. For the scenario highlighted here, we have used a very high limit in order to work with contracts such as PercentSplitETH (which will push payments to up to 5 different recipients, and those recipients may be smart contract wallets themselves).\n> \n> However we were too flexible here. And in total, the max potential gas costs are higher than they should be. We have changed the logic to only use `SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS` when 1 recipient is defined, otherwise use `SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT`. This will support our PercentSplitETH scenario and use cases like it, while restricting the worst case scenario to something much more reasonable.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-08-foundation-findings/issues/165#issuecomment-1228026327):**\n > Keeping the Medium severity because users are potentially paying more than necessary.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-08-foundation-drop-contest",
  "Code": [
    {
      "filename": "contracts/mixins/shared/MarketFees.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@manifoldxyz/royalty-registry-solidity/contracts/IRoyaltyRegistry.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport \"../../interfaces/IGetFees.sol\";\nimport \"../../interfaces/IGetRoyalties.sol\";\nimport \"../../interfaces/IOwnable.sol\";\nimport \"../../interfaces/IRoyaltyInfo.sol\";\nimport \"../../interfaces/ITokenCreator.sol\";\n\nimport \"../../libraries/ArrayLibrary.sol\";\n\nimport \"./Constants.sol\";\nimport \"./FoundationTreasuryNode.sol\";\nimport \"./OZERC165Checker.sol\";\nimport \"./SendValueWithFallbackWithdraw.sol\";\nimport \"./MarketSharedCore.sol\";\n\nerror NFTMarketFees_Address_Does_Not_Support_IRoyaltyRegistry();\n\n/**\n * @title A mixin to distribute funds when an NFT is sold.\n */\nabstract contract MarketFees is FoundationTreasuryNode, MarketSharedCore, SendValueWithFallbackWithdraw {\n  using AddressUpgradeable for address;\n  using ArrayLibrary for address payable[];\n  using ArrayLibrary for uint256[];\n  using ERC165Checker for address;\n  using OZERC165Checker for address;\n\n  /**\n   * @dev Removing old unused variables in an upgrade safe way. Was:\n   * uint256 private _primaryFoundationFeeBasisPoints;\n   * uint256 private _secondaryFoundationFeeBasisPoints;\n   * uint256 private _secondaryCreatorFeeBasisPoints;\n   * mapping(address => mapping(uint256 => bool)) private _nftContractToTokenIdToFirstSaleCompleted;\n   */\n  uint256[4] private __gap_was_fees;\n\n  /// @notice The royalties sent to creator recipients on secondary sales.\n  uint256 private constant CREATOR_ROYALTY_DENOMINATOR = BASIS_POINTS / 1000; // 10%\n  /// @notice The fee collected by Foundation for sales facilitated by this market contract.\n  uint256 private constant PROTOCOL_FEE_DENOMINATOR = BASIS_POINTS / 500; // 5%\n  /// @notice The fee collected by the buy referrer for sales facilitated by this market contract.\n  ///         This fee is calculated from the total protocol fee.\n  /// @dev 20% of protocol fee == 1% of total sale.\n  uint256 private constant BUY_REFERRER_PROTOCOL_FEE_DENOMINATOR = 5;\n\n  IRoyaltyRegistry private immutable royaltyRegistry;\n\n  /// @notice The address of this contract's implementation.\n  /// @dev This is used when making stateless external calls to this contract,\n  /// saving gas over hopping through the proxy which is only necessary when accessing state.\n  MarketFees private immutable implementationAddress;\n\n  /// @notice True for the Drop market which only performs primary sales. False if primary & secondary are supported.\n  bool private immutable assumePrimarySale;\n\n  /**\n   * @notice Emitted when a NFT sold with a referrer.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param buyReferrer The account which received the buy referral incentive.\n   * @param buyReferrerFee The portion of the protocol fee collected by the buy referrer.\n   * @param buyReferrerSellerFee The portion of the owner revenue collected by the buy referrer (not implemented).\n   */\n  event BuyReferralPaid(\n    address indexed nftContract,\n    uint256 indexed tokenId,\n    address buyReferrer,\n    uint256 buyReferrerFee,\n    uint256 buyReferrerSellerFee\n  );\n\n  /**\n   * @notice Configures the registry allowing for royalty overrides to be defined.\n   * @param _royaltyRegistry The registry to use for royalty overrides.\n   */\n  constructor(address _royaltyRegistry, bool _assumePrimarySale) {\n    if (!_royaltyRegistry.supportsInterface(type(IRoyaltyRegistry).interfaceId)) {\n      revert NFTMarketFees_Address_Does_Not_Support_IRoyaltyRegistry();\n    }\n    royaltyRegistry = IRoyaltyRegistry(_royaltyRegistry);\n\n    assumePrimarySale = _assumePrimarySale;\n\n    // In the constructor, `this` refers to the implementation address. Everywhere else it'll be the proxy.\n    implementationAddress = this;\n  }\n\n  /**\n   * @notice Distributes funds to foundation, creator recipients, and NFT owner after a sale.\n   */\n  function _distributeFunds(\n    address nftContract,\n    uint256 tokenId,\n    address payable seller,\n    uint256 price,\n    address payable buyReferrer\n  )\n    internal\n    returns (\n      uint256 totalFees,\n      uint256 creatorRev,\n      uint256 sellerRev\n    )\n  {\n    address payable[] memory creatorRecipients;\n    uint256[] memory creatorShares;\n\n    uint256 buyReferrerFee;\n    (totalFees, creatorRecipients, creatorShares, sellerRev, buyReferrerFee) = _getFees(\n      nftContract,\n      tokenId,\n      seller,\n      price,\n      buyReferrer\n    );\n\n    // Pay the creator(s)\n    unchecked {\n      for (uint256 i = 0; i < creatorRecipients.length; ++i) {\n        _sendValueWithFallbackWithdraw(\n          creatorRecipients[i],\n          creatorShares[i],\n          SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS\n        );\n        // Sum the total creator rev from shares\n        // creatorShares is in ETH so creatorRev will not overflow here.\n        creatorRev += creatorShares[i];\n      }\n    }\n\n    // Pay the seller\n    _sendValueWithFallbackWithdraw(seller, sellerRev, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n\n    // Pay the protocol fee\n    _sendValueWithFallbackWithdraw(getFoundationTreasury(), totalFees, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n\n    // Pay the buy referrer fee\n    if (buyReferrerFee != 0) {\n      _sendValueWithFallbackWithdraw(buyReferrer, buyReferrerFee, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n      emit BuyReferralPaid(nftContract, tokenId, buyReferrer, buyReferrerFee, 0);\n      unchecked {\n        // Add the referrer fee back into the total fees so that all 3 return fields sum to the total price for events\n        totalFees += buyReferrerFee;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns how funds will be distributed for a sale at the given price point.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param price The sale price to calculate the fees for.\n   * @return totalFees How much will be sent to the Foundation treasury and/or referrals.\n   * @return creatorRev How much will be sent across all the `creatorRecipients` defined.\n   * @return creatorRecipients The addresses of the recipients to receive a portion of the creator fee.\n   * @return creatorShares The percentage of the creator fee to be distributed to each `creatorRecipient`.\n   * If there is only one `creatorRecipient`, this may be an empty array.\n   * Otherwise `creatorShares.length` == `creatorRecipients.length`.\n   * @return sellerRev How much will be sent to the owner/seller of the NFT.\n   * If the NFT is being sold by the creator, this may be 0 and the full revenue will appear as `creatorRev`.\n   * @return seller The address of the owner of the NFT.\n   * If `sellerRev` is 0, this may be `address(0)`.\n   */\n  function getFeesAndRecipients(\n    address nftContract,\n    uint256 tokenId,\n    uint256 price\n  )\n    external\n    view\n    returns (\n      uint256 totalFees,\n      uint256 creatorRev,\n      address payable[] memory creatorRecipients,\n      uint256[] memory creatorShares,\n      uint256 sellerRev,\n      address payable seller\n    )\n  {\n    seller = _getSellerOrOwnerOf(nftContract, tokenId);\n    (totalFees, creatorRecipients, creatorShares, sellerRev, ) = _getFees(\n      nftContract,\n      tokenId,\n      seller,\n      price,\n      // TODO add referral info\n      payable(0)\n    );\n\n    // Sum the total creator rev from shares\n    for (uint256 i = 0; i < creatorShares.length; ++i) {\n      creatorRev += creatorShares[i];\n    }\n  }\n\n  /**\n   * @notice Returns the address of the registry allowing for royalty configuration overrides.\n   * @dev See https://royaltyregistry.xyz/\n   * @return registry The address of the royalty registry contract.\n   */\n  function getRoyaltyRegistry() external view returns (address registry) {\n    return address(royaltyRegistry);\n  }\n\n  /**\n   * @notice **For internal use only.**\n   * @dev This function is external to allow using try/catch but is not intended for external use.\n   * This checks the token creator.\n   */\n  function internalGetTokenCreator(address nftContract, uint256 tokenId)\n    external\n    view\n    returns (address payable creator)\n  {\n    creator = ITokenCreator(nftContract).tokenCreator{ gas: READ_ONLY_GAS_LIMIT }(tokenId);\n  }\n\n  /**\n   * @notice **For internal use only.**\n   * @dev This function is external to allow using try/catch but is not intended for external use.\n   * If ERC2981 royalties (or getRoyalties) are defined by the NFT contract, allow this standard to define immutable\n   * royalties that cannot be later changed via the royalty registry.\n   */\n  function internalGetImmutableRoyalties(address nftContract, uint256 tokenId)\n    external\n    view\n    returns (address payable[] memory recipients, uint256[] memory splitPerRecipientInBasisPoints)\n  {\n    // 1st priority: ERC-2981\n    if (nftContract.supportsERC165InterfaceUnchecked(type(IRoyaltyInfo).interfaceId)) {\n      try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (\n        address receiver,\n        uint256 royaltyAmount\n      ) {\n        // Manifold contracts return (address(this), 0) when royalties are not defined\n        // - so ignore results when the amount is 0\n        if (royaltyAmount > 0) {\n          recipients = new address payable[](1);\n          recipients[0] = payable(receiver);\n          splitPerRecipientInBasisPoints = new uint256[](1);\n          // The split amount is assumed to be 100% when only 1 recipient is returned\n          return (recipients, splitPerRecipientInBasisPoints);\n        }\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Fall through\n      }\n    }\n\n    // 2nd priority: getRoyalties\n    if (nftContract.supportsERC165InterfaceUnchecked(type(IGetRoyalties).interfaceId)) {\n      try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n        address payable[] memory _recipients,\n        uint256[] memory recipientBasisPoints\n      ) {\n        if (_recipients.length != 0 && _recipients.length == recipientBasisPoints.length) {\n          return (_recipients, recipientBasisPoints);\n        }\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Fall through\n      }\n    }\n  }\n\n  /**\n   * @notice **For internal use only.**\n   * @dev This function is external to allow using try/catch but is not intended for external use.\n   * This checks for royalties defined in the royalty registry or via a non-standard royalty API.\n   */\n  // solhint-disable-next-line code-complexity\n  function internalGetMutableRoyalties(\n    address nftContract,\n    uint256 tokenId,\n    address payable creator\n  ) external view returns (address payable[] memory recipients, uint256[] memory splitPerRecipientInBasisPoints) {\n    /* Overrides must support ERC-165 when registered, except for overrides defined by the registry owner.\n       If that results in an override w/o 165 we may need to upgrade the market to support or ignore that override. */\n    // The registry requires overrides are not 0 and contracts when set.\n    // If no override is set, the nftContract address is returned.\n\n    try royaltyRegistry.getRoyaltyLookupAddress{ gas: READ_ONLY_GAS_LIMIT }(nftContract) returns (\n      address overrideContract\n    ) {\n      if (overrideContract != nftContract) {\n        nftContract = overrideContract;\n\n        // The functions above are repeated here if an override is set.\n\n        // 3rd priority: ERC-2981 override\n        if (nftContract.supportsERC165InterfaceUnchecked(type(IRoyaltyInfo).interfaceId)) {\n          try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (\n            address receiver,\n            uint256 /* royaltyAmount */\n          ) {\n            recipients = new address payable[](1);\n            recipients[0] = payable(receiver);\n            splitPerRecipientInBasisPoints = new uint256[](1);\n            // The split amount is assumed to be 100% when only 1 recipient is returned\n            return (recipients, splitPerRecipientInBasisPoints);\n          } catch // solhint-disable-next-line no-empty-blocks\n          {\n            // Fall through\n          }\n        }\n\n        // 4th priority: getRoyalties override\n        if (recipients.length == 0 && nftContract.supportsERC165InterfaceUnchecked(type(IGetRoyalties).interfaceId)) {\n          try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n            address payable[] memory _recipients,\n            uint256[] memory recipientBasisPoints\n          ) {\n            if (_recipients.length != 0 && _recipients.length == recipientBasisPoints.length) {\n              return (_recipients, recipientBasisPoints);\n            }\n          } catch // solhint-disable-next-line no-empty-blocks\n          {\n            // Fall through\n          }\n        }\n      }\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Ignore out of gas errors and continue using the nftContract address\n    }\n\n    // 5th priority: getFee* from contract or override\n    if (nftContract.supportsERC165InterfaceUnchecked(type(IGetFees).interfaceId)) {\n      try IGetFees(nftContract).getFeeRecipients{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n        address payable[] memory _recipients\n      ) {\n        if (_recipients.length != 0) {\n          try IGetFees(nftContract).getFeeBps{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n            uint256[] memory recipientBasisPoints\n          ) {\n            if (_recipients.length == recipientBasisPoints.length) {\n              return (_recipients, recipientBasisPoints);\n            }\n          } catch // solhint-disable-next-line no-empty-blocks\n          {\n            // Fall through\n          }\n        }\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Fall through\n      }\n    }\n\n    // 6th priority: tokenCreator w/ or w/o requiring 165 from contract or override\n    if (creator != address(0)) {\n      // Only pay the tokenCreator if there wasn't another royalty defined\n      recipients = new address payable[](1);\n      recipients[0] = creator;\n      splitPerRecipientInBasisPoints = new uint256[](1);\n      // The split amount is assumed to be 100% when only 1 recipient is returned\n      return (recipients, splitPerRecipientInBasisPoints);\n    }\n\n    // 7th priority: owner from contract or override\n    try IOwnable(nftContract).owner{ gas: READ_ONLY_GAS_LIMIT }() returns (address owner) {\n      if (owner != address(0)) {\n        // Only pay the owner if there wasn't another royalty defined\n        recipients = new address payable[](1);\n        recipients[0] = payable(owner);\n        splitPerRecipientInBasisPoints = new uint256[](1);\n        // The split amount is assumed to be 100% when only 1 recipient is returned\n        return (recipients, splitPerRecipientInBasisPoints);\n      }\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Fall through\n    }\n\n    // If no valid payment address or creator is found, return 0 recipients\n  }\n\n  /**\n   * @notice Calculates how funds should be distributed for the given sale details.\n   * @dev When the NFT is being sold by the `tokenCreator`, all the seller revenue will\n   * be split with the royalty recipients defined for that NFT.\n   */\n  // solhint-disable-next-line code-complexity\n  function _getFees(\n    address nftContract,\n    uint256 tokenId,\n    address payable seller,\n    uint256 price,\n    address payable buyReferrer\n  )\n    private\n    view\n    returns (\n      uint256 totalFees,\n      address payable[] memory creatorRecipients,\n      uint256[] memory creatorShares,\n      uint256 sellerRev,\n      uint256 buyReferrerFee\n    )\n  {\n    // Calculate the protocol fee\n    unchecked {\n      // SafeMath is not required when dividing by a non-zero constant.\n      totalFees = price / PROTOCOL_FEE_DENOMINATOR;\n    }\n\n    address payable creator;\n    try implementationAddress.internalGetTokenCreator(nftContract, tokenId) returns (address payable _creator) {\n      creator = _creator;\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Fall through\n    }\n\n    try implementationAddress.internalGetImmutableRoyalties(nftContract, tokenId) returns (\n      address payable[] memory _recipients,\n      uint256[] memory _splitPerRecipientInBasisPoints\n    ) {\n      (creatorRecipients, creatorShares) = (_recipients, _splitPerRecipientInBasisPoints);\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Fall through\n    }\n\n    if (creatorRecipients.length == 0) {\n      // Check mutable royalties only if we didn't find results from the immutable API\n      try implementationAddress.internalGetMutableRoyalties(nftContract, tokenId, creator) returns (\n        address payable[] memory _recipients,\n        uint256[] memory _splitPerRecipientInBasisPoints\n      ) {\n        (creatorRecipients, creatorShares) = (_recipients, _splitPerRecipientInBasisPoints);\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Fall through\n      }\n    }\n\n    if (creatorRecipients.length != 0 || assumePrimarySale) {\n      uint256 creatorRev;\n      if (assumePrimarySale) {\n        // All revenue should go to the creator recipients\n        unchecked {\n          // totalFees is always < price.\n          creatorRev = price - totalFees;\n        }\n        if (creatorRecipients.length == 0) {\n          // If no creators were found via the royalty APIs, then set that recipient to the seller's address\n          creatorRecipients = new address payable[](1);\n          creatorRecipients[0] = seller;\n          creatorShares = new uint256[](1);\n          // The split amount is assumed to be 100% when only 1 recipient is returned\n        }\n      } else if (seller == creator || (creatorRecipients.length == 1 && seller == creatorRecipients[0])) {\n        // When sold by the creator, all revenue is split if applicable.\n        // If the seller is unknown, assume it's being sold by the creator.\n        unchecked {\n          // totalFees is always < price.\n          creatorRev = price - totalFees;\n        }\n      } else {\n        // Rounding favors the owner first, then creator, and foundation last.\n        unchecked {\n          // SafeMath is not required when dividing by a non-zero constant.\n          creatorRev = price / CREATOR_ROYALTY_DENOMINATOR;\n        }\n        sellerRev = price - totalFees - creatorRev;\n      }\n\n      // Cap the max number of recipients supported\n      creatorRecipients.capLength(MAX_ROYALTY_RECIPIENTS);\n      creatorShares.capLength(MAX_ROYALTY_RECIPIENTS);\n\n      // Sum the total shares defined\n      uint256 totalShares;\n      if (creatorRecipients.length > 1) {\n        unchecked {\n          for (uint256 i = 0; i < creatorRecipients.length; ++i) {\n            if (creatorShares[i] > BASIS_POINTS) {\n              // If the numbers are >100% we ignore the fee recipients and pay just the first instead\n              totalShares = 0;\n              break;\n            }\n            totalShares += creatorShares[i];\n          }\n        }\n\n        if (totalShares == 0) {\n          // If no shares were defined or shares were out of bounds, pay only the first recipient\n          creatorRecipients.capLength(1);\n          creatorShares.capLength(1);\n        }\n      }\n\n      // Send payouts to each additional recipient if more than 1 was defined\n      uint256 totalRoyaltiesDistributed;\n      for (uint256 i = 1; i < creatorRecipients.length; ) {\n        uint256 royalty = (creatorRev * creatorShares[i]) / totalShares;\n        totalRoyaltiesDistributed += royalty;\n        creatorShares[i] = royalty;\n        unchecked {\n          ++i;\n        }\n      }\n\n      // Send the remainder to the 1st creator, rounding in their favor\n      creatorShares[0] = creatorRev - totalRoyaltiesDistributed;\n    } else {\n      // No royalty recipients found.\n      unchecked {\n        // totalFees is always < price.\n        sellerRev = price - totalFees;\n      }\n    }\n\n    if (buyReferrer != address(0) && buyReferrer != msg.sender && buyReferrer != seller && buyReferrer != creator) {\n      unchecked {\n        buyReferrerFee = totalFees / BUY_REFERRER_PROTOCOL_FEE_DENOMINATOR;\n\n        // buyReferrerFee is always <= totalFees\n        totalFees -= buyReferrerFee;\n      }\n    }\n  }\n\n  /**\n   * @notice This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[1000] private __gap;\n}"
    }
  ]
}