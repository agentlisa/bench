{
  "Title": "Missing Validations",
  "Content": "The `Verify` function [performs sanity checks](https://github.com/Consensys/linea-contracts-fix/blob/04d6677474421239c1f215c5a676223d09266ba4/contracts/verifiers/PlonkVerifierFull.sol#L174-L176) on the inputs, but there are still some validations missing. In particular, it does not confirm the number of public inputs, or whether the commitments correspond to valid elliptic curve points.\n\n\nIn the interest of reducing the attack surface, consider including these validations. Note that checking that the commitments are valid elliptic curve points is a requirement of the PLONK specification in order to inherit the security proof.\n\n\n***Update:** Partially resolved in [pull request #26](https://github.com/Consensys/linea-contracts-fix/pull/26). A check to explicitly restrict the number of public inputs was added. Regarding the elliptic curve checks, the Linea team stated:*\n\n\n\n> *It is implicitly tested when the EC precompiles are called - if a point is not on the curve, the precompile will revert. This avoids doing checks each time we verify a proof (there are a lot of points to verify), and the proofs that are received are likely to be correctly formatted so we believe the trade-off is better as it is now.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/verifiers/PlonkVerifierFull.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n// Copyright 2023 Consensys Software Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Code generated by gnark DO NOT EDIT\n\npragma solidity 0.8.19;\n\ncontract PlonkVerifierFull {\n  uint256 private constant r_mod = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n  uint256 private constant p_mod = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n  uint256 private constant g2_srs_0_x_0 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\n  uint256 private constant g2_srs_0_x_1 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\n  uint256 private constant g2_srs_0_y_0 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\n  uint256 private constant g2_srs_0_y_1 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\n\n  uint256 private constant g2_srs_1_x_0 = 15805639136721018565402881920352193254830339253282065586954346329754995870280;\n  uint256 private constant g2_srs_1_x_1 = 19089565590083334368588890253123139704298730990782503769911324779715431555531;\n  uint256 private constant g2_srs_1_y_0 = 9779648407879205346559610309258181044130619080926897934572699915909528404984;\n  uint256 private constant g2_srs_1_y_1 = 6779728121489434657638426458390319301070371227460768374343986326751507916979;\n\n  // ----------------------- vk ---------------------\n  uint256 private constant vk_domain_size = 33554432;\n  uint256 private constant vk_inv_domain_size =\n    21888242219518804655518433051623070663413851959604507555939307129453691614729;\n  uint256 private constant vk_omega = 19200870435978225707111062059747084165650991997241425080699860725083300967194;\n  uint256 private constant vk_ql_com_x = 15219271245698983703471423648023665720996205681784744600640314563625154579786;\n  uint256 private constant vk_ql_com_y = 20147594135982735259732754468148273541964923282562024733532785339023994968013;\n  uint256 private constant vk_qr_com_x = 21471071871292076580302623340312052053656709918995831984303212428778960332599;\n  uint256 private constant vk_qr_com_y = 15259265517764171942718107061584834645622370551725116555489996695545525645011;\n  uint256 private constant vk_qm_com_x = 7348167581357627394271400666076873505823385867737608431101258472693436797940;\n  uint256 private constant vk_qm_com_y = 4441183888936334562772144285824576613397978465178907198241592714557417319270;\n  uint256 private constant vk_qo_com_x = 690118329970351488385912633539015955126172086565412016261383595846817534429;\n  uint256 private constant vk_qo_com_y = 21854047320402578077195589346598189991187569103145043066685944954863560120820;\n  uint256 private constant vk_qk_com_x = 13603163727786566911398797609626301727351105723694955263993678345045934228870;\n  uint256 private constant vk_qk_com_y = 8339979733962310806038498361419393444965826606900970819477237490233428996333;\n\n  uint256 private constant vk_s1_com_x = 634493952854013755921699384519724653689756821082556819717184748995785102434;\n  uint256 private constant vk_s1_com_y = 20558435202691230255449033800343112788829920102758977812256470547750228131634;\n\n  uint256 private constant vk_s2_com_x = 6249349279481794121010728521332464829934723701621873491125551712685998783470;\n  uint256 private constant vk_s2_com_y = 4768324564744950463017317507840427044475111606201230109107364345742145486572;\n\n  uint256 private constant vk_s3_com_x = 6211604418720336838649890166502267316070740192872385963594274693381591578311;\n  uint256 private constant vk_s3_com_y = 3950283788807144685755254392627057902299881176666195233354776073965155557919;\n\n  uint256 private constant vk_coset_shift = 5;\n\n  uint256 private constant vk_selector_commitments_commit_api_0_x =\n    2614573220337297659179308133300379021102641010525403337401619021428140031269;\n  uint256 private constant vk_selector_commitments_commit_api_0_y =\n    5896590631125620550976365652082599923038691774487942725877415439318691171350;\n\n  uint256 private constant vk_index_commit_api_0 = 16790349;\n\n  uint256 private constant vk_nb_commitments_commit_api = 1;\n\n  // ------------------------------------------------\n\n  // offset proof\n  uint256 private constant proof_l_com_x = 0x00;\n  uint256 private constant proof_l_com_y = 0x20;\n  uint256 private constant proof_r_com_x = 0x40;\n  uint256 private constant proof_r_com_y = 0x60;\n  uint256 private constant proof_o_com_x = 0x80;\n  uint256 private constant proof_o_com_y = 0xa0;\n\n  // h = h_0 + x^{n+2}h_1 + x^{2(n+2)}h_2\n  uint256 private constant proof_h_0_x = 0xc0;\n  uint256 private constant proof_h_0_y = 0xe0;\n  uint256 private constant proof_h_1_x = 0x100;\n  uint256 private constant proof_h_1_y = 0x120;\n  uint256 private constant proof_h_2_x = 0x140;\n  uint256 private constant proof_h_2_y = 0x160;\n\n  // wire values at zeta\n  uint256 private constant proof_l_at_zeta = 0x180;\n  uint256 private constant proof_r_at_zeta = 0x1a0;\n  uint256 private constant proof_o_at_zeta = 0x1c0;\n\n  //uint256[STATE_WIDTH-1] permutation_polynomials_at_zeta; // Sσ1(zeta),Sσ2(zeta)\n  uint256 private constant proof_s1_at_zeta = 0x1e0; // Sσ1(zeta)\n  uint256 private constant proof_s2_at_zeta = 0x200; // Sσ2(zeta)\n\n  //Bn254.G1Point grand_product_commitment;                 // [z(x)]\n  uint256 private constant proof_grand_product_commitment_x = 0x220;\n  uint256 private constant proof_grand_product_commitment_y = 0x240;\n\n  uint256 private constant proof_grand_product_at_zeta_omega = 0x260; // z(w*zeta)\n  uint256 private constant proof_quotient_polynomial_at_zeta = 0x280; // t(zeta)\n  uint256 private constant proof_linearised_polynomial_at_zeta = 0x2a0; // r(zeta)\n\n  // Folded proof for the opening of H, linearised poly, l, r, o, s_1, s_2, qcp\n  uint256 private constant proof_batch_opening_at_zeta_x = 0x2c0; // [Wzeta]\n  uint256 private constant proof_batch_opening_at_zeta_y = 0x2e0;\n\n  //Bn254.G1Point opening_at_zeta_omega_proof;      // [Wzeta*omega]\n  uint256 private constant proof_opening_at_zeta_omega_x = 0x300;\n  uint256 private constant proof_opening_at_zeta_omega_y = 0x320;\n\n  uint256 private constant proof_openings_selector_commit_api_at_zeta = 0x340;\n  // -> next part of proof is\n  // [ openings_selector_commits || commitments_wires_commit_api]\n\n  // -------- offset state\n\n  // challenges to check the claimed quotient\n  uint256 private constant state_alpha = 0x00;\n  uint256 private constant state_beta = 0x20;\n  uint256 private constant state_gamma = 0x40;\n  uint256 private constant state_zeta = 0x60;\n\n  // reusable value\n  uint256 private constant state_alpha_square_lagrange_0 = 0x80;\n\n  // commitment to H\n  uint256 private constant state_folded_h_x = 0xa0;\n  uint256 private constant state_folded_h_y = 0xc0;\n\n  // commitment to the linearised polynomial\n  uint256 private constant state_linearised_polynomial_x = 0xe0;\n  uint256 private constant state_linearised_polynomial_y = 0x100;\n\n  // Folded proof for the opening of H, linearised poly, l, r, o, s_1, s_2, qcp\n  uint256 private constant state_folded_claimed_values = 0x120;\n\n  // folded digests of H, linearised poly, l, r, o, s_1, s_2, qcp\n  // Bn254.G1Point folded_digests;\n  uint256 private constant state_folded_digests_x = 0x140;\n  uint256 private constant state_folded_digests_y = 0x160;\n\n  uint256 private constant state_pi = 0x180;\n\n  uint256 private constant state_zeta_power_n_minus_one = 0x1a0;\n\n  uint256 private constant state_gamma_kzg = 0x1c0;\n\n  uint256 private constant state_success = 0x1e0;\n  uint256 private constant state_check_var = 0x200; // /!\\ this slot is used for debugging only\n\n  uint256 private constant state_last_mem = 0x220;\n\n  // -------- errors\n  uint256 private constant error_string_id = 0x08c379a000000000000000000000000000000000000000000000000000000000; // selector for function Error(string)\n\n  // -------- utils (for hash_fr)\n  uint256 private constant bb = 340282366920938463463374607431768211456; // 2**128\n  uint256 private constant zero_uint256 = 0;\n\n  uint8 private constant lenInBytes = 48;\n  uint8 private constant sizeDomain = 11;\n  uint8 private constant one = 1;\n  uint8 private constant two = 2;\n\n  function Verify(bytes calldata proof, uint256[] calldata public_inputs) public view returns (bool success) {\n    assembly {\n      let mem := mload(0x40)\n      let freeMem := add(mem, state_last_mem)\n\n      // sanity checks\n      check_inputs_size(public_inputs.length, public_inputs.offset)\n      check_proof_size(proof.length)\n      check_proof_openings_size(proof.offset)\n\n      // compute the challenges\n      let prev_challenge_non_reduced\n      prev_challenge_non_reduced := derive_gamma(proof.offset, public_inputs.length, public_inputs.offset)\n      prev_challenge_non_reduced := derive_beta(prev_challenge_non_reduced)\n      prev_challenge_non_reduced := derive_alpha(proof.offset, prev_challenge_non_reduced)\n      derive_zeta(proof.offset, prev_challenge_non_reduced)\n\n      // evaluation of Z=Xⁿ-1 at ζ, we save this value\n      let zeta := mload(add(mem, state_zeta))\n      let zeta_power_n_minus_one := addmod(pow(zeta, vk_domain_size, freeMem), sub(r_mod, 1), r_mod)\n      mstore(add(mem, state_zeta_power_n_minus_one), zeta_power_n_minus_one)\n\n      // public inputs contribution\n      let l_pi := sum_pi_wo_api_commit(public_inputs.offset, public_inputs.length, freeMem)\n      let l_wocommit := sum_pi_commit(proof.offset, public_inputs.length, freeMem)\n      l_pi := addmod(l_wocommit, l_pi, r_mod)\n      mstore(add(mem, state_pi), l_pi)\n\n      compute_alpha_square_lagrange_0()\n      verify_quotient_poly_eval_at_zeta(proof.offset)\n      fold_h(proof.offset)\n      compute_commitment_linearised_polynomial(proof.offset)\n      compute_gamma_kzg(proof.offset)\n      fold_state(proof.offset)\n      batch_verify_multi_points(proof.offset)\n\n      success := mload(add(mem, state_success))\n\n      // Beginning errors -------------------------------------------------\n      function error_ec_op() {\n        let ptError := mload(0x40)\n        mstore(ptError, error_string_id) // selector for function Error(string)\n        mstore(add(ptError, 0x4), 0x20)\n        mstore(add(ptError, 0x24), 0x12)\n        mstore(add(ptError, 0x44), \"error ec operation\")\n        revert(ptError, 0x64)\n      }\n\n      function error_inputs_size() {\n        let ptError := mload(0x40)\n        mstore(ptError, error_string_id) // selector for function Error(string)\n        mstore(add(ptError, 0x4), 0x20)\n        mstore(add(ptError, 0x24), 0x18)\n        mstore(add(ptError, 0x44), \"inputs are bigger than r\")\n        revert(ptError, 0x64)\n      }\n\n      function error_proof_size() {\n        let ptError := mload(0x40)\n        mstore(ptError, error_string_id) // selector for function Error(string)\n        mstore(add(ptError, 0x4), 0x20)\n        mstore(add(ptError, 0x24), 0x10)\n        mstore(add(ptError, 0x44), \"wrong proof size\")\n        revert(ptError, 0x64)\n      }\n\n      function error_proof_openings_size() {\n        let ptError := mload(0x40)\n        mstore(ptError, error_string_id) // selector for function Error(string)\n        mstore(add(ptError, 0x4), 0x20)\n        mstore(add(ptError, 0x24), 0x16)\n        mstore(add(ptError, 0x44), \"openings bigger than r\")\n        revert(ptError, 0x64)\n      }\n\n      function error_verify() {\n        let ptError := mload(0x40)\n        mstore(ptError, error_string_id) // selector for function Error(string)\n        mstore(add(ptError, 0x4), 0x20)\n        mstore(add(ptError, 0x24), 0xc)\n        mstore(add(ptError, 0x44), \"error verify\")\n        revert(ptError, 0x64)\n      }\n      // end errors -------------------------------------------------\n\n      // Beginning checks -------------------------------------------------\n\n      // s number of public inputs, p pointer the public inputs\n      function check_inputs_size(s, p) {\n        let input_checks := 1\n        for {\n          let i\n        } lt(i, s) {\n          i := add(i, 1)\n        } {\n          input_checks := and(input_checks, lt(calldataload(p), r_mod))\n          p := add(p, 0x20)\n        }\n        if iszero(input_checks) {\n          error_inputs_size()\n        }\n      }\n\n      function check_proof_size(actual_proof_size) {\n        let expected_proof_size := add(0x340, mul(vk_nb_commitments_commit_api, 0x60))\n        if iszero(eq(actual_proof_size, expected_proof_size)) {\n          error_proof_size()\n        }\n      }\n\n      function check_proof_openings_size(aproof) {\n        let openings_check := 1\n\n        // linearised polynomial at zeta\n        let p := add(aproof, proof_linearised_polynomial_at_zeta)\n        openings_check := and(openings_check, lt(calldataload(p), r_mod))\n\n        // quotient polynomial at zeta\n        p := add(aproof, proof_quotient_polynomial_at_zeta)\n        openings_check := and(openings_check, lt(calldataload(p), r_mod))\n\n        // proof_l_at_zeta\n        p := add(aproof, proof_l_at_zeta)\n        openings_check := and(openings_check, lt(calldataload(p), r_mod))\n\n        // proof_r_at_zeta\n        p := add(aproof, proof_r_at_zeta)\n        openings_check := and(openings_check, lt(calldataload(p), r_mod))\n\n        // proof_o_at_zeta\n        p := add(aproof, proof_o_at_zeta)\n        openings_check := and(openings_check, lt(calldataload(p), r_mod))\n\n        // proof_s1_at_zeta\n        p := add(aproof, proof_s1_at_zeta)\n        openings_check := and(openings_check, lt(calldataload(p), r_mod))\n\n        // proof_s2_at_zeta\n        p := add(aproof, proof_s2_at_zeta)\n        openings_check := and(openings_check, lt(calldataload(p), r_mod))\n\n        // proof_grand_product_at_zeta_omega\n        p := add(aproof, proof_grand_product_at_zeta_omega)\n        openings_check := and(openings_check, lt(calldataload(p), r_mod))\n\n        // proof_openings_selector_commit_api_at_zeta\n\n        p := add(aproof, proof_openings_selector_commit_api_at_zeta)\n        for {\n          let i := 0\n        } lt(i, vk_nb_commitments_commit_api) {\n          i := add(i, 1)\n        } {\n          openings_check := and(openings_check, lt(calldataload(p), r_mod))\n          p := add(p, 0x20)\n        }\n\n        if iszero(openings_check) {\n          error_proof_openings_size()\n        }\n      }\n      // end checks -------------------------------------------------\n\n      // Beginning challenges -------------------------------------------------\n\n      // Derive gamma as Sha256(<transcript>)\n      // where transcript is the concatenation (in this order) of:\n      // * the word \"gamma\" in ascii, equal to [0x67,0x61,0x6d, 0x6d, 0x61] and encoded as a uint256.\n      // * the commitments to the permutation polynomials S1, S2, S3, where we concatenate the coordinates of those points\n      // * the commitments of Ql, Qr, Qm, Qo, Qk\n      // * the public inputs\n      // * the commitments of the wires related to the custom gates (commitments_wires_commit_api)\n      // * commitments to L, R, O (proof_<l,r,o>_com_<x,y>)\n      // The data described above is written starting at mPtr. \"gamma\" lies on 5 bytes,\n      // and is encoded as a uint256 number n. In basis b = 256, the number looks like this\n      // [0 0 0 .. 0x67 0x61 0x6d, 0x6d, 0x61]. The first non zero entry is at position 27=0x1b\n      // nb_pi, pi respectively number of public inputs and public inputs\n      function derive_gamma(aproof, nb_pi, pi) -> gamma_not_reduced {\n        let state := mload(0x40)\n        let mPtr := add(state, state_last_mem)\n\n        // gamma\n        // gamma in ascii is [0x67,0x61,0x6d, 0x6d, 0x61]\n        // (same for alpha, beta, zeta)\n        mstore(mPtr, 0x67616d6d61) // \"gamma\"\n\n        mstore(add(mPtr, 0x20), vk_s1_com_x)\n        mstore(add(mPtr, 0x40), vk_s1_com_y)\n        mstore(add(mPtr, 0x60), vk_s2_com_x)\n        mstore(add(mPtr, 0x80), vk_s2_com_y)\n        mstore(add(mPtr, 0xa0), vk_s3_com_x)\n        mstore(add(mPtr, 0xc0), vk_s3_com_y)\n        mstore(add(mPtr, 0xe0), vk_ql_com_x)\n        mstore(add(mPtr, 0x100), vk_ql_com_y)\n        mstore(add(mPtr, 0x120), vk_qr_com_x)\n        mstore(add(mPtr, 0x140), vk_qr_com_y)\n        mstore(add(mPtr, 0x160), vk_qm_com_x)\n        mstore(add(mPtr, 0x180), vk_qm_com_y)\n        mstore(add(mPtr, 0x1a0), vk_qo_com_x)\n        mstore(add(mPtr, 0x1c0), vk_qo_com_y)\n        mstore(add(mPtr, 0x1e0), vk_qk_com_x)\n        mstore(add(mPtr, 0x200), vk_qk_com_y)\n\n        // public inputs\n        let _mPtr := add(mPtr, 0x220)\n        let size_pi_in_bytes := mul(nb_pi, 0x20)\n        calldatacopy(_mPtr, pi, size_pi_in_bytes)\n        _mPtr := add(_mPtr, size_pi_in_bytes)\n\n        // wire commitment commit api\n        let _proof := add(aproof, proof_openings_selector_commit_api_at_zeta)\n        _proof := add(_proof, mul(vk_nb_commitments_commit_api, 0x20))\n        let size_wire_commitments_commit_api_in_bytes := mul(vk_nb_commitments_commit_api, 0x40)\n        calldatacopy(_mPtr, _proof, size_wire_commitments_commit_api_in_bytes)\n        _mPtr := add(_mPtr, size_wire_commitments_commit_api_in_bytes)\n\n        // commitments to l, r, o\n        let size_commitments_lro_in_bytes := 0xc0\n        calldatacopy(_mPtr, aproof, size_commitments_lro_in_bytes)\n        _mPtr := add(_mPtr, size_commitments_lro_in_bytes)\n\n        let size := add(0x2c5, mul(nb_pi, 0x20)) // 0x2c5 = 22*32+5\n        size := add(size, mul(vk_nb_commitments_commit_api, 0x40))\n        let l_success := staticcall(gas(), 0x2, add(mPtr, 0x1b), size, mPtr, 0x20) //0x1b -> 000..\"gamma\"\n        if iszero(l_success) {\n          error_verify()\n        }\n        gamma_not_reduced := mload(mPtr)\n        mstore(add(state, state_gamma), mod(gamma_not_reduced, r_mod))\n      }\n\n      function derive_beta(gamma_not_reduced) -> beta_not_reduced {\n        let state := mload(0x40)\n        let mPtr := add(mload(0x40), state_last_mem)\n\n        // beta\n        mstore(mPtr, 0x62657461) // \"beta\"\n        mstore(add(mPtr, 0x20), gamma_not_reduced)\n        let l_success := staticcall(gas(), 0x2, add(mPtr, 0x1c), 0x24, mPtr, 0x20) //0x1b -> 000..\"gamma\"\n        if iszero(l_success) {\n          error_verify()\n        }\n        beta_not_reduced := mload(mPtr)\n        mstore(add(state, state_beta), mod(beta_not_reduced, r_mod))\n      }\n\n      // alpha depends on the previous challenge (beta) and on the commitment to the grand product polynomial\n      function derive_alpha(aproof, beta_not_reduced) -> alpha_not_reduced {\n        let state := mload(0x40)\n        let mPtr := add(mload(0x40), state_last_mem)\n\n        // alpha\n        mstore(mPtr, 0x616C706861) // \"alpha\"\n        mstore(add(mPtr, 0x20), beta_not_reduced)\n        calldatacopy(add(mPtr, 0x40), add(aproof, proof_grand_product_commitment_x), 0x40)\n        let l_success := staticcall(gas(), 0x2, add(mPtr, 0x1b), 0x65, mPtr, 0x20) //0x1b -> 000..\"gamma\"\n        if iszero(l_success) {\n          error_verify()\n        }\n        alpha_not_reduced := mload(mPtr)\n        mstore(add(state, state_alpha), mod(alpha_not_reduced, r_mod))\n      }\n\n      // zeta depends on the previous challenge (alpha) and on the commitment to the quotient polynomial\n      function derive_zeta(aproof, alpha_not_reduced) {\n        let state := mload(0x40)\n        let mPtr := add(mload(0x40), state_last_mem)\n\n        // zeta\n        mstore(mPtr, 0x7a657461) // \"zeta\"\n        mstore(add(mPtr, 0x20), alpha_not_reduced)\n        calldatacopy(add(mPtr, 0x40), add(aproof, proof_h_0_x), 0xc0)\n        let l_success := staticcall(gas(), 0x2, add(mPtr, 0x1c), 0xe4, mPtr, 0x20)\n        if iszero(l_success) {\n          error_verify()\n        }\n        let zeta_not_reduced := mload(mPtr)\n        mstore(add(state, state_zeta), mod(zeta_not_reduced, r_mod))\n      }\n      // END challenges -------------------------------------------------\n\n      // BEGINNING compute_pi -------------------------------------------------\n\n      // public input (not comming from the commit api) contribution\n      // ins, n are the public inputs and number of public inputs respectively\n      function sum_pi_wo_api_commit(ins, n, mPtr) -> pi_wo_commit {\n        let state := mload(0x40)\n        let z := mload(add(state, state_zeta))\n        let zpnmo := mload(add(state, state_zeta_power_n_minus_one))\n\n        let li := mPtr\n        batch_compute_lagranges_at_z(z, zpnmo, n, li)\n\n        let tmp := 0\n        for {\n          let i := 0\n        } lt(i, n) {\n          i := add(i, 1)\n        } {\n          tmp := mulmod(mload(li), calldataload(ins), r_mod)\n          pi_wo_commit := addmod(pi_wo_commit, tmp, r_mod)\n          li := add(li, 0x20)\n          ins := add(ins, 0x20)\n        }\n      }\n\n      // mPtr <- [L_0(z), .., L_{n-1}(z)]\n      //\n      // Here L_i(zeta) =  ωⁱ/n * (ζⁿ-1)/(ζ-ωⁱ) where:\n      // * n = vk_domain_size\n      // * ω = vk_omega (generator of the multiplicative cyclic group of order n in (ℤ/rℤ)*)\n      // * ζ = z (challenge derived with Fiat Shamir)\n      // * zpnmo = 'zeta power n minus one' (ζⁿ-1) which has been precomputed\n      function batch_compute_lagranges_at_z(z, zpnmo, n, mPtr) {\n        let zn := mulmod(zpnmo, vk_inv_domain_size, r_mod) // 1/n * (ζⁿ - 1)\n\n        let _w := 1\n        let _mPtr := mPtr\n        for {\n          let i := 0\n        } lt(i, n) {\n          i := add(i, 1)\n        } {\n          mstore(_mPtr, addmod(z, sub(r_mod, _w), r_mod))\n          _w := mulmod(_w, vk_omega, r_mod)\n          _mPtr := add(_mPtr, 0x20)\n        }\n        batch_invert(mPtr, n, _mPtr)\n        _mPtr := mPtr\n        _w := 1\n        for {\n          let i := 0\n        } lt(i, n) {\n          i := add(i, 1)\n        } {\n          mstore(_mPtr, mulmod(mulmod(mload(_mPtr), zn, r_mod), _w, r_mod))\n          _mPtr := add(_mPtr, 0x20)\n          _w := mulmod(_w, vk_omega, r_mod)\n        }\n      }\n\n      // batch invert (modulo r) in place the nb_ins uint256 inputs starting at ins.\n      function batch_invert(ins, nb_ins, mPtr) {\n        mstore(mPtr, 1)\n        let offset := 0\n        for {\n          let i := 0\n        } lt(i, nb_ins) {\n          i := add(i, 1)\n        } {\n          let prev := mload(add(mPtr, offset))\n          let cur := mload(add(ins, offset))\n          cur := mulmod(prev, cur, r_mod)\n          offset := add(offset, 0x20)\n          mstore(add(mPtr, offset), cur)\n        }\n        ins := add(ins, sub(offset, 0x20))\n        mPtr := add(mPtr, offset)\n        let inv := pow(mload(mPtr), sub(r_mod, 2), add(mPtr, 0x20))\n        for {\n          let i := 0\n        } lt(i, nb_ins) {\n          i := add(i, 1)\n        } {\n          mPtr := sub(mPtr, 0x20)\n          let tmp := mload(ins)\n          let cur := mulmod(inv, mload(mPtr), r_mod)\n          mstore(ins, cur)\n          inv := mulmod(inv, tmp, r_mod)\n          ins := sub(ins, 0x20)\n        }\n      }\n\n      // mPtr free memory. Computes the public input contribution related to the commit\n      function sum_pi_commit(aproof, nb_public_inputs, mPtr) -> pi_commit {\n        let state := mload(0x40)\n        let z := mload(add(state, state_zeta))\n        let zpnmo := mload(add(state, state_zeta_power_n_minus_one))\n\n        let p := add(aproof, proof_openings_selector_commit_api_at_zeta)\n        p := add(p, mul(vk_nb_commitments_commit_api, 0x20)) // p points now to the wire commitments\n\n        let h_fr, ith_lagrange\n\n        h_fr := hash_fr(calldataload(p), calldataload(add(p, 0x20)), mPtr)\n        ith_lagrange := compute_ith_lagrange_at_z(z, zpnmo, add(nb_public_inputs, vk_index_commit_api_0), mPtr)\n        pi_commit := addmod(pi_commit, mulmod(h_fr, ith_lagrange, r_mod), r_mod)\n        p := add(p, 0x40)\n      }\n\n      // z zeta\n      // zpmno ζⁿ-1\n      // i i-th lagrange\n      // mPtr free memory\n      // Computes L_i(zeta) =  ωⁱ/n * (ζⁿ-1)/(ζ-ωⁱ) where:\n      function compute_ith_lagrange_at_z(z, zpnmo, i, mPtr) -> res {\n        let w := pow(vk_omega, i, mPtr) // w**i\n        i := addmod(z, sub(r_mod, w), r_mod) // z-w**i\n        w := mulmod(w, vk_inv_domain_size, r_mod) // w**i/n\n        i := pow(i, sub(r_mod, 2), mPtr) // (z-w**i)**-1\n        w := mulmod(w, i, r_mod) // w**i/n*(z-w)**-1\n        res := mulmod(w, zpnmo, r_mod)\n      }\n\n      // (x, y) point on bn254, both on 32bytes\n      // mPtr free memory\n      function hash_fr(x, y, mPtr) -> res {\n        // [0x00, .. , 0x00 || x, y, || 0, 48, 0, dst, sizeDomain]\n        // <-  64 bytes  ->  <-64b -> <-       1 bytes each     ->\n\n        // [0x00, .., 0x00] 64 bytes of zero\n        mstore(mPtr, zero_uint256)\n        mstore(add(mPtr, 0x20), zero_uint256)\n\n        // msg =  x || y , both on 32 bytes\n        mstore(add(mPtr, 0x40), x)\n        mstore(add(mPtr, 0x60), y)\n\n        // 0 || 48 || 0 all on 1 byte\n        mstore8(add(mPtr, 0x80), 0)\n        mstore8(add(mPtr, 0x81), lenInBytes)\n        mstore8(add(mPtr, 0x82), 0)\n\n        // \"BSB22-Plonk\" = [42, 53, 42, 32, 32, 2d, 50, 6c, 6f, 6e, 6b,]\n        mstore8(add(mPtr, 0x83), 0x42)\n        mstore8(add(mPtr, 0x84), 0x53)\n        mstore8(add(mPtr, 0x85), 0x42)\n        mstore8(add(mPtr, 0x86), 0x32)\n        mstore8(add(mPtr, 0x87), 0x32)\n        mstore8(add(mPtr, 0x88), 0x2d)\n        mstore8(add(mPtr, 0x89), 0x50)\n        mstore8(add(mPtr, 0x8a), 0x6c)\n        mstore8(add(mPtr, 0x8b), 0x6f)\n        mstore8(add(mPtr, 0x8c), 0x6e)\n        mstore8(add(mPtr, 0x8d), 0x6b)\n\n        // size domain\n        mstore8(add(mPtr, 0x8e), sizeDomain)\n\n        let l_success := staticcall(gas(), 0x2, mPtr, 0x8f, mPtr, 0x20)\n        if iszero(l_success) {\n          error_verify()\n        }\n\n        let b0 := mload(mPtr)\n\n        // [b0         || one || dst || sizeDomain]\n        // <-64bytes ->  <-    1 byte each      ->\n        mstore8(add(mPtr, 0x20), one) // 1\n\n        mstore8(add(mPtr, 0x21), 0x42) // dst\n        mstore8(add(mPtr, 0x22), 0x53)\n        mstore8(add(mPtr, 0x23), 0x42)\n        mstore8(add(mPtr, 0x24), 0x32)\n        mstore8(add(mPtr, 0x25), 0x32)\n        mstore8(add(mPtr, 0x26), 0x2d)\n        mstore8(add(mPtr, 0x27), 0x50)\n        mstore8(add(mPtr, 0x28), 0x6c)\n        mstore8(add(mPtr, 0x29), 0x6f)\n        mstore8(add(mPtr, 0x2a), 0x6e)\n        mstore8(add(mPtr, 0x2b), 0x6b)\n\n        mstore8(add(mPtr, 0x2c), sizeDomain) // size domain\n        l_success := staticcall(gas(), 0x2, mPtr, 0x2d, mPtr, 0x20)\n        if iszero(l_success) {\n          error_verify()\n        }\n\n        // b1 is located at mPtr. We store b2 at add(mPtr, 0x20)\n\n        // [b0^b1      || two || dst || sizeDomain]\n        // <-64bytes ->  <-    1 byte each      ->\n        mstore(add(mPtr, 0x20), xor(mload(mPtr), b0))\n        mstore8(add(mPtr, 0x40), two)\n\n        mstore8(add(mPtr, 0x41), 0x42) // dst\n        mstore8(add(mPtr, 0x42), 0x53)\n        mstore8(add(mPtr, 0x43), 0x42)\n        mstore8(add(mPtr, 0x44), 0x32)\n        mstore8(add(mPtr, 0x45), 0x32)\n        mstore8(add(mPtr, 0x46), 0x2d)\n        mstore8(add(mPtr, 0x47), 0x50)\n        mstore8(add(mPtr, 0x48), 0x6c)\n        mstore8(add(mPtr, 0x49), 0x6f)\n        mstore8(add(mPtr, 0x4a), 0x6e)\n        mstore8(add(mPtr, 0x4b), 0x6b)\n\n        mstore8(add(mPtr, 0x4c), sizeDomain) // size domain\n\n        let offset := add(mPtr, 0x20)\n        l_success := staticcall(gas(), 0x2, offset, 0x2d, offset, 0x20)\n        if iszero(l_success) {\n          error_verify()\n        }\n\n        // at this point we have mPtr = [ b1 || b2] where b1 is on 32byes and b2 in 16bytes.\n        // we interpret it as a big integer mod r in big endian (similar to regular decimal notation)\n        // the result is then 2**(8*16)*mPtr[32:] + mPtr[32:48]\n        res := mulmod(mload(mPtr), bb, r_mod) // <- res = 2**128 * mPtr[:32]\n        offset := add(mPtr, 0x10)\n        for {\n          let i := 0\n        } lt(i, 0x10) {\n          i := add(i, 1)\n        } {\n          // mPtr <- [xx, xx, ..,  | 0, 0, .. 0  ||    b2   ]\n          mstore8(offset, 0x00)\n          offset := add(offset, 0x1)\n        }\n        let b1 := mload(add(mPtr, 0x10)) // b1 <- [0, 0, .., 0 ||  b2[:16] ]\n        res := addmod(res, b1, r_mod)\n      }\n\n      // END compute_pi -------------------------------------------------\n\n      // compute α² * 1/n * (ζ{n}-1)/(ζ - 1) where\n      // * α = challenge derived in derive_gamma_beta_alpha_zeta\n      // * n = vk_domain_size\n      // * ω = vk_omega (generator of the multiplicative cyclic group of order n in (ℤ/rℤ)*)\n      // * ζ = zeta (challenge derived with Fiat Shamir)\n      function compute_alpha_square_lagrange_0() {\n        let state := mload(0x40)\n        let mPtr := add(mload(0x40), state_last_mem)\n\n        let res := mload(add(state, state_zeta_power_n_minus_one))\n        let den := addmod(mload(add(state, state_zeta)), sub(r_mod, 1), r_mod)\n        den := pow(den, sub(r_mod, 2), mPtr)\n        den := mulmod(den, vk_inv_domain_size, r_mod)\n        res := mulmod(den, res, r_mod)\n\n        let l_alpha := mload(add(state, state_alpha))\n        res := mulmod(res, l_alpha, r_mod)\n        res := mulmod(res, l_alpha, r_mod)\n        mstore(add(state, state_alpha_square_lagrange_0), res)\n      }\n\n      // follows alg. p.13 of https://eprint.iacr.org/2019/953.pdf\n      // with t₁ = t₂ = 1, and the proofs are ([digest] + [quotient] +purported evaluation):\n      // * [state_folded_state_digests], [proof_batch_opening_at_zeta_x], state_folded_evals\n      // * [proof_grand_product_commitment], [proof_opening_at_zeta_omega_x], [proof_grand_product_at_zeta_omega]\n      function batch_verify_multi_points(aproof) {\n        let state := mload(0x40)\n        let mPtr := add(state, state_last_mem)\n\n        // here the random is not a challenge, hence no need to use Fiat Shamir, we just\n        // need an unpredictible result.\n        let random := mod(keccak256(state, 0x20), r_mod)\n\n        let folded_quotients := mPtr\n        mPtr := add(folded_quotients, 0x40)\n        mstore(folded_quotients, calldataload(add(aproof, proof_batch_opening_at_zeta_x)))\n        mstore(add(folded_quotients, 0x20), calldataload(add(aproof, proof_batch_opening_at_zeta_y)))\n        point_acc_mul_calldata(folded_quotients, add(aproof, proof_opening_at_zeta_omega_x), random, mPtr)\n\n        let folded_digests := add(state, state_folded_digests_x)\n        point_acc_mul_calldata(folded_digests, add(aproof, proof_grand_product_commitment_x), random, mPtr)\n\n        let folded_evals := add(state, state_folded_claimed_values)\n        fr_acc_mul_calldata(folded_evals, add(aproof, proof_grand_product_at_zeta_omega), random)\n\n        let folded_evals_commit := mPtr\n        mPtr := add(folded_evals_commit, 0x40)\n        mstore(folded_evals_commit, 14312776538779914388377568895031746459131577658076416373430523308756343304251)\n        mstore(\n          add(folded_evals_commit, 0x20),\n          11763105256161367503191792604679297387056316997144156930871823008787082098465\n        )\n        mstore(add(folded_evals_commit, 0x40), mload(folded_evals))\n        let check_staticcall := staticcall(gas(), 7, folded_evals_commit, 0x60, folded_evals_commit, 0x40)\n        if eq(check_staticcall, 0) {\n          error_verify()\n        }\n\n        let folded_evals_commit_y := add(folded_evals_commit, 0x20)\n        mstore(folded_evals_commit_y, sub(p_mod, mload(folded_evals_commit_y)))\n        point_add(folded_digests, folded_digests, folded_evals_commit, mPtr)\n\n        let folded_points_quotients := mPtr\n        mPtr := add(mPtr, 0x40)\n        point_mul_calldata(\n          folded_points_quotients,\n          add(aproof, proof_batch_opening_at_zeta_x),\n          mload(add(state, state_zeta)),\n          mPtr\n        )\n        let zeta_omega := mulmod(mload(add(state, state_zeta)), vk_omega, r_mod)\n        random := mulmod(random, zeta_omega, r_mod)\n        point_acc_mul_calldata(folded_points_quotients, add(aproof, proof_opening_at_zeta_omega_x), random, mPtr)\n\n        point_add(folded_digests, folded_digests, folded_points_quotients, mPtr)\n\n        let folded_quotients_y := add(folded_quotients, 0x20)\n        mstore(folded_quotients_y, sub(p_mod, mload(folded_quotients_y)))\n\n        mstore(mPtr, mload(folded_digests))\n        mstore(add(mPtr, 0x20), mload(add(folded_digests, 0x20)))\n        mstore(add(mPtr, 0x40), g2_srs_0_x_0) // the 4 lines are the canonical G2 point on BN254\n        mstore(add(mPtr, 0x60), g2_srs_0_x_1)\n        mstore(add(mPtr, 0x80), g2_srs_0_y_0)\n        mstore(add(mPtr, 0xa0), g2_srs_0_y_1)\n        mst"
    }
  ]
}