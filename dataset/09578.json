{
  "Title": "[M-04] `requiredImprovementRate` can not work as expected when `previousInterestRate` less than 10 due to precision loss",
  "Content": "_Submitted by WatchPug, also found by CertoraInc and hickuphh3_\n\n[NFTLoanFacilitator.sol#L167-L179](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L167-L179)\n\n```solidity\n{\n    uint256 previousInterestRate = loan.perAnumInterestRate;\n    uint256 previousDurationSeconds = loan.durationSeconds;\n\n    require(interestRate <= previousInterestRate, 'NFTLoanFacilitator: rate too high');\n    require(durationSeconds >= previousDurationSeconds, 'NFTLoanFacilitator: duration too low');\n\n    require((previousLoanAmount * requiredImprovementRate / SCALAR) <= amountIncrease\n    || previousDurationSeconds + (previousDurationSeconds * requiredImprovementRate / SCALAR) <= durationSeconds \n    || (previousInterestRate != 0 // do not allow rate improvement if rate already 0\n        && previousInterestRate - (previousInterestRate * requiredImprovementRate / SCALAR) >= interestRate), \n    \"NFTLoanFacilitator: proposed terms must be better than existing terms\");\n}\n```\n\nThe `requiredImprovementRate` represents the percentage of improvement required of at least one of the terms when buying out from a previous lender.\n\nHowever, when `previousInterestRate` is less than `10` and `requiredImprovementRate` is `100`, due to precision loss, the new `interestRate` is allowed to be the same as the previous one.\n\nMaking such an expected constraint absent.\n\n### Proof of Concept\n\n1.  Alice `createLoan()` with `maxPerAnumInterest` = 10, received `loanId` = 1\n2.  Bob `lend()` with `interestRate` = 9  for `loanId` = 1\n3.  Charlie `lend()` with `interestRate` = 9 (and all the same other terms with Bob) and buys out `loanId` = 1\n\nCharlie is expected to provide at least 10% better terms, but actually bought out Bob with the same terms.\n\n### Recommended Mitigation Steps\n\nConsider using: [OpenZeppelin/Math.sol#L39-L42](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/utils/math/Math.sol#L39-L42)<br>\n\nAnd change the check to:\n\n```solidity\n(previousInterestRate != 0 // do not allow rate improvement if rate already 0\n        && previousInterestRate - Math.ceilDiv(previousInterestRate * requiredImprovementRate, SCALAR) >= interestRate)\n```\n\n**[wilsoncusack (Backed Protocol) confirmed and resolved](https://github.com/code-423n4/2022-04-backed-findings/issues/80#issuecomment-1094305756)**\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-04-backed-findings/issues/80#issuecomment-1100093154):**\n > Sponsor confirmed with fix.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-04-backed-protocol-contest",
  "Code": [
    {
      "filename": "contracts/NFTLoanFacilitator.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.12;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {SafeTransferLib, ERC20} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {INFTLoanFacilitator} from './interfaces/INFTLoanFacilitator.sol';\nimport {IERC721Mintable} from './interfaces/IERC721Mintable.sol';\nimport {ILendTicket} from './interfaces/ILendTicket.sol';\n\ncontract NFTLoanFacilitator is Ownable, INFTLoanFacilitator {\n    using SafeTransferLib for ERC20;\n\n    // ==== constants ====\n\n    /** \n     * See {INFTLoanFacilitator-INTEREST_RATE_DECIMALS}.     \n     * @dev lowest non-zero APR possible = (1/10^3) = 0.001 = 0.1%\n     */\n    uint8 public constant override INTEREST_RATE_DECIMALS = 3;\n\n    /// See {INFTLoanFacilitator-SCALAR}.\n    uint256 public constant override SCALAR = 10 ** INTEREST_RATE_DECIMALS;\n\n    \n    // ==== state variables ====\n\n    /// See {INFTLoanFacilitator-originationFeeRate}.\n    /// @dev starts at 1%\n    uint256 public override originationFeeRate = 10 ** (INTEREST_RATE_DECIMALS - 2);\n\n    /// See {INFTLoanFacilitator-requiredImprovementRate}.\n    /// @dev starts at 10%\n    uint256 public override requiredImprovementRate = 10 ** (INTEREST_RATE_DECIMALS - 1);\n\n    /// See {INFTLoanFacilitator-lendTicketContract}.\n    address public override lendTicketContract;\n\n    /// See {INFTLoanFacilitator-borrowTicketContract}.\n    address public override borrowTicketContract;\n\n    /// See {INFTLoanFacilitator-loanInfo}.\n    mapping(uint256 => Loan) public loanInfo;\n\n    /// @dev tracks loan count\n    uint256 private _nonce = 1;\n\n    \n    // ==== modifiers ====\n\n    modifier notClosed(uint256 loanId) { \n        require(!loanInfo[loanId].closed, \"NFTLoanFacilitator: loan closed\");\n        _; \n    }\n\n\n    // ==== constructor ====\n\n    constructor(address _manager) {\n        transferOwnership(_manager);\n    }\n\n    \n    // ==== state changing external functions ====\n\n    /// See {INFTLoanFacilitator-createLoan}.\n    function createLoan(\n        uint256 collateralTokenId,\n        address collateralContractAddress,\n        uint16 maxPerAnumInterest,\n        uint128 minLoanAmount,\n        address loanAssetContractAddress,\n        uint32 minDurationSeconds,\n        address mintBorrowTicketTo\n    )\n        external\n        override\n        returns (uint256 id) \n    {\n        require(minDurationSeconds != 0, 'NFTLoanFacilitator: 0 duration');\n        require(minLoanAmount != 0, 'NFTLoanFacilitator: 0 loan amount');\n        require(collateralContractAddress != lendTicketContract,\n        'NFTLoanFacilitator: cannot use tickets as collateral');\n        require(collateralContractAddress != borrowTicketContract, \n        'NFTLoanFacilitator: cannot use tickets as collateral');\n        \n        IERC721(collateralContractAddress).transferFrom(msg.sender, address(this), collateralTokenId);\n\n        unchecked {\n            id = _nonce++;\n        }\n\n        Loan storage loan = loanInfo[id];\n        loan.loanAssetContractAddress = loanAssetContractAddress;\n        loan.loanAmount = minLoanAmount;\n        loan.collateralTokenId = collateralTokenId;\n        loan.collateralContractAddress = collateralContractAddress;\n        loan.perAnumInterestRate = maxPerAnumInterest;\n        loan.durationSeconds = minDurationSeconds;\n        \n        IERC721Mintable(borrowTicketContract).mint(mintBorrowTicketTo, id);\n        emit CreateLoan(\n            id,\n            msg.sender,\n            collateralTokenId,\n            collateralContractAddress,\n            maxPerAnumInterest,\n            loanAssetContractAddress,\n            minLoanAmount,\n            minDurationSeconds\n        );\n    }\n\n    /// See {INFTLoanFacilitator-closeLoan}.\n    function closeLoan(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {\n        require(IERC721(borrowTicketContract).ownerOf(loanId) == msg.sender,\n        \"NFTLoanFacilitator: borrow ticket holder only\");\n\n        Loan storage loan = loanInfo[loanId];\n        require(loan.lastAccumulatedTimestamp == 0, \"NFTLoanFacilitator: has lender, use repayAndCloseLoan\");\n        \n        loan.closed = true;\n        IERC721(loan.collateralContractAddress).transferFrom(address(this), sendCollateralTo, loan.collateralTokenId);\n        emit Close(loanId);\n    }\n\n    /// See {INFTLoanFacilitator-lend}.\n    function lend(\n        uint256 loanId,\n        uint16 interestRate,\n        uint128 amount,\n        uint32 durationSeconds,\n        address sendLendTicketTo\n    )\n        external\n        override\n        notClosed(loanId)\n    {\n        Loan storage loan = loanInfo[loanId];\n        \n        if (loan.lastAccumulatedTimestamp == 0) {\n            address loanAssetContractAddress = loan.loanAssetContractAddress;\n            require(loanAssetContractAddress != address(0), \"NFTLoanFacilitator: invalid loan\");\n\n            require(interestRate <= loan.perAnumInterestRate, 'NFTLoanFacilitator: rate too high');\n            require(durationSeconds >= loan.durationSeconds, 'NFTLoanFacilitator: duration too low');\n            require(amount >= loan.loanAmount, 'NFTLoanFacilitator: amount too low');\n        \n            loan.perAnumInterestRate = interestRate;\n            loan.lastAccumulatedTimestamp = uint40(block.timestamp);\n            loan.durationSeconds = durationSeconds;\n            loan.loanAmount = amount;\n\n            ERC20(loanAssetContractAddress).safeTransferFrom(msg.sender, address(this), amount);\n            uint256 facilitatorTake = amount * originationFeeRate / SCALAR;\n            ERC20(loanAssetContractAddress).safeTransfer(\n                IERC721(borrowTicketContract).ownerOf(loanId),\n                amount - facilitatorTake\n            );\n            IERC721Mintable(lendTicketContract).mint(sendLendTicketTo, loanId);\n        } else {\n            uint256 previousLoanAmount = loan.loanAmount;\n            // will underflow if amount < previousAmount\n            uint256 amountIncrease = amount - previousLoanAmount;\n\n            {\n                uint256 previousInterestRate = loan.perAnumInterestRate;\n                uint256 previousDurationSeconds = loan.durationSeconds;\n\n                require(interestRate <= previousInterestRate, 'NFTLoanFacilitator: rate too high');\n                require(durationSeconds >= previousDurationSeconds, 'NFTLoanFacilitator: duration too low');\n\n                require((previousLoanAmount * requiredImprovementRate / SCALAR) <= amountIncrease\n                || previousDurationSeconds + (previousDurationSeconds * requiredImprovementRate / SCALAR) <= durationSeconds \n                || (previousInterestRate != 0 // do not allow rate improvement if rate already 0\n                    && previousInterestRate - (previousInterestRate * requiredImprovementRate / SCALAR) >= interestRate), \n                \"NFTLoanFacilitator: proposed terms must be better than existing terms\");\n            }\n\n            uint256 accumulatedInterest = _interestOwed(\n                previousLoanAmount,\n                loan.lastAccumulatedTimestamp,\n                loan.perAnumInterestRate,\n                loan.accumulatedInterest\n            );\n\n            require(accumulatedInterest <= type(uint128).max,\n            \"NFTLoanFacilitator: accumulated interest exceeds uint128\");\n\n            loan.perAnumInterestRate = interestRate;\n            loan.lastAccumulatedTimestamp = uint40(block.timestamp);\n            loan.durationSeconds = durationSeconds;\n            loan.loanAmount = amount;\n            loan.accumulatedInterest = uint128(accumulatedInterest);\n\n            address currentLoanOwner = IERC721(lendTicketContract).ownerOf(loanId);\n            if (amountIncrease > 0) {\n                address loanAssetContractAddress = loan.loanAssetContractAddress;\n                ERC20(loanAssetContractAddress).safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    amount + accumulatedInterest\n                );\n                ERC20(loanAssetContractAddress).safeTransfer(\n                    currentLoanOwner,\n                    accumulatedInterest + previousLoanAmount\n                );\n                uint256 facilitatorTake = (amountIncrease * originationFeeRate / SCALAR);\n                ERC20(loanAssetContractAddress).safeTransfer(\n                    IERC721(borrowTicketContract).ownerOf(loanId),\n                    amountIncrease - facilitatorTake\n                );\n            } else {\n                ERC20(loan.loanAssetContractAddress).safeTransferFrom(\n                    msg.sender,\n                    currentLoanOwner,\n                    accumulatedInterest + previousLoanAmount\n                );\n            }\n            ILendTicket(lendTicketContract).loanFacilitatorTransfer(currentLoanOwner, sendLendTicketTo, loanId);\n            \n            emit BuyoutLender(loanId, msg.sender, currentLoanOwner, accumulatedInterest, previousLoanAmount);\n        }\n\n        emit Lend(loanId, msg.sender, interestRate, amount, durationSeconds);\n    }\n\n    /// See {INFTLoanFacilitator-repayAndCloseLoan}.\n    function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {\n        Loan storage loan = loanInfo[loanId];\n\n        uint256 interest = _interestOwed(\n            loan.loanAmount,\n            loan.lastAccumulatedTimestamp,\n            loan.perAnumInterestRate,\n            loan.accumulatedInterest\n        );\n        address lender = IERC721(lendTicketContract).ownerOf(loanId);\n        loan.closed = true;\n        ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount);\n        IERC721(loan.collateralContractAddress).safeTransferFrom(\n            address(this),\n            IERC721(borrowTicketContract).ownerOf(loanId),\n            loan.collateralTokenId\n        );\n\n        emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount);\n        emit Close(loanId);\n    }\n\n    /// See {INFTLoanFacilitator-seizeCollateral}.\n    function seizeCollateral(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {\n        require(IERC721(lendTicketContract).ownerOf(loanId) == msg.sender, \n        \"NFTLoanFacilitator: lend ticket holder only\");\n\n        Loan storage loan = loanInfo[loanId];\n        require(block.timestamp > loan.durationSeconds + loan.lastAccumulatedTimestamp,\n        \"NFTLoanFacilitator: payment is not late\");\n\n        loan.closed = true;\n        IERC721(loan.collateralContractAddress).safeTransferFrom(\n            address(this),\n            sendCollateralTo,\n            loan.collateralTokenId\n        );\n\n        emit SeizeCollateral(loanId);\n        emit Close(loanId);\n    }\n\n    \n    // === owner state changing ===\n\n    /**\n     * @notice Sets lendTicketContract to _contract\n     * @dev cannot be set if lendTicketContract is already set\n     */\n    function setLendTicketContract(address _contract) external onlyOwner {\n        require(lendTicketContract == address(0), 'NFTLoanFacilitator: already set');\n\n        lendTicketContract = _contract;\n    }\n\n    /**\n     * @notice Sets borrowTicketContract to _contract\n     * @dev cannot be set if borrowTicketContract is already set\n     */\n    function setBorrowTicketContract(address _contract) external onlyOwner {\n        require(borrowTicketContract == address(0), 'NFTLoanFacilitator: already set');\n\n        borrowTicketContract = _contract;\n    }\n\n    /// @notice Transfers `amount` of loan origination fees for `asset` to `to`\n    function withdrawOriginationFees(address asset, uint256 amount, address to) external onlyOwner {\n        ERC20(asset).safeTransfer(to, amount);\n\n        emit WithdrawOriginationFees(asset, amount, to);\n    }\n\n    /**\n     * @notice Updates originationFeeRate the faciliator keeps of each loan amount\n     * @dev Cannot be set higher than 5%\n     */\n    function updateOriginationFeeRate(uint32 _originationFeeRate) external onlyOwner {\n        require(_originationFeeRate <= 5 * (10 ** (INTEREST_RATE_DECIMALS - 2)), \"NFTLoanFacilitator: max fee 5%\");\n        \n        originationFeeRate = _originationFeeRate;\n\n        emit UpdateOriginationFeeRate(_originationFeeRate);\n    }\n\n    /**\n     * @notice updates the percent improvement required of at least one loan term when buying out lender \n     * a loan that already has a lender. E.g. setting this value to 10 means duration or amount\n     * must be 10% higher or interest rate must be 10% lower. \n     * @dev Cannot be 0.\n     */\n    function updateRequiredImprovementRate(uint256 _improvementRate) external onlyOwner {\n        require(_improvementRate > 0, 'NFTLoanFacilitator: 0 improvement rate');\n\n        requiredImprovementRate = _improvementRate;\n\n        emit UpdateRequiredImprovementRate(_improvementRate);\n    }\n\n    \n    // ==== external view ====\n\n    /// See {INFTLoanFacilitator-loanInfoStruct}.\n    function loanInfoStruct(uint256 loanId) external view override returns (Loan memory) {\n        return loanInfo[loanId];\n    }\n\n    /// See {INFTLoanFacilitator-totalOwed}.\n    function totalOwed(uint256 loanId) external view override returns (uint256) {\n        Loan storage loan = loanInfo[loanId];\n        if (loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;\n\n        return loanInfo[loanId].loanAmount + _interestOwed(\n            loan.loanAmount,\n            loan.lastAccumulatedTimestamp,\n            loan.perAnumInterestRate,\n            loan.accumulatedInterest\n        );\n    }\n\n    /// See {INFTLoanFacilitator-interestOwed}.\n    function interestOwed(uint256 loanId) external view override returns (uint256) {\n        Loan storage loan = loanInfo[loanId];\n        if(loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;\n\n        return _interestOwed(\n            loan.loanAmount,\n            loan.lastAccumulatedTimestamp,\n            loan.perAnumInterestRate,\n            loan.accumulatedInterest\n        );\n    }\n\n    /// See {INFTLoanFacilitator-loanEndSeconds}.\n    function loanEndSeconds(uint256 loanId) external view override returns (uint256) {\n        Loan storage loan = loanInfo[loanId];\n        return loan.durationSeconds + loan.lastAccumulatedTimestamp;\n    }\n\n    \n    // === private ===\n\n    /// @dev Returns the total interest owed on loan\n    function _interestOwed(\n        uint256 loanAmount,\n        uint256 lastAccumulatedTimestamp,\n        uint256 perAnumInterestRate,\n        uint256 accumulatedInterest\n    ) \n        internal \n        view \n        returns (uint256) \n    {\n        return loanAmount\n            * (block.timestamp - lastAccumulatedTimestamp)\n            * (perAnumInterestRate * 1e18 / 365 days)\n            / 1e21 // SCALAR * 1e18\n            + accumulatedInterest;\n    }\n}"
    },
    {
      "filename": "contracts/utils/math/Math.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}"
    }
  ]
}