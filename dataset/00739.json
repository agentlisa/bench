{
  "Title": "Oracle Data Lacks Validation",
  "Content": "Throughout the [codebase](https://github.com/Ion-Protocol/ion-protocol/tree/98e282514ac5827196b49f688938e1e44709505a/), there are several functions that use on-chain oracles to retrieve price data. These oracles consistently lack validation of the returned data. In particular:\n\n\n* The `WstEthSpotOracle` contract uses a Chainlink oracle to get the [price of stETH in ETH](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/oracles/spot/WstEthSpotOracle.sol#L38) within the `getPrice` function.\n* The `EthXSpotOracle` contract uses a Redstone oracle to get the [price of ETHx in USD](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/oracles/spot/EthXSpotOracle.sol#L42) and a Chainlink oracle to get the [price of ETH in USD](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/oracles/spot/EthXSpotOracle.sol#L45) within the `getPrice` function.\n\n\nConsider adding checks which validate the returned data to ensure a non-zero price is returned and that the price is recent.\n\n\n***Update:** Acknowledged, not resolved. Ion Protocol team stated:*\n\n\n\n> *Please refer to the M-07 response stating that underreported and overreported spot oracle values do not cause user loss of funds.*\n> \n> \n> *The suggested validation above is to check the returned value against a zero value. However, even if the oracle returns a zero value, the zero value will simply not allow any issuance of debt and therefore is not a risk for the protocol. Therefore validating the zero value or not validating the zero value does not introduce a meaningful difference to user safety.*\n> \n> \n> *As stated in M-07, similar malfunctioning of oracle behavior will be monitored offchain to trigger pauses when necessary.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/oracles/spot/WstEthSpotOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.21;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { SpotOracle } from \"src/oracles/spot/SpotOracle.sol\";\nimport { IChainlink } from \"src/interfaces/IChainlink.sol\";\n\ninterface IWstEth {\n    function getStETHByWstETH(uint256 stEthAmount) external view returns (uint256 wstEthAmount);\n}\n\ncontract WstEthSpotOracle is SpotOracle {\n    using SafeCast for int256; \n    IChainlink immutable ST_ETH_TO_ETH_CHAINLINK;\n    IWstEth immutable WST_ETH;\n\n    constructor(\n        uint256 _ltv,\n        address _reserveOracle,\n        address _stEthToEthChainlink,\n        address _wstETH\n    )\n        SpotOracle(_ltv, _reserveOracle)\n    {\n        ST_ETH_TO_ETH_CHAINLINK = IChainlink(_stEthToEthChainlink);\n        WST_ETH = IWstEth(_wstETH);\n    }\n\n    // @notice Gets the pure price of the collateral in terms of ETH. \n    // @dev Because the collateral amount in the core contract is denominated in amount of wstETH tokens,\n    // spot needs to equal (stETH/wstETH) * (ETH/stETH) * liquidationThreshold.\n    // If the beaconchain reserve decreases, the wstEth to stEth conversion will be directly impacted,\n    // but the stEth to Eth conversion will simply be determined by the chainlink price oracle.\n    // @return ethPerWstEth price of wstETH in ETH [wad]\n    function getPrice() public view override returns (uint256 ethPerWstEth) {\n        // get price from the protocol feed\n        (, int256 _ethPerStEth,,,) = ST_ETH_TO_ETH_CHAINLINK.latestRoundData(); // price of stETH denominated in ETH\n        uint256 ethPerStEth = _ethPerStEth.toUint256(); \n        // collateral * wstEthInEth = collateralInEth\n        ethPerWstEth = WST_ETH.getStETHByWstETH(uint256(ethPerStEth)); // stEth per wstEth\n    }\n}"
    },
    {
      "filename": "src/oracles/spot/EthXSpotOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.21;\n\nimport { SpotOracle } from \"src/oracles/spot/SpotOracle.sol\";\nimport { IChainlink } from \"src/interfaces/IChainlink.sol\";\nimport { WadRayMath } from \"src/libraries/math/WadRayMath.sol\";\n\ninterface IRedstonePriceFeed {\n    function latestAnswer() external view returns (int256 answer);\n}\n\nuint8 constant REDSTONE_DECIMALS = 8;\nuint8 constant CHAINLINK_DECIMALS = 8;\n\ncontract EthXSpotOracle is SpotOracle {\n    using WadRayMath for uint256;\n\n    IRedstonePriceFeed immutable REDSTONE_ETHX_PRICE_FEED;\n    IChainlink immutable USD_PER_ETH_CHAINLINK;\n\n    constructor(\n        uint256 _ltv,\n        address _reserveOracle,\n        address _redstoneEthXPriceFeed,\n        address _usdPerEthChainlink\n    )\n        SpotOracle(_ltv, _reserveOracle)\n    {\n        REDSTONE_ETHX_PRICE_FEED = IRedstonePriceFeed(_redstoneEthXPriceFeed);\n        USD_PER_ETH_CHAINLINK = IChainlink(_usdPerEthChainlink);\n    }\n\n    // @notice Gets the price of ETHx in ETH. \n    // @dev redstone oracle returns dollar value per ETHx with 6 decimals.\n    // This needs to be converted to [wad] and to ETH denomination.\n    // @return ethPerEthX price of ETHx in ETH [wad] \n    function getPrice() public view override returns (uint256 ethPerEthX) {\n        // get price from the protocol feed\n        // usd per ETHx\n\n        uint256 usdPerEthX = uint256(REDSTONE_ETHX_PRICE_FEED.latestAnswer()).scaleUpToWad(REDSTONE_DECIMALS); //\n\n        // usd per ETH\n        (, int256 _usdPerEth,,,) = USD_PER_ETH_CHAINLINK.latestRoundData(); // price of stETH denominated in ETH\n        uint256 usdPerEth = uint256(_usdPerEth).scaleUpToWad(CHAINLINK_DECIMALS); // price of stETH denominated in ETH\n\n        // (USD per ETHx) / (USD per ETH) = (USD per ETHx) * (ETH per USD) = ETH per ETHx\n        ethPerEthX = usdPerEthX.wadDivDown(usdPerEth);\n    }\n}"
    }
  ]
}