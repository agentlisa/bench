{
  "Title": "[G-12] Switch the order around `&&` to use `shortcircuit` to save gas (Instances missed by bot)",
  "Content": "\n### Instance 1\n\nYou can switch the order of conditions in the `if` statement to utilize short-circuit evaluation. This ensures that `if` the first condition `(unwrap)` is `false` the second condition `(address(weth) == address(token))` won't even be evaluated.\n\n```solidity\nFile : automators/Automator.sol\n\n219:  if (address(weth) == address(token) && unwrap) {\n```\n\n[Automator.sol#L219](https://github.com/code-423n4/2024-03-revert-lend/blob/main/src/automators/Automator.sol#L219)\n\n### Recommended Mitigation Steps\n\n```diff\nFile : automators/Automator.sol\n\n-219:  if (address(weth) == address(token) && unwrap) {\n+219:  if (unwrap && address(weth) == address(token)) {\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-03-revert-lend",
  "Code": [
    {
      "filename": "src/automators/Automator.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"v3-core/interfaces/IUniswapV3Factory.sol\";\nimport \"v3-core/interfaces/IUniswapV3Pool.sol\";\nimport \"v3-core/libraries/TickMath.sol\";\nimport \"v3-core/libraries/FullMath.sol\";\n\nimport \"v3-periphery/interfaces/INonfungiblePositionManager.sol\";\n\nimport \"../../lib/IWETH9.sol\";\nimport \"../utils/Swapper.sol\";\nimport \"../interfaces/IVault.sol\";\n\nabstract contract Automator is Swapper, Ownable {\n    uint256 internal constant Q64 = 2 ** 64;\n    uint256 internal constant Q96 = 2 ** 96;\n\n    uint32 public constant MIN_TWAP_SECONDS = 60; // 1 minute\n    uint32 public constant MAX_TWAP_TICK_DIFFERENCE = 200; // 2%\n\n    // admin events\n    event OperatorChanged(address newOperator, bool active);\n    event VaultChanged(address newVault, bool active);\n\n    event WithdrawerChanged(address newWithdrawer);\n    event TWAPConfigChanged(uint32 TWAPSeconds, uint16 maxTWAPTickDifference);\n\n    // configurable by owner\n    mapping(address => bool) public operators;\n    mapping(address => bool) public vaults;\n\n    address public withdrawer;\n    uint32 public TWAPSeconds;\n    uint16 public maxTWAPTickDifference;\n\n    constructor(\n        INonfungiblePositionManager npm,\n        address _operator,\n        address _withdrawer,\n        uint32 _TWAPSeconds,\n        uint16 _maxTWAPTickDifference,\n        address _zeroxRouter,\n        address _universalRouter\n    ) Swapper(npm, _zeroxRouter, _universalRouter) {\n        setOperator(_operator, true);\n        setWithdrawer(_withdrawer);\n        setTWAPConfig(_maxTWAPTickDifference, _TWAPSeconds);\n    }\n\n    /**\n     * @notice Owner controlled function to set withdrawer address\n     * @param _withdrawer withdrawer\n     */\n    function setWithdrawer(address _withdrawer) public onlyOwner {\n        emit WithdrawerChanged(_withdrawer);\n        withdrawer = _withdrawer;\n    }\n\n    /**\n     * @notice Owner controlled function to activate/deactivate operator address\n     * @param _operator operator\n     * @param _active active or not\n     */\n    function setOperator(address _operator, bool _active) public onlyOwner {\n        emit OperatorChanged(_operator, _active);\n        operators[_operator] = _active;\n    }\n\n    /**\n     * @notice Owner controlled function to activate/deactivate vault address\n     * @param _vault vault\n     * @param _active active or not\n     */\n    function setVault(address _vault, bool _active) public onlyOwner {\n        emit VaultChanged(_vault, _active);\n        vaults[_vault] = _active;\n    }\n\n    /**\n     * @notice Owner controlled function to increase TWAPSeconds / decrease maxTWAPTickDifference\n     */\n    function setTWAPConfig(uint16 _maxTWAPTickDifference, uint32 _TWAPSeconds) public onlyOwner {\n        if (_TWAPSeconds < MIN_TWAP_SECONDS) {\n            revert InvalidConfig();\n        }\n        if (_maxTWAPTickDifference > MAX_TWAP_TICK_DIFFERENCE) {\n            revert InvalidConfig();\n        }\n        emit TWAPConfigChanged(_TWAPSeconds, _maxTWAPTickDifference);\n        TWAPSeconds = _TWAPSeconds;\n        maxTWAPTickDifference = _maxTWAPTickDifference;\n    }\n\n    /**\n     * @notice Withdraws token balance (accumulated protocol fee)\n     * @param tokens Addresses of tokens to withdraw\n     * @param to Address to send to\n     */\n    function withdrawBalances(address[] calldata tokens, address to) external virtual {\n        if (msg.sender != withdrawer) {\n            revert Unauthorized();\n        }\n\n        uint256 i;\n        uint256 count = tokens.length;\n        for (; i < count; ++i) {\n            uint256 balance = IERC20(tokens[i]).balanceOf(address(this));\n            if (balance > 0) {\n                _transferToken(to, IERC20(tokens[i]), balance, true);\n            }\n        }\n    }\n\n    /**\n     * @notice Withdraws ETH balance\n     * @param to Address to send to\n     */\n    function withdrawETH(address to) external {\n        if (msg.sender != withdrawer) {\n            revert Unauthorized();\n        }\n\n        uint256 balance = address(this).balance;\n        if (balance > 0) {\n            (bool sent,) = to.call{value: balance}(\"\");\n            if (!sent) {\n                revert EtherSendFailed();\n            }\n        }\n    }\n\n    // validate if swap can be done with specified oracle parameters - if not possible reverts\n    // if possible returns minAmountOut\n    function _validateSwap(\n        bool swap0For1,\n        uint256 amountIn,\n        IUniswapV3Pool pool,\n        uint32 twapPeriod,\n        uint16 maxTickDifference,\n        uint64 maxPriceDifferenceX64\n    ) internal view returns (uint256 amountOutMin, int24 currentTick, uint160 sqrtPriceX96, uint256 priceX96) {\n        // get current price and tick\n        (sqrtPriceX96, currentTick,,,,,) = pool.slot0();\n\n        // check if current tick not too far from TWAP\n        if (!_hasMaxTWAPTickDifference(pool, twapPeriod, currentTick, maxTickDifference)) {\n            revert TWAPCheckFailed();\n        }\n\n        // calculate min output price price and percentage\n        priceX96 = FullMath.mulDiv(sqrtPriceX96, sqrtPriceX96, Q96);\n        if (swap0For1) {\n            amountOutMin = FullMath.mulDiv(amountIn * (Q64 - maxPriceDifferenceX64), priceX96, Q96 * Q64);\n        } else {\n            amountOutMin = FullMath.mulDiv(amountIn * (Q64 - maxPriceDifferenceX64), Q96, priceX96 * Q64);\n        }\n    }\n\n    // Checks if there was not more tick difference\n    // returns false if not enough data available or tick difference >= maxDifference\n    function _hasMaxTWAPTickDifference(IUniswapV3Pool pool, uint32 twapPeriod, int24 currentTick, uint16 maxDifference)\n        internal\n        view\n        returns (bool)\n    {\n        (int24 twapTick, bool twapOk) = _getTWAPTick(pool, twapPeriod);\n        if (twapOk) {\n            return twapTick - currentTick >= -int16(maxDifference) && twapTick - currentTick <= int16(maxDifference);\n        } else {\n            return false;\n        }\n    }\n\n    // gets twap tick from pool history if enough history available\n    function _getTWAPTick(IUniswapV3Pool pool, uint32 twapPeriod) internal view returns (int24, bool) {\n        uint32[] memory secondsAgos = new uint32[](2);\n        secondsAgos[0] = 0; // from (before)\n        secondsAgos[1] = twapPeriod; // from (before)\n\n        // pool observe may fail when there is not enough history available\n        try pool.observe(secondsAgos) returns (int56[] memory tickCumulatives, uint160[] memory) {\n            return (int24((tickCumulatives[0] - tickCumulatives[1]) / int56(uint56(twapPeriod))), true);\n        } catch {\n            return (0, false);\n        }\n    }\n\n    function _decreaseFullLiquidityAndCollect(\n        uint256 tokenId,\n        uint128 liquidity,\n        uint256 amountRemoveMin0,\n        uint256 amountRemoveMin1,\n        uint256 deadline\n    ) internal returns (uint256 amount0, uint256 amount1, uint256 feeAmount0, uint256 feeAmount1) {\n        if (liquidity > 0) {\n            // store in temporarely \"misnamed\" variables - see comment below\n            (feeAmount0, feeAmount1) = nonfungiblePositionManager.decreaseLiquidity(\n                INonfungiblePositionManager.DecreaseLiquidityParams(\n                    tokenId, liquidity, amountRemoveMin0, amountRemoveMin1, deadline\n                )\n            );\n        }\n        (amount0, amount1) = nonfungiblePositionManager.collect(\n            INonfungiblePositionManager.CollectParams(tokenId, address(this), type(uint128).max, type(uint128).max)\n        );\n\n        // fee amount is what was collected additionally to liquidity amount\n        feeAmount0 = amount0 - feeAmount0;\n        feeAmount1 = amount1 - feeAmount1;\n    }\n\n    // transfers token (or unwraps WETH and sends ETH)\n    function _transferToken(address to, IERC20 token, uint256 amount, bool unwrap) internal {\n        if (address(weth) == address(token) && unwrap) {\n            weth.withdraw(amount);\n            (bool sent,) = to.call{value: amount}(\"\");\n            if (!sent) {\n                revert EtherSendFailed();\n            }\n        } else {\n            SafeERC20.safeTransfer(token, to, amount);\n        }\n    }\n\n    function _validateOwner(uint256 tokenId, address vault) internal returns (address owner) {\n        // msg.sender must not be a vault\n        if (vaults[msg.sender]) {\n            revert Unauthorized();\n        }\n\n        if (vault != address(0)) {\n            if (!vaults[vault]) {\n                revert Unauthorized();\n            }\n            owner = IVault(vault).ownerOf(tokenId);\n        } else {\n            owner = nonfungiblePositionManager.ownerOf(tokenId);\n        }\n\n        if (owner != msg.sender) {\n            revert Unauthorized();\n        }\n    }\n\n    // needed for WETH unwrapping\n    receive() external payable {\n        if (msg.sender != address(weth)) {\n            revert NotWETH();\n        }\n    }\n}"
    }
  ]
}