{
  "Title": "[L02] contractEnabled should be a bool",
  "Content": "The variable `contractEnabled` is declared in many contracts as a `uint` value, for example [within the `BasicTokenAdapters`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/BasicTokenAdapters.sol#L88) or the [`SAFEEngine`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/SAFEEngine.sol#L116) contracts. Whenever its value is set, it is always set to a `1` or `0` value. Furthermore, whenever it is checked, it is always checked for strict equality to either `0` (like within the [`AccountingEngine`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/AccountingEngine.sol#L325) contract) or `1` (also within the [`AccountingEngine`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/AccountingEngine.sol#L55) contract).\n\n\nSince a `uint` can contain many values besides `0` or `1`, if somehow any one of the `contractEnabled` values is set greater than `1`, all strict equality checks on `contractEnabled` will fail.\n\n\nIf this variable is intended to have only two possible values, consider changing the declarations of `contractEnabled` so that they are `bool`s. This is the intended type for such a situation, and will prevent accidentally setting `contractEnabled` to anything other than the two intended values.\n\n\n***Update:** Acknowledged, not fixed. Reflexer Labsâ€™ statement for this issue:*\n\n\n\n> \n>  We would like to stick to the same logic inherited from MCD\n> \n> \n> \n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/BasicTokenAdapters.sol",
      "content": "/// BasicTokenAdapters.sol\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.7;\n\nabstract contract CollateralLike {\n    function decimals() virtual public view returns (uint);\n    function transfer(address,uint) virtual public returns (bool);\n    function transferFrom(address,address,uint) virtual public returns (bool);\n}\n\nabstract contract DSTokenLike {\n    function mint(address,uint) virtual external;\n    function burn(address,uint) virtual external;\n}\n\nabstract contract SAFEEngineLike {\n    function modifyCollateralBalance(bytes32,address,int) virtual external;\n    function transferInternalCoins(address,address,uint) virtual external;\n}\n\n/*\n    Here we provide *adapters* to connect the SAFEEngine to arbitrary external\n    token implementations, creating a bounded context for the SAFEEngine. The\n    adapters here are provided as working examples:\n      - `BasicCollateralJoin`: For well behaved ERC20 tokens, with simple transfer semantics.\n      - `ETHJoin`: For native Ether.\n      - `CoinJoin`: For connecting internal coin balances to an external\n                   `Coin` implementation.\n    In practice, adapter implementations will be varied and specific to\n    individual collateral types, accounting for different transfer\n    semantics and token standards.\n    Adapters need to implement two basic methods:\n      - `join`: enter collateral into the system\n      - `exit`: remove collateral from the system\n*/\n\ncontract BasicCollateralJoin {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"BasicCollateralJoin/account-not-authorized\");\n        _;\n    }\n\n    // SAFE database\n    SAFEEngineLike  public safeEngine;\n    // Collateral type name\n    bytes32        public collateralType;\n    // Actual collateral token contract\n    CollateralLike public collateral;\n    // How many decimals the collateral token has\n    uint           public decimals;\n    // Whether this adapter contract is enabled or not\n    uint           public contractEnabled;\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event DisableContract();\n    event Join(address sender, address account, uint wad);\n    event Exit(address sender, address account, uint wad);\n\n    constructor(address safeEngine_, bytes32 collateralType_, address collateral_) public {\n        authorizedAccounts[msg.sender] = 1;\n        contractEnabled = 1;\n        safeEngine       = SAFEEngineLike(safeEngine_);\n        collateralType  = collateralType_;\n        collateral      = CollateralLike(collateral_);\n        decimals        = collateral.decimals();\n        emit AddAuthorization(msg.sender);\n    }\n    /**\n     * @notice Disable this contract\n     */\n    function disableContract() external isAuthorized {\n        contractEnabled = 0;\n        emit DisableContract();\n    }\n    /**\n    * @notice Join collateral in the system\n    * @dev This function locks collateral in the adapter and creates a 'representation' of\n    *      the locked collateral inside the system. This adapter assumes that the collateral\n    *      has 18 decimals\n    * @param account Account from which we transferFrom collateral and add it in the system\n    * @param wad Amount of collateral to transfer in the system (represented as a number with 18 decimals)\n    **/\n    function join(address account, uint wad) external {\n        require(contractEnabled == 1, \"BasicCollateralJoin/contract-not-enabled\");\n        require(int(wad) >= 0, \"BasicCollateralJoin/overflow\");\n        safeEngine.modifyCollateralBalance(collateralType, account, int(wad));\n        require(collateral.transferFrom(msg.sender, address(this), wad), \"BasicCollateralJoin/failed-transfer\");\n        emit Join(msg.sender, account, wad);\n    }\n    /**\n    * @notice Exit collateral from the system\n    * @dev This function destroys the collateral representation from inside the system\n    *      and exits the collateral from this adapte. The adapter assumes that the collateral\n    *      has 18 decimals\n    * @param account Account to which we transfer the collateral\n    * @param wad Amount of collateral to transfer to 'account' (represented as a number with 18 decimals)\n    **/\n    function exit(address account, uint wad) external {\n        require(wad <= 2 ** 255, \"BasicCollateralJoin/overflow\");\n        safeEngine.modifyCollateralBalance(collateralType, msg.sender, -int(wad));\n        require(collateral.transfer(account, wad), \"BasicCollateralJoin/failed-transfer\");\n        emit Exit(msg.sender, account, wad);\n    }\n}\n\ncontract ETHJoin {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"ETHJoin/account-not-authorized\");\n        _;\n    }\n\n    // SAFE database\n    SAFEEngineLike public safeEngine;\n    // Collateral type name\n    bytes32       public collateralType;\n    // Whether this contract is enabled or not\n    uint          public contractEnabled;\n    // Number of decimals ETH has\n    uint          public decimals;\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event DisableContract();\n    event Join(address sender, address account, uint wad);\n    event Exit(address sender, address account, uint wad);\n\n    constructor(address safeEngine_, bytes32 collateralType_) public {\n        authorizedAccounts[msg.sender] = 1;\n        contractEnabled                = 1;\n        safeEngine                      = SAFEEngineLike(safeEngine_);\n        collateralType                 = collateralType_;\n        decimals                       = 18;\n        emit AddAuthorization(msg.sender);\n    }\n    /**\n     * @notice Disable this contract\n     */\n    function disableContract() external isAuthorized {\n        contractEnabled = 0;\n        emit DisableContract();\n    }\n    /**\n    * @notice Join ETH in the system\n    * @param account Account that will receive the ETH representation inside the system\n    **/\n    function join(address account) external payable {\n        require(contractEnabled == 1, \"ETHJoin/contract-not-enabled\");\n        require(int(msg.value) >= 0, \"ETHJoin/overflow\");\n        safeEngine.modifyCollateralBalance(collateralType, account, int(msg.value));\n        emit Join(msg.sender, account, msg.value);\n    }\n    /**\n    * @notice Exit ETH from the system\n    * @param account Account that will receive the ETH representation inside the system\n    **/\n    function exit(address payable account, uint wad) external {\n        require(int(wad) >= 0, \"ETHJoin/overflow\");\n        safeEngine.modifyCollateralBalance(collateralType, msg.sender, -int(wad));\n        emit Exit(msg.sender, account, wad);\n        account.transfer(wad);\n    }\n}\n\ncontract CoinJoin {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"CoinJoin/account-not-authorized\");\n        _;\n    }\n\n    // SAFE database\n    SAFEEngineLike public safeEngine;\n    // Coin created by the system; this is the external, ERC-20 representation, not the internal 'coinBalance'\n    DSTokenLike   public systemCoin;\n    // Whether this contract is enabled or not\n    uint          public contractEnabled;\n    // Number of decimals the system coin has\n    uint          public decimals;\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event DisableContract();\n    event Join(address sender, address account, uint wad);\n    event Exit(address sender, address account, uint wad);\n\n    constructor(address safeEngine_, address systemCoin_) public {\n        authorizedAccounts[msg.sender] = 1;\n        contractEnabled                = 1;\n        safeEngine                      = SAFEEngineLike(safeEngine_);\n        systemCoin                     = DSTokenLike(systemCoin_);\n        decimals                       = 18;\n        emit AddAuthorization(msg.sender);\n    }\n    /**\n     * @notice Disable this contract\n     */\n    function disableContract() external isAuthorized {\n        contractEnabled = 0;\n        emit DisableContract();\n    }\n    uint constant RAY = 10 ** 27;\n    function multiply(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n    /**\n    * @notice Join system coins in the system\n    * @dev Exited coins have 18 decimals but inside the system they have 45 (rad) decimals.\n           When we join, the amount (wad) is multiplied by 10**27 (ray)\n    * @param account Account that will receive the joined coins\n    * @param wad Amount of external coins to join (18 decimal number)\n    **/\n    function join(address account, uint wad) external {\n        safeEngine.transferInternalCoins(address(this), account, multiply(RAY, wad));\n        systemCoin.burn(msg.sender, wad);\n        emit Join(msg.sender, account, wad);\n    }\n    /**\n    * @notice Exit system coins from the system and inside 'Coin.sol'\n    * @dev Inside the system, coins have 45 (rad) decimals but outside they have 18 decimals (wad).\n           When we exit, we specify a wad amount of coins and then the contract automatically multiplies\n           wad by 10**27 to move the correct 45 decimal coin amount to this adapter\n    * @param account Account that will receive the exited coins\n    * @param wad Amount of internal coins to join (18 decimal number that will be multiplied by ray)\n    **/\n    function exit(address account, uint wad) external {\n        require(contractEnabled == 1, \"CoinJoin/contract-not-enabled\");\n        safeEngine.transferInternalCoins(msg.sender, address(this), multiply(RAY, wad));\n        systemCoin.mint(account, wad);\n        emit Exit(msg.sender, account, wad);\n    }\n}"
    }
  ]
}