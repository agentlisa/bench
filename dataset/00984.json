{
  "Title": "GMXOracle.sol#L280: function `getLpTokenAmount` icorrectly assumes that the returned price is in 18 decimal places. But it is 30 decimal places.",
  "Content": "# GMXOracle.sol#L280: function `getLpTokenAmount` icorrectly assumes that the returned price is in 18 decimal places. But it is 30 decimal places.\n\n### Severity\nHigh Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/oracles/GMXOracle.sol#L280\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/oracles/GMXOracle.sol#L280</a>\n\n\n## Summary\n\n`GMXOracle` oracle has a function [getLpTokenAmount](https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/oracles/GMXOracle.sol#L280) which is in scope. This is Used in keeper script to calculate how much LP tokens for given USD value.\n\nThis function returns the `lpTokenAmount` with 30 decimal places instead of 18 as the function assumes.\n\n## Vulnerability Details\n\nLets look at the function [getLpTokenAmount](https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/oracles/GMXOracle.sol#L280)\n\n```solidity\n  /**\n    * @notice Get token A and token B's LP token amount required for a given value\n    * @param givenValue Given value needed, expressed in 1e30 -------------------------->> refer this\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param isDeposit Boolean for deposit or withdrawal\n    * @param maximize Boolean for minimum or maximum price\n    * @return lpTokenAmount Amount of LP tokens; expressed in 1e18 -------------->>> refer this\n  */\n  function getLpTokenAmount(\n    uint256 givenValue,\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    bool isDeposit,\n    bool maximize\n  ) public view returns (uint256) {\n    uint256 _lpTokenValue = getLpTokenValue(\n      marketToken,\n      indexToken,\n      longToken,\n      shortToken,\n      isDeposit,\n      maximize\n    );\n\n\n    return givenValue * SAFE_MULTIPLIER / _lpTokenValue;\n  }\n```\n\nSAFE_MULTIPLIER is in 18 decimal places.\n\nThe values returned from the function `_lpTokenValue` is in 18 decimal places. Refer the [line](https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/oracles/GMXOracle.sol#L264)\n\nSo the final returned value from the function `getLpTokenAmount`  is (1e30 * 1e18) / 1e18 = 1e30\n\n## Impact\n\nOverestimating the lpToken amount for the given USD value. \n\n## Tools Used\n\nManual review.\n\n## Recommendations\n\nUpdate the function `getLpTokenAmount` as shown below.\n\n```solidity\n  function getLpTokenAmount(\n    uint256 givenValue,\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    bool isDeposit,\n    bool maximize\n  ) public view returns (uint256) {\n    uint256 _lpTokenValue = getLpTokenValue(\n      marketToken,\n      indexToken,\n      longToken,\n      shortToken,\n      isDeposit,\n      maximize\n    );\n\n    return givenValue * SAFE_MULTIPLIER / _lpTokenValue; ------>> remove\n\n    return (givenValue * SAFE_MULTIPLIER) / (_lpTokenValue * 1e12); ---->> add\n   \n  }\n```",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "contracts/oracles/GMXOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { ISyntheticReader } from \"../interfaces/protocols/gmx/ISyntheticReader.sol\";\nimport { IChainlinkOracle } from \"../interfaces/oracles/IChainlinkOracle.sol\";\nimport { Errors } from \"../utils/Errors.sol\";\n\nimport { console } from \"forge-std/console.sol\";\n\ncontract GMXOracle {\n\n  /* ==================== STATE VARIABLES ==================== */\n\n  // GMX DataStore\n  address public immutable dataStore;\n  // GMX Synthetic Reader\n  ISyntheticReader public immutable syntheticReader;\n  // Chainlink oracle\n  IChainlinkOracle public immutable chainlinkOracle;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ====================== CONSTRUCTOR ====================== */\n\n  /**\n    * @param _DataStore Address of GMX DataStore\n    * @param _syntheticReader Address of GMX Synthetic Reader\n    * @param _chainlinkOracle Address of Chainlink oracle\n  */\n  constructor(\n    address _DataStore,\n    ISyntheticReader _syntheticReader,\n    IChainlinkOracle _chainlinkOracle\n  ) {\n    if (_DataStore == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(_syntheticReader) == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(_chainlinkOracle) == address(0)) revert Errors.ZeroAddressNotAllowed();\n\n    dataStore = _DataStore;\n    syntheticReader = _syntheticReader;\n    chainlinkOracle = _chainlinkOracle;\n  }\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice Get amountsOut of either the long or short token based on the amountsIn\n    * of either long or short token in the market\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param tokenIn TokenIn address\n    * @param amountIn Amount of tokenIn, expressed in tokenIn's decimals\n    * @return amountsOut Amount of tokenOut within LP (market) to be received, expressed in tokenOut's decimals\n  */\n  function getAmountsOut(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    address tokenIn,\n    uint256 amountIn\n  ) public view returns (uint256) {\n    ISyntheticReader.MarketProps memory _market;\n    _market.marketToken = marketToken;\n    _market.indexToken = indexToken;\n    _market.longToken = longToken;\n    _market.shortToken = shortToken;\n\n    ISyntheticReader.PriceProps memory _indexTokenPrice;\n    _indexTokenPrice.min = _getTokenPriceMinMaxFormatted(indexToken);\n    _indexTokenPrice.max = _getTokenPriceMinMaxFormatted(indexToken);\n\n    ISyntheticReader.PriceProps memory _longTokenPrice;\n    _longTokenPrice.min = _getTokenPriceMinMaxFormatted(longToken);\n    _longTokenPrice.max = _getTokenPriceMinMaxFormatted(longToken);\n\n    ISyntheticReader.PriceProps memory _shortTokenPrice;\n    _shortTokenPrice.min = _getTokenPriceMinMaxFormatted(shortToken);\n    _shortTokenPrice.max = _getTokenPriceMinMaxFormatted(shortToken);\n\n    ISyntheticReader.MarketPrices memory _prices;\n    _prices.indexTokenPrice = _indexTokenPrice;\n    _prices.longTokenPrice = _longTokenPrice;\n    _prices.shortTokenPrice = _shortTokenPrice;\n\n    address _uiFeeReceiver = address(0);\n\n    (uint256 _amountsOut,,) = syntheticReader.getSwapAmountOut(\n      dataStore,\n      _market,\n      _prices,\n      tokenIn,\n      amountIn,\n      _uiFeeReceiver\n    );\n\n    return _amountsOut;\n  }\n\n  /**\n    * @notice Helper function to calculate amountIn of either long or short token for swapping for\n    * desired amountsOut of long or short token\n    * @notice We utilise GMX's getSwapAmountOut() with tokenOut being tokenIn, multiplying\n    * the amountsOut value by 1.0015x to account for fees and normal chainlink price feed differential\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param tokenOut TokenIn address\n    * @param amountsOut Amount of tokenIn, expressed in tokenIn's decimals\n    * @return amountsOut Amount of tokenOut within LP (market) to be received, expressed in tokenOut's decimals\n  */\n  function getAmountsIn(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    address tokenOut,\n    uint256 amountsOut\n  ) public view returns (uint256) {\n    return getAmountsOut(\n      marketToken,\n      indexToken,\n      longToken,\n      shortToken,\n      tokenOut,\n      amountsOut\n    ) * (1e18 + 15e14) / SAFE_MULTIPLIER;\n  }\n\n  /**\n    * @notice Get LP (market) token info\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param pnlFactorType P&L Factory type in bytes32 hashed string\n    * @param maximize Min/max price boolean\n    * @return (marketTokenPrice, MarketPoolValueInfoProps MarketInfo)\n  */\n  function getMarketTokenInfo(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    bytes32 pnlFactorType,\n    bool maximize\n  ) public view returns (int256, ISyntheticReader.MarketPoolValueInfoProps memory) {\n    if (address(marketToken) == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(indexToken) == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(longToken) == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(shortToken) == address(0)) revert Errors.ZeroAddressNotAllowed();\n\n    ISyntheticReader.MarketProps memory _market;\n    _market.marketToken = marketToken;\n    _market.indexToken = indexToken;\n    _market.longToken = longToken;\n    _market.shortToken = shortToken;\n\n    ISyntheticReader.PriceProps memory _indexTokenPrice;\n    _indexTokenPrice.min = _getTokenPriceMinMaxFormatted(indexToken);\n    _indexTokenPrice.max = _getTokenPriceMinMaxFormatted(indexToken);\n\n    ISyntheticReader.PriceProps memory _longTokenPrice;\n    _longTokenPrice.min = _getTokenPriceMinMaxFormatted(longToken);\n    _longTokenPrice.max = _getTokenPriceMinMaxFormatted(longToken);\n\n    ISyntheticReader.PriceProps memory _shortTokenPrice;\n    _shortTokenPrice.min = _getTokenPriceMinMaxFormatted(shortToken);\n    _shortTokenPrice.max = _getTokenPriceMinMaxFormatted(shortToken);\n\n    return syntheticReader.getMarketTokenPrice(\n      dataStore,\n      _market,\n      _indexTokenPrice,\n      _longTokenPrice,\n      _shortTokenPrice,\n      pnlFactorType,\n      maximize\n    );\n  }\n\n  /**\n    * @notice Get LP (market) token reserves\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @return (reserveA, reserveB) Reserve amount of longToken and shortToken respectively\n  */\n  function getLpTokenReserves(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken\n  ) public view returns (uint256, uint256) {\n    // _pnlFactorType value does not matter in getting token reserves\n    bytes32 _pnlFactorType = keccak256(abi.encode(\"MAX_PNL_FACTOR_FOR_DEPOSITS\"));\n\n    // _maximize value does not matter in getting token reserves\n    bool _maximize = false;\n\n    (, ISyntheticReader.MarketPoolValueInfoProps memory _marketInfo) = getMarketTokenInfo(\n      marketToken,\n      indexToken,\n      longToken,\n      shortToken,\n      _pnlFactorType,\n      _maximize\n    );\n\n    return (\n      _marketInfo.longTokenAmount,\n      _marketInfo.shortTokenAmount\n    );\n  }\n\n  /**\n    * @notice Get LP (market) token reserves\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param isDeposit Boolean for deposit or withdrawal\n    * @param maximize Boolean for minimum or maximum price\n    * @return marketTokenPrice in 1e18\n  */\n  function getLpTokenValue(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    bool isDeposit,\n    bool maximize\n  ) public view returns (uint256) {\n    bytes32 _pnlFactorType;\n\n    if (isDeposit) {\n      _pnlFactorType = keccak256(abi.encode(\"MAX_PNL_FACTOR_FOR_DEPOSITS\"));\n    } else {\n      _pnlFactorType = keccak256(abi.encode(\"MAX_PNL_FACTOR_FOR_WITHDRAWALS\"));\n    }\n\n    (int256 _marketTokenPrice,) = getMarketTokenInfo(\n      marketToken,\n      indexToken,\n      longToken,\n      shortToken,\n      _pnlFactorType,\n      maximize\n    );\n\n    // If LP token value is negative, return 0\n    if (_marketTokenPrice < 0) {\n      return 0;\n    } else {\n      // Price returned in 1e30, we normalize it to 1e18\n      return uint256(_marketTokenPrice) / 1e12;\n    }\n  }\n\n\n  /**\n    * @notice Get token A and token B's LP token amount required for a given value\n    * @param givenValue Given value needed, expressed in 1e30\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param isDeposit Boolean for deposit or withdrawal\n    * @param maximize Boolean for minimum or maximum price\n    * @return lpTokenAmount Amount of LP tokens; expressed in 1e18\n  */\n  function getLpTokenAmount(\n    uint256 givenValue,\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    bool isDeposit,\n    bool maximize\n  ) public view returns (uint256) {\n    uint256 _lpTokenValue = getLpTokenValue(\n      marketToken,\n      indexToken,\n      longToken,\n      shortToken,\n      isDeposit,\n      maximize\n    );\n\n    return givenValue * SAFE_MULTIPLIER / _lpTokenValue;\n  }\n\n  /* ================== INTERNAL FUNCTIONS =================== */\n\n  /**\n    * @notice Get token price formatted for GMX mix/max decimals for 1e30 normalization\n    * @dev E.g. if token decimals is 18, to normalize to 1e30, we need to return 30-18 = 1e12\n    * consult() usually returns asset price in 8 decimals, so 30 - tokenDecimals - priceDecimals\n    * should format the decimals correctly for 1e30\n    * @param token Token address\n    * @return tokenPriceMinMaxFormatted\n  */\n  function _getTokenPriceMinMaxFormatted(address token) internal view returns (uint256) {\n    (int256 _price, uint8 _priceDecimals) = chainlinkOracle.consult(token);\n\n    return uint256(_price) * 10 ** (30 - IERC20Metadata(token).decimals() - _priceDecimals);\n  }\n}"
    },
    {
      "filename": "contracts/oracles/GMXOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { ISyntheticReader } from \"../interfaces/protocols/gmx/ISyntheticReader.sol\";\nimport { IChainlinkOracle } from \"../interfaces/oracles/IChainlinkOracle.sol\";\nimport { Errors } from \"../utils/Errors.sol\";\n\nimport { console } from \"forge-std/console.sol\";\n\ncontract GMXOracle {\n\n  /* ==================== STATE VARIABLES ==================== */\n\n  // GMX DataStore\n  address public immutable dataStore;\n  // GMX Synthetic Reader\n  ISyntheticReader public immutable syntheticReader;\n  // Chainlink oracle\n  IChainlinkOracle public immutable chainlinkOracle;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ====================== CONSTRUCTOR ====================== */\n\n  /**\n    * @param _DataStore Address of GMX DataStore\n    * @param _syntheticReader Address of GMX Synthetic Reader\n    * @param _chainlinkOracle Address of Chainlink oracle\n  */\n  constructor(\n    address _DataStore,\n    ISyntheticReader _syntheticReader,\n    IChainlinkOracle _chainlinkOracle\n  ) {\n    if (_DataStore == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(_syntheticReader) == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(_chainlinkOracle) == address(0)) revert Errors.ZeroAddressNotAllowed();\n\n    dataStore = _DataStore;\n    syntheticReader = _syntheticReader;\n    chainlinkOracle = _chainlinkOracle;\n  }\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice Get amountsOut of either the long or short token based on the amountsIn\n    * of either long or short token in the market\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param tokenIn TokenIn address\n    * @param amountIn Amount of tokenIn, expressed in tokenIn's decimals\n    * @return amountsOut Amount of tokenOut within LP (market) to be received, expressed in tokenOut's decimals\n  */\n  function getAmountsOut(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    address tokenIn,\n    uint256 amountIn\n  ) public view returns (uint256) {\n    ISyntheticReader.MarketProps memory _market;\n    _market.marketToken = marketToken;\n    _market.indexToken = indexToken;\n    _market.longToken = longToken;\n    _market.shortToken = shortToken;\n\n    ISyntheticReader.PriceProps memory _indexTokenPrice;\n    _indexTokenPrice.min = _getTokenPriceMinMaxFormatted(indexToken);\n    _indexTokenPrice.max = _getTokenPriceMinMaxFormatted(indexToken);\n\n    ISyntheticReader.PriceProps memory _longTokenPrice;\n    _longTokenPrice.min = _getTokenPriceMinMaxFormatted(longToken);\n    _longTokenPrice.max = _getTokenPriceMinMaxFormatted(longToken);\n\n    ISyntheticReader.PriceProps memory _shortTokenPrice;\n    _shortTokenPrice.min = _getTokenPriceMinMaxFormatted(shortToken);\n    _shortTokenPrice.max = _getTokenPriceMinMaxFormatted(shortToken);\n\n    ISyntheticReader.MarketPrices memory _prices;\n    _prices.indexTokenPrice = _indexTokenPrice;\n    _prices.longTokenPrice = _longTokenPrice;\n    _prices.shortTokenPrice = _shortTokenPrice;\n\n    address _uiFeeReceiver = address(0);\n\n    (uint256 _amountsOut,,) = syntheticReader.getSwapAmountOut(\n      dataStore,\n      _market,\n      _prices,\n      tokenIn,\n      amountIn,\n      _uiFeeReceiver\n    );\n\n    return _amountsOut;\n  }\n\n  /**\n    * @notice Helper function to calculate amountIn of either long or short token for swapping for\n    * desired amountsOut of long or short token\n    * @notice We utilise GMX's getSwapAmountOut() with tokenOut being tokenIn, multiplying\n    * the amountsOut value by 1.0015x to account for fees and normal chainlink price feed differential\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param tokenOut TokenIn address\n    * @param amountsOut Amount of tokenIn, expressed in tokenIn's decimals\n    * @return amountsOut Amount of tokenOut within LP (market) to be received, expressed in tokenOut's decimals\n  */\n  function getAmountsIn(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    address tokenOut,\n    uint256 amountsOut\n  ) public view returns (uint256) {\n    return getAmountsOut(\n      marketToken,\n      indexToken,\n      longToken,\n      shortToken,\n      tokenOut,\n      amountsOut\n    ) * (1e18 + 15e14) / SAFE_MULTIPLIER;\n  }\n\n  /**\n    * @notice Get LP (market) token info\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param pnlFactorType P&L Factory type in bytes32 hashed string\n    * @param maximize Min/max price boolean\n    * @return (marketTokenPrice, MarketPoolValueInfoProps MarketInfo)\n  */\n  function getMarketTokenInfo(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    bytes32 pnlFactorType,\n    bool maximize\n  ) public view returns (int256, ISyntheticReader.MarketPoolValueInfoProps memory) {\n    if (address(marketToken) == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(indexToken) == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(longToken) == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(shortToken) == address(0)) revert Errors.ZeroAddressNotAllowed();\n\n    ISyntheticReader.MarketProps memory _market;\n    _market.marketToken = marketToken;\n    _market.indexToken = indexToken;\n    _market.longToken = longToken;\n    _market.shortToken = shortToken;\n\n    ISyntheticReader.PriceProps memory _indexTokenPrice;\n    _indexTokenPrice.min = _getTokenPriceMinMaxFormatted(indexToken);\n    _indexTokenPrice.max = _getTokenPriceMinMaxFormatted(indexToken);\n\n    ISyntheticReader.PriceProps memory _longTokenPrice;\n    _longTokenPrice.min = _getTokenPriceMinMaxFormatted(longToken);\n    _longTokenPrice.max = _getTokenPriceMinMaxFormatted(longToken);\n\n    ISyntheticReader.PriceProps memory _shortTokenPrice;\n    _shortTokenPrice.min = _getTokenPriceMinMaxFormatted(shortToken);\n    _shortTokenPrice.max = _getTokenPriceMinMaxFormatted(shortToken);\n\n    return syntheticReader.getMarketTokenPrice(\n      dataStore,\n      _market,\n      _indexTokenPrice,\n      _longTokenPrice,\n      _shortTokenPrice,\n      pnlFactorType,\n      maximize\n    );\n  }\n\n  /**\n    * @notice Get LP (market) token reserves\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @return (reserveA, reserveB) Reserve amount of longToken and shortToken respectively\n  */\n  function getLpTokenReserves(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken\n  ) public view returns (uint256, uint256) {\n    // _pnlFactorType value does not matter in getting token reserves\n    bytes32 _pnlFactorType = keccak256(abi.encode(\"MAX_PNL_FACTOR_FOR_DEPOSITS\"));\n\n    // _maximize value does not matter in getting token reserves\n    bool _maximize = false;\n\n    (, ISyntheticReader.MarketPoolValueInfoProps memory _marketInfo) = getMarketTokenInfo(\n      marketToken,\n      indexToken,\n      longToken,\n      shortToken,\n      _pnlFactorType,\n      _maximize\n    );\n\n    return (\n      _marketInfo.longTokenAmount,\n      _marketInfo.shortTokenAmount\n    );\n  }\n\n  /**\n    * @notice Get LP (market) token reserves\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param isDeposit Boolean for deposit or withdrawal\n    * @param maximize Boolean for minimum or maximum price\n    * @return marketTokenPrice in 1e18\n  */\n  function getLpTokenValue(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    bool isDeposit,\n    bool maximize\n  ) public view returns (uint256) {\n    bytes32 _pnlFactorType;\n\n    if (isDeposit) {\n      _pnlFactorType = keccak256(abi.encode(\"MAX_PNL_FACTOR_FOR_DEPOSITS\"));\n    } else {\n      _pnlFactorType = keccak256(abi.encode(\"MAX_PNL_FACTOR_FOR_WITHDRAWALS\"));\n    }\n\n    (int256 _marketTokenPrice,) = getMarketTokenInfo(\n      marketToken,\n      indexToken,\n      longToken,\n      shortToken,\n      _pnlFactorType,\n      maximize\n    );\n\n    // If LP token value is negative, return 0\n    if (_marketTokenPrice < 0) {\n      return 0;\n    } else {\n      // Price returned in 1e30, we normalize it to 1e18\n      return uint256(_marketTokenPrice) / 1e12;\n    }\n  }\n\n\n  /**\n    * @notice Get token A and token B's LP token amount required for a given value\n    * @param givenValue Given value needed, expressed in 1e30\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param isDeposit Boolean for deposit or withdrawal\n    * @param maximize Boolean for minimum or maximum price\n    * @return lpTokenAmount Amount of LP tokens; expressed in 1e18\n  */\n  function getLpTokenAmount(\n    uint256 givenValue,\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    bool isDeposit,\n    bool maximize\n  ) public view returns (uint256) {\n    uint256 _lpTokenValue = getLpTokenValue(\n      marketToken,\n      indexToken,\n      longToken,\n      shortToken,\n      isDeposit,\n      maximize\n    );\n\n    return givenValue * SAFE_MULTIPLIER / _lpTokenValue;\n  }\n\n  /* ================== INTERNAL FUNCTIONS =================== */\n\n  /**\n    * @notice Get token price formatted for GMX mix/max decimals for 1e30 normalization\n    * @dev E.g. if token decimals is 18, to normalize to 1e30, we need to return 30-18 = 1e12\n    * consult() usually returns asset price in 8 decimals, so 30 - tokenDecimals - priceDecimals\n    * should format the decimals correctly for 1e30\n    * @param token Token address\n    * @return tokenPriceMinMaxFormatted\n  */\n  function _getTokenPriceMinMaxFormatted(address token) internal view returns (uint256) {\n    (int256 _price, uint8 _priceDecimals) = chainlinkOracle.consult(token);\n\n    return uint256(_price) * 10 ** (30 - IERC20Metadata(token).decimals() - _priceDecimals);\n  }\n}"
    },
    {
      "filename": "contracts/oracles/GMXOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { ISyntheticReader } from \"../interfaces/protocols/gmx/ISyntheticReader.sol\";\nimport { IChainlinkOracle } from \"../interfaces/oracles/IChainlinkOracle.sol\";\nimport { Errors } from \"../utils/Errors.sol\";\n\nimport { console } from \"forge-std/console.sol\";\n\ncontract GMXOracle {\n\n  /* ==================== STATE VARIABLES ==================== */\n\n  // GMX DataStore\n  address public immutable dataStore;\n  // GMX Synthetic Reader\n  ISyntheticReader public immutable syntheticReader;\n  // Chainlink oracle\n  IChainlinkOracle public immutable chainlinkOracle;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ====================== CONSTRUCTOR ====================== */\n\n  /**\n    * @param _DataStore Address of GMX DataStore\n    * @param _syntheticReader Address of GMX Synthetic Reader\n    * @param _chainlinkOracle Address of Chainlink oracle\n  */\n  constructor(\n    address _DataStore,\n    ISyntheticReader _syntheticReader,\n    IChainlinkOracle _chainlinkOracle\n  ) {\n    if (_DataStore == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(_syntheticReader) == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(_chainlinkOracle) == address(0)) revert Errors.ZeroAddressNotAllowed();\n\n    dataStore = _DataStore;\n    syntheticReader = _syntheticReader;\n    chainlinkOracle = _chainlinkOracle;\n  }\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice Get amountsOut of either the long or short token based on the amountsIn\n    * of either long or short token in the market\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param tokenIn TokenIn address\n    * @param amountIn Amount of tokenIn, expressed in tokenIn's decimals\n    * @return amountsOut Amount of tokenOut within LP (market) to be received, expressed in tokenOut's decimals\n  */\n  function getAmountsOut(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    address tokenIn,\n    uint256 amountIn\n  ) public view returns (uint256) {\n    ISyntheticReader.MarketProps memory _market;\n    _market.marketToken = marketToken;\n    _market.indexToken = indexToken;\n    _market.longToken = longToken;\n    _market.shortToken = shortToken;\n\n    ISyntheticReader.PriceProps memory _indexTokenPrice;\n    _indexTokenPrice.min = _getTokenPriceMinMaxFormatted(indexToken);\n    _indexTokenPrice.max = _getTokenPriceMinMaxFormatted(indexToken);\n\n    ISyntheticReader.PriceProps memory _longTokenPrice;\n    _longTokenPrice.min = _getTokenPriceMinMaxFormatted(longToken);\n    _longTokenPrice.max = _getTokenPriceMinMaxFormatted(longToken);\n\n    ISyntheticReader.PriceProps memory _shortTokenPrice;\n    _shortTokenPrice.min = _getTokenPriceMinMaxFormatted(shortToken);\n    _shortTokenPrice.max = _getTokenPriceMinMaxFormatted(shortToken);\n\n    ISyntheticReader.MarketPrices memory _prices;\n    _prices.indexTokenPrice = _indexTokenPrice;\n    _prices.longTokenPrice = _longTokenPrice;\n    _prices.shortTokenPrice = _shortTokenPrice;\n\n    address _uiFeeReceiver = address(0);\n\n    (uint256 _amountsOut,,) = syntheticReader.getSwapAmountOut(\n      dataStore,\n      _market,\n      _prices,\n      tokenIn,\n      amountIn,\n      _uiFeeReceiver\n    );\n\n    return _amountsOut;\n  }\n\n  /**\n    * @notice Helper function to calculate amountIn of either long or short token for swapping for\n    * desired amountsOut of long or short token\n    * @notice We utilise GMX's getSwapAmountOut() with tokenOut being tokenIn, multiplying\n    * the amountsOut value by 1.0015x to account for fees and normal chainlink price feed differential\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param tokenOut TokenIn address\n    * @param amountsOut Amount of tokenIn, expressed in tokenIn's decimals\n    * @return amountsOut Amount of tokenOut within LP (market) to be received, expressed in tokenOut's decimals\n  */\n  function getAmountsIn(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    address tokenOut,\n    uint256 amountsOut\n  ) public view returns (uint256) {\n    return getAmountsOut(\n      marketToken,\n      indexToken,\n      longToken,\n      shortToken,\n      tokenOut,\n      amountsOut\n    ) * (1e18 + 15e14) / SAFE_MULTIPLIER;\n  }\n\n  /**\n    * @notice Get LP (market) token info\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param pnlFactorType P&L Factory type in bytes32 hashed string\n    * @param maximize Min/max price boolean\n    * @return (marketTokenPrice, MarketPoolValueInfoProps MarketInfo)\n  */\n  function getMarketTokenInfo(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    bytes32 pnlFactorType,\n    bool maximize\n  ) public view returns (int256, ISyntheticReader.MarketPoolValueInfoProps memory) {\n    if (address(marketToken) == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(indexToken) == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(longToken) == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(shortToken) == address(0)) revert Errors.ZeroAddressNotAllowed();\n\n    ISyntheticReader.MarketProps memory _market;\n    _market.marketToken = marketToken;\n    _market.indexToken = indexToken;\n    _market.longToken = longToken;\n    _market.shortToken = shortToken;\n\n    ISyntheticReader.PriceProps memory _indexTokenPrice;\n    _indexTokenPrice.min = _getTokenPriceMinMaxFormatted(indexToken);\n    _indexTokenPrice.max = _getTokenPriceMinMaxFormatted(indexToken);\n\n    ISyntheticReader.PriceProps memory _longTokenPrice;\n    _longTokenPrice.min = _getTokenPriceMinMaxFormatted(longToken);\n    _longTokenPrice.max = _getTokenPriceMinMaxFormatted(longToken);\n\n    ISyntheticReader.PriceProps memory _shortTokenPrice;\n    _shortTokenPrice.min = _getTokenPriceMinMaxFormatted(shortToken);\n    _shortTokenPrice.max = _getTokenPriceMinMaxFormatted(shortToken);\n\n    return syntheticReader.getMarketTokenPrice(\n      dataStore,\n      _market,\n      _indexTokenPrice,\n      _longTokenPrice,\n      _shortTokenPrice,\n      pnlFactorType,\n      maximize\n    );\n  }\n\n  /**\n    * @notice Get LP (market) token reserves\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @return (reserveA, reserveB) Reserve amount of longToken and shortToken respectively\n  */\n  function getLpTokenReserves(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken\n  ) public view returns (uint256, uint256) {\n    // _pnlFactorType value does not matter in getting token reserves\n    bytes32 _pnlFactorType = keccak256(abi.encode(\"MAX_PNL_FACTOR_FOR_DEPOSITS\"));\n\n    // _maximize value does not matter in getting token reserves\n    bool _maximize = false;\n\n    (, ISyntheticReader.MarketPoolValueInfoProps memory _marketInfo) = getMarketTokenInfo(\n      marketToken,\n      indexToken,\n      longToken,\n      shortToken,\n      _pnlFactorType,\n      _maximize\n    );\n\n    return (\n      _marketInfo.longTokenAmount,\n      _marketInfo.shortTokenAmount\n    );\n  }\n\n  /**\n    * @notice Get LP (market) token reserves\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param isDeposit Boolean for deposit or withdrawal\n    * @param maximize Boolean for minimum or maximum price\n    * @return marketTokenPrice in 1e18\n  */\n  function getLpTokenValue(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    bool isDeposit,\n    bool maximize\n  ) public view returns (uint256) {\n    bytes32 _pnlFactorType;\n\n    if (isDeposit) {\n      _pnlFactorType = keccak256(abi.encode(\"MAX_PNL_FACTOR_FOR_DEPOSITS\"));\n    } else {\n      _pnlFactorType = keccak256(abi.encode(\"MAX_PNL_FACTOR_FOR_WITHDRAWALS\"));\n    }\n\n    (int256 _marketTokenPrice,) = getMarketTokenInfo(\n      marketToken,\n      indexToken,\n      longToken,\n      shortToken,\n      _pnlFactorType,\n      maximize\n    );\n\n    // If LP token value is negative, return 0\n    if (_marketTokenPrice < 0) {\n      return 0;\n    } else {\n      // Price returned in 1e30, we normalize it to 1e18\n      return uint256(_marketTokenPrice) / 1e12;\n    }\n  }\n\n\n  /**\n    * @notice Get token A and token B's LP token amount required for a given value\n    * @param givenValue Given value needed, expressed in 1e30\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param isDeposit Boolean for deposit or withdrawal\n    * @param maximize Boolean for minimum or maximum price\n    * @return lpTokenAmount Amount of LP tokens; expressed in 1e18\n  */\n  function getLpTokenAmount(\n    uint256 givenValue,\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    bool isDeposit,\n    bool maximize\n  ) public view returns (uint256) {\n    uint256 _lpTokenValue = getLpTokenValue(\n      marketToken,\n      indexToken,\n      longToken,\n      shortToken,\n      isDeposit,\n      maximize\n    );\n\n    return givenValue * SAFE_MULTIPLIER / _lpTokenValue;\n  }\n\n  /* ================== INTERNAL FUNCTIONS =================== */\n\n  /**\n    * @notice Get token price formatted for GMX mix/max decimals for 1e30 normalization\n    * @dev E.g. if token decimals is 18, to normalize to 1e30, we need to return 30-18 = 1e12\n    * consult() usually returns asset price in 8 decimals, so 30 - tokenDecimals - priceDecimals\n    * should format the decimals correctly for 1e30\n    * @param token Token address\n    * @return tokenPriceMinMaxFormatted\n  */\n  function _getTokenPriceMinMaxFormatted(address token) internal view returns (uint256) {\n    (int256 _price, uint8 _priceDecimals) = chainlinkOracle.consult(token);\n\n    return uint256(_price) * 10 ** (30 - IERC20Metadata(token).decimals() - _priceDecimals);\n  }\n}"
    },
    {
      "filename": "contracts/oracles/GMXOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { ISyntheticReader } from \"../interfaces/protocols/gmx/ISyntheticReader.sol\";\nimport { IChainlinkOracle } from \"../interfaces/oracles/IChainlinkOracle.sol\";\nimport { Errors } from \"../utils/Errors.sol\";"
    }
  ]
}