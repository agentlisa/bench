{
  "Title": "[N-05] Use a modifier for access control",
  "Content": "\nConsider using a modifier to implement access control instead of inlining the condition/requirement in the function's body.\n\nhttps://github.com/code-423n4/2023-03-wenwin/blob/main/src/RNSourceController.sol#L46-L49\n\n```solidity\nfunction onRandomNumberFulfilled(uint256 randomNumber) external override {\n    if (msg.sender != address(source)) {\n        revert RandomNumberFulfillmentUnauthorized();\n    }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-03-wenwin",
  "Code": [
    {
      "filename": "src/RNSourceController.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// slither-disable-next-line solc-version\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport \"src/interfaces/IRNSource.sol\";\nimport \"src/interfaces/IRNSourceController.sol\";\n\n/// @dev A contract that controls the list of random number sources and dispatches random number requests to them.\nabstract contract RNSourceController is Ownable2Step, IRNSourceController {\n    IRNSource public override source;\n\n    uint256 public override failedSequentialAttempts;\n    uint256 public override maxFailedAttemptsReachedAt;\n    uint256 public override lastRequestTimestamp;\n    bool public override lastRequestFulfilled = true;\n    uint256 public immutable override maxFailedAttempts;\n    uint256 public immutable override maxRequestDelay;\n    uint256 private constant MAX_MAX_FAILED_ATTEMPTS = 10;\n    uint256 private constant MAX_REQUEST_DELAY = 5 hours;\n\n    /// @dev Constructs a new random number source controller.\n    /// @param _maxFailedAttempts The maximum number of sequential failed attempts to use a random number source before\n    /// it is removed from the list of sources\n    /// @param _maxRequestDelay The maximum delay between random number request and its fulfillment\n    constructor(uint256 _maxFailedAttempts, uint256 _maxRequestDelay) {\n        if (_maxFailedAttempts > MAX_MAX_FAILED_ATTEMPTS) {\n            revert MaxFailedAttemptsTooBig();\n        }\n        if (_maxRequestDelay > MAX_REQUEST_DELAY) {\n            revert MaxRequestDelayTooBig();\n        }\n        maxFailedAttempts = _maxFailedAttempts;\n        maxRequestDelay = _maxRequestDelay;\n    }\n\n    /// @dev Requests a random number from the current random number source.\n    function requestRandomNumber() internal {\n        if (!lastRequestFulfilled) {\n            revert PreviousRequestNotFulfilled();\n        }\n\n        requestRandomNumberFromSource();\n    }\n\n    function onRandomNumberFulfilled(uint256 randomNumber) external override {\n        if (msg.sender != address(source)) {\n            revert RandomNumberFulfillmentUnauthorized();\n        }\n\n        lastRequestFulfilled = true;\n        failedSequentialAttempts = 0;\n        maxFailedAttemptsReachedAt = 0;\n\n        receiveRandomNumber(randomNumber);\n    }\n\n    function receiveRandomNumber(uint256 randomNumber) internal virtual;\n\n    function retry() external override {\n        if (lastRequestFulfilled) {\n            revert CannotRetrySuccessfulRequest();\n        }\n        if (block.timestamp - lastRequestTimestamp <= maxRequestDelay) {\n            revert CurrentRequestStillActive();\n        }\n\n        uint256 failedAttempts = ++failedSequentialAttempts;\n        if (failedAttempts == maxFailedAttempts) {\n            maxFailedAttemptsReachedAt = block.timestamp;\n        }\n\n        emit Retry(source, failedSequentialAttempts);\n        requestRandomNumberFromSource();\n    }\n\n    function initSource(IRNSource rnSource) external override onlyOwner {\n        if (address(rnSource) == address(0)) {\n            revert RNSourceZeroAddress();\n        }\n        if (address(source) != address(0)) {\n            revert AlreadyInitialized();\n        }\n\n        source = rnSource;\n        emit SourceSet(rnSource);\n    }\n\n    function swapSource(IRNSource newSource) external override onlyOwner {\n        if (address(newSource) == address(0)) {\n            revert RNSourceZeroAddress();\n        }\n        bool notEnoughRetryInvocations = failedSequentialAttempts < maxFailedAttempts;\n        bool notEnoughTimeReachingMaxFailedAttempts = block.timestamp < maxFailedAttemptsReachedAt + maxRequestDelay;\n        if (notEnoughRetryInvocations || notEnoughTimeReachingMaxFailedAttempts) {\n            revert NotEnoughFailedAttempts();\n        }\n        source = newSource;\n        failedSequentialAttempts = 0;\n        maxFailedAttemptsReachedAt = 0;\n\n        emit SourceSet(newSource);\n        requestRandomNumberFromSource();\n    }\n\n    function requestRandomNumberFromSource() private {\n        lastRequestTimestamp = block.timestamp;\n        lastRequestFulfilled = false;\n\n        // slither-disable-start uninitialized-local\n        // See Slither issue: https://github.com/crytic/slither/issues/511\n        try source.requestRandomNumber() {\n            emit SuccessfulRNRequest(source);\n        } catch Error(string memory reason) {\n            emit FailedRNRequest(source, bytes(reason));\n        } catch (bytes memory reason) {\n            emit FailedRNRequest(source, reason);\n        }\n        // slither-disable-end uninitialized-local\n    }\n}"
    }
  ]
}