{
  "Title": "[L-04] `claimableUserDelayedWithdrawals` sometimes returns unclaimable `DelayedWithdrawals`, so users will see incorrect data",
  "Content": "\n### Proof of Concept\nThe `canClaimDelayedWithdrawal` function will return false for a withdrawal, which the block duration has not passed. The same restriction will be checked whenever an actual withdrawal is triggered, but the `claimableUserDelayedWithdrawals` function does not take into account block duration validation.\n\n```solidity\n    function claimableUserDelayedWithdrawals(address user) external view returns (DelayedWithdrawal[] memory) {\n        uint256 delayedWithdrawalsCompleted = _userWithdrawals[user].delayedWithdrawalsCompleted;\n        uint256 delayedWithdrawalsLength = _userWithdrawals[user].delayedWithdrawals.length;\n        uint256 claimableDelayedWithdrawalsLength = delayedWithdrawalsLength - delayedWithdrawalsCompleted;\n        DelayedWithdrawal[] memory claimableDelayedWithdrawals = new DelayedWithdrawal[](claimableDelayedWithdrawalsLength);\n        for (uint256 i = 0; i < claimableDelayedWithdrawalsLength; i++) {\n            claimableDelayedWithdrawals[i] = _userWithdrawals[user].delayedWithdrawals[delayedWithdrawalsCompleted + i];\n        }\n        return claimableDelayedWithdrawals;\n    }\n...\n    function canClaimDelayedWithdrawal(address user, uint256 index) external view returns (bool) {\n        return ((index >= _userWithdrawals[user].delayedWithdrawalsCompleted) && (block.number >= _userWithdrawals[user].delayedWithdrawals[index].blockCreated + withdrawalDelayBlocks));\n    }\n```\n[src/contracts/pods/DelayedWithdrawalRouter.sol#L110](https://github.com/code-423n4/2023-04-eigenlayer/blob/398cc428541b91948f717482ec973583c9e76232/src/contracts/pods/DelayedWithdrawalRouter.sol#L110)\n\n### Recommended Mitigation Steps\n\n```solidity\n    function claimableUserDelayedWithdrawals(address user) external view returns (DelayedWithdrawal[] memory) {\n        uint256 delayedWithdrawalsCompleted = _userWithdrawals[user].delayedWithdrawalsCompleted;\n        uint256 delayedWithdrawalsLength = _userWithdrawals[user].delayedWithdrawals.length;\n        uint256 claimableDelayedWithdrawalsLength = delayedWithdrawalsLength - delayedWithdrawalsCompleted;\n        DelayedWithdrawal[] memory claimableDelayedWithdrawals;\n        for (uint256 i = 0; i < claimableDelayedWithdrawalsLength; i++) {\n            if (block.number < _userWithdrawals[user].delayedWithdrawals[delayedWithdrawalsCompleted + i].blockCreated + withdrawalDelayBlocks) {\n                break;\n            }\n            claimableDelayedWithdrawals.push(_userWithdrawals[user].delayedWithdrawals[delayedWithdrawalsCompleted + i]);\n        }\n        return claimableDelayedWithdrawals;\n    }\n\n```\n\n**[Alex the Entreprenerd (judge) decreased severity to QA](https://github.com/code-423n4/2023-04-eigenlayer-findings/issues/37#issuecomment-1570757603)**\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-04-eigenlayer",
  "Code": [
    {
      "filename": "src/contracts/pods/DelayedWithdrawalRouter.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.12;\n\nimport \"@openzeppelin-upgrades/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin-upgrades/contracts/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin-upgrades/contracts/security/ReentrancyGuardUpgradeable.sol\";\nimport \"../interfaces/IEigenPodManager.sol\";\nimport \"../interfaces/IDelayedWithdrawalRouter.sol\";\nimport \"../permissions/Pausable.sol\";\n\ncontract DelayedWithdrawalRouter is Initializable, OwnableUpgradeable, ReentrancyGuardUpgradeable, Pausable, IDelayedWithdrawalRouter {\n    /// @notice Emitted when the `withdrawalDelayBlocks` variable is modified from `previousValue` to `newValue`.\n    event WithdrawalDelayBlocksSet(uint256 previousValue, uint256 newValue);\n\n    // index for flag that pauses withdrawals (i.e. 'delayedWithdrawal claims') when set\n    uint8 internal constant PAUSED_DELAYED_WITHDRAWAL_CLAIMS = 0;\n\n    /**\n     * @notice Delay enforced by this contract for completing any delayedWithdrawal. Measured in blocks, and adjustable by this contract's owner,\n     * up to a maximum of `MAX_WITHDRAWAL_DELAY_BLOCKS`. Minimum value is 0 (i.e. no delay enforced).\n     */\n    uint256 public withdrawalDelayBlocks;\n    // the number of 12-second blocks in one week (60 * 60 * 24 * 7 / 12 = 50,400)\n    uint256 public constant MAX_WITHDRAWAL_DELAY_BLOCKS = 50400;\n\n    /// @notice The EigenPodManager contract of EigenLayer.\n    IEigenPodManager public immutable eigenPodManager;\n\n    /// @notice Mapping: user => struct storing all delayedWithdrawal info. Marked as internal with an external getter function named `userWithdrawals`\n    mapping(address => UserDelayedWithdrawals) internal _userWithdrawals;\n\n    /// @notice event for delayedWithdrawal creation\n    event DelayedWithdrawalCreated(address podOwner, address recipient, uint256 amount, uint256 index);\n\n    /// @notice event for the claiming of delayedWithdrawals\n    event DelayedWithdrawalsClaimed(address recipient, uint256 amountClaimed, uint256 delayedWithdrawalsCompleted);\n\n    /// @notice Modifier used to permission a function to only be called by the EigenPod of the specified `podOwner`\n    modifier onlyEigenPod(address podOwner) {\n        require(address(eigenPodManager.getPod(podOwner)) == msg.sender, \"DelayedWithdrawalRouter.onlyEigenPod: not podOwner's EigenPod\");\n        _;\n    }\n\n    constructor(IEigenPodManager _eigenPodManager) {\n        require(address(_eigenPodManager) != address(0), \"DelayedWithdrawalRouter.constructor: _eigenPodManager cannot be zero address\");\n        eigenPodManager = _eigenPodManager;\n    }\n\n    function initialize(address initOwner, IPauserRegistry _pauserRegistry, uint256 initPausedStatus, uint256 _withdrawalDelayBlocks) external initializer {\n        _transferOwnership(initOwner);\n        _initializePauser(_pauserRegistry, initPausedStatus);\n        _setWithdrawalDelayBlocks(_withdrawalDelayBlocks);\n    }\n\n    /** \n     * @notice Creates a delayed withdrawal for `msg.value` to the `recipient`.\n     * @dev Only callable by the `podOwner`'s EigenPod contract.\n     */\n    function createDelayedWithdrawal(address podOwner, address recipient) external payable onlyEigenPod(podOwner) {\n        uint224 withdrawalAmount = uint224(msg.value);\n        if (withdrawalAmount != 0) {\n            DelayedWithdrawal memory delayedWithdrawal = DelayedWithdrawal({\n                amount: withdrawalAmount,\n                blockCreated: uint32(block.number)\n            });\n            _userWithdrawals[recipient].delayedWithdrawals.push(delayedWithdrawal);\n            emit DelayedWithdrawalCreated(podOwner, recipient, withdrawalAmount, _userWithdrawals[recipient].delayedWithdrawals.length - 1);\n        }\n    }\n\n    /**\n     * @notice Called in order to withdraw delayed withdrawals made to the `recipient` that have passed the `withdrawalDelayBlocks` period.\n     * @param recipient The address to claim delayedWithdrawals for.\n     * @param maxNumberOfDelayedWithdrawalsToClaim Used to limit the maximum number of delayedWithdrawals to loop through claiming.\n     * @dev \n     *      WARNING: Note that the caller of this function cannot control where the funds are sent, but they can control when the \n     *              funds are sent once the withdrawal becomes claimable.\n     */\n    function claimDelayedWithdrawals(address recipient, uint256 maxNumberOfDelayedWithdrawalsToClaim)\n        external\n        nonReentrant\n        onlyWhenNotPaused(PAUSED_DELAYED_WITHDRAWAL_CLAIMS)\n    {\n        _claimDelayedWithdrawals(recipient, maxNumberOfDelayedWithdrawalsToClaim);\n    }\n\n    /**\n     * @notice Called in order to withdraw delayed withdrawals made to the caller that have passed the `withdrawalDelayBlocks` period.\n     * @param maxNumberOfDelayedWithdrawalsToClaim Used to limit the maximum number of delayedWithdrawals to loop through claiming.\n     */\n    function claimDelayedWithdrawals(uint256 maxNumberOfDelayedWithdrawalsToClaim)\n        external\n        nonReentrant\n        onlyWhenNotPaused(PAUSED_DELAYED_WITHDRAWAL_CLAIMS)\n    {\n        _claimDelayedWithdrawals(msg.sender, maxNumberOfDelayedWithdrawalsToClaim);\n    }\n\n    /// @notice Owner-only function for modifying the value of the `withdrawalDelayBlocks` variable.\n    function setWithdrawalDelayBlocks(uint256 newValue) external onlyOwner {\n        _setWithdrawalDelayBlocks(newValue);\n    }\n\n    /// @notice Getter function for the mapping `_userWithdrawals`\n    function userWithdrawals(address user) external view returns (UserDelayedWithdrawals memory) {\n        return _userWithdrawals[user];\n    }\n\n    /// @notice Getter function to get all delayedWithdrawals that are currently claimable by the `user`\n    function claimableUserDelayedWithdrawals(address user) external view returns (DelayedWithdrawal[] memory) {\n        uint256 delayedWithdrawalsCompleted = _userWithdrawals[user].delayedWithdrawalsCompleted;\n        uint256 delayedWithdrawalsLength = _userWithdrawals[user].delayedWithdrawals.length;\n        uint256 claimableDelayedWithdrawalsLength = delayedWithdrawalsLength - delayedWithdrawalsCompleted;\n        DelayedWithdrawal[] memory claimableDelayedWithdrawals = new DelayedWithdrawal[](claimableDelayedWithdrawalsLength);\n        for (uint256 i = 0; i < claimableDelayedWithdrawalsLength; i++) {\n            claimableDelayedWithdrawals[i] = _userWithdrawals[user].delayedWithdrawals[delayedWithdrawalsCompleted + i];\n        }\n        return claimableDelayedWithdrawals;\n    }\n\n    /// @notice Getter function for fetching the delayedWithdrawal at the `index`th entry from the `_userWithdrawals[user].delayedWithdrawals` array\n    function userDelayedWithdrawalByIndex(address user, uint256 index) external view returns (DelayedWithdrawal memory) {\n        return _userWithdrawals[user].delayedWithdrawals[index];\n    }\n\n    /// @notice Getter function for fetching the length of the delayedWithdrawals array of a specific user\n    function userWithdrawalsLength(address user) external view returns (uint256) {\n        return _userWithdrawals[user].delayedWithdrawals.length;\n    }\n\n    /// @notice Convenience function for checking whethere or not the delayedWithdrawal at the `index`th entry from the `_userWithdrawals[user].delayedWithdrawals` array is currently claimable\n    function canClaimDelayedWithdrawal(address user, uint256 index) external view returns (bool) {\n        return ((index >= _userWithdrawals[user].delayedWithdrawalsCompleted) && (block.number >= _userWithdrawals[user].delayedWithdrawals[index].blockCreated + withdrawalDelayBlocks));\n    }\n\n    /// @notice internal function used in both of the overloaded `claimDelayedWithdrawals` functions\n    function _claimDelayedWithdrawals(address recipient, uint256 maxNumberOfDelayedWithdrawalsToClaim) internal {\n        uint256 amountToSend = 0;\n        uint256 delayedWithdrawalsCompletedBefore = _userWithdrawals[recipient].delayedWithdrawalsCompleted;\n        uint256 _userWithdrawalsLength = _userWithdrawals[recipient].delayedWithdrawals.length;\n        uint256 i = 0;\n        while (i < maxNumberOfDelayedWithdrawalsToClaim && (delayedWithdrawalsCompletedBefore + i) < _userWithdrawalsLength) {\n            // copy delayedWithdrawal from storage to memory\n            DelayedWithdrawal memory delayedWithdrawal = _userWithdrawals[recipient].delayedWithdrawals[delayedWithdrawalsCompletedBefore + i];\n            // check if delayedWithdrawal can be claimed. break the loop as soon as a delayedWithdrawal cannot be claimed\n            if (block.number < delayedWithdrawal.blockCreated + withdrawalDelayBlocks) {\n                break;\n            }\n            // otherwise, the delayedWithdrawal can be claimed, in which case we increase the amountToSend and increment i\n            amountToSend += delayedWithdrawal.amount;\n            // increment i to account for the delayedWithdrawal being claimed\n            unchecked {\n                ++i;\n            }\n        }\n        // mark the i delayedWithdrawals as claimed\n        _userWithdrawals[recipient].delayedWithdrawalsCompleted = delayedWithdrawalsCompletedBefore + i;\n        // actually send the ETH\n        if (amountToSend != 0) {\n            AddressUpgradeable.sendValue(payable(recipient), amountToSend);\n        }\n        emit DelayedWithdrawalsClaimed(recipient, amountToSend, delayedWithdrawalsCompletedBefore + i);\n    }\n\n    /// @notice internal function for changing the value of `withdrawalDelayBlocks`. Also performs sanity check and emits an event.\n    function _setWithdrawalDelayBlocks(uint256 newValue) internal {\n        require(newValue <= MAX_WITHDRAWAL_DELAY_BLOCKS, \"DelayedWithdrawalRouter._setWithdrawalDelayBlocks: newValue too large\");\n        emit WithdrawalDelayBlocksSet(withdrawalDelayBlocks, newValue);\n        withdrawalDelayBlocks = newValue;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n}"
    }
  ]
}