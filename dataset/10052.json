{
  "Title": "[H-07] SavingsAccount withdrawAll and switchStrategy can freeze user funds by ignoring possible strategy liquidity issues",
  "Content": "_Submitted by hyh, also found by cmichel_\n\n### Impact\n\nFull withdrawal and moving funds between strategies can lead to wrong accounting if the corresponding market has tight liquidity, which can be the case at least for `AaveYield`. That is, as the whole amount is required to be moved at once from Aave, both `withdrawAll` and `switchStrategy` will incorrectly account for partial withdrawal as if it was full whenever the corresponding underlying yield pool had liquidity issues.\n\n`withdrawAll` will delete user entry, locking the user funds in the strategy: user will get partial withdrawal and have the corresponding accounting entry removed, while the remaining actual funds will be frozen within the system.\n\n`switchStrategy` will subtract full number of shares for the `_amount` requested from the old strategy, while adding lesser partial number of shares for `_tokensReceived` to the new one with the same effect of freezing user's funds within the system.\n\n#### Proof of Concept\n\nSavingsAccount.withdrawAll\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccount.sol#L286>\n\nSavingsAccount.switchStrategy:\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccount.sol#L152>\n\nWhen full withdrawal or strategy switch is performed it is one withdraw via `unlockTokens` without checking the amount received.\n\nIn the same time the withdraw can fail for example for the strategy switch if old strategy is having liquidity issues at the moment, i.e. Aave market is currently have utilization rate too high to withdraw the amount requested given current size of the lending pool.\n\nAave `unlockTokens` return is correctly not matched with amount requested:\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/yield/AaveYield.sol#L217>\n\nBut, for example, `withdrawAll` ignores the fact that some funds can remain in the strategy and deletes the use entry after one withdraw attempt:\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccount.sol#L294>\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccount.sol#L312>\n\n`switchStrategy` removes the old entry completely:\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccount.sol#L181>\n\n#### Recommended Mitigation Steps\n\nFor both `withdrawAll` and `switchStrategy` the immediate fix is to account for tokens received in both cases, which are `_amount` after `unlockTokens` for `withdrawAll` and `_tokensReceived` for `switchStrategy`.\n\nMore general handling of the liquidity issues ideally to be addressed architecturally, given the potential issues with liquidity availability any strategy withdrawals can be done as follows:\n\n1.  Withdraw what is possible on demand, leave the amount due as is, i.e. do not commit to completing the action in one go and notify the user the action was partial (return actual amount)\n2.  Save to query and repeat for the remainder funds on the next similar action (this can be separate flag triggered mode)\n\n**[ritik99 (Sublime) disagreed with severity](https://github.com/code-423n4/2021-12-sublime-findings/issues/80#issuecomment-1000184590):**\n > The above issue requires making a few assumptions - (i) the underlying yield protocol does not have sufficient reserves to facilitate the withdrawal of a single user, (ii) the user attempts to withdraw all their assets during such times of insufficient reserves.\n> \n> We agree that the above could be a possibility, but would be unlikely. The underlying yield protocols undergo an interest rate spike during high utilization ratios to bring reserves back to normal levels, and some revert if they cannot withdraw the necessary amount (for eg, [Compound](https://github.com/compound-finance/compound-protocol/blob/4a8648ec0364d24c4ecfc7d6cae254f55030d65f/contracts/CToken.sol#L679)). During live deployment, only those strategies that work expectedly would be onboarded, while others wouldn't (for eg, Aave as a strategy wouldn't be integrated until their [wrappers for aTokens](https://github.com/aave/protocol-v2/blob/feat-atoken-wrapper-liquidity-mining/contracts/protocol/tokenization/StaticATokenLM.sol) are ready for use). Hence we suggest reducing severity to (2) medium-risk\n> \n> also similar to #144 \n\n**[0xean (judge) commented](https://github.com/code-423n4/2021-12-sublime-findings/issues/80#issuecomment-1018054859):**\n > While I understand the argument regarding this being an unlikely scenario, I don't believe that is a sufficient reason to downgrade the issue give the impact to a user and the lost funds.  \n> \n> `\n> 2 â€” Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> `\n> \n> In this scenario - Assets are at a direct risk. \n\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2021-12-sublime-contest",
  "Code": [
    {
      "filename": "contracts/SavingsAccount/SavingsAccount.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '../interfaces/ISavingsAccount.sol';\nimport '../interfaces/IStrategyRegistry.sol';\nimport '../interfaces/IYield.sol';\n\n/**\n * @title Savings account contract with Methods related to savings account\n * @notice Implements the functions related to savings account\n * @author Sublime\n **/\ncontract SavingsAccount is ISavingsAccount, Initializable, OwnableUpgradeable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /**\n     * @notice address of the strategy registry used to whitelist strategies\n     */\n    address public strategyRegistry;\n\n    /**\n     * @notice address of the credit lines contract\n     */\n    address public creditLine;\n\n    /**\n     * @notice mapping from user to token to strategy to balance of shares\n     * @dev user -> token -> strategy (underlying address) -> amount (shares)\n     */\n    mapping(address => mapping(address => mapping(address => uint256))) public override balanceInShares;\n\n    /**\n     * @notice mapping from user to token to toAddress for approval to amount approved\n     * @dev user => token => to => amount\n     */\n    mapping(address => mapping(address => mapping(address => uint256))) public allowance;\n\n    /**\n     * @notice modifier to check if address is the credit line\n     * @param _caller address to check if credit line\n     */\n    modifier onlyCreditLine(address _caller) {\n        require(_caller == creditLine, 'Invalid caller');\n        _;\n    }\n\n    /**\n     * @dev initialize the contract\n     * @param _owner address of the owner of the savings account contract\n     * @param _strategyRegistry address of the strategy registry\n     * @param _creditLine address of the credit line contract\n     **/\n    function initialize(\n        address _owner,\n        address _strategyRegistry,\n        address _creditLine\n    ) external initializer {\n        __Ownable_init();\n        super.transferOwnership(_owner);\n\n        _updateCreditLine(_creditLine);\n        _updateStrategyRegistry(_strategyRegistry);\n    }\n\n    /**\n     * @notice used to update credit line contract address\n     * @dev only owner can update\n     * @param _creditLine updated address of credit lines\n     */\n    function updateCreditLine(address _creditLine) external onlyOwner {\n        _updateCreditLine(_creditLine);\n    }\n\n    function _updateCreditLine(address _creditLine) internal {\n        require(_creditLine != address(0), 'SavingsAccount::initialize zero address');\n        creditLine = _creditLine;\n        emit CreditLineUpdated(_creditLine);\n    }\n\n    /**\n     * @notice used to update strategy registry address\n     * @dev only owner can update\n     * @param _strategyRegistry updated address of strategy registry\n     */\n    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {\n        _updateStrategyRegistry(_strategyRegistry);\n    }\n\n    function _updateStrategyRegistry(address _strategyRegistry) internal {\n        require(_strategyRegistry != address(0), 'SavingsAccount::updateStrategyRegistry zero address');\n        strategyRegistry = _strategyRegistry;\n        emit StrategyRegistryUpdated(_strategyRegistry);\n    }\n\n    /**\n     * @notice used to deposit tokens into strategy via savings account\n     * @dev if token is address(0), then it is Ether\n     * @param _amount amount of tokens deposited\n     * @param _token address of token contract\n     * @param _strategy address of the strategy into which tokens are to be deposited\n     * @param _to address to deposit to\n     */\n    function deposit(\n        uint256 _amount,\n        address _token,\n        address _strategy,\n        address _to\n    ) external payable override nonReentrant returns (uint256) {\n        require(_to != address(0), 'SavingsAccount::deposit receiver address should not be zero address');\n        uint256 _sharesReceived = _deposit(_amount, _token, _strategy);\n        balanceInShares[_to][_token][_strategy] = balanceInShares[_to][_token][_strategy].add(_sharesReceived);\n        emit Deposited(_to, _sharesReceived, _token, _strategy);\n        return _sharesReceived;\n    }\n\n    function _deposit(\n        uint256 _amount,\n        address _token,\n        address _strategy\n    ) internal returns (uint256 _sharesReceived) {\n        require(_amount != 0, 'SavingsAccount::_deposit Amount must be greater than zero');\n        _sharesReceived = _depositToYield(_amount, _token, _strategy);\n    }\n\n    function _depositToYield(\n        uint256 _amount,\n        address _token,\n        address _strategy\n    ) internal returns (uint256 _sharesReceived) {\n        require(IStrategyRegistry(strategyRegistry).registry(_strategy), 'SavingsAccount::deposit strategy do not exist');\n        uint256 _ethValue;\n\n        if (_token == address(0)) {\n            _ethValue = _amount;\n            require(msg.value == _amount, 'SavingsAccount::deposit ETH sent must be equal to amount');\n        }\n        _sharesReceived = IYield(_strategy).lockTokens{value: _ethValue}(msg.sender, _token, _amount);\n    }\n\n    /**\n     * @dev Used to switch saving strategy of an _token\n     * @param _currentStrategy initial strategy of token\n     * @param _newStrategy new strategy to invest\n     * @param _token address of the token\n     * @param _amount amount of tokens to be reinvested\n     */\n    function switchStrategy(\n        uint256 _amount,\n        address _token,\n        address _currentStrategy,\n        address _newStrategy\n    ) external override nonReentrant {\n        require(_currentStrategy != _newStrategy, 'SavingsAccount::switchStrategy Same strategy');\n        require(IStrategyRegistry(strategyRegistry).registry(_newStrategy), 'SavingsAccount::_newStrategy do not exist');\n        require(_amount != 0, 'SavingsAccount::switchStrategy Amount must be greater than zero');\n\n        _amount = IYield(_currentStrategy).getSharesForTokens(_amount, _token);\n\n        balanceInShares[msg.sender][_token][_currentStrategy] = balanceInShares[msg.sender][_token][_currentStrategy].sub(\n            _amount,\n            'SavingsAccount::switchStrategy Insufficient balance'\n        );\n\n        uint256 _tokensReceived = IYield(_currentStrategy).unlockTokens(_token, _amount);\n\n        uint256 _ethValue;\n        if (_token != address(0)) {\n            IERC20(_token).safeApprove(_newStrategy, _tokensReceived);\n        } else {\n            _ethValue = _tokensReceived;\n        }\n        _amount = _tokensReceived;\n        \n        uint256 _sharesReceived = IYield(_newStrategy).lockTokens{value: _ethValue}(address(this), _token, _tokensReceived);\n\n        balanceInShares[msg.sender][_token][_newStrategy] = balanceInShares[msg.sender][_token][_newStrategy].add(_sharesReceived);\n        emit StrategySwitched(msg.sender, _token, _amount, _sharesReceived, _currentStrategy, _newStrategy);\n    }\n\n    /**\n     * @dev Used to withdraw token from Saving Account\n     * @param _to address to which token should be sent\n     * @param _amount amount of tokens to withdraw\n     * @param _token address of the token to be withdrawn\n     * @param _strategy strategy from where token has to withdrawn(ex:- compound,Aave etc)\n     * @param _withdrawShares boolean indicating to withdraw in liquidity share or underlying token\n     */\n    function withdraw(\n        uint256 _amount,\n        address _token,\n        address _strategy,\n        address payable _to,\n        bool _withdrawShares\n    ) external override nonReentrant returns (uint256) {\n        require(_amount != 0, 'SavingsAccount::withdraw Amount must be greater than zero');\n\n        _amount = IYield(_strategy).getSharesForTokens(_amount, _token);\n\n        balanceInShares[msg.sender][_token][_strategy] = balanceInShares[msg.sender][_token][_strategy].sub(\n            _amount,\n            'SavingsAccount::withdraw Insufficient amount'\n        );\n\n        (address _receivedToken, uint256 _amountReceived) = _withdraw(_amount, _token, _strategy, _to, _withdrawShares);\n\n        emit Withdrawn(msg.sender, _to, _amount, _token, _strategy, _withdrawShares);\n        return _amountReceived;\n    }\n\n    /**\n     * @dev Used to withdraw token from allowance of Saving Account\n     * @param _from address from which tokens will be withdrawn\n     * @param _to address to which token should be withdrawn\n     * @param _amount amount of tokens to withdraw\n     * @param _token address of the token to be withdrawn\n     * @param _strategy strategy from where token has to withdrawn(ex:- compound,Aave etc)\n     * @param _withdrawShares boolean indicating to withdraw in liquidity share or underlying token\n     */\n\n    function withdrawFrom(\n        uint256 _amount,\n        address _token,\n        address _strategy,\n        address _from,\n        address payable _to,\n        bool _withdrawShares\n    ) external override nonReentrant returns (uint256) {\n        require(_amount != 0, 'SavingsAccount::withdrawFrom Amount must be greater than zero');\n\n        allowance[_from][_token][msg.sender] = allowance[_from][_token][msg.sender].sub(\n            _amount,\n            'SavingsAccount::withdrawFrom allowance limit exceeding'\n        );\n\n        _amount = IYield(_strategy).getSharesForTokens(_amount, _token);\n\n        balanceInShares[_from][_token][_strategy] = balanceInShares[_from][_token][_strategy].sub(\n            _amount,\n            'SavingsAccount::withdrawFrom insufficient balance'\n        );\n        (address _receivedToken, uint256 _amountReceived) = _withdraw(_amount, _token, _strategy, _to, _withdrawShares);\n        emit Withdrawn(_from, msg.sender, _amount, _token, _strategy, _withdrawShares);\n        return _amountReceived;\n    }\n\n    function _withdraw(\n        uint256 _amount,\n        address _token,\n        address _strategy,\n        address payable _to,\n        bool _withdrawShares\n    ) internal returns (address _tokenReceived, uint256 _amountReceived) {\n        if (_withdrawShares) {\n            _tokenReceived = IYield(_strategy).liquidityToken(_token);\n            require(_tokenReceived != address(0), 'Liquidity Tokens address cannot be address(0)');\n            _amountReceived = IYield(_strategy).unlockShares(_tokenReceived, _amount);\n        } else {\n            _tokenReceived = _token;\n            _amountReceived = IYield(_strategy).unlockTokens(_token, _amount);\n        }\n        _transfer(_amountReceived, _tokenReceived, _to);\n    }\n\n    function _transfer(\n        uint256 _amount,\n        address _token,\n        address payable _to\n    ) internal {\n        if (_token == address(0)) {\n            (bool _success, ) = _to.call{value: _amount}('');\n            require(_success, 'Transfer failed');\n        } else {\n            IERC20(_token).safeTransfer(_to, _amount);\n        }\n    }\n\n    /**\n     * @notice used to withdraw a token from all strategies\n     * @param _token address of token which is to be withdrawn\n     */\n    function withdrawAll(address _token) external override nonReentrant returns (uint256 _tokenReceived) {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n\n        for (uint256 i = 0; i < _strategyList.length; i++) {\n            if (balanceInShares[msg.sender][_token][_strategyList[i]] != 0 && _strategyList[i] != address(0)) {\n                uint256 _amount = balanceInShares[msg.sender][_token][_strategyList[i]];\n                _amount = IYield(_strategyList[i]).unlockTokens(_token, balanceInShares[msg.sender][_token][_strategyList[i]]);\n                _tokenReceived = _tokenReceived.add(_amount);\n                delete balanceInShares[msg.sender][_token][_strategyList[i]];\n            }\n        }\n\n        if (_tokenReceived == 0) return 0;\n\n        _transfer(_tokenReceived, _token, payable(msg.sender));\n\n        emit WithdrawnAll(msg.sender, _tokenReceived, _token);\n    }\n\n    function withdrawAll(address _token, address _strategy) external override nonReentrant returns (uint256 _tokenReceived) {\n        uint256 _sharesBalance = balanceInShares[msg.sender][_token][_strategy];\n\n        if(_sharesBalance == 0) return 0;\n\n        uint256 _amount = IYield(_strategy).unlockTokens(_token, _sharesBalance);\n\n        delete balanceInShares[msg.sender][_token][_strategy];\n\n        _transfer(_amount, _token, payable(msg.sender));\n\n        emit Withdrawn(msg.sender, msg.sender, _amount, _token, _strategy, false);\n    }\n\n    /**\n     * @notice used to approve allowance to an address\n     * @dev this is prone to race condition, hence increaseAllowance is recommended\n     * @param _amount amount of tokens approved\n     * @param _token address of token approved\n     * @param _to address of the user approved to\n     */\n    function approve(\n        uint256 _amount,\n        address _token,\n        address _to\n    ) external override {\n        allowance[msg.sender][_token][_to] = _amount;\n\n        emit Approved(_token, msg.sender, _to, _amount);\n    }\n\n    /**\n     * @notice used to increase allowance to an address\n     * @param _amount amount of tokens allowance is increased by\n     * @param _token address of token approved\n     * @param _to address of the address approved to\n     */\n    function increaseAllowance(\n        uint256 _amount,\n        address _token,\n        address _to\n    ) external override {\n        uint256 _updatedAllowance = allowance[msg.sender][_token][_to].add(_amount);\n        allowance[msg.sender][_token][_to] = _updatedAllowance;\n\n        emit Approved(_token, msg.sender, _to, _updatedAllowance);\n    }\n\n    /**\n     * @notice used to decrease allowance to an address\n     * @param _amount amount of tokens allowance is decreased by\n     * @param _token address of token approved\n     * @param _to address of the user approved to\n     */\n    function decreaseAllowance(\n        uint256 _amount,\n        address _token,\n        address _to\n    ) external override {\n        uint256 _updatedAllowance = allowance[msg.sender][_token][_to].sub(_amount);\n        allowance[msg.sender][_token][_to] = _updatedAllowance;\n\n        emit Approved(_token, msg.sender, _to, _updatedAllowance);\n    }\n\n    /**\n     * @notice used by credit lines to replenish the allowance once the credit line pricinpal is repaid\n     * @param _amount amount of tokens allowance is increased by\n     * @param _token address of token approved\n     * @param _from address of the lender of the credit line which is being replenished\n     */\n    function increaseAllowanceToCreditLine(\n        uint256 _amount,\n        address _token,\n        address _from\n    ) external override onlyCreditLine(msg.sender) {\n        allowance[_from][_token][msg.sender] = allowance[_from][_token][msg.sender].add(_amount);\n\n        emit CreditLineAllowanceRefreshed(_token, _from, msg.sender, _amount);\n    }\n\n    /**\n     * @notice used to transfer tokens\n     * @param _amount amount of tokens transferred\n     * @param _token address of token transferred\n     * @param _strategy address of the strategy from which tokens are transferred\n     * @param _to address of the user tokens are transferred to\n     */\n    function transfer(\n        uint256 _amount,\n        address _token,\n        address _strategy,\n        address _to\n    ) external override returns (uint256) {\n        require(_amount != 0, 'SavingsAccount::transfer zero amount');\n\n        if (_strategy != address(0)) {\n            _amount = IYield(_strategy).getSharesForTokens(_amount, _token);\n        }\n\n        balanceInShares[msg.sender][_token][_strategy] = balanceInShares[msg.sender][_token][_strategy].sub(\n            _amount,\n            'SavingsAccount::transfer insufficient funds'\n        );\n\n        //update receiver's balance\n        balanceInShares[_to][_token][_strategy] = balanceInShares[_to][_token][_strategy].add(_amount);\n\n        emit Transfer(_token, _strategy, msg.sender, _to, _amount);\n\n        return _amount;\n    }\n\n    /**\n     * @notice used to transfer tokens from allowance by another address\n     * @param _amount amount of tokens transferred\n     * @param _token address of token transferred\n     * @param _strategy address of the strategy from which tokens are transferred\n     * @param _from address from whose allowance tokens are transferred\n     * @param _to address of the user tokens are transferred to\n     */\n    function transferFrom(\n        uint256 _amount,\n        address _token,\n        address _strategy,\n        address _from,\n        address _to\n    ) external override returns (uint256) {\n        require(_amount != 0, 'SavingsAccount::transferFrom zero amount');\n        //update allowance\n        allowance[_from][_token][msg.sender] = allowance[_from][_token][msg.sender].sub(\n            _amount,\n            'SavingsAccount::transferFrom allowance limit exceeding'\n        );\n\n        if (_strategy != address(0)) {\n            _amount = IYield(_strategy).getSharesForTokens(_amount, _token);\n        }\n\n        //reduce sender's balance\n        balanceInShares[_from][_token][_strategy] = balanceInShares[_from][_token][_strategy].sub(\n            _amount,\n            'SavingsAccount::transferFrom insufficient allowance'\n        );\n\n        //update receiver's balance\n        balanceInShares[_to][_token][_strategy] = (balanceInShares[_to][_token][_strategy]).add(_amount);\n\n        emit Transfer(_token, _strategy, _from, _to, _amount);\n\n        return _amount;\n    }\n\n    /**\n     * @notice used to query total tokens of a token with a user\n     * @param _user address of the user\n     * @param _token address of token\n     * @return _totalTokens total number of tokens of the token with the user\n     */\n    function getTotalTokens(address _user, address _token) external override returns (uint256 _totalTokens) {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n\n        for (uint256 i = 0; i < _strategyList.length; i++) {\n            uint256 _liquidityShares = balanceInShares[_user][_token][_strategyList[i]];\n\n            if (_liquidityShares != 0) {\n                uint256 _tokenInStrategy = _liquidityShares;\n                if (_strategyList[i] != address(0)) {\n                    _tokenInStrategy = IYield(_strategyList[i]).getTokensForShares(_liquidityShares, _token);\n                }\n\n                _totalTokens = _totalTokens.add(_tokenInStrategy);\n            }\n        }\n    }\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/SavingsAccount/SavingsAccount.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '../interfaces/ISavingsAccount.sol';\nimport '../interfaces/IStrategyRegistry.sol';\nimport '../interfaces/IYield.sol';\n\n/**\n * @title Savings account contract with Methods related to savings account\n * @notice Implements the functions related to savings account\n * @author Sublime\n **/\ncontract SavingsAccount is ISavingsAccount, Initializable, OwnableUpgradeable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /**\n     * @notice address of the strategy registry used to whitelist strategies\n     */\n    address public strategyRegistry;\n\n    /**\n     * @notice address of the credit lines contract\n     */\n    address public creditLine;\n\n    /**\n     * @notice mapping from user to token to strategy to balance of shares\n     * @dev user -> token -> strategy (underlying address) -> amount (shares)\n     */\n    mapping(address => mapping(address => mapping(address => uint256))) public override balanceInShares;\n\n    /**\n     * @notice mapping from user to token to toAddress for approval to amount approved\n     * @dev user => token => to => amount\n     */\n    mapping(address => mapping(address => mapping(address => uint256))) public allowance;\n\n    /**\n     * @notice modifier to check if address is the credit line\n     * @param _caller address to check if credit line\n     */\n    modifier onlyCreditLine(address _caller) {\n        require(_caller == creditLine, 'Invalid caller');\n        _;\n    }\n\n    /**\n     * @dev initialize the contract\n     * @param _owner address of the owner of the savings account contract\n     * @param _strategyRegistry address of the strategy registry\n     * @param _creditLine address of the credit line contract\n     **/\n    function initialize(\n        address _owner,\n        address _strategyRegistry,\n        address _creditLine\n    ) external initializer {\n        __Ownable_init();\n        super.transferOwnership(_owner);\n\n        _updateCreditLine(_creditLine);\n        _updateStrategyRegistry(_strategyRegistry);\n    }\n\n    /**\n     * @notice used to update credit line contract address\n     * @dev only owner can update\n     * @param _creditLine updated address of credit lines\n     */\n    function updateCreditLine(address _creditLine) external onlyOwner {\n        _updateCreditLine(_creditLine);\n    }\n\n    function _updateCreditLine(address _creditLine) internal {\n        require(_creditLine != address(0), 'SavingsAccount::initialize zero address');\n        creditLine = _creditLine;\n        emit CreditLineUpdated(_creditLine);\n    }\n\n    /**\n     * @notice used to update strategy registry address\n     * @dev only owner can update\n     * @param _strategyRegistry updated address of strategy registry\n     */\n    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {\n        _updateStrategyRegistry(_strategyRegistry);\n    }\n\n    function _updateStrategyRegistry(address _strategyRegistry) internal {\n        require(_strategyRegistry != address(0), 'SavingsAccount::updateStrategyRegistry zero address');\n        strategyRegistry = _strategyRegistry;\n        emit StrategyRegistryUpdated(_strategyRegistry);\n    }\n\n    /**\n     * @notice used to deposit tokens into strategy via savings account\n     * @dev if token is address(0), then it is Ether\n     * @param _amount amount of tokens deposited\n     * @param _token address of token contract\n     * @param _strategy address of the strategy into which tokens are to be deposited\n     * @param _to address to deposit to\n     */\n    function deposit(\n        uint256 _amount,\n        address _token,\n        address _strategy,\n        address _to\n    ) external payable override nonReentrant returns (uint256) {\n        require(_to != address(0), 'SavingsAccount::deposit receiver address should not be zero address');\n        uint256 _sharesReceived = _deposit(_amount, _token, _strategy);\n        balanceInShares[_to][_token][_strategy] = balanceInShares[_to][_token][_strategy].add(_sharesReceived);\n        emit Deposited(_to, _sharesReceived, _token, _strategy);\n        return _sharesReceived;\n    }\n\n    function _deposit(\n        uint256 _amount,\n        address _token,\n        address _strategy\n    ) internal returns (uint256 _sharesReceived) {\n        require(_amount != 0, 'SavingsAccount::_deposit Amount must be greater than zero');\n        _sharesReceived = _depositToYield(_amount, _token, _strategy);\n    }\n\n    function _depositToYield(\n        uint256 _amount,\n        address _token,\n        address _strategy\n    ) internal returns (uint256 _sharesReceived) {\n        require(IStrategyRegistry(strategyRegistry).registry(_strategy), 'SavingsAccount::deposit strategy do not exist');\n        uint256 _ethValue;\n\n        if (_token == address(0)) {\n            _ethValue = _amount;\n            require(msg.value == _amount, 'SavingsAccount::deposit ETH sent must be equal to amount');\n        }\n        _sharesReceived = IYield(_strategy).lockTokens{value: _ethValue}(msg.sender, _token, _amount);\n    }\n\n    /**\n     * @dev Used to switch saving strategy of an _token\n     * @param _currentStrategy initial strategy of token\n     * @param _newStrategy new strategy to invest\n     * @param _token address of the token\n     * @param _amount amount of tokens to be reinvested\n     */\n    function switchStrategy(\n        uint256 _amount,\n        address _token,\n        address _currentStrategy,\n        address _newStrategy\n    ) external override nonReentrant {\n        require(_currentStrategy != _newStrategy, 'SavingsAccount::switchStrategy Same strategy');\n        require(IStrategyRegistry(strategyRegistry).registry(_newStrategy), 'SavingsAccount::_newStrategy do not exist');\n        require(_amount != 0, 'SavingsAccount::switchStrategy Amount must be greater than zero');\n\n        _amount = IYield(_currentStrategy).getSharesForTokens(_amount, _token);\n\n        balanceInShares[msg.sender][_token][_currentStrategy] = balanceInShares[msg.sender][_token][_currentStrategy].sub(\n            _amount,\n            'SavingsAccount::switchStrategy Insufficient balance'\n        );\n\n        uint256 _tokensReceived = IYield(_currentStrategy).unlockTokens(_token, _amount);\n\n        uint256 _ethValue;\n        if (_token != address(0)) {\n            IERC20(_token).safeApprove(_newStrategy, _tokensReceived);\n        } else {\n            _ethValue = _tokensReceived;\n        }\n        _amount = _tokensReceived;\n        \n        uint256 _sharesReceived = IYield(_newStrategy).lockTokens{value: _ethValue}(address(this), _token, _tokensReceived);\n\n        balanceInShares[msg.sender][_token][_newStrategy] = balanceInShares[msg.sender][_token][_newStrategy].add(_sharesReceived);\n        emit StrategySwitched(msg.sender, _token, _amount, _sharesReceived, _currentStrategy, _newStrategy);\n    }\n\n    /**\n     * @dev Used to withdraw token from Saving Account\n     * @param _to address to which token should be sent\n     * @param _amount amount of tokens to withdraw\n     * @param _token address of the token to be withdrawn\n     * @param _strategy strategy from where token has to withdrawn(ex:- compound,Aave etc)\n     * @param _withdrawShares boolean indicating to withdraw in liquidity share or underlying token\n     */\n    function withdraw(\n        uint256 _amount,\n        address _token,\n        address _strategy,\n        address payable _to,\n        bool _withdrawShares\n    ) external override nonReentrant returns (uint256) {\n        require(_amount != 0, 'SavingsAccount::withdraw Amount must be greater than zero');\n\n        _amount = IYield(_strategy).getSharesForTokens(_amount, _token);\n\n        balanceInShares[msg.sender][_token][_strategy] = balanceInShares[msg.sender][_token][_strategy].sub(\n            _amount,\n            'SavingsAccount::withdraw Insufficient amount'\n        );\n\n        (address _receivedToken, uint256 _amountReceived) = _withdraw(_amount, _token, _strategy, _to, _withdrawShares);\n\n        emit Withdrawn(msg.sender, _to, _amount, _token, _strategy, _withdrawShares);\n        return _amountReceived;\n    }\n\n    /**\n     * @dev Used to withdraw token from allowance of Saving Account\n     * @param _from address from which tokens will be withdrawn\n     * @param _to address to which token should be withdrawn\n     * @param _amount amount of tokens to withdraw\n     * @param _token address of the token to be withdrawn\n     * @param _strategy strategy from where token has to withdrawn(ex:- compound,Aave etc)\n     * @param _withdrawShares boolean indicating to withdraw in liquidity share or underlying token\n     */\n\n    function withdrawFrom(\n        uint256 _amount,\n        address _token,\n        address _strategy,\n        address _from,\n        address payable _to,\n        bool _withdrawShares\n    ) external override nonReentrant returns (uint256) {\n        require(_amount != 0, 'SavingsAccount::withdrawFrom Amount must be greater than zero');\n\n        allowance[_from][_token][msg.sender] = allowance[_from][_token][msg.sender].sub(\n            _amount,\n            'SavingsAccount::withdrawFrom allowance limit exceeding'\n        );\n\n        _amount = IYield(_strategy).getSharesForTokens(_amount, _token);\n\n        balanceInShares[_from][_token][_strategy] = balanceInShares[_from][_token][_strategy].sub(\n            _amount,\n            'SavingsAccount::withdrawFrom insufficient balance'\n        );\n        (address _receivedToken, uint256 _amountReceived) = _withdraw(_amount, _token, _strategy, _to, _withdrawShares);\n        emit Withdrawn(_from, msg.sender, _amount, _token, _strategy, _withdrawShares);\n        return _amountReceived;\n    }\n\n    function _withdraw(\n        uint256 _amount,\n        address _token,\n        address _strategy,\n        address payable _to,\n        bool _withdrawShares\n    ) internal returns (address _tokenReceived, uint256 _amountReceived) {\n        if (_withdrawShares) {\n            _tokenReceived = IYield(_strategy).liquidityToken(_token);\n            require(_tokenReceived != address(0), 'Liquidity Tokens address cannot be address(0)');\n            _amountReceived = IYield(_strategy).unlockShares(_tokenReceived, _amount);\n        } else {\n            _tokenReceived = _token;\n            _amountReceived = IYield(_strategy).unlockTokens(_token, _amount);\n        }\n        _transfer(_amountReceived, _tokenReceived, _to);\n    }\n\n    function _transfer(\n        uint256 _amount,\n        address _token,\n        address payable _to\n    ) internal {\n        if (_token == address(0)) {\n            (bool _success, ) = _to.call{value: _amount}('');\n            require(_success, 'Transfer failed');\n        } else {\n            IERC20(_token).safeTransfer(_to, _amount);\n        }\n    }\n\n    /**\n     * @notice used to withdraw a token from all strategies\n     * @param _token address of token which is to be withdrawn\n     */\n    function withdrawAll(address _token) external override nonReentrant returns (uint256 _tokenReceived) {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n\n        for (uint256 i = 0; i < _strategyList.length; i++) {\n            if (balanceInShares[msg.sender][_token][_strategyList[i]] != 0 && _strategyList[i] != address(0)) {\n                uint256 _amount = balanceInShares[msg.sender][_token][_strategyList[i]];\n                _amount = IYield(_strategyList[i]).unlockTokens(_token, balanceInShares[msg.sender][_token][_strategyList[i]]);\n                _tokenReceived = _tokenReceived.add(_amount);\n                delete balanceInShares[msg.sender][_token][_strategyList[i]];\n            }\n        }\n\n        if (_tokenReceived == 0) return 0;\n\n        _transfer(_tokenReceived, _token, payable(msg.sender));\n\n        emit WithdrawnAll(msg.sender, _tokenReceived, _token);\n    }\n\n    function withdrawAll(address _token, address _strategy) external override nonReentrant returns (uint256 _tokenReceived) {\n        uint256 _sharesBalance = balanceInShares[msg.sender][_token][_strategy];\n\n        if(_sharesBalance == 0) return 0;\n\n        uint256 _amount = IYield(_strategy).unlockTokens(_token, _sharesBalance);\n\n        delete balanceInShares[msg.sender][_token][_strategy];\n\n        _transfer(_amount, _token, payable(msg.sender));\n\n        emit Withdrawn(msg.sender, msg.sender, _amount, _token, _strategy, false);\n    }\n\n    /**\n     * @notice used to approve allowance to an address\n     * @dev this is prone to race condition, hence increaseAllowance is recommended\n     * @param _amount amount of tokens approved\n     * @param _token address of token approved\n     * @param _to address of the user approved to\n     */\n    function approve(\n        uint256 _amount,\n        address _token,\n        address _to\n    ) external override {\n        allowance[msg.sender][_token][_to] = _amount;\n\n        emit Approved(_token, msg.sender, _to, _amount);\n    }\n\n    /**\n     * @notice used to increase allowance to an address\n     * @param _amount amount of tokens allowance is increased by\n     * @param _token address of token approved\n     * @param _to address of the address approved to\n     */\n    function increaseAllowance(\n        uint256 _amount,\n        address _token,\n        address _to\n    ) external override {\n        uint256 _updatedAllowance = allowance[msg.sender][_token][_to].add(_amount);\n        allowance[msg.sender][_token][_to] = _updatedAllowance;\n\n        emit Approved(_token, msg.sender, _to, _updatedAllowance);\n    }\n\n    /**\n     * @notice used to decrease allowance to an address\n     * @param _amount amount of tokens allowance is decreased by\n     * @param _token address of token approved\n     * @param _to address of the user approved to\n     */\n    function decreaseAllowance(\n        uint256 _amount,\n        address _token,"
    }
  ]
}