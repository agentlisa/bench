{
  "Title": "Nick's Method for Deployments Is Error-Prone",
  "Content": "The `TeleporterMessenger` contract will be deployed at the same address on any subnet that wishes to allow cross-chain messaging using the Teleporter protocol. It is intended to use [Nick's method](https://github.com/ava-labs/teleporter/blob/253b833518aa7a6448650388cc288bd76d8470a7/contracts/src/Teleporter/TeleporterMessenger.sol#L21C100-L21C113) to ensure that the contract is deployed at the same address on each subnet. Since Nick's method uses a signed transaction from a one-time address, a few concerns arise that could prevent deployment as intended. In particular:\n\n\n* If the deployment fails, the signed transaction will not be able to be retried as the signed nonce in the transaction for the one-time address will be used. This could occur if the call to [`WARP_MESSENGER.getBlockchainID()`](https://github.com/ava-labs/teleporter/blob/253b833518aa7a6448650388cc288bd76d8470a7/contracts/src/Teleporter/TeleporterMessenger.sol#L104) fails.\n* If a subnet defines non-standard costs for opcodes, the `gasLimit` in the signed transaction may not be large enough for the deployment transaction to be executed.\n* The `gasPrice` must also be set within the signed transaction. The `gasPrice` can vary widely between subnets due to the popularity of the chain as well as the liquid supply of native tokens used for paying for gas. If a subnet has a low total supply of the native token relative to other chains, the specified `gasPrice` may not be large enough to get the deployment transaction included in a block. Conversely, if a subnet has a relatively large liquid supply of native tokens, the `gasPrice` may require spending a large quantity of native tokens. This could result in an expensive deployment transaction when measured in fiat currency.\n\n\nConsider using an alternative to Nick's method such as `CREATE2`. Alternatively, consider ensuring that there is a fallback approach to deploying the `TeleporterMessenger` contract at the intended address and that its procedure is well documented. This is so that the actors involved in the deployment of a new subnet can mitigate this problem without any friction.\n\n\n***Update:** Partially resolved in [pull request 64 at commit `5f8b039`](https://github.com/ava-labs/teleporter/pull/64/commits/5f8b0392696e7a7e4117900dc990aef335e43d11). `blockchainID` assignment has been moved from the `constructor` function into the `receiveCrossChainMessage` function. However, it would preferable to use a one-time only dedicated method to initialize the variable to reduce the attack surface and the gas cost when receiving messages from other subnets. Moreover, the [deployment documentation](https://github.com/ava-labs/teleporter/tree/f0bdc1b1015d998a2417fd6c537cd33333e81d4e/utils/contract-deployment) does not include the additional information to deploy the contract under problematic situations. AVA Labs stated the following regarding the issue:*\n\n\n\n> *We have updated the `TeleporterMessenger` contract such that it has an empty/default constructor in order to minimize the potential for the deployment transaction to fail.* *Using `CREATE2` is not really a viable alternative to Nick's method. It requires that a factory contract is deployed at the same address on each chain prior to creating the `TeleporterMessenger` instance using the factory. In order to deploy the factory contract to the same address on each chain (without having a shared account key used by every chain, as required in this case), Nick's method would still need to be used in the same manner, with the same possible error cases for that transaction to fail.* *The fallback approach in mind for a scenario where the normal `TeleporterMessenger` deployment transaction using Nick's method fails for a subnet is for that subnet to [specify the contract in their genesis for new subnets](https://github.com/ava-labs/subnet-evm/blob/master/core/genesis.go#L102), or [add the code in a state upgrade](https://github.com/ava-labs/subnet-evm/blob/master/params/state_upgrade.go) as part of a required network update for existing subnets. While more cumbersome than sending a pre-defined transaction, each allows a surefire fallback approach for getting the contract code the necessary address on a given chain.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/Teleporter/TeleporterMessenger.sol",
      "content": "// (c) 2023, Ava Labs, Inc. All rights reserved.\n// See the file LICENSE for licensing terms.\n\n// SPDX-License-Identifier: Ecosystem\n\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@subnet-evm-contracts/interfaces/IWarpMessenger.sol\";\nimport \"./ITeleporterMessenger.sol\";\nimport \"./ReceiptQueue.sol\";\nimport \"./SafeERC20TransferFrom.sol\";\nimport \"./ITeleporterReceiver.sol\";\nimport \"./ReentrancyGuards.sol\";\n\n/**\n * @dev Implementation of the {ITeleporterMessenger} interface.\n *\n * This implementation is used to send messages cross chain using the WarpMessenger precompile,\n * and to receive messages sent from other chains. Teleporter contracts should be deployed through Nick's method\n * of universal deployer, such that the same contract is deployed at the same address on all chains.\n */\ncontract TeleporterMessenger is ITeleporterMessenger, ReentrancyGuards {\n    using SafeERC20 for IERC20;\n\n    struct SentMessageInfo {\n        bytes32 messageHash;\n        TeleporterFeeInfo feeInfo;\n    }\n\n    WarpMessenger public constant WARP_MESSENGER =\n        WarpMessenger(0x0200000000000000000000000000000000000005);\n\n    // Tracks the latest message ID used for a given destination subnet.\n    // Key is the destination subnet ID, and the value is the last message ID used for that subnet.\n    // Note that the first message ID used for each subnet will be 1 (not 0).\n    mapping(bytes32 => uint256) public latestMessageIDs;\n\n    // Tracks the outstanding receipts to send back to a given subnet in subsequent messages sent to it.\n    // Key is the subnet ID of the other subnet, and the value is a queue of pending receipts for messages\n    // we have received from that subnet.\n    mapping(bytes32 => ReceiptQueue) public outstandingReceipts;\n\n    // Tracks the message hash and fee information for each message sent that we have not yet received\n    // a receipt for. The messages are tracked per subnet and keyed by message ID.\n    // The first key is the subnet ID, the second key is the message ID, and the value is the info\n    // for the uniquely identified message.\n    mapping(bytes32 => mapping(uint256 => SentMessageInfo))\n        public sentMessageInfo;\n\n    // Tracks the relayer reward address for each message delivered from a given subnet.\n    // Note that these values are also used to determine if a given message has been delivered or not.\n    // The first key is the subnet ID, the second key is the message ID, and the value is the reward address\n    // provided by the deliverer of the uniquely identified message.\n    mapping(bytes32 => mapping(uint256 => address))\n        public relayerRewardAddresses;\n\n    // Tracks the hash of messages that have been received but whose execution has never succeeded.\n    // Enables retrying of failed messages with higher gas limits. Message execution is guaranteed to\n    // succeed at most once.  The first key is the subnet ID, the second key is the message ID, and\n    // the value is the hash of the uniquely identified message whose execution failed.\n    mapping(bytes32 => mapping(uint256 => bytes32))\n        public receivedFailedMessageHashes;\n\n    // Tracks the fee amounts for a given asset able to be redeemed by a given relayer.\n    // The first key is the relayer address, the second key is the ERC20 token contract address,\n    // and the value is the amount of the asset owed to the relayer.\n    mapping(address => mapping(address => uint256)) public relayerRewardAmounts;\n\n    // The maximum number of receipts to include in a single message.\n    uint256 public constant MAXIMUM_RECEIPT_COUNT = 5;\n\n    // Teleporter delivers message by invoking functions of the form: funcName(bytes32 originChainID, address originSenderAddress, ...)\n    // where \"...\" can represent arbitrary additional parameters. Accounting for the 4 byte function selector and two 32 byte parameters,\n    // there is a minimum valid message length of 68 bytes.\n    uint256 public constant REQUIRED_ORIGIN_CHAIN_ID_START_INDEX = 4;\n    uint256 public constant MINIMUM_REQUIRED_CALL_DATA_LENGTH = 68;\n\n    // The blockchain ID of the chain the contract is deployed on. Determined by warp messenger precompile.\n    bytes32 public immutable blockchainID;\n\n    // Errors\n    error InsufficientGas();\n    error InvalidAdditionalFeeAmount();\n    error InvalidDestinationAddress();\n    error InvalidDestinationChainID();\n    error InvalidFeeAssetContractAddress();\n    error InvalidMessageHash();\n    error InvalidOriginSenderAddress();\n    error InvalidRelayerRewardAddress();\n    error InvalidWarpMessage();\n    error MessageAlreadyDelivered();\n    error MessageNotFound();\n    error MessageRetryExecutionFailed();\n    error NoRelayerRewardToRedeem();\n    error ReceiptNotFound();\n    error UnauthorizedRelayer();\n\n    /**\n     * @dev Sets the value of `blockchainID` to the value determined by the warp messenger precompile.\n     */\n    constructor() {\n        blockchainID = WARP_MESSENGER.getBlockchainID();\n    }\n\n    /**\n     * @dev See {ITeleporterMessenger-sendCrossChainMessage}\n     *\n     * When executed, it will kick off an asynchronous event to have the validators of the chain create an\n     * aggregate BLS signature of the message.\n     *\n     * Emits a {SendCrossChainMessage} event when message successfully gets sent.\n     */\n    function sendCrossChainMessage(\n        TeleporterMessageInput calldata messageInput\n    ) external senderNonReentrant returns (uint256 messageID) {\n        // Get the outstanding receipts for messages that have been previously received\n        // from the destination subnet but not yet acknowledged, and attach the receipts\n        // to the Teleporter message to be sent.\n        return\n            _sendTeleporterMessage({\n                destinationChainID: messageInput.destinationChainID,\n                destinationAddress: messageInput.destinationAddress,\n                feeInfo: messageInput.feeInfo,\n                requiredGasLimit: messageInput.requiredGasLimit,\n                allowedRelayerAddresses: messageInput.allowedRelayerAddresses,\n                message: messageInput.message,\n                receipts: _getOutstandingReceiptsToSend(\n                    messageInput.destinationChainID\n                )\n            });\n    }\n\n    /**\n     * @dev See {ITeleporterMessenger-retrySendCrossChainMessage}\n     *\n     * Emits {SendCrossChainMessage} event.\n     * Requirements:\n     *\n     * - `message` must have been previously sent to the given destination chain ID.\n     * - `message` encoding mush match previously sent message.\n     */\n    function retrySendCrossChainMessage(\n        bytes32 destinationChainID,\n        TeleporterMessage calldata message\n    ) external senderNonReentrant {\n        // Get the previously sent message hash.\n        bytes32 messageHash = sentMessageInfo[destinationChainID][\n            message.messageID\n        ].messageHash;\n        if (messageHash == bytes32(0)) {\n            // If the message hash is zero, the message was never sent.\n            revert MessageNotFound();\n        }\n\n        // Check that the hash of the provided message matches the one that was originally submitted.\n        bytes memory messageBytes = abi.encode(message);\n        if (keccak256(messageBytes) != messageHash) {\n            revert InvalidMessageHash();\n        }\n\n        // Emit and make state variable changes before external calls when possible,\n        // though this function is protected by sender reentrancy guard.\n        emit SendCrossChainMessage(\n            destinationChainID,\n            message.messageID,\n            message\n        );\n\n        // Resubmit the message to the warp message precompile now that we know the exact message was\n        // already submitted in the past.\n        WARP_MESSENGER.sendWarpMessage(\n            destinationChainID,\n            address(this),\n            messageBytes\n        );\n    }\n\n    /**\n     * @dev See {ITeleporterMessenger-addFeeAmount}\n     *\n     * Emits {AddFeeAmount} event.\n     * Requirements:\n     *\n     * - `additionalFeeAmount` must be non-zero.\n     * - message must exist and not have been delivered yet.\n     * - `feeContractAddress` must match the fee asset contract address used in the original call to sendCrossChainMessage.\n     */\n    function addFeeAmount(\n        bytes32 destinationChainID,\n        uint256 messageID,\n        address feeContractAddress,\n        uint256 additionalFeeAmount\n    ) external senderNonReentrant {\n        // The additional fee amount must be non-zero.\n        if (additionalFeeAmount == 0) {\n            revert InvalidAdditionalFeeAmount();\n        }\n\n        // Do not allow adding a fee asset with contract address zero.\n        if (feeContractAddress == address(0)) {\n            revert InvalidFeeAssetContractAddress();\n        }\n\n        // If we have received the delivery receipt for this message, its hash and fee information\n        // will be cleared from state. At this point, you can not add to its fee. This is also the\n        // case if the given message never existed.\n        if (\n            sentMessageInfo[destinationChainID][messageID].messageHash ==\n            bytes32(0)\n        ) {\n            revert MessageAlreadyDelivered();\n        }\n\n        // Check that the fee contract address matches the one that was originally used. Only a single\n        // fee asset can be used to incentivize the delivery of a given message.\n        // We require users to explicitly pass the same fee asset contract address here rather than just using\n        // the previously submitted asset type as a defensive measure to avoid having users accidentally confuse\n        // which asset they are paying.\n        if (\n            sentMessageInfo[destinationChainID][messageID]\n                .feeInfo\n                .contractAddress != feeContractAddress\n        ) {\n            revert InvalidFeeAssetContractAddress();\n        }\n\n        // Transfer the additional fee amount to this Teleporter instance.\n        uint256 adjustedAmount = SafeERC20TransferFrom.safeTransferFrom(\n            IERC20(feeContractAddress),\n            additionalFeeAmount\n        );\n\n        // Store the updated fee amount, and emit it as an event.\n        sentMessageInfo[destinationChainID][messageID]\n            .feeInfo\n            .amount += adjustedAmount;\n\n        emit AddFeeAmount(\n            destinationChainID,\n            messageID,\n            sentMessageInfo[destinationChainID][messageID].feeInfo\n        );\n    }\n\n    /**\n     * @dev See {ITeleporterMessenger-receiveCrossChainMessage}\n     *\n     * Emits {ReceiveCrossChainMessage} event.\n     * Re-entrancy is explicitly disallowed between receiving functions. One message is not able to receive another message.\n     * Requirements:\n     *\n     * - `relayerRewardAddress` must not be the zero address.\n     * - `messageIndex` must specify a valid warp message in the transaction's storage slots.\n     * - Valid warp message provided in storage slots, and sender address matches the address of this contract.\n     * - Warp message `destinationChainID` must match the `blockchainID` of this contract.\n     * - Warp message `destinationAddress` must match the address of this contract.\n     * - Teleporter message was not previously delivered.\n     * - Transaction was sent by an allowed relayer for corresponding teleporter message.\n     */\n    function receiveCrossChainMessage(\n        uint32 messageIndex,\n        address relayerRewardAddress\n    ) external receiverNonReentrant {\n        // The relayer reward address is not allowed to be the zero address because it is how we track\n        // whether or not a message has been delivered.\n        if (relayerRewardAddress == address(0)) {\n            revert InvalidRelayerRewardAddress();\n        }\n\n        // Verify and parse the cross chain message included in the transaction access list\n        // using the warp message precompile.\n        (WarpMessage memory warpMessage, bool success) = WARP_MESSENGER\n            .getVerifiedWarpMessage(messageIndex);\n\n        if (!success) {\n            revert InvalidWarpMessage();\n        }\n\n        // Only allow for messages to be received from the same address as this teleporter contract.\n        // The contract should be deployed using the universal deployer pattern, such that it knows messages\n        // received from the same address on other chains were constructed using the same bytecode of this contract.\n        // This allows for trusting the message format and uniqueness as specified by sendCrossChainMessage.\n        if (warpMessage.originSenderAddress != address(this)) {\n            revert InvalidOriginSenderAddress();\n        }\n\n        // Require that the message was intended for this blockchain and teleporter contract.\n        if (warpMessage.destinationChainID != blockchainID) {\n            revert InvalidDestinationChainID();\n        }\n\n        if (warpMessage.destinationAddress != address(this)) {\n            revert InvalidDestinationAddress();\n        }\n\n        // Parse the payload of the message.\n        TeleporterMessage memory teleporterMessage = abi.decode(\n            warpMessage.payload,\n            (TeleporterMessage)\n        );\n\n        // Check the message has not been delivered before by checking that there is no relayer reward\n        // address stored for it already.\n        if (\n            relayerRewardAddresses[warpMessage.sourceChainID][\n                teleporterMessage.messageID\n            ] != address(0)\n        ) {\n            revert MessageAlreadyDelivered();\n        }\n\n        // Check that the caller is allowed to deliver this message.\n        if (\n            !_checkIsAllowedRelayer(\n                msg.sender,\n                teleporterMessage.allowedRelayerAddresses\n            )\n        ) {\n            revert UnauthorizedRelayer();\n        }\n\n        // Store the relayer reward address provided, effectively marking the message as received.\n        relayerRewardAddresses[warpMessage.sourceChainID][\n            teleporterMessage.messageID\n        ] = relayerRewardAddress;\n\n        // Execute the message.\n        if (teleporterMessage.message.length > 0) {\n            _handleInitialMessageExecution(\n                warpMessage.sourceChainID,\n                teleporterMessage\n            );\n        }\n\n        // Process the receipts that were included in the teleporter message by paying the\n        // fee for the messages are reward to the given relayers.\n        uint256 length = teleporterMessage.receipts.length;\n        for (uint256 i = 0; i < length; ++i) {\n            TeleporterMessageReceipt memory receipt = teleporterMessage\n                .receipts[i];\n            _markReceipt(\n                warpMessage.sourceChainID,\n                receipt.receivedMessageID,\n                receipt.relayerRewardAddress\n            );\n        }\n\n        // Store the receipt of this message delivery. When a subsquent message is sent back\n        // to the origin of this message, we will clean up the receipt state.\n        // If the receipts queue contract for this chain doesn't exist yet, create it now.\n        ReceiptQueue receiptsQueue = outstandingReceipts[\n            warpMessage.sourceChainID\n        ];\n        if (address(receiptsQueue) == address(0)) {\n            receiptsQueue = new ReceiptQueue();\n            outstandingReceipts[warpMessage.sourceChainID] = receiptsQueue;\n        }\n        receiptsQueue.enqueue(\n            TeleporterMessageReceipt({\n                receivedMessageID: teleporterMessage.messageID,\n                relayerRewardAddress: relayerRewardAddress\n            })\n        );\n\n        emit ReceiveCrossChainMessage(\n            warpMessage.sourceChainID,\n            teleporterMessage.messageID,\n            teleporterMessage\n        );\n    }\n\n    /**\n     * @dev See {ITeleporterMessenger-retryMessageExecution}\n     *\n     * Reverts if the message execution fails again on specified message.\n     * Requirements:\n     *\n     * - `message` must have previously failed to execute, and matches the hash of the failed message.\n     */\n    function retryMessageExecution(\n        bytes32 originChainID,\n        TeleporterMessage calldata message\n    ) external receiverNonReentrant {\n        // Check that the hash of the payload provided matches the hash of the payload that preivously failed to execute.\n        bytes32 failedMessageHash = receivedFailedMessageHashes[originChainID][\n            message.messageID\n        ];\n        if (failedMessageHash == bytes32(0)) {\n            revert MessageNotFound();\n        }\n\n        if (keccak256(abi.encode(message)) != failedMessageHash) {\n            revert InvalidMessageHash();\n        }\n\n        // Check that the target address has fully initialized contract code prior to calling it.\n        // If the target address does not have code, the execution automatically fails because\n        // we disallow calling EOA addresses.\n        if (message.destinationAddress.code.length == 0) {\n            revert InvalidDestinationAddress();\n        }\n\n        // Clear the failed message hash from state prior to retrying its execution to redundantly prevent\n        // reentrance attacks (on top of the nonReentrant guard).\n        emit MessageExecutionRetried(originChainID, message.messageID);\n        delete receivedFailedMessageHashes[originChainID][message.messageID];\n\n        // Reattempt the message execution with all of the gas left available for execution of this transaction.\n        // We use all of the gas left because this message has already been successfully delivered, and it is the\n        // responsibility of the caller to provide as much gas is needed. Compared to the initial delivery, where\n        // the relayer should still receive their reward even if the message exeuction takes more gas than expected.\n        // We require that the call be successful because if not the retry is considered to have failed and we\n        // should revert this transaction so the message can be retried again if desired.\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = message.destinationAddress.call(\n            abi.encodeCall(\n                ITeleporterReceiver.receiveTeleporterMessage,\n                (originChainID, message.senderAddress, message.message)\n            )\n        );\n        if (!success) {\n            revert MessageRetryExecutionFailed();\n        }\n    }\n\n    /**\n     * @dev See {ITeleporterMessenger-retryReceipts}\n     *\n     * There is no explicit limit to the number of receipts able to be retried in a single message because\n     * this method is intended to be used by relayers themselves to ensure their receipts get returned.\n     * There is no fee associated with the empty message, and the same relayer is expected to relay it\n     * themselves in order to claim their rewards, so it is their responsibility to ensure that the necessary\n     * gas is provided for however many receipts are being retried.\n     *\n     * When receipts are retried, they are not removed from their corresponding receipt queue because there\n     * is no efficient way to remove a specific receipt from an arbitrary position in the queue, and it is\n     * harmless for receipts to be sent multiple times within the protocol.\n     *\n     * Emits {SendCrossChainMessage} event.\n     * Requirements:\n     * - `messageIDs` must all be valid and have existing receipts.\n     */\n    function retryReceipts(\n        bytes32 originChainID,\n        uint256[] calldata messageIDs,\n        TeleporterFeeInfo calldata feeInfo,\n        address[] calldata allowedRelayerAddresses\n    ) external senderNonReentrant returns (uint256 messageID) {\n        // Iterate through the specified message IDs and create teleporter receipts to send back.\n        TeleporterMessageReceipt[]\n            memory receiptsToSend = new TeleporterMessageReceipt[](\n                messageIDs.length\n            );\n        for (uint256 i = 0; i < messageIDs.length; i++) {\n            uint256 receivedMessageID = messageIDs[i];\n            // Check the relayer reward address for this message.\n            address relayerRewardAddress = relayerRewardAddresses[\n                originChainID\n            ][receivedMessageID];\n            if (relayerRewardAddress == address(0)) {\n                revert ReceiptNotFound();\n            }\n\n            receiptsToSend[i] = TeleporterMessageReceipt({\n                receivedMessageID: receivedMessageID,\n                relayerRewardAddress: relayerRewardAddress\n            });\n        }\n\n        messageID = _sendTeleporterMessage({\n            destinationChainID: originChainID,\n            destinationAddress: address(0),\n            feeInfo: feeInfo,\n            requiredGasLimit: uint256(0),\n            allowedRelayerAddresses: allowedRelayerAddresses,\n            message: new bytes(0),\n            receipts: receiptsToSend\n        });\n        return messageID;\n    }\n\n    /**\n     * @dev See {ITeleporterMessenger-redeemRelayerRewards}\n     *\n     * Requirements:\n     *\n     * - `rewardAmount` must be non-zero.\n     */\n    function redeemRelayerRewards(address feeAsset) external {\n        uint256 rewardAmount = relayerRewardAmounts[msg.sender][feeAsset];\n        if (rewardAmount == 0) {\n            revert NoRelayerRewardToRedeem();\n        }\n\n        // Zero the reward balance before calling the external ERC20 to transfer the\n        // reward to prevent any possible re-entrancy.\n        delete relayerRewardAmounts[msg.sender][feeAsset];\n\n        // We don't need to handle \"fee on transfer\" tokens in a special case here because\n        // the amount credited to the caller does not affect this contracts accounting. The\n        // reward is considered paid in full in all cases.\n        IERC20(feeAsset).safeTransfer(msg.sender, rewardAmount);\n    }\n\n    /**\n     * See {ITeleporterMessenger-getMessageHash}\n     */\n    function getMessageHash(\n        bytes32 destinationChainID,\n        uint256 messageID\n    ) external view returns (bytes32 messageHash) {\n        return sentMessageInfo[destinationChainID][messageID].messageHash;\n    }\n\n    /**\n     * @dev See {ITeleporterMessenger-messageReceived}\n     */\n    function messageReceived(\n        bytes32 originChainID,\n        uint256 messageID\n    ) external view returns (bool delivered) {\n        return relayerRewardAddresses[originChainID][messageID] != address(0);\n    }\n\n    /**\n     * @dev See {ITeleporterMessenger-getRelayerRewardAddress}\n     */\n    function getRelayerRewardAddress(\n        bytes32 originChainID,\n        uint256 messageID\n    ) external view returns (address relayerRewardAddress) {\n        return relayerRewardAddresses[originChainID][messageID];\n    }\n\n    /**\n     * @dev See {ITeleporterMessenger-checkRelayerRewardAmount}\n     */\n    function checkRelayerRewardAmount(\n        address relayer,\n        address feeAsset\n    ) external view returns (uint256) {\n        return relayerRewardAmounts[relayer][feeAsset];\n    }\n\n    /**\n     * @dev See {ITeleporterMessenger-getFeeInfo}\n     */\n    function getFeeInfo(\n        bytes32 destinationChainID,\n        uint256 messageID\n    ) external view returns (address feeAsset, uint256 feeAmount) {\n        TeleporterFeeInfo memory feeInfo = sentMessageInfo[destinationChainID][\n            messageID\n        ].feeInfo;\n        return (feeInfo.contractAddress, feeInfo.amount);\n    }\n\n    /**\n     * @dev Returns the next message ID to be used to send a message to the given chain ID.\n     */\n    function getNextMessageID(\n        bytes32 chainID\n    ) external view returns (uint256 messageID) {\n        return _getNextMessageID(chainID);\n    }\n\n    /**\n     * @dev Checks whether `delivererAddress` is allowed to deliver the message.\n     */\n    function checkIsAllowedRelayer(\n        address delivererAddress,\n        address[] calldata allowedRelayers\n    ) external pure returns (bool) {\n        return _checkIsAllowedRelayer(delivererAddress, allowedRelayers);\n    }\n\n    /**\n     * @dev Helper function for sending a teleporter message cross chain.\n     * Constructs the teleporter message and sends it through the warp messenger precompile,\n     * and performs fee transfer if necessary.\n     *\n     * Emits a {SendCrossChainMessage} event.\n     */\n    function _sendTeleporterMessage(\n        bytes32 destinationChainID,\n        address destinationAddress,\n        TeleporterFeeInfo calldata feeInfo,\n        uint256 requiredGasLimit,\n        address[] calldata allowedRelayerAddresses,\n        bytes memory message,\n        TeleporterMessageReceipt[] memory receipts\n    ) private returns (uint256 messageID) {\n        // Get the message ID to use for this message.\n        messageID = _getNextMessageID(destinationChainID);\n\n        // Construct and serialize the message.\n        TeleporterMessage memory teleporterMessage = TeleporterMessage({\n            messageID: messageID,\n            senderAddress: msg.sender,\n            destinationAddress: destinationAddress,\n            requiredGasLimit: requiredGasLimit,\n            allowedRelayerAddresses: allowedRelayerAddresses,\n            receipts: receipts,\n            message: message\n        });\n        bytes memory teleporterMessageBytes = abi.encode(teleporterMessage);\n\n        // Set the message ID value as being used.\n        latestMessageIDs[destinationChainID] = messageID;\n\n        // If the fee amount is non-zero, transfer the asset into control of this TeleporterMessenger contract instance.\n        // We allow the fee to be 0 because its possible for someone to run their own relayer and deliver their own messages,\n        // which does not require further incentivization. They still must pay the transaction fee to submit the message, so\n        // this is not a DOS vector in terms of being able to submit zero-fee messages.\n        uint256 adjustedFeeAmount = 0;\n        if (feeInfo.amount > 0) {\n            // If the fee amount is non-zero, check that the contract address is not address(0)\n            if (feeInfo.contractAddress == address(0)) {\n                revert InvalidFeeAssetContractAddress();\n            }\n\n            adjustedFeeAmount = SafeERC20TransferFrom.safeTransferFrom(\n                IERC20(feeInfo.contractAddress),\n                feeInfo.amount\n            );\n        }\n\n        // Store the fee asset and amount to be paid to the relayer of this message upon receiving the receipt.\n        // Also store the message hash so that it can be retried until we get receipt of its delivery.\n        sentMessageInfo[destinationChainID][messageID] = SentMessageInfo({\n            messageHash: keccak256(teleporterMessageBytes),\n            feeInfo: TeleporterFeeInfo({\n                contractAddress: feeInfo.contractAddress,\n                amount: adjustedFeeAmount\n            })\n        });\n\n        emit SendCrossChainMessage(\n            destinationChainID,\n            messageID,\n            teleporterMessage\n        );\n\n        // Submit the message to the AWM precompile.\n        // The Teleporter contract only allows for sending messages to other instances of the same\n        // contract at the same address on other EVM chains, which is why we set the destination adress\n        // as the address of this contract.\n        WARP_MESSENGER.sendWarpMessage(\n            destinationChainID,\n            address(this),\n            teleporterMessageBytes\n        );\n\n        return messageID;\n    }\n\n    /**\n     * @dev Marks the receipt of a message from the given destination chain ID with the given message ID.\n     *\n     * It is possible that the receipt was already received for this message, in which case we return early.\n     * If existing message is found and not yet delivered, we delete it from state and increment the fee/reward\n     */\n    function _markReceipt(\n        bytes32 destinationChainID,\n        uint256 messageID,\n        address relayerRewardAddress\n    ) private {\n        // Get the information about the sent message we are now marking as received.\n        SentMessageInfo memory messageInfo = sentMessageInfo[\n            destinationChainID\n        ][messageID];\n\n        // If the message hash does not exist, it could be the case that the receipt was already\n        // received for this message (it's possible for receipts to be sent more than once)\n        // or that the other chain sent an invalid receipt. We return early since this is an expected\n        // case where there is no fee to be paid for the given message.\n        if (messageInfo.messageHash == bytes32(0)) {\n            return;\n        }\n\n        // Delete the message information from state now that we know it has been delivered.\n        delete sentMessageInfo[destinationChainID][messageID];\n\n        // Increment the fee/reward amount owed to the relayer for having delivered\n        // the message identified in this receipt.\n        relayerRewardAmounts[relayerRewardAddress][\n            messageInfo.feeInfo.contractAddress\n        ] += messageInfo.feeInfo.amount;\n    }\n\n    /**\n     * @dev Attempts to execute the newly delivered message.\n     *\n     * Only revert in the event that the message deliverer (relayer) did not provide enough gas to handle the execution\n     * (including possibly storing a failed message in state). All execution specific errors (i.e. invalid call data, etc)\n     * that are not in the relayers control are caught and handled properly.\n     *\n     * Emits a {FailedMessageExecution} event if the call on destination address fails with formatted call data.\n     * Requirements:\n     *\n     * - There is enough gas left to cover `message.requiredGasLimit`.\n     */\n    function _handleInitialMessageExecution(\n        bytes32 originChainID,\n        TeleporterMessage memory message\n    ) private {\n        // Check that the message delivery was provided the required gas amount as specified by the sender.\n        // If the required gas amount is provided, the message will be considered delivered whether or not\n        // its execution succeeds, such that the relayer can claim their fee reward. However, if the message\n        // execution fails, the message hash will be stored in state such that anyone can try to provide more\n        // gas to successfully execute the message.\n        if (gasleft() < message.requiredGasLimit) {\n            revert InsufficientGas();\n        }\n\n        // The destination address must have fully initialized contract code in order for the message\n        // to call it. If the destination address does not have code, we store the message as a failed\n        // execution so that it can be retried in the future should a contract be later deployed to\n        // the address.\n        if (message.destinationAddress.code.length == 0) {\n            _storeFailedMessageExecution(originChainID, message);\n            return;\n        }\n\n        // Call the destination address of the message with the formatted call data.\n        // We only provide the required gas limit to the sub-call because we know that\n        // we have sufficient gas left to cover that amount, and do not want to allow the\n        // end application to consume arbitrary gas.\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = message.destinationAddress.call{\n            gas: message.requiredGasLimit\n        }(\n            abi.encodeCall(\n                ITeleporterReceiver.receiveTeleporterMessage,\n                (originChainID, message.senderAddress, message.message)\n            )\n        );\n\n        // If the execution failed, we will store a hash of the message in state such that it's\n        // execution can be retried again in the future with a higher gas limit (paid by whoever\n        // retries).Either way, the message will now be considered \"delivered\" since the relayer\n        // provided enough gas to meet the required gas limit.\n        if (!success) {\n            _storeFailedMessageExecution(originChainID, message);\n        }\n    }\n\n    /**\n     * @dev Stores the hash of a message that has been successfully delivered but fails to execute properly\n     * such that the message execution can be retried by anyone in the future.\n     */\n    function _storeFailedMessageExecution(\n        bytes32 originChainID,\n        TeleporterMessage memory message\n    ) private {\n        receivedFailedMessageHashes[originChainID][\n            message.messageID\n        ] = keccak256(abi.encode(message));\n\n        // Emit a failed execution event for anyone monitoring unsuccessful messages to retry.\n        emit FailedMessageExecution(originChainID, mess"
    }
  ]
}