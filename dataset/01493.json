{
  "Title": "H-5: wrong bToken's exchangeRateStored used for calculate ColleteralValue",
  "Content": "# Issue H-5: wrong bToken's exchangeRateStored used for calculate ColleteralValue \n\nSource: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/117 \n\n## Found by \nmert\\_eren\nBlueBerryBank.sol calculate position's risk value with `getPositionRisk()` . This function used for is position can be liquadatable or not.\n```solidity\n    function getPositionRisk(uint256 positionId) public returns (uint256 risk) {\n        uint256 pv = getPositionValue(positionId);\n        uint256 ov = getDebtValue(positionId);\n        uint256 cv = getIsolatedCollateralValue(positionId);\n\n\n        if (\n            (cv == 0 && pv == 0 && ov == 0) || pv >= ov /// Closed position or Overcollateralized position\n        ) {\n            risk = 0;\n        } else if (cv == 0) {\n            /// Sth bad happened to isolated underlying token\n            risk = Constants.DENOMINATOR;\n        } else {\n            risk = ((ov - pv) * Constants.DENOMINATOR) / cv;\n        }\n    }\n```\n\n`getIsolatedColleteralValue()` calculate lended value in position.\n```solidity\n    function getIsolatedCollateralValue(\n        uint256 positionId\n    ) public override returns (uint256 icollValue) {\n        Position memory pos = positions[positionId];\n        /// NOTE: exchangeRateStored has 18 decimals.\n        uint256 underlyingAmount;\n        if (_isSoftVault(pos.underlyingToken)) {\n            underlyingAmount =\n                (ICErc20(banks[pos.debtToken].bToken).exchangeRateStored() *\n                    pos.underlyingVaultShare) /\n                Constants.PRICE_PRECISION;\n        } else {\n            underlyingAmount = pos.underlyingVaultShare;\n        }\n        icollValue = oracle.getTokenValue(\n            pos.underlyingToken,\n            underlyingAmount\n        );\n    }\n```\nFor calculate total value it should calculate first `underlyingAmount`. Due to calculate this, it should first multiply `pos.underlyingVaultShare` with ```exchangeRateStored()``` of this token.Because when stored `underlyingVaultShare` in `lend` function, it not stored directly lended amount but the amount minted in softVault after this tokens lended to it. \n```solidity\n    function lend(\n        address token,\n        uint256 amount\n    ) external override inExec poke(token) onlyWhitelistedToken(token) {\n        ...\n\n\n        if (_isSoftVault(token)) {\n            _ensureApprove(token, bank.softVault, amount);\n            pos.underlyingVaultShare += ISoftVault(bank.softVault).deposit(\n                amount\n            );\n        } else {\n            _ensureApprove(token, bank.hardVault, amount);\n            pos.underlyingVaultShare += IHardVault(bank.hardVault).deposit(\n                token,\n                amount\n            );\n        }\n\n```\nSoftVault's `deposit` function call `mint` function of blueBerry bToken (which work same as compound cToken).And return minted amount of bToken. bToken mintAmount is `amount/exchangeRateStored` . So when calculate `underlyingAmount` , `pos.UnderlyinVaultShare` must be multiplied with btoken of underlyingToken's `exchangeRateStored`. However as seen above of the `getIsolatedColleteralValue()` code snippet it multiply with `debtToken`'s bToken not `underlyingToken`'s. Due to all bTokens' has different `exchangeRate`, `underlyingAmount` will be calculate wrong. \n\n \n## Vulnerability Detail\n\n## Impact\nmisCalculation of `getIsolatedColleteralValue()` so `cv` in `getPositionRisk`.This will lead some protocols can be \n## Code Snippet\nhttps://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/BlueBerryBank.sol#L493\n## Tool used\n\nManual Review\n\n## Recommendation\nuse underlying token's bToken exchangeRate in `getIsolatedColleteralValue()` not debtToken's.\n\n\n\n\n\n## Discussion\n\n**merteren1234**\n\nEscalate\nI think this issue is not duplicate of #16. Because this issue indicate differeant root cause than #16. This issue's root cause is , wrong bToken's exchangeRate used in getIsolatedColleteral().Not about old exchangeRate used or not. Moreover without fixing this issue , #16 is not valid because pos.debtToken is updated with poke modifier in liquidate function and its exchangeRate used in getIsolatedColleteralValue() .\nThis issue is about getIsolatedColleteralValue() use debtToken's exchangeRate which is wrong because this functions should use underlyingToken's exchangeRate. So even though #16 is fixed  (there will be no impact without fix this issue.) this issue still remain and changing `ICErc20(banks[pos.debtToken].bToken).exchangeRateStored()` with `ICErc20(banks[pos.underlyingToken].bToken).exchangeRateStored()`   is mandatory to take correct getIsolatedColleteralValue().\n\n\n**sherlock-admin2**\n\n > Escalate\n> I think this issue is not duplicate of #16. Because this issue indicate differeant root cause than #16. This issue's root cause is , wrong bToken's exchangeRate used in getIsolatedColleteral().Not about old exchangeRate used or not. Moreover without fixing this issue , #16 is not valid because pos.debtToken is updated with poke modifier in liquidate function and its exchangeRate used in getIsolatedColleteralValue() .\n> This issue is about getIsolatedColleteralValue() use debtToken's exchangeRate which is wrong because this functions should use underlyingToken's exchangeRate. So even though #16 is fixed  (there will be no impact without fix this issue.) this issue still remain and changing `ICErc20(banks[pos.debtToken].bToken).exchangeRateStored()` with `ICErc20(banks[pos.underlyingToken].bToken).exchangeRateStored()`   is mandatory to take correct getIsolatedColleteralValue().\n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Shogoki**\n\nNot a duplicate of #16 \n\n**hrishibhat**\n\n@Shogoki is this a valid issue on its own?\n\n**nevillehuang**\n\n> @Shogoki is this a valid issue on its own?\n\n@Gornutz \n\n**hrishibhat**\n\nResult:\nHigh\nUnique\nAfter further review and discussions considering this a valid high issue as the exchange rate can be affected significantly by the tokens decimal and this is not a duplicate of #16 \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [merteren1234](https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/117/#issuecomment-1693539478): accepted\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/104",
  "Code": [
    {
      "filename": "blueberry-core/contracts/BlueBerryBank.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport \"./utils/BlueBerryConst.sol\" as Constants;\nimport \"./utils/BlueBerryErrors.sol\" as Errors;\nimport \"./utils/EnsureApprove.sol\";\nimport \"./utils/ERC1155NaiveReceiver.sol\";\nimport \"./interfaces/IBank.sol\";\nimport \"./interfaces/ICoreOracle.sol\";\nimport \"./interfaces/ISoftVault.sol\";\nimport \"./interfaces/IHardVault.sol\";\nimport \"./interfaces/compound/ICErc20.sol\";\nimport \"./libraries/BBMath.sol\";\n\n /// @title BlueberryBank\n /// @author BlueberryProtocol\n /// @notice Blueberry Bank is the main contract that stores user's positions and track the borrowing of tokens\ncontract BlueBerryBank is\n    OwnableUpgradeable,\n    ERC1155NaiveReceiver,\n    IBank,\n    EnsureApprove\n{\n    using BBMath for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                   PUBLIC STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// Constants for internal usage.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private constant _NO_ID = type(uint256).max;\n    address private constant _NO_ADDRESS = address(1);\n\n    /// Temporary variables used across functions.\n    uint256 public _GENERAL_LOCK;      // TEMPORARY: re-entrancy lock guard.\n    uint256 public _IN_EXEC_LOCK;      // TEMPORARY: exec lock guard.\n    uint256 public POSITION_ID;        // TEMPORARY: position ID currently under execution.\n    address public SPELL;              // TEMPORARY: spell currently under execution.\n\n    /// Configurations and oracle addresses.\n    IProtocolConfig public config;     /// @dev The protocol config address.\n    ICoreOracle public oracle;         /// @dev The main oracle address.\n\n    /// State variables for position and bank.\n    uint256 public nextPositionId;        /// Next available position ID, starting from 1 (see initialize).\n    uint256 public bankStatus;            /// Each bit stores certain bank status, e.g. borrow allowed, repay allowed\n    uint256 public repayResumedTimestamp; /// Timestamp that repay is allowed or resumed\n\n    /// Collections of banks and positions.\n    address[] public allBanks;                     /// The list of all listed banks.\n    mapping(address => Bank) public banks;         /// Mapping from token to bank data.\n    mapping(address => bool) public bTokenInBank;  /// Mapping from bToken to its existence in bank.\n    mapping(uint256 => Position) public positions; /// Mapping from position ID to position data.\n\n    /// Flags and whitelists\n    bool public allowContractCalls; // The boolean status whether to allow call from contract (false = onlyEOA)\n    mapping(address => bool) public whitelistedTokens;        /// Mapping from token to whitelist status\n    mapping(address => bool) public whitelistedWrappedTokens; /// Mapping from token to whitelist status\n    mapping(address => bool) public whitelistedSpells;        /// Mapping from spell to whitelist status\n    mapping(address => bool) public whitelistedContracts;     /// Mapping from user to whitelist status\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      MODIFIERS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Ensure that the function is called from EOA\n    /// when allowContractCalls is set to false and caller is not whitelisted\n    modifier onlyEOAEx() {\n        if (!allowContractCalls && !whitelistedContracts[msg.sender]) {\n            if (AddressUpgradeable.isContract(msg.sender))\n                revert Errors.NOT_EOA(msg.sender);\n        }\n        _;\n    }\n\n    /// @dev Ensure that the token is already whitelisted\n    modifier onlyWhitelistedToken(address token) {\n        if (!whitelistedTokens[token])\n            revert Errors.TOKEN_NOT_WHITELISTED(token);\n        _;\n    }\n\n    /// @dev Ensure that the wrapped ERC1155 is already whitelisted\n    modifier onlyWhitelistedERC1155(address token) {\n        if (!whitelistedWrappedTokens[token])\n            revert Errors.TOKEN_NOT_WHITELISTED(token);\n        _;\n    }\n\n    /// @dev Reentrancy lock guard.\n    modifier lock() {\n        if (_GENERAL_LOCK != _NOT_ENTERED) revert Errors.LOCKED();\n        _GENERAL_LOCK = _ENTERED;\n        _;\n        _GENERAL_LOCK = _NOT_ENTERED;\n    }\n\n    /// @dev Ensure that the function is called from within the execution scope.\n    modifier inExec() {\n        if (POSITION_ID == _NO_ID) revert Errors.NOT_IN_EXEC();\n        if (SPELL != msg.sender) revert Errors.NOT_FROM_SPELL(msg.sender);\n        if (_IN_EXEC_LOCK != _NOT_ENTERED) revert Errors.LOCKED();\n        _IN_EXEC_LOCK = _ENTERED;\n        _;\n        _IN_EXEC_LOCK = _NOT_ENTERED;\n    }\n\n    /// @dev Ensure that the interest rate of the given token is accrued.\n    modifier poke(address token) {\n        accrue(token);\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Initialize the bank smart contract, using msg.sender as the first governor.\n    /// @dev Emits a {SetOracle} event.\n    /// @param oracle_ The oracle smart contract address.\n    /// @param config_ The Protocol config address\n    function initialize(\n        ICoreOracle oracle_,\n        IProtocolConfig config_\n    ) external initializer {\n        __Ownable_init();\n        if (address(oracle_) == address(0) || address(config_) == address(0)) {\n            revert Errors.ZERO_ADDRESS();\n        }\n        _GENERAL_LOCK = _NOT_ENTERED;\n        _IN_EXEC_LOCK = _NOT_ENTERED;\n        POSITION_ID = _NO_ID;\n        SPELL = _NO_ADDRESS;\n\n        config = config_;\n        oracle = oracle_;\n\n        nextPositionId = 1;\n        bankStatus = 15; // 0x1111: allow borrow, repay, lend, withdrawLend as default\n\n        emit SetOracle(address(oracle_));\n    }\n\n    /// @notice Fetches the executor of the current position.\n    /// @dev An executor is the owner of the current position.\n    /// @return Address of the executor.\n    function EXECUTOR() external view override returns (address) {\n        uint256 positionId = POSITION_ID;\n        if (positionId == _NO_ID) {\n            revert Errors.NOT_UNDER_EXECUTION();\n        }\n        return positions[positionId].owner;\n    }\n\n    /// @dev Toggles the allowance of contract calls.\n    /// @param ok If true, contract calls are allowed. Otherwise, only EOA calls are allowed.\n    function setAllowContractCalls(bool ok) external onlyOwner {\n        allowContractCalls = ok;\n    }\n\n    /// @dev Sets whitelist statuses for various contracts.\n    /// @param contracts List of contract addresses.\n    /// @param statuses Corresponding list of whitelist statuses to set.\n    function whitelistContracts(\n        address[] calldata contracts,\n        bool[] calldata statuses\n    ) external onlyOwner {\n        if (contracts.length != statuses.length) {\n            revert Errors.INPUT_ARRAY_MISMATCH();\n        }\n        for (uint256 idx = 0; idx < contracts.length; idx++) {\n            if (contracts[idx] == address(0)) {\n                revert Errors.ZERO_ADDRESS();\n            }\n            whitelistedContracts[contracts[idx]] = statuses[idx];\n        }\n    }\n\n    /// @dev Set the whitelist status for specific spells.\n    /// @param spells Array of spell addresses to change their whitelist status.\n    /// @param statuses Array of boolean values indicating the desired whitelist status for each spell.\n    function whitelistSpells(\n        address[] calldata spells,\n        bool[] calldata statuses\n    ) external onlyOwner {\n        if (spells.length != statuses.length) {\n            revert Errors.INPUT_ARRAY_MISMATCH();\n        }\n        for (uint256 idx = 0; idx < spells.length; idx++) {\n            if (spells[idx] == address(0)) {\n                revert Errors.ZERO_ADDRESS();\n            }\n            whitelistedSpells[spells[idx]] = statuses[idx];\n        }\n    }\n\n    /// @dev Set the whitelist status for specific tokens.\n    /// @param tokens Array of token addresses to change their whitelist status.\n    /// @param statuses Array of boolean values indicating the desired whitelist status for each token.\n    function whitelistTokens(\n        address[] calldata tokens,\n        bool[] calldata statuses\n    ) external onlyOwner {\n        if (tokens.length != statuses.length) {\n            revert Errors.INPUT_ARRAY_MISMATCH();\n        }\n        for (uint256 idx = 0; idx < tokens.length; idx++) {\n            if (statuses[idx] && !oracle.isTokenSupported(tokens[idx]))\n                revert Errors.ORACLE_NOT_SUPPORT(tokens[idx]);\n            whitelistedTokens[tokens[idx]] = statuses[idx];\n            emit SetWhitelistToken(tokens[idx], statuses[idx]);\n        }\n    }\n\n    /// @dev Set the whitelist status for specific wrapped tokens (ERC1155).\n    /// @param tokens Array of wrapped token addresses to set their whitelist status.\n    /// @param ok Boolean indicating the desired whitelist status for the provided tokens.\n    function whitelistERC1155(\n        address[] memory tokens,\n        bool ok\n    ) external onlyOwner {\n        for (uint256 idx = 0; idx < tokens.length; idx++) {\n            address token = tokens[idx];\n            if (token == address(0)) revert Errors.ZERO_ADDRESS();\n            whitelistedWrappedTokens[token] = ok;\n            emit SetWhitelistERC1155(token, ok);\n        }\n    }\n\n    /// @dev Add a new bank entity with associated vaults.\n    /// @dev Emits a {AddBank} event.\n    /// @param token Address of the underlying token for the bank.\n    /// @param softVault Address of the softVault.\n    /// @param hardVault Address of the hardVault.\n    /// @param liqThreshold Liquidation threshold.\n    function addBank(\n        address token,\n        address softVault,\n        address hardVault,\n        uint256 liqThreshold\n    ) external onlyOwner onlyWhitelistedToken(token) {\n        if (softVault == address(0) || hardVault == address(0))\n            revert Errors.ZERO_ADDRESS();\n        if (liqThreshold > Constants.DENOMINATOR)\n            revert Errors.LIQ_THRESHOLD_TOO_HIGH(liqThreshold);\n        if (liqThreshold < Constants.MIN_LIQ_THRESHOLD)\n            revert Errors.LIQ_THRESHOLD_TOO_LOW(liqThreshold);\n\n        Bank storage bank = banks[token];\n        address bToken = address(ISoftVault(softVault).bToken());\n\n        if (bTokenInBank[bToken]) revert Errors.BTOKEN_ALREADY_ADDED();\n        if (bank.isListed) revert Errors.BANK_ALREADY_LISTED();\n        if (allBanks.length >= 256) revert Errors.BANK_LIMIT();\n\n        bTokenInBank[bToken] = true;\n        bank.isListed = true;\n        bank.index = uint8(allBanks.length);\n        bank.bToken = bToken;\n        bank.softVault = softVault;\n        bank.hardVault = hardVault;\n        bank.liqThreshold = liqThreshold;\n\n        IHardVault(hardVault).setApprovalForAll(hardVault, true);\n        allBanks.push(token);\n\n        emit AddBank(token, bToken, softVault, hardVault);\n    }\n\n    /// @dev Update the bank's operational status flags.\n    /// @param _bankStatus The new status flags for the bank.\n    function setBankStatus(uint256 _bankStatus) external onlyOwner {\n        bool repayAllowedStatusBefore = isRepayAllowed();\n        bankStatus = _bankStatus;\n        bool repayAllowedStatusAfter = isRepayAllowed();\n\n        /// If the repayAllowed status changes from \"off\" to \"on\", update the timestamp.\n        if (!repayAllowedStatusBefore && repayAllowedStatusAfter) {\n            repayResumedTimestamp = block.timestamp;\n        }\n    }\n\n    /// @dev Determine if borrowing is currently allowed based on the bank's status flags.\n    /// @notice Check the last bit of bankStatus.\n    /// @return A boolean indicating whether borrowing is permitted.\n    function isBorrowAllowed() public view returns (bool) {\n        return (bankStatus & 0x01) > 0;\n    }\n\n    /// @dev Determine if repayments are currently allowed based on the bank's status flags.\n    /// @notice Check the second-to-last bit of bankStatus.\n    /// @return A boolean indicating whether repayments are permitted.\n    function isRepayAllowed() public view returns (bool) {\n        return (bankStatus & 0x02) > 0;\n    }\n\n    /// @dev Determine if lending is currently allowed based on the bank's status flags.\n    /// @notice Check the third-to-last bit of bankStatus.\n    /// @return A boolean indicating whether lending is permitted.\n    function isLendAllowed() public view returns (bool) {\n        return (bankStatus & 0x04) > 0;\n    }\n\n    /// @dev Determine if withdrawing from lending is currently allowed based on the bank's status flags.\n    /// @notice Check the fourth-to-last bit of bankStatus.\n    /// @return A boolean indicating whether withdrawing from lending is permitted.\n    function isWithdrawLendAllowed() public view returns (bool) {\n        return (bankStatus & 0x08) > 0;\n    }\n\n    /// @dev Get the current FeeManager interface from the configuration.\n    /// @return An interface representing the current FeeManager.\n    function feeManager() public view returns (IFeeManager) {\n        return config.feeManager();\n    }\n\n    /// @dev Trigger interest accrual for a specific bank.\n    /// @param token The address of the underlying token to trigger the interest accrual.\n    function accrue(address token) public override {\n        Bank storage bank = banks[token];\n        if (!bank.isListed) revert Errors.BANK_NOT_LISTED(token);\n        ICErc20(bank.bToken).borrowBalanceCurrent(address(this));\n    }\n\n    /// @dev Convenient function to trigger interest accrual for multiple banks.\n    /// @param tokens An array of token addresses to trigger interest accrual for.\n    function accrueAll(address[] memory tokens) external {\n        for (uint256 idx = 0; idx < tokens.length; idx++) {\n            accrue(tokens[idx]);\n        }\n    }\n\n    /// @dev Internal function to return the current borrow balance of the given token.\n    /// @param token The token address to query for borrow balance.\n    function _borrowBalanceStored(\n        address token\n    ) internal view returns (uint256) {\n        return ICErc20(banks[token].bToken).borrowBalanceStored(address(this));\n    }\n\n    /// @dev Trigger interest accrual and return the current debt balance for a specific position.\n    /// @param positionId The ID of the position to query for the debt balance.\n    /// The current debt balance for the specified position.\n    function currentPositionDebt(\n        uint256 positionId\n    )\n        external\n        override\n        poke(positions[positionId].debtToken)\n        returns (uint256)\n    {\n        return getPositionDebt(positionId);\n    }\n\n    /// @notice Retrieve the debt of a given position, considering the stored debt interest.\n    /// @dev Should call accrue first to obtain the current debt.\n    /// @param positionId The ID of the position to query.\n    function getPositionDebt(\n        uint256 positionId\n    ) public view returns (uint256 debt) {\n        Position memory pos = positions[positionId];\n        Bank memory bank = banks[pos.debtToken];\n        if (pos.debtShare == 0 || bank.totalShare == 0) {\n            return 0;\n        }\n        debt = (pos.debtShare * _borrowBalanceStored(pos.debtToken)).divCeil(\n            bank.totalShare\n        );\n    }\n\n    /// @dev Retrieve information about a specific bank.\n    /// @param token The token address to query for bank information.\n    /// @return isListed Whether the bank is listed or not.\n    /// @return bToken The address of the bToken associated with the bank.\n    /// @return totalShare The total shares in the bank.\n    function getBankInfo(\n        address token\n    )\n        external\n        view\n        override\n        returns (bool isListed, address bToken, uint256 totalShare)\n    {\n        Bank memory bank = banks[token];\n        return (bank.isListed, bank.bToken, bank.totalShare);\n    }\n\n    /// @dev Fetches details about a specific position using its ID.\n    /// @param positionId Unique identifier of the position.\n    /// @return Position object containing all details about the position.\n    function getPositionInfo(\n        uint256 positionId\n    ) external view override returns (Position memory) {\n        return positions[positionId];\n    }\n\n    /// @dev Fetches details about the current active position.\n    /// @notice This function assumes the presence of an active position and will revert if there's none.\n    /// @return Position object containing all details about the current position.\n    function getCurrentPositionInfo()\n        external\n        view\n        override\n        returns (Position memory)\n    {\n        if (POSITION_ID == _NO_ID) revert Errors.BAD_POSITION(POSITION_ID);\n        return positions[POSITION_ID];\n    }\n\n    /// @dev Computes the total USD value of the collateral of a given position.\n    /// @notice The returned value includes both the collateral and any pending rewards.\n    /// @param positionId ID of the position to compute the value for.\n    /// @return positionValue Total USD value of the collateral and pending rewards.\n    function getPositionValue(\n        uint256 positionId\n    ) public override returns (uint256 positionValue) {\n        Position memory pos = positions[positionId];\n        if (pos.collateralSize == 0) {\n            return 0;\n        } else {\n            if (pos.collToken == address(0))\n                revert Errors.BAD_COLLATERAL(positionId);\n            uint256 collValue = oracle.getWrappedTokenValue(\n                pos.collToken,\n                pos.collId,\n                pos.collateralSize\n            );\n\n            uint rewardsValue;\n            (address[] memory tokens, uint256[] memory rewards) = IERC20Wrapper(\n                pos.collToken\n            ).pendingRewards(pos.collId, pos.collateralSize);\n            for (uint256 i; i < tokens.length; i++) {\n                if (oracle.isTokenSupported(tokens[i])) {\n                    rewardsValue += oracle.getTokenValue(tokens[i], rewards[i]);\n                }\n            }\n\n            return collValue + rewardsValue;\n        }\n    }\n\n    /// @dev Computes the total USD value of the debt of a given position.\n    /// @notice Ensure to call `accrue` beforehand to account for any interest changes.\n    /// @param positionId ID of the position to compute the debt value for.\n    /// @return debtValue Total USD value of the position's debt.\n    function getDebtValue(\n        uint256 positionId\n    ) public override returns (uint256 debtValue) {\n        Position memory pos = positions[positionId];\n        uint256 debt = getPositionDebt(positionId);\n        debtValue = oracle.getTokenValue(pos.debtToken, debt);\n    }\n\n    /// @dev Computes the USD value of the isolated collateral for a given position.\n    /// @notice Ensure to call `accrue` beforehand to get the most recent value.\n    /// @param positionId ID of the position to compute the isolated collateral value for.\n    /// @return icollValue USD value of the isolated collateral.\n    function getIsolatedCollateralValue(\n        uint256 positionId\n    ) public override returns (uint256 icollValue) {\n        Position memory pos = positions[positionId];\n        /// NOTE: exchangeRateStored has 18 decimals.\n        uint256 underlyingAmount;\n        if (_isSoftVault(pos.underlyingToken)) {\n            underlyingAmount =\n                (ICErc20(banks[pos.debtToken].bToken).exchangeRateStored() *\n                    pos.underlyingVaultShare) /\n                Constants.PRICE_PRECISION;\n        } else {\n            underlyingAmount = pos.underlyingVaultShare;\n        }\n        icollValue = oracle.getTokenValue(\n            pos.underlyingToken,\n            underlyingAmount\n        );\n    }\n\n    /// @dev Computes the risk ratio of a specified position.\n    /// @notice A higher risk ratio implies greater risk associated with the position.\n    ///         when:  riskRatio = (ov - pv) / cv\n    ///         where: riskRatio = (debt - positionValue) / isolatedCollateralValue\n    /// @param positionId ID of the position to assess risk for.\n    /// @return risk The risk ratio of the position (based on a scale of 1e4).\n    function getPositionRisk(uint256 positionId) public returns (uint256 risk) {\n        uint256 pv = getPositionValue(positionId);\n        uint256 ov = getDebtValue(positionId);\n        uint256 cv = getIsolatedCollateralValue(positionId);\n\n        if (\n            (cv == 0 && pv == 0 && ov == 0) || pv >= ov /// Closed position or Overcollateralized position\n        ) {\n            risk = 0;\n        } else if (cv == 0) {\n            /// Sth bad happened to isolated underlying token\n            risk = Constants.DENOMINATOR;\n        } else {\n            risk = ((ov - pv) * Constants.DENOMINATOR) / cv;\n        }\n    }\n\n    /// @dev Determines if a given position can be liquidated based on its risk ratio.\n    /// @param positionId ID of the position to check.\n    /// @return True if the position can be liquidated; otherwise, false.\n    function isLiquidatable(uint256 positionId) public returns (bool) {\n        return\n            getPositionRisk(positionId) >=\n            banks[positions[positionId].underlyingToken].liqThreshold;\n    }\n\n    /// @dev Liquidates a position by repaying its debt and taking the collateral.\n    /// @dev Emits a {Liquidate} event.\n    /// @notice Liquidation can only be triggered if the position is deemed liquidatable \n    ///         and other conditions are met.\n    /// @param positionId The unique identifier of the position to liquidate.\n    /// @param debtToken The token in which the debt is denominated.\n    /// @param amountCall The amount of debt to be repaid when calling transferFrom.\n    function liquidate(\n        uint256 positionId,\n        address debtToken,\n        uint256 amountCall\n    ) external override lock poke(debtToken) {\n        /// Ensures repayments are allowed at the moment of calling this function.\n        if (!isRepayAllowed()) revert Errors.REPAY_NOT_ALLOWED();\n        /// Ensures a non-zero repayment amount is specified.\n        if (amountCall == 0) revert Errors.ZERO_AMOUNT();\n        /// Ensures the position is liquidatable.\n        if (!isLiquidatable(positionId))\n            revert Errors.NOT_LIQUIDATABLE(positionId);\n\n        /// Retrieve the position and associated bank data.\n        Position storage pos = positions[positionId];\n        Bank memory bank = banks[pos.underlyingToken];\n        /// Ensure the position has valid collateral.\n        if (pos.collToken == address(0))\n            revert Errors.BAD_COLLATERAL(positionId);\n\n        /// Revert liquidation if the repayment hasn't been warmed up \n        /// following the last state where repayments were paused.\n        if (\n            block.timestamp <\n            repayResumedTimestamp + Constants.LIQUIDATION_REPAY_WARM_UP_PERIOD\n        ) revert Errors.REPAY_ALLOW_NOT_WARMED_UP();\n\n        /// Repay the debt and get details of repayment.\n        uint256 oldShare = pos.debtShare;\n        (uint256 amountPaid, uint256 share) = _repay(\n            positionId,\n            debtToken,\n            amountCall\n        );\n\n        /// Calculate the size of collateral and underlying vault share that the liquidator will get.\n        uint256 liqSize = (pos.collateralSize * share) / oldShare;\n        uint256 uVaultShare = (pos.underlyingVaultShare * share) / oldShare;\n\n        /// Adjust the position's debt and collateral after liquidation.\n        pos.collateralSize -= liqSize;\n        pos.underlyingVaultShare -= uVaultShare;\n\n        /// Transfer the liquidated collateral (Wrapped LP Tokens) to the liquidator.\n        IERC1155Upgradeable(pos.collToken).safeTransferFrom(\n            address(this),\n            msg.sender,\n            pos.collId,\n            liqSize,\n            \"\"\n        );\n        /// Transfer underlying collaterals(vault share tokens) to liquidator\n        if (_isSoftVault(pos.underlyingToken)) {\n            IERC20Upgradeable(bank.softVault).safeTransfer(\n                msg.sender,\n                uVaultShare\n            );\n        } else {\n            IERC1155Upgradeable(bank.hardVault).safeTransferFrom(\n                address(this),\n                msg.sender,\n                uint256(uint160(pos.underlyingToken)),\n                uVaultShare,\n                \"\"\n            );\n        }\n\n        /// Emit an event capturing details of the liquidation process.\n        emit Liquidate(\n            positionId,\n            msg.sender,\n            debtToken,\n            amountPaid,\n            share,\n            liqSize,\n            uVaultShare\n        );\n    }\n\n    /// @dev Executes a specific action on a position.\n    /// @dev Emit an {Execute} event.\n    /// @notice This can be used for various operations like adjusting collateral, repaying debt, etc.\n    /// @param positionId Unique identifier of the position, or zero for a new position.\n    /// @param spell Address of the contract (\"spell\") that contains the logic for the action to be executed.\n    /// @param data Data payload to pass to the spell for execution.\n    function execute(\n        uint256 positionId,\n        address spell,\n        bytes memory data\n    ) external lock onlyEOAEx returns (uint256) {\n        if (!whitelistedSpells[spell])\n            revert Errors.SPELL_NOT_WHITELISTED(spell);\n        if (positionId == 0) {\n            positionId = nextPositionId++;\n            positions[positionId].owner = msg.sender;\n        } else {\n            if (positionId >= nextPositionId)\n                revert Errors.BAD_POSITION(positionId);\n            if (msg.sender != positions[positionId].owner)\n                revert Errors.NOT_FROM_OWNER(positionId, msg.sender);\n        }\n        POSITION_ID = positionId;\n        SPELL = spell;\n\n        (bool ok, bytes memory returndata) = SPELL.call(data);\n        if (!ok) {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(\"bad cast call\");\n            }\n        }\n\n        if (isLiquidatable(positionId)) revert Errors.INSUFFICIENT_COLLATERAL();\n\n        POSITION_ID = _NO_ID;\n        SPELL = _NO_ADDRESS;\n\n        emit Execute(positionId, msg.sender);\n\n        return positionId;\n    }\n\n    /// @dev Lend tokens to the bank as isolated collateral.\n    /// @dev Emit a {Lend} event.\n    /// @notice The tokens lent will be used as collateral in the bank and might earn interest or other rewards.\n    /// @param token The address of the token to lend.\n    /// @param amount The number of tokens to lend.\n    function lend(\n        address token,\n        uint256 amount\n    ) external override inExec poke(token) onlyWhitelistedToken(token) {\n        if (!isLendAllowed()) revert Errors.LEND_NOT_ALLOWED();\n\n        Position storage pos = positions[POSITION_ID];\n        Bank storage bank = banks[token];\n        if (pos.underlyingToken != address(0)) {\n            /// already have isolated collateral, allow same isolated collateral\n            if (pos.underlyingToken != token)\n                revert Errors.INCORRECT_UNDERLYING(token);\n        } else {\n            pos.underlyingToken = token;\n        }\n\n        IERC20Upgradeable(token).safeTransferFrom(\n            pos.owner,\n            address(this),\n            amount\n        );\n        _ensureApprove(token, address(feeManager()), amount);\n        amount = feeManager().doCutDepositFee(token, amount);\n\n        if (_isSoftVault(token)) {\n            _ensureApprove(token, bank.softVault, amount);\n            pos.underlyingVaultShare += ISoftVault(bank.softVault).deposit(\n                amount\n            );\n        } else {\n            _ensureApprove(token, bank.hardVault, amount);\n            pos.underlyingVaultShare += IHardVault(bank.hardVault).deposit(\n                token,\n                amount\n            );\n        }\n\n        emit Lend(POSITION_ID, msg.sender, token, amount);\n    }\n\n    /// @dev Withdraw isolated collateral tokens previously lent to the bank.\n    /// @dev Emit a {WithdrawLend} event.\n    /// @notice This will reduce the isolated collateral and might also reduce the position's overall health.\n    /// @param token The address of the isolated collateral token to withdraw.\n    /// @param shareAmount The number of vault share tokens to withdraw.\n    function withdrawLend(\n        address token,\n        uint256 shareAmount\n    ) external override inExec poke(token) {\n        if (!isWithdrawLendAllowed()) revert Errors.WITHDRAW_LEND_NOT_ALLOWED();\n        Position storage pos = positions[POSITION_ID];\n        Bank memory bank = banks[token];\n        if (token != pos.underlyingToken) revert Errors.INVALID_UTOKEN(token);\n        if (shareAmount == type(uint256).max) {\n            shareAmount = pos.underlyingVaultShare;\n        }\n\n        uint256 wAmount;\n        if (_isSoftVault(token)) {\n            _ensureApprove(bank.softVault, bank.softVault, shareAmount);\n            wAmount = ISoftVault(bank.softVault).withdraw(shareAmount);\n        } else {\n            wAmount = IHardVault(bank.hardVault).withdraw(token, shareAmount);\n        }\n\n        pos.underlyingVaultShare -= shareAmount;\n\n        _ensureApprove(token, address(feeManager()), wAmount);\n        wAmount = feeManager().doCutWithdrawFee(token, wAmount);\n\n        IERC20Upgradeable(token).safeTransfer(msg.sender, wAmount);\n\n        emit WithdrawLend(POSITION_ID, msg.sender, token, wAmount);\n    }\n\n    /// @notice Allows users to borrow tokens from the specified bank.\n    /// @dev This function must only be called from a spell while under execution.\n    /// @dev Emit a {Borrow} event.\n    /// @param token The token to borrow from the bank.\n    /// @param amount The amount of tokens the user wishes to borrow.\n    /// @return borrowedAmount Returns the actual amount borrowed from the bank.\n    function borrow(\n        address token,\n        uint256 amount\n    )\n        external\n        override\n        inExec\n        poke(token)\n        onlyWhitelistedToken(token)\n        returns (uint256 borrowedAmount)\n    {\n        if (!isBorrowAllowed()) revert Errors.BORROW_NOT_ALLOWED();\n        Bank storage bank = banks[token];\n        Position storage pos = positions[POSITION_ID];\n        if (pos.debtToken != address(0)) {\n            /// already have some debts, allow same debt token\n            if (pos.debtToken != token) revert Errors.INCORRECT_DEBT(token);\n        } else {\n            pos.debtToken = token;\n        }\n\n        uint256 totalShare = bank.totalShare;\n        uint256 totalDebt = _borrowBalanceStored(token);\n        uint256 share = totalShare == 0\n            ? amount\n            : (amount * totalShare).divCeil(totalDebt);\n        if (share == 0) revert Errors.BORROW_ZERO_SHARE(amount);\n        bank.totalShare += share;\n        pos.debtShare += share;\n\n        borrowedAmount = _doBorrow(token, amount);\n        IERC20Upgradeable(token).safeTransfer(msg.sender, borrowedAmount);\n\n        emit Borrow(POSITION_ID, msg.sender, token, amount, share);\n    }\n\n    /// @notice Allows users to repay their borrowed tokens to the bank.\n    /// @dev This function must only be called while under execution.\n    /// @dev Emit a {Repay} event.\n    /// @param token The token to repay to the bank.\n    /// @param amountCall The amount of tokens to be repaid.\n    functio"
    }
  ]
}