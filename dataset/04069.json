{
  "Title": "[L05] Missing error messages in require statements",
  "Content": "Throughout the codebase, there are several require statements which lack error messages. For example:\n\n\n* On [line 786 of `Escrow.sol`](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/Escrow.sol#L786).\n* On [line 237 of `Liquidation.sol`](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/utils/Liquidation.sol#L237).\n* On [line 478 of `Liquidation.sol`](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/utils/Liquidation.sol#L478).\n* On [line 536 of `Liquidation.sol`](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/utils/Liquidation.sol#L536).\n* On [line 540 of `Liquidation.sol`](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/utils/Liquidation.sol#L540).\n* On [line 610 of `Liquidation.sol`](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/utils/Liquidation.sol#L610).\n* On [line 162 of `Portfolios.sol`](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/Portfolios.sol#L162).\n* On [line 815 of `Portfolios.sol`](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/Portfolios.sol#L815).\n* On [line 176 of `RiskFramework.sol`](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/utils/RiskFramework.sol#L176).\n\n\nConsider providing specific, informative, and user-friendly error messages with every require statement.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Escrow.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./utils/Governed.sol\";\nimport \"./utils/Liquidation.sol\";\n\nimport \"./lib/SafeInt256.sol\";\nimport \"./lib/SafeMath.sol\";\nimport \"./lib/SafeUInt128.sol\";\nimport \"./lib/SafeERC20.sol\";\n\nimport \"./interface/IERC20.sol\";\nimport \"./interface/IERC777.sol\";\nimport \"./interface/IERC777Recipient.sol\";\nimport \"./interface/IERC1820Registry.sol\";\nimport \"./interface/IAggregator.sol\";\nimport \"./interface/IEscrowCallable.sol\";\nimport \"./interface/IWETH.sol\";\n\nimport \"./storage/EscrowStorage.sol\";\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\n\n/**\n * @title Escrow\n * @notice Manages a account balances for the entire system including deposits, withdraws,\n * cash balances, collateral lockup for trading, cash transfers (settlement), and liquidation.\n */\ncontract Escrow is EscrowStorage, Governed, IERC777Recipient, IEscrowCallable {\n    using SafeUInt128 for uint128;\n    using SafeMath for uint256;\n    using SafeInt256 for int256;\n\n    uint256 private constant UINT256_MAX = 2**256 - 1;\n\n    /**\n     * @dev skip\n     * @param directory reference to other contracts\n     * @param registry ERC1820 registry for ERC777 token standard\n     */\n    function initialize(\n        address directory,\n        address owner,\n        address registry,\n        address weth\n    ) external initializer {\n        Governed.initialize(directory, owner);\n\n        // This registry call is used for the ERC777 token standard.\n        IERC1820Registry(registry).setInterfaceImplementer(address(0), TOKENS_RECIPIENT_INTERFACE_HASH, address(this));\n\n        // List ETH as the zero currency\n        WETH = weth;\n        currencyIdToAddress[0] = WETH;\n        addressToCurrencyId[WETH] = 0;\n        currencyIdToDecimals[0] = Common.DECIMALS;\n        emit NewCurrency(WETH);\n    }\n\n    /********** Events *******************************/\n\n    /**\n     * @notice A new currency\n     * @param token address of the tradable token\n     */\n    event NewCurrency(address indexed token);\n\n    /**\n     * @notice A new exchange rate between two currencies\n     * @param base id of the base currency\n     * @param quote id of the quote currency\n     */\n    event UpdateExchangeRate(uint16 indexed base, uint16 indexed quote);\n\n    /**\n     * @notice Notice of a deposit made to an account\n     * @param currency currency id of the deposit\n     * @param account address of the account where the deposit was made\n     * @param value amount of tokens deposited\n     */\n    event Deposit(uint16 indexed currency, address account, uint256 value);\n\n    /**\n     * @notice Notice of a withdraw from an account\n     * @param currency currency id of the withdraw\n     * @param account address of the account where the withdraw was made\n     * @param value amount of tokens withdrawn\n     */\n    event Withdraw(uint16 indexed currency, address account, uint256 value);\n\n    /**\n     * @notice Notice of a successful liquidation. `msg.sender` will be the liquidator.\n     * @param localCurrency currency that was liquidated\n     * @param collateralCurrency currency that was exchanged for the local currency\n     * @param account the account that was liquidated\n     * @param amountRecollateralized the amount of local currency that recollateralized\n     */\n    event Liquidate(uint16 indexed localCurrency, uint16 collateralCurrency, address account, uint128 amountRecollateralized);\n\n    /**\n     * @notice Notice of a successful batch liquidation. `msg.sender` will be the liquidator.\n     * @param localCurrency currency that was liquidated\n     * @param collateralCurrency currency that was exchanged for the local currency\n     * @param accounts the accounts that were liquidated\n     * @param amountRecollateralized the amount of local currency that recollateralized\n     */\n    event LiquidateBatch(\n        uint16 indexed localCurrency,\n        uint16 collateralCurrency,\n        address[] accounts,\n        uint128[] amountRecollateralized\n    );\n\n    /**\n     * @notice Notice of a successful cash settlement. `msg.sender` will be the settler.\n     * @param localCurrency currency that was settled\n     * @param collateralCurrency currency that was exchanged for the local currency\n     * @param payer the account that paid in the settlement\n     * @param settledAmount the amount settled between the parties\n     */\n    event SettleCash(\n        uint16 localCurrency,\n        uint16 collateralCurrency,\n        address indexed payer,\n        uint128 settledAmount\n    );\n\n    /**\n     * @notice Notice of a successful batch cash settlement. `msg.sender` will be the settler.\n     * @param localCurrency currency that was settled\n     * @param collateralCurrency currency that was exchanged for the local currency\n     * @param payers the accounts that paid in the settlement\n     * @param settledAmounts the amounts settled between the parties\n     */\n    event SettleCashBatch(\n        uint16 localCurrency,\n        uint16 collateralCurrency,\n        address[] payers,\n        uint128[] settledAmounts\n    );\n\n    /**\n     * @notice Emitted when liquidation and settlement discounts are set\n     * @param liquidationDiscount discount given to liquidators when purchasing collateral\n     * @param settlementDiscount discount given to settlers when purchasing collateral\n     * @param repoIncentive incentive given to liquidators for pulling liquidity tokens to recollateralize an account\n     */\n    event SetDiscounts(uint128 liquidationDiscount, uint128 settlementDiscount, uint128 repoIncentive);\n\n    /**\n     * @notice Emitted when reserve account is set\n     * @param reserveAccount account that holds balances in reserve\n     */\n    event SetReserve(address reserveAccount);\n\n    /********** Events *******************************/\n\n    /********** Governance Settings ******************/\n\n    /**\n     * @notice Sets a local cached version of the G_LIQUIDITY_HAIRCUT on the RiskFramework contract. This will be\n     * used locally in the settlement and liquidation calculations when we pull local currency liquidity tokens.\n     * @dev skip\n     */\n    function setLiquidityHaircut(uint128 haircut) external override {\n        require(calledByPortfolios(), $$(ErrorCode(UNAUTHORIZED_CALLER)));\n        EscrowStorageSlot._setLiquidityHaircut(haircut);\n    }\n\n    /**\n     * @notice Sets discounts applied when purchasing collateral during liquidation or settlement. Discounts are\n     * represented as percentages multiplied by 1e18. For example, a 5% discount for liquidators will be set as\n     * 1.05e18\n     * @dev governance\n     * @param liquidation discount applied to liquidation\n     * @param settlement discount applied to settlement\n     * @param repoIncentive incentive to repo liquidity tokens\n     */\n    function setDiscounts(uint128 liquidation, uint128 settlement, uint128 repoIncentive) external onlyOwner {\n        EscrowStorageSlot._setLiquidationDiscount(liquidation);\n        EscrowStorageSlot._setSettlementDiscount(settlement);\n        EscrowStorageSlot._setLiquidityTokenRepoIncentive(repoIncentive);\n\n        emit SetDiscounts(liquidation, settlement, repoIncentive);\n    }\n\n    /**\n     * @notice Sets the reserve account used to settle against for insolvent accounts\n     * @dev governance\n     * @param account address of reserve account\n     */\n    function setReserveAccount(address account) external onlyOwner {\n        G_RESERVE_ACCOUNT = account;\n\n        emit SetReserve(account);\n    }\n\n    /**\n     * @notice Lists a new currency for deposits\n     * @dev governance\n     * @param token address of ERC20 or ERC777 token to list\n     * @param options a set of booleans that describe the token\n     */\n    function listCurrency(address token, TokenOptions memory options) public onlyOwner {\n        require(addressToCurrencyId[token] == 0 && token != WETH, $$(ErrorCode(INVALID_CURRENCY)));\n\n        maxCurrencyId++;\n        // We don't do a lot of checking here but since this is purely an administrative\n        // activity we just rely on governance not to set this improperly.\n        currencyIdToAddress[maxCurrencyId] = token;\n        addressToCurrencyId[token] = maxCurrencyId;\n        tokenOptions[token] = options;\n        uint256 decimals = IERC20(token).decimals();\n        currencyIdToDecimals[maxCurrencyId] = 10**(decimals);\n        // We need to set this number so that the free collateral check can provision\n        // the right number of currencies.\n        Portfolios().setNumCurrencies(maxCurrencyId);\n\n        emit NewCurrency(token);\n    }\n\n    /**\n     * @notice Creates an exchange rate between two currencies.\n     * @dev governance\n     * @param base the base currency\n     * @param quote the quote currency\n     * @param rateOracle the oracle that will give the exchange rate between the two\n     * @param buffer multiple to apply to the exchange rate that sets the collateralization ratio\n     * @param rateDecimals decimals of precision that the rate oracle uses\n     * @param mustInvert true if the chainlink oracle must be inverted\n     */\n    function addExchangeRate(\n        uint16 base,\n        uint16 quote,\n        address rateOracle,\n        uint128 buffer,\n        uint128 rateDecimals,\n        bool mustInvert\n    ) external onlyOwner {\n        // We require that exchange rate buffers are always greater than the settlement discount. The reason is\n        // that if this is not the case, it opens up the possibility that free collateral actually ends up in a worse\n        // position in the event of a third party settlement.\n        require(buffer > G_SETTLEMENT_DISCOUNT(), $$(ErrorCode(INVALID_HAIRCUT_SIZE)));\n        exchangeRateOracles[base][quote] = ExchangeRate.Rate(\n            rateOracle,\n            rateDecimals,\n            mustInvert,\n            buffer\n        );\n\n        emit UpdateExchangeRate(base, quote);\n    }\n\n    /********** Governance Settings ******************/\n\n    /********** Getter Methods ***********************/\n\n    /**\n     * @notice Evaluates whether or not a currency id is valid\n     * @param currency currency id\n     * @return true if the currency is valid\n     */\n    function isValidCurrency(uint16 currency) public override view returns (bool) {\n        return currency <= maxCurrencyId;\n    }\n\n    /**\n     * @notice Getter method for exchange rates\n     * @param base token address for the base currency\n     * @param quote token address for the quote currency\n     * @return ExchangeRate struct\n     */\n    function getExchangeRate(uint16 base, uint16 quote) external view returns (ExchangeRate.Rate memory) {\n        return exchangeRateOracles[base][quote];\n    }\n\n    /**\n     * @notice Returns the net balances of all the currencies owned by an account as\n     * an array. Each index of the array refers to the currency id.\n     * @param account the account to query\n     * @return the balance of each currency net of the account's cash position\n     */\n    function getBalances(address account) external override view returns (int256[] memory) {\n        // We add one here because the zero currency index is unused\n        int256[] memory balances = new int256[](maxCurrencyId + 1);\n\n        for (uint256 i; i < balances.length; i++) {\n            balances[i] = cashBalances[uint16(i)][account];\n        }\n\n        return balances;\n    }\n\n    /**\n     * @notice Converts the balances given to ETH for the purposes of determining whether an account has\n     * sufficient free collateral.\n     * @dev - INVALID_CURRENCY: length of the amounts array must match the total number of currencies\n     *  - INVALID_EXCHANGE_RATE: exchange rate returned by the oracle is less than 0\n     * @param amounts the balance in each currency group as an array, each index refers to the currency group id.\n     * @return an array the same length as amounts with each balance denominated in ETH\n     */\n    function convertBalancesToETH(int256[] memory amounts) public override view returns (int256[] memory) {\n        // We expect values for all currencies to be supplied here, we will not do any work on 0 balances.\n        require(amounts.length == maxCurrencyId + 1, $$(ErrorCode(INVALID_CURRENCY)));\n        int256[] memory results = new int256[](amounts.length);\n\n        // Currency ID = 0 is already ETH so we don't need to convert it, unless it is negative. Then we will\n        // haircut it.\n        if (amounts[0] < 0) {\n            // We store the ETH buffer on the exchange rate back to itself.\n            uint128 buffer = exchangeRateOracles[0][0].buffer;\n            results[0] = amounts[0].mul(buffer).div(Common.DECIMALS);\n        } else {\n            results[0] = amounts[0];\n        }\n\n        for (uint256 i = 1; i < amounts.length; i++) {\n            if (amounts[i] == 0) continue;\n\n            ExchangeRate.Rate memory er = exchangeRateOracles[uint16(i)][0];\n            uint256 baseDecimals = currencyIdToDecimals[uint16(i)];\n\n            if (amounts[i] < 0) {\n                // We buffer negative amounts to enforce collateralization ratios\n                results[i] = ExchangeRate._convertToETH(er, baseDecimals, amounts[i], true);\n            } else {\n                // We do not buffer positive amounts so that they can be used to collateralize\n                // other debts.\n                results[i] = ExchangeRate._convertToETH(er, baseDecimals, amounts[i], false);\n            }\n        }\n\n        return results;\n    }\n\n    /********** Getter Methods ***********************/\n\n    /********** Withdraw / Deposit Methods ***********/\n\n    /**\n     * @notice receive fallback for WETH transfers\n     * @dev skip\n     */\n    receive() external payable {\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\n    }\n\n    /**\n     * @notice This is a special function to handle ETH deposits. Value of ETH to be deposited must be specified in `msg.value`\n     * @dev - OVER_MAX_ETH_BALANCE: balance of deposit cannot overflow uint128\n     */\n    function depositEth() external payable {\n        _depositEth(msg.sender);\n    }\n\n    function _depositEth(address to) internal {\n        require(msg.value <= Common.MAX_UINT_128, $$(ErrorCode(OVER_MAX_ETH_BALANCE)));\n        IWETH(WETH).deposit{value: msg.value}();\n\n        cashBalances[0][to] = cashBalances[0][to].add(\n            uint128(msg.value)\n        );\n        emit Deposit(0, to, msg.value);\n    }\n\n    /**\n     * @notice Withdraw ETH from the contract.\n     * @dev - INSUFFICIENT_BALANCE: not enough balance in account\n     * - INSUFFICIENT_FREE_COLLATERAL: not enough free collateral to withdraw\n     * - TRANSFER_FAILED: eth transfer did not return success\n     * @param amount the amount of eth to withdraw from the contract\n     */\n    function withdrawEth(uint128 amount) external {\n        _withdrawEth(msg.sender, amount);\n    }\n\n    function _withdrawEth(address to, uint128 amount) internal {\n        int256 balance = cashBalances[0][to];\n        cashBalances[0][to] = balance.subNoNeg(amount);\n        require(_freeCollateral(to) >= 0, $$(ErrorCode(INSUFFICIENT_FREE_COLLATERAL)));\n\n        IWETH(WETH).withdraw(uint256(amount));\n        // solium-disable-next-line security/no-call-value\n        (bool success, ) = to.call{value: amount}(\"\");\n        require(success, $$(ErrorCode(TRANSFER_FAILED)));\n        emit Withdraw(0, to, amount);\n    }\n\n    /**\n     * @notice Transfers a balance from an ERC20 token contract into the Escrow. Do not call this for ERC777 transfers, use\n     * the `send` method instead.\n     * @dev - INVALID_CURRENCY: token address supplied is not a valid currency\n     * @param token token contract to send from\n     * @param amount tokens to transfer\n     */\n    function deposit(address token, uint128 amount) external {\n        _deposit(msg.sender, token, amount);\n    }\n\n    function _deposit(address from, address token, uint128 amount) internal {\n        uint16 currencyId = addressToCurrencyId[token];\n        if ((currencyId == 0 && token != WETH)) {\n            revert($$(ErrorCode(INVALID_CURRENCY)));\n        }\n\n        TokenOptions memory options = tokenOptions[token];\n        amount = _tokenDeposit(token, from, amount, options);\n        if (!options.isERC777) cashBalances[currencyId][from] = cashBalances[currencyId][from].add(amount);\n\n        emit Deposit(currencyId, from, amount);\n    }\n\n    function _tokenDeposit(\n        address token,\n        address from,\n        uint128 amount,\n        TokenOptions memory options\n    ) internal returns (uint128) {\n        if (options.hasTransferFee) {\n            // If there is a transfer fee we check the pre and post transfer balance to ensure that we increment\n            // the balance by the correct amount after transfer.\n            uint256 preTransferBalance = IERC20(token).balanceOf(address(this));\n            SafeERC20.safeTransferFrom(IERC20(token), from, address(this), amount);\n            uint256 postTransferBalance = IERC20(token).balanceOf(address(this));\n\n            amount = SafeCast.toUint128(postTransferBalance.sub(preTransferBalance));\n        } else if (options.isERC777) {\n            IERC777(token).operatorSend(from, address(this), amount, \"0x\", \"0x\");\n        }else {\n            SafeERC20.safeTransferFrom(IERC20(token), from, address(this), amount);\n        }\n        \n        return amount;\n    }\n\n    /**\n     * @notice Withdraws from an account's collateral holdings back to their account. Checks if the\n     * account has sufficient free collateral after the withdraw or else it fails.\n     * @dev - INSUFFICIENT_BALANCE: not enough balance in account\n     * - INVALID_CURRENCY: token address supplied is not a valid currency\n     * - INSUFFICIENT_FREE_COLLATERAL: not enough free collateral to withdraw\n     * @param token collateral type to withdraw\n     * @param amount total value to withdraw\n     */\n    function withdraw(address token, uint128 amount) external {\n       _withdraw(msg.sender, msg.sender, token, amount, true);\n    }\n\n    function _withdraw(\n        address from,\n        address to,\n        address token,\n        uint128 amount,\n        bool checkFC\n    ) internal {\n        uint16 currencyId = addressToCurrencyId[token];\n        require(token != address(0), $$(ErrorCode(INVALID_CURRENCY)));\n\n        // We settle matured assets before withdraw in case there are matured cash receiver or liquidity\n        // token assets\n        if (checkFC) Portfolios().settleMaturedAssets(from);\n\n        int256 balance = cashBalances[currencyId][from];\n        cashBalances[currencyId][from] = balance.subNoNeg(amount);\n\n        // We're checking this after the withdraw has been done on currency balances. We skip this check\n        // for batch withdraws when we check once after everything is completed.\n        if (checkFC) {\n            (int256 fc, /* int256[] memory */, /* int256[] memory */) = Portfolios().freeCollateralView(from);\n            require(fc >= 0, $$(ErrorCode(INSUFFICIENT_FREE_COLLATERAL)));\n        }\n\n        _tokenWithdraw(token, to, amount);\n\n        emit Withdraw(currencyId, to, amount);\n    }\n\n    function _tokenWithdraw(\n        address token,\n        address to,\n        uint128 amount\n    ) internal {\n        if (tokenOptions[token].isERC777) {\n            IERC777(token).send(to, amount, \"0x\");\n        } else {\n            SafeERC20.safeTransfer(IERC20(token), to, amount);\n        }\n    }\n\n    /**\n     * @notice Deposits on behalf of an account, called via the ERC1155 batchOperation and bridgeTransferFrom.\n     * @dev skip\n     */\n    function depositsOnBehalf(address account, Common.Deposit[] memory deposits) public payable override {\n        require(calledByERC1155Trade(), $$(ErrorCode(UNAUTHORIZED_CALLER)));\n\n        if (msg.value != 0) {\n            _depositEth(account);\n        }\n\n        for (uint256 i; i < deposits.length; i++) {\n            address tokenAddress = currencyIdToAddress[deposits[i].currencyId];\n            _deposit(account, tokenAddress, deposits[i].amount);\n        }\n    }\n\n    /**\n     * @notice Withdraws on behalf of an account, called via the ERC1155 batchOperation and bridgeTransferFrom. Note that\n     * this does not handle non-WETH withdraws.\n     * @dev skip\n     */\n    function withdrawsOnBehalf(address account, Common.Withdraw[] memory withdraws) public override {\n        require(calledByERC1155Trade(), $$(ErrorCode(UNAUTHORIZED_CALLER)));\n\n        for (uint256 i; i < withdraws.length; i++) {\n            address tokenAddress = currencyIdToAddress[withdraws[i].currencyId];\n            uint128 amount;\n\n            if (withdraws[i].amount == 0) {\n                // If the amount is zero then we skip.\n                continue;\n            } else {\n                amount = withdraws[i].amount;\n            }\n\n            // We skip the free collateral check here because ERC1155.batchOperation will do the check\n            // before it exits.\n            _withdraw(account, withdraws[i].to, tokenAddress, amount, false);\n        }\n    }\n\n    /**\n     * @notice Receives tokens from an ERC777 send message.\n     * @dev skip\n     * @param from address the tokens are being sent from (!= msg.sender)\n     * @param amount amount\n     */\n    function tokensReceived(\n        address, /*operator*/\n        address from,\n        address, /*to*/\n        uint256 amount,\n        bytes calldata, /*userData*/\n        bytes calldata /*operatorData*/\n    ) external override {\n        uint16 currencyId = addressToCurrencyId[msg.sender];\n        require(currencyId != 0, $$(ErrorCode(INVALID_CURRENCY)));\n        cashBalances[currencyId][from] = cashBalances[currencyId][from].add(SafeCast.toUint128(amount));\n\n        emit Deposit(currencyId, from, amount);\n    }\n\n    /********** Withdraw / Deposit Methods ***********/\n\n    /********** Cash Management *********/\n\n    /**\n     * @notice Transfers the cash required between the Market and the specified account. Cash\n     * held by the Market is available to purchase in the liquidity pools.\n     * @dev skip\n     * @param account the account to withdraw collateral from\n     * @param cashGroupId the cash group used to authenticate the fCash market\n     * @param value the amount of collateral to deposit\n     * @param fee the amount of `value` to pay as a fee\n     */\n    function depositIntoMarket(\n        address account,\n        uint8 cashGroupId,\n        uint128 value,\n        uint128 fee\n    ) external override {\n        // Only the fCash market is allowed to call this function.\n        Common.CashGroup memory cg = Portfolios().getCashGroup(cashGroupId);\n        require(msg.sender == cg.cashMarket, $$(ErrorCode(UNAUTHORIZED_CALLER)));\n\n        if (fee > 0) {\n            cashBalances[cg.currency][G_RESERVE_ACCOUNT] = cashBalances[cg.currency][G_RESERVE_ACCOUNT]\n                .add(fee);\n        }\n\n        cashBalances[cg.currency][msg.sender] = cashBalances[cg.currency][msg.sender].add(value);\n        int256 balance = cashBalances[cg.currency][account];\n        cashBalances[cg.currency][account] = balance.subNoNeg(value.add(fee));\n    }\n\n    /**\n     * @notice Transfers the cash required between the Market and the specified account. Cash\n     * held by the Market is available to purchase in the liquidity pools.\n     * @dev skip\n     * @param account the account to withdraw cash from\n     * @param cashGroupId the cash group used to authenticate the fCash market\n     * @param value the amount of cash to deposit\n     * @param fee the amount of `value` to pay as a fee\n     */\n    function withdrawFromMarket(\n        address account,\n        uint8 cashGroupId,\n        uint128 value,\n        uint128 fee\n    ) external override {\n        // Only the fCash market is allowed to call this function.\n        Common.CashGroup memory cg = Portfolios().getCashGroup(cashGroupId);\n        require(msg.sender == cg.cashMarket, $$(ErrorCode(UNAUTHORIZED_CALLER)));\n\n        if (fee > 0) {\n            cashBalances[cg.currency][G_RESERVE_ACCOUNT] = cashBalances[cg.currency][G_RESERVE_ACCOUNT]\n                .add(fee);\n        }\n\n        cashBalances[cg.currency][account] = cashBalances[cg.currency][account].add(value.sub(fee));\n\n        int256 balance = cashBalances[cg.currency][msg.sender];\n        cashBalances[cg.currency][msg.sender] = balance.subNoNeg(value);\n    }\n\n    /**\n     * @notice Adds or removes collateral from the fCash market when the portfolio is trading positions\n     * as a result of settlement or liquidation.\n     * @dev skip\n     * @param currency the currency group of the collateral\n     * @param cashMarket the address of the fCash market to transfer between\n     * @param amount the amount to transfer\n     */\n    function unlockCurrentCash(\n        uint16 currency,\n        address cashMarket,\n        int256 amount\n    ) external override {\n        require(calledByPortfolios(), $$(ErrorCode(UNAUTHORIZED_CALLER)));\n\n        // The methods that calls this function will handle management of the collateral that is added or removed from\n        // the market.\n        int256 balance = cashBalances[currency][cashMarket];\n        cashBalances[currency][cashMarket] = balance.subNoNeg(amount);\n    }\n\n    /**\n     * @notice Can only be called by Portfolios when assets are settled to cash. There is no free collateral\n     * check for this function call because asset settlement is an equivalent transformation of a asset\n     * to a net cash value. An account's free collateral position will remain unchanged after settlement.\n     * @dev skip\n     * @param account account where the cash is settled\n     * @param settledCash an array of the currency groups that need to have their cash balance updated\n     */\n    function portfolioSettleCash(address account, int256[] calldata settledCash) external override {\n        require(calledByPortfolios(), $$(ErrorCode(UNAUTHORIZED_CALLER)));\n        // Since we are using the indexes to refer to the currency group ids, the length must be less than\n        // or equal to the total number of group ids currently used plus the zero currency which is unused.\n        require(settledCash.length == maxCurrencyId + 1, $$(ErrorCode(INVALID_CURRENCY)));\n\n        for (uint256 i = 0; i < settledCash.length; i++) {\n            if (settledCash[i] != 0) {\n                // Update the balance of the appropriate currency group. We've validated that this conversion\n                // to uint16 will not overflow with the require statement above.\n                cashBalances[uint16(i)][account] = cashBalances[uint16(i)][account].add(settledCash[i]);\n            }\n        }\n    }\n\n    /********** Cash Management *********/\n\n    /********** Settle Cash / Liquidation *************/\n\n    /**\n     * @notice Settles the cash balances of payers in batch\n     * @dev - INVALID_CURRENCY: currency specified is invalid\n     *  - INCORRECT_CASH_BALANCE: payer does not have sufficient cash balance to settle\n     *  - INVALID_EXCHANGE_RATE: exchange rate returned by the oracle is less than 0\n     *  - NO_EXCHANGE_LISTED_FOR_PAIR: cannot settle cash because no exchange is listed for the pair\n     *  - INSUFFICIENT_COLLATERAL_FOR_SETTLEMENT: not enough collateral to settle on the exchange\n     *  - RESERVE_ACCOUNT_HAS_INSUFFICIENT_BALANCE: settling requires the reserve account, but there is insufficient\n     * balance to do so\n     *  - INSUFFICIENT_COLLATERAL_BALANCE: account does not hold enough collateral to settle, they will have\n     * additional collateral in a different currency if they are collateralized\n     *  - INSUFFICIENT_FREE_COLLATERAL_SETTLER: calling account to settle cash does not have sufficient free collateral\n     * after settling payers and receivers\n     * @param localCurrency the currency that the payer's debts are denominated in\n     * @param collateralCurrency the collateral to settle the debts against\n     * @param payers the party that has a negative cash balance and will transfer collateral to the receiver\n     * @param values the amount of collateral to transfer\n     */\n    function settleCashBalanceBatch(\n        uint16 localCurrency,\n        uint16 collateralCurrency,\n        address[] calldata payers,\n        uint128[] calldata values\n    ) external {\n        Liquidation.RateParameters memory rateParam = _validateCurrencies(localCurrency, collateralCurrency);\n\n        uint128[] memory settledAmounts = new uint128[](values.length);\n        uint128 totalCollateral;\n        uint128 totalLocal;\n\n        for (uint256 i; i < payers.length; i++) {\n            uint128 local;\n            uint128 collateral;\n            (settledAmounts[i], local, collateral) = _settleCashBalance(\n                payers[i],\n                values[i],\n                rateParam\n            );\n\n            totalCollateral = totalCollateral.add(collateral);\n            totalLocal = totalLocal.add(local);\n        }\n\n        _finishLiquidateSettle(localCurrency, totalLocal);\n        _finishLiquidateSettle(collateralCurrency, int256(totalCollateral).neg());\n        emit SettleCashBatch(localCurrency, collateralCurrency, payers, settledAmounts);\n    }\n\n    /**\n     * @notice Settles the cash balance between the payer and the receiver.\n     * @dev - INCORRECT_CASH_BALANCE: payer or receiver does not have sufficient cash balance to settle\n     *  - INVALID_EXCHANGE_RATE: exchange rate returned by the oracle is less than 0\n     *  - NO_EXCHANGE_LISTED_FOR_PAIR: cannot settle cash because no exchange is listed for the pair\n     *  - INSUFFICIENT_COLLATERAL_FOR_SETTLEMENT: not enough collateral to settle on the exchange\n     *  - RESERVE_ACCOUNT_HAS_INSUFFICIENT_BALANCE: settling requires the reserve account, but there is insufficient\n     * balance to do so\n     *  - INSUFFICIENT_COLLATERAL_BALANCE: account does not hold enough collateral to settle, they will have\n     *  - INSUFFICIENT_FREE_COLLATERAL_SETTLER: calling account to settle cash does not have sufficient free collateral\n     * after settling payers and receivers\n     * @param localCurrency the currency that the payer's debts are denominated in\n     * @param collateralCurrency the collateral to settle the debts against\n     * @param payer the party that has a negative cash balance and will transfer collateral to the receiver\n     * @param value the amount of collateral to transfer\n     */\n    function settleCashBalance(\n        uint16 localCurrency,\n        uint16 collateralCurrency,\n        address payer,\n        uint128 value\n    ) external {\n        Liquidation.RateParameters memory rateParam = _validateCurrencies(localCurrency, collateralCurrency);\n\n        (uint128 settledAmount, uint128 totalLocal, uint128 totalCollateral) = _settleCashBalance(payer, value, rateParam);\n\n        _finishLiquidateSettle(localCurrency, totalLocal);\n        _finishLiquidateSettle(collateralCurrency, int256(totalCollateral).neg());\n        emit SettleCash(localCurrency, collateralCurrency, payer, settledAmount);\n    }\n\n    /**\n     * @notice Settles the cash balance between the payer and the receiver.\n     * @param payer the party that has a negative cash balance and will transfer collateral to the receiver\n     * @param valueToSettle the amount of collateral to transfer\n     * @param rateParam rate params for the liquidation library\n     */\n    function _settleCashBalance(\n        address payer,\n        uint128 valueToSettle,\n        Liquidation.RateParameters memory rateParam\n    ) internal returns (uint128, uint128, uint128) {\n        require(payer != msg.sender, $$(ErrorCode(CANNOT_SETTLE_SELF)));\n        if (valueToSettle == 0) return (0, 0, 0);\n        Common.FreeCollateralFactors memory fc = _freeCollateralFactors(\n            payer, \n            rateParam.localCurrency,\n            rateParam.collateralCurrency\n        );\n\n        int256 payerLocalBalance = cashBalances[rateParam.localCurrency][payer];\n        int256 payerCollateralBalance = cashBalances[rateParam.collateralCurrency][payer];\n\n        // This cash account must have enough negative cash to settle against\n        require(payerLocalBalance <= int256(valueToSettle).neg(), $$(ErrorCode(INCORRECT_CASH_BALANCE)));\n\n        Liquidation.TransferAmounts memory transfer = Liquidation.settle(\n            payer,\n            payerCollateralBalance,\n            valueToSettle,\n            fc,\n            rateParam,\n            address(Portfolios())\n        );\n\n        if (payerCollateralBalance != transfer.payerCollateralBalance) {\n            cashBalances[rateParam.collateralCurrency][payer] = transfer.payerCollateralBalance;\n        }\n\n        if (transfer.netLocalCurrencyPayer > 0) {\n            cashBalances[rateParam.localCurrency][payer] = payerLocalBalance.add(transfer.netLocalCurrencyPayer);\n        }\n\n        // This will not be negative"
    }
  ]
}