{
  "Title": "[L09] Missing NatSpec comments",
  "Content": "Some of the functions have missing or incomplete [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/latest/natspec-format.html) (NatSpec) comments.\n\n\n* [the `publishPendingConfig` function](https://github.com/UMAprotocol/protocol/blob/1631ef7ad29aaeba756ef3b9a01c667e1343df85/packages/core/contracts/financial-templates/perpetual-multiparty/ConfigStore.sol#L111-L111) of the `ConfigStore` has no NatSpec comments.\n* [the `OracleAncillaryInterface`](https://github.com/UMAprotocol/protocol/blob/1631ef7ad29aaeba756ef3b9a01c667e1343df85/packages/core/contracts/oracle/interfaces/OracleAncillaryInterface.sol) has included an `ancillaryData` parameter to all the function calls, but the NatSpec comments have not been updated accordingly.\n\n\n**Update**: *Fixed in [PR#2305](https://github.com/UMAprotocol/protocol/pull/2305).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/core/contracts/financial-templates/perpetual-multiparty/ConfigStore.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./ConfigStoreInterface.sol\";\nimport \"../../common/implementation/Testable.sol\";\nimport \"../../common/implementation/Lockable.sol\";\nimport \"../../common/implementation/FixedPoint.sol\";\n\n/**\n * @notice ConfigStore stores configuration settings for a perpetual contract and provides and interface for it\n * to query settings such as reward rates, proposal bond sizes, etc. The configuration settings can be upgraded\n * by a privileged account and the upgraded changes are timelocked.\n */\ncontract ConfigStore is ConfigStoreInterface, Testable, Lockable, Ownable {\n    using SafeMath for uint256;\n    using FixedPoint for FixedPoint.Unsigned;\n\n    /****************************************\n     *        STORE DATA STRUCTURES         *\n     ****************************************/\n\n    // Make currentConfig private to force user to call getCurrentConfig, which returns the pendingConfig\n    // if its liveness has expired.\n    ConfigStoreInterface.ConfigSettings private currentConfig;\n\n    // Beginning on `pendingPassedTimestamp`, the `pendingConfig` can be published as the current config.\n    ConfigStoreInterface.ConfigSettings public pendingConfig;\n    uint256 public pendingPassedTimestamp;\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n\n    event ProposedNewConfigSettings(\n        address indexed proposer,\n        uint256 rewardRate,\n        uint256 proposerBond,\n        uint256 timelockLiveness,\n        uint256 proposalPassedTimestamp\n    );\n    event ChangedConfigSettings(uint256 rewardRate, uint256 proposerBond, uint256 timelockLiveness);\n\n    /****************************************\n     *                MODIFIERS             *\n     ****************************************/\n\n    // Update config settings if possible.\n    modifier updateConfig() {\n        _updateConfig();\n        _;\n    }\n\n    /**\n     * @notice Propose new configuration settings. New settings go into effect\n     * after a liveness period passes.\n     * @param _initialConfig Configuration settings to initialize `currentConfig` with.\n     * @param _timerAddress Address of testable Timer contract.\n     */\n    constructor(ConfigSettings memory _initialConfig, address _timerAddress) public Testable(_timerAddress) {\n        _validateConfig(_initialConfig);\n        currentConfig = _initialConfig;\n    }\n\n    /**\n     * @notice Returns current config or pending config if pending liveness has expired.\n     * @return ConfigSettings config settings that calling financial contract should view as \"live\".\n     */\n    function getCurrentConfig()\n        external\n        view\n        override\n        nonReentrantView()\n        returns (ConfigStoreInterface.ConfigSettings memory)\n    {\n        if (_pendingProposalPassed()) {\n            return pendingConfig;\n        } else {\n            return currentConfig;\n        }\n    }\n\n    /**\n     * @notice Propose new configuration settings. New settings go into effect\n     * after a liveness period passes.\n     * @param newConfig Configuration settings to publish after `currentConfig.timelockLiveness` passes from now.\n     * @dev Callable only by owner. Calling this while there is already a pending proposal\n     * will overwrite the pending proposal.\n     */\n    function proposeNewConfig(ConfigSettings memory newConfig) external onlyOwner() nonReentrant() updateConfig() {\n        _validateConfig(newConfig);\n\n        // Warning: This overwrites a pending proposal!\n        pendingConfig = newConfig;\n\n        // Use current config's liveness period to timelock this proposal.\n        pendingPassedTimestamp = getCurrentTime().add(currentConfig.timelockLiveness);\n\n        emit ProposedNewConfigSettings(\n            msg.sender,\n            newConfig.rewardRatePerSecond.rawValue,\n            newConfig.proposerBondPct.rawValue,\n            newConfig.timelockLiveness,\n            pendingPassedTimestamp\n        );\n    }\n\n    function publishPendingConfig() external nonReentrant() updateConfig() {}\n\n    /****************************************\n     *         INTERNAL FUNCTIONS           *\n     ****************************************/\n\n    // Check if pending proposal can overwrite the current config.\n    function _updateConfig() internal {\n        // If liveness has passed, publish new reward rate.\n        if (_pendingProposalPassed()) {\n            currentConfig = pendingConfig;\n\n            _deletePendingConfig();\n\n            emit ChangedConfigSettings(\n                currentConfig.rewardRatePerSecond.rawValue,\n                currentConfig.proposerBondPct.rawValue,\n                currentConfig.timelockLiveness\n            );\n        }\n    }\n\n    function _deletePendingConfig() internal {\n        delete pendingConfig;\n        pendingPassedTimestamp = 0;\n    }\n\n    function _pendingProposalPassed() internal view returns (bool) {\n        return (pendingPassedTimestamp != 0 && pendingPassedTimestamp <= getCurrentTime());\n    }\n\n    // Use this method to constrain values with which you can set ConfigSettings.\n    function _validateConfig(ConfigStoreInterface.ConfigSettings memory config) internal pure {\n        // Make sure timelockLiveness is not too long, otherwise contract can might not be able to fix itself\n        // before a vulnerability drains its collateral.\n        require(config.timelockLiveness <= 7 days && config.timelockLiveness >= 1 days, \"Invalid timelockLiveness\");\n\n        // Upper limits for the reward and bond rates are estimated based on offline discussions,\n        // and it is expected that these hard-coded limits can change in future deployments.\n        // For a discussion thread, go [here](https://github.com/UMAprotocol/protocol/pull/2223#discussion_r530692149).\n\n        // Proposer bond of 0.04% is based on a maximum expected funding rate error of 200%/year.\n        FixedPoint.Unsigned memory maxProposerBond = FixedPoint.fromUnscaledUint(4).div(1e4);\n        require(config.proposerBondPct.isLessThan(maxProposerBond), \"Invalid proposerBondPct\");\n\n        // Reward rate should be less than 100% a year => 100% / 360 days / 24 hours / 60 mins / 60 secs\n        // = 0.0000033\n        FixedPoint.Unsigned memory maxRewardRatePerSecond = FixedPoint.fromUnscaledUint(33).div(1e7);\n        require(config.rewardRatePerSecond.isLessThan(maxRewardRatePerSecond), \"Invalid rewardRatePerSecond\");\n    }\n}"
    }
  ]
}