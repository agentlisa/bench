{
  "Title": "[M-19] `CLOCK_MODE()` will not work properly for Arbitrum or Optimism due to `block.number`",
  "Content": "\n### Proof of Concept\n\nAccording to [Arbitrum Docs](https://developer.offchainlabs.com/time), `block.number` returns the most recently synced L1 block number. Once per minute, the block number in the `Sequencer` is synced to the actual L1 block number. Using `block.number` as a clock can lead to inaccurate timing.\n\nIt also presents an issue for [Optimism](https://community.optimism.io/docs/developers/build/differences/#block-numbers-and-timestamps) because each transaction is it's own block.\n\n<https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/governance/LybraGovernance.sol#L152>\n\n### Recommended Mitigation Steps\n\nUse `block.timestamp` rather than `block.number`\n\n### Assessed type\n\nTiming\n\n**[LybraFinance commented](https://github.com/code-423n4/2023-06-lybra-findings/issues/114#issuecomment-1639775144):**\n > The governance contract only exists on the Ethereum mainnet.\n\n**[LybraFinance acknowledged](https://github.com/code-423n4/2023-06-lybra-findings/issues/114#issuecomment-1656708522)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-06-lybra",
  "Code": [
    {
      "filename": "contracts/lybra/governance/LybraGovernance.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts/governance/extensions/GovernorTimelockControl.sol\";\nimport \"../interfaces/IesLBR.sol\";\nimport \"../interfaces/IGovernanceTimelock.sol\";\n\ncontract LybraGovernance is GovernorTimelockControl {\n    \n    IesLBR public esLBR;\n    IGovernanceTimelock public GovernanceTimelock;\n\n    /// @notice Ballot receipt record for a voter\n    struct Receipt {\n        /// @notice Whether or not a vote has been cast\n        bool hasVoted;\n\n        /// @notice Whether or not the voter supports the proposal or abstains\n        uint8 support;\n\n        /// @notice The number of votes the voter had, which were cast\n        uint256 votes;\n    }\n    \n\n    struct ProposalExtraData {\n        mapping(address => Receipt)  receipts;\n        mapping(uint8 => uint256) supportVotes;\n        uint256 totalVotes;\n    }\n\n    mapping (uint256 => ProposalExtraData) public proposalData;\n     \n\n\n        // TimelockController timelockAddress;\n      constructor(string memory name_, TimelockController timelock_, address _esLBR) GovernorTimelockControl(timelock_)  Governor(name_) {\n        // timelock = timelock_;\n        esLBR = IesLBR(_esLBR);\n        GovernanceTimelock = IGovernanceTimelock(address(timelock_));\n    }\n\n      /**\n     * @notice module:user-config\n     * @dev Minimum number of cast voted required for a proposal to be successful.\n     *\n     * NOTE: The `timepoint` parameter corresponds to the snapshot used for counting vote. This allows to scale the\n     * quorum depending on values such as the totalSupply of a token at this timepoint (see {ERC20Votes}).\n     */\n    function quorum(uint256 timepoint) public view override returns (uint256){\n        return esLBR.getPastTotalSupply(timepoint) / 3;\n    }\n\n    \n    /**\n     * @dev Amount of votes already cast passes the threshold limit.\n     */\n    function _quorumReached(uint256 proposalId) internal view override returns (bool){\n        return proposalData[proposalId].supportVotes[1] + proposalData[proposalId].supportVotes[2] >= quorum(proposalSnapshot(proposalId));\n    }\n\n       /**\n     * @dev Is the proposal successful or not.\n     */\n    function _voteSucceeded(uint256 proposalId) internal view override returns (bool){\n        return proposalData[proposalId].supportVotes[1] > proposalData[proposalId].supportVotes[0];\n    }\n\n       /**\n     * @dev Register a vote for `proposalId` by `account` with a given `support`, voting `weight` and voting `params`.\n     *\n     * Note: Support is generic and can represent various things depending on the voting system used.\n     */\n\n    function _countVote(uint256 proposalId, address account, uint8 support, uint256 weight, bytes memory) internal override {\n      \n        require(state(proposalId) == ProposalState.Active, \"GovernorBravo::castVoteInternal: voting is closed\");\n        require(support <= 2, \"GovernorBravo::castVoteInternal: invalid vote type\");\n        ProposalExtraData storage proposalExtraData = proposalData[proposalId];\n        Receipt storage receipt = proposalExtraData.receipts[account];\n        require(receipt.hasVoted == false, \"GovernorBravo::castVoteInternal: voter already voted\");\n        \n        proposalExtraData.supportVotes[support] += weight;\n       \n\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = weight;\n        proposalExtraData.totalVotes += weight;\n        \n    }\n\n    /**\n     * @dev Get the voting weight of `account` at a specific `timepoint`, for a vote as described by `params`.\n     */\n\n     function _getVotes(address account, uint256 timepoint, bytes memory) internal view override returns (uint256){\n\n        return esLBR.getPastVotes(account, timepoint);\n     }\n\n    /**\n     * @dev Overridden execute function that run the already queued proposal through the timelock.\n     */\n    function _execute(uint256 /* proposalId */, address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash) internal virtual override {\n        require(GovernanceTimelock.checkOnlyRole(keccak256(\"TIMELOCK\"), msg.sender), \"not authorized\");\n        super._execute(1, targets, values, calldatas, descriptionHash);\n        // _timelock.executeBatch{value: msg.value}(targets, values, calldatas, 0, descriptionHash);\n    }\n\n    function proposals(uint256 proposalId) external view returns (uint256 id, address proposer, uint256 eta, uint256 startBlock, uint256 endBlock, uint256 forVotes, uint256 againstVotes, uint256 abstainVotes, bool canceled, bool executed) {\n        id = proposalId;\n        eta = proposalEta(proposalId);\n        startBlock = proposalSnapshot(proposalId);\n        endBlock = proposalDeadline(proposalId);\n\n        proposer = proposalProposer(proposalId);\n        \n        forVotes =  proposalData[proposalId].supportVotes[0];\n        againstVotes =  proposalData[proposalId].supportVotes[1];\n        abstainVotes =  proposalData[proposalId].supportVotes[2];\n\n        ProposalState currentState = state(proposalId);\n        canceled = currentState == ProposalState.Canceled;\n        executed = currentState == ProposalState.Executed;\n    }\n\n    function getReceipt(uint256 proposalId, address account) external view returns (bool voted, uint8 support, uint256 votes){  \n        voted = proposalData[proposalId].receipts[account].hasVoted;\n        support = proposalData[proposalId].receipts[account].support;\n        votes = proposalData[proposalId].receipts[account].votes;\n    }\n\n    /**\n     * @notice module:user-config\n     * @dev Delay between the vote start and vote end. The unit this duration is expressed in depends on the clock\n     * (see EIP-6372) this contract uses.\n     *\n     * NOTE: The {votingDelay} can delay the start of the vote. This must be considered when setting the voting\n     * duration compared to the voting delay.\n     */\n    function votingPeriod() public pure override returns (uint256){\n         return 3;\n    }\n\n     function votingDelay() public pure override returns (uint256){\n         return 1;\n    }\n\n     function CLOCK_MODE() public override view returns (string memory){\n       require(clock() == block.number, \"Votes: broken clock mode\");\n        return \"mode=blocknumber&from=default\";\n    }\n\n    function COUNTING_MODE() public override view virtual returns (string memory){\n          return \"support=bravo&quorum=for,abstain\";\n    }\n\n    \n    function clock() public override view returns (uint48){\n        return SafeCast.toUint48(block.number);\n    }\n\n    function hasVoted(uint256 proposalId, address account) public override view virtual returns (bool){\n        return proposalData[proposalId].receipts[account].hasVoted;\n    }\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"The number of votes required in order for a voter to become a proposer\"_.\n     */\n    function proposalThreshold() public pure override returns (uint256) {\n        return 1e23;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(GovernorTimelockControl) returns (bool) {\n        bytes4 governorCancelId = this.cancel.selector ^ this.proposalProposer.selector;\n\n        bytes4 governorParamsId = this.castVoteWithReasonAndParams.selector ^\n            this.castVoteWithReasonAndParamsBySig.selector ^\n            this.getVotesWithParams.selector;\n\n        // The original interface id in v4.3.\n        bytes4 governor43Id = type(IGovernor).interfaceId ^\n            type(IERC6372).interfaceId ^\n            governorCancelId ^\n            governorParamsId;\n\n        // An updated interface id in v4.6, with params added.\n        bytes4 governor46Id = type(IGovernor).interfaceId ^ type(IERC6372).interfaceId ^ governorCancelId;\n\n        // For the updated interface id in v4.9, we use governorCancelId directly.\n\n        return\n            interfaceId == governor43Id ||\n            interfaceId == governor46Id ||\n            interfaceId == governorCancelId ||\n            interfaceId == type(IERC1155Receiver).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n\n}"
    }
  ]
}