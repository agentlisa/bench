{
  "Title": "Use of CREATE method is suspicious of reorg attack",
  "Content": "# Use of CREATE method is suspicious of reorg attack\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-05-Sablier/blob/43d7e752a68bba2a1d73d3d6466c3059079ed0c6/v2-periphery/src/SablierV2MerkleLockupFactory.sol#L36\">https://github.com/Cyfrin/2024-05-Sablier/blob/43d7e752a68bba2a1d73d3d6466c3059079ed0c6/v2-periphery/src/SablierV2MerkleLockupFactory.sol#L36</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-05-Sablier/blob/43d7e752a68bba2a1d73d3d6466c3059079ed0c6/v2-periphery/src/SablierV2MerkleLockupFactory.sol#L71\">https://github.com/Cyfrin/2024-05-Sablier/blob/43d7e752a68bba2a1d73d3d6466c3059079ed0c6/v2-periphery/src/SablierV2MerkleLockupFactory.sol#L71</a>\n\n\n## Summary \n\nWhen a campaign initiator wants to create a linear or tranched airstream, he calls `SablierV2MerkleLockupFactory::createMerkleLL`, `SablierV2MerkleLockupFactory::createMerkleLT`, however these functions use the CREATE method (can be seen in the provided github permalinks) where the address derivation depends only on the `SablierV2MerkleLockupFactory` nonce. This is susceptible to reorg attacks.\n\n## Vulnerability Details\n\nAs mentioned in the report's title, reorgs can occur in all EVM chains and most likely on L2's like Arbitrum or Polygon, and as stated in the protocol's README Sablier is compatible with \"Any network which is EVM compatible\", here are some reference links for some previous reorgs that happened in the past: \n\nEthereum: https://decrypt.co/101390/ethereum-beacon-chain-blockchain-reorg - 2 years ago\n\nPolygon: https://polygonscan.com/block/36757444/f?hash=0xf9aefee3ea0e4fc5f67aac48cb6e25912158ce9dca9ec6c99259d937433d6df8 - 2 years ago, this is with 120 blocks depth which means 4 minutes of re-written tx's since the block rate is ~2 seconds\n         https://protos.com/polygon-hit-by-157-block-reorg-despite-hard-fork-to-reduce-reorgs/ - February last year, 157 blocks depth\n\nOptimistic rollups (Optimism/Arbitrum) are also suspect to reorgs since if someone finds a fraud the blocks will be reverted, even though the user receives a confirmation.\n\nThese are the biggest events of reorgs that happened, here is a link for forked blocks, which means excluded blocks as a result of \"Block Reorganizations\" on Polygon: https://polygonscan.com/blocks_forked?p=1, where can be observed that at least two-digit block reorgs happen every month.\n\nThe vulnerability here is that airstream creators rely on address derivation in advance or when trying to deploy the same address on different chains, any funds sent to the airstream can be stolen.\n\nProof-Of-Concept:\n\nImagine the following scenario:\n\n1. Alice deploys a new Airstream and funds it.\n2. Bob has an active bot that observes the blockchain and alerts in reorg.\n3. Bob calls one of the forementioned create functions \n4. Thus an Airstream is created with an address to which Alice sends tokens.\n5. Finally Alice's tx is executed and an Airstream is funded which Bob controls.\n6. Bob immediately calls `SablierV2MerkleLockup::clawback` and transfers the tokens to himself.\n\n## Impact\n\nImpact: High - funds provided by the creator can be stolen\nLikelihood: Low - as it requires an event of block reorganizations and as the creator of the stream has an option to not fund it immediately.\nOverall: Medium \n\n## Tools Used\n\nManual Review \n\n## Recommendations\n\nDeploy the newly created Airstreams via `CREATE2` with `salt` that inlcudes `msg.sender`. ",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clvb9njmy00012dqjyaavpl44",
  "Code": [
    {
      "filename": "v2-periphery/src/SablierV2MerkleLockupFactory.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.22;\n\nimport { uUNIT } from \"@prb/math/src/UD2x18.sol\";\nimport { ISablierV2LockupLinear } from \"@sablier/v2-core/src/interfaces/ISablierV2LockupLinear.sol\";\nimport { ISablierV2LockupTranched } from \"@sablier/v2-core/src/interfaces/ISablierV2LockupTranched.sol\";\nimport { LockupLinear } from \"@sablier/v2-core/src/types/DataTypes.sol\";\n\nimport { ISablierV2MerkleLL } from \"./interfaces/ISablierV2MerkleLL.sol\";\nimport { ISablierV2MerkleLockupFactory } from \"./interfaces/ISablierV2MerkleLockupFactory.sol\";\nimport { ISablierV2MerkleLT } from \"./interfaces/ISablierV2MerkleLT.sol\";\nimport { Errors } from \"./libraries/Errors.sol\";\nimport { SablierV2MerkleLL } from \"./SablierV2MerkleLL.sol\";\nimport { SablierV2MerkleLT } from \"./SablierV2MerkleLT.sol\";\nimport { MerkleLockup, MerkleLT } from \"./types/DataTypes.sol\";\n\n/// @title SablierV2MerkleLockupFactory\n/// @notice See the documentation in {ISablierV2MerkleLockupFactory}.\ncontract SablierV2MerkleLockupFactory is ISablierV2MerkleLockupFactory {\n    /*//////////////////////////////////////////////////////////////////////////\n                         USER-FACING NON-CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice inheritdoc ISablierV2MerkleLockupFactory\n    function createMerkleLL(\n        MerkleLockup.ConstructorParams memory baseParams,\n        ISablierV2LockupLinear lockupLinear,\n        LockupLinear.Durations memory streamDurations,\n        uint256 aggregateAmount,\n        uint256 recipientCount\n    )\n        external\n        returns (ISablierV2MerkleLL merkleLL)\n    {\n        // Deploy the MerkleLockup contract with CREATE.\n        merkleLL = new SablierV2MerkleLL(baseParams, lockupLinear, streamDurations);\n\n        // Log the creation of the MerkleLockup contract, including some metadata that is not stored on-chain.\n        emit CreateMerkleLL(merkleLL, baseParams, lockupLinear, streamDurations, aggregateAmount, recipientCount);\n    }\n\n    /// @notice inheritdoc ISablierV2MerkleLockupFactory\n    function createMerkleLT(\n        MerkleLockup.ConstructorParams memory baseParams,\n        ISablierV2LockupTranched lockupTranched,\n        MerkleLT.TrancheWithPercentage[] memory tranchesWithPercentages,\n        uint256 aggregateAmount,\n        uint256 recipientCount\n    )\n        external\n        returns (ISablierV2MerkleLT merkleLT)\n    {\n        // Calculate the sum of percentages and durations across all tranches.\n        uint64 totalPercentage;\n        uint256 totalDuration;\n        for (uint256 i = 0; i < tranchesWithPercentages.length; ++i) {\n            uint64 percentage = tranchesWithPercentages[i].unlockPercentage.unwrap();\n            totalPercentage = totalPercentage + percentage;\n            unchecked {\n                // Safe to use `unchecked` because its only used in the event.\n                totalDuration += tranchesWithPercentages[i].duration;\n            }\n        }\n\n        // Check: the sum of percentages equals 100%.\n        if (totalPercentage != uUNIT) {\n            revert Errors.SablierV2MerkleLockupFactory_TotalPercentageNotOneHundred(totalPercentage);\n        }\n\n        // Deploy the MerkleLockup contract with CREATE.\n        merkleLT = new SablierV2MerkleLT(baseParams, lockupTranched, tranchesWithPercentages);\n\n        // Log the creation of the MerkleLockup contract, including some metadata that is not stored on-chain.\n        emit CreateMerkleLT(\n            merkleLT,\n            baseParams,\n            lockupTranched,\n            tranchesWithPercentages,\n            totalDuration,\n            aggregateAmount,\n            recipientCount\n        );\n    }\n}"
    },
    {
      "filename": "v2-periphery/src/SablierV2MerkleLockupFactory.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.22;\n\nimport { uUNIT } from \"@prb/math/src/UD2x18.sol\";\nimport { ISablierV2LockupLinear } from \"@sablier/v2-core/src/interfaces/ISablierV2LockupLinear.sol\";\nimport { ISablierV2LockupTranched } from \"@sablier/v2-core/src/interfaces/ISablierV2LockupTranched.sol\";\nimport { LockupLinear } from \"@sablier/v2-core/src/types/DataTypes.sol\";\n\nimport { ISablierV2MerkleLL } from \"./interfaces/ISablierV2MerkleLL.sol\";\nimport { ISablierV2MerkleLockupFactory } from \"./interfaces/ISablierV2MerkleLockupFactory.sol\";\nimport { ISablierV2MerkleLT } from \"./interfaces/ISablierV2MerkleLT.sol\";\nimport { Errors } from \"./libraries/Errors.sol\";\nimport { SablierV2MerkleLL } from \"./SablierV2MerkleLL.sol\";\nimport { SablierV2MerkleLT } from \"./SablierV2MerkleLT.sol\";\nimport { MerkleLockup, MerkleLT } from \"./types/DataTypes.sol\";\n\n/// @title SablierV2MerkleLockupFactory\n/// @notice See the documentation in {ISablierV2MerkleLockupFactory}.\ncontract SablierV2MerkleLockupFactory is ISablierV2MerkleLockupFactory {\n    /*//////////////////////////////////////////////////////////////////////////\n                         USER-FACING NON-CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice inheritdoc ISablierV2MerkleLockupFactory\n    function createMerkleLL(\n        MerkleLockup.ConstructorParams memory baseParams,\n        ISablierV2LockupLinear lockupLinear,\n        LockupLinear.Durations memory streamDurations,\n        uint256 aggregateAmount,\n        uint256 recipientCount\n    )\n        external\n        returns (ISablierV2MerkleLL merkleLL)\n    {\n        // Deploy the MerkleLockup contract with CREATE.\n        merkleLL = new SablierV2MerkleLL(baseParams, lockupLinear, streamDurations);\n\n        // Log the creation of the MerkleLockup contract, including some metadata that is not stored on-chain.\n        emit CreateMerkleLL(merkleLL, baseParams, lockupLinear, streamDurations, aggregateAmount, recipientCount);\n    }\n\n    /// @notice inheritdoc ISablierV2MerkleLockupFactory\n    function createMerkleLT(\n        MerkleLockup.ConstructorParams memory baseParams,\n        ISablierV2LockupTranched lockupTranched,\n        MerkleLT.TrancheWithPercentage[] memory tranchesWithPercentages,\n        uint256 aggregateAmount,\n        uint256 recipientCount\n    )\n        external\n        returns (ISablierV2MerkleLT merkleLT)\n    {\n        // Calculate the sum of percentages and durations across all tranches.\n        uint64 totalPercentage;\n        uint256 totalDuration;\n        for (uint256 i = 0; i < tranchesWithPercentages.length; ++i) {\n            uint64 percentage = tranchesWithPercentages[i].unlockPercentage.unwrap();\n            totalPercentage = totalPercentage + percentage;\n            unchecked {\n                // Safe to use `unchecked` because its only used in the event.\n                totalDuration += tranchesWithPercentages[i].duration;\n            }\n        }\n\n        // Check: the sum of percentages equals 100%.\n        if (totalPercentage != uUNIT) {\n            revert Errors.SablierV2MerkleLockupFactory_TotalPercentageNotOneHundred(totalPercentage);\n        }\n\n        // Deploy the MerkleLockup contract with CREATE.\n        merkleLT = new SablierV2MerkleLT(baseParams, lockupTranched, tranchesWithPercentages);\n\n        // Log the creation of the MerkleLockup contract, including some metadata that is not stored on-chain.\n        emit CreateMerkleLT(\n            merkleLT,\n            baseParams,\n            lockupTranched,\n            tranchesWithPercentages,\n            totalDuration,\n            aggregateAmount,\n            recipientCount\n        );\n    }\n}"
    }
  ]
}