{
  "Title": "[M-09] Last Trove may be prevented from redeeming",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Core/contracts/RedemptionHelper.sol#L128\n\n\n# Vulnerability details\n\n## Impact\nIn `redeemCollateral()` of RedemptionHelper.sol, the LUSD `balanceOf` the redeemer is checked against the specific collateral recorded LUSD debt (both active and defaulted). \n```solidity\n\nfunction redeemCollateral(\n        address _collateral,\n        address _redeemer,\n        uint _LUSDamount,\n        address _firstRedemptionHint,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint _partialRedemptionHintNICR,\n        uint _maxIterations,\n        uint _maxFeePercentage\n    )\n        external override\n    {\n        _requireCallerIsTroveManager();\n        _requireValidCollateralAddress(_collateral);\n        RedemptionTotals memory totals;\n\n        _requireValidMaxFeePercentage(_maxFeePercentage);\n        _requireAfterBootstrapPeriod();\n        totals.price = priceFeed.fetchPrice(_collateral);\n        ICollateralConfig collateralConfigCached = collateralConfig;\n        totals.collDecimals = collateralConfigCached.getCollateralDecimals(_collateral);\n        totals.collMCR = collateralConfigCached.getCollateralMCR(_collateral);\n        _requireTCRoverMCR(_collateral, totals.price, totals.collDecimals, totals.collMCR);\n        _requireAmountGreaterThanZero(_LUSDamount);\n        _requireLUSDBalanceCoversRedemption(lusdToken, _redeemer, _LUSDamount);\n\n        totals.totalLUSDSupplyAtStart = getEntireSystemDebt(_collateral);\n        // Confirm redeemer's balance is less than total LUSD supply\n        assert(lusdToken.balanceOf(_redeemer) <= totals.totalLUSDSupplyAtStart);\n        ...\n}\n```\nThis makes sense in a single collateral system such as Liquity, but is problematic in a multi-collateral one like Reserve. Since each collateral type tracks its own debt but mints the same LUSD token, LUSD supply (and thus balance) being less than the collateral debt is no longer an invariant. This can can result in:\n- Last trove may be prevented from redeeming by griefers.\n- Users that deposit into multiple Trove types may be prevented from redeeming.\n\n## Proof of Concept\n### Last trove may be prevented from redeeming\nConsider the cases when \n```\n- There are 2 Trove types (wBTC and wETH). \n- There is 10000 total LUSD debt in the wBTC Troves.\n- Stability Pool has 150 LUSD deposited i.e. full liquidity to offset debt.\n- There is 100 total LUSD debt in the wETH pool.\n- ETH prices crash and all Troves get liquidated except the last one.\n```\nA griefer can front-run the last Trove from redeeming by sending the user weth with the amount `entireSystemDebt` + 1.\n\nIn a similar case as above, any users that may borrow from multiple Troves types such that their LUSD balance is greater than the total collateral debt will be prevented from redeeming. However, this is not as problematic because they can just send their excess tokens out.\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\n- Consider removing this check as the invariant no longer applies",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-02-ethos-reserve-contest",
  "Code": [
    {
      "filename": "Ethos-Core/contracts/RedemptionHelper.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.6.11;\n\nimport \"./Interfaces/ICollateralConfig.sol\";\nimport \"./Interfaces/ILQTYStaking.sol\";\nimport \"./Interfaces/ILUSDToken.sol\";\nimport \"./Interfaces/IPriceFeed.sol\";\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/IRedemptionHelper.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/IERC20.sol\";\n\ncontract RedemptionHelper is LiquityBase, Ownable, IRedemptionHelper {\n    uint constant public BOOTSTRAP_PERIOD = 14 days;\n\n    ITroveManager public troveManager;\n    ICollateralConfig public collateralConfig;\n    IERC20 public lqtyToken;\n    ILUSDToken public lusdToken;\n    ISortedTroves public sortedTroves;\n    ILQTYStaking public lqtyStaking;\n\n    struct RedemptionTotals {\n        uint remainingLUSD;\n        uint totalLUSDToRedeem;\n        uint totalCollateralDrawn;\n        uint collateralFee;\n        uint collateralToSendToRedeemer;\n        uint decayedBaseRate;\n        uint price;\n        uint totalLUSDSupplyAtStart;\n        uint256 collDecimals;\n        uint256 collMCR;\n        address currentBorrower;\n    }\n\n    struct SingleRedemptionValues {\n        uint LUSDLot;\n        uint collLot;\n        bool cancelledPartial;\n    }\n\n    // Due to \"stack too deep\" error\n    struct LocalVariables_redeemCollateralFromTrove {\n        uint newDebt;\n        uint newColl;\n        uint newNICR;\n        uint256 collDecimals;\n    }\n\n    function setAddresses(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        ITroveManager _troveManager,\n        ICollateralConfig _collateralConfig,\n        IERC20 _lqtyToken,\n        IPriceFeed _priceFeed,\n        ILUSDToken _lusdToken,\n        ISortedTroves _sortedTroves,\n        ILQTYStaking _lqtyStaking\n    ) external onlyOwner {\n        activePool = _activePool;\n        defaultPool = _defaultPool;\n        troveManager = _troveManager;\n        collateralConfig = _collateralConfig;\n        lqtyToken = _lqtyToken;\n        priceFeed = _priceFeed;\n        lusdToken = _lusdToken;\n        sortedTroves = _sortedTroves;\n        lqtyStaking = _lqtyStaking;\n\n        _renounceOwnership();\n    }\n\n    /* Send _LUSDamount LUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n    * request.  Applies pending rewards to a Trove before reducing its debt and coll.\n    *\n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by\n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\n    *\n    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to\n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”\n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode\n    * costs can vary.\n    *\n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.\n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position\n    * in the sortedTroves list along with the ICR value that the hint was found for.\n    *\n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining LUSD amount, which they can attempt\n    * to redeem later.\n    */\n    function redeemCollateral(\n        address _collateral,\n        address _redeemer,\n        uint _LUSDamount,\n        address _firstRedemptionHint,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint _partialRedemptionHintNICR,\n        uint _maxIterations,\n        uint _maxFeePercentage\n    )\n        external override\n    {\n        _requireCallerIsTroveManager();\n        _requireValidCollateralAddress(_collateral);\n        RedemptionTotals memory totals;\n\n        _requireValidMaxFeePercentage(_maxFeePercentage);\n        _requireAfterBootstrapPeriod();\n        totals.price = priceFeed.fetchPrice(_collateral);\n        ICollateralConfig collateralConfigCached = collateralConfig;\n        totals.collDecimals = collateralConfigCached.getCollateralDecimals(_collateral);\n        totals.collMCR = collateralConfigCached.getCollateralMCR(_collateral);\n        _requireTCRoverMCR(_collateral, totals.price, totals.collDecimals, totals.collMCR);\n        _requireAmountGreaterThanZero(_LUSDamount);\n        _requireLUSDBalanceCoversRedemption(lusdToken, _redeemer, _LUSDamount);\n\n        totals.totalLUSDSupplyAtStart = getEntireSystemDebt(_collateral);\n        // Confirm redeemer's balance is less than total LUSD supply\n        assert(lusdToken.balanceOf(_redeemer) <= totals.totalLUSDSupplyAtStart);\n\n        totals.remainingLUSD = _LUSDamount;\n\n        ISortedTroves sortedTrovesCached = sortedTroves;\n        if (_isValidFirstRedemptionHint(\n            sortedTrovesCached,\n            _collateral,\n            _firstRedemptionHint,\n            totals.price,\n            totals.collMCR)\n        ) {\n            totals.currentBorrower = _firstRedemptionHint;\n        } else {\n            totals.currentBorrower = sortedTrovesCached.getLast(_collateral);\n            // Find the first trove with ICR >= MCR\n            while (totals.currentBorrower != address(0) &&\n                troveManager.getCurrentICR(totals.currentBorrower, _collateral, totals.price) < totals.collMCR) \n            {\n                totals.currentBorrower = sortedTrovesCached.getPrev(_collateral, totals.currentBorrower);\n            }\n        }\n\n        // Loop through the Troves starting from the one with lowest collateral ratio until _amount of LUSD is exchanged for collateral\n        if (_maxIterations == 0) { _maxIterations = uint(-1); }\n        while (totals.currentBorrower != address(0) && totals.remainingLUSD > 0 && _maxIterations > 0) {\n            _maxIterations--;\n            // Save the address of the Trove preceding the current one, before potentially modifying the list\n            address nextUserToCheck = sortedTrovesCached.getPrev(_collateral, totals.currentBorrower);\n\n            troveManager.applyPendingRewards(totals.currentBorrower, _collateral);\n\n            SingleRedemptionValues memory singleRedemption = _redeemCollateralFromTrove(\n                totals.currentBorrower,\n                _collateral,\n                totals.remainingLUSD,\n                totals.price,\n                _upperPartialRedemptionHint,\n                _lowerPartialRedemptionHint,\n                _partialRedemptionHintNICR,\n                collateralConfigCached\n            );\n\n            if (singleRedemption.cancelledPartial) break; // Partial redemption was cancelled (out-of-date hint, or new net debt < minimum), therefore we could not redeem from the last Trove\n\n            totals.totalLUSDToRedeem  = totals.totalLUSDToRedeem.add(singleRedemption.LUSDLot);\n            totals.totalCollateralDrawn = totals.totalCollateralDrawn.add(singleRedemption.collLot);\n\n            totals.remainingLUSD = totals.remainingLUSD.sub(singleRedemption.LUSDLot);\n            totals.currentBorrower = nextUserToCheck;\n        }\n        require(totals.totalCollateralDrawn > 0);\n\n        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption.\n        // Use the saved total LUSD supply value, from before it was reduced by the redemption.\n        troveManager.updateBaseRateFromRedemption(\n            totals.totalCollateralDrawn,\n            totals.price,\n            totals.collDecimals,\n            totals.totalLUSDSupplyAtStart\n        );\n\n        // Calculate the ETH fee\n        totals.collateralFee = troveManager.getRedemptionFee(totals.totalCollateralDrawn);\n\n        _requireUserAcceptsFee(totals.collateralFee, totals.totalCollateralDrawn, _maxFeePercentage);\n\n        // Send the collateral fee to the LQTY staking contract\n        activePool.sendCollateral(_collateral, address(lqtyStaking), totals.collateralFee);\n        lqtyStaking.increaseF_Collateral(_collateral, totals.collateralFee);\n\n        totals.collateralToSendToRedeemer = totals.totalCollateralDrawn.sub(totals.collateralFee);\n\n        // Burn the total LUSD that is cancelled with debt, and send the redeemed collateral to _redeemer\n        troveManager.burnLUSDAndEmitRedemptionEvent(\n            _redeemer,\n            _collateral,\n            _LUSDamount,\n            totals.totalLUSDToRedeem,\n            totals.totalCollateralDrawn,\n            totals.collateralFee\n        );\n\n        // Update Active Pool LUSD, and send ETH to account\n        activePool.decreaseLUSDDebt(_collateral, totals.totalLUSDToRedeem);\n        activePool.sendCollateral(_collateral, _redeemer, totals.collateralToSendToRedeemer);\n    }\n\n    function _isValidFirstRedemptionHint(\n        ISortedTroves _sortedTroves,\n        address _collateral,\n        address _firstRedemptionHint,\n        uint _price,\n        uint256 _MCR\n    ) internal view returns (bool) {\n        if (_firstRedemptionHint == address(0) ||\n            !_sortedTroves.contains(_collateral, _firstRedemptionHint) ||\n            troveManager.getCurrentICR(_firstRedemptionHint, _collateral, _price) < _MCR\n        ) {\n            return false;\n        }\n\n        address nextTrove = _sortedTroves.getNext(_collateral, _firstRedemptionHint);\n        return nextTrove == address(0) || troveManager.getCurrentICR(nextTrove, _collateral, _price) < _MCR;\n    }\n\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for LUSD up to _maxLUSDamount\n    function _redeemCollateralFromTrove(\n        address _borrower,\n        address _collateral,\n        uint _maxLUSDamount,\n        uint _price,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint _partialRedemptionHintNICR,\n        ICollateralConfig _collateralConfig\n    )\n        internal returns (SingleRedemptionValues memory singleRedemption)\n    {\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the liquidation reserve\n        singleRedemption.LUSDLot = LiquityMath._min(\n            _maxLUSDamount,\n            troveManager.getTroveDebt(_borrower, _collateral).sub(LUSD_GAS_COMPENSATION)\n        );\n\n        LocalVariables_redeemCollateralFromTrove memory vars;\n        vars.collDecimals = _collateralConfig.getCollateralDecimals(_collateral);\n\n        // Get the collLot of equivalent value in USD\n        singleRedemption.collLot = singleRedemption.LUSDLot.mul(10**vars.collDecimals).div(_price);\n\n        // Decrease the debt and collateral of the current Trove according to the LUSD lot and corresponding collateral to send\n        vars.newDebt = troveManager.getTroveDebt(_borrower, _collateral).sub(singleRedemption.LUSDLot);\n        vars.newColl = troveManager.getTroveColl(_borrower, _collateral).sub(singleRedemption.collLot);\n\n        if (vars.newDebt == LUSD_GAS_COMPENSATION) {\n            // No debt left in the Trove (except for the liquidation reserve), therefore the trove gets closed\n            troveManager.removeStake(_borrower, _collateral);\n            troveManager.closeTrove(_borrower, _collateral, 4); // 4 = closedByRedemption\n            troveManager.redeemCloseTrove(_borrower, _collateral, LUSD_GAS_COMPENSATION, vars.newColl);\n        } else {\n            vars.newNICR = LiquityMath._computeNominalCR(vars.newColl, vars.newDebt, vars.collDecimals);\n\n            /*\n            * If the provided hint is out of date, we bail since trying to reinsert without a good hint will almost\n            * certainly result in running out of gas. \n            *\n            * If the resultant net debt of the partial is less than the minimum, net debt we bail.\n            */\n            if (vars.newNICR != _partialRedemptionHintNICR || _getNetDebt(vars.newDebt) < MIN_NET_DEBT) {\n                singleRedemption.cancelledPartial = true;\n                return singleRedemption;\n            }\n\n            troveManager.reInsert(\n                _borrower,\n                _collateral,\n                vars.newNICR,\n                _upperPartialRedemptionHint,\n                _lowerPartialRedemptionHint\n            );\n            troveManager.updateDebtAndCollAndStakesPostRedemption(_borrower, _collateral, vars.newDebt, vars.newColl);\n        }\n\n        return singleRedemption;\n    }\n\n    function _requireCallerIsTroveManager() internal view {\n        require(msg.sender == address(troveManager), \"RedemptionHelper: Caller is not TroveManager\");\n    }\n\n    function _requireValidCollateralAddress(address _collateral) internal view {\n        require(collateralConfig.isCollateralAllowed(_collateral), \"Invalid collateral address\");\n    }\n\n    function _requireValidMaxFeePercentage(uint _maxFeePercentage) internal view {\n        require(_maxFeePercentage >= troveManager.REDEMPTION_FEE_FLOOR() && _maxFeePercentage <= DECIMAL_PRECISION);\n    }\n\n    function _requireAfterBootstrapPeriod() internal view {\n        uint systemDeploymentTime = lusdToken.getDeploymentStartTime();\n        require(block.timestamp >= systemDeploymentTime.add(BOOTSTRAP_PERIOD));\n    }\n\n    function _requireTCRoverMCR(address _collateral, uint _price, uint256 _collDecimals, uint256 _MCR) internal view {\n        require(_getTCR(_collateral, _price, _collDecimals) >= _MCR);\n    }\n\n    function _requireAmountGreaterThanZero(uint _amount) internal pure {\n        require(_amount > 0);\n    }\n\n    function _requireLUSDBalanceCoversRedemption(ILUSDToken _lusdToken, address _redeemer, uint _amount) internal view {\n        require(_lusdToken.balanceOf(_redeemer) >= _amount);\n    }\n}"
    }
  ]
}