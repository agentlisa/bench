{
  "Title": "Staker contract should be declared abstract",
  "Content": "The [`Staker`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/Staker.sol) contract contains the following internal virtual functions:\n\n\n* [`inActiveReveal`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/Staker.sol#L310) which always returns `false` and is meant to return a boolean value that indicates whether or not the voting system is currently in a reveal phase\n* [`getStartingIndexForStaker`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/Staker.sol#L314) which always returns `0` and is meant to return a uint64 value indicating the index of the first request from which slashing rewards and penalties apply to a new staker\n\n\nNeither function is supposed to modify the contract state despite lacking a `view` identifier.\n\n\nFurther, the documentation of the `inActiveReveal` function states “This function should be overridden by the child contract”. This suggests the Staker contract is designed to always be inherited by a child contract which overrides both virtual functions, and never deployed as a standalone contract.\n\n\nTo enforce the intended design, prevent accidental deployments, and enhance the clarity of your code base, consider declaring the [`Staker`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/Staker.sol#L16) contract with the `abstract` keyword and removing the function body of `inActiveReveal` and `getStartingIndexForStaker` in order to force their implementation by a derived contract. Additionally, consider adding the `view` modifier to both function declarations.\n\n\n**Update:** *Fixed as of commit [`8b3084adcd51fba381e733d05b75345fa3db5e4d`](https://github.com/UMAprotocol/protocol/pull/4068/commits/8b3084adcd51fba381e733d05b75345fa3db5e4d) in [pull request #4068](https://github.com/UMAprotocol/protocol/pull/4068).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/core/contracts/oracle/implementation/Staker.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"../../common/implementation/Testable.sol\";\n\nimport \"./VotingToken.sol\";\nimport \"../interfaces/StakerInterface.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n/**\n * @title Staking contract enabling UMA to be locked up by stakers to earn a prorate share of a fixed emission rate.\n * @dev Handles the staking, unstaking and reward retrieval logic.\n */\ncontract Staker is StakerInterface, Ownable {\n    /****************************************\n     *           STAKING TRACKERS           *\n     ****************************************/\n\n    uint256 public emissionRate;\n    uint256 public cumulativeActiveStake;\n    uint256 public cumulativePendingStake;\n    uint256 public rewardPerTokenStored;\n\n    VotingToken public override votingToken;\n    uint64 public lastUpdateTime;\n    uint64 public unstakeCoolDown;\n\n    struct VoterStake {\n        uint256 activeStake;\n        uint256 pendingUnstake;\n        uint256 pendingStake;\n        uint256 rewardsPaidPerToken;\n        uint256 outstandingRewards;\n        uint64 lastRequestIndexConsidered;\n        uint64 unstakeRequestTime;\n        address delegate;\n    }\n\n    mapping(address => VoterStake) public voterStakes;\n    mapping(address => address) public delegateToStaker;\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n\n    event Staked(\n        address indexed voter,\n        uint256 amount,\n        uint256 voterActiveStake,\n        uint256 voterPendingStake,\n        uint256 voterPendingUnStake,\n        uint256 cumulativeActiveStake,\n        uint256 cumulativePendingStake\n    );\n\n    event RequestedUnstake(\n        address indexed voter,\n        uint256 amount,\n        uint256 unstakeTime,\n        uint256 voterActiveStake,\n        uint256 voterPendingStake\n    );\n\n    event ExecutedUnstake(\n        address indexed voter,\n        uint256 tokensSent,\n        uint256 voterActiveStake,\n        uint256 voterPendingStake\n    );\n\n    event WithdrawnRewards(address indexed voter, uint256 tokensWithdrawn);\n\n    event UpdatedReward(address indexed voter, uint256 newReward, uint256 lastUpdateTime);\n\n    event UpdatedActiveStake(\n        address indexed voter,\n        uint256 voterActiveStake,\n        uint256 voterPendingStake,\n        uint256 cumulativeActiveStake,\n        uint256 cumulativePendingStake\n    );\n\n    event SetNewEmissionRate(uint256 newEmissionRate);\n\n    event SetNewUnstakeCooldown(uint256 newUnstakeCooldown);\n\n    /**\n     * @notice Construct the Staker contract\n     * @param _emissionRate amount of voting tokens that are emitted per second, split prorate to stakers.\n     * @param _unstakeCoolDown time that a voter must wait to unstake after requesting to unstake.\n     *  to be voted on in the next round. If after this, the request is rolled to a round after the next round.\n     * @param _votingToken address of the UMA token contract used to commit votes.\n     */\n    constructor(\n        uint256 _emissionRate,\n        uint64 _unstakeCoolDown,\n        address _votingToken\n    ) {\n        emissionRate = _emissionRate;\n        unstakeCoolDown = _unstakeCoolDown;\n        votingToken = VotingToken(_votingToken);\n    }\n\n    /****************************************\n     *           STAKER FUNCTIONS           *\n     ****************************************/\n\n    /**\n     * @notice Pulls tokens from users wallet and stakes them. If we are in a active reveal phase the stake amount will\n     * be added to the pending stake. If not, the stake amount will be added to the active stake.\n     * @param amount the amount of tokens to stake.\n     */\n    function stake(uint256 amount) public override {\n        VoterStake storage voterStake = voterStakes[msg.sender];\n        // If the staker has a cumulative staked balance of 0 then we can shortcut their lastRequestIndexConsidered to\n        // the most recent index. This means we don't need to traverse requests where the staker was not staked.\n        // getStartingIndexForStaker returns the appropriate index to start at.\n        if (getVoterStake(msg.sender) + voterStake.pendingUnstake == 0)\n            voterStake.lastRequestIndexConsidered = getStartingIndexForStaker();\n        _updateTrackers(msg.sender);\n\n        if (inActiveReveal()) {\n            voterStake.pendingStake += amount;\n            cumulativePendingStake += amount;\n        } else {\n            voterStake.activeStake += amount;\n            cumulativeActiveStake += amount;\n        }\n\n        votingToken.transferFrom(msg.sender, address(this), amount);\n        emit Staked(\n            msg.sender,\n            amount,\n            voterStake.activeStake,\n            voterStake.pendingStake,\n            voterStake.pendingUnstake,\n            cumulativeActiveStake,\n            cumulativePendingStake\n        );\n    }\n\n    /**\n     * @notice Request a certain number of tokens to be unstaked. After the unstake time expires, the user may execute\n     * the unstake. Tokens requested to unstake are not slashable nor subject to earning rewards.\n     * This function cannot be called during an active reveal phase.\n     * Note that there is no way to cancel an unstake request, you must wait until after unstakeRequestTime and re-stake.\n     * @param amount the amount of tokens to request to be unstaked.\n     */\n    function requestUnstake(uint256 amount) public override {\n        require(!inActiveReveal(), \"In an active reveal phase\");\n        _updateTrackers(msg.sender);\n        VoterStake storage voterStake = voterStakes[msg.sender];\n\n        require(voterStake.activeStake >= amount, \"Bad request amount\");\n        require(voterStake.pendingUnstake == 0, \"Have previous request unstake\");\n\n        cumulativeActiveStake -= amount;\n        voterStake.pendingUnstake = amount;\n        voterStake.activeStake -= amount;\n        voterStake.unstakeRequestTime = SafeCast.toUint64(getCurrentTime());\n\n        emit RequestedUnstake(\n            msg.sender,\n            amount,\n            voterStake.unstakeRequestTime,\n            voterStake.activeStake,\n            voterStake.pendingStake\n        );\n    }\n\n    /**\n     * @notice  Execute a previously requested unstake. Requires the unstake time to have passed.\n     * @dev If a staker requested an unstake and time > unstakeRequestTime then send funds to staker. Note that this\n     * method assumes that the `updateTrackers().\n     */\n    function executeUnstake() public override {\n        VoterStake storage voterStake = voterStakes[msg.sender];\n        require(\n            voterStake.unstakeRequestTime != 0 && getCurrentTime() >= voterStake.unstakeRequestTime + unstakeCoolDown,\n            \"Unstake time not passed\"\n        );\n        uint256 tokensToSend = voterStake.pendingUnstake;\n\n        if (tokensToSend > 0) {\n            voterStake.pendingUnstake = 0;\n            voterStake.unstakeRequestTime = 0;\n            votingToken.transfer(msg.sender, tokensToSend);\n        }\n\n        emit ExecutedUnstake(msg.sender, tokensToSend, voterStake.activeStake, voterStake.pendingStake);\n    }\n\n    /**\n     * @notice Send accumulated rewards to the voter. Note that these rewards do not include slashing balance changes.\n     * @return uint256 the amount of tokens sent to the voter.\n     */\n    function withdrawRewards() public override returns (uint256) {\n        _updateTrackers(msg.sender);\n        VoterStake storage voterStake = voterStakes[msg.sender];\n\n        uint256 tokensToMint = voterStake.outstandingRewards;\n        if (tokensToMint > 0) {\n            voterStake.outstandingRewards = 0;\n            require(votingToken.mint(msg.sender, tokensToMint), \"Voting token issuance failed\");\n        }\n        emit WithdrawnRewards(msg.sender, tokensToMint);\n        return (tokensToMint);\n    }\n\n    /**\n     * @notice Stake accumulated rewards. This is just a convenience method that combines withdraw with stake in the\n     * same transaction.\n     * @dev this method requires that the user has approved this contract.\n     * @return uint256 the amount of tokens that the user is staking.\n     */\n    function withdrawAndRestake() public returns (uint256) {\n        uint256 rewards = withdrawRewards();\n        stake(rewards);\n        return rewards;\n    }\n\n    /****************************************\n     *        OWNER ADMIN FUNCTIONS         *\n     ****************************************/\n\n    /**\n     * @notice  Set the token's emission rate, the number of voting tokens that are emitted per second per staked token,\n     * split prorate to stakers.\n     * @param _emissionRate the new amount of voting tokens that are emitted per second, split prorate to stakers.\n     */\n    function setEmissionRate(uint256 _emissionRate) public onlyOwner {\n        _updateReward(address(0));\n        emissionRate = _emissionRate;\n        emit SetNewEmissionRate(emissionRate);\n    }\n\n    /**\n     * @notice  Set the amount of time a voter must wait to unstake after submitting a request to do so.\n     * @param _unstakeCoolDown the new duration of the cool down period in seconds.\n     */\n    function setUnstakeCoolDown(uint64 _unstakeCoolDown) public onlyOwner {\n        unstakeCoolDown = _unstakeCoolDown;\n        emit SetNewUnstakeCooldown(unstakeCoolDown);\n    }\n\n    function _updateTrackers(address voterAddress) internal virtual {\n        _updateReward(voterAddress);\n        _updateActiveStake(voterAddress);\n    }\n\n    /****************************************\n     *            VIEW FUNCTIONS            *\n     ****************************************/\n\n    /**\n     * @notice  Determine the number of outstanding token rewards that can be withdrawn by a voter.\n     * @param voterAddress the address of the voter.\n     * @return uint256 the outstanding rewards.\n     */\n    function outstandingRewards(address voterAddress) public view returns (uint256) {\n        VoterStake storage voterStake = voterStakes[voterAddress];\n\n        return\n            ((getVoterStake(voterAddress) * (rewardPerToken() - voterStake.rewardsPaidPerToken)) / 1e18) +\n            voterStake.outstandingRewards;\n    }\n\n    /**\n     * @notice  Calculate the reward per token based on the last time the reward was updated.\n     * @return uint256 the reward per token.\n     */\n    function rewardPerToken() public view returns (uint256) {\n        if (getCumulativeStake() == 0) return rewardPerTokenStored;\n        return\n            rewardPerTokenStored + ((getCurrentTime() - lastUpdateTime) * emissionRate * 1e18) / getCumulativeStake();\n    }\n\n    /**\n     * @notice  Returns the total amount of tokens staked. This is the sum of the active stake and the pending stake.\n     * @return uint256 the cumulative stake.\n     */\n    function getCumulativeStake() public view returns (uint256) {\n        return cumulativeActiveStake + cumulativePendingStake;\n    }\n\n    /**\n     * @notice  Returns the total amount of tokens staked by the voter.\n     * @param voterAddress the address of the voter.\n     * @return uint256 the total stake.\n     */\n    function getVoterStake(address voterAddress) public view returns (uint256) {\n        return voterStakes[voterAddress].activeStake + voterStakes[voterAddress].pendingStake;\n    }\n\n    /**\n     * @notice Returns the current block timestamp.\n     * @dev Can be overridden to control contract time.\n     */\n    function getCurrentTime() public view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    /****************************************\n     *          INTERNAL FUNCTIONS          *\n     ****************************************/\n\n    // Determine if we are in an active reveal phase. This function should be overridden by the child contract.\n    function inActiveReveal() internal virtual returns (bool) {\n        return false;\n    }\n\n    function getStartingIndexForStaker() internal virtual returns (uint64) {\n        return 0;\n    }\n\n    // Calculate the reward per token based on last time the reward was updated.\n    function _updateReward(address voterAddress) internal {\n        uint256 newRewardPerToken = rewardPerToken();\n        rewardPerTokenStored = newRewardPerToken;\n        lastUpdateTime = SafeCast.toUint64(getCurrentTime());\n        if (voterAddress != address(0)) {\n            VoterStake storage voterStake = voterStakes[voterAddress];\n            voterStake.outstandingRewards = outstandingRewards(voterAddress);\n            voterStake.rewardsPaidPerToken = newRewardPerToken;\n        }\n        emit UpdatedReward(voterAddress, newRewardPerToken, lastUpdateTime);\n    }\n\n    // Updates the active stake of the voter if not in an active reveal phase.\n    function _updateActiveStake(address voterAddress) internal {\n        if (voterStakes[voterAddress].pendingStake == 0 || inActiveReveal()) return;\n        cumulativeActiveStake += voterStakes[voterAddress].pendingStake;\n        cumulativePendingStake -= voterStakes[voterAddress].pendingStake;\n        voterStakes[voterAddress].activeStake += voterStakes[voterAddress].pendingStake;\n        voterStakes[voterAddress].pendingStake = 0;\n\n        emit UpdatedActiveStake(\n            voterAddress,\n            voterStakes[voterAddress].activeStake,\n            voterStakes[voterAddress].pendingStake,\n            cumulativeActiveStake,\n            cumulativePendingStake\n        );\n    }\n}"
    },
    {
      "filename": "packages/core/contracts/oracle/implementation/Staker.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"../../common/implementation/Testable.sol\";\n\nimport \"./VotingToken.sol\";\nimport \"../interfaces/StakerInterface.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n/**\n * @title Staking contract enabling UMA to be locked up by stakers to earn a prorate share of a fixed emission rate.\n * @dev Handles the staking, unstaking and reward retrieval logic.\n */\ncontract Staker is StakerInterface, Ownable {\n    /****************************************\n     *           STAKING TRACKERS           *\n     ****************************************/\n\n    uint256 public emissionRate;\n    uint256 public cumulativeActiveStake;\n    uint256 public cumulativePendingStake;\n    uint256 public rewardPerTokenStored;\n\n    VotingToken public override votingToken;\n    uint64 public lastUpdateTime;\n    uint64 public unstakeCoolDown;\n\n    struct VoterStake {\n        uint256 activeStake;\n        uint256 pendingUnstake;\n        uint256 pendingStake;\n        uint256 rewardsPaidPerToken;\n        uint256 outstandingRewards;\n        uint64 lastRequestIndexConsidered;\n        uint64 unstakeRequestTime;\n        address delegate;\n    }\n\n    mapping(address => VoterStake) public voterStakes;\n    mapping(address => address) public delegateToStaker;\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n\n    event Staked(\n        address indexed voter,\n        uint256 amount,\n        uint256 voterActiveStake,\n        uint256 voterPendingStake,\n        uint256 voterPendingUnStake,\n        uint256 cumulativeActiveStake,\n        uint256 cumulativePendingStake\n    );\n\n    event RequestedUnstake(\n        address indexed voter,\n        uint256 amount,\n        uint256 unstakeTime,\n        uint256 voterActiveStake,\n        uint256 voterPendingStake\n    );\n\n    event ExecutedUnstake(\n        address indexed voter,\n        uint256 tokensSent,\n        uint256 voterActiveStake,\n        uint256 voterPendingStake\n    );\n\n    event WithdrawnRewards(address indexed voter, uint256 tokensWithdrawn);\n\n    event UpdatedReward(address indexed voter, uint256 newReward, uint256 lastUpdateTime);\n\n    event UpdatedActiveStake(\n        address indexed voter,\n        uint256 voterActiveStake,\n        uint256 voterPendingStake,\n        uint256 cumulativeActiveStake,\n        uint256 cumulativePendingStake\n    );\n\n    event SetNewEmissionRate(uint256 newEmissionRate);\n\n    event SetNewUnstakeCooldown(uint256 newUnstakeCooldown);\n\n    /**\n     * @notice Construct the Staker contract\n     * @param _emissionRate amount of voting tokens that are emitted per second, split prorate to stakers.\n     * @param _unstakeCoolDown time that a voter must wait to unstake after requesting to unstake.\n     *  to be voted on in the next round. If after this, the request is rolled to a round after the next round.\n     * @param _votingToken address of the UMA token contract used to commit votes.\n     */\n    constructor(\n        uint256 _emissionRate,\n        uint64 _unstakeCoolDown,\n        address _votingToken\n    ) {\n        emissionRate = _emissionRate;\n        unstakeCoolDown = _unstakeCoolDown;\n        votingToken = VotingToken(_votingToken);\n    }\n\n    /****************************************\n     *           STAKER FUNCTIONS           *\n     ****************************************/\n\n    /**\n     * @notice Pulls tokens from users wallet and stakes them. If we are in a active reveal phase the stake amount will\n     * be added to the pending stake. If not, the stake amount will be added to the active stake.\n     * @param amount the amount of tokens to stake.\n     */\n    function stake(uint256 amount) public override {\n        VoterStake storage voterStake = voterStakes[msg.sender];\n        // If the staker has a cumulative staked balance of 0 then we can shortcut their lastRequestIndexConsidered to\n        // the most recent index. This means we don't need to traverse requests where the staker was not staked.\n        // getStartingIndexForStaker returns the appropriate index to start at.\n        if (getVoterStake(msg.sender) + voterStake.pendingUnstake == 0)\n            voterStake.lastRequestIndexConsidered = getStartingIndexForStaker();\n        _updateTrackers(msg.sender);\n\n        if (inActiveReveal()) {\n            voterStake.pendingStake += amount;\n            cumulativePendingStake += amount;\n        } else {\n            voterStake.activeStake += amount;\n            cumulativeActiveStake += amount;\n        }\n\n        votingToken.transferFrom(msg.sender, address(this), amount);\n        emit Staked(\n            msg.sender,\n            amount,\n            voterStake.activeStake,\n            voterStake.pendingStake,\n            voterStake.pendingUnstake,\n            cumulativeActiveStake,\n            cumulativePendingStake\n        );\n    }\n\n    /**\n     * @notice Request a certain number of tokens to be unstaked. After the unstake time expires, the user may execute\n     * the unstake. Tokens requested to unstake are not slashable nor subject to earning rewards.\n     * This function cannot be called during an active reveal phase.\n     * Note that there is no way to cancel an unstake request, you must wait until after unstakeRequestTime and re-stake.\n     * @param amount the amount of tokens to request to be unstaked.\n     */\n    function requestUnstake(uint256 amount) public override {\n        require(!inActiveReveal(), \"In an active reveal phase\");\n        _updateTrackers(msg.sender);\n        VoterStake storage voterStake = voterStakes[msg.sender];\n\n        require(voterStake.activeStake >= amount, \"Bad request amount\");\n        require(voterStake.pendingUnstake == 0, \"Have previous request unstake\");\n\n        cumulativeActiveStake -= amount;\n        voterStake.pendingUnstake = amount;\n        voterStake.activeStake -= amount;\n        voterStake.unstakeRequestTime = SafeCast.toUint64(getCurrentTime());\n\n        emit RequestedUnstake(\n            msg.sender,\n            amount,\n            voterStake.unstakeRequestTime,\n            voterStake.activeStake,\n            voterStake.pendingStake\n        );\n    }\n\n    /**\n     * @notice  Execute a previously requested unstake. Requires the unstake time to have passed.\n     * @dev If a staker requested an unstake and time > unstakeRequestTime then send funds to staker. Note that this\n     * method assumes that the `updateTrackers().\n     */\n    function executeUnstake() public override {\n        VoterStake storage voterStake = voterStakes[msg.sender];\n        require(\n            voterStake.unstakeRequestTime != 0 && getCurrentTime() >= voterStake.unstakeRequestTime + unstakeCoolDown,\n            \"Unstake time not passed\"\n        );\n        uint256 tokensToSend = voterStake.pendingUnstake;\n\n        if (tokensToSend > 0) {\n            voterStake.pendingUnstake = 0;\n            voterStake.unstakeRequestTime = 0;\n            votingToken.transfer(msg.sender, tokensToSend);\n        }\n\n        emit ExecutedUnstake(msg.sender, tokensToSend, voterStake.activeStake, voterStake.pendingStake);\n    }\n\n    /**\n     * @notice Send accumulated rewards to the voter. Note that these rewards do not include slashing balance changes.\n     * @return uint256 the amount of tokens sent to the voter.\n     */\n    function withdrawRewards() public override returns (uint256) {\n        _updateTrackers(msg.sender);\n        VoterStake storage voterStake = voterStakes[msg.sender];\n\n        uint256 tokensToMint = voterStake.outstandingRewards;\n        if (tokensToMint > 0) {\n            voterStake.outstandingRewards = 0;\n            require(votingToken.mint(msg.sender, tokensToMint), \"Voting token issuance failed\");\n        }\n        emit WithdrawnRewards(msg.sender, tokensToMint);\n        return (tokensToMint);\n    }\n\n    /**\n     * @notice Stake accumulated rewards. This is just a convenience method that combines withdraw with stake in the\n     * same transaction.\n     * @dev this method requires that the user has approved this contract.\n     * @return uint256 the amount of tokens that the user is staking.\n     */\n    function withdrawAndRestake() public returns (uint256) {\n        uint256 rewards = withdrawRewards();\n        stake(rewards);\n        return rewards;\n    }\n\n    /****************************************\n     *        OWNER ADMIN FUNCTIONS         *\n     ****************************************/\n\n    /**\n     * @notice  Set the token's emission rate, the number of voting tokens that are emitted per second per staked token,\n     * split prorate to stakers.\n     * @param _emissionRate the new amount of voting tokens that are emitted per second, split prorate to stakers.\n     */\n    function setEmissionRate(uint256 _emissionRate) public onlyOwner {\n        _updateReward(address(0));\n        emissionRate = _emissionRate;\n        emit SetNewEmissionRate(emissionRate);\n    }\n\n    /**\n     * @notice  Set the amount of time a voter must wait to unstake after submitting a request to do so.\n     * @param _unstakeCoolDown the new duration of the cool down period in seconds.\n     */\n    function setUnstakeCoolDown(uint64 _unstakeCoolDown) public onlyOwner {\n        unstakeCoolDown = _unstakeCoolDown;\n        emit SetNewUnstakeCooldown(unstakeCoolDown);\n    }\n\n    function _updateTrackers(address voterAddress) internal virtual {\n        _updateReward(voterAddress);\n        _updateActiveStake(voterAddress);\n    }\n\n    /****************************************\n     *            VIEW FUNCTIONS            *\n     ****************************************/\n\n    /**\n     * @notice  Determine the number of outstanding token rewards that can be withdrawn by a voter.\n     * @param voterAddress the address of the voter.\n     * @return uint256 the outstanding rewards.\n     */\n    function outstandingRewards(address voterAddress) public view returns (uint256) {\n        VoterStake storage voterStake = voterStakes[voterAddress];\n\n        return\n            ((getVoterStake(voterAddress) * (rewardPerToken() - voterStake.rewardsPaidPerToken)) / 1e18) +\n            voterStake.outstandingRewards;\n    }\n\n    /**\n     * @notice  Calculate the reward per token based on the last time the reward was updated.\n     * @return uint256 the reward per token.\n     */\n    function rewardPerToken() public view returns (uint256) {\n        if (getCumulativeStake() == 0) return rewardPerTokenStored;\n        return\n            rewardPerTokenStored + ((getCurrentTime() - lastUpdateTime) * emissionRate * 1e18) / getCumulativeStake();\n    }\n\n    /**\n     * @notice  Returns the total amount of tokens staked. This is the sum of the active stake and the pending stake.\n     * @return uint256 the cumulative stake.\n     */\n    function getCumulativeStake() public view returns (uint256) {\n        return cumulativeActiveStake + cumulativePendingStake;\n    }\n\n    /**\n     * @notice  Returns the total amount of tokens staked by the voter.\n     * @param voterAddress the address of the voter.\n     * @return uint256 the total stake.\n     */\n    function getVoterStake(address voterAddress) public view returns (uint256) {\n        return voterStakes[voterAddress].activeStake + voterStakes[voterAddress].pendingStake;\n    }\n\n    /**\n     * @notice Returns the current block timestamp.\n     * @dev Can be overridden to control contract time.\n     */\n    function getCurrentTime() public view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    /****************************************\n     *          INTERNAL FUNCTIONS          *\n     ****************************************/\n\n    // Determine if we are in an active reveal phase. This function should be overridden by the child contract.\n    function inActiveReveal() internal virtual returns (bool) {\n        return false;\n    }\n\n    function getStartingIndexForStaker() internal virtual returns (uint64) {\n        return 0;\n    }\n\n    // Calculate the reward per token based on last time the reward was updated.\n    function _updateReward(address voterAddress) internal {\n        uint256 newRewardPerToken = rewardPerToken();\n        rewardPerTokenStored = newRewardPerToken;\n        lastUpdateTime = SafeCast.toUint64(getCurrentTime());\n        if (voterAddress != address(0)) {\n            VoterStake storage voterStake = voterStakes[voterAddress];\n            voterStake.outstandingRewards = outstandingRewards(voterAddress);\n            voterStake.rewardsPaidPerToken = newRewardPerToken;\n        }\n        emit UpdatedReward(voterAddress, newRewardPerToken, lastUpdateTime);\n    }\n\n    // Updates the active stake of the voter if not in an active reveal phase.\n    function _updateActiveStake(address voterAddress) internal {\n        if (voterStakes[voterAddress].pendingStake == 0 || inActiveReveal()) return;\n        cumulativeActiveStake += voterStakes[voterAddress].pendingStake;\n        cumulativePendingStake -= voterStakes[voterAddress].pendingStake;\n        voterStakes[voterAddress].activeStake += voterStakes[voterAddress].pendingStake;\n        voterStakes[voterAddress].pendingStake = 0;\n\n        emit UpdatedActiveStake(\n            voterAddress,\n            voterStakes[voterAddress].activeStake,\n            voterStakes[voterAddress].pendingStake,\n            cumulativeActiveStake,\n            cumulativePendingStake\n        );\n    }\n}"
    },
    {
      "filename": "packages/core/contracts/oracle/implementation/Staker.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"../../common/implementation/Testable.sol\";\n\nimport \"./VotingToken.sol\";\nimport \"../interfaces/StakerInterface.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n/**\n * @title Staking contract enabling UMA to be locked up by stakers to earn a prorate share of a fixed emission rate.\n * @dev Handles the staking, unstaking and reward retrieval logic.\n */\ncontract Staker is StakerInterface, Ownable {\n    /****************************************\n     *           STAKING TRACKERS           *\n     ****************************************/\n\n    uint256 public emissionRate;\n    uint256 public cumulativeActiveStake;\n    uint256 public cumulativePendingStake;\n    uint256 public rewardPerTokenStored;\n\n    VotingToken public override votingToken;\n    uint64 public lastUpdateTime;\n    uint64 public unstakeCoolDown;\n\n    struct VoterStake {\n        uint256 activeStake;\n        uint256 pendingUnstake;\n        uint256 pendingStake;\n        uint256 rewardsPaidPerToken;\n        uint256 outstandingRewards;\n        uint64 lastRequestIndexConsidered;\n        uint64 unstakeRequestTime;\n        address delegate;\n    }\n\n    mapping(address => VoterStake) public voterStakes;\n    mapping(address => address) public delegateToStaker;\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n\n    event Staked(\n        address indexed voter,\n        uint256 amount,\n        uint256 voterActiveStake,\n        uint256 voterPendingStake,\n        uint256 voterPendingUnStake,\n        uint256 cumulativeActiveStake,\n        uint256 cumulativePendingStake\n    );\n\n    event RequestedUnstake(\n        address indexed voter,\n        uint256 amount,\n        uint256 unstakeTime,\n        uint256 voterActiveStake,\n        uint256 voterPendingStake\n    );\n\n    event ExecutedUnstake(\n        address indexed voter,\n        uint256 tokensSent,\n        uint256 voterActiveStake,\n        uint256 voterPendingStake\n    );\n\n    event WithdrawnRewards(address indexed voter, uint256 tokensWithdrawn);\n\n    event UpdatedReward(address indexed voter, uint256 newReward, uint256 lastUpdateTime);\n\n    event UpdatedActiveStake(\n        address indexed voter,\n        uint256 voterActiveStake,\n        uint256 voterPendingStake,\n        uint256 cumulativeActiveStake,\n        uint256 cumulativePendingStake\n    );\n\n    event SetNewEmissionRate(uint256 newEmissionRate);\n\n    event SetNewUnstakeCooldown(uint256 newUnstakeCooldown);\n\n    /**\n     * @notice Construct the Staker contract\n     * @param _emissionRate amount of voting tokens that are emitted per second, split prorate to stakers.\n     * @param _unstakeCoolDown time that a voter must wait to unstake after requesting to unstake.\n     *  to be voted on in the next round. If after this, the request is rolled to a round after the next round.\n     * @param _votingToken address of the UMA token contract used to commit votes.\n     */\n    constructor(\n        uint256 _emissionRate,\n        uint64 _unstakeCoolDown,\n        address _votingToken\n    ) {\n        emissionRate = _emissionRate;\n        unstakeCoolDown = _unstakeCoolDown;\n        votingToken = VotingToken(_votingToken);\n    }\n\n    /****************************************\n     *           STAKER FUNCTIONS           *\n     ****************************************/\n\n    /**\n     * @notice Pulls tokens from users wallet and stakes them. If we are in a active reveal phase the stake amount will\n     * be added to the pending stake. If not, the stake amount will be added to the active stake.\n     * @param amount the amount of tokens to stake.\n     */\n    function stake(uint256 amount) public override {\n        VoterStake storage voterStake = voterStakes[msg.sender];\n        // If the staker has a cumulative staked balance of 0 then we can shortcut their lastRequestIndexConsidered to\n        // the most recent index. This means we don't need to traverse requests where the staker was not staked.\n        // getStartingIndexForStaker returns the appropriate index to start at.\n        if (getVoterStake(msg.sender) + voterStake.pendingUnstake == 0)\n            voterStake.lastRequestIndexConsidered = getStartingIndexForStaker();\n        _updateTrackers(msg.sender);\n\n        if (inActiveReveal()) {\n            voterStake.pendingStake += amount;\n            cumulativePendingStake += amount;\n        } else {\n            voterStake.activeStake += amount;\n            cumulativeActiveStake += amount;\n        }\n\n        votingToken.transferFrom(msg.sender, address(this), amount);\n        emit Staked(\n            msg.sender,\n            amount,\n            voterStake.activeStake,\n            voterStake.pendingStake,\n            voterStake.pendingUnstake,\n            cumulativeActiveStake,\n            cumulativePendingStake\n        );\n    }\n\n    /**\n     * @notice Request a certain number of tokens to be unstaked. After the unstake time expires, the user may execute\n     * the unstake. Tokens requested to unstake are not slashable nor subject to earning rewards.\n     * This function cannot be called during an active reveal phase.\n     * Note that there is no way to cancel an unstake request, you must wait until after unstakeRequestTime and re-stake.\n     * @param amount the amount of tokens to request to be unstaked.\n     */\n    function requestUnstake(uint256 amount) public override {\n        require(!inActiveReveal(), \"In an active reveal phase\");\n        _updateTrackers(msg.sender);\n        VoterStake storage voterStake = voterStakes[msg.sender];"
    }
  ]
}