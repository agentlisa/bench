{
  "Title": "[L01] Abi.encodePacked function receives dynamic-sized parameters",
  "Content": "The [`checkProofOfPossession` function](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/UsingPrecompiles.sol#L149-L157) of the `UsingPrecompiles` contract uses both [dynamic-sized variables `blsKey` and `blsPop`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/UsingPrecompiles.sol#L155) as the parameters of the `encodePacked` function.\n\n\nAs stated in the [Solidity documentation webpage](https://solidity.readthedocs.io/en/v0.5.15/abi-spec.html) it is easy to craft collisions if more than one parameter of the `encodePacked` function is dynamically-sized. \n\n\nAlthough no attack vector has been identified from this behavior, consider using `abi.encode` instead.\n\n\n****Update:*** Not fixed. cLabs’ statement for this issue:*\n\n\n\n> \n> `Abi.encodePacked`​ is used here to concatenate bytes before they are passed on to a precompile. The length of these arrays are checked in `Validator._updateBlsPublicKey`​. Perhaps it would be helpful to check that here or change the parameter types. On the other hand, it’s possible to call the precompile using any arguments without using this method.\n> \n> \n> \n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/common/UsingPrecompiles.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\ncontract UsingPrecompiles {\n  using SafeMath for uint256;\n\n  address constant TRANSFER = address(0xff - 2);\n  address constant FRACTION_MUL = address(0xff - 3);\n  address constant PROOF_OF_POSSESSION = address(0xff - 4);\n  address constant GET_VALIDATOR = address(0xff - 5);\n  address constant NUMBER_VALIDATORS = address(0xff - 6);\n  address constant EPOCH_SIZE = address(0xff - 7);\n  address constant BLOCK_NUMBER_FROM_HEADER = address(0xff - 8);\n  address constant HASH_HEADER = address(0xff - 9);\n  address constant GET_PARENT_SEAL_BITMAP = address(0xff - 10);\n  address constant GET_VERIFIED_SEAL_BITMAP = address(0xff - 11);\n\n  /**\n   * @notice calculate a * b^x for fractions a, b to `decimals` precision\n   * @param aNumerator Numerator of first fraction\n   * @param aDenominator Denominator of first fraction\n   * @param bNumerator Numerator of exponentiated fraction\n   * @param bDenominator Denominator of exponentiated fraction\n   * @param exponent exponent to raise b to\n   * @param _decimals precision\n   * @return numerator/denominator of the computed quantity (not reduced).\n   */\n  function fractionMulExp(\n    uint256 aNumerator,\n    uint256 aDenominator,\n    uint256 bNumerator,\n    uint256 bDenominator,\n    uint256 exponent,\n    uint256 _decimals\n  ) public view returns (uint256, uint256) {\n    require(aDenominator != 0 && bDenominator != 0);\n    uint256 returnNumerator;\n    uint256 returnDenominator;\n    bool success;\n    bytes memory out;\n    (success, out) = FRACTION_MUL.staticcall(\n      abi.encodePacked(aNumerator, aDenominator, bNumerator, bDenominator, exponent, _decimals)\n    );\n    require(\n      success,\n      \"UsingPrecompiles :: fractionMulExp Unsuccessful invocation of fraction exponent\"\n    );\n    returnNumerator = getUint256FromBytes(out, 0);\n    returnDenominator = getUint256FromBytes(out, 32);\n    return (returnNumerator, returnDenominator);\n  }\n\n  /**\n   * @notice Returns the current epoch size in blocks.\n   * @return The current epoch size in blocks.\n   */\n  function getEpochSize() public view returns (uint256) {\n    bytes memory out;\n    bool success;\n    (success, out) = EPOCH_SIZE.staticcall(abi.encodePacked());\n    require(success);\n    return getUint256FromBytes(out, 0);\n  }\n\n  /**\n   * @notice Returns the epoch number at a block.\n   * @param blockNumber Block number where epoch number is calculated.\n   * @return Epoch number.\n   */\n  function getEpochNumberOfBlock(uint256 blockNumber) public view returns (uint256) {\n    uint256 sz = getEpochSize();\n    return blockNumber.sub(1) / sz;\n  }\n\n  /**\n   * @notice Returns the epoch number at a block.\n   * @return Current epoch number.\n   */\n  function getEpochNumber() public view returns (uint256) {\n    return getEpochNumberOfBlock(block.number);\n  }\n\n  /**\n   * @notice Gets a validator address from the current validator set.\n   * @param index Index of requested validator in the validator set.\n   * @return Address of validator at the requested index.\n   */\n  function validatorSignerAddressFromCurrentSet(uint256 index) public view returns (address) {\n    bytes memory out;\n    bool success;\n    (success, out) = GET_VALIDATOR.staticcall(abi.encodePacked(index, uint256(block.number)));\n    require(success);\n    return address(getUint256FromBytes(out, 0));\n  }\n\n  /**\n   * @notice Gets a validator address from the validator set at the given block number.\n   * @param index Index of requested validator in the validator set.\n   * @param blockNumber Block number to retrieve the validator set from.\n   * @return Address of validator at the requested index.\n   */\n  function validatorSignerAddressFromSet(uint256 index, uint256 blockNumber)\n    public\n    view\n    returns (address)\n  {\n    bytes memory out;\n    bool success;\n    (success, out) = GET_VALIDATOR.staticcall(abi.encodePacked(index, blockNumber));\n    require(success);\n    return address(getUint256FromBytes(out, 0));\n  }\n\n  /**\n   * @notice Gets the size of the current elected validator set.\n   * @return Size of the current elected validator set.\n   */\n  function numberValidatorsInCurrentSet() public view returns (uint256) {\n    bytes memory out;\n    bool success;\n    (success, out) = NUMBER_VALIDATORS.staticcall(abi.encodePacked(uint256(block.number)));\n    require(success);\n    return getUint256FromBytes(out, 0);\n  }\n\n  /**\n   * @notice Gets the size of the validator set that must sign the given block number.\n   * @param blockNumber Block number to retrieve the validator set from.\n   * @return Size of the validator set.\n   */\n  function numberValidatorsInSet(uint256 blockNumber) public view returns (uint256) {\n    bytes memory out;\n    bool success;\n    (success, out) = NUMBER_VALIDATORS.staticcall(abi.encodePacked(blockNumber));\n    require(success);\n    return getUint256FromBytes(out, 0);\n  }\n\n  /**\n   * @notice Checks a BLS proof of possession.\n   * @param sender The address signed by the BLS key to generate the proof of possession.\n   * @param blsKey The BLS public key that the validator is using for consensus, should pass proof\n   *   of possession. 48 bytes.\n   * @param blsPop The BLS public key proof-of-possession, which consists of a signature on the\n   *   account address. 96 bytes.\n   * @return True upon success.\n   */\n  function checkProofOfPossession(address sender, bytes memory blsKey, bytes memory blsPop)\n    public\n    view\n    returns (bool)\n  {\n    bool success;\n    (success, ) = PROOF_OF_POSSESSION.staticcall(abi.encodePacked(sender, blsKey, blsPop));\n    return success;\n  }\n\n  /**\n   * @notice Parses block number out of header.\n   * @param header RLP encoded header\n   * @return Block number.\n   */\n  function getBlockNumberFromHeader(bytes memory header) public view returns (uint256) {\n    bytes memory out;\n    bool success;\n    (success, out) = BLOCK_NUMBER_FROM_HEADER.staticcall(abi.encodePacked(header));\n    require(success);\n    return getUint256FromBytes(out, 0);\n  }\n\n  /**\n   * @notice Computes hash of header.\n   * @param header RLP encoded header\n   * @return Header hash.\n   */\n  function hashHeader(bytes memory header) public view returns (bytes32) {\n    bytes memory out;\n    bool success;\n    (success, out) = HASH_HEADER.staticcall(abi.encodePacked(header));\n    require(success);\n    return getBytes32FromBytes(out, 0);\n  }\n\n  /**\n   * @notice Gets the parent seal bitmap from the header at the given block number.\n   * @param blockNumber Block number to retrieve. Must be within 4 epochs of the current number.\n   * @return Bitmap parent seal with set bits at indices correspoinding to signing validators.\n   */\n  function getParentSealBitmap(uint256 blockNumber) public view returns (bytes32) {\n    bytes memory out;\n    bool success;\n    (success, out) = GET_PARENT_SEAL_BITMAP.staticcall(abi.encodePacked(blockNumber));\n    require(success);\n    return getBytes32FromBytes(out, 0);\n  }\n\n  /**\n   * @notice Verifies the BLS signature on the header and returns the seal bitmap.\n   * The validator set used for verification is retrieved based on the parent hash field of the\n   * header.  If the parent hash is not in the blockchain, verification fails.\n   * @param header RLP encoded header\n   * @return Bitmap parent seal with set bits at indices correspoinding to signing validators.\n   */\n  function getVerifiedSealBitmapFromHeader(bytes memory header) public view returns (bytes32) {\n    bytes memory out;\n    bool success;\n    (success, out) = GET_VERIFIED_SEAL_BITMAP.staticcall(abi.encodePacked(header));\n    require(success);\n    return getBytes32FromBytes(out, 0);\n  }\n\n  /**\n   * @notice Converts bytes to uint256.\n   * @param bs byte[] data\n   * @param start offset into byte data to convert\n   * @return uint256 data\n   */\n  function getUint256FromBytes(bytes memory bs, uint256 start) internal pure returns (uint256) {\n    return uint256(getBytes32FromBytes(bs, start));\n  }\n\n  /**\n   * @notice Converts bytes to bytes32.\n   * @param bs byte[] data\n   * @param start offset into byte data to convert\n   * @return bytes32 data\n   */\n  function getBytes32FromBytes(bytes memory bs, uint256 start) internal pure returns (bytes32) {\n    require(bs.length >= start + 32, \"slicing out of range\");\n    bytes32 x;\n    assembly {\n      x := mload(add(bs, add(start, 32)))\n    }\n    return x;\n  }\n}"
    }
  ]
}