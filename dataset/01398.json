{
  "Title": "H-8: Incorrect approach to tracking the PnL of a DV",
  "Content": "# Issue H-8: Incorrect approach to tracking the PnL of a DV \n\nSource: https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/589 \n\n## Found by \nxiaoming90\n\nA DV might be incorrectly marked as not sitting in a loss, thus allowing users to burn all the DV shares, locking in all the loss of the DV and the vault shareholders.\n\n## Vulnerability Detail\n\nLet $DV_A$ be a certain destination vault.\n\nAssume that at $T0$, the current debt value (`currentDvDebtValue`) of $DV_A$ is 95 WETH, and the last debt value (`updatedDebtBasis`) is 100 WETH. Since the current debt value has become smaller than the last debt value, the vault is making a loss of 5 WETH since the last rebalancing, so $DV_A$ is sitting at a loss, and users can only burn a limited amount of DestinationVault_A's shares.\n\nAssume that at $T1$, there is some slight rebalancing performed on $DV_A$, and a few additional LP tokens are deposited to it. Thus, its current debt value increased to 98 WETH. At the same time, the `destInfo.debtBasis` and `destInfo.ownedShares` will be updated to the current value. \n\nImmediately after the rebalancing, $DV_A$ will not be considered sitting in a loss since the `currentDvDebtValue` and `updatedDebtBasis` should be equal now. As a result, users could now burn all the $DV_A$ shares of the LMPVault during withdrawal.\n\n$DV_A$ suddenly becomes not sitting at a loss even though the fact is that it is still sitting at a loss of 5 WETH. The loss has been written off.\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/libs/LMPDebt.sol#L275\n\n```solidity\nFile: LMPDebt.sol\n274:         // Neither of these numbers include rewards from the DV\n275:         if (currentDvDebtValue < updatedDebtBasis) {\n276:             // We are currently sitting at a loss. Limit the value we can pull from\n277:             // the destination vault\n278:             currentDvDebtValue = currentDvDebtValue.mulDiv(userShares, totalVaultShares, Math.Rounding.Down);\n279:             currentDvShares = currentDvShares.mulDiv(userShares, totalVaultShares, Math.Rounding.Down);\n280:         }\n```\n\n## Impact\n\nA DV might be incorrectly marked as not sitting in a loss, thus allowing users to burn all the DV shares, locking in all the loss of the DV and the vault shareholders.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/libs/LMPDebt.sol#L275\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider a more sophisticated approach to track a DV's Profit and Loss (PnL). \n\nIn our example, $DV_A$ should only be considered not making a loss if the price of the LP tokens starts to appreciate and cover the loss of 5 WETH.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**Trumpero** commented:\n> invalid, it is intended that sitting at a loss is considered by comparing the current debt to the latest recorded debt. Additionally, when it considers not sitting at a loss, it doesn't limit the value can pull but it only pulls enough tokens to withdraw. These withdrawn tokens will not be locked\n\n\n\n**xiaoming9090**\n\nEscalate\n\nThe main point of this report is to highlight the issues with the current algorithm/approach of tracking the PnL of a DV and marking it as sitting on a loss or not, which is obviously incorrect, as shown in my report. I have discussed this issue with the protocol team during the audit period, and the impact is undesirable, as shown below.\n\n![image](https://github.com/sherlock-audit/2023-06-tokemak-judging/assets/102820284/5dcf50f0-0efb-44bd-80b9-5c7720da43fa)\n\nIt should not be confused with how it is intended to be used in other parts of the protocol, which is unrelated. In addition, the intended approach does not mean that those issues/risks are acceptable and thus considered invalid. If the approach is incorrect, those issues must be flagged during the audit. \n\nThus, this is a valid High issue.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> The main point of this report is to highlight the issues with the current algorithm/approach of tracking the PnL of a DV and marking it as sitting on a loss or not, which is obviously incorrect, as shown in my report. I have discussed this issue with the protocol team during the audit period, and the impact is undesirable, as shown below.\n> \n> ![image](https://github.com/sherlock-audit/2023-06-tokemak-judging/assets/102820284/5dcf50f0-0efb-44bd-80b9-5c7720da43fa)\n> \n> It should not be confused with how it is intended to be used in other parts of the protocol, which is unrelated. In addition, the intended approach does not mean that those issues/risks are acceptable and thus considered invalid. If the approach is incorrect, those issues must be flagged during the audit. \n> \n> Thus, this is a valid High issue.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Trumpero**\n\nTks for the clarification @xiaoming9090 \nPlease review this issue as well @codenutt \n\n**codenutt**\n\n> Tks for the clarification @xiaoming9090 Please review this issue as well @codenutt\n\nYup agree with @xiaoming9090 here.\n\n**Evert0x**\n\nPlanning to accept escalation and make issue high severity \n\n@Trumpero \n\n**Trumpero**\n\nAgree with the high severity\n\n**Evert0x**\n\nResult:\nHigh\nUnique \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [xiaoming9090](https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/589/#issuecomment-1748035493): accepted\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/101",
  "Code": [
    {
      "filename": "v2-core-audit-2023-07-14/src/vault/libs/LMPDebt.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\n\npragma solidity 0.8.17;\n\nimport { Errors } from \"src/utils/Errors.sol\";\nimport { IDestinationVault } from \"src/interfaces/vault/IDestinationVault.sol\";\nimport { Math } from \"openzeppelin-contracts/utils/math/Math.sol\";\nimport { EnumerableSet } from \"openzeppelin-contracts/utils/structs/EnumerableSet.sol\";\nimport { IStrategy } from \"src/interfaces/strategy/IStrategy.sol\";\nimport { SafeERC20 } from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20Metadata as IERC20 } from \"openzeppelin-contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { ISystemRegistry, IDestinationVaultRegistry } from \"src/interfaces/ISystemRegistry.sol\";\nimport { IERC3156FlashBorrower } from \"openzeppelin-contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport { LMPStrategy } from \"src/strategy/LMPStrategy.sol\";\n\nlibrary LMPDebt {\n    using Math for uint256;\n    using SafeERC20 for IERC20;\n\n    error VaultShutdown();\n    error WithdrawShareCalcInvalid(uint256 currentShares, uint256 cachedShares);\n    error RebalanceDestinationsMatch(address destinationVault);\n    error RebalanceFailed(string message);\n\n    struct DestinationInfo {\n        /// @notice Current underlying and reward value at the destination vault\n        /// @dev Used for calculating totalDebt of the LMPVault\n        uint256 currentDebt;\n        /// @notice Last block timestamp this info was updated\n        uint256 lastReport;\n        /// @notice How many shares of the destination vault we owned at last report\n        uint256 ownedShares;\n        /// @notice Amount of baseAsset transferred out in service of deployments\n        /// @dev Used for calculating 'in profit' or not during user withdrawals\n        uint256 debtBasis;\n    }\n\n    struct RebalanceOutParams {\n        /// Address that will received the withdrawn underlyer\n        address receiver;\n        /// The \"out\" destination vault\n        address destinationOut;\n        /// The amount of tokenOut that will be withdrawn\n        uint256 amountOut;\n        /// The underlyer for destinationOut\n        address tokenOut;\n        IERC20 _baseAsset;\n        bool _shutdown;\n    }\n\n    /// @dev In memory struct only for managing vars in rebalances\n    struct IdleDebtChange {\n        uint256 debtDecrease;\n        uint256 debtIncrease;\n        uint256 idleDecrease;\n        uint256 idleIncrease;\n    }\n\n    struct FlashRebalanceParams {\n        uint256 totalIdle;\n        uint256 totalDebt;\n        IERC20 baseAsset;\n        bool shutdown;\n    }\n\n    function rebalance(\n        DestinationInfo storage destInfoOut,\n        DestinationInfo storage destInfoIn,\n        IStrategy.RebalanceParams memory params,\n        IERC20 baseAsset,\n        bool shutdown,\n        uint256 totalIdle,\n        uint256 totalDebt\n    ) external returns (uint256 idle, uint256 debt) {\n        LMPDebt.IdleDebtChange memory idleDebtChange;\n\n        // make sure there's something to do\n        if (params.amountIn == 0 && params.amountOut == 0) {\n            revert Errors.InvalidParams();\n        }\n\n        if (params.destinationIn == params.destinationOut) {\n            revert RebalanceDestinationsMatch(params.destinationOut);\n        }\n\n        // make sure we have a valid path\n        {\n            (bool success, string memory message) = LMPStrategy.verifyRebalance(params);\n            if (!success) {\n                revert RebalanceFailed(message);\n            }\n        }\n\n        // Handle decrease (shares going \"Out\", cashing in shares and sending underlying back to swapper)\n        // If the tokenOut is _asset we assume they are taking idle\n        // which is already in the contract\n        idleDebtChange = _handleRebalanceOut(\n            LMPDebt.RebalanceOutParams({\n                receiver: msg.sender,\n                destinationOut: params.destinationOut,\n                amountOut: params.amountOut,\n                tokenOut: params.tokenOut,\n                _baseAsset: baseAsset,\n                _shutdown: shutdown\n            }),\n            destInfoOut\n        );\n\n        // Handle increase (shares coming \"In\", getting underlying from the swapper and trading for new shares)\n        if (params.amountIn > 0) {\n            // transfer dv underlying lp from swapper to here\n            IERC20(params.tokenIn).safeTransferFrom(msg.sender, address(this), params.amountIn);\n\n            // deposit to dv (already checked in `verifyRebalance` so no need to check return of deposit)\n\n            if (params.tokenIn != address(baseAsset)) {\n                IDestinationVault dvIn = IDestinationVault(params.destinationIn);\n                (uint256 debtDecreaseIn, uint256 debtIncreaseIn) =\n                    _handleRebalanceIn(destInfoIn, dvIn, params.tokenIn, params.amountIn);\n                idleDebtChange.debtDecrease += debtDecreaseIn;\n                idleDebtChange.debtIncrease += debtIncreaseIn;\n            } else {\n                idleDebtChange.idleIncrease += params.amountIn;\n            }\n        }\n\n        {\n            idle = totalIdle;\n            debt = totalDebt;\n\n            if (idleDebtChange.idleDecrease > 0 || idleDebtChange.idleIncrease > 0) {\n                idle = idle + idleDebtChange.idleIncrease - idleDebtChange.idleDecrease;\n            }\n\n            if (idleDebtChange.debtDecrease > 0 || idleDebtChange.debtIncrease > 0) {\n                debt = debt + idleDebtChange.debtIncrease - idleDebtChange.debtDecrease;\n            }\n        }\n    }\n\n    function flashRebalance(\n        DestinationInfo storage destInfoOut,\n        DestinationInfo storage destInfoIn,\n        IERC3156FlashBorrower receiver,\n        IStrategy.RebalanceParams memory params,\n        FlashRebalanceParams memory flashParams,\n        bytes calldata data\n    ) external returns (uint256 idle, uint256 debt) {\n        LMPDebt.IdleDebtChange memory idleDebtChange;\n\n        // make sure there's something to do\n        if (params.amountIn == 0 && params.amountOut == 0) {\n            revert Errors.InvalidParams();\n        }\n\n        if (params.destinationIn == params.destinationOut) {\n            revert RebalanceDestinationsMatch(params.destinationOut);\n        }\n\n        // make sure we have a valid path\n        {\n            (bool success, string memory message) = LMPStrategy.verifyRebalance(params);\n            if (!success) {\n                revert RebalanceFailed(message);\n            }\n        }\n\n        // Handle decrease (shares going \"Out\", cashing in shares and sending underlying back to swapper)\n        // If the tokenOut is _asset we assume they are taking idle\n        // which is already in the contract\n        idleDebtChange = _handleRebalanceOut(\n            LMPDebt.RebalanceOutParams({\n                receiver: address(receiver),\n                destinationOut: params.destinationOut,\n                amountOut: params.amountOut,\n                tokenOut: params.tokenOut,\n                _baseAsset: flashParams.baseAsset,\n                _shutdown: flashParams.shutdown\n            }),\n            destInfoOut\n        );\n\n        // Handle increase (shares coming \"In\", getting underlying from the swapper and trading for new shares)\n        if (params.amountIn > 0) {\n            IDestinationVault dvIn = IDestinationVault(params.destinationIn);\n\n            // get \"before\" counts\n            uint256 tokenInBalanceBefore = IERC20(params.tokenIn).balanceOf(address(this));\n\n            // Give control back to the solver so they can make use of the \"out\" assets\n            // and get our \"in\" asset\n            bytes32 flashResult = receiver.onFlashLoan(msg.sender, params.tokenIn, params.amountIn, 0, data);\n\n            // We assume the solver will send us the assets\n            uint256 tokenInBalanceAfter = IERC20(params.tokenIn).balanceOf(address(this));\n\n            // Make sure the call was successful and verify we have at least the assets we think\n            // we were getting\n            if (\n                flashResult != keccak256(\"ERC3156FlashBorrower.onFlashLoan\")\n                    || tokenInBalanceAfter < tokenInBalanceBefore + params.amountIn\n            ) {\n                revert Errors.FlashLoanFailed(params.tokenIn, params.amountIn);\n            }\n\n            if (params.tokenIn != address(flashParams.baseAsset)) {\n                (uint256 debtDecreaseIn, uint256 debtIncreaseIn) =\n                    _handleRebalanceIn(destInfoIn, dvIn, params.tokenIn, tokenInBalanceAfter);\n                idleDebtChange.debtDecrease += debtDecreaseIn;\n                idleDebtChange.debtIncrease += debtIncreaseIn;\n            } else {\n                idleDebtChange.idleIncrease += tokenInBalanceAfter - tokenInBalanceBefore;\n            }\n        }\n\n        {\n            idle = flashParams.totalIdle;\n            debt = flashParams.totalDebt;\n\n            if (idleDebtChange.idleDecrease > 0 || idleDebtChange.idleIncrease > 0) {\n                idle = idle + idleDebtChange.idleIncrease - idleDebtChange.idleDecrease;\n            }\n\n            if (idleDebtChange.debtDecrease > 0 || idleDebtChange.debtIncrease > 0) {\n                debt = debt + idleDebtChange.debtIncrease - idleDebtChange.debtDecrease;\n            }\n        }\n    }\n\n    function _calcUserWithdrawSharesToBurn(\n        DestinationInfo storage destInfo,\n        IDestinationVault destVault,\n        uint256 userShares,\n        uint256 maxAssetsToPull,\n        uint256 totalVaultShares\n    ) external returns (uint256 sharesToBurn, uint256 totalDebtBurn) {\n        // Figure out how many shares we can burn from the destination as well\n        // as what our totalDebt deduction should be (totalDebt being a cached value).\n        // If the destination vault is currently sitting at a profit, then the user can burn\n        // all the shares this vault owns. If its at a loss, they can only burn an amount\n        // proportional to their ownership of this vault. This is so a user doesn't lock in\n        // a loss for the entire vault during their withdrawal\n\n        uint256 currentDvShares = destVault.balanceOf(address(this));\n\n        // slither-disable-next-line incorrect-equality\n        if (currentDvShares == 0) {\n            return (0, 0);\n        }\n\n        // Calculate the current value of our shares\n        uint256 currentDvDebtValue = destVault.debtValue(currentDvShares);\n\n        // Get the basis for the current deployment\n        uint256 cachedDebtBasis = destInfo.debtBasis;\n\n        // The amount of shares we had at the last debt reporting\n        uint256 cachedDvShares = destInfo.ownedShares;\n\n        // The value of our debt + earned rewards at last debt reporting\n        uint256 cachedCurrentDebt = destInfo.currentDebt;\n\n        // Our current share balance should only ever be lte the last snapshot\n        // Any update to the deployment should update the snapshot and withdrawals\n        // can only lower it\n        if (currentDvShares > cachedDvShares) {\n            revert WithdrawShareCalcInvalid(currentDvShares, cachedDvShares);\n        }\n\n        // Recalculated what the debtBasis is with the current number of shares\n        uint256 updatedDebtBasis = cachedDebtBasis.mulDiv(currentDvShares, cachedDvShares, Math.Rounding.Up);\n\n        // Neither of these numbers include rewards from the DV\n        if (currentDvDebtValue < updatedDebtBasis) {\n            // We are currently sitting at a loss. Limit the value we can pull from\n            // the destination vault\n            currentDvDebtValue = currentDvDebtValue.mulDiv(userShares, totalVaultShares, Math.Rounding.Down);\n            currentDvShares = currentDvShares.mulDiv(userShares, totalVaultShares, Math.Rounding.Down);\n        }\n\n        // Shouldn't pull more than we want\n        // Or, we're not in profit so we limit the pull\n        if (currentDvDebtValue < maxAssetsToPull) {\n            maxAssetsToPull = currentDvDebtValue;\n        }\n\n        // Calculate the portion of shares to burn based on the assets we need to pull\n        // and the current total debt value. These are destination vault shares.\n        sharesToBurn = currentDvShares.mulDiv(maxAssetsToPull, currentDvDebtValue, Math.Rounding.Up);\n\n        // This is what will be deducted from totalDebt with the withdrawal. The totalDebt number\n        // is calculated based on the cached values so we need to be sure to reduce it\n        // proportional to the original cached debt value\n        totalDebtBurn = cachedCurrentDebt.mulDiv(sharesToBurn, cachedDvShares, Math.Rounding.Up);\n    }\n\n    /// @notice Perform deposit and debt info update for the \"in\" destination during a rebalance\n    /// @dev This \"in\" function performs less validations than its \"out\" version\n    /// @param dvIn The \"in\" destination vault\n    /// @param tokenIn The underlyer for dvIn\n    /// @param depositAmount The amount of tokenIn that will be deposited\n    /// @return debtDecrease The previous amount of debt dvIn accounted for in totalDebt\n    /// @return debtIncrease The current amount of debt dvIn should account for in totalDebt\n    function handleRebalanceIn(\n        DestinationInfo storage destInfo,\n        IDestinationVault dvIn,\n        address tokenIn,\n        uint256 depositAmount\n    ) external returns (uint256 debtDecrease, uint256 debtIncrease) {\n        (debtDecrease, debtIncrease) = _handleRebalanceIn(destInfo, dvIn, tokenIn, depositAmount);\n    }\n\n    /// @notice Perform deposit and debt info update for the \"in\" destination during a rebalance\n    /// @dev This \"in\" function performs less validations than its \"out\" version\n    /// @param dvIn The \"in\" destination vault\n    /// @param tokenIn The underlyer for dvIn\n    /// @param depositAmount The amount of tokenIn that will be deposited\n    /// @return debtDecrease The previous amount of debt dvIn accounted for in totalDebt\n    /// @return debtIncrease The current amount of debt dvIn should account for in totalDebt\n    function _handleRebalanceIn(\n        DestinationInfo storage destInfo,\n        IDestinationVault dvIn,\n        address tokenIn,\n        uint256 depositAmount\n    ) private returns (uint256 debtDecrease, uint256 debtIncrease) {\n        IERC20(tokenIn).safeApprove(address(dvIn), depositAmount);\n\n        // Snapshot our current shares so we know how much to back out\n        uint256 originalShareBal = dvIn.balanceOf(address(this));\n\n        // deposit to dv\n        uint256 newShares = dvIn.depositUnderlying(depositAmount);\n\n        // Update the debt info snapshot\n        (debtDecrease, debtIncrease) =\n            _recalculateDestInfo(destInfo, dvIn, originalShareBal, originalShareBal + newShares, true);\n    }\n\n    /**\n     * @notice Perform withdraw and debt info update for the \"out\" destination during a rebalance\n     * @dev This \"out\" function performs more validations and handles idle as opposed to \"in\" which does not\n     *  debtDecrease The previous amount of debt destinationOut accounted for in totalDebt\n     *  debtIncrease The current amount of debt destinationOut should account for in totalDebt\n     *  idleDecrease Amount of baseAsset that was sent from the vault. > 0 only when tokenOut == baseAsset\n     *  idleIncrease Amount of baseAsset that was claimed from Destination Vault\n     * @param params Rebalance out params\n     * @param destOutInfo The \"out\" destination vault info\n     * @return assetChange debt and idle change data\n     */\n    function handleRebalanceOut(\n        RebalanceOutParams memory params,\n        DestinationInfo storage destOutInfo\n    ) external returns (IdleDebtChange memory assetChange) {\n        (assetChange) = _handleRebalanceOut(params, destOutInfo);\n    }\n\n    /**\n     * @notice Perform withdraw and debt info update for the \"out\" destination during a rebalance\n     * @dev This \"out\" function performs more validations and handles idle as opposed to \"in\" which does not\n     *  debtDecrease The previous amount of debt destinationOut accounted for in totalDebt\n     *  debtIncrease The current amount of debt destinationOut should account for in totalDebt\n     *  idleDecrease Amount of baseAsset that was sent from the vault. > 0 only when tokenOut == baseAsset\n     *  idleIncrease Amount of baseAsset that was claimed from Destination Vault\n     * @param params Rebalance out params\n     * @param destOutInfo The \"out\" destination vault info\n     * @return assetChange debt and idle change data\n     */\n    function _handleRebalanceOut(\n        RebalanceOutParams memory params,\n        DestinationInfo storage destOutInfo\n    ) private returns (IdleDebtChange memory assetChange) {\n        // Handle decrease (shares going \"Out\", cashing in shares and sending underlying back to swapper)\n        // If the tokenOut is _asset we assume they are taking idle\n        // which is already in the contract\n        if (params.amountOut > 0) {\n            if (params.tokenOut != address(params._baseAsset)) {\n                IDestinationVault dvOut = IDestinationVault(params.destinationOut);\n\n                // Snapshot our current shares so we know how much to back out\n                uint256 originalShareBal = dvOut.balanceOf(address(this));\n\n                // Burning our shares will claim any pending baseAsset\n                // rewards and send them to us. Make sure we capture them\n                // so they can end up in idle\n                uint256 beforeBaseAssetBal = params._baseAsset.balanceOf(address(this));\n\n                // withdraw underlying from dv\n                // slither-disable-next-line unused-return\n                dvOut.withdrawUnderlying(params.amountOut, params.receiver);\n\n                assetChange.idleIncrease = params._baseAsset.balanceOf(address(this)) - beforeBaseAssetBal;\n\n                // Update the debt info snapshot\n                (assetChange.debtDecrease, assetChange.debtIncrease) = _recalculateDestInfo(\n                    destOutInfo, dvOut, originalShareBal, originalShareBal - params.amountOut, true\n                );\n            } else {\n                // If we are shutdown then the only operations we should be performing are those that get\n                // the base asset back to the vault. We shouldn't be sending out more\n                if (params._shutdown) {\n                    revert VaultShutdown();\n                }\n                // Working with idle baseAsset which should be in the vault already\n                // Just send it out\n                IERC20(params.tokenOut).safeTransfer(params.receiver, params.amountOut);\n                assetChange.idleDecrease = params.amountOut;\n            }\n        }\n    }\n\n    function recalculateDestInfo(\n        DestinationInfo storage destInfo,\n        IDestinationVault destVault,\n        uint256 originalShares,\n        uint256 currentShares,\n        bool resetDebtBasis\n    ) external returns (uint256 totalDebtDecrease, uint256 totalDebtIncrease) {\n        (totalDebtDecrease, totalDebtIncrease) =\n            _recalculateDestInfo(destInfo, destVault, originalShares, currentShares, resetDebtBasis);\n    }\n\n    function _recalculateDestInfo(\n        DestinationInfo storage destInfo,\n        IDestinationVault destVault,\n        uint256 originalShares,\n        uint256 currentShares,\n        bool resetDebtBasis\n    ) private returns (uint256 totalDebtDecrease, uint256 totalDebtIncrease) {\n        // Figure out what to back out of our totalDebt number.\n        // We could have had withdraws since the last snapshot which means our\n        // cached currentDebt number should be decreased based on the remaining shares\n        // totalDebt is decreased using the same proportion of shares method during withdrawals\n        // so this should represent whatever is remaining.\n\n        // Figure out how much our debt is currently worth\n        uint256 dvDebtValue = destVault.debtValue(currentShares);\n\n        // Calculate what we're backing out based on the original shares\n        uint256 currentDebt = (destInfo.currentDebt * originalShares) / Math.max(destInfo.ownedShares, 1);\n        destInfo.currentDebt = dvDebtValue;\n        destInfo.lastReport = block.timestamp;\n        destInfo.ownedShares = currentShares;\n        if (resetDebtBasis) {\n            destInfo.debtBasis = dvDebtValue;\n        }\n\n        totalDebtDecrease = currentDebt;\n        totalDebtIncrease = dvDebtValue;\n    }\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/src/vault/libs/LMPDebt.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\n\npragma solidity 0.8.17;\n\nimport { Errors } from \"src/utils/Errors.sol\";\nimport { IDestinationVault } from \"src/interfaces/vault/IDestinationVault.sol\";\nimport { Math } from \"openzeppelin-contracts/utils/math/Math.sol\";\nimport { EnumerableSet } from \"openzeppelin-contracts/utils/structs/EnumerableSet.sol\";\nimport { IStrategy } from \"src/interfaces/strategy/IStrategy.sol\";\nimport { SafeERC20 } from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20Metadata as IERC20 } from \"openzeppelin-contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { ISystemRegistry, IDestinationVaultRegistry } from \"src/interfaces/ISystemRegistry.sol\";\nimport { IERC3156FlashBorrower } from \"openzeppelin-contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport { LMPStrategy } from \"src/strategy/LMPStrategy.sol\";\n\nlibrary LMPDebt {\n    using Math for uint256;\n    using SafeERC20 for IERC20;\n\n    error VaultShutdown();\n    error WithdrawShareCalcInvalid(uint256 currentShares, uint256 cachedShares);\n    error RebalanceDestinationsMatch(address destinationVault);\n    error RebalanceFailed(string message);\n\n    struct DestinationInfo {\n        /// @notice Current underlying and reward value at the destination vault\n        /// @dev Used for calculating totalDebt of the LMPVault\n        uint256 currentDebt;\n        /// @notice Last block timestamp this info was updated\n        uint256 lastReport;\n        /// @notice How many shares of the destination vault we owned at last report\n        uint256 ownedShares;\n        /// @notice Amount of baseAsset transferred out in service of deployments\n        /// @dev Used for calculating 'in profit' or not during user withdrawals\n        uint256 debtBasis;\n    }\n\n    struct RebalanceOutParams {\n        /// Address that will received the withdrawn underlyer\n        address receiver;\n        /// The \"out\" destination vault\n        address destinationOut;\n        /// The amount of tokenOut that will be withdrawn\n        uint256 amountOut;\n        /// The underlyer for destinationOut\n        address tokenOut;\n        IERC20 _baseAsset;\n        bool _shutdown;\n    }\n\n    /// @dev In memory struct only for managing vars in rebalances\n    struct IdleDebtChange {\n        uint256 debtDecrease;\n        uint256 debtIncrease;\n        uint256 idleDecrease;\n        uint256 idleIncrease;\n    }\n\n    struct FlashRebalanceParams {\n        uint256 totalIdle;\n        uint256 totalDebt;\n        IERC20 baseAsset;\n        bool shutdown;\n    }\n\n    function rebalance(\n        DestinationInfo storage destInfoOut,\n        DestinationInfo storage destInfoIn,\n        IStrategy.RebalanceParams memory params,\n        IERC20 baseAsset,\n        bool shutdown,\n        uint256 totalIdle,\n        uint256 totalDebt\n    ) external returns (uint256 idle, uint256 debt) {\n        LMPDebt.IdleDebtChange memory idleDebtChange;\n\n        // make sure there's something to do\n        if (params.amountIn == 0 && params.amountOut == 0) {\n            revert Errors.InvalidParams();\n        }\n\n        if (params.destinationIn == params.destinationOut) {\n            revert RebalanceDestinationsMatch(params.destinationOut);\n        }\n\n        // make sure we have a valid path\n        {\n            (bool success, string memory message) = LMPStrategy.verifyRebalance(params);\n            if (!success) {\n                revert RebalanceFailed(message);\n            }\n        }\n\n        // Handle decrease (shares going \"Out\", cashing in shares and sending underlying back to swapper)\n        // If the tokenOut is _asset we assume they are taking idle\n        // which is already in the contract\n        idleDebtChange = _handleRebalanceOut(\n            LMPDebt.RebalanceOutParams({\n                receiver: msg.sender,\n                destinationOut: params.destinationOut,\n                amountOut: params.amountOut,\n                tokenOut: params.tokenOut,\n                _baseAsset: baseAsset,\n                _shutdown: shutdown\n            }),\n            destInfoOut\n        );\n\n        // Handle increase (shares coming \"In\", getting underlying from the swapper and trading for new shares)\n        if (params.amountIn > 0) {\n            // transfer dv underlying lp from swapper to here\n            IERC20(params.tokenIn).safeTransferFrom(msg.sender, address(this), params.amountIn);\n\n            // deposit to dv (already checked in `verifyRebalance` so no need to check return of deposit)\n\n            if (params.tokenIn != address(baseAsset)) {\n                IDestinationVault dvIn = IDestinationVault(params.destinationIn);\n                (uint256 debtDecreaseIn, uint256 debtIncreaseIn) =\n                    _handleRebalanceIn(destInfoIn, dvIn, params.tokenIn, params.amountIn);\n                idleDebtChange.debtDecrease += debtDecreaseIn;\n                idleDebtChange.debtIncrease += debtIncreaseIn;\n            } else {\n                idleDebtChange.idleIncrease += params.amountIn;\n            }\n        }\n\n        {\n            idle = totalIdle;\n            debt = totalDebt;\n\n            if (idleDebtChange.idleDecrease > 0 || idleDebtChange.idleIncrease > 0) {\n                idle = idle + idleDebtChange.idleIncrease - idleDebtChange.idleDecrease;\n            }\n\n            if (idleDebtChange.debtDecrease > 0 || idleDebtChange.debtIncrease > 0) {\n                debt = debt + idleDebtChange.debtIncrease - idleDebtChange.debtDecrease;\n            }\n        }\n    }\n\n    function flashRebalance(\n        DestinationInfo storage destInfoOut,\n        DestinationInfo storage destInfoIn,\n        IERC3156FlashBorrower receiver,\n        IStrategy.RebalanceParams memory params,\n        FlashRebalanceParams memory flashParams,\n        bytes calldata data\n    ) external returns (uint256 idle, uint256 debt) {\n        LMPDebt.IdleDebtChange memory idleDebtChange;\n\n        // make sure there's something to do\n        if (params.amountIn == 0 && params.amountOut == 0) {\n            revert Errors.InvalidParams();\n        }\n\n        if (params.destinationIn == params.destinationOut) {\n            revert RebalanceDestinationsMatch(params.destinationOut);\n        }\n\n        // make sure we have a valid path\n        {\n            (bool success, string memory message) = LMPStrategy.verifyRebalance(params);\n            if (!success) {\n                revert RebalanceFailed(message);\n            }\n        }\n\n        // Handle decrease (shares going \"Out\", cashing in shares and sending underlying back to swapper)\n        // If the tokenOut is _asset we assume they are taking idle\n        // which is already in the contract\n        idleDebtChange = _handleRebalanceOut(\n            LMPDebt.RebalanceOutParams({\n                receiver: address(receiver),\n                destinationOut: params.destinationOut,\n                amountOut: params.amountOut,\n                tokenOut: params.tokenOut,\n                _baseAsset: flashParams.baseAsset,\n                _shutdown: flashParams.shutdown\n            }),\n            destInfoOut\n        );\n\n        // Handle increase (shares coming \"In\", getting underlying from the swapper and trading for new shares)\n        if (params.amountIn > 0) {\n            IDestinationVault dvIn = IDestinationVault(params.destinationIn);\n\n            // get \"before\" counts\n            uint256 tokenInBalanceBefore = IERC20(params.tokenIn).balanceOf(address(this));\n\n            // Give control back to the solver so they can make use of the \"out\" assets\n            // and get our \"in\" asset\n            bytes32 flashResult = receiver.onFlashLoan(msg.sender, params.tokenIn, params.amountIn, 0, data);\n\n            // We assume the solver will send us the assets\n            uint256 tokenInBalanceAfter = IERC20(params.tokenIn).balanceOf(address(this));\n\n            // Make sure the call was successful and verify we have at least the assets we think\n            // we were getting\n            if (\n                flashResult != keccak256(\"ERC3156FlashBorrower.onFlashLoan\")\n                    || tokenInBalanceAfter < tokenInBalanceBefore + params.amountIn\n            ) {\n                revert Errors.FlashLoanFailed(params.tokenIn, params.amountIn);\n            }\n\n            if (params.tokenIn != address(flashParams.baseAsset)) {\n                (uint256 debtDecreaseIn, uint256 debtIncreaseIn) =\n                    _handleRebalanceIn(destInfoIn, dvIn, params.tokenIn, tokenInBalanceAfter);\n                idleDebtChange.debtDecrease += debtDecreaseIn;\n                idleDebtChange.debtIncrease += debtIncreaseIn;\n            } else {\n                idleDebtChange.idleIncrease += tokenInBalanceAfter - tokenInBalanceBefore;\n            }\n        }\n\n        {\n            idle = flashParams.totalIdle;\n            debt = flashParams.totalDebt;\n\n            if (idleDebtChange.idleDecrease > 0 || idleDebtChange.idleIncrease > 0) {\n                idle = idle + idleDebtChange.idleIncrease - idleDebtChange.idleDecrease;\n            }\n\n            if (idleDebtChange.debtDecrease > 0 || idleDebtChange.debtIncrease > 0) {\n                debt = debt + idleDebtChange.debtIncrease - idleDebtChange.debtDecrease;\n            }\n        }\n    }\n\n    function _calcUserWithdrawSharesToBurn(\n        DestinationInfo storage destInfo,\n        IDestinationVault destVault,\n        uint256 userShares,\n        uint256 maxAssetsToPull,\n        uint256 totalVaultShares\n    ) external returns (uint256 sharesToBurn, uint256 totalDebtBurn) {\n        // Figure out how many shares we can burn from the destination as well\n        // as what our totalDebt deduction should be (totalDebt being a cached value).\n        // If the destination vault is currently sitting at a profit, then the user can burn\n        // all the shares this vault owns. If its at a loss, they can only burn an amount\n        // proportional to their ownership of this vault. This is so a user doesn't lock in\n        // a loss for the entire vault during their withdrawal\n\n        uint256 currentDvShares = destVault.balanceOf(address(this));\n\n        // slither-disable-next-line incorrect-equality\n        if (currentDvShares == 0) {\n            return (0, 0);\n        }\n\n        // Calculate the current value of our shares\n        uint256 currentDvDebtValue = destVault.debtValue(currentDvShares);\n\n        // Get the basis for the current deployment\n        uint256 cachedDebtBasis = destInfo.debtBasis;\n\n        // The amount of shares we had at the last debt reporting\n        uint256 cachedDvShares = destInfo.ownedShares;\n\n        // The value of our debt + earned rewards at last debt reporting\n        uint256 cachedCurrentDebt = destInfo.currentDebt;\n\n        // Our current share balance should only ever be lte the last snapshot\n        // Any update to the deployment should update the snapshot and withdrawals\n        // can only lower it\n        if (currentDvShares > cachedDvShares) {\n            revert WithdrawShareCalcInvalid(currentDvShares, cachedDvShares);\n        }\n\n        // Recalculated what the debtBasis is with the current number of shares\n        uint256 updatedDebtBasis = cachedDebtBasis.mulDiv(currentDvShares, cachedDvShares, Math.Rounding.Up);\n\n        // Neither of these numbers include rewards from the DV\n        if (currentDvDebtValue < updatedDebtBasis) {\n            // We are currently sitting at a loss. Limit the value we can pull from\n            // the destination vault\n            currentDvDebtValue = currentDvDebtValue.mulDiv(userShares, totalVaultShares, Math.Rounding.Down);\n            currentDvShares = currentDvShares.mulDiv(userShares, totalVaultShares, Math.Rounding.Down);\n        }\n\n        // Shouldn't pull more than we want\n        // Or, we're not in profit so we limit the pull\n        if (currentDvDebtValue < maxAssetsToPull) {\n            maxAssetsToPull = currentDvDebtValue;\n        }\n\n        // Calculate the portion of shares to burn based on the assets we need to pull\n        // and the current total debt value. These are destination vault shares.\n        sharesToBurn = currentDvShares.mulDiv(maxAssetsToPull, currentDvDebtValue, Math.Rounding.Up);\n\n        // This is what will be deducted from totalDebt with the w"
    }
  ]
}