{
  "Title": "H-6: Signers can brick safe by adding unlimited additional signers while avoiding checks",
  "Content": "# Issue H-6: Signers can brick safe by adding unlimited additional signers while avoiding checks \n\nSource: https://github.com/sherlock-audit/2023-02-hats-judging/issues/48 \n\n## Found by \nobront, roguereddwarf, Dug\n\n## Summary\n\nThere are a number of checks in `checkAfterExecution()` to ensure that the signers cannot perform any illegal actions to exert too much control over the safe. However, there is no check to ensure that additional owners are not added to the safe. This could be done in a way that pushes the total over `maxSigners`, which will cause all future transactions to revert.\n\nThis means that signers can easily collude to freeze the contract, giving themselves the power to hold the protocol ransom to unfreeze the safe and all funds inside it.\n\n## Vulnerability Detail\n\nWhen new owners are added to the contract through the `claimSigner()` function, the total number of owners is compared to `maxSigners` to ensure it doesn't exceed it.\n\nHowever, owners can also be added by a normal `execTransaction` function. In this case, there are very few checks (all of which could easily or accidentally be missed) to stop us from adding too many owners:\n\n```solidity\nif (safe.getThreshold() != _getCorrectThreshold()) {\n    revert SignersCannotChangeThreshold();\n}\n\nfunction _getCorrectThreshold() internal view returns (uint256 _threshold) {\n    uint256 count = _countValidSigners(safe.getOwners());\n    uint256 min = minThreshold;\n    uint256 max = targetThreshold;\n    if (count < min) _threshold = min;\n    else if (count > max) _threshold = max;\n    else _threshold = count;\n}\n```\nThat means that either in the case that (a) the safe's threshold is already at `targetThreshold` or (b) the owners being added are currently toggled off or have eligibility turned off, this check will pass and the owners will be added.\n\nOnce they are added, all future transactions will fail. Each time a transaction is processed, `checkTransaction()` is called, which calls `reconcileSignerCount()`, which has the following check:\n```solidity\nif (validSignerCount > maxSigners) {\n    revert MaxSignersReached();\n}\n```\nThis will revert as long as the new owners are now activated as valid signers.\n\nIn the worst case scenario, valid signers wearing an immutable hat are added as owners when the safe's threshold is already above `targetThreshold`. The check passes, but the new owners are already valid signers. There is no admin action that can revoke the validity of their hats, so the `reconcileSignerCount()` function will always revert, and therefore the safe is unusable.\n\nSince `maxSigners` is immutable and can't be changed, the only solution is for the hat wearers to renounce their hats. Otherwise, the safe will remain unusable with all funds trapped inside.\n\n## Impact\n\nSigners can easily collude to freeze the contract, giving themselves the power to hold the protocol ransom to unfreeze the safe and all funds inside it.\n\nIn a less malicious case, signers might accidentally add too many owners and end up needing to manage the logistics of having users renounce their hats.\n\n## Code Snippet\n\nhttps://github.com/Hats-Protocol/hats-zodiac/blob/9455cc0957762f5dbbd8e62063d970199109b977/src/HatsSignerGateBase.sol#L507-L529\n\nhttps://github.com/Hats-Protocol/hats-zodiac/blob/9455cc0957762f5dbbd8e62063d970199109b977/src/HatsSignerGateBase.sol#L187-L189\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThere should be a check in `checkAfterExecution()` that ensures that the number of owners on the safe has not changed throughout the execution.\n\nIt also may be recommended that the `maxSigners` value is adjustable by the contract owner.\n\n## Discussion\n\n**spengrah**\n\n> There is no admin action that can revoke the validity of their hats, so the reconcileSignerCount() function will always revert, and therefore the safe is unusable.\n\nThis is not fully true, since either the hat's eligibility or toggle module could revoke their hat. But this is definitely not guaranteed to be possible, especially in the case of mechanistic modules that have hardcoded revocation logic, so addressing this issue is warranted.\n\nMy current thinking is that storing/comparing the full owner array — which is likely necessary to address #118 and #70 — would also address this issue, since ensuring exact same owners also ensures same number of owners.\n\ncc @zobront \n\n**spengrah**\n\nhttps://github.com/Hats-Protocol/hats-zodiac/pull/5\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/48",
  "Code": [
    {
      "filename": "src/HatsSignerGateBase.sol",
      "content": "// SPDX-License-Identifier: CC0\npragma solidity >=0.8.13;\n\nimport { Test, console2 } from \"forge-std/Test.sol\"; // remove after testing\nimport \"./HSGLib.sol\";\nimport { HatsOwnedInitializable } from \"hats-auth/HatsOwnedInitializable.sol\";\nimport { BaseGuard } from \"zodiac/guard/BaseGuard.sol\";\nimport { IAvatar } from \"zodiac/interfaces/IAvatar.sol\";\nimport { StorageAccessible } from \"@gnosis.pm/safe-contracts/contracts/common/StorageAccessible.sol\";\nimport { IGnosisSafe, Enum } from \"./Interfaces/IGnosisSafe.sol\";\nimport { SignatureDecoder } from \"@gnosis.pm/safe-contracts/contracts/common/SignatureDecoder.sol\";\n\nabstract contract HatsSignerGateBase is BaseGuard, SignatureDecoder, HatsOwnedInitializable {\n    /// @notice The multisig to which this contract is attached\n    IGnosisSafe public safe;\n\n    /// @notice The minimum signature threshold for the `safe`\n    uint256 public minThreshold;\n\n    /// @notice The highest level signature threshold for the `safe`\n    uint256 public targetThreshold;\n\n    /// @notice The maximum number of signers allowed for the `safe`\n    uint256 public maxSigners;\n\n    /// @notice The current number of signers on the `safe`\n    uint256 public signerCount;\n\n    /// @notice The version of HatsSignerGate used in this contract\n    string public version;\n\n    /// @notice The number of modules enabled on the `safe`, as enabled via this contract\n    uint256 public enabledModuleCount;\n\n    /// @dev Temporary record of the existing modules on the `safe` when a transaction is submitted\n    bytes32 internal _existingModulesHash;\n    \n    /// @dev A simple re-entrency guard\n    uint256 internal _guardEntries;\n\n    /// @dev The head pointer used in the GnosisSafe owners linked list, as well as the module linked list\n    address internal constant SENTINEL_OWNERS = address(0x1);\n\n    /// @dev The storage slot used by GnosisSafe to store the guard address\n    ///      keccak256(\"guard_manager.guard.address\")\n    bytes32 internal constant GUARD_STORAGE_SLOT = 0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8;\n\n    /// @dev Makes the singleton unusable by setting its owner to the 1-address\n    constructor() payable initializer {\n        _HatsOwned_init(1, address(0x1));\n    }\n\n    /// @notice Initializes a new instance\n    /// @dev Can only be called once\n    /// @param initializeParams ABI-encoded bytes with initialization parameters\n    function setUp(bytes calldata initializeParams) public payable virtual initializer { }\n\n    /// @notice Internal function to initialize a new instance\n    /// @param _ownerHatId The hat id of the hat that owns this instance of HatsSignerGate\n    /// @param _safe The multisig to which this instance of HatsSignerGate is attached\n    /// @param _hats The Hats Protocol address\n    /// @param _minThreshold The minimum threshold for the `_safe`\n    /// @param _targetThreshold The maxium threshold for the `_safe`\n    /// @param _maxSigners The maximum number of signers allowed on the `_safe`\n    /// @param _version The current version of HatsSignerGate\n    function _setUp(\n        uint256 _ownerHatId,\n        address _safe,\n        address _hats,\n        uint256 _minThreshold,\n        uint256 _targetThreshold,\n        uint256 _maxSigners,\n        string memory _version,\n        uint256 _existingModuleCount\n    ) internal {\n        _HatsOwned_init(_ownerHatId, _hats);\n        maxSigners = _maxSigners;\n        safe = IGnosisSafe(_safe);\n\n        _setTargetThreshold(_targetThreshold);\n        _setMinThreshold(_minThreshold);\n        version = _version;\n        enabledModuleCount = _existingModuleCount + 1; // this contract is enabled as well\n    }\n\n    /// @notice Checks if `_account` is a valid signer\n    /// @dev Must be implemented by all flavors of HatsSignerGate\n    /// @param _account The address to check\n    /// @return valid Whether `_account` is a valid signer\n    function isValidSigner(address _account) public view virtual returns (bool valid) { }\n\n    /// @notice Sets a new target threshold, and changes `safe`'s threshold if appropriate\n    /// @dev Only callable by a wearer of the owner hat. Reverts if `_targetThreshold` is greater than `maxSigners`.\n    /// @param _targetThreshold The new target threshold to set\n    function setTargetThreshold(uint256 _targetThreshold) public onlyOwner {\n        if (_targetThreshold != targetThreshold) {\n            _setTargetThreshold(_targetThreshold);\n\n            if (signerCount > 1) _setSafeThreshold(_targetThreshold);\n\n            emit HSGLib.TargetThresholdSet(_targetThreshold);\n        }\n    }\n\n    /// @notice Internal function to set the target threshold\n    /// @dev Reverts if `_targetThreshold` is greater than `maxSigners`\n    /// @param _targetThreshold The new target threshold to set\n    function _setTargetThreshold(uint256 _targetThreshold) internal {\n        if (_targetThreshold > maxSigners) {\n            revert InvalidTargetThreshold();\n        }\n\n        targetThreshold = _targetThreshold;\n    }\n\n    /// @notice Internal function to set the threshold for the `safe`\n    /// @dev Forwards the threshold-setting call to `safe.ExecTransactionFromModule`\n    /// @param _threshold The threshold to set on the `safe`\n    function _setSafeThreshold(uint256 _threshold) internal {\n        uint256 newThreshold = _threshold;\n        uint256 signerCount_ = signerCount; // save an SLOAD\n\n        // ensure that txs can't execute if fewer signers than target threshold\n        if (signerCount_ <= _threshold) {\n            newThreshold = signerCount_;\n        }\n        if (newThreshold != safe.getThreshold()) {\n            bytes memory data = abi.encodeWithSignature(\"changeThreshold(uint256)\", newThreshold);\n\n            bool success = safe.execTransactionFromModule(\n                address(safe), // to\n                0, // value\n                data, // data\n                Enum.Operation.Call // operation\n            );\n\n            if (!success) {\n                revert FailedExecChangeThreshold();\n            }\n        }\n    }\n\n    /// @notice Sets a new minimum threshold\n    /// @dev Only callable by a wearer of the owner hat. Reverts if `_minThreshold` is greater than `maxSigners` or `targetThreshold`\n    /// @param _minThreshold The new minimum threshold\n    function setMinThreshold(uint256 _minThreshold) public onlyOwner {\n        _setMinThreshold(_minThreshold);\n        emit HSGLib.MinThresholdSet(_minThreshold);\n    }\n\n    /// @notice Internal function to set a new minimum threshold\n    /// @dev Only callable by a wearer of the owner hat. Reverts if `_minThreshold` is greater than `maxSigners` or `targetThreshold`\n    /// @param _minThreshold The new minimum threshold\n    function _setMinThreshold(uint256 _minThreshold) internal {\n        if (_minThreshold > maxSigners || _minThreshold > targetThreshold) {\n            revert InvalidMinThreshold();\n        }\n\n        minThreshold = _minThreshold;\n    }\n\n    /// @notice Allows the owner to enable a new module on the `safe`\n    /// @dev Increments the `enabledModuleCount` to include the new module in the allowed list (see `checkTransaction` and `checkAfterExecution`)\n    /// @param _module The address of the module to enable\n    function enableNewModule(address _module) external onlyOwner {\n        ++enabledModuleCount;\n\n        bytes memory data = abi.encodeWithSignature(\"enableModule(address)\", _module);\n        bool success = safe.execTransactionFromModule(\n            address(safe), // to\n            0, // value\n            data, // data\n            Enum.Operation.Call // operation\n        );\n\n        if (!success) {\n            revert FailedExecEnableModule();\n        }\n    }\n\n    /// @notice Tallies the number of existing `safe` owners that wear a signer hat, sets `signerCount` to that value, and updates the `safe` threshold if necessary\n    /// @dev Does NOT remove invalid `safe` owners\n    function reconcileSignerCount() public {\n        address[] memory owners = safe.getOwners();\n        uint256 validSignerCount = _countValidSigners(owners);\n\n        if (validSignerCount > maxSigners) {\n            revert MaxSignersReached();\n        }\n\n        // update the signer count accordingly\n        signerCount = validSignerCount;\n\n        uint256 currentThreshold = safe.getThreshold();\n        uint256 newThreshold;\n        uint256 target = targetThreshold; // save SLOADs\n\n        if (validSignerCount <= target && validSignerCount != currentThreshold) {\n            newThreshold = validSignerCount;\n        } else if (validSignerCount > target && currentThreshold < target) {\n            newThreshold = target;\n        }\n        if (newThreshold > 0) {\n            bytes memory data = abi.encodeWithSignature(\"changeThreshold(uint256)\", validSignerCount);\n\n            bool success = safe.execTransactionFromModule(\n                address(safe), // to\n                0, // value\n                data, // data\n                Enum.Operation.Call // operation\n            );\n\n            if (!success) {\n                revert FailedExecChangeThreshold();\n            }\n        }\n    }\n\n    /// @notice Internal function to count the number of valid signers in an array of addresses\n    /// @param owners The addresses to check for validity\n    /// @return validSignerCount The number of valid signers in `owners`\n    function _countValidSigners(address[] memory owners) internal view returns (uint256 validSignerCount) {\n        uint256 length = owners.length;\n        // count the existing safe owners that wear the signer hat\n        for (uint256 i; i < length;) {\n            if (isValidSigner(owners[i])) {\n                // shouldn't overflow given reasonable owners array length\n                unchecked {\n                    ++validSignerCount;\n                }\n            }\n            // shouldn't overflow given reasonable owners array length\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Internal function that adds `_signer` as an owner on `safe`, updating the threshold if appropriate\n    /// @dev Unsafe. Does not check if `_signer` is a valid signer\n    /// @param _owners Array of owners on the `safe`\n    /// @param _currentSignerCount The current number of signers\n    /// @param _signer The address to add as a new `safe` owner\n    function _grantSigner(address[] memory _owners, uint256 _currentSignerCount, address _signer) internal {\n        uint256 newSignerCount = _currentSignerCount;\n\n        uint256 currentThreshold = safe.getThreshold(); // view function\n        uint256 newThreshold = currentThreshold;\n\n        bytes memory addOwnerData;\n\n        // if the only owner is a non-signer (ie this module set as an owner on initialization), replace it with _signer\n        if (_owners.length == 1 && _owners[0] == address(this)) {\n            // prevOwner will always be the sentinel when owners.length == 1\n\n            // set up the swapOwner call\n            addOwnerData = abi.encodeWithSignature(\n                \"swapOwner(address,address,address)\",\n                SENTINEL_OWNERS, // prevOwner\n                address(this), // oldOwner\n                _signer // newOwner\n            );\n            unchecked {\n                // shouldn't overflow given MaxSignersReached check higher in call stack\n                ++newSignerCount;\n            }\n        } else {\n            // otherwise, add the claimer as a new owner\n\n            unchecked {\n                // shouldn't overflow given MaxSignersReached check higher in call stack\n                ++newSignerCount;\n            }\n\n            // ensure that txs can't execute if fewer signers than target threshold\n            if (newSignerCount <= targetThreshold) {\n                newThreshold = newSignerCount;\n            }\n\n            // set up the addOwner call\n            addOwnerData = abi.encodeWithSignature(\"addOwnerWithThreshold(address,uint256)\", _signer, newThreshold);\n        }\n\n        // increment signer count\n        signerCount = newSignerCount;\n\n        // execute the call\n        bool success = safe.execTransactionFromModule(\n            address(safe), // to\n            0, // value\n            addOwnerData, // data\n            Enum.Operation.Call // operation\n        );\n\n        if (!success) {\n            revert FailedExecAddSigner();\n        }\n    }\n\n    /// @notice Internal function that adds `_signer` as an owner on `safe` by swapping with an existing (invalid) owner\n    /// @dev Unsafe. Does not check if `_signer` is a valid signer.\n    /// @param _owners Array of owners on the `safe`\n    /// @param _ownerCount The number of owners on the `safe` (length of `_owners` array)\n    /// @param _maxSigners The maximum number of signers allowed\n    /// @param _currentSignerCount The current number of signers\n    /// @param _signer The address to add as a new `safe` owner\n    /// @return success Whether an invalid signer was found and successfully replaced with `_signer`\n    function _swapSigner(\n        address[] memory _owners,\n        uint256 _ownerCount,\n        uint256 _maxSigners,\n        uint256 _currentSignerCount,\n        address _signer\n    ) internal returns (bool success) {\n        address ownerToCheck;\n        bytes memory data;\n\n        for (uint256 i; i < _ownerCount - 1;) {\n            ownerToCheck = _owners[i];\n\n            if (!isValidSigner(ownerToCheck)) {\n                // prep the swap\n                data = abi.encodeWithSignature(\n                    \"swapOwner(address,address,address)\",\n                    _findPrevOwner(_owners, ownerToCheck), // prevOwner\n                    ownerToCheck, // oldOwner\n                    _signer // newOwner\n                );\n\n                // execute the swap, reverting if it fails for some reason\n                success = safe.execTransactionFromModule(\n                    address(safe), // to\n                    0, // value\n                    data, // data\n                    Enum.Operation.Call // operation\n                );\n\n                if (!success) {\n                    revert FailedExecRemoveSigner();\n                }\n\n                // increment the signer count if signerCount was correct, ie `reconcileSignerCount` was called prior\n                if (_currentSignerCount < _maxSigners) ++signerCount;\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Removes an invalid signer from the `safe`, updating the threshold if appropriate\n    /// @param _signer The address to remove if not a valid signer\n    function removeSigner(address _signer) public virtual {\n        if (isValidSigner(_signer)) {\n            revert StillWearsSignerHat(_signer);\n        }\n\n        _removeSigner(_signer);\n    }\n\n    /// @notice Internal function to remove a signer from the `safe`, updating the threshold if appropriate\n    /// @dev Unsafe. Does not check for signer validity before removal\n    /// @param _signer The address to remove\n    function _removeSigner(address _signer) internal {\n        bytes memory removeOwnerData;\n        address[] memory owners = safe.getOwners();\n        uint256 currentSignerCount = signerCount; // save an SLOAD\n        uint256 newSignerCount;\n\n        if (currentSignerCount < 2 && owners.length == 1) {\n            // signerCount could be 0 after reconcileSignerCount\n            // make address(this) the only owner\n            removeOwnerData = abi.encodeWithSignature(\n                \"swapOwner(address,address,address)\",\n                SENTINEL_OWNERS, // prevOwner\n                _signer, // oldOwner\n                address(this) // newOwner\n            );\n\n            // newSignerCount is already 0\n        } else {\n            uint256 currentThreshold = safe.getThreshold();\n            uint256 newThreshold = currentThreshold;\n            uint256 validSignerCount = _countValidSigners(owners);\n\n            if (validSignerCount == currentSignerCount) {\n                newSignerCount = currentSignerCount;\n            } else {\n                newSignerCount = currentSignerCount - 1;\n            }\n\n            // ensure that txs can't execute if fewer signers than target threshold\n            if (newSignerCount <= targetThreshold) {\n                newThreshold = newSignerCount;\n            }\n\n            removeOwnerData = abi.encodeWithSignature(\n                \"removeOwner(address,address,uint256)\", _findPrevOwner(owners, _signer), _signer, newThreshold\n            );\n        }\n\n        // update signerCount\n        signerCount = newSignerCount;\n\n        bool success = safe.execTransactionFromModule(\n            address(safe), // to\n            0, // value\n            removeOwnerData, // data\n            Enum.Operation.Call // operation\n        );\n\n        if (!success) {\n            revert FailedExecRemoveSigner();\n        }\n    }\n\n    /// @notice Internal function to find the previous owner of an `_owner` in an array of `_owners`, ie the pointer to the owner to remove from the `safe` owners linked list\n    /// @param _owners An array of addresses\n    /// @param _owner The address after the one to find\n    /// @return prevOwner The owner previous to `_owner` in the `safe` linked list\n    function _findPrevOwner(address[] memory _owners, address _owner) internal pure returns (address prevOwner) {\n        prevOwner = SENTINEL_OWNERS;\n\n        for (uint256 i; i < _owners.length;) {\n            if (_owners[i] == _owner) {\n                if (i == 0) break;\n                prevOwner = _owners[i - 1];\n            }\n            // shouldn't overflow given reasonable _owners array length\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    // solhint-disallow-next-line payable-fallback\n    fallback() external {\n        // We don't revert on fallback to avoid issues in case of a Safe upgrade\n        // E.g. The expected check method might change and then the Safe would be locked.\n    }\n\n    /// @notice Pre-flight check on a `safe` transaction to ensure that it s signers are valid, called from within `safe.execTransactionFromModule()`\n    /// @dev Overrides All params mirror params for `safe.execTransactionFromModule()`\n    function checkTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures,\n        address // msgSender\n    ) external override {\n        if (msg.sender != address(safe)) revert NotCalledFromSafe();\n\n        uint256 safeOwnerCount = safe.getOwners().length;\n        // uint256 validSignerCount = _countValidSigners(safe.getOwners());\n\n        // ensure that safe threshold is correct\n        reconcileSignerCount();\n\n        if (safeOwnerCount < minThreshold) {\n            revert BelowMinThreshold(minThreshold, safeOwnerCount);\n        }\n\n        // get the tx hash; view function\n        bytes32 txHash = safe.getTransactionHash(\n            // Transaction info\n            to,\n            value,\n            data,\n            operation,\n            safeTxGas,\n            // Payment info\n            baseGas,\n            gasPrice,\n            gasToken,\n            refundReceiver,\n            // Signature info\n            // We subtract 1 since nonce was just incremented in the parent function call\n            safe.nonce() - 1 // view function\n        );\n\n        uint256 validSigCount = countValidSignatures(txHash, signatures, signatures.length / 65);\n\n        // revert if there aren't enough valid signatures\n        if (validSigCount < safe.getThreshold() || validSigCount < minThreshold) {\n            revert InvalidSigners();\n        }\n\n        // record existing modules for post-flight check\n        // SENTINEL_OWNERS and SENTINEL_MODULES are both address(0x1)\n        (address[] memory modules,) = safe.getModulesPaginated(SENTINEL_OWNERS, enabledModuleCount);\n        _existingModulesHash = keccak256(abi.encode(modules));\n\n        unchecked {\n            ++_guardEntries;\n        }\n    }\n\n    /// @notice Post-flight check to prevent `safe` signers from removing this contract guard, changing any modules, or changing the threshold\n    /// @dev Modified from https://github.com/gnosis/zodiac-guard-mod/blob/988ebc7b71e352f121a0be5f6ae37e79e47a4541/contracts/ModGuard.sol#L86\n    function checkAfterExecution(bytes32, bool) external override {\n        if (msg.sender != address(safe)) revert NotCalledFromSafe();\n\n        if (\n            abi.decode(StorageAccessible(address(safe)).getStorageAt(uint256(GUARD_STORAGE_SLOT), 1), (address))\n                != address(this)\n        ) {\n            revert CannotDisableThisGuard(address(this));\n        }\n\n        if (safe.getThreshold() != _getCorrectThreshold()) {\n            revert SignersCannotChangeThreshold();\n        }\n\n        // SENTINEL_OWNERS and SENTINEL_MODULES are both address(0x1)\n        (address[] memory modules,) = safe.getModulesPaginated(SENTINEL_OWNERS, enabledModuleCount + 1);\n        if (keccak256(abi.encode(modules)) != _existingModulesHash) {\n            revert SignersCannotChangeModules();\n        }\n\n        // leave checked to catch underflows triggered by re-erntry attempts\n        --_guardEntries;\n    }\n\n    /// @notice Internal function to calculate the threshold that `safe` should have, given the correct `signerCount`, `minThreshold`, and `targetThreshold`\n    /// @return _threshold The correct threshold\n    function _getCorrectThreshold() internal view returns (uint256 _threshold) {\n        uint256 count = _countValidSigners(safe.getOwners());\n        uint256 min = minThreshold;\n        uint256 max = targetThreshold;\n        if (count < min) _threshold = min;\n        else if (count > max) _threshold = max;\n        else _threshold = count;\n    }\n\n    /// @notice Counts the number of hats-valid signatures within a set of `signatures`\n    /// @dev modified from https://github.com/safe-global/safe-contracts/blob/c36bcab46578a442862d043e12a83fec41143dec/contracts/GnosisSafe.sol#L240\n    /// @param dataHash The signed data\n    /// @param signatures The set of signatures to check\n    /// @return validSigCount The number of hats-valid signatures\n    function countValidSignatures(bytes32 dataHash, bytes memory signatures, uint256 sigCount)\n        public\n        view\n        returns (uint256 validSigCount)\n    {\n        // There cannot be an owner with address 0.\n        address currentOwner;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i;\n\n        for (i; i < sigCount;) {\n            (v, r, s) = signatureSplit(signatures, i);\n            if (v == 0) {\n                // If v is 0 then it is a contract signature\n                // When handling contract signatures the address of the contract is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n            } else if (v == 1) {\n                // If v is 1 then it is an approved hash\n                // When handling approved hashes the address of the approver is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n            } else if (v > 30) {\n                // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\n                // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n                currentOwner =\n                    ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n            } else {\n                // Default is the ecrecover flow with the provided data hash\n                // Use ecrecover with the messageHash for EOA signatures\n                currentOwner = ecrecover(dataHash, v, r, s);\n            }\n\n            if (isValidSigner(currentOwner)) {\n                // shouldn't overflow given reasonable sigCount\n                unchecked {\n                    ++validSigCount;\n                }\n            }\n            // shouldn't overflow given reasonable sigCount\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/HatsSignerGateBase.sol",
      "content": "// SPDX-License-Identifier: CC0\npragma solidity >=0.8.13;\n\nimport { Test, console2 } from \"forge-std/Test.sol\"; // remove after testing\nimport \"./HSGLib.sol\";\nimport { HatsOwnedInitializable } from \"hats-auth/HatsOwnedInitializable.sol\";\nimport { BaseGuard } from \"zodiac/guard/BaseGuard.sol\";\nimport { IAvatar } from \"zodiac/interfaces/IAvatar.sol\";\nimport { StorageAccessible } from \"@gnosis.pm/safe-contracts/contracts/common/StorageAccessible.sol\";\nimport { IGnosisSafe, Enum } from \"./Interfaces/IGnosisSafe.sol\";\nimport { SignatureDecoder } from \"@gnosis.pm/safe-contracts/contracts/common/SignatureDecoder.sol\";\n\nabstract contract HatsSignerGateBase is BaseGuard, SignatureDecoder, HatsOwnedInitializable {\n    /// @notice The multisig to which this contract is attached\n    IGnosisSafe public safe;\n\n    /// @notice The minimum signature threshold for the `safe`\n    uint256 public minThreshold;\n\n    /// @notice The highest level signature threshold for the `safe`\n    uint256 public targetThreshold;\n\n    /// @notice The maximum number of signers allowed for the `safe`\n    uint256 public maxSigners;\n\n    /// @notice The current number of signers on the `safe`\n    uint256 public signerCount;\n\n    /// @notice The version of HatsSignerGate used in this contract\n    string public version;\n\n    /// @notice The number of modules enabled on the `safe`, as enabled via this contract\n    uint256 public enabledModuleCount;\n\n    /// @dev Temporary record of the existing modules on the `safe` when a transaction is submitted\n    bytes32 internal _existingModulesHash;\n    \n    /// @dev A simple re-entrency guard\n    uint256 internal _guardEntries;\n\n    /// @dev The head pointer used in the GnosisSafe owners linked list, as well as the module linked list\n    address internal constant SENTINEL_OWNERS = address(0x1);\n\n    /// @dev The storage slot used by GnosisSafe to store the guard address\n    ///      keccak256(\"guard_manager.guard.address\")\n    bytes32 internal constant GUARD_STORAGE_SLOT = 0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8;\n\n    /// @dev Makes the singleton unusable by setting its owner to the 1-address\n    constructor() payable initializer {\n        _HatsOwned_init(1, address(0x1));\n    }\n\n    /// @notice Initializes a new instance\n    /// @dev Can only be called once\n    /// @param initializeParams ABI-encoded bytes with initialization parameters\n    function setUp(bytes calldata initializeParams) public payable virtual initializer { }\n\n    /// @notice Internal function to initialize a new instance\n    /// @param _ownerHatId The hat id of the hat that owns this instance of HatsSignerGate\n    /// @param _safe The multisig to which this instance of HatsSignerGate is attached\n    /// @param _hats The Hats Protocol address\n    /// @param _minThreshold The minimum threshold for the `_safe`\n    /// @param _targetThreshold The maxium threshold for the `_safe`\n    /// @param _maxSigners The maximum number of signers allowed on the `_safe`\n    /// @param _version The current version of HatsSignerGate\n    function _setUp(\n        uint256 _ownerHatId,\n        address _safe,\n        address _hats,\n        uint256 _minThreshold,\n        uint256 _targetThreshold,\n        uint256 _maxSigners,\n        string memory _version,\n        uint256 _existingModuleCount\n    ) internal {\n        _HatsOwned_init(_ownerHatId, _hats);\n        maxSigners = _maxSigners;\n        safe = IGnosisSafe(_safe);\n\n        _setTargetThreshold(_targetThreshold);\n        _setMinThreshold(_minThreshold);\n        version = _version;\n        enabledModuleCount = _existingModuleCount + 1; // this contract is enabled as well\n    }\n\n    /// @notice Checks if `_account` is a valid signer\n    /// @dev Must be implemented by all flavors of HatsSignerGate\n    /// @param _account The address to check\n    /// @return valid Whether `_account` is a valid signer\n    function isValidSigner(address _account) public view virtual returns (bool valid) { }\n\n    /// @notice Sets a new target threshold, and changes `safe`'s threshold if appropriate\n    /// @dev Only callable by a wearer of the owner hat. Reverts if `_targetThreshold` is greater than `maxSigners`.\n    /// @param _targetThreshold The new target threshold to set\n    function setTargetThreshold(uint256 _targetThreshold) public onlyOwner {\n        if (_targetThreshold != targetThreshold) {\n            _setTargetThreshold(_targetThreshold);\n\n            if (signerCount > 1) _setSafeThreshold(_targetThreshold);\n\n            emit HSGLib.TargetThresholdSet(_targetThreshold);\n        }\n    }\n\n    /// @notice Internal function to set the target threshold\n    /// @dev Reverts if `_targetThreshold` is greater than `maxSigners`\n    /// @param _targetThreshold The new target threshold to set\n    function _setTargetThreshold(uint256 _targetThreshold) internal {\n        if (_targetThreshold > maxSigners) {\n            revert InvalidTargetThreshold();\n        }\n\n        targetThreshold = _targetThreshold;\n    }\n\n    /// @notice Internal function to set the threshold for the `safe`\n    /// @dev Forwards the threshold-setting call to `safe.ExecTransactionFromModule`\n    /// @param _threshold The threshold to set on the `safe`\n    function _setSafeThreshold(uint256 _threshold) internal {\n        uint256 newThreshold = _threshold;\n        uint256 signerCount_ = signerCount; // save an SLOAD\n\n        // ensure that txs can't execute if fewer signers than target threshold\n        if (signerCount_ <= _threshold) {\n            newThreshold = signerCount_;\n        }\n        if (newThreshold != safe.getThreshold()) {\n            bytes memory data = abi.encodeWithSignature(\"changeThreshold(uint256)\", newThreshold);\n\n            bool success = safe.execTransactionFromModule(\n                address(safe), // to\n                0, // value\n                data, // data\n                Enum.Operation.Call // operation\n            );\n\n            if (!success) {\n                revert FailedExecChangeThreshold();\n            }\n        }\n    }\n\n    /// @notice Sets a new minimum threshold\n    /// @dev Only callable by a wearer of the owner hat. Reverts if `_minThreshold` is greater than `maxSigners` or `targetThreshold`\n    /// @param _minThreshold The new minimum threshold\n    function setMinThreshold(uint256 _minThreshold) public onlyOwner {\n        _setMinThreshold(_minThreshold);\n        emit HSGLib.MinThresholdSet(_minThreshold);\n    }\n\n    /// @notice Internal function to set a new minimum threshold\n    /// @dev Only callable by a wearer of the owner hat. Reverts if `_minThreshold` is greater than `maxSigners` or `targetThreshold`\n    /// @param _minThreshold The new minimum threshold\n    function _setMinThreshold(uint256 _minThreshold) internal {\n        if (_minThreshold > maxSigners || _minThreshold > targetThreshold) {\n            revert InvalidMinThreshold();\n        }\n\n        minThreshold = _minThreshold;\n    }\n\n    /// @notice Allows the owner to enable a new module on the `safe`\n    /// @dev Increments the `enabledModuleCount` to include the new module in the allowed list (see `checkTransaction` and `checkAfterExecution`)\n    /// @param _module The address of the module to enable\n    function enableNewModule(address _module) external onlyOwner {\n        ++enabledModuleCount;\n\n        bytes memory data = abi.encodeWithSignature(\"enableModule(address)\", _module);\n        bool success = safe.execTransactionFromModule(\n            address(safe), // to\n            0, // value\n            data, // data\n            Enum.Operation.Call // operation\n        );\n\n        if (!success) {\n            revert FailedExecEnableModule();\n        }\n    }\n\n    /// @notice Tallies the number of existing `safe` owners that wear a signer hat, sets `signerCount` to that value, and updates the `safe` threshold if necessary\n    /// @dev Does NOT remove invalid `safe` owners\n    function reconcileSignerCount() public {\n        address[] memory owners = safe.getOwners();\n        uint256 validSignerCount = _countValidSigners(owners);\n\n        if (validSignerCount > maxSigners) {\n            revert MaxSignersReached();\n        }\n\n        // update the signer count accordingly\n        signerCount = validSignerCount;\n\n        uint256 currentThreshold = safe.getThreshold();\n        uint256 newThreshold;\n        uint256 target = targetThreshold; // save SLOADs\n\n        if (validSignerCount <= target && validSignerCount != currentThreshold) {"
    }
  ]
}