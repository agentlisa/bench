{
  "Title": "M-3: The protocol shouldn't charge interests when paused",
  "Content": "# Issue M-3: The protocol shouldn't charge interests when paused \n\nSource: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/234 \n\n## Found by \nhansfriese, rvierdiiev\n\n\n\n## Summary\nThe protocol charges interest from users using `virtualPrice` and it increases when the protocol is paused.\n\nAs a result, users would be forced to pay more interests and experience an unexpected liquidation.\n\n## Vulnerability Detail\nThe protocol has 3 kinds of the vault and each one has `pause/unpause` option by `pausers`.\n\nAlso, each collateral would be paused using `CollateralBook.pauseCollateralType()`.\n\nBut it updates the `virtualPrice` during the paused period and the below scenarios would be possible.\n\n#### Scenario 1\n1. A user `Alice` opened a loan using some collaterals.\n2. The vault was paused for a while for some unexpected reason.\n3. Meanwhile, her loan was changed to a `liquidatable` one but she can't add collaterals(or close the loan) in the paused state.\n4. After the protocol is unpaused, she's trying to protect her loan by adding collaterals but `Bob` can liquidate her loan with front running.\n5. Even if her loan isn't liquidated, she should pay interests during the paused period and it's not fair for her.\n\n#### Scenario 2\n1. A user `Alice` opened a loan with `minOpeningMargin = 101%`.\n2. After the protocol was paused for some reason, the admin decided to change `minOpeningMargin = 105%`.\n3. `Alice` wants to close her loan before it's applied because it's too high for her but she can't because it's paused.\n4. After the new `minOpeningMargin` is applied, `Alice` will be forced to pay interests of the higher `minOpeningMargin` for the paused period.\n\nWhen I check other protocols to charge interests, it's normal to enable some ways to protect their loans during the paused period for users.\n\nCurrently, all functions don't work in the paused mode and it shouldn't charge interests in this case.\n\n## Impact\nUsers might be forced to pay more interests or their loans might be liquidated unexpectedly.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/CollateralBook.sol#L127\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/Vault_Base_ERC20.sol#L85\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/Vault_Velo.sol#L141\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/Vault_Base_ERC20.sol#L203-L221\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/Vault_Velo.sol#L248-L265\n\n## Tool used\nManual Review\n\n## Recommendation\nWe shouldn't increase the `virtualPrice` during the paused period.\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed, will fix. Partial duplicate of issues #42 and issue #38. This was a design decision but we have decided to change it so that users can closeLoans, addCollateral or be liquidated when a collateral/vault is Paused.\n\n**kree-dotcom**\n\nAllow users to call `increaseCollateralAmount()`, `closeLoan()` and `callLiquidation()` of each Vault while the vault is paused. \nhttps://github.com/kree-dotcom/isomorph/commit/627212dcdcc3c22553de5587a90c9fae211a4888\n\n**kree-dotcom**\n\nFreeze collateral interest when collateral is paused. https://github.com/kree-dotcom/isomorph/commit/8ed4909462315bda79a08b773c530dfadfc1c4a3\n\nThis is achieved by ensuring the virtualPrice is up-to-date when pausing and then altering the lastUpdateTime when unpausing so that the system thinks the virtualPrice has been updated for the paused time period. \n\nIf a collateral is paused and unpaused often then interest owed can be lost because of rounding here as we can lose <180s of interest due per pausing. However as only admins can pause collaterals this is deemed an insignificant risk to the system as it would just slightly reduce fees owed on one collateral. \n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/22",
  "Code": [
    {
      "filename": "contracts/Isomorph/contracts/CollateralBook.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.9;\npragma abicoder v2;\nimport \"./RoleControl.sol\";\nimport \"./interfaces/ICollateralBook.sol\";\nimport \"./interfaces/IVault.sol\";\n\nuint256 constant COLLATERAL_BOOK_TIME_DELAY = 3 days;\n\ncontract CollateralBook is RoleControl(COLLATERAL_BOOK_TIME_DELAY){\n\n    mapping(address => bool) public collateralValid;\n    mapping(address => bool) public collateralPaused;\n    mapping(address => Collateral) public collateralProps;\n    mapping(bytes32 => address) public liquidityPoolOf;\n    mapping(uint256 => address) public vaults;\n\n    \n    bytes32 public constant VAULT_ROLE = keccak256(\"MINTER_ROLE\");\n\n    uint256 public constant THREE_MIN = 180;\n    uint256 public constant DIVISION_BASE = 1 ether;\n    uint256 public constant CHANGE_COLLATERAL_DELAY = 200; //2 days\n\n    //temporary data stores for changing Collateral variables\n    address queuedCollateralAddress;\n    bytes32 queuedCurrencyKey;\n    uint256 queuedMinimumRatio;\n    uint256 queuedLiquidationRatio;\n    uint256 queuedInterestPer3Min;\n    address queuedLiquidityPool;\n    uint256 queuedTimestamp;\n\n    // @notice minOpeningMargin MUST always be set high enough that \n    // a single update in the Chainlink pricefeed underlying Synthetix \n    // is significantly unlikely to produce an undercollateralized loan else the system is frontrunnable.\n    struct Collateral {\n        bytes32 currencyKey; //used by synthetix to identify synths\n        uint256 minOpeningMargin; //minimum loan margin required on opening or adjusting a loan\n        uint256 liquidatableMargin; //margin point below which a loan can be liquidated\n        uint256 interestPer3Min; //what percentage the interest grows by every 3 minutes\n        uint256 lastUpdateTime; //last blocktimestamp this collateral's virtual price was updated\n        uint256 virtualPrice; //price accounting for growing interest accrued on any loans taken in this collateral\n        uint256 assetType; //number to indicate what system this collateral token belongs to, \n                            // assetType is used to determine which Vault we are looking at\n    }\n\n\n    modifier collateralExists(address _collateralAddress){\n        require(collateralValid[_collateralAddress], \"Unsupported collateral!\");\n        _;\n    }\n\n    modifier onlyVault{\n        require(hasRole(VAULT_ROLE, msg.sender), \"Only updatable by vault\");\n        _;\n    }\n\n     constructor() {\n        //we dont want the `DEFAULT_ADMIN_ROLE` to exist as this doesn't require a \n        // time delay to add/remove any role and so is dangerous. \n        //So we do not set it and set our weaker admin role.\n        _setupRole(ADMIN_ROLE, msg.sender);\n    }\n\n    /**\n      * @notice Used for testing or when a bot wants to check virtualPrice of an asset\n      * @param _collateralAddress address of collateral token being used.\n       */\n    function viewVirtualPriceforAsset(address _collateralAddress) external view returns(uint256){\n        return (collateralProps[_collateralAddress].virtualPrice);\n    }\n\n    /**\n      * @notice Used for testing or when a bot wants to check if a collateral token needs the virtualPrice \n            manually updated due to inactivity.\n      * @param _collateralAddress address of collateral token being used.\n       */\n    function viewLastUpdateTimeforAsset(address _collateralAddress) external view returns(uint256){\n        return (collateralProps[_collateralAddress].lastUpdateTime);\n    }\n\n     /**\n      * @notice Only Admin can modify collateral tokens,\n      * @notice two step process to enforce a timelock for changing collateral\n      * @notice first you call queueCollateralChange() then changeCollateralType() after timelock period ends\n      * @dev does not allow changing token address, if this changes add a new collateral.\n      * @param _collateralAddress address of collateral token being used.\n      * @param _currencyKey symbol() returned string, used for synthetix calls\n      * @param _minimumRatio lowest margin ratio for opening debts with new collateral token\n      * @param _liquidationRatio margin ratio at which a loan backed by said collateral can be liquidated.\n      * @param _interestPer3Min interest charged per block to loan holders using this collateral.\n      * @param _liquidityPool only set for Lyra LP tokens, this address is where price info of the LP token is stored. The Zero address is used for non-Lyra Collateral\n     **/\n    function queueCollateralChange(\n        address _collateralAddress,\n        bytes32 _currencyKey,\n        uint256 _minimumRatio,\n        uint256 _liquidationRatio,\n        uint256 _interestPer3Min,\n        uint256 _assetType,\n        address _liquidityPool\n\n    ) external collateralExists(_collateralAddress) onlyAdmin {\n        require(_collateralAddress != address(0));\n        require(_minimumRatio > _liquidationRatio);\n        require(_liquidationRatio != 0);\n        require(vaults[_assetType] != address(0), \"Vault not deployed yet\");\n        IVault vault = IVault(vaults[_assetType]);\n        //prevent setting liquidationRatio too low such that it would cause an overflow in callLiquidation, see appendix on liquidation maths for details.\n        require( vault.LIQUIDATION_RETURN() *_liquidationRatio >= 10 ** 36, \"Liquidation ratio too low\");\n\n        queuedCollateralAddress = _collateralAddress;\n        queuedCurrencyKey = _currencyKey;\n        queuedMinimumRatio = _minimumRatio;\n        queuedLiquidationRatio = _liquidationRatio;\n        queuedInterestPer3Min = _interestPer3Min;\n        queuedLiquidityPool = _liquidityPool;\n        queuedTimestamp = block.timestamp;\n    }\n    /**\n    * @notice Only Admin can modify collateral tokens, \n    * @notice forces virtualPrice to be up-to-date when updating to prevent retroactive interest rate changes.\n    * @dev if time since last virtual price update is too long, \n    * @dev you must cycle it via the vault.updateVirtualPriceSlowly function or this function will revert\n     */\n    function changeCollateralType() external onlyAdmin {\n        uint256 submissionTimestamp = queuedTimestamp;\n        require(submissionTimestamp != 0, \"Uninitialized collateral change\");\n        require(submissionTimestamp + CHANGE_COLLATERAL_DELAY <= block.timestamp, \"Not enough time passed\");\n        address collateralAddress = queuedCollateralAddress;\n        bytes32 currencyKey = queuedCurrencyKey;\n        uint256 minimumRatio = queuedMinimumRatio;\n        uint256 liquidationRatio = queuedLiquidationRatio;\n        uint256 interestPer3Min = queuedInterestPer3Min;\n        address liquidityPool = queuedLiquidityPool;\n        \n\n        //Now we must ensure interestPer3Min changes aren't applied retroactively\n        // by updating the assets virtualPrice to current block timestamp\n        uint256 timeDelta = (block.timestamp - collateralProps[collateralAddress].lastUpdateTime) / THREE_MIN;\n        if (timeDelta != 0){ \n           updateVirtualPriceSlowly(collateralAddress, timeDelta );\n        }\n        bytes32 oldCurrencyKey = collateralProps[collateralAddress].currencyKey;\n\n        _changeCollateralParameters(\n            collateralAddress,\n            currencyKey,\n            minimumRatio,\n            liquidationRatio,\n            interestPer3Min\n        );\n        //Then update LiqPool as this isn't stored in the struct and requires the currencyKey also.\n        liquidityPoolOf[oldCurrencyKey]= address(0); \n        liquidityPoolOf[currencyKey]= liquidityPool;\n        \n    }\n\n   /** \n      * @dev This function should only be used by trusted functions that have validated all inputs already\n      * @param _collateralAddress address of collateral token being used.\n      * @param _currencyKey symbol() returned string, used for synthetix calls\n      * @param _minimumRatio lowest margin ratio for opening debts with new collateral token\n      * @param _liquidationRatio margin ratio at which a loan backed by said collateral can be liquidated.\n      * @param _interestPer3Min interest charged per block to loan holders using this collateral.\n     **/ \n    function _changeCollateralParameters(\n        address _collateralAddress,\n        bytes32 _currencyKey,\n        uint256 _minimumRatio,\n        uint256 _liquidationRatio,\n        uint256 _interestPer3Min\n        ) internal {\n        collateralProps[_collateralAddress].currencyKey = _currencyKey;\n        collateralProps[_collateralAddress].minOpeningMargin = _minimumRatio;\n        collateralProps[_collateralAddress].liquidatableMargin = _liquidationRatio;\n        collateralProps[_collateralAddress].interestPer3Min = _interestPer3Min;\n    }\n\n  /// @notice  Allows governance to pause a collateral type if necessary\n  /// @param _collateralAddress the token address of the collateral we wish to remove\n  /// @param _currencyKey the related synthcode, here we use this to prevent accidentally pausing the wrong collateral token.\n  /// @dev this should only be called on collateral no longer used by loans.\n    function pauseCollateralType(\n        address _collateralAddress,\n        bytes32 _currencyKey\n        ) external collateralExists(_collateralAddress) onlyAdmin {\n        require(_collateralAddress != address(0)); //this should get caught by the collateralExists check but just to be careful\n        //checks two inputs to help prevent input mistakes\n        require( _currencyKey == collateralProps[_collateralAddress].currencyKey, \"Mismatched data\");\n        collateralValid[_collateralAddress] = false;\n        collateralPaused[_collateralAddress] = true;\n        \n    }\n\n  /// @notice  Allows governance to unpause a collateral type if necessary\n  /// @param _collateralAddress the token address of the collateral we wish to remove\n  /// @param _currencyKey the related synthcode, here we use this to prevent accidentally unpausing the wrong collateral token.\n  /// @dev this should only be called on collateral that should be reenabled for taking loans against\n    function unpauseCollateralType(\n        address _collateralAddress,\n        bytes32 _currencyKey\n        ) external onlyAdmin {\n        require(_collateralAddress != address(0));\n        require(collateralPaused[_collateralAddress], \"Unsupported collateral or not Paused\");\n        //checks two inputs to help prevent input mistakes\n        require( _currencyKey == collateralProps[_collateralAddress].currencyKey, \"Mismatched data\");\n        collateralValid[_collateralAddress] = true;\n        collateralPaused[_collateralAddress] = false;\n        \n    }\n    /// @dev Governnance callable only, this should be set once atomically on construction \n    /// @notice once called it can no longer be called.\n    /// @param _vault the address of the vault system\n    function addVaultAddress(address _vault, uint256 _assetType) external onlyAdmin{\n        require(_vault != address(0), \"Zero address\");\n        require(vaults[_assetType] == address(0), \"Asset type already has vault\");\n        _setupRole(VAULT_ROLE, _vault);\n        vaults[_assetType]= _vault;\n    }\n    \n    /// @notice this takes in the updated virtual price of a collateral and records it as well as the time it was updated.\n    /// @dev this should only be called by vault functions which have updated the virtual price and need to log this.\n    /// @dev it is only callable by vault functions as a result.\n    /// @notice both virtualPrice and updateTime are strictly monotonically increasing so we verify this with require statements\n    /// @param _collateralAddress the token address of the collateral we are updating\n    /// @param _virtualPriceUpdate interest calculation update for it's virtual price\n    /// @param _updateTime block timestamp to keep track of last updated time.\n    \n    function _updateVirtualPriceAndTime(\n        address _collateralAddress,\n        uint256 _virtualPriceUpdate,\n        uint256 _updateTime\n        ) internal  {\n\n        require( collateralProps[_collateralAddress].virtualPrice < _virtualPriceUpdate, \"Incorrect virtual price\" );\n        require( collateralProps[_collateralAddress].lastUpdateTime < _updateTime, \"Incorrect timestamp\" );\n        collateralProps[_collateralAddress].virtualPrice = _virtualPriceUpdate;\n        collateralProps[_collateralAddress].lastUpdateTime = _updateTime;\n    }\n\n    /// @dev external function to enable the Vault to update the collateral virtual price & update timestamp\n    ///      while maintaining the same method as the slow update below for consistency.\n    function vaultUpdateVirtualPriceAndTime(\n        address _collateralAddress,\n        uint256 _virtualPriceUpdate,\n        uint256 _updateTime\n    ) external onlyVault collateralExists(_collateralAddress){\n        _updateVirtualPriceAndTime(_collateralAddress, _virtualPriceUpdate, _updateTime);\n    }\n\n\n    /// @dev this function is intentionally callable by anyone\n    /// @notice it is designed to prevent DOS situations occuring if there is a long period of inactivity for a collateral token\n    /// @param _collateralAddress the collateral token you are updating the virtual price of\n    /// @param _cycles how many updates (currently equal to seconds) to process the virtual price for.\n    function updateVirtualPriceSlowly(\n        address _collateralAddress,\n        uint256 _cycles\n        ) public collateralExists(_collateralAddress){ \n            Collateral memory collateral = collateralProps[_collateralAddress];\n            uint256 timeDelta = block.timestamp - collateral.lastUpdateTime;\n            uint256 threeMinDelta = timeDelta / THREE_MIN;\n    \n            require(_cycles <= threeMinDelta, 'Cycle count too high');\n                for (uint256 i = 0; i < _cycles; i++ ){\n                    collateral.virtualPrice = (collateral.virtualPrice * collateral.interestPer3Min) / DIVISION_BASE; \n                }\n            _updateVirtualPriceAndTime(_collateralAddress, collateral.virtualPrice, collateral.lastUpdateTime + (_cycles*THREE_MIN));\n        }\n    \n    \n    \n\n    /**\n      * @notice Only governance can add new collateral tokens\n      * @dev adds new synth token to approved list of collateral\n      * @dev includes sanity checks \n      * @param _collateralAddress address of collateral token being used.\n      * @param _currencyKey symbol() returned string, used for synthetix calls\n      * @param _minimumRatio lowest margin ratio for opening debts with new collateral token\n      * @param _liquidationRatio margin ratio at which a loan backed by said collateral can be liquidated.\n      * @param _interestPer3Min interest charged per block to loan holders using this collateral.\n      * @param _assetType number to indicate what system this collateral token belongs to, \n                          used to determine value function in vault.\n     **/\n    function addCollateralType(\n        address _collateralAddress,\n        bytes32 _currencyKey,\n        uint256 _minimumRatio,\n        uint256 _liquidationRatio,\n        uint256 _interestPer3Min,\n        uint256 _assetType,\n        address _liquidityPool\n        ) external onlyAdmin {\n\n        require(!collateralValid[_collateralAddress], \"Collateral already exists\");\n        require(!collateralPaused[_collateralAddress], \"Collateral already exists\");\n        require(_collateralAddress != address(0));\n        require(_minimumRatio > _liquidationRatio);\n        require(_liquidationRatio > 0);\n        require(vaults[_assetType] != address(0), \"Vault not deployed yet\");\n        IVault vault = IVault(vaults[_assetType]);\n\n        //prevent setting liquidationRatio too low such that it would cause an overflow in callLiquidation, see appendix on liquidation maths for details.\n        require( vault.LIQUIDATION_RETURN() *_liquidationRatio >= 10 ** 36, \"Liquidation ratio too low\"); //i.e. 1 when multiplying two 1 ether scale numbers.\n        collateralValid[_collateralAddress] = true;\n        collateralProps[_collateralAddress] = Collateral(\n            _currencyKey,\n            _minimumRatio,\n            _liquidationRatio,\n            _interestPer3Min,\n            block.timestamp,\n            1 ether,\n            _assetType\n            );\n        //Then update LiqPool as this isn't stored in the struct and requires the currencyKey also.\n        liquidityPoolOf[_currencyKey]= _liquidityPool; \n    }\n\n}"
    },
    {
      "filename": "contracts/Isomorph/contracts/Vault_Base_ERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Vault_Base_ERC20.sol for isomorph.loans\n// Bug bounties available\n\npragma solidity =0.8.9; \npragma abicoder v2;\n\n// Interfaces\nimport \"./interfaces/IisoUSDToken.sol\";\nimport \"./interfaces/ICollateralBook.sol\";\n\n//Open Zeppelin dependancies\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\n//Time delayed governance\nimport \"./RoleControl.sol\";\n\nuint256 constant VAULT_TIME_DELAY = 3 days;\n\nabstract contract Vault_Base_ERC20 is RoleControl(VAULT_TIME_DELAY), Pausable {\n\n    \n    //these mappings store the loan details of each users loan against each collateral.\n    //collateral address => user address => quantity\n    mapping(address => mapping(address => uint256)) public collateralPosted;\n    //this stores the original loan principle requested, used for burning when closing\n    //collateral address => user address => loan principle quantity\n    mapping(address => mapping(address => uint256)) public isoUSDLoaned;\n    //this records loan amounts requested and grows by interest accrued\n    //collateral address => user address => total loan and interest owed\n    mapping(address => mapping(address => uint256)) public isoUSDLoanAndInterest;\n\n    //variables relating to access control and setting new roles\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    //Constants\n    uint256 public constant LIQUIDATION_RETURN = 95 ether /100; //95% returned on liquidiation\n    uint256 public constant LOAN_SCALE = 1 ether; //base for division/decimal maths\n    uint256 public constant TENTH_OF_CENT = 1 ether /1000; //$0.001\n\n    //Enums// collateral type identifiers to revert if the wrong collateral is interacted with by the wrong Vault.\n    enum AssetType {Synthetix_Synth, Lyra_LP} \n    \n    \n    //Variables \n    //These three control max loans opened per day\n    uint256 public dailyMax = 1_000_000 ether; //one million with 18d.p.\n    uint256 public dayCounter = block.timestamp;\n    uint256 public dailyTotal = 0;\n\n    //These two handle fees paid to liquidators and the protocol by users \n    uint256 public loanOpenFee = 1 ether /100; //1 percent opening fee.\n\n    \n    //The treasury is where moUSD fees are paid, to keep this upgradable we allow changing by the admin, after a timelock period\n    address public treasury;\n    address public pendingTreasury;\n    uint256 public updateTreasuryTimestamp;\n\n    IisoUSDToken public isoUSD;\n    ICollateralBook public collateralBook;\n    \n   \n\n    event OpenOrIncreaseLoan(address indexed user, uint256 loanTaken, bytes32 indexed collateralToken, uint256 collateralAmount); \n    event IncreaseCollateral(address indexed user, bytes32 indexed collateralToken, uint256 collateralAmount); \n    event ClosedLoan(address indexed user, uint256 loanAmountReturned, bytes32 indexed collateralToken, uint256 returnedCapital);\n    event Liquidation(address indexed loanHolder, address indexed Liquidator, uint256 loanAmountReturned, bytes32 indexed collateralToken, uint256 liquidatedCapital);\n    event BadDebtCleared(address indexed loanHolder, address indexed Liquidator, uint256 debtCleared, bytes32 indexed collateralToken);\n    event ChangeDailyMax(uint256 newDailyMax, uint256 oldDailyMax);\n    event ChangeOpenLoanFee(uint256 newOpenLoanFee, uint256 oldOpenLoanFee);\n    event ChangeTreasury(address oldTreasury, address newTreasury);\n\n    event SystemPaused(address indexed pausedBy);\n    event SystemUnpaused(address indexed unpausedBy);\n    \n\n    /**\n        External onlyAdmin or onlyPauser governance functions\n     */\n\n\n    /// @notice sets state to paused only triggerable by pauser (all admins are pausers also)\n    function pause() external  {\n        bool validUser = hasRole(ADMIN_ROLE, msg.sender) || hasRole(PAUSER_ROLE, msg.sender);\n        require(validUser, \"Caller is not able to call pause\");\n        _pause();\n        emit SystemPaused(msg.sender);\n    }\n    /// @notice sets state to unpaused only triggerable by admin\n    function unpause() external onlyAdmin {\n        _unpause();\n        emit SystemUnpaused(msg.sender);\n    }\n\n    /// @notice dailyMax can be set to 0 effectively preventing anyone from opening new loans.\n    function setDailyMax(uint256 _newDailyMax) external onlyAdmin {\n        require(_newDailyMax < 100_000_000 ether ); //sanity check, require less than 100 million opened per day\n        emit ChangeDailyMax(_newDailyMax, dailyMax); //ignoring CEI pattern here\n        dailyMax = _newDailyMax;\n        \n        \n    }\n\n    /// @notice openLoanFee can be set to 10% max, fee applied to all loans on opening\n    function setOpenLoanFee(uint256 _newOpenLoanFee) external onlyAdmin {\n        require(_newOpenLoanFee <= 1 ether /10 ); \n        emit ChangeOpenLoanFee(_newOpenLoanFee, loanOpenFee); //ignoring CEI pattern here\n        loanOpenFee = _newOpenLoanFee;\n        \n        \n    }\n\n    /// @notice admin only function to queue treasury address change which must wait the timelock period before being implemented\n    function proposeTreasury(address _newTreasury) external onlyAdmin {\n        require(_newTreasury != address(0)); \n        pendingTreasury = _newTreasury;\n        updateTreasuryTimestamp = block.timestamp + VAULT_TIME_DELAY;\n    }\n\n    /// @notice admin only function to change treasury target after timelock delay\n    function setTreasury() external onlyAdmin {\n        require(updateTreasuryTimestamp < block.timestamp); \n        address copyOfPendingTreasury = pendingTreasury;\n        require(copyOfPendingTreasury != address(0));\n        emit ChangeTreasury(treasury, copyOfPendingTreasury); //ignoring CEI pattern here\n        treasury = copyOfPendingTreasury;\n    }\n\n    /**\n        Internal helper and check functions\n     */\n\n    /// @dev process for Synthetix assets\n    /// @dev leverages synthetix system to verify that the collateral in question is currently trading\n    /// @dev this prevents people frontrunning closed weekend markets for expected price crashes etc\n    /// @notice this call verifies Synthetix system, exchange and the synths in question are all available.\n    /// @notice if any of them aren't the function will revert.\n    /// @param _currencyKey the code used by synthetix to identify different synths, linked in collateral structure to collateral address\n    function _checkIfCollateralIsActive(bytes32 _currencyKey) internal virtual view;\n\n    /// @notice while this could be abused to DOS the system, given the openLoan fee this is an expensive attack to maintain\n    function _checkDailyMaxLoans(uint256 _amountAdded) internal {\n        if (block.timestamp > dayCounter + 1 days ){\n            dailyTotal = _amountAdded;\n            dayCounter = block.timestamp;\n        }\n        else{\n            dailyTotal += _amountAdded;\n        }\n        require( dailyTotal  < dailyMax, \"Try again tomorrow loan opening limit hit\");\n    }\n    \n    /// @notice basic checks to verify collateral being used exists\n    /// @dev should be called by any external function modifying a loan\n    function _collateralExists(address _collateralAddress) internal {\n        require(collateralBook.collateralValid(_collateralAddress), \"Unsupported collateral!\");\n    }\n\n    /// @param _collateralAddress the address of the collateral token you are fetching\n    /// @notice returns all collateral struct fields seperately so that functions requiring \n    /// @notice them can only locally store the ones they need\n    function _getCollateral(address _collateralAddress) internal returns(\n        bytes32 ,\n        uint256 ,\n        uint256 ,\n        uint256 ,\n        uint256 ,\n        uint256,\n        AssetType \n        ){\n        ICollateralBook.Collateral memory collateral = collateralBook.collateralProps(_collateralAddress);\n        return (\n            collateral.currencyKey,\n            collateral.minOpeningMargin,\n            collateral.liquidatableMargin, \n            collateral.interestPer3Min, \n            collateral.lastUpdateTime, \n            collateral.virtualPrice,\n            AssetType(collateral.assetType)\n            );\n    }\n\n\n\n    /// @param _percentToPay the percentage of the total sum express as a fee\n    /// @param _amount quantity of which to work out the percentage splits of\n    /// @dev internal function used to calculate treasury fees on opening loans\n    /// @return postFees is the quantity after the percentToPay has been deducted from it,\n    /// @return feeToPay is the percentToPay of original _amount.\n    function _findFees(uint256 _percentToPay, uint256 _amount) internal pure returns(uint256, uint256){\n        uint256 feeToPay = ((_amount * _percentToPay) / LOAN_SCALE);\n        uint256 postFees = _amount - feeToPay; //if the user loan is too small this will revert\n        return (postFees, feeToPay);\n    }\n\n\n    /// @param _currentBlockTime this should always be block.timestamp, passed in by trusted functions\n    /// @param _collateralAddress the address of the collateral token you wish to update the virtual price of \n    /// @dev this function should ONLY be called by other vault functions in which they pass in the block timestamp directly to this.\n    /// @dev currently uses interest calculations per 3 minutes to save gas and prevent DOS loop situations\n    function _updateVirtualPrice(uint256 _currentBlockTime, address _collateralAddress) internal { \n        (   ,\n            ,\n            ,\n            uint256 interestPer3Min,\n            uint256 lastUpdateTime,\n            uint256 virtualPrice,\n\n        ) = _getCollateral(_collateralAddress);\n        uint256 timeDelta = _currentBlockTime - lastUpdateTime;\n        //exit gracefully if two users call the function for the same collateral in the same 3min period\n        uint256 threeMinuteDelta = timeDelta / 180; \n        if(threeMinuteDelta > 0) {\n            for (uint256 i = 0; i < threeMinuteDelta; i++ ){\n            virtualPrice = (virtualPrice * interestPer3Min) / LOAN_SCALE; \n            }\n            collateralBook.vaultUpdateVirtualPriceAndTime(_collateralAddress, virtualPrice, _currentBlockTime);\n        }\n    }\n    \n\n     /**\n      * @notice Only Vault can mint isoUSD.\n      * @dev internal function to handle increases of loan\n      * @param _loanAmount amount of isoUSD to be borrowed, some is used to pay the opening fee the rest is sent to the user.\n     **/\n    function _increaseLoan(uint256 _loanAmount) internal {\n        uint256 userMint;\n        uint256 loanFee;\n        _checkDailyMaxLoans(_loanAmount);\n        (userMint, loanFee) = _findFees(loanOpenFee, _loanAmount);\n        isoUSD.mint(_loanAmount);\n        //isoUSD reverts on transfer failure so we can safely ignore slither's warnings for it.\n        //slither-disable-next-line unchecked-transfer\n        isoUSD.transfer(msg.sender, userMint);\n        //slither-disable-next-line unchecked-transfer\n        isoUSD.transfer(treasury, loanFee);\n    }\n    /// @dev internal function used to increase user collateral on loan.\n    /// @param _collateral the ERC20 compatible collateral to use, already set up in another function\n    /// @param _colAmount the amount of collateral to be transfered to the vault. \n    function _increaseCollateral(IERC20 _collateral, uint256 _colAmount) internal {\n        bool success  =_collateral.transferFrom(msg.sender, address(this), _colAmount);\n        //due to contract size we cannot use SafeERC20 so we check for non-reverting ERC20 failures\n        require(success);\n        \n    }\n\n    \n    /// @dev internal function used to decrease user collateral on loan.\n    /// @param _collateralAddress the ERC20 compatible collateral Address NOT already set up as an IERC20.\n    /// @param _amount the amount of collateral to be transfered back to the user.\n    /// @param _USDReturned quantity of isoUSD being returned to the vault, this can be zero.\n    /// @param _interestPaid quantity of interest paid on closing loan, this is transfered to the treasury , this can be zero\n    function _decreaseLoan(address _collateralAddress, uint256 _amount, uint256 _USDReturned, uint256 _interestPaid) internal {\n        IERC20 collateral = IERC20(_collateralAddress);\n        //_interestPaid is always less than _USDReturned so this is safe.\n        uint256 USDBurning = _USDReturned - _interestPaid;\n        //slither-disable-next-line unchecked-transfer\n        isoUSD.transferFrom(msg.sender, address(this), _USDReturned);\n        //burn original loan principle\n        isoUSD.burn(address(this), USDBurning);\n        //transfer interest earned on loan to treasury\n        //slither-disable-next-line unchecked-transfer\n        isoUSD.transfer(treasury, _interestPaid);\n        bool success  = collateral.transfer(msg.sender, _amount);\n        //due to contract size we cannot use SafeERC20 so we check for non-reverting ERC20 failures\n        require(success);\n        \n    }\n\n\n    /// @notice function required because of stack depth on closeLoan, only called by closeLoan function.\n    /// @param _collateralAddress address of the collateral token being used.\n    /// @param _collateralToUser quantity of collateral proposed to be returned to user closing loan\n    /// @param _USDToVault proposed quantity of isoUSD being returned (burnt) to the vault on closing the loan.\n    function _closeLoanChecks(address _collateralAddress, uint256 _collateralToUser, uint256 _USDToVault) internal view {\n        require(collateralPosted[_collateralAddress][msg.sender] >= _collateralToUser, \"User never posted this much collateral!\");\n        require(isoUSD.balanceOf(msg.sender) >= _USDToVault, \"Insufficient user isoUSD balance!\");\n    }\n\n    /**\n        Public functions \n    */\n\n\n    //isoUSD is assumed to be valued at $1 by all of the system to avoid oracle attacks. \n    /// @param _currencyKey code used by Synthetix to identify each collateral/synth\n    /// @param _amount quantity of collateral to price into sUSD\n    /// @return returns the value of the given synth in sUSD which is assumed to be pegged at $1.\n    function priceCollateralToUSD(bytes32 _currencyKey, uint256 _amount) public view virtual returns(uint256);\n\n    /**\n        External user loan interaction functions\n     */\n\n\n     /**\n      * @notice Only Vaults can mint isoUSD.\n      * @dev Mints 'USDborrowed' amount of isoUSD to vault and transfers to msg.sender and emits transfer event.\n      * @param _collateralAddress address of collateral token being used.\n      * @param _colAmount amount of collateral tokens being used.\n      * @param _USDborrowed amount of isoUSD to be minted, it is then split into the amount sent and the opening fee.\n     **/\n    function openLoan(\n        address _collateralAddress,\n        uint256 _colAmount,\n        uint256 _USDborrowed\n        ) external virtual;\n\n\n    /**\n      * @dev Increases collateral supplied against an existing loan. \n      * @notice Checks adding the collateral will keep the user above liquidation, \n      * @notice this debatable check isn't technically needed but feels fairer to end users.\n      * @param _collateralAddress address of collateral token being used.\n      * @param _colAmount amount of collateral tokens being used.\n     **/\n    function increaseCollateralAmount(\n        address _collateralAddress,\n        uint256 _colAmount\n        ) external virtual;\n\n\n     /**\n      * @notice Only Vault can destroy isoUSD.\n      * @dev destroys USDreturned of isoUSD held by caller, returns user collateral, close debt \n      * @dev if debt remains, checks minimum collateral ratio is upheld \n      * @dev if cost of a transaction can be <$0.01 YOU MUST UPDATE TENTH_OF_CENT check otherwise users can open microloans and close, withdrawing collateral without repaying. \n      * @param _collateralAddress address of collateral token being used.\n      * @param _collateralToUser amount of collateral tokens being returned to user.\n      * @param _USDToVault amount of isoUSD to be burnt.\n     **/\n\n    function closeLoan(\n        address _collateralAddress,\n        uint256 _collateralToUser,\n        uint256 _USDToVault\n        ) external virtual;\n    \n    \n\n    /**\n        Liquidation functions\n     \n    */\n    \n    // @dev this functions trusts all inputs, never call it without having done all validation first.\n    function _liquidate(\n        address _loanHolder,\n        address _collateralAddress,\n        uint256 _col"
    }
  ]
}