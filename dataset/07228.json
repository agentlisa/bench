{
  "Title": "[M-16] RToken permanently insolvent/unusable if a single collateral in the basket behaves unexpectedly",
  "Content": "\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/CTokenFiatCollateral.sol#L45><br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/CTokenFiatCollateral.sol#L37><br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/AssetRegistry.sol#L50><br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BasketHandler.sol#L300><br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/AssetRegistry.sol#L87>\n\nAsset plugins assume underlying collateral tokens will always behave as they are expected at the time of the plugin creation. This assumption can be incorrect because of multiple reasons such as upgrades/rug pulls/hacks.\n\nIn case a single collateral token in a basket of assets causes functions in the asset to fail the whole RToken functionality will be broken.\n\nThis includes (and not limited to):\n\n1.  Users cannot redeem RTokens for any collateral\n2.  Users cannot issue RTokens\n3.  Bad collateral token cannot be unregistered\n4.  Stakers will not be able to unstake\n5.  Recollateralization will not be possible\n6.  Basket cannot be updated\n\nThe impacts become permanent as the unregistering of bad collateral assets is also dependent on collateral token behavior.\n\nEmphasis of funds lost:<br>\n* A basket holds 2 collateral assets \\[cAssetA, cAssetB] where cAssetA holds 1% of the RToken collateral and cAssetB holds 99%.\n* cAssetA gets hacked and self-destructed. This means it will revert on any interaction with it.\n* Even though 99% of funds still exists in cAssetB. They will be permanently locked and RToken will be unusable.\n\n### Proof of Concept\n\nLets assume a `CTokenFiatCollateral` of `cUSDP` is registered as an asset in `AssetRegistry`.\n\nOne day, `cUSDP` deployer gets hacked and the contract self-destructs, therefore any call to the `cUSDP` contract will fail.<br>\n`cUSDP` is a proxy contract:<br>\n<https://etherscan.io/address/0x041171993284df560249B57358F931D9eB7b925D#readProxyContract>\n\nNote: There could be other reasons that calls to `cUSDP` will revert such as:\n\n1.  Upgrade to implementation to change/deprecate functions\n2.  Freezing of contract for a long duration of time (due to patching)\n3.  blacklisting/whitelisitng callers.\n\n**Bad collateral assets cannot be unregistered**\n\nLets describe the flow of unregistering an asset from the `AssetRegistry`:\n\n`governance` needs to call `unregister` in order to unregister and asset:<br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/AssetRegistry.sol#L87>\n\n        function unregister(IAsset asset) external governance {\n            require(_erc20s.contains(address(asset.erc20())), \"no asset to unregister\");\n            require(assets[asset.erc20()] == asset, \"asset not found\");\n            uint192 quantity = basketHandler.quantity(asset.erc20());\n\n            _erc20s.remove(address(asset.erc20()));\n            assets[asset.erc20()] = IAsset(address(0));\n            emit AssetUnregistered(asset.erc20(), asset);\n\n            if (quantity > 0) basketHandler.disableBasket();\n        }\n\nAs can seen above, `basketHandler.quantity(asset.erc20());` is called as part of the unregister flow.\n\n`quantity` function in `basketHandler`:<br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BasketHandler.sol#L300>\n\n        function quantity(IERC20 erc20) public view returns (uint192) {\n            try assetRegistry.toColl(erc20) returns (ICollateral coll) {\n                if (coll.status() == CollateralStatus.DISABLED) return FIX_ZERO;\n\n                uint192 refPerTok = coll.refPerTok(); // {ref/tok}\n                if (refPerTok > 0) {\n                    // {tok/BU} = {ref/BU} / {ref/tok}\n                    return basket.refAmts[erc20].div(refPerTok, CEIL);\n                } else {\n                    return FIX_MAX;\n                }\n            } catch {\n                return FIX_ZERO;\n            }\n        }\n\nThe asset is still registered so the `try` call will succeed and ` coll.refPerTok(); ` will be called.\n\n`refPerTok` function in `CTokenFiatCollateral` (which is used as an asset of `cUSDP`):<br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/CTokenFiatCollateral.sol#L45>\n\n        function refPerTok() public view override returns (uint192) {\n            uint256 rate = ICToken(address(erc20)).exchangeRateStored();\n            int8 shiftLeft = 8 - int8(referenceERC20Decimals) - 18;\n            return shiftl_toFix(rate, shiftLeft);\n        }\n\nIf `ICToken(address(erc20)).exchangeRateStored();` will revert because of the previously defined reasons (hack, upgrade, etc..), the whole `unregister` call will be a reverted.\n\n**Explanation of Impact**\n\nAs long as the asset is registered and cannot be removed (explained above), many function calls will revert and cause the impacts in the `impact` section.\n\nThe main reason is the `refresh` function of `CTokenFiatCollateral` (used for `cUSDP`) depends on a call to `cUSDP` `exchangeRateCurrent` function.<br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/CTokenFiatCollateral.sol#L37>\n\n        function refresh() public virtual override {\n            // == Refresh ==\n            // Update the Compound Protocol\n            ICToken(address(erc20)).exchangeRateCurrent();\n\n            // Intentional and correct for the super call to be last!\n            super.refresh(); // already handles all necessary default checks\n        }\n\n`AssetRegistry`s `refresh` function calls refresh to all registered assets:<br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/AssetRegistry.sol#L50>\n\n        function refresh() public {\n            // It's a waste of gas to require notPausedOrFrozen because assets can be updated directly\n            uint256 length = _erc20s.length();\n            for (uint256 i = 0; i < length; ++i) {\n                assets[IERC20(_erc20s.at(i))].refresh();\n            }\n        }\n\nIn our case, `CTokenFiatCollateral.refresh()` will revert therefore the call to `AssetRegistry.refresh()` will revert.\n\n`AssetRegistry.refresh()` is called in critical functions that will revert:\n\n1.  `_manageTokens` - used manage backing policy, handout excess assets and perform recollateralization\n(<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BackingManager.sol#L107>)\n\n2.  `refreshBucket` - used to switch the basket configuration\n(<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BasketHandler.sol#L184>)\n\n3.  `issue` - used to issue RTokens to depositors\n(<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L194>)\n\n4.  `vest` - used to vest issuance of an account\n(<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L380>)\n\n5.  `redeem` - used to redeem collateral assets for RTokens\n(<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L443>)\n\n6.  `poke` - in main, used as a refresher\n(<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/Main.sol#L45>)\n\n7.  `withdraw` in RSR, stakers will not be able to unstake\n(<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L302>)\n\n### Tools Used\n\nFoundry, VS Code\n\n### Recommended Mitigation Steps\n\nFor plugins to function as intended there has to be a dependency on protocol specific function.\n\nIn a case that the collateral token is corrupted, the governance should be able to replace to corrupted token. The unregistering flow should never be depended on the token functionality.\n\n**[0xean (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/254#issuecomment-1400504728):**\n > Downgrading to Medium and leaving open to sponsor review. There are externalities here that do no qualify the issue as High.\n\n**[tbrent (Reserve) confirmed and commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/254#issuecomment-1404418850):**\n > Nice find!\n\n**[tbrent (Reserve) mitigated](https://github.com/code-423n4/2023-02-reserve-mitigation-contest#mitigations-to-be-reviewed):**\n > This PR makes the AssetRegistry more resilient to bad collateral during asset unregistration, and disables staking when frozen.<br>\n> [reserve-protocol/protocol#623](https://github.com/reserve-protocol/protocol/pull/623)\n\n**Status:** Not fully mitigated. Full details in [report from AkshaySrivastav](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/73), and also included in Mitigation Review section below.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-01-reserve-contest",
  "Code": [
    {
      "filename": "contracts/plugins/assets/CTokenFiatCollateral.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"./FiatCollateral.sol\";\nimport \"./ICToken.sol\";\nimport \"../../libraries/Fixed.sol\";\n\n/**\n * @title CTokenFiatCollateral\n * @notice Collateral plugin for a cToken of fiat collateral, like cUSDC or cUSDP\n * Expected: {tok} != {ref}, {ref} is pegged to {target} unless defaulting, {target} == {UoA}\n */\ncontract CTokenFiatCollateral is FiatCollateral {\n    using OracleLib for AggregatorV3Interface;\n    using FixLib for uint192;\n\n    // All cTokens have 8 decimals, but their underlying may have 18 or 6 or something else.\n\n    uint8 public immutable referenceERC20Decimals;\n\n    IComptroller public immutable comptroller;\n\n    /// @param comptroller_ The CompoundFinance Comptroller\n    constructor(CollateralConfig memory config, IComptroller comptroller_) FiatCollateral(config) {\n        require(address(comptroller_) != address(0), \"comptroller missing\");\n        ICToken erc20 = ICToken(address(config.erc20));\n        referenceERC20Decimals = IERC20Metadata(erc20.underlying()).decimals();\n        comptroller = comptroller_;\n    }\n\n    /// Refresh exchange rates and update default status.\n    /// @custom:interaction RCEI\n    function refresh() public virtual override {\n        // == Refresh ==\n        // Update the Compound Protocol\n        ICToken(address(erc20)).exchangeRateCurrent();\n\n        // Intentional and correct for the super call to be last!\n        super.refresh(); // already handles all necessary default checks\n    }\n\n    /// @return {ref/tok} Quantity of whole reference units per whole collateral tokens\n    function refPerTok() public view override returns (uint192) {\n        uint256 rate = ICToken(address(erc20)).exchangeRateStored();\n        int8 shiftLeft = 8 - int8(referenceERC20Decimals) - 18;\n        return shiftl_toFix(rate, shiftLeft);\n    }\n\n    /// Claim rewards earned by holding a balance of the ERC20 token\n    /// @dev delegatecall\n    function claimRewards() external virtual override {\n        IERC20 comp = IERC20(comptroller.getCompAddress());\n        uint256 oldBal = comp.balanceOf(address(this));\n        comptroller.claimComp(address(this));\n        emit RewardsClaimed(comp, comp.balanceOf(address(this)) - oldBal);\n    }\n}"
    },
    {
      "filename": "contracts/plugins/assets/CTokenFiatCollateral.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"./FiatCollateral.sol\";\nimport \"./ICToken.sol\";\nimport \"../../libraries/Fixed.sol\";\n\n/**\n * @title CTokenFiatCollateral\n * @notice Collateral plugin for a cToken of fiat collateral, like cUSDC or cUSDP\n * Expected: {tok} != {ref}, {ref} is pegged to {target} unless defaulting, {target} == {UoA}\n */\ncontract CTokenFiatCollateral is FiatCollateral {\n    using OracleLib for AggregatorV3Interface;\n    using FixLib for uint192;\n\n    // All cTokens have 8 decimals, but their underlying may have 18 or 6 or something else.\n\n    uint8 public immutable referenceERC20Decimals;\n\n    IComptroller public immutable comptroller;\n\n    /// @param comptroller_ The CompoundFinance Comptroller\n    constructor(CollateralConfig memory config, IComptroller comptroller_) FiatCollateral(config) {\n        require(address(comptroller_) != address(0), \"comptroller missing\");\n        ICToken erc20 = ICToken(address(config.erc20));\n        referenceERC20Decimals = IERC20Metadata(erc20.underlying()).decimals();\n        comptroller = comptroller_;\n    }\n\n    /// Refresh exchange rates and update default status.\n    /// @custom:interaction RCEI\n    function refresh() public virtual override {\n        // == Refresh ==\n        // Update the Compound Protocol\n        ICToken(address(erc20)).exchangeRateCurrent();\n\n        // Intentional and correct for the super call to be last!\n        super.refresh(); // already handles all necessary default checks\n    }\n\n    /// @return {ref/tok} Quantity of whole reference units per whole collateral tokens\n    function refPerTok() public view override returns (uint192) {\n        uint256 rate = ICToken(address(erc20)).exchangeRateStored();\n        int8 shiftLeft = 8 - int8(referenceERC20Decimals) - 18;\n        return shiftl_toFix(rate, shiftLeft);\n    }\n\n    /// Claim rewards earned by holding a balance of the ERC20 token\n    /// @dev delegatecall\n    function claimRewards() external virtual override {\n        IERC20 comp = IERC20(comptroller.getCompAddress());\n        uint256 oldBal = comp.balanceOf(address(this));\n        comptroller.claimComp(address(this));\n        emit RewardsClaimed(comp, comp.balanceOf(address(this)) - oldBal);\n    }\n}"
    },
    {
      "filename": "contracts/p1/AssetRegistry.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"../interfaces/IAssetRegistry.sol\";\nimport \"../interfaces/IMain.sol\";\nimport \"./mixins/Component.sol\";\n\n/// The AssetRegistry provides the mapping from ERC20 to Asset, allowing the rest of Main\n/// to think in terms of ERC20 tokens and target/ref units.\ncontract AssetRegistryP1 is ComponentP1, IAssetRegistry {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    // Peer-component addresses\n    IBasketHandler private basketHandler;\n\n    // Registered ERC20s\n    EnumerableSet.AddressSet private _erc20s;\n\n    // Registered Assets\n    mapping(IERC20 => IAsset) private assets;\n\n    /* ==== Contract Invariants ====\n       The contract state is just the mapping assets; _erc20s is ignored in properties.\n\n       invariant: _erc20s == keys(assets)\n       invariant: addr == assets[addr].erc20()\n           where: addr in assets\n     */\n\n    /// Initialize the AssetRegistry with assets\n    // effects: assets' = {a.erc20(): a for a in assets_}\n    function init(IMain main_, IAsset[] calldata assets_) external initializer {\n        __Component_init(main_);\n        basketHandler = main_.basketHandler();\n        uint256 length = assets_.length;\n        for (uint256 i = 0; i < length; ++i) {\n            _register(assets_[i]);\n        }\n    }\n\n    /// Update the state of all assets\n    /// @custom:refresher\n    // actions: calls refresh(c) for c in keys(assets) when c.isCollateral()\n    function refresh() public {\n        // It's a waste of gas to require notPausedOrFrozen because assets can be updated directly\n        uint256 length = _erc20s.length();\n        for (uint256 i = 0; i < length; ++i) {\n            assets[IERC20(_erc20s.at(i))].refresh();\n        }\n    }\n\n    /// Register `asset`\n    /// If either the erc20 address or the asset was already registered, fail\n    /// @return true if the erc20 address was not already registered.\n    /// @custom:governance\n    // checks: asset.erc20() not in keys(assets) or assets[asset.erc20] == asset\n    // effects: assets' = assets.set(asset.erc20(), asset)\n    // returns: (asset.erc20 not in keys(assets))\n    function register(IAsset asset) external governance returns (bool) {\n        return _register(asset);\n    }\n\n    /// Register `asset` if and only if its erc20 address is already registered.\n    /// If the erc20 address was not registered, revert.\n    /// @return swapped If the asset was swapped for a previously-registered asset\n    /// @custom:governance\n    // contract\n    // checks: asset.erc20() in assets\n    // effects: assets' = assets + {asset.erc20(): asset}\n    // actions: if asset.erc20() is in basketHandler's basket then basketHandler.disableBasket()\n    function swapRegistered(IAsset asset) external governance returns (bool swapped) {\n        require(_erc20s.contains(address(asset.erc20())), \"no ERC20 collision\");\n\n        uint192 quantity = basketHandler.quantity(asset.erc20());\n\n        if (quantity > 0) basketHandler.disableBasket();\n\n        swapped = _registerIgnoringCollisions(asset);\n    }\n\n    /// Unregister an asset, requiring that it is already registered\n    /// @custom:governance\n    // checks: assets[asset.erc20()] == asset\n    // effects: assets' = assets - {asset.erc20():_} + {asset.erc20(), asset}\n    function unregister(IAsset asset) external governance {\n        require(_erc20s.contains(address(asset.erc20())), \"no asset to unregister\");\n        require(assets[asset.erc20()] == asset, \"asset not found\");\n        uint192 quantity = basketHandler.quantity(asset.erc20());\n\n        _erc20s.remove(address(asset.erc20()));\n        assets[asset.erc20()] = IAsset(address(0));\n        emit AssetUnregistered(asset.erc20(), asset);\n\n        if (quantity > 0) basketHandler.disableBasket();\n    }\n\n    /// Return the Asset registered for erc20; revert if erc20 is not registered.\n    // checks: erc20 in assets\n    // returns: assets[erc20]\n    function toAsset(IERC20 erc20) external view returns (IAsset) {\n        require(_erc20s.contains(address(erc20)), \"erc20 unregistered\");\n        return assets[erc20];\n    }\n\n    /// Return the Collateral registered for erc20; revert if erc20 is not registered as Collateral\n    // checks: erc20 in assets, assets[erc20].isCollateral()\n    // returns: assets[erc20]\n    function toColl(IERC20 erc20) external view returns (ICollateral) {\n        require(_erc20s.contains(address(erc20)), \"erc20 unregistered\");\n        require(assets[erc20].isCollateral(), \"erc20 is not collateral\");\n        return ICollateral(address(assets[erc20]));\n    }\n\n    /// Returns true if erc20 is registered.\n    // returns: (erc20 in assets)\n    function isRegistered(IERC20 erc20) external view returns (bool) {\n        return _erc20s.contains(address(erc20));\n    }\n\n    /// Returns keys(assets) as a (duplicate-free) list.\n    // returns: [keys(assets)] without duplicates.\n    function erc20s() external view returns (IERC20[] memory erc20s_) {\n        uint256 length = _erc20s.length();\n        erc20s_ = new IERC20[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            erc20s_[i] = IERC20(_erc20s.at(i));\n        }\n    }\n\n    /// Returns keys(assets), values(assets) as (duplicate-free) lists.\n    // returns: [keys(assets)], [values(assets)] without duplicates.\n    function getRegistry() external view returns (Registry memory reg) {\n        uint256 length = _erc20s.length();\n        reg.erc20s = new IERC20[](length);\n        reg.assets = new IAsset[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            reg.erc20s[i] = IERC20(_erc20s.at(i));\n            reg.assets[i] = assets[IERC20(_erc20s.at(i))];\n        }\n    }\n\n    /// Register an asset\n    /// Forbids registering a different asset for an ERC20 that is already registered\n    /// @return registered If the asset was moved from unregistered to registered\n    // checks: (asset.erc20() not in assets) or (assets[asset.erc20()] == asset)\n    // effects: assets' = assets.set(asset.erc20(), asset)\n    // returns: assets.erc20() not in assets\n    function _register(IAsset asset) internal returns (bool registered) {\n        require(\n            !_erc20s.contains(address(asset.erc20())) || assets[asset.erc20()] == asset,\n            \"duplicate ERC20 detected\"\n        );\n\n        registered = _registerIgnoringCollisions(asset);\n    }\n\n    /// Register an asset, unregistering any previous asset with the same ERC20.\n    // effects: assets' = assets.set(asset.erc20(), asset)\n    // returns: assets[asset.erc20()] != asset\n    function _registerIgnoringCollisions(IAsset asset) private returns (bool swapped) {\n        IERC20Metadata erc20 = asset.erc20();\n        if (_erc20s.contains(address(erc20))) {\n            if (assets[erc20] == asset) return false;\n            else emit AssetUnregistered(erc20, assets[erc20]);\n        } else {\n            _erc20s.add(address(erc20));\n        }\n\n        assets[erc20] = asset;\n        emit AssetRegistered(erc20, asset);\n\n        // Refresh to ensure it does not revert, and to save a recent lastPrice\n        asset.refresh();\n        return true;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[47] private __gap;\n}"
    },
    {
      "filename": "contracts/p1/BasketHandler.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"../interfaces/IAssetRegistry.sol\";\nimport \"../interfaces/IBasketHandler.sol\";\nimport \"../interfaces/IMain.sol\";\nimport \"../libraries/Array.sol\";\nimport \"../libraries/Fixed.sol\";\nimport \"./mixins/Component.sol\";\n\n// A \"valid collateral array\" is a an IERC20[] value without rtoken, rsr, or any duplicate values\n\n// A BackupConfig value is valid if erc20s is a valid collateral array\nstruct BackupConfig {\n    uint256 max; // Maximum number of backup collateral erc20s to use in a basket\n    IERC20[] erc20s; // Ordered list of backup collateral ERC20s\n}\n\n// What does a BasketConfig value mean?\n//\n// erc20s, targetAmts, and targetNames should be interpreted together.\n// targetAmts[erc20] is the quantity of target units of erc20 that one BU should hold\n// targetNames[erc20] is the name of erc20's target unit\n// and then backups[tgt] is the BackupConfig to use for the target unit named tgt\n//\n// For any valid BasketConfig value:\n//     erc20s == keys(targetAmts) == keys(targetNames)\n//     if name is in values(targetNames), then backups[name] is a valid BackupConfig\n//     erc20s is a valid collateral array\n//\n// In the meantime, treat erc20s as the canonical set of keys for the target* maps\nstruct BasketConfig {\n    // The collateral erc20s in the prime (explicitly governance-set) basket\n    IERC20[] erc20s;\n    // Amount of target units per basket for each prime collateral token. {target/BU}\n    mapping(IERC20 => uint192) targetAmts;\n    // Cached view of the target unit for each erc20 upon setup\n    mapping(IERC20 => bytes32) targetNames;\n    // Backup configurations, per target name.\n    mapping(bytes32 => BackupConfig) backups;\n}\n\n/// The type of BasketHandler.basket.\n/// Defines a basket unit (BU) in terms of reference amounts of underlying tokens\n// Logically, basket is just a mapping of erc20 addresses to ref-unit amounts.\n// In the analytical comments I'll just refer to it that way.\n//\n// A Basket is valid if erc20s is a valid collateral array and erc20s == keys(refAmts)\nstruct Basket {\n    IERC20[] erc20s; // enumerated keys for refAmts\n    mapping(IERC20 => uint192) refAmts; // {ref/BU}\n}\n\n/*\n * @title BasketLibP1\n */\nlibrary BasketLibP1 {\n    using BasketLibP1 for Basket;\n    using FixLib for uint192;\n\n    /// Set self to a fresh, empty basket\n    // self'.erc20s = [] (empty list)\n    // self'.refAmts = {} (empty map)\n    function empty(Basket storage self) internal {\n        uint256 length = self.erc20s.length;\n        for (uint256 i = 0; i < length; ++i) self.refAmts[self.erc20s[i]] = FIX_ZERO;\n        delete self.erc20s;\n    }\n\n    /// Set `self` equal to `other`\n    function setFrom(Basket storage self, Basket storage other) internal {\n        empty(self);\n        uint256 length = other.erc20s.length;\n        for (uint256 i = 0; i < length; ++i) {\n            self.erc20s.push(other.erc20s[i]);\n            self.refAmts[other.erc20s[i]] = other.refAmts[other.erc20s[i]];\n        }\n    }\n\n    /// Add `weight` to the refAmount of collateral token `tok` in the basket `self`\n    // self'.refAmts[tok] = self.refAmts[tok] + weight\n    // self'.erc20s is keys(self'.refAmts)\n    function add(\n        Basket storage self,\n        IERC20 tok,\n        uint192 weight\n    ) internal {\n        // untestable:\n        //      Both calls to .add() use a weight that has been CEIL rounded in the\n        //      Fixed library div function, so weight will never be 0 here.\n        //      Additionally, setPrimeBasket() enforces prime-basket tokens must have a weight > 0.\n        if (weight == FIX_ZERO) return;\n        if (self.refAmts[tok].eq(FIX_ZERO)) {\n            self.erc20s.push(tok);\n            self.refAmts[tok] = weight;\n        } else {\n            self.refAmts[tok] = self.refAmts[tok].plus(weight);\n        }\n    }\n}\n\n/**\n * @title BasketHandler\n * @notice Handles the basket configuration, definition, and evolution over time.\n */\ncontract BasketHandlerP1 is ComponentP1, IBasketHandler {\n    using BasketLibP1 for Basket;\n    using CollateralStatusComparator for CollateralStatus;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using FixLib for uint192;\n\n    uint192 public constant MAX_TARGET_AMT = 1e3 * FIX_ONE; // {target/BU} max basket weight\n\n    // Peer components\n    IAssetRegistry private assetRegistry;\n    IBackingManager private backingManager;\n    IERC20 private rsr;\n    IRToken private rToken;\n    IStRSR private stRSR;\n\n    // config is the basket configuration, from which basket will be computed in a basket-switch\n    // event. config is only modified by governance through setPrimeBakset and setBackupConfig\n    BasketConfig private config;\n\n    // basket, disabled, nonce, and timestamp are only ever set by `_switchBasket()`\n    // basket is the current basket.\n    Basket private basket;\n\n    uint48 public override nonce; // A unique identifier for this basket instance\n    uint48 public override timestamp; // The timestamp when this basket was last set\n\n    // If disabled is true, status() is DISABLED, the basket is invalid,\n    // and everything except redemption should be paused.\n    bool private disabled;\n\n    // ==== Invariants ====\n    // basket is a valid Basket:\n    //   basket.erc20s is a valid collateral array and basket.erc20s == keys(basket.refAmts)\n    // config is a valid BasketConfig:\n    //   erc20s == keys(targetAmts) == keys(targetNames)\n    //   erc20s is a valid collateral array\n    //   for b in vals(backups), b.erc20s is a valid collateral array.\n    // if basket.erc20s is empty then disabled == true\n\n    // BasketHandler.init() just leaves the BasketHandler state zeroed\n    function init(IMain main_) external initializer {\n        __Component_init(main_);\n\n        assetRegistry = main_.assetRegistry();\n        backingManager = main_.backingManager();\n        rsr = main_.rsr();\n        rToken = main_.rToken();\n        stRSR = main_.stRSR();\n\n        disabled = true;\n    }\n\n    /// Disable the basket in order to schedule a basket refresh\n    /// @custom:protected\n    // checks: caller is assetRegistry\n    // effects: disabled' = true\n    function disableBasket() external {\n        require(_msgSender() == address(assetRegistry), \"asset registry only\");\n        uint192[] memory refAmts = new uint192[](basket.erc20s.length);\n        emit BasketSet(nonce, basket.erc20s, refAmts, true);\n        disabled = true;\n    }\n\n    /// Switch the basket, only callable directly by governance\n    /// @custom:interaction OR @custom:governance\n    // checks: either caller has OWNER,\n    //         or (basket is disabled after refresh and we're unpaused and unfrozen)\n    // actions: calls assetRegistry.refresh(), then _switchBasket()\n    // effects:\n    //   Either: (basket' is a valid nonempty basket, without DISABLED collateral,\n    //            that satisfies basketConfig) and disabled' = false\n    //   Or no such basket exists and disabled' = true\n    function refreshBasket() external {\n        assetRegistry.refresh();\n\n        require(\n            main.hasRole(OWNER, _msgSender()) ||\n                (status() == CollateralStatus.DISABLED && !main.pausedOrFrozen()),\n            \"basket unrefreshable\"\n        );\n        _switchBasket();\n    }\n\n    /// Set the prime basket in the basket configuration, in terms of erc20s and target amounts\n    /// @param erc20s The collateral for the new prime basket\n    /// @param targetAmts The target amounts (in) {target/BU} for the new prime basket\n    /// @custom:governance\n    // checks:\n    //   caller is OWNER\n    //   len(erc20s) == len(targetAmts)\n    //   erc20s is a valid collateral array\n    //   for all i, erc20[i] is in AssetRegistry as collateral\n    //   for all i, 0 < targetAmts[i] <= MAX_TARGET_AMT == 1000\n    //\n    // effects:\n    //   config'.erc20s = erc20s\n    //   config'.targetAmts[erc20s[i]] = targetAmts[i], for i from 0 to erc20s.length-1\n    //   config'.targetNames[e] = assetRegistry.toColl(e).targetName, for e in erc20s\n    function setPrimeBasket(IERC20[] calldata erc20s, uint192[] calldata targetAmts)\n        external\n        governance\n    {\n        require(erc20s.length > 0, \"cannot empty basket\");\n        require(erc20s.length == targetAmts.length, \"must be same length\");\n        requireValidCollArray(erc20s);\n\n        // Clean up previous basket config\n        for (uint256 i = 0; i < config.erc20s.length; ++i) {\n            delete config.targetAmts[config.erc20s[i]];\n            delete config.targetNames[config.erc20s[i]];\n        }\n        delete config.erc20s;\n\n        // Set up new config basket\n        bytes32[] memory names = new bytes32[](erc20s.length);\n\n        for (uint256 i = 0; i < erc20s.length; ++i) {\n            // This is a nice catch to have, but in general it is possible for\n            // an ERC20 in the prime basket to have its asset unregistered.\n            require(assetRegistry.toAsset(erc20s[i]).isCollateral(), \"token is not collateral\");\n            require(0 < targetAmts[i], \"invalid target amount; must be nonzero\");\n            require(targetAmts[i] <= MAX_TARGET_AMT, \"invalid target amount; too large\");\n\n            config.erc20s.push(erc20s[i]);\n            config.targetAmts[erc20s[i]] = targetAmts[i];\n            names[i] = assetRegistry.toColl(erc20s[i]).targetName();\n            config.targetNames[erc20s[i]] = names[i];\n        }\n\n        emit PrimeBasketSet(erc20s, targetAmts, names);\n    }\n\n    /// Set the backup configuration for some target name\n    /// @custom:governance\n    // checks:\n    //   caller is OWNER\n    //   erc20s is a valid collateral array\n    //   for all i, erc20[i] is in AssetRegistry as collateral\n    //\n    // effects:\n    //   config'.backups[targetName] = {max: max, erc20s: erc20s}\n    function setBackupConfig(\n        bytes32 targetName,\n        uint256 max,\n        IERC20[] calldata erc20s\n    ) external governance {\n        requireValidCollArray(erc20s);\n        BackupConfig storage conf = config.backups[targetName];\n        conf.max = max;\n        delete conf.erc20s;\n\n        for (uint256 i = 0; i < erc20s.length; ++i) {\n            // This is a nice catch to have, but in general it is possible for\n            // an ERC20 in the backup config to have its asset altered.\n            require(assetRegistry.toAsset(erc20s[i]).isCollateral(), \"token is not collateral\");\n            conf.erc20s.push(erc20s[i]);\n        }\n        emit BackupConfigSet(targetName, max, erc20s);\n    }\n\n    /// @return Whether this contract owns enough collateral to cover rToken.basketsNeeded() BUs\n    /// ie, whether the protocol is currently fully collateralized\n    function fullyCollateralized() external view returns (bool) {\n        return basketsHeldBy(address(backingManager)) >= rToken.basketsNeeded();\n    }\n\n    /// @return status_ The status of the basket\n    // returns DISABLED if disabled == true, and worst(status(coll)) otherwise\n    function status() public view returns (CollateralStatus status_) {\n        uint256 size = basket.erc20s.length;\n\n        // untestable:\n        //      disabled is only set in _switchBasket, and only if size > 0.\n        if (disabled || size == 0) return CollateralStatus.DISABLED;\n\n        for (uint256 i = 0; i < size; ++i) {\n            CollateralStatus s = assetRegistry.toColl(basket.erc20s[i]).status();\n            if (s.worseThan(status_)) status_ = s;\n        }\n    }\n\n    /// @return {tok/BU} The token-quantity of an ERC20 token in the basket.\n    // Returns 0 if erc20 is not registered, disabled, or not in the basket\n    // Returns FIX_MAX (in lieu of +infinity) if Collateral.refPerTok() is 0.\n    // Otherwise returns (token's basket.refAmts / token's Collateral.refPerTok())\n    function quantity(IERC20 erc20) public view returns (uint192) {\n        try assetRegistry.toColl(erc20) returns (ICollateral coll) {\n            if (coll.status() == CollateralStatus.DISABLED) return FIX_ZERO;\n\n            uint192 refPerTok = coll.refPerTok(); // {ref/tok}\n            if (refPerTok > 0) {\n                // {tok/BU} = {ref/BU} / {ref/tok}\n                return basket.refAmts[erc20].div(refPerTok, CEIL);\n            } else {\n                return FIX_MAX;\n            }\n        } catch {\n            return FIX_ZERO;\n        }\n    }\n\n    /// Should not revert\n    /// @return low {UoA/tok} The lower end of the price estimate\n    /// @return high {UoA/tok} The upper end of the price estimate\n    // returns sum(quantity(erc20) * price(erc20) for erc20 in basket.erc20s)\n    function price() external view returns (uint192 low, uint192 high) {\n        return _price(false);\n    }\n\n    /// Should not revert\n    /// lowLow should be nonzero when the asset might be worth selling\n    /// @return lotLow {UoA/tok} The lower end of the lot price estimate\n    /// @return lotHigh {UoA/tok} The upper end of the lot price estimate\n    // returns sum(quantity(erc20) * lotPrice(erc20) for erc20 in basket.erc20s)\n    function lotPrice() external view returns (uint192 lotLow, uint192 lotHigh) {\n        return _price(true);\n    }\n\n    /// Returns the price of a BU, using the lot prices if `useLotPrice` is true\n    /// @return low {UoA/tok} The lower end of the lot price estimate\n    /// @return high {UoA/tok} The upper end of the lot price estimate\n    function _price(bool useLotPrice) internal view returns (uint192 low, uint192 high) {\n        uint256 low256;\n        uint256 high256;\n\n        uint256 len = basket.erc20s.length;\n        for (uint256 i = 0; i < len; ++i) {\n            uint192 qty = quantity(basket.erc20s[i]);\n            if (qty == 0) continue;\n\n            (uint192 lowP, uint192 highP) = useLotPrice\n                ? assetRegistry.toAsset(basket.erc20s[i]).lotPrice()\n                : assetRegistry.toAsset(basket.erc20s[i]).price();\n\n            low256 += quantityMulPrice(qty, lowP);\n            high256 += quantityMulPrice(qty, highP);\n        }\n\n        low = low256 >= FIX_MAX ? FIX_MAX : uint192(low256);\n        high = high256 >= FIX_MAX ? FIX_MAX : uint192(high256);\n    }\n\n    /// Multiply quantity by price, rounding up to FIX_MAX and down to 0\n    /// @param qty {tok/BU}\n    /// @param p {UoA/tok}\n    function quantityMulPrice(uint192 qty, uint192 p) internal pure returns (uint192) {\n        // untestable:\n        //      qty will never = 0 here because of the check in _price()\n        if (qty == 0 || p == 0) return 0;\n        // untestable:\n        //      qty = FIX_MAX iff p = 0\n        if (qty == FIX_MAX || p == FIX_MAX) return FIX_MAX;\n\n        // return FIX_MAX instead of throwing overflow errors.\n        unchecked {\n            // p and mul *are* Fix values, so have 18 decimals (D18)\n            uint256 rawDelta = uint256(p) * qty; // {D36} = {D18} * {D18}\n            // if we overflowed *, then return FIX_MAX\n            if (rawDelta / p != qty) return FIX_MAX;\n\n            // add in FIX_HALF for rounding\n            uint256 shiftDelta = rawDelta + (FIX_ONE / 2);\n            // untestable (here there be dragons):\n            //          A)  shiftDelta = rawDelta + (FIX_ONE / 2)\n            //      shiftDelta overflows if:\n            //          B)  shiftDelta = MAX_UINT256 - FIX_ONE/2 + 1\n            //              rawDelta + (FIX_ONE/2) = MAX_UINT256 - FIX_ONE/2 + 1\n            //              p * qty = MAX_UINT256 - FIX_ONE + 1\n            //      therefore shiftDelta overflows if:\n            //          C)  p = (MAX_UINT256 - FIX_ONE + 1) / qty\n            //      MAX_UINT256 ~= 1e77 , FIX_MAX ~= 6e57 (6e20 difference in magnitude)\n            //      qty <= 1e21 (MAX_TARGET_AMT)\n            //      qty must be between 1e19 & 1e20 in order for p in (C) to be uint192,\n            //      but qty would have to be < 1e18 in order for (A) to overflow\n            if (shiftDelta < rawDelta) return FIX_MAX;\n\n            // return _div(rawDelta, FIX_ONE, ROUND)\n            return uint192(shiftDelta / FIX_ONE); // {D18} = {D36} / {D18}\n        }\n    }\n\n    /// Return the current reference basket\n    /// @return erc20s The erc20s in the reference basket\n    function basketTokens() external view returns (IERC20[] memory erc20s) {\n        uint256 len = basket.erc20s.length;\n        erc20s = new IERC20[](len);\n        for (uint256 i = 0; i < len; ++i) {\n            erc20s[i] = basket.erc20s[i];\n        }\n    }\n\n    /// Return the current issuance/redemption value of `amount` BUs\n    /// @param amount {BU}\n    /// @return erc20s The backing collateral erc20s\n    /// @return quantities {qTok} ERC20 token quantities equal to `amount` BUs\n    // Returns (erc20s, [quantity(e) * amount {as qTok} for e in erc20s])\n    function quote(uint192 amount, RoundingMode rounding)\n        external\n        view\n        returns (address[] memory erc20s, uint256[] memory quantities)\n    {\n        uint256 length = basket.erc20s.length;\n        erc20s = new address[](length);\n        quantities = new uint256[](length);\n\n        for (uint256 i = 0; i < length; ++i) {\n            erc20s[i] = address(basket.erc20s[i]);\n\n            // {qTok} = {tok/BU} * {BU} * {tok} * {qTok/tok}\n            quantities[i] = quantity(basket.erc20s[i]).mul(amount, rounding).shiftl_toUint(\n                int8(IERC20Metadata(address(basket.erc20s[i])).decimals()),\n                rounding\n            );\n        }\n    }\n\n    /// @return baskets {BU} The balance of basket units held by `account`\n    /// @dev Returns FIX_ZERO for an empty basket\n    // Returns:\n    //    0, if (basket.erc20s is empty) or (disabled is true) or (status() is DISABLED)\n    //    min(e.balanceOf(account) / quantity(e) for e in basket.erc20s if quantity(e) > 0),\n    function basketsHeldBy(address account) public view returns (uint192 baskets) {\n        uint256 length = basket.erc20s.length;\n        if (length == 0 || disabled) return FIX_ZERO;\n        baskets = FIX_MAX;\n\n        for (uint256 i = 0; i < length; ++i) {\n            ICollateral coll = assetRegistry.toColl(basket.erc20s[i]);\n            if (coll.status() == CollateralStatus.DISABLED) return FIX_ZERO;\n\n            uint192 refPerTok = coll.refPerTok();\n            // If refPerTok is 0, then we have zero of coll's reference unit.\n            // We know that basket.refAmts[basket.erc20s[i]] > 0, so we have no baskets.\n            if (refPerTok == 0) return FIX_ZERO;\n\n            // {tok}\n            uint192 bal = coll.bal(account);\n\n            // {tok/BU} = {ref/BU} / {ref/tok}.  0-division averted by condition above.\n            uint192 q = basket.refAmts[basket.erc20s[i]].div(refPerTok, CEIL);\n\n            // {BU} = {tok} / {tok/BU}.  q > 0 because q = (n).div(_, CEIL) and n > 0\n            baskets = fixMin(baskets, bal.div(q));\n        }\n    }\n\n    /* _switchBasket computes basket' from three inputs:\n       - the basket configuration (config: BasketConfig)\n       - the function (isGood: erc20 -> bool), implemented here by goodCollateral()\n       - the function (targetPerRef: erc20 -> Fix) implemented by the Collateral plugin\n\n       ==== Definitions ====\n\n       We use e:IERC20 to mean any erc20 token address, and tgt:bytes32 to mean any target name\n\n       // targetWeight(b, e) is the target-unit weight of token e in basket b\n       Let targetWeight(b, e) = b.refAmt[e] * targetPerRef(e)\n\n       // backups(tgt) is the list of sound backup tokens we plan to use for target `tgt`.\n       Let backups(tgt) = config.backups[tgt].erc20s\n                          .filter(isGood)\n                          .takeUpTo(config.backups[tgt].max)\n\n       Let primeWt(e) = if e in config.erc20s and isGood(e)\n                        then config.targetAmts[e]\n                        else 0\n       Let backupWt(e) = if e in backups(tgt)\n                         then unsoundPrimeWt(tgt) / len(Backups(tgt))\n                         else 0\n       Let unsoundPrimeWt(tgt) = sum(config.targetAmts[e]\n                                     for e in config.erc20s\n                                     where config.targetNames[e] == tgt and !isGood(e))\n\n       ==== The correctness condition ====\n\n       If unsoundPrimeWt(tgt) > 0 and len(backups(tgt)) == 0 for"
    }
  ]
}