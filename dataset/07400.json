{
  "Title": "[G-10]  Division by two should use bit shifting",
  "Content": "\n`<x> / 2` is the same as `<x> >> 1`. While the compiler uses the `SHR` opcode to accomplish both, the version that uses division incurs an overhead of [**20 gas**](https://gist.github.com/IllIllI000/ec0e4e6c4f52a6bca158f137a3afd4ff) due to `JUMP`s to and from a compiler utility function that introduces checks which can be avoided by using `unchecked {}` around the division by two.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: src/libraries/UniswapHelpers.sol\n\n111:          return TickMath.getSqrtRatioAtTick(TickMath.getTickAtSqrtRatio(uint160((token1ONE << 96) / token0ONE)) / 2);\n\n```\nhttps://github.com/with-backed/papr/blob/1933da2e38ff9d47c17e2749d6088bbbd40bfa68/src/libraries/UniswapHelpers.sol#L111\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-12-backed",
  "Code": [
    {
      "filename": "src/libraries/UniswapHelpers.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.0;\n\nimport {IUniswapV3Pool} from \"v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {IUniswapV3Factory} from \"v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\nimport {TickMath} from \"fullrange/libraries/TickMath.sol\";\nimport {FullMath} from \"fullrange/libraries/FullMath.sol\";\nimport {SafeCast} from \"v3-core/contracts/libraries/SafeCast.sol\";\n\nimport {PoolAddress} from \"./PoolAddress.sol\";\n\nlibrary UniswapHelpers {\n    using SafeCast for uint256;\n\n    /// @param minOut The minimum out amount the user wanted\n    /// @param actualOut The actual out amount the user received\n    error TooLittleOut(uint256 minOut, uint256 actualOut);\n\n    IUniswapV3Factory constant FACTORY = IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984);\n\n    /// @notice executes a swap on the Uniswap\n    /// @param pool The pool to swap on\n    /// @param recipient The address to send the output to\n    /// @param zeroForOne Whether to swap token0 for token1 or vice versa\n    /// @param amountSpecified The amount of token0 or token1 to swap\n    /// @param minOut The minimum amount of token0 or token1 to receive\n    /// @param sqrtPriceLimitX96 The price limit for the swap\n    /// @param data Any data to pass to the uniswap callback handler\n    /// @return amountOut The amount of token0 or token1 received\n    /// @return amountIn The amount of token0 or token1 sent\n    function swap(\n        address pool,\n        address recipient,\n        bool zeroForOne,\n        uint256 amountSpecified,\n        uint256 minOut,\n        uint160 sqrtPriceLimitX96,\n        bytes memory data\n    ) internal returns (uint256 amountOut, uint256 amountIn) {\n        (int256 amount0, int256 amount1) = IUniswapV3Pool(pool).swap(\n            recipient,\n            zeroForOne,\n            amountSpecified.toInt256(),\n            sqrtPriceLimitX96 == 0\n                ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                : sqrtPriceLimitX96,\n            data\n        );\n\n        if (zeroForOne) {\n            amountOut = uint256(-amount1);\n            amountIn = uint256(amount0);\n        } else {\n            amountOut = uint256(-amount0);\n            amountIn = uint256(amount1);\n        }\n\n        if (amountOut < minOut) {\n            revert TooLittleOut(amountOut, minOut);\n        }\n    }\n\n    /// @notice initializes a UniswapV3 pool with the given sqrt ratio\n    /// @param tokenA the first token in the pool\n    /// @param tokenB the second token in the pool\n    /// @param feeTier the fee tier of the pool\n    /// @param sqrtRatio the sqrt ratio to initialize the pool with\n    /// @return pool the address of the newly created pool\n    function deployAndInitPool(address tokenA, address tokenB, uint24 feeTier, uint160 sqrtRatio)\n        internal\n        returns (address)\n    {\n        IUniswapV3Pool pool = IUniswapV3Pool(FACTORY.createPool(tokenA, tokenB, feeTier));\n        pool.initialize(sqrtRatio);\n\n        return address(pool);\n    }\n\n    /// @notice returns the current price tick of a UniswapV3 pool\n    /// @param pool the address of the pool\n    /// @return tick the current price tick of the pool\n    function poolCurrentTick(address pool) internal returns (int24) {\n        (, int24 tick,,,,,) = IUniswapV3Pool(pool).slot0();\n\n        return tick;\n    }\n\n    /// @notice returns whether or not two pools have the same tokens\n    /// @param pool1 the first pool\n    /// @param pool2 the second pool\n    /// @return same whether or not the two pools have the same tokens\n    function poolsHaveSameTokens(address pool1, address pool2) internal view returns (bool) {\n        return IUniswapV3Pool(pool1).token0() == IUniswapV3Pool(pool2).token0()\n            && IUniswapV3Pool(pool1).token1() == IUniswapV3Pool(pool2).token1();\n    }\n\n    /// @notice returns whether or not a pool is a UniswapV3 pool\n    /// @param pool the address of the pool\n    /// @return isUniswapPool whether or not the pool is a UniswapV3 pool\n    function isUniswapPool(address pool) internal view returns (bool) {\n        IUniswapV3Pool p = IUniswapV3Pool(pool);\n        PoolAddress.PoolKey memory k = PoolAddress.getPoolKey(p.token0(), p.token1(), p.fee());\n        return pool == PoolAddress.computeAddress(address(FACTORY), k);\n    }\n\n    /// @notice returns the sqrt ratio at which token0 and token1 are trading at 1:1\n    /// @param token0ONE 10 ** token0.decimals()\n    /// @param token1ONE 10 ** token1.decimals()\n    /// @return sqrtRatio at which token0 and token1 are trading at 1:1\n    function oneToOneSqrtRatio(uint256 token0ONE, uint256 token1ONE) internal pure returns (uint160) {\n        return TickMath.getSqrtRatioAtTick(TickMath.getTickAtSqrtRatio(uint160((token1ONE << 96) / token0ONE)) / 2);\n    }\n}"
    }
  ]
}