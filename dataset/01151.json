{
  "Title": "L2 Standard ERC-20 Token Metadata Can Be Set Arbitrarily",
  "Content": "When an ERC-20 is first deposited on L2 through the standard ERC-20 gateway contract, the [contract fetches](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/gateways/L1StandardERC20Gateway.sol#L150) the symbol, name and decimals of the ERC-20 token. These are [ABI encoded](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/gateways/L1StandardERC20Gateway.sol#L153) alongside the `_data` passed by the user, and the message is forwarded to the L2. On the L2 side, as this token is seen for the first time, the metadata is [decoded from the data](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/gateways/L2StandardERC20Gateway.sol#L162). A [call to the `ScrollStandardERC20Factory`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/gateways/L2StandardERC20Gateway.sol#L161) is then made and a clone of the `ScrollStandardERC20` contract is deployed and [initialized](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/gateways/L2StandardERC20Gateway.sol#L166) with the symbol, name and decimals.\n\n\nHowever, an attacker can use the lack of atomicity when bridging to set arbitrary metadata when an ERC-20 is bridged to L2 for the first time. An example of this would involve two transactions:\n\n\n1. The attacker first calls the [deposit](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/gateways/L1StandardERC20Gateway.sol#L114) function to deposit a new ERC-20 token with a very low `_gasLimit` parameter. Because the ERC-20 address is not yet in `tokenMapping`, the contract fetches its [metadata](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/gateways/L1StandardERC20Gateway.sol#L150) information and [encodes](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/gateways/L1StandardERC20Gateway.sol#L153) it alongside the `_data` parameter. The token is then added to the `tokenMapping`, the message is relayed and reverts on L2 with an out-of-gas exception.\n2. The attacker then calls the [deposit](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/gateways/L1StandardERC20Gateway.sol#L114) function again with a `_data` parameter containing an [ABI encoding of arbitrary metadata](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/gateways/L1StandardERC20Gateway.sol#L153). Because the `tokenMapping` now contains the ERC-20 address, the call would be directly transmitted to L2 without fetching the ERC-20 metadata. As it is the first time the L2 sees this token, a `ScrollStandardERC20` clone is deployed with symbol, name and decimals decoded from the `_data` parameter set by the attacker.\n\n\nThe token contract would thus have its metadata set by the attacker. Additionally, this contract and the factory are [immutable](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/libraries/token/ScrollStandardERC20.sol#L15), and the address to which a clone is deployed is deterministic meaning it cannot be redeployed easily. This would be complex to fix in practice. In terms of impact, it would be very confusing for users, having to deal with tokens with different metadata in the UIs depending on whether the token is on L1 or L2, and could be used to intentionally grief specific projects.\n\n\nConsider not updating `tokenMapping[_token]` on the first partially successful L1 deposit, but only when a token is successfully withdrawn from L2 in the [`finalizeWithdrawERC20` function](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/gateways/L1StandardERC20Gateway.sol#L88). This strikes a good balance by ensuring that tokens can be deployed even if a first transaction fails on L2, as the metadata would be sent again, while avoiding wasting gas by querying this information on each deposit forever.\n\n\n***Update:** Resolved in [pull request #606](https://github.com/scroll-tech/scroll/pull/606) at commit [2f76991](https://github.com/scroll-tech/scroll/pull/606/commits/2f76991ddbddcf92bef5fbd0103124e6636c6f2c).*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/L1/gateways/L1StandardERC20Gateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport {IERC20Metadata} from \"../../interfaces/IERC20Metadata.sol\";\nimport {IL2ERC20Gateway} from \"../../L2/gateways/IL2ERC20Gateway.sol\";\nimport {IL1ScrollMessenger} from \"../IL1ScrollMessenger.sol\";\nimport {IL1ERC20Gateway} from \"./IL1ERC20Gateway.sol\";\n\nimport {ScrollGatewayBase} from \"../../libraries/gateway/ScrollGatewayBase.sol\";\nimport {L1ERC20Gateway} from \"./L1ERC20Gateway.sol\";\n\n/// @title L1StandardERC20Gateway\n/// @notice The `L1StandardERC20Gateway` is used to deposit standard ERC20 tokens in layer 1 and\n/// finalize withdraw the tokens from layer 2.\n/// @dev The deposited ERC20 tokens are held in this gateway. On finalizing withdraw, the corresponding\n/// token will be transfer to the recipient directly. Any ERC20 that requires non-standard functionality\n/// should use a separate gateway.\ncontract L1StandardERC20Gateway is Initializable, ScrollGatewayBase, L1ERC20Gateway {\n    using SafeERC20 for IERC20;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The address of ScrollStandardERC20 implementation in L2.\n    address public l2TokenImplementation;\n\n    /// @notice The address of ScrollStandardERC20Factory contract in L2.\n    address public l2TokenFactory;\n\n    /// @notice Mapping from l1 token address to l2 token address.\n    /// @dev This is not necessary, since we can compute the address directly. But, we use this mapping\n    /// to keep track on whether we have deployed the token in L2 using the L2ScrollStandardERC20Factory and\n    /// pass deploy data on first call to the token.\n    mapping(address => address) private tokenMapping;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @notice Initialize the storage of L1StandardERC20Gateway.\n    /// @param _counterpart The address of L2StandardERC20Gateway in L2.\n    /// @param _router The address of L1GatewayRouter.\n    /// @param _messenger The address of L1ScrollMessenger.\n    /// @param _l2TokenImplementation The address of ScrollStandardERC20 implementation in L2.\n    /// @param _l2TokenFactory The address of ScrollStandardERC20Factory contract in L2.\n    function initialize(\n        address _counterpart,\n        address _router,\n        address _messenger,\n        address _l2TokenImplementation,\n        address _l2TokenFactory\n    ) external initializer {\n        require(_router != address(0), \"zero router address\");\n        ScrollGatewayBase._initialize(_counterpart, _router, _messenger);\n\n        require(_l2TokenImplementation != address(0), \"zero implementation hash\");\n        require(_l2TokenFactory != address(0), \"zero factory address\");\n\n        l2TokenImplementation = _l2TokenImplementation;\n        l2TokenFactory = _l2TokenFactory;\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function getL2ERC20Address(address _l1Token) public view override returns (address) {\n        // In StandardERC20Gateway, all corresponding l2 tokens are depoyed by Create2 with salt,\n        // we can calculate the l2 address directly.\n        bytes32 _salt = keccak256(abi.encodePacked(counterpart, keccak256(abi.encodePacked(_l1Token))));\n\n        return Clones.predictDeterministicAddress(l2TokenImplementation, _salt, l2TokenFactory);\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function finalizeWithdrawERC20(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable override onlyCallByCounterpart nonReentrant {\n        require(msg.value == 0, \"nonzero msg.value\");\n        require(_l2Token != address(0), \"token address cannot be 0\");\n        require(getL2ERC20Address(_l1Token) == _l2Token, \"l2 token mismatch\");\n\n        // @note can possible trigger reentrant call to messenger,\n        // but it seems not a big problem.\n        IERC20(_l1Token).safeTransfer(_to, _amount);\n\n        _doCallback(_to, _data);\n\n        emit FinalizeWithdrawERC20(_l1Token, _l2Token, _from, _to, _amount, _data);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @inheritdoc L1ERC20Gateway\n    function _deposit(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) internal virtual override nonReentrant {\n        require(_amount > 0, \"deposit zero amount\");\n\n        // 1. Extract real sender if this call is from L1GatewayRouter.\n        address _from = msg.sender;\n        if (router == msg.sender) {\n            (_from, _data) = abi.decode(_data, (address, bytes));\n        }\n\n        // 2. Transfer token into this contract.\n        {\n            // common practice to handle fee on transfer token.\n            uint256 _before = IERC20(_token).balanceOf(address(this));\n            IERC20(_token).safeTransferFrom(_from, address(this), _amount);\n            uint256 _after = IERC20(_token).balanceOf(address(this));\n            // no unchecked here, since some weird token may return arbitrary balance.\n            _amount = _after - _before;\n            // ignore weird fee on transfer token\n            require(_amount > 0, \"deposit zero amount\");\n        }\n\n        // 3. Generate message passed to L2StandardERC20Gateway.\n        address _l2Token = tokenMapping[_token];\n        bytes memory _l2Data = _data;\n        if (_l2Token == address(0)) {\n            // It is a new token, compute and store mapping in storage.\n            _l2Token = getL2ERC20Address(_token);\n            tokenMapping[_token] = _l2Token;\n\n            // passing symbol/name/decimal in order to deploy in L2.\n            string memory _symbol = IERC20Metadata(_token).symbol();\n            string memory _name = IERC20Metadata(_token).name();\n            uint8 _decimals = IERC20Metadata(_token).decimals();\n            _l2Data = abi.encode(_data, abi.encode(_symbol, _name, _decimals));\n        }\n        bytes memory _message = abi.encodeWithSelector(\n            IL2ERC20Gateway.finalizeDepositERC20.selector,\n            _token,\n            _l2Token,\n            _from,\n            _to,\n            _amount,\n            _l2Data\n        );\n\n        // 4. Send message to L1ScrollMessenger.\n        IL1ScrollMessenger(messenger).sendMessage{value: msg.value}(counterpart, 0, _message, _gasLimit);\n\n        emit DepositERC20(_token, _l2Token, _from, _to, _amount, _data);\n    }\n}"
    },
    {
      "filename": "contracts/src/L1/gateways/L1StandardERC20Gateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport {IERC20Metadata} from \"../../interfaces/IERC20Metadata.sol\";\nimport {IL2ERC20Gateway} from \"../../L2/gateways/IL2ERC20Gateway.sol\";\nimport {IL1ScrollMessenger} from \"../IL1ScrollMessenger.sol\";\nimport {IL1ERC20Gateway} from \"./IL1ERC20Gateway.sol\";\n\nimport {ScrollGatewayBase} from \"../../libraries/gateway/ScrollGatewayBase.sol\";\nimport {L1ERC20Gateway} from \"./L1ERC20Gateway.sol\";\n\n/// @title L1StandardERC20Gateway\n/// @notice The `L1StandardERC20Gateway` is used to deposit standard ERC20 tokens in layer 1 and\n/// finalize withdraw the tokens from layer 2.\n/// @dev The deposited ERC20 tokens are held in this gateway. On finalizing withdraw, the corresponding\n/// token will be transfer to the recipient directly. Any ERC20 that requires non-standard functionality\n/// should use a separate gateway.\ncontract L1StandardERC20Gateway is Initializable, ScrollGatewayBase, L1ERC20Gateway {\n    using SafeERC20 for IERC20;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The address of ScrollStandardERC20 implementation in L2.\n    address public l2TokenImplementation;\n\n    /// @notice The address of ScrollStandardERC20Factory contract in L2.\n    address public l2TokenFactory;\n\n    /// @notice Mapping from l1 token address to l2 token address.\n    /// @dev This is not necessary, since we can compute the address directly. But, we use this mapping\n    /// to keep track on whether we have deployed the token in L2 using the L2ScrollStandardERC20Factory and\n    /// pass deploy data on first call to the token.\n    mapping(address => address) private tokenMapping;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @notice Initialize the storage of L1StandardERC20Gateway.\n    /// @param _counterpart The address of L2StandardERC20Gateway in L2.\n    /// @param _router The address of L1GatewayRouter.\n    /// @param _messenger The address of L1ScrollMessenger.\n    /// @param _l2TokenImplementation The address of ScrollStandardERC20 implementation in L2.\n    /// @param _l2TokenFactory The address of ScrollStandardERC20Factory contract in L2.\n    function initialize(\n        address _counterpart,\n        address _router,\n        address _messenger,\n        address _l2TokenImplementation,\n        address _l2TokenFactory\n    ) external initializer {\n        require(_router != address(0), \"zero router address\");\n        ScrollGatewayBase._initialize(_counterpart, _router, _messenger);\n\n        require(_l2TokenImplementation != address(0), \"zero implementation hash\");\n        require(_l2TokenFactory != address(0), \"zero factory address\");\n\n        l2TokenImplementation = _l2TokenImplementation;\n        l2TokenFactory = _l2TokenFactory;\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function getL2ERC20Address(address _l1Token) public view override returns (address) {\n        // In StandardERC20Gateway, all corresponding l2 tokens are depoyed by Create2 with salt,\n        // we can calculate the l2 address directly.\n        bytes32 _salt = keccak256(abi.encodePacked(counterpart, keccak256(abi.encodePacked(_l1Token))));\n\n        return Clones.predictDeterministicAddress(l2TokenImplementation, _salt, l2TokenFactory);\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function finalizeWithdrawERC20(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable override onlyCallByCounterpart nonReentrant {\n        require(msg.value == 0, \"nonzero msg.value\");\n        require(_l2Token != address(0), \"token address cannot be 0\");\n        require(getL2ERC20Address(_l1Token) == _l2Token, \"l2 token mismatch\");\n\n        // @note can possible trigger reentrant call to messenger,\n        // but it seems not a big problem.\n        IERC20(_l1Token).safeTransfer(_to, _amount);\n\n        _doCallback(_to, _data);\n\n        emit FinalizeWithdrawERC20(_l1Token, _l2Token, _from, _to, _amount, _data);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @inheritdoc L1ERC20Gateway\n    function _deposit(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) internal virtual override nonReentrant {\n        require(_amount > 0, \"deposit zero amount\");\n\n        // 1. Extract real sender if this call is from L1GatewayRouter.\n        address _from = msg.sender;\n        if (router == msg.sender) {\n            (_from, _data) = abi.decode(_data, (address, bytes));\n        }\n\n        // 2. Transfer token into this contract.\n        {\n            // common practice to handle fee on transfer token.\n            uint256 _before = IERC20(_token).balanceOf(address(this));\n            IERC20(_token).safeTransferFrom(_from, address(this), _amount);\n            uint256 _after = IERC20(_token).balanceOf(address(this));\n            // no unchecked here, since some weird token may return arbitrary balance.\n            _amount = _after - _before;\n            // ignore weird fee on transfer token\n            require(_amount > 0, \"deposit zero amount\");\n        }\n\n        // 3. Generate message passed to L2StandardERC20Gateway.\n        address _l2Token = tokenMapping[_token];\n        bytes memory _l2Data = _data;\n        if (_l2Token == address(0)) {\n            // It is a new token, compute and store mapping in storage.\n            _l2Token = getL2ERC20Address(_token);\n            tokenMapping[_token] = _l2Token;\n\n            // passing symbol/name/decimal in order to deploy in L2.\n            string memory _symbol = IERC20Metadata(_token).symbol();\n            string memory _name = IERC20Metadata(_token).name();\n            uint8 _decimals = IERC20Metadata(_token).decimals();\n            _l2Data = abi.encode(_data, abi.encode(_symbol, _name, _decimals));\n        }\n        bytes memory _message = abi.encodeWithSelector(\n            IL2ERC20Gateway.finalizeDepositERC20.selector,\n            _token,\n            _l2Token,\n            _from,\n            _to,\n            _amount,\n            _l2Data\n        );\n\n        // 4. Send message to L1ScrollMessenger.\n        IL1ScrollMessenger(messenger).sendMessage{value: msg.value}(counterpart, 0, _message, _gasLimit);\n\n        emit DepositERC20(_token, _l2Token, _from, _to, _amount, _data);\n    }\n}"
    },
    {
      "filename": "contracts/src/L1/gateways/L1StandardERC20Gateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport {IERC20Metadata} from \"../../interfaces/IERC20Metadata.sol\";\nimport {IL2ERC20Gateway} from \"../../L2/gateways/IL2ERC20Gateway.sol\";\nimport {IL1ScrollMessenger} from \"../IL1ScrollMessenger.sol\";\nimport {IL1ERC20Gateway} from \"./IL1ERC20Gateway.sol\";\n\nimport {ScrollGatewayBase} from \"../../libraries/gateway/ScrollGatewayBase.sol\";\nimport {L1ERC20Gateway} from \"./L1ERC20Gateway.sol\";\n\n/// @title L1StandardERC20Gateway\n/// @notice The `L1StandardERC20Gateway` is used to deposit standard ERC20 tokens in layer 1 and\n/// finalize withdraw the tokens from layer 2.\n/// @dev The deposited ERC20 tokens are held in this gateway. On finalizing withdraw, the corresponding\n/// token will be transfer to the recipient directly. Any ERC20 that requires non-standard functionality\n/// should use a separate gateway.\ncontract L1StandardERC20Gateway is Initializable, ScrollGatewayBase, L1ERC20Gateway {\n    using SafeERC20 for IERC20;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The address of ScrollStandardERC20 implementation in L2.\n    address public l2TokenImplementation;\n\n    /// @notice The address of ScrollStandardERC20Factory contract in L2.\n    address public l2TokenFactory;\n\n    /// @notice Mapping from l1 token address to l2 token address.\n    /// @dev This is not necessary, since we can compute the address directly. But, we use this mapping\n    /// to keep track on whether we have deployed the token in L2 using the L2ScrollStandardERC20Factory and\n    /// pass deploy data on first call to the token.\n    mapping(address => address) private tokenMapping;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @notice Initialize the storage of L1StandardERC20Gateway.\n    /// @param _counterpart The address of L2StandardERC20Gateway in L2.\n    /// @param _router The address of L1GatewayRouter.\n    /// @param _messenger The address of L1ScrollMessenger.\n    /// @param _l2TokenImplementation The address of ScrollStandardERC20 implementation in L2.\n    /// @param _l2TokenFactory The address of ScrollStandardERC20Factory contract in L2.\n    function initialize(\n        address _counterpart,\n        address _router,\n        address _messenger,\n        address _l2TokenImplementation,\n        address _l2TokenFactory\n    ) external initializer {\n        require(_router != address(0), \"zero router address\");\n        ScrollGatewayBase._initialize(_counterpart, _router, _messenger);\n\n        require(_l2TokenImplementation != address(0), \"zero implementation hash\");\n        require(_l2TokenFactory != address(0), \"zero factory address\");\n\n        l2TokenImplementation = _l2TokenImplementation;\n        l2TokenFactory = _l2TokenFactory;\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function getL2ERC20Address(address _l1Token) public view override returns (address) {\n        // In StandardERC20Gateway, all corresponding l2 tokens are depoyed by Create2 with salt,\n        // we can calculate the l2 address directly.\n        bytes32 _salt = keccak256(abi.encodePacked(counterpart, keccak256(abi.encodePacked(_l1Token))));\n\n        return Clones.predictDeterministicAddress(l2TokenImplementation, _salt, l2TokenFactory);\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function finalizeWithdrawERC20(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable override onlyCallByCounterpart nonReentrant {\n        require(msg.value == 0, \"nonzero msg.value\");\n        require(_l2Token != address(0), \"token address cannot be 0\");\n        require(getL2ERC20Address(_l1Token) == _l2Token, \"l2 token mismatch\");\n\n        // @note can possible trigger reentrant call to messenger,\n        // but it seems not a big problem.\n        IERC20(_l1Token).safeTransfer(_to, _amount);\n\n        _doCallback(_to, _data);\n\n        emit FinalizeWithdrawERC20(_l1Token, _l2Token, _from, _to, _amount, _data);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @inheritdoc L1ERC20Gateway\n    function _deposit(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) internal virtual override nonReentrant {\n        require(_amount > 0, \"deposit zero amount\");\n\n        // 1. Extract real sender if this call is from L1GatewayRouter.\n        address _from = msg.sender;\n        if (router == msg.sender) {\n            (_from, _data) = abi.decode(_data, (address, bytes));\n        }\n\n        // 2. Transfer token into this contract.\n        {\n            // common practice to handle fee on transfer token.\n            uint256 _before = IERC20(_token).balanceOf(address(this));\n            IERC20(_token).safeTransferFrom(_from, address(this), _amount);\n            uint256 _after = IERC20(_token).balanceOf(address(this));\n            // no unchecked here, since some weird token may return arbitrary balance.\n            _amount = _after - _before;\n            // ignore weird fee on transfer token\n            require(_amount > 0, \"deposit zero amount\");\n        }\n\n        // 3. Generate message passed to L2StandardERC20Gateway.\n        address _l2Token = tokenMapping[_token];\n        bytes memory _l2Data = _data;\n        if (_l2Token == address(0)) {\n            // It is a new token, compute and store mapping in storage.\n            _l2Token = getL2ERC20Address(_token);\n            tokenMapping[_token] = _l2Token;\n\n            // passing symbol/name/decimal in order to deploy in L2.\n            string memory _symbol = IERC20Metadata(_token).symbol();\n            string memory _name = IERC20Metadata(_token).name();\n            uint8 _decimals = IERC20Metadata(_token).decimals();\n            _l2Data = abi.encode(_data, abi.encode(_symbol, _name, _decimals));\n        }\n        bytes memory _message = abi.encodeWithSelector(\n            IL2ERC20Gateway.finalizeDepositERC20.selector,\n            _token,\n            _l2Token,\n            _from,\n            _to,\n            _amount,\n            _l2Data\n        );\n\n        // 4. Send message to L1ScrollMessenger.\n        IL1ScrollMessenger(messenger).sendMessage{value: msg.value}(counterpart, 0, _message, _gasLimit);\n\n        emit DepositERC20(_token, _l2Token, _from, _to, _amount, _data);\n    }\n}"
    },
    {
      "filename": "contracts/src/libraries/token/ScrollStandardERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {ERC20PermitUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\nimport {IScrollERC20Upgradeable} from \"./IScrollERC20Upgradeable.sol\";\nimport {IERC677Receiver} from \"../callbacks/IERC677Receiver.sol\";\n\n/// @notice The `ScrollStandardERC20` is the ERC20 token contract created by\n/// `L2StandardERC20Gateway` when the first time the L1 ERC20 is bridged via\n/// `L1StandardERC20Gateway`.\n/// @dev The reason that `ScrollStandardERC20` inherits `IScrollERC20Upgradeable` is because we need\n/// to use the `initialize` function from the `ERC20PermitUpgradeable` to initialize the ERC20\n/// token. However, the token contract is NOT upgradable afterwards because\n/// `ScrollStandardERC20Factory` uses `Clones` to deploy the `ScrollStandardERC20` contract.\ncontract ScrollStandardERC20 is ERC20PermitUpgradeable, IScrollERC20Upgradeable {\n    /// @inheritdoc IScrollERC20Upgradeable\n    address public override gateway;\n\n    /// @inheritdoc IScrollERC20Upgradeable\n    address public override counterpart;\n\n    uint8 private decimals_;\n\n    modifier onlyGateway() {\n        require(gateway == msg.sender, \"Only Gateway\");\n        _;\n    }\n\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        address _gateway,\n        address _counterpart\n    ) external initializer {\n        __ERC20Permit_init(_name);\n        __ERC20_init(_name, _symbol);\n\n        decimals_ = _decimals;\n        gateway = _gateway;\n        counterpart = _counterpart;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return decimals_;\n    }\n\n    /// @dev ERC677 Standard, see https://github.com/ethereum/EIPs/issues/677\n    /// Defi can use this method to transfer L1/L2 token to L2/L1,\n    /// and deposit to L2/L1 contract in one transaction\n    function transferAndCall(\n        address receiver,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool success) {\n        ERC20Upgradeable.transfer(receiver, amount);\n        if (isContract(receiver)) {\n            contractFallback(receiver, amount, data);\n        }\n        return true;\n    }\n\n    function contractFallback(\n        address to,\n        uint256 value,\n        bytes memory data\n    ) private {\n        IERC677Receiver receiver = IERC677Receiver(to);\n        receiver.onTokenTransfer(msg.sender, value, data);\n    }\n\n    function isContract(address _addr) private view returns (bool hasCode) {\n        uint256 length;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            length := extcodesize(_addr)\n        }\n        return length > 0;\n    }\n\n    /// @inheritdoc IScrollERC20Upgradeable\n    function mint(address _to, uint256 _amount) external onlyGateway {\n        _mint(_to, _amount);\n    }\n\n    /// @inheritdoc IScrollERC20Upgradeable\n    function burn(address _from, uint256 _amount) external onlyGateway {\n        _burn(_from, _amount);\n    }\n}"
    },
    {
      "filename": "contracts/src/L1/gateways/L1StandardERC20Gateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport {IERC20Metadata} from \"../../interfaces/IERC20Metadata.sol\";\nimport {IL2ERC20Gateway} from \"../../L2/gateways/IL2ERC20Gateway.sol\";\nimport {IL1ScrollMessenger} from \"../IL1ScrollMessenger.sol\";\nimport {IL1ERC20Gateway} from \"./IL1ERC20Gateway.sol\";\n\nimport {ScrollGatewayBase} from \"../../libraries/gateway/ScrollGatewayBase.sol\";\nimport {L1ERC20Gateway} from \"./L1ERC20Gateway.sol\";\n\n/// @title L1StandardERC20Gateway\n/// @notice The `L1StandardERC20Gateway` is used to deposit standard ERC20 tokens in layer 1 and\n/// finalize withdraw the tokens from layer 2.\n/// @dev The deposited ERC20 tokens are held in this gateway. On finalizing withdraw, the corresponding\n/// token will be transfer to the recipient directly. Any ERC20 that requires non-standard functionality\n/// should use a separate gateway.\ncontract L1StandardERC20Gateway is Initializable, ScrollGatewayBase, L1ERC20Gateway {\n    using SafeERC20 for IERC20;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The address of ScrollStandardERC20 implementation in L2.\n    address public l2TokenImplementation;\n\n    /// @notice The address of ScrollStandardERC20Factory contract in L2.\n    address public l2TokenFactory;\n\n    /// @notice Mapping from l1 token address to l2 token address.\n    /// @dev This is not necessary, since we can compute the address directly. But, we use this mapping\n    /// to keep track on whether we have deployed the token in L2 using the L2ScrollStandardERC20Factory and\n    /// pass deploy data on first call to the token.\n    mapping(address => address) private tokenMapping;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @notice Initialize the storage of L1StandardERC20Gateway.\n    /// @param _counterpart The address of L2StandardERC20Gateway in L2.\n    /// @param _router The address of L1GatewayRouter.\n    /// @param _messenger The address of L1ScrollMessenger.\n    /// @param _l2TokenImplementation The address of ScrollStandardERC20 implementation in L2.\n    /// @param _l2TokenFactory The address of ScrollStandardERC20Factory contract in L2.\n    function initialize(\n        address _counterpart,\n        address _router,\n        address _messenger,\n        address _l2TokenImplementation,\n        address _l2TokenFactory\n    ) external initializer {\n        require(_router != address(0), \"zero router address\");\n        ScrollGatewayBase._initialize(_counterpart, _router, _messenger);\n\n        require(_l2TokenImplementation != address(0), \"zero implementation hash\");\n        require(_l2TokenFactory != address(0), \"zero factory address\");\n\n        l2TokenImplementation = _l2TokenImplementation;\n        l2TokenFactory = _l2TokenFactory;\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function getL2ERC20Address(address _l1Token) public view override returns (address) {\n        // In StandardERC20Gateway, all corresponding l2 tokens are depoyed by Create2 with salt,\n        // we can calculate the l2 address directly.\n        bytes32 _salt = keccak256(abi.encodePacked(counterpart, keccak256(abi.encodePacked(_l1Token))));\n\n        return Clones.predictDeterministicAddress(l2TokenImplementation, _salt, l2TokenFactory);\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function finalizeWithdrawERC20(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable override onlyCallByCounterpart nonReentrant {\n        require(msg.value == 0, \"nonzero msg.value\");\n        require(_l2Token != address(0), \"token address cannot be 0\");\n        require(getL2ERC20Address(_l1Token) == _l2Token, \"l2 token mismatch\");\n\n        // @note can possible trigger reentrant call to messenger,\n        // but it seems not a big problem.\n        IERC20(_l1Token).safeTransfer(_to, _amount);\n\n        _doCallback(_to, _data);\n\n        emit FinalizeWithdrawERC20(_l1Token, _l2Token, _from, _to, _amount, _data);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @inheritdoc L1ERC20Gateway\n    function _deposit(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) internal virtual override nonReentrant {\n        require(_amount > 0, \"deposit zero amount\");\n\n        // 1. Extract real sender if this call is from L1GatewayRouter.\n        address _from = msg.sender;\n        if (router == msg.sender) {\n            (_from, _data) = abi.decode(_data, (address, bytes));\n        }\n\n        // 2. Transfer token into this contract.\n        {\n            // common practice to handle fee on transfer token.\n            uint256 _before = IERC20(_token).balanceOf(address(this));\n            IERC20(_token).safeTransferFrom(_from, address(this), _amount);\n            uint256 _after = IERC20(_token).balanceOf(address(this));\n            // no unchecked here, since some weird token may return arbitrary balance.\n            _amount = _after - _before;\n            // ignore weird fee on transfer token\n            require(_amount > 0, \"deposit zero amount\");\n        }\n\n        // 3. Generate message passed to L2StandardERC20Gateway.\n        address _l2Token = tokenMapping[_token];\n        bytes memory _l2Data = _data;\n        if (_l2Token == address(0)) {\n            // It is a new token, compute and store mapping in storage.\n            _l2Token = getL2ERC20Address(_token);\n            tokenMapping[_token] = _l2Token;\n\n            // passing symbol/name/decimal in order to deploy in L2.\n            string memory _symbol = IERC20Metadata(_token).symbol();\n            string memory _name = IERC20Metadata(_token).name();\n            uint8 _decimals = IERC20Metadata(_token).decimals();\n            _l2Data = abi.encode(_data, abi.encode(_symbol, _name, _decimals));\n        }\n        bytes memory _message = abi.encodeWithSelector(\n            IL2ERC20Gateway.finalizeDepositERC20.selector,\n            _token,\n            _l2Token,\n            _from,\n            _to,\n            _amount,\n            _l2Data\n        );\n\n        // 4. Send message to L1ScrollMessenger.\n        IL1ScrollMessenger(messenger).sendMessage{value: msg.value}(counterpart, 0, _message, _gasLimit);\n\n        emit DepositERC20(_token, _l2Token, _from, _to, _amount, _data);\n    }\n}"
    }
  ]
}