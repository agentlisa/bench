{
  "Title": "Pool initialization can be front-run",
  "Content": "##### Description\nAfter the pool deployment https://github.com/cryptoalgebra/Algebra/blob/6c22b64977e0b0266aec89470480df74977eb606/src/core/contracts/AlgebraFactory.sol#L95, the initialize function isn't called which allows anyone to set the initial price in the pool. The price setting can affect liquidity addition in the `mint` function. Initialization can also be front-run if the pool is created from the periphery, so this problem allows a malicious user to ddos any pool.\nAlso, the `swap` function can be executed without any tokens from the `msg.sender` if it operates entirely within an interval with zero active liquidity. Concurrently, the `mint` function in the `AlgebraPool` contract does not include the `amount0Max` and `amount1Max` parameters making it vulnerable to undesirable price fluctuations. This creates a loophole that malicious actors can exploit capitalizing on price slippage to their advantage.\n\nFor clarity, consider the following sequence of events (these events can also take place after the pool creation):\n\n1. A liquidity provider (LP) initiates the `mint` transaction to the `AlgebraPool` with the current price set to `P` and the pool's actual liquidity standing at zero. The LP's intention is to set a position with the `amount0` of token0 and `amount1` of token1.\n2. An exploiter front-runs this action by performing a `swap` which shifts the price to `P' < P` undervaluing `token0`. This operation costs the exploiter nothing in terms of `token0` due to the absence of liquidity.\n3. Subsequently, the LP mints the new position acquiring `amount0' < amount0` of token0 and `amount1' > amount1` of token1.\n4. Then the exploiter conducts another `swap` acquiring `token0` and reverting its price back to the prevalent market rate capitalizing on the arbitrage window.\n5. These actions result in the LP contributing more of `token1` than it was initially planned incurring a loss.\n\nThis issue is classified as `high` severity. It offers bad actors an opportunity to exploit the lack of price slippage checks in the `mint` function. Even though conditions without `amount0Max` and `amount1Max` might be managed through the `periphery`, it still exposes the system to the near-zero cost of significant price shifts within intervals with zero active liquidity. This could potentially pave the way for DoS attacks targeting liquidity positions.\n\n##### Recommendation\nWe recommend calling the initialize function after the pool deployment in the `createPool` function. Also, we recommend implementing constraints on the `swap` function, especially when the swap ends in a non-initialized tick with zero liquidity. This will retain malicious entities from manipulating prices within intervals of zero liquidity and will limit the feasibility of DoS attacks in such scenarios. For solving the problem when the pool is initialized with a correct price but a malicious actor uses token-free swaps to move the price, we recommend adding a method that allows users to move price and add liquidity in one tx. Price moving, in this case, will be token-free because total pool liquidity will be 0.\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "src/core/contracts/AlgebraFactory.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\nimport './libraries/Constants.sol';\n\nimport './interfaces/IAlgebraFactory.sol';\nimport './interfaces/IAlgebraPoolDeployer.sol';\nimport './interfaces/plugin/IAlgebraPluginFactory.sol';\n\nimport './AlgebraCommunityVault.sol';\n\nimport '@openzeppelin/contracts/access/Ownable2Step.sol';\nimport '@openzeppelin/contracts/access/AccessControlEnumerable.sol';\n\n/// @title Algebra factory\n/// @notice Is used to deploy pools and its plugins\n/// @dev Version: Algebra Integral\ncontract AlgebraFactory is IAlgebraFactory, Ownable2Step, AccessControlEnumerable {\n  /// @inheritdoc IAlgebraFactory\n  bytes32 public constant override POOLS_ADMINISTRATOR_ROLE = keccak256('POOLS_ADMINISTRATOR'); // it`s here for the public visibility of the value\n\n  /// @inheritdoc IAlgebraFactory\n  address public immutable override poolDeployer;\n\n  /// @inheritdoc IAlgebraFactory\n  address public immutable override communityVault;\n\n  /// @inheritdoc IAlgebraFactory\n  uint16 public override defaultCommunityFee;\n\n  /// @inheritdoc IAlgebraFactory\n  uint16 public override defaultFee;\n\n  /// @inheritdoc IAlgebraFactory\n  int24 public override defaultTickspacing;\n\n  /// @inheritdoc IAlgebraFactory\n  uint256 public override renounceOwnershipStartTimestamp;\n\n  /// @dev time delay before ownership renouncement can be finished\n  uint256 private constant RENOUNCE_OWNERSHIP_DELAY = 1 days;\n\n  /// @inheritdoc IAlgebraFactory\n  IAlgebraPluginFactory public defaultPluginFactory;\n\n  /// @inheritdoc IAlgebraFactory\n  mapping(address => mapping(address => address)) public override poolByPair;\n\n  /// @dev keccak256 of AlgebraPool init bytecode. Used to compute pool address deterministically\n  bytes32 private constant POOL_INIT_CODE_HASH = 0x6850df26deb431442e7ee6a953ade87dd82a8401a612ea683b545f83cd15e236;\n\n  constructor(address _poolDeployer) {\n    require(_poolDeployer != address(0));\n    poolDeployer = _poolDeployer;\n    communityVault = address(new AlgebraCommunityVault(msg.sender));\n    defaultTickspacing = Constants.INIT_DEFAULT_TICK_SPACING;\n    defaultFee = Constants.INIT_DEFAULT_FEE;\n\n    emit DefaultTickspacing(Constants.INIT_DEFAULT_TICK_SPACING);\n    emit DefaultFee(Constants.INIT_DEFAULT_FEE);\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function owner() public view override(IAlgebraFactory, Ownable) returns (address) {\n    return super.owner();\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function hasRoleOrOwner(bytes32 role, address account) public view override returns (bool) {\n    return (owner() == account || super.hasRole(role, account));\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function defaultConfigurationForPool() external view returns (uint16 communityFee, int24 tickSpacing, uint16 fee) {\n    return (defaultCommunityFee, defaultTickspacing, defaultFee);\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function computePoolAddress(address token0, address token1) public view override returns (address pool) {\n    pool = address(uint160(uint256(keccak256(abi.encodePacked(hex'ff', poolDeployer, keccak256(abi.encode(token0, token1)), POOL_INIT_CODE_HASH)))));\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function createPool(address tokenA, address tokenB) external override returns (address pool) {\n    require(tokenA != tokenB);\n    (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    require(token0 != address(0));\n    require(poolByPair[token0][token1] == address(0));\n\n    address defaultPlugin;\n    if (address(defaultPluginFactory) != address(0)) {\n      defaultPlugin = defaultPluginFactory.createPlugin(computePoolAddress(token0, token1));\n    }\n\n    pool = IAlgebraPoolDeployer(poolDeployer).deploy(address(defaultPlugin), token0, token1);\n\n    poolByPair[token0][token1] = pool; // to avoid future addresses comparison we are populating the mapping twice\n    poolByPair[token1][token0] = pool;\n    emit Pool(token0, token1, pool);\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function setDefaultCommunityFee(uint16 newDefaultCommunityFee) external override onlyOwner {\n    require(newDefaultCommunityFee <= Constants.MAX_COMMUNITY_FEE);\n    require(defaultCommunityFee != newDefaultCommunityFee);\n    defaultCommunityFee = newDefaultCommunityFee;\n    emit DefaultCommunityFee(newDefaultCommunityFee);\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function setDefaultFee(uint16 newDefaultFee) external override onlyOwner {\n    require(newDefaultFee <= Constants.MAX_DEFAULT_FEE);\n    require(defaultFee != newDefaultFee);\n    defaultFee = newDefaultFee;\n    emit DefaultFee(newDefaultFee);\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function setDefaultTickspacing(int24 newDefaultTickspacing) external override onlyOwner {\n    require(newDefaultTickspacing >= Constants.MIN_TICK_SPACING);\n    require(newDefaultTickspacing <= Constants.MAX_TICK_SPACING);\n    require(newDefaultTickspacing != defaultTickspacing);\n    defaultTickspacing = newDefaultTickspacing;\n    emit DefaultTickspacing(newDefaultTickspacing);\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function setDefaultPluginFactory(address newDefaultPluginFactory) external override onlyOwner {\n    require(newDefaultPluginFactory != address(defaultPluginFactory));\n    defaultPluginFactory = IAlgebraPluginFactory(newDefaultPluginFactory);\n    emit DefaultPluginFactory(newDefaultPluginFactory);\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function startRenounceOwnership() external override onlyOwner {\n    require(renounceOwnershipStartTimestamp == 0);\n    renounceOwnershipStartTimestamp = block.timestamp;\n    emit RenounceOwnershipStart(renounceOwnershipStartTimestamp, renounceOwnershipStartTimestamp + RENOUNCE_OWNERSHIP_DELAY);\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function stopRenounceOwnership() external override onlyOwner {\n    require(renounceOwnershipStartTimestamp != 0);\n    renounceOwnershipStartTimestamp = 0;\n    emit RenounceOwnershipStop(block.timestamp);\n  }\n\n  /// @dev Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore.\n  /// Can only be called by the current owner if RENOUNCE_OWNERSHIP_DELAY seconds\n  /// have passed since the call to the startRenounceOwnership() function.\n  function renounceOwnership() public override onlyOwner {\n    require(renounceOwnershipStartTimestamp != 0);\n    require(block.timestamp - renounceOwnershipStartTimestamp >= RENOUNCE_OWNERSHIP_DELAY);\n    renounceOwnershipStartTimestamp = 0;\n\n    super.renounceOwnership();\n    emit RenounceOwnershipFinish(block.timestamp);\n  }\n\n  /// @dev Transfers ownership of the contract to a new account (`newOwner`).\n  /// Modified to fit with the role mechanism.\n  function _transferOwnership(address newOwner) internal override {\n    _revokeRole(DEFAULT_ADMIN_ROLE, owner());\n    super._transferOwnership(newOwner);\n    _grantRole(DEFAULT_ADMIN_ROLE, owner());\n  }\n}"
    }
  ]
}