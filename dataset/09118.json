{
  "Title": "[M-02] `CrvDepositorWrapper.sol` relies on oracle that isn't frequently updated",
  "Content": "_Submitted by 0x52_\n\n[CrvDepositorWrapper.sol#L56-L65](https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/CrvDepositorWrapper.sol#L56-L65)<br>\n\nUnpredictable slippage, sandwich vulnerability or frequent failed transactions\n\n### Proof of Concept\n\nCrvDepostiorWrapper uses the TWAP provided by the 20/80 WETH/BAL. The issue is that this pool has only handled \\~15 transactions per day in the last 30 days, which means that the oracle frequently goes more than an hour without updating. Each time a state changing operation is called, the following code in the balancer pool takes a snapshot of the pool state BEFORE any operation changes it:\n\n[OracleWeightedPool.sol#L156-L161](https://github.com/balancer-labs/balancer-v2-monorepo/blob/80e1a5db7439069e2cb53e228bce0a8a51f5b23e/pkg/pool-weighted/contracts/oracle/OracleWeightedPool.sol#L156-L161)<br>\n\nThis could result in the price of the oracle frequently not reflecting the true value of the assets due to infrequency of update. Now also consider that the pool has a trading fee of 2%. Combine an inaccurate oracle with a high fee pool and trades can exhibit high levels of \"slippage\". To account for this outputBps in AuraStakingProxy needs to be set relatively low or risks frequent failed transactions when calling distribute due to slippage conditions not being met. The lower outputBps is set the more vulnerable distribute becomes to sandwich attacks.\n\n### Recommended Mitigation Steps\n\nConsider using chainlink oracles for both BAL and ETH to a realtime estimate of the LP value. A chainlink LP oracle implementation can be found [here](https://blog.alphaventuredao.io/fair-lp-token-pricing/).\n\n**[0xMaharishi (Aura Finance) confirmed and commented](https://github.com/code-423n4/2022-05-aura-findings/issues/115#issuecomment-1138380103):**\n > Valid finding and agree with the severity generally. Vector here is either function reverting or potentially getting sandwiched.\n> \n> To mitigate this currently, there is a `keeper` address added and the tx would be sent via flashbots, however agree that other steps could be taken to allow it to operate more fluidly.\n\n**[0xMaharishi (Aura Finance) resolved and commented](https://github.com/code-423n4/2022-05-aura-findings/issues/115#issuecomment-1141477104):**\n > Resolution for now is to use the CrvDepositorWrapper price as a guideline and let the `keeper` of AuraStakingProxy provide a minOut.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-05-aura",
  "Code": [
    {
      "filename": "contracts/CrvDepositorWrapper.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\nimport { IVault, IPriceOracle, IAsset } from \"./Interfaces.sol\";\nimport { IVault } from \"./Interfaces.sol\";\n\ninterface ICrvDepositor {\n    function depositFor(\n        address to,\n        uint256 _amount,\n        bool _lock,\n        address _stakeAddress\n    ) external;\n}\n\n/**\n * @title   BalInvestor\n * @notice  Deposits $BAL into a BAL/WETH BPT. Hooks into TWAP to determine minOut.\n * @dev     Abstract contract for depositing BAL -> balBPT -> auraBAL via crvDepositor\n */\nabstract contract BalInvestor {\n    using SafeERC20 for IERC20;\n\n    IVault public immutable BALANCER_VAULT;\n    address public immutable BAL;\n    address public immutable WETH;\n    address public immutable BALANCER_POOL_TOKEN;\n    bytes32 public immutable BAL_ETH_POOL_ID;\n\n    constructor(\n        IVault _balancerVault,\n        address _bal,\n        address _weth,\n        bytes32 _balETHPoolId\n    ) {\n        (\n            address poolAddress, /* */\n\n        ) = _balancerVault.getPool(_balETHPoolId);\n        require(poolAddress != address(0), \"!poolAddress\");\n\n        BALANCER_VAULT = _balancerVault;\n        BAL = _bal;\n        WETH = _weth;\n        BALANCER_POOL_TOKEN = poolAddress;\n        BAL_ETH_POOL_ID = _balETHPoolId;\n    }\n\n    function _setApprovals() internal {\n        IERC20(WETH).safeApprove(address(BALANCER_VAULT), type(uint256).max);\n        IERC20(BAL).safeApprove(address(BALANCER_VAULT), type(uint256).max);\n    }\n\n    function _getBptPrice() internal view returns (uint256) {\n        IPriceOracle.OracleAverageQuery[] memory queries = new IPriceOracle.OracleAverageQuery[](1);\n\n        queries[0].variable = IPriceOracle.Variable.BPT_PRICE;\n        queries[0].secs = 3600; // last hour\n        queries[0].ago = 0; // now\n\n        // Gets the balancer time weighted average price denominated in BAL\n        return IPriceOracle(BALANCER_POOL_TOKEN).getTimeWeightedAverage(queries)[0];\n    }\n\n    function _getMinOut(uint256 amount, uint256 minOutBps) internal view returns (uint256) {\n        // Gets the balancer time weighted average price denominated in BAL\n        // e.g.  if 1 BAL == 0.4 BPT, bptOraclePrice == 2.5\n        uint256 bptOraclePrice = _getBptPrice();\n        // e.g. minOut = (((100e18 * 1e18) / 2.5e18) * 9980) / 10000;\n        // e.g. minout = 39.92e18\n        uint256 minOut = (((amount * 1e18) / bptOraclePrice) * minOutBps) / 10000;\n        return minOut;\n    }\n\n    function _investBalToPool(uint256 amount, uint256 minOut) internal {\n        IERC20(BAL).safeTransferFrom(msg.sender, address(this), amount);\n        IAsset[] memory assets = new IAsset[](2);\n        assets[0] = IAsset(BAL);\n        assets[1] = IAsset(WETH);\n        uint256[] memory maxAmountsIn = new uint256[](2);\n        maxAmountsIn[0] = amount;\n        maxAmountsIn[1] = 0;\n\n        BALANCER_VAULT.joinPool(\n            BAL_ETH_POOL_ID,\n            address(this),\n            address(this),\n            IVault.JoinPoolRequest(\n                assets,\n                maxAmountsIn,\n                abi.encode(IVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT, maxAmountsIn, minOut),\n                false // Don't use internal balances\n            )\n        );\n    }\n}\n\n/**\n * @title   CrvDepositorWrapper\n * @notice  Converts BAL -> balBPT and then wraps to auraBAL via the crvDepositor\n */\ncontract CrvDepositorWrapper is BalInvestor {\n    address public immutable crvDeposit;\n\n    constructor(\n        address _crvDeposit,\n        IVault _balancerVault,\n        address _bal,\n        address _weth,\n        bytes32 _balETHPoolId\n    ) BalInvestor(_balancerVault, _bal, _weth, _balETHPoolId) {\n        crvDeposit = _crvDeposit;\n    }\n\n    function setApprovals() external {\n        _setApprovals();\n        require(IERC20(BALANCER_POOL_TOKEN).approve(crvDeposit, type(uint256).max), \"!approval\");\n    }\n\n    /**\n     * @dev Gets minimum output based on BPT oracle price\n     * @param _amount Units of BAL to deposit\n     * @param _outputBps Multiplier where 100% == 10000, 99.5% == 9950 and 98% == 9800\n     * @return minOut Units of BPT to expect as output\n     */\n    function getMinOut(uint256 _amount, uint256 _outputBps) external view returns (uint256) {\n        return _getMinOut(_amount, _outputBps);\n    }\n\n    function deposit(\n        uint256 _amount,\n        uint256 _minOut,\n        bool _lock,\n        address _stakeAddress\n    ) external {\n        _investBalToPool(_amount, _minOut);\n        uint256 bptBalance = IERC20(BALANCER_POOL_TOKEN).balanceOf(address(this));\n        ICrvDepositor(crvDeposit).depositFor(msg.sender, bptBalance, _lock, _stakeAddress);\n    }\n}"
    },
    {
      "filename": "pkg/pool-weighted/contracts/oracle/OracleWeightedPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@balancer-labs/v2-solidity-utils/contracts/helpers/LogCompression.sol\";\n\nimport \"@balancer-labs/v2-pool-utils/contracts/oracle/PoolPriceOracle.sol\";\n\nimport \"../BaseWeightedPool.sol\";\nimport \"../InvariantGrowthProtocolFees.sol\";\nimport \"./OracleWeightedMath.sol\";\nimport \"./OracleWeightedPoolMiscData.sol\";\n\ncontract OracleWeightedPool is BaseWeightedPool, InvariantGrowthProtocolFees, PoolPriceOracle {\n    using FixedPoint for uint256;\n    using OracleWeightedPoolMiscData for bytes32;\n\n    IERC20 internal immutable _token0;\n    IERC20 internal immutable _token1;\n\n    uint256 private immutable _normalizedWeight0;\n    uint256 private immutable _normalizedWeight1;\n\n    // All token balances are normalized to behave as if the token had 18 decimals. We assume a token's decimals will\n    // not change throughout its lifetime, and store the corresponding scaling factor for each at construction time.\n    // These factors are always greater than or equal to one: tokens with more than 18 decimals are not supported.\n    uint256 internal immutable _scalingFactor0;\n    uint256 internal immutable _scalingFactor1;\n\n    event OracleEnabledChanged(bool enabled);\n\n    struct NewPoolParams {\n        IVault vault;\n        string name;\n        string symbol;\n        IERC20[] tokens;\n        uint256 normalizedWeight0;\n        uint256 normalizedWeight1;\n        uint256 swapFeePercentage;\n        uint256 pauseWindowDuration;\n        uint256 bufferPeriodDuration;\n        bool oracleEnabled;\n        address owner;\n    }\n\n    constructor(NewPoolParams memory params)\n        BaseWeightedPool(\n            params.vault,\n            params.name,\n            params.symbol,\n            params.tokens,\n            new address[](2), // No asset managers\n            params.swapFeePercentage,\n            params.pauseWindowDuration,\n            params.bufferPeriodDuration,\n            params.owner,\n            false\n        )\n    {\n        _require(params.tokens.length == 2, Errors.TOKENS_LENGTH_MUST_BE_2);\n        // Ensure each normalized weight is above the minimum, and find the token index of the maximum weight\n        _require(params.normalizedWeight0 >= WeightedMath._MIN_WEIGHT, Errors.MIN_WEIGHT);\n        _require(params.normalizedWeight1 >= WeightedMath._MIN_WEIGHT, Errors.MIN_WEIGHT);\n\n        // Ensure that the normalized weights sum to ONE\n        uint256 normalizedSum = params.normalizedWeight0.add(params.normalizedWeight1);\n        _require(normalizedSum == FixedPoint.ONE, Errors.NORMALIZED_WEIGHT_INVARIANT);\n\n        _token0 = params.tokens[0];\n        _token1 = params.tokens[1];\n\n        _scalingFactor0 = _computeScalingFactor(params.tokens[0]);\n        _scalingFactor1 = _computeScalingFactor(params.tokens[1]);\n\n        _normalizedWeight0 = params.normalizedWeight0;\n        _normalizedWeight1 = params.normalizedWeight1;\n\n        _setOracleEnabled(params.oracleEnabled);\n    }\n\n    // Getters / Setters\n\n    function getMiscData()\n        external\n        view\n        returns (\n            int256 logInvariant,\n            int256 logTotalSupply,\n            uint256 oracleSampleCreationTimestamp,\n            uint256 oracleIndex,\n            bool oracleEnabled,\n            uint256 swapFeePercentage\n        )\n    {\n        bytes32 miscData = _getMiscData();\n        logInvariant = miscData.logInvariant();\n        logTotalSupply = miscData.logTotalSupply();\n        oracleSampleCreationTimestamp = miscData.oracleSampleCreationTimestamp();\n        oracleIndex = miscData.oracleIndex();\n        oracleEnabled = miscData.oracleEnabled();\n\n        swapFeePercentage = getSwapFeePercentage();\n    }\n\n    /**\n     * @dev Balancer Governance can always enable the Oracle, even if it was originally not enabled. This allows for\n     * Pools that unexpectedly drive much more volume and liquidity than expected to serve as Price Oracles.\n     *\n     * Note that the Oracle can only be enabled - it can never be disabled.\n     */\n    function enableOracle() external whenNotPaused authenticate {\n        _setOracleEnabled(true);\n\n        // Cache log invariant and supply only if the pool was initialized\n        if (totalSupply() > 0) {\n            _cacheInvariantAndSupply();\n        }\n    }\n\n    function _setOracleEnabled(bool enabled) internal {\n        _setMiscData(_getMiscData().setOracleEnabled(enabled));\n        emit OracleEnabledChanged(enabled);\n    }\n\n    function _getNormalizedWeights() internal view virtual override returns (uint256[] memory) {\n        uint256[] memory normalizedWeights = new uint256[](2);\n        normalizedWeights[0] = _normalizedWeight0;\n        normalizedWeights[1] = _normalizedWeight1;\n        return normalizedWeights;\n    }\n\n    // Swaps remain the same, except we need to update the oracle with the pre-swap balances (after these have been\n    // upscaled, but before we return). A good place to do this is at the beginning of BaseMinimalSwapInfoPool's\n    // _onSwapGivenIn and _onSwapGivenOut.\n\n    function _onSwapGivenIn(\n        SwapRequest memory swapRequest,\n        uint256 currentBalanceTokenIn,\n        uint256 currentBalanceTokenOut\n    ) internal virtual override returns (uint256) {\n        bool tokenInIsToken0 = swapRequest.tokenIn == _token0;\n\n        // Update price oracle with the pre-swap balances\n        _updateOracle(\n            swapRequest.lastChangeBlock,\n            tokenInIsToken0 ? currentBalanceTokenIn : currentBalanceTokenOut,\n            tokenInIsToken0 ? currentBalanceTokenOut : currentBalanceTokenIn\n        );\n\n        return super._onSwapGivenIn(swapRequest, currentBalanceTokenIn, currentBalanceTokenOut);\n    }\n\n    function _onSwapGivenOut(\n        SwapRequest memory swapRequest,\n        uint256 currentBalanceTokenIn,\n        uint256 currentBalanceTokenOut\n    ) internal virtual override returns (uint256) {\n        bool tokenInIsToken0 = swapRequest.tokenIn == _token0;\n\n        // Update price oracle with the pre-swap balances\n        _updateOracle(\n            swapRequest.lastChangeBlock,\n            tokenInIsToken0 ? currentBalanceTokenIn : currentBalanceTokenOut,\n            tokenInIsToken0 ? currentBalanceTokenOut : currentBalanceTokenIn\n        );\n\n        return super._onSwapGivenOut(swapRequest, currentBalanceTokenIn, currentBalanceTokenOut);\n    }\n\n    // Joins and exit also remain the same, except we need to update the oracle with the pre-join/exit balances (after\n    // these have been upscaled, but before we subtract join/exits amounts from them), and we need to cache the\n    // post-join/exit invariant and total supply.\n    // The oracle update can be performed at the beginning of BasePool's _onJoinPool and _onExitPool, while the cache\n    // update requires BPT to have been minted or burned already, so the most suitable place is at the end of\n    // IBasePool's onJoinPool and onExitPool, immediately before returning to the Vault.\n\n    function _onJoinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        uint256[] memory scalingFactors,\n        bytes memory userData\n    ) internal virtual override returns (uint256, uint256[] memory) {\n        // Update price oracle with the pre-join balances\n        _updateOracle(lastChangeBlock, balances[0], balances[1]);\n\n        return\n            super._onJoinPool(\n                poolId,\n                sender,\n                recipient,\n                balances,\n                lastChangeBlock,\n                protocolSwapFeePercentage,\n                scalingFactors,\n                userData\n            );\n    }\n\n    function onJoinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) public virtual override returns (uint256[] memory, uint256[] memory) {\n        (uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts) = super.onJoinPool(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData\n        );\n\n        // Update cached total supply and invariant using the results after the join that will be used for future\n        // oracle updates.\n        _cacheInvariantAndSupply();\n\n        return (amountsIn, dueProtocolFeeAmounts);\n    }\n\n    function _onExitPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        uint256[] memory scalingFactors,\n        bytes memory userData\n    ) internal virtual override returns (uint256, uint256[] memory) {\n        // The oracle is not updated if the Pool is paused to avoid extra calculations and reduce the potential for\n        // errors.\n        if (_isNotPaused()) {\n            // Update price oracle with the pre-exit balances\n            _updateOracle(lastChangeBlock, balances[0], balances[1]);\n        }\n\n        return\n            super._onExitPool(\n                poolId,\n                sender,\n                recipient,\n                balances,\n                lastChangeBlock,\n                protocolSwapFeePercentage,\n                scalingFactors,\n                userData\n            );\n    }\n\n    function onExitPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) public virtual override returns (uint256[] memory, uint256[] memory) {\n        (uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts) = super.onExitPool(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData\n        );\n\n        // Update cached total supply and invariant using the results after the exit that will be used for future\n        // oracle updates, only if the pool was not paused (to minimize code paths taken while paused).\n        if (_isNotPaused()) {\n            _cacheInvariantAndSupply();\n        }\n\n        return (amountsOut, dueProtocolFeeAmounts);\n    }\n\n    // Oracle functions\n\n    /**\n     * @dev Updates the Price Oracle based on the Pool's current state (balances, BPT supply and invariant). Must be\n     * called on *all* state-changing functions with the balances *before* the state change happens, and with\n     * `lastChangeBlock` as the number of the block in which any of the balances last changed.\n     */\n    function _updateOracle(\n        uint256 lastChangeBlock,\n        uint256 balanceToken0,\n        uint256 balanceToken1\n    ) internal {\n        if (block.number == lastChangeBlock) {\n            return;\n        }\n\n        bytes32 miscData = _getMiscData();\n\n        if (miscData.oracleEnabled()) {\n            int256 logSpotPrice = OracleWeightedMath._calcLogSpotPrice(\n                _normalizedWeight0,\n                balanceToken0,\n                _normalizedWeight1,\n                balanceToken1\n            );\n\n            int256 logBPTPrice = OracleWeightedMath._calcLogBPTPrice(\n                _normalizedWeight0,\n                balanceToken0,\n                miscData.logTotalSupply()\n            );\n\n            uint256 oracleCurrentIndex = miscData.oracleIndex();\n\n            uint256 oracleUpdatedIndex = _processPriceData(\n                miscData.oracleSampleCreationTimestamp(),\n                oracleCurrentIndex,\n                logSpotPrice,\n                logBPTPrice,\n                miscData.logInvariant()\n            );\n\n            if (oracleCurrentIndex != oracleUpdatedIndex) {\n                _setMiscData(\n                    // Oracle data is time-based: users should be careful to pick appropiate time windows\n                    // solhint-disable-next-line not-rely-on-time\n                    miscData.setOracleIndex(oracleUpdatedIndex).setOracleSampleCreationTimestamp(block.timestamp)\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Stores the logarithm of the invariant and BPT total supply, to be later used in each oracle update. Because\n     * it is stored in miscData, which is read in all operations (including swaps), this saves gas by not requiring to\n     * compute or read these values when updating the oracle.\n     *\n     * This function must be called by all actions that update the invariant and BPT supply (joins and exits). Swaps\n     * also alter the invariant due to collected swap fees, but this growth is considered negligible and not accounted\n     * for.\n     */\n    function _cacheInvariantAndSupply() internal {\n        bytes32 miscData = _getMiscData();\n\n        if (miscData.oracleEnabled()) {\n            _setMiscData(\n                miscData.setLogInvariant(LogCompression.toLowResLog(getLastInvariant())).setLogTotalSupply(\n                    LogCompression.toLowResLog(totalSupply())\n                )\n            );\n        }\n    }\n\n    function _getOracleIndex() internal view override returns (uint256) {\n        return _getMiscData().oracleIndex();\n    }\n\n    // Scaling\n\n    function _scalingFactor(bool token0) internal view returns (uint256) {\n        return token0 ? _scalingFactor0 : _scalingFactor1;\n    }\n\n    function _scalingFactor(IERC20 token) internal view virtual override returns (uint256) {\n        return _scalingFactor(token == _token0);\n    }\n\n    function _scalingFactors() internal view virtual override returns (uint256[] memory) {\n        uint256[] memory scalingFactors = new uint256[](2);\n        scalingFactors[0] = _scalingFactor0;\n        scalingFactors[1] = _scalingFactor1;\n        return scalingFactors;\n    }\n\n    function _getMaxTokens() internal pure virtual override returns (uint256) {\n        return 2;\n    }\n\n    function _getTotalTokens() internal pure virtual override returns (uint256) {\n        return 2;\n    }\n\n    function _getNormalizedWeight(IERC20 token) internal view virtual override returns (uint256) {\n        return token == _token0 ? _normalizedWeight0 : _normalizedWeight1;\n    }\n\n    // InvariantGrowthProtocolFees\n\n    function _beforeJoinExit(\n        uint256[] memory preBalances,\n        uint256[] memory normalizedWeights,\n        uint256 protocolSwapFeePercentage\n    ) internal virtual override(BaseWeightedPool, InvariantGrowthProtocolFees) {\n        InvariantGrowthProtocolFees._beforeJoinExit(preBalances, normalizedWeights, protocolSwapFeePercentage);\n    }\n\n    function _afterJoinExit(\n        bool isJoin,\n        uint256[] memory preBalances,\n        uint256[] memory balanceDeltas,\n        uint256[] memory normalizedWeights\n    ) internal virtual override(BaseWeightedPool, InvariantGrowthProtocolFees) {\n        InvariantGrowthProtocolFees._afterJoinExit(isJoin, preBalances, balanceDeltas, normalizedWeights);\n    }\n}"
    }
  ]
}