{
  "Title": "[H-23] Refund mechanism for failed cross-chain transactions does not work",
  "Content": "\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/usd0/modules/USDOLeverageModule.sol#L180-L185> \n\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/usd0/modules/USDOMarketModule.sol#L178-L186> \n\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/usd0/modules/USDOOptionsModule.sol#L187-L197> \n\n<https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/modules/BaseTOFTLeverageModule.sol#L195-L200> \n\n<https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/modules/BaseTOFTMarketModule.sol#L170-L175> \n\n<https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L202-L212> \n\n<https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/modules/BaseTOFTStrategyModule.sol#L163-L168>\n\nThere is a refund mechanism in `USDO` and `TOFT` modules that will return funds when the execution on the destination chain fails.\n\nIt happens when `module.delegatecall()` fails, where the following code (see below) will trigger a refund of the bridged fund to the user. After that a revert is then 'forwarded' to the main executor contract (`BaseUSDO` or `BaseTOFT`).\n\nHowever, the issue is that the revert will also reverse the refund even when the revert is forwarded.\n\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/usd0/modules/USDOLeverageModule.sol#L180-L185>\n\n```Solidity\n        if (!success) {\n            if (balanceAfter - balanceBefore >= amount) {\n                IERC20(address(this)).safeTransfer(leverageFor, amount);\n            }\n\n            //@audit - this revert will actually reverse the refund before this\n            revert(_getRevertMsg(reason)); //forward revert because it's handled by the main executor\n        }\n```\n\nAlthough the main executor contract will `_storeFailedMessage()` to allow users to `retryMessage()` and re-execute the failed transaction, it will not go through if the error is permanent. That means the `retryMessage()` will also revert and there is no way to recover the funds.\n\n### Impact\n\nUser will lose their bridged fund if the cross chain execution encounters a permanent error, which will permanently lock up the bridged funds in the contract as there is no way to recover it.\n\n### Proof of Concept\n\n1.  Add a `revert()` in `leverageUpInternal()` within `USDOLeverageModule.sol#L197` as follows, to simulate a permanent failure for the remote execution at destination chain.\n\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/usd0/modules/USDOLeverageModule.sol#L197>.\n\n```Solidity\nfunction leverageUpInternal(\n        uint256 amount,\n        IUSDOBase.ILeverageSwapData memory swapData,\n        IUSDOBase.ILeverageExternalContractsData memory externalData,\n        IUSDOBase.ILeverageLZData memory lzData,\n        address leverageFor\n    ) public payable {\n\n        //@audit - to simulate a permanent failure for this remote execution (e.g. issue with swap)\n        revert();\n\n        ...\n    }\n```\n\n2.  Add the following `console.log` to [singularity.test.ts#L4113](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/test/singularity.test.ts#L4113)\n\n```Solidity\n            console.log(\"USDO_10 balance for deployer.address (expected to be equal to 10000000000000000000) : \", await USDO_10.balanceOf(deployer.address));\n```\n\n3.  Run the test case `'should bounce between 2 chains'` under `'multiHopBuyCollateral()'` tests in `singularity.test.ts`. It will show that the `deployer.address` fails to receive the refund amount.\n\n### Recommended Mitigation Steps\n\nImplement a 'pull' mechanism for users to withdraw the refund instead of 'pushing' to the user.\n\nThat can be done by using a a new state variable within `USDO` and `TOFT` to store the refund amount for the transaction with the corresponding `payloadHash` for `failedMessages` mapping.\n\nChecks must be implemented to ensure that if user withdraws the refund, the corresponding `failedMessages` entry is cleared so that the user cannot retry the transaction again.\n\nSimilarly, if `retryMessage()` is used to re-execute the transaction successfully, the refund amount in the new state variable should be cleared.\n\n**[0xRektora (Tapioca) confirmed via duplicate issue #1410](https://github.com/code-423n4/2023-07-tapioca-findings/issues/1410)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-tapioca",
  "Code": [
    {
      "filename": "contracts/usd0/modules/USDOLeverageModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\n//LZ\nimport \"tapioca-sdk/dist/contracts/libraries/LzLib.sol\";\n\n//TAPIOCA\nimport {IUSDOBase} from \"tapioca-periph/contracts/interfaces/IUSDO.sol\";\nimport \"tapioca-periph/contracts/interfaces/ISwapper.sol\";\nimport \"tapioca-periph/contracts/interfaces/ITapiocaOFT.sol\";\nimport \"tapioca-periph/contracts/interfaces/ISingularity.sol\";\nimport \"tapioca-periph/contracts/interfaces/IPermitBorrow.sol\";\nimport \"tapioca-periph/contracts/interfaces/IPermitAll.sol\";\n\nimport \"../BaseUSDOStorage.sol\";\n\n/// @title USDO leverage module\n/// @notice USDO module for leverage type actions\ncontract USDOLeverageModule is BaseUSDOStorage {\n    using SafeERC20 for IERC20;\n\n    constructor(\n        address _lzEndpoint,\n        IYieldBoxBase _yieldBox\n    ) BaseUSDOStorage(_lzEndpoint, _yieldBox) {}\n\n    function initMultiHopBuy(\n        address from,\n        uint256 collateralAmount,\n        uint256 borrowAmount,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData,\n        bytes calldata airdropAdapterParams,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        bytes32 senderBytes = LzLib.addressToBytes32(from);\n\n        bytes memory lzPayload = abi.encode(\n            PT_MARKET_MULTIHOP_BUY,\n            senderBytes,\n            from,\n            collateralAmount,\n            borrowAmount,\n            swapData,\n            lzData,\n            externalData,\n            approvals\n        );\n\n        _lzSend(\n            lzData.lzSrcChainId,\n            lzPayload,\n            payable(lzData.refundAddress),\n            lzData.zroPaymentAddress,\n            airdropAdapterParams,\n            msg.value\n        );\n        emit SendToChain(lzData.lzSrcChainId, msg.sender, senderBytes, 0);\n    }\n\n    function sendForLeverage(\n        uint256 amount,\n        address leverageFor,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData\n    ) external payable {\n        bytes32 senderBytes = LzLib.addressToBytes32(msg.sender);\n        _debitFrom(msg.sender, lzEndpoint.getChainId(), senderBytes, amount);\n\n        bytes memory lzPayload = abi.encode(\n            PT_LEVERAGE_MARKET_UP,\n            senderBytes,\n            amount,\n            swapData,\n            externalData,\n            lzData,\n            leverageFor\n        );\n\n        _lzSend(\n            lzData.lzDstChainId,\n            lzPayload,\n            payable(lzData.refundAddress),\n            lzData.zroPaymentAddress,\n            lzData.dstAirdropAdapterParam,\n            msg.value\n        );\n        emit SendToChain(lzData.lzDstChainId, msg.sender, senderBytes, amount);\n    }\n\n    function multiHop(bytes memory _payload) public {\n        (\n            ,\n            ,\n            address from,\n            uint256 collateralAmount,\n            uint256 borrowAmount,\n            IUSDOBase.ILeverageSwapData memory swapData,\n            IUSDOBase.ILeverageLZData memory lzData,\n            IUSDOBase.ILeverageExternalContractsData memory externalData,\n            ICommonData.IApproval[] memory approvals\n        ) = abi.decode(\n                _payload,\n                (\n                    uint16,\n                    bytes32,\n                    address,\n                    uint256,\n                    uint256,\n                    IUSDOBase.ILeverageSwapData,\n                    IUSDOBase.ILeverageLZData,\n                    IUSDOBase.ILeverageExternalContractsData,\n                    ICommonData.IApproval[]\n                )\n            );\n\n        if (approvals.length > 0) {\n            _callApproval(approvals);\n        }\n\n        ISingularity(externalData.srcMarket).multiHopBuyCollateral(\n            from,\n            collateralAmount,\n            borrowAmount,\n            swapData,\n            lzData,\n            externalData\n        );\n    }\n\n    function leverageUp(\n        address module,\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) public {\n        (\n            ,\n            ,\n            uint256 amount,\n            IUSDOBase.ILeverageSwapData memory swapData,\n            IUSDOBase.ILeverageExternalContractsData memory externalData,\n            IUSDOBase.ILeverageLZData memory lzData,\n            address leverageFor\n        ) = abi.decode(\n                _payload,\n                (\n                    uint16,\n                    bytes32,\n                    uint256,\n                    IUSDOBase.ILeverageSwapData,\n                    IUSDOBase.ILeverageExternalContractsData,\n                    IUSDOBase.ILeverageLZData,\n                    address\n                )\n            );\n\n        uint256 balanceBefore = balanceOf(address(this));\n        bool credited = creditedPackets[_srcChainId][_srcAddress][_nonce];\n        if (!credited) {\n            _creditTo(_srcChainId, address(this), amount);\n            creditedPackets[_srcChainId][_srcAddress][_nonce] = true;\n        }\n        uint256 balanceAfter = balanceOf(address(this));\n\n        (bool success, bytes memory reason) = module.delegatecall(\n            abi.encodeWithSelector(\n                this.leverageUpInternal.selector,\n                amount,\n                swapData,\n                externalData,\n                lzData,\n                leverageFor\n            )\n        );\n\n        if (!success) {\n            if (balanceAfter - balanceBefore >= amount) {\n                IERC20(address(this)).safeTransfer(leverageFor, amount);\n            }\n            revert(_getRevertMsg(reason)); //forward revert because it's handled by the main executor\n        }\n\n        emit ReceiveFromChain(_srcChainId, leverageFor, amount);\n    }\n\n    function leverageUpInternal(\n        uint256 amount,\n        IUSDOBase.ILeverageSwapData memory swapData,\n        IUSDOBase.ILeverageExternalContractsData memory externalData,\n        IUSDOBase.ILeverageLZData memory lzData,\n        address leverageFor\n    ) public payable {\n        //swap from USDO\n        _approve(address(this), externalData.swapper, amount);\n        ISwapper.SwapData memory _swapperData = ISwapper(externalData.swapper)\n            .buildSwapData(\n                address(this),\n                swapData.tokenOut,\n                amount,\n                0,\n                false,\n                false\n            );\n\n        (uint256 amountOut, ) = ISwapper(externalData.swapper).swap(\n            _swapperData,\n            swapData.amountOutMin,\n            address(this),\n            swapData.data\n        );\n\n        //wrap into tOFT\n        IERC20(swapData.tokenOut).approve(externalData.tOft, amountOut);\n        ITapiocaOFTBase(externalData.tOft).wrap(\n            address(this),\n            address(this),\n            amountOut\n        );\n\n        //send to YB & deposit\n        ICommonData.IApproval[] memory approvals;\n        ITapiocaOFT(externalData.tOft).sendToYBAndBorrow{\n            value: address(this).balance\n        }(\n            address(this),\n            leverageFor,\n            lzData.lzSrcChainId,\n            lzData.srcAirdropAdapterParam,\n            ITapiocaOFT.IBorrowParams({\n                amount: amountOut,\n                borrowAmount: 0,\n                marketHelper: externalData.magnetar,\n                market: externalData.srcMarket\n            }),\n            ICommonData.IWithdrawParams({\n                withdraw: false,\n                withdrawLzFeeAmount: 0,\n                withdrawOnOtherChain: false,\n                withdrawLzChainId: 0,\n                withdrawAdapterParams: \"0x\"\n            }),\n            ICommonData.ISendOptions({\n                extraGasLimit: lzData.srcExtraGasLimit,\n                zroPaymentAddress: lzData.zroPaymentAddress\n            }),\n            approvals\n        );\n    }\n\n    function _callApproval(ICommonData.IApproval[] memory approvals) private {\n        for (uint256 i = 0; i < approvals.length; ) {\n            if (approvals[i].permitBorrow) {\n                try\n                    IPermitBorrow(approvals[i].target).permitBorrow(\n                        approvals[i].owner,\n                        approvals[i].spender,\n                        approvals[i].value,\n                        approvals[i].deadline,\n                        approvals[i].v,\n                        approvals[i].r,\n                        approvals[i].s\n                    )\n                {} catch Error(string memory reason) {\n                    if (!approvals[i].allowFailure) {\n                        revert(reason);\n                    }\n                }\n            } else if (approvals[i].permitAll) {\n                try\n                    IPermitAll(approvals[i].target).permitAll(\n                        approvals[i].owner,\n                        approvals[i].spender,\n                        approvals[i].deadline,\n                        approvals[i].v,\n                        approvals[i].r,\n                        approvals[i].s\n                    )\n                {} catch Error(string memory reason) {\n                    if (!approvals[i].allowFailure) {\n                        revert(reason);\n                    }\n                }\n            } else {\n                try\n                    IERC20Permit(approvals[i].target).permit(\n                        approvals[i].owner,\n                        approvals[i].spender,\n                        approvals[i].value,\n                        approvals[i].deadline,\n                        approvals[i].v,\n                        approvals[i].r,\n                        approvals[i].s\n                    )\n                {} catch Error(string memory reason) {\n                    if (!approvals[i].allowFailure) {\n                        revert(reason);\n                    }\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/usd0/modules/USDOMarketModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\n//LZ\nimport \"tapioca-sdk/dist/contracts/libraries/LzLib.sol\";\n\n//TAPIOCA\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {IUSDOBase} from \"tapioca-periph/contracts/interfaces/IUSDO.sol\";\nimport \"tapioca-periph/contracts/interfaces/ITapiocaOFT.sol\";\nimport \"tapioca-periph/contracts/interfaces/IMagnetar.sol\";\nimport \"tapioca-periph/contracts/interfaces/IMarket.sol\";\nimport \"tapioca-periph/contracts/interfaces/ISingularity.sol\";\nimport \"tapioca-periph/contracts/interfaces/IPermitBorrow.sol\";\nimport \"tapioca-periph/contracts/interfaces/IPermitAll.sol\";\n\nimport \"../BaseUSDOStorage.sol\";\n\n/// @title USDO market module\n/// @notice USDO module for market type actions\ncontract USDOMarketModule is BaseUSDOStorage {\n    using RebaseLibrary for Rebase;\n    using SafeERC20 for IERC20;\n\n    constructor(\n        address _lzEndpoint,\n        IYieldBoxBase _yieldBox\n    ) BaseUSDOStorage(_lzEndpoint, _yieldBox) {}\n\n    function removeAsset(\n        address from,\n        address to,\n        uint16 lzDstChainId,\n        address zroPaymentAddress,\n        bytes calldata adapterParams,\n        ICommonData.ICommonExternalContracts calldata externalData,\n        IUSDOBase.IRemoveAndRepay calldata removeAndRepayData,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        bytes memory lzPayload = abi.encode(\n            PT_MARKET_REMOVE_ASSET,\n            to,\n            externalData,\n            removeAndRepayData,\n            approvals\n        );\n\n        _lzSend(\n            lzDstChainId,\n            lzPayload,\n            payable(from),\n            zroPaymentAddress,\n            adapterParams,\n            msg.value\n        );\n\n        emit SendToChain(lzDstChainId, from, LzLib.addressToBytes32(to), 0);\n    }\n\n    function sendAndLendOrRepay(\n        address _from,\n        address _to,\n        uint16 lzDstChainId,\n        address zroPaymentAddress,\n        IUSDOBase.ILendOrRepayParams calldata lendParams,\n        ICommonData.IApproval[] calldata approvals,\n        ICommonData.IWithdrawParams calldata withdrawParams,\n        bytes calldata adapterParams\n    ) external payable {\n        bytes32 toAddress = LzLib.addressToBytes32(_to);\n        _debitFrom(\n            _from,\n            lzEndpoint.getChainId(),\n            toAddress,\n            lendParams.depositAmount\n        );\n\n        bytes memory lzPayload = abi.encode(\n            PT_YB_SEND_SGL_LEND_OR_REPAY,\n            _from,\n            _to,\n            lendParams,\n            approvals,\n            withdrawParams\n        );\n\n        _lzSend(\n            lzDstChainId,\n            lzPayload,\n            payable(_from),\n            zroPaymentAddress,\n            adapterParams,\n            msg.value\n        );\n\n        emit SendToChain(\n            lzDstChainId,\n            _from,\n            toAddress,\n            lendParams.depositAmount\n        );\n    }\n\n    function remove(bytes memory _payload) public {\n        (\n            ,\n            address to,\n            ICommonData.ICommonExternalContracts memory externalData,\n            IUSDOBase.IRemoveAndRepay memory removeAndRepayData,\n            ICommonData.IApproval[] memory approvals\n        ) = abi.decode(\n                _payload,\n                (\n                    uint16,\n                    address,\n                    ICommonData.ICommonExternalContracts,\n                    IUSDOBase.IRemoveAndRepay,\n                    ICommonData.IApproval[]\n                )\n            );\n\n        //approvals\n        if (approvals.length > 0) {\n            _callApproval(approvals);\n        }\n\n        IMagnetar(externalData.magnetar).exitPositionAndRemoveCollateral(\n            to,\n            externalData,\n            removeAndRepayData\n        );\n    }\n\n    function lend(\n        address module,\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) public {\n        (\n            ,\n            ,\n            address to,\n            IUSDOBase.ILendOrRepayParams memory lendParams,\n            ICommonData.IApproval[] memory approvals,\n            ICommonData.IWithdrawParams memory withdrawParams\n        ) = abi.decode(\n                _payload,\n                (\n                    uint16,\n                    address,\n                    address,\n                    IUSDOBase.ILendOrRepayParams,\n                    ICommonData.IApproval[],\n                    ICommonData.IWithdrawParams\n                )\n            );\n\n        uint256 balanceBefore = balanceOf(address(this));\n        bool credited = creditedPackets[_srcChainId][_srcAddress][_nonce];\n        if (!credited) {\n            _creditTo(_srcChainId, address(this), lendParams.depositAmount);\n            creditedPackets[_srcChainId][_srcAddress][_nonce] = true;\n        }\n        uint256 balanceAfter = balanceOf(address(this));\n\n        (bool success, bytes memory reason) = module.delegatecall(\n            abi.encodeWithSelector(\n                this.lendInternal.selector,\n                to,\n                lendParams,\n                approvals,\n                withdrawParams\n            )\n        );\n\n        if (!success) {\n            if (balanceAfter - balanceBefore >= lendParams.depositAmount) {\n                IERC20(address(this)).safeTransfer(\n                    to,\n                    lendParams.depositAmount\n                );\n            }\n            revert(_getRevertMsg(reason)); //forward revert because it's handled by the main executor\n        }\n\n        emit ReceiveFromChain(_srcChainId, to, lendParams.depositAmount);\n    }\n\n    function lendInternal(\n        address to,\n        IUSDOBase.ILendOrRepayParams memory lendParams,\n        ICommonData.IApproval[] memory approvals,\n        ICommonData.IWithdrawParams memory withdrawParams\n    ) public payable {\n        if (approvals.length > 0) {\n            _callApproval(approvals);\n        }\n\n        // Use market helper to deposit and add asset to market\n        approve(address(lendParams.marketHelper), lendParams.depositAmount);\n        if (lendParams.repay) {\n            IMagnetar(lendParams.marketHelper)\n                .depositRepayAndRemoveCollateralFromMarket(\n                    lendParams.market,\n                    to,\n                    lendParams.depositAmount,\n                    lendParams.repayAmount,\n                    0,\n                    true,\n                    withdrawParams\n                );\n        } else {\n            IMagnetar(lendParams.marketHelper).mintFromBBAndLendOnSGL(\n                to,\n                lendParams.depositAmount,\n                IUSDOBase.IMintData({\n                    mint: false,\n                    mintAmount: 0,\n                    collateralDepositData: ICommonData.IDepositData({\n                        deposit: false,\n                        amount: 0,\n                        extractFromSender: false\n                    })\n                }),\n                ICommonData.IDepositData({\n                    deposit: true,\n                    amount: lendParams.depositAmount,\n                    extractFromSender: true\n                }),\n                lendParams.lockData,\n                lendParams.participateData,\n                ICommonData.ICommonExternalContracts({\n                    magnetar: address(0),\n                    singularity: lendParams.market,\n                    bigBang: address(0)\n                })\n            );\n        }\n    }\n\n    function _callApproval(ICommonData.IApproval[] memory approvals) private {\n        for (uint256 i = 0; i < approvals.length; ) {\n            if (approvals[i].permitBorrow) {\n                try\n                    IPermitBorrow(approvals[i].target).permitBorrow(\n                        approvals[i].owner,\n                        approvals[i].spender,\n                        approvals[i].value,\n                        approvals[i].deadline,\n                        approvals[i].v,\n                        approvals[i].r,\n                        approvals[i].s\n                    )\n                {} catch Error(string memory reason) {\n                    if (!approvals[i].allowFailure) {\n                        revert(reason);\n                    }\n                }\n            } else if (approvals[i].permitAll) {\n                try\n                    IPermitAll(approvals[i].target).permitAll(\n                        approvals[i].owner,\n                        approvals[i].spender,\n                        approvals[i].deadline,\n                        approvals[i].v,\n                        approvals[i].r,\n                        approvals[i].s\n                    )\n                {} catch Error(string memory reason) {\n                    if (!approvals[i].allowFailure) {\n                        revert(reason);\n                    }\n                }\n            } else {\n                try\n                    IERC20Permit(approvals[i].target).permit(\n                        approvals[i].owner,\n                        approvals[i].spender,\n                        approvals[i].value,\n                        approvals[i].deadline,\n                        approvals[i].v,\n                        approvals[i].r,\n                        approvals[i].s\n                    )\n                {} catch Error(string memory reason) {\n                    if (!approvals[i].allowFailure) {\n                        revert(reason);\n                    }\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/usd0/modules/USDOOptionsModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\n//LZ\nimport \"tapioca-sdk/dist/contracts/libraries/LzLib.sol\";\n\n//TAPIOCA\nimport \"tapioca-periph/contracts/interfaces/IPermitBorrow.sol\";\nimport \"tapioca-periph/contracts/interfaces/IPermitAll.sol\";\nimport \"tapioca-periph/contracts/interfaces/ITapiocaOptionsBroker.sol\";\nimport \"tapioca-periph/contracts/interfaces/ISendFrom.sol\";\nimport \"../BaseUSDOStorage.sol\";\n\n/// @title USDO options module\n/// @notice USDO module for oTap type actions\ncontract USDOOptionsModule is BaseUSDOStorage {\n    using SafeERC20 for IERC20;\n\n    constructor(\n        address _lzEndpoint,\n        IYieldBoxBase _yieldBox\n    ) BaseUSDOStorage(_lzEndpoint, _yieldBox) {}\n\n    function triggerSendFrom(\n        uint16 lzDstChainId,\n        bytes calldata airdropAdapterParams,\n        address zroPaymentAddress,\n        uint256 amount,\n        ISendFrom.LzCallParams calldata sendFromData,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        bytes memory lzPayload = abi.encode(\n            PT_SEND_FROM,\n            msg.sender,\n            amount,\n            sendFromData,\n            lzEndpoint.getChainId(),\n            approvals\n        );\n\n        _lzSend(\n            lzDstChainId,\n            lzPayload,\n            payable(msg.sender),\n            zroPaymentAddress,\n            airdropAdapterParams,\n            msg.value\n        );\n\n        emit SendToChain(\n            lzDstChainId,\n            msg.sender,\n            LzLib.addressToBytes32(msg.sender),\n            0\n        );\n    }\n\n    function exerciseOption(\n        ITapiocaOptionsBrokerCrossChain.IExerciseOptionsData\n            calldata optionsData,\n        ITapiocaOptionsBrokerCrossChain.IExerciseLZData calldata lzData,\n        ITapiocaOptionsBrokerCrossChain.IExerciseLZSendTapData\n            calldata tapSendData,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        bytes32 toAddress = LzLib.addressToBytes32(optionsData.from);\n\n        _debitFrom(\n            optionsData.from,\n            lzEndpoint.getChainId(),\n            toAddress,\n            optionsData.paymentTokenAmount\n        );\n\n        bytes memory lzPayload = abi.encode(\n            PT_TAP_EXERCISE,\n            optionsData,\n            tapSendData,\n            approvals\n        );\n\n        bytes memory adapterParams = LzLib.buildDefaultAdapterParams(\n            lzData.extraGas\n        );\n\n        _lzSend(\n            lzData.lzDstChainId,\n            lzPayload,\n            payable(optionsData.from),\n            lzData.zroPaymentAddress,\n            adapterParams,\n            msg.value\n        );\n\n        emit SendToChain(\n            lzData.lzDstChainId,\n            optionsData.from,\n            toAddress,\n            optionsData.paymentTokenAmount\n        );\n    }\n\n    function sendFromDestination(bytes memory _payload) public {\n        (\n            ,\n            address from,\n            uint256 amount,\n            ISendFrom.LzCallParams memory callParams,\n            uint16 lzDstChainId,\n            ICommonData.IApproval[] memory approvals\n        ) = abi.decode(\n                _payload,\n                (\n                    uint16,\n                    address,\n                    uint256,\n                    ISendFrom.LzCallParams,\n                    uint16,\n                    ICommonData.IApproval[]\n                )\n            );\n\n        if (approvals.length > 0) {\n            _callApproval(approvals);\n        }\n\n        ISendFrom(address(this)).sendFrom{value: address(this).balance}(\n            from,\n            lzDstChainId,\n            LzLib.addressToBytes32(from),\n            amount,\n            callParams\n        );\n\n        emit ReceiveFromChain(lzDstChainId, from, 0);\n    }\n\n    function exercise(\n        address module,\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) public {\n        (\n            ,\n            ITapiocaOptionsBrokerCrossChain.IExerciseOptionsData\n                memory optionsData,\n            ITapiocaOptionsBrokerCrossChain.IExerciseLZSendTapData\n                memory tapSendData,\n            ICommonData.IApproval[] memory approvals\n        ) = abi.decode(\n                _payload,\n                (\n                    uint16,\n                    ITapiocaOptionsBrokerCrossChain.IExerciseOptionsData,\n                    ITapiocaOptionsBrokerCrossChain.IExerciseLZSendTapData,\n                    ICommonData.IApproval[]\n                )\n            );\n\n        uint256 balanceBefore = balanceOf(address(this));\n        bool credited = creditedPackets[_srcChainId][_srcAddress][_nonce];\n        if (!credited) {\n            _creditTo(\n                _srcChainId,\n                address(this),\n                optionsData.paymentTokenAmount\n            );\n            creditedPackets[_srcChainId][_srcAddress][_nonce] = true;\n        }\n        uint256 balanceAfter = balanceOf(address(this));\n\n        (bool success, bytes memory reason) = module.delegatecall(\n            abi.encodeWithSelector(\n                this.exerciseInternal.selector,\n                optionsData.from,\n                optionsData.oTAPTokenID,\n                optionsData.paymentToken,\n                optionsData.tapAmount,\n                optionsData.target,\n                tapSendData,\n                approvals\n            )\n        );\n\n        if (!success) {\n            if (\n                balanceAfter - balanceBefore >= optionsData.paymentTokenAmount\n            ) {\n                IERC20(address(this)).safeTransfer(\n                    optionsData.from,\n                    optionsData.paymentTokenAmount\n                );\n            }\n            revert(_getRevertMsg(reason)); //forward revert because it's handled by the main executor\n        }\n\n        emit ReceiveFromChain(\n            _srcChainId,\n            optionsData.from,\n            optionsData.paymentTokenAmount\n        );\n    }\n\n    function exerciseInternal(\n        address from,\n        uint256 oTAPTokenID,\n        address paymentToken,\n        uint256 tapAmount,\n        address target,\n        ITapiocaOptionsBrokerCrossChain.IExerciseLZSendTapData\n            memory tapSendData,\n        ICommonData.IApproval[] memory approvals\n    ) public {\n        if (approvals.length > 0) {\n            _callApproval(approvals);\n        }\n\n        ITapiocaOptionsBroker(target).exerciseOption(\n            oTAPTokenID,\n            paymentToken,\n            tapAmount\n        );\n        if (tapSendData.withdrawOnAnotherChain) {\n            ISendFrom(tapSendData.tapOftAddress).sendFrom(\n                address(this),\n                tapSendData.lzDstChainId,\n                LzLib.addressToBytes32(from),\n                tapAmount,\n                ISendFrom.LzCallParams({\n                    refundAddress: payable(from),\n                    zroPaymentAddress: tapSendData.zroPaymentAddress,\n                    adapterParams: LzLib.buildDefaultAdapterParams(\n                        tapSendData.extraGas\n                    )\n                })\n            );\n        } else {\n            IERC20(tapSendData.tapOftAddress).safeTransfer(from, tapAmount);\n        }\n    }\n\n    function _callApproval(ICommonData.IApproval[] memory approvals) private {\n        for (uint256 i = 0; i < approvals.length; ) {\n            if (approvals[i].permitBorrow) {\n                try\n                    IPermitBorrow(approvals[i].target).permitBorrow(\n                        approvals[i].owner,\n                        approvals[i].spender,\n                        approvals[i].value,\n                        approvals[i].deadline,\n                        approvals[i].v,\n                        approvals[i].r,\n                        approvals[i].s\n                    )\n                {} catch Error(string memory reason) {\n                    if (!approvals[i].allowFailure) {\n                        revert(reason);\n                    }\n                }\n            } else if (approvals[i].permitAll) {\n                try\n                    IPermitAll(approvals[i].target).permitAll(\n                        approvals[i].owner,\n                        approvals[i].spender,\n                        approvals[i].deadline,\n                        approvals[i].v,\n                        approvals[i].r,\n                        approvals[i].s\n                    )\n                {} catch Error(string memory reason) {\n                    if (!approvals[i].allowFailure) {\n                        revert(reason);\n                    }\n                }\n            } else {\n                try\n                    IERC20Permit(approvals[i].target).permit(\n                        approvals[i].owner,\n                        approvals[i].spender,\n                        approvals[i].value,\n                        approvals[i].deadline,\n                        approvals[i].v,\n                        approvals[i].r,\n                        approvals[i].s\n                    )\n                {} catch Error(string memory reason) {\n                    if (!approvals[i].allowFailure) {\n                        revert(reason);\n                    }\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/tOFT/modules/BaseTOFTLeverageModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\n//LZ\nimport \"tapioca-sdk/dist/contracts/libraries/LzLib.sol\";\n\n//TAPIOCA\nimport {IUSDOBase} from \"tapioca-periph/contracts/interfaces/IUSDO.sol\";\nimport \"tapioca-periph/contracts/interfaces/ISwapper.sol\";\nimport \"tapioca-periph/contracts/interfaces/IMagnetar.sol\";\nimport \"tapioca-periph/contracts/interfaces/ISingularity.sol\";\nimport \"tapioca-periph/contracts/interfaces/IPermitBorrow.sol\";\nimport \"tapioca-periph/contracts/interfaces/IPermitAll.sol\";\nimport \"tapioca-periph/contracts/interfaces/ITapiocaOptionsBroker.sol\";\nimport \"tapioca-periph/contracts/interfaces/ITapiocaOptionLiquidityProvision.sol\";\n\nimport \"../BaseTOFTStorage.sol\";\n\n/// @title tOFT leverage module\n/// @notice tOFT module for leverage type actions\ncontract BaseTOFTLeverageModule is BaseTOFTStorage {\n    using SafeERC20 for IERC20;\n    using BytesLib for bytes;\n\n    constructor(\n        address _lzEndpoint,\n        address _erc20,\n        IYieldBoxBase _yieldBox,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal,\n        uint256 _hostChainID\n    )\n        BaseTOFTStorage(\n            _lzEndpoint,\n            _erc20,\n            _yieldBox,\n            _name,\n            _symbol,\n            _decimal,\n            _hostChainID\n        )\n    {}\n\n    function initMultiSell(\n        address from,\n        uint256 share,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData,\n        bytes calldata airdropAdapterParams,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        bytes32 senderBytes = LzLib.addressToBytes32(from);\n\n        bytes memory lzPayload = abi.encode(\n            PT_MARKET_MULTIHOP_SELL,\n            senderBytes,\n            from,\n            share,\n            swapData,\n            lzData,\n            externalData,\n            airdropAdapterParams,\n            approvals\n        );\n\n        _lzSend(\n            lzData.lzSrcChainId,\n            lzPayload,\n            payable(lzData.refundAddress),\n            lzData.zroPaymentAddress,\n            airdropAdapterParams,\n            msg.value\n        );\n        emit SendToChain(lzData.lzSrcChainId, msg.sender, senderBytes, 0);\n    }\n\n    function sendForLeverage(\n        uint256 amount,\n        address leverageFor,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData\n    ) external payable {\n        bytes32 senderBytes = LzLib.addressToBytes32(msg.sender);\n        _debitFrom(msg.sender, lzEndpoint.getChainId(), senderBytes, amount);\n\n        bytes memory lzPayload = abi.encode(\n            PT_LEVERAGE_MARKET_DOWN,\n            senderBytes,\n            amount,\n            swapData,\n            externalData,\n            lzData,\n            leverageFor\n        );\n\n        _lzSend(\n            lzData.lzDstChainId,\n            lzPayload,\n            payable(lzData.refundAddress),\n            lzData.zroPaymentAddress,\n            lzData.dstAirdropAdapterParam,\n            msg.value\n        );\n        emit SendToChain(lzData.lzDstChainId, msg.sender, senderBytes, amount);\n    }\n\n    //---Destination calls---\n    function multiHop(bytes memory _payload) public {\n        (\n            ,\n            ,\n            address from,\n            uint256 share,"
    }
  ]
}