{
  "Title": "[H-04] Reentrancy issue in yVault.deposit",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/yVault/yVault.sol#L144-L145\n\n\n# Vulnerability details\n\n## Impact\nIn `deposit`, the balance is cached and then a `token.transferFrom` is triggered which can lead to exploits if the `token` is a token that gives control to the sender, like ERC777 tokens.\n\n#### POC\nInitial state: `balance() = 1000`, shares `supply = 1000`.\nDepositing 1000 amount should mint 1000 supply, but one can split the 1000 amounts into two 500 deposits and use re-entrancy to profit.\n\n- Outer `deposit(500)`: `balanceBefore = 1000`. Control is given to attacker ...\n- Inner `deposit(500)`: `balanceBefore = 1000`. `shares = (_amount * supply) / balanceBefore = 500 * 1000 / 1000 = 500` shares are minted ...\n- Outer `deposit(500)` continues with the mint: `shares = (_amount * supply) / balanceBefore = 500 * 1500 / 1000 = 750` are minted.\n- Withdrawing the `500 + 750 = 1250` shares via `withdraw(1250)`, the attacker receives `backingTokens = (balance() * _shares) / supply = 2000 * 1250 / 2250 = 1111.111111111`. The attacker makes a profit of `1111 - 1000 = 111` tokens.\n- They repeat the attack until the vault is drained.\n\n## Recommended Mitigation Steps\nThe `safeTransferFrom` should be the last call in `deposit`.\n\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-04-jpegd-contest",
  "Code": [
    {
      "filename": "contracts/vaults/yVault/yVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../../interfaces/IController.sol\";\nimport \"../../interfaces/IYVault.sol\";\n\n/// @title JPEG'd yVault\n/// @notice Allows users to deposit fungible assets into autocompounding strategy contracts (e.g. {StrategyPUSDConvex}).\n/// Non whitelisted contracts can't deposit/withdraw.\n/// Owner is DAO\ncontract YVault is ERC20, Ownable {\n    using SafeERC20 for ERC20;\n    using Address for address;\n\n    event Deposit(address indexed depositor, uint256 wantAmount);\n    event Withdrawal(address indexed withdrawer, uint256 wantAmount);\n\n    struct Rate {\n        uint128 numerator;\n        uint128 denominator;\n    }\n\n    ERC20 public immutable token;\n    IController public controller;\n    \n    address public farm;\n    \n    Rate internal availableTokensRate;\n\n    mapping(address => bool) public whitelistedContracts;\n\n    /// @param _token The token managed by this vault\n    /// @param _controller The JPEG'd strategies controller\n    constructor(\n        address _token,\n        address _controller,\n        Rate memory _availableTokensRate\n    )\n        ERC20(\n            string(\n                abi.encodePacked(\"JPEG\\xE2\\x80\\x99d \", ERC20(_token).name())\n            ),\n            string(abi.encodePacked(\"JPEGD\", ERC20(_token).symbol()))\n        )\n    {\n        setController(_controller);\n        setAvailableTokensRate(_availableTokensRate);\n        token = ERC20(_token);\n    }\n\n    /// @dev Modifier that ensures that non-whitelisted contracts can't interact with the vault.\n    /// Prevents non-whitelisted 3rd party contracts from diluting stakers.\n    /// The {isContract} function returns false when `_account` is a contract executing constructor code.\n    /// This may lead to some contracts being able to bypass this check.\n    /// @param _account Address to check\n    modifier noContract(address _account) {\n        require(\n            !_account.isContract() || whitelistedContracts[_account],\n            \"Contracts not allowed\"\n        );\n        _;\n    }\n\n    /// @inheritdoc ERC20\n    function decimals() public view virtual override returns (uint8) {\n        return token.decimals();\n    }\n\n    /// @return The total amount of tokens managed by this vault and the underlying strategy\n    function balance() public view returns (uint256) {\n        return\n            token.balanceOf(address(this)) +\n            controller.balanceOf(address(token));\n    }\n\n    // @return The amount of JPEG tokens claimable by {YVaultLPFarming}\n    function balanceOfJPEG() external view returns (uint256) {\n        return controller.balanceOfJPEG(address(token));\n    }\n\n    /// @notice Allows the owner to whitelist/blacklist contracts\n    /// @param _contract The contract address to whitelist/blacklist\n    /// @param _isWhitelisted Whereter to whitelist or blacklist `_contract`\n    function setContractWhitelisted(address _contract, bool _isWhitelisted)\n        external\n        onlyOwner\n    {\n        whitelistedContracts[_contract] = _isWhitelisted;\n    }\n\n    /// @notice Allows the owner to set the rate of tokens held by this contract that the underlying strategy should be able to borrow\n    /// @param _rate The new rate\n    function setAvailableTokensRate(Rate memory _rate) public onlyOwner {\n        require(\n            _rate.numerator > 0 && _rate.denominator >= _rate.numerator,\n            \"INVALID_RATE\"\n        );\n        availableTokensRate = _rate;\n    }\n\n    /// @notice ALlows the owner to set this vault's controller\n    /// @param _controller The new controller\n    function setController(address _controller) public onlyOwner {\n        require(_controller != address(0), \"INVALID_CONTROLLER\");\n        controller = IController(_controller);\n    }\n\n    /// @notice Allows the owner to set the yVault LP farm\n    /// @param _farm The new farm\n    function setFarmingPool(address _farm) public onlyOwner {\n        require(_farm != address(0), \"INVALID_FARMING_POOL\");\n        farm = _farm;\n    }\n\n    /// @return How much the vault allows to be borrowed by the underlying strategy.\n    /// Sets minimum required on-hand to keep small withdrawals cheap\n    function available() public view returns (uint256) {\n        return\n            (token.balanceOf(address(this)) * availableTokensRate.numerator) /\n            availableTokensRate.denominator;\n    }\n\n    /// @notice Deposits `token` into the underlying strategy\n    function earn() external {\n        uint256 _bal = available();\n        token.safeTransfer(address(controller), _bal);\n        controller.earn(address(token), _bal);\n    }\n\n    /// @notice Allows users to deposit their entire `token` balance\n    function depositAll() external {\n        deposit(token.balanceOf(msg.sender));\n    }\n\n    /// @notice Allows users to deposit `token`. Contracts can't call this function\n    /// @param _amount The amount to deposit\n    function deposit(uint256 _amount) public noContract(msg.sender) {\n        require(_amount > 0, \"INVALID_AMOUNT\");\n        uint256 balanceBefore = balance();\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        uint256 supply = totalSupply();\n        uint256 shares;\n        if (supply == 0) {\n            shares = _amount;\n        } else {\n            //balanceBefore can't be 0 if totalSupply is > 0\n            shares = (_amount * supply) / balanceBefore;\n        }\n        _mint(msg.sender, shares);\n\n        emit Deposit(msg.sender, _amount);\n    }\n\n    /// @notice Allows users to withdraw all their deposited balance\n    function withdrawAll() external {\n        withdraw(balanceOf(msg.sender));\n    }\n\n    /// @notice Allows users to withdraw tokens. Contracts can't call this function\n    /// @param _shares The amount of shares to burn\n    function withdraw(uint256 _shares) public noContract(msg.sender) {\n        require(_shares > 0, \"INVALID_AMOUNT\");\n\n        uint256 supply = totalSupply();\n        require(supply > 0, \"NO_TOKENS_DEPOSITED\");\n\n        uint256 backingTokens = (balance() * _shares) / supply;\n        _burn(msg.sender, _shares);\n\n        // Check balance\n        uint256 vaultBalance = token.balanceOf(address(this));\n        if (vaultBalance < backingTokens) {\n            uint256 toWithdraw = backingTokens - vaultBalance;\n            controller.withdraw(address(token), toWithdraw);\n        }\n\n        token.safeTransfer(msg.sender, backingTokens);\n        emit Withdrawal(msg.sender, backingTokens);\n    }\n\n    /// @notice Allows anyone to withdraw JPEG to `farm` \n    function withdrawJPEG() external {\n        require(farm != address(0), \"NO_FARM\");\n        controller.withdrawJPEG(address(token), farm);\n    }\n\n    /// @return The underlying tokens per share\n    function getPricePerFullShare() external view returns (uint256) {\n        uint256 supply = totalSupply();\n        if (supply == 0) return 0;\n        return (balance() * 1e18) / supply;\n    }\n\n    /// @dev Prevent the owner from renouncing ownership. Having no owner would render this contract unusable due to the inability to create new epochs\n    function renounceOwnership() public view override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n}"
    }
  ]
}