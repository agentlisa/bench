{
  "Title": "[M-05] Comptroller rewards can be artificially inflated and drained by manipulating [totalStaked - totalFrozen] (or: wrong rewards calculation)",
  "Content": "_Submitted by kenzo_\n\nBy adding a small of amount of staking to a normal user scenario, and not approving this small amount as a loan for anybody, a staker can gain disproportionate amounts of comptroller rewards, even to the point of draining the contract.\nFor example:\nStakers A,B,C stake 100, 65, 20, approve it for borrower Z, then staker B stakes an additional 0.07 DAI, and borrower Z borrows 185. This will result in disproportionate amount of rewards.\n\nAs far as I see, this is the main line that causes the inflated amount (*deep breath*):\nIn `calculateRewardsByBlocks`, you set:\n\n```solidity\nuserManagerData.totalStaked = userManagerContract.totalStaked() - userManagerData.totalFrozen;\n```\n\n[`Comptroller.sol` L140](https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L140)\n\nNote that a staker can make this amount very small (depending of course on the current numbers of the protocol).\n(A more advanced attacker might diminish the effect of the current numbers of the protocol by initiating fake loans to himself and not paying them.)\nThis field is then passed to `calculateRewards`, and passed further to `getInflationIndexNew`, and further to `getInflationIndex`.\npassed to `calculateRewards` : [`Comptroller.sol` L167](https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L167)\n\npassed to `getInflationIndexNew` : [`Comptroller.sol` L259](https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L259)\n\npassed to `getInflationIndex` :  [`Comptroller.sol` L238](https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L238)\n\nNow we actually use it in the following line (as `effectiveAmount`):\n```solidity\nreturn blockDelta * inflationPerBlock(effectiveAmount).wadDiv(effectiveAmount) + inflationIndex;\n```\n\n[`Comptroller.sol` L315](https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L315)\n\nSo 2 things are happening here:\n\n1.  mul by `inflationPerBlock(effectiveAmount)` - uses the lookup table in Comptroller. This value gets bigger as effectiveAmount gets smaller, and if effectiveAmount is in the area of 10\\*\\*18, we will get the maximum amount of the lookup.\n2.  div by `effectiveAmount` - as we saw, this can be made small, thereby enlarging the result.\n\nAll together, this calculation will be set to `curInflationIndex` and then used in the following line:\n\n    return (curInflationIndex - startInflationIndex).wadMul(effectiveStakeAmount).wadMul(inflationIndex);\n\n[`Comptroller.sol` L263](https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L263)\n\nNote the `curInflationIndex - startInflationIndex`: per my POC (see below), this can result in a curInflationIndex which is orders of magnitude larger (200x) than startInflationIndex. This creates a huge inflation of rewards.\n\n#### Impact\nComptroller rewards can be drained.\n\n#### Proof of Concept\nSee the following script for a POC of reward drainage. It is based on the scenario in test/integration/`testUserManager`:\n\nStakers A,B,C stake 100, 65, 20, and borrower Z borrows 185. But the difference in my script is that just before borrower Z borrows 185, staker B stakes an additional 0.07 DAI. (This will be the small amount that is `totalStaked - totalFrozen`).\n\nThen, we wait 11 blocks to make the loan overdue, call `updateOverdueInfo` so `totalFrozen` would be updated, and then staker B calls `withdrawRewards`.\nHe ends up with 873 unionTokens out of the 1000 the Comptroller has been seeded with. And this number can be enlarged by changing the small additional amount that staker B staked.\n\nIn this scenario, when calling `withdrawRewards`, the calculated `curInflationIndex` will be 215 WAD, while `startInflationIndex` is 1 WAD, and this is the main issue as I understand it.\n\nFile password: \"union\".\nhttps://pastebin.com/3bJF8mTe\n\n#### Tools Used\nManual analysis, hardhat\n\n#### Recommended Mitigation Steps\nAre you sure that this line should deduct the `totalFrozen`?\n```solidity\nuserManagerData.totalStaked = userManagerContract.totalStaked() - userManagerData.totalFrozen;\n```\n\n[`Comptroller.sol` L140](https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L140)\n\nPer my tests, if we change it to just\n```solidity\nuserManagerData.totalStaked = userManagerContract.totalStaked();\n```\n\nThen we are getting normal results again and no drainage. And the var *is* called just `totalStaked`...\nSo maybe this is the change that needs to be made? But maybe you have a reason to deduct the `totalFrozen`.\nIf so, then a mitigation will perhaps be to limit curInflationIndex somehow, maybe by changing the lookup table, or limiting it to a percentage from startInflationIndex ; but even then, there is also the issue of dividing by `userManagerData.totalStaked` which can be made quite small as the user has control over that.\n\n**[kingjacob (Union) confirmed](https://github.com/code-423n4/2021-10-union-findings/issues/78)**\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-10-union-findings/issues/78#issuecomment-966593455):**\n > Agree with the finding, the warden has found a specific attack that can leak value, while the leak value marks it as Medium Severity, will think over if the economic exploit is big enough to warrant a high severity\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2021-10-union",
  "Code": [
    {
      "filename": "contracts/token/Comptroller.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../Controller.sol\";\nimport \"../WadRayMath.sol\";\nimport \"../interfaces/IComptroller.sol\";\nimport \"../interfaces/IMarketRegistry.sol\";\nimport \"../interfaces/IUserManager.sol\";\n\n//For the time being, only the reward calculation of a single token is supported, and the contract needs to be revised after determining the reward calculation scheme of multiple tokens\ncontract Comptroller is Controller, IComptroller {\n    using WadRayMath for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct Info {\n        uint256 frozenCoinAge;\n        uint256 updatedBlock; //last withdraw rewards block\n        uint256 inflationIndex; //last withdraw rewards inflationIndex\n        uint256 accrued; //the unionToken accrued but not yet transferred to each user\n    }\n\n    struct UserManagerData {\n        uint256 userStaked;\n        uint256 totalFrozen;\n        uint256 totalStaked;\n        uint256 userFrozen;\n        uint256 frozenCoinAge;\n        uint256 totalLocked;\n        bool isMember;\n    }\n\n    uint256 public constant INIT_INFLATION_INDEX = 10**18;\n    uint256 public constant nonMemberRatio = 75 * 10**16; // 75%;\n    uint256 public constant memberRatio = 10**18; // 100%;\n    uint256 public halfDecayPoint;\n    uint256 public gInflationIndex; // store the latest inflation index\n    uint256 public gLastUpdatedBlock; // block number when updating the inflation index\n    IERC20Upgradeable public unionToken;\n    IMarketRegistry public marketRegistry;\n    //1 address account, 2 address token\n    mapping(address => mapping(address => Info)) public users;\n\n    modifier onlyUserManager(address token) {\n        require(msg.sender == _getUserManager(token), \"UnionToken: only user manager can call\");\n        _;\n    }\n\n    /**\n     *  @dev Withdraw rewards event\n     *  @param account The staker's address\n     *  @param amount The amount of Union tokens to withdraw\n     */\n    event LogWithdrawRewards(address indexed account, uint256 amount);\n\n    function __Comptroller_init(address unionToken_, address marketRegistry_) public initializer {\n        Controller.__Controller_init(msg.sender);\n        unionToken = IERC20Upgradeable(unionToken_);\n        marketRegistry = IMarketRegistry(marketRegistry_);\n        gInflationIndex = INIT_INFLATION_INDEX;\n        gLastUpdatedBlock = block.number;\n        halfDecayPoint = 100000;\n    }\n\n    function setHalfDecayPoint(uint256 point) public onlyAdmin {\n        halfDecayPoint = point;\n    }\n\n    /**\n     *  @dev Get the reward multipier based on the account status\n     *  @param account Account address\n     *  @param token ERC20 token address\n     *  @return Multiplier number (in wei)\n     */\n    function getRewardsMultiplier(address account, address token) public view override returns (uint256) {\n        IUserManager userManagerContract = IUserManager(_getUserManager(token));\n        uint256 stakingAmount = userManagerContract.getStakerBalance(account);\n        uint256 lockedStake = userManagerContract.getTotalLockedStake(account);\n        uint256 totalFrozen = userManagerContract.getTotalFrozenAmount(account);\n        bool isMember = userManagerContract.checkIsMember(account);\n        return _getRewardsMultiplier(stakingAmount, lockedStake, totalFrozen, isMember);\n    }\n\n    /**\n     *  @dev Withdraw rewards\n     *  @param token Staking token address\n     *  @return Amount of rewards\n     */\n    function withdrawRewards(address sender, address token)\n        external\n        override\n        whenNotPaused\n        onlyUserManager(token)\n        returns (uint256)\n    {\n        uint256 amount = calculateRewardsByBlocks(sender, token, 0);\n        IUserManager userManagerContract = IUserManager(_getUserManager(token));\n        // update the global states\n        uint256 totalStaked_ = userManagerContract.totalStaked() - userManagerContract.totalFrozen();\n        gInflationIndex = _getInflationIndexNew(totalStaked_, block.number - gLastUpdatedBlock);\n        gLastUpdatedBlock = block.number;\n        users[sender][token].frozenCoinAge = 0;\n        users[sender][token].updatedBlock = block.number;\n        users[sender][token].inflationIndex = gInflationIndex;\n        if (unionToken.balanceOf(address(this)) >= amount && amount > 0) {\n            unionToken.safeTransfer(sender, amount);\n            users[sender][token].accrued = 0;\n            emit LogWithdrawRewards(sender, amount);\n\n            return amount;\n        } else {\n            users[sender][token].accrued = amount;\n            emit LogWithdrawRewards(sender, 0);\n\n            return 0;\n        }\n    }\n\n    /**\n     *  @dev Calculate unclaimed rewards based on blocks\n     *  @param account User address\n     *  @param token Staking token address\n     *  @param futureBlocks Number of blocks in the future\n     *  @return Unclaimed rewards\n     */\n    function calculateRewardsByBlocks(\n        address account,\n        address token,\n        uint256 futureBlocks\n    ) public view override returns (uint256) {\n        IUserManager userManagerContract = IUserManager(_getUserManager(token));\n        Info memory userInfo = users[account][token];\n        UserManagerData memory userManagerData;\n\n        userManagerData.totalFrozen = userManagerContract.totalFrozen();\n        userManagerData.userStaked = userManagerContract.getStakerBalance(account);\n        userManagerData.userFrozen = userManagerContract.getTotalFrozenAmount(account);\n        userManagerData.totalStaked = userManagerContract.totalStaked() - userManagerData.totalFrozen;\n\n        uint256 lastUpdatedBlock = userInfo.updatedBlock;\n        if (block.number < lastUpdatedBlock) {\n            lastUpdatedBlock = block.number;\n        }\n\n        uint256 pastBlocks = block.number - lastUpdatedBlock + futureBlocks;\n        userManagerData.frozenCoinAge =\n            userManagerContract.getFrozenCoinAge(account, pastBlocks) +\n            userInfo.frozenCoinAge;\n\n        userManagerData.totalLocked = userManagerContract.getTotalLockedStake(account);\n        userManagerData.isMember = userManagerContract.checkIsMember(account);\n\n        uint256 inflationIndex = _getRewardsMultiplier(\n            userManagerData.userStaked,\n            userManagerData.totalLocked,\n            userManagerData.userFrozen,\n            userManagerData.isMember\n        );\n\n        return\n            userInfo.accrued +\n            _calculateRewards(\n                account,\n                token,\n                userManagerData.totalStaked,\n                userManagerData.userStaked,\n                userManagerData.frozenCoinAge,\n                pastBlocks,\n                inflationIndex\n            );\n    }\n\n    /**\n     *  @dev Calculate currently unclaimed rewards\n     *  @param account Account address\n     *  @param token Staking token address\n     *  @return Unclaimed rewards\n     */\n    function calculateRewards(address account, address token) public view override returns (uint256) {\n        return calculateRewardsByBlocks(account, token, 0);\n    }\n\n    /**\n     *  @dev When total staked change update inflation index\n     *  @param totalStaked totalStaked amount\n     *  @return Whether succeeded\n     */\n    function updateTotalStaked(address token, uint256 totalStaked)\n        external\n        override\n        whenNotPaused\n        onlyUserManager(token)\n        returns (bool)\n    {\n        if (totalStaked > 0) {\n            gInflationIndex = _getInflationIndexNew(totalStaked, block.number - gLastUpdatedBlock);\n        }\n        gLastUpdatedBlock = block.number;\n\n        return true;\n    }\n\n    function addFrozenCoinAge(\n        address staker,\n        address token,\n        uint256 lockedStake,\n        uint256 lastRepay\n    ) external override onlyUserManager(token) {\n        uint256 lastBlock = users[staker][token].updatedBlock;\n        uint256 blocks;\n        if (lastBlock > lastRepay) {\n            // Frozen CoinAge here has been accounted for when the user withdraws the rewards, so here just need to calculate the delta between block.number and lastBlock\n            blocks = block.number - lastBlock;\n        } else {\n            blocks = block.number - lastRepay;\n        }\n\n        users[staker][token].frozenCoinAge += lockedStake * blocks;\n    }\n\n    /**\n     *  @dev Calculate new inflation index based on # of blocks\n     *  @param totalStaked_ Number of total staked tokens in the system\n     *  @param blockDelta Number of blocks\n     *  @return New inflation index\n     */\n    function _getInflationIndexNew(uint256 totalStaked_, uint256 blockDelta) private view returns (uint256) {\n        if (totalStaked_ == 0) {\n            return INIT_INFLATION_INDEX;\n        }\n\n        if (blockDelta == 0) {\n            return gInflationIndex;\n        }\n\n        return _getInflationIndex(totalStaked_, gInflationIndex, blockDelta);\n    }\n\n    function _calculateRewards(\n        address account,\n        address token,\n        uint256 totalStaked,\n        uint256 userStaked,\n        uint256 frozenCoinAge,\n        uint256 pastBlocks,\n        uint256 inflationIndex\n    ) private view returns (uint256) {\n        uint256 startInflationIndex = users[account][token].inflationIndex;\n        require(userStaked * pastBlocks >= frozenCoinAge, \" Comptroller: frozen coin age error\");\n\n        if (userStaked == 0 || totalStaked == 0 || startInflationIndex == 0 || pastBlocks == 0) {\n            return 0;\n        }\n\n        uint256 effectiveStakeAmount = (userStaked * pastBlocks - frozenCoinAge) / pastBlocks;\n\n        uint256 curInflationIndex = _getInflationIndexNew(totalStaked, pastBlocks);\n\n        require(curInflationIndex >= startInflationIndex, \"Comptroller: inflationIndex error\");\n\n        return (curInflationIndex - startInflationIndex).wadMul(effectiveStakeAmount).wadMul(inflationIndex);\n    }\n\n    function _getUserManager(address token) private view returns (address userManager) {\n        (, userManager) = marketRegistry.tokens(token);\n    }\n\n    /**\n     *  @dev Calculate inflation per block\n     *  @param effectiveTotalStake Effective total stake\n     *  @return Inflation amount, div totalSupply is the inflation rate\n     */\n    function inflationPerBlock(uint256 effectiveTotalStake) public view returns (uint256) {\n        uint256 index = effectiveTotalStake / halfDecayPoint;\n        return lookup(index);\n    }\n\n    function lookup(uint256 index) public pure returns (uint256) {\n        if (index <= 0.00001 * 10**18) {\n            return 1 * 10**18;\n        } else if (index <= 0.0001 * 10**18) {\n            return 0.9 * 10**18;\n        } else if (index <= 0.001 * 10**18) {\n            return 0.8 * 10**18;\n        } else if (index <= 0.01 * 10**18) {\n            return 0.7 * 10**18;\n        } else if (index <= 0.1 * 10**18) {\n            return 0.6 * 10**18;\n        } else if (index <= 1 * 10**18) {\n            return 0.5 * 10**18;\n        } else if (index <= 5 * 10**18) {\n            return 0.25 * 10**18;\n        } else if (index <= 10 * 10**18) {\n            return 0.1 * 10**18;\n        } else if (index <= 100 * 10**18) {\n            return 0.01 * 10**18;\n        } else if (index <= 1000 * 10**18) {\n            return 0.001 * 10**18;\n        } else if (index <= 10000 * 10**18) {\n            return 0.0001 * 10**18;\n        } else if (index <= 100000 * 10**18) {\n            return 0.00001 * 10**18;\n        } else {\n            return 0.000001 * 10**18;\n        }\n    }\n\n    function _getInflationIndex(\n        uint256 effectiveAmount,\n        uint256 inflationIndex,\n        uint256 blockDelta\n    ) private view returns (uint256) {\n        return blockDelta * inflationPerBlock(effectiveAmount).wadDiv(effectiveAmount) + inflationIndex;\n    }\n\n    function _getRewardsMultiplier(\n        uint256 userStaked,\n        uint256 lockedStake,\n        uint256 totalFrozen_,\n        bool isMember_\n    ) private pure returns (uint256) {\n        if (isMember_) {\n            if (userStaked == 0 || totalFrozen_ >= lockedStake || totalFrozen_ >= userStaked) {\n                return memberRatio;\n            }\n\n            uint256 effectiveLockedAmount = lockedStake - totalFrozen_;\n            uint256 effectiveStakeAmount = userStaked - totalFrozen_;\n\n            uint256 lendingRatio = effectiveLockedAmount.wadDiv(effectiveStakeAmount);\n\n            return lendingRatio + memberRatio;\n        } else {\n            return nonMemberRatio;\n        }\n    }\n}"
    },
    {
      "filename": "contracts/token/Comptroller.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../Controller.sol\";\nimport \"../WadRayMath.sol\";\nimport \"../interfaces/IComptroller.sol\";\nimport \"../interfaces/IMarketRegistry.sol\";\nimport \"../interfaces/IUserManager.sol\";\n\n//For the time being, only the reward calculation of a single token is supported, and the contract needs to be revised after determining the reward calculation scheme of multiple tokens\ncontract Comptroller is Controller, IComptroller {\n    using WadRayMath for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct Info {\n        uint256 frozenCoinAge;\n        uint256 updatedBlock; //last withdraw rewards block\n        uint256 inflationIndex; //last withdraw rewards inflationIndex\n        uint256 accrued; //the unionToken accrued but not yet transferred to each user\n    }\n\n    struct UserManagerData {\n        uint256 userStaked;\n        uint256 totalFrozen;\n        uint256 totalStaked;\n        uint256 userFrozen;\n        uint256 frozenCoinAge;\n        uint256 totalLocked;\n        bool isMember;\n    }\n\n    uint256 public constant INIT_INFLATION_INDEX = 10**18;\n    uint256 public constant nonMemberRatio = 75 * 10**16; // 75%;\n    uint256 public constant memberRatio = 10**18; // 100%;\n    uint256 public halfDecayPoint;\n    uint256 public gInflationIndex; // store the latest inflation index\n    uint256 public gLastUpdatedBlock; // block number when updating the inflation index\n    IERC20Upgradeable public unionToken;\n    IMarketRegistry public marketRegistry;\n    //1 address account, 2 address token\n    mapping(address => mapping(address => Info)) public users;\n\n    modifier onlyUserManager(address token) {\n        require(msg.sender == _getUserManager(token), \"UnionToken: only user manager can call\");\n        _;\n    }\n\n    /**\n     *  @dev Withdraw rewards event\n     *  @param account The staker's address\n     *  @param amount The amount of Union tokens to withdraw\n     */\n    event LogWithdrawRewards(address indexed account, uint256 amount);\n\n    function __Comptroller_init(address unionToken_, address marketRegistry_) public initializer {\n        Controller.__Controller_init(msg.sender);\n        unionToken = IERC20Upgradeable(unionToken_);\n        marketRegistry = IMarketRegistry(marketRegistry_);\n        gInflationIndex = INIT_INFLATION_INDEX;\n        gLastUpdatedBlock = block.number;\n        halfDecayPoint = 100000;\n    }\n\n    function setHalfDecayPoint(uint256 point) public onlyAdmin {\n        halfDecayPoint = point;\n    }\n\n    /**\n     *  @dev Get the reward multipier based on the account status\n     *  @param account Account address\n     *  @param token ERC20 token address\n     *  @return Multiplier number (in wei)\n     */\n    function getRewardsMultiplier(address account, address token) public view override returns (uint256) {\n        IUserManager userManagerContract = IUserManager(_getUserManager(token));\n        uint256 stakingAmount = userManagerContract.getStakerBalance(account);\n        uint256 lockedStake = userManagerContract.getTotalLockedStake(account);\n        uint256 totalFrozen = userManagerContract.getTotalFrozenAmount(account);\n        bool isMember = userManagerContract.checkIsMember(account);\n        return _getRewardsMultiplier(stakingAmount, lockedStake, totalFrozen, isMember);\n    }\n\n    /**\n     *  @dev Withdraw rewards\n     *  @param token Staking token address\n     *  @return Amount of rewards\n     */\n    function withdrawRewards(address sender, address token)\n        external\n        override\n        whenNotPaused\n        onlyUserManager(token)\n        returns (uint256)\n    {\n        uint256 amount = calculateRewardsByBlocks(sender, token, 0);\n        IUserManager userManagerContract = IUserManager(_getUserManager(token));\n        // update the global states\n        uint256 totalStaked_ = userManagerContract.totalStaked() - userManagerContract.totalFrozen();\n        gInflationIndex = _getInflationIndexNew(totalStaked_, block.number - gLastUpdatedBlock);\n        gLastUpdatedBlock = block.number;\n        users[sender][token].frozenCoinAge = 0;\n        users[sender][token].updatedBlock = block.number;\n        users[sender][token].inflationIndex = gInflationIndex;\n        if (unionToken.balanceOf(address(this)) >= amount && amount > 0) {\n            unionToken.safeTransfer(sender, amount);\n            users[sender][token].accrued = 0;\n            emit LogWithdrawRewards(sender, amount);\n\n            return amount;\n        } else {\n            users[sender][token].accrued = amount;\n            emit LogWithdrawRewards(sender, 0);\n\n            return 0;\n        }\n    }\n\n    /**\n     *  @dev Calculate unclaimed rewards based on blocks\n     *  @param account User address\n     *  @param token Staking token address\n     *  @param futureBlocks Number of blocks in the future\n     *  @return Unclaimed rewards\n     */\n    function calculateRewardsByBlocks(\n        address account,\n        address token,\n        uint256 futureBlocks\n    ) public view override returns (uint256) {\n        IUserManager userManagerContract = IUserManager(_getUserManager(token));\n        Info memory userInfo = users[account][token];\n        UserManagerData memory userManagerData;\n\n        userManagerData.totalFrozen = userManagerContract.totalFrozen();\n        userManagerData.userStaked = userManagerContract.getStakerBalance(account);\n        userManagerData.userFrozen = userManagerContract.getTotalFrozenAmount(account);\n        userManagerData.totalStaked = userManagerContract.totalStaked() - userManagerData.totalFrozen;\n\n        uint256 lastUpdatedBlock = userInfo.updatedBlock;\n        if (block.number < lastUpdatedBlock) {\n            lastUpdatedBlock = block.number;\n        }\n\n        uint256 pastBlocks = block.number - lastUpdatedBlock + futureBlocks;\n        userManagerData.frozenCoinAge =\n            userManagerContract.getFrozenCoinAge(account, pastBlocks) +\n            userInfo.frozenCoinAge;\n\n        userManagerData.totalLocked = userManagerContract.getTotalLockedStake(account);\n        userManagerData.isMember = userManagerContract.checkIsMember(account);\n\n        uint256 inflationIndex = _getRewardsMultiplier(\n            userManagerData.userStaked,\n            userManagerData.totalLocked,\n            userManagerData.userFrozen,\n            userManagerData.isMember\n        );\n\n        return\n            userInfo.accrued +\n            _calculateRewards(\n                account,\n                token,\n                userManagerData.totalStaked,\n                userManagerData.userStaked,\n                userManagerData.frozenCoinAge,\n                pastBlocks,\n                inflationIndex\n            );\n    }\n\n    /**\n     *  @dev Calculate currently unclaimed rewards\n     *  @param account Account address\n     *  @param token Staking token address\n     *  @return Unclaimed rewards\n     */\n    function calculateRewards(address account, address token) public view override returns (uint256) {\n        return calculateRewardsByBlocks(account, token, 0);\n    }\n\n    /**\n     *  @dev When total staked change update inflation index\n     *  @param totalStaked totalStaked amount\n     *  @return Whether succeeded\n     */\n    function updateTotalStaked(address token, uint256 totalStaked)\n        external\n        override\n        whenNotPaused\n        onlyUserManager(token)\n        returns (bool)\n    {\n        if (totalStaked > 0) {\n            gInflationIndex = _getInflationIndexNew(totalStaked, block.number - gLastUpdatedBlock);\n        }\n        gLastUpdatedBlock = block.number;\n\n        return true;\n    }\n\n    function addFrozenCoinAge(\n        address staker,\n        address token,\n        uint256 lockedStake,\n        uint256 lastRepay\n    ) external override onlyUserManager(token) {\n        uint256 lastBlock = users[staker][token].updatedBlock;\n        uint256 blocks;\n        if (lastBlock > lastRepay) {\n            // Frozen CoinAge here has been accounted for when the user withdraws the rewards, so here just need to calculate the delta between block.number and lastBlock\n            blocks = block.number - lastBlock;\n        } else {\n            blocks = block.number - lastRepay;\n        }\n\n        users[staker][token].frozenCoinAge += lockedStake * blocks;\n    }\n\n    /**\n     *  @dev Calculate new inflation index based on # of blocks\n     *  @param totalStaked_ Number of total staked tokens in the system\n     *  @param blockDelta Number of blocks\n     *  @return New inflation index\n     */\n    function _getInflationIndexNew(uint256 totalStaked_, uint256 blockDelta) private view returns (uint256) {\n        if (totalStaked_ == 0) {\n            return INIT_INFLATION_INDEX;\n        }\n\n        if (blockDelta == 0) {\n            return gInflationIndex;\n        }\n\n        return _getInflationIndex(totalStaked_, gInflationIndex, blockDelta);\n    }\n\n    function _calculateRewards(\n        address account,\n        address token,\n        uint256 totalStaked,\n        uint256 userStaked,\n        uint256 frozenCoinAge,\n        uint256 pastBlocks,\n        uint256 inflationIndex\n    ) private view returns (uint256) {\n        uint256 startInflationIndex = users[account][token].inflationIndex;\n        require(userStaked * pastBlocks >= frozenCoinAge, \" Comptroller: frozen coin age error\");\n\n        if (userStaked == 0 || totalStaked == 0 || startInflationIndex == 0 || pastBlocks == 0) {\n            return 0;\n        }\n\n        uint256 effectiveStakeAmount = (userStaked * pastBlocks - frozenCoinAge) / pastBlocks;\n\n        uint256 curInflationIndex = _getInflationIndexNew(totalStaked, pastBlocks);\n\n        require(curInflationIndex >= startInflationIndex, \"Comptroller: inflationIndex error\");\n\n        return (curInflationIndex - startInflationIndex).wadMul(effectiveStakeAmount).wadMul(inflationIndex);\n    }\n\n    function _getUserManager(address token) private view returns (address userManager) {\n        (, userManager) = marketRegistry.tokens(token);\n    }\n\n    /**\n     *  @dev Calculate inflation per block\n     *  @param effectiveTotalStake Effective total stake\n     *  @return Inflation amount, div totalSupply is the inflation rate\n     */\n    function inflationPerBlock(uint256 effectiveTotalStake) public view returns (uint256) {\n        uint256 index = effectiveTotalStake / halfDecayPoint;\n        return lookup(index);\n    }\n\n    function lookup(uint256 index) public pure returns (uint256) {\n        if (index <= 0.00001 * 10**18) {\n            return 1 * 10**18;\n        } else if (index <= 0.0001 * 10**18) {\n            return 0.9 * 10**18;\n        } else if (index <= 0.001 * 10**18) {\n            return 0.8 * 10**18;\n        } else if (index <= 0.01 * 10**18) {\n            return 0.7 * 10**18;\n        } else if (index <= 0.1 * 10**18) {\n            return 0.6 * 10**18;\n        } else if (index <= 1 * 10**18) {\n            return 0.5 * 10**18;\n        } else if (index <= 5 * 10**18) {\n            return 0.25 * 10**18;\n        } else if (index <= 10 * 10**18) {\n            return 0.1 * 10**18;\n        } else if (index <= 100 * 10**18) {\n            return 0.01 * 10**18;\n        } else if (index <= 1000 * 10**18) {\n            return 0.001 * 10**18;\n        } else if (index <= 10000 * 10**18) {\n            return 0.0001 * 10**18;\n        } else if (index <= 100000 * 10**18) {\n            return 0.00001 * 10**18;\n        } else {\n            return 0.000001 * 10**18;\n        }\n    }\n\n    function _getInflationIndex(\n        uint256 effectiveAmount,\n        uint256 inflationIndex,\n        uint256 blockDelta\n    ) private view returns (uint256) {\n        return blockDelta * inflationPerBlock(effectiveAmount).wadDiv(effectiveAmount) + inflationIndex;\n    }\n\n    function _getRewardsMultiplier(\n        uint256 userStaked,\n        uint256 lockedStake,\n        uint256 totalFrozen_,\n        bool isMember_\n    ) private pure returns (uint256) {\n        if (isMember_) {\n            if (userStaked == 0 || totalFrozen_ >= lockedStake || totalFrozen_ >= userStaked) {\n                return memberRatio;\n            }\n\n            uint256 effectiveLockedAmount = lockedStake - totalFrozen_;\n            uint256 effectiveStakeAmount = userStaked - totalFrozen_;\n\n            uint256 lendingRatio = effectiveLockedAmount.wadDiv(effectiveStakeAmount);\n\n            return lendingRatio + memberRatio;\n        } else {\n            return nonMemberRatio;\n        }\n    }\n}"
    },
    {
      "filename": "contracts/token/Comptroller.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../Controller.sol\";\nimport \"../WadRayMath.sol\";\nimport \"../interfaces/IComptroller.sol\";\nimport \"../interfaces/IMarketRegistry.sol\";\nimport \"../interfaces/IUserManager.sol\";\n\n//For the time being, only the reward calculation of a single token is supported, and the contract needs to be revised after determining the reward calculation scheme of multiple tokens\ncontract Comptroller is Controller, IComptroller {\n    using WadRayMath for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct Info {\n        uint256 frozenCoinAge;\n        uint256 updatedBlock; //last withdraw rewards block\n        uint256 inflationIndex; //last withdraw rewards inflationIndex\n        uint256 accrued; //the unionToken accrued but not yet transferred to each user\n    }\n\n    struct UserManagerData {\n        uint256 userStaked;\n        uint256 totalFrozen;\n        uint256 totalStaked;\n        uint256 userFrozen;\n        uint256 frozenCoinAge;\n        uint256 totalLocked;\n        bool isMember;\n    }\n\n    uint256 public constant INIT_INFLATION_INDEX = 10**18;\n    uint256 public constant nonMemberRatio = 75 * 10**16; // 75%;\n    uint256 public constant memberRatio = 10**18; // 100%;\n    uint256 public halfDecayPoint;\n    uint256 public gInflationIndex; // store the latest inflation index\n    uint256 public gLastUpdatedBlock; // block number when updating the inflation index\n    IERC20Upgradeable public unionToken;\n    IMarketRegistry public marketRegistry;\n    //1 address account, 2 address token\n    mapping(address => mapping(address => Info)) public users;\n\n    modifier onlyUserManager(address token) {\n        require(msg.sender == _getUserManager(token), \"UnionToken: only user manager can call\");\n        _;\n    }\n\n    /**\n     *  @dev Withdraw rewards event\n     *  @param account The staker's address\n     *  @param amount The amount of Union tokens to withdraw\n     */\n    event LogWithdrawRewards(address indexed account, uint256 amount);\n\n    function __Comptroller_init(address unionToken_, address marketRegistry_) public initializer {\n        Controller.__Controller_init(msg.sender);\n        unionToken = IERC20Upgradeable(unionToken_);\n        marketRegistry = IMarketRegistry(marketRegistry_);\n        gInflationIndex = INIT_INFLATION_INDEX;\n        gLastUpdatedBlock = block.number;\n        halfDecayPoint = 100000;\n    }\n\n    function setHalfDecayPoint(uint256 point) public onlyAdmin {\n        halfDecayPoint = point;\n    }\n\n    /**\n     *  @dev Get the reward multipier based on the account status\n     *  @param account Account address\n     *  @param token ERC20 token address\n     *  @return Multiplier number (in wei)\n     */\n    function getRewardsMultiplier(address account, address token) public view override returns (uint256) {\n        IUserManager userManagerContract = IUserManager(_getUserManager(token));\n        uint256 stakingAmount = userManagerContract.getStakerBalance(account);\n        uint256 lockedStake = userManagerContract.getTotalLockedStake(account);\n        uint256 totalFrozen = userManagerContract.getTotalFrozenAmount(account);\n        bool isMember = userManagerContract.checkIsMember(account);\n        return _getRewardsMultiplier(stakingAmount, lockedStake, totalFrozen, isMember);\n    }\n\n    /**\n     *  @dev Withdraw rewards\n     *  @param token Staking token address\n     *  @return Amount of rewards\n     */\n    function withdrawRewards(address sender, address token)\n        external\n        override\n        whenNotPaused\n        onlyUserManager(token)\n        returns (uint256)\n    {\n        uint256 amount = calculateRewardsByBlocks(sender, token, 0);\n        IUserManager userManagerContract = IUserManager(_getUserManager(token));\n        // update the global states\n        uint256 totalStaked_ = userManagerContract.totalStaked() - userManagerContract.totalFrozen();\n        gInflationIndex = _getInflationIndexNew(totalStaked_, block.number - gLastUpdatedBlock);\n        gLastUpdatedBlock = block.number;\n        users[sender][token].frozenCoinAge = 0;\n        users[sender][token].updatedBlock = block.number;\n        users[sender][token].inflationIndex = gInflationIndex;\n        if (unionToken.balanceOf(address(this)) >= amount && amount > 0) {\n            unionToken.safeTransfer(sender, amount);\n            users[sender][token].accrued = 0;\n            emit LogWithdrawRewards(sender, amount);\n\n            return amount;\n        } else {\n            users[sender][token].accrued = amount;\n            emit LogWithdrawRewards(sender, 0);\n\n            return 0;\n        }\n    }\n\n    /**\n     *  @dev Calculate unclaimed rewards based on blocks\n     *  @param account User address\n     *  @param token Staking token address\n     *  @param futureBlocks Number of blocks in the future\n     *  @return Unclaimed rewards\n     */\n    function calculateRewardsByBlocks(\n        address account,\n        address token,\n        uint256 futureBlocks\n    ) public view override returns (uint256) {\n        IUserManager userManagerContract = IUserManager(_getUserManager(token));\n        Info memory userInfo = users[account][token];\n        UserManagerData memory userManagerData;\n\n        userManagerData.totalFrozen = userManagerContract.totalFrozen();\n        userManagerData.userStaked = userManagerContract.getStakerBalance(account);\n        userManagerData.userFrozen = userManagerContract.getTotalFrozenAmount(account);\n        userManagerData.totalStaked = userManagerContract.totalStaked() - userManagerData.totalFrozen;\n\n        uint256 lastUpdatedBlock = userInfo.updatedBlock;\n        if (block.number < lastUpdatedBlock) {\n            lastUpdatedBlock = block.number;\n        }\n\n        uint256 pastBlocks = block.number - lastUpdatedBlock + futureBlocks;\n        userManagerData.frozenCoinAge =\n            userManagerContract.getFrozenCoinAge(account, pastBlocks) +\n            userInfo.frozenCoinAge;\n\n        userManagerData.totalLocked = userManagerContract.getTotalLockedStake(account);\n        userManagerData.isMember = userManagerContract.checkIsMember(account);\n\n        uint256 inflationIndex = _getRewardsMultiplier(\n            userManagerData.userStaked,\n            userManagerData.totalLocked,\n            userManagerData.userFrozen,\n            userManagerData.isMember\n        );\n\n        return\n            userInfo.accrued +\n            _calculateRewards(\n                account,\n                token,\n                userManagerData.totalStaked,\n                userManagerData.userStaked,\n                userManagerData.frozenCoinAge,\n                pastBlocks,\n                inflationIndex\n            );\n    }\n\n    /**\n     *  @dev Calculate currently unclaimed rewards\n     *  @param account Account address\n     *  @param token Staking token address\n     *  @return Unclaimed rewards\n     */\n    function calculateRewards(address account, address token) public view override returns (uint256) {\n        return calculateRewardsByBlocks(account, token, 0);\n    }\n\n    /**\n     *  @dev When total staked change update inflation index\n     *  @param totalStaked totalStaked amount\n     *  @return Whether succeeded\n     */\n    function updateTotalStaked(address token, uint256 totalStaked)"
    }
  ]
}