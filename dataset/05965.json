{
  "Title": "[N-03] `relay()` is not declared as `payable`",
  "Content": "\nIn `SecurityCouncilNomineeElectionGovernor`, although `relay()` makes calls with `AddressUpgradeable.functionCallWithValue()`, it is not declared as `payable`:\n\n[SecurityCouncilNomineeElectionGovernor.sol#L254-L261](https://github.com/ArbitrumFoundation/governance/blob/c18de53820c505fc459f766c1b224810eaeaabc5/src/security-council-mgmt/governors/SecurityCouncilNomineeElectionGovernor.sol#L254-L261)\n\n```solidity\n    function relay(address target, uint256 value, bytes calldata data)\n        external\n        virtual\n        override\n        onlyOwner\n    {\n        AddressUpgradeable.functionCallWithValue(target, data, value);\n    }\n```\n\nThis limits the functionality of `relay()`, as governance will not be able to send ETH to this contract and transfer the ETH to `target` in a single call to `relay()`.\n\n### Recommendation\n\nConsider declaring `relay()` as `payable`:\n\n[SecurityCouncilNomineeElectionGovernor.sol#L254-L261](https://github.com/ArbitrumFoundation/governance/blob/c18de53820c505fc459f766c1b224810eaeaabc5/src/security-council-mgmt/governors/SecurityCouncilNomineeElectionGovernor.sol#L254-L261)\n\n```solidity\n    function relay(address target, uint256 value, bytes calldata data)\n        external\n+       payable\n        virtual\n        override\n        onlyOwner\n    {\n        AddressUpgradeable.functionCallWithValue(target, data, value);\n    }\n```\n\nThis applies to the `relay()` function in [`SecurityCouncilMemberElectionGovernor`](https://github.com/ArbitrumFoundation/governance/blob/c18de53820c505fc459f766c1b224810eaeaabc5/src/security-council-mgmt/governors/SecurityCouncilMemberElectionGovernor.sol) and [`SecurityCouncilMemberRemovalGovernor`](https://github.com/ArbitrumFoundation/governance/blob/c18de53820c505fc459f766c1b224810eaeaabc5/src/security-council-mgmt/governors/SecurityCouncilMemberRemovalGovernor.sol) as well.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-08-arbitrum",
  "Code": [
    {
      "filename": "src/security-council-mgmt/governors/SecurityCouncilNomineeElectionGovernor.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorSettingsUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../interfaces/ISecurityCouncilMemberElectionGovernor.sol\";\nimport \"../interfaces/ISecurityCouncilNomineeElectionGovernor.sol\";\nimport \"./modules/SecurityCouncilNomineeElectionGovernorCountingUpgradeable.sol\";\nimport \"./modules/ArbitrumGovernorVotesQuorumFractionUpgradeable.sol\";\nimport \"./modules/SecurityCouncilNomineeElectionGovernorTiming.sol\";\nimport \"./modules/ElectionGovernor.sol\";\nimport \"../SecurityCouncilMgmtUtils.sol\";\n\n/// @title SecurityCouncilNomineeElectionGovernor\n/// @notice Governor contract for selecting Security Council Nominees (phase 1 of the Security Council election process).\ncontract SecurityCouncilNomineeElectionGovernor is\n    Initializable,\n    GovernorUpgradeable,\n    GovernorVotesUpgradeable,\n    SecurityCouncilNomineeElectionGovernorCountingUpgradeable,\n    ArbitrumGovernorVotesQuorumFractionUpgradeable,\n    GovernorSettingsUpgradeable,\n    OwnableUpgradeable,\n    SecurityCouncilNomineeElectionGovernorTiming,\n    ElectionGovernor,\n    ISecurityCouncilNomineeElectionGovernor\n{\n    /// @notice parameters for `initialize`\n    /// @param firstNominationStartDate First election start date\n    /// @param nomineeVettingDuration Duration of the nominee vetting period (expressed in blocks)\n    /// @param nomineeVetter Address of the nominee vetter\n    /// @param securityCouncilManager Security council manager contract\n    /// @param token Token used for voting\n    /// @param owner Owner of the governor (the Arbitrum DAO)\n    /// @param quorumNumeratorValue Numerator of the quorum fraction (0.2% = 20)\n    /// @param votingPeriod Duration of the voting period (expressed in blocks)\n    ///                     Note that the voting period + nominee vetting duration must be << than 6 months to ensure elections dont overlap\n    struct InitParams {\n        Date firstNominationStartDate;\n        uint256 nomineeVettingDuration;\n        address nomineeVetter;\n        ISecurityCouncilManager securityCouncilManager;\n        ISecurityCouncilMemberElectionGovernor securityCouncilMemberElectionGovernor;\n        IVotesUpgradeable token;\n        address owner;\n        uint256 quorumNumeratorValue;\n        uint256 votingPeriod;\n    }\n\n    /// @notice Information about a nominee election\n    /// @param isContender Whether the account is a contender\n    /// @param isExcluded Whether the account has been excluded by the nomineeVetter\n    /// @param excludedNomineeCount The number of nominees that have been excluded by the nomineeVetter\n    struct ElectionInfo {\n        mapping(address => bool) isContender;\n        mapping(address => bool) isExcluded;\n        uint256 excludedNomineeCount;\n    }\n\n    /// @notice Address responsible for blocking non compliant nominees\n    address public nomineeVetter;\n\n    /// @notice Security council manager contract\n    /// @dev    Used to execute the election result immediately if <= 6 compliant nominees are chosen\n    ISecurityCouncilManager public securityCouncilManager;\n\n    /// @notice Security council member election governor contract\n    ISecurityCouncilMemberElectionGovernor public securityCouncilMemberElectionGovernor;\n\n    /// @notice Number of elections created\n    uint256 public electionCount;\n\n    /// @notice Maps proposalId to ElectionInfo\n    mapping(uint256 => ElectionInfo) internal _elections;\n\n    event NomineeVetterChanged(address indexed oldNomineeVetter, address indexed newNomineeVetter);\n    event ContenderAdded(uint256 indexed proposalId, address indexed contender);\n    event NomineeExcluded(uint256 indexed proposalId, address indexed nominee);\n\n    error OnlyNomineeVetter();\n    error CreateTooEarly(uint256 blockTimestamp, uint256 startTime);\n    error AlreadyContender(address contender);\n    error ProposalNotActive(ProposalState state);\n    error AccountInOtherCohort(Cohort cohort, address account);\n    error ProposalNotSucceededState(ProposalState state);\n    error ProposalNotInVettingPeriod(uint256 blockNumber, uint256 vettingDeadline);\n    error NomineeAlreadyExcluded(address nominee);\n    error CompliantNomineeTargetHit(uint256 nomineeCount, uint256 expectedCount);\n    error ProposalInVettingPeriod(uint256 blockNumber, uint256 vettingDeadline);\n    error InsufficientCompliantNomineeCount(uint256 compliantNomineeCount, uint256 expectedCount);\n    error ProposeDisabled();\n    error NotNominee(address nominee);\n    error ProposalIdMismatch(uint256 nomineeProposalId, uint256 memberProposalId);\n    error QuorumNumeratorTooLow(uint256 quorumNumeratorValue);\n    error CastVoteDisabled();\n    error LastMemberElectionNotExecuted(uint256 prevProposalId);\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the governor\n    function initialize(InitParams memory params) public initializer {\n        __Governor_init(\"SecurityCouncilNomineeElectionGovernor\");\n        __GovernorVotes_init(params.token);\n        __SecurityCouncilNomineeElectionGovernorCounting_init();\n        __ArbitrumGovernorVotesQuorumFraction_init(params.quorumNumeratorValue);\n        __GovernorSettings_init(0, params.votingPeriod, 0); // votingDelay and proposalThreshold are set to 0\n        __SecurityCouncilNomineeElectionGovernorTiming_init(\n            params.firstNominationStartDate, params.nomineeVettingDuration\n        );\n        _transferOwnership(params.owner);\n\n        nomineeVetter = params.nomineeVetter;\n        if (!Address.isContract(address(params.securityCouncilManager))) {\n            revert NotAContract(address(params.securityCouncilManager));\n        }\n        securityCouncilManager = params.securityCouncilManager;\n        if (!Address.isContract(address(params.securityCouncilMemberElectionGovernor))) {\n            revert NotAContract(address(params.securityCouncilMemberElectionGovernor));\n        }\n        securityCouncilMemberElectionGovernor = params.securityCouncilMemberElectionGovernor;\n\n        // elsewhere we make assumptions that the number of nominees\n        // is not greater than 500\n        // This value can still be updated via updateQuorumNumerator to a lower value\n        // if it is deemed ok, however we put a quick check here as a reminder\n        if ((quorumDenominator() / params.quorumNumeratorValue) > 500) {\n            revert QuorumNumeratorTooLow(params.quorumNumeratorValue);\n        }\n    }\n\n    /// @notice Allows the nominee vetter to call certain functions\n    modifier onlyNomineeVetter() {\n        if (msg.sender != nomineeVetter) {\n            revert OnlyNomineeVetter();\n        }\n        _;\n    }\n\n    /// @notice Some operations can only be performed during the vetting period.\n    modifier onlyVettingPeriod(uint256 proposalId) {\n        // voting is over and the proposal must have succeeded, not active or executed\n        ProposalState state_ = state(proposalId);\n        if (state_ != ProposalState.Succeeded) {\n            revert ProposalNotSucceededState(state_);\n        }\n\n        // the proposal must not have passed the vetting deadline\n        uint256 vettingDeadline = proposalVettingDeadline(proposalId);\n        if (block.number > vettingDeadline) {\n            revert ProposalNotInVettingPeriod(block.number, vettingDeadline);\n        }\n\n        _;\n    }\n\n    /// @notice Creates a new nominee election proposal.\n    ///         Can be called by anyone every 6 months.\n    /// @return proposalId The id of the proposal\n    function createElection() external returns (uint256 proposalId) {\n        // require that the last member election has executed\n        _requireLastMemberElectionHasExecuted();\n\n        // each election has a deterministic start time\n        uint256 thisElectionStartTs = electionToTimestamp(electionCount);\n        if (block.timestamp < thisElectionStartTs) {\n            revert CreateTooEarly(block.timestamp, thisElectionStartTs);\n        }\n\n        (\n            address[] memory targets,\n            uint256[] memory values,\n            bytes[] memory callDatas,\n            string memory description\n        ) = getProposeArgs(electionCount);\n\n        proposalId = GovernorUpgradeable.propose(targets, values, callDatas, description);\n\n        electionCount++;\n    }\n\n    /// @dev Revert if the previous member election has not executed.\n    ///      Ensures that there are no unexpected behaviors from multiple elections running at the same time.\n    ///      If, for some reason, the previous member election is blocked,\n    ///      it is up to the security council or DAO to unblock the previous election before creating a new one.\n    function _requireLastMemberElectionHasExecuted() internal view {\n        if (electionCount == 0) {\n            return;\n        }\n\n        (\n            address[] memory prevTargets,\n            uint256[] memory prevValues,\n            bytes[] memory prevCallDatas,\n            string memory prevDescription\n        ) = getProposeArgs(electionCount - 1);\n\n        uint256 prevProposalId =\n            hashProposal(prevTargets, prevValues, prevCallDatas, keccak256(bytes(prevDescription)));\n\n        if (\n            IGovernorUpgradeable(address(securityCouncilMemberElectionGovernor)).state(\n                prevProposalId\n            ) != ProposalState.Executed\n        ) {\n            revert LastMemberElectionNotExecuted(prevProposalId);\n        }\n    }\n\n    /// @notice Put `msg.sender` up for nomination. Must be called before a contender can receive votes.\n    ///         Contenders are expected to control an address than can create a signature that would be a\n    ///         recognised by a Gnosis Safe. They need to be able to do this with this same address on each of the\n    ///         chains where the Security Council is active. It is expected that the nominee vetter will check this\n    ///         during the vetting phase and exclude any contenders which dont meet this criteria.\n    /// @dev    Can be called only while a proposal is active (in voting phase)\n    ///         A contender cannot be a member of the opposite cohort.\n    function addContender(uint256 proposalId) external {\n        ElectionInfo storage election = _elections[proposalId];\n\n        if (election.isContender[msg.sender]) {\n            revert AlreadyContender(msg.sender);\n        }\n\n        ProposalState state_ = state(proposalId);\n        if (state_ != ProposalState.Active) {\n            revert ProposalNotActive(state_);\n        }\n\n        // check to make sure the contender is not part of the other cohort (the cohort not currently up for election)\n        // this only checks against the current the current other cohort, and against the current cohort membership\n        // in the security council, so changes to those will mean this check will be inconsistent.\n        // this check then is only a relevant check when the elections are running as expected - one at a time,\n        // every 6 months. Updates to the sec council manager using methods other than replaceCohort can effect this check\n        // and it's expected that the entity making those updates understands this.\n        if (securityCouncilManager.cohortIncludes(otherCohort(), msg.sender)) {\n            revert AccountInOtherCohort(otherCohort(), msg.sender);\n        }\n\n        election.isContender[msg.sender] = true;\n\n        emit ContenderAdded(proposalId, msg.sender);\n    }\n\n    /// @notice Allows the owner to change the nomineeVetter\n    function setNomineeVetter(address _nomineeVetter) external onlyGovernance {\n        address oldNomineeVetter = nomineeVetter;\n        nomineeVetter = _nomineeVetter;\n        emit NomineeVetterChanged(oldNomineeVetter, _nomineeVetter);\n    }\n\n    /// @notice Allows the owner to make calls from the governor\n    /// @dev    See {L2ArbitrumGovernor-relay}\n    function relay(address target, uint256 value, bytes calldata data)\n        external\n        virtual\n        override\n        onlyOwner\n    {\n        AddressUpgradeable.functionCallWithValue(target, data, value);\n    }\n\n    /// @notice Allows the nomineeVetter to exclude a noncompliant nominee.\n    /// @dev    Can be called only after a nomninee election proposal has \"succeeded\" (voting has ended) and before the nominee vetting period has ended.\n    ///         Will revert if the provided account is not a nominee (had less than the required votes).\n    function excludeNominee(uint256 proposalId, address nominee)\n        external\n        onlyNomineeVetter\n        onlyVettingPeriod(proposalId)\n    {\n        ElectionInfo storage election = _elections[proposalId];\n        if (election.isExcluded[nominee]) {\n            revert NomineeAlreadyExcluded(nominee);\n        }\n        if (!isNominee(proposalId, nominee)) {\n            revert NotNominee(nominee);\n        }\n\n        election.isExcluded[nominee] = true;\n        election.excludedNomineeCount++;\n\n        emit NomineeExcluded(proposalId, nominee);\n    }\n\n    /// @notice Allows the nomineeVetter to explicitly include a nominee if there are fewer nominees than the target.\n    /// @dev    Can be called only when a proposal is succeeded (voting has ended) and there are fewer compliant nominees than the target.\n    ///         Will revert if the provided account is already a nominee\n    ///         The Constitution must be followed adding nominees. For example this method can be used by the Foundation to add a\n    ///         random member of the outgoing security council, if less than 6 members meet the threshold to become a nominee\n    function includeNominee(uint256 proposalId, address account) external onlyNomineeVetter {\n        ProposalState state_ = state(proposalId);\n        if (state_ != ProposalState.Succeeded) {\n            revert ProposalNotSucceededState(state_);\n        }\n\n        if (isNominee(proposalId, account)) {\n            revert NomineeAlreadyAdded(account);\n        }\n\n        uint256 cnCount = compliantNomineeCount(proposalId);\n        uint256 cohortSize = securityCouncilManager.cohortSize();\n        if (cnCount >= cohortSize) {\n            revert CompliantNomineeTargetHit(cnCount, cohortSize);\n        }\n\n        // can't include nominees from the other cohort (the cohort not currently up for election)\n        // this only checks against the current the current other cohort, and against the current cohort membership\n        // in the security council, so changes to those will mean this check will be inconsistent.\n        // this check then is only a relevant check when the elections are running as expected - one at a time,\n        // every 6 months. Updates to the sec council manager using methods other than replaceCohort can effect this check\n        // and it's expected that the entity making those updates understands this.\n        if (securityCouncilManager.cohortIncludes(otherCohort(), account)) {\n            revert AccountInOtherCohort(otherCohort(), account);\n        }\n\n        _addNominee(proposalId, account);\n    }\n\n    /// @dev    `GovernorUpgradeable` function to execute a proposal overridden to handle nominee elections.\n    ///         Can be called by anyone via `execute` after voting and nominee vetting periods have ended.\n    ///         If the number of compliant nominees is > the target number of nominees,\n    ///         we move on to the next phase by calling the SecurityCouncilMemberElectionGovernor.\n    /// @param  proposalId The id of the proposal\n    function _execute(\n        uint256 proposalId,\n        address[] memory, /* targets */\n        uint256[] memory, /* values */\n        bytes[] memory callDatas,\n        bytes32 /*descriptionHash*/\n    ) internal virtual override {\n        // we can only execute when the vetting deadline has passed\n        uint256 vettingDeadline = proposalVettingDeadline(proposalId);\n        if (block.number <= vettingDeadline) {\n            revert ProposalInVettingPeriod(block.number, vettingDeadline);\n        }\n\n        uint256 cnCount = compliantNomineeCount(proposalId);\n        uint256 cohortSize = securityCouncilManager.cohortSize();\n        if (cnCount < cohortSize) {\n            revert InsufficientCompliantNomineeCount(cnCount, cohortSize);\n        }\n\n        uint256 electionIndex = extractElectionIndex(callDatas);\n        uint256 memberElectionProposalId =\n            securityCouncilMemberElectionGovernor.proposeFromNomineeElectionGovernor(electionIndex);\n\n        // proposals in the member and nominee governors should have the same ids\n        // so we do a safety check here to ensure this is the case\n        if (memberElectionProposalId != proposalId) {\n            revert ProposalIdMismatch(proposalId, memberElectionProposalId);\n        }\n    }\n\n    /// @notice Normally \"the number of votes required in order for a voter to become a proposer.\" But in our case it is 0.\n    /// @dev    Since we only want proposals to be created via `createElection`, we set the proposal threshold to 0.\n    ///         `createElection` determines the rules for creating a proposal.\n    function proposalThreshold()\n        public\n        view\n        virtual\n        override(GovernorSettingsUpgradeable, GovernorUpgradeable)\n        returns (uint256)\n    {\n        return 0;\n    }\n\n    /// @inheritdoc ISecurityCouncilNomineeElectionGovernor\n    function isCompliantNominee(uint256 proposalId, address account) public view returns (bool) {\n        return isNominee(proposalId, account) && !_elections[proposalId].isExcluded[account];\n    }\n\n    /// @inheritdoc ISecurityCouncilNomineeElectionGovernor\n    function compliantNominees(uint256 proposalId) public view returns (address[] memory) {\n        ElectionInfo storage election = _elections[proposalId];\n        address[] memory maybeCompliantNominees =\n            SecurityCouncilNomineeElectionGovernorCountingUpgradeable.nominees(proposalId);\n        return SecurityCouncilMgmtUtils.filterAddressesWithExcludeList(\n            maybeCompliantNominees, election.isExcluded\n        );\n    }\n\n    /// @notice Current number of compliant nominees for the proposal\n    function compliantNomineeCount(uint256 proposalId) public view returns (uint256) {\n        return nomineeCount(proposalId) - _elections[proposalId].excludedNomineeCount;\n    }\n\n    /// @notice Returns cohort currently up for election\n    function currentCohort() public view returns (Cohort) {\n        // current cohort is at electionCount - 1\n        return electionCount == 0 ? Cohort.FIRST : electionIndexToCohort(electionCount - 1);\n    }\n\n    /// @notice Returns cohort not currently up for election\n    function otherCohort() public view returns (Cohort) {\n        // previous cohort is at electionCount - 2\n        return (electionCount < 2) ? Cohort.SECOND : electionIndexToCohort(electionCount - 2);\n    }\n\n    /// @notice returns true if the nominee has been excluded by the nomineeVetter for the given proposal\n    function isExcluded(uint256 proposalId, address possibleExcluded) public view returns (bool) {\n        return _elections[proposalId].isExcluded[possibleExcluded];\n    }\n\n    /// @notice returns the number of excluded nominees for the given proposal\n    function excludedNomineeCount(uint256 proposalId) public view returns (uint256) {\n        return _elections[proposalId].excludedNomineeCount;\n    }\n\n    /// @inheritdoc SecurityCouncilNomineeElectionGovernorCountingUpgradeable\n    function isContender(uint256 proposalId, address possibleContender)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return _elections[proposalId].isContender[possibleContender];\n    }\n\n    /// @notice Always reverts.\n    /// @dev    `GovernorUpgradeable` function to create a proposal overridden to just revert.\n    ///         We only want proposals to be created via `createElection`.\n    function propose(address[] memory, uint256[] memory, bytes[] memory, string memory)\n        public\n        virtual\n        override\n        returns (uint256)\n    {\n        revert ProposeDisabled();\n    }\n\n    /// @notice Always reverts. Use castVoteWithReasonAndParams instead\n    function castVote(uint256, uint8) public virtual override returns (uint256) {\n        revert CastVoteDisabled();\n    }\n\n    /// @notice Always reverts. Use castVoteWithReasonAndParams instead\n    function castVoteWithReason(uint256, uint8, string calldata)\n        public\n        virtual\n        override\n        returns (uint256)\n    {\n        revert CastVoteDisabled();\n    }\n\n    /// @notice Always reverts. Use castVoteWithReasonAndParamsBySig instead\n    function castVoteBySig(uint256, uint8, uint8, bytes32, bytes32)\n        public\n        virtual\n        override\n        returns (uint256)\n    {\n        revert CastVoteDisabled();\n    }\n}"
    },
    {
      "filename": "src/security-council-mgmt/governors/SecurityCouncilNomineeElectionGovernor.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorSettingsUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../interfaces/ISecurityCouncilMemberElectionGovernor.sol\";\nimport \"../interfaces/ISecurityCouncilNomineeElectionGovernor.sol\";\nimport \"./modules/SecurityCouncilNomineeElectionGovernorCountingUpgradeable.sol\";\nimport \"./modules/ArbitrumGovernorVotesQuorumFractionUpgradeable.sol\";\nimport \"./modules/SecurityCouncilNomineeElectionGovernorTiming.sol\";\nimport \"./modules/ElectionGovernor.sol\";\nimport \"../SecurityCouncilMgmtUtils.sol\";\n\n/// @title SecurityCouncilNomineeElectionGovernor\n/// @notice Governor contract for selecting Security Council Nominees (phase 1 of the Security Council election process).\ncontract SecurityCouncilNomineeElectionGovernor is\n    Initializable,\n    GovernorUpgradeable,\n    GovernorVotesUpgradeable,\n    SecurityCouncilNomineeElectionGovernorCountingUpgradeable,\n    ArbitrumGovernorVotesQuorumFractionUpgradeable,\n    GovernorSettingsUpgradeable,\n    OwnableUpgradeable,\n    SecurityCouncilNomineeElectionGovernorTiming,\n    ElectionGovernor,\n    ISecurityCouncilNomineeElectionGovernor\n{\n    /// @notice parameters for `initialize`\n    /// @param firstNominationStartDate First election start date\n    /// @param nomineeVettingDuration Duration of the nominee vetting period (expressed in blocks)\n    /// @param nomineeVetter Address of the nominee vetter\n    /// @param securityCouncilManager Security council manager contract\n    /// @param token Token used for voting\n    /// @param owner Owner of the governor (the Arbitrum DAO)\n    /// @param quorumNumeratorValue Numerator of the quorum fraction (0.2% = 20)\n    /// @param votingPeriod Duration of the voting period (expressed in blocks)\n    ///                     Note that the voting period + nominee vetting duration must be << than 6 months to ensure elections dont overlap\n    struct InitParams {\n        Date firstNominationStartDate;\n        uint256 nomineeVettingDuration;\n        address nomineeVetter;\n        ISecurityCouncilManager securityCouncilManager;\n        ISecurityCouncilMemberElectionGovernor securityCouncilMemberElectionGovernor;\n        IVotesUpgradeable token;\n        address owner;\n        uint256 quorumNumeratorValue;\n        uint256 votingPeriod;\n    }\n\n    /// @notice Information about a nominee election\n    /// @param isContender Whether the account is a contender\n    /// @param isExcluded Whether the account has been excluded by the nomineeVetter\n    /// @param excludedNomineeCount The number of nominees that have been excluded by the nomineeVetter\n    struct ElectionInfo {\n        mapping(address => bool) isContender;\n        mapping(address => bool) isExcluded;\n        uint256 excludedNomineeCount;\n    }\n\n    /// @notice Address responsible for blocking non compliant nominees\n    address public nomineeVetter;\n\n    /// @notice Security council manager contract\n    /// @dev    Used to execute the election result immediately if <= 6 compliant nominees are chosen\n    ISecurityCouncilManager public securityCouncilManager;\n\n    /// @notice Security council member election governor contract\n    ISecurityCouncilMemberElectionGovernor public securityCouncilMemberElectionGovernor;\n\n    /// @notice Number of elections created\n    uint256 public electionCount;\n\n    /// @notice Maps proposalId to ElectionInfo\n    mapping(uint256 => ElectionInfo) internal _elections;\n\n    event NomineeVetterChanged(address indexed oldNomineeVetter, address indexed newNomineeVetter);\n    event ContenderAdded(uint256 indexed proposalId, address indexed contender);\n    event NomineeExcluded(uint256 indexed proposalId, address indexed nominee);\n\n    error OnlyNomineeVetter();\n    error CreateTooEarly(uint256 blockTimestamp, uint256 startTime);\n    error AlreadyContender(address contender);\n    error ProposalNotActive(ProposalState state);\n    error AccountInOtherCohort(Cohort cohort, address account);\n    error ProposalNotSucceededState(ProposalState state);\n    error ProposalNotInVettingPeriod(uint256 blockNumber, uint256 vettingDeadline);\n    error NomineeAlreadyExcluded(address nominee);\n    error CompliantNomineeTargetHit(uint256 nomineeCount, uint256 expectedCount);\n    error ProposalInVettingPeriod(uint256 blockNumber, uint256 vettingDeadline);\n    error InsufficientCompliantNomineeCount(uint256 compliantNomineeCount, uint256 expectedCount);\n    error ProposeDisabled();\n    error NotNominee(address nominee);\n    error ProposalIdMismatch(uint256 nomineeProposalId, uint256 memberProposalId);\n    error QuorumNumeratorTooLow(uint256 quorumNumeratorValue);\n    error CastVoteDisabled();\n    error LastMemberElectionNotExecuted(uint256 prevProposalId);\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the governor\n    function initialize(InitParams memory params) public initializer {\n        __Governor_init(\"SecurityCouncilNomineeElectionGovernor\");\n        __GovernorVotes_init(params.token);\n        __SecurityCouncilNomineeElectionGovernorCounting_init();\n        __ArbitrumGovernorVotesQuorumFraction_init(params.quorumNumeratorValue);\n        __GovernorSettings_init(0, params.votingPeriod, 0); // votingDelay and proposalThreshold are set to 0\n        __SecurityCouncilNomineeElectionGovernorTiming_init(\n            params.firstNominationStartDate, params.nomineeVettingDuration\n        );\n        _transferOwnership(params.owner);\n\n        nomineeVetter = params.nomineeVetter;\n        if (!Address.isContract(address(params.securityCouncilManager))) {\n            revert NotAContract(address(params.securityCouncilManager));\n        }\n        securityCouncilManager = params.securityCouncilManager;\n        if (!Address.isContract(address(params.securityCouncilMemberElectionGovernor))) {\n            revert NotAContract(address(params.securityCouncilMemberElectionGovernor));\n        }\n        securityCouncilMemberElectionGovernor = params.securityCouncilMemberElectionGovernor;\n\n        // elsewhere we make assumptions that the number of nominees\n        // is not greater than 500\n        // This value can still be updated via updateQuorumNumerator to a lower value\n        // if it is deemed ok, however we put a quick check here as a reminder\n        if ((quorumDenominator() / params.quorumNumeratorValue) > 500) {\n            revert QuorumNumeratorTooLow(params.quorumNumeratorValue);\n        }\n    }\n\n    /// @notice Allows the nominee vetter to call certain functions\n    modifier onlyNomineeVetter() {\n        if (msg.sender != nomineeVetter) {\n            revert OnlyNomineeVetter();\n        }\n        _;\n    }\n\n    /// @notice Some operations can only be performed during the vetting period.\n    modifier onlyVettingPeriod(uint256 proposalId) {\n        // voting is over and the proposal must have succeeded, not active or executed\n        ProposalState state_ = state(proposalId);\n        if (state_ != ProposalState.Succeeded) {\n            revert ProposalNotSucceededState(state_);\n        }\n\n        // the proposal must not have passed the vetting deadline\n        uint256 vettingDeadline = proposalVettingDeadline(proposalId);\n        if (block.number > vettingDeadline) {\n            revert ProposalNotInVettingPeriod(block.number, vettingDeadline);\n        }\n\n        _;\n    }\n\n    /// @notice Creates a new nominee election proposal.\n    ///         Can be called by anyone every 6 months.\n    /// @return proposalId The id of the proposal\n    function createElection() external returns (uint256 proposalId) {\n        // require that the last member election has executed\n        _requireLastMemberElectionHasExecuted();\n\n        // each election has a deterministic start time\n        uint256 thisElectionStartTs = electionToTimestamp(electionCount);\n        if (block.timestamp < thisElectionStartTs) {\n            revert CreateTooEarly(block.timestamp, thisElectionStartTs);\n        }\n\n        (\n            address[] memory targets,\n            uint256[] memory values,\n            bytes[] memory callDatas,\n            string memory description\n        ) = getProposeArgs(electionCount);\n\n        proposalId = GovernorUpgradeable.propose(targets, values, callDatas, description);\n\n        electionCount++;\n    }\n\n    /// @dev Revert if the previous member election has not executed.\n    ///      Ensures that there are no unexpected behaviors from multiple elections running at the same time.\n    ///      If, for some reason, the previous member election is blocked,\n    ///      it is up to the security council or DAO to unblock the previous election before creating a new one.\n    function _requireLastMemberElectionHasExecuted() internal view {\n        if (electionCount == 0) {\n            return;\n        }\n\n        (\n            address[] memory prevTargets,\n            uint256[] memory prevValues,\n            bytes[] memory prevCallDatas,\n            string memory prevDescription\n        ) = getProposeArgs(electionCount - 1);\n\n        uint256 prevProposalId =\n            hashProposal(prevTargets, prevValues, prevCallDatas, keccak256(bytes(prevDescription)));\n\n        if (\n            IGovernorUpgradeable(address(securityCouncilMemberElectionGovernor)).state(\n                prevProposalId\n            ) != ProposalState.Executed\n        ) {\n            revert LastMemberElectionNotExecuted(prevProposalId);\n        }\n    }\n\n    /// @notice Put `msg.sender` up for nomination. Must be called before a contender can receive votes.\n    ///         Contenders are expected to control an address than can create a signature that would be a\n    ///         recognised by a Gnosis Safe. They need to be able to do this with this same address on each of the\n    ///         chains where the Security Council is active. It is expected that the nominee vetter will check this\n    ///         during the vetting phase and exclude any contenders which dont meet this criteria.\n    /// @dev    Can be called only while a proposal is active (in voting phase)\n    ///         A contender cannot be a member of the opposite cohort.\n    function addContender(uint256 proposalId) external {\n        ElectionInfo storage election = _elections[proposalId];\n\n        if (election.isContender[msg.sender]) {\n            revert AlreadyContender(msg.sender);\n        }\n\n        ProposalState state_ = state(proposalId);\n        if (state_ != ProposalState.Active) {\n            revert ProposalNotActive(state_);\n        }\n\n        // check to make sure the contender is not part of the other cohort (the cohort not currently up for election)\n        // this only checks against the current the current other cohort, and against the current cohort membership\n        // in the security council, so changes to those will mean this check will be inconsistent.\n        // this check then is only a relevant check when the elections are running as expected - one at a time,\n        // every 6 months. Updates to the sec council manager using methods other than replaceCohort can effect this check\n        // and it's expected that the entity making those updates understands this.\n        if (securityCouncilManager.cohortIncludes(otherCohort(), msg.sender)) {\n            revert AccountInOtherCohort(otherCohort(), msg.sender);\n        }\n\n        election.isContender[msg.sender] = true;\n\n        emit ContenderAdded(proposalId, msg.sender);\n    }\n\n    /// @notice Allows the owner to change the nomineeVetter\n    function setNomineeVetter(address _nomineeVetter) external onlyGovernance {\n        address oldNomineeVetter = nomineeVetter;\n        nomineeVetter = _nomineeVetter;\n        emit NomineeVetterChanged(o"
    }
  ]
}