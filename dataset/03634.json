{
  "Title": "Missing validation on relation",
  "Content": "##### Description\nAt the lines https://github.com/aave/governance-crosschain-bridges/blob/7f56e7ae63f30ba8dcd7ced6a11a34c2eb865a1d/contracts/BridgeExecutorBase.sol#L34-L39 are working with the variables `minimumDelay` and `maximumDelay`. But nowhere is there a comparison of these variables with each other.\n\n##### Recommendation\nIt is recommended to add a check for comparing the values of variables between each other.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/BridgeExecutorBase.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.7.5;\npragma abicoder v2;\n\nimport './dependencies/SafeMath.sol';\nimport './interfaces/IBridgeExecutor.sol';\n\nabstract contract BridgeExecutorBase is IBridgeExecutor {\n  using SafeMath for uint256;\n\n  uint256 public immutable override GRACE_PERIOD;\n  uint256 public immutable override MINIMUM_DELAY;\n  uint256 public immutable override MAXIMUM_DELAY;\n\n  uint256 private _actionsSetCounter;\n  address private _guardian;\n  uint256 private _delay;\n\n  mapping(uint256 => ActionsSet) private _actionsSets;\n  mapping(bytes32 => bool) private _queuedActions;\n\n  modifier onlyGuardian() {\n    require(msg.sender == _guardian, 'ONLY_BY_GUARDIAN');\n    _;\n  }\n\n  constructor(\n    uint256 delay,\n    uint256 gracePeriod,\n    uint256 minimumDelay,\n    uint256 maximumDelay,\n    address guardian\n  ) {\n    require(delay >= minimumDelay, 'DELAY_SHORTER_THAN_MINIMUM');\n    require(delay <= maximumDelay, 'DELAY_LONGER_THAN_MAXIMUM');\n    _delay = delay;\n    GRACE_PERIOD = gracePeriod;\n    MINIMUM_DELAY = minimumDelay;\n    MAXIMUM_DELAY = maximumDelay;\n\n    _guardian = guardian;\n\n    emit NewDelay(delay);\n  }\n\n  /**\n   * @dev Execute the ActionsSet\n   * @param actionsSetId id of the ActionsSet to execute\n   **/\n  function execute(uint256 actionsSetId) external payable override {\n    require(getActionsSetState(actionsSetId) == ActionsSetState.Queued, 'ONLY_QUEUED_ACTIONS');\n\n    ActionsSet storage actionsSet = _actionsSets[actionsSetId];\n    require(block.timestamp >= actionsSet.executionTime, 'TIMELOCK_NOT_FINISHED');\n\n    actionsSet.executed = true;\n    for (uint256 i = 0; i < actionsSet.targets.length; i++) {\n      _executeTransaction(\n        actionsSet.targets[i],\n        actionsSet.values[i],\n        actionsSet.signatures[i],\n        actionsSet.calldatas[i],\n        actionsSet.executionTime,\n        actionsSet.withDelegatecalls[i]\n      );\n    }\n    emit ActionsSetExecuted(actionsSetId, msg.sender);\n  }\n\n  /**\n   * @dev Cancel the ActionsSet\n   * @param actionsSetId id of the ActionsSet to cancel\n   **/\n  function cancel(uint256 actionsSetId) external override onlyGuardian {\n    ActionsSetState state = getActionsSetState(actionsSetId);\n    require(state == ActionsSetState.Queued, 'ONLY_BEFORE_EXECUTED');\n\n    ActionsSet storage actionsSet = _actionsSets[actionsSetId];\n    actionsSet.canceled = true;\n    for (uint256 i = 0; i < actionsSet.targets.length; i++) {\n      _cancelTransaction(\n        actionsSet.targets[i],\n        actionsSet.values[i],\n        actionsSet.signatures[i],\n        actionsSet.calldatas[i],\n        actionsSet.executionTime,\n        actionsSet.withDelegatecalls[i]\n      );\n    }\n\n    emit ActionsSetCanceled(actionsSetId);\n  }\n\n  /**\n   * @dev Set the delay\n   * @param delay delay between queue and execution of an ActionsSet\n   **/\n  function setDelay(uint256 delay) public override onlyGuardian {\n    _validateDelay(delay);\n    _delay = delay;\n\n    emit NewDelay(delay);\n  }\n\n  /**\n   * @dev Get the ActionsSet by Id\n   * @param actionsSetId id of the ActionsSet\n   * @return the ActionsSet requested\n   **/\n  function getActionsSetById(uint256 actionsSetId)\n    external\n    view\n    override\n    returns (ActionsSet memory)\n  {\n    return _actionsSets[actionsSetId];\n  }\n\n  /**\n   * @dev Get the current state of an ActionsSet\n   * @param actionsSetId id of the ActionsSet\n   * @return The current state if the ActionsSet\n   **/\n  function getActionsSetState(uint256 actionsSetId) public view override returns (ActionsSetState) {\n    require(_actionsSetCounter >= actionsSetId, 'INVALID_ACTION_ID');\n    ActionsSet storage actionsSet = _actionsSets[actionsSetId];\n    if (actionsSet.canceled) {\n      return ActionsSetState.Canceled;\n    } else if (actionsSet.executed) {\n      return ActionsSetState.Executed;\n    } else if (block.timestamp > actionsSet.executionTime.add(GRACE_PERIOD)) {\n      return ActionsSetState.Expired;\n    } else {\n      return ActionsSetState.Queued;\n    }\n  }\n\n  /**\n   * @dev Returns whether an action (via actionHash) is queued\n   * @param actionHash hash of the action to be checked\n   * keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\n   * @return true if underlying action of actionHash is queued\n   **/\n  function isActionQueued(bytes32 actionHash) public view override returns (bool) {\n    return _queuedActions[actionHash];\n  }\n\n  /**\n   * @dev Receive Funds if necessary for delegate calls\n   **/\n  function receiveFunds() external payable {}\n\n  /**\n   * @dev Getter of the delay between queuing and execution\n   * @return The delay in seconds\n   **/\n  function getDelay() external view override returns (uint256) {\n    return _delay;\n  }\n\n  /**\n   * @dev Queue the ActionsSet - only callable by the BridgeMessageProvessor\n   * @param targets list of contracts called by each action's associated transaction\n   * @param values list of value in wei for each action's  associated transaction\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\n   **/\n  function _queue(\n    address[] memory targets,\n    uint256[] memory values,\n    string[] memory signatures,\n    bytes[] memory calldatas,\n    bool[] memory withDelegatecalls\n  ) internal {\n    require(targets.length != 0, 'INVALID_EMPTY_TARGETS');\n    require(\n      targets.length == values.length &&\n        targets.length == signatures.length &&\n        targets.length == calldatas.length &&\n        targets.length == withDelegatecalls.length,\n      'INCONSISTENT_PARAMS_LENGTH'\n    );\n\n    uint256 actionsSetId = _actionsSetCounter;\n    uint256 executionTime = block.timestamp.add(_delay);\n    _actionsSetCounter++;\n\n    for (uint256 i = 0; i < targets.length; i++) {\n      bytes32 actionHash =\n        keccak256(\n          abi.encode(\n            targets[i],\n            values[i],\n            signatures[i],\n            calldatas[i],\n            executionTime,\n            withDelegatecalls[i]\n          )\n        );\n      require(!isActionQueued(actionHash), 'DUPLICATED_ACTION');\n      _queuedActions[actionHash] = true;\n    }\n\n    ActionsSet storage actionsSet = _actionsSets[actionsSetId];\n    actionsSet.id = actionsSetId;\n    actionsSet.targets = targets;\n    actionsSet.values = values;\n    actionsSet.signatures = signatures;\n    actionsSet.calldatas = calldatas;\n    actionsSet.withDelegatecalls = withDelegatecalls;\n    actionsSet.executionTime = executionTime;\n\n    emit ActionsSetQueued(\n      actionsSetId,\n      targets,\n      values,\n      signatures,\n      calldatas,\n      withDelegatecalls,\n      executionTime\n    );\n  }\n\n  function _executeTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 executionTime,\n    bool withDelegatecall\n  ) internal {\n    bytes32 actionHash =\n      keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall));\n    _queuedActions[actionHash] = false;\n\n    bytes memory callData;\n\n    if (bytes(signature).length == 0) {\n      callData = data;\n    } else {\n      callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n    }\n\n    bool success;\n    bytes memory resultData;\n    if (withDelegatecall) {\n      require(msg.value >= value, 'NOT_ENOUGH_MSG_VALUE');\n      // solium-disable-next-line security/no-call-value\n      (success, resultData) = target.delegatecall(callData);\n    } else {\n      // solium-disable-next-line security/no-call-value\n      (success, resultData) = target.call{value: value}(callData);\n    }\n\n    require(success, 'FAILED_ACTION_EXECUTION');\n  }\n\n  function _cancelTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 executionTime,\n    bool withDelegatecall\n  ) internal {\n    bytes32 actionHash =\n      keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall));\n    _queuedActions[actionHash] = false;\n  }\n\n  function _validateDelay(uint256 delay) internal view {\n    require(delay >= MINIMUM_DELAY, 'DELAY_SHORTER_THAN_MINIMUM');\n    require(delay <= MAXIMUM_DELAY, 'DELAY_LONGER_THAN_MAXIMUM');\n  }\n}"
    }
  ]
}