{
  "Title": "Tokens Sharing an Address Across L1 and L2 Can Prevent Users From Bridging",
  "Content": "Users can call the `bridgeToken` function on the origin layer to start the bridging process. The `completeBridging` function can then be called on the destination layer to complete it. Bridges track tokens internally using their native address, defined as the address of the token on the chain from which it was first bridged. A token can thus only be native on either L1 or L2. If a token with the same address on L1 and L2 is encountered, a choice is made as to which token is the \"real\" native one by picking the first one that is bridged. It then [becomes impossible](https://github.com/Consensys/linea-contracts/blob/f08c1906855198e2dc0413a47dcb38291b7087e5/contracts/tokenBridge/TokenBridge.sol#L142) to bridge a token with the same address in the other direction.\n\n\nHowever, this mechanism can be exploited as a DOS attack to prevent users from bridging. This can be done as follows:\n\n\n1. An attacker deploys a token on L2 with the same address as a token on L1 which has not been bridged yet.\n2. The attacker calls `bridgeToken` on L2, followed by `completeBridging` on L1.\n3. The token is now considered native to L2, and users can [no longer bridge this token in the L1 to L2 direction](https://github.com/Consensys/linea-contracts/blob/f08c1906855198e2dc0413a47dcb38291b7087e5/contracts/tokenBridge/TokenBridge.sol#L142).\n\n\nA token can be deployed to the same address on L1 and L2 by using `create2`. At a high level, the issue above arises because of the assumption in the bridge logic that a token cannot be native on both chains. A solution would ideally result in two `bridgedToken` instances being deployed, one on each chain, each associated with its own native token.\n\n\nConsider using a different prevention method that allows native tokens to exist on both chains at the same address. Such changes would have to be end-to-end tested.\n\n\n***Update:** Resolved at commit [bb3691b](https://github.com/Consensys/linea-contracts-fix/commit/bb3691b67101e5cc9839b781af861defa81a2986#diff-25f3d0fec85d77ddb3f064f0d83dd452e62c913e4d3a558253315cd533998265R153).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/tokenBridge/TokenBridge.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.19;\n\nimport { ITokenBridge } from \"./interfaces/ITokenBridge.sol\";\nimport { IMessageService } from \"../interfaces/IMessageService.sol\";\n\nimport { IERC20PermitUpgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20PermitUpgradeable.sol\";\nimport { IERC20MetadataUpgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { SafeERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { BeaconProxy } from \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\n\nimport { BridgedToken } from \"./BridgedToken.sol\";\nimport { MessageServiceBase } from \"../messageService/MessageServiceBase.sol\";\n\n/**\n * @title Linea Canonical Token Bridge\n * @notice Contract to manage cross-chain ERC20 bridging.\n * @author ConsenSys Software Inc.\n */\ncontract TokenBridge is ITokenBridge, PausableUpgradeable, Ownable2StepUpgradeable, MessageServiceBase {\n  // solhint-disable-next-line var-name-mixedcase\n  bytes4 internal constant _PERMIT_SELECTOR =\n    bytes4(keccak256(bytes(\"permit(address,address,uint256,uint256,uint8,bytes32,bytes32)\")));\n\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  address public tokenBeacon;\n  mapping(address => address) public nativeToBridgedToken;\n  mapping(address => address) public bridgedToNativeToken;\n\n  // Special addresses used in the mappings to mark specific states for tokens.\n  /// @notice EMPTY means a token is not present in the mapping.\n  address internal constant EMPTY = address(0x0);\n  /// @notice RESERVED means a token is reserved and cannot be bridged.\n  address internal constant RESERVED_STATUS = address(0x111);\n  /// @notice NATIVE means a token is native to the current local chain.\n  address internal constant NATIVE_STATUS = address(0x222);\n  /// @notice DEPLOYED means the bridged token contract has been deployed on the remote chain.\n  address internal constant DEPLOYED_STATUS = address(0x333);\n\n  /// @dev Keep free storage slots for future implementation updates to avoid storage collision.\n  uint256[50] private __gap;\n\n  /// @dev Ensures the token has not been bridged before.\n  modifier isNewToken(address _token) {\n    if (nativeToBridgedToken[_token] != EMPTY || bridgedToNativeToken[_token] != EMPTY)\n      revert AlreadyBridgedToken(_token);\n    _;\n  }\n\n  /**\n   * @dev Ensures the address is not address(0).\n   * @param _addr Address to check.\n   */\n  modifier nonZeroAddress(address _addr) {\n    if (_addr == EMPTY) revert ZeroAddressNotAllowed();\n    _;\n  }\n  /**\n   * @dev Ensures the amount is not 0.\n   * @param _amount amount to check.\n   */\n  modifier nonZeroAmount(uint256 _amount) {\n    if (_amount == 0) revert ZeroAmountNotAllowed(_amount);\n    _;\n  }\n\n  /// @dev Disable constructor for safety\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @dev Contract will be used as proxy implementation.\n   * @param _messageService The address of the MessageService contract.\n   * @param _tokenBeacon The address of the tokenBeacon.\n   * @param _reservedTokens The list of reserved tokens to be set\n   */\n  function initialize(\n    address _securityCouncil,\n    address _messageService,\n    address _tokenBeacon,\n    address[] calldata _reservedTokens\n  ) external nonZeroAddress(_securityCouncil) nonZeroAddress(_messageService) nonZeroAddress(_tokenBeacon) initializer {\n    __Pausable_init();\n    __Ownable2Step_init();\n    __MessageServiceBase_init(_messageService);\n    tokenBeacon = _tokenBeacon;\n    for (uint256 i = 0; i < _reservedTokens.length; i++) {\n      if (_reservedTokens[i] == EMPTY) revert ZeroAddressNotAllowed();\n      setReserved(_reservedTokens[i]);\n    }\n    _transferOwnership(_securityCouncil);\n  }\n\n  /**\n   * @notice This function is the single entry point to bridge tokens to the\n   *   other chain, both for native and already bridged tokens. You can use it\n   *   to bridge any ERC20. If the token is bridged for the first time an ERC20\n   *   (BridgedToken.sol) will be automatically deployed on the target chain.\n   * @dev User should first allow the bridge to transfer tokens on his behalf.\n   *   Alternatively, you can use BridgeTokenWithPermit to do so in a single\n   *   transaction. If you want the transfer to be automatically executed on the\n   *   destination chain. You should send enough ETH to pay the postman fees.\n   *   Note that Linea can reserved some tokens (which use a dedicated bridge).\n   *   In this case, the token cannot be bridged. Linea can only reserved tokens\n   *   that are not been bridged yet.\n   *   Linea can pause the bridge for security reason. In this case new bridge\n   *   transaction would revert.\n   * @param _token The address of the token to be bridged.\n   * @param _amount The amount of the token to be bridged.\n   * @param _recipient The address that will receive the tokens on the other chain.\n   */\n  function bridgeToken(\n    address _token,\n    uint256 _amount,\n    address _recipient\n  ) public payable nonZeroAddress(_token) nonZeroAmount(_amount) whenNotPaused {\n    address nativeMappingValue = nativeToBridgedToken[_token];\n\n    if (nativeMappingValue == RESERVED_STATUS) {\n      // Token is reserved\n      revert ReservedToken(_token);\n    }\n\n    address bridgedMappingValue = bridgedToNativeToken[_token];\n    address nativeToken;\n    bytes memory tokenMetadata;\n    if (bridgedMappingValue != EMPTY) {\n      // Token is bridged\n      BridgedToken(_token).burn(msg.sender, _amount);\n      nativeToken = bridgedMappingValue;\n    } else {\n      // Token is native\n\n      // Make sure that this token has not been bridged as a native token from the other layer\n      // If this is the case nativeMappingValue should be EMPTY or DEPLOYED or NATIVE if not we revert\n      if (nativeMappingValue != EMPTY && nativeMappingValue != DEPLOYED_STATUS && nativeMappingValue != NATIVE_STATUS) {\n        revert TokenNativeOnOtherLayer(_token);\n      }\n\n      // For tokens with special fee logic, ensure that only the amount received\n      // by the bridge will be minted on the target chain.\n      uint256 balanceBefore = IERC20Upgradeable(_token).balanceOf(address(this));\n      IERC20Upgradeable(_token).safeTransferFrom(msg.sender, address(this), _amount);\n      _amount = IERC20Upgradeable(_token).balanceOf(address(this)) - balanceBefore;\n      nativeToken = _token;\n      if (nativeMappingValue == EMPTY) {\n        // New token\n        nativeToBridgedToken[_token] = NATIVE_STATUS;\n        emit NewToken(_token);\n      }\n\n      // Send Metadata only when the token has not been deployed on the other chain yet\n      if (nativeMappingValue != DEPLOYED_STATUS) {\n        tokenMetadata = abi.encode(_safeName(_token), _safeSymbol(_token), _safeDecimals(_token));\n      }\n    }\n\n    messageService.sendMessage{ value: msg.value }(\n      remoteSender,\n      msg.value, // fees\n      abi.encodeCall(ITokenBridge.completeBridging, (nativeToken, _amount, _recipient, tokenMetadata))\n    );\n    emit BridgingInitiated(msg.sender, _recipient, _token, _amount);\n  }\n\n  /**\n   * @notice Similar to `bridgeToken` function but allows to pass additional\n   *   permit data to do the ERC20 approval in a single transaction.\n   * @param _token The address of the token to be bridged.\n   * @param _amount The amount of the token to be bridged.\n   * @param _recipient The address that will receive the tokens on the other chain.\n   * @param _permitData The permit data for the token, if applicable.\n   */\n  function bridgeTokenWithPermit(\n    address _token,\n    uint256 _amount,\n    address _recipient,\n    bytes calldata _permitData\n  ) external payable nonZeroAddress(_token) nonZeroAmount(_amount) whenNotPaused {\n    if (_permitData.length != 0) {\n      _permit(_token, _permitData);\n    }\n    bridgeToken(_token, _amount, _recipient);\n  }\n\n  /**\n   * @dev It can only be called from the Message Service. To finalize the bridging\n   *   process, a user or postman needs to use the `claimMessage` function of the\n   *   Message Service to trigger the transaction.\n   * @param _nativeToken The address of the token on its native chain.\n   * @param _amount The amount of the token to be received.\n   * @param _recipient The address that will receive the tokens.\n   * @param _tokenMetadata Additional data used to deploy the bridged token if it\n   *   doesn't exist already.\n   */\n  function completeBridging(\n    address _nativeToken,\n    uint256 _amount,\n    address _recipient,\n    bytes calldata _tokenMetadata\n  ) external onlyMessagingService onlyAuthorizedRemoteSender {\n    address nativeMappingValue = nativeToBridgedToken[_nativeToken];\n    address bridgedToken;\n\n    if (nativeMappingValue == NATIVE_STATUS || nativeMappingValue == DEPLOYED_STATUS) {\n      // Token is native on the local chain\n      IERC20Upgradeable(_nativeToken).safeTransfer(_recipient, _amount);\n    } else {\n      bridgedToken = nativeMappingValue;\n      if (nativeMappingValue == EMPTY) {\n        // New token\n        bridgedToken = deployBridgedToken(_nativeToken, _tokenMetadata);\n        bridgedToNativeToken[bridgedToken] = _nativeToken;\n        nativeToBridgedToken[_nativeToken] = bridgedToken;\n      }\n      BridgedToken(bridgedToken).mint(_recipient, _amount);\n    }\n    emit BridgingFinalized(_nativeToken, bridgedToken, _amount, _recipient);\n  }\n\n  /**\n   * @dev Change the address of the Message Service.\n   * @param _messageService The address of the new Message Service.\n   */\n  function setMessageService(address _messageService) public onlyOwner {\n    address oldMessageService = address(messageService);\n    messageService = IMessageService(_messageService);\n    emit MessageServiceUpdated(_messageService, oldMessageService);\n  }\n\n  /**\n   * @dev Change the status to DEPLOYED to the tokens passed in parameter\n   *    Will call the method setDeployed on the other chain using the message Service\n   * @param _tokens Array of bridged tokens that have been deployed.\n   */\n  function confirmDeployment(address[] memory _tokens) external payable {\n    // Check that the tokens have actually been deployed\n    for (uint256 i; i < _tokens.length; i++) {\n      address nativeToken = bridgedToNativeToken[_tokens[i]];\n      if (nativeToken == EMPTY) {\n        revert TokenNotDeployed(_tokens[i]);\n      }\n      _tokens[i] = nativeToken;\n    }\n\n    messageService.sendMessage{ value: msg.value }(\n      remoteSender,\n      msg.value, // fees\n      abi.encodeCall(ITokenBridge.setDeployed, (_tokens))\n    );\n\n    emit DeploymentConfirmed(_tokens);\n  }\n\n  /**\n   * @dev Change the status of tokens to DEPLOYED. New bridge transaction will not\n   *   contain token metadata, which save gas.\n   *   Can only be called from the Message Service. A user or postman needs to use\n   *   the `claimMessage` function of the Message Service to trigger the transaction.\n   * @param _nativeTokens Array of native tokens for which the DEPLOYED status must be set.\n   */\n  function setDeployed(address[] memory _nativeTokens) external onlyMessagingService onlyAuthorizedRemoteSender {\n    address nativeToken;\n    for (uint256 i; i < _nativeTokens.length; i++) {\n      nativeToken = _nativeTokens[i];\n      nativeToBridgedToken[_nativeTokens[i]] = DEPLOYED_STATUS;\n      emit TokenDeployed(_nativeTokens[i]);\n    }\n  }\n\n  /**\n   * @dev Sets the address of the remote token bridge. Can only be called once.\n   * @param _remoteTokenBridge The address of the remote token bridge to be set.\n   */\n  function setRemoteTokenBridge(address _remoteTokenBridge) external onlyOwner {\n    if (remoteSender != EMPTY) revert RemoteTokenBridgeAlreadySet(remoteSender);\n    _setRemoteSender(_remoteTokenBridge);\n    emit RemoteTokenBridgeSet(_remoteTokenBridge);\n  }\n\n  /**\n   * @dev Deploy a new EC20 contract for bridged token using a beacon proxy pattern.\n   *   To adapt to future requirements, Linea can update the implementation of\n   *   all (existing and future) contracts by updating the beacon. This update is\n   *   subject to a by a time lock.\n   *   Contracts are deployed using CREATE2 so deployment address is deterministic.\n   * @param _nativeToken The address of the native token on the source chain.\n   * @param _tokenMetadata The encoded metadata for the token.\n   * @return The address of the newly deployed BridgedToken contract.\n   */\n  function deployBridgedToken(address _nativeToken, bytes calldata _tokenMetadata) internal returns (address) {\n    bytes32 _salt;\n    assembly {\n      _salt := _nativeToken\n    }\n    BeaconProxy bridgedToken = new BeaconProxy{ salt: _salt }(tokenBeacon, \"\");\n    address bridgedTokenAddress = address(bridgedToken);\n\n    (string memory name, string memory symbol, uint8 decimals) = abi.decode(_tokenMetadata, (string, string, uint8));\n    BridgedToken(bridgedTokenAddress).initialize(name, symbol, decimals);\n    emit NewTokenDeployed(bridgedTokenAddress);\n    return bridgedTokenAddress;\n  }\n\n  /**\n   * @dev Linea can reserved tokens. In this case, the token cannot be bridged.\n   *   Linea can only reserved tokens that are not been bridged before.\n   * @param _token The address of the token to be set as reserved.\n   */\n  function setReserved(address _token) public onlyOwner isNewToken(_token) nonZeroAddress(_token) {\n    nativeToBridgedToken[_token] = RESERVED_STATUS;\n    emit TokenReserved(_token);\n  }\n\n  /**\n   * @dev Removes a token from the reserved list.\n   * @param _token The address of the token to be removed from the reserved list.\n   */\n  function removeReserved(address _token) external onlyOwner {\n    if (nativeToBridgedToken[_token] != RESERVED_STATUS) revert NotReserved(_token);\n    nativeToBridgedToken[_token] = EMPTY;\n  }\n\n  /**\n   * @dev Linea can set a custom ERC20 contract for specific ERC20.\n   *   For security purpose, Linea can only call this function if the token has\n   *   not been bridged yet.\n   * @param _nativeToken The address of the token on the source chain.\n   * @param _targetContract The address of the custom contract.\n   */\n  function setCustomContract(\n    address _nativeToken,\n    address _targetContract\n  ) external onlyOwner isNewToken(_nativeToken) {\n    if (bridgedToNativeToken[_targetContract] != EMPTY) {\n      revert AlreadyBrigedToNativeTokenSet(_targetContract);\n    }\n    if (_targetContract == NATIVE_STATUS || _targetContract == DEPLOYED_STATUS || _targetContract == RESERVED_STATUS) {\n      revert StatusAddressNotAllowed(_targetContract);\n    }\n    nativeToBridgedToken[_nativeToken] = _targetContract;\n    bridgedToNativeToken[_targetContract] = _nativeToken;\n    emit CustomContractSet(_nativeToken, _targetContract);\n  }\n\n  /**\n   * @dev Pause the contract, can only be called by the owner.\n   */\n  function pause() external onlyOwner {\n    _pause();\n  }\n\n  /**\n   * @dev Unpause the contract, can only be called by the owner.\n   */\n  function unpause() external onlyOwner {\n    _unpause();\n  }\n\n  // Helpers to safely get the metadata from a token, inspired by\n  // https://github.com/traderjoe-xyz/joe-core/blob/main/contracts/MasterChefJoeV3.sol#L55-L95\n\n  /**\n   * @dev Provides a safe ERC20.name version which returns 'NO_NAME' as fallback string.\n   * @param _token The address of the ERC-20 token contract\n   * @param _token The address of the ERC-20 token contract.\n   */\n  function _safeName(address _token) internal view returns (string memory) {\n    (bool success, bytes memory data) = _token.staticcall(abi.encodeCall(IERC20MetadataUpgradeable.name, ()));\n    return success ? _returnDataToString(data) : \"NO_NAME\";\n  }\n\n  /**\n   * @dev Provides a safe ERC20.symbol version which returns 'NO_SYMBOL' as fallback string\n   * @param _token The address of the ERC-20 token contract\n   */\n  function _safeSymbol(address _token) internal view returns (string memory) {\n    (bool success, bytes memory data) = _token.staticcall(abi.encodeCall(IERC20MetadataUpgradeable.symbol, ()));\n    return success ? _returnDataToString(data) : \"NO_SYMBOL\";\n  }\n\n  /**\n   * @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.\n   *   Note Tokens with (decimals > 255) are not supported\n   * @param _token The address of the ERC-20 token contract\n   */\n  function _safeDecimals(address _token) internal view returns (uint8) {\n    (bool success, bytes memory data) = _token.staticcall(abi.encodeCall(IERC20MetadataUpgradeable.decimals, ()));\n    return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n  }\n\n  /**\n   * @dev Converts returned data to string. Returns 'NOT_VALID_ENCODING' as fallback value.\n   * @param _data returned data\n   */\n  function _returnDataToString(bytes memory _data) internal pure returns (string memory) {\n    if (_data.length >= 64) {\n      return abi.decode(_data, (string));\n    } else if (_data.length != 32) {\n      return \"UNKNOWN\";\n    }\n\n    // Since the strings on bytes32 are encoded left-right, check the first zero in the data\n    uint256 nonZeroBytes;\n    unchecked {\n      while (nonZeroBytes < 32 && _data[nonZeroBytes] != 0) {\n        nonZeroBytes++;\n      }\n    }\n\n    // If the first one is 0, we do not handle the encoding\n    if (nonZeroBytes == 0) {\n      return \"UNKNOWN\";\n    }\n    // Create a byte array with nonZeroBytes length\n    bytes memory bytesArray = new bytes(nonZeroBytes);\n    unchecked {\n      for (uint256 i = 0; i < nonZeroBytes; i++) {\n        bytesArray[i] = _data[i];\n      }\n    }\n    return string(bytesArray);\n  }\n\n  /**\n   * @notice Call the token permit method of extended ERC20\n   * @param _token ERC20 token address\n   * @param _permitData Raw data of the call `permit` of the token\n   */\n  function _permit(address _token, bytes calldata _permitData) internal {\n    if (bytes4(_permitData[:4]) != _PERMIT_SELECTOR)\n      revert InvalidPermitData(bytes4(_permitData[:4]), _PERMIT_SELECTOR);\n    // Decode the permit data\n    // The parameters are:\n    // 1. owner: The address of the wallet holding the tokens\n    // 2. spender: The address of the entity permitted to spend the tokens\n    // 3. value: The maximum amount of tokens the spender is allowed to spend\n    // 4. deadline: The time until which the permit is valid\n    // 5. v: Part of the signature (along with r and s), these three values form the signature of the permit\n    // 6. r: Part of the signature\n    // 7. s: Part of the signature\n    (address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) = abi.decode(\n      _permitData[4:],\n      (address, address, uint256, uint256, uint8, bytes32, bytes32)\n    );\n    if (owner != msg.sender) revert PermitNotFromSender(owner);\n    if (spender != address(this)) revert PermitNotAllowingBridge(spender);\n    IERC20PermitUpgradeable(_token).permit(msg.sender, address(this), amount, deadline, v, r, s);\n  }\n}"
    },
    {
      "filename": "contracts/tokenBridge/TokenBridge.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.19;\n\nimport { ITokenBridge } from \"./interfaces/ITokenBridge.sol\";\nimport { IMessageService } from \"../interfaces/IMessageService.sol\";\n\nimport { IERC20PermitUpgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20PermitUpgradeable.sol\";\nimport { IERC20MetadataUpgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { SafeERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { BeaconProxy } from \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\n\nimport { BridgedToken } from \"./BridgedToken.sol\";\nimport { MessageServiceBase } from \"../messageService/MessageServiceBase.sol\";\n\n/**\n * @title Linea Canonical Token Bridge\n * @notice Contract to manage cross-chain ERC20 bridging.\n * @author ConsenSys Software Inc.\n */\ncontract TokenBridge is ITokenBridge, PausableUpgradeable, Ownable2StepUpgradeable, MessageServiceBase {\n  // solhint-disable-next-line var-name-mixedcase\n  bytes4 internal constant _PERMIT_SELECTOR =\n    bytes4(keccak256(bytes(\"permit(address,address,uint256,uint256,uint8,bytes32,bytes32)\")));\n\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  address public tokenBeacon;\n  mapping(address => address) public nativeToBridgedToken;\n  mapping(address => address) public bridgedToNativeToken;\n\n  // Special addresses used in the mappings to mark specific states for tokens.\n  /// @notice EMPTY means a token is not present in the mapping.\n  address internal constant EMPTY = address(0x0);\n  /// @notice RESERVED means a token is reserved and cannot be bridged.\n  address internal constant RESERVED_STATUS = address(0x111);\n  /// @notice NATIVE means a token is native to the current local chain.\n  address internal constant NATIVE_STATUS = address(0x222);\n  /// @notice DEPLOYED means the bridged token contract has been deployed on the remote chain.\n  address internal constant DEPLOYED_STATUS = address(0x333);\n\n  /// @dev Keep free storage slots for future implementation updates to avoid storage collision.\n  uint256[50] private __gap;\n\n  /// @dev Ensures the token has not been bridged before.\n  modifier isNewToken(address _token) {\n    if (nativeToBridgedToken[_token] != EMPTY || bridgedToNativeToken[_token] != EMPTY)\n      revert AlreadyBridgedToken(_token);\n    _;\n  }\n\n  /**\n   * @dev Ensures the address is not address(0).\n   * @param _addr Address to check.\n   */\n  modifier nonZeroAddress(address _addr) {\n    if (_addr == EMPTY) revert ZeroAddressNotAllowed();\n    _;\n  }\n  /**\n   * @dev Ensures the amount is not 0.\n   * @param _amount amount to check.\n   */\n  modifier nonZeroAmount(uint256 _amount) {\n    if (_amount == 0) revert ZeroAmountNotAllowed(_amount);\n    _;\n  }\n\n  /// @dev Disable constructor for safety\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @dev Contract will be used as proxy implementation.\n   * @param _messageService The address of the MessageService contract.\n   * @param _tokenBeacon The address of the tokenBeacon.\n   * @param _reservedTokens The list of reserved tokens to be set\n   */\n  function initialize(\n    address _securityCouncil,\n    address _messageService,\n    address _tokenBeacon,\n    address[] calldata _reservedTokens\n  ) external nonZeroAddress(_securityCouncil) nonZeroAddress(_messageService) nonZeroAddress(_tokenBeacon) initializer {\n    __Pausable_init();\n    __Ownable2Step_init();\n    __MessageServiceBase_init(_messageService);\n    tokenBeacon = _tokenBeacon;\n    for (uint256 i = 0; i < _reservedTokens.length; i++) {\n      if (_reservedTokens[i] == EMPTY) revert ZeroAddressNotAllowed();\n      setReserved(_reservedTokens[i]);\n    }\n    _transferOwnership(_securityCouncil);\n  }\n\n  /**\n   * @notice This function is the single entry point to bridge tokens to the\n   *   other chain, both for native and already bridged tokens. You can use it\n   *   to bridge any ERC20. If the token is bridged for the first time an ERC20\n   *   (BridgedToken.sol) will be automatically deployed on the target chain.\n   * @dev User should first allow the bridge to transfer tokens on his behalf.\n   *   Alternatively, you can use BridgeTokenWithPermit to do so in a single\n   *   transaction. If you want the transfer to be automatically executed on the\n   *   destination chain. You should send enough ETH to pay the postman fees.\n   *   Note that Linea can reserved some tokens (which use a dedicated bridge).\n   *   In this case, the token cannot be bridged. Linea can only reserved tokens\n   *   that are not been bridged yet.\n   *   Linea can pause the bridge for security reason. In this case new bridge\n   *   transaction would revert.\n   * @param _token The address of the token to be bridged.\n   * @param _amount The amount of the token to be bridged.\n   * @param _recipient The address that will receive the tokens on the other chain.\n   */\n  function bridgeToken(\n    address _token,\n    uint256 _amount,\n    address _recipient\n  ) public payable nonZeroAddress(_token) nonZeroAmount(_amount) whenNotPaused {\n    address nativeMappingValue = nativeToBridgedToken[_token];\n\n    if (nativeMappingValue == RESERVED_STATUS) {\n      // Token is reserved\n      revert ReservedToken(_token);\n    }\n\n    address bridgedMappingValue = bridgedToNativeToken[_token];\n    address nativeToken;\n    bytes memory tokenMetadata;\n    if (bridgedMappingValue != EMPTY) {\n      // Token is bridged\n      BridgedToken(_token).burn(msg.sender, _amount);\n      nativeToken = bridgedMappingValue;\n    } else {\n      // Token is native\n\n      // Make sure that this token has not been bridged as a native token from the other layer\n      // If this is the case nativeMappingValue should be EMPTY or DEPLOYED or NATIVE if not we revert\n      if (nativeMappingValue != EMPTY && nativeMappingValue != DEPLOYED_STATUS && nativeMappingValue != NATIVE_STATUS) {\n        revert TokenNativeOnOtherLayer(_token);\n      }\n\n      // For tokens with special fee logic, ensure that only the amount received\n      // by the bridge will be minted on the target chain.\n      uint256 balanceBefore = IERC20Upgradeable(_token).balanceOf(address(this));\n      IERC20Upgradeable(_token).safeTransferFrom(msg.sender, address(this), _amount);\n      _amount = IERC20Upgradeable(_token).balanceOf(address(this)) - balanceBefore;\n      nativeToken = _token;\n      if (nativeMappingValue == EMPTY) {\n        // New token\n        nativeToBridgedToken[_token] = NATIVE_STATUS;\n        emit NewToken(_token);\n      }\n\n      // Send Metadata only when the token has not been deployed on the other chain yet\n      if (nativeMappingValue != DEPLOYED_STATUS) {\n        tokenMetadata = abi.encode(_safeName(_token), _safeSymbol(_token), _safeDecimals(_token));\n      }\n    }\n\n    messageService.sendMessage{ value: msg.value }(\n      remoteSender,\n      msg.value, // fees\n      abi.encodeCall(ITokenBridge.completeBridging, (nativeToken, _amount, _recipient, tokenMetadata))\n    );\n    emit BridgingInitiated(msg.sender, _recipient, _token, _amount);\n  }\n\n  /**\n   * @notice Similar to `bridgeToken` function but allows to pass additional\n   *   permit data to do the ERC20 approval in a single transaction.\n   * @param _token The address of the token to be bridged.\n   * @param _amount The amount of the token to be bridged.\n   * @param _recipient The address that will receive the tokens on the other chain.\n   * @param _permitData The permit data for the token, if applicable.\n   */\n  function bridgeTokenWithPermit(\n    address _token,\n    uint256 _amount,\n    address _recipient,\n    bytes calldata _permitData\n  ) external payable nonZeroAddress(_token) nonZeroAmount(_amount) whenNotPaused {\n    if (_permitData.length != 0) {\n      _permit(_token, _permitData);\n    }\n    bridgeToken(_token, _amount, _recipient);\n  }\n\n  /**\n   * @dev It can only be called from the Message Service. To finalize the bridging\n   *   process, a user or postman needs to use the `claimMessage` function of the\n   *   Message Service to trigger the transaction.\n   * @param _nativeToken The address of the token on its native chain.\n   * @param _amount The amount of the token to be received.\n   * @param _recipient The address that will receive the tokens.\n   * @param _tokenMetadata Additional data used to deploy the bridged token if it\n   *   doesn't exist already.\n   */\n  function completeBridging(\n    address _nativeToken,\n    uint256 _amount,\n    address _recipient,\n    bytes calldata _tokenMetadata\n  ) external onlyMessagingService onlyAuthorizedRemoteSender {\n    address nativeMappingValue = nativeToBridgedToken[_nativeToken];\n    address bridgedToken;\n\n    if (nativeMappingValue == NATIVE_STATUS || nativeMappingValue == DEPLOYED_STATUS) {\n      // Token is native on the local chain\n      IERC20Upgradeable(_nativeToken).safeTransfer(_recipient, _amount);\n    } else {\n      bridgedToken = nativeMappingValue;\n      if (nativeMappingValue == EMPTY) {\n        // New token\n        bridgedToken = deployBridgedToken(_nativeToken, _tokenMetadata);\n        bridgedToNativeToken[bridgedToken] = _nativeToken;\n        nativeToBridgedToken[_nativeToken] = bridgedToken;\n      }\n      BridgedToken(bridgedToken).mint(_recipient, _amount);\n    }\n    emit BridgingFinalized(_nativeToken, bridgedToken, _amount, _recipient);\n  }\n\n  /**\n   * @dev Change the address of the Message Service.\n   * @param _messageService The address of the new Message Service.\n   */\n  function setMessageService(address _messageService) public onlyOwner {\n    address oldMessageService = address(messageService);\n    messageService = IMessageService(_messageService);\n    emit MessageServiceUpdated(_messageService, oldMessageService);\n  }\n\n  /**\n   * @dev Change the status to DEPLOYED to the tokens passed in parameter\n   *    Will call the method setDeployed on the other chain using the message Service\n   * @param _tokens Array of bridged tokens that have been deployed.\n   */\n  function confirmDeployment(address[] memory _tokens) external payable {\n    // Check that the tokens have actually been deployed\n    for (uint256 i; i < _tokens.length; i++) {\n      address nativeToken = bridgedToNativeToken[_tokens[i]];\n      if (nativeToken == EMPTY) {\n        revert TokenNotDeployed(_tokens[i]);\n      }\n      _tokens[i] = nativeToken;\n    }\n\n    messageService.sendMessage{ value: msg.value }(\n      remoteSender,\n      msg.value, // fees\n      abi.encodeCall(ITokenBridge.setDeployed, (_tokens))\n    );\n\n    emit DeploymentConfirmed(_tokens);\n  }\n\n  /**\n   * @dev Change the status of tokens to DEPLOYED. New bridge transaction will not\n   *   contain token metadata, which save gas.\n   *   Can only be called from the Message Service. A user or postman needs to use\n   *   the `claimMessage` function of the Message Service to trigger the transaction.\n   * @param _nativeTokens Array of native tokens for which the DEPLOYED status must be set.\n   */\n  function setDeployed(address[] memory _nativeTokens) external onlyMessagingService onlyAuthorizedRemoteSender {\n    address nativeToken;\n    for (uint256 i; i < _nativeTokens.length; i++) {\n      nativeToken = _nativeTokens[i];\n      nativeToBridgedToken[_nativeTokens[i]] = DEPLOYED_STATUS;\n      emit TokenDeployed(_nativeTokens[i]);\n    }\n  }\n\n  /**\n   * @dev Sets the address of the remote token bridge. Can only be called once.\n   * @param _remoteTokenBridge The address of the remote token bridge to be set.\n   */\n  function setRemoteTokenBridge(address _remoteTokenBridge) external onlyOwner {\n    if (remoteSender != EMPTY) revert RemoteTokenBridgeAlreadySet(remoteSender);\n    _setRemoteSender(_remoteTokenBridge);\n    emit RemoteTokenBridgeSet(_remoteTokenBridge);\n  }\n\n  /**\n   * @dev Deploy a new EC20 contract for bridged token using a beacon proxy pattern.\n   *   To adapt to future requirements, Linea can update the implementation of\n   *   all (existing and future) contracts by updating the beacon. This update is\n   *   subject to a by a time lock.\n   *   Contracts are deployed using CREATE2 so deployment address is deterministic.\n   * @param _nativeToken The address of the native token on the source chain.\n   * @param _tokenMetadata The encoded metadata for the token.\n   * @return The address of the newly deployed BridgedToken contract.\n   */\n  function deployBridgedToken(address _nativeToken, bytes calldata _tokenMetadata) internal returns (address) {\n    bytes32 _salt;\n    assembly {\n      _salt := _nativeToken\n    }\n    BeaconProxy bridgedToken = new BeaconProxy{ salt: _salt }(tokenBeacon, \"\");\n    address bridgedTokenAddress = address(bridgedToken);\n\n    (string memory name, string memory symbol, uint8 decimals) = abi.decode(_tokenMetadata, (string, string, uint8));\n    BridgedToken(bridgedTokenAddress).initialize(name, symbol, decimals);\n    emit NewTokenDeployed(bridgedTokenAddress);\n    return bridgedTokenAddress;\n  }\n\n  /**\n   * @dev Linea can reserved tokens. In this case, the token cannot be bridged.\n   *   Linea can only reserved tokens that are no"
    }
  ]
}