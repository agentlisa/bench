{
  "Title": "[08] Setters should check if set the same value",
  "Content": "\nThe setter functions listed don't check if the new value is different from the old value.\n\n[`CoreRef::_setCore`](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/core/CoreRef.sol#L49-L54)\n\n```solidity\nfunction _setCore(address newCore) internal {\n    address oldCore = address(_core);\n    // @audit-info no check if old == new \n    _core = Core(newCore);\n\n    emit CoreUpdate(oldCore, newCore);\n}\n```\n\n[`GuildGovernor::_setQuorum`](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/governance/GuildGovernor.sol#L68-L71)\n\n```solidity\nfunction _setQuorum(uint256 newQuorum) internal {\n    emit QuorumUpdated(_quorum, newQuorum);\n    // @audit-info no check if old == new\n    _quorum = newQuorum;\n}\n```\n\n[`GuildVetoGovernor::_setQuorum`](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/governance/GuildVetoGovernor.sol#L71-L74)\n\n```solidity\nfunction _setQuorum(uint256 newQuorum) internal virtual {\n    emit QuorumUpdated(_quorum, newQuorum);\n    // @audit-info old == new check\n    _quorum = newQuorum;\n}\n```\n\n[`GuildVetoGovernor::_updateTimelock`](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/governance/GuildVetoGovernor.sol#L99-L102)\n\n```\nfunction _updateTimelock(address newTimelock) private {\n    emit TimelockChange(timelock, newTimelock);\n    // @audit-info old == new check\n    timelock = newTimelock;\n}\n```\n\n### Recommendation\n\nAdd checks to verify that the new value is not equal to the old value.\n\n*** \n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-12-ethereumcreditguild",
  "Code": [
    {
      "filename": "src/core/CoreRef.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport {Core} from \"@src/core/Core.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\n\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\n\n/// @title A Reference to Core\n/// @author eswak\n/// @notice defines some modifiers and utilities around interacting with Core\nabstract contract CoreRef is Pausable {\n    /// @notice emitted when the reference to core is updated\n    event CoreUpdate(address indexed oldCore, address indexed newCore);\n\n    /// @notice reference to Core\n    Core private _core;\n\n    constructor(address coreAddress) {\n        _core = Core(coreAddress);\n    }\n\n    /// @notice named onlyCoreRole to prevent collision with OZ onlyRole modifier\n    modifier onlyCoreRole(bytes32 role) {\n        require(_core.hasRole(role, msg.sender), \"UNAUTHORIZED\");\n        _;\n    }\n\n    /// @notice address of the Core contract referenced\n    function core() public view returns (Core) {\n        return _core;\n    }\n\n    /// @notice WARNING CALLING THIS FUNCTION CAN POTENTIALLY\n    /// BRICK A CONTRACT IF CORE IS SET INCORRECTLY\n    /// @notice set new reference to core\n    /// only callable by governor\n    /// @param newCore to reference\n    function setCore(\n        address newCore\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        _setCore(newCore);\n    }\n\n    /// @notice WARNING CALLING THIS FUNCTION CAN POTENTIALLY\n    /// BRICK A CONTRACT IF CORE IS SET INCORRECTLY\n    /// @notice set new reference to core\n    /// @param newCore to reference\n    function _setCore(address newCore) internal {\n        address oldCore = address(_core);\n        _core = Core(newCore);\n\n        emit CoreUpdate(oldCore, newCore);\n    }\n\n    /// @notice set pausable methods to paused\n    function pause() public onlyCoreRole(CoreRoles.GUARDIAN) {\n        _pause();\n    }\n\n    /// @notice set pausable methods to unpaused\n    function unpause() public onlyCoreRole(CoreRoles.GUARDIAN) {\n        _unpause();\n    }\n\n    /// ------------------------------------------\n    /// ------------ Emergency Action ------------\n    /// ------------------------------------------\n\n    /// inspired by MakerDAO Multicall:\n    /// https://github.com/makerdao/multicall/blob/master/src/Multicall.sol\n\n    /// @notice struct to pack calldata and targets for an emergency action\n    struct Call {\n        /// @notice target address to call\n        address target;\n        /// @notice amount of eth to send with the call\n        uint256 value;\n        /// @notice payload to send to target\n        bytes callData;\n    }\n\n    /// @notice due to inflexibility of current smart contracts,\n    /// add this ability to be able to execute arbitrary calldata\n    /// against arbitrary addresses.\n    /// callable only by governor\n    function emergencyAction(\n        Call[] calldata calls\n    )\n        external\n        payable\n        onlyCoreRole(CoreRoles.GOVERNOR)\n        returns (bytes[] memory returnData)\n    {\n        returnData = new bytes[](calls.length);\n        for (uint256 i = 0; i < calls.length; i++) {\n            address payable target = payable(calls[i].target);\n            uint256 value = calls[i].value;\n            bytes calldata callData = calls[i].callData;\n\n            (bool success, bytes memory returned) = target.call{value: value}(\n                callData\n            );\n            require(success, \"CoreRef: underlying call reverted\");\n            returnData[i] = returned;\n        }\n    }\n}"
    },
    {
      "filename": "src/governance/GuildGovernor.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport {Governor, IGovernor} from \"@openzeppelin/contracts/governance/Governor.sol\";\nimport {GovernorSettings} from \"@openzeppelin/contracts/governance/extensions/GovernorSettings.sol\";\nimport {GovernorTimelockControl} from \"@openzeppelin/contracts/governance/extensions/GovernorTimelockControl.sol\";\nimport {GovernorVotes, IERC165} from \"@openzeppelin/contracts/governance/extensions/GovernorVotes.sol\";\nimport {GovernorCountingSimple} from \"@openzeppelin/contracts/governance/extensions/GovernorCountingSimple.sol\";\nimport {IVotes} from \"@openzeppelin/contracts/governance/utils/IVotes.sol\";\nimport {TimelockController} from \"@openzeppelin/contracts/governance/TimelockController.sol\";\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\n\n/// @title Governor for on-chain governance of Ethereum Credit Guild, based on the OZ implementation.\n/// @author eswak\ncontract GuildGovernor is\n    CoreRef,\n    Governor,\n    GovernorVotes,\n    GovernorTimelockControl,\n    GovernorSettings,\n    GovernorCountingSimple\n{\n    /// @notice Private storage variable for quorum (the minimum number of votes needed for a vote to pass).\n    uint256 private _quorum;\n\n    /// @notice Emitted when quorum is updated.\n    event QuorumUpdated(uint256 oldQuorum, uint256 newQuorum);\n\n    constructor(\n        address _core,\n        address _timelock,\n        address _token,\n        uint256 initialVotingDelay,\n        uint256 initialVotingPeriod,\n        uint256 initialProposalThreshold,\n        uint256 initialQuorum\n    )\n        CoreRef(_core)\n        Governor(\"ECG Governor\")\n        GovernorVotes(IVotes(_token))\n        GovernorTimelockControl(TimelockController(payable(_timelock)))\n        GovernorSettings(\n            initialVotingDelay,\n            initialVotingPeriod,\n            initialProposalThreshold\n        )\n    {\n        _setQuorum(initialQuorum);\n    }\n\n    /// ------------------------------------------------------------------------\n    /// Quorum managment.\n    /// ------------------------------------------------------------------------\n\n    /// @notice The minimum number of votes needed for a vote to pass.\n    function quorum(\n        uint256 /* blockNumber*/\n    ) public view override returns (uint256) {\n        return _quorum;\n    }\n\n    /**\n     * @dev Internal setter for the proposal quorum.\n     *\n     * Emits a {QuorumUpdated} event.\n     */\n    function _setQuorum(uint256 newQuorum) internal {\n        emit QuorumUpdated(_quorum, newQuorum);\n        _quorum = newQuorum;\n    }\n\n    /// ------------------------------------------------------------------------\n    /// Governor-only actions.\n    /// ------------------------------------------------------------------------\n\n    /// @notice Override of a GovernorSettings function, to restrict to Core GOVERNOR role.\n    function setVotingDelay(\n        uint256 newVotingDelay\n    ) public override onlyCoreRole(CoreRoles.GOVERNOR) {\n        _setVotingDelay(newVotingDelay);\n    }\n\n    /// @notice Override of a GovernorSettings function, to restrict to Core GOVERNOR role.\n    function setVotingPeriod(\n        uint256 newVotingPeriod\n    ) public override onlyCoreRole(CoreRoles.GOVERNOR) {\n        _setVotingPeriod(newVotingPeriod);\n    }\n\n    /// @notice Override of a GovernorSettings.sol function, to restrict to Core GOVERNOR role.\n    function setProposalThreshold(\n        uint256 newProposalThreshold\n    ) public override onlyCoreRole(CoreRoles.GOVERNOR) {\n        _setProposalThreshold(newProposalThreshold);\n    }\n\n    /// @notice Adjust quorum, restricted to Core GOVERNOR role.\n    function setQuorum(\n        uint256 newQuorum\n    ) public onlyCoreRole(CoreRoles.GOVERNOR) {\n        _setQuorum(newQuorum);\n    }\n\n    /// ------------------------------------------------------------------------\n    /// Guardian-only actions.\n    /// ------------------------------------------------------------------------\n\n    /// @notice Allow guardian to cancel a proposal in progress.\n    function guardianCancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public onlyCoreRole(CoreRoles.GUARDIAN) returns (uint256) {\n        return _cancel(targets, values, calldatas, descriptionHash);\n    }\n\n    /// ------------------------------------------------------------------------\n    /// Overrides required by Solidity.\n    /// ------------------------------------------------------------------------\n\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal override(Governor, GovernorTimelockControl) returns (uint256) {\n        return super._cancel(targets, values, calldatas, descriptionHash);\n    }\n\n    function _execute(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal override(Governor, GovernorTimelockControl) {\n        super._execute(proposalId, targets, values, calldatas, descriptionHash);\n    }\n\n    function _executor()\n        internal\n        view\n        override(Governor, GovernorTimelockControl)\n        returns (address)\n    {\n        return super._executor();\n    }\n\n    function proposalThreshold()\n        public\n        view\n        override(Governor, GovernorSettings)\n        returns (uint256)\n    {\n        return super.proposalThreshold();\n    }\n\n    function state(\n        uint256 proposalId\n    )\n        public\n        view\n        override(Governor, GovernorTimelockControl)\n        returns (ProposalState)\n    {\n        return super.state(proposalId);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view override(Governor, GovernorTimelockControl) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}"
    },
    {
      "filename": "src/governance/GuildVetoGovernor.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport {Governor, IGovernor} from \"@openzeppelin/contracts/governance/Governor.sol\";\nimport {GovernorTimelockControl} from \"@openzeppelin/contracts/governance/extensions/GovernorTimelockControl.sol\";\nimport {GovernorVotes, IERC165} from \"@openzeppelin/contracts/governance/extensions/GovernorVotes.sol\";\nimport {GovernorCountingSimple} from \"@openzeppelin/contracts/governance/extensions/GovernorCountingSimple.sol\";\nimport {IVotes} from \"@openzeppelin/contracts/governance/utils/IVotes.sol\";\nimport {TimelockController} from \"@openzeppelin/contracts/governance/TimelockController.sol\";\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\n\n/// @title Governor for on-chain governance of Ethereum Credit Guild, based on the OZ implementation.\n/// This governor is specifically designed for adding veto capabilities :\n/// Token holders cannot propose() arbitrary actions, they have to create the proposals\n/// through the createVeto() function, and this governor will only be able to execute the\n/// action of cancelling an action in the linked TimelockController if the veto vote passes.\n/// Token holders can only vote against an action that is queued in the linked TimelockController.\n/// When enough against votes (above veto quorum) are cast, the veto vote is considered successful,\n/// and this governor can early-execute the proposal of cancelling the action in the linked\n/// TimelockController, without having to wait the end of a voting period.\n/// After the action has been queued in the linked TimelockController for enough time to be\n/// executed, the veto vote is considered failed and the action cannot be cancelled anymore.\n/// @author eswak\ncontract GuildVetoGovernor is CoreRef, Governor, GovernorVotes {\n    /// @notice Private storage variable for quorum (the minimum number of votes needed for a vote to pass).\n    uint256 private _quorum;\n\n    /// @notice Emitted when quorum is updated.\n    event QuorumUpdated(uint256 oldQuorum, uint256 newQuorum);\n\n    constructor(\n        address _core,\n        address initialTimelock,\n        address _token,\n        uint256 initialQuorum\n    )\n        CoreRef(_core)\n        Governor(\"ECG Veto Governor\")\n        GovernorVotes(IVotes(_token))\n    {\n        _setQuorum(initialQuorum);\n        _updateTimelock(initialTimelock);\n    }\n\n    /// ------------------------------------------------------------------------\n    /// Quorum Management\n    /// ------------------------------------------------------------------------\n\n    /**\n     * @dev Public accessor to check the minimum number of votes needed for a vote to pass.\n     */\n    function quorum(\n        uint256 /* blockNumber*/\n    ) public view override returns (uint256) {\n        return _quorum;\n    }\n\n    /// @notice Adjust quorum, restricted to Core GOVERNOR role.\n    function setQuorum(\n        uint256 newQuorum\n    ) public onlyCoreRole(CoreRoles.GOVERNOR) {\n        _setQuorum(newQuorum);\n    }\n\n    /**\n     * @dev Internal setter for the proposal quorum.\n     *\n     * Emits a {QuorumUpdated} event.\n     */\n    function _setQuorum(uint256 newQuorum) internal virtual {\n        emit QuorumUpdated(_quorum, newQuorum);\n        _quorum = newQuorum;\n    }\n\n    /// ------------------------------------------------------------------------\n    /// Timelock Management\n    /// ------------------------------------------------------------------------\n\n    /**\n     * @dev Emitted when the timelock controller used for proposal execution is modified.\n     */\n    event TimelockChange(address oldTimelock, address newTimelock);\n\n    /// @notice the timelock linked to this veto governor\n    address public timelock;\n\n    /// @notice mapping of proposalId (in this Governor) to timelockId (action ID in\n    /// the timelock linked to this governor).\n    mapping(uint256 => bytes32) private _timelockIds;\n\n    /// @notice Set the timelock this veto governor can cancel from.\n    function updateTimelock(\n        address newTimelock\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        _updateTimelock(newTimelock);\n    }\n\n    function _updateTimelock(address newTimelock) private {\n        emit TimelockChange(timelock, newTimelock);\n        timelock = newTimelock;\n    }\n\n    /// ------------------------------------------------------------------------\n    /// Vote counting\n    /// ------------------------------------------------------------------------\n\n    /**\n     * @dev Supported vote types. Matches Governor Bravo ordering.\n     */\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n\n    struct ProposalVote {\n        uint256 againstVotes;\n        uint256 forVotes;\n        uint256 abstainVotes;\n        mapping(address => bool) hasVoted;\n    }\n\n    mapping(uint256 => ProposalVote) private _proposalVotes;\n\n    /**\n     * @dev See {IGovernor-COUNTING_MODE}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE()\n        public\n        pure\n        virtual\n        override\n        returns (string memory)\n    {\n        return \"support=bravo&quorum=against\";\n    }\n\n    /**\n     * @dev See {IGovernor-hasVoted}.\n     */\n    function hasVoted(\n        uint256 proposalId,\n        address account\n    ) public view virtual override returns (bool) {\n        return _proposalVotes[proposalId].hasVoted[account];\n    }\n\n    /**\n     * @dev Accessor to the internal vote counts.\n     */\n    function proposalVotes(\n        uint256 proposalId\n    )\n        public\n        view\n        virtual\n        returns (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes)\n    {\n        // againstVotes are supporting the execution of Veto\n        againstVotes = _proposalVotes[proposalId].againstVotes;\n        // no forVotes can be cast in the Veto module, keep 0 value\n        forVotes = 0;\n        // no abstainVotes can be cast in the Veto module, keep 0 value\n        abstainVotes = 0;\n    }\n\n    /**\n     * @dev See {Governor-_quorumReached}.\n     */\n    function _quorumReached(\n        uint256 proposalId\n    ) internal view virtual override returns (bool) {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n\n        return\n            quorum(proposalSnapshot(proposalId)) <= proposalvote.againstVotes;\n    }\n\n    /**\n     * @dev Veto votes are always considered \"successful\" in this part of the logic, as there is no opposition\n     * between 'for' and 'against' votes, since people cannot vote 'for'. For a veto to be considered successful,\n     * it only needs to reach quorum.\n     */\n    function _voteSucceeded(\n        uint256 /* proposalId*/\n    ) internal pure virtual override returns (bool) {\n        return true;\n    }\n\n    /**\n     * @dev See {Governor-_countVote}. In this module, the support follows the `VoteType` enum (from Governor Bravo).\n     */\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight,\n        bytes memory // params\n    ) internal virtual override {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n\n        require(\n            !proposalvote.hasVoted[account],\n            \"GuildVetoGovernor: vote already cast\"\n        );\n        proposalvote.hasVoted[account] = true;\n\n        if (support == uint8(VoteType.Against)) {\n            proposalvote.againstVotes += weight;\n        } else {\n            revert(\"GuildVetoGovernor: can only vote against in veto proposals\");\n        }\n    }\n\n    /// ------------------------------------------------------------------------\n    /// Public functions override\n    /// ------------------------------------------------------------------------\n\n    /// @dev no voting delay between veto proposal and veto voting period.\n    function votingDelay() public pure override returns (uint256) {\n        return 0;\n    }\n\n    /// @dev voting period is unused, it is a duration in blocks for the vote\n    /// but the timestamp of the action in the timelock is used to know if the\n    /// vote period is over (after action is ready in the timelock, the veto\n    /// vote failed).\n    function votingPeriod() public pure override returns (uint256) {\n        return 2425847; // ~1 year with 1 block every 13s\n    }\n\n    /// @notice State of a given proposal\n    /// The state can be one of:\n    /// - ProposalState.Pending   (0) Lasts only during the block where the veto proposal has been created.\n    /// - ProposalState.Active    (1) If action is pending in the timelock and veto quorum has not been reached yet.\n    /// - ProposalState.Canceled  (2) If a veto was created but the timelock action has been cancelled through another\n    ///   mean before the veto vote succeeded. The internal _cancel() function is not reachable by another mean (no\n    ///   public cancel() function), so this is the only case where a proposal will have Canceled status.\n    /// - ProposalState.Defeated  (3) If proposal already executed or is ready to execute in the timelock.\n    /// - ProposalState.Succeeded (4) If action is pending in the timelock and veto quorum has been reached. Veto can be executed instantly.\n    /// - ProposalState.Executed  (7) If a veto successfully executed.\n    /// note that veto proposals have a quorum that works with 'against' votes, and that only 'against' votes can be\n    /// cast in this veto governor.\n    function state(\n        uint256 proposalId\n    ) public view override returns (ProposalState) {\n        ProposalState status = super.state(proposalId);\n        bytes32 queueid = _timelockIds[proposalId];\n\n        // @dev all proposals that are in this Governor's state should have been created\n        // by the createVeto() method, and therefore should have _timelockIds set, so this\n        // condition check is an invalid state that should never be reached.\n        assert(queueid != bytes32(0));\n\n        // Proposal already executed and stored in state\n        if (status == ProposalState.Executed) {\n            return ProposalState.Executed;\n        }\n        // Proposal cannot be Canceled because there is no public cancel() function.\n        // Vote has just been created, still in waiting period\n        if (status == ProposalState.Pending) {\n            return ProposalState.Pending;\n        }\n\n        // at this stage, status from super can be one of: Active, Succeeded, Defeated\n        // Read timestamp in the timelock to determine the state of the proposal\n        uint256 timelockOperationTimestamp = TimelockController(\n            payable(timelock)\n        ).getTimestamp(queueid);\n\n        // proposal already cleared from the timelock by something else\n        if (timelockOperationTimestamp == 0) {\n            return ProposalState.Canceled;\n        }\n        // proposal already executed in the timelock\n        if (timelockOperationTimestamp == 1) {\n            return ProposalState.Defeated;\n        }\n\n        // proposal still in waiting period in the timelock\n        if (timelockOperationTimestamp > block.timestamp) {\n            // ready to veto\n            // no need for \"&& _voteSucceeded(proposalId)\" in condition because\n            // veto votes are always succeeded (there is no tallying for 'for'\n            // votes against 'against' votes), the only condition is the quorum.\n            if (_quorumReached(proposalId)) {\n                return ProposalState.Succeeded;\n            }\n            // need more votes to veto\n            else {\n                return ProposalState.Active;\n            }\n        }\n        // proposal is ready to execute in the timelock, the veto\n        // vote did not reach quorum in time.\n        else {\n            return ProposalState.Defeated;\n        }\n    }\n\n    /// @dev override to prevent arbitrary calls to be proposed\n    function propose(\n        address[] memory /* targets*/,\n        uint256[] memory /* values*/,\n        bytes[] memory /* calldatas*/,\n        string memory /* description*/\n    ) public pure override returns (uint256) {\n        revert(\"GuildVetoGovernor: cannot propose arbitrary actions\");\n    }\n\n    /// @notice Propose a governance action to veto (cancel) a target action ID in the\n    /// governor's linked timelock.\n    function createVeto(bytes32 timelockId) external returns (uint256) {\n        // Check that the operation is pending in the timelock\n        uint256 timelockExecutionTime = TimelockController(payable(timelock))\n            .getTimestamp(timelockId);\n        require(\n            timelockExecutionTime > 1,\n            \"GuildVetoGovernor: action must be pending\"\n        );\n\n        // Build proposal data\n        (\n            address[] memory targets,\n            uint256[] memory values,\n            bytes[] memory calldatas,\n            string memory description\n        ) = _getVetoCalls(timelockId);\n\n        uint256 proposalId = super.propose(\n            targets,\n            values,\n            calldatas,\n            description\n        );\n\n        // Save mapping between proposalId and timelockId\n        _timelockIds[proposalId] = timelockId;\n\n        return proposalId;\n    }\n\n    /// @notice Execute a governance action to veto (cancel) a target action ID in the\n    /// governor's linked timelock.\n    /// @dev the standard execute() function can also be used for this, and the function\n    /// is only added for convenience.\n    function executeVeto(bytes32 timelockId) external returns (uint256) {\n        // Build proposal data\n        (\n            address[] memory targets,\n            uint256[] memory values,\n            bytes[] memory calldatas,\n            string memory description\n        ) = _getVetoCalls(timelockId);\n        // Execute\n        return\n            super.execute(\n                targets,\n                values,\n                calldatas,\n                keccak256(bytes(description))\n            );\n    }\n\n    function _getVetoCalls(\n        bytes32 timelockId\n    )\n        internal\n        view\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            bytes[] memory calldatas,\n            string memory description\n        )\n    {\n        targets = new address[](1);\n        targets[0] = timelock;\n        values = new uint256[](1); // 0 eth\n        calldatas = new bytes[](1);\n        calldatas[0] = abi.encodeWithSelector(\n            TimelockController.cancel.selector,\n            timelockId\n        );\n        description = string.concat(\n            \"Veto proposal for \",\n            string(abi.encodePacked(timelockId))\n        );\n    }\n}"
    },
    {
      "filename": "src/governance/GuildVetoGovernor.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport {Governor, IGovernor} from \"@openzeppelin/contracts/governance/Governor.sol\";\nimport {GovernorTimelockControl} from \"@openzeppelin/contracts/governance/extensions/GovernorTimelockControl.sol\";\nimport {GovernorVotes, IERC165} from \"@openzeppelin/contracts/governance/extensions/GovernorVotes.sol\";\nimport {GovernorCountingSimple} from \"@openzeppelin/contracts/governance/extensions/GovernorCountingSimple.sol\";\nimport {IVotes} from \"@openzeppelin/contracts/governance/utils/IVotes.sol\";\nimport {TimelockController} from \"@openzeppelin/contracts/governance/TimelockController.sol\";\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\n\n/// @title Governor for on-chain governance of Ethereum Credit Guild, based on the OZ implementation.\n/// This governor is specifically designed for adding veto capabilities :\n/// Token holders cannot propose() arbitrary actions, they have to create the proposals\n/// through the createVeto() function, and this governor will only be able to execute the\n/// action of cancelling an action in the linked TimelockController if the veto vote passes.\n/// Token holders can only vote against an action that is queued in the linked TimelockController.\n/// When enough against votes (above veto quorum) are cast, the veto vote is considered successful,\n/// and this governor can early-execute the proposal of cancelling the action in the linked\n/// TimelockController, without having to wait the end of a voting period.\n/// After the action has been queued in the linked TimelockController for enough time to be\n/// executed, the veto vote is considered failed and the action cannot be cancelled anymore.\n/// @author eswak\ncontract GuildVetoGovernor is CoreRef, Governor, GovernorVotes {\n    /// @notice Private storage variable for quorum (the minimum number of votes needed for a vote to pass).\n    uint256 private _quorum;\n\n    /// @notice Emitted when quorum is updated.\n    event QuorumUpdated(uint256 oldQuorum, uint256 newQuorum);\n\n    constructor(\n        address _core,\n        address initialTimelock,\n        address _token,\n        uint256 initialQuorum\n    )\n        CoreRef(_core)\n        Governor(\"ECG Veto Governor\")\n        GovernorVotes(IVotes(_token))\n    {\n        _setQuorum(initialQuorum);\n        _updateTimelock(initialTimelock);\n    }\n\n    /// ------------------------------------------------------------------------\n    /// Quorum Management\n    /// ------------------------------------------------------------------------\n\n    /**\n     * @dev Public accessor to check the minimum number of votes needed for a vote to pass.\n     */\n    function quorum(\n        uint256 /* blockNumber*/\n    ) public view override returns (uint256) {\n        return _quorum;\n    }\n\n    /// @notice Adjust quorum, restricted to Core GOVERNOR role.\n    function setQuorum(\n        uint256 newQuorum\n    ) public onlyCoreRole(CoreRoles.GOVERNOR) {\n        _setQuorum(newQuorum);\n    }\n\n    /**\n     * @dev Internal setter for the proposal quorum.\n     *\n     * Emits a {QuorumUpdated} event.\n     */\n    function _setQuorum(uint256 newQuorum) internal virtual {\n        emit QuorumUpdated(_quorum, newQuorum);\n        _quorum = newQuorum;\n    }\n\n    /// ------------------------------------------------------------------------\n    /// Timelock Management\n    /// ------------------------------------------------------------------------\n\n    /**\n     * @dev Emitted when the timelock controller used for proposal execution is modified.\n     */\n    event TimelockChange(address oldTimelock, address newTimelock);\n\n    /// @notice the timelock linked to this veto governor\n    address public timelock;\n\n    /// @notice mapping of proposalId (in this Governor) to timelockId (action ID in\n    /// the timelock linked to this governor).\n    mapping(uint256 => bytes32) private _timelockIds;\n\n    /// @notice Set the timelock this veto governor can cancel from.\n    function updateTimelock(\n        address newTimelock\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        _updateTimelock(newTimelock);\n    }\n\n    function _updateTimelock(address newTimelock) private {\n        emit TimelockChange(timelock, newTimelock);\n        timelock = newTimelock;\n    }\n\n    /// ------------------------------------------------------------------------\n    /// Vote counting\n    /// ------------------------------------------------------------------------\n\n    /**\n     * @dev Supported vote types. Matches Governor Bravo ordering.\n     */\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n\n    struct ProposalVote {\n        uint256 againstVotes;\n        uint256 forVotes;\n        uint256 abstainVotes;\n        mapping(address => bool) hasVoted;\n    }\n\n    mapping(uint256 => ProposalVote) private _proposalVotes;\n\n    /**\n     * @dev See {IGovernor-COUNTING_MODE}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE()\n        public\n        pure\n        virtual\n        override\n        returns (string memory)\n    {\n        return \"support=bravo&quorum=against\";\n    }\n\n    /**\n     * @dev See {IGovernor-hasVoted}.\n     */\n    function hasVoted(\n        uint256 proposalId,\n        address account\n    ) public view virtual override returns (bool) {\n        return _proposalVotes[proposalId].hasVoted[account];\n    }\n\n    /**\n     * @dev Accessor to the internal vote counts.\n     */\n    function proposalVotes(\n        uint256 proposalId\n    )\n        public\n        view\n        virtual\n        returns (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes)\n    {\n        // againstVotes are supporting the execution of Veto\n        againstVotes = _proposalVotes[proposalId].againstVotes;\n        // no forVotes can be cast in the Veto module, keep 0 value\n        forVotes = 0;\n        // no abstainVotes can be cast in the Veto module, keep 0 value\n        abstainVotes = 0;\n    }\n\n    /**\n     * @dev See {Governor-_quorumReached}.\n     */\n    function _quorumReached(\n        uint256 proposalId\n    ) internal view virtual override returns (bool) {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n\n        return\n            quorum(proposalSnapshot(proposalId)) <= proposalvote.againstVotes;\n    }\n\n    /**\n     * @dev Veto votes are always considered \"successful\" in this part of the logic, as there is no opposition\n     * between 'for' and 'against' votes, since people cannot vote 'for'. For a veto to be considered successful,\n     * it only needs to reach quorum.\n     */\n    function _voteSucceeded(\n        uint256 /* proposalId*/\n    ) internal pure virtual override returns (bool) {\n        return true;\n    }\n\n    /**\n     * @dev See {Governor-_countVote}. In this module, the support follows the `VoteType` enum (from Governor Bravo).\n     */\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight,\n        bytes memory // params\n    ) internal virtual override {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n\n        require(\n            !proposalvote.hasVoted[account],\n            \"GuildVetoGovernor: vote already cast\"\n        );\n        proposalvote.hasVoted[account] = true;\n\n        if (support == uint8(VoteType.Against)) {\n            proposalvote.againstVotes += weight;\n        } else {\n            revert(\"GuildVetoGovernor: can only vote against in veto proposals\");\n        }\n    }\n\n    /// ------------------------------------------------------------------------\n    /// Public functions override\n    /// ------------------------------------------------------------------------\n\n    /// @dev no voting delay between veto proposal and veto voting period.\n    function votingDelay() public pure override returns (uint256) {\n        return 0;\n    }\n\n    /// @dev voting period is unused, it is a duration in blocks for the vote\n    /// but the timestamp of the action in the timelock is used to know if the\n    /// vote period is over (after action is ready in the timelock, the veto\n    /// vote failed).\n    function votingPeriod() public pure override returns (uint256) {\n        return 2425847; // ~1 year with 1 block every 13s\n    }\n\n    /// @notice State of a given proposal\n    /// The state can be one of:\n    /// - ProposalState.Pending   (0) Lasts only during the block where the veto proposal has been created.\n    //"
    }
  ]
}