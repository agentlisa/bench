{
  "Title": "[H-01] `VaultProxy` implementation can be initialized by anyone and self-destructed",
  "Content": "\n<https://github.com/code-423n4/2023-06-stader/blob/7566b5a35f32ebd55d3578b8bd05c038feb7d9cc/contracts/VaultProxy.sol#L20-L36> <br><https://github.com/code-423n4/2023-06-stader/blob/7566b5a35f32ebd55d3578b8bd05c038feb7d9cc/contracts/VaultProxy.sol#L41-L50>\n\nWhen the `VaultFactory` contract is deployed and initialized, the `initialise` method on the newly created `VaultProxy` implementation contract is never called. As such, anyone can call that method and pass in whatever values they want as arguments. One important argument is the `_staderConfig` address, which controls where the `fallback` function will direct `delegatecall` operations. If an attacker passes in a contract that calls `selfdestruct`, it will be run in the context of the `VaultProxy` implementation contract and will erase all code from that address. Since the clones from the `VaultProxy` contract merely delegate calls to the implementation address, all subsequent calls for all created vaults from that implementation will be treated like an EOA and return `true`, even though calls to functions on that proxy were never executed.\n\n### Proof of Concept\n\n*   First, an attacker deploys a contract called `AttackContract` that calls `selfdestruct` in its `fallback` function.\n\n<!---->\n\n    contract AttackContract {\n        function getValidatorWithdrawalVaultImplementation() public view returns(address) {\n            return address(this);\n        }\n        function getNodeELRewardVaultImplementation() public view returns(address) {\n    \treturn address(this);\n        }\n        fallback(bytes calldata _input) external payable returns(bytes memory _output) {\n    \tselfdestruct(address(0));\n        }\n    }\n\n*   The attacker calls the `initialise` method on the `VaultProxy` implementation contract. That address is stored in the `vaultProxyImplementation` variable on the `VaultFactory` contract. The attacker passes in the address of `AttackContract` as the `_staderConfig` argument for the `initialise` function.\n*   The attacker then calls a non-existent function on the `VaultProxy` implementation contract, which triggers it's `fallback` function. The `fallback` function calls `staderConfig.getNodeELRewardVaultImplementation()`, and since `staderConfig` is set the `AttackContract` address, it returns the address of the `AttackContract`. `delegatecall` runs the fallback function of `AttackContract` in its own execution environment. `selfdestruct` is called in the execution environment of the `VaultProxy` implementation, which erases the code at that address.\n*   All cloned copies of the `VaultProxy` implementation contract are now forwarding calls to an implementation address that has no code stored at it. These calls will be treated like calls to an EOA and return `true` for `success`.\n\n### Recommended Mitigation Steps\n\nPrevent the `initialise` function from being called on the `VaultProxy` implementation contract by inheriting from OpenZeppelin's `Initializable` contract, like the system is doing in other contracts. Call the `_disableInitializers` function in the constructor and protect `initialise` with the `initializer` modifier. Alternatively, the `initialise` function can be called from the `initialize` function of the `VaultFactory` contract when the `VaultProxy` contract is instantiated.\n\n### Assessed type\n\nAccess Control\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2022-06-stader-findings/issues/418#issuecomment-1618129945):**\n > Keeping High severity. This seems exploitable to lock funds with no cost, as the fallback function is payable.\n\n**[sanjay-staderlabs (Stader) confirmed](https://github.com/code-423n4/2022-06-stader-findings/issues/418#issuecomment-1619515745)**\n\n**[sanjay-staderlabs (Stader) commented](https://github.com/code-423n4/2023-06-stader-findings/issues/418#issuecomment-1633520116):**\n>This is fixed in the code.\n***\n\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-06-stader",
  "Code": [
    {
      "filename": "contracts/VaultProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport './library/UtilLib.sol';\nimport './interfaces/IVaultProxy.sol';\n\n//contract to delegate call to respective vault implementation based on the flag of 'isValidatorWithdrawalVault'\ncontract VaultProxy is IVaultProxy {\n    bool public override vaultSettleStatus;\n    bool public override isValidatorWithdrawalVault;\n    bool public override isInitialized;\n    uint8 public override poolId;\n    uint256 public override id; //validatorId or operatorId based on vault type\n    address public override owner;\n    IStaderConfig public override staderConfig;\n\n    constructor() {}\n\n    //initialise the vault proxy with data\n    function initialise(\n        bool _isValidatorWithdrawalVault,\n        uint8 _poolId,\n        uint256 _id,\n        address _staderConfig\n    ) external {\n        if (isInitialized) {\n            revert AlreadyInitialized();\n        }\n        UtilLib.checkNonZeroAddress(_staderConfig);\n        isValidatorWithdrawalVault = _isValidatorWithdrawalVault;\n        isInitialized = true;\n        poolId = _poolId;\n        id = _id;\n        staderConfig = IStaderConfig(_staderConfig);\n        owner = staderConfig.getAdmin();\n    }\n\n    /**route all call to this proxy contract to the respective latest vault contract\n     * fetched from staderConfig. This approch will help in changing the implementation\n     * of validatorWithdrawalVault/nodeELRewardVault for already deployed vaults*/\n    fallback(bytes calldata _input) external payable returns (bytes memory) {\n        address vaultImplementation = isValidatorWithdrawalVault\n            ? staderConfig.getValidatorWithdrawalVaultImplementation()\n            : staderConfig.getNodeELRewardVaultImplementation();\n        (bool success, bytes memory data) = vaultImplementation.delegatecall(_input);\n        if (!success) {\n            revert(string(data));\n        }\n        return data;\n    }\n\n    /**\n     * @notice update the address of stader config contract\n     * @dev only owner can call\n     * @param _staderConfig address of updated staderConfig\n     */\n    function updateStaderConfig(address _staderConfig) external override onlyOwner {\n        UtilLib.checkNonZeroAddress(_staderConfig);\n        staderConfig = IStaderConfig(_staderConfig);\n        emit UpdatedStaderConfig(_staderConfig);\n    }\n\n    /**\n     * @notice @update the owner of vault proxy contrat\n     * @dev only owner can call\n     * @param _owner new owner account\n     */\n    function updateOwner(address _owner) external override onlyOwner {\n        UtilLib.checkNonZeroAddress(_owner);\n        owner = _owner;\n        emit UpdatedOwner(owner);\n    }\n\n    //modifier to check only owner\n    modifier onlyOwner() {\n        if (msg.sender != owner) {\n            revert CallerNotOwner();\n        }\n        _;\n    }\n}"
    }
  ]
}