{
  "Title": "[M-01] Loans of tokens with >18 decimals can result in incorrect collateral calculation",
  "Content": "\nIt is possible for a user to mislead a Pool Delegate to a seemingly innocuous loan by utilizing a token with more than 18 decimals as collateral and lucrative loan terms.\n\nThe [final calculation](https://github.com/maple-labs/maple-core/blob/031374b2609560ade825532474048eb5826dec20/contracts/library/LoanLib.sol#L235) within the `collateralRequiredForDrawdown` of `LoanLib` incorrectly assumes the collateral token of a loan to be less than `18` decimals, which can not be the case as there is no sanitization conducted on the creation of a `Loan` via the factory. This can cause an underflow to the power of `10` which will cause the division to yield `0` and thus cause the `Loan` to calculate `0` as collateral required for the loan. We advise the [same paradigm](https://github.com/maple-labs/maple-core/blob/031374b2609560ade825532474048eb5826dec20/contracts/library/LoanLib.sol#L247) as `_toWad` to be applied, which is secure.\n\n**[lucas-manuel (Maple) acknowledged](https://github.com/code-423n4/2021-04-maple-findings/issues/4#issuecomment-824852669):**\n\n> We are aware that we cannot onboard liquidityAssets or collateralAssets with more that 18 decimals of precision, and will make that part of our onboarding criteria.\n\n**[Nick Johnson (Judge)](https://github.com/code-423n4/2021-04-maple-findings/issues/4#issuecomment-827193173):**\n\n> This is 100% a legitimate issue that could be exploited against the contract, and using social mitigations (making this part of the onboarding strategy) when there's a technical mitigation (`require()`ing that the token have <= 18 decimals, or using the recommended mitigation) is insufficient and could easily lead to an exploit due to human error.\n>\n> Based on the OWASP methodogology, I'm judging this as Likelihood=Low (because of the requirement to get it past human review) and Impact=High (because of the impact of the bug if it were exploited to create a 0-collateral loan and default on it), resulting in a Severity of Medium.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2021-04-maple",
  "Code": [
    {
      "filename": "contracts/library/LoanLib.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"../interfaces/ICollateralLocker.sol\";\nimport \"../interfaces/ICollateralLockerFactory.sol\";\nimport \"../interfaces/IERC20Details.sol\";\nimport \"../interfaces/IFundingLocker.sol\";\nimport \"../interfaces/IFundingLockerFactory.sol\";\nimport \"../interfaces/IGlobals.sol\";\nimport \"../interfaces/ILateFeeCalc.sol\";\nimport \"../interfaces/ILoanFactory.sol\";\nimport \"../interfaces/IPremiumCalc.sol\";\nimport \"../interfaces/IRepaymentCalc.sol\";\nimport \"../interfaces/IUniswapRouter.sol\";\nimport \"../library/Util.sol\";\n\nimport \"lib/openzeppelin-contracts/contracts/token/ERC20/SafeERC20.sol\";\nimport \"lib/openzeppelin-contracts/contracts/math/SafeMath.sol\";\n\n/// @title LoanLib is a library of utility functions used by Loan.\nlibrary LoanLib {\n\n    using SafeMath  for uint256;\n    using SafeERC20 for IERC20;\n\n    enum State { Ready, Active, Matured, Expired, Liquidated }\n\n    address public constant UNISWAP_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n\n    /********************************/\n    /*** Lender Utility Functions ***/\n    /********************************/\n\n    /**\n        @dev If the borrower has not drawn down loan past grace period, return capital to lenders.\n        @param liquidityAsset  IERC20 of the liquidityAsset\n        @param superFactory    Factory that instantiated Loan\n        @param fundingLocker   Address of FundingLocker\n        @param createdAt       Timestamp of Loan instantiation\n        @return excessReturned Amount of liquidityAsset that was returned to the Loan from the FundingLocker\n    */\n    function unwind(IERC20 liquidityAsset, address superFactory, address fundingLocker, uint256 createdAt) external returns(uint256 excessReturned) {\n        IGlobals globals = _globals(superFactory);\n\n        // Only callable if time has passed drawdown grace period, set in MapleGlobals\n        require(block.timestamp > createdAt.add(globals.fundingPeriod()), \"Loan:FUNDING_PERIOD_NOT_FINISHED\");\n\n        uint256 preBal = liquidityAsset.balanceOf(address(this));  // Account for existing balance in Loan\n\n        // Drain funding from FundingLocker, transfers all liquidityAsset to this Loan\n        IFundingLocker(fundingLocker).drain();\n\n        // Update excessReturned accounting for claim()\n        return liquidityAsset.balanceOf(address(this)).sub(preBal);\n    }\n\n    /**\n        @dev Liquidate a Borrower's collateral via Uniswap when a default is triggered.\n        @param collateralAsset   IERC20 of the collateralAsset\n        @param liquidityAsset         Address of liquidityAsset\n        @param superFactory      Factory that instantiated Loan\n        @param collateralLocker  Address of CollateralLocker\n        @return amountLiquidated Amount of collateralAsset that was liquidated\n        @return amountRecovered  Amount of liquidityAsset that was returned to the Loan from the liquidation\n    */\n    function liquidateCollateral(\n        IERC20  collateralAsset,\n        address liquidityAsset,\n        address superFactory,\n        address collateralLocker\n    ) \n        external\n        returns (\n            uint256 amountLiquidated,\n            uint256 amountRecovered\n        ) \n    {\n        // Get liquidation amount from CollateralLocker\n        uint256 liquidationAmt = collateralAsset.balanceOf(address(collateralLocker));\n        \n        // Pull collateralAsset from collateralLocker\n        ICollateralLocker(collateralLocker).pull(address(this), liquidationAmt);\n\n        if (address(collateralAsset) != liquidityAsset && liquidationAmt > uint256(0)) {\n            collateralAsset.safeApprove(UNISWAP_ROUTER, uint256(0));\n            collateralAsset.safeApprove(UNISWAP_ROUTER, liquidationAmt);\n\n            IGlobals globals = _globals(superFactory);\n\n            uint256 minAmount = Util.calcMinAmount(globals, address(collateralAsset), liquidityAsset, liquidationAmt);  // Minimum amount of loan asset get after swapping collateral asset\n\n            // Generate path\n            address uniswapAssetForPath = globals.defaultUniswapPath(address(collateralAsset), liquidityAsset);\n            bool middleAsset = uniswapAssetForPath != liquidityAsset && uniswapAssetForPath != address(0);\n\n            address[] memory path = new address[](middleAsset ? 3 : 2);\n\n            path[0] = address(collateralAsset);\n            path[1] = middleAsset ? uniswapAssetForPath : liquidityAsset;\n\n            if (middleAsset) path[2] = liquidityAsset;\n\n            // Swap collateralAsset for liquidityAsset\n            uint256[] memory returnAmounts = IUniswapRouter(UNISWAP_ROUTER).swapExactTokensForTokens(\n                liquidationAmt,\n                minAmount.sub(minAmount.mul(globals.maxSwapSlippage()).div(10_000)),\n                path,\n                address(this),\n                block.timestamp\n            );\n\n            amountLiquidated = returnAmounts[0];\n            amountRecovered  = returnAmounts[path.length - 1];\n        } else {\n            amountLiquidated = liquidationAmt;\n            amountRecovered  = liquidationAmt;\n        }\n    }\n\n    /**********************************/\n    /*** Governor Utility Functions ***/\n    /**********************************/\n\n    /**\n        @dev Transfer any locked funds to the governor.\n        @param token Address of the token that need to reclaimed.\n        @param liquidityAsset Address of loan asset that is supported by the loan in other words denominated currency in which it taking funds.\n        @param globals Instance of the `MapleGlobals` contract.\n     */\n    function reclaimERC20(address token, address liquidityAsset, IGlobals globals) external {\n        require(msg.sender == globals.governor(), \"Loan:UNAUTHORIZED\");\n        require(token != liquidityAsset && token != address(0), \"Loan:INVALID_TOKEN\");\n        IERC20(token).safeTransfer(msg.sender, IERC20(token).balanceOf(address(this)));\n    }\n\n    /************************/\n    /*** Getter Functions ***/\n    /************************/\n\n    /**\n        @dev Determines if a default can be triggered.\n        @param nextPaymentDue     Timestamp of when payment is due\n        @param defaultGracePeriod Amount of time after `nextPaymentDue` that a borrower has before a liquidation can occur\n        @param superFactory       Factory that instantiated Loan\n        @param balance            LoanFDT balance of msg.sender\n        @param totalSupply        LoanFDT totalSupply\n        @return boolean indicating if default can be triggered\n    */\n    function canTriggerDefault(uint256 nextPaymentDue, uint256 defaultGracePeriod, address superFactory, uint256 balance, uint256 totalSupply) external view returns(bool) {\n\n        bool pastDefaultGracePeriod = block.timestamp > nextPaymentDue.add(defaultGracePeriod);\n\n        // Check if the loan is past the defaultGracePeriod and that msg.sender has a percentage of total LoanFDTs that is greater\n        // than the minimum equity needed (specified in globals)\n        return pastDefaultGracePeriod && balance >= totalSupply * _globals(superFactory).minLoanEquity() / 10_000;\n    }\n\n    /**\n        @dev Returns information on next payment amount.\n        @param superFactory     Factory that instantiated Loan\n        @param repaymentCalc    Address of RepaymentCalc\n        @param nextPaymentDue   Timestamp of when payment is due\n        @param lateFeeCalc      Address of LateFeeCalc\n        @return total           Entitiled interest to the next payment, Principal + Interest only when the next payment is last payment of the loan\n        @return principal       Entitiled principal amount needs to pay in the next payment\n        @return interest        Entitiled interest amount needs to pay in the next payment\n        @return _nextPaymentDue Payment Due Date\n        @return paymentLate     Boolean if payment is late\n    */\n    function getNextPayment(\n        address superFactory,\n        address repaymentCalc,\n        uint256 nextPaymentDue,\n        address lateFeeCalc\n    ) \n        public\n        view\n        returns (\n            uint256 total,\n            uint256 principal,\n            uint256 interest,\n            uint256 _nextPaymentDue,\n            bool    paymentLate\n        ) \n    {\n        IGlobals globals = _globals(superFactory);\n        _nextPaymentDue  = nextPaymentDue;\n\n        // Get next payment amounts from repayment calc\n        (total, principal, interest) = IRepaymentCalc(repaymentCalc).getNextPayment(address(this));\n\n        paymentLate = block.timestamp > _nextPaymentDue;\n\n        // If payment is late, add late fees\n        if (paymentLate) {\n            uint256 lateFee = ILateFeeCalc(lateFeeCalc).getLateFee(interest);\n            \n            total    = total.add(lateFee);\n            interest = interest.add(lateFee);\n        }\n    }\n\n    /**\n        @dev Helper for calculating collateral required to drawdown amt.\n        @param collateralAsset IERC20 of the collateralAsset\n        @param liquidityAsset  IERC20 of the liquidityAsset\n        @param collateralRatio Percentage of drawdown value that must be posted as collateral\n        @param superFactory    Factory that instantiated Loan\n        @param amt             Drawdown amount\n        @return Amount of collateralAsset required to post in CollateralLocker for given drawdown amt\n    */\n    function collateralRequiredForDrawdown(\n        IERC20Details collateralAsset,\n        IERC20Details liquidityAsset,\n        uint256 collateralRatio,\n        address superFactory,\n        uint256 amt\n    ) \n        external\n        view\n        returns (uint256) \n    {\n        IGlobals globals = _globals(superFactory);\n\n        uint256 wad = _toWad(amt, liquidityAsset);  // Convert to WAD precision\n\n        // Fetch current value of liquidityAsset and collateralAsset (Chainlink oracles provide 8 decimal precision)\n        uint256 liquidityAssetPrice  = globals.getLatestPrice(address(liquidityAsset));\n        uint256 collateralPrice = globals.getLatestPrice(address(collateralAsset));\n\n        // Calculate collateral required\n        uint256 collateralRequiredUSD = wad.mul(liquidityAssetPrice).mul(collateralRatio).div(10_000); // 18 + 8 = 26 decimals\n        uint256 collateralRequiredWAD = collateralRequiredUSD.div(collateralPrice);               // 26 - 8 = 18 decimals\n\n        return collateralRequiredWAD.div(10 ** (18 - collateralAsset.decimals()));  // 18 - (18 - collateralDecimals) = collateralDecimals\n    }\n\n    /************************/\n    /*** Helper Functions ***/\n    /************************/\n\n    function _globals(address loanFactory) internal view returns (IGlobals) {\n        return IGlobals(ILoanFactory(loanFactory).globals());\n    }\n\n    function _toWad(uint256 amt, IERC20Details liquidityAsset) internal view returns(uint256) {\n        return amt.mul(10 ** 18).div(10 ** liquidityAsset.decimals());\n    }\n}"
    }
  ]
}