{
  "Title": "M-1: resolveQueuedTrades() ERC777 re-enter to steal funds",
  "Content": "# Issue M-1: resolveQueuedTrades() ERC777 re-enter to steal funds \n\nSource: https://github.com/sherlock-audit/2022-11-buffer-judging/issues/130 \n\n## Found by \nbin2chen, HonorLt, KingNFT\n\n## Summary\n_openQueuedTrade() does not follow the “Checks Effects Interactions” principle and may lead to re-entry to steal the funds\n\nhttps://fravoll.github.io/solidity-patterns/checks_effects_interactions.html\n\n## Vulnerability Detail\nThe prerequisite is that tokenX is ERC777 e.g. “sushi”\n1. resolveQueuedTrades() call _openQueuedTrade()\n2. in _openQueuedTrade() call \"tokenX.transfer(queuedTrade.user)\" if (revisedFee < queuedTrade.totalFee) before set queuedTrade.isQueued = false; \n```solidity\n    function _openQueuedTrade(uint256 queueId, uint256 price) internal {\n...\n        if (revisedFee < queuedTrade.totalFee) {\n            tokenX.transfer( //***@audit call transfer , if ERC777 , can re-enter ***/\n                queuedTrade.user,\n                queuedTrade.totalFee - revisedFee\n            );\n        }\n\n        queuedTrade.isQueued = false;  //****@audit  change state****/\n    }\n```\n3.if ERC777 re-enter to #cancelQueuedTrade() to get tokenX back,it can close,  because queuedTrade.isQueued still equal true\n4. back to _openQueuedTrade()  set queuedTrade.isQueued = false\n5.so steal tokenX\n## Impact\nif tokenX equal ERC777 can steal token\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferRouter.sol#L350\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nfollow “Checks Effects Interactions” \n\n```solidity\n    function _openQueuedTrade(uint256 queueId, uint256 price) internal {\n...\n+      queuedTrade.isQueued = false; \n        // Transfer the fee to the target options contract\n        IERC20 tokenX = IERC20(optionsContract.tokenX());\n        tokenX.transfer(queuedTrade.targetContract, revisedFee);\n\n-       queuedTrade.isQueued = false; \n        emit OpenTrade(queuedTrade.user, queueId, optionId);\n    }\n```\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/24",
  "Code": [
    {
      "filename": "contracts/contracts/core/BufferRouter.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"../interfaces/Interfaces.sol\";\n\n/**\n * @author Heisenberg\n * @notice Buffer Options Router Contract\n */\ncontract BufferRouter is AccessControl, IBufferRouter {\n    uint16 MAX_WAIT_TIME = 1 minutes;\n    uint256 public nextQueueId = 0;\n    address public publisher;\n    uint256 public nextQueueIdToProcess = 0;\n    bool public isInPrivateKeeperMode = true;\n\n    mapping(address => uint256[]) public userQueuedIds;\n    mapping(address => uint256[]) public userCancelledQueuedIds;\n    mapping(address => uint256) public userNextQueueIndexToProcess;\n    mapping(uint256 => QueuedTrade) public queuedTrades;\n    mapping(address => bool) public contractRegistry;\n    mapping(address => bool) public isKeeper;\n\n    constructor(address _publisher) {\n        publisher = _publisher;\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /************************************************\n     *  ADMIN ONLY FUNCTIONS\n     ***********************************************/\n\n    function setContractRegistry(address targetContract, bool register)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        contractRegistry[targetContract] = register;\n    }\n\n    function setKeeper(address _keeper, bool _isActive)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        isKeeper[_keeper] = _isActive;\n    }\n\n    function setInPrivateKeeperMode() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        isInPrivateKeeperMode = !isInPrivateKeeperMode;\n    }\n\n    /************************************************\n     *  USER WRITE FUNCTIONS\n     ***********************************************/\n\n    /**\n     * @notice Adds an option creation request in the queue\n     */\n    function initiateTrade(\n        uint256 totalFee,\n        uint256 period,\n        bool isAbove,\n        address targetContract,\n        uint256 expectedStrike,\n        uint256 slippage,\n        bool allowPartialFill,\n        string memory referralCode,\n        uint256 traderNFTId\n    ) external returns (uint256 queueId) {\n        // Checks if the target contract has been registered\n        require(\n            contractRegistry[targetContract],\n            \"Router: Unauthorized contract\"\n        );\n        IBufferBinaryOptions optionsContract = IBufferBinaryOptions(\n            targetContract\n        );\n\n        optionsContract.runInitialChecks(slippage, period, totalFee);\n\n        // Transfer the fee specified from the user to this contract.\n        // User has to approve first inorder to execute this function\n        IERC20(optionsContract.tokenX()).transferFrom(\n            msg.sender,\n            address(this),\n            totalFee\n        );\n        queueId = nextQueueId;\n        nextQueueId++;\n\n        QueuedTrade memory queuedTrade = QueuedTrade(\n            queueId,\n            userQueueCount(msg.sender),\n            msg.sender,\n            totalFee,\n            period,\n            isAbove,\n            targetContract,\n            expectedStrike,\n            slippage,\n            allowPartialFill,\n            block.timestamp,\n            true,\n            referralCode,\n            traderNFTId\n        );\n\n        queuedTrades[queueId] = queuedTrade;\n\n        userQueuedIds[msg.sender].push(queueId);\n\n        emit InitiateTrade(msg.sender, queueId, block.timestamp);\n    }\n\n    /**\n     * @notice Cancels a queued traded. Can only be called by the trade owner\n     */\n    function cancelQueuedTrade(uint256 queueId) external {\n        QueuedTrade memory queuedTrade = queuedTrades[queueId];\n        require(msg.sender == queuedTrade.user, \"Router: Forbidden\");\n        require(queuedTrade.isQueued, \"Router: Trade has already been opened\");\n        _cancelQueuedTrade(queueId);\n        emit CancelTrade(queuedTrade.user, queueId, \"User Cancelled\");\n    }\n\n    /************************************************\n     *  KEEPER ONLY FUNCTIONS\n     ***********************************************/\n\n    /**\n     * @notice Verifies the trade parameter via the signature and resolves all the valid queued trades\n     */\n    function resolveQueuedTrades(OpenTradeParams[] calldata params) external {\n        _validateKeeper();\n        for (uint32 index = 0; index < params.length; index++) {\n            OpenTradeParams memory currentParams = params[index];\n            QueuedTrade memory queuedTrade = queuedTrades[\n                currentParams.queueId\n            ];\n            bool isSignerVerifed = _validateSigner(\n                currentParams.timestamp,\n                currentParams.asset,\n                currentParams.price,\n                currentParams.signature\n            );\n            // Silently fail if the signature doesn't match\n            if (!isSignerVerifed) {\n                emit FailResolve(\n                    currentParams.queueId,\n                    \"Router: Signature didn't match\"\n                );\n                continue;\n            }\n            if (\n                !queuedTrade.isQueued ||\n                currentParams.timestamp != queuedTrade.queuedTime\n            ) {\n                // Trade has already been opened or cancelled or the timestamp is wrong.\n                // So ignore this trade.\n                continue;\n            }\n\n            // If the opening time is much greater than the queue time then cancel the trade\n            if (block.timestamp - queuedTrade.queuedTime <= MAX_WAIT_TIME) {\n                _openQueuedTrade(currentParams.queueId, currentParams.price);\n            } else {\n                _cancelQueuedTrade(currentParams.queueId);\n                emit CancelTrade(\n                    queuedTrade.user,\n                    currentParams.queueId,\n                    \"Wait time too high\"\n                );\n            }\n\n            // Track the next queueIndex to be processed for user\n            userNextQueueIndexToProcess[queuedTrade.user] =\n                queuedTrade.userQueueIndex +\n                1;\n        }\n        // Track the next queueIndex to be processed overall\n        nextQueueIdToProcess = params[params.length - 1].queueId + 1;\n    }\n\n    /**\n     * @notice Verifies the option parameter via the signature and unlocks an array of options\n     */\n    function unlockOptions(CloseTradeParams[] calldata optionData) external {\n        _validateKeeper();\n\n        uint32 arrayLength = uint32(optionData.length);\n        for (uint32 i = 0; i < arrayLength; i++) {\n            CloseTradeParams memory params = optionData[i];\n            IBufferBinaryOptions optionsContract = IBufferBinaryOptions(\n                params.asset\n            );\n            (, , , , , uint256 expiration, , , ) = optionsContract.options(\n                params.optionId\n            );\n\n            bool isSignerVerifed = _validateSigner(\n                params.expiryTimestamp,\n                params.asset,\n                params.priceAtExpiry,\n                params.signature\n            );\n\n            // Silently fail if the timestamp of the signature is wrong\n            if (expiration != params.expiryTimestamp) {\n                emit FailUnlock(params.optionId, \"Router: Wrong price\");\n                continue;\n            }\n\n            // Silently fail if the signature doesn't match\n            if (!isSignerVerifed) {\n                emit FailUnlock(\n                    params.optionId,\n                    \"Router: Signature didn't match\"\n                );\n                continue;\n            }\n\n            try\n                optionsContract.unlock(params.optionId, params.priceAtExpiry)\n            {} catch Error(string memory reason) {\n                emit FailUnlock(params.optionId, reason);\n                continue;\n            }\n        }\n    }\n\n    /************************************************\n     *  READ ONLY FUNCTIONS\n     ***********************************************/\n\n    function userQueueCount(address user) public view returns (uint256) {\n        return userQueuedIds[user].length;\n    }\n\n    function userCancelledQueueCount(address user)\n        external\n        view\n        returns (uint256)\n    {\n        return userCancelledQueuedIds[user].length;\n    }\n\n    /************************************************\n     *  INTERNAL FUNCTIONS\n     ***********************************************/\n    function _validateKeeper() private view {\n        require(\n            !isInPrivateKeeperMode || isKeeper[msg.sender],\n            \"Keeper: forbidden\"\n        );\n    }\n\n    function _validateSigner(\n        uint256 timestamp,\n        address asset,\n        uint256 price,\n        bytes memory signature\n    ) internal view returns (bool) {\n        bytes32 digest = ECDSA.toEthSignedMessageHash(\n            keccak256(abi.encodePacked(timestamp, asset, price))\n        );\n        address recoveredSigner = ECDSA.recover(digest, signature);\n        return recoveredSigner == publisher;\n    }\n\n    function _openQueuedTrade(uint256 queueId, uint256 price) internal {\n        QueuedTrade storage queuedTrade = queuedTrades[queueId];\n        IBufferBinaryOptions optionsContract = IBufferBinaryOptions(\n            queuedTrade.targetContract\n        );\n\n        // Check if slippage lies within the bounds\n        bool isSlippageWithinRange = optionsContract.isStrikeValid(\n            queuedTrade.slippage,\n            price,\n            queuedTrade.expectedStrike\n        );\n\n        if (!isSlippageWithinRange) {\n            _cancelQueuedTrade(queueId);\n            emit CancelTrade(\n                queuedTrade.user,\n                queueId,\n                \"Slippage limit exceeds\"\n            );\n\n            return;\n        }\n\n        // Check all the parameters and compute the amount and revised fee\n        uint256 amount;\n        uint256 revisedFee;\n        bool isReferralValid;\n        IBufferBinaryOptions.OptionParams\n            memory optionParams = IBufferBinaryOptions.OptionParams(\n                queuedTrade.expectedStrike,\n                0,\n                queuedTrade.period,\n                queuedTrade.isAbove,\n                queuedTrade.allowPartialFill,\n                queuedTrade.totalFee,\n                queuedTrade.user,\n                queuedTrade.referralCode,\n                queuedTrade.traderNFTId\n            );\n        try optionsContract.checkParams(optionParams) returns (\n            uint256 _amount,\n            uint256 _revisedFee,\n            bool _isReferralValid\n        ) {\n            (amount, revisedFee, isReferralValid) = (\n                _amount,\n                _revisedFee,\n                _isReferralValid\n            );\n        } catch Error(string memory reason) {\n            _cancelQueuedTrade(queueId);\n            emit CancelTrade(queuedTrade.user, queueId, reason);\n            return;\n        }\n\n        // Transfer the fee to the target options contract\n        IERC20 tokenX = IERC20(optionsContract.tokenX());\n        tokenX.transfer(queuedTrade.targetContract, revisedFee);\n\n        // Refund the user in case the trade amount was lesser\n        if (revisedFee < queuedTrade.totalFee) {\n            tokenX.transfer(\n                queuedTrade.user,\n                queuedTrade.totalFee - revisedFee\n            );\n        }\n\n        optionParams.totalFee = revisedFee;\n        optionParams.strike = price;\n        optionParams.amount = amount;\n\n        uint256 optionId = optionsContract.createFromRouter(\n            optionParams,\n            isReferralValid\n        );\n\n        queuedTrade.isQueued = false;\n\n        emit OpenTrade(queuedTrade.user, queueId, optionId);\n    }\n\n    function _cancelQueuedTrade(uint256 queueId) internal {\n        QueuedTrade storage queuedTrade = queuedTrades[queueId];\n        IBufferBinaryOptions optionsContract = IBufferBinaryOptions(\n            queuedTrade.targetContract\n        );\n        queuedTrade.isQueued = false;\n        IERC20(optionsContract.tokenX()).transfer(\n            queuedTrade.user,\n            queuedTrade.totalFee\n        );\n\n        userCancelledQueuedIds[queuedTrade.user].push(queueId);\n    }\n}"
    }
  ]
}