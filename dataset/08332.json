{
  "Title": "[Gâ€‘03]  `internal` functions only called once can be inlined to save gas",
  "Content": "\nNot inlining costs **20 to 40 gas** because of two extra `JUMP` instructions and additional stack operations needed for function calls.\n\n*There are 7 instances of this issue:*\n\n```solidity\nFile: contracts/auth/AxelarAuthWeighted.sol\n\n86        function _validateSignatures(\n87            bytes32 messageHash,\n88            address[] memory operators,\n89            uint256[] memory weights,\n90            uint256 threshold,\n91:           bytes[] memory signatures\n\n115:      function _isSortedAscAndContainsNoDuplicate(address[] memory accounts) internal pure returns (bool) {\n\n```\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/auth/AxelarAuthWeighted.sol#L86-L91>\n\n```solidity\nFile: contracts/AxelarGateway.sol\n\n611:      function _setTokenDailyMintAmount(string memory symbol, uint256 amount) internal {\n\n622:      function _setTokenAddress(string memory symbol, address tokenAddress) internal {\n\n630       function _setContractCallApproved(\n631           bytes32 commandId,\n632           string memory sourceChain,\n633           string memory sourceAddress,\n634           address contractAddress,\n635:          bytes32 payloadHash\n\n640       function _setContractCallApprovedWithMint(\n641           bytes32 commandId,\n642           string memory sourceChain,\n643           string memory sourceAddress,\n644           address contractAddress,\n645           bytes32 payloadHash,\n646           string memory symbol,\n647:          uint256 amount\n\n655:      function _setImplementation(address newImplementation) internal {\n\n```\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/AxelarGateway.sol#L611>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-07-axelar",
  "Code": [
    {
      "filename": "contracts/auth/AxelarAuthWeighted.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IAxelarAuthWeighted } from '../interfaces/IAxelarAuthWeighted.sol';\nimport { ECDSA } from '../ECDSA.sol';\nimport { Ownable } from '../Ownable.sol';\n\ncontract AxelarAuthWeighted is Ownable, IAxelarAuthWeighted {\n    uint256 public currentEpoch;\n    mapping(uint256 => bytes32) public hashForEpoch;\n    mapping(bytes32 => uint256) public epochForHash;\n\n    uint8 internal constant OLD_KEY_RETENTION = 16;\n\n    constructor(bytes[] memory recentOperators) {\n        for (uint256 i; i < recentOperators.length; ++i) {\n            _transferOperatorship(recentOperators[i]);\n        }\n    }\n\n    /**************************\\\n    |* External Functionality *|\n    \\**************************/\n\n    function validateProof(bytes32 messageHash, bytes calldata proof) external view returns (bool currentOperators) {\n        (address[] memory operators, uint256[] memory weights, uint256 threshold, bytes[] memory signatures) = abi.decode(\n            proof,\n            (address[], uint256[], uint256, bytes[])\n        );\n\n        bytes32 operatorsHash = keccak256(abi.encode(operators, weights, threshold));\n        uint256 operatorsEpoch = epochForHash[operatorsHash];\n        uint256 epoch = currentEpoch;\n\n        if (operatorsEpoch == 0 || epoch - operatorsEpoch >= OLD_KEY_RETENTION) revert InvalidOperators();\n\n        _validateSignatures(messageHash, operators, weights, threshold, signatures);\n\n        currentOperators = operatorsEpoch == epoch;\n    }\n\n    /***********************\\\n    |* Owner Functionality *|\n    \\***********************/\n\n    function transferOperatorship(bytes calldata params) external onlyOwner {\n        _transferOperatorship(params);\n    }\n\n    /**************************\\\n    |* Internal Functionality *|\n    \\**************************/\n\n    function _transferOperatorship(bytes memory params) internal {\n        (address[] memory newOperators, uint256[] memory newWeights, uint256 newThreshold) = abi.decode(\n            params,\n            (address[], uint256[], uint256)\n        );\n        uint256 operatorsLength = newOperators.length;\n        uint256 weightsLength = newWeights.length;\n\n        // operators must be sorted binary or alphabetically in lower case\n        if (operatorsLength == 0 || !_isSortedAscAndContainsNoDuplicate(newOperators)) revert InvalidOperators();\n\n        if (weightsLength != operatorsLength) revert InvalidWeights();\n\n        uint256 totalWeight = 0;\n        for (uint256 i = 0; i < weightsLength; ++i) {\n            totalWeight += newWeights[i];\n        }\n        if (newThreshold == 0 || totalWeight < newThreshold) revert InvalidThreshold();\n\n        bytes32 newOperatorsHash = keccak256(params);\n\n        if (epochForHash[newOperatorsHash] > 0) revert SameOperators();\n\n        uint256 epoch = currentEpoch + 1;\n        currentEpoch = epoch;\n        hashForEpoch[epoch] = newOperatorsHash;\n        epochForHash[newOperatorsHash] = epoch;\n\n        emit OperatorshipTransferred(newOperators, newWeights, newThreshold);\n    }\n\n    function _validateSignatures(\n        bytes32 messageHash,\n        address[] memory operators,\n        uint256[] memory weights,\n        uint256 threshold,\n        bytes[] memory signatures\n    ) internal pure {\n        uint256 operatorsLength = operators.length;\n        uint256 operatorIndex = 0;\n        uint256 weight = 0;\n        // looking for signers within operators\n        // assuming that both operators and signatures are sorted\n        for (uint256 i = 0; i < signatures.length; ++i) {\n            address signer = ECDSA.recover(messageHash, signatures[i]);\n            // looping through remaining operators to find a match\n            for (; operatorIndex < operatorsLength && signer != operators[operatorIndex]; ++operatorIndex) {}\n            // checking if we are out of operators\n            if (operatorIndex == operatorsLength) revert MalformedSigners();\n            // return if weight sum above threshold\n            weight += weights[operatorIndex];\n            // weight needs to reach or surpass threshold\n            if (weight >= threshold) return;\n            // increasing operators index if match was found\n            ++operatorIndex;\n        }\n        // if weight sum below threshold\n        revert MalformedSigners();\n    }\n\n    function _isSortedAscAndContainsNoDuplicate(address[] memory accounts) internal pure returns (bool) {\n        for (uint256 i; i < accounts.length - 1; ++i) {\n            if (accounts[i] >= accounts[i + 1]) {\n                return false;\n            }\n        }\n\n        return accounts[0] != address(0);\n    }\n}"
    },
    {
      "filename": "contracts/AxelarGateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IAxelarGateway } from './interfaces/IAxelarGateway.sol';\nimport { IAxelarAuth } from './interfaces/IAxelarAuth.sol';\nimport { IERC20 } from './interfaces/IERC20.sol';\nimport { IBurnableMintableCappedERC20 } from './interfaces/IBurnableMintableCappedERC20.sol';\nimport { ITokenDeployer } from './interfaces/ITokenDeployer.sol';\n\nimport { ECDSA } from './ECDSA.sol';\nimport { DepositHandler } from './DepositHandler.sol';\nimport { AdminMultisigBase } from './AdminMultisigBase.sol';\n\ncontract AxelarGateway is IAxelarGateway, AdminMultisigBase {\n    enum TokenType {\n        InternalBurnable,\n        InternalBurnableFrom,\n        External\n    }\n\n    /// @dev Removed slots; Should avoid re-using\n    // bytes32 internal constant KEY_ALL_TOKENS_FROZEN = keccak256('all-tokens-frozen');\n    // bytes32 internal constant PREFIX_TOKEN_FROZEN = keccak256('token-frozen');\n\n    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.implementation') - 1`.\n    bytes32 internal constant KEY_IMPLEMENTATION = bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);\n\n    // AUDIT: slot names should be prefixed with some standard string\n    bytes32 internal constant PREFIX_COMMAND_EXECUTED = keccak256('command-executed');\n    bytes32 internal constant PREFIX_TOKEN_ADDRESS = keccak256('token-address');\n    bytes32 internal constant PREFIX_TOKEN_TYPE = keccak256('token-type');\n    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED = keccak256('contract-call-approved');\n    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT = keccak256('contract-call-approved-with-mint');\n    bytes32 internal constant PREFIX_TOKEN_DAILY_MINT_LIMIT = keccak256('token-daily-mint-limit');\n    bytes32 internal constant PREFIX_TOKEN_DAILY_MINT_AMOUNT = keccak256('token-daily-mint-amount');\n\n    bytes32 internal constant SELECTOR_BURN_TOKEN = keccak256('burnToken');\n    bytes32 internal constant SELECTOR_DEPLOY_TOKEN = keccak256('deployToken');\n    bytes32 internal constant SELECTOR_MINT_TOKEN = keccak256('mintToken');\n    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL = keccak256('approveContractCall');\n    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT = keccak256('approveContractCallWithMint');\n    bytes32 internal constant SELECTOR_TRANSFER_OPERATORSHIP = keccak256('transferOperatorship');\n\n    address internal immutable AUTH_MODULE;\n    address internal immutable TOKEN_DEPLOYER_IMPLEMENTATION;\n\n    constructor(address authModule, address tokenDeployerImplementation) {\n        if (authModule.code.length == 0) revert InvalidAuthModule();\n        if (tokenDeployerImplementation.code.length == 0) revert InvalidTokenDeployer();\n\n        AUTH_MODULE = authModule;\n        TOKEN_DEPLOYER_IMPLEMENTATION = tokenDeployerImplementation;\n    }\n\n    modifier onlySelf() {\n        if (msg.sender != address(this)) revert NotSelf();\n\n        _;\n    }\n\n    /******************\\\n    |* Public Methods *|\n    \\******************/\n\n    function sendToken(\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        string calldata symbol,\n        uint256 amount\n    ) external {\n        _burnTokenFrom(msg.sender, symbol, amount);\n        emit TokenSent(msg.sender, destinationChain, destinationAddress, symbol, amount);\n    }\n\n    function callContract(\n        string calldata destinationChain,\n        string calldata destinationContractAddress,\n        bytes calldata payload\n    ) external {\n        emit ContractCall(msg.sender, destinationChain, destinationContractAddress, keccak256(payload), payload);\n    }\n\n    function callContractWithToken(\n        string calldata destinationChain,\n        string calldata destinationContractAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount\n    ) external {\n        _burnTokenFrom(msg.sender, symbol, amount);\n        emit ContractCallWithToken(msg.sender, destinationChain, destinationContractAddress, keccak256(payload), payload, symbol, amount);\n    }\n\n    function isContractCallApproved(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) external view override returns (bool) {\n        return getBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash));\n    }\n\n    function isContractCallAndMintApproved(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) external view override returns (bool) {\n        return\n            getBool(\n                _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount)\n            );\n    }\n\n    function validateContractCall(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash\n    ) external override returns (bool valid) {\n        bytes32 key = _getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, msg.sender, payloadHash);\n        valid = getBool(key);\n        if (valid) _setBool(key, false);\n    }\n\n    function validateContractCallAndMint(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) external override returns (bool valid) {\n        bytes32 key = _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, msg.sender, payloadHash, symbol, amount);\n        valid = getBool(key);\n        if (valid) {\n            // Prevent re-entrancy\n            _setBool(key, false);\n            _mintToken(symbol, msg.sender, amount);\n        }\n    }\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function tokenDailyMintLimit(string memory symbol) public view override returns (uint256) {\n        return getUint(_getTokenDailyMintLimitKey(symbol));\n    }\n\n    function tokenDailyMintAmount(string memory symbol) public view override returns (uint256) {\n        return getUint(_getTokenDailyMintAmountKey(symbol, block.timestamp / 1 days));\n    }\n\n    function allTokensFrozen() external pure override returns (bool) {\n        return false;\n    }\n\n    function implementation() public view override returns (address) {\n        return getAddress(KEY_IMPLEMENTATION);\n    }\n\n    function tokenAddresses(string memory symbol) public view override returns (address) {\n        return getAddress(_getTokenAddressKey(symbol));\n    }\n\n    function tokenFrozen(string memory) external pure override returns (bool) {\n        return false;\n    }\n\n    function isCommandExecuted(bytes32 commandId) public view override returns (bool) {\n        return getBool(_getIsCommandExecutedKey(commandId));\n    }\n\n    /// @dev Returns the current `adminEpoch`.\n    function adminEpoch() external view override returns (uint256) {\n        return _adminEpoch();\n    }\n\n    /// @dev Returns the admin threshold for a given `adminEpoch`.\n    function adminThreshold(uint256 epoch) external view override returns (uint256) {\n        return _getAdminThreshold(epoch);\n    }\n\n    /// @dev Returns the array of admins within a given `adminEpoch`.\n    function admins(uint256 epoch) external view override returns (address[] memory results) {\n        uint256 adminCount = _getAdminCount(epoch);\n        results = new address[](adminCount);\n\n        for (uint256 i; i < adminCount; ++i) {\n            results[i] = _getAdmin(epoch, i);\n        }\n    }\n\n    /*******************\\\n    |* Admin Functions *|\n    \\*******************/\n\n    function setTokenDailyMintLimits(string[] calldata symbols, uint256[] calldata limits) external override onlyAdmin {\n        if (symbols.length != limits.length) revert InvalidSetDailyMintLimitsParams();\n\n        for (uint256 i = 0; i < symbols.length; i++) {\n            string memory symbol = symbols[i];\n            uint256 limit = limits[i];\n\n            if (tokenAddresses(symbol) == address(0)) revert TokenDoesNotExist(symbol);\n\n            _setTokenDailyMintLimit(symbol, limit);\n        }\n    }\n\n    function upgrade(\n        address newImplementation,\n        bytes32 newImplementationCodeHash,\n        bytes calldata setupParams\n    ) external override onlyAdmin {\n        if (newImplementationCodeHash != newImplementation.codehash) revert InvalidCodeHash();\n\n        emit Upgraded(newImplementation);\n\n        // AUDIT: If `newImplementation.setup` performs `selfdestruct`, it will result in the loss of _this_ implementation (thereby losing the gateway)\n        //        if `upgrade` is entered within the context of _this_ implementation itself.\n        if (setupParams.length != 0) {\n            (bool success, ) = newImplementation.delegatecall(abi.encodeWithSelector(IAxelarGateway.setup.selector, setupParams));\n\n            if (!success) revert SetupFailed();\n        }\n\n        _setImplementation(newImplementation);\n    }\n\n    /**********************\\\n    |* External Functions *|\n    \\**********************/\n\n    function setup(bytes calldata params) external override {\n        // Prevent setup from being called on a non-proxy (the implementation).\n        if (implementation() == address(0)) revert NotProxy();\n\n        (address[] memory adminAddresses, uint256 newAdminThreshold, bytes memory newOperatorsData) = abi.decode(\n            params,\n            (address[], uint256, bytes)\n        );\n\n        // NOTE: Admin epoch is incremented to easily invalidate current admin-related state.\n        uint256 newAdminEpoch = _adminEpoch() + uint256(1);\n        _setAdminEpoch(newAdminEpoch);\n        _setAdmins(newAdminEpoch, adminAddresses, newAdminThreshold);\n\n        if (newOperatorsData.length > 0) {\n            IAxelarAuth(AUTH_MODULE).transferOperatorship(newOperatorsData);\n\n            emit OperatorshipTransferred(newOperatorsData);\n        }\n    }\n\n    function execute(bytes calldata input) external override {\n        (bytes memory data, bytes memory proof) = abi.decode(input, (bytes, bytes));\n\n        bytes32 messageHash = ECDSA.toEthSignedMessageHash(keccak256(data));\n\n        // TEST auth and getaway separately\n        bool currentOperators = IAxelarAuth(AUTH_MODULE).validateProof(messageHash, proof);\n\n        uint256 chainId;\n        bytes32[] memory commandIds;\n        string[] memory commands;\n        bytes[] memory params;\n\n        try AxelarGateway(this)._unpackLegacyCommands(data) returns (\n            uint256 chainId_,\n            bytes32[] memory commandIds_,\n            string[] memory commands_,\n            bytes[] memory params_\n        ) {\n            (chainId, commandIds, commands, params) = (chainId_, commandIds_, commands_, params_);\n        } catch {\n            (chainId, commandIds, commands, params) = abi.decode(data, (uint256, bytes32[], string[], bytes[]));\n        }\n\n        if (chainId != block.chainid) revert InvalidChainId();\n\n        uint256 commandsLength = commandIds.length;\n\n        if (commandsLength != commands.length || commandsLength != params.length) revert InvalidCommands();\n\n        for (uint256 i; i < commandsLength; ++i) {\n            bytes32 commandId = commandIds[i];\n\n            if (isCommandExecuted(commandId)) continue; /* Ignore if duplicate commandId received */\n\n            bytes4 commandSelector;\n            bytes32 commandHash = keccak256(abi.encodePacked(commands[i]));\n\n            if (commandHash == SELECTOR_DEPLOY_TOKEN) {\n                commandSelector = AxelarGateway.deployToken.selector;\n            } else if (commandHash == SELECTOR_MINT_TOKEN) {\n                commandSelector = AxelarGateway.mintToken.selector;\n            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL) {\n                commandSelector = AxelarGateway.approveContractCall.selector;\n            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT) {\n                commandSelector = AxelarGateway.approveContractCallWithMint.selector;\n            } else if (commandHash == SELECTOR_BURN_TOKEN) {\n                commandSelector = AxelarGateway.burnToken.selector;\n            } else if (commandHash == SELECTOR_TRANSFER_OPERATORSHIP) {\n                if (!currentOperators) continue;\n\n                commandSelector = AxelarGateway.transferOperatorship.selector;\n            } else {\n                continue; /* Ignore if unknown command received */\n            }\n\n            // Prevent a re-entrancy from executing this command before it can be marked as successful.\n            _setCommandExecuted(commandId, true);\n            (bool success, ) = address(this).call(abi.encodeWithSelector(commandSelector, params[i], commandId));\n\n            if (success) emit Executed(commandId);\n            else _setCommandExecuted(commandId, false);\n        }\n    }\n\n    /******************\\\n    |* Self Functions *|\n    \\******************/\n\n    function deployToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory name, string memory symbol, uint8 decimals, uint256 cap, address tokenAddress, uint256 dailyMintLimit) = abi.decode(\n            params,\n            (string, string, uint8, uint256, address, uint256)\n        );\n\n        // Ensure that this symbol has not been taken.\n        if (tokenAddresses(symbol) != address(0)) revert TokenAlreadyExists(symbol);\n\n        if (tokenAddress == address(0)) {\n            // If token address is no specified, it indicates a request to deploy one.\n            bytes32 salt = keccak256(abi.encodePacked(symbol));\n\n            (bool success, bytes memory data) = TOKEN_DEPLOYER_IMPLEMENTATION.delegatecall(\n                abi.encodeWithSelector(ITokenDeployer.deployToken.selector, name, symbol, decimals, cap, salt)\n            );\n\n            if (!success) revert TokenDeployFailed(symbol);\n\n            tokenAddress = abi.decode(data, (address));\n\n            _setTokenType(symbol, TokenType.InternalBurnableFrom);\n        } else {\n            // If token address is specified, ensure that there is a contact at the specified address.\n            if (tokenAddress.code.length == uint256(0)) revert TokenContractDoesNotExist(tokenAddress);\n\n            // Mark that this symbol is an external token, which is needed to differentiate between operations on mint and burn.\n            _setTokenType(symbol, TokenType.External);\n        }\n\n        _setTokenAddress(symbol, tokenAddress);\n        _setTokenDailyMintLimit(symbol, dailyMintLimit);\n\n        emit TokenDeployed(symbol, tokenAddress);\n    }\n\n    function mintToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory symbol, address account, uint256 amount) = abi.decode(params, (string, address, uint256));\n\n        _mintToken(symbol, account, amount);\n    }\n\n    function burnToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory symbol, bytes32 salt) = abi.decode(params, (string, bytes32));\n\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n\n        if (_getTokenType(symbol) == TokenType.External) {\n            DepositHandler depositHandler = new DepositHandler{ salt: salt }();\n\n            (bool success, bytes memory returnData) = depositHandler.execute(\n                tokenAddress,\n                abi.encodeWithSelector(IERC20.transfer.selector, address(this), IERC20(tokenAddress).balanceOf(address(depositHandler)))\n            );\n\n            if (!success || (returnData.length != uint256(0) && !abi.decode(returnData, (bool)))) revert BurnFailed(symbol);\n\n            // NOTE: `depositHandler` must always be destroyed in the same runtime context that it is deployed.\n            depositHandler.destroy(address(this));\n        } else {\n            IBurnableMintableCappedERC20(tokenAddress).burn(salt);\n        }\n    }\n\n    function approveContractCall(bytes calldata params, bytes32 commandId) external onlySelf {\n        (\n            string memory sourceChain,\n            string memory sourceAddress,\n            address contractAddress,\n            bytes32 payloadHash,\n            bytes32 sourceTxHash,\n            uint256 sourceEventIndex\n        ) = abi.decode(params, (string, string, address, bytes32, bytes32, uint256));\n\n        _setContractCallApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash);\n        emit ContractCallApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, sourceTxHash, sourceEventIndex);\n    }\n\n    function approveContractCallWithMint(bytes calldata params, bytes32 commandId) external onlySelf {\n        (\n            string memory sourceChain,\n            string memory sourceAddress,\n            address contractAddress,\n            bytes32 payloadHash,\n            string memory symbol,\n            uint256 amount,\n            bytes32 sourceTxHash,\n            uint256 sourceEventIndex\n        ) = abi.decode(params, (string, string, address, bytes32, string, uint256, bytes32, uint256));\n\n        _setContractCallApprovedWithMint(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount);\n        emit ContractCallApprovedWithMint(\n            commandId,\n            sourceChain,\n            sourceAddress,\n            contractAddress,\n            payloadHash,\n            symbol,\n            amount,\n            sourceTxHash,\n            sourceEventIndex\n        );\n    }\n\n    function transferOperatorship(bytes calldata newOperatorsData, bytes32) external onlySelf {\n        IAxelarAuth(AUTH_MODULE).transferOperatorship(newOperatorsData);\n\n        emit OperatorshipTransferred(newOperatorsData);\n    }\n\n    /********************\\\n    |* Internal Methods *|\n    \\********************/\n\n    function _unpackLegacyCommands(bytes memory executeData)\n        external\n        pure\n        returns (\n            uint256 chainId,\n            bytes32[] memory commandIds,\n            string[] memory commands,\n            bytes[] memory params\n        )\n    {\n        (chainId, , commandIds, commands, params) = abi.decode(executeData, (uint256, uint256, bytes32[], string[], bytes[]));\n    }\n\n    function _callERC20Token(address tokenAddress, bytes memory callData) internal returns (bool) {\n        (bool success, bytes memory returnData) = tokenAddress.call(callData);\n        return success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\n    }\n\n    function _mintToken(\n        string memory symbol,\n        address account,\n        uint256 amount\n    ) internal {\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n\n        _setTokenDailyMintAmount(symbol, tokenDailyMintAmount(symbol) + amount);\n\n        if (_getTokenType(symbol) == TokenType.External) {\n            bool success = _callERC20Token(tokenAddress, abi.encodeWithSelector(IERC20.transfer.selector, account, amount));\n\n            if (!success) revert MintFailed(symbol);\n        } else {\n            IBurnableMintableCappedERC20(tokenAddress).mint(account, amount);\n        }\n    }\n\n    function _burnTokenFrom(\n        address sender,\n        string memory symbol,\n        uint256 amount\n    ) internal {\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n        if (amount == 0) revert InvalidAmount();\n\n        TokenType tokenType = _getTokenType(symbol);\n        bool burnSuccess;\n\n        if (tokenType == TokenType.External) {\n            burnSuccess = _callERC20Token(\n                tokenAddress,\n                abi.encodeWithSelector(IERC20.transferFrom.selector, sender, address(this), amount)\n            );\n\n            if (!burnSuccess) revert BurnFailed(symbol);\n\n            return;\n        }\n\n        if (tokenType == TokenType.InternalBurnableFrom) {\n            burnSuccess = _callERC20Token(\n                tokenAddress,\n                abi.encodeWithSelector(IBurnableMintableCappedERC20.burnFrom.selector, sender, amount)\n            );\n\n            if (!burnSuccess) revert BurnFailed(symbol);\n\n            return;\n        }\n\n        burnSuccess = _callERC20Token(\n            tokenAddress,\n            abi.encodeWithSelector(\n                IERC20.transferFrom.selector,\n                sender,\n                IBurnableMintableCappedERC20(tokenAddress).depositAddress(bytes32(0)),\n                amount\n            )\n        );\n\n        if (!burnSuccess) revert BurnFailed(symbol);\n\n        IBurnableMintableCappedERC20(tokenAddress).burn(bytes32(0));\n    }\n\n    /********************\\\n    |* Pure Key Getters *|\n    \\********************/\n\n    function _getTokenDailyMintLimitKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_DAILY_MINT_LIMIT, symbol));\n    }\n\n    function _getTokenDailyMintAmountKey(string memory symbol, uint256 day) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_DAILY_MINT_AMOUNT, symbol, day));\n    }\n\n    function _getTokenTypeKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_TYPE, symbol));\n    }\n\n    function _getTokenAddressKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_ADDRESS, symbol));\n    }\n\n    function _getIsCommandExecutedKey(bytes32 commandId) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_COMMAND_EXECUTED, commandId));\n    }\n\n    function _getIsContractCallApprovedKey(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encode(PREFIX_CONTRACT_CALL_APPROVED, commandId, sourceChain, sourceAddress, contractAddress, payloadHash));\n    }\n\n    function _getIsContractCallApprovedWithMintKey(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT,\n                    commandId,\n                    sourceChain,\n                    sourceAddress,\n                    contractAddress,\n                    payloadHash,\n                    symbol,\n                    amount\n                )\n            );\n    }\n\n    /********************\\\n    |* Internal Getters *|\n    \\********************/\n\n    function _getTokenType(string memory symbol) internal view returns (TokenType) {\n        return TokenType(getUint(_getTokenTypeKey(symbol)));\n    }\n\n    /********************\\\n    |* Internal Setters *|\n    \\********************/\n\n    function _setTokenDailyMintLimit(string memory symbol, uint256 limit) internal {\n        _setUint(_getTokenDailyMintLimitKey(symbol), limit);\n\n        emit TokenDailyMintLimitUpdated(symbol, limit);\n    }\n\n    function _setTokenDailyMintAmount(string memory symbol, uint256 amount) internal {\n        uint256 limit = tokenDailyMintLimit(symbol);\n        if (limit > 0 && amount > limit) revert ExceedDailyMintLimit(symbol);\n\n        _setUint(_getTokenDailyMintAmountKey(symbol, block.timestamp / 1 days), amount);\n    }\n\n    function _setTokenType(string memory symbol, TokenType tokenType) internal {\n        _setUint(_getTokenTypeKey(symbol), uint256(tokenType));\n    }\n\n    function _setTokenAddress(string memory symbol, address tokenAddress) internal {\n        _setAddress(_getTokenAddressKey(symbol), tokenAddress);\n    }\n\n    function _setCommandExecuted(bytes32 commandId, bool executed) internal {\n        _setBool(_getIsCommandExecutedKey(commandId), executed);\n    }\n\n    function _setContractCallApproved(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) internal {\n        _setBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash), true);\n    }\n\n    function _setContractCallApprovedWithMint(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) internal {\n        _setBool(\n            _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount),\n            true\n        );\n    }\n\n    function _setImplementation(address newImplementation) internal {\n        _setAddress(KEY_IMPLEMENTATION, newImplementation);\n    }\n}"
    }
  ]
}