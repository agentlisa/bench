{
  "Title": "Confusing examples",
  "Content": "The [`upgradeable-contracts` example](https://github.com/paritytech/ink/tree/c8aa3ee41112b327d4f3cb3959f188945c8ccace/examples/upgradeable-contracts) shows two ways of implementing upgradeability:\n\n\n* The first one, implemented in the [`set-code-hash`](https://github.com/paritytech/ink/tree/c8aa3ee41112b327d4f3cb3959f188945c8ccace/examples/upgradeable-contracts/set-code-hash) directory, shows how a smart contract written in ink! can be upgraded by updating the implementation logic through the `ink::env::set_code_hash` function.\n* [The second one, `forward-calls`](https://github.com/paritytech/ink/tree/c8aa3ee41112b327d4f3cb3959f188945c8ccace/examples/upgradeable-contracts/forward-calls), shows how to perform upgrades by using proxies. Similarly to well-known implementations of the Proxy pattern in solidity, the idea in this approach is to forward calls from the Proxy contract to an implementation contract, using the context of the former but the logic of the latter.\n\n\nThe issue lies in the fact that, in the latter, the [`forward` function](https://github.com/paritytech/ink/blob/c8aa3ee41112b327d4f3cb3959f188945c8ccace/examples/upgradeable-contracts/forward-calls/lib.rs#L71) does not use the implementation of `delegatecall` but performs a regular call operation instead. As a result, the context and storage used in this example will not be the one of the Proxy, but the implementation, breaking the upgradeability pattern.\n\n\nIt is suggested to improve the documentation of how `delegatecall` works in ink! by including examples of both upgradeable and non-upgradeable proxies. Additionally, consider updating the mentioned example using delegate instead of regular calls.\n\n\n***Update:** Resolved in [pull request #1697](https://github.com/paritytech/ink/pull/1697) and [pull request #1704](https://github.com/paritytech/ink/pull/1704).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "examples/upgradeable-contracts/forward-calls/lib.rs",
      "content": "//! This example demonstrates how the Proxy/Forward pattern can be\n//! implemented in ink!.\n//!\n//! What the contract does is:\n//!\n//!   * Any call to this contract that does not match a selector\n//!     of it is forwarded to a specified address.\n//!   * The instantiator of the contract can modify this specified\n//!     `forward_to` address at any point.\n//!\n//! Using this pattern it is possible to implement upgradeable contracts.\n//!\n//! Note though that the contract to which calls are forwarded still\n//! contains it's own state.\n\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\n#[ink::contract]\npub mod proxy {\n    use ink::env::call::Call;\n\n    /// A simple proxy contract.\n    #[ink(storage)]\n    pub struct Proxy {\n        /// The `AccountId` of a contract where any call that does not match a\n        /// selector of this contract is forwarded to.\n        forward_to: AccountId,\n        /// The `AccountId` of a privileged account that can update the\n        /// forwarding address. This address is set to the account that\n        /// instantiated this contract.\n        admin: AccountId,\n    }\n\n    impl Proxy {\n        /// Instantiate this contract with an address of the `logic` contract.\n        ///\n        /// Sets the privileged account to the caller. Only this account may\n        /// later changed the `forward_to` address.\n        #[ink(constructor)]\n        pub fn new(forward_to: AccountId) -> Self {\n            Self {\n                admin: Self::env().caller(),\n                forward_to,\n            }\n        }\n\n        /// Changes the `AccountId` of the contract where any call that does\n        /// not match a selector of this contract is forwarded to.\n        #[ink(message)]\n        pub fn change_forward_address(&mut self, new_address: AccountId) {\n            assert_eq!(\n                self.env().caller(),\n                self.admin,\n                \"caller {:?} does not have sufficient permissions, only {:?} does\",\n                self.env().caller(),\n                self.admin,\n            );\n            self.forward_to = new_address;\n        }\n\n        /// Fallback message for a contract call that doesn't match any\n        /// of the other message selectors.\n        ///\n        /// # Note:\n        ///\n        /// - We allow payable messages here and would forward any optionally supplied\n        ///   value as well.\n        /// - If the self receiver were `forward(&mut self)` here, this would not\n        ///   have any effect whatsoever on the contract we forward to.\n        #[ink(message, payable, selector = _)]\n        pub fn forward(&self) -> u32 {\n            ink::env::call::build_call::<ink::env::DefaultEnvironment>()\n                .call_type(\n                    Call::new()\n                        .callee(self.forward_to)\n                        .transferred_value(self.env().transferred_value())\n                        .gas_limit(0),\n                )\n                .call_flags(\n                    ink::env::CallFlags::default()\n                        .set_forward_input(true)\n                        .set_tail_call(true),\n                )\n                .try_invoke()\n                .unwrap_or_else(|env_err| {\n                    panic!(\n                        \"cross-contract call to {:?} failed due to {:?}\",\n                        self.forward_to, env_err\n                    )\n                })\n                .unwrap_or_else(|lang_err| {\n                    panic!(\n                        \"cross-contract call to {:?} failed due to {:?}\",\n                        self.forward_to, lang_err\n                    )\n                });\n            unreachable!(\n                \"the forwarded call will never return since `tail_call` was set\"\n            );\n        }\n    }\n}"
    }
  ]
}