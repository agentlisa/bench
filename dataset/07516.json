{
  "Title": "[L-02] Use ```safeTransferOwnership``` instead of ```transferOwnership``` function",
  "Content": "\n[FixedPriceFactory.sol#L9](https://github.com/code-423n4/2022-12escher/blob/main/src/minters/FixedPriceFactory.sol#L9)\n\n[LPDAFactory.sol#L9](https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDAFactory.sol#L9)\n\n[OpenEditionFactory.sol#L9](https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/OpenEditionFactory.sol#L9)\n\n```transferOwnership``` function is used to change Ownership from ```Ownable.sol```.\n\nUse a 2 structure transferOwnership which is safer. \n```safeTransferOwnership```,  use is more secure due to 2-stage ownership transfer.\n\n### Recommended Mitigation Steps\n\nUse ``Ownable2Step.sol``\n\n[Ownable2Step.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable2Step.sol)\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-12-escher-contest",
  "Code": [
    {
      "filename": "src/minters/LPDAFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {LPDA} from \"./LPDA.sol\";\nimport {Ownable} from \"openzeppelin/access/Ownable.sol\";\nimport {Clones} from \"openzeppelin/proxy/Clones.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\n\ncontract LPDAFactory is Ownable {\n    using Clones for address;\n\n    address payable public feeReceiver;\n    address public immutable implementation;\n\n    event NewLPDAContract(\n        address indexed _creator,\n        address indexed _edition,\n        address indexed _saleContract,\n        LPDA.Sale _saleInfo\n    );\n\n    constructor() Ownable() {\n        implementation = address(new LPDA());\n        feeReceiver = payable(msg.sender);\n    }\n\n    /// @notice create a fixed sale proxy contract\n    /// @param sale the sale info\n    function createLPDASale(LPDA.Sale calldata sale) external returns (address clone) {\n        require(IEscher721(sale.edition).hasRole(bytes32(0x00), msg.sender), \"NOT AUTHORIZED\");\n        require(sale.saleReceiver != address(0), \"INVALID SALE RECEIVER\");\n        require(sale.startTime >= block.timestamp, \"INVALID START TIME\");\n        require(sale.endTime > sale.startTime, \"INVALID END TIME\");\n        require(sale.finalId > sale.currentId, \"INVALID FINAL ID\");\n        require(sale.startPrice > 0, \"INVALID START PRICE\");\n        require(sale.dropPerSecond > 0, \"INVALID DROP PER SECOND\");\n\n        clone = implementation.clone();\n        LPDA(clone).initialize(sale);\n\n        emit NewLPDAContract(msg.sender, sale.edition, clone, sale);\n    }\n\n    /// @notice set the fee receiver for fixed price editions\n    /// @param fees the address to receive fees\n    function setFeeReceiver(address payable fees) public onlyOwner {\n        feeReceiver = fees;\n    }\n}"
    },
    {
      "filename": "src/minters/OpenEditionFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {OpenEdition} from \"./OpenEdition.sol\";\nimport {Ownable} from \"openzeppelin/access/Ownable.sol\";\nimport {Clones} from \"openzeppelin/proxy/Clones.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\n\ncontract OpenEditionFactory is Ownable {\n    using Clones for address;\n\n    address payable public feeReceiver;\n    address public immutable implementation;\n\n    event NewOpenEditionContract(\n        address indexed creator,\n        address indexed edition,\n        address indexed saleContract,\n        OpenEdition.Sale saleInfo\n    );\n\n    constructor() Ownable() {\n        implementation = address(new OpenEdition());\n        feeReceiver = payable(msg.sender);\n    }\n\n    /// @notice create a fixed sale proxy contract\n    /// @param sale the sale info\n    function createOpenEdition(OpenEdition.Sale calldata sale) external returns (address clone) {\n        require(IEscher721(sale.edition).hasRole(bytes32(0x00), msg.sender), \"NOT AUTHORIZED\");\n        require(sale.startTime >= block.timestamp, \"START TIME IN PAST\");\n        require(sale.endTime > sale.startTime, \"END TIME BEFORE START\");\n\n        clone = implementation.clone();\n        OpenEdition(clone).initialize(sale);\n\n        emit NewOpenEditionContract(msg.sender, sale.edition, clone, sale);\n    }\n\n    /// @notice set the fee receiver for fixed price editions\n    /// @param fees the address to receive fees\n    function setFeeReceiver(address payable fees) public onlyOwner {\n        feeReceiver = fees;\n    }\n}"
    }
  ]
}