{
  "Title": "Debt Socialization Can Be Prevented",
  "Content": "The current implementation of the liquidation process [checks at the end](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/modules/Liquidation.sol#L204-L214) of the liquidation process if the entire debt has been repaid, and if not, whether there is any remaining collateral that can be liquidated. If there is no more collateral to liquidate, [the debt might be socialized](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/modules/Liquidation.sol#L208-L213), depending on the configuration.\n\n\nHowever, the issue arises in the [`checkNoCollateral`](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/shared/LiquidityUtils.sol#L58-L69) function responsible for checking if there is any collateral left. It iterates over the collateral and checks the balance for each. If the [balance is greater than 0](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/shared/LiquidityUtils.sol#L64-L65), it assumes there is still collateral to liquidate, thereby preventing the debt from being subject to liquidation. This creates a scenario where any violator who owns just 1 share of the recognized collateral can prevent debt socialization. Consequently, bad debt can continue accruing interest and worsen the situation.\n\n\nConsider redesigning the debt socialization logic to ensure that the debt is correctly socialized, even in scenarios where just some dust of the collateral is present.\n\n\n***Update:** Resolved. The Euler team stated:*\n\n\n\n> *We acknowledge the issue. Since the EVC enforces a limit on the number of collateral assets (and vaults can enforce a lower limit via hooks), somebody who wishes to socialise debt can construct a batch transaction that atomically liquidates each collateral asset without running into significant gas costs: Most of the gas costs will be amortised since storage is warmed by the first liquidation. This method can be used to socialise the debt of an active violator who front-runs 1 wei deposits.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/EVault/modules/Liquidation.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {ILiquidation} from \"../IEVault.sol\";\nimport {Base} from \"../shared/Base.sol\";\nimport {BalanceUtils} from \"../shared/BalanceUtils.sol\";\nimport {LiquidityUtils} from \"../shared/LiquidityUtils.sol\";\n\nimport \"../shared/types/Types.sol\";\n\n/// @title LiquidationModule\n/// @author Euler Labs (https://www.eulerlabs.com/)\n/// @notice An EVault module handling liquidations of unhealthy accounts\nabstract contract LiquidationModule is ILiquidation, Base, BalanceUtils, LiquidityUtils {\n    using TypesLib for uint256;\n\n    // Maximum liquidation discount that can be awarded under any conditions.\n    uint256 constant MAXIMUM_LIQUIDATION_DISCOUNT = 0.2 * 1e18;\n\n    struct LiquidationCache {\n        address liquidator;\n        address violator;\n        address collateral;\n        address[] collaterals;\n        Assets liability;\n        Assets repay;\n        uint256 yieldBalance;\n    }\n\n    /// @inheritdoc ILiquidation\n    function checkLiquidation(address liquidator, address violator, address collateral)\n        public\n        view\n        virtual\n        nonReentrantView\n        returns (uint256 maxRepay, uint256 maxYield)\n    {\n        LiquidationCache memory liqCache =\n            calculateLiquidation(loadVault(), liquidator, violator, collateral, type(uint256).max);\n\n        maxRepay = liqCache.repay.toUint();\n        maxYield = liqCache.yieldBalance;\n    }\n\n    /// @inheritdoc ILiquidation\n    function liquidate(address violator, address collateral, uint256 repayAssets, uint256 minYieldBalance)\n        public\n        virtual\n        nonReentrant\n    {\n        (VaultCache memory vaultCache, address liquidator) = initOperation(OP_LIQUIDATE, CHECKACCOUNT_CALLER);\n\n        LiquidationCache memory liqCache =\n            calculateLiquidation(vaultCache, liquidator, violator, collateral, repayAssets);\n\n        executeLiquidation(vaultCache, liqCache, minYieldBalance);\n    }\n\n    function calculateLiquidation(\n        VaultCache memory vaultCache,\n        address liquidator,\n        address violator,\n        address collateral,\n        uint256 desiredRepay\n    ) private view returns (LiquidationCache memory liqCache) {\n        // Init cache\n\n        liqCache.liquidator = liquidator;\n        liqCache.violator = violator;\n        liqCache.collateral = collateral;\n\n        liqCache.repay = Assets.wrap(0);\n        liqCache.yieldBalance = 0;\n        liqCache.liability = getCurrentOwed(vaultCache, violator).toAssetsUp();\n        liqCache.collaterals = getCollaterals(violator);\n\n        // Checks\n\n        // Self liquidation is not allowed\n        if (liqCache.violator == liqCache.liquidator) revert E_SelfLiquidation();\n        // Only liquidate trusted collaterals to make sure yield transfer has no side effects.\n        if (!isRecognizedCollateral(liqCache.collateral)) revert E_BadCollateral();\n        // Verify this vault is the controller for the violator\n        validateController(liqCache.violator);\n        // Violator must have enabled the collateral to be transferred to the liquidator\n        if (!isCollateralEnabled(liqCache.violator, liqCache.collateral)) revert E_CollateralDisabled();\n        // Violator's health check must not be deferred, meaning no prior operations on violator's account\n        // would possibly be forgiven after the enforced collateral transfer to the liquidator\n        if (isAccountStatusCheckDeferred(violator)) revert E_ViolatorLiquidityDeferred();\n\n        // Violator has no liabilities, liquidation is a no-op\n        if (liqCache.liability.isZero()) return liqCache;\n\n        // Calculate max yield and repay\n\n        liqCache = calculateMaxLiquidation(liqCache, vaultCache);\n\n        // Adjust for desired repay\n\n        if (desiredRepay != type(uint256).max) {\n            uint256 maxRepay = liqCache.repay.toUint();\n            if (desiredRepay > maxRepay) revert E_ExcessiveRepayAmount();\n\n            if (maxRepay > 0) {\n                liqCache.yieldBalance = desiredRepay * liqCache.yieldBalance / maxRepay;\n                liqCache.repay = desiredRepay.toAssets();\n            }\n        }\n    }\n\n    function calculateMaxLiquidation(LiquidationCache memory liqCache, VaultCache memory vaultCache)\n        private\n        view\n        returns (LiquidationCache memory)\n    {\n        // Check account health\n\n        (uint256 liquidityCollateralValue, uint256 liquidityLiabilityValue) =\n            calculateLiquidity(vaultCache, liqCache.violator, liqCache.collaterals, LTVType.LIQUIDATION);\n\n        // no violation\n        if (liquidityCollateralValue > liquidityLiabilityValue) return liqCache;\n\n        // Compute discount\n\n        uint256 discountFactor = liquidityCollateralValue * 1e18 / liquidityLiabilityValue; // discountFactor = health score = 1 - discount\n\n        if (discountFactor < 1e18 - MAXIMUM_LIQUIDATION_DISCOUNT) {\n            discountFactor = 1e18 - MAXIMUM_LIQUIDATION_DISCOUNT;\n        }\n\n        // Compute maximum yield\n\n        uint256 collateralBalance = IERC20(liqCache.collateral).balanceOf(liqCache.violator);\n        uint256 collateralValue =\n            vaultCache.oracle.getQuote(collateralBalance, liqCache.collateral, vaultCache.unitOfAccount);\n\n        if (collateralValue == 0) {\n            // worthless collateral can be claimed with no repay\n            liqCache.yieldBalance = collateralBalance;\n            return liqCache;\n        }\n\n        uint256 liabilityValue = liqCache.liability.toUint();\n        if (address(vaultCache.asset) != vaultCache.unitOfAccount) {\n            // liquidation, in contrast to liquidity calculation, uses mid-point pricing instead of bid/ask\n            liabilityValue =\n                vaultCache.oracle.getQuote(liabilityValue, address(vaultCache.asset), vaultCache.unitOfAccount);\n        }\n\n        uint256 maxRepayValue = liabilityValue;\n        uint256 maxYieldValue = maxRepayValue * 1e18 / discountFactor;\n\n        // Limit yield to borrower's available collateral, and reduce repay if necessary\n        // This can happen when borrower has multiple collaterals and seizing all of this one won't bring the violator back to solvency\n\n        if (collateralValue < maxYieldValue) {\n            maxRepayValue = collateralValue * discountFactor / 1e18;\n            maxYieldValue = collateralValue;\n        }\n\n        liqCache.repay = (maxRepayValue * liqCache.liability.toUint() / liabilityValue).toAssets();\n        liqCache.yieldBalance = maxYieldValue * collateralBalance / collateralValue;\n\n        return liqCache;\n    }\n\n    function executeLiquidation(VaultCache memory vaultCache, LiquidationCache memory liqCache, uint256 minYieldBalance)\n        private\n    {\n        // Check minimum yield.\n\n        if (minYieldBalance > liqCache.yieldBalance) revert E_MinYield();\n\n        // Handle repay: liquidator takes on violator's debt:\n\n        transferBorrow(vaultCache, liqCache.violator, liqCache.liquidator, liqCache.repay);\n\n        // Handle yield: liquidator receives violator's collateral\n\n        // Impersonate violator on the EVC to seize collateral. The yield transfer will trigger a health check on the violator's\n        // account, which should be forgiven, because the violator's account is not guaranteed to be healthy after liquidation.\n        // This operation is safe, because:\n        // 1. `liquidate` function is enforcing that the violator is not in deferred checks state,\n        //    therefore there were no prior batch operations that could have registered a health check,\n        //    and if the check is present now, it must have been triggered by the enforced transfer.\n        // 2. Only collaterals with initialized LTV settings can be liquidated and they are assumed to be audited\n        //    to have safe transfer methods, which make no external calls. In other words, yield transfer will not\n        //    have any side effects, which would be wrongly forgiven.\n        // 3. Any additional operations on violator's account in a batch will register the health check again, and it\n        //    will be executed normally at the end of the batch.\n\n        if (liqCache.yieldBalance > 0) {\n            enforceCollateralTransfer(\n                liqCache.collateral, liqCache.yieldBalance, liqCache.violator, liqCache.liquidator\n            );\n\n            forgiveAccountStatusCheck(liqCache.violator);\n        }\n\n        // Handle debt socialization\n\n        if (\n            vaultCache.configFlags.isNotSet(CFG_DONT_SOCIALIZE_DEBT) && liqCache.liability > liqCache.repay\n                && checkNoCollateral(liqCache.violator, liqCache.collaterals)\n        ) {\n            Assets owedRemaining = liqCache.liability - liqCache.repay;\n            decreaseBorrow(vaultCache, liqCache.violator, owedRemaining);\n\n            // decreaseBorrow emits Repay without any assets entering the vault. Emit Withdraw from and to zero address to cover the missing amount for offchain trackers.\n            emit Withdraw(liqCache.liquidator, address(0), address(0), owedRemaining.toUint(), 0);\n            emit DebtSocialized(liqCache.violator, owedRemaining.toUint());\n        }\n\n        emit Liquidate(\n            liqCache.liquidator, liqCache.violator, liqCache.collateral, liqCache.repay.toUint(), liqCache.yieldBalance\n        );\n    }\n}\n\n/// @dev Deployable module contract\ncontract Liquidation is LiquidationModule {\n    constructor(Integrations memory integrations) Base(integrations) {}\n}"
    },
    {
      "filename": "src/EVault/shared/LiquidityUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {BorrowUtils} from \"./BorrowUtils.sol\";\nimport {LTVUtils} from \"./LTVUtils.sol\";\n\nimport \"./types/Types.sol\";\n\n/// @title LiquidityUtils\n/// @author Euler Labs (https://www.eulerlabs.com/)\n/// @notice Utilities for calculating account liquidity and health status\nabstract contract LiquidityUtils is BorrowUtils, LTVUtils {\n    using TypesLib for uint256;\n\n    // Calculate the value of liabilities, and the liquidation or borrowing LTV adjusted collateral value.\n    function calculateLiquidity(\n        VaultCache memory vaultCache,\n        address account,\n        address[] memory collaterals,\n        LTVType ltvType\n    ) internal view virtual returns (uint256 collateralValue, uint256 liabilityValue) {\n        validateOracle(vaultCache);\n\n        for (uint256 i; i < collaterals.length; ++i) {\n            collateralValue += getCollateralValue(vaultCache, account, collaterals[i], ltvType);\n        }\n\n        liabilityValue = getLiabilityValue(vaultCache, account, vaultStorage.users[account].getOwed());\n    }\n\n    // Check that the value of the collateral, adjusted for borrowing LTV, is equal or greater than the liability value.\n    function checkLiquidity(VaultCache memory vaultCache, address account, address[] memory collaterals)\n        internal\n        view\n        virtual\n    {\n        validateOracle(vaultCache);\n\n        Owed owed = vaultStorage.users[account].getOwed();\n        if (owed.isZero()) return;\n\n        uint256 liabilityValue = getLiabilityValue(vaultCache, account, owed);\n\n        uint256 collateralValue;\n        for (uint256 i; i < collaterals.length; ++i) {\n            collateralValue += getCollateralValue(vaultCache, account, collaterals[i], LTVType.BORROWING);\n            if (collateralValue > liabilityValue) return;\n        }\n\n        revert E_AccountLiquidity();\n    }\n\n    // Check if the account has no collateral balance left, used for debt socialization\n    // If LTV is zero, the collateral can still be liquidated.\n    // If the price of collateral is zero, liquidations are not executed, so the check won't be performed.\n    // If there is no collateral balance at all, then debt socialization can happen.\n    function checkNoCollateral(address account, address[] memory collaterals) internal view virtual returns (bool) {\n        for (uint256 i; i < collaterals.length; ++i) {\n            address collateral = collaterals[i];\n\n            if (!isRecognizedCollateral(collateral)) continue;\n\n            uint256 balance = IERC20(collateral).balanceOf(account);\n            if (balance > 0) return false;\n        }\n\n        return true;\n    }\n\n    function getLiabilityValue(VaultCache memory vaultCache, address account, Owed owed)\n        internal\n        view\n        virtual\n        returns (uint256 value)\n    {\n        // update owed with interest accrued\n        uint256 owedAssets = getCurrentOwed(vaultCache, account, owed).toAssetsUp().toUint();\n\n        if (owedAssets == 0) return 0;\n\n        if (address(vaultCache.asset) == vaultCache.unitOfAccount) {\n            value = owedAssets;\n        } else {\n            // ask price for liability\n            (, value) = vaultCache.oracle.getQuotes(owedAssets, address(vaultCache.asset), vaultCache.unitOfAccount);\n        }\n    }\n\n    function getCollateralValue(VaultCache memory vaultCache, address account, address collateral, LTVType ltvType)\n        internal\n        view\n        virtual\n        returns (uint256 value)\n    {\n        ConfigAmount ltv = getLTV(collateral, ltvType);\n        if (ltv.isZero()) return 0;\n\n        uint256 balance = IERC20(collateral).balanceOf(account);\n        if (balance == 0) return 0;\n\n        // bid price for collateral\n        (uint256 currentCollateralValue,) = vaultCache.oracle.getQuotes(balance, collateral, vaultCache.unitOfAccount);\n\n        return ltv.mul(currentCollateralValue);\n    }\n\n    function validateOracle(VaultCache memory vaultCache) internal pure {\n        if (address(vaultCache.oracle) == address(0)) revert E_NoPriceOracle();\n    }\n}"
    }
  ]
}