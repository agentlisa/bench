{
  "Title": "[G-05] Cache the mapping values rather than fetch it every time",
  "Content": "\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/OndoPriceOracle.sol#L61-L72\n\n### OndoPriceOracle.sol.getUnderlyingPrice(): fTokenToUnderlyingPrice[fToken] should be cached\n```solidity\nFile: /contracts/lending/OndoPriceOracle.sol\n61:  function getUnderlyingPrice(\n62:    address fToken\n63:  ) external view override returns (uint256) {\n64:    if (fTokenToUnderlyingPrice[fToken] != 0) { //@audit: Initial access\n65:      return fTokenToUnderlyingPrice[fToken];//@audit: 2nd access\n66:    } else {\n```\n\n```diff\ndiff --git a/contracts/lending/OndoPriceOracle.sol b/contracts/lending/OndoPriceOracle.sol\nindex 471769e..ddfc781 100644\n--- a/contracts/lending/OndoPriceOracle.sol\n+++ b/contracts/lending/OndoPriceOracle.sol\n@@ -61,8 +61,9 @@ contract OndoPriceOracle is IOndoPriceOracle, Ownable {\n   function getUnderlyingPrice(\n     address fToken\n   ) external view override returns (uint256) {\n-    if (fTokenToUnderlyingPrice[fToken] != 0) {\n-      return fTokenToUnderlyingPrice[fToken];\n+    uint256 _fTokenToUnderlyingPrice = fTokenToUnderlyingPrice[fToken];\n+    if (_fTokenToUnderlyingPrice != 0) {\n+      return _fTokenToUnderlyingPrice;\n     } else {\n       // Price is not manually set, attempt to retrieve price from Compound's\n       // oracle\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/OndoPriceOracleV2.sol#L114-L116\n\n### OndoPriceOracleV2.sol.getUnderlyingPrice(): fTokenToUnderlyingPriceCap\\[fToken\\] should be cached\n```solidity\nFile: /contracts/lending/OndoPriceOracleV2.sol\n114:    if (fTokenToUnderlyingPriceCap[fToken] > 0) { //@audit: Initial access\n115:      price = _min(price, fTokenToUnderlyingPriceCap[fToken]);//@audit: 2nd access\n116:    }\n```\n\n### Use the cached value here \nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cCash/CTokenCash.sol#L50-L55\n```solidity\nFile: /contracts/lending/tokens/cCash/CTokenCash.sol\n50:    // Set initial exchange rate\n51:    initialExchangeRateMantissa = initialExchangeRateMantissa_;//@audit: Cached here\n52:    require(\n53:      initialExchangeRateMantissa > 0, //@audit: Use the cached value\n54:      \"initial exchange rate must be greater than zero.\"\n55:    );\n```\n\n```diff\ndiff --git a/contracts/lending/tokens/cCash/CTokenCash.sol b/contracts/lending/tokens/cCash/CTokenCash.sol\nindex 93d5000..9f0f7da 100644\n--- a/contracts/lending/tokens/cCash/CTokenCash.sol\n+++ b/contracts/lending/tokens/cCash/CTokenCash.sol\n@@ -50,7 +50,7 @@ abstract contract CTokenCash is\n     // Set initial exchange rate\n     initialExchangeRateMantissa = initialExchangeRateMantissa_;\n     require(\n-      initialExchangeRateMantissa > 0,\n+      initialExchangeRateMantissa_ > 0,\n       \"initial exchange rate must be greater than zero.\"\n     );\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2023-01-ondo-finance-contest",
  "Code": [
    {
      "filename": "contracts/lending/OndoPriceOracle.sol",
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n */\npragma solidity 0.6.12;\n\nimport \"./IOndoPriceOracle.sol\";\nimport \"contracts/lending/compound/Ownable.sol\";\n\n/// @notice Interface for generalizing different cToken oracles\ninterface CTokenOracle {\n  function getUnderlyingPrice(address cToken) external view returns (uint256);\n}\n\n/// @notice Helper interface for standardizing common calls to\n///         fTokens and cTokens\ninterface CTokenLike {\n  function underlying() external view returns (address);\n}\n\n/**\n * @title OndoPriceOracle\n * @author Ondo Finance\n * @notice This contract acts as a custom price oracle for the flux finance\n *         lending market. It allows for the owner to set the underlying price\n *         directly in contract storage or set an fToken-to-cToken\n *         association for piggy backing on an existing cToken's oracle.\n */\ncontract OndoPriceOracle is IOndoPriceOracle, Ownable {\n  /// @notice Initially set to contracts/lending/compound/uniswap/UniswapAnchoredView.sol\n  CTokenOracle public cTokenOracle =\n    CTokenOracle(0x65c816077C29b557BEE980ae3cC2dCE80204A0C5);\n\n  /// @notice Contract storage for fToken's underlying asset prices\n  mapping(address => uint256) public fTokenToUnderlyingPrice;\n\n  /// @notice fToken to cToken associations for piggy backing off\n  ///         of cToken oracles\n  mapping(address => address) public fTokenToCToken;\n\n  /**\n   * @notice Retrieve the price of the provided fToken\n   *         contract's underlying asset\n   *\n   * @param fToken fToken contract address\n   *\n   * @dev This function first attempts to check if the price has been set directly \n          in contract storage. If not set, we check if there is a corresponding cToken\n   *      set within `fTokenToCToken` and piggy back on an external price oracle.\n   */\n  function getUnderlyingPrice(\n    address fToken\n  ) external view override returns (uint256) {\n    if (fTokenToUnderlyingPrice[fToken] != 0) {\n      return fTokenToUnderlyingPrice[fToken];\n    } else {\n      // Price is not manually set, attempt to retrieve price from Compound's\n      // oracle\n      address cTokenAddress = fTokenToCToken[fToken];\n      return cTokenOracle.getUnderlyingPrice(cTokenAddress);\n    }\n  }\n\n  /**\n   * @notice Sets the price of an fToken contract's underlying asset\n   *\n   * @param fToken fToken contract address\n   * @param price  New price of underlying asset\n   */\n  function setPrice(address fToken, uint256 price) external override onlyOwner {\n    uint256 oldPrice = fTokenToUnderlyingPrice[fToken];\n    fTokenToUnderlyingPrice[fToken] = price;\n    emit UnderlyingPriceSet(fToken, oldPrice, price);\n  }\n\n  /**\n   * @notice Associates a custom fToken with an external cToken\n   *\n   * @param fToken fToken contract address\n   * @param cToken cToken contract address\n   */\n  function setFTokenToCToken(\n    address fToken,\n    address cToken\n  ) external override onlyOwner {\n    address oldCToken = fTokenToCToken[fToken];\n    _setFTokenToCToken(fToken, cToken);\n    emit FTokenToCTokenSet(fToken, oldCToken, cToken);\n  }\n\n  /**\n   * @notice Sets the external oracle address\n   *\n   * @param newOracle cToken oracle contract address\n   */\n  function setOracle(address newOracle) external override onlyOwner {\n    address oldOracle = address(cTokenOracle);\n    cTokenOracle = CTokenOracle(newOracle);\n    emit CTokenOracleSet(oldOracle, newOracle);\n  }\n\n  /**\n   * @notice Private implementation function for setting fToken\n   *         to cToken implementation\n   *\n   * @param fToken fToken contract address\n   * @param cToken cToken contract address\n   */\n  function _setFTokenToCToken(address fToken, address cToken) internal {\n    require(\n      CTokenLike(fToken).underlying() == CTokenLike(cToken).underlying(),\n      \"cToken and fToken must have the same underlying asset if cToken nonzero\"\n    );\n    fTokenToCToken[fToken] = cToken;\n  }\n}"
    },
    {
      "filename": "contracts/lending/OndoPriceOracleV2.sol",
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n */\npragma solidity 0.8.16;\n\nimport \"./IOndoPriceOracleV2.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/access/Ownable.sol\";\nimport \"contracts/lending/chainlink/AggregatorV3Interface.sol\";\n\n/// @notice Interface for generalizing different cToken oracles\ninterface CTokenOracle {\n  function getUnderlyingPrice(address cToken) external view returns (uint256);\n}\n\n/// @notice Helper interface for standardizing comnmon calls to\n///         fTokens and cTokens\ninterface CTokenLike {\n  function underlying() external view returns (address);\n}\n\n/// @notice Helper interface for interacting with underlying assets\n///         that are ERC20 compliant\ninterface IERC20Like {\n  function decimals() external view returns (uint8);\n}\n\n/**\n * @title OndoPriceOracleV2\n * @author Ondo Finance\n * @notice This contract acts as a custom price oracle for the Flux lending\n *         market protocol. It allows for the owner to set the underlying price\n *         directly in contract storage, to set an fToken-to-cToken\n *         association for price retrieval using Compound's oracle, and\n *         to set an association between an fToken and a Chainlink\n *         oracle for price retrieval. It also allows the owner to\n *         set a price ceiling (a.k.a \"cap\") on an fToken's underlying asset.\n */\ncontract OndoPriceOracleV2 is IOndoPriceOracleV2, Ownable {\n  /// @notice Initially set to contracts/lending/compound/uniswap/UniswapAnchoredView.sol\n  CTokenOracle public cTokenOracle =\n    CTokenOracle(0x65c816077C29b557BEE980ae3cC2dCE80204A0C5);\n\n  /// @notice fToken to Oracle Type association\n  mapping(address => OracleType) public fTokenToOracleType;\n\n  /// @notice Contract storage for fToken's underlying asset prices\n  mapping(address => uint256) public fTokenToUnderlyingPrice;\n\n  /// @notice fToken to cToken associations for piggy backing off\n  ///         of Compound's Oracle\n  mapping(address => address) public fTokenToCToken;\n\n  struct ChainlinkOracleInfo {\n    AggregatorV3Interface oracle;\n    uint256 scaleFactor;\n  }\n\n  /// @notice fToken to Chainlink oracle association\n  mapping(address => ChainlinkOracleInfo) public fTokenToChainlinkOracle;\n\n  /// @notice Price cap for the underlying asset of an fToken. Optional.\n  mapping(address => uint256) public fTokenToUnderlyingPriceCap;\n\n  /// @notice The maximum amount of time delay we will tolerate from all\n  ///         Chainlink oracles.\n  uint256 public maxChainlinkOracleTimeDelay = 90000; // 25 hours\n\n  /**\n   * @notice Retrieve the price of the provided fToken\n   *         contract's underlying asset\n   *\n   * @param fToken fToken contract address\n   *\n   * @dev This function attempts to retrieve the price based on the associated\n   *      `OracleType`. This can mean retrieving from Compound's oracle, a\n   *      Chainlink oracle, or even a price set manually within contract\n   *      storage. It will cap the price if a price cap is set in\n   *      `fTokenToUnderlyingPriceCap`.\n   * @dev Only supports oracle prices denominated in USD\n   */\n  function getUnderlyingPrice(\n    address fToken\n  ) external view override returns (uint256) {\n    uint256 price;\n\n    // Get price of fToken depending on OracleType\n    OracleType oracleType = fTokenToOracleType[fToken];\n    if (oracleType == OracleType.MANUAL) {\n      // Get price stored in contract storage\n      price = fTokenToUnderlyingPrice[fToken];\n    } else if (oracleType == OracleType.COMPOUND) {\n      // Get associated cToken and call Compound oracle\n      address cTokenAddress = fTokenToCToken[fToken];\n      price = cTokenOracle.getUnderlyingPrice(cTokenAddress);\n    } else if (oracleType == OracleType.CHAINLINK) {\n      // Get price from Chainlink oracle\n      price = getChainlinkOraclePrice(fToken);\n    } else {\n      revert(\"Oracle type not supported\");\n    }\n\n    // If price cap is set, take the min.\n    if (fTokenToUnderlyingPriceCap[fToken] > 0) {\n      price = _min(price, fTokenToUnderlyingPriceCap[fToken]);\n    }\n\n    return price;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                   Price Cap & Oracle Type Setter\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Sets the price cap for the provided fToken's underlying asset\n   *\n   * @param fToken fToken contract address\n   */\n  function setPriceCap(\n    address fToken,\n    uint256 value\n  ) external override onlyOwner {\n    uint256 oldPriceCap = fTokenToUnderlyingPriceCap[fToken];\n    fTokenToUnderlyingPriceCap[fToken] = value;\n    emit PriceCapSet(fToken, oldPriceCap, value);\n  }\n\n  /**\n   * @notice Sets the oracle type for the provided fToken\n   *\n   * @param fToken     fToken contract address\n   * @param oracleType Oracle Type of fToken\n   */\n  function setFTokenToOracleType(\n    address fToken,\n    OracleType oracleType\n  ) external override onlyOwner {\n    fTokenToOracleType[fToken] = oracleType;\n    emit FTokenToOracleTypeSet(fToken, oracleType);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                            Manual Oracle\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Sets the price of an fToken contract's underlying asset\n   *\n   * @param fToken fToken contract address\n   * @param price  New price of underlying asset\n   */\n  function setPrice(address fToken, uint256 price) external override onlyOwner {\n    require(\n      fTokenToOracleType[fToken] == OracleType.MANUAL,\n      \"OracleType must be Manual\"\n    );\n    uint256 oldPrice = fTokenToUnderlyingPrice[fToken];\n    fTokenToUnderlyingPrice[fToken] = price;\n    emit UnderlyingPriceSet(fToken, oldPrice, price);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          Compound Oracle\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Sets the external oracle address for Compound oracleType\n   *\n   * @param newOracle cToken oracle contract address\n   */\n  function setOracle(address newOracle) external override onlyOwner {\n    address oldOracle = address(cTokenOracle);\n    cTokenOracle = CTokenOracle(newOracle);\n    emit CTokenOracleSet(oldOracle, newOracle);\n  }\n\n  /**\n   * @notice Associates a custom fToken with an external cToken\n   *\n   * @param fToken fToken contract address\n   * @param cToken cToken contract address\n   */\n  function setFTokenToCToken(\n    address fToken,\n    address cToken\n  ) external override onlyOwner {\n    address oldCToken = fTokenToCToken[fToken];\n    _setFTokenToCToken(fToken, cToken);\n    emit FTokenToCTokenSet(fToken, oldCToken, cToken);\n  }\n\n  /**\n   * @notice Private implementation function for setting fToken\n   *         to cToken implementation\n   *\n   * @param fToken fToken contract address\n   * @param cToken cToken contract address\n   */\n  function _setFTokenToCToken(address fToken, address cToken) internal {\n    require(\n      fTokenToOracleType[fToken] == OracleType.COMPOUND,\n      \"OracleType must be Compound\"\n    );\n    require(\n      CTokenLike(fToken).underlying() == CTokenLike(cToken).underlying(),\n      \"cToken and fToken must have the same underlying asset\"\n    );\n    fTokenToCToken[fToken] = cToken;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          Chainlink Oracle\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Associates a custom fToken with a Chainlink oracle\n   *\n   * @param fToken             fToken contract address\n   * @param newChainlinkOracle Chainlink oracle address\n   *\n   */\n  function setFTokenToChainlinkOracle(\n    address fToken,\n    address newChainlinkOracle\n  ) external override onlyOwner {\n    address oldChainlinkOracle = address(\n      fTokenToChainlinkOracle[fToken].oracle\n    );\n    _setFTokenToChainlinkOracle(fToken, newChainlinkOracle);\n    emit ChainlinkOracleSet(fToken, oldChainlinkOracle, newChainlinkOracle);\n  }\n\n  /**\n   * @notice Internal implementation function for setting fToken to\n   *         chainlinkOracle implementation\n   *\n   * @param fToken          fToken contract address\n   * @param chainlinkOracle cToken contract address\n   */\n  function _setFTokenToChainlinkOracle(\n    address fToken,\n    address chainlinkOracle\n  ) internal {\n    require(\n      fTokenToOracleType[fToken] == OracleType.CHAINLINK,\n      \"OracleType must be Chainlink\"\n    );\n    address underlying = CTokenLike(fToken).underlying();\n    fTokenToChainlinkOracle[fToken].scaleFactor = (10 **\n      (36 -\n        uint256(IERC20Like(underlying).decimals()) -\n        uint256(AggregatorV3Interface(chainlinkOracle).decimals())));\n    fTokenToChainlinkOracle[fToken].oracle = AggregatorV3Interface(\n      chainlinkOracle\n    );\n  }\n\n  /**\n   * @notice Retrieve price of fToken's underlying asset from a Chainlink\n   *         oracle\n   *\n   * @param fToken fToken contract address\n   *\n   * @dev This function is public for observability purposes only.\n   */\n  function getChainlinkOraclePrice(\n    address fToken\n  ) public view returns (uint256) {\n    require(\n      fTokenToOracleType[fToken] == OracleType.CHAINLINK,\n      \"fToken is not configured for Chainlink oracle\"\n    );\n    ChainlinkOracleInfo memory chainlinkInfo = fTokenToChainlinkOracle[fToken];\n    (\n      uint80 roundId,\n      int answer,\n      ,\n      uint updatedAt,\n      uint80 answeredInRound\n    ) = chainlinkInfo.oracle.latestRoundData();\n    require(\n      (answeredInRound >= roundId) &&\n        (updatedAt >= block.timestamp - maxChainlinkOracleTimeDelay),\n      \"Chainlink oracle price is stale\"\n    );\n    require(answer >= 0, \"Price cannot be negative\");\n    // Scale to decimals needed in Comptroller (18 decimal underlying -> 18 decimals; 6 decimal underlying -> 30 decimals)\n    // Scales by same conversion factor as in Compound Oracle\n    return uint256(answer) * chainlinkInfo.scaleFactor;\n  }\n\n  /**\n   * @notice Set the max time delay that we will tolerate from a Chainlink\n   *         oracle contract `latestRoundData()` response\n   *\n   * @param _maxChainlinkOracleTimeDelay New Max time delay (in seconds)\n   */\n  function setMaxChainlinkOracleTimeDelay(\n    uint256 _maxChainlinkOracleTimeDelay\n  ) external override onlyOwner {\n    uint256 oldMaxDelay = maxChainlinkOracleTimeDelay;\n    maxChainlinkOracleTimeDelay = _maxChainlinkOracleTimeDelay;\n    emit MaxChainlinkOracleTimeDelaySet(\n      oldMaxDelay,\n      _maxChainlinkOracleTimeDelay\n    );\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                                Utils\n  //////////////////////////////////////////////////////////////*/\n\n  function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n}"
    },
    {
      "filename": "contracts/lending/tokens/cCash/CTokenCash.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"../cErc20Delegate/ComptrollerInterface.sol\";\nimport \"../cErc20Delegate/ErrorReporter.sol\";\nimport \"../cErc20Delegate/EIP20Interface.sol\";\nimport \"../cErc20Delegate/InterestRateModel.sol\";\nimport \"../cErc20Delegate/ExponentialNoError.sol\";\nimport \"./CTokenInterfacesModifiedCash.sol\";\n\n/**\n * @title Ondo's CToken Contract for CASH\n * @notice Abstract base for CTokens w/underlying as CASH tokens\n * @dev Does KYC checks on key functions\n * @author Compound + Ondo\n */\nabstract contract CTokenCash is\n  CTokenInterface,\n  ExponentialNoError,\n  TokenErrorReporter\n{\n  /**\n   * @notice Initialize the money market\n   * @param comptroller_ The address of the Comptroller\n   * @param interestRateModel_ The address of the interest rate model\n   * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n   * @param name_ EIP-20 name of this token\n   * @param symbol_ EIP-20 symbol of this token\n   * @param decimals_ EIP-20 decimal precision of this token\n   * @param kycRegistry_ KYC Registry contract address\n   * @param kycRequirementGroup_ KYC Requirement group to check KYC status\n   *                             against\n   */\n  function initialize(\n    ComptrollerInterface comptroller_,\n    InterestRateModel interestRateModel_,\n    uint initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_,\n    address kycRegistry_,\n    uint256 kycRequirementGroup_\n  ) public {\n    require(msg.sender == admin, \"only admin may initialize the market\");\n    require(\n      accrualBlockNumber == 0 && borrowIndex == 0,\n      \"market may only be initialized once\"\n    );\n\n    // Set initial exchange rate\n    initialExchangeRateMantissa = initialExchangeRateMantissa_;\n    require(\n      initialExchangeRateMantissa > 0,\n      \"initial exchange rate must be greater than zero.\"\n    );\n\n    // Set the comptroller\n    uint err = _setComptroller(comptroller_);\n    require(err == NO_ERROR, \"setting comptroller failed\");\n\n    // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n    accrualBlockNumber = getBlockNumber();\n    borrowIndex = mantissaOne;\n\n    // Set the interest rate model (depends on block number / borrow index)\n    err = _setInterestRateModelFresh(interestRateModel_);\n    require(err == NO_ERROR, \"setting interest rate model failed\");\n\n    name = name_;\n    symbol = symbol_;\n    decimals = decimals_;\n\n    // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n    _notEntered = true;\n\n    // Initialize KYCRegistryClient\n    _setKYCRegistry(kycRegistry_);\n    _setKYCRequirementGroup(kycRequirementGroup_);\n  }\n\n  /**\n   * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n   * @dev Called by both `transfer` and `transferFrom` internally\n   * @param spender The address of the account performing the transfer\n   * @param src The address of the source account\n   * @param dst The address of the destination account\n   * @param tokens The number of tokens to transfer\n   * @return 0 if the transfer succeeded, else revert\n   */\n  function transferTokens(\n    address spender,\n    address src,\n    address dst,\n    uint tokens\n  ) internal returns (uint) {\n    /* Revert if KYC not valid */\n    require(_getKYCStatus(spender), \"Spender not KYC'd\");\n    require(_getKYCStatus(src), \"Source not KYC'd\");\n    require(_getKYCStatus(dst), \"Destination not KYC'd\");\n\n    /* Fail if transfer not allowed */\n    uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n    if (allowed != 0) {\n      revert TransferComptrollerRejection(allowed);\n    }\n\n    /* Do not allow self-transfers */\n    if (src == dst) {\n      revert TransferNotAllowed();\n    }\n\n    /* Get the allowance, infinite for the account owner */\n    uint startingAllowance = 0;\n    if (spender == src) {\n      startingAllowance = type(uint).max;\n    } else {\n      startingAllowance = transferAllowances[src][spender];\n    }\n\n    /* Do the calculations, checking for {under,over}flow */\n    uint allowanceNew = startingAllowance - tokens;\n    uint srcTokensNew = accountTokens[src] - tokens;\n    uint dstTokensNew = accountTokens[dst] + tokens;\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    accountTokens[src] = srcTokensNew;\n    accountTokens[dst] = dstTokensNew;\n\n    /* Eat some of the allowance (if necessary) */\n    if (startingAllowance != type(uint).max) {\n      transferAllowances[src][spender] = allowanceNew;\n    }\n\n    /* We emit a Transfer event */\n    emit Transfer(src, dst, tokens);\n\n    // unused function\n    // comptroller.transferVerify(address(this), src, dst, tokens);\n\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   * @return Whether or not the transfer succeeded\n   */\n  function transfer(\n    address dst,\n    uint256 amount\n  ) external override nonReentrant returns (bool) {\n    return transferTokens(msg.sender, msg.sender, dst, amount) == NO_ERROR;\n  }\n\n  /**\n   * @notice Transfer `amount` tokens from `src` to `dst`\n   * @param src The address of the source account\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   * @return Whether or not the transfer succeeded\n   */\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external override nonReentrant returns (bool) {\n    return transferTokens(msg.sender, src, dst, amount) == NO_ERROR;\n  }\n\n  /**\n   * @notice Approve `spender` to transfer up to `amount` from `src`\n   * @dev This will overwrite the approval amount for `spender`\n   *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n   * @param spender The address of the account which may transfer tokens\n   * @param amount The number of tokens that are approved (uint256.max means infinite)\n   * @return Whether or not the approval succeeded\n   */\n  function approve(\n    address spender,\n    uint256 amount\n  ) external override returns (bool) {\n    address src = msg.sender;\n    transferAllowances[src][spender] = amount;\n    emit Approval(src, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Get the current allowance from `owner` for `spender`\n   * @param owner The address of the account which owns the tokens to be spent\n   * @param spender The address of the account which may transfer tokens\n   * @return The number of tokens allowed to be spent (-1 means infinite)\n   */\n  function allowance(\n    address owner,\n    address spender\n  ) external view override returns (uint256) {\n    return transferAllowances[owner][spender];\n  }\n\n  /**\n   * @notice Get the token balance of the `owner`\n   * @param owner The address of the account to query\n   * @return The number of tokens owned by `owner`\n   */\n  function balanceOf(address owner) external view override returns (uint256) {\n    return accountTokens[owner];\n  }\n\n  /**\n   * @notice Get the underlying balance of the `owner`\n   * @dev This also accrues interest in a transaction\n   * @param owner The address of the account to query\n   * @return The amount of underlying owned by `owner`\n   */\n  function balanceOfUnderlying(address owner) external override returns (uint) {\n    Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\n    return mul_ScalarTruncate(exchangeRate, accountTokens[owner]);\n  }\n\n  /**\n   * @notice Get a snapshot of the account's balances, and the cached exchange rate\n   * @dev This is used by comptroller to more efficiently perform liquidity checks.\n   * @param account Address of the account to snapshot\n   * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n   */\n  function getAccountSnapshot(\n    address account\n  ) external view override returns (uint, uint, uint, uint) {\n    return (\n      NO_ERROR,\n      accountTokens[account],\n      borrowBalanceStoredInternal(account),\n      exchangeRateStoredInternal()\n    );\n  }\n\n  /**\n   * @dev Function to simply retrieve block number\n   *  This exists mainly for inheriting test contracts to stub this result.\n   */\n  function getBlockNumber() internal view virtual returns (uint) {\n    return block.number;\n  }\n\n  /**\n   * @notice Returns the current per-block borrow interest rate for this cToken\n   * @return The borrow interest rate per block, scaled by 1e18\n   */\n  function borrowRatePerBlock() external view override returns (uint) {\n    return\n      interestRateModel.getBorrowRate(\n        getCashPrior(),\n        totalBorrows,\n        totalReserves\n      );\n  }\n\n  /**\n   * @notice Returns the current per-block supply interest rate for this cToken\n   * @return The supply interest rate per block, scaled by 1e18\n   */\n  function supplyRatePerBlock() external view override returns (uint) {\n    return\n      interestRateModel.getSupplyRate(\n        getCashPrior(),\n        totalBorrows,\n        totalReserves,\n        reserveFactorMantissa\n      );\n  }\n\n  /**\n   * @notice Returns the current total borrows plus accrued interest\n   * @return The total borrows with interest\n   */\n  function totalBorrowsCurrent() external override nonReentrant returns (uint) {\n    accrueInterest();\n    return totalBorrows;\n  }\n\n  /**\n   * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n   * @param account The address whose balance should be calculated after updating borrowIndex\n   * @return The calculated balance\n   */\n  function borrowBalanceCurrent(\n    address account\n  ) external override nonReentrant returns (uint) {\n    accrueInterest();\n    return borrowBalanceStored(account);\n  }\n\n  /**\n   * @notice Return the borrow balance of account based on stored data\n   * @param account The address whose balance should be calculated\n   * @return The calculated balance\n   */\n  function borrowBalanceStored(\n    address account\n  ) public view override returns (uint) {\n    return borrowBalanceStoredInternal(account);\n  }\n\n  /**\n   * @notice Return the borrow balance of account based on stored data\n   * @param account The address whose balance should be calculated\n   * @return (error code, the calculated balance or 0 if error code is non-zero)\n   */\n  function borrowBalanceStoredInternal(\n    address account\n  ) internal view returns (uint) {\n    /* Get borrowBalance and borrowIndex */\n    BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n    /* If borrowBalance = 0 then borrowIndex is likely also 0.\n     * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n     */\n    if (borrowSnapshot.principal == 0) {\n      return 0;\n    }\n\n    /* Calculate new borrow balance using the interest index:\n     *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n     */\n    uint principalTimesIndex = borrowSnapshot.principal * borrowIndex;\n    return principalTimesIndex / borrowSnapshot.interestIndex;\n  }\n\n  /**\n   * @notice Accrue interest then return the up-to-date exchange rate\n   * @return Calculated exchange rate scaled by 1e18\n   */\n  function exchangeRateCurrent() public override nonReentrant returns (uint) {\n    accrueInterest();\n    return exchangeRateStored();\n  }\n\n  /**\n   * @notice Calculates the exchange rate from the underlying to the cToken\n   * @dev This function does not accrue interest before calculating the exchange rate\n   * @return Calculated exchange rate scaled by 1e18\n   */\n  function exchangeRateStored() public view override returns (uint) {\n    return exchangeRateStoredInternal();\n  }\n\n  /**\n   * @notice Calculates the exchange rate from the underlying to the cToken\n   * @dev This function does not accrue interest before calculating the exchange rate\n   * @return calculated exchange rate scaled by 1e18\n   */\n  function exchangeRateStoredInternal() internal view virtual returns (uint) {\n    uint _totalSupply = totalSupply;\n    if (_totalSupply == 0) {\n      /*\n       * If there are no tokens minted:\n       *  exchangeRate = initialExchangeRate\n       */\n      return initialExchangeRateMantissa;\n    } else {\n      /*\n       * Otherwise:\n       *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n       */\n      uint totalCash = getCashPrior();\n      uint cashPlusBorrowsMinusReserves = totalCash +\n        totalBorrows -\n        totalReserves;\n      uint exchangeRate = (cashPlusBorrowsMinusReserves * expScale) /\n        _totalSupply;\n\n      return exchangeRate;\n    }\n  }\n\n  /**\n   * @notice Get cash balance of this cToken in the underlying asset\n   * @return The quantity of underlying asset owned by this contract\n   */\n  function getCash() external view override returns (uint) {\n    return getCashPrior();\n  }\n\n  /**\n   * @notice Applies accrued interest to total borrows and reserves\n   * @dev This calculates interest accrued from the last checkpointed block\n   *   up to the current block and writes new checkpoint to storage.\n   */\n  function accrueInterest() public virtual override returns (uint) {\n    /* Remember the initial block number */\n    uint currentBlockNumber = getBlockNumber();\n    uint accrualBlockNumberPrior = accrualBlockNumber;\n\n    /* Short-circuit accumulating 0 interest */\n    if (accrualBlockNumberPrior == currentBlockNumber) {\n      return NO_ERROR;\n    }\n\n    /* Read the previous values out of storage */\n    uint cashPrior = getCashPrior();\n    uint borrowsPrior = totalBorrows;\n    uint reservesPrior = totalReserves;\n    uint borrowIndexPrior = borrowIndex;\n\n    /* Calculate the current borrow interest rate */\n    uint borrowRateMantissa = interestRateModel.getBorrowRate(\n      cashPrior,\n      borrowsPrior,\n      reservesPrior\n    );\n    require(\n      borrowRateMantissa <= borrowRateMaxMantissa,\n      \"borrow rate is absurdly high\"\n    );\n\n    /* Calculate the number of blocks elapsed since the last accrual */\n    uint blockDelta = currentBlockNumber - accrualBlockNumberPrior;\n\n    /*\n     * Calculate the interest accumulated into borrows and reserves and the new index:\n     *  simpleInterestFactor = borrowRate * blockDelta\n     *  interestAccumulated = simpleInterestFactor * totalBorrows\n     *  totalBorrowsNew = interestAccumulated + totalBorrows\n     *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n     *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n     */\n\n    Exp memory simpleInterestFactor = mul_(\n      Exp({mantissa: borrowRateMantissa}),\n      blockDelta\n    );\n    uint interestAccumulated = mul_ScalarTruncate(\n      simpleInterestFactor,\n      borrowsPrior\n    );\n    uint totalBorrowsNew = interestAccumulated + borrowsPrior;\n    uint totalReservesNew = mul_ScalarTruncateAddUInt(\n      Exp({mantissa: reserveFactorMantissa}),\n      interestAccumulated,\n      reservesPrior\n    );\n    uint borrowIndexNew = mul_ScalarTruncateAddUInt(\n      simpleInterestFactor,\n      borrowIndexPrior,\n      borrowIndexPrior\n    );\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /* We write the previously calculated values into storage */\n    accrualBlockNumber = currentBlockNumber;\n    borrowIndex = borrowIndexNew;\n    totalBorrows = totalBorrowsNew;\n    totalReserves = totalReservesNew;\n\n    /* We emit an AccrueInterest event */\n    emit AccrueInterest(\n      cashPrior,\n      interestAccumulated,\n      borrowIndexNew,\n      totalBorrowsNew\n    );\n\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender supplies assets into the market and receives cTokens in exchange\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param mintAmount The amount of the underlying asset to supply\n   */\n  function mintInternal(uint mintAmount) internal nonReentrant {\n    accrueInterest();\n    // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n    mintFresh(msg.sender, mintAmount);\n  }\n\n  /**\n   * @notice User supplies assets into the market and receives cTokens in exchange\n   * @dev Assumes interest has already been accrued up to the current block\n   * @param minter The address of the account which is supplying the assets\n   * @param mintAmount The amount of the underlying asset to supply\n   */\n  function mintFresh(address minter, uint mintAmount) internal {\n    /* Revert if minter not KYC'd */\n    require(_getKYCStatus(minter), \"Minter not KYC'd\");\n\n    /* Fail"
    }
  ]
}