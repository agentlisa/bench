{
  "Title": "M-5: Limited support to a specific subset of ERC20 tokens",
  "Content": "# Issue M-5: Limited support to a specific subset of ERC20 tokens \n\nSource: https://github.com/sherlock-audit/2022-11-buffer-judging/issues/73 \n\n## Found by \nak1, bin2chen, 0x4non, jonatascm, sach1r0, pashov, HonorLt, peanuts, m\\_Rassska, adriro, Deivitto, \\_\\_141345\\_\\_, eierina, 0xcc, rvierdiiev, cccz, minhtrng, ctf\\_sec, aphak5010, Bnke0x0, eyexploit, hansfriese, 0x007\n\n## Summary\n\nBuffer contest states 'any ERC20 supported', therefore it should take into account all the different ways of signalling success and failure.  This is not the case, as all ERC20's transfer(), transferFrom(), and approve() functions are either not verified at all or verified for returning true. As a result, depending on the ERC20 token, some transfer errors may result in passing unnoticed, and/or some successfull transfer may be treated as failed.\n\nCurrently the only supported ERC20 tokens are the ones that fulfill both the following requirements:\n- always revert on failure;\n- always returns boolean true on success.\n\nAn example of a very well known token that is not supported is Tether USD (USDT).\n\n> **ðŸ‘‹** IMPORTANT\n> This issue is not the same as reporting that \"return value must be verified to be true\" where the checks are missing! Indeed **such a simplistic report should be considered invalid** as it still does not solve all the problems but rather introduces others. See Vulnerability Details section for rationale.\n\n## Vulnerability Detail\n\nTokens have different ways of signalling success and failure, and this affect mostly transfer(), transferFrom() and approve() in ERC20 tokens. While some tokens revert upon failure, others consistently return boolean flags to indicate success or failure, and many others have mixed behaviours.\n\nSee below a snippet of the [USDT Token contract](https://etherscan.io/token/0xdac17f958d2ee523a2206206994597c13d831ec7#code#L1) compared to the 0x's [ZRX Token contract](https://etherscan.io/token/0xe41d2489571d322189246dafa5ebde1f4699f498#code#L1) where the USDT Token transfer function does not even return a boolean value, while the ZRX token consistently returns boolean value hence returning false on failure instead of reverting.\n\n***USDT Token snippet (no return value) from Etherscan***\n```solidity\nfunction transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3 * 32) {\n\tvar _allowance = allowed[_from][msg.sender];\n\n\t// Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n\t// if (_value > _allowance) throw;\n\n\tuint fee = (_value.mul(basisPointsRate)).div(10000);\n\tif (fee > maximumFee) {\n\t\tfee = maximumFee;\n\t}\n\tif (_allowance < MAX_UINT) {\n\t\tallowed[_from][msg.sender] = _allowance.sub(_value);\n\t}\n\tuint sendAmount = _value.sub(fee);\n\tbalances[_from] = balances[_from].sub(_value);\n\tbalances[_to] = balances[_to].add(sendAmount);\n\tif (fee > 0) {\n\t\tbalances[owner] = balances[owner].add(fee);\n\t\tTransfer(_from, owner, fee);\n\t}\n\tTransfer(_from, _to, sendAmount);\n}\n```\n\n***ZRX Token snippet (consistently true or false boolean result) from Etherscan***\n```solidity\nfunction transferFrom(address _from, address _to, uint _value) returns (bool) {\n\tif (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n\t\tbalances[_to] += _value;\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tTransfer(_from, _to, _value);\n\t\treturn true;\n\t} else { return false; }\n}\n```\n\n## Impact\n\nGiven the different usages of token transfers in BufferBinaryOptions.sol, BufferBinaryPool.sol, and BufferRouter.sol, there can be 2 types of impacts depending on the ERC20 contract being traded.\n\n### Impact type 1\nThe ERC20 token being traded is one that consistently returns a boolean result in the case of success and failure like for example [0x](https://www.0x.org/)'s [ZRX Token contract](https://etherscan.io/token/0xe41d2489571d322189246dafa5ebde1f4699f498#code#L1). Where the return value is currently not verified to be true (i.e.: [#1](https://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferRouter.sol#L86), [#2](https://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferRouter.sol#L331), [#3](https://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferRouter.sol#L335), [#4](https://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferRouter.sol#L361), [#5](https://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryOptions.sol#L141), [#6](https://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryOptions.sol#L477)) the transfer may fail (e.g.: no tokens transferred due to insufficient balance) but the error would not be detected by the Buffer contracts.\n\n### Impact type 2\nThe ERC20 token being traded is one that do not return a boolean value like for example the well knonw [Tether USD Token contract](https://etherscan.io/token/0xdac17f958d2ee523a2206206994597c13d831ec7#code#L1). Successful transfers would cause a revert in the Buffer contracts where the return value is verified to be true (i.e.: [#1](https://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryPool.sol#L162), [#2](https://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryPool.sol#L205), [#3](https://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryPool.sol#L241), [#4](https://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryPool.sol#L323)) due to the token not returing boolean results.\n\nSame is true for appove calls.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferRouter.sol#L86-L90\nhttps://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferRouter.sol#L331\nhttps://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferRouter.sol#L335-L338\nhttps://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferRouter.sol#L361-L364\nhttps://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryOptions.sol#L141\nhttps://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryOptions.sol#L477\n\nhttps://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryPool.sol#L162\nhttps://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryPool.sol#L205\nhttps://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryPool.sol#L241\nhttps://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryPool.sol#L323\n\n## Tool used\n\nManual Review\n\n## Recommendation\nTo handle most of these inconsistent behaviors across multiple tokens, either use OpenZeppelin's [SafeERC20 library](https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#SafeERC20), or use a more reusable implementation (i.e. library) of the following intentionally explicit, descriptive example code for an ERC20 transferFrom() call that takes into account all the different ways of signalling success and failure, and apply to all ERC20 transfer(), transferFrom(), approve() calls in the Buffer contracts.\n\n```solidity\nIERC20 token = whatever_token;\n\n(bool success, bytes memory returndata) = address(token).call(abi.encodeWithSelector(IERC20.transferFrom.selector, sender, recipient, amount));\n\n// if success == false, without any doubts there was an error and callee reverted\nrequire(success, \"Transfer failed!\");\n\n// if success == true, we need to check whether we got a return value or not (like in the case of USDT)\nif (returndata.length > 0) {\n\t// we got a return value, it must be a boolean and it should be true\n\trequire(abi.decode(returndata, (bool)), \"Transfer failed!\");\n} else {\n\t// since we got no return value it can be one of two cases:\n\t// 1. the transferFrom does not return a boolean and it did succeed\n\t// 2. the token address is not a contract address therefore call() always return success = true as per EVM design\n\t// To discriminate between 1 and 2, we need to check if the address actually points to a contract\n\trequire(address(token).code.length > 0, \"Not a token address!\");\n}\n```\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/24",
  "Code": [
    {
      "filename": "contracts/contracts/core/BufferRouter.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"../interfaces/Interfaces.sol\";\n\n/**\n * @author Heisenberg\n * @notice Buffer Options Router Contract\n */\ncontract BufferRouter is AccessControl, IBufferRouter {\n    uint16 MAX_WAIT_TIME = 1 minutes;\n    uint256 public nextQueueId = 0;\n    address public publisher;\n    uint256 public nextQueueIdToProcess = 0;\n    bool public isInPrivateKeeperMode = true;\n\n    mapping(address => uint256[]) public userQueuedIds;\n    mapping(address => uint256[]) public userCancelledQueuedIds;\n    mapping(address => uint256) public userNextQueueIndexToProcess;\n    mapping(uint256 => QueuedTrade) public queuedTrades;\n    mapping(address => bool) public contractRegistry;\n    mapping(address => bool) public isKeeper;\n\n    constructor(address _publisher) {\n        publisher = _publisher;\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /************************************************\n     *  ADMIN ONLY FUNCTIONS\n     ***********************************************/\n\n    function setContractRegistry(address targetContract, bool register)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        contractRegistry[targetContract] = register;\n    }\n\n    function setKeeper(address _keeper, bool _isActive)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        isKeeper[_keeper] = _isActive;\n    }\n\n    function setInPrivateKeeperMode() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        isInPrivateKeeperMode = !isInPrivateKeeperMode;\n    }\n\n    /************************************************\n     *  USER WRITE FUNCTIONS\n     ***********************************************/\n\n    /**\n     * @notice Adds an option creation request in the queue\n     */\n    function initiateTrade(\n        uint256 totalFee,\n        uint256 period,\n        bool isAbove,\n        address targetContract,\n        uint256 expectedStrike,\n        uint256 slippage,\n        bool allowPartialFill,\n        string memory referralCode,\n        uint256 traderNFTId\n    ) external returns (uint256 queueId) {\n        // Checks if the target contract has been registered\n        require(\n            contractRegistry[targetContract],\n            \"Router: Unauthorized contract\"\n        );\n        IBufferBinaryOptions optionsContract = IBufferBinaryOptions(\n            targetContract\n        );\n\n        optionsContract.runInitialChecks(slippage, period, totalFee);\n\n        // Transfer the fee specified from the user to this contract.\n        // User has to approve first inorder to execute this function\n        IERC20(optionsContract.tokenX()).transferFrom(\n            msg.sender,\n            address(this),\n            totalFee\n        );\n        queueId = nextQueueId;\n        nextQueueId++;\n\n        QueuedTrade memory queuedTrade = QueuedTrade(\n            queueId,\n            userQueueCount(msg.sender),\n            msg.sender,\n            totalFee,\n            period,\n            isAbove,\n            targetContract,\n            expectedStrike,\n            slippage,\n            allowPartialFill,\n            block.timestamp,\n            true,\n            referralCode,\n            traderNFTId\n        );\n\n        queuedTrades[queueId] = queuedTrade;\n\n        userQueuedIds[msg.sender].push(queueId);\n\n        emit InitiateTrade(msg.sender, queueId, block.timestamp);\n    }\n\n    /**\n     * @notice Cancels a queued traded. Can only be called by the trade owner\n     */\n    function cancelQueuedTrade(uint256 queueId) external {\n        QueuedTrade memory queuedTrade = queuedTrades[queueId];\n        require(msg.sender == queuedTrade.user, \"Router: Forbidden\");\n        require(queuedTrade.isQueued, \"Router: Trade has already been opened\");\n        _cancelQueuedTrade(queueId);\n        emit CancelTrade(queuedTrade.user, queueId, \"User Cancelled\");\n    }\n\n    /************************************************\n     *  KEEPER ONLY FUNCTIONS\n     ***********************************************/\n\n    /**\n     * @notice Verifies the trade parameter via the signature and resolves all the valid queued trades\n     */\n    function resolveQueuedTrades(OpenTradeParams[] calldata params) external {\n        _validateKeeper();\n        for (uint32 index = 0; index < params.length; index++) {\n            OpenTradeParams memory currentParams = params[index];\n            QueuedTrade memory queuedTrade = queuedTrades[\n                currentParams.queueId\n            ];\n            bool isSignerVerifed = _validateSigner(\n                currentParams.timestamp,\n                currentParams.asset,\n                currentParams.price,\n                currentParams.signature\n            );\n            // Silently fail if the signature doesn't match\n            if (!isSignerVerifed) {\n                emit FailResolve(\n                    currentParams.queueId,\n                    \"Router: Signature didn't match\"\n                );\n                continue;\n            }\n            if (\n                !queuedTrade.isQueued ||\n                currentParams.timestamp != queuedTrade.queuedTime\n            ) {\n                // Trade has already been opened or cancelled or the timestamp is wrong.\n                // So ignore this trade.\n                continue;\n            }\n\n            // If the opening time is much greater than the queue time then cancel the trade\n            if (block.timestamp - queuedTrade.queuedTime <= MAX_WAIT_TIME) {\n                _openQueuedTrade(currentParams.queueId, currentParams.price);\n            } else {\n                _cancelQueuedTrade(currentParams.queueId);\n                emit CancelTrade(\n                    queuedTrade.user,\n                    currentParams.queueId,\n                    \"Wait time too high\"\n                );\n            }\n\n            // Track the next queueIndex to be processed for user\n            userNextQueueIndexToProcess[queuedTrade.user] =\n                queuedTrade.userQueueIndex +\n                1;\n        }\n        // Track the next queueIndex to be processed overall\n        nextQueueIdToProcess = params[params.length - 1].queueId + 1;\n    }\n\n    /**\n     * @notice Verifies the option parameter via the signature and unlocks an array of options\n     */\n    function unlockOptions(CloseTradeParams[] calldata optionData) external {\n        _validateKeeper();\n\n        uint32 arrayLength = uint32(optionData.length);\n        for (uint32 i = 0; i < arrayLength; i++) {\n            CloseTradeParams memory params = optionData[i];\n            IBufferBinaryOptions optionsContract = IBufferBinaryOptions(\n                params.asset\n            );\n            (, , , , , uint256 expiration, , , ) = optionsContract.options(\n                params.optionId\n            );\n\n            bool isSignerVerifed = _validateSigner(\n                params.expiryTimestamp,\n                params.asset,\n                params.priceAtExpiry,\n                params.signature\n            );\n\n            // Silently fail if the timestamp of the signature is wrong\n            if (expiration != params.expiryTimestamp) {\n                emit FailUnlock(params.optionId, \"Router: Wrong price\");\n                continue;\n            }\n\n            // Silently fail if the signature doesn't match\n            if (!isSignerVerifed) {\n                emit FailUnlock(\n                    params.optionId,\n                    \"Router: Signature didn't match\"\n                );\n                continue;\n            }\n\n            try\n                optionsContract.unlock(params.optionId, params.priceAtExpiry)\n            {} catch Error(string memory reason) {\n                emit FailUnlock(params.optionId, reason);\n                continue;\n            }\n        }\n    }\n\n    /************************************************\n     *  READ ONLY FUNCTIONS\n     ***********************************************/\n\n    function userQueueCount(address user) public view returns (uint256) {\n        return userQueuedIds[user].length;\n    }\n\n    function userCancelledQueueCount(address user)\n        external\n        view\n        returns (uint256)\n    {\n        return userCancelledQueuedIds[user].length;\n    }\n\n    /************************************************\n     *  INTERNAL FUNCTIONS\n     ***********************************************/\n    function _validateKeeper() private view {\n        require(\n            !isInPrivateKeeperMode || isKeeper[msg.sender],\n            \"Keeper: forbidden\"\n        );\n    }\n\n    function _validateSigner(\n        uint256 timestamp,\n        address asset,\n        uint256 price,\n        bytes memory signature\n    ) internal view returns (bool) {\n        bytes32 digest = ECDSA.toEthSignedMessageHash(\n            keccak256(abi.encodePacked(timestamp, asset, price))\n        );\n        address recoveredSigner = ECDSA.recover(digest, signature);\n        return recoveredSigner == publisher;\n    }\n\n    function _openQueuedTrade(uint256 queueId, uint256 price) internal {\n        QueuedTrade storage queuedTrade = queuedTrades[queueId];\n        IBufferBinaryOptions optionsContract = IBufferBinaryOptions(\n            queuedTrade.targetContract\n        );\n\n        // Check if slippage lies within the bounds\n        bool isSlippageWithinRange = optionsContract.isStrikeValid(\n            queuedTrade.slippage,\n            price,\n            queuedTrade.expectedStrike\n        );\n\n        if (!isSlippageWithinRange) {\n            _cancelQueuedTrade(queueId);\n            emit CancelTrade(\n                queuedTrade.user,\n                queueId,\n                \"Slippage limit exceeds\"\n            );\n\n            return;\n        }\n\n        // Check all the parameters and compute the amount and revised fee\n        uint256 amount;\n        uint256 revisedFee;\n        bool isReferralValid;\n        IBufferBinaryOptions.OptionParams\n            memory optionParams = IBufferBinaryOptions.OptionParams(\n                queuedTrade.expectedStrike,\n                0,\n                queuedTrade.period,\n                queuedTrade.isAbove,\n                queuedTrade.allowPartialFill,\n                queuedTrade.totalFee,\n                queuedTrade.user,\n                queuedTrade.referralCode,\n                queuedTrade.traderNFTId\n            );\n        try optionsContract.checkParams(optionParams) returns (\n            uint256 _amount,\n            uint256 _revisedFee,\n            bool _isReferralValid\n        ) {\n            (amount, revisedFee, isReferralValid) = (\n                _amount,\n                _revisedFee,\n                _isReferralValid\n            );\n        } catch Error(string memory reason) {\n            _cancelQueuedTrade(queueId);\n            emit CancelTrade(queuedTrade.user, queueId, reason);\n            return;\n        }\n\n        // Transfer the fee to the target options contract\n        IERC20 tokenX = IERC20(optionsContract.tokenX());\n        tokenX.transfer(queuedTrade.targetContract, revisedFee);\n\n        // Refund the user in case the trade amount was lesser\n        if (revisedFee < queuedTrade.totalFee) {\n            tokenX.transfer(\n                queuedTrade.user,\n                queuedTrade.totalFee - revisedFee\n            );\n        }\n\n        optionParams.totalFee = revisedFee;\n        optionParams.strike = price;\n        optionParams.amount = amount;\n\n        uint256 optionId = optionsContract.createFromRouter(\n            optionParams,\n            isReferralValid\n        );\n\n        queuedTrade.isQueued = false;\n\n        emit OpenTrade(queuedTrade.user, queueId, optionId);\n    }\n\n    function _cancelQueuedTrade(uint256 queueId) internal {\n        QueuedTrade storage queuedTrade = queuedTrades[queueId];\n        IBufferBinaryOptions optionsContract = IBufferBinaryOptions(\n            queuedTrade.targetContract\n        );\n        queuedTrade.isQueued = false;\n        IERC20(optionsContract.tokenX()).transfer(\n            queuedTrade.user,\n            queuedTrade.totalFee\n        );\n\n        userCancelledQueuedIds[queuedTrade.user].push(queueId);\n    }\n}"
    },
    {
      "filename": "contracts/contracts/core/BufferBinaryPool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.4;\n\nimport \"../interfaces/Interfaces.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n/**\n * @author Heisenberg\n * @title Buffer TokenX Liquidity Pool\n * @notice Accumulates liquidity in TokenX from LPs and distributes P&L in TokenX\n */\ncontract BufferBinaryPool is\n    ERC20(\"Buffer LP Token\", \"BLP\"),\n    AccessControl,\n    ILiquidityPool\n{\n    ERC20 public tokenX;\n    uint16 public constant ACCURACY = 1e3;\n    uint32 public constant INITIAL_RATE = 1;\n    uint32 public lockupPeriod = 10 minutes;\n    uint256 public lockedAmount;\n    uint256 public lockedPremium;\n    uint256 public maxLiquidity;\n    address public owner;\n    bytes32 public constant OPTION_ISSUER_ROLE =\n        keccak256(\"OPTION_ISSUER_ROLE\");\n\n    mapping(address => LockedLiquidity[]) public lockedLiquidity;\n    mapping(address => bool) public isHandler;\n    mapping(address => ProvidedLiquidity) public liquidityPerUser;\n\n    constructor(ERC20 _tokenX) {\n        tokenX = _tokenX;\n        owner = msg.sender;\n        maxLiquidity = 5000000 * 10**_tokenX.decimals();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /************************************************\n     *  ADMIN ONLY FUNCTIONS\n     ***********************************************/\n\n    /**\n     * @notice Used for adding or removing handlers\n     */\n    function setHandler(address _handler, bool _isActive)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        isHandler[_handler] = _isActive;\n    }\n\n    /**\n     * @notice Used for adjusting the max limit of the pool\n     */\n    function setMaxLiquidity(uint256 _maxLiquidity)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        maxLiquidity = _maxLiquidity;\n        emit UpdateMaxLiquidity(_maxLiquidity);\n    }\n\n    /************************************************\n     *  EXTERNAL/PUBLIC FUNCTIONS\n     ***********************************************/\n\n    /**\n     * @notice ERC20 transferFrom. Overridden to allow handler to transfer without approval\n     */\n    function transferFrom(\n        address _sender,\n        address _recipient,\n        uint256 _amount\n    ) public virtual override returns (bool) {\n        if (isHandler[msg.sender]) {\n            _transfer(_sender, _recipient, _amount);\n            return true;\n        }\n\n        uint256 currentAllowance = allowance(_sender, msg.sender);\n        require(\n            currentAllowance >= _amount,\n            \"Pool: transfer amount exceeds allowance\"\n        );\n        unchecked {\n            _approve(_sender, msg.sender, currentAllowance - _amount);\n        }\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice A provider supplies tokenX to the pool and receives BLP tokens\n     * @param minMint Minimum amount of tokens that should be received by a provider.\n                      Calling the provide function will require the minimum amount of tokens to be minted.\n                      The actual amount that will be minted could vary but can only be higher (not lower) than the minimum value.\n     */\n    function provide(uint256 tokenXAmount, uint256 minMint)\n        external\n        returns (uint256 mint)\n    {\n        mint = _provide(tokenXAmount, minMint, msg.sender);\n    }\n\n    /**\n     * @notice Called by handler to add liquidity for an account\n     */\n    function provideForAccount(\n        uint256 tokenXAmount,\n        uint256 minMint,\n        address account\n    ) external returns (uint256 mint) {\n        _validateHandler();\n        mint = _provide(tokenXAmount, minMint, account);\n    }\n\n    /**\n     * @notice Burns BLP and receives X from the pool\n     */\n    function withdraw(uint256 tokenXAmount) external {\n        _withdraw(tokenXAmount, msg.sender);\n    }\n\n    /**\n     * @notice Called by the Handler to burns BLP and receives X for a user\n     */\n    function withdrawForAccount(uint256 tokenXAmount, address account)\n        external\n        returns (uint256 burn)\n    {\n        _validateHandler();\n        burn = _withdraw(tokenXAmount, account);\n    }\n\n    /************************************************\n     *  OPTION ONLY FUNCTIONS\n     ***********************************************/\n\n    /**\n     * @notice Called by BufferCallOptions to lock the funds\n     * @param id optionId\n     * @param tokenXAmount Amount of funds that should be locked in an option\n     * @param premium Premium paid to liquidity pool to lock the above funds\n     */\n    function lock(\n        uint256 id,\n        uint256 tokenXAmount,\n        uint256 premium\n    ) external override onlyRole(OPTION_ISSUER_ROLE) {\n        require(id == lockedLiquidity[msg.sender].length, \"Pool: Wrong id\");\n\n        require(\n            (lockedAmount + tokenXAmount) <= totalTokenXBalance(),\n            \"Pool: Amount is too large.\"\n        );\n\n        bool success = tokenX.transferFrom(msg.sender, address(this), premium);\n        require(success, \"Pool: The Premium transfer didn't go through\");\n\n        lockedLiquidity[msg.sender].push(\n            LockedLiquidity(tokenXAmount, premium, true)\n        );\n        lockedPremium = lockedPremium + premium;\n        lockedAmount = lockedAmount + tokenXAmount;\n    }\n\n    /**\n     * @notice Called by BufferOptions to unlock the funds\n     * @param id Id of LockedLiquidity that should be unlocked\n     */\n    function unlock(uint256 id) external override onlyRole(OPTION_ISSUER_ROLE) {\n        uint256 premium = _unlock(id);\n\n        emit Profit(id, premium);\n    }\n\n    /**\n     * @notice Called by BufferCallOptions to send funds to liquidity providers after an option's expiration\n     * @param id Id of LockedLiquidity\n     * @param to Provider\n     * @param tokenXAmount Funds that should be sent\n     */\n    function send(\n        uint256 id,\n        address to,\n        uint256 tokenXAmount\n    ) external override onlyRole(OPTION_ISSUER_ROLE) {\n        LockedLiquidity storage ll = lockedLiquidity[msg.sender][id];\n        require(ll.locked, \"Pool: lockedAmount is already unlocked\");\n        require(to != address(0));\n\n        ll.locked = false;\n        lockedPremium = lockedPremium - ll.premium;\n        lockedAmount = lockedAmount - ll.amount;\n\n        uint256 transferTokenXAmount = tokenXAmount > ll.amount\n            ? ll.amount\n            : tokenXAmount;\n\n        bool success = tokenX.transfer(to, transferTokenXAmount);\n        require(success, \"Pool: The Payout transfer didn't go through\");\n\n        if (transferTokenXAmount <= ll.premium)\n            emit Profit(id, ll.premium - transferTokenXAmount);\n        else emit Loss(id, transferTokenXAmount - ll.premium);\n    }\n\n    /************************************************\n     *  INTERNAL FUNCTIONS\n     ***********************************************/\n\n    function _provide(\n        uint256 tokenXAmount,\n        uint256 minMint,\n        address account\n    ) internal returns (uint256 mint) {\n        uint256 supply = totalSupply();\n        uint256 balance = totalTokenXBalance();\n\n        require(\n            balance + tokenXAmount <= maxLiquidity,\n            \"Pool has already reached it's max limit\"\n        );\n\n        if (supply > 0 && balance > 0)\n            mint = (tokenXAmount * supply) / (balance);\n        else mint = tokenXAmount * INITIAL_RATE;\n\n        require(mint >= minMint, \"Pool: Mint limit is too large\");\n        require(mint > 0, \"Pool: Amount is too small\");\n\n        bool success = tokenX.transferFrom(\n            account,\n            address(this),\n            tokenXAmount\n        );\n        require(success, \"Pool: The Provide transfer didn't go through\");\n\n        _mint(account, mint);\n\n        LockedAmount memory amountLocked = LockedAmount(block.timestamp, mint);\n        liquidityPerUser[account].lockedAmounts.push(amountLocked);\n        _updateLiquidity(account);\n\n        emit Provide(account, tokenXAmount, mint);\n    }\n\n    function _updateLiquidity(address account) internal {\n        (\n            uint256 unlockedAmount,\n            uint256 nextIndexForUnlock\n        ) = _getUnlockedLiquidity(account);\n\n        liquidityPerUser[account].unlockedAmount = unlockedAmount;\n        liquidityPerUser[account].nextIndexForUnlock = nextIndexForUnlock;\n    }\n\n    function _getUnlockedLiquidity(address account)\n        internal\n        view\n        returns (uint256 unlockedAmount, uint256 nextIndexForUnlock)\n    {\n        uint256 len = liquidityPerUser[account].lockedAmounts.length;\n        unlockedAmount = liquidityPerUser[account].unlockedAmount;\n        uint256 index = liquidityPerUser[account].nextIndexForUnlock;\n        nextIndexForUnlock = index;\n        for (uint256 n = index; n < len; n++) {\n            if (\n                liquidityPerUser[account].lockedAmounts[n].timestamp +\n                    lockupPeriod <=\n                block.timestamp\n            ) {\n                unlockedAmount += liquidityPerUser[account]\n                    .lockedAmounts[n]\n                    .amount;\n                nextIndexForUnlock = n + 1;\n            } else {\n                break;\n            }\n        }\n    }\n\n    function _validateHandler() private view {\n        require(isHandler[msg.sender], \"Pool: forbidden\");\n    }\n\n    function _withdraw(uint256 tokenXAmount, address account)\n        internal\n        returns (uint256 burn)\n    {\n        require(\n            tokenXAmount <= availableBalance(),\n            \"Pool: Not enough funds on the pool contract. Please lower the amount.\"\n        );\n        uint256 totalSupply = totalSupply();\n        uint256 balance = totalTokenXBalance();\n\n        uint256 maxUserTokenXWithdrawal = (balanceOf(account) * balance) /\n            totalSupply;\n\n        uint256 tokenXAmountToWithdraw = maxUserTokenXWithdrawal < tokenXAmount\n            ? maxUserTokenXWithdrawal\n            : tokenXAmount;\n\n        burn = divCeil((tokenXAmountToWithdraw * totalSupply), balance);\n\n        _updateLiquidity(account);\n\n        require(\n            liquidityPerUser[account].unlockedAmount >= burn,\n            \"Pool: Withdrawal amount is greater than current unlocked amount\"\n        );\n        require(burn <= balanceOf(account), \"Pool: Amount is too large\");\n        require(burn > 0, \"Pool: Amount is too small\");\n\n        _burn(account, burn);\n\n        bool success = tokenX.transfer(account, tokenXAmountToWithdraw);\n        require(success, \"Pool: The Withdrawal didn't go through\");\n\n        emit Withdraw(account, tokenXAmountToWithdraw, burn);\n    }\n\n    function _unlock(uint256 id) internal returns (uint256 premium) {\n        LockedLiquidity storage ll = lockedLiquidity[msg.sender][id];\n        require(ll.locked, \"Pool: lockedAmount is already unlocked\");\n        ll.locked = false;\n\n        lockedPremium = lockedPremium - ll.premium;\n        lockedAmount = lockedAmount - ll.amount;\n        premium = ll.premium;\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 value\n    ) internal override {\n        if (!isHandler[from] && !isHandler[to] && from != address(0)) {\n            _updateLiquidity(from);\n            require(\n                liquidityPerUser[from].unlockedAmount >= value,\n                \"Pool: Transfer of funds in lock in period is blocked\"\n            );\n            liquidityPerUser[from].unlockedAmount -= value;\n            liquidityPerUser[to].unlockedAmount += value;\n        }\n    }\n\n    /************************************************\n     *  READ ONLY FUNCTIONS\n     ***********************************************/\n\n    /**\n     * @dev Returns the decimals of the token.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return tokenX.decimals();\n    }\n\n    /**\n     * @dev Converts BLP to tokenX.\n     */\n    function toTokenX(uint256 amount) public view returns (uint256) {\n        uint256 totalSupply = totalSupply();\n        uint256 balance = totalTokenXBalance();\n\n        return (amount * balance) / totalSupply;\n    }\n\n    /**\n     * @dev Returns available liquidity\n     */\n    function getUnlockedLiquidity(address account)\n        external\n        view\n        returns (uint256 unlockedAmount)\n    {\n        (unlockedAmount, ) = _getUnlockedLiquidity(account);\n    }\n\n    /**\n     * @notice Returns provider's share in X\n     */\n    function shareOf(address account) external view returns (uint256 share) {\n        if (totalSupply() > 0)\n            share = (totalTokenXBalance() * balanceOf(account)) / totalSupply();\n        else share = 0;\n    }\n\n    /**\n     * @notice Returns the amount of X available for withdrawals\n     */\n    function availableBalance() public view override returns (uint256 balance) {\n        return totalTokenXBalance() - lockedAmount;\n    }\n\n    /**\n     * @notice Returns the total balance of X provided to the pool\n     */\n    function totalTokenXBalance()\n        public\n        view\n        override\n        returns (uint256 balance)\n    {\n        return tokenX.balanceOf(address(this)) - lockedPremium;\n    }\n\n    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        if (a % b != 0) c = c + 1;\n        return c;\n    }\n}"
    },
    {
      "filename": "contracts/contracts/core/BufferRouter.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"../interfaces/Interfaces.sol\";\n\n/**\n * @author Heisenberg\n * @notice Buffer Options Router Contract\n */\ncontract BufferRouter is AccessControl, IBufferRouter {\n    uint16 MAX_WAIT_TIME = 1 minutes;\n    uint256 public nextQueueId = 0;\n    address public publisher;\n    uint256 public nextQueueIdToProcess = 0;\n    bool public isInPrivateKeeperMode = true;\n\n    mapping(address => uint256[]) public userQueuedIds;\n    mapping(address => uint256[]) public userCancelledQueuedIds;\n    mapping(address => uint256) public userNextQueueIndexToProcess;\n    mapping(uint256 => QueuedTrade) public queuedTrades;\n    mapping(address => bool) public contractRegistry;\n    mapping(address => bool) public isKeeper;\n\n    constructor(address _publisher) {\n        publisher = _publisher;\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /************************************************\n     *  ADMIN ONLY FUNCTIONS\n     ***********************************************/\n\n    function setContractRegistry(address targetContract, bool register)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        contractRegistry[targetContract] = register;\n    }\n\n    function setKeeper(address _keeper, bool _isActive)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        isKeeper[_keeper] = _isActive;\n    }\n\n    function setInPrivateKeeperMode() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        isInPrivateKeeperMode = !isInPrivateKeeperMode;\n    }\n\n    /************************************************\n     *  USER WRITE FUNCTIONS\n     ***********************************************/\n\n    /**\n     * @notice Adds an option creation request in the queue\n     */\n    function initiateTrade(\n        uint256 totalFee,\n        uint256 period,\n        bool isAbove,\n        address targetContract,\n        uint256 expectedStrike,\n        uint256 slippage,\n        bool allowPartialFill,\n        string memory referralCode,\n        uint256 traderNFTId\n    ) external returns (uint256 queueId) {\n        // Checks if the target contract has been registered\n        require(\n            contractRegistry[targetContract],\n            \"Router: Unauthorized contract\"\n        );\n        IBufferBinaryOptions optionsContract = IBufferBinaryOptions(\n            targetContract\n        );\n\n        optionsContract.runInitialChecks(slippage, period, totalFee);\n\n        // Transfer the fee specified from the user to this contract.\n        // User has to approve first inorder to execute this function\n        IERC20(optionsContract.tokenX()).transferFrom(\n            msg.sender,\n            address(this),\n            totalFee\n        );\n        queueId = nextQueueId;\n        nextQueueId++;\n\n        QueuedTrade memory queuedTrade = QueuedTrade(\n            queueId,\n            userQueueCount(msg.sender),\n            msg.sender,\n            totalFee,\n            period,\n            isAbove,\n            targetContract,\n            expectedStrike,\n            slippage,\n            allowPartialFill,\n            block.timestamp,\n            true,\n            referralCode,\n            traderNFTId\n        );\n\n        queuedTrades[queueId] = queuedTrade;\n\n        userQueuedIds[msg.sender].push(queueId);\n\n        emit InitiateTrade(msg.sender, queueId, block.timestamp);\n    }\n\n    /**\n     * @notice Cancels a queued traded. Can only be called by the trade owner\n     */\n    function cancelQueuedTrade(uint256 queueId) external {\n        QueuedTrade memory queuedTrade = queuedTrades[queueId];\n        require(msg.sender == queuedTrade.user, \"Router: Forbidden\");\n        require(queuedTrade.isQueued, \"Router: Trade has already been opened\");\n        _cancelQueuedTrade(queueId);\n        emit CancelTrade(queuedTrade.user, queueId, \"User Cancelled\");\n    }\n\n    /************************************************\n     *  KEEPER ONLY FUNCTIONS\n     ***********************************************/\n\n    /**\n     * @notice Verifies the trade parameter via the signature and resolves all the valid queued trades\n     */\n    function resolveQueuedTrades(OpenTradeParams[] calldata params) external {\n        _validateKeeper();\n        for (uint32 index = 0; index < params.length; index++) {\n            OpenTradeParams memory currentParams = params[index];\n            QueuedTrade memory queuedTrade = queuedTrades[\n                currentParams.queueId\n            ];\n            bool isSignerVerifed = _validateSigner(\n                currentParams.timestamp,\n                currentParams.asset,\n                currentParams.price,\n                currentParams.signature\n            );\n            // Silently fail if the signature doesn't match\n            if (!isSignerVerifed) {\n                emit FailResolve(\n                    currentParams.queueId,\n                    \"Router: Signature didn't match\"\n                );\n                continue;\n            }\n            if (\n                !queuedTrade.isQueued ||\n                currentParams.timestamp != queuedTrade.queuedTime\n            ) {\n                // Trade has already been opened or cancelled or the timestamp is wrong.\n                // So ignore this trade.\n                continue;\n            }\n\n            // If the opening time is much greater than the queue time then cancel the trade\n            if (block.timestamp - queuedTrade.queuedTime <= MAX_WAIT_TIME) {\n                _openQueuedTrade(currentParams.queueId, currentParams.price);\n            } else {\n                _cancelQueuedTrade(currentParams.queueId);\n                emit CancelTrade(\n                    queuedTrade.user,\n                    currentParams.queueId,\n                    \"Wait time too high\"\n                );\n            }\n\n            // Track the next queueIndex to be processed for user\n            userNextQueueIndexToProcess[queuedTrade.user] =\n                queuedTrade.userQueueIndex +\n                1;\n        }\n        // Track the next queueIndex to be processed overall\n        nextQueueIdToProcess = params[params.length - 1].queueId + 1;\n    }\n\n    /**\n     * @notice Verifies the option parameter via the signature and unlocks an array of options\n     */\n    function unlockOptions(CloseTradeParams[] calldata optionData) external {\n        _validateKeeper();\n\n        uint32 arrayLength = uint32(optionData.length);\n        for (uint32 i = 0; i < arrayLength; i++) {\n            CloseTradeParams memory params = optionData[i];\n            IBufferBinaryOptions optionsContract = IBufferBinaryOptions(\n                params.asset\n            );\n            (, , , , , uint256 expiration, , , ) = optionsContract.options(\n                params.optionId\n            );\n\n            bool isSignerVerifed = _validateSigner(\n                params.expiryTimestamp,\n                params"
    }
  ]
}