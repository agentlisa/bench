{
  "Title": "Imprecise bounds",
  "Content": "There are several examples where the time windows or value ranges are defined inconsistently. In particular:\n\n\n* The `getWithdrawalInfoInternal` function of the `RoutineInvokerLibV1` library considers the `end` timestamp to be [part of the withdrawal period](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/RoutineInvokerLibV1.sol#L70) but the `mustBeDuringWithdrawalPeriod` validation function [does not](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/RoutineInvokerLibV1.sol#L161).\n* The `StakingPoolLibV1` library [prevents withdrawals](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/StakingPoolLibV1.sol#L293) on the block height where withdrawals can start.\n* Neither the [`mustBeBeforeResolutionDeadline` function](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/ValidationLibV1.sol#L261) nor the [`mustBeAfterResolutionDeadline` function](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/ValidationLibV1.sol#L282) will succeed on the resolution deadline.\n* The flash loan fee calculation requires the loan to be [strictly less](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/VaultLibV1.sol#L306) than the available balance, even though the contract [claims](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/VaultLibV1.sol#L347) to loan out the whole balance.\n\n\n**Update:** *Fixed as of commit `3412b68b9d729d0bc5c3b5860ace7a38a06b9835` in [pull request #167](https://github.com/neptune-mutual-blue/protocol/pull/167).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/libraries/RoutineInvokerLibV1.sol",
      "content": "// Neptune Mutual Protocol (https://neptunemutual.com)\n// SPDX-License-Identifier: BUSL-1.1\n/* solhint-disable ordering  */\npragma solidity ^0.8.0;\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IStore.sol\";\nimport \"../interfaces/ILendingStrategy.sol\";\nimport \"./PriceLibV1.sol\";\nimport \"./ProtoUtilV1.sol\";\nimport \"./CoverUtilV1.sol\";\nimport \"./RegistryLibV1.sol\";\nimport \"./StrategyLibV1.sol\";\nimport \"./ValidationLibV1.sol\";\n\nlibrary RoutineInvokerLibV1 {\n  using PriceLibV1 for IStore;\n  using ProtoUtilV1 for IStore;\n  using RegistryLibV1 for IStore;\n  using StrategyLibV1 for IStore;\n  using CoverUtilV1 for IStore;\n  using StoreKeyUtil for IStore;\n  using ValidationLibV1 for IStore;\n\n  enum Action {\n    Deposit,\n    Withdraw\n  }\n\n  function updateStateAndLiquidity(IStore s, bytes32 coverKey) external {\n    _invoke(s, coverKey);\n  }\n\n  function _invoke(IStore s, bytes32 coverKey) private {\n    // solhint-disable-next-line\n    if (s.getLastUpdatedOnInternal(coverKey) + _getUpdateInterval(s) > block.timestamp) {\n      return;\n    }\n\n    PriceLibV1.setNpmPrice(s);\n\n    if (coverKey > 0) {\n      _updateWithdrawalPeriod(s, coverKey);\n      _invokeAssetManagement(s, coverKey);\n      s.setLastUpdatedOn(coverKey);\n    }\n  }\n\n  function _getUpdateInterval(IStore s) private view returns (uint256) {\n    return s.getUintByKey(ProtoUtilV1.NS_LIQUIDITY_STATE_UPDATE_INTERVAL);\n  }\n\n  function getWithdrawalInfoInternal(IStore s, bytes32 coverKey)\n    public\n    view\n    returns (\n      bool isWithdrawalPeriod,\n      uint256 lendingPeriod,\n      uint256 withdrawalWindow,\n      uint256 start,\n      uint256 end\n    )\n  {\n    (lendingPeriod, withdrawalWindow) = s.getRiskPoolingPeriodsInternal(coverKey);\n\n    // Get the withdrawal period of this cover liquidity\n    start = s.getUintByKey(getNextWithdrawalStartKey(coverKey));\n    end = s.getUintByKey(getNextWithdrawalEndKey(coverKey));\n\n    // solhint-disable-next-line\n    if (block.timestamp >= start && block.timestamp <= end) {\n      isWithdrawalPeriod = true;\n    }\n  }\n\n  function _isWithdrawalPeriod(IStore s, bytes32 coverKey) private view returns (bool) {\n    (bool isWithdrawalPeriod, , , , ) = getWithdrawalInfoInternal(s, coverKey);\n    return isWithdrawalPeriod;\n  }\n\n  function _updateWithdrawalPeriod(IStore s, bytes32 coverKey) private {\n    (, uint256 lendingPeriod, uint256 withdrawalWindow, uint256 start, uint256 end) = getWithdrawalInfoInternal(s, coverKey);\n\n    // Without a lending period and withdrawal window, nothing can be updated\n    if (lendingPeriod == 0 || withdrawalWindow == 0) {\n      return;\n    }\n\n    // The withdrawal period is now over.\n    // Deposits can be performed again.\n    // Set the next withdrawal cycle\n    if (block.timestamp > end) {\n      // solhint-disable-previous-line\n\n      // Next Withdrawal Cycle\n\n      // Withdrawals can start after the lending period\n      start = block.timestamp + lendingPeriod; // solhint-disable\n      // Withdrawals can be performed until the end of the next withdrawal cycle\n      end = start + withdrawalWindow;\n\n      s.setUintByKey(getNextWithdrawalStartKey(coverKey), start);\n      s.setUintByKey(getNextWithdrawalEndKey(coverKey), end);\n      setAccrualCompleteInternal(s, coverKey, false);\n    }\n  }\n\n  function isAccrualCompleteInternal(IStore s, bytes32 coverKey) external view returns (bool) {\n    return s.getBoolByKey(getAccrualInvocationKey(coverKey));\n  }\n\n  function setAccrualCompleteInternal(\n    IStore s,\n    bytes32 coverKey,\n    bool flag\n  ) public {\n    s.setBoolByKey(getAccrualInvocationKey(coverKey), flag);\n  }\n\n  /**\n   * @dev Hash key of the \"accrual invocation status\" for the given cover.\n   *\n   * Warning: this function does not validate the cover key supplied.\n   *\n   * @param coverKey Enter cover key\n   *\n   */\n  function getAccrualInvocationKey(bytes32 coverKey) public pure returns (bytes32) {\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_ACCRUAL_INVOCATION, coverKey));\n  }\n\n  /**\n   * @dev Hash key of the \"next withdrawal start date\" for the given cover.\n   *\n   * Warning: this function does not validate the cover key supplied.\n   *\n   * @param coverKey Enter cover key\n   *\n   */\n  function getNextWithdrawalStartKey(bytes32 coverKey) public pure returns (bytes32) {\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_LENDING_STRATEGY_WITHDRAWAL_START, coverKey));\n  }\n\n  /**\n   * @dev Hash key of the \"next withdrawal end date\" for the given cover.\n   *\n   * Warning: this function does not validate the cover key supplied.\n   *\n   * @param coverKey Enter cover key\n   *\n   */\n  function getNextWithdrawalEndKey(bytes32 coverKey) public pure returns (bytes32) {\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_LENDING_STRATEGY_WITHDRAWAL_END, coverKey));\n  }\n\n  function mustBeDuringWithdrawalPeriod(IStore s, bytes32 coverKey) external view {\n    // Get the withdrawal period of this cover liquidity\n    uint256 start = s.getUintByKey(getNextWithdrawalStartKey(coverKey));\n    uint256 end = s.getUintByKey(getNextWithdrawalEndKey(coverKey));\n\n    require(start > 0 && block.timestamp >= start, \"Withdrawal period has not started\");\n    require(end > 0 && block.timestamp < end, \"Withdrawal period has already ended\");\n  }\n\n  function _executeAndGetAction(\n    IStore s,\n    ILendingStrategy,\n    bytes32 coverKey\n  ) private returns (Action) {\n    // If the cover is undergoing reporting, withdraw everything\n    bool isNormal = s.isCoverNormalInternal(coverKey);\n\n    if (isNormal != true) {\n      // Reset the withdrawal window\n      s.setUintByKey(getNextWithdrawalStartKey(coverKey), 0);\n      s.setUintByKey(getNextWithdrawalEndKey(coverKey), 0);\n\n      return Action.Withdraw;\n    }\n\n    if (_isWithdrawalPeriod(s, coverKey) == true) {\n      return Action.Withdraw;\n    }\n\n    return Action.Deposit;\n  }\n\n  function _canDeposit(\n    IStore s,\n    ILendingStrategy strategy,\n    uint256 totalStrategies,\n    bytes32 coverKey\n  ) private view returns (uint256) {\n    IERC20 stablecoin = IERC20(s.getStablecoin());\n\n    uint256 totalBalance = s.getStablecoinOwnedByVaultInternal(coverKey);\n    uint256 maximumAllowed = (totalBalance * s.getMaxLendingRatioInternal()) / ProtoUtilV1.MULTIPLIER;\n    uint256 allocation = maximumAllowed / totalStrategies;\n    uint256 weight = strategy.getWeight();\n    uint256 canDeposit = (allocation * weight) / ProtoUtilV1.MULTIPLIER;\n    uint256 alreadyDeposited = s.getAmountInStrategy(coverKey, strategy.getName(), address(stablecoin));\n\n    if (alreadyDeposited >= canDeposit) {\n      return 0;\n    }\n\n    return canDeposit - alreadyDeposited;\n  }\n\n  function _invokeAssetManagement(IStore s, bytes32 coverKey) private {\n    address vault = s.getVaultAddress(coverKey);\n    _withdrawFromDisabled(s, coverKey, vault);\n\n    address[] memory strategies = s.getActiveStrategiesInternal();\n\n    for (uint256 i = 0; i < strategies.length; i++) {\n      ILendingStrategy strategy = ILendingStrategy(strategies[i]);\n      _executeStrategy(s, strategy, strategies.length, vault, coverKey);\n    }\n  }\n\n  function _executeStrategy(\n    IStore s,\n    ILendingStrategy strategy,\n    uint256 totalStrategies,\n    address vault,\n    bytes32 coverKey\n  ) private {\n    uint256 canDeposit = _canDeposit(s, strategy, totalStrategies, coverKey);\n    uint256 balance = IERC20(s.getStablecoin()).balanceOf(vault);\n\n    if (canDeposit > balance) {\n      canDeposit = balance;\n    }\n\n    Action action = _executeAndGetAction(s, strategy, coverKey);\n\n    if (action == Action.Deposit && canDeposit == 0) {\n      return;\n    }\n\n    if (action == Action.Withdraw) {\n      _withdrawAllFromStrategy(strategy, vault, coverKey);\n      return;\n    }\n\n    _depositToStrategy(strategy, coverKey, canDeposit);\n  }\n\n  function _depositToStrategy(\n    ILendingStrategy strategy,\n    bytes32 coverKey,\n    uint256 amount\n  ) private {\n    strategy.deposit(coverKey, amount);\n  }\n\n  function _withdrawAllFromStrategy(\n    ILendingStrategy strategy,\n    address vault,\n    bytes32 coverKey\n  ) private returns (uint256 stablecoinWithdrawn) {\n    uint256 balance = IERC20(strategy.getDepositCertificate()).balanceOf(vault);\n\n    if (balance > 0) {\n      stablecoinWithdrawn = strategy.withdraw(coverKey);\n    }\n  }\n\n  function _withdrawFromDisabled(\n    IStore s,\n    bytes32 coverKey,\n    address onBehalfOf\n  ) private {\n    address[] memory strategies = s.getDisabledStrategiesInternal();\n\n    for (uint256 i = 0; i < strategies.length; i++) {\n      ILendingStrategy strategy = ILendingStrategy(strategies[i]);\n      uint256 balance = IERC20(strategy.getDepositCertificate()).balanceOf(onBehalfOf);\n\n      if (balance > 0) {\n        strategy.withdraw(coverKey);\n      }\n    }\n  }\n}"
    },
    {
      "filename": "contracts/libraries/StakingPoolLibV1.sol",
      "content": "// Neptune Mutual Protocol (https://neptunemutual.com)\n// SPDX-License-Identifier: BUSL-1.1\n/* solhint-disable ordering  */\npragma solidity ^0.8.0;\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\nimport \"./StoreKeyUtil.sol\";\nimport \"./ProtoUtilV1.sol\";\nimport \"./NTransferUtilV2.sol\";\nimport \"./ValidationLibV1.sol\";\nimport \"./StakingPoolCoreLibV1.sol\";\n\nlibrary StakingPoolLibV1 {\n  using ProtoUtilV1 for IStore;\n  using ValidationLibV1 for IStore;\n  using RegistryLibV1 for IStore;\n  using StoreKeyUtil for IStore;\n  using StakingPoolCoreLibV1 for IStore;\n  using NTransferUtilV2 for IERC20;\n\n  /**\n   * @dev Gets the info of a given staking pool by key\n   * @param s Specify the store instance\n   * @param key Provide the staking pool key to fetch info for\n   * @param you Specify the address to customize the info for\n   * @param name Returns the name of the staking pool\n   * @param addresses[0] stakingToken --> Returns the address of the token which is staked in this pool\n   * @param addresses[1] stakingTokenStablecoinPair --> Returns the pair address of the staking token and stablecoin\n   * @param addresses[2] rewardToken --> Returns the address of the token which is rewarded in this pool\n   * @param addresses[3] rewardTokenStablecoinPair --> Returns the pair address of the reward token and stablecoin\n   * @param values[0] totalStaked --> Returns the total units of staked tokens\n   * @param values[1] target --> Returns the target amount to stake (as staking token unit)\n   * @param values[2] maximumStake --> Returns the maximum amount of staking token units that can be added at a time\n   * @param values[3] stakeBalance --> Returns the amount of staking token currently locked in the pool\n   * @param values[4] cumulativeDeposits --> Returns the total amount tokens which were deposited in this pool\n   * @param values[5] rewardPerBlock --> Returns the unit of reward tokens awarded on each block for each unit of staking token\n   * @param values[6] platformFee --> Returns the % rate (multipled by ProtoUtilV1.MULTIPLIER) charged by protocol on rewards\n   * @param values[7] lockupPeriod --> Returns the period until when a stake can't be withdrawn\n   * @param values[8] rewardTokenBalance --> Returns the balance of the reward tokens still left in the pool\n   * @param values[9] accountStakeBalance --> Returns your stake amount\n   * @param values[10] totalBlockSinceLastReward --> Returns the number of blocks since your last reward\n   * @param values[11] rewards --> The amount of reward tokens you have accumulated till this block\n   * @param values[12] canWithdrawFromBlockHeight --> The block height after which you are allowed to withdraw your stake\n   * @param values[13] lastDepositHeight --> Returns the block number of your last deposit\n   * @param values[14] lastRewardHeight --> Returns the block number of your last reward\n   */\n  function getInfoInternal(\n    IStore s,\n    bytes32 key,\n    address you\n  )\n    external\n    view\n    returns (\n      string memory name,\n      address[] memory addresses,\n      uint256[] memory values\n    )\n  {\n    addresses = new address[](4);\n    values = new uint256[](15);\n\n    bool valid = s.checkIfStakingPoolExists(key);\n\n    if (valid) {\n      name = s.getStringByKeys(StakingPoolCoreLibV1.NS_POOL, key);\n\n      addresses[0] = s.getStakingTokenAddressInternal(key);\n      addresses[1] = s.getStakingTokenStablecoinPairAddressInternal(key);\n      addresses[2] = s.getRewardTokenAddressInternal(key);\n      addresses[3] = s.getRewardTokenStablecoinPairAddressInternal(key);\n\n      values[0] = s.getTotalStaked(key);\n      values[1] = s.getTarget(key);\n      values[2] = s.getMaximumStakeInternal(key);\n      values[3] = getPoolStakeBalanceInternal(s, key);\n      values[4] = getPoolCumulativeDeposits(s, key);\n      values[5] = s.getRewardPerBlock(key);\n      values[6] = s.getRewardPlatformFee(key);\n      values[7] = s.getLockupPeriodInBlocks(key);\n      values[8] = s.getRewardTokenBalance(key);\n      values[9] = getAccountStakingBalanceInternal(s, key, you);\n      values[10] = getTotalBlocksSinceLastRewardInternal(s, key, you);\n      values[11] = calculateRewardsInternal(s, key, you);\n      values[12] = canWithdrawFromBlockHeightInternal(s, key, you);\n      values[13] = getLastDepositHeight(s, key, you);\n      values[14] = getLastRewardHeight(s, key, you);\n    }\n  }\n\n  function getPoolStakeBalanceInternal(IStore s, bytes32 key) public view returns (uint256) {\n    uint256 totalStake = s.getUintByKeys(StakingPoolCoreLibV1.NS_POOL_STAKING_TOKEN_BALANCE, key);\n    return totalStake;\n  }\n\n  function getPoolCumulativeDeposits(IStore s, bytes32 key) public view returns (uint256) {\n    uint256 totalStake = s.getUintByKeys(StakingPoolCoreLibV1.NS_POOL_CUMULATIVE_STAKING_AMOUNT, key);\n    return totalStake;\n  }\n\n  function getAccountStakingBalanceInternal(\n    IStore s,\n    bytes32 key,\n    address account\n  ) public view returns (uint256) {\n    return s.getUintByKeys(StakingPoolCoreLibV1.NS_POOL_STAKING_TOKEN_BALANCE, key, account);\n  }\n\n  function getTotalBlocksSinceLastRewardInternal(\n    IStore s,\n    bytes32 key,\n    address account\n  ) public view returns (uint256) {\n    uint256 from = getLastRewardHeight(s, key, account);\n\n    if (from == 0) {\n      return 0;\n    }\n\n    return block.number - from;\n  }\n\n  function canWithdrawFromBlockHeightInternal(\n    IStore s,\n    bytes32 key,\n    address account\n  ) public view returns (uint256) {\n    uint256 lastDepositHeight = getLastDepositHeight(s, key, account);\n\n    if (lastDepositHeight == 0) {\n      return 0;\n    }\n\n    uint256 lockupPeriod = s.getLockupPeriodInBlocks(key);\n\n    return lastDepositHeight + lockupPeriod;\n  }\n\n  function getLastDepositHeight(\n    IStore s,\n    bytes32 key,\n    address account\n  ) public view returns (uint256) {\n    return s.getUintByKeys(StakingPoolCoreLibV1.NS_POOL_DEPOSIT_HEIGHTS, key, account);\n  }\n\n  function getLastRewardHeight(\n    IStore s,\n    bytes32 key,\n    address account\n  ) public view returns (uint256) {\n    return s.getUintByKeys(StakingPoolCoreLibV1.NS_POOL_REWARD_HEIGHTS, key, account);\n  }\n\n  function getStakingPoolRewardTokenBalance(IStore s, bytes32 key) public view returns (uint256) {\n    IERC20 rewardToken = IERC20(s.getAddressByKeys(StakingPoolCoreLibV1.NS_POOL_REWARD_TOKEN, key));\n    address stakingPool = s.getStakingPoolAddress();\n\n    return rewardToken.balanceOf(stakingPool);\n  }\n\n  function calculateRewardsInternal(\n    IStore s,\n    bytes32 key,\n    address account\n  ) public view returns (uint256) {\n    uint256 totalBlocks = getTotalBlocksSinceLastRewardInternal(s, key, account);\n\n    if (totalBlocks == 0) {\n      return 0;\n    }\n\n    uint256 rewardPerBlock = s.getRewardPerBlock(key);\n    uint256 myStake = getAccountStakingBalanceInternal(s, key, account);\n    uint256 rewards = (myStake * rewardPerBlock * totalBlocks) / 1 ether;\n\n    uint256 poolBalance = getStakingPoolRewardTokenBalance(s, key);\n\n    return rewards > poolBalance ? poolBalance : rewards;\n  }\n\n  /**\n   * @dev Withdraws the rewards of the caller (if any or if available).\n   *\n   *\n   * @custom:suppress-malicious-erc The ERC-20 `rewardtoken` can't be manipulated via user input.\n   *\n   */\n  function withdrawRewardsInternal(\n    IStore s,\n    bytes32 key,\n    address account\n  )\n    public\n    returns (\n      address rewardToken,\n      uint256 rewards,\n      uint256 platformFee\n    )\n  {\n    require(s.getRewardPlatformFee(key) <= ProtoUtilV1.MULTIPLIER, \"Invalid reward platform fee\");\n    rewards = calculateRewardsInternal(s, key, account);\n\n    s.setUintByKeys(StakingPoolCoreLibV1.NS_POOL_REWARD_HEIGHTS, key, account, block.number);\n\n    if (rewards == 0) {\n      return (address(0), 0, 0);\n    }\n\n    rewardToken = s.getAddressByKeys(StakingPoolCoreLibV1.NS_POOL_REWARD_TOKEN, key);\n\n    // Update (decrease) the balance of reward token\n    s.subtractUintByKeys(StakingPoolCoreLibV1.NS_POOL_REWARD_TOKEN_BALANCE, key, rewards);\n\n    // Update total rewards given\n    s.addUintByKeys(StakingPoolCoreLibV1.NS_POOL_TOTAL_REWARD_GIVEN, key, account, rewards); // To this account\n    s.addUintByKeys(StakingPoolCoreLibV1.NS_POOL_TOTAL_REWARD_GIVEN, key, rewards); // To everyone\n\n    // @suppress-division Checked side effects. If the reward platform fee is zero\n    // or a very small number, platform fee becomes zero because of data loss\n    platformFee = (rewards * s.getRewardPlatformFee(key)) / ProtoUtilV1.MULTIPLIER;\n\n    // @suppress-subtraction If `getRewardPlatformFee` is 100%, the following can result in zero value.\n    if (rewards - platformFee > 0) {\n      IERC20(rewardToken).ensureTransfer(msg.sender, rewards - platformFee);\n    }\n\n    if (platformFee > 0) {\n      IERC20(rewardToken).ensureTransfer(s.getTreasury(), platformFee);\n    }\n  }\n\n  /**\n   * @dev Deposit the specified amount of staking token to the specified pool.\n   *\n   * @custom:suppress-malicious-erc The ERC-20 `stakingToken` can't be manipulated via user input.\n   *\n   */\n  function depositInternal(\n    IStore s,\n    bytes32 key,\n    uint256 amount\n  )\n    external\n    returns (\n      address stakingToken,\n      address rewardToken,\n      uint256 rewards,\n      uint256 rewardsPlatformFee\n    )\n  {\n    require(amount > 0, \"Enter an amount\");\n    require(amount <= s.getMaximumStakeInternal(key), \"Stake too high\");\n    require(amount <= s.getAvailableToStakeInternal(key), \"Target achieved or cap exceeded\");\n\n    stakingToken = s.getStakingTokenAddressInternal(key);\n\n    // First withdraw your rewards\n    (rewardToken, rewards, rewardsPlatformFee) = withdrawRewardsInternal(s, key, msg.sender);\n\n    // Individual state\n    s.addUintByKeys(StakingPoolCoreLibV1.NS_POOL_STAKING_TOKEN_BALANCE, key, msg.sender, amount);\n    s.setUintByKeys(StakingPoolCoreLibV1.NS_POOL_DEPOSIT_HEIGHTS, key, msg.sender, block.number);\n\n    // Global state\n    s.addUintByKeys(StakingPoolCoreLibV1.NS_POOL_STAKING_TOKEN_BALANCE, key, amount);\n    s.addUintByKeys(StakingPoolCoreLibV1.NS_POOL_CUMULATIVE_STAKING_AMOUNT, key, amount);\n\n    IERC20(stakingToken).ensureTransferFrom(msg.sender, address(this), amount);\n  }\n\n  /**\n   * @dev Withdraw the specified amount of staking token from the specified pool.\n   *\n   * @custom:suppress-malicious-erc The ERC-20 `stakingToken` can't be manipulated via user input.\n   *\n   */\n  function withdrawInternal(\n    IStore s,\n    bytes32 key,\n    uint256 amount\n  )\n    external\n    returns (\n      address stakingToken,\n      address rewardToken,\n      uint256 rewards,\n      uint256 rewardsPlatformFee\n    )\n  {\n    require(amount > 0, \"Please specify amount\");\n\n    require(getAccountStakingBalanceInternal(s, key, msg.sender) >= amount, \"Insufficient balance\");\n    require(block.number > canWithdrawFromBlockHeightInternal(s, key, msg.sender), \"Withdrawal too early\");\n\n    stakingToken = s.getStakingTokenAddressInternal(key);\n\n    // First withdraw your rewards\n    (rewardToken, rewards, rewardsPlatformFee) = withdrawRewardsInternal(s, key, msg.sender);\n\n    // @suppress-subtraction The maximum amount that can be withdrawn is the staked balance\n    // and therefore underflow is not possible.\n    // Individual state\n    s.subtractUintByKeys(StakingPoolCoreLibV1.NS_POOL_STAKING_TOKEN_BALANCE, key, msg.sender, amount);\n\n    // Global state\n    s.subtractUintByKeys(StakingPoolCoreLibV1.NS_POOL_STAKING_TOKEN_BALANCE, key, amount);\n\n    IERC20(stakingToken).ensureTransfer(msg.sender, amount);\n  }\n}"
    },
    {
      "filename": "contracts/libraries/ValidationLibV1.sol",
      "content": "// Neptune Mutual Protocol (https://neptunemutual.com)\n// SPDX-License-Identifier: BUSL-1.1\n/* solhint-disable ordering  */\npragma solidity ^0.8.0;\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-solidity/contracts/access/IAccessControl.sol\";\nimport \"./ProtoUtilV1.sol\";\nimport \"./StoreKeyUtil.sol\";\nimport \"./RegistryLibV1.sol\";\nimport \"./CoverUtilV1.sol\";\nimport \"./GovernanceUtilV1.sol\";\nimport \"./AccessControlLibV1.sol\";\nimport \"../interfaces/IStore.sol\";\nimport \"../interfaces/IPausable.sol\";\nimport \"../interfaces/ICxToken.sol\";\n\nlibrary ValidationLibV1 {\n  using ProtoUtilV1 for IStore;\n  using StoreKeyUtil for IStore;\n  using CoverUtilV1 for IStore;\n  using GovernanceUtilV1 for IStore;\n  using RegistryLibV1 for IStore;\n\n  /**\n   * @dev Reverts if the protocol is paused\n   */\n  function mustNotBePaused(IStore s) public view {\n    address protocol = s.getProtocolAddress();\n    require(IPausable(protocol).paused() == false, \"Protocol is paused\");\n  }\n\n  /**\n   * @dev Reverts if the cover or any of the cover's product is not normal.\n   * @param coverKey Enter the cover key to check\n   */\n  function mustEnsureAllProductsAreNormal(IStore s, bytes32 coverKey) external view {\n    require(s.getBoolByKeys(ProtoUtilV1.NS_COVER, coverKey), \"Cover does not exist\");\n    require(s.isCoverNormalInternal(coverKey) == true, \"Status not normal\");\n  }\n\n  /**\n   * @dev Reverts if the key does not resolve in a valid cover contract\n   * or if the cover is under governance.\n   * @param coverKey Enter the cover key to check\n   * @param productKey Enter the product key to check\n   */\n  function mustHaveNormalProductStatus(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  ) external view {\n    require(s.getBoolByKeys(ProtoUtilV1.NS_COVER, coverKey), \"Cover does not exist\");\n    require(s.getProductStatusInternal(coverKey, productKey) == CoverUtilV1.ProductStatus.Normal, \"Status not normal\");\n  }\n\n  /**\n   * @dev Reverts if the key does not resolve in a valid cover contract.\n   * @param coverKey Enter the cover key to check\n   */\n  function mustBeValidCoverKey(IStore s, bytes32 coverKey) external view {\n    require(s.getBoolByKeys(ProtoUtilV1.NS_COVER, coverKey), \"Cover does not exist\");\n  }\n\n  /**\n   * @dev Reverts if the cover does not support creating products.\n   * @param coverKey Enter the cover key to check\n   */\n  function mustSupportProducts(IStore s, bytes32 coverKey) external view {\n    require(s.supportsProductsInternal(coverKey), \"Does not have products\");\n  }\n\n  /**\n   * @dev Reverts if the key does not resolve in a valid product of a cover contract.\n   * @param coverKey Enter the cover key to check\n   * @param productKey Enter the cover key to check\n   */\n  function mustBeValidProduct(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  ) public view {\n    require(s.isValidProductInternal(coverKey, productKey), \"Product does not exist\");\n  }\n\n  /**\n   * @dev Reverts if the key resolves in an expired product.\n   * @param coverKey Enter the cover key to check\n   * @param productKey Enter the cover key to check\n   */\n  function mustBeActiveProduct(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  ) public view {\n    require(s.isActiveProductInternal(coverKey, productKey), \"Product retired or deleted\");\n  }\n\n  /**\n   * @dev Reverts if the sender is not the cover owner\n   * @param coverKey Enter the cover key to check\n   * @param sender The `msg.sender` value\n   */\n  function mustBeCoverOwner(\n    IStore s,\n    bytes32 coverKey,\n    address sender\n  ) public view {\n    bool isCoverOwner = s.getCoverOwner(coverKey) == sender;\n    require(isCoverOwner, \"Forbidden\");\n  }\n\n  /**\n   * @dev Reverts if the sender is not the cover owner or the cover contract\n   * @param coverKey Enter the cover key to check\n   * @param sender The `msg.sender` value\n   */\n  function mustBeCoverOwnerOrCoverContract(\n    IStore s,\n    bytes32 coverKey,\n    address sender\n  ) external view {\n    bool isCoverOwner = s.getCoverOwner(coverKey) == sender;\n    bool isCoverContract = address(s.getCoverContract()) == sender;\n\n    require(isCoverOwner || isCoverContract, \"Forbidden\");\n  }\n\n  function senderMustBeCoverOwnerOrAdmin(IStore s, bytes32 coverKey) external view {\n    if (AccessControlLibV1.hasAccess(s, AccessControlLibV1.NS_ROLES_ADMIN, msg.sender) == false) {\n      mustBeCoverOwner(s, coverKey, msg.sender);\n    }\n  }\n\n  function senderMustBePolicyContract(IStore s) external view {\n    s.senderMustBeExactContract(ProtoUtilV1.CNS_COVER_POLICY);\n  }\n\n  function senderMustBePolicyManagerContract(IStore s) external view {\n    s.senderMustBeExactContract(ProtoUtilV1.CNS_COVER_POLICY_MANAGER);\n  }\n\n  function senderMustBeCoverContract(IStore s) external view {\n    s.senderMustBeExactContract(ProtoUtilV1.CNS_COVER);\n  }\n\n  function senderMustBeVaultContract(IStore s, bytes32 coverKey) external view {\n    address vault = s.getVaultAddress(coverKey);\n    require(msg.sender == vault, \"Forbidden\");\n  }\n\n  function senderMustBeGovernanceContract(IStore s) external view {\n    s.senderMustBeExactContract(ProtoUtilV1.CNS_GOVERNANCE);\n  }\n\n  function senderMustBeClaimsProcessorContract(IStore s) external view {\n    s.senderMustBeExactContract(ProtoUtilV1.CNS_CLAIM_PROCESSOR);\n  }\n\n  function callerMustBeClaimsProcessorContract(IStore s, address caller) external view {\n    s.callerMustBeExactContract(ProtoUtilV1.CNS_CLAIM_PROCESSOR, caller);\n  }\n\n  function senderMustBeStrategyContract(IStore s) external view {\n    bool senderIsStrategyContract = s.getBoolByKey(_getIsActiveStrategyKey(msg.sender));\n    require(senderIsStrategyContract == true, \"Not a strategy contract\");\n  }\n\n  function callerMustBeStrategyContract(IStore s, address caller) public view {\n    bool isActive = s.getBoolByKey(_getIsActiveStrategyKey(caller));\n    bool wasDisabled = s.getBoolByKey(_getIsDisabledStrategyKey(caller));\n\n    require(isActive == true || wasDisabled == true, \"Not a strategy contract\");\n  }\n\n  function callerMustBeSpecificStrategyContract(\n    IStore s,\n    address caller,\n    bytes32 strategyName\n  ) external view {\n    callerMustBeStrategyContract(s, caller);\n    require(IMember(caller).getName() == strategyName, \"Access denied\");\n  }\n\n  /**\n   * @dev Hash key of the \"active strategy flag\".\n   *\n   * Warning: this function does not validate the input arguments.\n   *\n   * @param strategyAddress Enter a strategy address\n   *\n   */\n  function _getIsActiveStrategyKey(address strategyAddress) private pure returns (bytes32) {\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_LENDING_STRATEGY_ACTIVE, strategyAddress));\n  }\n\n  /**\n   * @dev Hash key of the \"disabled strategy flag\".\n   *\n   * Warning: this function does not validate the input arguments.\n   *\n   * @param strategyAddress Enter a strategy address\n   *\n   */\n  function _getIsDisabledStrategyKey(address strategyAddress) private pure returns (bytes32) {\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_LENDING_STRATEGY_DISABLED, strategyAddress));\n  }\n\n  function senderMustBeProtocolMember(IStore s) external view {\n    require(s.isProtocolMember(msg.sender), \"Forbidden\");\n  }\n\n  function mustBeReporting(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  ) external view {\n    require(s.getProductStatusInternal(coverKey, productKey) == CoverUtilV1.ProductStatus.IncidentHappened, \"Not reporting\");\n  }\n\n  function mustBeDisputed(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  ) external view {\n    require(s.getProductStatusInternal(coverKey, productKey) == CoverUtilV1.ProductStatus.FalseReporting, \"Not disputed\");\n  }\n\n  function mustBeClaimable(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  ) public view {\n    require(s.getProductStatusInternal(coverKey, productKey) == CoverUtilV1.ProductStatus.Claimable, \"Not claimable\");\n  }\n\n  function mustBeClaimingOrDisputed(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  ) external view {\n    CoverUtilV1.ProductStatus status = s.getProductStatusInternal(coverKey, productKey);\n\n    bool claiming = status == CoverUtilV1.ProductStatus.Claimable;\n    bool falseReporting = status == CoverUtilV1.ProductStatus.FalseReporting;\n\n    require(claiming || falseReporting, \"Not claimable nor disputed\");\n  }\n\n  function mustBeReportingOrDisputed(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  ) external view {\n    CoverUtilV1.ProductStatus status = s.getProductStatusInternal(coverKey, productKey);\n    bool incidentHappened = status == CoverUtilV1.ProductStatus.IncidentHappened;\n    bool falseReporting = status == CoverUtilV1.ProductStatus.FalseReporting;\n\n    require(incidentHappened || falseReporting, \"Not reported nor disputed\");\n  }\n\n  function mustBeBeforeResolutionDeadline(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  ) external view {\n    uint256 deadline = s.getResolutionDeadlineInternal(coverKey, productKey);\n\n    if (deadline > 0) {\n      require(block.timestamp < deadline, \"Emergency resolution deadline over\"); // solhint-disable-line\n    }\n  }\n\n  function mustNotHaveResolutionDeadline(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  ) external view {\n    uint256 deadline = s.getResolutionDeadlineInternal(coverKey, productKey);\n    require(deadline == 0, \"Resolution already has deadline\");\n  }\n\n  function mustBeAfterResolutionDeadline(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  ) public view {\n    uint256 deadline = s.getResolutionDeadlineInternal(coverKey, productKey);\n    require(deadline > 0 && block.timestamp > deadline, \"Still unresolved\"); // solhint-disable-line\n  }\n\n  function mustBeValidIncidentDate(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey,\n    uint256 incidentDate\n  ) public view {\n    require(s.getActiveIncidentDateInternal(coverKey, productKey) == incidentDate, \"Invalid incident date\");\n  }\n\n  function mustHaveDispute(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  ) external view {\n    bool hasDispute = s.getBoolByKey(GovernanceUtilV1.getHasDisputeKeyInternal(coverKey, productKey));\n    require(hasDispute == true, \"Not disputed\");\n  }\n\n  function mustNotHaveDispute(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  ) external view {\n    bool hasDispute = s.getBoolByKey(GovernanceUtilV1.getHasDisputeKeyInternal(coverKey, productKey));\n    require(hasDispute == false, \"Already disputed\");\n  }\n\n  function mustBeDuringReportingPeriod(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  ) external view {\n    require(s.getResolutionTimestampInternal(coverKey, productKey) >= block.timestamp, \"Reporting window closed\"); // solhint-disable-line\n  }\n\n  function mustBeAfterReportingPeriod(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  ) public view {\n    require(block.timestamp > s.getResolutionTimestampInternal(coverKey, productKey), \"Reporting still active\"); // solhint-disable-line\n  }\n\n  function mustBeValidCxToken(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey,\n    address cxToken,\n    uint256 incidentDate\n  ) public view {\n    require(s.getBoolByKeys(ProtoUtilV1.NS_COVER_CXTOKEN, cxToken) == true, \"Unknown cxToken\");\n\n    bytes32 COVER_KEY = ICxToken(cxToken).COVER_KEY(); // solhint-disable-line\n    bytes32 PRODUCT_KEY = ICxToken(cxToken).PRODUCT_KEY(); // solhint-disable-line\n\n    require(coverKey == COVER_KEY && productKey == PRODUCT_KEY, \"Invalid cxToken\");\n\n    uint256 expires = ICxToken(cxToken).expiresOn();\n    require(expires > incidentDate, \"Invalid or expired cxToken\");\n  }\n\n  function mustBeValidClaim(\n    IStore s,\n    address account,\n    bytes32 coverKey,\n    bytes32 productKey,\n    address cxToken,\n    uint256 incidentDate,\n    uint256 amount\n  ) external view {\n    mustBeSupportedProductOrEmpty(s, coverKey, productKey);\n    mustBeValidCxToken(s, coverKey, productKey, cxToken, incidentDate);\n    mustBeClaimable(s, coverKey, productKey);\n    mustBeValidIncidentDate(s, coverKey, productKey, incidentDate);\n    mustBeDuringClaimPeriod(s, coverKey, productKey);\n    require(ICxToken(cxToken).getClaimablePolicyOf(account) >= amount, \"Claim exceeds your coverage\");\n  }\n\n  function mustNotHaveUnstaken(\n    IStore s,\n    address account,\n    bytes32 coverKey,\n    bytes32 productKey,\n    uint256 incidentDate\n  ) public view {\n    uint256 withdrawal = s.getReportingUnstakenAmountInternal(account, cov"
    }
  ]
}