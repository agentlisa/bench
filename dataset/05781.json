{
  "Title": "[M-07] If `RootBridgeAgent.lzReceiveNonBlocking` reverts internally, the native token sent by relayer to RootBridgeAgent is left in RootBridgeAgent",
  "Content": "\n[v2 adapterParams](https://layerzero.gitbook.io/docs/evm-guides/advanced/relayer-adapter-parameters#airdrop) are used to send messages, which means that the relayer will send native token to RootBridgeAgent before [RootBridgeAgent.lzReceive](https://github.com/code-423n4/2023-09-maia/blob/main/src/RootBridgeAgent.sol#L423) is called. However, if an exception occurs inside [lzReceiveNonBlocking](https://github.com/code-423n4/2023-09-maia/blob/main/src/RootBridgeAgent.sol#L434-L439), `lzReceive` will [not revert (except for ARB branch)](https://github.com/code-423n4/2023-09-maia/blob/main/src/RootBridgeAgent.sol#L430). In this way, the native token sent to RootBridgeAgent will stay in RootBridgeAgent. Malicious users can steal these native tokens by sending some messages.\n\n### Proof of Concept\n\nThe messages discussed below are all sent using V2 (Airdrop):\n\nWhen the cross-chain message reaches RootBridgeAgent, the relayer from layerZero will first send the native token to RootBridgeAgent and then call `RootBridgeAgent.lzReceive` which internally calls `lzReceiveNonBlocking` to process various messages.\n\n```solidity\nFile: src\\RootBridgeAgent.sol\n423:     function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64, bytes calldata _payload) public {\n424:         (bool success,) = address(this).excessivelySafeCall(\n425:             gasleft(),\n426:             150,\n427:             abi.encodeWithSelector(this.lzReceiveNonBlocking.selector, msg.sender, _srcChainId, _srcAddress, _payload)\n428:         );\n429:         \n430:->       if (!success) if (msg.sender == getBranchBridgeAgent[localChainId]) revert ExecutionFailure();\n431:     }\n```\n\nFrom the above code we can see that if `lzReceiveNonBlocking` returns false, as long as the sender is not from `getBranchBridgeAgent[localChainId]`(ARB branch), then tx will not revert. **This means that the native token previously sent by the relayer is left in this contract (RootBridgeAgent)**.\n\nIn `lzReceiveNonBlocking`, the functions used to process messages are two `_execute` functions: [1](https://github.com/code-423n4/2023-09-maia/blob/main/src/RootBridgeAgent.sol#L749-L758), [2](https://github.com/code-423n4/2023-09-maia/blob/main/src/RootBridgeAgent.sol#L768-L794). The difference between the former and the latter is whether Fallback can be triggered if a failure to process the message occurs.\n\n```solidity\nFile: src\\RootBridgeAgent.sol\n749:     function _execute(uint256 _depositNonce, bytes memory _calldata, uint16 _srcChainId) private {\n750:         //Update tx state as executed\n751:         executionState[_srcChainId][_depositNonce] = STATUS_DONE;\n752: \n753:         //Try to execute the remote request\n754:         (bool success,) = bridgeAgentExecutorAddress.call{value: address(this).balance}(_calldata);\n755: \n756:         // No fallback is requested revert allowing for retry.\n757:->       if (!success) revert ExecutionFailure();\n758:     }\n```\n\nIf the message is processed by `_execute` in L749, when `bridgeAgentExecutorAddress.call` returns `false`, the value sent is still in the current contract.\n\n```solidity\nFile: src\\RootBridgeAgent.sol\n768:     function _execute(\n769:         bool _hasFallbackToggled,\n770:         uint32 _depositNonce,\n771:         address _refundee,\n772:         bytes memory _calldata,\n773:         uint16 _srcChainId\n774:     ) private {\n775:         //Update tx state as executed\n776:         executionState[_srcChainId][_depositNonce] = STATUS_DONE;\n777: \n778:         //Try to execute the remote request\n779:         (bool success,) = bridgeAgentExecutorAddress.call{value: address(this).balance}(_calldata);\n780: \n781:         //Update tx state if execution failed\n782:         if (!success) {\n783:             //Read the fallback flag.\n784:             if (_hasFallbackToggled) {\n785:                 // Update tx state as retrieve only\n786:                 executionState[_srcChainId][_depositNonce] = STATUS_RETRIEVE;\n787:                 // Perform the fallback call\n788:                 _performFallbackCall(payable(_refundee), _depositNonce, _srcChainId);\n789:             } else {\n790:                 // No fallback is requested revert allowing for retry.\n791:                 revert ExecutionFailure();\n792:             }\n793:         }\n794:     }\n```\n\n`_hasFallbackToggled` is set when the user sends a message. When `bridgeAgentExecutorAddress.call` returns `false`:\n\n*   If the user sets the fallback flag, `_performFallbackCall` will be called, where [the native token previously sent by the relayer will be taken away](https://github.com/code-423n4/2023-09-maia/blob/main/src/RootBridgeAgent.sol#L940). There is no problem.\n*   If the user doesn't set the fallback flag, the value sent is still in the current contract.\n\nConsider the following scenario:\n\n1. Alice wants to send the USDC of the ftm branch to the mainnet branch via [BranchBridgeAgent.callOutSignedAndBridge](https://github.com/code-423n4/2023-09-maia/blob/main/src/BranchBridgeAgent.sol#L276-L282). The `_hasFallbackToggled` argument is set to `false`, that is, fallback will be not triggered. This operation requires two cross-chain messages: `ftm->arb` and `arb->mainnet`. `_gParams.remoteBranchExecutionGas` is set to 1 ether.\n\n2. When the message reaches RootBridgeAgent, relayer sends 1 ether native token to RootBridgeAgent, then calls `RootBridgeAgent.lzReceive`. The processing flow is as follows:\n\n    ```flow\n    RootBridgeAgent.lzReceive\n      (bool success,) = lzReceiveNonBlocking\n        _execute\t//_hasFallbackToggled = false\n          (bool success,) = bridgeAgentExecutorAddress.call\n          //if success = false\n          revert ExecutionFailure()\n      //success is false due to revert internally, msg.sender is not from arb, so tx will not revert\n    ```\n\n    This resulted in 1 ether native token being left in the RootBridgeAgent.\n\n3. Bob notices that RootBridgeAgent has ether and immediately calls via `BranchBridgeAgent.callOutSignedAndBridge`. The `_hasFallbackToggled` argument is set to `true`, that is, fallback will be triggered. The Call encoded in `_params` parameter intentionally triggers revert.\n\n4. When the message reaches RootBridgeAgent, the processing flow is as follows:\n\n    ```flow\n    RootBridgeAgent.lzReceive\n      (bool success,) = lzReceiveNonBlocking\n        _execute\t//_hasFallbackToggled = true\n          (bool success,) = bridgeAgentExecutorAddress.call\n          //success = false due to intentionally revert\n          _performFallbackCall\t//L788\n            //all native token held by RootBridgeAgent is taken away by this function\n            ILayerZeroEndpoint(lzEndpointAddress).send{value: address(this).balance}\n    ```\n\n5. Bob get all native token held by RootBridgeAgent because the excess gas will be returned to Bob by relayer.\n\n### Recommended Mitigation Steps\n\nIn `lzReceive`, if `success` is false and `msg.sender` is not an ARB branch, then the balance held by this should be returned to the sender address of the source message.\n\n### Assessed type\n\nContext\n\n**[alcueca (judge) decreased severity to Medium](https://github.com/code-423n4/2023-09-maia-findings/issues/518#issuecomment-1778896512)**\n\n**[0xLightt (Maia) confirmed via duplicate issue #464](https://github.com/code-423n4/2023-09-maia-findings/issues/464#issuecomment-1787990729)**\n\n**[0xBugsy (Maia) commented](https://github.com/code-423n4/2023-09-maia-findings/issues/518#issuecomment-1807198069):**\n > Addressed [here](https://github.com/Maia-DAO/2023-09-maia-remediations/commit/5ef0d547a9683750cee0859d0eca8f760b45959f).\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2023-09-maia-findings/issues/518).*\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-09-maia",
  "Code": [
    {
      "filename": "src/RootBridgeAgent.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ExcessivelySafeCall} from \"lib/ExcessivelySafeCall.sol\";\n\nimport {ILayerZeroEndpoint} from \"./interfaces/ILayerZeroEndpoint.sol\";\n\nimport {IBranchBridgeAgent} from \"./interfaces/IBranchBridgeAgent.sol\";\nimport {IERC20hTokenRoot} from \"./interfaces/IERC20hTokenRoot.sol\";\n\nimport {BridgeAgentConstants} from \"./interfaces/BridgeAgentConstants.sol\";\nimport {\n    GasParams,\n    DepositParams,\n    DepositMultipleParams,\n    ILayerZeroReceiver,\n    IRootBridgeAgent,\n    Settlement,\n    SettlementInput,\n    SettlementMultipleInput\n} from \"./interfaces/IRootBridgeAgent.sol\";\n\nimport {IRootPort as IPort} from \"./interfaces/IRootPort.sol\";\n\nimport {VirtualAccount} from \"./VirtualAccount.sol\";\nimport {DeployRootBridgeAgentExecutor, RootBridgeAgentExecutor} from \"./RootBridgeAgentExecutor.sol\";\n\n/// @title Root Bridge Agent Contract\n/// @author MaiaDAO\ncontract RootBridgeAgent is IRootBridgeAgent, BridgeAgentConstants {\n    using SafeTransferLib for address;\n    using ExcessivelySafeCall for address;\n    /*///////////////////////////////////////////////////////////////\n                        ROOT BRIDGE AGENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Local Chain Id\n    uint16 public immutable localChainId;\n\n    /// @notice Bridge Agent Factory Address.\n    address public immutable factoryAddress;\n\n    /// @notice Local Core Root Router Address\n    address public immutable localRouterAddress;\n\n    /// @notice Local Port Address where funds deposited from this chain are stored.\n    address public immutable localPortAddress;\n\n    /// @notice Local Layer Zero Endpoint Address for cross-chain communication.\n    address public immutable lzEndpointAddress;\n\n    /// @notice Address of Root Bridge Agent Executor.\n    address public immutable bridgeAgentExecutorAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                        BRANCH BRIDGE AGENTS STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Chain -> Branch Bridge Agent Address. For N chains, each Root Bridge Agent Address has M =< N Branch Bridge Agent Address.\n    mapping(uint256 chainId => address branchBridgeAgent) public getBranchBridgeAgent;\n\n    /// @notice Message Path for each connected Branch Bridge Agent as bytes for Layzer Zero interaction = localAddress + destinationAddress abi.encodePacked()\n    mapping(uint256 chainId => bytes branchBridgeAgentPath) public getBranchBridgeAgentPath;\n\n    /// @notice If true, bridge agent manager has allowed for a new given branch bridge agent to be synced/added.\n    mapping(uint256 chainId => bool allowed) public isBranchBridgeAgentAllowed;\n\n    /*///////////////////////////////////////////////////////////////\n                            SETTLEMENTS STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Deposit nonce used for identifying transaction.\n    uint32 public settlementNonce;\n\n    /// @notice Mapping from Settlement nonce to Settlement Struct.\n    mapping(uint256 nonce => Settlement settlementInfo) public getSettlement;\n\n    /*///////////////////////////////////////////////////////////////\n                            EXECUTOR STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice If true, bridge agent has already served a request with this nonce from  a given chain. Chain -> Nonce -> Bool\n    mapping(uint256 chainId => mapping(uint256 nonce => uint256 state)) public executionState;\n\n    /*///////////////////////////////////////////////////////////////\n                            REENTRANCY STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Re-entrancy lock modifier state.\n    uint256 internal _unlocked = 1;\n\n    /*///////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructor for Bridge Agent.\n     *     @param _localChainId Local Chain Id.\n     *     @param _lzEndpointAddress Local Layerzero Endpoint Address.\n     *     @param _localPortAddress Local Port Address.\n     *     @param _localRouterAddress Local Port Address.\n     */\n    constructor(\n        uint16 _localChainId,\n        address _lzEndpointAddress,\n        address _localPortAddress,\n        address _localRouterAddress\n    ) {\n        require(_lzEndpointAddress != address(0), \"Layerzero Enpoint Address cannot be zero address\");\n        require(_localPortAddress != address(0), \"Port Address cannot be zero address\");\n        require(_localRouterAddress != address(0), \"Router Address cannot be zero address\");\n\n        factoryAddress = msg.sender;\n        localChainId = _localChainId;\n        lzEndpointAddress = _lzEndpointAddress;\n        localPortAddress = _localPortAddress;\n        localRouterAddress = _localRouterAddress;\n        bridgeAgentExecutorAddress = DeployRootBridgeAgentExecutor.deploy(address(this));\n        settlementNonce = 1;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        FALLBACK FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    receive() external payable {}\n\n    /*///////////////////////////////////////////////////////////////\n                        VIEW EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootBridgeAgent\n    function getSettlementEntry(uint32 _settlementNonce) external view override returns (Settlement memory) {\n        return getSettlement[_settlementNonce];\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function getFeeEstimate(\n        uint256 _gasLimit,\n        uint256 _remoteBranchExecutionGas,\n        bytes calldata _payload,\n        uint16 _dstChainId\n    ) external view returns (uint256 _fee) {\n        (_fee,) = ILayerZeroEndpoint(lzEndpointAddress).estimateFees(\n            _dstChainId,\n            address(this),\n            _payload,\n            false,\n            abi.encodePacked(uint16(2), _gasLimit, _remoteBranchExecutionGas, getBranchBridgeAgent[_dstChainId])\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    ROOT ROUTER EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootBridgeAgent\n    function callOut(\n        address payable _refundee,\n        address _recipient,\n        uint16 _dstChainId,\n        bytes calldata _params,\n        GasParams calldata _gParams\n    ) external payable override lock requiresRouter {\n        //Encode Data for call.\n        bytes memory payload = abi.encodePacked(bytes1(0x00), _recipient, settlementNonce++, _params);\n\n        //Perform Call to clear hToken balance on destination branch chain.\n        _performCall(_dstChainId, _refundee, payload, _gParams);\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function callOutAndBridge(\n        address payable _refundee,\n        address _recipient,\n        uint16 _dstChainId,\n        bytes calldata _params,\n        SettlementInput calldata _sParams,\n        GasParams calldata _gParams,\n        bool _hasFallbackToggled\n    ) external payable override lock requiresRouter {\n        // Create Settlement and Perform call\n        bytes memory payload = _createSettlement(\n            settlementNonce,\n            _refundee,\n            _recipient,\n            _dstChainId,\n            _params,\n            _sParams.globalAddress,\n            _sParams.amount,\n            _sParams.deposit,\n            _hasFallbackToggled\n        );\n\n        //Perform Call.\n        _performCall(_dstChainId, _refundee, payload, _gParams);\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function callOutAndBridgeMultiple(\n        address payable _refundee,\n        address _recipient,\n        uint16 _dstChainId,\n        bytes calldata _params,\n        SettlementMultipleInput calldata _sParams,\n        GasParams calldata _gParams,\n        bool _hasFallbackToggled\n    ) external payable override lock requiresRouter {\n        // Create Settlement and Perform call\n        bytes memory payload = _createSettlementMultiple(\n            settlementNonce,\n            _refundee,\n            _recipient,\n            _dstChainId,\n            _sParams.globalAddresses,\n            _sParams.amounts,\n            _sParams.deposits,\n            _params,\n            _hasFallbackToggled\n        );\n\n        // Perform Call to destination Branch Chain.\n        _performCall(_dstChainId, _refundee, payload, _gParams);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    SETTLEMENT EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootBridgeAgent\n    function retrySettlement(\n        uint32 _settlementNonce,\n        address _recipient,\n        bytes calldata _params,\n        GasParams calldata _gParams,\n        bool _hasFallbackToggled\n    ) external payable override lock {\n        // Get storage reference\n        Settlement storage settlementReference = getSettlement[_settlementNonce];\n\n        // Check if Settlement hasn't been redeemed.\n        if (settlementReference.owner == address(0)) revert SettlementRetryUnavailable();\n\n        // Check if caller is Settlement owner\n        if (msg.sender != settlementReference.owner) {\n            if (msg.sender != address(IPort(localPortAddress).getUserAccount(settlementReference.owner))) {\n                revert NotSettlementOwner();\n            }\n        }\n\n        // Update Settlement Status\n        settlementReference.status = STATUS_SUCCESS;\n\n        // Perform Settlement Retry\n        _performRetrySettlementCall(\n            _hasFallbackToggled,\n            settlementReference.hTokens,\n            settlementReference.tokens,\n            settlementReference.amounts,\n            settlementReference.deposits,\n            _params,\n            _settlementNonce,\n            payable(settlementReference.owner),\n            _recipient,\n            settlementReference.dstChainId,\n            _gParams,\n            msg.value\n        );\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function retrieveSettlement(uint32 _settlementNonce, GasParams calldata _gParams) external payable lock {\n        //Get settlement storage reference\n        Settlement storage settlementReference = getSettlement[_settlementNonce];\n\n        // Get Settlement owner.\n        address settlementOwner = settlementReference.owner;\n\n        // Check if Settlement is Retrieve.\n        if (settlementOwner == address(0)) revert SettlementRetrieveUnavailable();\n\n        // Check Settlement Owner\n        if (msg.sender != settlementOwner) {\n            if (msg.sender != address(IPort(localPortAddress).getUserAccount(settlementOwner))) {\n                revert NotSettlementOwner();\n            }\n        }\n\n        //Encode Data for cross-chain call.\n        bytes memory payload = abi.encodePacked(bytes1(0x03), settlementOwner, _settlementNonce);\n\n        //Retrieve Deposit\n        _performCall(settlementReference.dstChainId, payable(settlementOwner), payload, _gParams);\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function redeemSettlement(uint32 _settlementNonce) external override lock {\n        // Get setttlement storage reference\n        Settlement storage settlement = getSettlement[_settlementNonce];\n\n        // Get deposit owner.\n        address settlementOwner = settlement.owner;\n\n        // Check if Settlement is redeemable.\n        if (settlement.status == STATUS_SUCCESS) revert SettlementRedeemUnavailable();\n        if (settlementOwner == address(0)) revert SettlementRedeemUnavailable();\n\n        // Check if Settlement Owner is msg.sender or msg.sender is the virtual account of the settlement owner.\n        if (msg.sender != settlementOwner) {\n            if (msg.sender != address(IPort(localPortAddress).getUserAccount(settlementOwner))) {\n                revert NotSettlementOwner();\n            }\n        }\n\n        // Clear Global hTokens To Recipient on Root Chain cancelling Settlement to Branch\n        for (uint256 i = 0; i < settlement.hTokens.length;) {\n            // Save to memory\n            address _hToken = settlement.hTokens[i];\n\n            // Check if asset\n            if (_hToken != address(0)) {\n                // Save to memory\n                uint24 _dstChainId = settlement.dstChainId;\n\n                // Move hTokens from Branch to Root + Mint Sufficient hTokens to match new port deposit\n                IPort(localPortAddress).bridgeToRoot(\n                    msg.sender,\n                    IPort(localPortAddress).getGlobalTokenFromLocal(_hToken, _dstChainId),\n                    settlement.amounts[i],\n                    settlement.deposits[i],\n                    _dstChainId\n                );\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Delete Settlement\n        delete getSettlement[_settlementNonce];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    TOKEN MANAGEMENT EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootBridgeAgent\n    function bridgeIn(address _recipient, DepositParams memory _dParams, uint256 _srcChainId)\n        public\n        override\n        requiresAgentExecutor\n    {\n        // Deposit can't be greater than amount.\n        if (_dParams.amount < _dParams.deposit) revert InvalidInputParams();\n\n        // Cache local port address\n        address _localPortAddress = localPortAddress;\n\n        // Check local exists.\n        if (_dParams.amount > 0) {\n            if (!IPort(_localPortAddress).isLocalToken(_dParams.hToken, _srcChainId)) {\n                revert InvalidInputParams();\n            }\n        }\n\n        // Check underlying exists.\n        if (_dParams.deposit > 0) {\n            if (IPort(_localPortAddress).getLocalTokenFromUnderlying(_dParams.token, _srcChainId) != _dParams.hToken) {\n                revert InvalidInputParams();\n            }\n        }\n\n        // Move hTokens from Branch to Root + Mint Sufficient hTokens to match new port deposit\n        IPort(_localPortAddress).bridgeToRoot(\n            _recipient,\n            IPort(_localPortAddress).getGlobalTokenFromLocal(_dParams.hToken, _srcChainId),\n            _dParams.amount,\n            _dParams.deposit,\n            _srcChainId\n        );\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function bridgeInMultiple(address _recipient, DepositMultipleParams calldata _dParams, uint256 _srcChainId)\n        external\n        override\n        requiresAgentExecutor\n    {\n        // Cache length\n        uint256 length = _dParams.hTokens.length;\n\n        // Check MAX_LENGTH\n        if (length > MAX_TOKENS_LENGTH) revert InvalidInputParams();\n\n        // Bridge in assets\n        for (uint256 i = 0; i < length;) {\n            bridgeIn(\n                _recipient,\n                DepositParams({\n                    hToken: _dParams.hTokens[i],\n                    token: _dParams.tokens[i],\n                    amount: _dParams.amounts[i],\n                    deposit: _dParams.deposits[i],\n                    depositNonce: 0\n                }),\n                _srcChainId\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    LAYER ZERO EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ILayerZeroReceiver\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64, bytes calldata _payload) public {\n        (bool success,) = address(this).excessivelySafeCall(\n            gasleft(),\n            150,\n            abi.encodeWithSelector(this.lzReceiveNonBlocking.selector, msg.sender, _srcChainId, _srcAddress, _payload)\n        );\n\n        if (!success) if (msg.sender == getBranchBridgeAgent[localChainId]) revert ExecutionFailure();\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function lzReceiveNonBlocking(\n        address _endpoint,\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        bytes calldata _payload\n    ) public override requiresEndpoint(_endpoint, _srcChainId, _srcAddress) {\n        // Deposit Nonce\n        uint32 nonce;\n\n        // DEPOSIT FLAG: 0 (System request / response)\n        if (_payload[0] == 0x00) {\n            // Parse deposit nonce\n            nonce = uint32(bytes4(_payload[PARAMS_START:PARAMS_TKN_START]));\n\n            // Check if tx has already been executed\n            if (executionState[_srcChainId][nonce] != STATUS_READY) {\n                revert AlreadyExecutedTransaction();\n            }\n\n            // Avoid stack too deep\n            uint16 srcChainId = _srcChainId;\n\n            // Try to execute remote request\n            // Flag 0 - RootBridgeAgentExecutor(bridgeAgentExecutorAddress).executeSystemRequest(_localRouterAddress, _payload, _srcChainId)\n            _execute(\n                nonce,\n                abi.encodeWithSelector(\n                    RootBridgeAgentExecutor.executeSystemRequest.selector, localRouterAddress, _payload, srcChainId\n                ),\n                srcChainId\n            );\n\n            // DEPOSIT FLAG: 1 (Call without Deposit)\n        } else if (_payload[0] == 0x01) {\n            // Parse Deposit Nonce\n            nonce = uint32(bytes4(_payload[PARAMS_START:PARAMS_TKN_START]));\n\n            // Check if tx has already been executed\n            if (executionState[_srcChainId][nonce] != STATUS_READY) {\n                revert AlreadyExecutedTransaction();\n            }\n\n            // Avoid stack too deep\n            uint16 srcChainId = _srcChainId;\n\n            // Try to execute remote request\n            // Flag 1 - RootBridgeAgentExecutor(bridgeAgentExecutorAddress).executeNoDeposit(localRouterAddress, payload, _srcChainId)\n            _execute(\n                nonce,\n                abi.encodeWithSelector(\n                    RootBridgeAgentExecutor.executeNoDeposit.selector, localRouterAddress, _payload, srcChainId\n                ),\n                srcChainId\n            );\n\n            // DEPOSIT FLAG: 2 (Call with Deposit)\n        } else if (_payload[0] == 0x02) {\n            //Parse Deposit Nonce\n            nonce = uint32(bytes4(_payload[PARAMS_START:PARAMS_TKN_START]));\n\n            //Check if tx has already been executed\n            if (executionState[_srcChainId][nonce] != STATUS_READY) {\n                revert AlreadyExecutedTransaction();\n            }\n\n            // Avoid stack too deep\n            uint16 srcChainId = _srcChainId;\n\n            // Try to execute remote request\n            // Flag 2 - RootBridgeAgentExecutor(bridgeAgentExecutorAddress).executeWithDeposit(localRouterAddress, _payload, _srcChainId)\n            _execute(\n                nonce,\n                abi.encodeWithSelector(\n                    RootBridgeAgentExecutor.executeWithDeposit.selector, localRouterAddress, _payload, srcChainId\n                ),\n                srcChainId\n            );\n\n            // DEPOSIT FLAG: 3 (Call with multiple asset Deposit)\n        } else if (_payload[0] == 0x03) {\n            // Parse deposit nonce\n            nonce = uint32(bytes4(_payload[2:6]));\n\n            // Check if tx has already been executed\n            if (executionState[_srcChainId][nonce] != STATUS_READY) {\n                revert AlreadyExecutedTransaction();\n            }\n\n            // Avoid stack too deep\n            uint16 srcChainId = _srcChainId;\n\n            // Try to execute remote request\n            // Flag 3 - RootBridgeAgentExecutor(bridgeAgentExecutorAddress).executeWithDepositMultiple(localRouterAddress, _payload, _srcChainId)\n            _execute(\n                nonce,\n                abi.encodeWithSelector(\n                    RootBridgeAgentExecutor.executeWithDepositMultiple.selector,\n                    localRouterAddress,\n                    _payload,\n                    srcChainId\n                ),\n                srcChainId\n            );\n\n            // DEPOSIT FLAG: 4 (Call without Deposit + msg.sender)\n        } else if (_payload[0] == 0x04) {\n            // Parse deposit nonce\n            nonce = uint32(bytes4(_payload[PARAMS_START_SIGNED:PARAMS_TKN_START_SIGNED]));\n\n            //Check if tx has already been executed\n            if (executionState[_srcChainId][nonce] != STATUS_READY) {\n                revert AlreadyExecutedTransaction();\n            }\n\n            // Get User Virtual Account\n            VirtualAccount userAccount = IPort(localPortAddress).fetchVirtualAccount(\n                address(uint160(bytes20(_payload[PARAMS_START:PARAMS_START_SIGNED])))\n            );\n\n            // Toggle Router Virtual Account use for tx execution\n            IPort(localPortAddress).toggleVirtualAccountApproved(userAccount, localRouterAddress);\n\n            // Avoid stack too deep\n            uint16 srcChainId = _srcChainId;\n\n            // Try to execute remote request\n            // Flag 4 - RootBridgeAgentExecutor(bridgeAgentExecutorAddress).executeSignedNoDeposit(address(userAccount), localRouterAddress, data, _srcChainId\n            _execute(\n                nonce,\n                abi.encodeWithSelector(\n                    RootBridgeAgentExecutor.executeSignedNoDeposit.selector,\n                    address(userAccount),\n                    localRouterAddress,\n                    _payload,\n                    srcChainId\n                ),\n                srcChainId\n            );\n\n            // Toggle Router Virtual Account use for tx execution\n            IPort(localPortAddress).toggleVirtualAccountApproved(userAccount, localRouterAddress);\n\n            //DEPOSIT FLAG: 5 (Call with Deposit + msg.sender)\n        } else if (_payload[0] & 0x7F == 0x05) {\n            // Parse deposit nonce\n            nonce = uint32(bytes4(_payload[PARAMS_START_SIGNED:PARAMS_TKN_START_SIGNED]));\n\n            //Check if tx has already been executed\n            if (executionState[_srcChainId][nonce] != STATUS_READY) {\n                revert AlreadyExecutedTransaction();\n            }\n\n            // Get User Virtual Account\n            VirtualAccount userAccount = IPort(localPortAddress).fetchVirtualAccount(\n                address(uint160(bytes20(_payload[PARAMS_START:PARAMS_START_SIGNED])))\n            );\n\n            // Toggle Router Virtual Account use for tx execution\n            IPort(localPortAddress).toggleVirtualAccountApproved(userAccount, localRouterAddress);\n\n            // Avoid stack too deep\n            uint16 srcChainId = _srcChainId;\n\n            // Try to execute remote request\n            // Flag 5 - RootBridgeAgentExecutor(bridgeAgentExecutorAddress).executeSignedWithDeposit(address(userAccount), localRouterAddress, data, _srcChainId)\n            _execute(\n                _payload[0] == 0x85,\n                nonce,\n                address(uint160(bytes20(_payload[PARAMS_START:PARAMS_START_SIGNED]))),\n                abi.encodeWithSelector(\n                    RootBridgeAgentExecutor.executeSignedWithDeposit.selector,\n                    address(userAccount),\n                    localRouterAddress,\n                    _payload,\n                    srcChainId\n                ),\n                srcChainId\n            );\n\n            // Toggle Router Virtual Account use for tx execution\n            IPort(localPortAddress).toggleVirtualAccountApproved(userAccount, localRouterAddress);\n\n            // DEPOSIT FLAG: 6 (Call with multiple asset Deposit + msg.sender)\n        } else if (_payload[0] & 0x7F == 0x06) {\n            // Parse deposit nonce\n            nonce = uint32(bytes4(_payload[PARAMS_START_SIGNED + PARAMS_START:PARAMS_START_SIGNED + PARAMS_TKN_START]));\n\n            // Check if tx has already been executed\n            if (executionState[_srcChainId][nonce] != STATUS_READY) {\n                revert AlreadyExecutedTransaction();\n            }\n\n            // Get User Virtual Account\n            VirtualAccount userAccount = IPort(localPortAddress).fetchVirtualAccount(\n                address(uint160(bytes20(_payload[PARAMS_START:PARAMS_START_SIGNED])))\n            );\n\n            // Toggle Router Virtual Account use for tx execution\n            IPort(localPortAddress).toggleVirtualAccountApproved(userAccount, localRouterAddress);\n\n            // Avoid stack too deep\n            uint16 srcChainId = _srcChainId;\n\n            // Try to execute remote request\n            // Flag 6 - RootBridgeAgentExecutor(bridgeAgentExecutorAddress).executeSignedWithDepositMultiple(address(userAccount), localRouterAddress, data, _srcChainId)\n            _execute(\n                _payload[0] == 0x86,\n                nonce,\n                address(uint160(bytes20(_payload[PARAMS_START:PARAMS_START_SIGNED]))),\n                abi.encodeWithSelector(\n                    RootBridgeAgentExecutor.executeSignedWithDepositMultiple.selector,\n                    address(userAccount),\n                    localRouterAddress,\n                    _payload,\n                    srcChainId\n                ),\n                srcChainId\n            );\n\n            // Toggle Router Virtual Account use for tx execution\n            IPort(localPortAddress).toggleVirtualAccountApproved(userAccount, localRouterAddress);\n\n            /// DEPOSIT FLAG: 7 (retrySettlement)\n        } else if (_payload[0] & 0x7F == 0x07) {\n            // Prepare Variables for decoding\n            address owner;\n            bytes memory params;\n            GasParams memory gParams;\n\n            // Decode Input\n            (nonce, owner, params, gParams) = abi.decode(_payload[PARAMS_START:], (uint32, address, bytes, GasParams));\n\n            // Get storage reference\n            Settlement storage settlementReference = getSettlement[nonce];\n\n            // Check if Settlement hasn't been redeemed.\n            if (settlementReference.owner == address(0)) revert SettlementRetryUnavailable();\n\n            // Check settlement owner\n            if (owner != settlementReference.owner) {\n                if (owner != address(IPort(localPortAddress).getUserAccount(settlementReference.owner))) {\n                    revert NotSettlementOwner();\n                }\n            }\n\n            //Update Settlement Staus\n            settlementReference.status = STATUS_SUCCESS;\n\n            //Retry settlement call with new params and gas\n            _performRetrySettlementCall(\n                _payload[0] == 0x87,\n                settlementReference.hTokens,\n                settlementReference.tokens,\n                settlementReference.amounts,\n                settlementReference.deposits,\n                params,\n                nonce,\n                payable(settlementReference.owner),\n                settlementReference.recipient,\n                settlementReference.dstChainId,\n                gParams,\n                address(this).balance\n            );\n\n            /// DEPOSIT FLAG: 8 (retrieveDeposit)\n        } else if (_payload[0] == 0x08) {\n            //Parse deposit nonce\n            nonce = uint32(bytes4(_payload[PARAMS_START_SIGNED:PARAMS_TKN_START_SIGNED]));\n\n            //Check if deposit is in retrieve mode\n            if (executionState[_srcChainId][nonce] == STATUS_DONE) {\n                revert AlreadyExecutedTransaction();\n            } else {\n                //Set settlement to retrieve mode, if not already set.\n                if (executionState[_srcChainId][nonce] == STATUS_READY) {\n                    executionState[_srcChainId][nonce] = STATUS_RETRIEVE;\n                }\n                //Trigger fallback/Retry failed fallback\n                _performFallbackCall(\n                    payable(address(uint160(bytes20(_payload[PARAMS_START:PARAMS_START_SIGNED])))), nonce, _srcChainId\n                );\n            }\n\n            //DEPOSIT FLAG: 9 (Fallback)\n        } else if (_payload[0] == 0x09) {\n            // Parse nonce\n            nonce = uint32(bytes4(_payload[PARAMS_START:PARAMS_TKN_START]));\n\n            // Reopen Settlement for redemption\n            getSettlement[nonce].status = STATUS_FAILED;\n\n            // Emit LogFallback\n            emit LogFallback(nonce, _srcChainId);\n\n            // return to prevent unnecessary emits/logic\n            return;\n\n            // Unrecognized Function Selector\n        } else {\n            revert UnknownFlag();\n        }\n\n        emit LogExecute(nonce, _srcChainId);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                DEPOSIT EXECUTION INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Internal function requests execution from Root Bridge Agent Executor Contract.\n     *   @param _depositNonce Identifier for nonce being executed.\n     *   @param _calldata Payload of message to be executed by the Root Bridge Agent Executor Contract.\n     *   @param _srcChainId Chain ID of source chain where request originates from.\n     */\n    function _execute(uint256 _depositNonce, bytes memory _calldata, uint16 _srcChainId) private {\n        //Update tx state as executed\n        executionState[_srcChainId][_depositNonce] = STATUS_DONE;\n\n        //Try to execute the remote request\n        (bool success,) = bridgeAgentExecutorAddress.call{value: address(this).balance}(_calldata);\n\n        // No fallback is requested revert allowing for retry.\n        if (!success) revert ExecutionFailure();\n    }\n\n    /**\n     * @notice Internal function requests execution from Root Bridge Agent Executor Contract.\n     *   @param _hasFallbackToggled if true, fallback on execution failure is toggled on.\n     *   @param _depositNonce Identifier for nonce being executed.\n     *   @param _refundee address to refund gas to in case of fallback being triggered.\n     *   @param _calldata Calldata to be executed by the Root Bridge Agent Executor Contract.\n     *   @param _srcChainId Chain ID of source chain where request originates from.\n     */\n    function _execute(\n        bool _hasFallbackToggled,\n        uint32 _depositNonce,\n        address _refundee,\n        bytes memory _calldata,\n        uint16 _srcChainId\n    ) private {\n        //Update tx state as executed\n        executionState[_srcChainId][_depositNonce] = STATUS_DONE;\n\n        //Try to execute the remote request\n        (bool success,) = bridgeAgentExecutorAddress.call{value: address(this).balance}(_calldata);\n\n        //Update tx state if execution failed\n        if (!success) {\n            //Read the fallback flag.\n            if (_hasFallbackToggled) {\n                // Update tx state as retrieve only\n                executionState[_srcChainId][_depositNonce] = STATUS_RETRIEVE;\n                // Perform the fallback call\n                _performFallbackCall(payable(_refundee), _depositNonce, _srcChainId);\n            } else {\n                // No fallback is requested revert allowing for retry.\n                revert ExecutionFailure();\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    LAYER ZERO INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Internal function performs call to Layer Zero Endpoint Contract for cross-chain messaging.\n     *   @param _refundee address to refund excess gas to.\n     *   @param _dstChainId Layer Zero Chain ID of destination chain.\n     *   @param _payload Payload of message to be sent to Layer Zero Endpoint Contract.\n     *   @param _gParams Gas parameters for cross-chain message execution.\n     */\n\n    function _performCall(\n        uint16 _dstChainId,\n        address payable _refundee,\n        bytes memory _payload,\n        GasParams calldata _gParams\n    ) internal {\n        // Get destination Branch Bridge Agent\n        address callee = getBranchBridgeAgent[_dstChainId];\n\n        // Check if valid destination\n        if (callee == address(0)) revert UnrecognizedBridgeAgent();\n\n        // Check if call to remote chain\n        if (_dstChainId != localChainId) {\n            //Sends message to Layerzero Enpoint\n            ILayerZeroEndpoint(lzEndpointAddress).send{value: msg.value}(\n                _dstChainId,\n                getBranchBridgeAgentPath[_dstChainId],\n                _payload,\n                _refundee,\n                address(0),\n                abi.encodePacked(uint16(2), _gP"
    }
  ]
}