{
  "Title": "[L01] Lack of input validation",
  "Content": "The [`collect` function](https://github.com/graphprotocol/contracts/blob/01c891829d39e1d6adc30bf13a2c8bf64504f808/contracts/staking/Staking.sol#L948) of the `Staking` contract does not validate whether the `_tokens` parameter is non-zero.\n\n\nWhen the `_tokens` parameter is zero, the `collect` function can run without error, and emit its `AllocationCollected` event. This provides no useful feedback in the form of a revert message if the parameter was malformed by the client. Furthermore, the emission of the trivial `AllocationCollected` event may confuse off-chain services.\n\n\nIn the case that allowing `collect` to be called on zero `_tokens` was a design choice, consider properly documenting this in the code and other public-facing documentation. Otherwise, consider adding proper checks that the `_tokens` parameter is non-zero.\n\n\n**Update:** *Fixed in commit [`bd06a61e1055a5e0585e8ea64e618a8d6ce65d7c`](https://github.com/graphprotocol/contracts/pull/457/commits/bd06a61e1055a5e0585e8ea64e618a8d6ce65d7c) where the `collect` function now includes documentation describing that zero values of `_tokens` are allowed.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/staking/Staking.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.3;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/cryptography/ECDSA.sol\";\n\nimport \"../upgrades/GraphUpgradeable.sol\";\n\nimport \"./IStaking.sol\";\nimport \"./StakingStorage.sol\";\nimport \"./libs/MathUtils.sol\";\nimport \"./libs/Rebates.sol\";\nimport \"./libs/Stakes.sol\";\n\n/**\n * @title Staking contract\n */\ncontract Staking is StakingV2Storage, GraphUpgradeable, IStaking {\n    using SafeMath for uint256;\n    using Stakes for Stakes.Indexer;\n    using Rebates for Rebates.Pool;\n\n    // 100% in parts per million\n    uint32 private constant MAX_PPM = 1000000;\n\n    // -- Events --\n\n    /**\n     * @dev Emitted when `indexer` update the delegation parameters for its delegation pool.\n     */\n    event DelegationParametersUpdated(\n        address indexed indexer,\n        uint32 indexingRewardCut,\n        uint32 queryFeeCut,\n        uint32 cooldownBlocks\n    );\n\n    /**\n     * @dev Emitted when `indexer` stake `tokens` amount.\n     */\n    event StakeDeposited(address indexed indexer, uint256 tokens);\n\n    /**\n     * @dev Emitted when `indexer` unstaked and locked `tokens` amount `until` block.\n     */\n    event StakeLocked(address indexed indexer, uint256 tokens, uint256 until);\n\n    /**\n     * @dev Emitted when `indexer` withdrew `tokens` staked.\n     */\n    event StakeWithdrawn(address indexed indexer, uint256 tokens);\n\n    /**\n     * @dev Emitted when `indexer` was slashed for a total of `tokens` amount.\n     * Tracks `reward` amount of tokens given to `beneficiary`.\n     */\n    event StakeSlashed(\n        address indexed indexer,\n        uint256 tokens,\n        uint256 reward,\n        address beneficiary\n    );\n\n    /**\n     * @dev Emitted when `delegator` delegated `tokens` to the `indexer`, the delegator\n     * gets `shares` for the delegation pool proportionally to the tokens staked.\n     */\n    event StakeDelegated(\n        address indexed indexer,\n        address indexed delegator,\n        uint256 tokens,\n        uint256 shares\n    );\n\n    /**\n     * @dev Emitted when `delegator` undelegated `tokens` from `indexer`.\n     * Tokens get locked for withdrawal after a period of time.\n     */\n    event StakeDelegatedLocked(\n        address indexed indexer,\n        address indexed delegator,\n        uint256 tokens,\n        uint256 shares,\n        uint256 until\n    );\n\n    /**\n     * @dev Emitted when `delegator` withdrew delegated `tokens` from `indexer`.\n     */\n    event StakeDelegatedWithdrawn(\n        address indexed indexer,\n        address indexed delegator,\n        uint256 tokens\n    );\n\n    /**\n     * @dev Emitted when `indexer` allocated `tokens` amount to `subgraphDeploymentID`\n     * during `epoch`.\n     * `allocationID` indexer derived address used to identify the allocation.\n     * `metadata` additional information related to the allocation.\n     */\n    event AllocationCreated(\n        address indexed indexer,\n        bytes32 indexed subgraphDeploymentID,\n        uint256 epoch,\n        uint256 tokens,\n        address indexed allocationID,\n        bytes32 metadata\n    );\n\n    /**\n     * @dev Emitted when `indexer` collected `tokens` amount in `epoch` for `allocationID`.\n     * These funds are related to `subgraphDeploymentID`.\n     * The `from` value is the sender of the collected funds.\n     */\n    event AllocationCollected(\n        address indexed indexer,\n        bytes32 indexed subgraphDeploymentID,\n        uint256 epoch,\n        uint256 tokens,\n        address indexed allocationID,\n        address from,\n        uint256 curationFees,\n        uint256 rebateFees\n    );\n\n    /**\n     * @dev Emitted when `indexer` close an allocation in `epoch` for `allocationID`.\n     * An amount of `tokens` get unallocated from `subgraphDeploymentID`.\n     * The `effectiveAllocation` are the tokens allocated from creation to closing.\n     * This event also emits the POI (proof of indexing) submitted by the indexer.\n     * `isDelegator` is true if the sender was one of the indexer's delegators.\n     */\n    event AllocationClosed(\n        address indexed indexer,\n        bytes32 indexed subgraphDeploymentID,\n        uint256 epoch,\n        uint256 tokens,\n        address indexed allocationID,\n        uint256 effectiveAllocation,\n        address sender,\n        bytes32 poi,\n        bool isDelegator\n    );\n\n    /**\n     * @dev Emitted when `indexer` claimed a rebate on `subgraphDeploymentID` during `epoch`\n     * related to the `forEpoch` rebate pool.\n     * The rebate is for `tokens` amount and `unclaimedAllocationsCount` are left for claim\n     * in the rebate pool. `delegationFees` collected and sent to delegation pool.\n     */\n    event RebateClaimed(\n        address indexed indexer,\n        bytes32 indexed subgraphDeploymentID,\n        address indexed allocationID,\n        uint256 epoch,\n        uint256 forEpoch,\n        uint256 tokens,\n        uint256 unclaimedAllocationsCount,\n        uint256 delegationFees\n    );\n\n    /**\n     * @dev Emitted when `caller` set `slasher` address as `allowed` to slash stakes.\n     */\n    event SlasherUpdate(address indexed caller, address indexed slasher, bool allowed);\n\n    /**\n     * @dev Emitted when `caller` set `assetHolder` address as `allowed` to send funds\n     * to staking contract.\n     */\n    event AssetHolderUpdate(address indexed caller, address indexed assetHolder, bool allowed);\n\n    /**\n     * @dev Emitted when `indexer` set `operator` access.\n     */\n    event SetOperator(address indexed indexer, address indexed operator, bool allowed);\n\n    /**\n     * @dev Emitted when `indexer` set an address to receive rewards.\n     */\n    event SetRewardsDestination(address indexed indexer, address indexed destination);\n\n    /**\n     * @dev Check if the caller is the slasher.\n     */\n    modifier onlySlasher {\n        require(slashers[msg.sender] == true, \"!slasher\");\n        _;\n    }\n\n    /**\n     * @dev Check if the caller is authorized (indexer or operator)\n     */\n    function _isAuth(address _indexer) private view returns (bool) {\n        return msg.sender == _indexer || isOperator(msg.sender, _indexer) == true;\n    }\n\n    /**\n     * @dev Initialize this contract.\n     */\n    function initialize(\n        address _controller,\n        uint256 _minimumIndexerStake,\n        uint32 _thawingPeriod,\n        uint32 _protocolPercentage,\n        uint32 _curationPercentage,\n        uint32 _channelDisputeEpochs,\n        uint32 _maxAllocationEpochs,\n        uint32 _delegationUnbondingPeriod,\n        uint32 _delegationRatio,\n        uint32 _rebateAlphaNumerator,\n        uint32 _rebateAlphaDenominator\n    ) external onlyImpl {\n        Managed._initialize(_controller);\n\n        // Settings\n        _setMinimumIndexerStake(_minimumIndexerStake);\n        _setThawingPeriod(_thawingPeriod);\n\n        _setProtocolPercentage(_protocolPercentage);\n        _setCurationPercentage(_curationPercentage);\n\n        _setChannelDisputeEpochs(_channelDisputeEpochs);\n        _setMaxAllocationEpochs(_maxAllocationEpochs);\n\n        _setDelegationUnbondingPeriod(_delegationUnbondingPeriod);\n        _setDelegationRatio(_delegationRatio);\n        _setDelegationParametersCooldown(0);\n        _setDelegationTaxPercentage(0);\n\n        _setRebateRatio(_rebateAlphaNumerator, _rebateAlphaDenominator);\n    }\n\n    /**\n     * @dev Set the minimum indexer stake required to.\n     * @param _minimumIndexerStake Minimum indexer stake\n     */\n    function setMinimumIndexerStake(uint256 _minimumIndexerStake) external override onlyGovernor {\n        _setMinimumIndexerStake(_minimumIndexerStake);\n    }\n\n    /**\n     * @dev Internal: Set the minimum indexer stake required.\n     * @param _minimumIndexerStake Minimum indexer stake\n     */\n    function _setMinimumIndexerStake(uint256 _minimumIndexerStake) private {\n        require(_minimumIndexerStake > 0, \"!minimumIndexerStake\");\n        minimumIndexerStake = _minimumIndexerStake;\n        emit ParameterUpdated(\"minimumIndexerStake\");\n    }\n\n    /**\n     * @dev Set the thawing period for unstaking.\n     * @param _thawingPeriod Period in blocks to wait for token withdrawals after unstaking\n     */\n    function setThawingPeriod(uint32 _thawingPeriod) external override onlyGovernor {\n        _setThawingPeriod(_thawingPeriod);\n    }\n\n    /**\n     * @dev Internal: Set the thawing period for unstaking.\n     * @param _thawingPeriod Period in blocks to wait for token withdrawals after unstaking\n     */\n    function _setThawingPeriod(uint32 _thawingPeriod) private {\n        require(_thawingPeriod > 0, \"!thawingPeriod\");\n        thawingPeriod = _thawingPeriod;\n        emit ParameterUpdated(\"thawingPeriod\");\n    }\n\n    /**\n     * @dev Set the curation percentage of query fees sent to curators.\n     * @param _percentage Percentage of query fees sent to curators\n     */\n    function setCurationPercentage(uint32 _percentage) external override onlyGovernor {\n        _setCurationPercentage(_percentage);\n    }\n\n    /**\n     * @dev Internal: Set the curation percentage of query fees sent to curators.\n     * @param _percentage Percentage of query fees sent to curators\n     */\n    function _setCurationPercentage(uint32 _percentage) private {\n        // Must be within 0% to 100% (inclusive)\n        require(_percentage <= MAX_PPM, \">percentage\");\n        curationPercentage = _percentage;\n        emit ParameterUpdated(\"curationPercentage\");\n    }\n\n    /**\n     * @dev Set a protocol percentage to burn when collecting query fees.\n     * @param _percentage Percentage of query fees to burn as protocol fee\n     */\n    function setProtocolPercentage(uint32 _percentage) external override onlyGovernor {\n        _setProtocolPercentage(_percentage);\n    }\n\n    /**\n     * @dev Internal: Set a protocol percentage to burn when collecting query fees.\n     * @param _percentage Percentage of query fees to burn as protocol fee\n     */\n    function _setProtocolPercentage(uint32 _percentage) private {\n        // Must be within 0% to 100% (inclusive)\n        require(_percentage <= MAX_PPM, \">percentage\");\n        protocolPercentage = _percentage;\n        emit ParameterUpdated(\"protocolPercentage\");\n    }\n\n    /**\n     * @dev Set the period in epochs that need to pass before fees in rebate pool can be claimed.\n     * @param _channelDisputeEpochs Period in epochs\n     */\n    function setChannelDisputeEpochs(uint32 _channelDisputeEpochs) external override onlyGovernor {\n        _setChannelDisputeEpochs(_channelDisputeEpochs);\n    }\n\n    /**\n     * @dev Internal: Set the period in epochs that need to pass before fees in rebate pool can be claimed.\n     * @param _channelDisputeEpochs Period in epochs\n     */\n    function _setChannelDisputeEpochs(uint32 _channelDisputeEpochs) private {\n        require(_channelDisputeEpochs > 0, \"!channelDisputeEpochs\");\n        channelDisputeEpochs = _channelDisputeEpochs;\n        emit ParameterUpdated(\"channelDisputeEpochs\");\n    }\n\n    /**\n     * @dev Set the max time allowed for indexers stake on allocations.\n     * @param _maxAllocationEpochs Allocation duration limit in epochs\n     */\n    function setMaxAllocationEpochs(uint32 _maxAllocationEpochs) external override onlyGovernor {\n        _setMaxAllocationEpochs(_maxAllocationEpochs);\n    }\n\n    /**\n     * @dev Internal: Set the max time allowed for indexers stake on allocations.\n     * @param _maxAllocationEpochs Allocation duration limit in epochs\n     */\n    function _setMaxAllocationEpochs(uint32 _maxAllocationEpochs) private {\n        maxAllocationEpochs = _maxAllocationEpochs;\n        emit ParameterUpdated(\"maxAllocationEpochs\");\n    }\n\n    /**\n     * @dev Set the rebate ratio (fees to allocated stake).\n     * @param _alphaNumerator Numerator of `alpha` in the cobb-douglas function\n     * @param _alphaDenominator Denominator of `alpha` in the cobb-douglas function\n     */\n    function setRebateRatio(uint32 _alphaNumerator, uint32 _alphaDenominator)\n        external\n        override\n        onlyGovernor\n    {\n        _setRebateRatio(_alphaNumerator, _alphaDenominator);\n    }\n\n    /**\n     * @dev Set the rebate ratio (fees to allocated stake).\n     * @param _alphaNumerator Numerator of `alpha` in the cobb-douglas function\n     * @param _alphaDenominator Denominator of `alpha` in the cobb-douglas function\n     */\n    function _setRebateRatio(uint32 _alphaNumerator, uint32 _alphaDenominator) private {\n        require(_alphaNumerator > 0 && _alphaDenominator > 0, \"!alpha\");\n        alphaNumerator = _alphaNumerator;\n        alphaDenominator = _alphaDenominator;\n        emit ParameterUpdated(\"rebateRatio\");\n    }\n\n    /**\n     * @dev Set the delegation ratio.\n     * If set to 10 it means the indexer can use up to 10x the indexer staked amount\n     * from their delegated tokens\n     * @param _delegationRatio Delegation capacity multiplier\n     */\n    function setDelegationRatio(uint32 _delegationRatio) external override onlyGovernor {\n        _setDelegationRatio(_delegationRatio);\n    }\n\n    /**\n     * @dev Internal: Set the delegation ratio.\n     * If set to 10 it means the indexer can use up to 10x the indexer staked amount\n     * from their delegated tokens\n     * @param _delegationRatio Delegation capacity multiplier\n     */\n    function _setDelegationRatio(uint32 _delegationRatio) private {\n        delegationRatio = _delegationRatio;\n        emit ParameterUpdated(\"delegationRatio\");\n    }\n\n    /**\n     * @dev Set the delegation parameters.\n     * @param _indexingRewardCut Percentage of indexing rewards left for delegators\n     * @param _queryFeeCut Percentage of query fees left for delegators\n     * @param _cooldownBlocks Period that need to pass to update delegation parameters\n     */\n    function setDelegationParameters(\n        uint32 _indexingRewardCut,\n        uint32 _queryFeeCut,\n        uint32 _cooldownBlocks\n    ) public override {\n        _setDelegationParameters(msg.sender, _indexingRewardCut, _queryFeeCut, _cooldownBlocks);\n    }\n\n    /**\n     * @dev Set the delegation parameters.\n     * @param _indexingRewardCut Percentage of indexing rewards left for delegators\n     * @param _queryFeeCut Percentage of query fees left for delegators\n     * @param _cooldownBlocks Period that need to pass to update delegation parameters\n     */\n    function _setDelegationParameters(\n        address _indexer,\n        uint32 _indexingRewardCut,\n        uint32 _queryFeeCut,\n        uint32 _cooldownBlocks\n    ) private {\n        // Incentives must be within bounds\n        require(_queryFeeCut <= MAX_PPM, \">queryFeeCut\");\n        require(_indexingRewardCut <= MAX_PPM, \">indexingRewardCut\");\n\n        // Cooldown period set by indexer cannot be below protocol global setting\n        require(_cooldownBlocks >= delegationParametersCooldown, \"<cooldown\");\n\n        // Verify the cooldown period passed\n        DelegationPool storage pool = delegationPools[_indexer];\n        require(\n            pool.updatedAtBlock == 0 ||\n                pool.updatedAtBlock.add(uint256(pool.cooldownBlocks)) <= block.number,\n            \"!cooldown\"\n        );\n\n        // Update delegation params\n        pool.indexingRewardCut = _indexingRewardCut;\n        pool.queryFeeCut = _queryFeeCut;\n        pool.cooldownBlocks = _cooldownBlocks;\n        pool.updatedAtBlock = block.number;\n\n        emit DelegationParametersUpdated(\n            _indexer,\n            _indexingRewardCut,\n            _queryFeeCut,\n            _cooldownBlocks\n        );\n    }\n\n    /**\n     * @dev Set the time in blocks an indexer needs to wait to change delegation parameters.\n     * @param _blocks Number of blocks to set the delegation parameters cooldown period\n     */\n    function setDelegationParametersCooldown(uint32 _blocks) external override onlyGovernor {\n        _setDelegationParametersCooldown(_blocks);\n    }\n\n    /**\n     * @dev Internal: Set the time in blocks an indexer needs to wait to change delegation parameters.\n     * @param _blocks Number of blocks to set the delegation parameters cooldown period\n     */\n    function _setDelegationParametersCooldown(uint32 _blocks) private {\n        delegationParametersCooldown = _blocks;\n        emit ParameterUpdated(\"delegationParametersCooldown\");\n    }\n\n    /**\n     * @dev Set the period for undelegation of stake from indexer.\n     * @param _delegationUnbondingPeriod Period in epochs to wait for token withdrawals after undelegating\n     */\n    function setDelegationUnbondingPeriod(uint32 _delegationUnbondingPeriod)\n        external\n        override\n        onlyGovernor\n    {\n        _setDelegationUnbondingPeriod(_delegationUnbondingPeriod);\n    }\n\n    /**\n     * @dev Internal: Set the period for undelegation of stake from indexer.\n     * @param _delegationUnbondingPeriod Period in epochs to wait for token withdrawals after undelegating\n     */\n    function _setDelegationUnbondingPeriod(uint32 _delegationUnbondingPeriod) private {\n        require(_delegationUnbondingPeriod > 0, \"!delegationUnbondingPeriod\");\n        delegationUnbondingPeriod = _delegationUnbondingPeriod;\n        emit ParameterUpdated(\"delegationUnbondingPeriod\");\n    }\n\n    /**\n     * @dev Set a delegation tax percentage to burn when delegated funds are deposited.\n     * @param _percentage Percentage of delegated tokens to burn as delegation tax\n     */\n    function setDelegationTaxPercentage(uint32 _percentage) external override onlyGovernor {\n        _setDelegationTaxPercentage(_percentage);\n    }\n\n    /**\n     * @dev Internal: Set a delegation tax percentage to burn when delegated funds are deposited.\n     * @param _percentage Percentage of delegated tokens to burn as delegation tax\n     */\n    function _setDelegationTaxPercentage(uint32 _percentage) private {\n        // Must be within 0% to 100% (inclusive)\n        require(_percentage <= MAX_PPM, \">percentage\");\n        delegationTaxPercentage = _percentage;\n        emit ParameterUpdated(\"delegationTaxPercentage\");\n    }\n\n    /**\n     * @dev Set or unset an address as allowed slasher.\n     * @param _slasher Address of the party allowed to slash indexers\n     * @param _allowed True if slasher is allowed\n     */\n    function setSlasher(address _slasher, bool _allowed) external override onlyGovernor {\n        require(_slasher != address(0), \"!slasher\");\n        slashers[_slasher] = _allowed;\n        emit SlasherUpdate(msg.sender, _slasher, _allowed);\n    }\n\n    /**\n     * @dev Set an address as allowed asset holder.\n     * @param _assetHolder Address of allowed source for state channel funds\n     * @param _allowed True if asset holder is allowed\n     */\n    function setAssetHolder(address _assetHolder, bool _allowed) external override onlyGovernor {\n        require(_assetHolder != address(0), \"!assetHolder\");\n        assetHolders[_assetHolder] = _allowed;\n        emit AssetHolderUpdate(msg.sender, _assetHolder, _allowed);\n    }\n\n    /**\n     * @dev Return if allocationID is used.\n     * @param _allocationID Address used as signer by the indexer for an allocation\n     * @return True if allocationID already used\n     */\n    function isAllocation(address _allocationID) external view override returns (bool) {\n        return _getAllocationState(_allocationID) != AllocationState.Null;\n    }\n\n    /**\n     * @dev Getter that returns if an indexer has any stake.\n     * @param _indexer Address of the indexer\n     * @return True if indexer has staked tokens\n     */\n    function hasStake(address _indexer) external view override returns (bool) {\n        return stakes[_indexer].tokensStaked > 0;\n    }\n\n    /**\n     * @dev Return the allocation by ID.\n     * @param _allocationID Address used as allocation identifier\n     * @return Allocation data\n     */\n    function getAllocation(address _allocationID)\n        external\n        view\n        override\n        returns (Allocation memory)\n    {\n        return allocations[_allocationID];\n    }\n\n    /**\n     * @dev Return the current state of an allocation.\n     * @param _allocationID Address used as the allocation identifier\n     * @return AllocationState\n     */\n    function getAllocationState(address _allocationID)\n        external\n        view\n        override\n        returns (AllocationState)\n    {\n        return _getAllocationState(_allocationID);\n    }\n\n    /**\n     * @dev Return the total amount of tokens allocated to subgraph.\n     * @param _subgraphDeploymentID Address used as the allocation identifier\n     * @return Total tokens allocated to subgraph\n     */\n    function getSubgraphAllocatedTokens(bytes32 _subgraphDeploymentID)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return subgraphAllocations[_subgraphDeploymentID];\n    }\n\n    /**\n     * @dev Return the delegation from a delegator to an indexer.\n     * @param _indexer Address of the indexer where funds have been delegated\n     * @param _delegator Address of the delegator\n     * @return Delegation data\n     */\n    function getDelegation(address _indexer, address _delegator)\n        external\n        view\n        override\n        returns (Delegation memory)\n    {\n        return delegationPools[_indexer].delegators[_delegator];\n    }\n\n    /**\n     * @dev Return whether the delegator has delegated to the indexer.\n     * @param _indexer Address of the indexer where funds have been delegated\n     * @param _delegator Address of the delegator\n     * @return True if delegator of indexer\n     */\n    function isDelegator(address _indexer, address _delegator) public view override returns (bool) {\n        return delegationPools[_indexer].delegators[_delegator].shares > 0;\n    }\n\n    /**\n     * @dev Get the total amount of tokens staked by the indexer.\n     * @param _indexer Address of the indexer\n     * @return Amount of tokens staked by the indexer\n     */\n    function getIndexerStakedTokens(address _indexer) external view override returns (uint256) {\n        return stakes[_indexer].tokensStaked;\n    }\n\n    /**\n     * @dev Get the total amount of tokens available to use in allocations.\n     * This considers the indexer stake and delegated tokens according to delegation ratio\n     * @param _indexer Address of the indexer\n     * @return Amount of tokens staked by the indexer\n     */\n    function getIndexerCapacity(address _indexer) public view override returns (uint256) {\n        Stakes.Indexer memory indexerStake = stakes[_indexer];\n        uint256 tokensDelegated = delegationPools[_indexer].tokens;\n\n        uint256 tokensDelegatedCap = indexerStake.tokensSecureStake().mul(uint256(delegationRatio));\n        uint256 tokensDelegatedCapacity = MathUtils.min(tokensDelegated, tokensDelegatedCap);\n\n        return indexerStake.tokensAvailableWithDelegation(tokensDelegatedCapacity);\n    }\n\n    /**\n     * @dev Returns amount of delegated tokens ready to be withdrawn after unbonding period.\n     * @param _delegation Delegation of tokens from delegator to indexer\n     * @return Amount of tokens to withdraw\n     */\n    function getWithdraweableDelegatedTokens(Delegation memory _delegation)\n        public\n        view\n        returns (uint256)\n    {\n        // There must be locked tokens and period passed\n        uint256 currentEpoch = epochManager().currentEpoch();\n        if (_delegation.tokensLockedUntil > 0 && currentEpoch >= _delegation.tokensLockedUntil) {\n            return _delegation.tokensLocked;\n        }\n        return 0;\n    }\n\n    /**\n     * @dev Authorize or unauthorize an address to be an operator.\n     * @param _operator Address to authorize\n     * @param _allowed Whether authorized or not\n     */\n    function setOperator(address _operator, bool _allowed) external override {\n        require(_operator != msg.sender, \"operator == sender\");\n        operatorAuth[msg.sender][_operator] = _allowed;\n        emit SetOperator(msg.sender, _operator, _allowed);\n    }\n\n    /**\n     * @dev Return true if operator is allowed for indexer.\n     * @param _operator Address of the operator\n     * @param _indexer Address of the indexer\n     */\n    function isOperator(address _operator, address _indexer) public view override returns (bool) {\n        return operatorAuth[_indexer][_operator];\n    }\n\n    /**\n     * @dev Deposit tokens on the indexer stake.\n     * @param _tokens Amount of tokens to stake\n     */\n    function stake(uint256 _tokens) external override {\n        stakeTo(msg.sender, _tokens);\n    }\n\n    /**\n     * @dev Deposit tokens on the indexer stake.\n     * @param _indexer Address of the indexer\n     * @param _tokens Amount of tokens to stake\n     */\n    function stakeTo(address _indexer, uint256 _tokens) public override notPartialPaused {\n        require(_tokens > 0, \"!tokens\");\n\n        // Ensure minimum stake\n        require(\n            stakes[_indexer].tokensSecureStake().add(_tokens) >= minimumIndexerStake,\n            \"!minimumIndexerStake\"\n        );\n\n        // Transfer tokens to stake from caller to this contract\n        _pullTokens(graphToken(), msg.sender, _tokens);\n\n        // Stake the transferred tokens\n        _stake(_indexer, _tokens);\n    }\n\n    /**\n     * @dev Unstake tokens from the indexer stake, lock them until thawing period expires.\n     * @param _tokens Amount of tokens to unstake\n     */\n    function unstake(uint256 _tokens) external override notPartialPaused {\n        address indexer = msg.sender;\n        Stakes.Indexer storage indexerStake = stakes[indexer];\n\n        require(_tokens > 0, \"!tokens\");\n        require(indexerStake.tokensStaked > 0, \"!stake\");\n        require(indexerStake.tokensAvailable() >= _tokens, \"!stake-avail\");\n\n        // Ensure minimum stake\n        uint256 newStake = indexerStake.tokensSecureStake().sub(_tokens);\n        require(newStake == 0 || newStake >= minimumIndexerStake, \"!minimumIndexerStake\");\n\n        // Before locking more tokens, withdraw any unlocked ones\n        uint256 tokensToWithdraw = indexerStake.tokensWithdrawable();\n        if (tokensToWithdraw > 0) {\n            _withdraw(indexer);\n        }\n\n        indexerStake.lockTokens(_tokens, thawingPeriod);\n\n        emit StakeLocked(indexer, indexerStake.tokensLocked, indexerStake.tokensLockedUntil);\n    }\n\n    /**\n     * @dev Withdraw indexer tokens once the thawing period has passed.\n     */\n    function withdraw() external override notPaused {\n        _withdraw(msg.sender);\n    }\n\n    /**\n     * @dev Set the destination where to send rewards.\n     * @param _destination Rewards destination address. If set to zero, rewards will be restaked\n     */\n    function setRewardsDestination(address _destination) external override {\n        rewardsDestination[msg.sender] = _destination;\n        emit SetRewardsDestination(msg.sender, _destination);\n    }\n\n    /**\n     * @dev Slash the indexer stake. Delegated tokens are not subject to slashing.\n     * Can only be called by the slasher role.\n     * @param _indexer Address of indexer to slash\n     * @param _tokens Amount of tokens to slash from the indexer stake\n     * @param _reward Amount of reward tokens to send to a beneficiary\n     * @param _beneficiary Address of a beneficiary to receive a reward for the slashing\n     */\n    function slash(\n        address _indexer,\n        uint256 _tokens,\n        uint256 _reward,\n        address _beneficiary\n    ) external override onlySlasher notPartialPaused {\n        Stakes.Indexer storage indexerStake = stakes[_indexer];\n\n        // Only able to slash a non-zero number of tokens\n        require(_tokens > 0, \"!tokens\");\n\n        // Rewards comes from tokens slashed balance\n        require(_tokens >= _reward, \"rewards>slash\");\n\n        // Cannot slash stake of an indexer without any or enough stake\n        require(indexerStake.tokensStaked > 0, \"!stake\");\n        require(_tokens <= indexerStake.tokensStaked, \"slash>stake\");\n\n        // Validate beneficiary of slashed tokens\n        require(_beneficiary != address(0), \"!beneficiary\");\n\n        // Slashing more tokens than freely available (over allocation condition)\n        // Unlock locked tokens to avoid the indexer to withdraw them\n        if (_tokens > indexerStake.tokensAvailable() && indexerStake.tokensLocked > 0) {\n            uint256 tokensOverAllocated = _tokens.sub(indexerStake.tokensAvailable());\n            uint256 tokensToUnlock = MathUtils.min(tokensOverAllocated, indexerStake.tokensLocked);\n            indexerStake.unlockTokens(tokensToUnlock);\n        }\n\n        // Remove tokens to slash from the stake\n        indexerStake.release(_tokens);\n\n        // -- Interactions --\n\n        IGraphToken graphToken = graphToken();\n\n        // Set apart the reward for the beneficiary and burn remaining slashed stake\n        _burnTokens(graphToken, _tokens.sub(_reward));\n\n        // Give the beneficiary a reward for slashing\n        _pushTokens(graphToken, _beneficiary, _reward);\n\n        emit StakeSlashed(_indexer, _tokens, _reward, _beneficiary);\n    }\n\n    /**\n     * @dev Delegate tokens to an indexer.\n     * @param _indexer Address of the indexer to delegate tokens to\n     * @param _tokens Amount of tokens to delegate\n     * @return Amount of shares issued of the delegation pool\n     */\n    function delegate(address _indexer, uint256 _tokens)\n        external\n        override\n        notPartialPaused\n        returns (uint256)\n    {\n        address delegator = msg.sender;\n\n        // Transfer tokens to delegate to this contract\n        _pullTokens(graphToken(), delegator, _tokens);\n\n        // Update state\n        return _delegate(delegator, _indexer, _tokens);\n    }\n\n    /**\n     * @dev Undelegate tokens from an indexer.\n     * @param _indexer Address of the indexer where tokens had been delegated\n     * @param _shares Amount of shares to return and undelegate tokens\n     * @return Amount of tokens returned for the shares of the delegation pool\n     */\n    function undelegate(address _indexer, uint256 _shares)\n        external\n        override\n        notPartialPaused\n        returns (uint256)\n    {\n        return _undelegate(msg.sender, _indexer, _shares);\n    }\n\n    /**\n     * @dev Withdraw delegated tokens once the unbonding period has passed.\n     * @param _indexer Withdraw available tokens delegated to indexer\n     * @param _delegateToIndexer Re-delegate to indexer address if non-zero, withdraw if zero address\n     */\n    function withdrawDelegated(address _indexer, address _delegateToIndexer)\n        external\n        override\n        notPaused\n        returns (uint256)\n    {\n        return _withdrawDelegated(msg.sender, _indexer, _delegateToIndexer);\n    }\n\n    /**\n     * @dev Allocate available tokens to a subgraph deployment.\n     * @param _subgraphDeploymentID ID of the SubgraphDeployment where tokens will be allocated\n     * @param _tokens Amount of tokens to allocate\n     * @param _allocationID The allocation identifier\n     * @param _metadata IPFS hash for additional information about the allocation\n     * @param _proof A 65-bytes Ethereum signed message of `keccak256(indexerAddress,allocationID)`\n     */\n    function allocate(\n        bytes32 _subgraphDeploymentID,\n        uint256 _tokens,\n        address _allocationID,\n        bytes32 _metadata,\n        bytes calldata _proof\n    ) external override notPaused {\n        _allocate(msg.sender, _subgraphDeploymentID, _tokens, _allocationID, _metadata, _proof);\n    }\n\n    /**\n     * @dev Allocate available tokens to a subgraph deployment.\n     * @param _indexer Indexer address to allocate funds from.\n     * @param _subgraphDeploymentID ID of the SubgraphDeployment where tokens will be allocated\n     * @param _tokens Amount of tokens to allocate\n     * @param _allocationID The allocation identifier\n     * @param _metadata IPFS hash for additional information about the allocation\n     * @param _proof A 65-bytes Ethereum signed message of `keccak256(indexerAddress,allocationID)`\n     */\n    function allocateFrom(\n        address _indexer,\n        bytes32 _subgraphDeploymentID,\n        uint256 _tokens,\n        address _allocationID,\n        bytes32 _metadata,\n        bytes calldata _proof\n    ) external override notPaused {\n        _allocate(_indexer, _subgraphDeploymentID, _tokens, _allocationID, _metadata, _proof);\n    }\n\n    /**\n     * @dev Close an allocation and free the staked tokens.\n     * To be eligible for rewards a proof of indexing must be presented.\n     * Presenting a bad proof is subject to slashable condition.\n     * To opt out for rewards set _poi to 0x0\n     * @param _allocationID The allocation identifier\n     * @param _poi Proof of indexing submitted for the allocated period\n     */\n    function closeAllocation(address _allocationID, bytes32 _poi) external override notPaused {\n        _closeAllocation(_allocationID, _poi);\n    }\n\n    /**\n     * @dev Close multiple allocations and free the staked tokens.\n     * To be eligible f"
    }
  ]
}