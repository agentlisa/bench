{
  "Title": "[H-02] `_aggregateValidFulfillmentOfferItems()` can be tricked to accept invalid inputs",
  "Content": "\n[FulfillmentApplier.sol#L406](https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/FulfillmentApplier.sol#L406)<br>\n\nThe `_aggregateValidFulfillmentOfferItems()` function aims to revert on orders with zero value or where a total consideration amount overflows. Internally this is accomplished by having a temporary variable `errorBuffer`, accumulating issues found, and only reverting once all the items are processed in case there was a problem found. This code is optimistic for valid inputs.\n\nNote: there is a similar issue in `_aggregateValidFulfillmentConsiderationItems()`, which is reported separately.\n\nThe problem lies in how this `errorBuffer` is updated:\n\n```solidity\n                // Update error buffer (1 = zero amount, 2 = overflow).\n                errorBuffer := or(\n                  errorBuffer,\n                  or(\n                    shl(1, lt(newAmount, amount)),\n                    iszero(mload(amountPtr))\n                  )\n                )\n```\n\nThe final error handling code:\n\n```solidity\n            // Determine if an error code is contained in the error buffer.\n            switch errorBuffer\n            case 1 {\n                // Store the MissingItemAmount error signature.\n                mstore(0, MissingItemAmount_error_signature)\n\n                // Return, supplying MissingItemAmount signature.\n                revert(0, MissingItemAmount_error_len)\n            }\n            case 2 {\n                // If the sum overflowed, panic.\n                throwOverflow()\n            }\n```\n\nWhile the expected value is `0` (success),  `1` or `2` (failure), it is possible to set it to `3`, which is unhandled and considered as a \"success\". This can be easily accomplished by having both an overflowing item and a zero item in the order list.\n\nThis validation error could lead to fulfilling an order with a consideration (potentially \\~0) lower than expected.\n\n### Proof of Concept\n\nCraft an offer containing two errors (e.g. with  zero amount and overflow).<br>\nCall `matchOrders()`. Via calls to `_matchAdvancedOrders()`, `_fulfillAdvancedOrders()`, `_applyFulfillment()`, `_aggregateValidFulfillmentOfferItems()` will be called.<br>\nThe `errorBuffer` will get a value of 3  (the `or` of 1 and 2).<br>\nAs the value of 3 is not detected, no error will be thrown and the order will be executed, including the mal formed values.\n\n### Recommended Mitigation Steps\n\n1.  Change the check on [FulfillmentApplier.sol#L465](https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/FulfillmentApplier.sol#L465)  to consider `case 3`.\n2.  Potential option: Introduce an early abort in case `errorBuffer != 0` on [FulfillmentApplier.sol#L338](https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/FulfillmentApplier.sol#L338)\n\n**[0age (OpenSea) confirmed](https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/75)**\n\n**[HardlyDifficult (judge) decreased severity to Medium](https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/75)**\n\n**[cmichel (warden) commented](https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/75#issuecomment-1172848110):**\n > > This validation error could lead to fulfilling an order with a consideration (potentially ~0) lower than expected.\n> \n> That's correct, you can use this to fulfill an order essentially for free, that's why I'd consider this high severity.\n> They could have done a better job demonstrating it with a POC test case but this sentence imo shows that they were aware of the impact.\n> \n> See [this test case](https://github.com/ProjectOpenSea/seaport/blob/5c6a628cb152d731e956682dd748d30e8bf1f1c9/test/findings/FulfillmentOverflowWithMissingItems.spec.ts#L136) showing how to buy an NFT for 1 DAI instead of 1000 DAI.\n\n**0age (OpenSea) disagreed with Medium severity:**\n > This is the highest-severity finding. If it were me, I'd switch this to high.\n\n**[HardlyDifficult (judge) increased severity to High](https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/75)**\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/75#issuecomment-1183115107):**\n > After further consideration and discussion with @HardlyDifficult, we agree with @cmichel that this should be of high severity. As the protocol allows for invalid orders to be created, users aware of this vulnerability will be able to fulfill an order at a considerable discount. This fits the criteria of a high severity issue as it directly leads to lost funds.\n\n**[0age (OpenSea) resolved](https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/75):**\n > PR: [ProjectOpenSea/seaport#320](https://github.com/ProjectOpenSea/seaport/pull/320)\n\n\n\n***\n\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-05-opensea-seaport-contest",
  "Code": [
    {
      "filename": "contracts/lib/FulfillmentApplier.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport { ItemType, Side } from \"./ConsiderationEnums.sol\";\n\n// prettier-ignore\nimport {\n    OfferItem,\n    ConsiderationItem,\n    ReceivedItem,\n    OrderParameters,\n    AdvancedOrder,\n    Execution,\n    FulfillmentComponent\n} from \"./ConsiderationStructs.sol\";\n\nimport \"./ConsiderationConstants.sol\";\n\n// prettier-ignore\nimport {\n    FulfillmentApplicationErrors\n} from \"../interfaces/FulfillmentApplicationErrors.sol\";\n\n/**\n * @title FulfillmentApplier\n * @author 0age\n * @notice FulfillmentApplier contains logic related to applying fulfillments,\n *         both as part of order matching (where offer items are matched to\n *         consideration items) as well as fulfilling available orders (where\n *         order items and consideration items are independently aggregated).\n */\ncontract FulfillmentApplier is FulfillmentApplicationErrors {\n    /**\n     * @dev Internal view function to match offer items to consideration items\n     *      on a group of orders via a supplied fulfillment.\n     *\n     * @param advancedOrders          The orders to match.\n     * @param offerComponents         An array designating offer components to\n     *                                match to consideration components.\n     * @param considerationComponents An array designating consideration\n     *                                components to match to offer components.\n     *                                Note that each consideration amount must\n     *                                be zero in order for the match operation\n     *                                to be valid.\n     *\n     * @return execution The transfer performed as a result of the fulfillment.\n     */\n    function _applyFulfillment(\n        AdvancedOrder[] memory advancedOrders,\n        FulfillmentComponent[] calldata offerComponents,\n        FulfillmentComponent[] calldata considerationComponents\n    ) internal view returns (Execution memory execution) {\n        // Ensure 1+ of both offer and consideration components are supplied.\n        if (\n            offerComponents.length == 0 || considerationComponents.length == 0\n        ) {\n            revert OfferAndConsiderationRequiredOnFulfillment();\n        }\n\n        // Declare a new Execution struct.\n        Execution memory considerationExecution;\n\n        // Validate & aggregate consideration items to new Execution object.\n        _aggregateValidFulfillmentConsiderationItems(\n            advancedOrders,\n            considerationComponents,\n            considerationExecution\n        );\n\n        // Retrieve the consideration item from the execution struct.\n        ReceivedItem memory considerationItem = considerationExecution.item;\n\n        // Validate & aggregate offer items to Execution object.\n        _aggregateValidFulfillmentOfferItems(\n            advancedOrders,\n            offerComponents,\n            execution\n        );\n\n        // Ensure offer and consideration share types, tokens and identifiers.\n        if (\n            execution.item.itemType != considerationItem.itemType ||\n            execution.item.token != considerationItem.token ||\n            execution.item.identifier != considerationItem.identifier\n        ) {\n            revert MismatchedFulfillmentOfferAndConsiderationComponents();\n        }\n\n        // If total consideration amount exceeds the offer amount...\n        if (considerationItem.amount > execution.item.amount) {\n            // Retrieve the first consideration component from the fulfillment.\n            FulfillmentComponent memory targetComponent = (\n                considerationComponents[0]\n            );\n\n            // Add excess consideration item amount to original array of orders.\n            advancedOrders[targetComponent.orderIndex]\n                .parameters\n                .consideration[targetComponent.itemIndex]\n                .startAmount = considerationItem.amount - execution.item.amount;\n\n            // Reduce total consideration amount to equal the offer amount.\n            considerationItem.amount = execution.item.amount;\n        } else {\n            // Retrieve the first offer component from the fulfillment.\n            FulfillmentComponent memory targetComponent = (offerComponents[0]);\n\n            // Add excess offer item amount to the original array of orders.\n            advancedOrders[targetComponent.orderIndex]\n                .parameters\n                .offer[targetComponent.itemIndex]\n                .startAmount = execution.item.amount - considerationItem.amount;\n        }\n\n        // Reuse execution struct with consideration amount and recipient.\n        execution.item.amount = considerationItem.amount;\n        execution.item.recipient = considerationItem.recipient;\n\n        // Return the final execution that will be triggered for relevant items.\n        return execution; // Execution(considerationItem, offerer, conduitKey);\n    }\n\n    /**\n     * @dev Internal view function to aggregate offer or consideration items\n     *      from a group of orders into a single execution via a supplied array\n     *      of fulfillment components. Items that are not available to aggregate\n     *      will not be included in the aggregated execution.\n     *\n     * @param advancedOrders        The orders to aggregate.\n     * @param side                  The side (i.e. offer or consideration).\n     * @param fulfillmentComponents An array designating item components to\n     *                              aggregate if part of an available order.\n     * @param fulfillerConduitKey   A bytes32 value indicating what conduit, if\n     *                              any, to source the fulfiller's token\n     *                              approvals from. The zero hash signifies that\n     *                              no conduit should be used, with approvals\n     *                              set directly on this contract.\n     *\n     * @return execution The transfer performed as a result of the fulfillment.\n     */\n    function _aggregateAvailable(\n        AdvancedOrder[] memory advancedOrders,\n        Side side,\n        FulfillmentComponent[] memory fulfillmentComponents,\n        bytes32 fulfillerConduitKey\n    ) internal view returns (Execution memory execution) {\n        // Skip overflow / underflow checks; conditions checked or unreachable.\n        unchecked {\n            // Retrieve fulfillment components array length and place on stack.\n            // Ensure at least one fulfillment component has been supplied.\n            if (fulfillmentComponents.length == 0) {\n                revert MissingFulfillmentComponentOnAggregation(side);\n            }\n\n            // If the fulfillment components are offer components...\n            if (side == Side.OFFER) {\n                // Return execution for aggregated items provided by offerer.\n                _aggregateValidFulfillmentOfferItems(\n                    advancedOrders,\n                    fulfillmentComponents,\n                    execution\n                );\n            } else {\n                // Otherwise, fulfillment components are consideration\n                // components. Return execution for aggregated items provided by\n                // the fulfiller.\n                _aggregateValidFulfillmentConsiderationItems(\n                    advancedOrders,\n                    fulfillmentComponents,\n                    execution\n                );\n\n                // Set the caller as the offerer on the execution.\n                execution.offerer = msg.sender;\n\n                // Set fulfiller conduit key as the conduit key on execution.\n                execution.conduitKey = fulfillerConduitKey;\n            }\n\n            // Set the offerer as the receipient if execution amount is nonzero.\n            if (execution.item.amount == 0) {\n                execution.item.recipient = payable(execution.offerer);\n            }\n        }\n    }\n\n    /**\n     * @dev Internal pure function to aggregate a group of offer items using\n     *      supplied directives on which component items are candidates for\n     *      aggregation, skipping items on orders that are not available.\n     *\n     * @param advancedOrders  The orders to aggregate offer items from.\n     * @param offerComponents An array of FulfillmentComponent structs\n     *                        indicating the order index and item index of each\n     *                        candidate offer item for aggregation.\n     * @param execution       The execution to apply the aggregation to.\n     */\n    function _aggregateValidFulfillmentOfferItems(\n        AdvancedOrder[] memory advancedOrders,\n        FulfillmentComponent[] memory offerComponents,\n        Execution memory execution\n    ) internal view {\n        assembly {\n            // Declare function for reverts on invalid fulfillment data.\n            function throwInvalidFulfillmentComponentData() {\n                // Store the InvalidFulfillmentComponentData error signature.\n                mstore(0, InvalidFulfillmentComponentData_error_signature)\n\n                // Return, supplying InvalidFulfillmentComponentData signature.\n                revert(0, InvalidFulfillmentComponentData_error_len)\n            }\n\n            // Declare function for reverts due to arithmetic overflows.\n            function throwOverflow() {\n                // Store the Panic error signature.\n                mstore(0, Panic_error_signature)\n\n                // Store the arithmetic (0x11) panic code as initial argument.\n                mstore(Panic_error_offset, Panic_arithmetic)\n\n                // Return, supplying Panic signature and arithmetic code.\n                revert(0, Panic_error_length)\n            }\n\n            // Get position in offerComponents head.\n            let fulfillmentHeadPtr := add(offerComponents, OneWord)\n\n            // Retrieve the order index using the fulfillment pointer.\n            let orderIndex := mload(mload(fulfillmentHeadPtr))\n\n            // Ensure that the order index is not out of range.\n            if iszero(lt(orderIndex, mload(advancedOrders))) {\n                throwInvalidFulfillmentComponentData()\n            }\n\n            // Read advancedOrders[orderIndex] pointer from its array head.\n            let orderPtr := mload(\n                // Calculate head position of advancedOrders[orderIndex].\n                add(add(advancedOrders, OneWord), mul(orderIndex, OneWord))\n            )\n\n            // Read the pointer to OrderParameters from the AdvancedOrder.\n            let paramsPtr := mload(orderPtr)\n\n            // Load the offer array pointer.\n            let offerArrPtr := mload(\n                add(paramsPtr, OrderParameters_offer_head_offset)\n            )\n\n            // Retrieve item index using an offset of the fulfillment pointer.\n            let itemIndex := mload(\n                add(mload(fulfillmentHeadPtr), Fulfillment_itemIndex_offset)\n            )\n\n            // Only continue if the fulfillment is not invalid.\n            if iszero(lt(itemIndex, mload(offerArrPtr))) {\n                throwInvalidFulfillmentComponentData()\n            }\n\n            // Retrieve consideration item pointer using the item index.\n            let offerItemPtr := mload(\n                add(\n                    // Get pointer to beginning of receivedItem.\n                    add(offerArrPtr, OneWord),\n                    // Calculate offset to pointer for desired order.\n                    mul(itemIndex, OneWord)\n                )\n            )\n\n            // Declare a variable for the final aggregated item amount.\n            let amount := 0\n\n            // Create variable to track errors encountered with amount.\n            let errorBuffer := 0\n\n            // Only add offer amount to execution amount on a nonzero numerator.\n            if mload(add(orderPtr, AdvancedOrder_numerator_offset)) {\n                // Retrieve amount pointer using consideration item pointer.\n                let amountPtr := add(offerItemPtr, Common_amount_offset)\n\n                // Set the amount.\n                amount := mload(amountPtr)\n\n                // Zero out amount on item to indicate it is credited.\n                mstore(amountPtr, 0)\n\n                // Buffer indicating whether issues were found.\n                errorBuffer := iszero(amount)\n            }\n\n            // Retrieve the received item pointer.\n            let receivedItemPtr := mload(execution)\n\n            // Set the caller as the recipient on the received item.\n            mstore(\n                add(receivedItemPtr, ReceivedItem_recipient_offset),\n                caller()\n            )\n\n            // Set the item type on the received item.\n            mstore(receivedItemPtr, mload(offerItemPtr))\n\n            // Set the token on the received item.\n            mstore(\n                add(receivedItemPtr, Common_token_offset),\n                mload(add(offerItemPtr, Common_token_offset))\n            )\n\n            // Set the identifier on the received item.\n            mstore(\n                add(receivedItemPtr, Common_identifier_offset),\n                mload(add(offerItemPtr, Common_identifier_offset))\n            )\n\n            // Set the offerer on returned execution using order pointer.\n            mstore(add(execution, Execution_offerer_offset), mload(paramsPtr))\n\n            // Set conduitKey on returned execution via offset of order pointer.\n            mstore(\n                add(execution, Execution_conduit_offset),\n                mload(add(paramsPtr, OrderParameters_conduit_offset))\n            )\n\n            // Calculate the hash of (itemType, token, identifier).\n            let dataHash := keccak256(\n                receivedItemPtr,\n                ReceivedItem_CommonParams_size\n            )\n\n            // Get position one word past last element in head of array.\n            let endPtr := add(\n                offerComponents,\n                mul(mload(offerComponents), OneWord)\n            )\n\n            // Iterate over remaining offer components.\n            // prettier-ignore\n            for {} lt(fulfillmentHeadPtr,  endPtr) {} {\n                // Increment the pointer to the fulfillment head by one word.\n                fulfillmentHeadPtr := add(fulfillmentHeadPtr, OneWord)\n\n                // Get the order index using the fulfillment pointer.\n                orderIndex := mload(mload(fulfillmentHeadPtr))\n\n                // Ensure the order index is in range.\n                if iszero(lt(orderIndex, mload(advancedOrders))) {\n                  throwInvalidFulfillmentComponentData()\n                }\n\n                // Get pointer to AdvancedOrder element.\n                orderPtr := mload(\n                    add(\n                        add(advancedOrders, OneWord),\n                        mul(orderIndex, OneWord)\n                    )\n                )\n\n                // Only continue if numerator is not zero.\n                if iszero(mload(\n                    add(orderPtr, AdvancedOrder_numerator_offset)\n                )) {\n                  continue\n                }\n\n                // Read the pointer to OrderParameters from the AdvancedOrder.\n                paramsPtr := mload(orderPtr)\n\n                // Load offer array pointer.\n                offerArrPtr := mload(\n                    add(\n                        paramsPtr,\n                        OrderParameters_offer_head_offset\n                    )\n                )\n\n                // Get the item index using the fulfillment pointer.\n                itemIndex := mload(add(mload(fulfillmentHeadPtr), OneWord))\n\n                // Throw if itemIndex is out of the range of array.\n                if iszero(\n                    lt(itemIndex, mload(offerArrPtr))\n                ) {\n                    throwInvalidFulfillmentComponentData()\n                }\n\n                // Retrieve offer item pointer using index.\n                offerItemPtr := mload(\n                    add(\n                        // Get pointer to beginning of receivedItem.\n                        add(offerArrPtr, OneWord),\n                        // Use offset to pointer for desired order.\n                        mul(itemIndex, OneWord)\n                    )\n                )\n\n                // Retrieve amount pointer using offer item pointer.\n                let amountPtr := add(\n                      offerItemPtr,\n                      Common_amount_offset\n                )\n\n                // Add offer amount to execution amount.\n                let newAmount := add(amount, mload(amountPtr))\n\n                // Update error buffer (1 = zero amount, 2 = overflow).\n                errorBuffer := or(\n                  errorBuffer,\n                  or(\n                    shl(1, lt(newAmount, amount)),\n                    iszero(mload(amountPtr))\n                  )\n                )\n\n                // Update the amount to the new, summed amount.\n                amount := newAmount\n\n                // Zero out amount on original item to indicate it is credited.\n                mstore(amountPtr, 0)\n\n                // Ensure the indicated item matches original item.\n                if iszero(\n                    and(\n                        and(\n                          // The offerer must match on both items.\n                          eq(\n                              mload(paramsPtr),\n                              mload(\n                                  add(execution, Execution_offerer_offset)\n                              )\n                          ),\n                          // The conduit key must match on both items.\n                          eq(\n                              mload(\n                                  add(\n                                      paramsPtr,\n                                      OrderParameters_conduit_offset\n                                  )\n                              ),\n                              mload(\n                                  add(\n                                      execution,\n                                      Execution_conduit_offset\n                                  )\n                              )\n                          )\n                        ),\n                        // The itemType, token, and identifier must match.\n                        eq(\n                            dataHash,\n                            keccak256(\n                                offerItemPtr,\n                                ReceivedItem_CommonParams_size\n                            )\n                        )\n                    )\n                ) {\n                    // Throw if any of the requirements are not met.\n                    throwInvalidFulfillmentComponentData()\n                }\n            }\n            // Write final amount to execution.\n            mstore(add(mload(execution), Common_amount_offset), amount)\n\n            // Determine if an error code is contained in the error buffer.\n            switch errorBuffer\n            case 1 {\n                // Store the MissingItemAmount error signature.\n                mstore(0, MissingItemAmount_error_signature)\n\n                // Return, supplying MissingItemAmount signature.\n                revert(0, MissingItemAmount_error_len)\n            }\n            case 2 {\n                // If the sum overflowed, panic.\n                throwOverflow()\n            }\n        }\n    }\n\n    /**\n     * @dev Internal pure function to aggregate a group of consideration items\n     *      using supplied directives on which component items are candidates\n     *      for aggregation, skipping items on orders that are not available.\n     *\n     * @param advancedOrders          The orders to aggregate consideration\n     *                                items from.\n     * @param considerationComponents An array of FulfillmentComponent structs\n     *                                indicating the order index and item index\n     *                                of each candidate consideration item for\n     *                                aggregation.\n     * @param execution       The execution to apply the aggregation to.\n     */\n    function _aggregateValidFulfillmentConsiderationItems(\n        AdvancedOrder[] memory advancedOrders,\n        FulfillmentComponent[] memory considerationComponents,\n        Execution memory execution\n    ) internal pure {\n        // Utilize assembly in order to efficiently aggregate the items.\n        assembly {\n            // Declare function for reverts on invalid fulfillment data.\n            function throwInvalidFulfillmentComponentData() {\n                // Store the InvalidFulfillmentComponentData error signature.\n                mstore(0, InvalidFulfillmentComponentData_error_signature)\n\n                // Return, supplying InvalidFulfillmentComponentData signature.\n                revert(0, InvalidFulfillmentComponentData_error_len)\n            }\n\n            // Declare function for reverts due to arithmetic overflows.\n            function throwOverflow() {\n                // Store the Panic error signature.\n                mstore(0, Panic_error_signature)\n\n                // Store the arithmetic (0x11) panic code as initial argument.\n                mstore(Panic_error_offset, Panic_arithmetic)\n\n                // Return, supplying Panic signature and arithmetic code.\n                revert(0, Panic_error_length)\n            }\n\n            // Get position in considerationComponents head.\n            let fulfillmentHeadPtr := add(considerationComponents, OneWord)\n\n            // Retrieve the order index using the fulfillment pointer.\n            let orderIndex := mload(mload(fulfillmentHeadPtr))\n\n            // Ensure that the order index is not out of range.\n            if iszero(lt(orderIndex, mload(advancedOrders))) {\n                throwInvalidFulfillmentComponentData()\n            }\n\n            // Read advancedOrders[orderIndex] pointer from its array head.\n            let orderPtr := mload(\n                // Calculate head position of advancedOrders[orderIndex].\n                add(add(advancedOrders, OneWord), mul(orderIndex, OneWord))\n            )\n\n            // Load consideration array pointer.\n            let considerationArrPtr := mload(\n                add(\n                    // Read pointer to OrderParameters from the AdvancedOrder.\n                    mload(orderPtr),\n                    OrderParameters_consideration_head_offset\n                )\n            )\n\n            // Retrieve item index using an offset of the fulfillment pointer.\n            let itemIndex := mload(\n                add(mload(fulfillmentHeadPtr), Fulfillment_itemIndex_offset)\n            )\n\n            // Ensure that the order index is not out of range.\n            if iszero(lt(itemIndex, mload(considerationArrPtr))) {\n                throwInvalidFulfillmentComponentData()\n            }\n\n            // Retrieve consideration item pointer using the item index.\n            let considerationItemPtr := mload(\n                add(\n                    // Get pointer to beginning of receivedItem.\n                    add(considerationArrPtr, OneWord),\n                    // Calculate offset to pointer for desired order.\n                    mul(itemIndex, OneWord)\n                )\n            )\n\n            // Declare a variable for the final aggregated item amount.\n            let amount := 0\n\n            // Create variable to track errors encountered with amount.\n            let errorBuffer := 0\n\n            // Only add consideration amount to execution amount if numerator is\n            // greater than zero.\n            if mload(add(orderPtr, AdvancedOrder_numerator_offset)) {\n                // Retrieve amount pointer using consideration item pointer.\n                let amountPtr := add(considerationItemPtr, Common_amount_offset)\n\n                // Set the amount.\n                amount := mload(amountPtr)\n\n                // Set error bit if amount is zero.\n                errorBuffer := iszero(amount)\n\n                // Zero out amount on item to indicate it is credited.\n                mstore(amountPtr, 0)\n            }\n\n            // Retrieve ReceivedItem pointer from Execution.\n            let receivedItem := mload(execution)\n\n            // Set the item type on the received item.\n            mstore(receivedItem, mload(considerationItemPtr))\n\n            // Set the token on the received item.\n            mstore(\n                add(receivedItem, Common_token_offset),\n                mload(add(considerationItemPtr, Common_token_offset))\n            )\n\n            // Set the identifier on the received item.\n            mstore(\n                add(receivedItem, Common_identifier_offset),\n                mload(add(considerationItemPtr, Common_identifier_offset))\n            )\n\n            // Set the recipient on the received item.\n            mstore(\n                add(receivedItem, ReceivedItem_recipient_offset),\n                mload(\n                    add(\n                        considerationItemPtr,\n                        ConsiderationItem_recipient_offset\n                    )\n                )\n            )\n\n            // Calculate the hash of (itemType, token, identifier).\n            let dataHash := keccak256(\n                receivedItem,\n                ReceivedItem_CommonParams_size\n            )\n\n            // Get position one word past last element in head of array.\n            let endPtr := add(\n                considerationComponents,\n                mul(mload(considerationComponents), OneWord)\n            )\n\n            // Iterate over remaining offer components.\n            // prettier-ignore\n            for {} lt(fulfillmentHeadPtr,  endPtr) {} {\n                // Increment position in considerationComponents head.\n                fulfillmentHeadPtr := add(fulfillmentHeadPtr, OneWord)\n\n                // Get the order index using the fulfillment pointer.\n                orderIndex := mload(mload(fulfillmentHeadPtr))\n\n                // Ensure the order index is in range.\n                if iszero(lt(orderIndex, mload(advancedOrders))) {\n                  throwInvalidFulfillmentComponentData()\n                }\n\n                // Get pointer to AdvancedOrder element.\n                orderPtr := mload(\n                    add(\n                        add(advancedOrders, OneWord),\n                        mul(orderIndex, OneWord)\n                    )\n                )\n\n                // Only continue if numerator is not zero.\n                if iszero(\n                    mload(add(orderPtr, AdvancedOrder_numerator_offset))\n                ) {\n                  continue\n                }\n\n                // Load consideration array pointer from OrderParameters.\n                considerationArrPtr := mload(\n                    add(\n                        // Get pointer to OrderParameters from AdvancedOrder.\n                        mload(orderPtr),\n                        OrderParameters_consideration_head_offset\n                    )\n                )\n\n                // Get the item index using the fulfillment pointer.\n                itemIndex := mload(add(mload(fulfillmentHeadPtr), OneWord))\n\n                // Check if itemIndex is within the range of array.\n                if iszero(lt(itemIndex, mload(considerationArrPtr))) {\n                    throwInvalidFulfillmentComponentData()\n                }\n\n                // Retrieve consideration item pointer using index.\n                considerationItemPtr := mload(\n                    add(\n                        // Get pointer to beginning of receivedItem.\n                        add(considerationArrPtr, OneWord),\n                        // Use offset to pointer for desired order.\n                        mul(itemIndex, OneWord)\n                    )\n                )\n\n                // Retrieve amount pointer using consideration item pointer.\n                let amountPtr := add(\n                      considerationItemPtr,\n                      Common_amount_offset\n                )\n\n                // Add offer amount to execution amount.\n                let newAmount := add(amount, mload(amountPtr))\n\n                // Update error buffer (1 = zero amount, 2 = overflow).\n                errorBuffer := or(\n                  errorBuffer,\n                  or(\n                    shl(1, lt(newAmount, amount)),\n                    iszero(mload(amountPtr))\n                  )\n                )\n\n                // Update the amount to the new, summed amount.\n                amount := newAmount\n\n                // Zero out amount on original item to indicate it is credited.\n                mstore(amountPtr, 0)\n\n                // Ensure the indicated item matches original item.\n                if iszero(\n                    and(\n                        // Item recipients must match.\n                        eq(\n                            mload(\n                                add(\n                                    considerationItemPtr,\n                                    ConsiderItem_recipient_offset\n                                )\n                            ),\n                            mload(\n                                add(\n                                    receivedItem,\n                                    ReceivedItem_recipient_offset\n                                )\n                            )\n                        ),\n                        // The itemType, token, identifier must match.\n                        eq(\n                          dataHash,\n                          keccak256(\n                            considerationItemPtr,\n                            ReceivedItem_CommonParams_size\n                          )\n                        )\n                    )\n                ) {\n                    // Throw if any of the requirements are not met.\n                    throwInvalidFulfillmentComponentData()\n                }\n            }\n            // Write final amount to execution.\n            mstore(add(receivedItem, Common_amount_offset), amount)\n\n            // Determine if an error code is contained in the error buffer.\n            switch errorBuffer\n            case 1 {\n                // Store the MissingItemAmount error signature.\n                mstore(0, MissingItemAmount_error_signature)\n\n                // Return, supplying MissingItemAmount signature.\n                revert(0, MissingItemAmount_error_len)\n            }\n            case 2 {\n                // If the sum overflowed, panic.\n                throwOverflow()\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/lib/FulfillmentApplier.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport { ItemType, Side } from \"./ConsiderationEnums.sol\";\n\n// prettier-ignore\nimport {\n    OfferItem,\n    ConsiderationItem,\n    ReceivedItem,\n    OrderParameters,\n    AdvancedOrder,\n    Execution,\n    FulfillmentComponent\n} from \"./ConsiderationStructs.sol\";\n\nimport \"./ConsiderationConstants.sol\";\n\n// prettier-ignore\nimport {\n    FulfillmentApplicationErrors\n} from \"../interfaces/FulfillmentApplicationErrors.sol\";\n\n/**\n * @title FulfillmentApplier\n * @author 0age\n * @notice FulfillmentApplier contains logic related to applying fulfillments,\n *         both as part of order matching (where offer items are matched to\n *         consideration items) as well as fulfilling available orders (where\n *         order items and consideration items are independently aggregated).\n */\ncontract FulfillmentApplier is FulfillmentApplicationErrors {\n    /**\n     * @dev Internal view function to match offer items to consideration items\n     *      on a group of orders via a supplied fulfillment.\n     *\n     * @param advancedOrders          The orders to match.\n     * @param offerComponents         An array designating offer components to\n     *                                match to consideration components.\n     * @param considerationComponents An array designating consideration\n     *                                components to match to offer components.\n     *                                Note that each consideration amount must\n     *                                be zero in order for the match operation\n     *                                to be valid.\n     *\n     * @return execution The transfer performed as a result of the fulfillment.\n     */\n    function _applyFulfillment(\n        AdvancedOrder[] memory advancedOrders,\n        FulfillmentComponent[] calldata offerComponents,\n        FulfillmentComponent[] calldata considerationComponents\n    ) internal view returns (Execution memory execution) {\n        // Ensure 1+ of both offer"
    }
  ]
}