{
  "Title": "[M-13] Incorrect calculation of lending shares in `_withdrawOrAllocateSharesLiquidation` can lead to revert and failure to liquidate",
  "Content": "\nWhen liquidating a user, `_withdrawOrAllocateSharesLiquidation()` can be called which checks if a pool is large enough to pay out the liquidator, and if not, then the liquidator is allocated shares that can be used to withdraw at a later time when the pool is large enough. There are two scenarios in which the pool will not be large enough to pay out the liquidator:\n\n1. The obvious scenario where the pool simply doesn't contain enough tokens to cover the withdraw amount.\n2. So many tokens are borrowed out of the pool that there isn't enough available to pay out the liquidator.\n\nNote: If there are some tokens available but not enough to cover the entire withdraw amount, then those tokens are transferred, dropping the total pool to `0`, and the rest are allocated as shares.\n\nHowever, if these scenarios were ever to arise, the `_withdrawOrAllocateSharesLiquidation()` function would not work as expected. This is due to how it calculates the lending shares (`totalPoolInShares`) of the total pool:\n\n<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseCore.sol#L493>\n\nWhen liquidating, it will calculate the `totalPoolInShares` like this (with amount being the total pool):\n\n```\n       lendingShares = (totalDepositShares * amount) / pseudoTotalPool - 1;\n```\n\nHowever, calculating the lending shares this way will cause the `_compareSharePrices()` to revert on the `syncPool` modifier. Specifically the check on\n\n        _validateParameter(\n            _lendSharePriceBefore,\n            lendSharePriceAfter\n        );\n\nThis is because `_maxSharePrice` is passed in as false to `calculateLendingShares()`, which subtracts one.\n\n```\n    uint256 totalPoolInShares = calculateLendingShares(\n                {\n                    _poolToken: _poolToken,\n                    _amount: totalPoolToken,\n                    _maxSharePrice: false\n                }\n            );\n```\n\n<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseCore.sol#L497>\n\nHowever, because we are withdrawing, it should be set to true so that it adds one. In all other areas where `calculateLendingShares()` is being used, the functions that focus on withdrawing have `_maxSharePrice: true` and the depositing functions have `_maxSharePrice: false`:\n\n[`withdrawOnBehalfExactAmount` on `WiseLending.sol`](<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseLending.sol#L874>).\n\n[`_preparationsWithdraw` on `MainHelper.sol`](<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/MainHelper.sol#L154>).\n\n[`_handleDeposit` on `WiseCore.sol`](<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseCore.sol#L119>).\n\nWhen `_maxSharePrice` is set to true, the `_validateParameter()` check will pass.\n\nEven if the `_validateParameter()` check did not exist, if `_maxSharePrice` is left as-is (set to false), any subsequent liquidations through `_withdrawOrAllocateSharesLiquidation()` would revert with panic due to an underflow. This is because (as stated above), liquidating when the pool is not large enough to pay out the liquidator will drop the total pool to `0` and issue the remainder as shares. Therefore, any subsequent calls to liquidate when the total pool is `0` will underflow:\n\n```\n        //amount is totalPoolToken which in this scenario = 0;\n        shares = amount * totalDepositShares / pseudoTotalPool - 1\n```\n\n### Impact\n\nWhen a particular receiving token is desired and `_withdrawOrAllocateSharesLiquidation()` is called, the liquidation will always revert if the total pool is not large enough to cover the withdraw amount. This defeats the purpose of `_withdrawOrAllocateSharesLiquidation()`, as stated in the NatSpec:\n\n```\n    /**\n         * @dev Internal math function for liquidation logic\n         * which checks if pool has enough token to pay out\n         * liquidator. If not, liquidator get corresponding\n         * shares for later withdraw.\n         */\n```\n\nThis will lead to frustrated users who desire a particular receiving token. The level of frustration will be even higher if the reason this function reverts is because the total pool is borrowed out. This would lead to a very high APY, thus a much higher desire to receive the particular token. Additionally, the borrowers in these particular situations will not be liquidated even though they should be. Ultimately, this will lead to loss of faith in the protocol.\n\nHowever, this can be easily avoided by just passing in a different receiving token that is large enough to payout the withdraw amount, which is why this is a medium level issue.\n\n### Proof of Concept\n\nCopy and paste this foundry test into the `/contracts` folder and run `forge test --fork-url mainnet --match-path ./contracts/WoolCentaurLiquidationTest.t.sol --match-test testLiquidateMockPool  -vvvv`.  As the code is, the test will fail.  To have it pass, change the bool [here](<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseCore.sol#L497>)\nto `true`.\n\n<details>\n\n```\n    // SPDX-License-Identifier: -- WISE --\n\n    pragma solidity =0.8.24;\n\n\n    import \"forge-std/Test.sol\";\n    import \"forge-std/StdUtils.sol\";\n    import \"./InterfaceHub/IBalancerFlashloan.sol\";\n    import \"./InterfaceHub/IWiseLending.sol\";\n    import \"./InterfaceHub/ICurve.sol\";\n    import \"./InterfaceHub/IAaveHub.sol\";\n    import \"./InterfaceHub/IAave.sol\";\n    import \"./InterfaceHub/IPositionNFTs.sol\";\n    import \"./WiseLendingBaseDeployment.t.sol\";\n    import \"./PoolManager.sol\";\n\n\n\n    contract WoolCentaur is BaseDeploymentTest {\n\n            function testLiquidateMockPool() public {\n                /////////////////////////////\n                // Setup new fork and deal tokens\n                _useBlock(\n                    NEW_BLOCK\n                );\n\n                _deployNewWiseLending(\n                    {\n                        _mainnetFork: false\n                    }\n                );\n\n                vm.deal(address(1), 2000 ether);\n                vm.deal(WISE_DEPLOYER, 1000 ether);\n                address paybackToken = address(MOCK_AAVE_ATOKEN_3);\n                address receivingToken = address(MOCK_AAVE_ATOKEN_4);\n                address mockWETH = address(MOCK_WETH);\n                deal(paybackToken, WISE_DEPLOYER, 11000e6);\n                deal(receivingToken, address(1), 200000e6);\n                deal(mockWETH, WISE_DEPLOYER, 1000e18);\n                deal(mockWETH, address(1), 1000e18);\n\n                //Mint position nfts to address 1\n                _startPrank(\n                    address(1)\n                );\n\n                POSITION_NFTS_INSTANCE.mintPosition();\n\n                uint256[] memory nftsOfOwner1 = POSITION_NFTS_INSTANCE.walletOfOwner(\n                    address(1)\n                );\n\n                uint256 nftIdFirst = nftsOfOwner1[0];\n\n                _stopPrank();\n\n                // Mint position nfts to WISE_DEPLOYER\n                _startPrank(\n                    WISE_DEPLOYER\n                );\n                POSITION_NFTS_INSTANCE.mintPosition();\n\n                uint256[] memory nftsOfOwner2 = POSITION_NFTS_INSTANCE.walletOfOwner(\n                    WISE_DEPLOYER\n                );\n\n                uint256 nftIdSecond = nftsOfOwner2[0];\n                \n                skip(10);\n\n                //Approve and deposit the payback tokens\n                IERC20(paybackToken).approve(\n                    address(LENDING_INSTANCE),\n                    10000e6\n                );\n\n                LENDING_INSTANCE.depositExactAmount(\n                    nftIdSecond,\n                    paybackToken,\n                    10000e6\n                );\n\n                //Approve and deposit the collateral tokens\n                IERC20(mockWETH).approve(\n                    address(LENDING_INSTANCE),\n                    1000e18\n                );\n\n                LENDING_INSTANCE.depositExactAmount(\n                    nftIdSecond,\n                    mockWETH,\n                    1000e18\n                );\n\n                _stopPrank();\n\n        \n                _startPrank(\n                    address(1)\n                );\n                //Deposit collateral tokens\n                LENDING_INSTANCE.depositExactAmountETH{\n                    value: 2000 ether\n                }(nftIdFirst);\n\n                //Set the value of the receiving token\n                MOCK_CHAINLINK_4.setValue(\n                    0.00000000000000001 ether\n                );\n                //Approve and deposit the receiving token\n                IERC20(receivingToken).approve(\n                    address(LENDING_INSTANCE),\n                    20000e6\n                );\n\n                LENDING_INSTANCE.depositExactAmount(\n                    nftIdFirst,\n                    receivingToken,\n                    20000e6\n                );\n                //Set the value of the payback token\n                MOCK_CHAINLINK_3.setValue(\n                    0.00000000000000001 ether\n                );\n                //Liquidatee borrows 100% the payback token\n                LENDING_INSTANCE.borrowExactAmount(\n                    nftIdFirst,\n                    paybackToken,\n                    10000e6\n                );\n                //Set the new value of payback token, pushing it into bad debt so it can be liquidated\n                MOCK_CHAINLINK_3.setValue(\n                    0.00000001 ether\n                );\n\n                _stopPrank();\n\n\n                _startPrank(\n                    WISE_DEPLOYER\n                );\n                //Liquidator borrows 100% of the receivingToken so shares must be issued\n                LENDING_INSTANCE.borrowExactAmount(\n                    nftIdSecond,\n                    receivingToken,\n                    20000e6\n                );\n\n\n                skip(6000);\n                (, uint256 liquidateeLendingSharesBefore) = LENDING_INSTANCE.userLendingData(nftIdFirst, (receivingToken));\n                (, uint256 liquidatorLendingSharesBefore) = LENDING_INSTANCE.userLendingData(nftIdSecond, (receivingToken));\n                //assert that the liquidator starts with 0 shares\n                assertEq(liquidatorLendingSharesBefore, 0);\n                emit log_named_uint(\"shares of liquidatee before\", liquidateeLendingSharesBefore);\n                emit log_named_uint(\"shares of liquidator before\", liquidatorLendingSharesBefore);\n                //Approve and liquidate the respective shares and tokens\n                IERC20(paybackToken).approve(\n                    address(LENDING_INSTANCE),\n                    11\n                );\n\n                LENDING_INSTANCE.liquidatePartiallyFromTokens(\n                    nftIdFirst,\n                    nftIdSecond,\n                    paybackToken,\n                    receivingToken,\n                    10\n                );\n                _stopPrank();\n\n                (, uint256 liquidateeLendingSharesAfter) = LENDING_INSTANCE.userLendingData(nftIdFirst, (receivingToken));\n                (, uint256 liquidatorLendingSharesAfter) = LENDING_INSTANCE.userLendingData(nftIdSecond, (receivingToken));\n                //asserts that the liquidator shares have increased\n                assertNotEq(liquidatorLendingSharesAfter, 0);\n                emit log_named_uint(\"shares of liquidatee after\", liquidateeLendingSharesAfter);\n                emit log_named_uint(\"shares of liquidator after\", liquidatorLendingSharesAfter);\n                //asserts that the liquidatee + the liquidator = the total shares\n                assertEq(liquidateeLendingSharesAfter + liquidatorLendingSharesAfter, 19999999998);\n            }\n    }\n```\n\n</details>\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nChange the `_maxSharePrice` under `calculateLendingShares` on `_withdrawOrAllocateSharesLiquidation()` to true.\n\n### Assessed type\n\nError\n\n**[vm06007 (Wise Lending) commented via duplicate issue #238](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/238#issuecomment-2002357694):**\n> That seems to be like a desired functionality by design and expected behavior. @vonMangoldt can confirm.\n\n**[vonMangoldt (Wise Lending) commented via duplicate issue #238](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/238#issuecomment-2003980386):**\n> This looks right from my first looking into it. Just curious why it didn't DOS in our javascript tests. Probably the percentage roundings (etc.) need to be aligned for that behaviour.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/116#issuecomment-2020926895):**\n > Selected as best because of good POC + well balanced severity rationalization.\n\n**[Wise Lending commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/116#issuecomment-2082920876):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-wise-lending",
  "Code": [
    {
      "filename": "contracts/WiseCore.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./MainHelper.sol\";\nimport \"./TransferHub/TransferHelper.sol\";\n\nabstract contract WiseCore is MainHelper, TransferHelper {\n\n    /**\n     * @dev Wrapper function combining pool\n     * preparations for borrow and collaterals.\n     * Bypassed when called by powerFarms.\n     */\n    function _prepareAssociatedTokens(\n        uint256 _nftId,\n        address _poolTokenLend,\n        address _poolTokenBorrow\n    )\n        internal\n        returns (\n            address[] memory,\n            address[] memory\n        )\n    {\n        return (\n            _preparationTokens(\n                positionLendTokenData,\n                _nftId,\n                _poolTokenLend\n            ),\n            _preparationTokens(\n                positionBorrowTokenData,\n                _nftId,\n                _poolTokenBorrow\n            )\n        );\n    }\n\n    /**\n     * @dev Core function combining withdraw\n     * logic and security checks.\n     */\n    function _coreWithdrawToken(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount,\n        uint256 _shares,\n        bool _onBehalf\n    )\n        internal\n    {\n        (\n            address[] memory lendTokens,\n            address[] memory borrowTokens\n        ) = _prepareAssociatedTokens(\n            _nftId,\n            _poolToken,\n            ZERO_ADDRESS\n        );\n\n        powerFarmCheck = WISE_SECURITY.checksWithdraw(\n            _nftId,\n            _caller,\n            _poolToken\n        );\n\n        _coreWithdrawBare(\n            _nftId,\n            _poolToken,\n            _amount,\n            _shares\n        );\n\n        if (_onBehalf == true) {\n            emit FundsWithdrawnOnBehalf(\n                _caller,\n                _nftId,\n                _poolToken,\n                _amount,\n                _shares,\n                block.timestamp\n            );\n        } else {\n            emit FundsWithdrawn(\n                _caller,\n                _nftId,\n                _poolToken,\n                _amount,\n                _shares,\n                block.timestamp\n            );\n        }\n\n        _curveSecurityChecks(\n            lendTokens,\n            borrowTokens\n        );\n    }\n\n    /**\n     * @dev Internal function combining deposit\n     * logic, security checks and event emit.\n     */\n    function _handleDeposit(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        internal\n        returns (uint256)\n    {\n        uint256 shareAmount = calculateLendingShares(\n            {\n                _poolToken: _poolToken,\n                _amount: _amount,\n                _maxSharePrice: false\n            }\n        );\n\n        _validateNonZero(\n            shareAmount\n        );\n\n        _checkDeposit(\n            _nftId,\n            _caller,\n            _poolToken,\n            _amount\n        );\n\n        _increasePositionLendingDeposit(\n            _nftId,\n            _poolToken,\n            shareAmount\n        );\n\n        _updatePoolStorage(\n            _poolToken,\n            _amount,\n            shareAmount,\n            _increaseTotalPool,\n            _increasePseudoTotalPool,\n            _increaseTotalDepositShares\n        );\n\n        _addPositionTokenData(\n            _nftId,\n            _poolToken,\n            hashMapPositionLending,\n            positionLendTokenData\n        );\n\n        emit FundsDeposited(\n            _caller,\n            _nftId,\n            _poolToken,\n            _amount,\n            shareAmount,\n            block.timestamp\n        );\n\n        return shareAmount;\n    }\n\n    /**\n     * @dev External wrapper for\n     * {_checkPositionLocked}.\n     */\n\n    function checkPositionLocked(\n        uint256 _nftId,\n        address _caller\n    )\n        external\n        view\n    {\n        _checkPositionLocked(\n            _nftId,\n            _caller\n        );\n    }\n\n    /**\n     * @dev Checks if a postion is locked\n     * for powerFarms. Get skipped when\n     * aaveHub or a powerFarm itself is\n     * the {msg.sender}.\n     */\n\n    function _checkPositionLocked(\n        uint256 _nftId,\n        address _caller\n    )\n        internal\n        view\n    {\n        if (_byPassCase(_caller) == true) {\n            return;\n        }\n\n        if (positionLocked[_nftId] == false) {\n            return;\n        }\n\n        revert PositionLocked();\n    }\n\n    /**\n     * @dev External wrapper for\n     * {_checkDeposit}.\n     */\n    function checkDeposit(\n        uint256 _nftId,\n        address _caller,\n        address _poolToken,\n        uint256 _amount\n    )\n        external\n        view\n    {\n        _checkDeposit(\n            _nftId,\n            _caller,\n            _poolToken,\n            _amount\n        );\n    }\n\n    /**\n     * @dev Internal function including\n     * security checks for deposit logic.\n     */\n    function _checkDeposit(\n        uint256 _nftId,\n        address _caller,\n        address _poolToken,\n        uint256 _amount\n    )\n        internal\n        view\n    {\n\n        if (WISE_ORACLE.chainLinkIsDead(_poolToken) == true) {\n            revert DeadOracle();\n        }\n\n        _checkAllowDeposit(\n            _nftId,\n            _caller\n        );\n\n        _checkPositionLocked(\n            _nftId,\n            _caller\n        );\n\n        WISE_SECURITY.checkPoolWithMinDeposit(\n            _poolToken,\n            _amount\n        );\n\n        _checkMaxDepositValue(\n            _poolToken,\n            _amount\n        );\n    }\n\n    function _checkAllowDeposit(\n        uint256 _nftId,\n        address _caller\n    )\n        internal\n        view\n    {\n        if (_caller == AAVE_HUB_ADDRESS) {\n            return;\n        }\n\n        if (POSITION_NFT.isOwner(_nftId, _caller) == true) {\n            return;\n        }\n\n        revert InvalidAction();\n    }\n\n    /**\n     * @dev Internal function checking\n     * if the deposit amount for the\n     * pool token is reached.\n     */\n    function _checkMaxDepositValue(\n        address _poolToken,\n        uint256 _amount\n    )\n        private\n        view\n    {\n        bool state = maxDepositValueToken[_poolToken]\n            < globalPoolData[_poolToken].totalBareToken\n            + lendingPoolData[_poolToken].pseudoTotalPool\n            + _amount;\n\n        if (state == true) {\n            revert InvalidAction();\n        }\n    }\n\n    /**\n     * @dev Low level core function combining\n     * pure withdraw math (without security\n     * checks).\n     */\n    function _coreWithdrawBare(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount,\n        uint256 _shares\n    )\n        private\n    {\n        _updatePoolStorage(\n            _poolToken,\n            _amount,\n            _shares,\n            _decreaseTotalPool,\n            _decreasePseudoTotalPool,\n            _decreaseTotalDepositShares\n        );\n\n        _decreaseLendingShares(\n            _nftId,\n            _poolToken,\n            _shares\n        );\n\n        _removeEmptyLendingData(\n            _nftId,\n            _poolToken\n        );\n    }\n\n    /**\n     * @dev Core function combining borrow\n     * logic with security checks.\n     */\n    function _coreBorrowTokens(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount,\n        uint256 _shares,\n        bool _onBehalf\n    )\n        internal\n    {\n        (\n            address[] memory lendTokens,\n            address[] memory borrowTokens\n        ) = _prepareAssociatedTokens(\n            _nftId,\n            ZERO_ADDRESS,\n            _poolToken\n        );\n\n        powerFarmCheck = WISE_SECURITY.checksBorrow(\n            _nftId,\n            _caller,\n            _poolToken\n        );\n\n        _updatePoolStorage(\n            _poolToken,\n            _amount,\n            _shares,\n            _increasePseudoTotalBorrowAmount,\n            _decreaseTotalPool,\n            _increaseTotalBorrowShares\n        );\n\n        _increaseMappingValue(\n            userBorrowShares,\n            _nftId,\n            _poolToken,\n            _shares\n        );\n\n        _addPositionTokenData(\n            _nftId,\n            _poolToken,\n            hashMapPositionBorrow,\n            positionBorrowTokenData\n        );\n\n        if (_onBehalf == true) {\n            emit FundsBorrowedOnBehalf(\n                _caller,\n                _nftId,\n                _poolToken,\n                _amount,\n                _shares,\n                block.timestamp\n            );\n        } else {\n            emit FundsBorrowed(\n                _caller,\n                _nftId,\n                _poolToken,\n                _amount,\n                _shares,\n                block.timestamp\n            );\n        }\n\n        _curveSecurityChecks(\n            lendTokens,\n            borrowTokens\n        );\n    }\n\n    /**\n     * @dev Internal math function for liquidation logic\n     * caluclating amount to withdraw from pure\n     * collateral for liquidation.\n     */\n    function _withdrawPureCollateralLiquidation(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _percentLiquidation\n    )\n        private\n        returns (uint256 transferAmount)\n    {\n        uint256 product = _percentLiquidation\n            * pureCollateralAmount[_nftId][_poolToken];\n\n        transferAmount = product / PRECISION_FACTOR_E18;\n\n        _decreasePositionMappingValue(\n            pureCollateralAmount,\n            _nftId,\n            _poolToken,\n            transferAmount\n        );\n\n        _decreaseTotalBareToken(\n            _poolToken,\n            transferAmount\n        );\n    }\n\n    /**\n     * @dev Internal math function for liquidation logic\n     * which checks if pool has enough token to pay out\n     * liquidator. If not, liquidator get corresponding\n     * shares for later withdraw.\n     */\n    function _withdrawOrAllocateSharesLiquidation(\n        uint256 _nftId,\n        uint256 _nftIdLiquidator,\n        address _poolToken,\n        uint256 _percentWishCollateral\n    )\n        private\n        returns (uint256)\n    {\n        uint256 product = _percentWishCollateral\n            * userLendingData[_nftId][_poolToken].shares;\n\n        uint256 cashoutShares = product / PRECISION_FACTOR_E18 + 1;\n\n        uint256 withdrawAmount = _cashoutAmount(\n            _poolToken,\n            cashoutShares\n        );\n\n        uint256 totalPoolToken = globalPoolData[_poolToken].totalPool;\n\n        if (withdrawAmount <= totalPoolToken) {\n\n            _coreWithdrawBare(\n                _nftId,\n                _poolToken,\n                withdrawAmount,\n                cashoutShares\n            );\n\n            return withdrawAmount;\n        }\n\n        uint256 totalPoolInShares = calculateLendingShares(\n            {\n                _poolToken: _poolToken,\n                _amount: totalPoolToken,\n                _maxSharePrice: false\n            }\n        );\n\n        uint256 shareDifference = cashoutShares\n            - totalPoolInShares;\n\n        _coreWithdrawBare(\n            _nftId,\n            _poolToken,\n            totalPoolToken,\n            totalPoolInShares\n        );\n\n        _decreaseLendingShares(\n            _nftId,\n            _poolToken,\n            shareDifference\n        );\n\n        _increasePositionLendingDeposit(\n            _nftIdLiquidator,\n            _poolToken,\n            shareDifference\n        );\n\n        _addPositionTokenData(\n            _nftIdLiquidator,\n            _poolToken,\n            hashMapPositionLending,\n            positionLendTokenData\n        );\n\n        _removeEmptyLendingData(\n            _nftId,\n            _poolToken\n        );\n\n        return totalPoolToken;\n    }\n\n    /**\n     * @dev Internal math function combining functionallity\n     * of {_withdrawPureCollateralLiquidation} and\n     * {_withdrawOrAllocateSharesLiquidation}.\n     */\n    function _calculateReceiveAmount(\n        uint256 _nftId,\n        uint256 _nftIdLiquidator,\n        address _receiveTokens,\n        uint256 _removePercentage\n    )\n        private\n        returns (uint256 receiveAmount)\n    {\n        if (pureCollateralAmount[_nftId][_receiveTokens] > 0) {\n            receiveAmount = _withdrawPureCollateralLiquidation(\n                _nftId,\n                _receiveTokens,\n                _removePercentage\n            );\n        }\n\n        uint256 potentialPureExtraCashout;\n        uint256 userShares = userLendingData[_nftId][_receiveTokens].shares;\n        uint256 pureCollateral = pureCollateralAmount[_nftId][_receiveTokens];\n\n        if (pureCollateral > 0 && userShares > 0) {\n            potentialPureExtraCashout = _calculatePotentialPureExtraCashout(\n                userShares,\n                _receiveTokens,\n                _removePercentage\n            );\n        }\n\n        if (potentialPureExtraCashout > 0 && potentialPureExtraCashout <= pureCollateral) {\n            _decreasePositionMappingValue(\n                pureCollateralAmount,\n                _nftId,\n                _receiveTokens,\n                potentialPureExtraCashout\n            );\n\n            _decreaseTotalBareToken(\n                _receiveTokens,\n                potentialPureExtraCashout\n            );\n\n            return receiveAmount + potentialPureExtraCashout;\n        }\n\n        if (userShares == 0) {\n            return receiveAmount;\n        }\n\n        if (userLendingData[_nftId][_receiveTokens].unCollateralized == true) {\n            return receiveAmount;\n        }\n\n        return _withdrawOrAllocateSharesLiquidation(\n            _nftId,\n            _nftIdLiquidator,\n            _receiveTokens,\n            _removePercentage\n        ) + receiveAmount;\n    }\n\n    function _calculatePotentialPureExtraCashout(\n        uint256 _userShares,\n        address _poolToken,\n        uint256 _removePercentage\n    )\n        private\n        view\n        returns (uint256)\n    {\n        return _cashoutAmount(\n            _poolToken,\n            _removePercentage\n                * _userShares\n                / PRECISION_FACTOR_E18\n        );\n    }\n\n    /**\n     * @dev Core liquidation function for\n     * security checks and liquidation math.\n     */\n    function _coreLiquidation(\n        CoreLiquidationStruct memory _data\n    )\n        internal\n        returns (uint256 receiveAmount)\n    {\n        _validateNonZero(\n            _data.paybackAmount\n        );\n\n        uint256 collateralPercentage = WISE_SECURITY.calculateWishPercentage(\n            _data.nftId,\n            _data.tokenToRecieve,\n            WISE_ORACLE.getTokensInETH(\n                _data.tokenToPayback,\n                _data.paybackAmount\n            ),\n            _data.maxFeeETH,\n            _data.baseRewardLiquidation\n        );\n\n        _validateParameter(\n            collateralPercentage,\n            PRECISION_FACTOR_E18\n        );\n\n        _corePayback(\n            _data.nftId,\n            _data.tokenToPayback,\n            _data.paybackAmount,\n            _data.shareAmountToPay\n        );\n\n        receiveAmount = _calculateReceiveAmount(\n            _data.nftId,\n            _data.nftIdLiquidator,\n            _data.tokenToRecieve,\n            collateralPercentage\n        );\n\n        WISE_SECURITY.checkBadDebtLiquidation(\n            _data.nftId\n        );\n\n        _curveSecurityChecks(\n            _data.lendTokens,\n            _data.borrowTokens\n        );\n\n        _safeTransferFrom(\n            _data.tokenToPayback,\n            _data.caller,\n            address(this),\n            _data.paybackAmount\n        );\n\n        _safeTransfer(\n            _data.tokenToRecieve,\n            _data.caller,\n            receiveAmount\n        );\n    }\n}"
    },
    {
      "filename": "contracts/WiseCore.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./MainHelper.sol\";\nimport \"./TransferHub/TransferHelper.sol\";\n\nabstract contract WiseCore is MainHelper, TransferHelper {\n\n    /**\n     * @dev Wrapper function combining pool\n     * preparations for borrow and collaterals.\n     * Bypassed when called by powerFarms.\n     */\n    function _prepareAssociatedTokens(\n        uint256 _nftId,\n        address _poolTokenLend,\n        address _poolTokenBorrow\n    )\n        internal\n        returns (\n            address[] memory,\n            address[] memory\n        )\n    {\n        return (\n            _preparationTokens(\n                positionLendTokenData,\n                _nftId,\n                _poolTokenLend\n            ),\n            _preparationTokens(\n                positionBorrowTokenData,\n                _nftId,\n                _poolTokenBorrow\n            )\n        );\n    }\n\n    /**\n     * @dev Core function combining withdraw\n     * logic and security checks.\n     */\n    function _coreWithdrawToken(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount,\n        uint256 _shares,\n        bool _onBehalf\n    )\n        internal\n    {\n        (\n            address[] memory lendTokens,\n            address[] memory borrowTokens\n        ) = _prepareAssociatedTokens(\n            _nftId,\n            _poolToken,\n            ZERO_ADDRESS\n        );\n\n        powerFarmCheck = WISE_SECURITY.checksWithdraw(\n            _nftId,\n            _caller,\n            _poolToken\n        );\n\n        _coreWithdrawBare(\n            _nftId,\n            _poolToken,\n            _amount,\n            _shares\n        );\n\n        if (_onBehalf == true) {\n            emit FundsWithdrawnOnBehalf(\n                _caller,\n                _nftId,\n                _poolToken,\n                _amount,\n                _shares,\n                block.timestamp\n            );\n        } else {\n            emit FundsWithdrawn(\n                _caller,\n                _nftId,\n                _poolToken,\n                _amount,\n                _shares,\n                block.timestamp\n            );\n        }\n\n        _curveSecurityChecks(\n            lendTokens,\n            borrowTokens\n        );\n    }\n\n    /**\n     * @dev Internal function combining deposit\n     * logic, security checks and event emit.\n     */\n    function _handleDeposit(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        internal\n        returns (uint256)\n    {\n        uint256 shareAmount = calculateLendingShares(\n            {\n                _poolToken: _poolToken,\n                _amount: _amount,\n                _maxSharePrice: false\n            }\n        );\n\n        _validateNonZero(\n            shareAmount\n        );\n\n        _checkDeposit(\n            _nftId,\n            _caller,\n            _poolToken,\n            _amount\n        );\n\n        _increasePositionLendingDeposit(\n            _nftId,\n            _poolToken,\n            shareAmount\n        );\n\n        _updatePoolStorage(\n            _poolToken,\n            _amount,\n            shareAmount,\n            _increaseTotalPool,\n            _increasePseudoTotalPool,\n            _increaseTotalDepositShares\n        );\n\n        _addPositionTokenData(\n            _nftId,\n            _poolToken,\n            hashMapPositionLending,\n            positionLendTokenData\n        );\n\n        emit FundsDeposited(\n            _caller,\n            _nftId,\n            _poolToken,\n            _amount,\n            shareAmount,\n            block.timestamp\n        );\n\n        return shareAmount;\n    }\n\n    /**\n     * @dev External wrapper for\n     * {_checkPositionLocked}.\n     */\n\n    function checkPositionLocked(\n        uint256 _nftId,\n        address _caller\n    )\n        external\n        view\n    {\n        _checkPositionLocked(\n            _nftId,\n            _caller\n        );\n    }\n\n    /**\n     * @dev Checks if a postion is locked\n     * for powerFarms. Get skipped when\n     * aaveHub or a powerFarm itself is\n     * the {msg.sender}.\n     */\n\n    function _checkPositionLocked(\n        uint256 _nftId,\n        address _caller\n    )\n        internal\n        view\n    {\n        if (_byPassCase(_caller) == true) {\n            return;\n        }\n\n        if (positionLocked[_nftId] == false) {\n            return;\n        }\n\n        revert PositionLocked();\n    }\n\n    /**\n     * @dev External wrapper for\n     * {_checkDeposit}.\n     */\n    function checkDeposit(\n        uint256 _nftId,\n        address _caller,\n        address _poolToken,\n        uint256 _amount\n    )\n        external\n        view\n    {\n        _checkDeposit(\n            _nftId,\n            _caller,\n            _poolToken,\n            _amount\n        );\n    }\n\n    /**\n     * @dev Internal function including\n     * security checks for deposit logic.\n     */\n    function _checkDeposit(\n        uint256 _nftId,\n        address _caller,\n        address _poolToken,\n        uint256 _amount\n    )\n        internal\n        view\n    {\n\n        if (WISE_ORACLE.chainLinkIsDead(_poolToken) == true) {\n            revert DeadOracle();\n        }\n\n        _checkAllowDeposit(\n            _nftId,\n            _caller\n        );\n\n        _checkPositionLocked(\n            _nftId,\n            _caller\n        );\n\n        WISE_SECURITY.checkPoolWithMinDeposit(\n            _poolToken,\n            _amount\n        );\n\n        _checkMaxDepositValue(\n            _poolToken,\n            _amount\n        );\n    }\n\n    function _checkAllowDeposit(\n        uint256 _nftId,\n        address _caller\n    )\n        internal\n        view\n    {\n        if (_caller == AAVE_HUB_ADDRESS) {\n            return;\n        }\n\n        if (POSITION_NFT.isOwner(_nftId, _caller) == true) {\n            return;\n        }\n\n        revert InvalidAction();\n    }\n\n    /**\n     * @dev Internal function checking\n     * if the deposit amount for the\n     * pool token is reached.\n     */\n    function _checkMaxDepositValue(\n        address _poolToken,\n        uint256 _amount\n    )\n        private\n        view\n    {\n        bool state = maxDepositValueToken[_poolToken]\n            < globalPoolData[_poolToken].totalBareToken\n            + lendingPoolData[_poolToken].pseudoTotalPool\n            + _amount;\n\n        if (state == true) {\n            revert InvalidAction();\n        }\n    }\n\n    /**\n     * @dev Low level core function combining\n     * pure withdraw math (without security\n     * checks).\n     */\n    function _coreWithdrawBare(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount,\n        uint256 _shares\n    )\n        private\n    {\n        _updatePoolStorage(\n            _poolToken,\n            _amount,\n            _shares,\n            _decreaseTotalPool,\n            _decreasePseudoTotalPool,\n            _decreaseTotalDepositShares\n        );\n\n        _decreaseLendingShares(\n            _nftId,\n            _poolToken,\n            _shares\n        );\n\n        _removeEmptyLendingData(\n            _nftId,\n            _poolToken\n        );\n    }\n\n    /**\n     * @dev Core function combining borrow\n     * logic with security checks.\n     */\n    function _coreBorrowTokens(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount,\n        uint256 _shares,\n        bool _onBehalf\n    )\n        internal\n    {\n        (\n            address[] memory lendTokens,\n            address[] memory borrowTokens\n        ) = _prepareAssociatedTokens(\n            _nftId,\n            ZERO_ADDRESS,\n            _poolToken\n        );\n\n        powerFarmCheck = WISE_SECURITY.checksBorrow(\n            _nftId,\n            _caller,\n            _poolToken\n        );\n\n        _updatePoolStorage(\n            _poolToken,\n            _amount,\n            _shares,\n            _increasePseudoTotalBorrowAmount,\n            _decreaseTotalPool,\n            _increaseTotalBorrowShares\n        );\n\n        _increaseMappingValue(\n            userBorrowShares,\n            _nftId,\n            _poolToken,\n            _shares\n        );\n\n        _addPositionTokenData(\n            _nftId,\n            _poolToken,\n            hashMapPositionBorrow,\n            positionBorrowTokenData\n        );\n\n        if (_onBehalf == true) {\n            emit FundsBorrowedOnBehalf(\n                _caller,\n                _nftId,\n                _poolToken,\n                _amount,\n                _shares,\n                block.timestamp\n            );\n        } else {\n            emit FundsBorrowed(\n                _caller,\n                _nftId,\n                _poolToken,\n                _amount,\n                _shares,\n                block.timestamp\n            );\n        }\n\n        _curveSecurityChecks(\n            lendTokens,\n            borrowTokens\n        );\n    }\n\n    /**\n     * @dev Internal math function for liquidation logic\n     * caluclating amount to withdraw from pure\n     * collateral for liquidation.\n     */\n    function _withdrawPureCollateralLiquidation(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _percentLiquidation\n    )\n        private\n        returns (uint256 transferAmount)\n    {\n        uint256 product = _percentLiquidation\n            * pureCollateralAmount[_nftId][_poolToken];\n\n        transferAmount = product / PRECISION_FACTOR_E18;\n\n        _decreasePositionMappingValue(\n            pureCollateralAmount,\n            _nftId,\n            _poolToken,\n            transferAmount\n        );\n\n        _decreaseTotalBareToken(\n            _poolToken,\n            transferAmount\n        );\n    }\n\n    /**\n     * @dev Internal math function for liquidation logic\n     * which checks if pool has enough token to pay out\n     * liquidator. If not, liquidator get corresponding\n     * shares for later withdraw.\n     */\n    function _withdrawOrAllocateSharesLiquidation(\n        uint256 _nftId,\n        uint256 _nftIdLiquidator,\n        address _poolToken,\n        uint256 _percentWishCollateral\n    )\n        private\n        returns (uint256)\n    {\n        uint256 product = _percentWishCollateral\n            * userLendingData[_nftId][_poolToken].shares;\n\n        uint256 cashoutShares = product / PRECISION_FACTOR_E18 + 1;\n\n        uint256 withdrawAmount = _cashoutAmount(\n            _poolToken,\n            cashoutShares\n        );\n\n        uint256 totalPoolToken = globalPoolData[_poolToken].totalPool;\n\n        if (withdrawAmount <= totalPoolToken) {\n\n            _coreWithdrawBare(\n                _nftId,\n                _poolToken,\n                withdrawAmount,\n                cashoutShares\n            );\n\n            return withdrawAmount;\n        }\n\n        uint256 totalPoolInShares = calculateLendingShares(\n            {\n                _poolToken: _poolToken,\n                _amount: totalPoolToken,\n                _maxSharePrice: false\n            }\n        );\n\n        uint256 shareDifference = cashoutShares\n            - totalPoolInShares;\n\n        _coreWithdrawBare(\n            _nftId,\n            _poolToken,\n            totalPoolToken,\n            totalPoolInShares\n        );\n\n        _decreaseLendingShares(\n            _nftId,\n            _poolToken,\n            shareDifference\n        );\n\n        _increasePositionLendingDeposit(\n            _nftIdLiquidator,\n            _poolToken,\n            shareDifference\n        );\n\n        _addPositionTokenData(\n            _nftIdLiquidator,\n            _poolToken,\n            hashMapPositionLending,\n            positionLendTokenData\n        );\n\n        _removeEmptyLendingData(\n            _nftId,\n            _poolToken\n        );\n\n        return totalPoolToken;\n    }\n\n    /**\n     * @dev Internal math function combining functionallity\n     * of {_withdrawPureCollateralLiquidation} and\n     * {_withdrawOrAllocateSharesLiquidation}.\n     */\n    function _calculateReceiveAmount(\n        uint256 _nftId,\n        uint256 _nftIdLiquidator,\n        address _receiveTokens,\n        uint256 _removePercentage\n    )\n        private\n        returns (uint256 receiveAmount)\n    {\n        if (pureCollateralAmount[_nftId][_receiveTokens] > 0) {\n            receiveAmount = _withdrawPureCollateralLiquidation(\n                _nftId,\n                _receiveTokens,\n                _removePercentage\n            );\n        }\n\n        uint256 potentialPureExtraCashout;\n        uint256 userShares = userLendingData[_nftId][_receiveTokens].shares;\n        uint256 pureCollateral = pureCollateralAmount[_nftId][_receiveTokens];\n\n        if (pureCollateral > 0 && userShares > 0) {\n            potentialPureExtraCashout = _calculatePotentialPureExtraCashout(\n                userShares,\n                _receiveTokens,\n                _removePercentage\n            );\n        }\n\n        if (potentialPureExtraCashout > 0 && potentialPureExtraCashout <= pureCollateral) {\n            _decreasePositionMappingValue(\n                pureCollateralAmount,\n                _nftId,\n                _receiveTokens,\n                potentialPureExtraCashout\n            );\n\n            _decreaseTotalBareToken(\n                _receiveTokens,\n                potentialPureExtraCashout\n            );\n\n            return receiveAmount + potentialPureExtraCashout;\n        }\n\n        if (userShares == 0) {\n            return receiveAmount;\n        }\n\n        if (userLendingData[_nftId][_receiveTokens].unCollateralized == true) {\n            return receiveAmount;\n        }\n\n        return _withdrawOrAllocateSharesLiquidation(\n            _nftId,\n            _nftIdLiquidator,\n            _receiveTokens,\n            _removePercentage\n        ) + receiveAmount;\n    }\n\n    function _calculatePotentialPureExtraCashout(\n        uint256 _userShares,\n        address _poolToken,\n        uint256 _removePercentage\n    )\n        private\n        view\n        returns (uint256)\n    {\n        return _cashoutAmount(\n            _poolToken,\n            _removePercentage\n                * _userShares\n                / PRECISION_FACTOR_E18\n        );\n    }\n\n    /**\n     * @dev Core liquidation function for\n     * security checks and liquidation math.\n     */\n    function _coreLiquidation(\n        CoreLiquidationStruct memory _data\n    )\n        internal\n        returns (uint256 receiveAmount)\n    {\n        _validateNonZero(\n            _data.paybackAmount\n        );\n\n        uint256 collateralPercentage = WISE_SECURITY.calculateWishPercentage(\n            _data.nftId,\n            _data.tokenToRecieve,\n            WISE_ORACLE.getTokensInETH(\n                _data.tokenToPayback,\n                _data.paybackAmount\n            ),\n            _data.maxFeeETH,\n            _data.baseRewardLiquidation\n        );\n\n        _validateParameter(\n            collateralPercentage,\n            PRECISION_FACTOR_E18\n        );\n\n        _corePayback(\n            _data.nftId,\n            _data.tokenToPayback,\n            _data.paybackAmount,\n            _data.shareAmountToPay\n        );\n\n        receiveAmount = _calculateReceiveAmount(\n            _data.nftId,\n            _data.nftIdLiquidator,\n            _data.tokenToRecieve,\n            collateralPercentage\n        );\n\n        WISE_SECURITY.checkBadDebtLiquidation(\n            _data.nftId\n        );\n\n        _curveSecurityChecks(\n            _data.lendTokens,\n            _data.borrowTokens\n        );\n\n        _safeTransferFrom(\n            _data.tokenToPayback,\n            _data.caller,\n            address(this),\n            _data.paybackAmount\n        );\n\n        _safeTransfer(\n            _data.tokenToRecieve,\n            _data.caller,\n            receiveAmount\n        );\n    }\n}"
    },
    {
      "filename": "contracts/WiseLending.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\n/**\n * @author RenÃ© Hochmuth\n * @author Christoph Krpoun\n * @author Vitally Marinchenko\n */\n\nimport \"./PoolManager.sol\";\n\n/**\n * @dev WISE lending is an automated lending platform on which users can collateralize\n * their assets and borrow tokens against them.\n *\n * Users need to pay borrow rates for debt tokens, which are reflected in a borrow APY for\n * each asset type (pool). This borrow rate is variable over time and determined through the\n * utilization of the pool. The bounding curve is a family of different bonding curves adjusted\n * automatically by LASA (Lending Automated Scaling Algorithm). For more information, see:\n * [https://wisesoft.gitbook.io/wise/wise-lending-protocol/lasa-ai]\n *\n * In addition to normal deposit, withdraw, borrow, and payback functions, there are other\n * interacting modes:\n *\n * - Solely deposit and withdraw allows the user to keep their funds private, enabling\n *    them to withdraw even when the pools are borrowed empty.\n *\n * - Aave pools  allow for maximal capital efficiency by earning aave supply APY for not\n *   borrowed funds.\n *\n * - Special curve pools nside beefy farms can be used as collateral, opening up new usage\n *   possibilities for these asset types.\n *\n * - Users can pay back their borrow with lending shares of the same asset type, making it\n *   easier to manage their positions.\n *\n * - Us"
    }
  ]
}