{
  "Title": "[G-14] Sort Solidity operations using short-circuit mode",
  "Content": "\nShort-circuiting is a solidity contract development model that uses ```OR/AND``` logic to sequence different cost operations. It puts low gas cost operations in the front and high gas cost operations in the back, so that if the front is low, if the cost operation is feasible, you can skip (short-circuit) the subsequent high-cost Ethereum virtual machine operation.\n\n```\n//f(x) is a low gas cost operation \n//g(y) is a high gas cost operation \n\n//Sort operations with different gas costs as follows \nf(x) || g(y) \nf(x) && g(y)\n```\n3 results - 3 files:\n```solidity\npackages\\v2-pool\\src\\libraries\\ConstantProduct.sol:\n  298:    if (product.div(longAmount, false) != rate || product >= numerator) revert NotEnoughLiquidityToBorrow();\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/libraries/ConstantProduct.sol#L298\n\n```solidity\npackages\\v2-library\\src\\CatchError.sol:\n  15:     if ((length - 4) % 32 == 0 && bytes4(reason) == selector) return BytesLib.slice(reason, 4, length - 4);\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-library/src/CatchError.sol#L15\n\n```solidity\npackages\\v2-library\\src\\FullMath.sol:\n  68:     if (subtrahend1 > minuend1 || (subtrahend1 == minuend1 && subtrahend0 > minuend0)) revert SubUnderflow(minuend0, minuend1, subtrahend0, subtrahend1);\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-library/src/FullMath.sol#L68\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-01-timeswap",
  "Code": [
    {
      "filename": "packages/v2-pool/src/libraries/ConstantProduct.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\nimport {Math} from \"@timeswap-labs/v2-library/src/Math.sol\";\nimport {FullMath} from \"@timeswap-labs/v2-library/src/FullMath.sol\";\n\nimport {SafeCast} from \"@timeswap-labs/v2-library/src/SafeCast.sol\";\n\nimport {FeeCalculation} from \"./FeeCalculation.sol\";\n\n/// @title Constant Product Library that returns the Constant Product given certain parameters\nlibrary ConstantProduct {\n    using Math for uint256;\n    using SafeCast for uint256;\n\n    /// @dev Reverts when calculation overflows or underflows.\n    error CalculationOverload();\n\n    /// @dev Reverts when there is not enough time value liqudity to receive when lending.\n    error NotEnoughLiquidityToLend();\n\n    /// @dev Reverts when there is not enough principal liquidity to borrow from.\n    error NotEnoughLiquidityToBorrow();\n\n    /// @dev Returns the Long position given liquidity.\n    /// @param liquidity The liquidity given.\n    /// @param rate The pool's squared root Interest Rate.\n    /// @param roundUp Rounds up the result when true. Rounds down the result when false.\n    function getLong(uint160 liquidity, uint160 rate, bool roundUp) internal pure returns (uint256) {\n        return (uint256(liquidity) << 96).div(rate, roundUp);\n    }\n\n    /// @dev Returns the Short position given liquidity.\n    /// @param liquidity The liquidity given.\n    /// @param rate The pool's squared root Interest Rate.\n    /// @param duration The time duration in seconds.\n    /// @param roundUp Rounds up the result when true. Rounds down the result when false.\n    function getShort(uint160 liquidity, uint160 rate, uint96 duration, bool roundUp) internal pure returns (uint256) {\n        return FullMath.mulDiv(uint256(liquidity).unsafeMul(duration), uint256(rate), uint256(1) << 192, roundUp);\n    }\n\n    /// @dev Calculate the amount of long positions in base denomination and short positions from change of liquidity.\n    /// @param rate The pool's squared root Interest Rate.\n    /// @param deltaLiquidity The change in liquidity amount.\n    /// @param duration The time duration in seconds.\n    /// @param isAdd Increase liquidity amount if true. Decrease liquidity amount if false.\n    /// @return longAmount The amount of long positions in base denomination to deposit when increasing liquidity.\n    /// The amount of long positions in base denomination to withdraw when decreasing liquidity.\n    /// @return shortAmount The amount of short positions to deposit when increasing liquidity.\n    /// The amount of short positions to withdraw when decreasing liquidity.\n    function calculateGivenLiquidityDelta(uint160 rate, uint160 deltaLiquidity, uint96 duration, bool isAdd) internal pure returns (uint256 longAmount, uint256 shortAmount) {\n        longAmount = getLong(deltaLiquidity, rate, isAdd);\n\n        shortAmount = getShort(deltaLiquidity, rate, duration, isAdd);\n    }\n\n    /// @dev Calculate the amount of liquidity positions and amount of short positions from given long positions in base denomination.\n    /// @param rate The pool's squared root Interest Rate.\n    /// @param longAmount The amount of long positions.\n    /// @param duration The time duration in seconds.\n    /// @param isAdd Deposit long amount in base denomination if true. Withdraw long amount in base denomination if false.\n    /// @return liquidityAmount The amount of liquidity positions minted when depositing long positions.\n    /// The amount of liquidity positions burnt when withdrawing long positions.\n    /// @return shortAmount The amount of short positions to deposit when depositing long positions.\n    /// The amount of short positions to withdraw when withdrawing long positions.\n    function calculateGivenLiquidityLong(uint160 rate, uint256 longAmount, uint96 duration, bool isAdd) internal pure returns (uint160 liquidityAmount, uint256 shortAmount) {\n        liquidityAmount = getLiquidityGivenLong(rate, longAmount, !isAdd);\n\n        shortAmount = getShort(liquidityAmount, rate, duration, isAdd);\n    }\n\n    /// @dev Calculate the amount of liquidity positions and amount of long positions in base denomination from given short positions.\n    /// @param rate The pool's squared root Interest Rate.\n    /// @param shortAmount The amount of short positions.\n    /// @param duration The time duration in seconds.\n    /// @param isAdd Deposit short amount if true. Withdraw short amount if false.\n    /// @return liquidityAmount The amount of liquidity positions minted when depositing short positions.\n    /// The amount of liquidity positions burnt when withdrawing short positions.\n    /// @return longAmount The amount of long positions in base denomination to deposit when depositing short positions.\n    /// The amount of long positions in base denomination to withdraw when withdrawing short positions.\n    function calculateGivenLiquidityShort(uint160 rate, uint256 shortAmount, uint96 duration, bool isAdd) internal pure returns (uint160 liquidityAmount, uint256 longAmount) {\n        liquidityAmount = getLiquidityGivenShort(rate, shortAmount, duration, !isAdd);\n\n        longAmount = getLong(liquidityAmount, rate, isAdd);\n    }\n\n    /// @dev Calculate the amount of liquidity positions and amount of long positions in base denomination or short position whichever is larger or smaller.\n    /// @param rate The pool's squared root Interest Rate.\n    /// @param amount The amount of long positions in base denomination or short positions whichever is larger.\n    /// @param duration The time duration in seconds.\n    /// @param isAdd Deposit short amount if true. Withdraw short amount if false.\n    /// @return liquidityAmount The amount of liquidity positions minted when depositing short positions.\n    /// The amount of liquidity positions burnt when withdrawing short positions.\n    /// @return longAmount The amount of long positions in base denomination to deposit when depositing short positions.\n    /// The amount of long positions in base denomination to withdraw when withdrawing short positions.\n    /// @return shortAmount The amount of short positions to deposit when depositing long positions.\n    /// The amount of short positions to withdraw when withdrawing long positions.\n    function calculateGivenLiquidityLargerOrSmaller(\n        uint160 rate,\n        uint256 amount,\n        uint96 duration,\n        bool isAdd\n    ) internal pure returns (uint160 liquidityAmount, uint256 longAmount, uint256 shortAmount) {\n        liquidityAmount = getLiquidityGivenLong(rate, amount, !isAdd);\n\n        shortAmount = getShort(liquidityAmount, rate, duration, isAdd);\n\n        if (isAdd ? amount >= shortAmount : amount <= shortAmount) longAmount = amount;\n        else {\n            liquidityAmount = getLiquidityGivenShort(rate, amount, duration, !isAdd);\n\n            longAmount = getLong(liquidityAmount, rate, isAdd);\n\n            shortAmount = amount;\n\n            if (isAdd ? amount < longAmount : amount > longAmount) longAmount = amount;\n        }\n    }\n\n    /// @dev Update the new square root interest rate given change in square root change.\n    /// @param liquidity The amount of liquidity of the pool.\n    /// @param rate The pool's squared root Interest Rate.\n    /// @param deltaRate The change in the squared root Interest Rate.\n    /// @param duration The time duration in seconds.\n    /// @param transactionFee The fee that will be adjusted in the transaction.\n    /// @param isAdd Increase square root interest rate if true. Decrease square root interest rate if false.\n    /// @return newRate The new squared root Interest Rate.\n    /// @return longAmount The amount of long positions in base denomination to withdraw when increasing square root interest rate.\n    /// The amount of long positions in base denomination to deposit when decreasing square root interest rate.\n    /// @return shortAmount The amount of short positions to deposit when increasing square root interest rate.\n    /// The amount of short positions to withdraw when decreasing square root interest rate.\n    /// @return fees The amount of long positions fee in base denominations when increasing square root interest rate.\n    /// The amount of short positions fee when decreasing square root interest rate.\n    function updateGivenSqrtInterestRateDelta(\n        uint160 liquidity,\n        uint160 rate,\n        uint160 deltaRate,\n        uint96 duration,\n        uint256 transactionFee,\n        bool isAdd\n    ) internal pure returns (uint160 newRate, uint256 longAmount, uint256 shortAmount, uint256 fees) {\n        newRate = isAdd ? rate + deltaRate : rate - deltaRate;\n\n        longAmount = getLongFromSqrtInterestRate(liquidity, rate, deltaRate, newRate, !isAdd);\n\n        shortAmount = getShortFromSqrtInterestRate(liquidity, deltaRate, duration, isAdd);\n\n        fees = FeeCalculation.getFeesRemoval(isAdd ? longAmount : shortAmount, transactionFee);\n        if (isAdd) longAmount -= fees;\n        else shortAmount -= fees;\n    }\n\n    /// @dev Update the new square root interest rate given change in long positions in base denomination.\n    /// @param liquidity The amount of liquidity of the pool.\n    /// @param rate The pool's squared root Interest Rate.\n    /// @param longAmount The amount of long positions.\n    /// @param duration The time duration in seconds.\n    /// @param transactionFee The fee that will be adjusted in the transaction.\n    /// @return newRate The new squared root Interest Rate.\n    /// @return shortAmount The amount of short positions to withdraw when depositing long positions in base denomination.\n    /// The amount of short positions to deposit when withdrawing long positions in base denomination.\n    /// @return fees The amount of short positions fee when depositing long positions in base denomination.\n    /// The amount of long positions fee in base denominations fee when withdrawing long positions in base denomination.\n    function updateGivenLong(\n        uint160 liquidity,\n        uint160 rate,\n        uint256 longAmount,\n        uint96 duration,\n        uint256 transactionFee,\n        bool isAdd\n    ) internal pure returns (uint160 newRate, uint256 shortAmount, uint256 fees) {\n        if (!isAdd) fees = FeeCalculation.getFeesAdditional(longAmount, transactionFee);\n\n        newRate = getNewSqrtInterestRateGivenLong(liquidity, rate, longAmount + (isAdd ? 0 : fees), isAdd);\n\n        shortAmount = getShortFromSqrtInterestRate(liquidity, isAdd ? rate - newRate : newRate - rate, duration, !isAdd);\n\n        if (isAdd) {\n            fees = FeeCalculation.getFeesRemoval(shortAmount, transactionFee);\n            shortAmount -= fees;\n        }\n    }\n\n    /// @dev Update the new square root interest rate given change in short positions.\n    /// @param liquidity The amount of liquidity of the pool.\n    /// @param rate The pool's squared root Interest Rate.\n    /// @param shortAmount The amount of short positions.\n    /// @param duration The time duration in seconds.\n    /// @param transactionFee The fee that will be adjusted in the transaction.\n    /// @return newRate The new squared root Interest Rate.\n    /// @return longAmount The amount of long positions in base denomination to withdraw when depositing short positions.\n    /// The amount of long positions in base denomination to deposit when withdrawing short positions.\n    /// @return fees The amount of long positions fee in base denominations when depositing short positions.\n    /// The amount of short positions fee when withdrawing short positions.\n    function updateGivenShort(\n        uint160 liquidity,\n        uint160 rate,\n        uint256 shortAmount,\n        uint96 duration,\n        uint256 transactionFee,\n        bool isAdd\n    ) internal pure returns (uint160 newRate, uint256 longAmount, uint256 fees) {\n        if (!isAdd) fees = FeeCalculation.getFeesAdditional(shortAmount, transactionFee);\n\n        uint160 deltaRate;\n        (newRate, deltaRate) = getNewSqrtInterestRateGivenShort(liquidity, rate, shortAmount + (isAdd ? 0 : fees), duration, isAdd);\n\n        longAmount = getLongFromSqrtInterestRate(liquidity, rate, deltaRate, newRate, !isAdd);\n\n        if (isAdd) {\n            fees = FeeCalculation.getFeesRemoval(longAmount, transactionFee);\n            longAmount -= fees;\n        }\n    }\n\n    /// @dev Update the new square root interest rate given sum of long positions in base denomination change and short position change.\n    /// @param liquidity The amount of liquidity of the pool.\n    /// @param rate The pool's squared root Interest Rate.\n    /// @param sumAmount The sum amount of long positions in base denomination change and short position change.\n    /// @param duration The time duration in seconds.\n    /// @param transactionFee The fee that will be adjusted in the transaction.\n    /// @param isAdd Increase square root interest rate if true. Decrease square root interest rate if false.\n    /// @return newRate The new squared root Interest Rate.\n    /// @return longAmount The amount of long positions in base denomination to withdraw when increasing square root interest rate.\n    /// The amount of long positions in base denomination to deposit when decreasing square root interest rate.\n    /// @return shortAmount The amount of short positions to deposit when increasing square root interest rate.\n    /// The amount of short positions to withdraw when decreasing square root interest rate.\n    /// @return fees The amount of long positions fee in base denominations when increasing square root interest rate.\n    /// The amount of short positions fee when decreasing square root interest rate.\n    function updateGivenSumLong(\n        uint160 liquidity,\n        uint160 rate,\n        uint256 sumAmount,\n        uint96 duration,\n        uint256 transactionFee,\n        bool isAdd\n    ) internal pure returns (uint160 newRate, uint256 longAmount, uint256 shortAmount, uint256 fees) {\n        uint256 amount = getShortOrLongFromGivenSum(liquidity, rate, sumAmount, duration, transactionFee, isAdd);\n\n        if (isAdd) (newRate, ) = getNewSqrtInterestRateGivenShort(liquidity, rate, amount, duration, false);\n        else newRate = getNewSqrtInterestRateGivenLong(liquidity, rate, amount, false);\n\n        fees = FeeCalculation.getFeesRemoval(amount, transactionFee);\n        amount -= fees;\n\n        if (isAdd) {\n            shortAmount = amount;\n            longAmount = sumAmount - shortAmount;\n        } else {\n            longAmount = amount;\n            shortAmount = sumAmount - longAmount;\n        }\n    }\n\n    /// @dev Returns liquidity for a given long.\n    /// @param rate The pool's squared root Interest Rate.\n    /// @param longAmount The amount of long in base denomination change..\n    /// @param roundUp Round up the result when true. Round down the result when false.\n    function getLiquidityGivenLong(uint160 rate, uint256 longAmount, bool roundUp) private pure returns (uint160) {\n        return FullMath.mulDiv(uint256(rate), longAmount, uint256(1) << 96, roundUp).toUint160();\n    }\n\n    /// @dev Returns liquidity for a given short.\n    /// @param rate The pool's squared root Interest Rate.\n    /// @param shortAmount The amount of short change.\n    /// @param duration The time duration in seconds.\n    /// @param roundUp Round up the result when true. Round down the result when false.\n    function getLiquidityGivenShort(uint160 rate, uint256 shortAmount, uint96 duration, bool roundUp) private pure returns (uint160) {\n        return FullMath.mulDiv(shortAmount, uint256(1) << 192, uint256(rate).unsafeMul(duration), roundUp).toUint160();\n    }\n\n    /// @dev Returns the new squared root interest rate given long positions in base denomination change.\n    /// @param liquidity The liquidity of the pool.\n    /// @param rate The pool's squared root Interest Rate.\n    /// @param longAmount The amount long positions in base denomination change.\n    /// @param isAdd Long positions increase when true. Long positions decrease when false.\n    function getNewSqrtInterestRateGivenLong(uint160 liquidity, uint160 rate, uint256 longAmount, bool isAdd) private pure returns (uint160) {\n        uint256 numerator;\n        unchecked {\n            numerator = uint256(liquidity) << 96;\n        }\n\n        uint256 product = longAmount.unsafeMul(rate);\n\n        if (isAdd) {\n            if (product.div(longAmount, false) == rate) {\n                uint256 denominator = numerator + product;\n                if (denominator >= numerator) {\n                    return FullMath.mulDiv(numerator, rate, denominator, true).toUint160();\n                }\n            }\n\n            uint256 denominator2 = numerator.div(rate, false);\n\n            denominator2 += longAmount;\n            return numerator.div(denominator2, true).toUint160();\n        } else {\n            if (product.div(longAmount, false) != rate || product >= numerator) revert NotEnoughLiquidityToBorrow();\n\n            uint256 denominator = numerator.unsafeSub(product);\n            return (FullMath.mulDiv(numerator, rate, denominator, true)).toUint160();\n        }\n    }\n\n    /// @dev Returns the new squared root interest rate given short position change.\n    /// @param liquidity The liquidity of the pool.\n    /// @param rate The pool's squared root Interest Rate.\n    /// @param shortAmount The amount short positions change.\n    /// @param duration The time duration in seconds.\n    /// @param isAdd Short positions increase when true. Short positions decrease when false.\n    /// @return newRate The updated squared interest rate\n    /// @return deltaRate The difference between the new and old squared interest rate\n    function getNewSqrtInterestRateGivenShort(uint160 liquidity, uint160 rate, uint256 shortAmount, uint96 duration, bool isAdd) private pure returns (uint160 newRate, uint160 deltaRate) {\n        uint256 denominator = uint256(liquidity).unsafeMul(duration);\n\n        deltaRate = FullMath.mulDiv(shortAmount, uint256(1) << 192, denominator, !isAdd).toUint160();\n\n        if (isAdd) newRate = rate + deltaRate;\n        else if (rate > deltaRate) newRate = rate - deltaRate;\n        else revert NotEnoughLiquidityToLend();\n    }\n\n    /// @dev Returns the long positions for a given interest rate.\n    /// @param liquidity The liquidity of the pool.\n    /// @param rate The pool's squared root Interest Rate.\n    /// @param deltaRate The pool's delta rate in square root interest rate.\n    /// @param newRate The new interest rate of the pool\n    /// @param roundUp Increases in square root interest rate when true. Decrease in square root interest rate when false.\n    function getLongFromSqrtInterestRate(uint160 liquidity, uint160 rate, uint160 deltaRate, uint160 newRate, bool roundUp) private pure returns (uint256) {\n        uint256 numerator;\n        unchecked {\n            numerator = uint256(liquidity) << 96;\n        }\n        return roundUp ? FullMath.mulDiv(numerator, deltaRate, uint256(rate), true).div(newRate, true) : FullMath.mulDiv(numerator, deltaRate, uint256(newRate), false).div(rate, false);\n    }\n\n    /// @dev Returns the short positions for a given interest rate.\n    /// @param liquidity The liquidity of the pool.\n    /// @param deltaRate The pool's delta rate in square root interest rate.\n    /// @param duration The time duration in seconds.\n    /// @param roundUp Increases in square root interest rate when true. Decrease in square root interest rate when false.\n    function getShortFromSqrtInterestRate(uint160 liquidity, uint160 deltaRate, uint96 duration, bool roundUp) private pure returns (uint256) {\n        uint256 numerator = uint256(liquidity).unsafeMul(duration);\n        return FullMath.mulDiv(uint256(numerator), uint256(deltaRate), uint256(1) << 192, roundUp);\n    }\n\n    /// @dev Get the short amount or long amount for given sum type transactions.\n    /// @param liquidity The liquidity of the pool.\n    /// @param rate The pool's squared root Interest Rate.\n    /// @param sumAmount The given sum amount.\n    /// @param duration The duration of the pool.\n    /// @param transactionFee The transaction fee of the pool.\n    /// @param isShort True if to calculate for short amount.\n    /// False if to calculate for long amount.\n    /// @return amount The short amount or long amount calculated.\n    function getShortOrLongFromGivenSum(uint160 liquidity, uint160 rate, uint256 sumAmount, uint96 duration, uint256 transactionFee, bool isShort) private pure returns (uint256 amount) {\n        uint256 negativeB = calculateNegativeB(liquidity, rate, sumAmount, duration, transactionFee, isShort);\n\n        uint256 sqrtDiscriminant = calculateSqrtDiscriminant(liquidity, rate, sumAmount, duration, transactionFee, negativeB, isShort);\n\n        amount = (negativeB - sqrtDiscriminant).shr(1, false);\n    }\n\n    /// @dev Calculate the negativeB.\n    /// @param liquidity The liquidity of the pool.\n    /// @param rate The pool's squared root Interest Rate.\n    /// @param sumAmount The given sum amount.\n    /// @param duration The duration of the pool.\n    /// @param transactionFee The transaction fee of the pool.\n    /// @param isShort True if to calculate for short amount.\n    /// False if to calculate for long amount.\n    /// @return negativeB The negative B calculated.\n    function calculateNegativeB(uint160 liquidity, uint160 rate, uint256 sumAmount, uint96 duration, uint256 transactionFee, bool isShort) private pure returns (uint256 negativeB) {\n        uint256 adjustment = (uint256(1) << 16).unsafeSub(transactionFee);\n\n        uint256 negativeB0 = isShort ? getShort(liquidity, rate, duration, false) : getLong(liquidity, rate, false);\n        uint256 negativeB1 = isShort\n            ? FullMath.mulDiv(liquidity, uint256(1) << 112, uint256(rate).unsafeMul(adjustment), false)\n            : FullMath.mulDiv(uint256(liquidity).unsafeMul(duration), rate, (uint256(1) << 176).unsafeMul(adjustment), false);\n        uint256 negativeB2 = FullMath.mulDiv(sumAmount, uint256(1) << 16, adjustment, false);\n\n        negativeB = negativeB0 + negativeB1 + negativeB2;\n    }\n\n    /// Dev Calculate the square root discriminant.\n    /// @param liquidity The liquidity of the pool.\n    /// @param rate The pool's squared root Interest Rate.\n    /// @param sumAmount The given sum amount.\n    /// @param duration The duration of the pool.\n    /// @param transactionFee The transaction fee of the pool.\n    /// @param negativeB The negative B calculated.\n    /// @param isShort True if to calculate for short amount.\n    /// False if to calculate for long amount.\n    /// @return sqrtDiscriminant The square root disriminant calculated.\n    function calculateSqrtDiscriminant(\n        uint160 liquidity,\n        uint160 rate,\n        uint256 sumAmount,\n        uint96 duration,\n        uint256 transactionFee,\n        uint256 negativeB,\n        bool isShort\n    ) private pure returns (uint256 sqrtDiscriminant) {\n        uint256 denominator = isShort ? (uint256(1) << 174).unsafeMul((uint256(1) << 16).unsafeSub(transactionFee)) : uint256(rate).unsafeMul((uint256(1) << 16).unsafeSub(transactionFee));\n\n        (uint256 a0, uint256 a1) = isShort ? FullMath.mul512(uint256(liquidity).unsafeMul(duration), rate) : FullMath.mul512(liquidity, uint256(1) << 114);\n\n        (uint256 a00, uint256 a01) = FullMath.mul512(a0, sumAmount);\n        (uint256 a10, uint256 a11) = FullMath.mul512(a1, sumAmount);\n\n        if (a11 == 0 && a01.unsafeAdd(a10) >= a01) {\n            a0 = a00;\n            a1 = a01.unsafeAdd(a10);\n            (a0, a1) = FullMath.div512(a0, a1, denominator, false);\n        } else {\n            (a0, a1) = FullMath.div512(a0, a1, denominator, false);\n\n            (a00, a01) = FullMath.mul512(a0, sumAmount);\n            (a10, a11) = FullMath.mul512(a1, sumAmount);\n\n            if (a11 != 0 || a01.unsafeAdd(a10) < a01) revert CalculationOverload();\n            a0 = a00;\n            a1 = a01.unsafeAdd(a10);\n        }\n\n        (uint256 b0, uint256 b1) = FullMath.mul512(negativeB, negativeB);\n\n        (b0, b1) = FullMath.sub512(b0, b1, a0, a1);\n\n        sqrtDiscriminant = FullMath.sqrt512(b0, b1, true);\n    }\n}"
    },
    {
      "filename": "packages/v2-library/src/CatchError.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\nimport {BytesLib} from \"./BytesLib.sol\";\n\nlibrary CatchError {\n    /// @dev Get the data passed from a given custom error.\n    /// @dev It checks that the first four bytes of the reason has the same selector.\n    /// @notice Will simply revert with the original error if the first four bytes is not the given selector.\n    /// @param reason The data being inquired upon.\n    /// @param selector The given conditional selector.\n    function catchError(bytes memory reason, bytes4 selector) internal pure returns (bytes memory) {\n        uint256 length = reason.length;\n\n        if ((length - 4) % 32 == 0 && bytes4(reason) == selector) return BytesLib.slice(reason, 4, length - 4);\n\n        assembly {\n            revert(reason, length)\n        }\n    }\n}"
    },
    {
      "filename": "packages/v2-library/src/FullMath.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\nimport {Math} from \"./Math.sol\";\n\nlibrary FullMath {\n    using Math for uint256;\n\n    /// @dev Reverts when modulo by zero.\n    error ModuloByZero();\n\n    /// @dev Reverts when add512 overflows over uint512.\n    /// @param addendA0 The least significant part of first addend.\n    /// @param addendA1 The most significant part of first addend.\n    /// @param addendB0 The least significant part of second addend.\n    /// @param addendB1 The most significant part of second addend.\n    error AddOverflow(uint256 addendA0, uint256 addendA1, uint256 addendB0, uint256 addendB1);\n\n    /// @dev Reverts when sub512 underflows.\n    /// @param minuend0 The least significant part of minuend.\n    /// @param minuend1 The most significant part of minuend.\n    /// @param subtrahend0 The least significant part of subtrahend.\n    /// @param subtrahend1 The most significant part of subtrahend.\n    error SubUnderflow(uint256 minuend0, uint256 minuend1, uint256 subtrahend0, uint256 subtrahend1);\n\n    /// @dev Reverts when div512To256 overflows over uint256.\n    /// @param dividend0 The least significant part of dividend.\n    /// @param dividend1 The most significant part of dividend.\n    /// @param divisor The divisor.\n    error DivOverflow(uint256 dividend0, uint256 dividend1, uint256 divisor);\n\n    /// @dev Reverts when mulDiv overflows over uint256.\n    /// @param multiplicand The multiplicand.\n    /// @param multiplier The multiplier.\n    /// @param divisor The divisor.\n    error MulDivOverflow(uint256 multiplicand, uint256 multiplier, uint256 divisor);\n\n    /// @dev Calculates the sum of two uint512 numbers.\n    /// @notice Reverts on overflow over uint512.\n    /// @param addendA0 The least signficant part of addendA.\n    /// @param addendA1 The most significant part of addendA.\n    /// @param addendB0 The least significant part of addendB.\n    /// @param addendB1 The most significant part of addendB.\n    /// @return sum0 The least significant part of sum.\n    /// @return sum1 The most significant part of sum.\n    function add512(uint256 addendA0, uint256 addendA1, uint256 addendB0, uint256 addendB1) internal pure returns (uint256 sum0, uint256 sum1) {\n        assembly {\n            sum0 := add(addendA0, addendB0)\n            sum1 := add(add(addendA1, addendB1), lt(sum0, addendA0))\n        }\n        if (addendA1 > sum1) revert AddOverflow(addendA0, addendA1, addendB0, addendB1);\n    }\n\n    /// @dev Calculates the difference of two uint512 numbers.\n    /// @notice Reverts on underflow.\n    /// @param minuend0 The least significant part of minuend.\n    /// @param minuend1 The most significant part of minuend.\n    /// @param subtrahend0 The least significant part of subtrahend.\n    /// @param subtrahend1 The most significant part of subtrahend.\n    /// @return difference0 The least significant part of difference.\n    /// @return difference1 The most significant part of difference.\n    function sub512(uint256 minuend0, uint256 minuend1, uint256 subtrahend0, uint256 subtrahend1) internal pure returns (uint256 difference0, uint256 difference1) {\n        assembly {\n            difference0 := sub(minuend0, subtrahend0)\n            difference1 := sub(sub(minuend1, subtrahend1), lt(minuend0, subtrahend0))\n        }\n\n        if (subtrahend1 > minuend1 || (subtrahend1 == minuend1 && subtrahend0 > minuend0)) revert SubUnderflow(minuend0, minuend1, subtrahend0, subtrahend1);\n    }\n\n    /// @dev Calculate the product of two uint256 numbers that may result to uint512 product.\n    /// @notice Can never overflow.\n    /// @param multiplicand The multiplicand.\n    /// @param multiplier The multiplier.\n    /// @return product0 The least significant part of product.\n    /// @return product1 The most significant part of product.\n    function mul512(uint256 multiplicand, uint256 multiplier) internal pure returns (uint256 product0, uint256 product1) {\n        assembly {\n            let mm := mulmod(multiplicand, multiplier, not(0))\n            product0 := mul(multiplicand, multiplier)\n            product1 := sub(sub(mm, product0), lt(mm, product0))\n        }\n    }\n\n    /// @dev Divide 2 to 256 power by the divisor.\n    /// @dev Rounds down the result.\n    /// @notice Reverts when divide by zero.\n    /// @param divisor The divisor.\n    /// @return quotient The quotient.\n    function div256(uint256 divisor) private pure returns (uint256 quotient) {\n        if (divisor == 0) revert Math.DivideByZero();\n        assembly {\n            quotient := add(div(sub(0, divisor), divisor), 1)\n        }\n    }\n\n    /// @dev Compute 2 to 256 power modulo the given value.\n    /// @notice Reverts when modulo by zero.\n    /// @param value The given value.\n    /// @return result The result.\n    function mod256(uint256 value) private pure returns (uint256 result) {\n        if (value == 0) revert ModuloByZero();\n        assembly {\n            result := mod(sub(0, value), value)\n        }\n    }\n\n    /// @dev Divide a uint512 number by uint256 number to return a uint512 number.\n    /// @dev Rounds down the result.\n    /// @param dividend0 The least significant part of dividend.\n    /// @param dividend1 The most significant part of dividend.\n    /// @param divisor The divisor.\n    /// @param quotient0 The least significant part of quotient.\n    /// @param quotient1 The most significant part of quotient.\n    function div512(uint256 dividend0, uint256 dividend1, uint256 divisor) private pure returns (uint256 quotient0, uint256 quotient1) {\n        if (dividend1 == 0) quotient0 = dividend0.div(divisor, false);\n        else {\n            uint256 q = div256(divisor);\n            uint256 r = mod256(divisor);\n            while (dividend1 != 0) {\n                (uint256 t0, uint256 t1) = mul512(dividend1, q);\n                (quotient0, quotient1) = add512(quotient0, quotient1, t0, t1);\n                (t0, t1) = mul512(dividend1, r);\n                (dividend0, dividend1) = add512(t0, t1, dividend0, 0);\n            }\n            (quotient0, quotient1) = add512(quotient0, quotient1, dividend0.div(divisor, false), 0);\n        }\n    }\n\n    /// @dev Divide a uint512 number by a uint256 number.\n    /// @dev Reverts when result is greater than uint256.\n    /// @notice Skips div512 if dividend1 is zero.\n    /// @param dividend0 The least significant part of dividend.\n    /// @param dividend1 The most significant part of dividend.\n    /// @param divisor The divisor.\n    /// @param roundUp Round up the result when true. Round down if false.\n    /// @param quotient The quotient.\n    function div512To256(uint256 dividend0, uint256 dividend1, uint256 divisor, bool roundUp) internal pure returns (uint256 quotient) {\n        uint256 quotient1;\n        (quotient, quotient1) = div512(dividend0, dividend1, divisor);\n\n        if (quotient1 != 0) revert DivOverflow(dividend0, dividend1, divisor);\n\n        if (roundUp) {\n            (uint256 productA0, uint256 productA1) = mul512(quotient, divisor);\n            if (dividend1 > productA1 || dividend0 > productA0) quotient++;\n        }\n    }\n\n    /// @dev Divide a uint512 number by a uint256 number.\n    /// @notice Skips div512 if dividend1 is zero.\n    /// @param dividend0 The least significant part of dividend.\n    /// @param dividend1 The most significant part of dividend.\n    /// @param divisor The divisor.\n    /// @param roundUp Round up the result when true. Round down if false.\n    /// @param quotient0 The least significant part of quotient.\n    /// @param quotient1 The most significant part of quotient.\n    function div512(uint256 dividend0, uint256 dividend1, uint256 divisor, bool roundUp) internal pure returns (uint256 quotient0, uint256 quotie"
    }
  ]
}