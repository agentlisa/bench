{
  "Title": "[G-05] Multiple accesses of a mapping/array should use a storage pointer",
  "Content": "\nCaching a mapping's value in a storage pointer when the value is accessed multiple times saves ~40 gas per access due to not having to perform the same offset calculation every time. Help the Optimizer by saving a storage variable's reference instead of repeatedly fetching it.\n\nTo achieve this, declare a storage pointer for the variable and use it instead of repeatedly fetching the reference in a map or an array. As an example, instead of repeatedly calling `_stakerS1Position[_staker]`, save its reference via a storage pointer: `uint256[] storage s1Array = _stakerS1Position[_staker]` and use the pointer instead.\n\nTotal instances: 25\n\nGas savings: `25 * 40 = 1000`\n\n**Gas savings will actually be greater since storage slot offset calculation is occuring within loops in some instances**\n\nhttps://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L715-L744\n\n### Cache storage pointers for `_stakerS1Position[_staker]`, `_stakerS2Position[_staker]`, `stakedS1[_staker]`, and `stakedS2[_staker]`.\n\n*More gas would actually be saved since storage slot offset calculation is occuring within a loop.*\n```solidity\nFile: contracts/staking/NeoTokyoStaker.sol\n715:\t\tStakedS1CitizenOutput[] memory stakedS1Details =\n716:\t\t\tnew StakedS1CitizenOutput[](_stakerS1Position[_staker].length); // @audit: 1st access\n717:\t\tfor (uint256 i; i < _stakerS1Position[_staker].length; ) { // @audit: 2nd access + on every iteration\n718:\t\t\tuint256 citizenId = _stakerS1Position[_staker][i]; // @audit: 3rd access + on every iteration\n719:\t\t\tStakedS1Citizen memory citizenDetails = stakedS1[_staker][citizenId]; // @audit: accessed on every iteration\n720:\t\t\tstakedS1Details[i] = StakedS1CitizenOutput({\n721:\t\t\t\tcitizenId: citizenId,\n722:\t\t\t\tstakedBytes: citizenDetails.stakedBytes,\n723:\t\t\t\ttimelockEndTime: citizenDetails.timelockEndTime,\n724:\t\t\t\tpoints: citizenDetails.points,\n725:\t\t\t\thasVault: citizenDetails.hasVault,\n726:\t\t\t\tstakedVaultId: citizenDetails.stakedVaultId\n727:\t\t\t});\n728:\t\t\tunchecked { i++; }\n729:\t\t}\n730:\n731:\t\t// Compile the S2 Citizen details.\n732:\t\tStakedS2CitizenOutput[] memory stakedS2Details =\n733:\t\t\tnew StakedS2CitizenOutput[](_stakerS2Position[_staker].length); // @audit: 1st access\n734:\t\tfor (uint256 i; i < _stakerS2Position[_staker].length; ) { // @audit: 2nd access + on every iteration\n735:\t\t\tuint256 citizenId = _stakerS2Position[_staker][i]; // @audit: 3rd access + on every iteration\n736:\t\t\tStakedS2Citizen memory citizenDetails = stakedS2[_staker][citizenId]; // @audit: accessed on every iteration\n737:\t\t\tstakedS2Details[i] = StakedS2CitizenOutput({\n738:\t\t\t\tcitizenId: citizenId,\n739:\t\t\t\tstakedBytes: citizenDetails.stakedBytes,\n740:\t\t\t\ttimelockEndTime: citizenDetails.timelockEndTime,\n741:\t\t\t\tpoints: citizenDetails.points\n742:\t\t\t});\n743:\t\t\tunchecked { i++; }\n744:\t\t}\n```\n```diff\ndiff --git a/contracts/staking/NeoTokyoStaker.sol b/contracts/staking/NeoTokyoStaker.sol\nindex a54d218..e078701 100644\n--- a/contracts/staking/NeoTokyoStaker.sol\n+++ b/contracts/staking/NeoTokyoStaker.sol\n@@ -712,11 +712,13 @@ contract NeoTokyoStaker is PermitControl, ReentrancyGuard {\n        ) external view returns (StakerPosition memory) {\n\n                // Compile the S1 Citizen details.\n+               uint256[] storage s1Array = _stakerS1Position[_staker];\n+               mapping (uint256 => StakedS1Citizen) storage s1CitizenMap = stakedS1[_staker];\n                StakedS1CitizenOutput[] memory stakedS1Details =\n-                       new StakedS1CitizenOutput[](_stakerS1Position[_staker].length);\n-               for (uint256 i; i < _stakerS1Position[_staker].length; ) {\n-                       uint256 citizenId = _stakerS1Position[_staker][i];\n-                       StakedS1Citizen memory citizenDetails = stakedS1[_staker][citizenId];\n+                       new StakedS1CitizenOutput[](s1Array.length);\n+               for (uint256 i; i < s1Array.length; ) {\n+                       uint256 citizenId = s1Array[i];\n+                       StakedS1Citizen memory citizenDetails = s1CitizenMap[citizenId];\n                        stakedS1Details[i] = StakedS1CitizenOutput({\n                                citizenId: citizenId,\n                                stakedBytes: citizenDetails.stakedBytes,\n@@ -729,11 +731,13 @@ contract NeoTokyoStaker is PermitControl, ReentrancyGuard {\n                }\n\n                // Compile the S2 Citizen details.\n+               uint256[] storage s2Array = _stakerS2Position[_staker];\n+               mapping (uint256 => StakedS2Citizen) storage s2CitizenMap = stakedS2[_staker];\n                StakedS2CitizenOutput[] memory stakedS2Details =\n-                       new StakedS2CitizenOutput[](_stakerS2Position[_staker].length);\n-               for (uint256 i; i < _stakerS2Position[_staker].length; ) {\n-                       uint256 citizenId = _stakerS2Position[_staker][i];\n-                       StakedS2Citizen memory citizenDetails = stakedS2[_staker][citizenId];\n+                       new StakedS2CitizenOutput[](s2Array.length);\n+               for (uint256 i; i < s2Array.length; ) {\n+                       uint256 citizenId = s2Array[i];\n+                       StakedS2Citizen memory citizenDetails = s2CitizenMap[citizenId];\n                        stakedS2Details[i] = StakedS2CitizenOutput({\n                                citizenId: citizenId,\n                                stakedBytes: citizenDetails.stakedBytes,\n```\n\nhttps://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L1144-L1165\n\n### Cache storage pointer for `stakerLPPosition[msg.sender]`.\n```solidity\nFile: contracts/staking/NeoTokyoStaker.sol\n1144:\t\tif (stakerLPPosition[msg.sender].multiplier == 0) { // @audit: 1st access\n1145:\t\t\tstakerLPPosition[msg.sender].multiplier = timelockMultiplier; // @audit: 2nd access\n1146:\n1147:\t\t// If a multiplier exists already, we must match it.\n1148:\t\t} else if (stakerLPPosition[msg.sender].multiplier != timelockMultiplier) { // @audit: 3rd access\n1149:\t\t\trevert MismatchedTimelock();\n1150:\t\t}\n1151:\n1152:\t\t// Update caller staking information and asset data.\n1153:\t\tPoolData storage pool = _pools[AssetType.LP];\n1154:\t\tunchecked {\n1155:\t\t\tuint256 points = amount * 100 / 1e18 * timelockMultiplier / _DIVISOR;\n1156:\n1157:\t\t\t// Update the caller's LP token stake.\n1158:\t\t\tstakerLPPosition[msg.sender].timelockEndTime = // @audit: 4th access\n1159:\t\t\t\tblock.timestamp + timelockDuration;\n1160:\t\t\tstakerLPPosition[msg.sender].amount += amount; // @audit: 5th & 6th access\n1161:\t\t\tstakerLPPosition[msg.sender].points += points; // @audit: 7th & 8th access\n1162:\n1163:\t\t\t// Update the pool point weights for rewards.\n1164:\t\t\tpool.totalPoints += points;\n1165:\t\t}\n```\n```diff\ndiff --git a/contracts/staking/NeoTokyoStaker.sol b/contracts/staking/NeoTokyoStaker.sol\nindex a54d218..7993a96 100644\n--- a/contracts/staking/NeoTokyoStaker.sol\n+++ b/contracts/staking/NeoTokyoStaker.sol\n@@ -1141,11 +1141,12 @@ contract NeoTokyoStaker is PermitControl, ReentrancyGuard {\n                uint256 timelockMultiplier = _timelock & type(uint128).max;\n\n                // If this is a new stake of this asset, initialize the multiplier details.\n-               if (stakerLPPosition[msg.sender].multiplier == 0) {\n-                       stakerLPPosition[msg.sender].multiplier = timelockMultiplier;\n+               LPPosition storage stakerPosition = stakerLPPosition[msg.sender];\n+               if (stakerPosition.multiplier == 0) {\n+                       stakerPosition.multiplier = timelockMultiplier;\n\n                // If a multiplier exists already, we must match it.\n-               } else if (stakerLPPosition[msg.sender].multiplier != timelockMultiplier) {\n+               } else if (stakerPosition.multiplier != timelockMultiplier) {\n                        revert MismatchedTimelock();\n                }\n\n@@ -1155,10 +1156,10 @@ contract NeoTokyoStaker is PermitControl, ReentrancyGuard {\n                        uint256 points = amount * 100 / 1e18 * timelockMultiplier / _DIVISOR;\n\n                        // Update the caller's LP token stake.\n-                       stakerLPPosition[msg.sender].timelockEndTime =\n+                       stakerPosition.timelockEndTime =\n                                block.timestamp + timelockDuration;\n-                       stakerLPPosition[msg.sender].amount += amount;\n-                       stakerLPPosition[msg.sender].points += points;\n+                       stakerPosition.amount += amount;\n+                       stakerPosition.points += points;\n\n                        // Update the pool point weights for rewards.\n                        pool.totalPoints += points;\n```\n\nhttps://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L1210-L1217\n\n### Cache storage pointer for `_pools[_assetType]`.\n```solidity\nFile: contracts/staking/NeoTokyoStaker.sol\n1210:\t\tif (_pools[_assetType].rewardCount == 0) { // @audit: 1st access\n1211:\t\t\trevert UnconfiguredPool(uint256(_assetType));\n1212:\t\t}\n1213:\n1214:\t\t// Validate that the asset being staked matches an active pool.\n1215:\t\tif (_pools[_assetType].rewardWindows[0].startTime >= block.timestamp) { // @audit: 2nd access\n1216:\t\t\trevert InactivePool(uint256(_assetType));\n1217:\t\t}\n```\n```diff\ndiff --git a/contracts/staking/NeoTokyoStaker.sol b/contracts/staking/NeoTokyoStaker.sol\nindex a54d218..b81a227 100644\n--- a/contracts/staking/NeoTokyoStaker.sol\n+++ b/contracts/staking/NeoTokyoStaker.sol\n@@ -1207,12 +1207,13 @@ contract NeoTokyoStaker is PermitControl, ReentrancyGuard {\n                }\n\n                // Validate that the asset being staked matches a configured pool.\n-               if (_pools[_assetType].rewardCount == 0) {\n+               PoolData storage pool = _pools[_assetType];\n+               if (pool.rewardCount == 0) {\n                        revert UnconfiguredPool(uint256(_assetType));\n                }\n\n                // Validate that the asset being staked matches an active pool.\n-               if (_pools[_assetType].rewardWindows[0].startTime >= block.timestamp) {\n+               if (pool.rewardWindows[0].startTime >= block.timestamp) {\n                        revert InactivePool(uint256(_assetType));\n                }\n```\n\nhttps://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L1277-L1368\n\n### Cache storage pointers for `_stakerS1Position[_recipient]`, `_stakerS2Position[_recipient]`, `stakedS1[_recipient]`, `stakedS2[_recipient]`, and `pool.rewardWindows`.\n\n*More gas would actually be saved since storage slot offset calculation is occuring within a loop.*\n```solidity\nFile: contracts/staking/NeoTokyoStaker.sol\n1277:\t\t\tuint256 points;\n1278:\t\t\tif (_assetType == AssetType.S1_CITIZEN) {\n1279:\t\t\t\tfor (uint256 i; i < _stakerS1Position[_recipient].length; ) { // @audit: 1st access + on every iteration\n1280:\t\t\t\t\tuint256 citizenId = _stakerS1Position[_recipient][i]; // @audit: 2nd access + on every iteration\n1281:\t\t\t\t\tStakedS1Citizen memory s1Citizen = stakedS1[_recipient][citizenId]; // @audit: accessed on every iteration\n1282:\t\t\t\t\tunchecked {\n1283:\t\t\t\t\t\tpoints += s1Citizen.points;\n1284:\t\t\t\t\t\ti++;\n1285:\t\t\t\t\t}\n1286:\t\t\t\t}\n1287:\t\t\t} else if (_assetType == AssetType.S2_CITIZEN) {\n1288:\t\t\t\tfor (uint256 i; i < _stakerS2Position[_recipient].length; ) { // @audit: 1st access + on every iteration\n1289:\t\t\t\t\tuint256 citizenId = _stakerS2Position[_recipient][i]; // @audit: 2nd access + on every iteration\n1290:\t\t\t\t\tStakedS2Citizen memory s2Citizen = stakedS2[_recipient][citizenId]; // @audit: accessed on every iteration\n1291:\t\t\t\t\tunchecked {\n1292:\t\t\t\t\t\tpoints += s2Citizen.points;\n1293:\t\t\t\t\t\ti++;\n1294:\t\t\t\t\t}\n1295:\t\t\t\t}\n1296:\t\t\t} else if (_assetType == AssetType.LP) {\n1297:\t\t\t\tunchecked {\n1298:\t\t\t\t\tpoints += stakerLPPosition[_recipient].points;\n1299:\t\t\t\t}\n1300:\t\t\t} else {\n1301:\t\t\t\trevert InvalidAssetType(uint256(_assetType));\n1302:\t\t\t}\n1303:\n1304:\t\t\t/*\n1305:\t\t\t\tDetermine the reward for the `_recipient` based on their points total. \n1306:\t\t\t\tIterate through the entire array of pool reward windows to find the \n1307:\t\t\t\tapplicable time period.\n1308:\t\t\t*/\n1309:\t\t\tuint256 totalReward;\n1310:\t\t\tuint256 lastPoolRewardTime = lastRewardTime[_recipient][_assetType];\n1311:\t\t\tuint256 windowCount = pool.rewardCount;\n1312:\t\t\tfor (uint256 i; i < windowCount; ) {\n1314:\t\t\t\tRewardWindow memory window = pool.rewardWindows[i]; // @audit: 1st access + on every iteration\n1315:\n1316:\t\t\t\t/*\n1317:\t\t\t\t\tIf the last reward time is less than the starting time of this \n1318:\t\t\t\t\twindow, then the reward was accrued in the previous window.\n1319:\t\t\t\t*/\n1320:\t\t\t\tif (lastPoolRewardTime < window.startTime) {\n1321:\t\t\t\t\tuint256 currentRewardRate = pool.rewardWindows[i - 1].reward; // @audit: 2nd access + on every iteration\n1322:\n1323:\t\t\t\t\t/*\n1324:\t\t\t\t\t\tIterate forward to the present timestamp over any unclaimed reward \n1325:\t\t\t\t\t\twindows.\n1326:\t\t\t\t\t*/\n1327:\t\t\t\t\tfor (uint256 j = i; j < windowCount; ) {\n1328:\n1329:\t\t\t\t\t\t// If the current time falls within this window, complete.\n1330:\t\t\t\t\t\tif (block.timestamp <= window.startTime) {\n1331:\t\t\t\t\t\t\tunchecked {\n1332:\t\t\t\t\t\t\t\tuint256 timeSinceReward = block.timestamp - lastPoolRewardTime;\n1333:\t\t\t\t\t\t\t\ttotalReward += currentRewardRate * timeSinceReward;\t\n1334:\t\t\t\t\t\t\t}\n1335:\n1336:\t\t\t\t\t\t\t// We have no forward goto and thus include this bastardry.\n1337:\t\t\t\t\t\t\ti = windowCount;\n1338:\t\t\t\t\t\t\tbreak;\n1339:\n1340:\t\t\t\t\t\t// Otherwise, accrue the remainder of this window and iterate.\n1341:\t\t\t\t\t\t} else {\n1342:\t\t\t\t\t\t\tunchecked {\n1343:\t\t\t\t\t\t\t\tuint256 timeSinceReward = window.startTime - lastPoolRewardTime;\n1344:\t\t\t\t\t\t\t\ttotalReward += currentRewardRate * timeSinceReward;\n1345:\t\t\t\t\t\t\t}\n1346:\t\t\t\t\t\t\tcurrentRewardRate = window.reward;\n1347:\t\t\t\t\t\t\tlastPoolRewardTime = window.startTime;\n1348:\n1349:\t\t\t\t\t\t\t/*\n1350:\t\t\t\t\t\t\t\tHandle the special case of overrunning the final window by \n1351:\t\t\t\t\t\t\t\tfulfilling the prior window and then jumping forward to use the \n1352:\t\t\t\t\t\t\t\tfinal reward window.\n1353:\t\t\t\t\t\t\t*/\n1354:\t\t\t\t\t\t\tif (j == windowCount - 1) {\n1355:\t\t\t\t\t\t\t\tunchecked {\n1356:\t\t\t\t\t\t\t\t\tuint256 timeSinceReward =\n1357:\t\t\t\t\t\t\t\t\t\tblock.timestamp - lastPoolRewardTime;\n1358:\t\t\t\t\t\t\t\t\ttotalReward += currentRewardRate * timeSinceReward;\n1359:\t\t\t\t\t\t\t\t}\n1360:\t\n1361:\t\t\t\t\t\t\t\t// We have no forward goto and thus include this bastardry.\n1362:\t\t\t\t\t\t\t\ti = windowCount;\n1363:\t\t\t\t\t\t\t\tbreak;\n1364:\t\n1365:\t\t\t\t\t\t\t// Otherwise, iterate.\n1366:\t\t\t\t\t\t\t} else {\n1367:\t\t\t\t\t\t\t\twindow = pool.rewardWindows[j + 1]; // @audit: 3rd access + on every iteration\n1368:\t\t\t\t\t\t\t}\n1369:\t\t\t\t\t\t}\n```\n```diff\ndiff --git a/contracts/staking/NeoTokyoStaker.sol b/contracts/staking/NeoTokyoStaker.sol\nindex a54d218..0a58815 100644\n--- a/contracts/staking/NeoTokyoStaker.sol\n+++ b/contracts/staking/NeoTokyoStaker.sol\n@@ -1276,18 +1276,22 @@ contract NeoTokyoStaker is PermitControl, ReentrancyGuard {\n                        // Calculate the total number of points accrued to the `_recipient`.\n                        uint256 points;\n                        if (_assetType == AssetType.S1_CITIZEN) {\n-                               for (uint256 i; i < _stakerS1Position[_recipient].length; ) {\n-                                       uint256 citizenId = _stakerS1Position[_recipient][i];\n-                                       StakedS1Citizen memory s1Citizen = stakedS1[_recipient][citizenId];\n+                               uint256[] storage s1Array = _stakerS1Position[_recipient];\n+                               mapping (uint256 => StakedS1Citizen) storage s1CitizenMap = stakedS1[_recipient];\n+                               for (uint256 i; i < s1Array.length; ) {\n+                                       uint256 citizenId = s1Array[i];\n+                                       StakedS1Citizen memory s1Citizen = s1CitizenMap[citizenId];\n                                        unchecked {\n                                                points += s1Citizen.points;\n                                                i++;\n                                        }\n                                }\n                        } else if (_assetType == AssetType.S2_CITIZEN) {\n-                               for (uint256 i; i < _stakerS2Position[_recipient].length; ) {\n-                                       uint256 citizenId = _stakerS2Position[_recipient][i];\n-                                       StakedS2Citizen memory s2Citizen = stakedS2[_recipient][citizenId];\n+                               uint256[] storage s2Array = _stakerS2Position[_recipient];\n+                               mapping (uint256 => StakedS2Citizen) storage s2CitizenMap = stakedS2[_recipient];\n+                               for (uint256 i; i < s2Array.length; ) {\n+                                       uint256 citizenId = s2Array[i];\n+                                       StakedS2Citizen memory s2Citizen = s2CitizenMap[citizenId];\n                                        unchecked {\n                                                points += s2Citizen.points;\n                                                i++;\n@@ -1309,15 +1313,16 @@ contract NeoTokyoStaker is PermitControl, ReentrancyGuard {\n                        uint256 totalReward;\n                        uint256 lastPoolRewardTime = lastRewardTime[_recipient][_assetType];\n                        uint256 windowCount = pool.rewardCount;\n+                       mapping (uint256 => RewardWindow) storage rewardWindowsMap = pool.rewardWindows;\n                        for (uint256 i; i < windowCount; ) {\n-                               RewardWindow memory window = pool.rewardWindows[i];\n+                               RewardWindow memory window = rewardWindowsMap[i];\n\n                                /*\n                                        If the last reward time is less than the starting time of this\n                                        window, then the reward was accrued in the previous window.\n                                */\n                                if (lastPoolRewardTime < window.startTime) {\n-                                       uint256 currentRewardRate = pool.rewardWindows[i - 1].reward;\n+                                       uint256 currentRewardRate = rewardWindowsMap[i - 1].reward;\n\n                                        /*\n                                                Iterate forward to the present timestamp over any unclaimed reward\n@@ -1363,7 +1368,7 @@ contract NeoTokyoStaker is PermitControl, ReentrancyGuard {\n\n                                                        // Otherwise, iterate.\n                                                        } else {\n-                                                               window = pool.rewardWindows[j + 1];\n+                                                               window = rewardWindowsMap[j + 1];\n                                                        }\n                                                }\n                                                unchecked { j++; }\n```\n\nhttps://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L1432-L1435\n\n### Cache storage pointer for `lastRewardTime[_recipient]`.\n```solidity\nFile: contracts/staking/NeoTokyoStaker.sol\n1432:\t\t// Record the current time as the beginning time for checking rewards.\n1433:\t\tlastRewardTime[_recipient][AssetType.S1_CITIZEN] = block.timestamp; // @audit: 1st access\n1434:\t\tlastRewardTime[_recipient][AssetType.S2_CITIZEN] = block.timestamp; // @audit: 2nd access\n1435:\t\tlastRewardTime[_recipient][AssetType.LP] = block.timestamp; // @audit: 3rd access\n```\n```diff\ndiff --git a/contracts/staking/NeoTokyoStaker.sol b/contracts/staking/NeoTokyoStaker.sol\nindex a54d218..4621b10 100644\n--- a/contracts/staking/NeoTokyoStaker.sol\n+++ b/contracts/staking/NeoTokyoStaker.sol\n@@ -1430,9 +1430,10 @@ contract NeoTokyoStaker is PermitControl, ReentrancyGuard {\n                );\n\n                // Record the current time as the beginning time for checking rewards.\n-               lastRewardTime[_recipient][AssetType.S1_CITIZEN] = block.timestamp;\n-               lastRewardTime[_recipient][AssetType.S2_CITIZEN] = block.timestamp;\n-               lastRewardTime[_recipient][AssetType.LP] = block.timestamp;\n+               mapping (AssetType => uint256) storage recipient = lastRewardTime[_recipient];\n+               recipient[AssetType.S1_CITIZEN] = block.timestamp;\n+               recipient[AssetType.S2_CITIZEN] = block.timestamp;\n+               recipient[AssetType.LP] = block.timestamp;\n\n                // Calculate total reward and tax.\n                uint256 totalReward;\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2023-03-neo-tokyo-contest",
  "Code": [
    {
      "filename": "contracts/staking/NeoTokyoStaker.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../access/PermitControl.sol\";\nimport \"../interfaces/IByteContract.sol\";\nimport \"../interfaces/IGenericGetter.sol\";\n\n/**\n\tThrown during when attempting to operate on a non-existent Citizen (S1 or S2).\n\n\t@param citizenId The ID of the caller's specified Citizen.\n*/\nerror CitizenDoesNotExist (\n\tuint256 citizenId\n);\n\n/**\n\tThrown when attempting to get a staker's position of an unknowable asset type.\n\n\t@param assetType The caller's specified asset type.\n*/\nerror UnknowablePosition (\n\tuint256 assetType\n);\n\n/**\n\tThrown when an S1 Citizen with a component Vault attempts to stake while \n\tattaching an optional non-component Vault.\n\n\t@param componentVaultId The ID of the S1 Citizen's component Vault.\n\t@param noncomponentVaultId The ID of the Vault the caller attempted to stake.\n*/\nerror CitizenAlreadyHasVault (\n\tuint256 componentVaultId,\n\tuint256 noncomponentVaultId\n);\n\n/**\n\tThrown when an S1 Citizen attempts to wrongfully claim the Hand bonus.\n\n\t@param citizenId The ID of the caller's specified S1 Citizen.\n*/\nerror CitizenIsNotHand (\n\tuint256 citizenId\n);\n\n/**\n\tThrown when a BYTES stake would exceed the cap of its corresponding Citizen.\n\n\t@param attemptedAmount The amount that the user is attempting to stake to.\n\t@param cap The staking cap of the Citizen.\n*/\nerror AmountExceedsCap (\n\tuint256 attemptedAmount,\n\tuint256 cap\n);\n\n/**\n\tThrown when attempting to stake BYTES into an unowned Citizen.\n\n\t@param citizenId The token ID of the Citizen involved in the attempted stake.\n\t@param seasonId The season ID of the Citizen, whether S1 or S2.\n*/\nerror CannotStakeIntoUnownedCitizen (\n\tuint256 citizenId,\n\tuint256 seasonId\n);\n\n/**\n\tThrown when attempting to stake BYTES into an invalid Citizen season.\n\n\t@param seasonId The ID of the Citizen season to try staking BYTES into.\n*/\nerror InvalidSeasonId (\n\tuint256 seasonId\n);\n\n/**\n\tThrown when attempting to increase a stake in an asset without matching the \n\texisting timelock of the asset.\n*/\nerror MismatchedTimelock ();\n\n/**\n\tThrown during staking or unstaking if an invalid AssetType is specified.\n\n\t@param assetType The caller's specified asset type.\n*/\nerror InvalidAssetType (\n\tuint256 assetType\n);\n\n/**\n\tThrown during staking if attempting to stake into an unconfigured asset pool.\n\n\t@param assetType The caller's specified asset type.\n*/\nerror UnconfiguredPool (\n\tuint256 assetType\n);\n\n/**\n\tThrown during staking if attempting to stake into an asset pool whose rewards \n\tare not yet active.\n\n\t@param assetType The caller's specified asset type.\n*/\nerror InactivePool (\n\tuint256 assetType\n);\n\n/**\n\tThrown during staking if an invalid timelock option is specified. Each \n\tAssetType being staked may have independently-configured timelock options.\n\n\t@param assetType The caller's specified asset type.\n\t@param timelockId The caller's specified timelock ID against `assetType`.\n*/\nerror InvalidTimelockOption (\n\tuint256 assetType,\n\tuint256 timelockId\n);\n\n/// Thrown if the caller of a function is not the BYTES contract.\nerror CallerIsNotBYTES ();\n\n/**\n\tThrown when withdrawing an asset fails to clear a timelock.\n\t\n\t@param endTime The time that the staked asset timelock ends.\n*/\nerror TimelockNotCleared (\n\tuint256 endTime\n);\n\n/**\n\tThrown when attempting to withdraw an unowned S1 Citizen.\n\n\t@param citizenId The ID of the S1 Citizen attempted to be withdrawn.\n*/\nerror CannotWithdrawUnownedS1 (\n\tuint256 citizenId\n);\n\n/**\n\tThrown when attempting to withdraw an unowned S2 Citizen.\n\n\t@param citizenId The ID of the S2 Citizen attempted to be withdrawn.\n*/\nerror CannotWithdrawUnownedS2 (\n\tuint256 citizenId\n);\n\n/**\n\tThrown if a caller tries to withdraw more LP tokens than they had staked.\n\n\t@param attemptedWithdraw The amount of LP tokens that the caller attempted to \n\t\twithdraw.\n\t@param position The amount of LP tokens that the caller has actually staked.\n*/\nerror NotEnoughLPTokens (\n\tuint256 attemptedWithdraw,\n\tuint256 position\n);\n\n/// Thrown if attempting to configure the LP token address post-lock.\nerror LockedConfigurationOfLP ();\n\n/// Thrown when specifying invalid reward windows for a pool.\nerror RewardWindowTimesMustIncrease ();\n\n/**\n\t@custom:benediction DEVS BENEDICAT ET PROTEGAT CONTRACTVS MEAM\n\t@title A pool-based staking contract for the Neo Tokyo ecosystem.\n\t@author Tim Clancy <@_Enoch>\n\t@author Rostislav Khlebnikov <@catpic5buck>\n\n\tThis contract allows callers to stake their Neo Tokyo Citizens (both S1 and \n\tS2) and BYTES for\ttime-locked emission rewards. The staker operates on a \n\tpoint-based, competitive system where stakers compete for a finite amount of \n\tdaily emissions. It allows permissioned managers to configure various \n\temission details for the Neo Tokyo ecosystem.\n\n\t@custom:date February 14th, 2023.\n*/\ncontract NeoTokyoStaker is PermitControl, ReentrancyGuard {\n\n\t/// The `transferFrom` selector for ERC-20 and ERC-721 tokens.\n\tbytes4 constant private _TRANSFER_FROM_SELECTOR = 0x23b872dd;\n\n\t/// The `transfer` selector for ERC-20 tokens.\n\tbytes4 constant private _TRANSFER_SELECTOR = 0xa9059cbb;\n\n\t/// A constant multiplier to reduce overflow in staking calculations.\n\tuint256 constant private _PRECISION = 1e12;\n\n\t/// A constant divisor to calculate points and multipliers as basis points.\n\tuint256 constant private _DIVISOR = 100;\n\n\t/// The number of BYTES needed to get one point in BYTES staking calculations.\n\tuint256 constant private _BYTES_PER_POINT = 200 * 1e18;\n\n\t/// The identifier for the right to configure the LP token address.\n\tbytes32 public constant CONFIGURE_LP = keccak256(\"CONFIGURE_LP\");\n\n\t/// The identifier for the right to configure timelock options.\n\tbytes32 public constant CONFIGURE_TIMELOCKS = keccak256(\n\t\t\"CONFIGURE_TIMELOCKS\"\n\t);\n\n\t/// The identifier for the right to configure Identity and Vault points.\n\tbytes32 public constant CONFIGURE_CREDITS = keccak256(\"CONFIGURE_CREDITS\");\n\n\t/// The identifier for the right to configure emission rates and the DAO tax.\n\tbytes32 public constant CONFIGURE_POOLS = keccak256(\"CONFIGURE_POOLS\");\n\n\t/// The identifier for the right to configure BYTES staking caps.\n\tbytes32 public constant CONFIGURE_CAPS = keccak256(\"CONFIGURE_CAPS\");\n\n\t/// The address of the new BYTES 2.0 token contract.\n\taddress immutable public BYTES;\n\n\t/// The address of the assembled Neo Tokyo S1 Citizen contract.\n\taddress immutable public S1_CITIZEN;\n\n\t/// The address of the assembled Neo Tokyo S2 Citizen contract.\n\taddress immutable public S2_CITIZEN;\n\n\t/// The address of the LP token contract.\n\taddress public LP;\n\n\t/**\n\t\tThe address of the Neo Tokyo S1 Identity contract. This specific contract \n\t\taddress is stored to check an assembled S1 Citizen's specific component \n\t\tidentity in order to check for Hands of the Citadel.\n\t*/\n\taddress immutable public IDENTITY;\n\n\t/// The address of the Neo Tokyo S1 Vault contract.\n\taddress immutable public VAULT;\n\n\t/**\n\t\tThe limit on the number of BYTES that may be staked per S1 Citizen \n\t\tassembled with a component Vault or per Vault-less S1 Citizen staked \n\t\talongside a Vault.\n\t*/\n\tuint256 public VAULT_CAP;\n\n\t/**\n\t\tThe limit on the number of BYTES that may be staked per S2 Citizen or S1 \n\t\tCitizen without Vault.\n\t*/\n\tuint256 public NO_VAULT_CAP;\n\n\t/**\n\t\tThis enum tracks each type of asset that may be operated on with this \n\t\tstaker.\n\n\t\t@param S1_CITIZEN A staked Neo Tokyo S1 Citizen.\n\t\t@param S2_CITIZEN A staked Neo Tokyo S2 Citizen.\n\t\t@param BYTES A set of staked BYTES ERC-20 token.\n\t\t@param LP Staked BYTES-ETH LP ERC-20 token.\n\t*/\n\tenum AssetType {\n\t\tS1_CITIZEN,\n\t\tS2_CITIZEN,\n\t\tBYTES,\n\t\tLP\n\t}\n\n\t/**\n\t\tThis mapping contains the per-asset configuration of different timelock \n\t\tperiods with their associated multipliers. For each asset, the interior \n\t\tmapping correlates a particular timelock option to a uint256 which encodes \n\t\tthe duration of the timelock in its upper 128 bits and the multiplier \n\t\toffered by that timelock, as basis points, in its lower 128 bits.\n\t*/\n\tmapping ( AssetType => mapping ( uint256 => uint256 )) public\ttimelockOptions;\n\n\t/**\n\t\tThis struct defines a specific time window in reward emission history. For \n\t\ta particular asset staking pool, it represents that beginning from \n\t\t`startTime`, the pool had a per-second reward emission rate of `reward`.\n\n\t\t@param startTime The time at which the daily reward activated.\n\t\t@param reward The reward emission rate beginning at `startTime`.\n\t*/\n\tstruct RewardWindow {\n\t\tuint128 startTime;\n\t\tuint128 reward;\n\t}\n\n\t/**\n\t\tThis struct is used to define both the configuration details for a \n\t\tparticular asset staking pool and the state of that pool as callers begin \n\t\tinteracting with it.\n\n\t\t@param totalPoints The total number of points in the pool.\n\t\t@param daoTax The percent, in basis points, of the reward emissions sent to \n\t\t\tthe DAO.\n\t\t@param rewardCount A count of the number of reward windows in the \n\t\t\t`rewardWindows` mapping, used for iterating.\n\t\t@param rewardWindows A mapping of the historic amount of BYTES token \t\n\t\t\trewarded per-second across all stakers in this particular pool.\n\t*/\n\tstruct PoolData {\n\t\tuint256 totalPoints;\n\t\tuint256 daoTax;\n\t\tuint256 rewardCount;\n\t\tmapping ( uint256 => RewardWindow ) rewardWindows;\n\t}\n\n\t/// Map an asset type to its corresponding pool data. \n\tmapping ( AssetType => PoolData ) private _pools;\n\t\n\t/// Track the last time a caller was granted their rewards for each asset.\n\tmapping ( address => mapping ( AssetType => uint256 )) public lastRewardTime;\n\n\t/** \n\t\tThis admin-configurable double-mapping allows us to deduce the Identity \n\t\t\"Credit Yield\" string of a Neo Tokyo S1 Citizen given the Citizen's reward \n\t\trate and the reward rate of the Citizen's Vault.\n\t*/\n\tmapping ( uint256 => mapping ( string => string )) public identityCreditYield;\n\n\t/// Assign a configurable multiplier to each S1 Citizen's Identity credit. \n\tmapping ( string => uint256 ) public identityCreditPoints;\n\n\t/// Assign a configurable multiplier to each S1 Citizen's Vault credit. \n\tmapping ( string => uint256 ) public vaultCreditMultiplier;\n\n\t/**\n\t\tThis struct records the state of each staked S1 Citizen.\n\n\t\t@param stakedBytes The number of BYTES that have been staked into this S1 \n\t\t\tCitizen. Depending on the value of `hasVault`, this S1 Citizen  will be \n\t\t\tbound to either the `VAULT_CAP` limit or `NO_VAULT_CAP` limit on the \n\t\t\tnumber of BYTES that may be staked.\n\t\t@param timelockEndTime The time at which the forced, timelocked staking of \n\t\t\tthis S1 Citizen ends. After this time the S1 Citizen may be withdrawn \n\t\t\tfrom the staker.\n\t\t@param points The number of base points that this staked S1 Citizen is \n\t\t\tworth, thus determining its share of emissions. An S1 Citizen's base \n\t\t\tpoints are a function of the S1 Citizen's component Identity and any \n\t\t\tassociated Vault multiplier. The base points are also multiplied by the \n\t\t\ttimelock option chosen at the time of staking. The base points are \n\t\t\tsupplemented in points calculations by the value of `stakedBytes`.\n\t\t@param stakedVaultId The optional ID of the Vault, if there is one, that \n\t\t\thas been staked alongside this S1 Citizen. If `hasVault` is true, this \n\t\t\tvalue may be non-zero to indicate a staked but non-component Vault. If \n\t\t\t`hasVault` is true and this value is zero, that is indicative of an S1 \n\t\t\tCitizen with a component Vault.\n\t\t@param hasVault A boolean indicating whether or not this S1 Citizen has an \n\t\t\tassociated Vault, whether that Vault is a component Vault assembled into \n\t\t\tthe S1 Citizen or one that has been staked alongside the S1 Citizen.\n\t*/\n\tstruct StakedS1Citizen {\n\t\tuint256 stakedBytes;\n\t\tuint256 timelockEndTime;\n\t\tuint256 points;\n\t\tuint256 stakedVaultId;\n\t\tbool hasVault;\n\t}\n\n\t/**\n\t\tA double mapping from a caller address to a specific S1 Citizen token ID to \n\t\tthe staking status of each S1 Citizen. This records the unique per-user \n\t\tstaking status of each S1 citizen.\n\t*/\n\tmapping ( address => mapping( uint256 => StakedS1Citizen )) public stakedS1;\n\n\t/**\n\t\tThis mapping correlates a caller address to a list of their \n\t\tcurrently-staked S1 Citizen token IDs.\n\t*/\n\tmapping ( address => uint256[] ) private _stakerS1Position;\n\n\t/**\n\t\tThis struct records the state of each staked S2 Citizen.\n\n\t\t@param stakedBytes The number of BYTES that have been staked into this S2 \n\t\t\tCitizen.\n\t\t@param timelockEndTime The time at which the forced, timelocked staking of \n\t\t\tthis S2 Citizen ends. After this time the S2 Citizen may be withdrawn \n\t\t\tfrom the staker.\n\t\t@param points The number of base points that this staked S2 Citizen is \n\t\t\tworth, thus determining its share of emissions. An S2 Citizen's base \n\t\t\tpoints are a function of the timelock option chosen at the time of \n\t\t\tstaking. The base points are supplemented in points calculations by the \n\t\t\tvalue of `stakedBytes`.\n\t*/\n\tstruct StakedS2Citizen {\n\t\tuint256 stakedBytes;\n\t\tuint256 timelockEndTime;\n\t\tuint256 points;\n\t}\n\n\t/**\n\t\tA double mapping from a caller address to a specific S2 Citizen token ID to \n\t\tthe staking status of each S2 Citizen. This records the unique per-user \n\t\tstaking status of each S2 citizen.\n\t*/\n\tmapping ( address => mapping( uint256 => StakedS2Citizen )) public stakedS2;\n\n\t/**\n\t\tThis mapping correlates a caller address to a list of their \n\t\tcurrently-staked S2 Citizen token IDs.\n\t*/\n\tmapping ( address => uint256[] ) private _stakerS2Position;\n\n\t/**\n\t\tThis struct defines the LP token staking position of a particular staker.\n\n\t\t@param amount The amount of LP tokens staked by the staker.\n\t\t@param timelockEndTime The tiume at which the forced, timelocked staking of \n\t\t\tthese LP tokens ends. After this the LP tokens may be withdrawn.\n\t\t@param points The number of points that this LP position accrues.\n\t\t@param multiplier The multiplier portion of the timelock option recorded so \n\t\t\tas to enforce later stakes to use the same point rate.\n\t*/\n\tstruct LPPosition {\n\t\tuint256 amount;\n\t\tuint256 timelockEndTime;\n\t\tuint256 points;\n\t\tuint256 multiplier;\n\t}\n\n\t/**\n\t\tThis mapping correlates each caller address to details regarding the LP \n\t\ttoken stake of that caller.\n\t*/\n\tmapping ( address => LPPosition ) public stakerLPPosition;\n\n\t/**\n\t\tThis struct supplies the position output state of each staked S1 Citizen.\n\n\t\t@param citizenId The token ID of this S1 Citizen.\n\t\t@param stakedBytes The number of BYTES that have been staked into this S1 \n\t\t\tCitizen. Depending on the value of `hasVault`, this S1 Citizen  will be \n\t\t\tbound to either the `VAULT_CAP` limit or `NO_VAULT_CAP` limit on the \n\t\t\tnumber of BYTES that may be staked.\n\t\t@param timelockEndTime The time at which the forced, timelocked staking of \n\t\t\tthis S1 Citizen ends. After this time the S1 Citizen may be withdrawn \n\t\t\tfrom the staker.\n\t\t@param points The number of base points that this staked S1 Citizen is \n\t\t\tworth, thus determining its share of emissions. An S1 Citizen's base \n\t\t\tpoints are a function of the S1 Citizen's component Identity and any \n\t\t\tassociated Vault multiplier. The base points are also multiplied by the \n\t\t\ttimelock option chosen at the time of staking. The base points are \n\t\t\tsupplemented in points calculations by the value of `stakedBytes`.\n\t\t@param stakedVaultId The optional ID of the Vault, if there is one, that \n\t\t\thas been staked alongside this S1 Citizen. If `hasVault` is true, this \n\t\t\tvalue may be non-zero to indicate a staked but non-component Vault. If \n\t\t\t`hasVault` is true and this value is zero, that is indicative of an S1 \n\t\t\tCitizen with a component Vault.\n\t\t@param hasVault A boolean indicating whether or not this S1 Citizen has an \n\t\t\tassociated Vault, whether that Vault is a component Vault assembled into \n\t\t\tthe S1 Citizen or one that has been staked alongside the S1 Citizen.\n\t*/\n\tstruct StakedS1CitizenOutput {\n\t\tuint256 citizenId;\n\t\tuint256 stakedBytes;\n\t\tuint256 timelockEndTime;\n\t\tuint256 points;\n\t\tuint256 stakedVaultId;\n\t\tbool hasVault;\n\t}\n\n\t/**\n\t\tThis struct supplies the position output state of each staked S2 Citizen.\n\n\t\t@param citizenId The token ID of this S1 Citizen.\n\t\t@param stakedBytes The number of BYTES that have been staked into this S2 \n\t\t\tCitizen.\n\t\t@param timelockEndTime The time at which the forced, timelocked staking of \n\t\t\tthis S2 Citizen ends. After this time the S2 Citizen may be withdrawn \n\t\t\tfrom the staker.\n\t\t@param points The number of base points that this staked S2 Citizen is \n\t\t\tworth, thus determining its share of emissions. An S2 Citizen's base \n\t\t\tpoints are a function of the timelock option chosen at the time of \n\t\t\tstaking. The base points are supplemented in points calculations by the \n\t\t\tvalue of `stakedBytes`.\n\t*/\n\tstruct StakedS2CitizenOutput {\n\t\tuint256 citizenId;\n\t\tuint256 stakedBytes;\n\t\tuint256 timelockEndTime;\n\t\tuint256 points;\n\t}\n\n\t/**\n\t\tThis struct records the state of all assets staked by a particular staker \n\t\taddress in this staker.\n\n\t\t@param stakedS1Citizens An array containing information about each S1 \n\t\t\tCitizen staked by a particular staker address.\n\t\t@param stakedS2Citizens An array containing information about each S2 \n\t\t\tCitizen staked by a particular staker address.\n\t\t@param stakedLPPosition Details regarding the LP token stake of a particular\n\t\t\tstaker address.\n\t*/\n\tstruct StakerPosition {\n\t\tStakedS1CitizenOutput[] stakedS1Citizens;\n\t\tStakedS2CitizenOutput[] stakedS2Citizens;\n\t\tLPPosition stakedLPPosition;\n\t}\n\n\t/// Whether or not setting the LP token contract address is locked.\n\tbool public lpLocked;\n\n\t/**\n\t\tThis struct records an input to the staker's `configurePools` function.\n\n\t\t@param assetType The asset type for the corresponding pool to set.\n\t\t@param daoTax The percent, in basis points, of the reward emissions sent to \n\t\t\tthe DAO.\n\t\t@param rewardWindows An array specifying the historic amount of BYTES token\n\t\t\trewarded per-second across all stakers in this particular pool.\n\t*/\n\tstruct PoolConfigurationInput {\n\t\tAssetType assetType;\n\t\tuint256 daoTax;\n\t\tRewardWindow[] rewardWindows;\n\t}\n\n\t/**\n\t\tThis event is emitted when an asset is successfully staked.\n\n\t\t@param staker The address of the caller who staked an `asset`.\n\t\t@param asset The address of the asset being staked.\n\t\t@param timelockOption Data encoding the parameters surrounding the timelock \n\t\t\toption used in staking the particular asset. Alternatively, this encodes \n\t\t\tctiizen information for BYTES staking.\n\t\t@param amountOrTokenId The amount of `asset` staked or, for S1 and S2 \n\t\t\tCitizens, the ID of the specific token staked.\n\t*/\n\tevent Stake (\n\t\taddress indexed staker,\n\t\taddress indexed asset,\n\t\tuint256 timelockOption,\n\t\tuint256 amountOrTokenId\n\t);\n\n\t/**\n\t\tThis event is emitted each time a recipient claims a reward.\n\n\t\t@param recipient The recipient of the reward.\n\t\t@param reward The amount of BYTES rewarded to the `recipient`.\n\t\t@param tax The amount of BYTES minted as tax to the DAO.\n\t*/\n\tevent Claim (\n\t\taddress indexed recipient,\n\t\tuint256 reward,\n\t\tuint256 tax\n\t);\n\n\t/**\n\t\tThis event is emitted when an asset is successfully withdrawn.\n\n\t\t@param caller The address of the caller who withdrew an `asset`.\n\t\t@param asset The address of the asset being withdrawn.\n\t\t@param amountOrTokenId The amount of `asset` withdrawn or, for S1 and S2 \n\t\t\tCitizens, the ID of the specific token withdrawn.\n\t*/\n\tevent Withdraw (\n\t\taddress indexed caller,\n\t\taddress indexed asset,\n\t\tuint256 amountOrTokenId\n\t);\n\n\t/**\n\t\tConstruct a new instance of this Neo Tokyo staker configured with the given \n\t\timmutable contract addresses.\n\n\t\t@param _bytes The address of the BYTES 2.0 ERC-20 token contract.\n\t\t@param _s1Citizen The address of the assembled Neo Tokyo S1 Citizen.\n\t\t@param _s2Citizen The address of the assembled Neo Tokyo S2 Citizen.\n\t\t@param _lpToken The address of the LP token.\n\t\t@param _identity The address of the specific Neo Tokyo Identity sub-item.\n\t\t@param _vault The address of the specific Neo Tokyo Vault sub-item.\n\t\t@param _vaultCap The limit on the number of BYTES that may be staked per S1 \n\t\t\tCitizen assembled with a component Vault or staked alongside a Vault.\n\t\t@param _noVaultCap The limit on the number of BYTES that may be staked per \n\t\t\tS2 Citizen or S1 Citizen without Vault.\n\t*/\n\tconstructor (\n\t\taddress _bytes,\n\t\taddress _s1Citizen,\n\t\taddress _s2Citizen,\n\t\taddress _lpToken,\n\t\taddress _identity,\n\t\taddress _vault,\n\t\tuint256 _vaultCap,\n\t\tuint256 _noVaultCap\n\t) {\n\t\tBYTES = _bytes;\n\t\tS1_CITIZEN = _s1Citizen;\n\t\tS2_CITIZEN = _s2Citizen;\n\t\tLP = _lpToken;\n\t\tIDENTITY = _identity;\n\t\tVAULT = _vault;\n\t\tVAULT_CAP = _vaultCap;\n\t\tNO_VAULT_CAP = _noVaultCap;\n\t}\n\n\t/**\n\t\tNeo Tokyo Identity items do not expose their \"Credit Yield\" trait values in \n\t\tan easily-consumed fashion. This function works backwards to calculate the \n\t\tunderlying \"Credit Yield\" trait value of the component Identity item of the \n\t\tNeo Tokyo S1 Citizen with the token ID of `_citizenId` given the reward \n\t\trate of the S1 Citizen as a whole and the credit multiplier of any \n\t\tcomponent Vault.\n\n\t\t@param _citizenId The token ID of the Neo Tokyo S1 Citizen to retrieve an \n\t\t\tIdentity \"Credit Yield\" trait value for.\n\t\t@param _vaultId The token ID of the Neo Tokyo S1 Citizen's component Vault, \n\t\t\tif there is one. This parameter is separated to optimized for callers who \n\t\t\thave already predetermined the token ID of the Vault.\n\n\t\t@return The \"Credit Yield\" trait value of the component Identity item of \n\t\t\tthe S1 Citizen with the token ID of `_citizenId`.\n\t*/\n\tfunction getCreditYield (\n\t\tuint256 _citizenId,\n\t\tuint256 _vaultId\n\t) public view returns (string memory) {\n\n\t\t// Retrieve the total reward rate of this S1 Citizen.\n\t\tIGenericGetter citizen = IGenericGetter(S1_CITIZEN);\n\t\tuint256 rewardRate = citizen.getRewardRateOfTokenId(_citizenId);\n\t\tif (rewardRate == 0) {\n\t\t\trevert CitizenDoesNotExist(_citizenId);\n\t\t}\n\n\t\t// Retrieve the credit rate multiplier of any associated Vault.\n\t\tIGenericGetter vault = IGenericGetter(VAULT);\n\t\tstring memory vaultMultiplier = (_vaultId != 0)\n\t\t\t? vault.getCreditMultiplier(_vaultId)\n\t\t\t: \"\";\n\t\t\n\t\t// Deduce the original Identity credit yield.\n\t\treturn identityCreditYield[rewardRate][vaultMultiplier];\n\t}\n\n\t/**\n\t\tThe multipliers to S1 Citizen points contributed by their component Vaults \n\t\tmay be independently configured by permitted administrators of this staking \n\t\tcontract. This helper function returns any of the multipliers that may have \n\t\tbeen configured.\n\n\t\t@param _vaultId The token ID of a Neo Tokyo S1 Vault to retrieve the \n\t\t\tconfigued multiplier for.\n\n\t\t@return The configured point multiplier for the Vault with token ID of \n\t\t\t`_vaultId`.\n\t*/\n\tfunction getConfiguredVaultMultiplier (\n\t\tuint256 _vaultId\n\t) public view returns (uint256) {\n\n\t\t// Retrieve the credit rate multiplier of the Vault.\n\t\tIGenericGetter vault = IGenericGetter(VAULT);\n\t\tstring memory vaultMultiplier = (_vaultId != 0)\n\t\t\t? vault.getCreditMultiplier(_vaultId)\n\t\t\t: \"\";\n\t\t\n\t\t// Deduce the configured Vault multiplier.\n\t\treturn vaultCreditMultiplier[vaultMultiplier];\n\t}\n\n\t/**\n\t\tReturn the list of `_staker`'s token IDs for the specified `_assetType` if \n\t\tthat type is the Neo Tokyo S1 Citizen or S2 Citizen. In order to determine \n\t\tthe staker's position in the LP asset type, the public `stakerLPPosition` \n\t\tmapping should be used. It is not valid to directly determine the position \n\t\tin BYTES of a particular staker; to retrieve that kind of cumulative data \n\t\tthe full output `getStakerPositions` function should be used.\n\n\t\t@param _staker The address of the staker to check for staked Citizen \n\t\t\tholdings.\n\t\t@param _assetType The asset type to check for staked holdings. This must be \n\t\t\tthe S1 Citizen or S2 Citizen type.\n\n\t\t@return The list of token IDs of a particular Citizen type that have been \n\t\t\tstaked by `_staker`.\n\t*/\n\tfunction getStakerPosition (\n\t\taddress _staker,\n\t\tAssetType _assetType\n\t) external view returns (uint256[] memory) {\n\t\tif (_assetType == AssetType.S1_CITIZEN) {\n\t\t\treturn _stakerS1Position[_staker];\n\t\t} else if (_assetType == AssetType.S2_CITIZEN) {\n\t\t\treturn _stakerS2Position[_staker];\n\t\t} else {\n\t\t\trevert UnknowablePosition(uint256(_assetType));\n\t\t}\n\t}\n\n\t/**\n\t\tRetrieve the entire position of the specified `_staker` across all asset \n\t\ttypes in this staker.\n\n\t\t@param _staker The address of the staker to check for assets.\n\n\t\t@return The position of the `_staker` across all asset types.\n\t*/\n\tfunction getStakerPositions (\n\t\taddress _staker\n\t) external view returns (StakerPosition memory) {\n\n\t\t// Compile the S1 Citizen details.\n\t\tStakedS1CitizenOutput[] memory stakedS1Details =\n\t\t\tnew StakedS1CitizenOutput[](_stakerS1Position[_staker].length);\n\t\tfor (uint256 i; i < _stakerS1Position[_staker].length; ) {\n\t\t\tuint256 citizenId = _stakerS1Position[_staker][i];\n\t\t\tStakedS1Citizen memory citizenDetails = stakedS1[_staker][citizenId];\n\t\t\tstakedS1Details[i] = StakedS1CitizenOutput({\n\t\t\t\tcitizenId: citizenId,\n\t\t\t\tstakedBytes: citizenDetails.stakedBytes,\n\t\t\t\ttimelockEndTime: citizenDetails.timelockEndTime,\n\t\t\t\tpoints: citizenDetails.points,\n\t\t\t\thasVault: citizenDetails.hasVault,\n\t\t\t\tstakedVaultId: citizenDetails.stakedVaultId\n\t\t\t});\n\t\t\tunchecked { i++; }\n\t\t}\n\n\t\t// Compile the S2 Citizen details.\n\t\tStakedS2CitizenOutput[] memory stakedS2Details =\n\t\t\tnew StakedS2CitizenOutput[](_stakerS2Position[_staker].length);\n\t\tfor (uint256 i; i < _stakerS2Position[_staker].length; ) {\n\t\t\tuint256 citizenId = _stakerS2Position[_staker][i];\n\t\t\tStakedS2Citizen memory citizenDetails = stakedS2[_staker][citizenId];\n\t\t\tstakedS2Details[i] = StakedS2CitizenOutput({\n\t\t\t\tcitizenId: citizenId,\n\t\t\t\tstakedBytes: citizenDetails.stakedBytes,\n\t\t\t\ttimelockEndTime: citizenDetails.timelockEndTime,\n\t\t\t\tpoints: citizenDetails.points\n\t\t\t});\n\t\t\tunchecked { i++; }\n\t\t}\n\n\t\t// Return the final output position struct.\n\t\treturn StakerPosition({\n\t\t\tstakedS1Citizens: stakedS1Details,\n\t\t\tstakedS2Citizens: stakedS2Details,\n\t\t\tstakedLPPosition: stakerLPPosition[_staker]\n\t\t});\n\t}\n\n\t/**\n\t\tA private helper function for performing the low-level call to \n\t\t`transferFrom` on either a specific ERC-721 token or some amount of ERC-20 \n\t\ttokens.\n\n\t\t@param _asset The address of the asset to perform the transfer call on.\n\t\t@param _from The address to attempt to transfer the asset from.\n\t\t@param _to The address to attempt to transfer the asset to.\n\t\t@param _idOrAmount This parameter encodes either an ERC-721 token ID or an \n\t\t\tamount of ERC-20 tokens to attempt to transfer, depending on what \n\t\t\tinterface is implemented by `_asset`.\n\t*/\n\tfunction _assetTransferFrom (\n\t\taddress _asset,\n\t\taddress _from,\n\t\taddress _to,\n\t\tuint256 _idOrAmount\n\t) private {\n\t\t(bool success, bytes memory data) = \n\t\t\t_asset.call(\n\t\t\t\tabi.encodeWithSelector(\n\t\t\t\t\t_TRANSFER_FROM_SELECTOR,\n\t\t\t\t\t_from,\n\t\t\t\t\t_to, \n\t\t\t\t\t_idOrAmount\n\t\t\t\t)\n\t\t\t);\n\n\t\t// Revert if the low-level call fails.\n\t\tif (!success) {\n\t\t\trevert(string(data));\n\t\t}\n\t}\n\n\t/**\n\t\tA private helper function for performing the low-level call to `transfer` \n\t\ton some amount of ERC-20 tokens.\n\n\t\t@param _asset The address of the asset to perform the transfer call on.\n\t\t@param _to The address to attempt to transfer the asset to.\n\t\t@param _amount The amount of ERC-20 tokens to attempt to transfer.\n\t*/\n\tfunction _assetTransfer (\n\t\taddress _asset,\n\t\taddress _to,\n\t\tuint256 _amount\n\t) private {\n\t\t(bool success, bytes memory data) = \n\t\t\t_asset.call(\n\t\t\t\tabi.encodeWithSelector(\n\t\t\t\t\t_TRANSFER_SELECTOR,\n\t\t\t\t\t_to, \n\t\t\t\t\t_amount\n\t\t\t\t)\n\t\t\t);\n\n\t\t// Revert if the low-level call fails.\n\t\tif (!success) {\n\t\t\trevert(string(data));\n\t\t}\n\t}\n\n\t/**\n\t\tA private helper for checking equality between two strings.\n\n\t\t@param _a The first string to compare.\n\t\t@param _b The second string to compare.\n\n\t\t@return Whether or not `_a` and `_b` are equal.\n\t*/\n\tfunction _stringEquals (\n\t\tstring memory _a,\n\t\tstring memory _b\n\t) private pure returns (bool) {\n\t\tbytes memory a = bytes(_a);\n\t\tbytes memory b = bytes(_b);\n\t\t\n\t\t// Check equivalence of the two strings by comparing their contents.\n\t\tbool equal = true;\n\t\tassembly {\n\t\t\tlet length := mload(a)\n\t\t\tswitch eq(length, mload(b))\n\n\t\t\t// Proceed to compare string contents if lengths are equal. \n\t\t\tcase 1 {\n\t\t\t\tlet cb := 1\n\n\t\t\t\t// Iterate through the strings and compare contents.\n\t\t\t\tlet mc := add(a, 0x20)\n\t\t\t\tlet end := add(mc, length)\n\t\t\t\tfor {\n\t\t\t\t\tlet cc := add(b, 0x20)\n\t\t\t\t} eq(add(lt(mc, end), cb), 2) {\n\t\t\t\t\tmc := add(mc, 0x20)\n\t\t\t\t\tcc := add(cc, 0x20)\n\t\t\t\t} {\n\n\t\t\t\t\t// If any of these checks fails then arrays are not equal.\n\t\t\t\t\tif iszero(eq(mload(mc), mload(cc))) {\n\t\t\t\t\t\tequal := 0\n\t\t\t\t\t\tcb := 0\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// By default the array length is not equal so the strings are not equal.\n\t\t\tdefault {\n\t\t\t\tequal := 0\n\t\t\t}\n\t\t}\n\t\treturn equal;\n\t}\n\n\t/**\n\t\tA private helper function for managing the staking of a particular S1 \n\t\tCitizen. S1 Citizens may optionally be staked at the same time as a Vault, \n\t\tif they do not already contain a Vault.\n\n\t\t@param _timelock The selected timelock option for the asset being staked. \n\t\t\tThis encodes the timelock duration and multiplier.\n\t*/\n\tfunction _stakeS1Citizen (\n\t\tuint256 _timelock\n\t) private {\n\t\tuint256 citizenId;\n\t\tuint256 vaultId;\n\t\tuint256 handClaimant;\n\n\t\t/*\n\t\t\tExtract the S1 Citizen ID, optional Vault token ID, and optional Hand \n\t\t\tclaimant ID from calldata.\n\t\t*/\n\t\tassembly {\n\t\t\tcitizenId := calldataload(0x44)\n\t\t\tvaultId := calldataload(0x64)\n\t\t\thandClaimant := calldataload(0x84)\n\t\t}\n\n\t\t/*\n\t\t\tAttempt to transfer the S1 Citizen to be held in escrow by this staking \n\t\t\tcontract. This transfer will fail if the caller is not the holder of the \n\t\t\tCitizen. This prevents double staking.\n\t\t*/\n\t\t_assetTransferFrom(S1_CITIZEN, msg.sender, address(this), citizenId);\n\n\t\t// Retrieve storage for tracking the staking state of this S1 Citizen.\n\t\tStakedS1Citizen storage citizenStatus = stakedS1[msg.sender][citizenId];\n\n\t\t// Attach a getter to the S1 Citizen and check for a component Vault.\n\t\tIGenericGetter citizen = IGenericGetter(S1_CITIZEN);\n\t\tuint256 citizenVaultId = citizen.getVaultIdOfTokenId(citizenId);\n\n\t\t/*\n\t\t\tA new Vault to stake may only be provided if the S1 Citizen being staked \n\t\t\tdoes not already have a component Vault.\n\t\t*/\n\t\tif (citizenVaultId != 0 && vaultId != 0) {\n\t\t\trevert CitizenAlreadyHasVault(citizenVaultId, vaultId);\n\n\t\t/*\n\t\t\tIf no optional vault is provided, and the S1 Citizen being staked already \n\t\t\thas an existing Vault, override the provided `vaultId`.\n\t\t*/\n\t\t} else if (citizenVaultId != 0 && vaultId == 0) {\n\t\t\tcitizenStatus.hasVault = true;\n\t\t\tvaultId = citizenVaultId;\n\n\t\t/*\n\t\t\tOtherwise, if the S1 Citizen has no component Vault, the newly-provided \n\t\t\tVault is staked and the S1 Citizen is recorded as carrying an optional, \n\t\t\tseparately-attached vault.\n\t\t*/\n\t\t} else if (citizenVaultId == 0 && vaultId != 0) {\n\t\t\t_assetTransferFrom(VAULT, msg.sender, address(this), vaultId);\n\t\t\tcitizenStatus.hasVault = true;\n\t\t\tcitizenStatus.stakedVaultId = vaultId;\n\t\t}\n\n\t\t/*\n\t\t\tIf the S1 Citizen contains no component Vault and is not staked alongside \n\t\t\tan optional Vault (`citizenVaultId` == 0 && `vaultId` == 0), we need not \n\t\t\tdo anything to change the initial state of a staked S1 Citizen's Vault.\n\t\t*/\n\n\t\t// Determine the base worth in points of the S1 Citizen's Identity.\n\t\tstring memory citizenCreditYield = getCreditYield(\n\t\t\tcitizenId,\n\t\t\tcitizenVaultId\n\t\t);\n\t\tuint256 identityPoints = identityCreditPoints[citizenCreditYield];\n\n\t\t// Hands of the Citadel are always given the same multiplier as '?' Vaults.\n\t\tuint256 vaultMultiplier = 100;\n\t\tif (handClaimant == 1) {\n\t\t\tuint256 identityId = citizen.getIdentityIdOfTokenId(citizenId);\n\t\t\tstring memory class = IGenericGetter(IDENTITY).getClass(identityId);\n\t\t\tif (_stringEquals(class, \"Hand of Citadel\")) {\n\t\t\t\tvaultMultiplier = vaultCreditMultiplier[\"?\"];\n\t\t\t} else {\n\t\t\t\trevert CitizenIsNotHand(citizenId);\n\t\t\t}\n\n\t\t// Otherwise use the configured Vault multiplier, if any.\n\t\t} else if (vaultId != 0) {\n\t\t\tvaultMultiplier = getConfiguredVaultMultiplier(vaultId);\n\t\t}\n\n\t\t// Decode the timelock option's duration and multiplier.\n\t\tuint256 timelockDuration = _timelock >> 128;\n\t\tuint256 timelockMultiplier = _timelock & type(uint128).max;\n\n\t\t// Update caller staking information and asset data.\n\t\tPoolData storage pool = _pools[AssetType.S1_CITIZEN];\n\t\tunchecked {\n\t\t\tcitizenStatus.points =\n\t\t\t\tidentityPoints * vaultMultiplier * timelockMultiplier /\n\t\t\t\t_DIVISOR / _DIVISOR;\n\t\t\tcitizenStatus.timelockEndTime = block.timestamp + timelockDuration;\n\n\t\t\t// Record the caller's staked S1 Citizen.\n\t\t\t_stakerS1Position[msg.sender].push(citizenId);\n\n\t\t\t// Update the pool point weights for rewards\n\t\t\tpool.totalPoints += citizenStatus.points;\n\t\t}\n\n\t\t// Emit an event recording this S1 Citizen staking.\n\t\temit Stake(\n\t\t\tmsg.sender,\n\t\t\tS1_CITIZEN,\n\t\t\t_timelock,\n\t\t\tcitizenId\n\t\t);\n\t}\n\n\t/**\n\t\tA private func"
    }
  ]
}