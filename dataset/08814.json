{
  "Title": "[M-20] In `reimburseLiquidityFees()` of `SponserVault` contract swaps tokens without slippage limit so its possible to perform sandwich attack and it create MEV",
  "Content": "_Submitted by unforgiven_\n\n[SponsorVault.sol#L187-L220](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/helpers/SponsorVault.sol#L187-L220)<br>\n\nWhen code swaps tokens it should specify slippage but in `reimburseLiquidityFees()` code contract calls `  tokenExchange.swapExactIn() ` without slippage and it's possible to perform sandwich attack and make contract to swap on bad exchange rates and there is MEV.\n\n### Proof of Concept\n\nThis is `reimburseLiquidityFees()` code in ` SponserVault  `:\n\n      /**\n       * @notice Performs liquidity fee reimbursement.\n       * @dev Uses the token exchange or liquidity deposited in this contract.\n       *      The `_receiver` address is only used for emitting in the event.\n       * @param _token The address of the token\n       * @param _liquidityFee The liquidity fee amount\n       * @param _receiver The address of the receiver\n       * @return Sponsored liquidity fee amount\n       */\n      function reimburseLiquidityFees(\n        address _token,\n        uint256 _liquidityFee,\n        address _receiver\n      ) external override onlyConnext returns (uint256) {\n        uint256 sponsoredFee;\n\n        if (address(tokenExchanges[_token]) != address(0)) {\n          uint256 currentBalance = address(this).balance;\n          ITokenExchange tokenExchange = tokenExchanges[_token];\n\n          uint256 amountIn = tokenExchange.getInGivenExpectedOut(_token, _liquidityFee);\n          amountIn = currentBalance >= amountIn ? amountIn : currentBalance;\n\n          // sponsored fee may end being less than _liquidityFee due to slippage\n          sponsoredFee = tokenExchange.swapExactIn{value: amountIn}(_token, msg.sender);\n        } else {\n          uint256 balance = IERC20(_token).balanceOf(address(this));\n          sponsoredFee = balance < _liquidityFee ? balance : _liquidityFee;\n\n          // some ERC20 do not allow to transfer 0 amount\n          if (sponsoredFee > 0) {\n            IERC20(_token).safeTransfer(msg.sender, sponsoredFee);\n          }\n        }\n\n        emit ReimburseLiquidityFees(_token, sponsoredFee, _receiver);\n\n        return sponsoredFee;\n      }\n\nAs you can see there is no slippage defined when calling `swapExactIn()` can that swap could happen in any exchange rate. it's possible to perform sandwich attack and do large swap before and after the transaction and make users lose funds. and it's also MEV opportunity.\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nSpecify slippage when calling swap tokens.\n\n**[jakekidd (Connext) acknowledged and commented](https://github.com/code-423n4/2022-06-connext-findings/issues/237#issuecomment-1165947255):**\n > This is absolutely correct, but unfortunately there is no apparent viable on-chain solution. If we revert because slippage is too high, behavior would be inconsistent and UX would be bad, to say the least. If we instead choose to *not sponsor* because the slippage is too high, then sponsorship could be griefed severely (i.e. 'if we can't get at least X, then give the user nothing' is not a valid sponsorship policy).\n> \n> Some things that make a sandwich attack less feasible however:\n> - Using exchanges with deep liquidity provision (sandwich attacks require principle liquidity, and cannot leverage flashloans).\n> - The fact that the liquidity fee here is only .05% of the transfer means that it would take a very heavy-handed attack and at least 1 very large transfer to make it profitable (for a 1M transfer, max profit is 500 dollars).\n> \n> This is a good entrypoint for a future feature that gives sponsors better options, such as only sponsoring transfers for specific assets that they supply (i.e. so no swap is required).\n> \n> cc @LayneHaber for thoughts. Because this essentially boils down to a feature request on behalf of sponsors - not a bug.\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-06-connext-findings/issues/237#issuecomment-1214763448):**\n > Seeing as I can't verify if `tokenExchange.swapExactIn` is indeed vulnerable to slippage, I will just side with the sponsor/warden on this one.\n\n\n\n***\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-06-connext",
  "Code": [
    {
      "filename": "contracts/contracts/core/connext/helpers/SponsorVault.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20, Address} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {ISponsorVault} from \"../interfaces/ISponsorVault.sol\";\nimport {ITokenExchange} from \"../interfaces/ITokenExchange.sol\";\nimport {IGasTokenOracle} from \"../interfaces/IGasTokenOracle.sol\";\n\n/**\n * @title SponsorVault\n * @author Connext Labs\n * @notice Contains logic for sponsoring liquidity and relayer fees\n */\ncontract SponsorVault is ISponsorVault, Ownable {\n  // ============ Libraries ============\n  using SafeERC20 for IERC20;\n\n  // ============ Struct ============\n  struct Rate {\n    uint256 num;\n    uint256 den;\n  }\n\n  // ============ Private storage ============\n\n  // ============ Public storage ============\n\n  /**\n   * @notice The address of connext\n   */\n  address public connext;\n\n  /**\n   * @notice The origin domain to this domain native token rates\n   * @dev Used when no oracle is available\n   */\n  mapping(uint32 => Rate) public rates;\n\n  /**\n   * @notice The maximum amount this domain native token to be sponsored for relayer fee\n   */\n  uint256 public relayerFeeCap;\n\n  /**\n   * @notice The origin domain to this domain native token oracle\n   * @dev Used to calculate sponsored relayer fee\n   */\n  IGasTokenOracle public gasTokenOracle;\n\n  /**\n   * @notice The this domain native token to token exchange\n   * @dev Used to exchange this domain native token to the token used to pay liquidity fees\n   */\n  mapping(address => ITokenExchange) public tokenExchanges;\n\n  // ============ Errors ============\n\n  error SponsorVault__setConnext_invalidConnext();\n  error SponsorVault__setRate_invalidOriginDomain();\n  error SponsorVault__setGasTokenOracle_invalidOriginDomain();\n  error SponsorVault__setTokenExchange_invalidAdopted();\n  error SponsorVault__onlyConnext();\n  error SponsorVault__withdraw_invalidAmount();\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when a new connext is set\n   */\n  event ConnextUpdated(address oldConnext, address newConnext, address caller);\n\n  /**\n   * @notice Emitted when a new rate is set\n   */\n  event RateUpdated(uint32 originDomain, Rate oldRate, Rate newRate, address caller);\n\n  /**\n   * @notice Emitted when a new relayerFeeCap is set\n   */\n  event RelayerFeeCapUpdated(uint256 oldRelayerFeeCap, uint256 newRelayerFeeCap, address caller);\n\n  /**\n   * @notice Emitted when a new native token oracle is set\n   */\n  event GasTokenOracleUpdated(address oldOracle, address newOracle, address caller);\n\n  /**\n   * @notice Emitted when a new token exchange is set\n   */\n  event TokenExchangeUpdated(address token, address oldTokenExchange, address newTokenExchange, address caller);\n\n  /**\n   * @notice Emitted when a liquidity fee is reimbursed\n   */\n  event ReimburseLiquidityFees(address token, uint256 amount, address receiver);\n\n  /**\n   * @notice Emitted when a relayer fee is reimbursed\n   */\n  event ReimburseRelayerFees(uint256 amount, address receiver);\n\n  /**\n   * @notice Emitted when liquidity is added\n   */\n  event Deposit(address token, uint256 amount, address caller);\n\n  /**\n   * @notice Emitted when liquidity is removed\n   */\n  event Withdraw(address token, address receiver, uint256 amount, address caller);\n\n  // ============ Modifiers ============\n\n  /**\n   * @notice Restricts the caller to connext\n   */\n  modifier onlyConnext() {\n    if (msg.sender != connext) revert SponsorVault__onlyConnext();\n    _;\n  }\n\n  // ============ Constructor ============\n\n  constructor(address _connext) Ownable() {\n    _setConnext(_connext);\n  }\n\n  // ============ Owner Functions ============\n\n  /**\n   * @notice Sets the Connext.\n   * @dev Connext and sponsor vault store references to each other\n   * @param _connext The address of the Connext implementation\n   */\n  function setConnext(address _connext) external onlyOwner {\n    _setConnext(_connext);\n  }\n\n  /**\n   * @notice Sets default origin domain native token to this domain native token rate.\n   * @param _originDomain The origin domain\n   * @param _rate The default rate\n   */\n  function setRate(uint32 _originDomain, Rate calldata _rate) external onlyOwner {\n    if (_originDomain == 0) revert SponsorVault__setRate_invalidOriginDomain();\n\n    emit RateUpdated(_originDomain, rates[_originDomain], _rate, msg.sender);\n\n    rates[_originDomain] = _rate;\n  }\n\n  /**\n   * @notice Sets the maximum sponsored relayer fee amount.\n   * @param _relayerFeeCap The new relayerFeeCap\n   */\n  function setRelayerFeeCap(uint256 _relayerFeeCap) external onlyOwner {\n    emit RelayerFeeCapUpdated(relayerFeeCap, _relayerFeeCap, msg.sender);\n    relayerFeeCap = _relayerFeeCap;\n  }\n\n  /**\n   * @notice Sets of an oracle that provides origin domain native token to this domain native token rates.\n   * @param _gasTokenOracle The oracle address\n   */\n  function setGasTokenOracle(address _gasTokenOracle) external onlyOwner {\n    emit GasTokenOracleUpdated(address(gasTokenOracle), _gasTokenOracle, msg.sender);\n    gasTokenOracle = IGasTokenOracle(_gasTokenOracle);\n  }\n\n  /**\n   * @notice Sets the address of an exchange used for swapping this domain native token for a given token.\n   * @param _token The address of the token\n   * @param _tokenExchange The oracle of the exchange\n   */\n  function setTokenExchange(address _token, address payable _tokenExchange) external onlyOwner {\n    if (_token == address(0)) revert SponsorVault__setTokenExchange_invalidAdopted();\n\n    emit TokenExchangeUpdated(_token, address(tokenExchanges[_token]), _tokenExchange, msg.sender);\n    tokenExchanges[_token] = ITokenExchange(_tokenExchange);\n  }\n\n  // ============ External functions ============\n\n  /**\n   * @notice Performs liquidity fee reimbursement.\n   * @dev Uses the token exchange or liquidity deposited in this contract.\n   *      The `_receiver` address is only used for emitting in the event.\n   * @param _token The address of the token\n   * @param _liquidityFee The liquidity fee amount\n   * @param _receiver The address of the receiver\n   * @return Sponsored liquidity fee amount\n   */\n  function reimburseLiquidityFees(\n    address _token,\n    uint256 _liquidityFee,\n    address _receiver\n  ) external override onlyConnext returns (uint256) {\n    uint256 sponsoredFee;\n\n    if (address(tokenExchanges[_token]) != address(0)) {\n      uint256 currentBalance = address(this).balance;\n      ITokenExchange tokenExchange = tokenExchanges[_token];\n\n      uint256 amountIn = tokenExchange.getInGivenExpectedOut(_token, _liquidityFee);\n      amountIn = currentBalance >= amountIn ? amountIn : currentBalance;\n\n      // sponsored fee may end being less than _liquidityFee due to slippage\n      sponsoredFee = tokenExchange.swapExactIn{value: amountIn}(_token, msg.sender);\n    } else {\n      uint256 balance = IERC20(_token).balanceOf(address(this));\n      sponsoredFee = balance < _liquidityFee ? balance : _liquidityFee;\n\n      // some ERC20 do not allow to transfer 0 amount\n      if (sponsoredFee > 0) {\n        IERC20(_token).safeTransfer(msg.sender, sponsoredFee);\n      }\n    }\n\n    emit ReimburseLiquidityFees(_token, sponsoredFee, _receiver);\n\n    return sponsoredFee;\n  }\n\n  /**\n   * @notice Performs relayer fee reimbursement sending the corresponding amount of this domain native token to `_to`.\n   * @dev Uses the configured oracle or default rate otherwise.\n   * @param _originDomain The origin domain id\n   * @param _to The fee recipient\n   * @param _originRelayerFee The relayer fee amount in origin domain native token\n   */\n  function reimburseRelayerFees(\n    uint32 _originDomain,\n    address payable _to,\n    uint256 _originRelayerFee\n  ) external override onlyConnext {\n    uint256 sponsoredFee;\n    uint256 num;\n    uint256 den;\n\n    if (address(gasTokenOracle) != address(0)) {\n      (num, den) = gasTokenOracle.getRate(_originDomain);\n\n      sponsoredFee = (_originRelayerFee * num) / den;\n    } else {\n      num = rates[_originDomain].num;\n      den = rates[_originDomain].den;\n    }\n\n    if (den != 0) {\n      sponsoredFee = (_originRelayerFee * num) / den;\n\n      // calculated or max\n      sponsoredFee = sponsoredFee > relayerFeeCap ? relayerFeeCap : sponsoredFee;\n      // calculated or leftover\n      sponsoredFee = sponsoredFee > address(this).balance ? address(this).balance : sponsoredFee;\n\n      Address.sendValue(_to, sponsoredFee);\n    }\n    emit ReimburseRelayerFees(sponsoredFee, _to);\n  }\n\n  /**\n   * @notice Adds liquidity to the sponsor vault, native token or ERC20.\n   * @dev Anyone can add liquidity.\n   * @param _token The ERC20 token address or address zero for native token\n   * @param _amount The amount of ERC20 to deposit or zero for native token since the amount is sent in msg.value\n   */\n  function deposit(address _token, uint256 _amount) external payable {\n    if (_token != address(0)) {\n      IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    emit Deposit(_token, _token != address(0) ? _amount : msg.value, msg.sender);\n  }\n\n  /**\n   * @notice Removes liquidity from the sponsor vault, native token or ERC20.\n   * @dev Only the owner can remove liquidity.\n   * @param _token The ERC20 token address or address zero for native token\n   * @param _receiver The receiver of the tokens\n   * @param _amount The amount to remove\n   */\n  function withdraw(\n    address _token,\n    address _receiver,\n    uint256 _amount\n  ) external onlyOwner {\n    if (_token == address(0)) {\n      if (address(this).balance < _amount) revert SponsorVault__withdraw_invalidAmount();\n      Address.sendValue(payable(_receiver), _amount);\n    } else {\n      if (IERC20(_token).balanceOf(address(this)) < _amount) revert SponsorVault__withdraw_invalidAmount();\n      IERC20(_token).safeTransfer(_receiver, _amount);\n    }\n\n    emit Withdraw(_token, _receiver, _amount, msg.sender);\n  }\n\n  // ============ Internal functions ============\n\n  function _setConnext(address _connext) internal {\n    if (_connext == address(0)) revert SponsorVault__setConnext_invalidConnext();\n\n    emit ConnextUpdated(connext, _connext, msg.sender);\n\n    connext = _connext;\n  }\n}"
    }
  ]
}