{
  "Title": "M-11: Malicious PartyB can block unfavorable close position requests causing a loss of profits for PartyB",
  "Content": "# Issue M-11: Malicious PartyB can block unfavorable close position requests causing a loss of profits for PartyB \n\nSource: https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/224 \n\n## Found by \nKose, Yuki, berndartmueller, xiaoming90\n## Summary\n\nMalicious PartyB can block close position requests that are unfavorable toward them by intentionally choose not to fulfill the close request and continuously prolonging the force close position cooldown period, causing a loss of profits for PartyA.\n\n## Vulnerability Detail\n\nIf PartyA invokes the `requestToClosePosition` function for an open quote, the quote's status will transition from `QuoteStatus.OPEN` to `QuoteStatus.CLOSE_PENDING`. In case PartyB fails to fulfill the close request (`fillCloseRequest`) during the cooldown period (`maLayout.forceCloseCooldown`), PartyA has the option to forcibly close the quote by utilizing the `forceClosePosition` function.\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol#L261\n\n```solidity\nFile: PartyAFacetImpl.sol\n253:     function forceClosePosition(uint256 quoteId, PairUpnlAndPriceSig memory upnlSig) internal {\n254:         AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n255:         MAStorage.Layout storage maLayout = MAStorage.layout();\n256:         Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n257: \n258:         uint256 filledAmount = quote.quantityToClose;\n259:         require(quote.quoteStatus == QuoteStatus.CLOSE_PENDING, \"PartyAFacet: Invalid state\");\n260:         require(\n261:             block.timestamp > quote.modifyTimestamp + maLayout.forceCloseCooldown,\n262:             \"PartyAFacet: Cooldown not reached\"\n263:         );\n..SNIP..\n```\n\nNevertheless, malicious PartyB can intentionally choose not to fulfill the close request and can continuously prolong the `quote.modifyTimestamp`, thereby preventing PartyA from ever being able to activate the `forceClosePosition` function.\n\nMalicious PartyB could extend the `quote.modifyTimestamp` via the following steps:\n\n1) Line 282 of the `fillCloseRequest` show that it is possible to partially fill a close request. As such, calls the `fillCloseRequest` function with the minimum possible `filledAmount` for the purpose of triggering the `LibQuote.closeQuote` function at Line 292.\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/PartyB/PartyBFacetImpl.sol#L256\n\n```solidity\nFile: PartyBFacetImpl.sol\n256:     function fillCloseRequest(\n257:         uint256 quoteId,\n258:         uint256 filledAmount,\n259:         uint256 closedPrice,\n260:         PairUpnlAndPriceSig memory upnlSig\n261:     ) internal {\n..SNIP..\n281:         if (quote.orderType == OrderType.LIMIT) {\n282:             require(quote.quantityToClose >= filledAmount, \"PartyBFacet: Invalid filledAmount\");\n283:         } else {\n284:             require(quote.quantityToClose == filledAmount, \"PartyBFacet: Invalid filledAmount\");\n285:         }\n..SNIP..\n292:         LibQuote.closeQuote(quote, filledAmount, closedPrice);\n293:     }\n```\n\n2. Once the `LibQuote.closeQuote` function is triggered, Line 153 will update the `quote.modifyTimestamp` to the current timestamp, which effectively extends the cooldown period that PartyA has to wait before allowing to forcefully close the position.\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/libraries/LibQuote.sol#L149\n\n```solidity\nFile: LibQuote.sol\n149:     function closeQuote(Quote storage quote, uint256 filledAmount, uint256 closedPrice) internal {\n150:         QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n151:         AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n152: \n153:         quote.modifyTimestamp = block.timestamp;\n..SNIP..\n```\n\n## Impact\n\nPartyB has the ability to deny users from forcefully closing their positions by exploiting the issue. Malicious PartyB could abuse this by blocking PartyA from closing their positions against them when the price is unfavorable toward them. For instance, when PartyA is winning the game and decided to close some of its positions against PartyB, PartyB could block the close position request to deny PartyA of their profits and prevent themselves from losing the game.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol#L261\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe `quote.modifyTimestamp` is updated to the current timestamp in many functions, including the `closeQuote` function, as shown in the above example.  A quick search within the codebase shows that there are around 17 functions that update the `quote.modifyTimestamp` to the current timestamp when triggered. Each of these functions serves as a potential attack vector for malicious PartyB to extend the `quote.modifyTimestamp` and deny users from forcefully closing their positions\n\nIt is recommended not to use the `quote.modifyTimestamp` for the purpose of determining if the force close position cooldown has reached, as this variable has been used in many other places. Instead, consider creating a new variable, such as `quote.requestClosePositionTimestamp` solely for the purpose of computing the force cancel quote cooldown.\n\nThe following fixes will prevent malicious PartyB from extending the cooldown period since the `quote.requestClosePositionTimestamp` variable is only used solely for the purpose of determining if the force close position cooldown has reached.\n\n```diff\nfunction requestToClosePosition(\n    uint256 quoteId,\n    uint256 closePrice,\n    uint256 quantityToClose,\n    OrderType orderType,\n    uint256 deadline,\n    SingleUpnlAndPriceSig memory upnlSig\n) internal {\n..SNIP..\n    accountLayout.partyANonces[quote.partyA] += 1;\n    quote.modifyTimestamp = block.timestamp;\n+\tquote.requestCancelQuoteTimestamp = block.timestamp;\n```\n\n```diff\nfunction forceClosePosition(uint256 quoteId, PairUpnlAndPriceSig memory upnlSig) internal {\n    AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n    MAStorage.Layout storage maLayout = MAStorage.layout();\n    Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n    uint256 filledAmount = quote.quantityToClose;\n    require(quote.quoteStatus == QuoteStatus.CLOSE_PENDING, \"PartyAFacet: Invalid state\");\n    require(\n-       block.timestamp > quote.modifyTimestamp + maLayout.forceCloseCooldown,\n+       block.timestamp > quote.requestCancelQuoteTimestamp + maLayout.forceCloseCooldown,\n        \"PartyAFacet: Cooldown not reached\"\n    );\n```\n\nIn addition, review the `forceClosePosition` function and applied the same fix to it since it is vulnerable to the same issue, but with a different impact.\n\n\n\n## Discussion\n\n**hrishibhat**\n\n@MoonKnightDev \n\n**hrishibhat**\n\nConsidering this a valid medium based on trust assumptions of partyB\n\n**CodingNameKiki**\n\nEscalate\n\nThe severity should be high:\n- Malicious party B can permanently prevent force closing a position, causing loss of profits for Party A.\n\n### Party Bs aren't intended to be trusted authorities and it can be seen both on the below screenshot and the screenshot at the end.\n\n<img width=\"672\" alt=\"Screenshot 2023-07-26 at 13 41 31\" src=\"https://github.com/sherlock-audit/2023-06-symmetrical-judging/assets/112419701/7817e5bc-132c-448b-8ae3-ddb8030c01f7\">\n\n## Malicious Party B is able to permanently prevent force closing a position by partially closing dust amounts.\n\nReference: #69\n \n### Short explanation\n\nMARKET - requires all of the quantity to be closed\nLIMIT - can be partially closed\n\nSince MARKET order is not allowed from force closing the position, the only way would be to set the order type as LIMIT which is exploitable by Malicious Party B.\n\n- PartyA requests MARKET order close\n\n- PartyB doesn't respond (malicious)\n\n- Market close expires (can't be force closed as a position)\n\n- PartyA requests a LIMIT order close\n\n- PartyB (malicious) partially closes dust amounts in order to reset the quote.modifyTimestamp to the current block.timestamp\n\nIn the end Party A doesn't have a way to close the position.\n\n### Conclusion\n- Party A can only force close position with LIMIT order, as MARKET is not allowed. \n- Party B can close dust amounts and permanently prevent force closing a position.\n\nAs mentioned by the senior watson duo to this issue - Malicious PartyB is able to permanently block unfair closing request towards them, by closing dust amounts in order to update the modify.timestamp, Party B is able to continuously prolonging the force close position cooldown period, causing a loss of profits for PartyA. In the end not even the function forceClosePosition won't be able to save Party A.\n\n### As force closing a position on MARKET order isn't allowed, the malicious Party B can partially close dust amounts to extend the forceCooldown, making the LIMIT order not force closable as well. In the end Party A won't be able to close the position.\n\n- In a case of malicious Party B, even the backup plan described by the sponsor won't work here.\n\n<img width=\"980\" alt=\"Screenshot 2023-07-26 at 13 20 47\" src=\"https://github.com/sherlock-audit/2023-06-symmetrical-judging/assets/112419701/4202c63a-ac45-4cd0-ac7b-f56cb3dc4987\">\n\n\n**sherlock-admin2**\n\n > Escalate\n> \n> The severity should be high:\n> - Malicious party B can permanently prevent force closing a position, causing loss of profits for Party A.\n> \n> ### Party Bs aren't intended to be trusted authorities and it can be seen both on the below screenshot and the screenshot at the end.\n> \n> <img width=\"672\" alt=\"Screenshot 2023-07-26 at 13 41 31\" src=\"https://github.com/sherlock-audit/2023-06-symmetrical-judging/assets/112419701/7817e5bc-132c-448b-8ae3-ddb8030c01f7\">\n> \n> ## Malicious Party B is able to permanently prevent force closing a position by partially closing dust amounts.\n> \n> Reference: #69\n>  \n> ### Short explanation\n> \n> MARKET - requires all of the quantity to be closed\n> LIMIT - can be partially closed\n> \n> Since MARKET order is not allowed from force closing the position, the only way would be to set the order type as LIMIT which is exploitable by Malicious Party B.\n> \n> - PartyA requests MARKET order close\n> \n> - PartyB doesn't respond (malicious)\n> \n> - Market close expires (can't be force closed as a position)\n> \n> - PartyA requests a LIMIT order close\n> \n> - PartyB (malicious) partially closes dust amounts in order to reset the quote.modifyTimestamp to the current block.timestamp\n> \n> In the end Party A doesn't have a way to close the position.\n> \n> ### Conclusion\n> - Party A can only force close position with LIMIT order, as MARKET is not allowed. \n> - Party B can close dust amounts and permanently prevent force closing a position.\n> \n> As mentioned by the senior watson duo to this issue - Malicious PartyB is able to permanently block unfair closing request towards them, by closing dust amounts in order to update the modify.timestamp, Party B is able to continuously prolonging the force close position cooldown period, causing a loss of profits for PartyA. In the end not even the function forceClosePosition won't be able to save Party A.\n> \n> ### As force closing a position on MARKET order isn't allowed, the malicious Party B can partially close dust amounts to extend the forceCooldown, making the LIMIT order not force closable as well. In the end Party A won't be able to close the position.\n> \n> - In a case of malicious Party B, even the backup plan described by the sponsor won't work here.\n> \n> <img width=\"980\" alt=\"Screenshot 2023-07-26 at 13 20 47\" src=\"https://github.com/sherlock-audit/2023-06-symmetrical-judging/assets/112419701/4202c63a-ac45-4cd0-ac7b-f56cb3dc4987\">\n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**CodingNameKiki**\n\nAdditional information from the sponsor.\n\nLeaving the decision to the Sherlock team.\n\n<img width=\"666\" alt=\"Screenshot 2023-07-28 at 16 40 20\" src=\"https://github.com/sherlock-audit/2023-06-symmetrical-judging/assets/112419701/a3609ac1-7a9b-4355-ad0d-ed307934da25\">\n\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nMaintaining the severity of the issue, as partyB currently is a registered entity along with the additional context of the mentioned above where partyB is malicious. \nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/6d2b64b6732fcfbd07c8217897dd233dbb6cd1f5/symmio-core/contracts/facets/control/ControlFacet.sol#L59\nNot penalizing the escalation because there might have been some ambiguity around the trust assumptions. \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [CodingNameKiki](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/224/#issuecomment-1651409829): accepted\n\n**MoonKnightDev**\n\nFixed code PR link:\nhttps://github.com/SYMM-IO/symmio-core/pull/13\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/85",
  "Code": [
    {
      "filename": "symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../libraries/LibLockedValues.sol\";\nimport \"../../libraries/LibMuon.sol\";\nimport \"../../libraries/LibAccount.sol\";\nimport \"../../libraries/LibSolvency.sol\";\nimport \"../../libraries/LibQuote.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/QuoteStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../storages/AccountStorage.sol\";\nimport \"../../storages/SymbolStorage.sol\";\n\nlibrary PartyAFacetImpl {\n    using LockedValuesOps for LockedValues;\n\n    function sendQuote(\n        address[] memory partyBsWhiteList,\n        uint256 symbolId,\n        PositionType positionType,\n        OrderType orderType,\n        uint256 price,\n        uint256 quantity,\n        uint256 cva,\n        uint256 mm,\n        uint256 lf,\n        uint256 maxInterestRate,\n        uint256 deadline,\n        SingleUpnlAndPriceSig memory upnlSig\n    ) internal returns (uint256 currentId) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\n\n        require(\n            quoteLayout.partyAPendingQuotes[msg.sender].length < maLayout.pendingQuotesValidLength,\n            \"PartyAFacet: Number of pending quotes out of range\"\n        );\n        require(symbolLayout.symbols[symbolId].isValid, \"PartyAFacet: Symbol is not valid\");\n        require(deadline >= block.timestamp, \"PartyAFacet: Low deadline\");\n\n        LockedValues memory lockedValues = LockedValues(cva, mm, lf);\n        uint256 tradingPrice = orderType == OrderType.LIMIT ? price : upnlSig.price;\n        uint256 notionalValue = (quantity * tradingPrice) / 1e18;\n        require(\n            lockedValues.total() <= notionalValue,\n            \"PartyAFacet: Leverage can't be lower than one\"\n        );\n\n        require(\n            lockedValues.lf >=\n                (symbolLayout.symbols[symbolId].minAcceptablePortionLF * lockedValues.total()) /\n                    1e18,\n            \"PartyAFacet: LF is not enough\"\n        );\n\n        require(\n            lockedValues.total() >= symbolLayout.symbols[symbolId].minAcceptableQuoteValue,\n            \"PartyAFacet: Quote value is low\"\n        );\n        for (uint8 i = 0; i < partyBsWhiteList.length; i++) {\n            require(\n                partyBsWhiteList[i] != msg.sender,\n                \"PartyAFacet: Sender isn't allowed in partyBWhiteList\"\n            );\n        }\n\n        LibMuon.verifyPartyAUpnlAndPrice(upnlSig, msg.sender, symbolId);\n\n        int256 availableBalance = LibAccount.partyAAvailableForQuote(upnlSig.upnl, msg.sender);\n        require(availableBalance > 0, \"PartyAFacet: Available balance is lower than zero\");\n        require(\n            uint256(availableBalance) >=\n                lockedValues.total() +\n                    ((quantity * tradingPrice * symbolLayout.symbols[symbolId].tradingFee) / 1e36),\n            \"PartyAFacet: insufficient available balance\"\n        );\n\n        // lock funds the in middle of way\n        accountLayout.pendingLockedBalances[msg.sender].add(lockedValues);\n        currentId = ++quoteLayout.lastId;\n        accountLayout.partyANonces[msg.sender] += 1;\n\n        // create quote.\n        Quote memory quote = Quote({\n            id: currentId,\n            partyBsWhiteList: partyBsWhiteList,\n            symbolId: symbolId,\n            positionType: positionType,\n            orderType: orderType,\n            openedPrice: 0,\n            requestedOpenPrice: price,\n            marketPrice: upnlSig.price,\n            quantity: quantity,\n            closedAmount: 0,\n            lockedValues: lockedValues,\n            initialLockedValues: lockedValues,\n            maxInterestRate: maxInterestRate,\n            partyA: msg.sender,\n            partyB: address(0),\n            quoteStatus: QuoteStatus.PENDING,\n            avgClosedPrice: 0,\n            requestedClosePrice: 0,\n            parentId: 0,\n            createTimestamp: block.timestamp,\n            modifyTimestamp: block.timestamp,\n            quantityToClose: 0,\n            deadline: deadline\n        });\n        quoteLayout.quoteIdsOf[msg.sender].push(currentId);\n        quoteLayout.partyAPendingQuotes[msg.sender].push(currentId);\n        quoteLayout.quotes[currentId] = quote;\n\n        LibQuote.receiveTradingFee(currentId);\n    }\n\n    function requestToCancelQuote(uint256 quoteId) internal returns (QuoteStatus result) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(\n            quote.quoteStatus == QuoteStatus.PENDING || quote.quoteStatus == QuoteStatus.LOCKED,\n            \"PartyAFacet: Invalid state\"\n        );\n        accountLayout.partyANonces[quote.partyA] += 1;\n\n        if (block.timestamp > quote.deadline) {\n            result = LibQuote.expireQuote(quoteId);\n        } else if (quote.quoteStatus == QuoteStatus.PENDING) {\n            quote.quoteStatus = QuoteStatus.CANCELED;\n            LibQuote.returnTradingFee(quoteId);\n            accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n            LibQuote.removeFromPartyAPendingQuotes(quote);\n            result = QuoteStatus.CANCELED;\n        } else {\n            // Quote is locked\n            quote.quoteStatus = QuoteStatus.CANCEL_PENDING;\n            result = QuoteStatus.CANCEL_PENDING;\n        }\n        quote.modifyTimestamp = block.timestamp;\n    }\n\n    function requestToClosePosition(\n        uint256 quoteId,\n        uint256 closePrice,\n        uint256 quantityToClose,\n        OrderType orderType,\n        uint256 deadline,\n        SingleUpnlAndPriceSig memory upnlSig\n    ) internal {\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(quote.quoteStatus == QuoteStatus.OPENED, \"PartyAFacet: Invalid state\");\n        require(deadline >= block.timestamp, \"PartyAFacet: Low deadline\");\n        require(\n            LibQuote.quoteOpenAmount(quote) >= quantityToClose,\n            \"PartyAFacet: Invalid quantityToClose\"\n        );\n        LibMuon.verifyPartyAUpnlAndPrice(upnlSig, quote.partyA, quote.symbolId);\n        LibSolvency.isSolventAfterRequestToClosePosition(\n            quoteId,\n            closePrice,\n            quantityToClose,\n            upnlSig\n        );\n\n        // check that remaining position is not too small\n        if (LibQuote.quoteOpenAmount(quote) > quantityToClose) {\n            require(\n                ((LibQuote.quoteOpenAmount(quote) - quantityToClose) * quote.lockedValues.total()) /\n                    LibQuote.quoteOpenAmount(quote) >=\n                    symbolLayout.symbols[quote.symbolId].minAcceptableQuoteValue,\n                \"PartyAFacet: Remaining quote value is low\"\n            );\n        }\n\n        accountLayout.partyANonces[quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.CLOSE_PENDING;\n        quote.requestedClosePrice = closePrice;\n        quote.quantityToClose = quantityToClose;\n        quote.orderType = orderType;\n        quote.deadline = deadline;\n    }\n\n    function requestToCancelCloseRequest(uint256 quoteId) internal returns (QuoteStatus) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(quote.quoteStatus == QuoteStatus.CLOSE_PENDING, \"PartyAFacet: Invalid state\");\n        if (block.timestamp > quote.deadline) {\n            LibQuote.expireQuote(quoteId);\n            return QuoteStatus.OPENED;\n        } else {\n            accountLayout.partyANonces[quote.partyA] += 1;\n            quote.modifyTimestamp = block.timestamp;\n            quote.quoteStatus = QuoteStatus.CANCEL_CLOSE_PENDING;\n            return QuoteStatus.CANCEL_CLOSE_PENDING;\n        }\n    }\n\n    function forceCancelQuote(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(quote.quoteStatus == QuoteStatus.CANCEL_PENDING, \"PartyAFacet: Invalid state\");\n        require(\n            block.timestamp > quote.modifyTimestamp + maLayout.forceCancelCooldown,\n            \"PartyAFacet: Cooldown not reached\"\n        );\n        accountLayout.partyANonces[quote.partyA] += 1;\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.CANCELED;\n        accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n        accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(quote);\n\n        // send trading Fee back to partyA\n        LibQuote.returnTradingFee(quoteId);\n\n        LibQuote.removeFromPendingQuotes(quote);\n    }\n\n    function forceCancelCloseRequest(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n            \"PartyAFacet: Invalid state\"\n        );\n        require(\n            block.timestamp > quote.modifyTimestamp + maLayout.forceCancelCloseCooldown,\n            \"PartyAFacet: Cooldown not reached\"\n        );\n\n        accountLayout.partyANonces[quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.OPENED;\n        quote.requestedClosePrice = 0;\n        quote.quantityToClose = 0;\n    }\n\n    function forceClosePosition(uint256 quoteId, PairUpnlAndPriceSig memory upnlSig) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        uint256 filledAmount = quote.quantityToClose;\n        require(quote.quoteStatus == QuoteStatus.CLOSE_PENDING, \"PartyAFacet: Invalid state\");\n        require(\n            block.timestamp > quote.modifyTimestamp + maLayout.forceCloseCooldown,\n            \"PartyAFacet: Cooldown not reached\"\n        );\n        require(block.timestamp <= quote.deadline, \"PartyBFacet: Quote is expired\");\n        require(\n            quote.orderType == OrderType.LIMIT,\n            \"PartyBFacet: Quote's order type should be LIMIT\"\n        );\n        if (quote.positionType == PositionType.LONG) {\n            require(\n                upnlSig.price >=\n                    quote.requestedClosePrice +\n                        (quote.requestedClosePrice * maLayout.forceCloseGapRatio) /\n                        1e18,\n                \"PartyAFacet: Requested close price not reached\"\n            );\n        } else {\n            require(\n                upnlSig.price <=\n                    quote.requestedClosePrice -\n                        (quote.requestedClosePrice * maLayout.forceCloseGapRatio) /\n                        1e18,\n                \"PartyAFacet: Requested close price not reached\"\n            );\n        }\n\n        LibMuon.verifyPairUpnlAndPrice(upnlSig, quote.partyB, quote.partyA, quote.symbolId);\n        LibSolvency.isSolventAfterClosePosition(\n            quoteId,\n            filledAmount,\n            quote.requestedClosePrice,\n            upnlSig\n        );\n        accountLayout.partyANonces[quote.partyA] += 1;\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        LibQuote.closeQuote(quote, filledAmount, quote.requestedClosePrice);\n    }\n}"
    },
    {
      "filename": "symmio-core/contracts/facets/PartyB/PartyBFacetImpl.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../libraries/LibLockedValues.sol\";\nimport \"../../libraries/LibMuon.sol\";\nimport \"../../libraries/LibAccount.sol\";\nimport \"../../libraries/LibSolvency.sol\";\nimport \"../../libraries/LibQuote.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/QuoteStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../storages/GlobalAppStorage.sol\";\nimport \"../../storages/AccountStorage.sol\";\nimport \"../../storages/SymbolStorage.sol\";\n\nlibrary PartyBFacetImpl {\n    using LockedValuesOps for LockedValues;\n\n    function lockQuote(uint256 quoteId, SingleUpnlSig memory upnlSig, bool increaseNonce) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        LibMuon.verifyPartyBUpnl(upnlSig, msg.sender, quote.partyA);\n        checkPartyBValidationToLockQuote(quoteId, upnlSig.upnl);\n        if (increaseNonce) {\n            accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        }\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.LOCKED;\n        quote.partyB = msg.sender;\n        // lock funds for partyB\n        accountLayout.partyBPendingLockedBalances[msg.sender][quote.partyA].addQuote(quote);\n        quoteLayout.partyBPendingQuotes[msg.sender][quote.partyA].push(quote.id);\n    }\n\n    function unlockQuote(uint256 quoteId) internal returns (QuoteStatus) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        require(quote.quoteStatus == QuoteStatus.LOCKED, \"PartyBFacet: Invalid state\");\n        if (block.timestamp > quote.deadline) {\n            QuoteStatus result = LibQuote.expireQuote(quoteId);\n            return result;\n        } else {\n            accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n            quote.modifyTimestamp = block.timestamp;\n            quote.quoteStatus = QuoteStatus.PENDING;\n            accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(quote);\n            LibQuote.removeFromPartyBPendingQuotes(quote);\n            quote.partyB = address(0);\n            return QuoteStatus.PENDING;\n        }\n    }\n\n    function acceptCancelRequest(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        require(quote.quoteStatus == QuoteStatus.CANCEL_PENDING, \"PartyBFacet: Invalid state\");\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.CANCELED;\n        accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n        accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(quote);\n        // send trading Fee back to partyA\n        LibQuote.returnTradingFee(quoteId);\n\n        LibQuote.removeFromPendingQuotes(quote);\n    }\n\n    function checkPartyBValidationToLockQuote(uint256 quoteId, int256 upnl) internal view {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        require(quote.quoteStatus == QuoteStatus.PENDING, \"PartyBFacet: Invalid state\");\n        require(block.timestamp <= quote.deadline, \"PartyBFacet: Quote is expired\");\n        require(quoteId <= quoteLayout.lastId, \"PartyBFacet: Invalid quoteId\");\n        int256 availableBalance = LibAccount.partyBAvailableForQuote(\n            upnl,\n            msg.sender,\n            quote.partyA\n        );\n        require(availableBalance >= 0, \"PartyBFacet: Available balance is lower than zero\");\n        require(\n            uint256(availableBalance) >= quote.lockedValues.total(),\n            \"PartyBFacet: insufficient available balance\"\n        );\n        require(\n            !maLayout.partyBLiquidationStatus[msg.sender][quote.partyA],\n            \"PartyBFacet: PartyB isn't solvent\"\n        );\n        bool isValidPartyB;\n        if (quote.partyBsWhiteList.length == 0) {\n            require(msg.sender != quote.partyA, \"PartyBFacet: PartyA can't be partyB too\");\n            isValidPartyB = true;\n        } else {\n            for (uint8 index = 0; index < quote.partyBsWhiteList.length; index++) {\n                if (msg.sender == quote.partyBsWhiteList[index]) {\n                    isValidPartyB = true;\n                    break;\n                }\n            }\n        }\n        require(isValidPartyB, \"PartyBFacet: Sender isn't whitelisted\");\n    }\n\n    function openPosition(\n        uint256 quoteId,\n        uint256 filledAmount,\n        uint256 openedPrice,\n        PairUpnlAndPriceSig memory upnlSig\n    ) internal returns (uint256 currentId) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        require(\n            quote.quoteStatus == QuoteStatus.LOCKED ||\n            quote.quoteStatus == QuoteStatus.CANCEL_PENDING,\n            \"PartyBFacet: Invalid state\"\n        );\n        require(block.timestamp <= quote.deadline, \"PartyBFacet: Quote is expired\");\n        if (quote.orderType == OrderType.LIMIT) {\n            require(\n                quote.quantity >= filledAmount && filledAmount > 0,\n                \"PartyBFacet: Invalid filledAmount\"\n            );\n        } else {\n            require(quote.quantity == filledAmount, \"PartyBFacet: Invalid filledAmount\");\n        }\n        if (quote.positionType == PositionType.LONG) {\n            require(\n                openedPrice <= quote.requestedOpenPrice,\n                \"PartyBFacet: Opened price isn't valid\"\n            );\n        } else {\n            require(\n                openedPrice >= quote.requestedOpenPrice,\n                \"PartyBFacet: Opened price isn't valid\"\n            );\n        }\n        LibMuon.verifyPairUpnlAndPrice(upnlSig, quote.partyB, quote.partyA, quote.symbolId);\n\n        quote.openedPrice = openedPrice;\n        LibSolvency.isSolventAfterOpenPosition(quoteId, filledAmount, upnlSig);\n\n        accountLayout.partyANonces[quote.partyA] += 1;\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n\n        LibQuote.removeFromPendingQuotes(quote);\n\n        if (quote.quantity == filledAmount) {\n            accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n            accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(quote);\n\n            if (quote.orderType == OrderType.LIMIT) {\n                quote.lockedValues.mul(openedPrice).div(quote.requestedOpenPrice);\n            }\n            accountLayout.lockedBalances[quote.partyA].addQuote(quote);\n            accountLayout.partyBLockedBalances[quote.partyB][quote.partyA].addQuote(quote);\n        }\n        // partially fill\n        else {\n            currentId = ++quoteLayout.lastId;\n            QuoteStatus newStatus;\n            if (quote.quoteStatus == QuoteStatus.CANCEL_PENDING) {\n                newStatus = QuoteStatus.CANCELED;\n            } else {\n                newStatus = QuoteStatus.PENDING;\n                quoteLayout.partyAPendingQuotes[quote.partyA].push(currentId);\n            }\n            LockedValues memory filledLockedValues = LockedValues(\n                (quote.lockedValues.cva * filledAmount) / quote.quantity,\n                (quote.lockedValues.mm * filledAmount) / quote.quantity,\n                (quote.lockedValues.lf * filledAmount) / quote.quantity\n            );\n            LockedValues memory appliedFilledLockedValues = filledLockedValues;\n            appliedFilledLockedValues = appliedFilledLockedValues.mulMem(openedPrice);\n            appliedFilledLockedValues = appliedFilledLockedValues.divMem(quote.requestedOpenPrice);\n            // check that opened position is not minor position\n            require(\n                appliedFilledLockedValues.total() >=\n                SymbolStorage.layout().symbols[quote.symbolId].minAcceptableQuoteValue,\n                \"PartyBFacet: Quote value is low\"\n            );\n            // check that new pending position is not minor position\n            require(\n                (quote.lockedValues.total() - filledLockedValues.total()) >=\n                SymbolStorage.layout().symbols[quote.symbolId].minAcceptableQuoteValue,\n                \"PartyBFacet: Quote value is low\"\n            );\n\n            Quote memory q = Quote({\n                id: currentId,\n                partyBsWhiteList: quote.partyBsWhiteList,\n                symbolId: quote.symbolId,\n                positionType: quote.positionType,\n                orderType: quote.orderType,\n                openedPrice: 0,\n                requestedOpenPrice: quote.requestedOpenPrice,\n                marketPrice: quote.marketPrice,\n                quantity: quote.quantity - filledAmount,\n                closedAmount: 0,\n                lockedValues: LockedValues(0, 0, 0),\n                initialLockedValues: LockedValues(0, 0, 0),\n                maxInterestRate: quote.maxInterestRate,\n                partyA: quote.partyA,\n                partyB: address(0),\n                quoteStatus: newStatus,\n                avgClosedPrice: 0,\n                requestedClosePrice: 0,\n                parentId: quote.id,\n                createTimestamp: quote.createTimestamp,\n                modifyTimestamp: block.timestamp,\n                quantityToClose: 0,\n                deadline: quote.deadline\n            });\n\n            quoteLayout.quoteIdsOf[quote.partyA].push(currentId);\n            quoteLayout.quotes[currentId] = q;\n            Quote storage newQuote = quoteLayout.quotes[currentId];\n\n            if (newStatus == QuoteStatus.CANCELED) {\n                // send trading Fee back to partyA\n                LibQuote.returnTradingFee(currentId);\n                // part of quote has been filled and part of it has been canceled\n                accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n                accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(\n                    quote\n                );\n            } else {\n                accountLayout.pendingLockedBalances[quote.partyA].sub(filledLockedValues);\n                accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].sub(\n                    filledLockedValues\n                );\n            }\n            newQuote.lockedValues = quote.lockedValues.sub(filledLockedValues);\n            newQuote.initialLockedValues = newQuote.lockedValues;\n            quote.quantity = filledAmount;\n            quote.lockedValues = appliedFilledLockedValues;\n\n            // lock with amount of filledAmount\n            accountLayout.lockedBalances[quote.partyA].addQuote(quote);\n            accountLayout.partyBLockedBalances[quote.partyB][quote.partyA].addQuote(quote);\n        }\n        quote.quoteStatus = QuoteStatus.OPENED;\n        LibQuote.addToOpenPositions(quoteId);\n    }\n\n    function fillCloseRequest(\n        uint256 quoteId,\n        uint256 filledAmount,\n        uint256 closedPrice,\n        PairUpnlAndPriceSig memory upnlSig\n    ) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        require(\n            quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n            \"PartyBFacet: Invalid state\"\n        );\n        require(block.timestamp <= quote.deadline, \"PartyBFacet: Quote is expired\");\n        if (quote.positionType == PositionType.LONG) {\n            require(\n                closedPrice >= quote.requestedClosePrice,\n                \"PartyBFacet: Closed price isn't valid\"\n            );\n        } else {\n            require(\n                closedPrice <= quote.requestedClosePrice,\n                \"PartyBFacet: Closed price isn't valid\"\n            );\n        }\n        if (quote.orderType == OrderType.LIMIT) {\n            require(quote.quantityToClose >= filledAmount, \"PartyBFacet: Invalid filledAmount\");\n        } else {\n            require(quote.quantityToClose == filledAmount, \"PartyBFacet: Invalid filledAmount\");\n        }\n\n        LibMuon.verifyPairUpnlAndPrice(upnlSig, quote.partyB, quote.partyA, quote.symbolId);\n        LibSolvency.isSolventAfterClosePosition(quoteId, filledAmount, closedPrice, upnlSig);\n\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        accountLayout.partyANonces[quote.partyA] += 1;\n        LibQuote.closeQuote(quote, filledAmount, closedPrice);\n    }\n\n    function acceptCancelCloseRequest(uint256 quoteId) internal {\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n            \"PartyBFacet: Invalid state\"\n        );\n        AccountStorage.layout().partyBNonces[quote.partyB][quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.OPENED;\n        quote.requestedClosePrice = 0;\n        quote.quantityToClose = 0;\n    }\n\n    function emergencyClosePosition(uint256 quoteId, PairUpnlAndPriceSig memory upnlSig) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        require(quote.quoteStatus == QuoteStatus.OPENED, \"PartyBFacet: Invalid state\");\n        LibMuon.verifyPairUpnlAndPrice(upnlSig, quote.partyB, quote.partyA, quote.symbolId);\n        uint256 filledAmount = LibQuote.quoteOpenAmount(quote);\n        quote.quantityToClose = filledAmount;\n        quote.requestedClosePrice = upnlSig.price;\n        LibSolvency.isSolventAfterClosePosition(quoteId, filledAmount, upnlSig.price, upnlSig);\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        accountLayout.partyANonces[quote.partyA] += 1;\n        LibQuote.closeQuote(quote, filledAmount, upnlSig.price);\n    }\n\n}"
    },
    {
      "filename": "symmio-core/contracts/libraries/LibQuote.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"./LibLockedValues.sol\";\nimport \"../storages/QuoteStorage.sol\";\nimport \"../storages/AccountStorage.sol\";\nimport \"../storages/GlobalAppStorage.sol\";\nimport \"../storages/SymbolStorage.sol\";\nimport \"../storages/MAStorage.sol\";\n\nlibrary LibQuote {\n    using LockedValuesOps for LockedValues;\n\n    function getAmountToLockOfQuote(Quote storage quote) internal view returns (uint256) {\n        return quote.lockedValues.total();\n    }\n\n    function quoteOpenAmount(Quote storage quote) internal view returns (uint256) {\n        return quote.quantity - quote.closedAmount;\n    }\n\n    function getIndexOfItem(\n        uint256[] storage array_,\n        uint256 item\n    ) internal view returns (uint256) {\n        for (uint256 index = 0; index < array_.length; index++) {\n            if (array_[index] == item) return index;\n        }\n        return type(uint256).max;\n    }\n\n    function removeFromArray(uint256[] storage array_, uint256 item) internal {\n        uint256 index = getIndexOfItem(array_, item);\n        require(index != type(uint256).max, \"LibQuote: Item not Found\");\n        array_[index] = array_[array_.length - 1];\n        array_.pop();\n    }\n\n    function removeFromPartyAPendingQuotes(Quote storage quote) internal {\n        removeFromArray(QuoteStorage.layout().partyAPendingQuotes[quote.partyA], quote.id);\n    }\n\n    function removeFromPartyBPendingQuotes(Quote storage quote) internal {\n        removeFromArray(\n            QuoteStorage.layout().partyBPendingQuotes[quote.partyB][quote.partyA],\n            quote.id\n        );\n    }\n\n    function removeFromPendingQuotes(Quote storage quote) internal {\n        removeFromPartyAPendingQuotes(quote);\n        removeFromPartyBPendingQuotes(quote);\n    }\n\n    function addToOpenPositions(uint256 quoteId) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        Quote storage quote = quoteLayout.quotes[quoteId];\n\n        quoteLayout.partyAOpenPositions[quote.partyA].push(quote.id);\n        quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA].push(quote.id);\n\n        quoteLayout.partyAPositionsIndex[quote.id] = quoteLayout.partyAPositionsCount[quote.partyA];\n        quoteLayout.partyBPositionsIndex[quote.id] = quoteLayout.partyBPositionsCount[quote.partyB][\n            quote.partyA\n        ];\n\n        quoteLayout.partyAPositionsCount[quote.partyA] += 1;\n        quoteLayout.partyBPositionsCount[quote.partyB][quote.partyA] += 1;\n    }\n\n    function removeFromOpenPositions(uint256 quoteId) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        uint256 indexOfPartyAPosition = quoteLayout.partyAPositionsIndex[quote.id];\n        uint256 indexOfPartyBPosition = quoteLayout.partyBPositionsIndex[quote.id];\n        uint256 lastOpenPositionIndex = quoteLayout.partyAPositionsCount[quote.partyA] - 1;\n        quoteLayout.partyAOpenPositions[quote.partyA][indexOfPartyAPosition] = quoteLayout\n            .partyAOpenPositions[quote.partyA][lastOpenPositionIndex];\n        quoteLayout.partyAPositionsIndex[\n            quoteLayout.partyAOpenPositions[quote.partyA][lastOpenPositionIndex]\n        ] = indexOfPartyAPosition;\n        quoteLayout.partyAOpenPositions[quote.partyA].pop();\n\n        lastOpenPositionIndex = quoteLayout.partyBPositionsCount[quote.partyB][quote.partyA] - 1;\n        quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA][\n            indexOfPartyBPosition\n        ] = quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA][lastOpenPositionIndex];\n        quoteLayout.partyBPositionsIndex[\n            quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA][lastOpenPositionIndex]\n        ] = indexOfPartyBPosition;\n        quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA].pop();\n\n        quoteLayout.partyAPositionsIndex[quote.id] = 0;\n        quoteLayout.partyBPositionsIndex[quote.id] = 0;\n    }\n\n    function getValueOfQuoteForPartyA(\n        uint256 currentPrice,\n        uint256 filledAmount,\n        Quote storage quote\n    ) internal view returns (bool hasMadeProfit, uint256 pnl) {\n        if (currentPrice > quote.openedPrice) {\n            if (quote.positionType == PositionType.LONG) {\n                hasMadeProfit = true;\n            } else {\n                hasMadeProfit = false;\n            }\n            pnl = ((currentPrice - quote.openedPrice) * filledAmount) / 1e18;\n        } else {\n            if (quote.positionType == PositionType.LONG) {\n                hasMadeProfit = false;\n            } else {\n                hasMadeProfit = true;\n            }\n            pnl = ((quote.openedPrice - currentPrice) * filledAmount) / 1e18;\n        }\n    }\n\n    function getTradingFee(uint256 quoteId) internal view returns (uint256 fee) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        Symbol storage symbol = SymbolStorage.layout().symbols[quote.symbolId];\n        if (quote.orderType == OrderType.LIMIT) {\n            fee =\n                (LibQuote.quoteOpenAmount(quote) * quote.requestedOpenPrice * symbol.tradingFee) /\n                1e36;\n        } else {\n            fee = (LibQuote.quoteOpenAmount(quote) * quote.marketPrice * symbol.tradingFee) / 1e36;\n        }\n    }\n\n    function returnTradingFee(uint256 quoteI"
    }
  ]
}