{
  "Title": "KintoID, Factory and SponsorPaymaster initialize frontrun",
  "Content": "##### Description\n\nKintoId, Factory and SponsorPaymaster contracts require calling `initialize()` during the deployment. These functions are public. So, they can be frontrun by not authorized addresses.\nIn the Factory contract, it will allow to set own KintoId address, in KintoID it will allow to set malicious roles, and in SponsorPaymaster it will allow to set the owner which will receive gas compensation balance.\n- https://github.com/KintoXYZ/kinto-core/blob/f7dd98f66b9dfba1f73758703b808051196e740b/src/KintoID.sol#L63-L73\n- https://github.com/KintoXYZ/kinto-core/blob/f7dd98f66b9dfba1f73758703b808051196e740b/src/wallet/KintoWalletFactory.sol#L50-L56\n- https://github.com/KintoXYZ/kinto-core/blob/f7dd98f66b9dfba1f73758703b808051196e740b/src/paymasters/SponsorPaymaster.sol#L45-L50\n\nThe severity of this issue is high enough but it must be noted that the likelihood is quite low as the deployment process happens in the controlled chain.\n\n##### Recommendation\n\nWe recommend having either all deployment steps in one transaction or setting the allowed `initialize()` caller in the `constructor()`.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/KintoID.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\n/* External Imports */\nimport '@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155SupplyUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport {SignatureChecker} from '@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/structs/BitMapsUpgradeable.sol';\nimport {IKintoID} from './interfaces/IKintoID.sol';\n\n// import \"forge-std/console2.sol\";\n\n\n/**\n * @title Kinto ID\n * @dev The Kinto ID predeploy provides an interface to access all the ID functionality from the L2.\n */\ncontract KintoID is Initializable,\n    ERC1155Upgradeable, AccessControlUpgradeable, ERC1155SupplyUpgradeable, UUPSUpgradeable, IKintoID {\n    using BitMapsUpgradeable for BitMapsUpgradeable.BitMap;\n    using ECDSAUpgradeable for bytes32;\n    using SignatureChecker for address;\n\n    /* ============ Events ============ */\n    event TraitAdded(address indexed _to, uint16 _traitIndex, uint256 _timestamp);\n    event TraitRemoved(address indexed _to, uint16 _traitIndex, uint256 _timestamp);\n    event SanctionAdded(address indexed _to, uint16 _sanctionIndex, uint256 _timestamp);\n    event SanctionRemoved(address indexed _to, uint16 _sanctionIndex, uint256 _timestamp);\n    event AccountsMonitoredAt(address indexed _signer, uint256 _accountsCount, uint256 _timestamp);\n\n    /* ============ Constants ============ */\n    bytes32 public override constant KYC_PROVIDER_ROLE = keccak256('KYC_PROVIDER_ROLE');\n    bytes32 public override constant UPGRADER_ROLE = keccak256('UPGRADER_ROLE');\n\n    uint8 public override constant KYC_TOKEN_ID = 1;\n\n    // We'll monitor the whole list every single day and update it\n    uint256 public override lastMonitoredAt;\n\n    /* ============ State Variables ============ */\n\n    // Metadata for each minted token\n    mapping(address => IKintoID.Metadata) private _kycmetas;\n\n    /// @dev We include a nonce in every hashed message, and increment the nonce as part of a\n    /// state-changing operation, so as to prevent replay attacks, i.e. the reuse of a signature.\n    mapping(address => uint256) public override nonces;\n\n    /* ============ Modifiers ============ */\n\n\n    /* ============ Constructor & Initializers ============ */\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize() initializer public {\n        __ERC1155_init('https://mamorilabs.com/metadata/{id}.json'); // pinata, ipfs\n        __AccessControl_init();\n        __ERC1155Supply_init();\n        __UUPSUpgradeable_init();\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(KYC_PROVIDER_ROLE, msg.sender);\n        _setupRole(UPGRADER_ROLE, msg.sender);\n        lastMonitoredAt = block.timestamp;\n    }\n\n    /**\n     * @dev Authorize the upgrade. Only by the upgrader role.\n     * @param newImplementation address of the new implementation\n     */\n    // This function is called by the proxy contract when the implementation is upgraded\n    function _authorizeUpgrade(address newImplementation) internal onlyRole(UPGRADER_ROLE) override {}\n\n    /* ============ Token name, symbol & URI ============ */\n\n    /**\n     * @dev Gets the token name.\n     * @return string representing the token name\n     */\n    function name() external pure override returns (string memory) {\n        return 'Kinto ID';\n    }\n\n    /**\n     * @dev Gets the token symbol.\n     * @return string representing the token symbol\n     */\n    function symbol() external pure override returns (string memory) {\n        return 'KINID';\n    }\n\n    /**\n     * @dev Sets the token URI. Only by the admin role.\n     * @param newuri representing the token URI.\n     */\n    function setURI(string memory newuri) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setURI(newuri);\n    }\n\n    /* ============ Mint & Burn ============ */\n\n    /**\n     * @dev Mints a new individual KYC token.\n     * @param _signatureData Signature data\n     * @param _traits Traits to be added to the account.\n     */\n    function mintIndividualKyc(IKintoID.SignatureData calldata _signatureData, uint16[] memory _traits)\n        external override {\n        _mintTo(KYC_TOKEN_ID, _signatureData,_traits, true);\n    }\n\n    /**\n     * @dev Mints a new company KYC token.\n     * @param _signatureData Signature data\n     * @param _traits Traits to be added to the account.\n     */\n    function mintCompanyKyc(IKintoID.SignatureData calldata _signatureData, uint16[] memory _traits)\n        external override {\n        _mintTo(KYC_TOKEN_ID, _signatureData, _traits, false);\n    }\n\n    /**\n     * @dev Mints a new token to the given account.\n     * @param _tokenId Token ID to be minted\n     * @param _signatureData Signature data\n     * @param _traits Traits to be added to the account.\n     * @param _indiv Whether the account is individual or a company.\n    */\n    function _mintTo(\n        uint8 _tokenId,\n        IKintoID.SignatureData calldata _signatureData,\n        uint16[] memory _traits,\n        bool _indiv\n    ) private\n      onlySignerVerified(_tokenId, _signatureData) {\n       require(balanceOf(_signatureData.account, _tokenId) == 0, 'Balance before mint must be 0');\n\n       Metadata storage meta = _kycmetas[_signatureData.account];\n       meta.mintedAt = block.timestamp;\n       meta.individual = _indiv;\n\n       for (uint16 i = 0; i < _traits.length; i++) {\n           meta.traits.set(_traits[i]);\n       }\n\n       nonces[_signatureData.account]++;\n       _mint(_signatureData.account, _tokenId, 1, '');\n    }\n\n    /* ============ Burn ============ */\n\n    /**\n     * @dev Burns a KYC token.\n     * @param _signatureData Signature data\n     */\n    function burnKYC(SignatureData calldata _signatureData) external override {\n        _burnp(KYC_TOKEN_ID, _signatureData);\n    }\n\n    /**\n     * @dev Burns a token.\n     * @param _tokenId  token ID to be burned\n     * @param _signatureData Signature data\n     */\n    function _burnp(\n        uint256 _tokenId,\n        SignatureData calldata _signatureData\n    ) private onlySignerVerified(_tokenId, _signatureData) {\n        require(balanceOf(_signatureData.account, _tokenId) > 0, 'Nothing to burn');\n        nonces[_signatureData.account] += 1;\n        _burn(_signatureData.account, _tokenId, 1);\n        require(balanceOf(_signatureData.account, _tokenId) == 0, 'Balance after burn must be 0');\n    }\n\n    /* ============ Sanctions & traits ============ */\n\n    /**\n     * @dev Monitors the account. Only by the KYC provider role.\n     */\n    function monitor(\n        address[] memory _accounts,\n        IKintoID.MonitorUpdateData[][] memory _traitsAndSanctions\n    ) external override onlyRole(KYC_PROVIDER_ROLE) {\n        require(_accounts.length == _traitsAndSanctions.length, 'Length mismatch');\n        require(_accounts.length <= 200, 'Too many accounts to monitor at once');\n        for (uint8 i = 0; i < _accounts.length; i+= 1) {\n            require(balanceOf(_accounts[i], 1) > 0, 'Invalid account address');\n            Metadata storage meta = _kycmetas[_accounts[i]];\n            meta.updatedAt = block.timestamp;\n            for (uint16 j = 0; j < _traitsAndSanctions[i].length; j+= 1) {\n                IKintoID.MonitorUpdateData memory updateData = _traitsAndSanctions[i][j];\n                if (updateData.isTrait && updateData.isSet) {\n                    addTrait(_accounts[i], updateData.index);\n                } else if (updateData.isTrait && !updateData.isSet) {\n                    removeTrait(_accounts[i], updateData.index);\n                } else if (!updateData.isTrait && updateData.isSet) {\n                    addSanction(_accounts[i], updateData.index);\n                } else {\n                    removeSanction(_accounts[i], updateData.index);\n                }\n            }\n        }\n        lastMonitoredAt = block.timestamp;\n        emit AccountsMonitoredAt(msg.sender, _accounts.length, block.timestamp);\n    }\n\n    /**\n     * @dev Adds a trait to the account. Only by the KYC provider role.\n     * @param _account  account to be added the trait to.\n     * @param _traitId trait id to be added.\n     */\n    function addTrait(address _account, uint16 _traitId) public override onlyRole(KYC_PROVIDER_ROLE) {\n        Metadata storage meta = _kycmetas[_account];\n        if (!meta.traits.get(_traitId)) {\n          meta.traits.set(_traitId);\n          meta.updatedAt = block.timestamp;\n          emit TraitAdded(_account, _traitId, block.timestamp);\n        }\n    }\n\n    /**\n     * @dev Removes a trait from the account. Only by the KYC provider role.\n     * @param _account  account to be removed the trait from.\n     * @param _traitId trait id to be removed.\n     */\n    function removeTrait(address _account, uint16 _traitId) public override onlyRole(KYC_PROVIDER_ROLE) {\n        Metadata storage meta = _kycmetas[_account];\n\n        if (meta.traits.get(_traitId)) {\n            meta.traits.unset(_traitId);\n            meta.updatedAt = block.timestamp;\n            emit TraitRemoved(_account, _traitId, block.timestamp);\n        }\n    }\n\n    /**\n     * @dev Adds a sanction to the account. Only by the KYC provider role.\n     * @param _account  account to be added the sanction to.\n     * @param _countryId country id to be added.\n     */\n    function addSanction(address _account, uint16 _countryId) public override onlyRole(KYC_PROVIDER_ROLE) {\n        Metadata storage meta = _kycmetas[_account];\n        if (!meta.sanctions.get(_countryId)) {\n            meta.sanctions.set(_countryId);\n            meta.sanctionsCount += 1;\n            meta.updatedAt = block.timestamp;\n            emit SanctionAdded(_account, _countryId, block.timestamp);\n        }\n    }\n\n    /**\n     * @dev Removes a sanction from the account. Only by the KYC provider role.\n     * @param _account  account to be removed the sanction from.\n     * @param _countryId country id to be removed.\n     */\n    function removeSanction(address _account, uint16 _countryId) public override onlyRole(KYC_PROVIDER_ROLE) {\n        Metadata storage meta = _kycmetas[_account];\n        if (meta.sanctions.get(_countryId)) {\n            meta.sanctions.unset(_countryId);\n            meta.sanctionsCount -= 1;\n            meta.updatedAt = block.timestamp;\n            emit SanctionRemoved(_account, _countryId, block.timestamp);\n        }\n    }\n\n    /* ============ View Functions ============ */\n\n    /**\n     * @dev Returns whether the account holder is KYCd\n     * @param _account account to be checked.\n     * @return true if the account has KYC token.\n     */\n    function isKYC(address _account) external view override returns (bool) {\n        return balanceOf(_account, KYC_TOKEN_ID) > 0 && isSanctionsSafe(_account);\n    }\n\n    /**\n     * @dev Returns whether the account has been monitored in the last x days.\n     * @param _days Days to be checked.\n     * @return true if the account has been monitored in the last x days.\n    */\n    function isSanctionsMonitored(uint32 _days) public view override returns(bool) {\n        return block.timestamp - lastMonitoredAt < _days * (1 days);\n    }\n\n    /**\n     * @dev Returns whether the account is sanctions safe.\n     * @param _account account to be checked.\n     * @return true if the account is sanctions safe.\n     */\n    function isSanctionsSafe(address _account) public view override returns (bool) {\n        return isSanctionsMonitored(7) && _kycmetas[_account].sanctionsCount == 0;\n    }\n\n    /**\n     * @dev Returns whether the account is sanctions safe in a given country.\n     * @param _account account to be checked.\n     * @param _countryId country id to be checked.\n     * @return true if the account is sanctions safe in a given country.\n     */\n    function isSanctionsSafeIn(address _account, uint16 _countryId) external view override returns (bool) {\n        return isSanctionsMonitored(7) && !_kycmetas[_account].sanctions.get(_countryId);\n    }\n\n    /**\n     * @dev Returns whether the KYC account is a company\n     * @param _account account to be checked.\n     * @return true if the account is a company.\n     */\n    function isCompany(address _account) external view override returns (bool) {\n        return !_kycmetas[_account].individual;\n    }\n\n    /**\n     * @dev Returns whether the KYC account is an individual\n     * @param _account account to be checked.\n     * @return true if the account is an indivdual.\n     */\n    function isIndividual(address _account) external view override returns (bool) {\n        return _kycmetas[_account].individual;\n    }\n\n    /**\n     * @dev Returns the timestamp when the KYC token was minted\n     * @param _account account to be checked.\n     * @return timestamp when the KYC token was minted.\n     */\n    function mintedAt(address _account) external view override returns (uint256) {\n        return _kycmetas[_account].mintedAt;\n    }\n\n    /**\n     * @dev Returns whether the account has a given trait.\n     * @param _account account to be checked.\n     * @param index index of the trait to be checked.\n     * @return true if the account has the trait.\n     */\n    function hasTrait(address _account, uint16 index) external view override returns (bool) {\n        return _kycmetas[_account].traits.get(index);\n    }\n\n    /**\n     * @dev Returns an array of 256 booleans representing the traits of the account.\n     * @param _account account to be checked.\n     * @return array of 256 booleans representing the traits of the account.\n     */\n    function traits(address _account) external view override returns (bool[] memory) {\n        BitMapsUpgradeable.BitMap storage tokenTraits = _kycmetas[_account].traits;\n        bool[] memory result = new bool[](256);\n        for (uint256 i = 0; i < 256; i++) {\n            result[i] = tokenTraits.get(i);\n        }\n        return result;\n    }\n\n    /* ============ Signature Recovery ============ */\n\n    /**\n     * @dev Check that the signature is valid and the sender is a valid KYC provider.\n     * @param _id id of the token to be signed.\n     * @param _signature signature to be recovered.\n     */\n    modifier onlySignerVerified(\n      uint256 _id,\n      IKintoID.SignatureData calldata _signature\n    ) {\n        require(block.timestamp < _signature.expiresAt, 'Signature has expired');\n        require(nonces[_signature.signer] == _signature.nonce, 'Invalid Nonce');\n        require(hasRole(KYC_PROVIDER_ROLE, msg.sender), 'Invalid Provider');\n\n        bytes32 hash = keccak256(\n          abi.encodePacked(\n            '\\x19\\x01',   // EIP-191 header\n            keccak256(abi.encode(\n                _signature.signer,\n                address(this),\n                _signature.account,\n                _id,\n                _signature.expiresAt,\n                nonces[_signature.signer],\n                bytes32(block.chainid)\n            ))\n          )\n        ).toEthSignedMessageHash();\n\n        require(\n          _signature.signer.isValidSignatureNow(hash, _signature.signature),\n          'Invalid Signer'\n        );\n        _;\n    }\n\n    /* ============ Disable token transfers ============ */\n\n    /**\n     * @dev Hook that is called before any token transfer. Allow only mints and burns, no transfers.\n     * @param operator address which called `safeTransferFrom` function\n     * @param from source address\n     * @param to target address\n     * @param ids ids of the token type\n     * @param amounts transfer amounts\n     * @param data additional data with no specified format\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal override(ERC1155Upgradeable, ERC1155SupplyUpgradeable) {\n        require(\n          (from == address(0) && to != address(0)) || (from != address(0) && to == address(0)),\n          'Only mint or burn transfers are allowed'\n        );\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n    }\n\n    /* ============ Interface ============ */\n\n    /**\n     * @dev Returns whether the contract implements the interface defined by the id\n     * @param interfaceId id of the interface to be checked.\n     * @return true if the contract implements the interface defined by the id.\n    */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view override(ERC1155Upgradeable, AccessControlUpgradeable) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}"
    },
    {
      "filename": "src/wallet/KintoWalletFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\nimport '@openzeppelin/contracts/utils/Create2.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport { UpgradeableBeacon } from '@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol';\nimport { SafeBeaconProxy } from '../proxy/SafeBeaconProxy.sol';\n\nimport '../interfaces/IKintoID.sol';\nimport '../interfaces/IKintoWalletFactory.sol';\nimport './KintoWallet.sol';\n\n/**\n * @title KintoWalletFactory\n * @dev A kinto wallet factory contract for KintoWallet\n *   Sits behind a proxy. It's upgradeable.\n *   A UserOperations \"initCode\" holds the address of the factory,\n *   and a method call (to createAccount, in this sample factory).\n *   The factory's createAccount returns the target account address even if it is already installed.\n *   This way, the entryPoint.getSenderAddress() can be called either\n *   before or after the account is created.\n */\ncontract KintoWalletFactory is Initializable, UUPSUpgradeable, IKintoWalletFactory {\n\n    /* ============ State Variables ============ */\n    address immutable public override factoryOwner;\n    UpgradeableBeacon public immutable beacon;\n\n    IKintoID public override kintoID;\n    mapping (address => uint256) public override walletTs;\n    uint256 public override factoryWalletVersion;\n    uint256 public override totalWallets;\n\n    /* ============ Events ============ */\n    event KintoWalletFactoryCreation(address indexed account, address indexed owner, uint version);\n    event KintoWalletFactoryUpgraded(address indexed oldImplementation,\n        address indexed newImplementation);\n\n    /* ============ Constructor ============ */\n    constructor(UpgradeableBeacon _beaconp) {\n        factoryOwner = msg.sender;\n        beacon = _beaconp;\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Upgrade calling `upgradeTo()`\n     */\n    function initialize(\n        IKintoID _kintoID\n    ) external virtual initializer {\n        __UUPSUpgradeable_init();\n        factoryWalletVersion = 1;\n        kintoID = _kintoID;\n    }\n\n    /**\n     * @dev Upgrade the wallet implementations using the beacon\n     * @param newImplementationWallet The new implementation\n     */\n    function upgradeAllWalletImplementations(\n        IKintoWallet newImplementationWallet\n    ) external override {\n        require(msg.sender == factoryOwner, 'only owner');\n        require(address(newImplementationWallet) != address(0), 'invalid address');\n        factoryWalletVersion++;\n        emit KintoWalletFactoryUpgraded(address(newImplementationWallet),\n            address(newImplementationWallet));\n        beacon.upgradeTo(address(newImplementationWallet));\n    }\n\n    /**\n     *\n     * @dev Create an account, and return its address.\n     * It returns the address even if the account is already deployed.\n     * Note that during UserOperation execution,\n     * this method is called only if the account is not deployed.\n     * This method returns an existing account address so that entryPoint.getSenderAddress()\n     * would work even after account creation\n     * @param owner The owner address\n     * @param recoverer The recoverer address\n     * @param salt The salt to use for the calculation\n     * @return ret address of the account\n     */\n    function createAccount(address owner, address recoverer, uint256 salt) external override returns (\n        IKintoWallet ret\n    ) {\n        require(kintoID.isKYC(owner), 'KYC required');\n        address addr = getAddress(owner, recoverer, salt);\n        uint codeSize = addr.code.length;\n\n        if (codeSize > 0) {\n            return KintoWallet(payable(addr));\n        }\n\n        ret = KintoWallet(payable(\n            new SafeBeaconProxy{salt : bytes32(salt)}(\n                    address(beacon),\n                    abi.encodeWithSelector(\n                        KintoWallet.initialize.selector,\n                        owner,\n                        recoverer\n                    )\n                )\n        ));\n\n        walletTs[address(ret)] = block.timestamp;\n        totalWallets++;\n        // Emit event\n        emit KintoWalletFactoryCreation(address(ret), owner, factoryWalletVersion);\n    }\n\n    /* ============ Deploy Custom Contract ============ */\n\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     * -  sender myst be KYC'd\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deployContract(\n        uint amount,\n        bytes memory bytecode,\n        bytes32 salt\n    ) external override returns (address) {\n        require(kintoID.isKYC(msg.sender), 'KYC required');\n        return Create2.deploy(amount, salt, bytecode);\n    }\n\n    /* ============ View Functions ============ */\n\n    /**\n     * @dev Gets the creation timestamp of a current wallet\n     * @param wallet The wallet address\n     * @return The timestamp of the wallet. 0 if it is not a wallet\n     */\n    function getWalletTimestamp(address wallet) external view override returns (uint256) {\n        return walletTs[wallet];\n    }\n\n    /**\n     * @dev Calculates the counterfactual address of this account\n     * as it would be returned by createAccount()\n     * @param owner The owner address\n     * @param recoverer The address that can recover the account in an emergency\n     * @param salt The salt to use for the calculation\n     * @return The address of the account\n     */\n    function getAddress(address owner, address recoverer, uint256 salt) public view override returns (address) {\n        return Create2.computeAddress(bytes32(salt), keccak256(abi.encodePacked(\n                type(SafeBeaconProxy).creationCode,\n                abi.encode(\n                    address(beacon),\n                    abi.encodeCall(KintoWallet.initialize, (owner, recoverer))\n                )\n            )));\n    }\n\n    /**\n     * @dev Calculates the counterfactual address of this contract as it\n     * would be returned by deployContract()\n     * @param salt Salt used by CREATE2\n     * @param byteCodeHash The bytecode hash (keccack256) of the contract to deploy\n     * @return address of the contract to deploy\n     */\n    function getContractAddress(\n        bytes32 salt,\n        bytes32 byteCodeHash\n    ) public view override returns (address) {\n        return Create2.computeAddress(salt, byteCodeHash, address(this));\n    }\n\n    /**\n     * @dev Authorize the upgrade. Only by an owner.\n     * @param newImplementation address of the new implementation\n     */\n    // This function is called by the proxy contract when the factory is upgraded\n    function _authorizeUpgrade(address newImplementation) internal view override {\n        (newImplementation);\n        require(msg.sender == factoryOwner, 'only owner');\n    }\n}"
    },
    {
      "filename": "src/paymasters/SponsorPaymaster.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\n/* solhint-disable reason-string */\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport '../interfaces/ISponsorPaymaster.sol';\n\nimport '@aa/core/BasePaymaster.sol';\nimport 'forge-std/console2.sol';\n\n/**\n * An ETH-based paymaster that accepts ETH deposits\n * The deposit is only a safeguard: the user pays with his ETH deposited in the entry point if any.\n * The deposit is locked for the current block: the user must issue unlockTokenDeposit() to be allowed to withdraw\n *  (but can't use the deposit for this or further operations)\n *\n * paymasterAndData holds the paymaster address followed by the token address to use.\n */\ncontract SponsorPaymaster is Initializable, BasePaymaster, UUPSUpgradeable, ReentrancyGuard, ISponsorPaymaster {\n\n    using UserOperationLib for UserOperation;\n    using SafeERC20 for IERC20;\n\n    //calculated cost of the postOp\n    uint256 constant public COST_OF_POST = 35000;\n\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public contractSpent; // keeps track of total gas consumption by contract\n    mapping(address => uint256) public unlockBlock;\n\n    constructor(IEntryPoint __entryPoint) BasePaymaster(__entryPoint) {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev The _entryPoint member is immutable, to reduce gas consumption.  To upgrade EntryPoint,\n     * a new implementation of SimpleAccount must be deployed with the new EntryPoint address, then upgrading\n     * the implementation by calling `upgradeTo()`\n     */\n    function initialize(address _owner) external virtual initializer {\n        __UUPSUpgradeable_init();\n        _transferOwnership(_owner);\n        // unlocks owner\n        unlockTokenDeposit();\n    }\n\n    /**\n     * @dev Authorize the upgrade. Only by an owner.\n     * @param newImplementation address of the new implementation\n     */\n    // This function is called by the proxy contract when the implementation is upgraded\n    function _authorizeUpgrade(address newImplementation) internal view override {\n        require(msg.sender == owner(), 'SponsorPaymaster: not owner');\n        (newImplementation);\n    }\n\n    /**\n     * ETH value that a specific account can use to pay for gas.\n     * Note depositing the tokens is equivalent to transferring them to the \"account\" - only the account can later\n     *  use them - either as gas, or using withdrawTo()\n     *\n     * @param account the account to deposit for.\n     * msg.value the amount of token to deposit.\n     */\n    function addDepositFor(address account) payable external override {\n        require(msg.value > 0, 'requires a deposit');\n        //(sender must have approval for the paymaster)\n        balances[account] += msg.value;\n        if (msg.sender == account) {\n            lockTokenDeposit();\n        }\n        this.deposit{value: msg.value}();\n    }\n\n    /**\n     * Unlocks deposit, so that it can be withdrawn.\n     * can't be called in the same block as withdrawTo()\n     */\n    function unlockTokenDeposit() public override {\n        unlockBlock[msg.sender] = block.number;\n    }\n\n    /**\n     * Lock the ETH deposited for this account so they can be used to pay for gas.\n     * after calling unlockTokenDeposit(), the account can't use this paymaster until the deposit is locked.\n     */\n    function lockTokenDeposit() public override {\n        unlockBlock[msg.sender] = 0;\n    }\n\n    /**\n     * Withdraw ETH\n     * can only be called after unlock() is called in a previous block.\n     * @param target address to send to\n     * @param amount amount to withdraw\n     */\n    function withdrawTokensTo(address target, uint256 amount) external override nonReentrant() {\n        require(\n            unlockBlock[msg.sender] != 0 && block.number > unlockBlock[msg.sender],\n            'DepositPaymaster: must unlockTokenDeposit'\n        );\n        withdrawTo(payable(target), amount);\n        balances[msg.sender] -= amount;\n    }\n\n    /*******************************\n      Viewers *********************\n    *******************************/\n\n    /**\n     * @return amount - the amount of given token deposited to the Paymaster.\n     * @return _unlockBlock - the block height at which the deposit can be withdrawn.\n     */\n    function depositInfo(address account) public view returns (uint256 amount, uint256 _unlockBlock) {\n        amount = balances[account];\n        _unlockBlock = unlockBlock[account];\n    }\n\n    /**\n     * Validate the request:\n     * The sender should have enough deposit to pay the max possible cost.\n     * Note that the sender's balance is not checked. If it fails to pay from its balance,\n     * this deposit will be used to compensate the paymaster for the transaction.\n     */\n    function _validatePaymasterUserOp(\n        UserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 maxCost\n    ) internal view override returns (bytes memory context, uint256 validationData) {\n        (userOpHash);\n        // verificationGasLimit is dual-purposed, as gas limit for postOp. make sure it is high enough\n        require(userOp.verificationGasLimit > COST_OF_POST, 'DepositPaymaster: gas too low for postOp');\n\n        bytes calldata paymasterAndData = userOp.paymasterAndData;\n        require(paymasterAndData.length == 20, 'DepositPaymaster: paymasterAndData must be empty');\n        // Get the contract deployed address from the first 20 bytes of the paymasterAndData\n        address targetAccount =  address(bytes20(userOp.callData[16:]));\n        uint256 gasPriceUserOp = userOp.gasPrice();\n        require(unlockBlock[targetAccount] == 0, 'DepositPaymaster: deposit not locked');\n        require(balances[targetAccount] >= maxCost, 'DepositPaymaster: deposit too low');\n        return (abi.encode(targetAccount, gasPriceUserOp), 0);\n    }\n\n    /**\n     * perform the post-operation to charge the sender for the gas.\n     * in normal mode, use transferFrom to withdraw enough tokens from the sender's balance.\n     * in case the transferFrom fails, the _postOp reverts and the entryPoint will call it again,\n     * this time in *postOpReverted* mode.\n     * In this mode, we use the deposit to pay (which we validated to be large enough)\n     */\n    function _postOp(PostOpMode /* mode */, bytes calldata context, uint256 actualGasCost) internal override {\n        (address account, uint256 gasPricePostOp) = abi.decode(context, (address, uint256));\n        //use same conversion rate as used for validation.\n        uint256 ethCost = (actualGasCost + COST_OF_POST * gasPricePostOp);\n        balances[account] -= ethCost;\n        contractSpent[account] += ethCost;\n        balances[owner()] += ethCost;\n    }\n    \n}"
    }
  ]
}