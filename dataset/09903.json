{
  "Title": "[G-02] `save` SLOAD Gas Optimization",
  "Content": "\n**Severity**: *Gas Optimization*<br>\n**Likelihood**: *Medium*<br>\n**Status**: {Not Submitted}<br>\n**Scope**: [`save()`](https://github.com/code-423n4/2022-02-tribe-turbo/blob/main/src/modules/TurboSavior.sol#L96-L136)\n\nThere are two calls of `pool.oracle()` that can be gas golfed using an *mload* to reduce gas by `100 - 3`.\n\n![TurboSavior save function](https://i.imgur.com/S8ewc9B.png)\n\n**[transmissions11 (Tribe Turbo) commented](https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/43#issuecomment-1050199540):**\n > good finds, ty\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/43#issuecomment-1060103021):**\n > G-01 Agree with finding, each time we're reading from memory we're saving 97 gas at the cost of 3 for the initial cache. -191\n> \n> G-02 Same idea -94\n> \n> 285 gas saved\n\n\n\n***\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-02-tribe-turbo-contest",
  "Code": [
    {
      "filename": "src/modules/TurboSavior.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.10;\n\nimport {ERC4626} from \"solmate/mixins/ERC4626.sol\";\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport {Fei} from \"../interfaces/Fei.sol\";\nimport {CERC20} from \"../interfaces/CERC20.sol\";\nimport {Comptroller} from \"../interfaces/Comptroller.sol\";\n\nimport {TurboSafe} from \"../TurboSafe.sol\";\nimport {TurboMaster} from \"../TurboMaster.sol\";\n\n/// @title Turbo Savior\n/// @author Transmissions11\n/// @notice Safe repayment module.\ncontract TurboSavior is Auth, ReentrancyGuard {\n    using FixedPointMathLib for uint256;\n\n    /*///////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The Master contract.\n    /// @dev Used to validate Safes are legitimate.\n    TurboMaster public immutable master;\n\n    /// @notice The Fei token on the network.\n    Fei public immutable fei;\n\n    /// @notice The Turbo Fuse Pool used by the Master.\n    Comptroller public immutable pool;\n\n    /// @notice The Fei cToken in the Turbo Fuse Pool.\n    CERC20 public immutable feiTurboCToken;\n\n    /*///////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Creates a new Turbo Savior contract.\n    /// @param _master The Master of the Savior.\n    /// @param _owner The owner of the Savior.\n    /// @param _authority The Authority of the Savior.\n    constructor(\n        TurboMaster _master,\n        address _owner,\n        Authority _authority\n    ) Auth(_owner, _authority) {\n        master = _master;\n\n        fei = Fei(address(master.fei()));\n\n        pool = master.pool();\n\n        feiTurboCToken = pool.cTokensByUnderlying(fei);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              LINE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The minimum percentage debt must make up of the borrow limit for a Safe to be saved.\n    /// @dev A fixed point number where 1e18 represents 100% and 0 represents 0%.\n    uint256 public minDebtPercentageForSaving;\n\n    /// @notice Emitted when the minimum debt percentage for saving is updated.\n    /// @param newDefaultFeePercentage The new minimum debt percentage for saving.\n    event MinDebtPercentageForSavingUpdated(address indexed user, uint256 newDefaultFeePercentage);\n\n    /// @notice Sets the minimum debt percentage.\n    /// @param newMinDebtPercentageForSaving The new minimum debt percentage.\n    function setMinDebtPercentageForSaving(uint256 newMinDebtPercentageForSaving) external requiresAuth {\n        // A minimum debt percentage over 100% makes no sense.\n        require(newMinDebtPercentageForSaving <= 1e18, \"PERCENT_TOO_HIGH\");\n\n        // Update the minimum debt percentage.\n        minDebtPercentageForSaving = newMinDebtPercentageForSaving;\n\n        emit MinDebtPercentageForSavingUpdated(msg.sender, newMinDebtPercentageForSaving);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              SAVE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted a save is executed.\n    /// @param user The user who executed the save.\n    /// @param safe The Safe that was saved.\n    /// @param vault The Vault that was lessed.\n    /// @param feiAmount The amount of Fei that was lessed.\n    event SafeSaved(address indexed user, TurboSafe indexed safe, ERC4626 indexed vault, uint256 feiAmount);\n\n    /// @notice Save a Safe (call less on owner's behalf to prevent liquidation).\n    /// @param safe The Safe to be saved.\n    /// @param vault The Vault to less from.\n    /// @param feiAmount The amount of Fei to less from the Safe.\n    function save(\n        TurboSafe safe,\n        ERC4626 vault,\n        uint256 feiAmount\n    ) external requiresAuth nonReentrant {\n        // Ensure the Safe is registered with the Master.\n        require(master.getSafeId(safe) != 0);\n\n        emit SafeSaved(msg.sender, safe, vault, feiAmount);\n\n        // Cache the Safe's collateral asset, saves a warm SLOAD below.\n        CERC20 assetTurboCToken = safe.assetTurboCToken();\n\n        // Get the Safe's asset's collateral factor in the Turbo Fuse Pool.\n        (, uint256 collateralFactor) = pool.markets(assetTurboCToken);\n\n        // Compute the value of the Safe's collateral. Rounded down to favor saving.\n        uint256 borrowLimit = assetTurboCToken\n            .balanceOf(address(safe))\n            .mulWadDown(assetTurboCToken.exchangeRateStored())\n            .mulWadDown(collateralFactor)\n            .mulWadDown(pool.oracle().getUnderlyingPrice(assetTurboCToken));\n\n        // Compute the value of the Safe's debt. Rounding up to favor saving them.\n        uint256 debtValue = feiTurboCToken.borrowBalanceCurrent(address(safe)).mulWadUp(\n            pool.oracle().getUnderlyingPrice(feiTurboCToken)\n        );\n\n        // Ensure the Safe's debt percentage is high enough to justify saving, otherwise revert.\n        require(\n            borrowLimit != 0 && debtValue.divWadUp(borrowLimit) >= minDebtPercentageForSaving,\n            \"DEBT_PERCENT_TOO_LOW\"\n        );\n\n        // Less the Fei from the Safe.\n        safe.less(vault, feiAmount);\n    }\n}"
    }
  ]
}