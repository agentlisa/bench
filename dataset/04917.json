{
  "Title": "[L-12] Consider reading return value from snapshot() function",
  "Content": "\n[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/TaikoToken.sol#L52)\n\nThe snapshot() function returns a uint256 snapshotId. These ids if retrieved earlier can make the devs life easier when taking multiple timely snapshots.\n```solidity\nFile: TaikoToken.sol\n54:     function snapshot() public onlyFromOwnerOrNamed(\"snapshooter\") {\n55:         _snapshot();\n56:     }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-taiko",
  "Code": [
    {
      "filename": "packages/protocol/contracts/L1/TaikoToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol\";\nimport \"../common/EssentialContract.sol\";\n\n/// @title TaikoToken\n/// @notice The TaikoToken (TKO), in the protocol is used for prover collateral\n/// in the form of bonds. It is an ERC20 token with 18 decimal places of\n/// precision.\n/// @dev Labeled in AddressResolver as \"taiko_token\"\n/// @custom:security-contact security@taiko.xyz\ncontract TaikoToken is EssentialContract, ERC20SnapshotUpgradeable, ERC20VotesUpgradeable {\n    uint256[50] private __gap;\n\n    error TKO_INVALID_ADDR();\n\n    /// @notice Initializes the contract.\n    /// @param _owner The owner of this contract. msg.sender will be used if this value is zero.\n    /// @param _name The name of the token.\n    /// @param _symbol The symbol of the token.\n    /// @param _recipient The address to receive initial token minting.\n    function init(\n        address _owner,\n        string calldata _name,\n        string calldata _symbol,\n        address _recipient\n    )\n        public\n        initializer\n    {\n        __Essential_init(_owner);\n        __ERC20_init(_name, _symbol);\n        __ERC20Snapshot_init();\n        __ERC20Votes_init();\n        __ERC20Permit_init(_name);\n\n        // Mint 1 billion tokens\n        _mint(_recipient, 1_000_000_000 ether);\n    }\n\n    /// @notice Burns tokens from the specified address.\n    /// @param _from The address to burn tokens from.\n    /// @param _amount The amount of tokens to burn.\n    function burn(address _from, uint256 _amount) public onlyOwner {\n        _burn(_from, _amount);\n    }\n\n    /// @notice Creates a new token snapshot.\n    function snapshot() public onlyFromOwnerOrNamed(\"snapshooter\") {\n        _snapshot();\n    }\n\n    /// @notice Transfers tokens to a specified address.\n    /// @param _to The address to transfer tokens to.\n    /// @param _amount The amount of tokens to transfer.\n    /// @return A boolean indicating whether the transfer was successful or not.\n    function transfer(address _to, uint256 _amount) public override returns (bool) {\n        if (_to == address(this)) revert TKO_INVALID_ADDR();\n        return super.transfer(_to, _amount);\n    }\n\n    /// @notice Transfers tokens from one address to another.\n    /// @param _from The address to transfer tokens from.\n    /// @param _to The address to transfer tokens to.\n    /// @param _amount The amount of tokens to transfer.\n    /// @return A boolean indicating whether the transfer was successful or not.\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    )\n        public\n        override\n        returns (bool)\n    {\n        if (_to == address(this)) revert TKO_INVALID_ADDR();\n        return super.transferFrom(_from, _to, _amount);\n    }\n\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    )\n        internal\n        override(ERC20Upgradeable, ERC20SnapshotUpgradeable)\n    {\n        super._beforeTokenTransfer(_from, _to, _amount);\n    }\n\n    function _afterTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    )\n        internal\n        override(ERC20Upgradeable, ERC20VotesUpgradeable)\n    {\n        super._afterTokenTransfer(_from, _to, _amount);\n    }\n\n    function _mint(\n        address _to,\n        uint256 _amount\n    )\n        internal\n        override(ERC20Upgradeable, ERC20VotesUpgradeable)\n    {\n        super._mint(_to, _amount);\n    }\n\n    function _burn(\n        address _from,\n        uint256 _amount\n    )\n        internal\n        override(ERC20Upgradeable, ERC20VotesUpgradeable)\n    {\n        super._burn(_from, _amount);\n    }\n}"
    }
  ]
}