{
  "Title": "[H-01] Lack of Balance Validation",
  "Content": "\n### Description\n\nThe pool's ratio of y to x must be within the interval `[MIN_M, MAX_M)`, which will be checked by the `_checkBalances()` function.\nExternal view functions will call the `_swap()`, `_reserveTokenSpecified()` or `_lpTokenSpecified()` functions to get the specified result. However, `_checkBalances()` is only used in the `_swap()` and `_lpTokenSpecified()` functions. There is no balance validation for `depositGivenInputAmount()` and `withdrawGivenOutputAmount()` functions, which use the `_reserveTokenSpecified()` function.\n\n### Impact\n\nIf are no other validations outside of these two functions, user deposits/withdrawls may break the invariant, i.e. the pool's ratio of y to x is outside the interval `[MIN_M, MAX_M)`.\n\n### Proof of Concept\n\nAdd the following code in the test/EvolvingProteusProperties.t.sol file to the EvolvingProteusProperties contract, and run `forge test --mt RatioOutsideExpectedInterval`:\n\n```js\nfunction testDepositRatioOutsideExpectedInterval(uint256 x0, uint256 y0, uint256 s0, uint256 depositedAmount) public {\n  int128 MIN_M = 0x00000000000002af31dc461;\n  uint256 INT_MAX_SQRT = 0xb504f333f9de6484597d89b3754abe9f;\n\n  vm.assume(x0 >= MIN_BALANCE && x0 <= INT_MAX_SQRT);\n  vm.assume(y0 >= MIN_BALANCE && y0 <= INT_MAX_SQRT);\n  vm.assume(s0 >= MIN_BALANCE && s0 <= INT_MAX_SQRT);\n  vm.assume(depositedAmount >= MIN_OPERATING_AMOUNT && depositedAmount < INT_MAX_SQRT && depositedAmount >= 2 * uint256(FIXED_FEE));\n  vm.assume(y0/x0 <= MAX_BALANCE_AMOUNT_RATIO);\n  vm.assume(x0/y0 <= MAX_BALANCE_AMOUNT_RATIO);\n  vm.assume(int256(y0).divi(int256(x0) + int256(depositedAmount)) < MIN_M);   // breaks the invariant\n  SpecifiedToken depositedToken = SpecifiedToken.X;\n  \n  vm.expectRevert();  // There should be at least one case that call did not revert as expected\n  DUT.depositGivenInputAmount(\n      x0,\n      y0,\n      s0,\n      depositedAmount,\n      depositedToken\n  );\n}\n\nfunction testWithdrawRatioOutsideExpectedInterval(uint256 x0, uint256 y0, uint256 s0, uint256 withdrawnAmount) public {\n  int128 MIN_M = 0x00000000000002af31dc461;\n  uint256 INT_MAX_SQRT = 0xb504f333f9de6484597d89b3754abe9f;\n\n  vm.assume(x0 >= MIN_BALANCE && x0 <= INT_MAX_SQRT);\n  vm.assume(y0 >= MIN_BALANCE && y0 <= INT_MAX_SQRT);\n  vm.assume(s0 >= MIN_BALANCE && s0 <= INT_MAX_SQRT);\n  vm.assume(withdrawnAmount >= MIN_OPERATING_AMOUNT && withdrawnAmount < INT_MAX_SQRT && withdrawnAmount >= 2 * uint256(FIXED_FEE));\n  vm.assume(y0/x0 <= MAX_BALANCE_AMOUNT_RATIO);\n  vm.assume(x0/y0 <= MAX_BALANCE_AMOUNT_RATIO);\n  vm.assume(withdrawnAmount < y0);    // no more than balance\n  vm.assume((int256(y0) - int256(withdrawnAmount)).divi(int256(x0)) < MIN_M);   // breaks the invariant\n  SpecifiedToken withdrawnToken = SpecifiedToken.Y;\n  \n  vm.expectRevert();  // There should be at least one case that call did not revert as expected\n  DUT.withdrawGivenOutputAmount(\n      x0,\n      y0,\n      s0,\n      withdrawnAmount,\n      withdrawnToken\n  );\n}\n```\n\n### Recommended Mitigation Steps\n\nIt's recommended to add `_checkBalances(xi + specifiedAmount, yi)` after [L579](https://github.com/code-423n4/2023-08-shell/blob/main/src/proteus/EvolvingProteus.sol#L579) and add `_checkBalances(xi, yi + specifiedAmount)` after [L582](https://github.com/code-423n4/2023-08-shell/blob/main/src/proteus/EvolvingProteus.sol#L582).\n\n### Assessed type\n\nInvalid Validation\n\n**[viraj124 (Shell) commented via duplicate Issue #268](https://github.com/code-423n4/2023-08-shell-findings/issues/268#issuecomment-1704611312):**\n> This should be low/med at best IMO. We're adding the balance check, but note _`getUtility` is an internal method and there are input checks of the reserve balances values passed, so this is an invalid argument.\n\n**[viraj124 (Shell) confirmed and commented via duplicate Issue #268](https://github.com/code-423n4/2023-08-shell-findings/issues/268#issuecomment-1713211667):**\n> We checked this further with some other members of the team and agreed this is high severity. We've fixed this in a PR.\n\n**[Dravee (judge) increased severity to High](https://github.com/code-423n4/2023-08-shell-findings/issues/57#issuecomment-1721966687)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-08-shell",
  "Code": [
    {
      "filename": "src/proteus/EvolvingProteus.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Cowri Labs Inc.\n\npragma solidity =0.8.10;\n\nimport \"abdk-libraries-solidity/ABDKMath64x64.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {ILiquidityPoolImplementation, SpecifiedToken} from \"./ILiquidityPoolImplementation.sol\";\n\nstruct Config {\n    int128 py_init;\n    int128 px_init;\n    int128 py_final;\n    int128 px_final;\n    uint256 t_init;\n    uint256 t_final;\n}\n\n/**\n     * @dev The contract is called with the following parameters:\n     y_init: the initial price at the y axis\n     x_init: the initial price at the x axis\n     y_final: the final price at the y axis\n     x_final: the final price at the x axis\n     time: the total duration of the curve's evolution (e.g. the amount of time it should take to evolve from the initial to the final prices)\n     \n     Using these 5 inputs we can calculate the curve's parameters at every point in time. \n     \n     The parameters \"a\" and \"b\" are calculated from the price. a = 1/sqrt(y_axis_price) and b = sqrt(x_axis_price). \n     We calculate a(t) and b(t) by taking the time-dependant linear interpolate between the initial and final values. \n     In other words, a(t) = (a_init * (1-t)) + (a_final * (t)) and b(t) = (b_init * (1-t)) + (b_final * (t)), where \"t\"\n     is the percentage of time elapsed relative to the total specified duration. Since \n     a_init, a_final, b_init and b_final can be easily calculated from the input parameters (prices), this is a trivial\n     calculation. config.a() and config.b() are then called whenever a and b are needed, and return the correct value for\n     a or b and the time t. When the total duration is reached, t remains = 1 and the curve will remain in its final shape. \n\n     Note: To mitigate rounding errors, which if too large could result in liquidity provider losses, we enforce certain constraints on the algorithm.\n           Min transaction amount: A transaction amount cannot be too small relative to the size of the reserves in the pool. A transaction amount either as an input into the pool or an output from the pool will result in a transaction failure\n           Max transaction amount: a transaction amount cannot be too large relative to the size of the reserves in the pool. \n           Min reserve ratio: The ratio between the two reserves cannot fall below a certain ratio. Any transaction that would result in the pool going above or below this ratio will fail.\n           Max reserve ratio: the ratio between the two reserves cannot go above a certain ratio. Any transaction that results in the reserves going beyond this ratio will fall.\n*/\n\nlibrary LibConfig {\n    using ABDKMath64x64 for uint256;\n    using ABDKMath64x64 for int256;\n    using ABDKMath64x64 for int128;\n\n    int128 constant ABDK_ONE = int128(int256(1 << 64));\n\n    /**\n       @notice Calculates the equation parameters \"a\" & \"b\" described above & returns the config instance\n       @param py_init The initial price at the y axis\n       @param px_init The initial price at the x axis\n       @param py_final The final price at the y axis\n       @param px_final The final price at the x axis\n       @param _duration duration over which the curve will evolve\n     */\n    function newConfig(\n        int128 py_init,\n        int128 px_init,\n        int128 py_final,\n        int128 px_final,\n        uint256 _duration\n    ) public view returns (Config memory) {\n\n        return Config(\n            py_init,\n            px_init,\n            py_final,\n            px_final,\n            block.timestamp,\n            block.timestamp + _duration\n        );\n    }\n\n    /**\n       @notice Calculates the time that has passed since deployment\n       @param self config instance\n    */\n    function elapsed(Config storage self) public view returns (uint256) {\n        return block.timestamp - self.t_init;\n    }\n\n    /**\n       @notice Calculates the time as a percent of total duration\n       @param self config instance\n    */\n    function t(Config storage self) public view returns (int128) {\n        return elapsed(self).divu(duration(self));\n    }\n\n    /**\n       @notice The minimum price (at the x asymptote) at the current block\n       @param self config instance\n    */\n    function p_min(Config storage self) public view returns (int128) {\n        if (t(self) > ABDK_ONE) return self.px_final;\n        else return self.px_init.mul(ABDK_ONE.sub(t(self))).add(self.px_final.mul(t(self)));\n    }\n\n    /**\n       @notice The maximum price (at the y asymptote) at the current block\n       @param self config instance\n    */\n    function p_max(Config storage self) public view returns (int128) {\n        if (t(self) > ABDK_ONE) return self.py_final;\n        else return self.py_init.mul(ABDK_ONE.sub(t(self))).add(self.py_final.mul(t(self)));\n    }\n\n    /**\n       @notice Calculates the a variable in the curve eq which is basically a sq. root of the inverse of y instantaneous price\n       @param self config instance\n    */\n    function a(Config storage self) public view returns (int128) {\n        return (p_max(self).inv()).sqrt();\n    }\n\n    /**\n       @notice Calculates the b variable in the curve eq which is basically a sq. root of the inverse of x instantaneous price\n       @param self config instance\n    */\n    function b(Config storage self) public view returns (int128) {\n        return p_min(self).sqrt();\n    }\n\n\n    /**\n       @notice Calculates the duration of the curve evolution\n       @param self config instance\n    */\n    function duration(Config storage self) public view returns (uint256) {\n        return self.t_final - self.t_init;\n    }\n}\n\ncontract EvolvingProteus is ILiquidityPoolImplementation {\n    using ABDKMath64x64 for int128;\n    using ABDKMath64x64 for int256;\n    using LibConfig for Config;\n\n    /** \n     @notice \n     max threshold for amounts deposited, withdrawn & swapped\n    */ \n    uint256 constant INT_MAX = uint256(type(int256).max);\n    /** \n     @notice \n     When a token has 18 decimals, this is one microtoken\n    */ \n    int256 constant MIN_BALANCE = 10**12;\n    /** \n     @notice \n     The maximum slope (balance of y reserve) / (balance of x reserve)\n     This limits the pool to having at most 10**8 y for each x.\n    */ \n    int128 constant MAX_M = 0x5f5e1000000000000000000;\n    /** \n     @notice \n     The minimum slope (balance of y reserve) / (balance of x reserve)\n     This limits the pool to having at most 10**8 x for each y.\n    */ \n    int128 constant MIN_M = 0x00000000000002af31dc461;\n\n    /** \n     @notice \n     The maximum price value calculated with abdk library equivalent to 10^26(wei)\n    */ \n    int256 constant MAX_PRICE_VALUE = 1844674407370955161600000000;\n\n    /** \n     @notice \n     The minimum price value calculated with abdk library equivalent to 10^12(wei)\n    */ \n    int256 constant MIN_PRICE_VALUE = 184467440737;\n\n    /** \n     @notice \n     This limits the pool to inputting or outputting\n    */\n    uint256 constant MAX_BALANCE_AMOUNT_RATIO = 10**11;\n    /** \n     @notice \n     Equivalent to roughly twenty-five basis points since fee is applied twice.\n    */\n    uint256 public constant BASE_FEE = 800;\n    /** \n     @notice \n     When a token has 18 decimals, this is 1 nanotoken\n    */ \n    uint256 constant FIXED_FEE = 10**9;\n    /** \n      @notice \n      multiplier for math operations\n    */ \n    int256 constant MULTIPLIER = 1e18;\n    /** \n      @notice \n      max price ratio\n    */ \n    int256 constant MAX_PRICE_RATIO = 10**4; // to be comparable with the prices calculated through abdk math\n    /** \n      @notice \n      flag to indicate increase of the pool's perceived input or output\n    */ \n    bool constant FEE_UP = true;\n    /** \n      @notice \n      flag to indicate decrease of the pool's perceived input or output\n    */ \n    bool constant FEE_DOWN = false;\n    /** \n      @notice \n      pool config\n    */ \n    Config public config;\n\n\n    //*********************************************************************//\n    // --------------------------- custom errors ------------------------- //\n    //*********************************************************************//\n    error AmountError();\n    error BalanceError(int256 x, int256 y);\n    error BoundaryError(int256 x, int256 y);\n    error CurveError(int256 errorValue); \n    error InvalidPrice();\n    error MinimumAllowedPriceExceeded();\n    error MaximumAllowedPriceExceeded();\n    error MaximumAllowedPriceRatioExceeded();\n\n\n    //*********************************************************************//\n    // ---------------------------- constructor -------------------------- //\n    //*********************************************************************//\n\n    /**\n      @param py_init The initial price at the y axis\n      @param px_init The initial price at the x axis\n      @param py_final The final price at the y axis\n      @param px_final The final price at the y axis\n      @param duration duration for which the curve will evolve\n    */\n    constructor(\n        int128 py_init,\n        int128 px_init,\n        int128 py_final,\n        int128 px_final,\n        uint256 duration\n    ) { \n        // price value checks\n        if (py_init >= MAX_PRICE_VALUE || py_final >= MAX_PRICE_VALUE) revert MaximumAllowedPriceExceeded();\n        if (px_init <= MIN_PRICE_VALUE || px_final <= MIN_PRICE_VALUE) revert MinimumAllowedPriceExceeded();\n\n        // at all times x price should be less than y price\n        if (py_init <= px_init) revert InvalidPrice();\n        if (py_final <= px_final) revert InvalidPrice();\n\n        // max. price ratio check\n        if (py_init.div(py_init.sub(px_init)) > ABDKMath64x64.divu(uint(MAX_PRICE_RATIO), 1)) revert MaximumAllowedPriceRatioExceeded();\n        if (py_final.div(py_final.sub(px_final)) > ABDKMath64x64.divu(uint(MAX_PRICE_RATIO), 1)) revert MaximumAllowedPriceRatioExceeded();\n\n        config = LibConfig.newConfig(py_init, px_init, py_final, px_final, duration);\n      }\n\n\n    /**\n     * @dev Given an input amount of one reserve token, we compute the output\n     *  amount of the other reserve token, keeping utility invariant.\n     * @dev We use FEE_DOWN because we want to decrease the perceived\n     *  input amount and decrease the observed output amount.\n     */\n    function swapGivenInputAmount(\n        uint256 xBalance,\n        uint256 yBalance,\n        uint256 inputAmount,\n        SpecifiedToken inputToken\n    ) external view returns (uint256 outputAmount) {\n        // input amount validations against the current balance\n        require(\n            inputAmount < INT_MAX && xBalance < INT_MAX && yBalance < INT_MAX\n        );\n\n        _checkAmountWithBalance(\n            (inputToken == SpecifiedToken.X) ? xBalance : yBalance,\n            inputAmount\n        );\n\n        int256 result = _swap(\n            FEE_DOWN,\n            int256(inputAmount),\n            int256(xBalance),\n            int256(yBalance),\n            inputToken\n        );\n        // amount cannot be less than 0\n        require(result < 0);\n\n        // output amount validations against the current balance\n        outputAmount = uint256(-result);\n        _checkAmountWithBalance(\n            (inputToken == SpecifiedToken.X) ? yBalance : xBalance,\n            outputAmount\n        );\n    }\n\n    /**\n     * @dev Given an output amount of a reserve token, we compute the input\n     *  amount of the other reserve token, keeping utility invariant.\n     * @dev We use FEE_UP because we want to increase the perceived output\n     *  amount and increase the observed input amount.\n     */\n    function swapGivenOutputAmount(\n        uint256 xBalance,\n        uint256 yBalance,\n        uint256 outputAmount,\n        SpecifiedToken outputToken\n    ) external view returns (uint256 inputAmount) {\n        // output amount validations against the current balance\n        require(\n            outputAmount < INT_MAX && xBalance < INT_MAX && yBalance < INT_MAX\n        );\n        _checkAmountWithBalance(\n            outputToken == SpecifiedToken.X ? xBalance : yBalance,\n            outputAmount\n        );\n\n        int256 result = _swap(\n            FEE_UP,\n            -int256(outputAmount),\n            int256(xBalance),\n            int256(yBalance),\n            outputToken\n        );\n\n        // amount cannot be less than 0\n        require(result > 0);\n        inputAmount = uint256(result);\n\n        // input amount validations against the current balance\n        _checkAmountWithBalance(\n            outputToken == SpecifiedToken.X ? yBalance : xBalance,\n            inputAmount\n        );\n    }\n\n    /**\n     * @dev Given an input amount of a reserve token, we compute the output\n     *  amount of LP tokens, scaling the total supply of the LP tokens with the\n     *  utility of the pool.\n     * @dev We use FEE_DOWN because we want to decrease the perceived amount\n     *  deposited and decrease the amount of LP tokens minted.\n     */\n    function depositGivenInputAmount(\n        uint256 xBalance,\n        uint256 yBalance,\n        uint256 totalSupply,\n        uint256 depositedAmount,\n        SpecifiedToken depositedToken\n    ) external view returns (uint256 mintedAmount) {\n        // deposit amount validations against the current balance\n        require(\n            depositedAmount < INT_MAX &&\n                xBalance < INT_MAX &&\n                yBalance < INT_MAX &&\n                totalSupply < INT_MAX\n        );\n\n        int256 result = _reserveTokenSpecified(\n            depositedToken,\n            int256(depositedAmount),\n            FEE_DOWN,\n            int256(totalSupply),\n            int256(xBalance),\n            int256(yBalance)\n        );\n\n        // amount cannot be less than 0\n        require(result > 0);\n        mintedAmount = uint256(result);\n    }\n\n    /**\n     * @dev Given an output amount of the LP token, we compute an amount of\n     *  a reserve token that must be deposited to scale the utility of the pool\n     *  in proportion to the change in total supply of the LP token.\n     * @dev We use FEE_UP because we want to increase the perceived change in\n     *  total supply and increase the observed amount deposited.\n     */\n    function depositGivenOutputAmount(\n        uint256 xBalance,\n        uint256 yBalance,\n        uint256 totalSupply,\n        uint256 mintedAmount,\n        SpecifiedToken depositedToken\n    ) external view returns (uint256 depositedAmount) {\n        // lp amount validations against the current balance\n        require(\n            mintedAmount < INT_MAX &&\n                xBalance < INT_MAX &&\n                yBalance < INT_MAX &&\n                totalSupply < INT_MAX\n        );\n\n        int256 result = _lpTokenSpecified(\n            depositedToken,\n            int256(mintedAmount),\n            FEE_UP,\n            int256(totalSupply),\n            int256(xBalance),\n            int256(yBalance)\n        );\n\n        // amount cannot be less than 0\n        require(result > 0);\n        depositedAmount = uint256(result);\n    }\n\n    /**\n     * @dev Given an output amount of a reserve token, we compute an amount of\n     *  LP tokens that must be burned in order to decrease the total supply in\n     *  proportion to the decrease in utility.\n     * @dev We use FEE_UP because we want to increase the perceived amount\n     *  withdrawn from the pool and increase the observed decrease in total\n     *  supply.\n     */\n    function withdrawGivenOutputAmount(\n        uint256 xBalance,\n        uint256 yBalance,\n        uint256 totalSupply,\n        uint256 withdrawnAmount,\n        SpecifiedToken withdrawnToken\n    ) external view returns (uint256 burnedAmount) {\n        // withdraw amount validations against the current balance\n        require(\n            withdrawnAmount < INT_MAX &&\n                xBalance < INT_MAX &&\n                yBalance < INT_MAX &&\n                totalSupply < INT_MAX\n        );\n\n        int256 result = _reserveTokenSpecified(\n            withdrawnToken,\n            -int256(withdrawnAmount),\n            FEE_UP,\n            int256(totalSupply),\n            int256(xBalance),\n            int256(yBalance)\n        );\n\n        // amount cannot be less than 0\n        require(result < 0);\n        burnedAmount = uint256(-result);\n    }\n\n    /**\n     * @dev Given an input amount of the LP token, we compute an amount of\n     *  a reserve token that must be output to decrease the pool's utility in\n     *  proportion to the pool's decrease in total supply of the LP token.\n     * @dev We use FEE_UP because we want to increase the perceived amount of\n     *  reserve tokens leaving the pool and to increase the observed amount of\n     *  LP tokens being burned.\n     */\n    function withdrawGivenInputAmount(\n        uint256 xBalance,\n        uint256 yBalance,\n        uint256 totalSupply,\n        uint256 burnedAmount,\n        SpecifiedToken withdrawnToken\n    ) external view returns (uint256 withdrawnAmount) {\n        // lp amount validations against the current balance\n        require(\n            burnedAmount < INT_MAX &&\n                xBalance < INT_MAX &&\n                yBalance < INT_MAX &&\n                totalSupply < INT_MAX\n        );\n\n        int256 result = _lpTokenSpecified(\n            withdrawnToken,\n            -int256(burnedAmount),\n            FEE_DOWN,\n            int256(totalSupply),\n            int256(xBalance),\n            int256(yBalance)\n        );\n\n        // amount cannot be less than 0\n        require(result < 0);\n        withdrawnAmount = uint256(-result);\n    }\n\n    /**\n     * @dev From a starting point (xi, yi), we can begin a swap in four ways:\n     *  [+x, -x, +y, -y]. This function abstracts over those four ways using\n     *  the specifiedToken parameter and the sign of the specifiedAmount\n     *  integer.\n     * @dev A starting coordinate can be combined with the specified amount\n     *  to find a known final coordinate. A final coordinate and a final\n     *  utility can be used to determine the final point.\n     * @dev Using the final point and the initial point, we can find how much\n     *  of the non-specified token must enter or leave the pool in order to\n     *  keep utility invariant.\n     * @dev see notes above _findFinalPoint for information on direction\n     *  and other variables declared in this scope.\n     */\n    function _swap(\n        bool feeDirection,\n        int256 specifiedAmount,\n        int256 xi,\n        int256 yi,\n        SpecifiedToken specifiedToken\n    ) internal view returns (int256 computedAmount) {\n        int256 roundedSpecifiedAmount;\n        // calculating the amount considering the fee\n        {\n            roundedSpecifiedAmount = _applyFeeByRounding(\n                specifiedAmount,\n                feeDirection\n            );\n        }\n\n        int256 xf;\n        int256 yf;\n        // calculate final price points after the swap\n        {\n\n            int256 utility = _getUtility(xi, yi);\n\n            if (specifiedToken == SpecifiedToken.X) {\n                int256 fixedPoint = xi + roundedSpecifiedAmount;\n                (xf, yf) = _findFinalPoint(\n                    fixedPoint,\n                    utility,\n                    _getPointGivenXandUtility\n                );\n            } else {\n                int256 fixedPoint = yi + roundedSpecifiedAmount;\n                (xf, yf) = _findFinalPoint(\n                    fixedPoint,\n                    utility,\n                    _getPointGivenYandUtility\n                );\n            }\n        }\n        \n        // balance checks with consideration the computed amount\n        if (specifiedToken == SpecifiedToken.X) {\n            computedAmount = _applyFeeByRounding(yf - yi, feeDirection);\n            _checkBalances(xi + specifiedAmount, yi + computedAmount);\n        } else {\n            computedAmount = _applyFeeByRounding(xf - xi, feeDirection);\n            _checkBalances(xi + computedAmount, yi + specifiedAmount);\n        }\n    }\n\n    /**\n     * @dev When performing a deposit given an input amount or a withdraw\n     *  given an output amount, we know the initial point and final point,\n     *  which allows us to find the initial utility and final utility.\n     * @dev With the initial utility and final utility, we need to change\n     *  the total supply in proportion to the change in utility.\n     */\n    function _reserveTokenSpecified(\n        SpecifiedToken specifiedToken,\n        int256 specifiedAmount,\n        bool feeDirection,\n        int256 si,\n        int256 xi,\n        int256 yi\n    ) internal view returns (int256 computedAmount) {\n        int256 xf;\n        int256 yf;\n        int256 ui;\n        int256 uf;\n        {\n            // calculating the final price points considering the fee\n            if (specifiedToken == SpecifiedToken.X) {\n                xf = xi + _applyFeeByRounding(specifiedAmount, feeDirection);\n                yf = yi;\n            } else {\n                yf = yi + _applyFeeByRounding(specifiedAmount, feeDirection);\n                xf = xi;\n            }\n        }\n\n        ui = _getUtility(xi, yi);\n        uf = _getUtility(xf, yf);\n\n        uint256 result = Math.mulDiv(uint256(uf), uint256(si), uint256(ui));\n        require(result < INT_MAX);   \n        int256 sf = int256(result);\n\n        // apply fee to the computed amount\n        computedAmount = _applyFeeByRounding(sf - si, feeDirection);\n    }\n\n    /**\n     * @dev When performing a deposit given an output amount or a withdraw\n     *  given an input amount, we know the initial total supply and the final\n     *  total supply.\n     * @dev Given the change in total supply, we need to find how much of a\n     *  reserve token we need to take in or give out in order to change the\n     *  pool's utility in proportion to the pool's change in total supply.\n     * @dev see notes above _findFinalPoint for information on direction\n     *  and other variables declared in this scope.\n     */\n    function _lpTokenSpecified(\n        SpecifiedToken specifiedToken,\n        int256 specifiedAmount,\n        bool feeDirection,\n        int256 si,\n        int256 xi,\n        int256 yi\n    ) internal view returns (int256 computedAmount) {\n        // get final utility considering the fee\n        int256 uf = _getUtilityFinalLp(\n            si,\n            si + _applyFeeByRounding(specifiedAmount, feeDirection),\n            xi,\n            yi\n        );\n\n        // get final price points\n        int256 xf;\n        int256 yf;\n        if (specifiedToken == SpecifiedToken.X)\n            (xf, yf) = _findFinalPoint(\n                yi,\n                uf,\n                _getPointGivenYandUtility\n            );\n        else\n            (xf, yf) = _findFinalPoint(\n                xi,\n                uf,\n                _getPointGivenXandUtility\n            );\n\n        // balance checks with consideration the computed amount\n        if (specifiedToken == SpecifiedToken.X) {\n            computedAmount = _applyFeeByRounding(xf - xi, feeDirection);\n            _checkBalances(xi + computedAmount, yf);\n        } else {\n            computedAmount = _applyFeeByRounding(yf - yi, feeDirection);\n            _checkBalances(xf, yi + computedAmount);\n        }\n    }\n\n    /**\n     * @dev Calculate utility when lp token amount is specified while depositing/withdrawing liquidity\n    */\n    function _getUtilityFinalLp(\n        int256 si,\n        int256 sf,\n        int256 xi,\n        int256 yi\n    ) internal view returns (int256 uf) {\n        require(sf >= MIN_BALANCE);\n        int256 ui = _getUtility(xi, yi);\n        uint256 result = Math.mulDiv(uint256(ui), uint256(sf), uint256(si));\n        require(result < INT_MAX);\n        uf = int256(result);\n        return uf;\n    }\n\n    /**\n     * @dev This function leverages several properties of proteus to find\n     *  the final state of the balances after an action. These properties are:\n     *   1. There is always a known coordinate. We always know at least one of\n     *      xf or yf. In swaps we know the specified token (ti + amount == tf).\n     *      In deposits or withdrawals, we know the non-specified token\n     *      (ti == tf).\n     *   2. There is always a known utility. During swaps utility is invariant\n     *      (ui == uf).  During deposits or withdrawals, utility varies linearly\n     *      with the known change in total supply of the LP token.\n     * @param fixedCoordinate Known coordinate\n     * @param utility Known utility\n     * @param getPoint Function that uses the known coordinate and the known\n     *  utility to compute the unknown coordinate. Returns a point (x, y).\n*/\n    function _findFinalPoint(\n        int256 fixedCoordinate,\n        int256 utility,\n        function(int256, int256)\n            view\n            returns (int256, int256) getPoint\n    ) internal view returns (int256 xf, int256 yf) {\n        return getPoint(fixedCoordinate, utility);\n    }\n\n    /**\n     * @dev Utility is the pool's internal measure of how much value it holds\n     * @dev The pool values the x reserve and y reserve based on how much of\n     *  one it holds compared to the other. The higher ratio of y to x, the\n     *  less it values y compared to x.\n     * @dev the equation for a curve:\n     *  k(ab - 1)u**2 + (ay + bx)u + xy/k = 0\n     * @dev isolate u in the equation using the quadratic formula above gives us two solutions. \n     *  We always want the larger solution\n     */\n    function _getUtility(\n        int256 x,\n        int256 y\n    ) internal view returns (int256 utility) {\n\n        int128 a = config.a(); //these are abdk numbers representing the a and b values\n        int128 b = config.b(); \n\n        int128 two = ABDKMath64x64.divu(uint256(2 * MULTIPLIER), uint256(MULTIPLIER));\n        int128 one = ABDKMath64x64.divu(uint256(MULTIPLIER), uint256(MULTIPLIER));\n\n        int128 aQuad = (a.mul(b).sub(one));\n        int256 bQuad = (a.muli(y) + b.muli(x));\n        int256 cQuad = x * y;\n\n        int256 disc = int256(Math.sqrt(uint256((bQuad**2 - (aQuad.muli(cQuad)*4)))));\n        int256 r0 = (-bQuad*MULTIPLIER + disc*MULTIPLIER) / aQuad.mul(two).muli(MULTIPLIER);\n        int256 r1 = (-bQuad*MULTIPLIER - disc*MULTIPLIER) / aQuad.mul(two).muli(MULTIPLIER);\n\n        if(a < 0 && b < 0) utility = (r0 > r1) ? r1 : r0;\n        else utility = (r0 > r1) ? r0 : r1;\n        \n        if (utility < 0) revert CurveError(utility);\n    }\n\n    /**\n     * @dev Given a utility and a bonding curve (a, b, k) and one coordinate\n     *  of a point on that curve, we can find the other coordinate of the\n     *  point.\n     * @dev the equation for a curve:\n     *  ((x / (ku)) + a) ((y / (ku)) + b) = 1 (see _getUtility notes)\n     * @dev Isolating y in the equation above gives us the equation:\n     *  y = (k^2 u^2)/(a k u + x) - b k u\n     * @dev This function returns x as xf because we want to be able to call\n     *  getPointGivenX and getPointGivenY and handle the returned values\n     *  without caring about which particular function is was called.\n     */\n\n    function _getPointGivenXandUtility(\n        int256 x,\n        int256 utility\n    ) internal view returns (int256 x0, int256 y0) {\n        int128 a = config.a();\n        int128 b = config.b();\n\n        int256 a_convert = a.muli(MULTIPLIER);\n        int256 b_convert = b.muli(MULTIPLIER);\n        x0 = x;\n        \n        int256 f_0 = ((( x0  * MULTIPLIER ) / utility) + a_convert);\n        int256 f_1 = ((MULTIPLIER * MULTIPLIER / f_0) -  b_convert);\n        int256 f_2 = (f_1 * utility) / MULTIPLIER; \n        y0 = f_2;\n\n        if (y0 < 0) revert CurveError(y0);\n    }\n\n    /**\n     * @dev Given a utility and a bonding curve (a, b, k) and one coordinate\n     *  of a point on that curve, we can find the other coordinate of the\n     *  point.\n     * @dev the equation for a curve is:\n     *  ((x / (ku)) + a) ((y / (ku)) + b) = 1 (see _getUtility notes)\n     * @dev Isolating y in the equation above gives us the equation:\n     *  x = (k^2 u^2)/(b k u + y) - a k u\n     * @dev This function returns y as yf because we want to be able to call\n     *  getPointGivenX and getPointGivenY and handle the returned values\n     *  without caring about which particular function is was called.\n     */\n    function _getPointGivenYandUtility(\n        int256 y,\n        int256 utility\n    ) internal view returns (int256 x0, int256 y0) {\n        int128 a = config.a();\n        int128 b = config.b();\n\n        int256 a_convert = a.muli(MULTIPLIER);\n        int256 b_convert = b.muli(MULTIPLIER);\n        y0 = y;\n\n        int256 f_0 = (( y0  * MULTIPLIER ) / utility) + b_convert;\n        int256 f_1 = ( ((MULTIPLIER)*(MULTIPLIER) / f_0) - a_convert );\n        int256 f_2 = (f_1 * utility) / (MULTIPLIER); \n        x0 = f_2;\n\n        if (x0 < 0) revert CurveError(x0);\n    }\n\n \n    /**\n     * @dev this limits the ratio between a starting balance and an input\n     *  or output amount.\n     * @dev when we swap very small amounts against a very large pool,\n     *  precision errors can cause the pool to lose a small amount of value.\n     */\n    function _checkAmountWithBalance(uint256 balance, uint256 amount)\n        private\n        pure\n    {\n        if (balance / amount >= MAX_BALANCE_AMOUNT_RATIO) revert AmountError();\n    }\n\n    /**\n     * @dev The pool's balances of the x reserve and y reserve tokens must be\n     *  greater than the MIN_BALANCE\n     * @dev The pool's ratio of y to x must be within the interval\n     *  [MIN_M, MAX_M)\n     */\n    function _checkBalances(int256 x, int256 y) private pure {\n        if (x < MIN_BALANCE || y < MIN_BALANCE) revert BalanceError(x,y);\n        int128 finalBalanceRatio = y.divi(x);\n        if (finalBalanceRatio < MIN_M) revert BoundaryError(x,y);\n        else if (MAX_M <= finalBalanceRatio) revert BoundaryError(x,y);\n    }\n\n    /**\n     * @dev Rounding and fees are equivalent concepts\n     * @dev We charge fees by rounding values in directions that are beneficial\n     *  to the pool.\n     * @dev the BASE_FEE and FIXED_FEE values were chosen such that round\n     *  enough to cover numerical stability issues that arise from using a\n     *  fixed precision math library and piecewise bonding curves.\n     */\n    function _applyFeeByRounding(int256 amount, bool feeUp)\n        private\n        pure\n        returns (int256 roundedAmount)\n    {\n        bool negative = amount < 0 ? true : false;\n        uint256 absoluteValue = negative ? uint256(-amount) : uint256(amount);\n        // FIXED_FEE * 2 because we will possibly deduct the FIXED_FEE from\n        // this amount, and we don't want the final amount to be less than\n        // the FIXED_FEE.\n        if (absoluteValue < FIXED_FEE * 2) revert AmountError();\n\n        uint256 roundedAbsoluteAmount;\n        if (feeUp) {\n            roundedAbsoluteAmount =\n                absoluteValue +\n                (absoluteValue / BASE_FEE) +\n                FIXED_FEE;\n            require(roundedAbsoluteAmount < INT_MAX);\n        } else\n            roundedAbsoluteAmount =\n                absoluteValue -\n                (absoluteValue / BASE_FEE) -\n                FIXED_FEE;\n\n        roundedAmount = negative\n            ? -int256(roundedAbsoluteAmount)\n            : int256(roundedAbsoluteAmount);\n    }\n}"
    }
  ]
}