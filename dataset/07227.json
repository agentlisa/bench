{
  "Title": "[M-15] The Furnace#melt() is vulnerable to sandwich attacks",
  "Content": "# Lines of code\n\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/Furnace.sol#L70-L84\n\n\n# Vulnerability details\n\n\n## Impact\n\nMalicious users can get more of the RToken appreciation benefit brought by [`Furnace.sol#melt()`](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/Furnace.sol#L70), and long-term RToken holders will get less benefit.\nRToken holders will be less willing to provide liquidity to RToken pools (such as uniswap pools), resulting in less liquidity of RToken.\n\n## Proof of Concept\n\n### A1. Gain revenue from a flashloan sandwich attack\n\nA malicious user can launch a flashloan sandwich attack against [Furnace#melt()](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/Furnace.sol#L70) each time a whole period passed (payout happens).\n\nThe attack transaction execution steps:\n1. Borrow some assets (`inputFund`) with a flashloan\n2. Swap the `inputFund` for RToken\n3. Call [RToken#redeem()](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L439) to change the RToken to basket assets(`outputFund`). The `redeem()` will invoke `Furnace.melt()` automatically.\n4. Swap part of `outputFund` for `inputFund` and pay back the flashloan, the rest of `outputFund` is the profit.\n\nThe implicit assumption here is that most of the time the prices of RToken in `RToken.issues()`, `RToken.redeem()`, and DeFi pools are almost equal.\nThis assumption is reasonable because if there are price differentials, they can be balanced by arbitrage.\n\nThe attack can be profitable for:\n* `Furnace#melt()` will increase the price of RToken in issue/redeem (according to basket rate).\n* Step 2 buys RTokens at a lower price, and then step 3 sells RTokens at a higher price(`melt()` is called first in `redeem()`).\n\n### A2. Get a higher yield by holding RToken for a short period of time\n\nMalicious users can get higher yield by by following these steps:\n1. Calculate [the next payout block](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/Furnace.sol#L71) of Furnace in advance\n2. Call [RToken#issue()](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L177) 1 to n blocks before the payout block\n3. Call [RToken#redeem()](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L439) when the payout block reaches.\n\nSince this approach only requires 1 to n blocks to issue in advance, which is typically much smaller than [rewardPeriod](https://github.com/reserve-protocol/protocol/blob/df7ecadc2b/docs/system-design.md#rewardperiod), the attacker will obtain much higher APR than long-term RToken holders.\n\n## Tools Used\n\nManual\n\n## Recommended Mitigation Steps\n\nReferring to [eip-4626](https://eips.ethereum.org/EIPS/eip-4626), distribute rewards based on time weighted shares.\n\nAlternatively, always use a very small rewardPeriod and rewardRatio, and lower the upper limit [MAX_RATIO and MAX_PERIOD](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/Furnace.sol#L15-L16).\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-01-reserve-contest",
  "Code": [
    {
      "filename": "contracts/p1/Furnace.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.9;\n\nimport \"../libraries/Fixed.sol\";\nimport \"../interfaces/IFurnace.sol\";\nimport \"./mixins/Component.sol\";\n\n/**\n * @title FurnaceP1\n * @notice A helper to melt RTokens slowly and permisionlessly.\n */\ncontract FurnaceP1 is ComponentP1, IFurnace {\n    using FixLib for uint192;\n\n    uint192 public constant MAX_RATIO = FIX_ONE; // {1} 100%\n    uint48 public constant MAX_PERIOD = 31536000; // {s} 1 year\n\n    uint192 public ratio; // {1} What fraction of balance to melt each period\n    uint48 public period; // {seconds} How often to melt\n    uint256 public lastPayoutBal; // {qRTok} The balance of RToken at the last payout\n    uint48 public lastPayout; // {seconds} The last time we did a payout\n\n    IRToken private rToken;\n\n    // ==== Invariants ====\n    // ratio <= MAX_RATIO = 1e18\n    // 0 < period <= MAX_PERIOD\n    // lastPayout was the timestamp of the end of the last period we paid out\n    //   (or, if no periods have been paid out, the timestamp init() was called)\n    // lastPayoutBal was rtoken.balanceOf(this) after the last period we paid out\n    //   (or, if no periods have been paid out, that balance when init() was called)\n\n    function init(\n        IMain main_,\n        uint48 period_,\n        uint192 ratio_\n    ) external initializer {\n        __Component_init(main_);\n        rToken = main_.rToken();\n        setPeriod(period_);\n        setRatio(ratio_);\n        lastPayout = uint48(block.timestamp);\n        lastPayoutBal = rToken.balanceOf(address(this));\n    }\n\n    // [furnace-payout-formula]:\n    //   The process we're modelling is:\n    //     N = number of whole periods since lastPayout\n    //     bal_0 = rToken.balanceOf(this)\n    //     payout_{i+1} = bal_i * ratio\n    //     bal_{i+1} = bal_i - payout_{i+1}\n    //     payoutAmount = sum{payout_i for i in [1...N]}\n    //   thus:\n    //     bal_N = bal_0 - payout\n    //     bal_{i+1} = bal_i - bal_i * ratio = bal_i * (1-ratio)\n    //     bal_N = bal_0 * (1-ratio)**N\n    //   and so:\n    //     payoutAmount = bal_N - bal_0 = bal_0 * (1 - (1-ratio)**N)\n\n    /// Performs any melting that has vested since last call.\n    /// @custom:refresher\n    // let numPeriods = number of whole periods that have passed since `lastPayout`\n    //     payoutAmount = RToken.balanceOf(this) * (1 - (1-ratio)**N) from [furnace-payout-formula]\n    // effects:\n    //   lastPayout' = lastPayout + numPeriods * period (end of last pay period)\n    //   lastPayoutBal' = rToken.balanceOf'(this) (balance now == at end of pay leriod)\n    // actions:\n    //   rToken.melt(payoutAmount), paying payoutAmount to RToken holders\n\n    function melt() external notPausedOrFrozen {\n        if (uint48(block.timestamp) < uint64(lastPayout) + period) return;\n\n        // # of whole periods that have passed since lastPayout\n        uint48 numPeriods = uint48((block.timestamp) - lastPayout) / period;\n\n        // Paying out the ratio r, N times, equals paying out the ratio (1 - (1-r)^N) 1 time.\n        uint192 payoutRatio = FIX_ONE.minus(FIX_ONE.minus(ratio).powu(numPeriods));\n\n        uint256 amount = payoutRatio.mulu_toUint(lastPayoutBal);\n\n        lastPayout += numPeriods * period;\n        lastPayoutBal = rToken.balanceOf(address(this)) - amount;\n        if (amount > 0) rToken.melt(amount);\n    }\n\n    /// Period setting\n    /// @custom:governance\n    function setPeriod(uint48 period_) public governance {\n        require(period_ > 0 && period_ <= MAX_PERIOD, \"invalid period\");\n        emit PeriodSet(period, period_);\n        period = period_;\n    }\n\n    /// Ratio setting\n    /// @custom:governance\n    function setRatio(uint192 ratio_) public governance {\n        require(ratio_ <= MAX_RATIO, \"invalid ratio\");\n        // The ratio can safely be set to 0\n        emit RatioSet(ratio, ratio_);\n        ratio = ratio_;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[47] private __gap;\n}"
    }
  ]
}