{
  "Title": "[G-09] Use `do while` loops instead of `for` loops",
  "Content": "A `do while` loop will cost less gas since the condition is not being checked for the first iteration.\n\nTotal Instances: `14`\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-core/src/RewardsManager.sol#L680-L704\n\n*Gas Savings for `RewardsManager.claimRewards`, obtained via protocol's tests: Avg 90 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |  393064  |  \n| After  |  392974  | \n\n```solidity\nFile: ajna-core/src/RewardsManager.sol\n680:            for (uint256 i = 0; i < indexes_.length; ) {\n...\n704:                for (uint256 i = 0; i < indexes_.length; ) {\n```\n```diff\ndiff --git a/src/RewardsManager.sol b/src/RewardsManager.sol\nindex 314b476..ab3ceb6 100644\n--- a/src/RewardsManager.sol\n+++ b/src/RewardsManager.sol\n@@ -677,8 +677,8 @@ contract RewardsManager is IRewardsManager, ReentrancyGuard {\n\n         // update exchange rates only if the pool has not yet burned any tokens without calculating any reward\n         if (curBurnEpoch == 0) {\n-            for (uint256 i = 0; i < indexes_.length; ) {\n-\n+            uint256 i;\n+            do {\n                 _updateBucketExchangeRate(\n                     pool_,\n                     indexes_[i],\n@@ -687,7 +687,7 @@ contract RewardsManager is IRewardsManager, ReentrancyGuard {\n\n                 // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow\n                 unchecked { ++i; }\n-            }\n+            } while(i < indexes_.length);\n         }\n\n         else {\n@@ -701,8 +701,8 @@ contract RewardsManager is IRewardsManager, ReentrancyGuard {\n             if (block.timestamp <= curBurnTime + UPDATE_PERIOD) {\n\n                 // update exchange rates and calculate rewards if tokens were burned and within allowed time period\n-                for (uint256 i = 0; i < indexes_.length; ) {\n-\n+                uint256 i;\n+                do {\n                     // calculate rewards earned for updating bucket exchange rate\n                     updatedRewards_ += _updateBucketExchangeRateAndCalculateRewards(\n                         pool_,\n@@ -714,7 +714,7 @@ contract RewardsManager is IRewardsManager, ReentrancyGuard {\n\n                     // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow\n                     unchecked { ++i; }\n-                }\n+                } while(i < indexes_.length);\n\n                 uint256 rewardsCap            = Maths.wmul(UPDATE_CAP, totalBurned);\n                 uint256 rewardsClaimedInEpoch = updateRewardsClaimed[curBurnEpoch];\n```\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-core/src/RewardsManager.sol#L163\n\n*Gas Savings for `RewardsManager.moveStakedLiquidity`, obtained via protocol's tests: Avg 78 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |  2112272 |  \n| After  |  2112194 | \n\n```solidity\nFile: ajna-core/src/RewardsManager.sol\n163:        for (uint256 i = 0; i < fromBucketLength; ) {\n```\n```diff\ndiff --git a/src/RewardsManager.sol b/src/RewardsManager.sol\nindex 314b476..008ea99 100644\n--- a/src/RewardsManager.sol\n+++ b/src/RewardsManager.sol\n@@ -160,7 +160,8 @@ contract RewardsManager is IRewardsManager, ReentrancyGuard {\n\n         uint256 fromIndex;\n         uint256 toIndex;\n-        for (uint256 i = 0; i < fromBucketLength; ) {\n+        uint256 i;\n+        do {\n             fromIndex = fromBuckets_[i];\n             toIndex = toBuckets_[i];\n\n@@ -182,7 +183,7 @@ contract RewardsManager is IRewardsManager, ReentrancyGuard {\n\n             // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow\n             unchecked { ++i; }\n-        }\n+        } while (i < fromBucketLength);\n\n         emit MoveStakedLiquidity(tokenId_, fromBuckets_, toBuckets_);\n```\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-core/src/RewardsManager.sol#L396\n\n*Gas Savings for `RewardsManager.claimRewards`, obtained via protocol's tests: Avg 102 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |  393064  |  \n| After  |  392962  | \n\n```solidity\nFile: ajna-core/src/RewardsManager.sol\n396:        for (uint256 epoch = lastClaimedEpoch; epoch < epochToClaim_; ) {\n```\n```diff\ndiff --git a/src/RewardsManager.sol b/src/RewardsManager.sol\nindex 314b476..bf8c65a 100644\n--- a/src/RewardsManager.sol\n+++ b/src/RewardsManager.sol\n@@ -393,11 +393,10 @@ contract RewardsManager is IRewardsManager, ReentrancyGuard {\n         uint256[] memory positionIndexes = positionManager.getPositionIndexesFiltered(tokenId_);\n\n         // iterate through all burn periods to calculate and claim rewards\n-        for (uint256 epoch = lastClaimedEpoch; epoch < epochToClaim_; ) {\n-\n+        do {\n             uint256 nextEpochRewards = _calculateNextEpochRewards(\n                 tokenId_,\n-                epoch,\n+                lastClaimedEpoch,\n                 stakingEpoch,\n                 ajnaPool,\n                 positionIndexes\n@@ -405,12 +404,12 @@ contract RewardsManager is IRewardsManager, ReentrancyGuard {\n\n             rewards_ += nextEpochRewards;\n\n-            unchecked { ++epoch; }\n+            unchecked { ++lastClaimedEpoch; }\n\n             // update epoch token claim trackers\n-            rewardsClaimed[epoch]           += nextEpochRewards;\n-            isEpochClaimed[tokenId_][epoch] = true;\n-        }\n+            rewardsClaimed[lastClaimedEpoch]           += nextEpochRewards;\n+            isEpochClaimed[tokenId_][lastClaimedEpoch] = true;\n+        } while(lastClaimedEpoch < epochToClaim_);\n     }\n```\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-core/src/PositionManager.sol#L181-L210\n\n*Gas Savings for `PositionManager.memorializePositions`, obtained via protocol's tests: Avg 134 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |  1134444 |  \n| After  |  1134310 | \n\n```solidity\nFile: ajna-core/src/PositionManager.sol\n181:        for (uint256 i = 0; i < indexesLength; ) {\n182:            index = params_.indexes[i];\n183:\n184:            // record bucket index at which a position has added liquidity\n185:            // slither-disable-next-line unused-return\n186:            positionIndex.add(index);\n...\n206:            // save position in storage\n207:            positions[params_.tokenId][index] = position;\n208:\n209:            unchecked { ++i; }\n210:        }\n```\n```diff\ndiff --git a/src/PositionManager.sol b/src/PositionManager.sol\nindex 261fbc1..10fee91 100644\n--- a/src/PositionManager.sol\n+++ b/src/PositionManager.sol\n@@ -177,8 +177,9 @@ contract PositionManager is ERC721, PermitERC721, IPositionManager, Multicall, R\n\n         uint256 indexesLength = params_.indexes.length;\n         uint256 index;\n-\n-        for (uint256 i = 0; i < indexesLength; ) {\n+\n+        uint256 i;\n+        do {\n             index = params_.indexes[i];\n\n             // record bucket index at which a position has added liquidity\n@@ -207,7 +208,7 @@ contract PositionManager is ERC721, PermitERC721, IPositionManager, Multicall, R\n             positions[params_.tokenId][index] = position;\n\n             unchecked { ++i; }\n-        }\n+        } while(i < indexesLength);\n\n         // update pool LP accounting and transfer ownership of LP to PositionManager contract\n         pool.transferLP(owner, address(this), params_.indexes);\n```\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-core/src/PositionManager.sol#L364-L383\n\n*Gas Savings for `PositionManager.reedemPositions`, obtained via protocol's tests: Avg 44 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |  139811  |  \n| After  |  139767  | \n\n```solidity\nFile: ajna-core/src/PositionManager.sol\n364:        for (uint256 i = 0; i < indexesLength; ) {\n365:            index = params_.indexes[i];\n366:\n367:\n...\n379:            // remove LP tracked by position manager at bucket index\n380:            delete positions[params_.tokenId][index];\n381:\n382:            unchecked { ++i; }\n383:        }\n```\n```diff\ndiff --git a/src/PositionManager.sol b/src/PositionManager.sol\nindex 261fbc1..eeb4f44 100644\n--- a/src/PositionManager.sol\n+++ b/src/PositionManager.sol\n@@ -360,8 +360,9 @@ contract PositionManager is ERC721, PermitERC721, IPositionManager, Multicall, R\n         uint256[] memory lpAmounts = new uint256[](indexesLength);\n\n         uint256 index;\n-\n-        for (uint256 i = 0; i < indexesLength; ) {\n+\n+        uint256 i;\n+        do {\n             index = params_.indexes[i];\n\n             Position memory position = positions[params_.tokenId][index];\n@@ -380,7 +381,7 @@ contract PositionManager is ERC721, PermitERC721, IPositionManager, Multicall, R\n             delete positions[params_.tokenId][index];\n\n             unchecked { ++i; }\n-        }\n+        } while(i < indexesLength);\n\n         address owner = ownerOf(params_.tokenId);\n```\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/Funding.sol#L62-L65\n\n*Gas Savings for `GrantFund.executeExtraordinary`, obtained via protocol's tests: Avg 47 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |   95823  |  \n| After  |   95776  | \n\n```solidity\nFile: ajna-grants/src/grants/base/Funding.sol\n62:        for (uint256 i = 0; i < targets_.length; ++i) {\n63:            (bool success, bytes memory returndata) = targets_[i].call{value: values_[i]}(calldatas_[i]);\n64:            Address.verifyCallResult(success, returndata, errorMessage);\n65:        }\n```\n```diff\ndiff --git a/src/grants/base/Funding.sol b/src/grants/base/Funding.sol\nindex 72fafb9..37bd3fb 100644\n--- a/src/grants/base/Funding.sol\n+++ b/src/grants/base/Funding.sol\n@@ -59,10 +59,12 @@ abstract contract Funding is IFunding, ReentrancyGuard {\n         emit ProposalExecuted(proposalId_);\n\n         string memory errorMessage = \"Governor: call reverted without message\";\n-        for (uint256 i = 0; i < targets_.length; ++i) {\n+        uint256 i;\n+        do {\n             (bool success, bytes memory returndata) = targets_[i].call{value: values_[i]}(calldatas_[i]);\n             Address.verifyCallResult(success, returndata, errorMessage);\n-        }\n+            ++i;\n+        } while(i < targets_.length);\n     }\n\n      /**\n```\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/Funding.sol#L112-L140\n\n*Gas Savings for `GrantFund.proposeExtraordinary`, obtained via protocol's tests: Avg 44 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |   86505  |  \n| After  |   86461  | \n\n```solidity\nFile: ajna-grants/src/grants/base/Funding.sol\n112:        for (uint256 i = 0; i < targets_.length;) {\n113:\n114:            // check targets and values params are valid\n115:            if (targets_[i] != ajnaTokenAddress || values_[i] != 0) revert InvalidProposal();\n116:\n117:            // check calldata function selector is transfer()\n118:            bytes memory selDataWithSig = calldatas_[i];\n...\n136:            // update tokens requested for additional calldata\n137:            tokensRequested_ += SafeCast.toUint128(tokensRequested);\n138:\n139:            unchecked { ++i; }\n140:        }\n```\n```diff\ndiff --git a/src/grants/base/Funding.sol b/src/grants/base/Funding.sol\nindex 72fafb9..e9b3097 100644\n--- a/src/grants/base/Funding.sol\n+++ b/src/grants/base/Funding.sol\n@@ -108,9 +108,9 @@ abstract contract Funding is IFunding, ReentrancyGuard {\n\n         // check params have matching lengths\n         if (targets_.length == 0 || targets_.length != values_.length || targets_.length != calldatas_.length) revert InvalidProposal();\n-\n-        for (uint256 i = 0; i < targets_.length;) {\n-\n+\n+        uint256 i;\n+        do {\n             // check targets and values params are valid\n             if (targets_[i] != ajnaTokenAddress || values_[i] != 0) revert InvalidProposal();\n\n@@ -137,7 +137,7 @@ abstract contract Funding is IFunding, ReentrancyGuard {\n             tokensRequested_ += SafeCast.toUint128(tokensRequested);\n\n             unchecked { ++i; }\n-        }\n+        } while(i < targets_.length);\n     }\n\n     /**\n```\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/StandardFunding.sol#L434-L454\n\n*Gas Savings for `GrantFund.updateSlate`, obtained via protocol's tests: Avg 167 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |   318329 |  \n| After  |   318162 | \n\n```solidity\nFile: ajna-grants/src/grants/base/StandardFunding.sol\n434:        for (uint i = 0; i < numProposalsInSlate_; ) {\n435:            Proposal memory proposal = _standardFundingProposals[proposalIds_[i]];\n436:\n437:            // check if Proposal is in the topTenProposals list\n438:            if (_findProposalIndex(proposalIds_[i], _topTenProposals[distributionId_]) == -1) revert InvalidProposalSlate();\n439:\n440:            // account for fundingVotesReceived possibly being negative\n441:            if (proposal.fundingVotesReceived < 0) revert InvalidProposalSlate();\n442:\n443:            // update counters\n444:            sum_ += uint128(proposal.fundingVotesReceived); // since we are converting from int128 to uint128, we can safely assume that the value will not overflow\n445:            totalTokensRequested += proposal.tokensRequested;\n446:\n447:            // check if slate of proposals exceeded budget constraint ( 90% of GBC )\n448:            if (totalTokensRequested > (gbc * 9 / 10)) {\n449:                revert InvalidProposalSlate();\n450:            }\n451:\n452:            unchecked { ++i; }\n453:        }\n454:    }\n```\n```diff\ndiff --git a/src/grants/base/StandardFunding.sol b/src/grants/base/StandardFunding.sol\nindex 928b337..17c47e8 100644\n--- a/src/grants/base/StandardFunding.sol\n+++ b/src/grants/base/StandardFunding.sol\n@@ -431,7 +431,8 @@ abstract contract StandardFunding is Funding, IStandardFunding {\n         uint256 totalTokensRequested = 0;\n\n         // check each proposal in the slate is valid\n-        for (uint i = 0; i < numProposalsInSlate_; ) {\n+        uint256 i;\n+        do {\n             Proposal memory proposal = _standardFundingProposals[proposalIds_[i]];\n\n             // check if Proposal is in the topTenProposals list\n@@ -450,7 +451,7 @@ abstract contract StandardFunding is Funding, IStandardFunding {\n             }\n\n             unchecked { ++i; }\n-        }\n+        } while(i < numProposalsInSlate_);\n     }\n\n     /**\n```\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/StandardFunding.sol#L549-L568\n\n*Gas Savings for `GrantFund.fundingVote`, obtained via protocol's tests: Avg 111 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |   409345 |  \n| After  |   409234 | \n\n```solidity\nFile: ajna-grants/src/grants/base/StandardFunding.sol\n549:        for (uint256 i = 0; i < numVotesCast; ) {\n550:            Proposal storage proposal = _standardFundingProposals[voteParams_[i].proposalId];\n551:\n552:            // check that the proposal is part of the current distribution period\n553:            if (proposal.distributionId != currentDistributionId) revert InvalidVote();\n554:\n555:            // check that the proposal being voted on is in the top ten screened proposals\n556:            if (_findProposalIndex(voteParams_[i].proposalId, _topTenProposals[currentDistributionId]) == -1) revert InvalidVote();\n557:\n558:            // cast each successive vote\n559:            votesCast_ += _fundingVote(\n560:                currentDistribution,\n561:                proposal,\n562:                msg.sender,\n563:                voter,\n564:                voteParams_[i]\n565:            );\n566:\n567:            unchecked { ++i; }\n568:        }\n```\n```diff\ndiff --git a/src/grants/base/StandardFunding.sol b/src/grants/base/StandardFunding.sol\nindex 928b337..9dcab1a 100644\n--- a/src/grants/base/StandardFunding.sol\n+++ b/src/grants/base/StandardFunding.sol\n@@ -545,8 +545,9 @@ abstract contract StandardFunding is Funding, IStandardFunding {\n         }\n\n         uint256 numVotesCast = voteParams_.length;\n-\n-        for (uint256 i = 0; i < numVotesCast; ) {\n+\n+        uint256 i;\n+        do {\n             Proposal storage proposal = _standardFundingProposals[voteParams_[i].proposalId];\n\n             // check that the proposal is part of the current distribution period\n@@ -565,7 +566,7 @@ abstract contract StandardFunding is Funding, IStandardFunding {\n             );\n\n             unchecked { ++i; }\n-        }\n+        } while(i < numVotesCast);\n     }\n\n     /// @inheritdoc IStandardFunding\n```\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/StandardFunding.sol#L582-L595\n\n*Gas Savings for `GrantFund.screeningVote`, obtained via protocol's tests: Avg 167 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |   399146 |  \n| After  |   398979 | \n\n```solidity\nFile: ajna-grants/src/grants/base/StandardFunding.sol\n582:        for (uint256 i = 0; i < numVotesCast; ) {\n583:            Proposal storage proposal = _standardFundingProposals[voteParams_[i].proposalId];\n584:\n585:            // check that the proposal is part of the current distribution period\n586:            if (proposal.distributionId != currentDistribution.id) revert InvalidVote();\n587:\n588:            uint256 votes = voteParams_[i].votes;\n589:\n590:            // cast each successive vote\n591:            votesCast_ += votes;\n592:            _screeningVote(msg.sender, proposal, votes);\n593:\n594:            unchecked { ++i; }\n595:        }\n```\n```diff\ndiff --git a/src/grants/base/StandardFunding.sol b/src/grants/base/StandardFunding.sol\nindex 928b337..649df77 100644\n--- a/src/grants/base/StandardFunding.sol\n+++ b/src/grants/base/StandardFunding.sol\n@@ -578,8 +578,9 @@ abstract contract StandardFunding is Funding, IStandardFunding {\n         if (block.number < currentDistribution.startBlock || block.number > _getScreeningStageEndBlock(currentDistribution.endBlock)) revert InvalidVote();\n\n         uint256 numVotesCast = voteParams_.length;\n-\n-        for (uint256 i = 0; i < numVotesCast; ) {\n+\n+        uint256 i;\n+        do {\n             Proposal storage proposal = _standardFundingProposals[voteParams_[i].proposalId];\n\n             // check that the proposal is part of the current distribution period\n@@ -592,7 +593,7 @@ abstract contract StandardFunding is Funding, IStandardFunding {\n             _screeningVote(msg.sender, proposal, votes);\n\n             unchecked { ++i; }\n-        }\n+        } while(i < numVotesCast);\n     }\n\n     /*********************************/\n```\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/StandardFunding.sol#L848-L852\n\n*Gas Savings for `GrantFund.fundingVote`, obtained via protocol's tests: Avg 456 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |   409345 |  \n| After  |   408889 | \n\n```solidity\nFile: ajna-grants/src/grants/base/StandardFunding.sol\n848:        for (uint256 i = 0; i < numVotesCast; ) {\n849:            votesCastSumSquared_ += Maths.wpow(SafeCast.toUint256(Maths.abs(votesCast_[i].votesUsed)), 2);\n850:\n851:            unchecked { ++i; }\n852:        }\n```\n```diff\ndiff --git a/src/grants/base/StandardFunding.sol b/src/grants/base/StandardFunding.sol\nindex 928b337..188e3db 100644\n--- a/src/grants/base/StandardFunding.sol\n+++ b/src/grants/base/StandardFunding.sol\n@@ -844,12 +844,13 @@ abstract contract StandardFunding is Funding, IStandardFunding {\n         FundingVoteParams[] memory votesCast_\n     ) internal pure returns (uint256 votesCastSumSquared_) {\n         uint256 numVotesCast = votesCast_.length;\n-\n-        for (uint256 i = 0; i < numVotesCast; ) {\n+\n+        uint256 i;\n+        do {\n             votesCastSumSquared_ += Maths.wpow(SafeCast.toUint256(Maths.abs(votesCast_[i].votesUsed)), 2);\n\n             unchecked { ++i; }\n-        }\n+        } while(i < numVotesCast);\n     }\n\n     /**\n```\n\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/StandardFunding.sol#L208-L214\n\n*Gas Savings for `GrantFund.startNewDistributionPeriod`, obtained via protocol's tests: Avg 82 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |   75597  |  \n| After  |   75515  | \n\n```solidity\nFile: ajna-grants/src/grants/base/StandardFunding.sol\n208:        for (uint i = 0; i < numFundedProposals; ) {\n```\n```diff\ndiff --git a/src/grants/base/StandardFunding.sol b/src/grants/base/StandardFunding.sol\nindex 928b337..7e2d7db 100644\n--- a/src/grants/base/StandardFunding.sol\n+++ b/src/grants/base/StandardFunding.sol\n@@ -204,14 +204,15 @@ abstract contract StandardFunding is Funding, IStandardFunding {\n\n         uint256 totalTokensRequested;\n         uint256 numFundedProposals = fundingProposalIds.length;\n-\n-        for (uint i = 0; i < numFundedProposals; ) {\n+\n+        uint256 i;\n+        do {\n             Proposal memory proposal = _standardFundingProposals[fundingProposalIds[i]];\n\n             totalTokensRequested += proposal.tokensRequested;\n\n             unchecked { ++i; }\n-        }\n+        } while(i < numFundedProposals);\n\n         // readd non distributed tokens to the treasury\n         treasury += (fundsAvailable - totalTokensRequested);\n```\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/StandardFunding.sol#L324-L330\n\n*Gas Savings for `GrantFund.updateSlate`, obtained via protocol's tests: Avg 167 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |   318329  |  \n| After  |   318162  | \n\n```solidity\nFile: ajna-grants/src/grants/base/StandardFunding.sol\n324:            for (uint i = 0; i < numProposalsInSlate; ) {\n```\n```diff\ndiff --git a/src/grants/base/StandardFunding.sol b/src/grants/base/StandardFunding.sol\nindex 928b337..67bee79 100644\n--- a/src/grants/base/StandardFunding.sol\n+++ b/src/grants/base/StandardFunding.sol\n@@ -320,14 +320,14 @@ abstract contract StandardFunding is Funding, IStandardFunding {\n         // if slate of proposals is new top slate, update state\n         if (newTopSlate_) {\n             uint256[] storage existingSlate = _fundedProposalSlates[newSlateHash];\n-\n-            for (uint i = 0; i < numProposalsInSlate; ) {\n-\n+\n+            uint256 i;\n+            do {\n                 // update list of proposals to fund\n                 existingSlate.push(proposalIds_[i]);\n\n                 unchecked { ++i; }\n-            }\n+            } while(i < numProposalsInSlate);\n\n             // update hash to point to the new leading slate of proposals\n             currentDistribution.fundedSlateHash = newSlateHash;\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-05-ajna",
  "Code": [
    {
      "filename": "ajna-core/src/RewardsManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport { IERC20 }          from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { IERC721 }         from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport { ReentrancyGuard } from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport { SafeERC20 }       from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport { IPool }                        from './interfaces/pool/IPool.sol';\nimport { IPositionManager }             from './interfaces/position/IPositionManager.sol';\nimport { IPositionManagerOwnerActions } from './interfaces/position/IPositionManagerOwnerActions.sol';\nimport {\n    IRewardsManager,\n    IRewardsManagerOwnerActions,\n    IRewardsManagerState,\n    IRewardsManagerDerivedState\n} from './interfaces/rewards/IRewardsManager.sol';\nimport { StakeInfo, BucketState } from './interfaces/rewards/IRewardsManagerState.sol';\n\nimport { PositionManager } from './PositionManager.sol';\n\nimport { Maths } from './libraries/internal/Maths.sol';\n\n/**\n *  @title  Rewards (staking) Manager contract\n *  @notice Pool lenders can optionally mint `NFT` that represents their positions.\n *          The Rewards contract allows pool lenders with positions `NFT` to stake and earn `Ajna` tokens. \n *          Lenders with `NFT`s can:\n *          - `stake` token\n *          - `update bucket exchange rate` and earn rewards\n *          - `claim` rewards\n *          - `unstake` token\n */\ncontract RewardsManager is IRewardsManager, ReentrancyGuard {\n\n    using SafeERC20 for IERC20;\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    /**\n     * @notice Maximum percentage of tokens burned that can be claimed as `Ajna` token `LP` `NFT` rewards.\n     */\n    uint256 internal constant REWARD_CAP = 0.8 * 1e18;\n    /**\n     * @notice Maximum percentage of tokens burned that can be claimed as `Ajna` token update rewards.\n     */\n    uint256 internal constant UPDATE_CAP = 0.1 * 1e18;\n    /**\n     * @notice Reward factor by which to scale the total rewards earned.\n     * @dev ensures that rewards issued to staked lenders in a given pool are less than the `Ajna` tokens burned in that pool.\n     */\n    uint256 internal constant REWARD_FACTOR = 0.5 * 1e18;\n    /**\n     * @notice Reward factor by which to scale rewards earned for updating a buckets exchange rate.\n     */\n    uint256 internal constant UPDATE_CLAIM_REWARD = 0.05 * 1e18;\n    /**\n     * @notice Time period after a burn event in which buckets exchange rates can be updated.\n     */\n    uint256 internal constant UPDATE_PERIOD = 2 weeks;\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    /// @dev `tokenID => epoch => bool has claimed` mapping.\n    mapping(uint256 => mapping(uint256 => bool)) public override isEpochClaimed;\n    /// @dev `epoch => rewards claimed` mapping.\n    mapping(uint256 => uint256) public override rewardsClaimed;\n    /// @dev `epoch => update bucket rate rewards claimed` mapping.\n    mapping(uint256 => uint256) public override updateRewardsClaimed;\n\n    /// @dev Mapping of per pool bucket exchange rates at a given burn event `poolAddress => bucketIndex => epoch => bucket exchange rate`.\n    mapping(address => mapping(uint256 => mapping(uint256 => uint256))) internal bucketExchangeRates;\n\n    /// @dev Mapping `tokenID => Stake info`.\n    mapping(uint256 => StakeInfo) internal stakes;\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    /// @dev Address of the `Ajna` token.\n    address public immutable ajnaToken;\n    /// @dev The `PositionManager` contract\n    IPositionManager public immutable positionManager;\n\n    /*******************/\n    /*** Constructor ***/\n    /*******************/\n\n    constructor(address ajnaToken_, IPositionManager positionManager_) {\n        if (ajnaToken_ == address(0)) revert DeployWithZeroAddress();\n\n        ajnaToken = ajnaToken_;\n        positionManager = positionManager_;\n    }\n\n    /**************************/\n    /*** External Functions ***/\n    /**************************/\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev    === Revert on ===\n     *  @dev    not owner `NotOwnerOfDeposit()`\n     *  @dev    already claimed `AlreadyClaimed()`\n     *  @dev    === Emit events ===\n     *  @dev    - `ClaimRewards`\n     */\n    function claimRewards(\n        uint256 tokenId_,\n        uint256 epochToClaim_\n    ) external override {\n        StakeInfo storage stakeInfo = stakes[tokenId_];\n\n        if (msg.sender != stakeInfo.owner) revert NotOwnerOfDeposit();\n\n        if (isEpochClaimed[tokenId_][epochToClaim_]) revert AlreadyClaimed();\n\n        _claimRewards(stakeInfo, tokenId_, epochToClaim_, true, stakeInfo.ajnaPool);\n    }\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev    === Revert on ===\n     *  @dev    not owner `NotOwnerOfDeposit()`\n     *  @dev    invalid index params `MoveStakedLiquidityInvalid()`\n     *  @dev    === Emit events ===\n     *  @dev    - `MoveStakedLiquidity`\n     */\n    function moveStakedLiquidity(\n        uint256 tokenId_,\n        uint256[] memory fromBuckets_,\n        uint256[] memory toBuckets_,\n        uint256 expiry_\n    ) external nonReentrant override {\n        StakeInfo storage stakeInfo = stakes[tokenId_];\n\n        if (msg.sender != stakeInfo.owner) revert NotOwnerOfDeposit();\n\n        // check move array sizes match to be able to match on index\n        uint256 fromBucketLength = fromBuckets_.length;\n        if (fromBucketLength != toBuckets_.length) revert MoveStakedLiquidityInvalid();\n\n        address ajnaPool = stakeInfo.ajnaPool;\n        uint256 curBurnEpoch = IPool(ajnaPool).currentBurnEpoch();\n\n        // claim rewards before moving liquidity, if any\n        _claimRewards(\n            stakeInfo,\n            tokenId_,\n            curBurnEpoch,\n            false,\n            ajnaPool\n        );\n\n        uint256 fromIndex;\n        uint256 toIndex;\n        for (uint256 i = 0; i < fromBucketLength; ) {\n            fromIndex = fromBuckets_[i];\n            toIndex = toBuckets_[i];\n\n            // call out to position manager to move liquidity between buckets\n            IPositionManagerOwnerActions.MoveLiquidityParams memory moveLiquidityParams = IPositionManagerOwnerActions.MoveLiquidityParams(\n                tokenId_,\n                ajnaPool,\n                fromIndex,\n                toIndex,\n                expiry_\n            );\n            positionManager.moveLiquidity(moveLiquidityParams);\n\n            // update to bucket state\n            BucketState storage toBucket = stakeInfo.snapshot[toIndex];\n            toBucket.lpsAtStakeTime  = uint128(positionManager.getLP(tokenId_, toIndex));\n            toBucket.rateAtStakeTime = uint128(IPool(ajnaPool).bucketExchangeRate(toIndex));\n            delete stakeInfo.snapshot[fromIndex];\n\n            // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow\n            unchecked { ++i; }\n        }\n\n        emit MoveStakedLiquidity(tokenId_, fromBuckets_, toBuckets_);\n\n        // update to bucket list exchange rates, from buckets are aready updated on claim\n        // calculate rewards for updating exchange rates, if any\n        uint256 updateReward = _updateBucketExchangeRates(\n            ajnaPool,\n            toBuckets_\n        );\n\n        // transfer rewards to sender\n        _transferAjnaRewards(updateReward);\n    }\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev    === Revert on ===\n     *  @dev    not owner `NotOwnerOfDeposit()`\n     *  @dev    === Emit events ===\n     *  @dev    - `Stake`\n     */\n    function stake(\n        uint256 tokenId_\n    ) external override {\n        address ajnaPool = PositionManager(address(positionManager)).poolKey(tokenId_);\n\n        // check that msg.sender is owner of tokenId\n        if (IERC721(address(positionManager)).ownerOf(tokenId_) != msg.sender) revert NotOwnerOfDeposit();\n\n        StakeInfo storage stakeInfo = stakes[tokenId_];\n        stakeInfo.owner    = msg.sender;\n        stakeInfo.ajnaPool = ajnaPool;\n\n        uint256 curBurnEpoch = IPool(ajnaPool).currentBurnEpoch();\n\n        // record the staking epoch\n        stakeInfo.stakingEpoch = uint96(curBurnEpoch);\n\n        // initialize last time interaction at staking epoch\n        stakeInfo.lastClaimedEpoch = uint96(curBurnEpoch);\n\n        uint256[] memory positionIndexes = positionManager.getPositionIndexes(tokenId_);\n\n        for (uint256 i = 0; i < positionIndexes.length; ) {\n\n            uint256 bucketId = positionIndexes[i];\n\n            BucketState storage bucketState = stakeInfo.snapshot[bucketId];\n\n            // record the number of lps in bucket at the time of staking\n            bucketState.lpsAtStakeTime = uint128(positionManager.getLP(\n                tokenId_,\n                bucketId\n            ));\n            // record the bucket exchange rate at the time of staking\n            bucketState.rateAtStakeTime = uint128(IPool(ajnaPool).bucketExchangeRate(bucketId));\n\n            // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow\n            unchecked { ++i; }\n        }\n\n        emit Stake(msg.sender, ajnaPool, tokenId_);\n\n        // transfer LP NFT to this contract\n        IERC721(address(positionManager)).transferFrom(msg.sender, address(this), tokenId_);\n\n        // calculate rewards for updating exchange rates, if any\n        uint256 updateReward = _updateBucketExchangeRates(\n            ajnaPool,\n            positionIndexes\n        );\n\n        // transfer rewards to sender\n        _transferAjnaRewards(updateReward);\n    }\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev    === Revert on ===\n     *  @dev    not owner `NotOwnerOfDeposit()`\n     *  @dev    === Emit events ===\n     *  @dev    - `ClaimRewards`\n     *  @dev    - `Unstake`\n     */\n    function unstake(\n        uint256 tokenId_\n    ) external override {\n        StakeInfo storage stakeInfo = stakes[tokenId_];\n\n        if (msg.sender != stakeInfo.owner) revert NotOwnerOfDeposit();\n\n        address ajnaPool = stakeInfo.ajnaPool;\n\n        // claim rewards, if any\n        _claimRewards(\n            stakeInfo,\n            tokenId_,\n            IPool(ajnaPool).currentBurnEpoch(),\n            false,\n            ajnaPool\n        );\n\n        // remove bucket snapshots recorded at the time of staking\n        uint256[] memory positionIndexes = positionManager.getPositionIndexes(tokenId_);\n        for (uint256 i = 0; i < positionIndexes.length; ) {\n            delete stakeInfo.snapshot[positionIndexes[i]]; // reset BucketState struct for current position\n\n            unchecked { ++i; }\n        }\n\n        // remove recorded stake info\n        delete stakes[tokenId_];\n\n        emit Unstake(msg.sender, ajnaPool, tokenId_);\n\n        // transfer LP NFT from contract to sender\n        IERC721(address(positionManager)).transferFrom(address(this), msg.sender, tokenId_);\n    }\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev    === Emit events ===\n     *  @dev    - `UpdateExchangeRates`\n     */\n    function updateBucketExchangeRatesAndClaim(\n        address pool_,\n        uint256[] calldata indexes_\n    ) external override returns (uint256 updateReward) {\n        updateReward = _updateBucketExchangeRates(pool_, indexes_);\n\n        // transfer rewards to sender\n        _transferAjnaRewards(updateReward);\n    }\n\n    /*******************************/\n    /*** External View Functions ***/\n    /*******************************/\n\n    /// @inheritdoc IRewardsManagerDerivedState\n    function calculateRewards(\n        uint256 tokenId_,\n        uint256 epochToClaim_\n    ) external view override returns (uint256 rewards_) {\n\n        address ajnaPool         = stakes[tokenId_].ajnaPool;\n        uint256 lastClaimedEpoch = stakes[tokenId_].lastClaimedEpoch;\n        uint256 stakingEpoch     = stakes[tokenId_].stakingEpoch;\n\n        uint256[] memory positionIndexes = positionManager.getPositionIndexesFiltered(tokenId_);\n\n        // iterate through all burn periods to calculate and claim rewards\n        for (uint256 epoch = lastClaimedEpoch; epoch < epochToClaim_; ) {\n\n            rewards_ += _calculateNextEpochRewards(\n                tokenId_,\n                epoch,\n                stakingEpoch,\n                ajnaPool,\n                positionIndexes\n            );\n\n            unchecked { ++epoch; }\n        }\n    }\n\n    /// @inheritdoc IRewardsManagerState\n    function getStakeInfo(\n        uint256 tokenId_\n    ) external view override returns (address, address, uint256) {\n        return (\n            stakes[tokenId_].owner,\n            stakes[tokenId_].ajnaPool,\n            stakes[tokenId_].lastClaimedEpoch\n        );\n    }\n\n    /// @inheritdoc IRewardsManagerState\n    function getBucketStateStakeInfo(\n        uint256 tokenId_,\n        uint256 bucketId_\n    ) external view override returns (uint256, uint256) {\n        return (\n            stakes[tokenId_].snapshot[bucketId_].lpsAtStakeTime,\n            stakes[tokenId_].snapshot[bucketId_].rateAtStakeTime\n        );\n    }\n\n    /**************************/\n    /*** Internal Functions ***/\n    /**************************/\n\n    /**\n     *  @notice Calculate the amount of rewards that have been accumulated by a staked `NFT`.\n     *  @dev    Rewards are calculated as the difference in exchange rates between the last interaction burn event and the current burn event.\n     *  @param  tokenId_      `ID` of the staked `LP` `NFT`.\n     *  @param  epochToClaim_ The burn epoch to claim rewards for (rewards calculation starts from the last claimed epoch).\n     *  @return rewards_      Amount of rewards earned by the `NFT`.\n     */\n    function _calculateAndClaimRewards(\n        uint256 tokenId_,\n        uint256 epochToClaim_\n    ) internal returns (uint256 rewards_) {\n\n        address ajnaPool         = stakes[tokenId_].ajnaPool;\n        uint256 lastClaimedEpoch = stakes[tokenId_].lastClaimedEpoch;\n        uint256 stakingEpoch     = stakes[tokenId_].stakingEpoch;\n\n        uint256[] memory positionIndexes = positionManager.getPositionIndexesFiltered(tokenId_);\n\n        // iterate through all burn periods to calculate and claim rewards\n        for (uint256 epoch = lastClaimedEpoch; epoch < epochToClaim_; ) {\n\n            uint256 nextEpochRewards = _calculateNextEpochRewards(\n                tokenId_,\n                epoch,\n                stakingEpoch,\n                ajnaPool,\n                positionIndexes\n            );\n\n            rewards_ += nextEpochRewards;\n\n            unchecked { ++epoch; }\n\n            // update epoch token claim trackers\n            rewardsClaimed[epoch]           += nextEpochRewards;\n            isEpochClaimed[tokenId_][epoch] = true;\n        }\n    }\n\n    /**\n     *  @notice Calculate the amount of rewards that have been accumulated by a staked `NFT` in next epoch.\n     *  @dev    Rewards are calculated as the difference in exchange rates between the last interaction burn event and the current burn event.\n     *  @param  tokenId_         `ID` of the staked `LP` `NFT`.\n     *  @param  epoch_           The current epoch.\n     *  @param  stakingEpoch_    The epoch in which token was staked.\n     *  @param  ajnaPool_        Address of the pool.\n     *  @param  positionIndexes_ Bucket ids associated with `NFT` staked.\n     *  @return epochRewards_    Calculated rewards in epoch.\n     */\n    function _calculateNextEpochRewards(\n        uint256 tokenId_,\n        uint256 epoch_,\n        uint256 stakingEpoch_,\n        address ajnaPool_,\n        uint256[] memory positionIndexes_\n    ) internal view returns (uint256 epochRewards_) {\n\n        uint256 nextEpoch = epoch_ + 1;\n        uint256 claimedRewardsInNextEpoch = rewardsClaimed[nextEpoch];\n        uint256 bucketIndex;\n        uint256 interestEarned;\n\n        // iterate through all buckets and calculate epoch rewards for\n        for (uint256 i = 0; i < positionIndexes_.length; ) {\n            bucketIndex = positionIndexes_[i];\n            BucketState memory bucketSnapshot = stakes[tokenId_].snapshot[bucketIndex];\n\n            uint256 bucketRate;\n            if (epoch_ != stakingEpoch_) {\n\n                // if staked in a previous epoch then use the initial exchange rate of epoch\n                bucketRate = bucketExchangeRates[ajnaPool_][bucketIndex][epoch_];\n            } else {\n\n                // if staked during the epoch then use the bucket rate at the time of staking\n                bucketRate = bucketSnapshot.rateAtStakeTime;\n            }\n\n            // calculate the amount of interest accrued in current epoch\n            interestEarned += _calculateExchangeRateInterestEarned(\n                ajnaPool_,\n                nextEpoch,\n                bucketIndex,\n                bucketSnapshot.lpsAtStakeTime,\n                bucketRate\n            ); \n            unchecked { ++i; }\n        }\n\n        // calculate and accumulate rewards if interest earned\n        if (interestEarned != 0) {\n            epochRewards_ = _calculateNewRewards(\n                ajnaPool_,\n                interestEarned,\n                nextEpoch,\n                epoch_,\n                claimedRewardsInNextEpoch\n            );\n        }\n    }\n\n    /**\n     *  @notice Calculate the amount of interest that has accrued to a lender in a bucket based upon their `LP`.\n     *  @param  pool_           Address of the pool whose exchange rates are being checked.\n     *  @param  nextEventEpoch_ The next event epoch to check the exchange rate for.\n     *  @param  bucketIndex_    Index of the bucket to check the exchange rate for.\n     *  @param  bucketLP_       Amount of `LP` in bucket.\n     *  @param  exchangeRate_   Exchange rate in current epoch.\n     *  @return interestEarned_ The amount of interest accrued.\n     */\n    function _calculateExchangeRateInterestEarned(\n        address pool_,\n        uint256 nextEventEpoch_,\n        uint256 bucketIndex_,\n        uint256 bucketLP_,\n        uint256 exchangeRate_\n    ) internal view returns (uint256 interestEarned_) {\n\n        if (exchangeRate_ != 0) {\n\n            uint256 nextExchangeRate = bucketExchangeRates[pool_][bucketIndex_][nextEventEpoch_];\n\n            // calculate interest earned only if next exchange rate is higher than current exchange rate\n            if (nextExchangeRate > exchangeRate_) {\n\n                // calculate the equivalent amount of quote tokens given the stakes lp balance,\n                // and the exchange rate at the next and current burn events\n                interestEarned_ = Maths.wmul(nextExchangeRate - exchangeRate_, bucketLP_);\n            }\n\n        }\n    }\n\n    /**\n     *  @notice Calculate new rewards between current and next epoch, based on earned interest.\n     *  @param  ajnaPool_              Address of the pool.\n     *  @param  interestEarned_        The amount of interest accrued to current epoch.\n     *  @param  nextEpoch_             The next burn event epoch to calculate new rewards.\n     *  @param  epoch_                 The current burn event epoch to calculate new rewards.\n     *  @param  rewardsClaimedInEpoch_ Rewards claimed in epoch.\n     *  @return newRewards_            New rewards between current and next burn event epoch.\n     */\n    function _calculateNewRewards(\n        address ajnaPool_,\n        uint256 interestEarned_,\n        uint256 nextEpoch_,\n        uint256 epoch_,\n        uint256 rewardsClaimedInEpoch_\n    ) internal view returns (uint256 newRewards_) {\n        (\n            ,\n            // total interest accumulated by the pool over the claim period\n            uint256 totalBurnedInPeriod,\n            // total tokens burned over the claim period\n            uint256 totalInterestEarnedInPeriod\n        ) = _getPoolAccumulators(ajnaPool_, nextEpoch_, epoch_);\n\n        // calculate rewards earned\n        newRewards_ = totalInterestEarnedInPeriod == 0 ? 0 : Maths.wmul(\n            REWARD_FACTOR,\n            Maths.wdiv(\n                Maths.wmul(interestEarned_, totalBurnedInPeriod),\n                totalInterestEarnedInPeriod\n            )\n        );\n\n        uint256 rewardsCapped = Maths.wmul(REWARD_CAP, totalBurnedInPeriod);\n\n        // Check rewards claimed - check that less than 80% of the tokens for a given burn event have been claimed.\n        if (rewardsClaimedInEpoch_ + newRewards_ > rewardsCapped) {\n\n            // set claim reward to difference between cap and reward\n            newRewards_ = rewardsCapped - rewardsClaimedInEpoch_;\n        }\n    }\n\n    /**\n     *  @notice Claim rewards that have been accumulated by a staked `NFT`.\n     *  @param  stakeInfo_     `StakeInfo` struct containing details of stake to claim rewards for.\n     *  @param  tokenId_       `ID` of the staked `LP` `NFT`.\n     *  @param  epochToClaim_  The burn epoch to claim rewards for (rewards calculation starts from the last claimed epoch)\n     *  @param  validateEpoch_ True if the epoch is received as a parameter and needs to be validated (lower or equal with latest epoch).\n     *  @param  ajnaPool_      Address of `Ajna` pool associated with the stake.\n     */\n    function _claimRewards(\n        StakeInfo storage stakeInfo_,\n        uint256 tokenId_,\n        uint256 epochToClaim_,\n        bool validateEpoch_,\n        address ajnaPool_\n    ) internal {\n\n        // revert if higher epoch to claim than current burn epoch\n        if (validateEpoch_ && epochToClaim_ > IPool(ajnaPool_).currentBurnEpoch()) revert EpochNotAvailable();\n\n        // update bucket exchange rates and claim associated rewards\n        uint256 rewardsEarned = _updateBucketExchangeRates(\n            ajnaPool_,\n            positionManager.getPositionIndexes(tokenId_)\n        );\n\n        rewardsEarned += _calculateAndClaimRewards(tokenId_, epochToClaim_);\n\n        uint256[] memory burnEpochsClaimed = _getBurnEpochsClaimed(\n            stakeInfo_.lastClaimedEpoch,\n            epochToClaim_\n        );\n\n        emit ClaimRewards(\n            msg.sender,\n            ajnaPool_,\n            tokenId_,\n            burnEpochsClaimed,\n            rewardsEarned\n        );\n\n        // update last interaction burn event\n        stakeInfo_.lastClaimedEpoch = uint96(epochToClaim_);\n\n        // transfer rewards to sender\n        _transferAjnaRewards(rewardsEarned);\n    }\n\n    /**\n     *  @notice Retrieve an array of burn epochs from which a depositor has claimed rewards.\n     *  @param  lastClaimedEpoch_      The last burn period in which a depositor claimed rewards.\n     *  @param  burnEpochToStartClaim_ The most recent burn period from a depositor earned rewards.\n     *  @return burnEpochsClaimed_     Array of burn epochs from which a depositor has claimed rewards.\n     */\n    function _getBurnEpochsClaimed(\n        uint256 lastClaimedEpoch_,\n        uint256 burnEpochToStartClaim_\n    ) internal pure returns (uint256[] memory burnEpochsClaimed_) {\n        uint256 numEpochsClaimed = burnEpochToStartClaim_ - lastClaimedEpoch_;\n\n        burnEpochsClaimed_ = new uint256[](numEpochsClaimed);\n\n        uint256 i;\n        uint256 claimEpoch = lastClaimedEpoch_ + 1;\n        while (claimEpoch <= burnEpochToStartClaim_) {\n            burnEpochsClaimed_[i] = claimEpoch;\n\n            // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow\n            unchecked {\n                ++i;\n                ++claimEpoch;\n            }\n        }\n    }\n\n    /**\n     *  @notice Retrieve the total ajna tokens burned and total interest earned by a pool since a given block.\n     *  @param  pool_                  Address of the `Ajna` pool to retrieve accumulators of.\n     *  @param  currentBurnEventEpoch_ The latest burn event.\n     *  @param  lastBurnEventEpoch_    The burn event to use as checkpoint since which values have accumulated.\n     *  @return Timestamp of the latest burn event.\n     *  @return Total `Ajna` tokens burned by the pool since the last burn event.\n     *  @return Total interest earned by the pool since the last burn event.\n     */\n    function _getPoolAccumulators(\n        address pool_,\n        uint256 currentBurnEventEpoch_,\n        uint256 lastBurnEventEpoch_\n    ) internal view returns (uint256, uint256, uint256) {\n        (\n            uint256 currentBurnTime,\n            uint256 totalInterestLatest,\n            uint256 totalBurnedLatest\n        ) = IPool(pool_).burnInfo(currentBurnEventEpoch_);\n\n        (\n            ,\n            uint256 totalInterestAtBlock,\n            uint256 totalBurnedAtBlock\n        ) = IPool(pool_).burnInfo(lastBurnEventEpoch_);\n\n        uint256 totalBurned   = totalBurnedLatest   != 0 ? totalBurnedLatest   - totalBurnedAtBlock   : totalBurnedAtBlock;\n        uint256 totalInterest = totalInterestLatest != 0 ? totalInterestLatest - totalInterestAtBlock : totalInterestAtBlock;\n\n        return (\n            currentBurnTime,\n            totalBurned,\n            totalInterest\n        );\n    }\n\n    /**\n     *  @notice Update the exchange rate of a list of buckets.\n     *  @dev    Called as part of `stake`, `unstake`, and `claimRewards`, as well as `updateBucketExchangeRatesAndClaim`.\n     *  @dev    Caller can claim `5%` of the rewards that have accumulated to each bucket since the last burn event, if it hasn't already been updated.\n     *  @param  pool_           Address of the pool whose exchange rates are being updated.\n     *  @param  indexes_        List of bucket indexes to be updated.\n     *  @return updatedRewards_ Update exchange rate rewards.\n     */\n    function _updateBucketExchangeRates(\n        address pool_,\n        uint256[] memory indexes_\n    ) internal returns (uint256 updatedRewards_) {\n        // get the current burn epoch from the given pool\n        uint256 curBurnEpoch = IPool(pool_).currentBurnEpoch();\n\n        // update exchange rates only if the pool has not yet burned any tokens without calculating any reward\n        if (curBurnEpoch == 0) {\n            for (uint256 i = 0; i < indexes_.length; ) {\n\n                _updateBucketExchangeRate(\n                    pool_,\n                    indexes_[i],\n                    curBurnEpoch\n                );\n\n                // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow\n                unchecked { ++i; }\n            }\n        }\n\n        else {\n            // retrieve accumulator values used to calculate rewards accrued\n            (\n                uint256 curBurnTime,\n                uint256 totalBurned,\n                uint256 totalInterestEarned\n            ) = _getPoolAccumulators(pool_, curBurnEpoch, curBurnEpoch - 1);\n\n            if (block.timestamp <= curBurnTime + UPDATE_PERIOD) {\n\n                // update exchange rates and calculate rewards if tokens were burned and within allowed time period\n                for (uint256 i = 0; i < indexes_.length; ) {\n\n                    // calculate rewards earned for updating bucket exchange rate\n                    updatedRewards_ += _updateBucketExchangeRateAndCalculateRewards(\n                        pool_,\n                        indexes_[i],\n                        curBurnEpoch,\n                        totalBurned,\n                        totalInterestEarned\n                    );\n\n                    // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow\n                    unchecked { ++i; }\n                }\n\n                uint256 rewardsCap            = Maths.wmul(UPDATE_CAP, totalBurned);\n                uint256 rewardsClaimedInEpoch = updateRewardsClaimed[curBurnEpoch];\n\n                // update total tokens claimed for updating bucket exchange rates tracker\n                if (rewardsClaimedInEpoch + updatedRewards_ >= rewardsCap) {\n                    // if update reward is greater than cap, set to remaining difference\n                    updatedRewards_ = rewardsCap - rewardsClaimedInEpoch;\n                }\n\n                // accumulate the full amount of additional rewards\n                updateRewardsClaimed[curBurnEpoch] += updatedRewards_;\n            }\n        }\n\n        // emit event with the list of bucket indexes updated\n        emit UpdateExchangeRates(msg.sender, pool_, indexes_, updatedRewards_);\n    }\n\n    /**\n     *  @notice Update the exchange rate of a specific bucket.\n     *  @param  pool_        Address of the pool whose exchange rates are being updated.\n     *  @param  bucketIndex_ Bucket index to update exchange rate.\n     *  @param  burnEpoch_   Current burn epoch of the pool.\n     */\n    function _updateBucketExchangeRate(\n        address pool_,\n        uint256 bucketIndex_,\n        uint256 burnEpoch_\n    ) internal {\n        uint256 burnExchangeRate = bucketExchangeRates[pool_][bucketIndex_][burnEpoch_];\n\n        // update bucket exchange rate at epoch only if it wasn't previously updated\n        if (burnExchangeRate == 0) {\n            uint256 curBucketExchangeRate = IPool(pool_).bucketExchangeRate(bucketIndex_);\n\n            // record bucket exchange rate at epoch\n            bucketExchangeRates[pool_][bucketIndex_][burnEpoch_] = curBucketExchangeRate;\n        }\n    }\n\n    /**\n     *  @notice Update the exchange rate of a specific bucket and calculate rewards based on prev exchange rate.\n     *  @param  pool_           Address of the pool whose exchange rates are being updated.\n     *  @param  bucketIndex_    Bucket index to update exchange rate.\n     *  @param  burnEpoch_      Current burn epoch of the pool.\n     *  @param  totalBurned_    Total `Ajna` tokens burned in pool.\n     *  @param  interestEarned_ Total interest rate earned in pool.\n     *  @return rewards_        Rewards for bucket exchange rate update.\n     */\n    function _updateBucketExchangeRateAndCalculateRewards(\n        address pool_,\n        uint256 bucketIndex_,\n        uint256 burnEpoch_,\n        uint256 totalBurned_,\n        uint256 interestEarned_\n    ) internal returns (uint256 rewards_) {\n        uint256 burnExchangeRate = bucketExchangeRates[pool_][bucketIndex_][burnEpoch_];\n\n        // update bucket exchange rate at epoch only if it wasn't previously updated\n        if (burnExchangeRate == 0) {\n            uint256 curBucketExchangeRate = IPool(pool_).bucketExchangeRate(bucketIndex_);\n\n            // record bucket exchange rate at epoch\n            bucketExchangeRates[pool_][bucketIndex_][burnEpoch_] = curBucketExchangeRate;\n\n            // retrieve the bucket exchange rate at the previous epoch\n            uint256 prevBucketExchangeRate = bucketExchangeRates[pool_][bucketIndex_][burnEpoch_ - 1];\n\n            // skip reward calculation if update at the previous epoch was missed and if exchange rate decreased due to bad debt\n            // prevents excess rewards from being provided from using a 0 value as an input to the interestFactor calculation below.\n            if (prevBucketExchangeRate != 0 && prevBucketExchangeRate < curBucketExchangeRate) {\n\n                // retrieve current deposit of the bucket\n                (, , , uint256 bucketDeposit, ) = IPool(pool_).bucketInfo(bucketIndex_);\n\n                uint256 burnFactor     = Maths.wmul(totalBurned_, bucketDeposit);\n                uint256 interestFactor = interestEarned_ == 0 ? 0 : Maths.wdiv(\n                    Maths.WAD - Maths.wdiv(prevBucketExchangeRate, curBucketExchangeRate),\n                    interestEarned_\n                );\n\n                // calculate rewards earned for updating bucket exchange rate \n                rewards_ += Maths.wmul(UPDATE_CLAIM_REWARD, Maths.wmul(burnFactor, interestFactor));\n            }\n        }\n    }\n\n    /** @notice Utility method to transfer `Ajna` rewards to the sender\n     *  @dev   This method is used to transfer rewards to the `msg.sender` after a successful claim or update.\n     *  @dev   It is used to ensure that rewards claimers will be able to claim some portion of the remaining tokens if a claim would exceed the remaining contract balance.\n     *  @param rewardsEarned_ Amount of rewards earned by the caller.\n     */\n    function _transferAjnaRewards(uint256 rewardsEarned_) internal {\n        // check that rewards earned isn't greater than remaining balance\n        // if remaining balance is greater, set to remaining balance\n        uint256 ajnaBalance = IERC20(ajnaToken).balanceOf(address(this));\n        if (rewardsEarned_ > ajnaBalance) rewardsEarned_ = ajnaBalance;\n\n        if (rewardsEarned_ != 0) {\n            // transfer rewards to sender\n            IERC20(ajnaToken).safeTransfer(msg.sender, rewardsEarned_);\n        }\n    }\n\n}"
    },
    {
      "filename": "ajna-core/src/RewardsManager.sol",
      "content": "// SPDX-Lice"
    }
  ]
}