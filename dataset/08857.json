{
  "Title": "[15] `abi.encode()` is less efficient than `abi.encodePacked()`",
  "Content": "\n*There are 3 instances of this issue:*\n\n```solidity\nFile: notional-wrapped-fcash/contracts/proxy/WrappedfCashFactory.sol   #1\n\n23:           return abi.encodePacked(type(nBeaconProxy).creationCode, abi.encode(BEACON, initCallData));\n```\n\n<https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/proxy/WrappedfCashFactory.sol#L23>\n\n```solidity\nFile: notional-wrapped-fcash/contracts/wfCashERC4626.sol   #2\n\n230           bytes memory userData = abi.encode(\n231               RedeemOpts({\n232                   redeemToUnderlying: true,\n233                   transferfCash: false,\n234                   receiver: receiver,\n235                   maxImpliedRate: 0\n236               })\n237:          );\n```\n\n<https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L230-L237>\n\n```solidity\nFile: notional-wrapped-fcash/contracts/wfCashLogic.sol   #3\n\n159:          bytes memory data = abi.encode(opts);\n```\n\n<https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashLogic.sol#L159>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-06-notional-coop",
  "Code": [
    {
      "filename": "notional-wrapped-fcash/contracts/proxy/WrappedfCashFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\nimport \"./nBeaconProxy.sol\";\n\ncontract WrappedfCashFactory {\n\n    /// @dev the Beacon contract here is an UpgradeableBeacon proxy, the contract\n    /// at this address can be upgraded which will upgrade all deployed wrappers.\n    address public immutable BEACON;\n    bytes32 public constant SALT = 0;\n\n    /// @notice Emitted when a new fCash wrapper has been deployed\n    event WrapperDeployed(uint16 currencyId, uint40 maturity, address wrapper);\n\n    constructor(address _beacon) {\n        BEACON = _beacon;\n    }\n\n    function _getByteCode(uint16 currencyId, uint40 maturity) internal view returns (bytes memory) {\n        bytes memory initCallData = abi.encodeWithSignature(\"initialize(uint16,uint40)\", currencyId, maturity);\n        return abi.encodePacked(type(nBeaconProxy).creationCode, abi.encode(BEACON, initCallData));\n    }\n\n    function deployWrapper(uint16 currencyId, uint40 maturity) external returns (address) {\n        address _computedWrapper = computeAddress(currencyId, maturity);\n\n        if (Address.isContract(_computedWrapper)) {\n            // If wrapper has already been deployed then just return it's address\n            return _computedWrapper;\n        } else {\n            address wrapper = Create2.deploy(0, SALT, _getByteCode(currencyId, maturity));\n            emit WrapperDeployed(currencyId, maturity, wrapper);\n            return wrapper;\n        }\n    }\n\n    function computeAddress(uint16 currencyId, uint40 maturity) public view returns (address) {\n        return Create2.computeAddress(SALT, keccak256(_getByteCode(currencyId, maturity)));\n    }\n}"
    },
    {
      "filename": "notional-wrapped-fcash/contracts/wfCashERC4626.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./wfCashLogic.sol\";\nimport \"../interfaces/IERC4626.sol\";\n\ncontract wfCashERC4626 is IERC4626, wfCashLogic {\n    constructor(INotionalV2 _notional, WETH9 _weth) wfCashLogic(_notional, _weth) {}\n\n    /** @dev See {IERC4626-asset} */\n    function asset() public view override returns (address) {\n        (IERC20 underlyingToken, bool isETH) = getToken(true);\n        return isETH ? address(WETH) : address(underlyingToken);\n    }\n\n    function _getMaturedValue() private view returns (uint256) {\n        // If the fCash has matured we use the cash balance instead.\n        uint16 currencyId = getCurrencyId();\n        // We cannot settle an account in a view method, so this may fail if the account has not been settled\n        // after maturity. This can be done by anyone so it should not be an issue\n        (int256 cashBalance, /* */, /* */) = NotionalV2.getAccountBalance(currencyId, address(this));\n        int256 underlyingExternal = NotionalV2.convertCashBalanceToExternal(currencyId, cashBalance, true);\n        require(underlyingExternal > 0, \"Must Settle\");\n\n        return uint256(underlyingExternal);\n    }\n\n    function _getPresentValue(uint256 fCashAmount) private view returns (uint256) {\n        (/* */, int256 precision) = getUnderlyingToken();\n        // Get the present value of the fCash held by the contract, this is returned in 8 decimal precision\n        (uint16 currencyId, uint40 maturity) = getDecodedID();\n        int256 pvInternal = NotionalV2.getPresentfCashValue(\n            currencyId,\n            maturity,\n            int256(fCashAmount), // total supply cannot overflow as fCash overflows at uint88\n            block.timestamp,\n            false\n        );\n\n        int256 pvExternal = (pvInternal * precision) / Constants.INTERNAL_TOKEN_PRECISION;\n        // PV should always be >= 0 since we are lending\n        require(pvExternal >= 0);\n        return uint256(pvExternal);\n    }\n\n    /** @dev See {IERC4626-totalAssets} */\n    function totalAssets() public view override returns (uint256) {\n        return hasMatured() ?  _getMaturedValue() : _getPresentValue(totalSupply());\n    }\n\n    /** @dev See {IERC4626-convertToShares} */\n    function convertToShares(uint256 assets) public view override returns (uint256 shares) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            // Scales assets by the value of a single unit of fCash\n            uint256 unitfCashValue = _getPresentValue(uint256(Constants.INTERNAL_TOKEN_PRECISION));\n            return (assets * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / unitfCashValue;\n        }\n\n        return (assets * totalSupply()) / totalAssets();\n    }\n\n    /** @dev See {IERC4626-convertToAssets} */\n    function convertToAssets(uint256 shares) public view override returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            // Catch the edge case where totalSupply causes a divide by zero error\n            return _getPresentValue(shares);\n        }\n\n        return (shares * totalAssets()) / supply;\n    }\n\n    /** @dev See {IERC4626-maxDeposit} */\n    function maxDeposit(address) public view override returns (uint256) {\n        return hasMatured() ? 0 : type(uint256).max;\n    }\n\n    /** @dev See {IERC4626-maxMint} */\n    function maxMint(address) public view override returns (uint256) {\n        return hasMatured() ? 0 : type(uint88).max;\n    }\n\n    /** @dev See {IERC4626-maxWithdraw} */\n    function maxWithdraw(address owner) public view override returns (uint256) {\n        return previewWithdraw(balanceOf(owner));\n    }\n\n    /** @dev See {IERC4626-maxRedeem} */\n    function maxRedeem(address owner) public view override returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /** @dev See {IERC4626-previewDeposit} */\n    function previewDeposit(uint256 assets) public view override returns (uint256) {\n        if (hasMatured()) {\n            return 0;\n        } else {\n            // This is how much fCash received from depositing assets\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (uint256 fCashAmount, /* */, /* */) = NotionalV2.getfCashLendFromDeposit(\n                currencyId,\n                assets,\n                maturity,\n                0,\n                block.timestamp,\n                true\n            );\n\n            return fCashAmount;\n        }\n    }\n\n    /** @dev See {IERC4626-previewMint} */\n    function previewMint(uint256 shares) public view override returns (uint256) {\n        if (hasMatured()) {\n            return 0;\n        } else {\n            // This is how much fCash received from depositing assets\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (uint256 depositAmountUnderlying, /* */, /* */, /* */) = NotionalV2.getDepositFromfCashLend(\n                currencyId,\n                shares,\n                maturity,\n                0,\n                block.timestamp\n            );\n\n            return depositAmountUnderlying;\n        }\n    }\n\n    /** @dev See {IERC4626-previewWithdraw} */\n    function previewWithdraw(uint256 assets) public view override returns (uint256 shares) {\n        if (hasMatured()) {\n            shares = convertToShares(assets);\n        } else {\n            // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (shares, /* */, /* */) = NotionalV2.getfCashBorrowFromPrincipal(\n                currencyId,\n                assets,\n                maturity,\n                0,\n                block.timestamp,\n                true\n            );\n        }\n    }\n\n    /** @dev See {IERC4626-previewRedeem} */\n    function previewRedeem(uint256 shares) public view override returns (uint256 assets) {\n        if (hasMatured()) {\n            assets = convertToAssets(shares);\n        } else {\n            // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (assets, /* */, /* */, /* */) = NotionalV2.getPrincipalFromfCashBorrow(\n                currencyId,\n                shares,\n                maturity,\n                0,\n                block.timestamp\n            );\n        }\n    }\n\n    /** @dev See {IERC4626-deposit} */\n    function deposit(uint256 assets, address receiver) public override returns (uint256) {\n        uint256 shares = previewDeposit(assets);\n        // Will revert if matured\n        _mintInternal(assets, _safeUint88(shares), receiver, 0, true);\n        emit Deposit(msg.sender, receiver, assets, shares);\n        return shares;\n    }\n\n    /** @dev See {IERC4626-mint} */\n    function mint(uint256 shares, address receiver) public override returns (uint256) {\n        uint256 assets = previewMint(shares);\n        // Will revert if matured\n        _mintInternal(assets, _safeUint88(shares), receiver, 0, true);\n        emit Deposit(msg.sender, receiver, assets, shares);\n        return assets;\n    }\n\n    /** @dev See {IERC4626-withdraw} */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public override returns (uint256) {\n        uint256 shares = previewWithdraw(assets);\n\n        if (msg.sender != owner) {\n            _spendAllowance(owner, msg.sender, shares);\n        }\n        _redeemInternal(shares, receiver, owner);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4626-redeem} */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public override returns (uint256) {\n        // It is more accurate and gas efficient to check the balance of the\n        // receiver here than rely on the previewRedeem method.\n        uint256 balanceBefore = IERC20(asset()).balanceOf(receiver);\n\n        if (msg.sender != owner) {\n            _spendAllowance(owner, msg.sender, shares);\n        }\n        _redeemInternal(shares, receiver, owner);\n\n        uint256 balanceAfter = IERC20(asset()).balanceOf(receiver);\n        uint256 assets = balanceAfter - balanceBefore;\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n        return assets;\n    }\n\n    function _redeemInternal(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) private {\n        bytes memory userData = abi.encode(\n            RedeemOpts({\n                redeemToUnderlying: true,\n                transferfCash: false,\n                receiver: receiver,\n                maxImpliedRate: 0\n            })\n        );\n\n        // No operator data\n        _burn(owner, shares, userData, \"\");\n    }\n\n    function _safeNegInt88(uint256 x) private pure returns (int88) {\n        int256 y = -int256(x);\n        require(int256(type(int88).min) <= y);\n        return int88(y);\n    }\n}"
    },
    {
      "filename": "notional-wrapped-fcash/contracts/wfCashLogic.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\npragma experimental ABIEncoderV2;\n\nimport \"./wfCashBase.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @dev This implementation contract is deployed as an UpgradeableBeacon. Each BeaconProxy\n/// that uses this contract as an implementation will call initialize to set its own fCash id.\n/// That identifier will represent the fCash that this ERC20 wrapper can hold.\nabstract contract wfCashLogic is wfCashBase, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\n    bytes4 internal constant ERC1155_ACCEPTED = 0xf23a6e61;\n    // bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))\n    bytes4 internal constant ERC1155_BATCH_ACCEPTED = 0xbc197c81;\n\n    constructor(INotionalV2 _notional, WETH9 _weth) wfCashBase(_notional, _weth) {}\n\n    /***** Mint Methods *****/\n\n    /// @notice Lends deposit amount in return for fCashAmount using cTokens or aTokens\n    /// @param depositAmountExternal amount of cash to deposit into this method\n    /// @param fCashAmount amount of fCash to purchase (lend)\n    /// @param receiver address to receive the fCash shares\n    /// @param minImpliedRate minimum annualized interest rate to lend at\n    function mintViaAsset(\n        uint256 depositAmountExternal,\n        uint88 fCashAmount,\n        address receiver,\n        uint32 minImpliedRate\n    ) external override {\n        _mintInternal(depositAmountExternal, fCashAmount, receiver, minImpliedRate, false);\n    }\n\n    /// @notice Lends deposit amount in return for fCashAmount using underlying tokens\n    /// @param depositAmountExternal amount of cash to deposit into this method\n    /// @param fCashAmount amount of fCash to purchase (lend)\n    /// @param receiver address to receive the fCash shares\n    /// @param minImpliedRate minimum annualized interest rate to lend at\n    function mintViaUnderlying(\n        uint256 depositAmountExternal,\n        uint88 fCashAmount,\n        address receiver,\n        uint32 minImpliedRate\n    ) external override {\n        _mintInternal(depositAmountExternal, fCashAmount, receiver, minImpliedRate, true);\n    }\n\n    function _mintInternal(\n        uint256 depositAmountExternal,\n        uint88 fCashAmount,\n        address receiver,\n        uint32 minImpliedRate,\n        bool useUnderlying\n    ) internal nonReentrant {\n        require(!hasMatured(), \"fCash matured\");\n        (IERC20 token, bool isETH) = getToken(useUnderlying);\n        uint256 balanceBefore = isETH ? address(this).balance : token.balanceOf(address(this));\n\n        // If dealing in ETH, we use WETH in the wrapper instead of ETH. NotionalV2 uses\n        // ETH natively but due to pull payment requirements for batchLend, it does not support\n        // ETH. batchLend only supports ERC20 tokens like cETH or aETH. Since the wrapper is a compatibility\n        // layer, it will support WETH so integrators can deal solely in ERC20 tokens. Instead of using\n        // \"batchLend\" we will use \"batchBalanceActionWithTrades\". The difference is that \"batchLend\"\n        // is more gas efficient (does not require and additional redeem call to asset tokens). If using cETH\n        // then everything will proceed via batchLend.\n        if (isETH) {\n            IERC20((address(WETH))).safeTransferFrom(msg.sender, address(this), depositAmountExternal);\n            WETH.withdraw(depositAmountExternal);\n\n            BalanceActionWithTrades[] memory action = EncodeDecode.encodeLendETHTrade(\n                getCurrencyId(),\n                getMarketIndex(),\n                depositAmountExternal,\n                fCashAmount,\n                minImpliedRate\n            );\n            // Notional will return any residual ETH as the native token. When we _sendTokensToReceiver those\n            // native ETH tokens will be wrapped back to WETH.\n            NotionalV2.batchBalanceAndTradeAction{value: depositAmountExternal}(address(this), action);\n        } else {\n            // Transfers tokens in for lending, Notional will transfer from this contract.\n            token.safeTransferFrom(msg.sender, address(this), depositAmountExternal);\n\n            // Executes a lending action on Notional\n            BatchLend[] memory action = EncodeDecode.encodeLendTrade(\n                getCurrencyId(),\n                getMarketIndex(),\n                fCashAmount,\n                minImpliedRate,\n                useUnderlying\n            );\n            NotionalV2.batchLend(address(this), action);\n        }\n\n        // Mints ERC20 tokens for the receiver, the false flag denotes that we will not do an\n        // operatorAck\n        _mint(receiver, fCashAmount, \"\", \"\", false);\n\n        _sendTokensToReceiver(token, msg.sender, isETH, balanceBefore);\n    }\n\n    /// @notice This hook will be called every time this contract receives fCash, will validate that\n    /// this is the correct fCash and then mint the corresponding amount of wrapped fCash tokens\n    /// back to the user.\n    function onERC1155Received(\n        address _operator,\n        address _from,\n        uint256 _id,\n        uint256 _value,\n        bytes calldata _data\n    ) external nonReentrant returns (bytes4) {\n        uint256 fCashID = getfCashId();\n        // Only accept erc1155 transfers from NotionalV2\n        require(\n            msg.sender == address(NotionalV2) &&\n            // Only accept the fcash id that corresponds to the listed currency and maturity\n            _id == fCashID &&\n            // Protect against signed value underflows\n            int256(_value) > 0,\n            \"Invalid\"\n        );\n\n        // Double check the account's position, these are not strictly necessary and add gas costs\n        // but might be good safe guards\n        AccountContext memory ac = NotionalV2.getAccountContext(address(this));\n        PortfolioAsset[] memory assets = NotionalV2.getAccountPortfolio(address(this));\n        require(\n            ac.hasDebt == 0x00 &&\n            assets.length == 1 &&\n            EncodeDecode.encodeERC1155Id(\n                assets[0].currencyId,\n                assets[0].maturity,\n                assets[0].assetType\n            ) == fCashID\n        );\n\n        // Update per account fCash balance, calldata from the ERC1155 call is\n        // passed via the ERC777 interface.\n        bytes memory userData;\n        bytes memory operatorData;\n        if (_operator == _from) userData = _data;\n        else operatorData = _data;\n\n        // We don't require a recipient ack here to maintain compatibility\n        // with contracts that don't support ERC777\n        _mint(_from, _value, userData, operatorData, false);\n\n        // This will allow the fCash to be accepted\n        return ERC1155_ACCEPTED;\n    }\n\n    /***** Redeem (Burn) Methods *****/\n\n    /// @notice Redeems tokens using custom options\n    /// @dev re-entrancy is protected on _burn\n    function redeem(uint256 amount, RedeemOpts memory opts) public override {\n        bytes memory data = abi.encode(opts);\n        // In this case, the owner is msg.sender based on the OZ ERC777 implementation\n        burn(amount, data);\n    }\n\n    /// @notice Redeems tokens to asset tokens\n    /// @dev re-entrancy is protected on _burn\n    function redeemToAsset(\n        uint256 amount,\n        address receiver,\n        uint32 maxImpliedRate\n    ) external override {\n        redeem(\n            amount,\n            RedeemOpts({\n                redeemToUnderlying: false,\n                transferfCash: false,\n                receiver: receiver,\n                maxImpliedRate: maxImpliedRate\n            })\n        );\n    }\n\n    /// @notice Redeems tokens to underlying\n    /// @dev re-entrancy is protected on _burn\n    function redeemToUnderlying(\n        uint256 amount,\n        address receiver,\n        uint32 maxImpliedRate\n    ) external override {\n        redeem(\n            amount,\n            RedeemOpts({\n                redeemToUnderlying: true,\n                transferfCash: false,\n                receiver: receiver,\n                maxImpliedRate: maxImpliedRate\n            })\n        );\n    }\n\n    /// @notice Called before tokens are burned (redemption) and so we will handle\n    /// the fCash properly before and after maturity.\n    function _burn(\n        address from,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    ) internal override nonReentrant {\n        // Save the total supply value before burning to calculate the cash claim share\n        uint256 initialTotalSupply = totalSupply();\n        RedeemOpts memory opts = abi.decode(userData, (RedeemOpts));\n        require(opts.receiver != address(0), \"Receiver is zero address\");\n        // This will validate that the account has sufficient tokens to burn and make\n        // any relevant underlying stateful changes to balances.\n        super._burn(from, amount, userData, operatorData);\n\n        if (hasMatured()) {\n            // If the fCash has matured, then we need to ensure that the account is settled\n            // and then we will transfer back the account's share of asset tokens.\n\n            // This is a noop if the account is already settled\n            NotionalV2.settleAccount(address(this));\n            uint16 currencyId = getCurrencyId();\n\n            (int256 cashBalance, /* */, /* */) = NotionalV2.getAccountBalance(currencyId, address(this));\n            require(0 < cashBalance, \"Negative Cash Balance\");\n\n            // This always rounds down in favor of the wrapped fCash contract.\n            uint256 assetInternalCashClaim = (uint256(cashBalance) * amount) / initialTotalSupply;\n\n            // Transfer withdrawn tokens to the `from` address\n            _withdrawCashToAccount(\n                currencyId,\n                opts.receiver,\n                _safeUint88(assetInternalCashClaim),\n                opts.redeemToUnderlying\n            );\n        } else if (opts.transferfCash) {\n            // If the fCash has not matured, then we can transfer it via ERC1155.\n            // NOTE: this may fail if the destination is a contract and it does not implement \n            // the `onERC1155Received` hook. If that is the case it is possible to use a regular\n            // ERC20 transfer on this contract instead.\n            NotionalV2.safeTransferFrom(\n                address(this), // Sending from this contract\n                opts.receiver, // Where to send the fCash\n                getfCashId(), // fCash identifier\n                amount, // Amount of fCash to send\n                userData\n            );\n        } else {\n            _sellfCash(\n                opts.receiver,\n                amount,\n                opts.redeemToUnderlying,\n                opts.maxImpliedRate\n            );\n        }\n    }\n\n    /// @notice After maturity, withdraw cash back to account\n    function _withdrawCashToAccount(\n        uint16 currencyId,\n        address receiver,\n        uint88 assetInternalCashClaim,\n        bool toUnderlying\n    ) private returns (uint256 tokensTransferred) {\n        (IERC20 token, bool isETH) = getToken(toUnderlying);\n        uint256 balanceBefore = isETH ? address(this).balance : token.balanceOf(address(this));\n\n        NotionalV2.withdraw(currencyId, assetInternalCashClaim, toUnderlying);\n\n        tokensTransferred = _sendTokensToReceiver(token, receiver, isETH, balanceBefore);\n    }\n\n    /// @dev Sells an fCash share back on the Notional AMM\n    function _sellfCash(\n        address receiver,\n        uint256 fCashToSell,\n        bool toUnderlying,\n        uint32 maxImpliedRate\n    ) private returns (uint256 tokensTransferred) {\n        (IERC20 token, bool isETH) = getToken(toUnderlying);\n        uint256 balanceBefore = isETH ? address(this).balance : token.balanceOf(address(this));\n\n        // Sells fCash on Notional AMM (via borrowing)\n        BalanceActionWithTrades[] memory action = EncodeDecode.encodeBorrowTrade(\n            getCurrencyId(),\n            getMarketIndex(),\n            _safeUint88(fCashToSell),\n            maxImpliedRate,\n            toUnderlying\n        );\n        NotionalV2.batchBalanceAndTradeAction(address(this), action);\n\n        // Send borrowed cash back to receiver\n        tokensTransferred = _sendTokensToReceiver(token, receiver, isETH, balanceBefore);\n    }\n\n    function _sendTokensToReceiver(\n        IERC20 token,\n        address receiver,\n        bool isETH,\n        uint256 balanceBefore\n    ) private returns (uint256 tokensTransferred) {\n        uint256 balanceAfter = isETH ? address(this).balance : token.balanceOf(address(this));\n        tokensTransferred = balanceAfter - balanceBefore;\n\n        if (isETH) {\n            WETH.deposit{value: tokensTransferred}();\n            IERC20(address(WETH)).safeTransfer(receiver, tokensTransferred);\n        } else {\n            token.safeTransfer(receiver, tokensTransferred);\n        }\n    }\n\n    function _safeUint88(uint256 x) internal pure returns (uint88) {\n        require(x <= uint256(type(uint88).max));\n        return uint88(x);\n    }\n}"
    }
  ]
}