{
  "Title": "[M-08] Mistakenly sent eth could be locked",
  "Content": "# Lines of code\n\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineLib.sol#L59-L74\n\n\n# Vulnerability details\n\n## Impact\n\nIf ERC20 and eth are transferred at same time, the mistakenly sent eth will be locked.\nThere are several functions could be affected and cause user fund lock:\n- `addCollateral()`\n- `addCredit()`\n- `increaseCredit()`\n- `depositAndClose()`\n- `depositAndRepay()`\n- `close()`\n\n## Proof of Concept\n\nIn `receiveTokenOrETH()`, different logic is used to handle ERC20 and eth transfer. However, in the ERC20 if block, mistakenly sent eth will be ignored. This part of eth will be locked in the contract.\n```solidity\n// Line-of-Credit/contracts/utils/LineLib.sol\n    function receiveTokenOrETH(\n      address token,\n      address sender,\n      uint256 amount\n    )\n      external\n      returns (bool)\n    {\n        if(token == address(0)) { revert TransferFailed(); }\n        if(token != Denominations.ETH) { // ERC20\n            IERC20(token).safeTransferFrom(sender, address(this), amount);\n        } else { // ETH\n            if(msg.value < amount) { revert TransferFailed(); }\n        }\n        return true;\n    }\n```\n\n\n## Tools Used\nManual analysis.\n\n## Recommended Mitigation Steps\n\nIn the ERC20 part, add check for `msg.value` to ensure no eth is sent:\n```solidity\n        if(token != Denominations.ETH) { // ERC20\n            if (msg.value > 0) { revert TransferFailed(); }\n            IERC20(token).safeTransferFrom(sender, address(this), amount);\n        } else { // ETH\n```\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-debt-dao-contest",
  "Code": [
    {
      "filename": "contracts/utils/LineLib.sol",
      "content": "pragma solidity 0.8.9;\nimport { IInterestRateCredit } from \"../interfaces/IInterestRateCredit.sol\";\nimport { ILineOfCredit } from \"../interfaces/ILineOfCredit.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { IERC20 } from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20}  from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport { Denominations } from \"chainlink/Denominations.sol\";\n\n/**\n  * @title Debt DAO Line of Credit Library\n  * @author Kiba Gateaux\n  * @notice Core logic and variables to be reused across all Debt DAO Marketplace Line of Credit contracts\n */\nlibrary LineLib {\n    using SafeERC20 for IERC20;\n\n    error TransferFailed();\n    error BadToken();\n\n    enum STATUS {\n        UNINITIALIZED,\n        ACTIVE,\n        LIQUIDATABLE,\n        REPAID,\n        INSOLVENT\n    }\n\n    /**\n     * @notice - Send ETH or ERC20 token from this contract to an external contract\n     * @param token - address of token to send out. Denominations.ETH for raw ETH\n     * @param receiver - address to send tokens to\n     * @param amount - amount of tokens to send\n     */\n    function sendOutTokenOrETH(\n      address token,\n      address receiver,\n      uint256 amount\n    )\n      external\n      returns (bool)\n    {\n        if(token == address(0)) { revert TransferFailed(); }\n        \n        // both branches revert if call failed\n        if(token!= Denominations.ETH) { // ERC20\n            IERC20(token).safeTransfer(receiver, amount);\n        } else { // ETH\n            payable(receiver).transfer(amount);\n        }\n        return true;\n    }\n\n    /**\n     * @notice - Receive ETH or ERC20 token at this contract from an external contract\n     * @param token - address of token to receive. Denominations.ETH for raw ETH\n     * @param sender - address that is sendingtokens/ETH\n     * @param amount - amount of tokens to send\n     */\n    function receiveTokenOrETH(\n      address token,\n      address sender,\n      uint256 amount\n    )\n      external\n      returns (bool)\n    {\n        if(token == address(0)) { revert TransferFailed(); }\n        if(token != Denominations.ETH) { // ERC20\n            IERC20(token).safeTransferFrom(sender, address(this), amount);\n        } else { // ETH\n            if(msg.value < amount) { revert TransferFailed(); }\n        }\n        return true;\n    }\n\n    /**\n     * @notice - Helper function to get current balance of this contract for ERC20 or ETH\n     * @param token - address of token to check. Denominations.ETH for raw ETH\n    */\n    function getBalance(address token) external view returns (uint256) {\n        if(token == address(0)) return 0;\n        return token != Denominations.ETH ?\n            IERC20(token).balanceOf(address(this)) :\n            address(this).balance;\n    }\n\n}"
    }
  ]
}