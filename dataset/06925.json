{
  "Title": "[M-04] Time-sensitive contracts deployed on zkSync",
  "Content": "\nTime-sensitive contracts will be impacted if deployed on zkSync.\n\n### Proof of Concept\n\nMany contracts use `block.number` to measure the time as the miners were able to manipulate the `timestamp` (the `timestamp` could be easily gamed over short intervals). So, it was assumed that `block.number` is a safer and more accurate source of measuring time than `timestamp`.\n\nFor instance, if a defi project sets 144000 block interval to release the interest, it means approximately `144000 * 12 = 20 days`. Please note that each block in Ethereum takes almost 12 second.\n\nIf the same defi project is deployed on zkSync, it will not operate as expected. Because there is no time-bound for the blocks in zkSync (the interval may be 30 seconds or 1 week). So, the time to release the interest can be between 50 days to 2762 days.\n\nSince, it is assumed that zkSync is Ethereum compatible, any deployed contracts on Ethereum may deploy their contract in zkSync without noting such big difference.\n\nEven if the contracts use `timestamp` to measure the time, there will be another issue. In the contract `SystemContext.sol`, it is possible to set new block with the same `timestamp` as previous block, but with incremented block number.<br>\n<https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/SystemContext.sol#L116>\n\nIn other words, new blocks are created but their time is frozen. Please note that freezing time can not be lasted for a long time, because when committing block their `timestamp` will be validated against a defined boundary.\n\n### Recommended Mitigation Steps\n\nIt should be explicitly mentioned that block intervals in zkSync are not compatible with Ethereum. So, time-sensitive contracts will be noted.\n\nMoreover, the equal sign should be removed in the following line:<br>\n<https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/SystemContext.sol#L116>\n\n**[miladpiri (zkSync) confirmed and commented](https://github.com/code-423n4/2023-03-zksync-findings/issues/70#issuecomment-1485041741):**\n > Two issues are stated:\n> 1. Block timestamp issue (which is duplicate of some other reports). dup [#31](https://github.com/code-423n4/2023-03-zksync-findings/issues/31) (**Low**)\n> 2. Block creation rate is not consistent with Ethereum. (not duplicate) (**Medium**)\n> \n> The judges can decide better how to distinguish them.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-03-zksync-findings/issues/70#issuecomment-1497377066):**\n > The warden has shown how the zkEVM could differ from the EVM in how block timing is enforced, because blocks can happen at inconsistent times, protocols contract could have their time assumptions broken.\n> \n> Because this is a finding that has been addressed by other L2s, and causes inconsistent behaviour vs the EVM, I agree with Medium Severity.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-03-zksync",
  "Code": [
    {
      "filename": "contracts/SystemContext.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {ISystemContext} from \"./interfaces/ISystemContext.sol\";\nimport {SystemContractHelper} from \"./libraries/SystemContractHelper.sol\";\nimport {BOOTLOADER_FORMAL_ADDRESS} from \"./Constants.sol\";\n\n/**\n * @author Matter Labs\n * @notice Contract that stores some of the context variables, that may be either\n * block-scoped, tx-scoped or system-wide.\n */\ncontract SystemContext is ISystemContext {\n    modifier onlyBootloader() {\n        require(msg.sender == BOOTLOADER_FORMAL_ADDRESS);\n        _;\n    }\n\n    /// @notice The chainId of the network. It is set at the genesis.\n    uint256 public chainId;\n\n    /// @notice The `tx.origin` in the current transaction.\n    /// @dev It is updated before each transaction by the bootloader\n    address public origin;\n\n    /// @notice The `tx.gasPrice` in the current transaction.\n    /// @dev It is updated before each transaction by the bootloader\n    uint256 public gasPrice;\n\n    /// @notice The current block's gasLimit (gasLimit in Ethereum terms).\n    /// @dev Currently set to some dummy value, it will be changed closer to mainnet.\n    uint256 public blockGasLimit = (1 << 30);\n\n    /// @notice The `block.coinbase` in the current transaction.\n    /// @dev For the support of coinbase, we will the bootloader formal address for now\n    address public coinbase = BOOTLOADER_FORMAL_ADDRESS;\n\n    /// @notice Formal `block.difficulty` parameter.\n    uint256 public difficulty = 2500000000000000;\n\n    /// @notice The `block.basefee`.\n    /// @dev It is currently a constant.\n    uint256 public baseFee;\n\n    /// @notice The coefficient with which the current block's number\n    /// is stored in the current block info\n    uint256 constant BLOCK_INFO_BLOCK_NUMBER_PART = 2 ** 128;\n\n    /// @notice block.number and block.timestamp stored packed.\n    /// @dev It is equal to 2^128 * block_number + block_timestamp.\n    uint256 public currentBlockInfo;\n\n    /// @notice The hashes of blocks.\n    /// @dev It stores block hashes for all previous blocks.\n    mapping(uint256 => bytes32) public blockHash;\n\n    /// @notice Set the current tx origin.\n    /// @param _newOrigin The new tx origin.\n    function setTxOrigin(address _newOrigin) external onlyBootloader {\n        origin = _newOrigin;\n    }\n\n    /// @notice Set the current tx origin.\n    /// @param _gasPrice The new tx gasPrice.\n    function setGasPrice(uint256 _gasPrice) external onlyBootloader {\n        gasPrice = _gasPrice;\n    }\n\n    /// @notice The method that emulates `blockhash` opcode in EVM.\n    /// @dev Just like the blockhash in the EVM, it returns bytes32(0), when\n    /// when queried about hashes that are older than 256 blocks ago.\n    function getBlockHashEVM(uint256 _block) external view returns (bytes32 hash) {\n        if (block.number < _block || block.number - _block > 256) {\n            hash = bytes32(0);\n        } else {\n            hash = blockHash[_block];\n        }\n    }\n\n    /// @notice Returns the current blocks' number and timestamp.\n    /// @return blockNumber and blockTimestamp tuple of the current block's number and the current block's timestamp\n    function getBlockNumberAndTimestamp() public view returns (uint256 blockNumber, uint256 blockTimestamp) {\n        uint256 blockInfo = currentBlockInfo;\n        blockNumber = blockInfo / BLOCK_INFO_BLOCK_NUMBER_PART;\n        blockTimestamp = blockInfo % BLOCK_INFO_BLOCK_NUMBER_PART;\n    }\n\n    /// @notice Returns the current block's number.\n    /// @return blockNumber The current block's number.\n    function getBlockNumber() public view returns (uint256 blockNumber) {\n        (blockNumber, ) = getBlockNumberAndTimestamp();\n    }\n\n    /// @notice Returns the current block's timestamp.\n    /// @return timestamp The current block's timestamp.\n    function getBlockTimestamp() public view returns (uint256 timestamp) {\n        (, timestamp) = getBlockNumberAndTimestamp();\n    }\n\n    /// @notice Increments the current block number and sets the new timestamp\n    /// @dev Called by the bootloader at the start of the block.\n    /// @param _prevBlockHash The hash of the previous block.\n    /// @param _newTimestamp The timestamp of the new block.\n    /// @param _expectedNewNumber The new block's number\n    /// @dev Whie _expectedNewNumber can be derived as prevBlockNumber + 1, we still\n    /// manually supply it here for consistency checks.\n    /// @dev The correctness of the _prevBlockHash and _newTimestamp should be enforced on L1.\n    function setNewBlock(\n        bytes32 _prevBlockHash,\n        uint256 _newTimestamp,\n        uint256 _expectedNewNumber,\n        uint256 _baseFee\n    ) external onlyBootloader {\n        (uint256 currentBlockNumber, uint256 currentBlockTimestamp) = getBlockNumberAndTimestamp();\n        require(_newTimestamp >= currentBlockTimestamp, \"Timestamps should be incremental\");\n        require(currentBlockNumber + 1 == _expectedNewNumber, \"The provided block number is not correct\");\n\n        blockHash[currentBlockNumber] = _prevBlockHash;\n\n        // Setting new block number and timestamp\n        currentBlockInfo = (currentBlockNumber + 1) * BLOCK_INFO_BLOCK_NUMBER_PART + _newTimestamp;\n\n        baseFee = _baseFee;\n\n        // The correctness of this block hash and the timestamp will be checked on L1:\n        SystemContractHelper.toL1(false, bytes32(_newTimestamp), _prevBlockHash);\n    }\n\n    /// @notice A testing method that manually sets the current blocks' number and timestamp.\n    /// @dev Should be used only for testing / ethCalls and should never be used in production.\n    function unsafeOverrideBlock(uint256 _newTimestamp, uint256 number, uint256 _baseFee) external onlyBootloader {\n        currentBlockInfo = (number) * BLOCK_INFO_BLOCK_NUMBER_PART + _newTimestamp;\n        baseFee = _baseFee;\n    }\n}"
    },
    {
      "filename": "contracts/SystemContext.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {ISystemContext} from \"./interfaces/ISystemContext.sol\";\nimport {SystemContractHelper} from \"./libraries/SystemContractHelper.sol\";\nimport {BOOTLOADER_FORMAL_ADDRESS} from \"./Constants.sol\";\n\n/**\n * @author Matter Labs\n * @notice Contract that stores some of the context variables, that may be either\n * block-scoped, tx-scoped or system-wide.\n */\ncontract SystemContext is ISystemContext {\n    modifier onlyBootloader() {\n        require(msg.sender == BOOTLOADER_FORMAL_ADDRESS);\n        _;\n    }\n\n    /// @notice The chainId of the network. It is set at the genesis.\n    uint256 public chainId;\n\n    /// @notice The `tx.origin` in the current transaction.\n    /// @dev It is updated before each transaction by the bootloader\n    address public origin;\n\n    /// @notice The `tx.gasPrice` in the current transaction.\n    /// @dev It is updated before each transaction by the bootloader\n    uint256 public gasPrice;\n\n    /// @notice The current block's gasLimit (gasLimit in Ethereum terms).\n    /// @dev Currently set to some dummy value, it will be changed closer to mainnet.\n    uint256 public blockGasLimit = (1 << 30);\n\n    /// @notice The `block.coinbase` in the current transaction.\n    /// @dev For the support of coinbase, we will the bootloader formal address for now\n    address public coinbase = BOOTLOADER_FORMAL_ADDRESS;\n\n    /// @notice Formal `block.difficulty` parameter.\n    uint256 public difficulty = 2500000000000000;\n\n    /// @notice The `block.basefee`.\n    /// @dev It is currently a constant.\n    uint256 public baseFee;\n\n    /// @notice The coefficient with which the current block's number\n    /// is stored in the current block info\n    uint256 constant BLOCK_INFO_BLOCK_NUMBER_PART = 2 ** 128;\n\n    /// @notice block.number and block.timestamp stored packed.\n    /// @dev It is equal to 2^128 * block_number + block_timestamp.\n    uint256 public currentBlockInfo;\n\n    /// @notice The hashes of blocks.\n    /// @dev It stores block hashes for all previous blocks.\n    mapping(uint256 => bytes32) public blockHash;\n\n    /// @notice Set the current tx origin.\n    /// @param _newOrigin The new tx origin.\n    function setTxOrigin(address _newOrigin) external onlyBootloader {\n        origin = _newOrigin;\n    }\n\n    /// @notice Set the current tx origin.\n    /// @param _gasPrice The new tx gasPrice.\n    function setGasPrice(uint256 _gasPrice) external onlyBootloader {\n        gasPrice = _gasPrice;\n    }\n\n    /// @notice The method that emulates `blockhash` opcode in EVM.\n    /// @dev Just like the blockhash in the EVM, it returns bytes32(0), when\n    /// when queried about hashes that are older than 256 blocks ago.\n    function getBlockHashEVM(uint256 _block) external view returns (bytes32 hash) {\n        if (block.number < _block || block.number - _block > 256) {\n            hash = bytes32(0);\n        } else {\n            hash = blockHash[_block];\n        }\n    }\n\n    /// @notice Returns the current blocks' number and timestamp.\n    /// @return blockNumber and blockTimestamp tuple of the current block's number and the current block's timestamp\n    function getBlockNumberAndTimestamp() public view returns (uint256 blockNumber, uint256 blockTimestamp) {\n        uint256 blockInfo = currentBlockInfo;\n        blockNumber = blockInfo / BLOCK_INFO_BLOCK_NUMBER_PART;\n        blockTimestamp = blockInfo % BLOCK_INFO_BLOCK_NUMBER_PART;\n    }\n\n    /// @notice Returns the current block's number.\n    /// @return blockNumber The current block's number.\n    function getBlockNumber() public view returns (uint256 blockNumber) {\n        (blockNumber, ) = getBlockNumberAndTimestamp();\n    }\n\n    /// @notice Returns the current block's timestamp.\n    /// @return timestamp The current block's timestamp.\n    function getBlockTimestamp() public view returns (uint256 timestamp) {\n        (, timestamp) = getBlockNumberAndTimestamp();\n    }\n\n    /// @notice Increments the current block number and sets the new timestamp\n    /// @dev Called by the bootloader at the start of the block.\n    /// @param _prevBlockHash The hash of the previous block.\n    /// @param _newTimestamp The timestamp of the new block.\n    /// @param _expectedNewNumber The new block's number\n    /// @dev Whie _expectedNewNumber can be derived as prevBlockNumber + 1, we still\n    /// manually supply it here for consistency checks.\n    /// @dev The correctness of the _prevBlockHash and _newTimestamp should be enforced on L1.\n    function setNewBlock(\n        bytes32 _prevBlockHash,\n        uint256 _newTimestamp,\n        uint256 _expectedNewNumber,\n        uint256 _baseFee\n    ) external onlyBootloader {\n        (uint256 currentBlockNumber, uint256 currentBlockTimestamp) = getBlockNumberAndTimestamp();\n        require(_newTimestamp >= currentBlockTimestamp, \"Timestamps should be incremental\");\n        require(currentBlockNumber + 1 == _expectedNewNumber, \"The provided block number is not correct\");\n\n        blockHash[currentBlockNumber] = _prevBlockHash;\n\n        // Setting new block number and timestamp\n        currentBlockInfo = (currentBlockNumber + 1) * BLOCK_INFO_BLOCK_NUMBER_PART + _newTimestamp;\n\n        baseFee = _baseFee;\n\n        // The correctness of this block hash and the timestamp will be checked on L1:\n        SystemContractHelper.toL1(false, bytes32(_newTimestamp), _prevBlockHash);\n    }\n\n    /// @notice A testing method that manually sets the current blocks' number and timestamp.\n    /// @dev Should be used only for testing / ethCalls and should never be used in production.\n    function unsafeOverrideBlock(uint256 _newTimestamp, uint256 number, uint256 _baseFee) external onlyBootloader {\n        currentBlockInfo = (number) * BLOCK_INFO_BLOCK_NUMBER_PART + _newTimestamp;\n        baseFee = _baseFee;\n    }\n}"
    }
  ]
}