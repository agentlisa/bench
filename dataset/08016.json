{
  "Title": "[M-10] StakingRewards.sol#notifyRewardAmount() Improper reward balance checks can make some users unable to withdraw their rewards",
  "Content": "\nSimilar to <https://github.com/code-423n4/2022-02-concur-findings/issues/209>\n\n            uint256 balance = rewardsToken.balanceOf(address(this));\n            require(\n                rewardRate <= balance.div(rewardsDuration),\n                \"Provided reward too high\"\n            );\n\nIn the current implementation, the contract only checks if balanceOf rewardsToken is greater than or equal to the future rewards.\n\nHowever, under normal circumstances, since users can not withdraw all their rewards in time, the balance in the contract contains rewards that belong to the users but have not been withdrawn yet. This means the current checks can not be sufficient enough to make sure the contract has enough amount of rewardsToken.\n\nAs a result, if the rewardsDistribution mistakenly notifyRewardAmount with a larger amount, the contract may end up in a wrong state that makes some users unable to claim their rewards.\n\nGiven:\n\n*   rewardsDuration = 7 days;\n\n1.  Alice stakes 1,000 stakingToken;\n2.  rewardsDistribution sends 100 rewardsToken to the contract;\n3.  rewardsDistribution calls `notifyRewardAmount()` with amount = 100;\n4.  7 days later, Alice calls `earned()` and it returns 100 rewardsToken, but Alice choose not to `getReward()` for now;\n5.  rewardsDistribution calls `notifyRewardAmount()` with amount = 100 without send any fund to contract, the tx will succeed;\n6.  7 days later, Alice calls `earned()` 200 rewardsToken, when Alice tries to call `getReward()`, the transaction will fail due to insufficient balance of rewardsToken.\n\nExpected Results:\n\nThe tx in step 5 should revert.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/ac3e86f07bc2f1f51148d2265cc897e8b494adf7/src/rewards/StakingRewards.sol#L201-L205>\n\n### Recommended Mitigation Steps\n\nConsider changing the function notifyRewardAmount to addRward and use transferFrom to transfer rewardsToken into the contract:\n\n    function addRward(uint256 reward)\n        external\n        updateReward(address(0))\n    {\n        require(\n            msg.sender == rewardsDistribution,\n            \"Caller is not RewardsDistribution contract\"\n        );\n\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward / rewardsDuration;\n        } else {\n            uint256 remaining = periodFinish - block.timestamp;\n            uint256 leftover = remaining * rewardRate;\n            rewardRate = (reward + leftover) / rewardsDuration;\n        }\n\n        rewardsToken.safeTransferFrom(msg.sender, address(this), reward);\n\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp + rewardsDuration;\n        emit RewardAdded(reward);\n    }\n\n**[MiguelBits (Y2K Finance) disputed](https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/50)** \n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-09-y2k-finance-contest",
  "Code": [
    {
      "filename": "src/rewards/StakingRewards.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {SafeTransferLib} from \"@solmate/utils/SafeTransferLib.sol\";\nimport {\n    ReentrancyGuard\n} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n// Inheritance\nimport {IStakingRewards} from \"./IStakingRewards.sol\";\nimport {RewardsDistributionRecipient} from \"./RewardsDistributionRecipient.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {\n    ERC1155Holder\n} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {ERC20} from \"@solmate/tokens/ERC20.sol\";\nimport \"./Owned.sol\";\n\n// https://docs.synthetix.io/contracts/source/contracts/stakingrewards\ncontract StakingRewards is\n    IStakingRewards,\n    RewardsDistributionRecipient,\n    ReentrancyGuard,\n    Pausable,\n    ERC1155Holder\n{\n    using SafeMath for uint256;\n    using SafeTransferLib for ERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    ERC20 public immutable rewardsToken;\n    IERC1155 public immutable stakingToken;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate;\n    uint256 public rewardsDuration;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    uint256 public id;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    /* ========== EVENTS ========== */\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 id, uint256 amount);\n    event Withdrawn(address indexed user, uint256 id, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event RewardsDurationUpdated(uint256 newDuration);\n    event Recovered(address token, uint256 amount);\n\n    /* ========== MODIFIERS ========== */\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _owner,\n        address _rewardsDistribution,\n        address _rewardsToken,\n        address _stakingToken,\n        uint256 _epochEnd,\n        uint256 _rewardsDuration,\n        uint256 _rewardRate\n    ) Owned(_owner) {\n        rewardsToken = ERC20(_rewardsToken);\n        stakingToken = IERC1155(_stakingToken);\n        rewardsDistribution = _rewardsDistribution;\n        id = _epochEnd;\n        rewardsDuration = _rewardsDuration;\n        rewardRate = _rewardRate;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n    function stake(uint256 amount)\n        external\n        nonReentrant\n        whenNotPaused\n        updateReward(msg.sender)\n    {\n        require(amount != 0, \"Cannot stake 0\");\n        _totalSupply = _totalSupply.add(amount);\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        stakingToken.safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            amount,\n            \"\"\n        );\n        emit Staked(msg.sender, id, amount);\n    }\n\n    function exit() external {\n        withdraw(_balances[msg.sender]);\n        getReward();\n    }\n\n    function withdraw(uint256 amount)\n        public\n        nonReentrant\n        updateReward(msg.sender)\n    {\n        require(amount > 0, \"Cannot withdraw 0\");\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        stakingToken.safeTransferFrom(\n            address(this),\n            msg.sender,\n            id,\n            amount,\n            \"\"\n        );\n        emit Withdrawn(msg.sender, id, amount);\n    }\n\n    function getReward() public nonReentrant updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardsToken.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate.mul(rewardsDuration);\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return block.timestamp < periodFinish ? block.timestamp : periodFinish;\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e18)\n                    .div(_totalSupply)\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            _balances[account]\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function notifyRewardAmount(uint256 reward)\n        external\n        override\n        onlyRewardsDistribution\n        updateReward(address(0))\n    {\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(rewardsDuration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n        }\n\n        // Ensure the provided reward amount is not more than the balance in the contract.\n        // This keeps the reward rate in the right range, preventing overflows due to\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n        uint256 balance = rewardsToken.balanceOf(address(this));\n        require(\n            rewardRate <= balance.div(rewardsDuration),\n            \"Provided reward too high\"\n        );\n\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(rewardsDuration);\n        emit RewardAdded(reward);\n    }\n\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address tokenAddress, uint256 tokenAmount)\n        external\n        onlyOwner\n    {\n        require(\n            tokenAddress != address(stakingToken),\n            \"Cannot withdraw the staking token\"\n        );\n        ERC20(tokenAddress).safeTransfer(owner, tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n\n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n        require(\n            block.timestamp > periodFinish,\n            \"Previous rewards period must be complete before changing the duration for the new period\"\n        );\n        rewardsDuration = _rewardsDuration;\n        emit RewardsDurationUpdated(rewardsDuration);\n    }\n}"
    }
  ]
}