{
  "Title": "[M-09] Unhealthy troves with LTV > 90% cannot always be absorbed as intended",
  "Content": "\nUnhealthy troves with `ltv > 90%` and `threshold < 90%` cannot always be absorbed due to a wrong if-condition. According to [Priority of liquidation methods](https://demo-35.gitbook.io/untitled/smart-contracts/purger-module#description-of-key-functions) it should always be possible to absorb unhealthy troves with `ltv > 90%`:\n\n> Absorption can happen only after an unhealthy trove's LTV has exceeded the LTV at which the maximum possible penalty is reached, or if it has exceeded 90% LTV. The liquidation penalty in this case will similarly be capped to the maximum of 12.5% or the maximum possible penalty.\n\nHowever, the [`purger::get_absorption_penalty_internal`(...)](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/purger.cairo#L433-L481) method mistakenly checks the `threshold` instead of the `ltv` against the `ABSORPTION_THRESHOLD (90%)` in [L467](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/purger.cairo#L467):\n\n```cairo\nfn get_absorption_penalty_internal(\n    self: @ContractState, threshold: Ray, ltv: Ray, ltv_after_compensation: Ray\n) -> Option<Ray> {\n    if ltv <= threshold {\n        return Option::None;\n    }\n\n    ...\n\n    let mut max_possible_penalty: Ray = min(\n        (RAY_ONE.into() - ltv_after_compensation) / ltv_after_compensation, MAX_PENALTY.into()\n    );\n\n    if threshold > ABSORPTION_THRESHOLD.into() { // @audit ltv instead\n        let s = self.penalty_scalar.read();\n        let penalty = min(MIN_PENALTY.into() + s * ltv / threshold - RAY_ONE.into(), max_possible_penalty);\n\n        return Option::Some(penalty);\n    }\n\n    let penalty = min(MIN_PENALTY.into() + ltv / threshold - RAY_ONE.into(), max_possible_penalty);\n\n    if penalty == max_possible_penalty {\n        Option::Some(penalty)\n    } else {\n        Option::None\n    }\n}\n```\n\nAs a consequence, unhealthy troves can only be absorbed if they reach the maximum possible penalty although the condition `ltv > 90%` is already satisfied. This is against the protocol's intended liquidation/absorption incentives and therefore, endangers the solvency of the protocol.\n\nBy observing the sponsor's [graph for liquidation penalty](https://demo-35.gitbook.io/untitled/smart-contracts/purger-module#resources) it becomes evident that the `MAX_PENALTY` can only be achieved for `ltv` up to `89%`. For even higher `ltv` up to `100%`, the penalty approaches `0%` due to `max_possible_penalty` (see code above), which lowers the incentives for liquidation and makes absorption a necessity.\n\nIn case of `threshold > 83%` there is a window where `90% < ltv < ltv@max_possible_penalty` causing absorptions to be impossible due to the present bug. This [linked graph](https://www.desmos.com/calculator/tqleykyaeq) visualizes the present issue.\n\n### Proof of Concept\n\nIn the following, a numerical example is provided to demonstrate the above claims. Initial assumptions:\n\n```\nthreshold              = 88%    (reasonable because shrine::MAX_THRESHOLD is 100%)\nltv                    = 91%    (should be eligible for absorption in any case)\nltv_after_compensation = 93%    (reasonable because ltv becomes worse due to compensation)\n```\n\nLet's do the math step-by-step:\n\n```cairo\nfn get_absorption_penalty_internal(\n    self: @ContractState, threshold: Ray, ltv: Ray, ltv_after_compensation: Ray\n) -> Option<Ray> {\n    // @PoC: 91% <= 88% --> false, skip body\n    if ltv <= threshold {\n        return Option::None;\n    }\n\n    ...\n\n    let mut max_possible_penalty: Ray = min(\n        (RAY_ONE.into() - ltv_after_compensation) / ltv_after_compensation, MAX_PENALTY.into()\n    );\n    // @PoC: max_possible_penalty = 7.53%\n    \n    // @PoC: 88% > 90% --> false, skip body due to wrong check\n    if threshold > ABSORPTION_THRESHOLD.into() { // @audit ltv instead\n        let s = self.penalty_scalar.read();\n        let penalty = min(MIN_PENALTY.into() + s * ltv / threshold - RAY_ONE.into(), max_possible_penalty);\n\n        return Option::Some(penalty);\n    }\n\n    let penalty = min(MIN_PENALTY.into() + ltv / threshold - RAY_ONE.into(), max_possible_penalty);\n    // @PoC: penalty = 6.41%\n    \n    // @PoC: 6.41% == 7.53% --> false, go in else\n    if penalty == max_possible_penalty {\n        Option::Some(penalty)\n    } else {\n        Option::None    // @PoC: trove is not eligible for absorption\n    }\n}\n```\n\nWe can see that the trove has not reached its maximum possible penalty yet, therefore, it cannot be absorbed as expected, although `ltv > 90%`.\n\n### Recommended Mitigation Steps\n\nMake sure the absorption threshold is checked against the `ltv` as intended:\n\n```diff\ndiff --git a/src/core/purger.cairo b/src/core/purger.cairo\nindex 6a36bbc..820aff5 100644\n--- a/src/core/purger.cairo\n+++ b/src/core/purger.cairo\n@@ -464,7 +464,7 @@ mod purger {\n                 (RAY_ONE.into() - ltv_after_compensation) / ltv_after_compensation, MAX_PENALTY.into()\n             );\n \n-            if threshold > ABSORPTION_THRESHOLD.into() {\n+            if ltv > ABSORPTION_THRESHOLD.into() {\n                 let s = self.penalty_scalar.read();\n                 let penalty = min(MIN_PENALTY.into() + s * ltv / threshold - RAY_ONE.into(), max_possible_penalty);\n```\n\n### Assessed type\n\nMath\n\n**[0xsomeone (judge) commented](https://github.com/code-423n4/2024-01-opus-findings/issues/11#issuecomment-1964565372):**\n > The warden has demonstrated how a contradiction between the documentation and the implementation of the project will cause certain troves to not be liquidate-able temporarily.\n> \n> I confirmed this submission as the documentation of the project states [in the priority of liquidation methods](https://demo-35.gitbook.io/untitled/smart-contracts/purger-module#description-of-key-functions) chapter that a trove should be liquidate-able if its TVL exceeds 90% (i.e. the `ABSORPTION_THRESHOLD`). The code incorrectly validates the trove's threshold rather than LTV, rendering the submission to be valid.\n> \n> I consider a medium-risk severity apt for this finding as the DoS is temporary.\n\n**[tserg (Opus) commented](https://github.com/code-423n4/2024-01-opus-findings/issues/11#issuecomment-1965784603):**\n > This is an error in the documentation.\n> \n> The correct wording should be:\n> ```\n> Absorption can happen only after an unhealthy trove's LTV has exceeded the LTV at which the maximum possible penalty is reached, or if its threshold exceeds 90% LTV and its LTV has exceeded the threshold\n> ```\n\n**[0xsomeone (judge) commented](https://github.com/code-423n4/2024-01-opus-findings/issues/11#issuecomment-1967266741):**\n > The sponsor has clarified that the documentation was incorrect and that the code behaves as expected; however, per C4 standards I will accept this submission as valid given that the documentation serves as the source of truth for the wardens to validate.\n\n**[0xTheC0der (warden) commented](https://github.com/code-423n4/2024-01-opus-findings/issues/11#issuecomment-1967488639):**\n > First of all, thanks for keeping the issue valid due to the *source of truth* consideration. I can confirm that's how we handle such cases on C4 and the present case serves as good exmaple of fair judging.  \n> \n> Anyways, I still want to provide further insights about this since it might be relevant for the sponsor.\n> \n> According to the sponsor's update:\n> > Absorption can happen only after an unhealthy trove's LTV has exceeded the LTV at which the maximum possible penalty is reached, or if its threshold exceeds 90% LTV and its LTV has exceeded the threshold\n> \n> The following would be true:\n> - A trove with 88% threshold could only be absorbed > 92.5% LTV (due to max. penalty).\n> - A trove with > 90% threshold could already be absorbed > 90% LTV (due to 90% threshold).\n> \n> This is contradictory and the discrepancy starts arising for thresholds > 83% effectively creating an \"absorption gap\", see main report and [graph](https://www.desmos.com/calculator/tqleykyaeq).\n> \n> As far as I understood the mechanics of the protocol, the initially documented LTV criteria of absorption seemed to be the most reasonable while the code is subject to the above discrepancy. Therefore, I still recommend to go with the implementation according to the main report's mitigation measures.  \n> \n> For anyone wanting to play around with threshold vs. LTV vs. max. penalty, I've created [this graph](https://www.desmos.com/calculator/tqleykyaeq) which is based on the sponsor's initial graph from the docs.\n> \n> I hope I could provide further insights and value!\n\n**[tserg (Opus) commented](https://github.com/code-423n4/2024-01-opus-findings/issues/11#issuecomment-1968371654):**\n > To give some context, the alternative condition of \"if its threshold exceeds 90% LTV and its LTV has exceeded the threshold\" for absorption was added because:\n> 1. As a matter of convenience, because at thresholds greater than 90%, there is relatively less room for the LTV to increase before the maximum penalty is reached; and\n> 2. At these high thresholds, the balance lies in favour of securing the protocol by liquidating these positions however the method (searcher or absorber) before they become underwater.\n> \n> In my opinion, the \"absorption gap\" for thresholds > 83%, while conceptually contradictory, is acceptable because searcher liquidations is already available once LTV > threshold. Of course, the contradiction is more jarring the closer we get to 90% (e.g. 88% threshold as you pointed), but a line has to be drawn somewhere and 90% is a convenient round figure.\n\n**[milancermak (Opus) confirmed](https://github.com/code-423n4/2024-01-opus-findings/issues/11#issuecomment-1983833070)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-opus",
  "Code": [
    {
      "filename": "src/core/purger.cairo",
      "content": "#[starknet::contract]\nmod purger {\n    use access_control::access_control_component;\n    use cmp::min;\n    use core::math::Oneable;\n    use core::zeroable::Zeroable;\n    use opus::core::roles::purger_roles;\n    use opus::interfaces::IAbsorber::{IAbsorberDispatcher, IAbsorberDispatcherTrait};\n    use opus::interfaces::IPurger::IPurger;\n    use opus::interfaces::ISeer::{ISeerDispatcher, ISeerDispatcherTrait};\n    use opus::interfaces::ISentinel::{ISentinelDispatcher, ISentinelDispatcherTrait};\n    use opus::interfaces::IShrine::{IShrineDispatcher, IShrineDispatcherTrait};\n    use opus::types::{AssetBalance, Health};\n    use opus::utils::reentrancy_guard::reentrancy_guard_component;\n    use starknet::{ContractAddress, get_caller_address};\n    use wadray::{Ray, RayZeroable, RAY_ONE, Wad, WadZeroable};\n\n    //\n    // Components\n    //\n\n    component!(path: access_control_component, storage: access_control, event: AccessControlEvent);\n\n    component!(path: reentrancy_guard_component, storage: reentrancy_guard, event: ReentrancyGuardEvent);\n\n    #[abi(embed_v0)]\n    impl AccessControlPublic = access_control_component::AccessControl<ContractState>;\n    impl AccessControlHelpers = access_control_component::AccessControlHelpers<ContractState>;\n\n    impl ReentrancyGuardHelpers = reentrancy_guard_component::ReentrancyGuardHelpers<ContractState>;\n\n    //\n    // Constants\n    //\n\n    // This is multiplied by a trove's threshold to determine the target LTV\n    // the trove should have after a liquidation, which in turn determines the\n    // maximum amount of the trove's debt that can be liquidated.\n    const THRESHOLD_SAFETY_MARGIN: u128 = 900000000000000000000000000; // 0.9 (ray)\n\n    // Maximum liquidation penalty (ray): 0.125 * RAY_ONE\n    const MAX_PENALTY: u128 = 125000000000000000000000000;\n\n    // Minimum liquidation penalty (ray): 0.03 * RAY_ONE\n    const MIN_PENALTY: u128 = 30000000000000000000000000;\n\n    // Bounds on the penalty scalar for absorber liquidations\n    const MIN_PENALTY_SCALAR: u128 = 970000000000000000000000000; // 0.97 (ray) (1 - MIN_PENALTY)\n    const MAX_PENALTY_SCALAR: u128 = 1060000000000000000000000000; // 1.06 (ray)\n\n    // LTV past which the second precondition for `absorb` is satisfied even if\n    // the trove's penalty is not at the absolute maximum given the LTV.\n    const ABSORPTION_THRESHOLD: u128 = 900000000000000000000000000; // 0.9 (ray)\n\n    // Maximum percentage of trove collateral that\n    // is transferred to caller of `absorb` as compensation 3% = 0.03 (ray)\n    const COMPENSATION_PCT: u128 = 30000000000000000000000000;\n\n    // Cap on compensation value: 50 (Wad)\n    const COMPENSATION_CAP: u128 = 50000000000000000000;\n\n    // Minimum threshold for the penalty calculation, under which the\n    // minimum penalty is automatically returned to avoid division by zero/overflow\n    const MIN_THRESHOLD_FOR_PENALTY_CALCS: u128 = 10000000000000000000000000; // RAY_ONE = 1% (ray)\n\n    //\n    // Storage\n    //\n\n    #[storage]\n    struct Storage {\n        // components\n        #[substorage(v0)]\n        access_control: access_control_component::Storage,\n        #[substorage(v0)]\n        reentrancy_guard: reentrancy_guard_component::Storage,\n        // the Shrine associated with this Purger\n        shrine: IShrineDispatcher,\n        // the Sentinel associated with the Shrine and this Purger\n        sentinel: ISentinelDispatcher,\n        // the Absorber associated with this Purger\n        absorber: IAbsorberDispatcher,\n        // the Seer module\n        seer: ISeerDispatcher,\n        // Scalar for multiplying penalties above `ABSORPTION_THRESHOLD`\n        penalty_scalar: Ray,\n    }\n\n    //\n    // Events\n    //\n\n    #[event]\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    enum Event {\n        AccessControlEvent: access_control_component::Event,\n        PenaltyScalarUpdated: PenaltyScalarUpdated,\n        Purged: Purged,\n        Compensate: Compensate,\n        // Component events\n        ReentrancyGuardEvent: reentrancy_guard_component::Event\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct PenaltyScalarUpdated {\n        new_scalar: Ray\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct Purged {\n        #[key]\n        trove_id: u64,\n        purge_amt: Wad,\n        percentage_freed: Ray,\n        #[key]\n        funder: ContractAddress,\n        #[key]\n        recipient: ContractAddress,\n        freed_assets: Span<AssetBalance>\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct Compensate {\n        #[key]\n        recipient: ContractAddress,\n        compensation: Span<AssetBalance>\n    }\n\n    //\n    // Constructor\n    //\n\n    #[constructor]\n    fn constructor(\n        ref self: ContractState,\n        admin: ContractAddress,\n        shrine: ContractAddress,\n        sentinel: ContractAddress,\n        absorber: ContractAddress,\n        seer: ContractAddress,\n    ) {\n        self.access_control.initializer(admin, Option::Some(purger_roles::default_admin_role()));\n\n        self.shrine.write(IShrineDispatcher { contract_address: shrine });\n        self.sentinel.write(ISentinelDispatcher { contract_address: sentinel });\n        self.absorber.write(IAbsorberDispatcher { contract_address: absorber });\n        self.seer.write(ISeerDispatcher { contract_address: seer });\n\n        self.penalty_scalar.write(RAY_ONE.into());\n        self.emit(PenaltyScalarUpdated { new_scalar: RAY_ONE.into() });\n    }\n\n    #[abi(embed_v0)]\n    impl IPurgerImpl of IPurger<ContractState> {\n        //\n        // View\n        //\n\n        // Returns a tuple of:\n        // 1. the penalty (Ray)\n        //    Returns 0 if trove is healthy, OR if the trove's LTV > 100%.\n        //    Note that the penalty should not be used as a proxy to determine if a\n        //    trove is liquidatable or not.\n        // 2. the maximum amount of debt that can be liquidated for the trove (Wad)\n        fn preview_liquidate(self: @ContractState, trove_id: u64) -> Option<(Ray, Wad)> {\n            let trove_health: Health = self.shrine.read().get_trove_health(trove_id);\n            preview_liquidate_internal(trove_health)\n        }\n\n        // Returns a tuple of:\n        // 1. the penalty (Ray)\n        //    Returns 0 if trove is healthy, OR not absorbable,\n        //    OR if the trove's LTV after compensation is deducted exceeds 100%.\n        //    Note that the penalty should not be used as a proxy to determine if a\n        //    trove is absorbable or not.\n        // 2. the maximum amount of debt that can be absorbed for the trove (Wad)\n        // 3. the amount of compensation the caller will receive (Wad)\n        fn preview_absorb(self: @ContractState, trove_id: u64) -> Option<(Ray, Wad, Wad)> {\n            let trove_health: Health = self.shrine.read().get_trove_health(trove_id);\n\n            match self.preview_absorb_internal(trove_health) {\n                Option::Some((\n                    penalty, max_absorption_amt, _, compensation, _, _,\n                )) => { Option::Some((penalty, max_absorption_amt, compensation)) },\n                Option::None => Option::None,\n            }\n        }\n\n        fn is_absorbable(self: @ContractState, trove_id: u64) -> bool {\n            let trove_health: Health = self.shrine.read().get_trove_health(trove_id);\n\n            match self.preview_absorb_internal(trove_health) {\n                Option::Some((_, _, _, _, _, _)) => true,\n                Option::None => false,\n            }\n        }\n\n        fn get_penalty_scalar(self: @ContractState) -> Ray {\n            self.penalty_scalar.read()\n        }\n\n        //\n        // External\n        //\n        fn set_penalty_scalar(ref self: ContractState, new_scalar: Ray) {\n            self.access_control.assert_has_role(purger_roles::SET_PENALTY_SCALAR);\n            assert(\n                MIN_PENALTY_SCALAR.into() <= new_scalar && new_scalar <= MAX_PENALTY_SCALAR.into(), 'PU: Invalid scalar'\n            );\n\n            self.penalty_scalar.write(new_scalar);\n            self.emit(PenaltyScalarUpdated { new_scalar });\n        }\n\n        // Performs searcher liquidations that requires the caller address to supply the amount of debt to repay\n        // and the recipient address to send the freed collateral to.\n        // Reverts if:\n        // - the trove is not liquidatable (i.e. LTV > threshold).\n        // - if the trove's LTV is worse off than before the liquidation (should not be possible, but as a precaution)\n        // Returns an array of `AssetBalance` struct for the freed collateral due to the recipient for performing\n        // the liquidation.\n        fn liquidate(\n            ref self: ContractState, trove_id: u64, amt: Wad, recipient: ContractAddress\n        ) -> Span<AssetBalance> {\n            let shrine: IShrineDispatcher = self.shrine.read();\n\n            let trove_health: Health = shrine.get_trove_health(trove_id);\n\n            let (trove_penalty, max_close_amt) = preview_liquidate_internal(trove_health)\n                .expect('PU: Not liquidatable');\n\n            // Cap the liquidation amount to the trove's maximum close amount\n            let purge_amt: Wad = min(amt, max_close_amt);\n\n            let percentage_freed: Ray = get_percentage_freed(\n                trove_health.ltv, trove_health.value, trove_health.debt, trove_penalty, purge_amt\n            );\n\n            let funder: ContractAddress = get_caller_address();\n\n            // Melt from the funder address directly\n            // This step is also crucial because it would revert if the Shrine has been killed, thereby\n            // preventing further liquidations.\n            shrine.melt(funder, trove_id, purge_amt);\n\n            // Free collateral corresponding to the purged amount\n            let freed_assets: Span<AssetBalance> = self.free(shrine, trove_id, percentage_freed, recipient);\n\n            // Safety check to ensure the new LTV is not worse off\n            let updated_trove_health: Health = shrine.get_trove_health(trove_id);\n            assert(updated_trove_health.ltv <= trove_health.ltv, 'PU: LTV increased');\n\n            self.emit(Purged { trove_id, purge_amt, percentage_freed, funder, recipient, freed_assets });\n\n            freed_assets\n        }\n\n        // Performs stability pool liquidations to pay down a trove's debt in full and transfer the\n        // freed collateral to the stability pool. If the stability pool does not have sufficient yin,\n        // the trove's debt and collateral will be proportionally redistributed among all troves\n        // containing the trove's collateral.\n        // - Amount of debt distributed to each collateral = (value of collateral / trove value) * trove debt\n        // Reverts if the trove's LTV is not above the maximum penalty LTV\n        // - This also checks the trove is liquidatable because threshold must be lower than max penalty LTV.\n        // Returns an array of `AssetBalance` struct for the freed collateral due to the caller as compensation.\n        fn absorb(ref self: ContractState, trove_id: u64) -> Span<AssetBalance> {\n            let shrine: IShrineDispatcher = self.shrine.read();\n\n            let trove_health: Health = shrine.get_trove_health(trove_id);\n\n            let (\n                trove_penalty,\n                max_purge_amt,\n                pct_value_to_compensate,\n                _,\n                ltv_after_compensation,\n                value_after_compensation\n            ) =\n                self\n                .preview_absorb_internal(trove_health)\n                .expect('PU: Not absorbable');\n\n            let caller: ContractAddress = get_caller_address();\n            let absorber: IAbsorberDispatcher = self.absorber.read();\n\n            // If the absorber is operational, cap the purge amount to the absorber's balance\n            // (including if it is zero).\n            let purge_amt = if absorber.is_operational() {\n                min(max_purge_amt, shrine.get_yin(absorber.contract_address))\n            } else {\n                WadZeroable::zero()\n            };\n\n            // Transfer a percentage of the penalty to the caller as compensation\n            let compensation_assets: Span<AssetBalance> = self.free(shrine, trove_id, pct_value_to_compensate, caller);\n\n            // Melt the trove's debt using the absorber's yin directly\n            // This needs to be called even if `purge_amt` is 0 so that accrued interest\n            // will be charged on the trove before `shrine.redistribute`.\n            // This step is also crucial because it would revert if the Shrine has been killed, thereby\n            // preventing further liquidations.\n            shrine.melt(absorber.contract_address, trove_id, purge_amt);\n\n            let can_absorb_some: bool = purge_amt.is_non_zero();\n            let is_fully_absorbed: bool = purge_amt == max_purge_amt;\n\n            let pct_value_to_purge: Ray = if can_absorb_some {\n                get_percentage_freed(\n                    ltv_after_compensation, value_after_compensation, trove_health.debt, trove_penalty, purge_amt\n                )\n            } else {\n                RayZeroable::zero()\n            };\n\n            // Only update the absorber and emit the `Purged` event if Absorber has some yin\n            // to melt the trove's debt and receive freed trove assets in return\n            if can_absorb_some {\n                // Free collateral corresponding to the purged amount\n                let absorbed_assets: Span<AssetBalance> = self\n                    .free(shrine, trove_id, pct_value_to_purge, absorber.contract_address);\n                absorber.update(absorbed_assets);\n\n                self\n                    .emit(\n                        Purged {\n                            trove_id,\n                            purge_amt,\n                            percentage_freed: pct_value_to_purge,\n                            funder: absorber.contract_address,\n                            recipient: absorber.contract_address,\n                            freed_assets: absorbed_assets\n                        }\n                    );\n            }\n\n            // If it is not a full absorption, perform redistribution.\n            if !is_fully_absorbed {\n                // This is guaranteed to be greater than zero.\n                let debt_to_redistribute: Wad = max_purge_amt - purge_amt;\n\n                let redistribute_trove_debt_in_full: bool = max_purge_amt == trove_health.debt;\n                let pct_value_to_redistribute: Ray = if redistribute_trove_debt_in_full {\n                    RAY_ONE.into()\n                } else {\n                    let debt_after_absorption: Wad = trove_health.debt - purge_amt;\n                    let value_after_absorption: Wad = value_after_compensation\n                        - wadray::rmul_rw(pct_value_to_purge, value_after_compensation);\n                    let ltv_after_absorption: Ray = wadray::rdiv_ww(debt_after_absorption, value_after_absorption);\n\n                    get_percentage_freed(\n                        ltv_after_absorption,\n                        value_after_absorption,\n                        debt_after_absorption,\n                        trove_penalty,\n                        debt_to_redistribute\n                    )\n                };\n                shrine.redistribute(trove_id, debt_to_redistribute, pct_value_to_redistribute);\n\n                // Update yang prices due to an appreciation in ratio of asset to yang from\n                // redistribution\n                self.seer.read().update_prices();\n            }\n\n            // Safety check to ensure the new LTV is not worse off\n            let updated_trove_health: Health = shrine.get_trove_health(trove_id);\n            assert(updated_trove_health.ltv <= trove_health.ltv, 'PU: LTV increased');\n\n            self.emit(Compensate { recipient: caller, compensation: compensation_assets });\n\n            compensation_assets\n        }\n    }\n\n\n    //\n    // Internal\n    //\n\n    #[generate_trait]\n    impl PurgerHelpers of PurgerHelpersTrait {\n        // Internal function to transfer the given percentage of a trove's collateral to the given\n        // recipient address.\n        // Returns an array of `AssetBalance` struct.\n        fn free(\n            ref self: ContractState,\n            shrine: IShrineDispatcher,\n            trove_id: u64,\n            percentage_freed: Ray,\n            recipient: ContractAddress,\n        ) -> Span<AssetBalance> {\n            self.reentrancy_guard.start();\n            let sentinel: ISentinelDispatcher = self.sentinel.read();\n            let yangs: Span<ContractAddress> = sentinel.get_yang_addresses();\n            let mut freed_assets: Array<AssetBalance> = ArrayTrait::new();\n\n            let mut yangs_copy: Span<ContractAddress> = yangs;\n\n            // Loop through yang addresses and transfer to recipient\n            loop {\n                match yangs_copy.pop_front() {\n                    Option::Some(yang) => {\n                        let deposited_yang_amt: Wad = shrine.get_deposit(*yang, trove_id);\n\n                        let freed_asset_amt: u128 = if deposited_yang_amt.is_zero() {\n                            0\n                        } else {\n                            let freed_yang: Wad = wadray::rmul_wr(deposited_yang_amt, percentage_freed);\n                            let exit_amt: u128 = sentinel.exit(*yang, recipient, trove_id, freed_yang);\n                            shrine.seize(*yang, trove_id, freed_yang);\n                            exit_amt\n                        };\n\n                        freed_assets.append(AssetBalance { address: *yang, amount: freed_asset_amt });\n                    },\n                    Option::None => { break; }\n                };\n            };\n\n            self.reentrancy_guard.end();\n            freed_assets.span()\n        }\n\n        // Returns `Option::None` if the trove is not absorbable, otherwise returns the absorption penalty\n        // A trove is absorbable if and only if:\n        // 1. ltv > threshold; and\n        // 2. either of the following is true:\n        //    a) its threshold is greater than `ABSORPTION_THRESHOLD`; or\n        //    b) the penalty is at the maximum possible for the current LTV such that the post-liquidation\n        //       LTV is not worse off (i.e. penalty == (1 - usable_ltv)/usable_ltv).\n        //\n        // If threshold exceeds ABSORPTION_THRESHOLD, the marginal penalty is scaled by `penalty_scalar`.\n        fn get_absorption_penalty_internal(\n            self: @ContractState, threshold: Ray, ltv: Ray, ltv_after_compensation: Ray\n        ) -> Option<Ray> {\n            if ltv <= threshold {\n                return Option::None;\n            }\n\n            // It's possible for `ltv_after_compensation` to be greater than one, so we handle this case\n            // to avoid underflow. Note that this also guarantees `ltv` is lesser than one.\n            if ltv_after_compensation > RAY_ONE.into() {\n                return Option::Some(RayZeroable::zero());\n            }\n\n            // If the threshold is below the given minimum, we automatically\n            // return the maximum penalty to avoid division by zero/overflow, or the largest possible penalty,\n            // whichever is smaller.\n            if threshold < MIN_THRESHOLD_FOR_PENALTY_CALCS.into() {\n                // This check is to avoid overflow in the event that the\n                // trove's LTV is also extremely low.\n                if ltv >= MIN_THRESHOLD_FOR_PENALTY_CALCS.into() {\n                    return Option::Some(\n                        min(MAX_PENALTY.into(), (RAY_ONE.into() - ltv_after_compensation) / ltv_after_compensation)\n                    );\n                }\n                return Option::Some(MAX_PENALTY.into());\n            }\n\n            // The `ltv_after_compensation` is used to calculate the maximum penalty that can be charged\n            // at the trove's current LTV after deducting compensation, while ensuring the LTV is not worse off\n            // after absorption.\n            let mut max_possible_penalty: Ray = min(\n                (RAY_ONE.into() - ltv_after_compensation) / ltv_after_compensation, MAX_PENALTY.into()\n            );\n\n            if threshold > ABSORPTION_THRESHOLD.into() {\n                let s = self.penalty_scalar.read();\n                let penalty = min(MIN_PENALTY.into() + s * ltv / threshold - RAY_ONE.into(), max_possible_penalty);\n\n                return Option::Some(penalty);\n            }\n\n            let penalty = min(MIN_PENALTY.into() + ltv / threshold - RAY_ONE.into(), max_possible_penalty);\n\n            if penalty == max_possible_penalty {\n                Option::Some(penalty)\n            } else {\n                Option::None\n            }\n        }\n\n        // Helper function to return the following for a trove:\n        // 1. absorption penalty (zero if trove is not absorbable)\n        // 2. maximum absorption amount (zero if trove is not absorbable)\n        // 3. compensation as a percentage of the trove's value (zero if trove is not absorbable)\n        // 4. amount of compensation due to the caller (zero if trove is not absorbable)\n        // 5. LTV after compensation (unchanged if trove is not absorbable)\n        // 6. value after compensation (unchanged if trove is not absorbable)\n        fn preview_absorb_internal(\n            self: @ContractState, trove_health: Health\n        ) -> Option<(Ray, Wad, Ray, Wad, Ray, Wad)> {\n            let (compensation_pct, compensation) = get_compensation(trove_health.value);\n            let ltv_after_compensation: Ray = trove_health.ltv / (RAY_ONE.into() - compensation_pct);\n\n            match self\n                .get_absorption_penalty_internal(trove_health.threshold, trove_health.ltv, ltv_after_compensation) {\n                Option::Some(penalty) => {\n                    let value_after_compensation: Wad = wadray::rmul_rw(\n                        RAY_ONE.into() - compensation_pct, trove_health.value\n                    );\n\n                    // LTV and value after compensation are used to calculate the max purge amount\n                    let max_absorption_amt: Wad = get_max_close_amount_internal(\n                        trove_health.threshold, value_after_compensation, trove_health.debt, penalty\n                    );\n\n                    if max_absorption_amt.is_non_zero() {\n                        Option::Some(\n                            (\n                                penalty,\n                                max_absorption_amt,\n                                compensation_pct,\n                                compensation,\n                                ltv_after_compensation,\n                                value_after_compensation\n                            )\n                        )\n                    } else {\n                        Option::None\n                    }\n                },\n                Option::None => Option::None,\n            }\n        }\n    }\n\n    //\n    // Pure functions\n    //\n\n    // Returns the maximum amount of debt that can be paid off in a given liquidation\n    // Note: this function reverts if the trove's LTV is below its threshold multiplied by `THRESHOLD_SAFETY_MARGIN`\n    // because `debt - wadray::rmul_wr(value, target_ltv)` would underflow\n    #[inline(always)]\n    fn get_max_close_amount_internal(threshold: Ray, value: Wad, debt: Wad, penalty: Ray) -> Wad {\n        let penalty_multiplier = RAY_ONE.into() + penalty;\n        let target_ltv = THRESHOLD_SAFETY_MARGIN.into() * threshold;\n\n        min(\n            wadray::rdiv_wr(\n                debt - wadray::rmul_wr(value, target_ltv), RAY_ONE.into() - penalty_multiplier * target_ltv\n            ),\n            debt\n        )\n    }\n\n    // Returns `Option::None` if the trove is not liquidatable, otherwise returns the liquidation penalty\n    fn get_liquidation_penalty_internal(threshold: Ray, ltv: Ray) -> Option<Ray> {\n        if ltv <= threshold {\n            return Option::None;\n        }\n\n        // Handling the case where `ltv > 1` to avoid underflow\n        if ltv >= RAY_ONE.into() {\n            return Option::Some(RayZeroable::zero());\n        }\n\n        // If the threshold is below the given minimum, we automatically\n        // return the minimum penalty to avoid division by zero/overflow, or the largest possible penalty,\n        // whichever is smaller.\n        if threshold < MIN_THRESHOLD_FOR_PENALTY_CALCS.into() {\n            // This check is to avoid overflow in the event that the\n            // trove's LTV is also extremely low.\n            if ltv >= MIN_THRESHOLD_FOR_PENALTY_CALCS.into() {\n                return Option::Some(min(MAX_PENALTY.into(), (RAY_ONE.into() - ltv) / ltv));\n            }\n            return Option::Some(MAX_PENALTY.into());\n        }\n\n        let penalty = min(\n            min(MIN_PENALTY.into() + ltv / threshold - RAY_ONE.into(), MAX_PENALTY.into()), (RAY_ONE.into() - ltv) / ltv\n        );\n\n        Option::Some(penalty)\n    }\n\n    // Helper function to return the following for a trove:\n    // 1. liquidation penalty (zero if trove is not liquidatable)\n    // 2. maximum liquidation amount (zero if trove is not liquidatable)\n    fn preview_liquidate_internal(trove_health: Health) -> Option<(Ray, Wad)> {\n        match get_liquidation_penalty_internal(trove_health.threshold, trove_health.ltv) {\n            Option::Some(penalty) => {\n                let max_close_amt = get_max_close_amount_internal(\n                    trove_health.threshold, trove_health.value, trove_health.debt, penalty\n                );\n\n                if max_close_amt.is_non_zero() {\n                    Option::Some((penalty, max_close_amt))\n                } else {\n                    Option::None\n                }\n            },\n            Option::None => Option::None,\n        }\n    }\n\n    // Helper function to calculate percentage of collateral freed.\n    // If LTV <= 100%, calculate based on the sum of amount paid down and liquidation penalty divided by total trove value.\n    // If LTV > 100%, pro-rate based on amount paid down divided by total debt.\n    fn get_percentage_freed(trove_ltv: Ray, trove_value: Wad, trove_debt: Wad, penalty: Ray, purge_amt: Wad) -> Ray {\n        if trove_ltv.val <= RAY_ONE {\n            let penalty_amt: Wad = wadray::rmul_wr(purge_amt, penalty);\n            wadray::rdiv_ww(purge_amt + penalty_amt, trove_value)\n        } else {\n            wadray::rdiv_ww(purge_amt, trove_debt)\n        }\n    }\n\n    // Returns:\n    // 1. the amount of compensation due to the caller of `absorb` as a percentage of\n    //    the value of the trove's collateral, capped at 3% of the trove's value or the\n    //    percentage of the trove's value equivalent to `COMPENSATION_CAP`\n    // 2. the value of (1) in Wad\n    fn get_compensation(trove_value: Wad) -> (Ray, Wad) {\n        let default_compensation_pct: Ray = COMPENSATION_PCT.into();\n        let default_compensation: Wad = wadray::rmul_wr(trove_value, default_compensation_pct);\n        if default_compensation.val < COMPENSATION_CAP {\n            (default_compensation_pct, default_compensation)\n        } else {\n            (wadray::rdiv_ww(COMPENSATION_CAP.into(), trove_value), COMPENSATION_CAP.into())\n        }\n    }\n}"
    }
  ]
}