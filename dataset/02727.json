{
  "Title": "M-6: Teller Cannot Be Removed From Callback Contract",
  "Content": "# Issue M-6: Teller Cannot Be Removed From Callback Contract \n\nSource: https://github.com/sherlock-audit/2022-11-bond-judging/issues/18 \n\n## Found by \nxiaoming90\n\n## Summary\n\nIf a vulnerable Teller is being exploited by an attacker, there is no way for the owner of the Callback Contract to remove the vulnerable Teller from their Callback Contract.\n\n## Vulnerability Detail\n\nThe Callback Contract is missing the feature to remove a Teller. Once a Teller has been added to the whitelist (`approvedMarkets` mapping), it is not possible to remove the Teller from the whitelist.\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseCallback.sol#L59\n\n```solidity\nFile: BondBaseCallback.sol\n56:     /* ========== WHITELISTING ========== */\n57: \n58:     /// @inheritdoc IBondCallback\n59:     function whitelist(address teller_, uint256 id_) external override onlyOwner {\n60:         // Check that the market id is a valid, live market on the aggregator\n61:         try _aggregator.isLive(id_) returns (bool live) {\n62:             if (!live) revert Callback_MarketNotSupported(id_);\n63:         } catch {\n64:             revert Callback_MarketNotSupported(id_);\n65:         }\n66: \n67:         // Check that the provided teller is the teller for the market ID on the stored aggregator\n68:         // We could pull the teller from the aggregator, but requiring the teller to be passed in\n69:         // is more explicit about which contract is being whitelisted\n70:         if (teller_ != address(_aggregator.getTeller(id_))) revert Callback_TellerMismatch();\n71: \n72:         approvedMarkets[teller_][id_] = true;\n73:     }\n```\n\n## Impact\n\nIn the event that a whitelisted Teller is found to be vulnerable and has been actively exploited by an attacker in the wild, the owner of the Callback Contract needs to mitigate the issue swiftly by removing the vulnerable Teller from the Callback Contract to stop it from draining the asset within the Callback Contract. However, the mitigation effort will be hindered by the fact there is no way to remove a Teller within the Callback Contract once it has been whitelisted. Thus, it might not be possible to stop the attacker from exploiting the vulnerable Teller to drain assets within the Callback Contract. The Callback Contract owners would need to find a workaround to block the attack, which will introduce an unnecessary delay to the recovery process where every second counts.\n\nAdditionally, if the owner accidentally whitelisted the wrong Teller, there is no way to remove it.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseCallback.sol#L59\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider implementing an additional function to allow the removal of a Teller from the whitelist (`approvedMarkets` mapping), so that a vulnerable Teller can be removed swiftly if needed.\n\n```solidity\nfunction removeFromWhitelist(address teller_, uint256 id_) external override onlyOwner {\n    approvedMarkets[teller_][id_] = false;\n}\n```\n\nNote: Although the owner of the Callback Contract can DOS its own market by abusing the `removeFromWhitelist` function, no sensible owner would do so.\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nAgree with this issue. We implemented a `blacklist()` function on the BondBaseCallback.sol contract to allow removing a teller and market ID combination from using the callback.\n\n\n\n**xiaoming9090**\n\nFixed in https://github.com/Bond-Protocol/bonds/commit/368e6c5b120d9fc44c59cc21d33ee51728728067\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/20",
  "Code": [
    {
      "filename": "src/bases/BondBaseCallback.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {Ownable} from \"openzeppelin/access/Ownable.sol\";\nimport {TransferHelper} from \"../lib/TransferHelper.sol\";\n\nimport {IBondCallback} from \"../interfaces/IBondCallback.sol\";\nimport {IBondAggregator} from \"../interfaces/IBondAggregator.sol\";\n\n/// @title Bond Callback\n/// @notice Bond Callback Base Contract\n/// @dev Bond Protocol is a system to create Olympus-style bond markets\n///      for any token pair. The markets do not require maintenance and will manage\n///      bond prices based on activity. Bond issuers create BondMarkets that pay out\n///      a Payout Token in exchange for deposited Quote Tokens. Users can purchase\n///      future-dated Payout Tokens with Quote Tokens at the current market price and\n///      receive Bond Tokens to represent their position while their bond vests.\n///      Once the Bond Tokens vest, they can redeem it for the Quote Tokens.\n///\n/// @dev The Callback contract is an optional feature of the Bond system.\n///      Callbacks allow issuers (market creators) to apply custom logic on receipt and\n///      payout of tokens. The Callback must be created prior to market creation and\n///      the address passed in as an argument. The Callback depends on the Aggregator\n///      contract for the Auctioneer that the market is created to get market data.\n///\n/// @dev Without a Callback contract, payout tokens are transferred directly from\n///      the market owner on each bond purchase (market owners must approve the\n///      Teller serving that market for the amount of Payout Tokens equivalent to the\n///      capacity of a market when created.\n///\n/// @author Oighty, Zeus, Potted Meat, indigo\nabstract contract BondBaseCallback is IBondCallback, Ownable, ReentrancyGuard {\n    using TransferHelper for ERC20;\n\n    /* ========== ERRORS ========== */\n\n    error Callback_MarketNotSupported(uint256 id);\n    error Callback_TokensNotReceived();\n    error Callback_TellerMismatch();\n\n    /* ========== STATE VARIABLES ========== */\n\n    mapping(address => mapping(uint256 => bool)) public approvedMarkets;\n    mapping(uint256 => uint256[2]) internal _amountsPerMarket;\n    mapping(ERC20 => uint256) internal priorBalances;\n    IBondAggregator internal _aggregator;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(IBondAggregator aggregator_) {\n        _aggregator = aggregator_;\n    }\n\n    /* ========== WHITELISTING ========== */\n\n    /// @inheritdoc IBondCallback\n    function whitelist(address teller_, uint256 id_) external override onlyOwner {\n        // Check that the market id is a valid, live market on the aggregator\n        try _aggregator.isLive(id_) returns (bool live) {\n            if (!live) revert Callback_MarketNotSupported(id_);\n        } catch {\n            revert Callback_MarketNotSupported(id_);\n        }\n\n        // Check that the provided teller is the teller for the market ID on the stored aggregator\n        // We could pull the teller from the aggregator, but requiring the teller to be passed in\n        // is more explicit about which contract is being whitelisted\n        if (teller_ != address(_aggregator.getTeller(id_))) revert Callback_TellerMismatch();\n\n        approvedMarkets[teller_][id_] = true;\n    }\n\n    /* ========== CALLBACK ========== */\n\n    /// @inheritdoc IBondCallback\n    function callback(\n        uint256 id_,\n        uint256 inputAmount_,\n        uint256 outputAmount_\n    ) external override nonReentrant {\n        /// Confirm that the teller and market id are whitelisted\n        if (!approvedMarkets[msg.sender][id_]) revert Callback_MarketNotSupported(id_);\n\n        // Get tokens for market\n        (, , ERC20 payoutToken, ERC20 quoteToken, , ) = _aggregator\n            .getAuctioneer(id_)\n            .getMarketInfoForPurchase(id_);\n\n        // Check that quoteTokens were transferred prior to the call\n        if (quoteToken.balanceOf(address(this)) < priorBalances[quoteToken] + inputAmount_)\n            revert Callback_TokensNotReceived();\n\n        // Call internal _callback function to handle implementation-specific logic\n        /// @dev must implement _callback in contracts that inherit this base\n        _callback(id_, quoteToken, inputAmount_, payoutToken, outputAmount_);\n\n        // Store amounts in/out\n        /// @dev updated after internal call so previous balances are available to check against\n        priorBalances[quoteToken] = quoteToken.balanceOf(address(this));\n        priorBalances[payoutToken] = payoutToken.balanceOf(address(this));\n        _amountsPerMarket[id_][0] += inputAmount_;\n        _amountsPerMarket[id_][1] += outputAmount_;\n    }\n\n    /// @notice              Implementation-specific callback logic\n    /// @dev                 Must be implemented by inheriting contract. Called from callback.\n    /// @param id_           ID of the market\n    /// @param quoteToken_   Address of the market quote token\n    /// @param inputAmount_  Amount of quote tokens expected to have been sent to the callback\n    /// @param payoutToken_    Address of the market payout token\n    /// @param outputAmount_ Amount of payout tokens to be paid out\n    function _callback(\n        uint256 id_,\n        ERC20 quoteToken_,\n        uint256 inputAmount_,\n        ERC20 payoutToken_,\n        uint256 outputAmount_\n    ) internal virtual;\n\n    /// @inheritdoc IBondCallback\n    function amountsForMarket(uint256 id_)\n        external\n        view\n        override\n        returns (uint256 in_, uint256 out_)\n    {\n        uint256[2] memory marketAmounts = _amountsPerMarket[id_];\n        return (marketAmounts[0], marketAmounts[1]);\n    }\n\n    /// @notice         Withdraw tokens from the callback and update balances\n    /// @notice         Only callback owner\n    /// @param to_      Address of the recipient\n    /// @param token_   Address of the token to withdraw\n    /// @param amount_  Amount of tokens to withdraw\n    function withdraw(\n        address to_,\n        ERC20 token_,\n        uint256 amount_\n    ) external onlyOwner {\n        token_.safeTransfer(to_, amount_);\n        priorBalances[token_] = token_.balanceOf(address(this));\n    }\n\n    /// @notice         Deposit tokens to the callback and update balances\n    /// @notice         Only callback owner\n    /// @param token_   Address of the token to deposit\n    /// @param amount_  Amount of tokens to deposit\n    function deposit(ERC20 token_, uint256 amount_) external onlyOwner {\n        token_.safeTransferFrom(msg.sender, address(this), amount_);\n        priorBalances[token_] = token_.balanceOf(address(this));\n    }\n}"
    },
    {
      "filename": "src/bases/BondBaseCallback.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {Ownable} from \"openzeppelin/access/Ownable.sol\";\nimport {TransferHelper} from \"../lib/TransferHelper.sol\";\n\nimport {IBondCallback} from \"../interfaces/IBondCallback.sol\";\nimport {IBondAggregator} from \"../interfaces/IBondAggregator.sol\";\n\n/// @title Bond Callback\n/// @notice Bond Callback Base Contract\n/// @dev Bond Protocol is a system to create Olympus-style bond markets\n///      for any token pair. The markets do not require maintenance and will manage\n///      bond prices based on activity. Bond issuers create BondMarkets that pay out\n///      a Payout Token in exchange for deposited Quote Tokens. Users can purchase\n///      future-dated Payout Tokens with Quote Tokens at the current market price and\n///      receive Bond Tokens to represent their position while their bond vests.\n///      Once the Bond Tokens vest, they can redeem it for the Quote Tokens.\n///\n/// @dev The Callback contract is an optional feature of the Bond system.\n///      Callbacks allow issuers (market creators) to apply custom logic on receipt and\n///      payout of tokens. The Callback must be created prior to market creation and\n///      the address passed in as an argument. The Callback depends on the Aggregator\n///      contract for the Auctioneer that the market is created to get market data.\n///\n/// @dev Without a Callback contract, payout tokens are transferred directly from\n///      the market owner on each bond purchase (market owners must approve the\n///      Teller serving that market for the amount of Payout Tokens equivalent to the\n///      capacity of a market when created.\n///\n/// @author Oighty, Zeus, Potted Meat, indigo\nabstract contract BondBaseCallback is IBondCallback, Ownable, ReentrancyGuard {\n    using TransferHelper for ERC20;\n\n    /* ========== ERRORS ========== */\n\n    error Callback_MarketNotSupported(uint256 id);\n    error Callback_TokensNotReceived();\n    error Callback_TellerMismatch();\n\n    /* ========== STATE VARIABLES ========== */\n\n    mapping(address => mapping(uint256 => bool)) public approvedMarkets;\n    mapping(uint256 => uint256[2]) internal _amountsPerMarket;\n    mapping(ERC20 => uint256) internal priorBalances;\n    IBondAggregator internal _aggregator;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(IBondAggregator aggregator_) {\n        _aggregator = aggregator_;\n    }\n\n    /* ========== WHITELISTING ========== */\n\n    /// @inheritdoc IBondCallback\n    function whitelist(address teller_, uint256 id_) external override onlyOwner {\n        // Check that the market id is a valid, live market on the aggregator\n        try _aggregator.isLive(id_) returns (bool live) {\n            if (!live) revert Callback_MarketNotSupported(id_);\n        } catch {\n            revert Callback_MarketNotSupported(id_);\n        }\n\n        // Check that the provided teller is the teller for the market ID on the stored aggregator\n        // We could pull the teller from the aggregator, but requiring the teller to be passed in\n        // is more explicit about which contract is being whitelisted\n        if (teller_ != address(_aggregator.getTeller(id_))) revert Callback_TellerMismatch();\n\n        approvedMarkets[teller_][id_] = true;\n    }\n\n    /* ========== CALLBACK ========== */\n\n    /// @inheritdoc IBondCallback\n    function callback(\n        uint256 id_,\n        uint256 inputAmount_,\n        uint256 outputAmount_\n    ) external override nonReentrant {\n        /// Confirm that the teller and market id are whitelisted\n        if (!approvedMarkets[msg.sender][id_]) revert Callback_MarketNotSupported(id_);\n\n        // Get tokens for market\n        (, , ERC20 payoutToken, ERC20 quoteToken, , ) = _aggregator\n            .getAuctioneer(id_)\n            .getMarketInfoForPurchase(id_);\n\n        // Check that quoteTokens were transferred prior to the call\n        if (quoteToken.balanceOf(address(this)) < priorBalances[quoteToken] + inputAmount_)\n            revert Callback_TokensNotReceived();\n\n        // Call internal _callback function to handle implementation-specific logic\n        /// @dev must implement _callback in contracts that inherit this base\n        _callback(id_, quoteToken, inputAmount_, payoutToken, outputAmount_);\n\n        // Store amounts in/out\n        /// @dev updated after internal call so previous balances are available to check against\n        priorBalances[quoteToken] = quoteToken.balanceOf(address(this));\n        priorBalances[payoutToken] = payoutToken.balanceOf(address(this));\n        _amountsPerMarket[id_][0] += inputAmount_;\n        _amountsPerMarket[id_][1] += outputAmount_;\n    }\n\n    /// @notice              Implementation-specific callback logic\n    /// @dev                 Must be implemented by inheriting contract. Called from callback.\n    /// @param id_           ID of the market\n    /// @param quoteToken_   Address of the market quote token\n    /// @param inputAmount_  Amount of quote tokens expected to have been sent to the callback\n    /// @param payoutToken_    Address of the market payout token\n    /// @param outputAmount_ Amount of payout tokens to be paid out\n    function _callback(\n        uint256 id_,\n        ERC20 quoteToken_,\n        uint256 inputAmount_,\n        ERC20 payoutToken_,\n        uint256 outputAmount_\n    ) internal virtual;\n\n    /// @inheritdoc IBondCallback\n    function amountsForMarket(uint256 id_)\n        external\n        view\n        override\n        returns (uint256 in_, uint256 out_)\n    {\n        uint256[2] memory marketAmounts = _amountsPerMarket[id_];\n        return (marketAmounts[0], marketAmounts[1]);\n    }\n\n    /// @notice         Withdraw tokens from the callback and update balances\n    /// @notice         Only callback owner\n    /// @param to_      Address of the recipient\n    /// @param token_   Address of the token to withdraw\n    /// @param amount_  Amount of tokens to withdraw\n    function withdraw(\n        address to_,\n        ERC20 token_,\n        uint256 amount_\n    ) external onlyOwner {\n        token_.safeTransfer(to_, amount_);\n        priorBalances[token_] = token_.balanceOf(address(this));\n    }\n\n    /// @notice         Deposit tokens to the callback and update balances\n    /// @notice         Only callback owner\n    /// @param token_   Address of the token to deposit\n    /// @param amount_  Amount of tokens to deposit\n    function deposit(ERC20 token_, uint256 amount_) external onlyOwner {\n        token_.safeTransferFrom(msg.sender, address(this), amount_);\n        priorBalances[token_] = token_.balanceOf(address(this));\n    }\n}"
    }
  ]
}