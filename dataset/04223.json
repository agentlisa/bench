{
  "Title": "[C02] Updating or removing a service type causes critical accounting errors",
  "Content": "Updating or removing a service type after a service provider has registered an endpoint of that type can result in critical accounting errors. These errors can have serious effects, including preventing service providers from deregistering endpoints and preventing delegators from undelegating their stake.\n\n\nWhen a service provider registers or deregisters an endpoint, the `ServiceProviderFactory` contract tracks the required bounds within which a service provider’s stake must remain. These bounds are tracked in a [`ServiceProviderDetails` struct](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ServiceProviderFactory.sol#L26-L33) in the `ServiceProviderFactory` contract, and are referred to as the [`minAccountStake`](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ServiceProviderFactory.sol#L31) and [`maxAccountStake`](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ServiceProviderFactory.sol#L32). These bounds are determined by the `minStake` and `maxStake` of the service type’s [`ServiceTypeStakeRequirements` struct](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ServiceTypeManager.sol#L25-L28), which is tracked in the `ServiceTypeManager` contract.\n\n\nHowever, when governance updates the `minStake` or `maxStake` of an endpoint — either via the [`updateServiceType` function](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ServiceTypeManager.sol#L123) or the [`removeServiceType` function](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ServiceTypeManager.sol#L123) — the `minAccountStake` and `maxAccountStake` for a given service provider that has already registered an endpoint of that type are *not* automatically updated.\n\n\nThis can result in critical accounting errors. Here are two examples.\n\n\nExample 1. Increasing a service type’s `minStake` or `maxStake` can result in a service provider being unable to deregister an endpoint:\n\n\nSuppose a service provider registers exactly one endpoint. Then suppose governance increases either the `minStake` or `maxStake` for that service type. Then when the service provider attempts to deregister their endpoint, their call to the `deregister` function will revert [on line 287](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ServiceProviderFactory.sol#L287) or [on line 288](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ServiceProviderFactory.sol#L288) due to an underflow in `.sub`.\n\n\nExample 2. Decreasing a service type’s `minStake` can result in a delegator being unable to undelegate all of their stake:\n\n\nSuppose a service provider registers an endpoint, and suppose a delegator delegates to that service provider. Then suppose governance decreases the `minStake` for that service type — either via the [`updateServiceType` function](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ServiceTypeManager.sol#L123) or the [`removeServiceType` function](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ServiceTypeManager.sol#L123). Then when the service provider deregisters the endpoint, the `deregister` function sets the `minAccountStake` to a value greater than `0` [on line 287](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ServiceProviderFactory.sol#L287). This means that when the delegator tries to undelegate all of their stake, their call to the `undelegateStake` function will revert [on line 311](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/DelegateManager.sol#L311), because the `validateAccountStakeBalance` function [calls the `_validateBalanceInternal` function](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ServiceProviderFactory.sol#L674), [which requires](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ServiceProviderFactory.sol#L776) that `amount` (which will be `0`) is at least `spDetails[_sp].minAccountStake` (which will be greater than `0`).\n\n\nConsider removing the ability for governance to upgrade or remove service types. Instead, consider indicating the version of the service type in the service type’s name (e.g.: `\"ServiceType1-v1\"`) and using a `bool` to flag whether the service type is still “active” and can be registered by service providers.\n\n\n***Update**: Fixed in [pull request #555](https://github.com/AudiusProject/audius-protocol/pull/555/files). The ability to update an existing service type was removed.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "eth-contracts/contracts/ServiceProviderFactory.sol",
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\nimport \"./ServiceTypeManager.sol\";\nimport \"./ClaimsManager.sol\";\nimport \"./Staking.sol\";\n\n\ncontract ServiceProviderFactory is InitializableV2 {\n    using SafeMath for uint;\n\n    address private stakingAddress;\n    address private delegateManagerAddress;\n    address private governanceAddress;\n    address private serviceTypeManagerAddress;\n    address private claimsManagerAddress;\n    uint private decreaseStakeLockupDuration;\n\n    /// @dev - Stores following entities\n    ///        1) Directly staked amount by SP, not including delegators\n    ///        2) % Cut of delegator tokens taken during reward\n    ///        3) Bool indicating whether this SP has met min/max requirements\n    ///        4) Number of endpoints registered by SP\n    ///        5) Minimum total stake for this account\n    ///        6) Maximum total stake for this account\n    struct ServiceProviderDetails {\n        uint deployerStake;\n        uint deployerCut;\n        bool validBounds;\n        uint numberOfEndpoints;\n        uint minAccountStake;\n        uint maxAccountStake;\n    }\n\n    /// @dev - Data structure for time delay during withdrawal\n    struct DecreaseStakeRequest {\n        uint decreaseAmount;\n        uint lockupExpiryBlock;\n    }\n\n    /// @dev - Mapping of service provider address to details\n    mapping(address => ServiceProviderDetails) spDetails;\n\n    /// @dev - Minimum staked by service provider account deployer\n    /// @dev - Static regardless of total number of endpoints for a given account\n    uint minDeployerStake;\n\n    /// @dev - standard - imitates relationship between Ether and Wei\n    uint8 private constant DECIMALS = 18;\n\n    /// @dev - denominator for deployer cut calculations\n    /// @dev - user values are intended to be x/DEPLOYER_CUT_BASE\n    uint private constant DEPLOYER_CUT_BASE = 100;\n\n    /// @dev - Struct maintaining information about sp\n    /// @dev - blocknumber is block.number when endpoint registered\n    struct ServiceEndpoint {\n        address owner;\n        string endpoint;\n        uint blocknumber;\n        address delegateOwnerWallet;\n    }\n\n    /// @dev - Uniquely assigned serviceProvider ID, incremented for each service type\n    /// @notice - Keeps track of the total number of services registered regardless of\n    ///           whether some have been deregistered since\n    mapping(bytes32 => uint) serviceProviderTypeIDs;\n\n    /// @dev - mapping of (serviceType -> (serviceInstanceId <-> serviceProviderInfo))\n    /// @notice - stores the actual service provider data like endpoint and owner wallet\n    ///           with the ability lookup by service type and service id */\n    mapping(bytes32 => mapping(uint => ServiceEndpoint)) serviceProviderInfo;\n\n    /// @dev - mapping of keccak256(endpoint) to uint ID\n    /// @notice - used to check if a endpoint has already been registered and also lookup\n    /// the id of an endpoint\n    mapping(bytes32 => uint) serviceProviderEndpointToId;\n\n    /// @dev - mapping of address -> sp id array */\n    /// @notice - stores all the services registered by a provider. for each address,\n    /// provides the ability to lookup by service type and see all registered services\n    mapping(address => mapping(bytes32 => uint[])) serviceProviderAddressToId;\n\n    /// @dev - Mapping of service provider -> decrease stake request\n    mapping(address => DecreaseStakeRequest) decreaseStakeRequests;\n\n    event RegisteredServiceProvider(\n      uint _spID,\n      bytes32 _serviceType,\n      address _owner,\n      string _endpoint,\n      uint256 _stakeAmount\n    );\n\n    event DeregisteredServiceProvider(\n      uint _spID,\n      bytes32 _serviceType,\n      address _owner,\n      string _endpoint,\n      uint256 _unstakeAmount\n    );\n\n    event UpdatedStakeAmount(\n      address _owner,\n      uint256 _stakeAmount\n    );\n\n    event UpdateEndpoint(\n      bytes32 _serviceType,\n      address _owner,\n      string _oldEndpoint,\n      string _newEndpoint,\n      uint spId\n    );\n\n    /**\n     * @notice Function to initialize the contract\n     * @param _governanceAddress - Governance proxy address\n     */\n    function initialize (address _governanceAddress) public initializer\n    {\n        governanceAddress = _governanceAddress;\n\n        // Configure direct minimum stake for deployer\n        minDeployerStake = 5 * 10**uint256(DECIMALS);\n\n        // 10 blocks for lockup duration\n        decreaseStakeLockupDuration = 10;\n\n        InitializableV2.initialize();\n    }\n\n    /**\n     * @notice Register a new endpoint to the account of msg.sender\n     * @dev Transfers stake from service provider into staking pool\n     * @param _serviceType - type of service to register, must be valid in ServiceTypeManager\n     * @param _endpoint - url of the service to register - url of the service to register\n     * @param _stakeAmount - amount to stake, must be within bounds in ServiceTypeManager\n     * @param _delegateOwnerWallet - wallet to delegate some permissions for some basic management properties\n     */\n    function register(\n        bytes32 _serviceType,\n        string calldata _endpoint,\n        uint256 _stakeAmount,\n        address _delegateOwnerWallet\n    ) external returns (uint spID)\n    {\n        _requireIsInitialized();\n        require(serviceTypeManagerAddress != address(0x00), \"serviceTypeManagerAddress not set\");\n        require(stakingAddress != address(0x00), \"stakingAddress not set\");\n\n        require(\n            ServiceTypeManager(serviceTypeManagerAddress).serviceTypeIsValid(_serviceType),\n            \"Valid service type required\");\n\n        // Stake token amount from msg.sender\n        if (_stakeAmount > 0) {\n            require(!_claimPending(msg.sender), \"No claim expected to be pending prior to stake transfer\");\n            Staking(stakingAddress).stakeFor(msg.sender, _stakeAmount);\n        }\n\n        require (\n            serviceProviderEndpointToId[keccak256(bytes(_endpoint))] == 0,\n            \"Endpoint already registered\");\n\n        uint newServiceProviderID = serviceProviderTypeIDs[_serviceType].add(1);\n        serviceProviderTypeIDs[_serviceType] = newServiceProviderID;\n\n        // Index spInfo\n        serviceProviderInfo[_serviceType][newServiceProviderID] = ServiceEndpoint({\n            owner: msg.sender,\n            endpoint: _endpoint,\n            blocknumber: block.number,\n            delegateOwnerWallet: _delegateOwnerWallet\n        });\n\n        // Update endpoint mapping\n        serviceProviderEndpointToId[keccak256(bytes(_endpoint))] = newServiceProviderID;\n\n        // Update (address -> type -> ids[])\n        serviceProviderAddressToId[msg.sender][_serviceType].push(newServiceProviderID);\n\n        // Increment number of endpoints for this address\n        spDetails[msg.sender].numberOfEndpoints = spDetails[msg.sender].numberOfEndpoints.add(1);\n\n        // Update deployer total\n        spDetails[msg.sender].deployerStake = (\n            spDetails[msg.sender].deployerStake.add(_stakeAmount)\n        );\n\n        // Update min and max totals for this service provider\n        (uint typeMin, uint typeMax) = ServiceTypeManager(\n            serviceTypeManagerAddress\n        ).getServiceTypeStakeInfo(_serviceType);\n        spDetails[msg.sender].minAccountStake = spDetails[msg.sender].minAccountStake.add(typeMin);\n        spDetails[msg.sender].maxAccountStake = spDetails[msg.sender].maxAccountStake.add(typeMax);\n\n        // Confirm both aggregate account balance and directly staked amount are valid\n        this.validateAccountStakeBalance(msg.sender);\n        uint currentlyStakedForOwner = Staking(stakingAddress).totalStakedFor(msg.sender);\n\n\n        // Indicate this service provider is within bounds\n        spDetails[msg.sender].validBounds = true;\n\n        emit RegisteredServiceProvider(\n            newServiceProviderID,\n            _serviceType,\n            msg.sender,\n            _endpoint,\n            currentlyStakedForOwner\n        );\n\n        return newServiceProviderID;\n    }\n\n    /**\n     * @notice Deregister an endpoint from the account of msg.sender\n     * @dev Unstakes all tokens for service provider if this is the last endpoint\n     * @param _serviceType - type of service to deregister\n     * @param _endpoint - endpoint to deregister\n     * @return spId of the service that was deregistered\n     */\n    function deregister(\n        bytes32 _serviceType,\n        string calldata _endpoint\n    ) external returns (uint deregisteredSpID)\n    {\n        _requireIsInitialized();\n\n        // Unstake on deregistration if and only if this is the last service endpoint\n        uint unstakeAmount = 0;\n        bool unstaked = false;\n        // owned by the service provider\n        if (spDetails[msg.sender].numberOfEndpoints == 1) {\n            unstakeAmount = spDetails[msg.sender].deployerStake;\n\n            // Submit request to decrease stake, overriding any pending request\n            decreaseStakeRequests[msg.sender] = DecreaseStakeRequest({\n                decreaseAmount: unstakeAmount,\n                lockupExpiryBlock: block.number.add(decreaseStakeLockupDuration)\n            });\n\n            unstaked = true;\n        }\n\n        require (\n            serviceProviderEndpointToId[keccak256(bytes(_endpoint))] != 0,\n            \"Endpoint not registered\");\n\n        // Cache invalided service provider ID\n        uint deregisteredID = serviceProviderEndpointToId[keccak256(bytes(_endpoint))];\n\n        // Update endpoint mapping\n        serviceProviderEndpointToId[keccak256(bytes(_endpoint))] = 0;\n\n        require(\n            keccak256(bytes(serviceProviderInfo[_serviceType][deregisteredID].endpoint)) == keccak256(bytes(_endpoint)),\n            \"Invalid endpoint for service type\");\n\n        require (\n            serviceProviderInfo[_serviceType][deregisteredID].owner == msg.sender,\n            \"Only callable by endpoint owner\");\n\n        // Update info mapping\n        delete serviceProviderInfo[_serviceType][deregisteredID];\n        // Reset id, update array\n        uint spTypeLength = serviceProviderAddressToId[msg.sender][_serviceType].length;\n        for (uint i = 0; i < spTypeLength; i ++) {\n            if (serviceProviderAddressToId[msg.sender][_serviceType][i] == deregisteredID) {\n                // Overwrite element to be deleted with last element in array\n                serviceProviderAddressToId[msg.sender][_serviceType][i] = serviceProviderAddressToId[msg.sender][_serviceType][spTypeLength - 1];\n                // Reduce array size, exit loop\n                serviceProviderAddressToId[msg.sender][_serviceType].length--;\n                // Confirm this ID has been found for the service provider\n                break;\n            }\n        }\n\n        // Decrement number of endpoints for this address\n        spDetails[msg.sender].numberOfEndpoints -= 1;\n\n        // Update min and max totals for this service provider\n        (uint typeMin, uint typeMax) = ServiceTypeManager(\n            serviceTypeManagerAddress\n        ).getServiceTypeStakeInfo(_serviceType);\n        spDetails[msg.sender].minAccountStake = spDetails[msg.sender].minAccountStake.sub(typeMin);\n        spDetails[msg.sender].maxAccountStake = spDetails[msg.sender].maxAccountStake.sub(typeMax);\n\n        emit DeregisteredServiceProvider(\n            deregisteredID,\n            _serviceType,\n            msg.sender,\n            _endpoint,\n            unstakeAmount);\n\n        // Confirm both aggregate account balance and directly staked amount are valid\n        // Only if unstake operation has not occurred\n        if (!unstaked) {\n            this.validateAccountStakeBalance(msg.sender);\n            // Indicate this service provider is within bounds\n            spDetails[msg.sender].validBounds = true;\n        }\n\n        return deregisteredID;\n    }\n\n    /**\n     * @notice Increase stake for service provider\n     * @param _increaseStakeAmount - amount to increase staked amount by\n     * @return New total stake for service provider\n     */\n    function increaseStake(\n        uint256 _increaseStakeAmount\n    ) external returns (uint newTotalStake)\n    {\n        _requireIsInitialized();\n\n        // Confirm owner has an endpoint\n        require(\n            spDetails[msg.sender].numberOfEndpoints > 0,\n            \"Registered endpoint required to increase stake\"\n        );\n        require(\n            !_claimPending(msg.sender),\n            \"No claim expected to be pending prior to stake transfer\"\n        );\n\n        Staking stakingContract = Staking(\n            stakingAddress\n        );\n\n        // Stake increased token amount for msg.sender\n        stakingContract.stakeFor(msg.sender, _increaseStakeAmount);\n\n        uint newStakeAmount = stakingContract.totalStakedFor(msg.sender);\n\n        // Update deployer total\n        spDetails[msg.sender].deployerStake = (\n            spDetails[msg.sender].deployerStake.add(_increaseStakeAmount)\n        );\n\n        // Confirm both aggregate account balance and directly staked amount are valid\n        this.validateAccountStakeBalance(msg.sender);\n\n        // Indicate this service provider is within bounds\n        spDetails[msg.sender].validBounds = true;\n\n        emit UpdatedStakeAmount(\n            msg.sender,\n            newStakeAmount\n        );\n\n        return newStakeAmount;\n    }\n\n    /**\n     * @notice Request to decrease stake. This sets a lockup for decreaseStakeLockupDuration after\n               which the actual decreaseStake can be called\n     * @dev Decreasing stake is only processed in a service provider is within valid bounds\n     * @param _decreaseStakeAmount - amount to decrease stake by in wei\n     * @return New total stake amount after the lockup\n     */\n    function requestDecreaseStake(uint _decreaseStakeAmount)\n    external returns (uint newStakeAmount)\n    {\n        _requireIsInitialized();\n        require(\n            !_claimPending(msg.sender),\n            \"No claim expected to be pending prior to stake transfer\"\n        );\n\n        Staking stakingContract = Staking(\n            stakingAddress\n        );\n\n        uint currentStakeAmount = stakingContract.totalStakedFor(msg.sender);\n\n        // Prohibit decreasing stake to invalid bounds\n        _validateBalanceInternal(msg.sender, (currentStakeAmount.sub(_decreaseStakeAmount)));\n\n        decreaseStakeRequests[msg.sender] = DecreaseStakeRequest({\n            decreaseAmount: _decreaseStakeAmount,\n            lockupExpiryBlock: block.number.add(decreaseStakeLockupDuration)\n        });\n\n        return currentStakeAmount.sub(_decreaseStakeAmount);\n    }\n\n    /**\n     * @notice Cancel a decrease stake request during the lockup\n     * @dev Either called by the service provider via DelegateManager or governance\n            during a slash action\n     * @param _account - address of service provider\n     */\n    function cancelDecreaseStakeRequest(address _account) external\n    {\n        require(\n            msg.sender == _account || msg.sender == delegateManagerAddress,\n            \"Only callable from owner or DelegateManager\"\n        );\n        require(_decreaseRequestIsPending(_account), \"Decrease stake request must be pending\");\n\n        // Clear decrease stake request\n        decreaseStakeRequests[_account] = DecreaseStakeRequest({\n            decreaseAmount: 0,\n            lockupExpiryBlock: 0\n        });\n    }\n\n    /**\n     * @notice Actually decrease a stake. Must have called requestDecreaseStake and waited for the\n               lockup period to expire\n     * @return New total stake after decrease\n     */\n    function decreaseStake() external returns (uint newTotalStake)\n    {\n        _requireIsInitialized();\n\n        require(_decreaseRequestIsPending(msg.sender), \"Decrease stake request must be pending\");\n        require(\n            decreaseStakeRequests[msg.sender].lockupExpiryBlock <= block.number,\n            \"Lockup must be expired\"\n        );\n\n        Staking stakingContract = Staking(\n            stakingAddress\n        );\n\n        // Decrease staked token amount for msg.sender\n        stakingContract.unstakeFor(msg.sender, decreaseStakeRequests[msg.sender].decreaseAmount);\n\n        // Query current stake\n        uint newStakeAmount = stakingContract.totalStakedFor(msg.sender);\n\n        // Update deployer total\n        spDetails[msg.sender].deployerStake = (\n            spDetails[msg.sender].deployerStake.sub(decreaseStakeRequests[msg.sender].decreaseAmount)\n        );\n\n        // Confirm both aggregate account balance and directly staked amount are valid\n        // During registration this validation is bypassed since no endpoints remain\n        if (spDetails[msg.sender].numberOfEndpoints > 0) {\n            this.validateAccountStakeBalance(msg.sender);\n        }\n\n        // Indicate this service provider is within bounds\n        spDetails[msg.sender].validBounds = true;\n\n        // Clear decrease stake request\n        delete decreaseStakeRequests[msg.sender];\n\n        emit UpdatedStakeAmount(\n            msg.sender,\n            newStakeAmount\n        );\n\n        return newStakeAmount;\n    }\n\n    /**\n     * @notice Update delegate owner wallet for a given endpoint\n     * @param _serviceType - type of service to register, must be valid in ServiceTypeManager\n     * @param _endpoint - url of the service to register - url of the service to register\n     * @param _updatedDelegateOwnerWallet - address of new delegate wallet\n     */\n    function updateDelegateOwnerWallet(\n        bytes32 _serviceType,\n        string calldata _endpoint,\n        address _updatedDelegateOwnerWallet\n    ) external\n    {\n        uint spID = this.getServiceProviderIdFromEndpoint(_endpoint);\n\n        require(\n            serviceProviderInfo[_serviceType][spID].owner == msg.sender,\n            \"Invalid update operation, wrong owner\");\n\n        serviceProviderInfo[_serviceType][spID].delegateOwnerWallet = _updatedDelegateOwnerWallet;\n    }\n\n    /**\n     * @notice Update the endpoint for a given service\n     * @param _serviceType - type of service to register, must be valid in ServiceTypeManager\n     * @param _oldEndpoint - old endpoint currently registered\n     * @param _oldEndpoint - new endpoint to replace old endpoint\n     */\n    function updateEndpoint(\n        bytes32 _serviceType,\n        string calldata _oldEndpoint,\n        string calldata _newEndpoint\n    ) external returns (uint spID)\n    {\n        uint spId = this.getServiceProviderIdFromEndpoint(_oldEndpoint);\n\n        require (spId != 0, \"Could not find service provider with that endpoint\");\n\n        ServiceEndpoint memory sp = serviceProviderInfo[_serviceType][spId];\n\n        require(sp.owner == msg.sender,\"Invalid update endpoint operation, wrong owner\");\n\n        require(\n            keccak256(bytes(sp.endpoint)) == keccak256(bytes(_oldEndpoint)),\n            \"Old endpoint doesn't match what's registered for the service provider\"\n        );\n\n        // invalidate old endpoint\n        serviceProviderEndpointToId[keccak256(bytes(sp.endpoint))] = 0;\n\n        // update to new endpoint\n        sp.endpoint = _newEndpoint;\n        serviceProviderInfo[_serviceType][spId] = sp;\n        serviceProviderEndpointToId[keccak256(bytes(_newEndpoint))] = spId;\n        return spId;\n    }\n\n    /**\n     * @notice Update service provider balance\n     * @dev Called by DelegateManager by functions modifying entire stake like claim and slash\n     * @param _serviceProvider - address of service provider\n     * @param _amount - new amount of direct state for service provider\n     */\n    function updateServiceProviderStake(\n        address _serviceProvider,\n        uint _amount\n     ) external\n    {\n        require(delegateManagerAddress != address(0x00), \"delegateManagerAddress not set\");\n        require(\n            msg.sender == delegateManagerAddress,\n            \"updateServiceProviderStake - only callable by DelegateManager\"\n        );\n        // Update SP tracked total\n        spDetails[_serviceProvider].deployerStake = _amount;\n        _updateServiceProviderBoundStatus(_serviceProvider);\n    }\n\n    /**\n     * @notice Update service provider cut of claims\n     * @notice Update service provider cut as % of delegate claim, divided by the deployerCutBase.\n     * @dev SPs will interact with this value as a percent, value translation done client side\n       @dev A value of 5 dictates a 5% cut, with ( 5 / 100 ) * delegateReward going to an SP from each delegator each round.\n     * @param _serviceProvider - address of service provider\n     * @param _cut - new deployer cut value\n     */\n    function updateServiceProviderCut(\n        address _serviceProvider,\n        uint _cut\n    ) external\n    {\n        require(\n            msg.sender == _serviceProvider,\n            \"Service Provider cut update operation restricted to deployer\");\n\n        require(\n            _cut <= DEPLOYER_CUT_BASE,\n            \"Service Provider cut cannot exceed base value\");\n        spDetails[_serviceProvider].deployerCut = _cut;\n    }\n\n    /// @notice Update service provider lockup duration\n    function updateDecreaseStakeLockupDuration(uint _duration) external {\n        _requireIsInitialized();\n\n        require(\n            msg.sender == governanceAddress,\n            \"Only callable by Governance contract\"\n        );\n\n        decreaseStakeLockupDuration = _duration;\n    }\n\n    /// @notice Get denominator for deployer cut calculations\n    function getServiceProviderDeployerCutBase()\n    external pure returns (uint base)\n    {\n        return DEPLOYER_CUT_BASE;\n    }\n\n    /// @notice Get total number of service providers for a given serviceType\n    function getTotalServiceTypeProviders(bytes32 _serviceType)\n    external view returns (uint numberOfProviders)\n    {\n        return serviceProviderTypeIDs[_serviceType];\n    }\n\n    /// @notice Get service provider id for an endpoint\n    function getServiceProviderIdFromEndpoint(string calldata _endpoint)\n    external view returns (uint spID)\n    {\n        return serviceProviderEndpointToId[keccak256(bytes(_endpoint))];\n    }\n\n    /// @notice Get minDeployerStake\n    function getMinDeployerStake()\n    external view returns (uint min)\n    {\n        return minDeployerStake;\n    }\n\n    /**\n     * @notice Get service provider ids for a given service provider and service type\n     * @return List of service ids of that type for a service provider\n     */\n    function getServiceProviderIdsFromAddress(address _ownerAddress, bytes32 _serviceType)\n    external view returns (uint[] memory spIds)\n    {\n        return serviceProviderAddressToId[_ownerAddress][_serviceType];\n    }\n\n    /**\n     * @notice Get information about a service endpoint given its service id\n     * @param _serviceType - type of service, must be a valid service from ServiceTypeManager\n     * @param _serviceId - id of service\n     */\n    function getServiceEndpointInfo(bytes32 _serviceType, uint _serviceId)\n    external view returns (address owner, string memory endpoint, uint blockNumber, address delegateOwnerWallet)\n    {\n        ServiceEndpoint memory sp = serviceProviderInfo[_serviceType][_serviceId];\n        return (sp.owner, sp.endpoint, sp.blocknumber, sp.delegateOwnerWallet);\n    }\n\n    /**\n     * @notice Get information about a service provider given their address\n     * @param _sp - address of service provider\n     */\n    function getServiceProviderDetails(address _sp)\n    external view returns (\n        uint deployerStake,\n        uint deployerCut,\n        bool validBounds,\n        uint numberOfEndpoints,\n        uint minAccountStake,\n        uint maxAccountStake)\n    {\n        return (\n            spDetails[_sp].deployerStake,\n            spDetails[_sp].deployerCut,\n            spDetails[_sp].validBounds,\n            spDetails[_sp].numberOfEndpoints,\n            spDetails[_sp].minAccountStake,\n            spDetails[_sp].maxAccountStake\n        );\n    }\n\n    /**\n     * @notice Get information about pending decrease stake requests for service provider\n     * @param _sp - address of service provider\n     */\n    function getPendingDecreaseStakeRequest(address _sp)\n    external view returns (uint amount, uint lockupExpiryBlock)\n    {\n        return (\n            decreaseStakeRequests[_sp].decreaseAmount,\n            decreaseStakeRequests[_sp].lockupExpiryBlock\n        );\n    }\n\n    /// @notice Get current unstake lockup duration\n    function getDecreaseStakeLockupDuration()\n    external view returns (uint duration)\n    {\n        return decreaseStakeLockupDuration;\n    }\n\n    /**\n     * @notice Validate that the total service provider balance is between the min and max stakes\n               for all their registered services and validate  direct stake for sp is above minimum\n     * @param _sp - address of service provider\n     */\n    function validateAccountStakeBalance(address _sp)\n    external view\n    {\n        _validateBalanceInternal(_sp, Staking(stakingAddress).totalStakedFor(_sp));\n    }\n\n    /// @notice Get the Governance address\n    function getGovernanceAddress() external view returns (address addr) {\n        return governanceAddress;\n    }\n\n    /// @notice Get the Staking address\n    function getStakingAddress() external view returns (address addr) {\n        return stakingAddress;\n    }\n\n    /// @notice Get the DelegateManager address\n    function getDelegateManagerAddress() external view returns (address addr) {\n        return delegateManagerAddress;\n    }\n\n    /// @notice Get the ServiceTypeManager address\n    function getServiceTypeManagerAddress() external view returns (address addr) {\n        return serviceTypeManagerAddress;\n    }\n\n    /// @notice Get the ClaimsManager address\n    function getClaimsManagerAddress() external view returns (address addr) {\n        return claimsManagerAddress;\n    }\n\n    /**\n     * @notice Set the Governance address\n     * @dev Only callable by Governance address\n     * @param _address - address for new Governance contract\n     */\n    function setGovernanceAddress(address _address) external {\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n        governanceAddress = _address;\n    }\n\n    /**\n     * @notice Set the Staking address\n     * @dev Only callable by Governance address\n     * @param _address - address for new Staking contract\n     */\n    function setStakingAddress(address _address) external {\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n        stakingAddress = _address;\n    }\n\n    /**\n     * @notice Set the DelegateManager address\n     * @dev Only callable by Governance address\n     * @param _address - address for new DelegateManager contract\n     */\n    function setDelegateManagerAddress(address _address) external {\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n        delegateManagerAddress = _address;\n    }\n\n    /**\n     * @notice Set the ServiceTypeManager address\n     * @dev Only callable by Governance address\n     * @param _address - address for new ServiceTypeManager contract\n     */\n    function setServiceTypeManagerAddress(address _address) external {\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n        serviceTypeManagerAddress = _address;\n    }\n\n    /**\n     * @notice Set the ClaimsManager address\n     * @dev Only callable by Governance address\n     * @param _address - address for new ClaimsManager contract\n     */\n    function setClaimsManagerAddress(address _address) external {\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n        claimsManagerAddress = _address;\n    }\n\n    /**\n     * @notice Update status in spDetails if the bounds for a service provider is valid\n     */\n    function _updateServiceProviderBoundStatus(address _serviceProvider) internal {\n        // Validate bounds for total stake\n        uint totalSPStake = Staking(stakingAddress).totalStakedFor(_serviceProvider);\n        if (totalSPStake < spDetails[_serviceProvider].minAccountStake ||\n            totalSPStake > spDetails[_serviceProvider].maxAccountStake) {\n            // Indicate this service provider is out of bounds\n            spDetails[_serviceProvider].validBounds = false;\n        } else {\n            // Indicate this service provider is within bounds\n            spDetails[_serviceProvider].validBounds = true;\n        }\n    }\n\n    /**\n     * @notice Compare a given amount input against valid min and max bounds for service provider\n     * @param _sp - address of service provider\n     * @param _amount - amount in wei to compare\n     */\n    function _validateBalanceInternal(address _sp, uint _amount) internal view\n    {\n        require(\n            _amount >= spDetails[_sp].minAccountStake,\n            \"Minimum stake requirement not met\");\n\n        require(\n            _amount <= spDetails[_sp].maxAccountStake,\n            \"Maximum stake amount exceeded\");\n\n        require(\n            spDetails[_sp].deployerStake == 0 || spDetails[_sp].deployerStake >= minDeployerStake,\n            \"Direct stake restriction violated for this service provider\");\n    }\n\n    /**\n     * @notice Get whether a decrease request has been initiated for service provider\n     * @param _serviceProvider - address of service provider\n     * return Boolean of whether decrease request has been initiated\n     */\n    function _decreaseRequestIsPending(address _serviceProvider)\n    internal view returns (bool pending)\n    {\n        return (\n            (decreaseStakeRequests[_serviceProvider].lockupExpiryBlock > 0) &&\n            (decreaseStakeRequests[_serviceProvider].decreaseAmount > 0)\n        );\n    }\n\n    /**\n     * @notice Boolean indicating whether a claim is pending for this service provider\n     */\n     /**\n     * @notice Get whether a claim is pending for this service provider\n     * @param _sp - address of service provider\n     * return Boolean of whether claim is pending\n     */\n    function _claimPending(address _sp) internal view returns (bool pending) {\n        return ClaimsManager(claimsManagerAddress).claimPending(_sp);\n    }\n}"
    },
    {
      "filename": "eth-contracts/contracts/ServiceTypeManager.sol",
      "content": "pragma solidity ^0.5.0;\n\nimport \"./InitializableV2.sol\";\n\n\ncontract ServiceTypeManager is InitializableV2 {\n    address governanceAddress;\n\n    /**\n     * @dev - mapping of serviceType - serviceTypeVersion\n     * Example - \"discovery-provider\" - [\"0.0.1\", \"0.0.2\", ..., \"currentVersion\"]\n     */\n    mapping(bytes32 => bytes32[]) public serviceTypeVersions;\n\n    /**\n     * @dev - mapping of serviceType - < serviceTypeVersion, isValid >\n     * Example - \"discovery-provider\" - <\"0.0.1\", true>\n     */\n    mapping(bytes32 => mapping(bytes32 => bool)) public serviceTypeVersionInfo;\n\n    /// @dev List of valid service types\n    bytes32[] private validServiceTypes;\n\n    /// @dev Struct representing service type stake requirements\n    struct ServiceTypeStakeRequirements {\n        uint minStake;\n        uint maxStake;\n    }\n\n    /// @dev mapping of service type to registered requirements\n    mapping(bytes32 => ServiceTypeStakeRequirements) serviceTypeStakeRequirements;\n\n    event SetServiceVersion(bytes32 _serviceType, bytes32 _serviceVersion);\n    event Test(string msg, bool value);\n    event TestAddr(string msg, address addr);\n\n    /**\n     * @notice Function to initialize the contract\n     * @param _governanceAddress - Governance proxy address\n     */\n    function initialize(address _governanceAddress) public initializer\n    {\n        governanceAddress = _governanceAddress;\n        InitializableV2.initialize();\n    }\n\n    /// @notice Get the Governance address\n    function getGovernanceAddress() external view returns (address addr) {\n        return governanceAddress;\n    }\n\n    /**\n     * @notice Set the Governance address\n     * @dev Only callable by Governance address\n     * @param _governanceAddress - address for new Governance contract\n     */\n    function setGovernanceAddress(address _governanceAddress) external {\n        require(msg.sender == governanceAddress, \"Only governance\");\n        governanceAddress = _governanceAddress;\n    }\n\n    // ========================================= Service Type Logic =========================================\n\n    /// @notice Add a new service type\n    /**\n     * @notice Add a new service type\n     * @param _serviceType - type of service to add\n     * @param _serviceTypeMin - minimum stake for service type\n     * @param _serviceTypeMax - maximum stake for service type\n     */\n    function addServiceType(\n        bytes32 _serviceType,\n        uint _serviceTypeMin,\n        uint _serviceTypeMax\n    ) external\n    {\n        _requireIsInitialized();\n\n        r"
    }
  ]
}