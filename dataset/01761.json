{
  "Title": "M-1: PriceOracle.getPrice doesn't check for stale price",
  "Content": "# Issue M-1: PriceOracle.getPrice doesn't check for stale price \n\nSource: https://github.com/sherlock-audit/2023-05-ironbank-judging/issues/9 \n\n## Found by \n0x3b, 0x52, 0x8chars, 0xHati, 0xStalin, 0xpinky, 3agle, Angry\\_Mustache\\_Man, Arabadzhiev, Aymen0909, Bauchibred, BenRai, Bozho, Breeje, Brenzee, BugBusters, CMierez, Delvir0, Diana, Hama, HexHackers, IceBear, Ignite, Jaraxxus, Kodyvim, Kose, Madalad, MohammedRizwan, Norah, Ocean\\_Sky, Pheonix, Proxy, R-Nemes, Ruhum, Schpiel, SovaSlava, anthony, berlin-101, bin2chen, bitsurfer, branch\\_indigo, devScrooge, evilakela, gkrastenov, harisnabeel, holyhansss, jayphbee, josephdara, kn0t, kutugu, lil.eth, martin, n33k, ni8mare, plainshift-2, qbs, qpzm, rvierdiiev, saidam017, santipu\\_, sashik\\_eth, shaka, shealtielanz, simon135, sl1, thekmj, toshii, tsvetanovv, vagrant\n## Summary\nPriceOracle.getPrice doesn't check for stale price. As result protocol can make decisions based on not up to date prices, which can cause loses.\n## Vulnerability Detail\n`PriceOracle.getPrice` function is going to provide asset price using chain link price feeds.\nhttps://github.com/sherlock-audit/2023-05-ironbank/blob/main/ib-v2/src/protocol/oracle/PriceOracle.sol#L66-L72\n```soldiity\n    function getPriceFromChainlink(address base, address quote) internal view returns (uint256) {\n        (, int256 price,,,) = registry.latestRoundData(base, quote);\n        require(price > 0, \"invalid price\");\n\n        // Extend the decimals to 1e18.\n        return uint256(price) * 10 ** (18 - uint256(registry.decimals(base, quote)));\n    }\n```\nThis function doesn't check that prices are up to date. Because of that it's possible that price is not outdated which can cause financial loses for protocol.\n## Impact\nProtocol can face bad debt.\n## Code Snippet\nProvided above\n## Tool used\n\nManual Review\n\n## Recommendation\nYou need to check that price is not outdated by checking round timestamp.\n\n\n\n## Discussion\n\n**ibsunhub**\n\nSame with the answer to #25.\nIt's not practical to setup different heartbeat for individual markets. And we have a backend to monitor the price deviation.\n\n**0xffff11**\n\nDue to the off-chain system by Iron, issue can be a low. (Does not really affect the current state of the contracts) @ibsunhub Is it the right resolution, or thinking more about invalid?\n\n**ib-tycho**\n\nWe still think this is invalid, thanks\n\n**0xffff11**\n\nBecause Iron's off-chain safeguard, invalid\n\n**bzpassersby**\n\nEscalate for 10 USDC\nI think this is wrongly classified as invalid. \n(1) It's impossible for Watsons to know that the protocol has off-chain safeguards because the protocol explicitly said there are no off-chain mechanisms in the contest info. It's unfair for Watsons who might be misled by this answer.\n```\nQ: Are there any off-chain mechanisms or off-chain procedures for the protocol (keeper bots, input validation expectations, etc)?\nnope\n```\n(2)It's right and should be encouraged for Watsons to point-out insufficient on-chain checks. The current code ignores any data freshness-related variables when consuming chainlink data, which is clearly not the best practice. \n\nAnd it's understandable that the protocol chose to implement such checks off-chain. But since Watsons wouldn't have known about this and that the code itself clearly has flaws. This should be at least low/informational. It's unfair for Watsons to be punished because of this. \n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> I think this is wrongly classified as invalid. \n> (1) It's impossible for Watsons to know that the protocol has off-chain safeguards because the protocol explicitly said there are no off-chain mechanisms in the contest info. It's unfair for Watsons who might be misled by this answer.\n> ```\n> Q: Are there any off-chain mechanisms or off-chain procedures for the protocol (keeper bots, input validation expectations, etc)?\n> nope\n> ```\n> (2)It's right and should be encouraged for Watsons to point-out insufficient on-chain checks. The current code ignores any data freshness-related variables when consuming chainlink data, which is clearly not the best practice. \n> \n> And it's understandable that the protocol chose to implement such checks off-chain. But since Watsons wouldn't have known about this and that the code itself clearly has flaws. This should be at least low/informational. It's unfair for Watsons to be punished because of this. \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nResult:\nMedium\nHas Duplicates\nConsidering this a valid medium \n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [bzpassersby](https://github.com/sherlock-audit/2023-05-ironbank-judging/issues/9/#issuecomment-1608200147): accepted\n\n**Josephdara**\n\nHi @hrishibhat @sherlock-admin \nI believe my issue has been omitted\nhttps://github.com/sherlock-audit/2023-05-ironbank-judging/issues/471#issue-1751647942\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/84",
  "Code": [
    {
      "filename": "ib-v2/src/protocol/oracle/PriceOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"chainlink/contracts/src/v0.8/interfaces/FeedRegistryInterface.sol\";\nimport \"chainlink/contracts/src/v0.8/Denominations.sol\";\nimport \"openzeppelin-contracts/contracts/access/Ownable2Step.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../../extensions/interfaces/WstEthInterface.sol\";\nimport \"../../interfaces/PriceOracleInterface.sol\";\n\ncontract PriceOracle is Ownable2Step, PriceOracleInterface {\n    /// @notice The Chainlink feed registry\n    FeedRegistryInterface public immutable registry;\n\n    /// @notice The address of Lido staked ETH\n    address public immutable steth;\n\n    /// @notice The address of Lido wrapped staked ETH\n    address public immutable wsteth;\n\n    struct AggregatorInfo {\n        address base;\n        address quote;\n    }\n\n    /// @notice The mapping from asset to aggregator\n    mapping(address => AggregatorInfo) public aggregators;\n\n    constructor(address registry_, address steth_, address wsteth_) {\n        registry = FeedRegistryInterface(registry_);\n        steth = steth_;\n        wsteth = wsteth_;\n    }\n\n    /**\n     * @notice Get the price of an asset in USD.\n     * @dev The price returned will be normalized by asset's decimals.\n     * @param asset The asset to get the price of\n     * @return The price of the asset in USD\n     */\n    function getPrice(address asset) external view returns (uint256) {\n        if (asset == wsteth) {\n            uint256 stEthPrice = getPriceFromChainlink(steth, Denominations.USD);\n            uint256 stEthPerToken = WstEthInterface(wsteth).stEthPerToken();\n            uint256 wstEthPrice = (stEthPrice * stEthPerToken) / 1e18;\n            return getNormalizedPrice(wstEthPrice, asset);\n        }\n\n        AggregatorInfo memory aggregatorInfo = aggregators[asset];\n        uint256 price = getPriceFromChainlink(aggregatorInfo.base, aggregatorInfo.quote);\n        if (aggregatorInfo.quote == Denominations.ETH) {\n            // Convert the price to USD based if it's ETH based.\n            uint256 ethUsdPrice = getPriceFromChainlink(Denominations.ETH, Denominations.USD);\n            price = (price * ethUsdPrice) / 1e18;\n        }\n        return getNormalizedPrice(price, asset);\n    }\n\n    /**\n     * @notice Get price from Chainlink.\n     * @param base The base asset\n     * @param quote The quote asset\n     * @return The price\n     */\n    function getPriceFromChainlink(address base, address quote) internal view returns (uint256) {\n        (, int256 price,,,) = registry.latestRoundData(base, quote);\n        require(price > 0, \"invalid price\");\n\n        // Extend the decimals to 1e18.\n        return uint256(price) * 10 ** (18 - uint256(registry.decimals(base, quote)));\n    }\n\n    /**\n     * @dev Get the normalized price.\n     * @param price The price\n     * @param asset The asset\n     * @return The normalized price\n     */\n    function getNormalizedPrice(uint256 price, address asset) internal view returns (uint256) {\n        uint8 decimals = IERC20Metadata(asset).decimals();\n        return price * 10 ** (18 - decimals);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    struct Aggregator {\n        address asset;\n        address base;\n        address quote;\n    }\n\n    /**\n     * @notice Set the aggregators.\n     * @param aggrs The aggregators\n     */\n    function _setAggregators(Aggregator[] calldata aggrs) external onlyOwner {\n        uint256 length = aggrs.length;\n        for (uint256 i = 0; i < length;) {\n            if (aggrs[i].base != address(0)) {\n                require(aggrs[i].quote == Denominations.ETH || aggrs[i].quote == Denominations.USD, \"unsupported quote\");\n\n                // Make sure the aggregator works.\n                address aggregator = address(registry.getFeed(aggrs[i].base, aggrs[i].quote));\n                require(registry.isFeedEnabled(aggregator), \"aggregator not enabled\");\n\n                (, int256 price,,,) = registry.latestRoundData(aggrs[i].base, aggrs[i].quote);\n                require(price > 0, \"invalid price\");\n            }\n            aggregators[aggrs[i].asset] = AggregatorInfo({base: aggrs[i].base, quote: aggrs[i].quote});\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n}"
    }
  ]
}