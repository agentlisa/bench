{
  "Title": "Interface Consistency",
  "Content": "\nThis warning is about the `StrategyBase` interface consistency.\n\nSince the `StrategyCurveSCRVv4_1` interface was changed with recent audit results, to keep the strategy interface consistent it is recommended to update all the other `StrategyBase`-interfaced strategies:\n- [strategy-curve-3crv-v1.sol#L40](https://github.com/pickle-finance/protocol/blob/9b0f330a16bc35c964211feae3b335ab398c01b6/src/strategies/curve/strategy-curve-3crv-v1.sol#L40)\n- [strategy-curve-rencrv-v1.sol#L41](https://github.com/pickle-finance/protocol/blob/9b0f330a16bc35c964211feae3b335ab398c01b6/src/strategies/curve/strategy-curve-rencrv-v1.sol#L41)\n- [strategy-curve-scrv-v3_1.sol#L46](https://github.com/pickle-finance/protocol/blob/9b0f330a16bc35c964211feae3b335ab398c01b6/src/strategies/curve/strategy-curve-scrv-v3_1.sol#L46)\n- [strategy-curve-scrv-v4.sol#L118](https://github.com/pickle-finance/protocol/blob/9b0f330a16bc35c964211feae3b335ab398c01b6/src/strategies/curve/strategy-curve-scrv-v4.sol#L118)\n\nTheir `getMostPremium()` and `harvest()` functions signature are required to be updated to keep interface compliance and avoid wrecking business-logic using this interface with inconsistent asset index result type or with already known front-run issue.\n\nStatus: *Fixed at https://github.com/pickle-finance/protocol/pull/19*\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/strategies/curve/strategy-curve-3crv-v1.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\nimport \"../../lib/erc20.sol\";\nimport \"../../lib/safe-math.sol\";\n\nimport \"../../interfaces/jar.sol\";\nimport \"../../interfaces/curve.sol\";\nimport \"../../interfaces/uniswapv2.sol\";\nimport \"../../interfaces/controller.sol\";\n\nimport \"../strategy-curve-base.sol\";\n\ncontract StrategyCurve3CRVv1 is StrategyCurveBase {\n    // Curve stuff\n    address public three_pool = 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;\n    address public three_gauge = 0xbFcF63294aD7105dEa65aA58F8AE5BE2D9d0952A;\n    address public three_crv = 0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490;\n\n    constructor(\n        address _governance,\n        address _strategist,\n        address _controller,\n        address _timelock\n    )\n        public\n        StrategyCurveBase(\n            three_pool,\n            three_gauge,\n            three_crv,\n            _governance,\n            _strategist,\n            _controller,\n            _timelock\n        )\n    {}\n\n    // **** Views ****\n\n    function getMostPremium()\n        public\n        override\n        view\n        returns (address, uint256)\n    {\n        uint256[] memory balances = new uint256[](3);\n        balances[0] = ICurveFi_3(curve).balances(0); // DAI\n        balances[1] = ICurveFi_3(curve).balances(1).mul(10**12); // USDC\n        balances[2] = ICurveFi_3(curve).balances(2).mul(10**12); // USDT\n\n        // DAI\n        if (\n            balances[0] < balances[1] &&\n            balances[0] < balances[2]\n        ) {\n            return (dai, 0);\n        }\n\n        // USDC\n        if (\n            balances[1] < balances[0] &&\n            balances[1] < balances[2]\n        ) {\n            return (usdc, 1);\n        }\n\n        // USDT\n        if (\n            balances[2] < balances[0] &&\n            balances[2] < balances[1]\n        ) {\n            return (usdt, 2);\n        }\n\n        // If they're somehow equal, we just want DAI\n        return (dai, 0);\n    }\n\n    function getName() external override pure returns (string memory) {\n        return \"StrategyCurve3CRVv1\";\n    }\n\n    // **** State Mutations ****\n\n    function harvest() public onlyBenevolent override {\n        // Anyone can harvest it at any given time.\n        // I understand the possibility of being frontrun\n        // But ETH is a dark forest, and I wanna see how this plays out\n        // i.e. will be be heavily frontrunned?\n        //      if so, a new strategy will be deployed.\n\n        // stablecoin we want to convert to\n        (address to, uint256 toIndex) = getMostPremium();\n\n        // Collects crv tokens\n        // Don't bother voting in v1\n        ICurveMintr(mintr).mint(gauge);\n        uint256 _crv = IERC20(crv).balanceOf(address(this));\n        if (_crv > 0) {\n            // x% is sent back to the rewards holder\n            // to be used to lock up in as veCRV in a future date\n            uint256 _keepCRV = _crv.mul(keepCRV).div(keepCRVMax);\n            if (_keepCRV > 0) {\n                IERC20(crv).safeTransfer(\n                    IController(controller).treasury(),\n                    _keepCRV\n                );\n            }\n            _crv = _crv.sub(_keepCRV);\n            _swapUniswap(crv, to, _crv);\n        }\n\n        // Adds liquidity to curve.fi's pool\n        // to get back want (scrv)\n        uint256 _to = IERC20(to).balanceOf(address(this));\n        if (_to > 0) {\n            IERC20(to).safeApprove(curve, 0);\n            IERC20(to).safeApprove(curve, _to);\n            uint256[3] memory liquidity;\n            liquidity[toIndex] = _to;\n            ICurveFi_3(curve).add_liquidity(liquidity, 0);\n        }\n\n        // We want to get back sCRV\n        uint256 _want = IERC20(want).balanceOf(address(this));\n        if (_want > 0) {\n            // Fees 4.5% goes to treasury\n            IERC20(want).safeTransfer(\n                IController(controller).treasury(),\n                _want.mul(performanceFee).div(performanceMax)\n            );\n\n            deposit();\n        }\n    }\n}"
    },
    {
      "filename": "src/strategies/curve/strategy-curve-rencrv-v1.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\nimport \"../../lib/erc20.sol\";\nimport \"../../lib/safe-math.sol\";\n\nimport \"../../interfaces/jar.sol\";\nimport \"../../interfaces/curve.sol\";\nimport \"../../interfaces/uniswapv2.sol\";\nimport \"../../interfaces/controller.sol\";\n\nimport \"../strategy-curve-base.sol\";\n\ncontract StrategyCurveRenCRVv1 is StrategyCurveBase {\n    // https://www.curve.fi/ren\n    // Curve stuff\n    address public ren_pool = 0x93054188d876f558f4a66B2EF1d97d16eDf0895B;\n    address public ren_gauge = 0xB1F2cdeC61db658F091671F5f199635aEF202CAC;\n    address public ren_crv = 0x49849C98ae39Fff122806C06791Fa73784FB3675;\n\n    constructor(\n        address _governance,\n        address _strategist,\n        address _controller,\n        address _timelock\n    )\n        public\n        StrategyCurveBase(\n            ren_pool,\n            ren_gauge,\n            ren_crv,\n            _governance,\n            _strategist,\n            _controller,\n            _timelock\n        )\n    {}\n\n    // **** Views ****\n\n    function getMostPremium() public override view returns (address, uint256) {\n        // Both 8 decimals, so doesn't matter\n        uint256[] memory balances = new uint256[](3);\n        balances[0] = ICurveFi_2(curve).balances(0); // RENBTC\n        balances[1] = ICurveFi_2(curve).balances(1); // WBTC\n\n        // renbtc\n        if (balances[0] < balances[1]) {\n            return (renbtc, 0);\n        }\n\n        // WBTC\n        if (balances[1] < balances[0]) {\n            return (wbtc, 1);\n        }\n\n        // If they're somehow equal, we just want RENBTC\n        return (renbtc, 0);\n    }\n\n    function getName() external override pure returns (string memory) {\n        return \"StrategyCurveRenCRVv1\";\n    }\n\n    // **** State Mutations ****\n\n    function harvest() public override onlyBenevolent {\n        // Anyone can harvest it at any given time.\n        // I understand the possibility of being frontrun\n        // But ETH is a dark forest, and I wanna see how this plays out\n        // i.e. will be be heavily frontrunned?\n        //      if so, a new strategy will be deployed.\n\n        // stablecoin we want to convert to\n        (address to, uint256 toIndex) = getMostPremium();\n\n        // Collects crv tokens\n        // Don't bother voting in v1\n        ICurveMintr(mintr).mint(gauge);\n        uint256 _crv = IERC20(crv).balanceOf(address(this));\n        if (_crv > 0) {\n            // x% is sent back to the rewards holder\n            // to be used to lock up in as veCRV in a future date\n            uint256 _keepCRV = _crv.mul(keepCRV).div(keepCRVMax);\n            if (_keepCRV > 0) {\n                IERC20(crv).safeTransfer(\n                    IController(controller).treasury(),\n                    _keepCRV\n                );\n            }\n            _crv = _crv.sub(_keepCRV);\n            _swapUniswap(crv, to, _crv);\n        }\n\n        // Adds liquidity to curve.fi's pool\n        // to get back want (scrv)\n        uint256 _to = IERC20(to).balanceOf(address(this));\n        if (_to > 0) {\n            IERC20(to).safeApprove(curve, 0);\n            IERC20(to).safeApprove(curve, _to);\n            uint256[2] memory liquidity;\n            liquidity[toIndex] = _to;\n            ICurveFi_2(curve).add_liquidity(liquidity, 0);\n        }\n\n        // We want to get back sCRV\n        uint256 _want = IERC20(want).balanceOf(address(this));\n        if (_want > 0) {\n            // Fees 4.5% goes to treasury\n            IERC20(want).safeTransfer(\n                IController(controller).treasury(),\n                _want.mul(performanceFee).div(performanceMax)\n            );\n\n            deposit();\n        }\n    }\n}"
    },
    {
      "filename": "src/strategies/curve/strategy-curve-scrv-v3_1.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\nimport \"../../lib/erc20.sol\";\nimport \"../../lib/safe-math.sol\";\n\nimport \"./scrv-voter.sol\";\nimport \"./crv-locker.sol\";\n\nimport \"../../interfaces/jar.sol\";\nimport \"../../interfaces/curve.sol\";\nimport \"../../interfaces/uniswapv2.sol\";\nimport \"../../interfaces/controller.sol\";\n\nimport \"../strategy-curve-base.sol\";\n\ncontract StrategyCurveSCRVv3_1 is StrategyCurveBase {\n    // Curve stuff\n    address public susdv2_pool = 0xA5407eAE9Ba41422680e2e00537571bcC53efBfD;\n    address public susdv2_gauge = 0xA90996896660DEcC6E997655E065b23788857849;\n    address public scrv = 0xC25a3A3b969415c80451098fa907EC722572917F;\n\n    // Harvesting\n    address public snx = 0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F;\n\n    constructor(\n        address _governance,\n        address _strategist,\n        address _controller,\n        address _timelock\n    )\n        public\n        StrategyCurveBase(\n            susdv2_pool,\n            susdv2_gauge,\n            scrv,\n            _governance,\n            _strategist,\n            _controller,\n            _timelock\n        )\n    {}\n\n    // **** Views ****\n\n    function getMostPremium()\n        public\n        override\n        view\n        returns (address, uint256)\n    {\n        uint256[] memory balances = new uint256[](4);\n        balances[0] = ICurveFi_4(curve).balances(0); // DAI\n        balances[1] = ICurveFi_4(curve).balances(1).mul(10**12); // USDC\n        balances[2] = ICurveFi_4(curve).balances(2).mul(10**12); // USDT\n        balances[3] = ICurveFi_4(curve).balances(3); // sUSD\n\n        // DAI\n        if (\n            balances[0] < balances[1] &&\n            balances[0] < balances[2] &&\n            balances[0] < balances[3]\n        ) {\n            return (dai, 0);\n        }\n\n        // USDC\n        if (\n            balances[1] < balances[0] &&\n            balances[1] < balances[2] &&\n            balances[1] < balances[3]\n        ) {\n            return (usdc, 1);\n        }\n\n        // USDT\n        if (\n            balances[2] < balances[0] &&\n            balances[2] < balances[1] &&\n            balances[2] < balances[3]\n        ) {\n            return (usdt, 2);\n        }\n\n        // SUSD\n        if (\n            balances[3] < balances[0] &&\n            balances[3] < balances[1] &&\n            balances[3] < balances[2]\n        ) {\n            return (susd, 3);\n        }\n\n        // If they're somehow equal, we just want DAI\n        return (dai, 0);\n    }\n\n    function getName() external override pure returns (string memory) {\n        return \"StrategyCurveSCRVv3_1\";\n    }\n\n    // **** State Mutations ****\n\n    function harvest() public onlyBenevolent override {\n        // Anyone can harvest it at any given time.\n        // I understand the possibility of being frontrun\n        // But ETH is a dark forest, and I wanna see how this plays out\n        // i.e. will be be heavily frontrunned?\n        //      if so, a new strategy will be deployed.\n\n        // stablecoin we want to convert to\n        (address to, uint256 toIndex) = getMostPremium();\n\n        // Collects crv tokens\n        // Don't bother voting in v1\n        ICurveMintr(mintr).mint(gauge);\n        uint256 _crv = IERC20(crv).balanceOf(address(this));\n        if (_crv > 0) {\n            // x% is sent back to the rewards holder\n            // to be used to lock up in as veCRV in a future date\n            uint256 _keepCRV = _crv.mul(keepCRV).div(keepCRVMax);\n            if (_keepCRV > 0) {\n                IERC20(crv).safeTransfer(\n                    IController(controller).treasury(),\n                    _keepCRV\n                );\n            }\n            _crv = _crv.sub(_keepCRV);\n            _swapUniswap(crv, to, _crv);\n        }\n\n        // Collects SNX tokens\n        ICurveGauge(gauge).claim_rewards(address(this));\n        uint256 _snx = IERC20(snx).balanceOf(address(this));\n        if (_snx > 0) {\n            _swapUniswap(snx, to, _snx);\n        }\n\n        // Adds liquidity to curve.fi's susd pool\n        // to get back want (scrv)\n        uint256 _to = IERC20(to).balanceOf(address(this));\n        if (_to > 0) {\n            IERC20(to).safeApprove(curve, 0);\n            IERC20(to).safeApprove(curve, _to);\n            uint256[4] memory liquidity;\n            liquidity[toIndex] = _to;\n            ICurveFi_4(curve).add_liquidity(liquidity, 0);\n        }\n\n        // We want to get back sCRV\n        uint256 _want = IERC20(want).balanceOf(address(this));\n        if (_want > 0) {\n            // Fees 4.5% goes to treasury\n            IERC20(want).safeTransfer(\n                IController(controller).treasury(),\n                _want.mul(performanceFee).div(performanceMax)\n            );\n\n            deposit();\n        }\n    }\n}"
    },
    {
      "filename": "src/strategies/curve/strategy-curve-scrv-v4.sol",
      "content": "// https://etherscan.io/address/0x594a198048501a304267e63b3bad0f0638da7628#code\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\nimport \"../../lib/erc20.sol\";\nimport \"../../lib/safe-math.sol\";\n\nimport \"./scrv-voter.sol\";\nimport \"./crv-locker.sol\";\n\nimport \"../../interfaces/jar.sol\";\nimport \"../../interfaces/curve.sol\";\nimport \"../../interfaces/uniswapv2.sol\";\nimport \"../../interfaces/controller.sol\";\n\ncontract StrategyCurveSCRVv4 {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    // sCRV\n    address public constant want = 0xC25a3A3b969415c80451098fa907EC722572917F;\n\n    // susdv2 pool\n    address public constant curve = 0xA5407eAE9Ba41422680e2e00537571bcC53efBfD;\n\n    // tokens we're farming\n    address public constant crv = 0xD533a949740bb3306d119CC777fa900bA034cd52;\n    address public constant snx = 0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F;\n\n    // curve dao\n    address\n        public constant scrvGauge = 0xA90996896660DEcC6E997655E065b23788857849;\n    address public constant mintr = 0xd061D61a4d941c39E5453435B6345Dc261C2fcE0;\n    address public constant escrow = 0x5f3b5DfEb7B28CDbD7FAba78963EE202a494e2A2;\n\n    // stablecoins\n    address public constant dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address public constant usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    address public constant usdt = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n    address public constant susd = 0x57Ab1ec28D129707052df4dF418D58a2D46d5f51;\n\n    // pickle token\n    address public constant pickle = 0x429881672B9AE42b8EbA0E26cD9C73711b891Ca5;\n\n    // weth (for uniswapv2 xfers)\n    address public constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    // burn address\n    address public constant burn = 0x000000000000000000000000000000000000dEaD;\n\n    // dex\n    address public univ2Router2 = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n\n    // crv-locker and voter\n    address public scrvVoter;\n    address public crvLocker;\n\n    // Restake 50% of CRV\n    uint256 public keepCRV = 5000;\n    uint256 public constant keepCRVMax = 10000;\n\n    // Perfomance fee 4.5%\n    uint256 public performanceFee = 450;\n    uint256 public constant performanceMax = 10000;\n\n    // Withdrawal fee 0.5%\n    // - 0.325% to treasury\n    // - 0.175% to dev fund\n    uint256 public treasuryFee = 325;\n    uint256 public constant treasuryMax = 100000;\n\n    uint256 public devFundFee = 175;\n    uint256 public constant devFundMax = 100000;\n\n    address public governance;\n    address public controller;\n    address public strategist;\n\n    constructor(\n        address _governance,\n        address _strategist,\n        address _controller,\n        address _scrvVoter,\n        address _crvLocker\n    ) public {\n        governance = _governance;\n        strategist = _strategist;\n        controller = _controller;\n\n        scrvVoter = _scrvVoter;\n        crvLocker = _crvLocker;\n    }\n\n    // **** Views ****\n\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    function balanceOfPool() public view returns (uint256) {\n        return SCRVVoter(scrvVoter).balanceOf(scrvGauge);\n    }\n\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    function getName() external pure returns (string memory) {\n        return \"StrategyCurveSCRVv4\";\n    }\n\n    function getHarvestable() external returns (uint256) {\n        return ICurveGauge(scrvGauge).claimable_tokens(crvLocker);\n    }\n\n    function getMostPremium() public view returns (address, uint256) {\n        uint256[] memory balances = new uint256[](4);\n        balances[0] = ICurveFi_4(curve).balances(0); // DAI\n        balances[1] = ICurveFi_4(curve).balances(1).mul(10**12); // USDC\n        balances[2] = ICurveFi_4(curve).balances(2).mul(10**12); // USDT\n        balances[3] = ICurveFi_4(curve).balances(3); // sUSD\n\n        // DAI\n        if (\n            balances[0] < balances[1] &&\n            balances[0] < balances[2] &&\n            balances[0] < balances[3]\n        ) {\n            return (dai, 0);\n        }\n\n        // USDC\n        if (\n            balances[1] < balances[0] &&\n            balances[1] < balances[2] &&\n            balances[1] < balances[3]\n        ) {\n            return (usdc, 1);\n        }\n\n        // USDT\n        if (\n            balances[2] < balances[0] &&\n            balances[2] < balances[1] &&\n            balances[2] < balances[3]\n        ) {\n            return (usdt, 2);\n        }\n\n        // SUSD\n        if (\n            balances[3] < balances[0] &&\n            balances[3] < balances[1] &&\n            balances[3] < balances[2]\n        ) {\n            return (susd, 3);\n        }\n\n        // If they're somehow equal, we just want DAI\n        return (dai, 0);\n    }\n\n    // **** Setters ****\n\n    function setDevFundFee(uint256 _devFundFee) external {\n        require(msg.sender == governance, \"!governance\");\n        devFundFee = _devFundFee;\n    }\n\n    function setTreasuryFee(uint256 _treasuryFee) external {\n        require(msg.sender == governance, \"!governance\");\n        treasuryFee = _treasuryFee;\n    }\n\n    function setPerformanceFee(uint256 _performanceFee) external {\n        require(msg.sender == governance, \"!governance\");\n        performanceFee = _performanceFee;\n    }\n\n    function setStrategist(address _strategist) external {\n        require(msg.sender == governance, \"!governance\");\n        strategist = _strategist;\n    }\n\n    function setGovernance(address _governance) external {\n        require(msg.sender == governance, \"!governance\");\n        governance = _governance;\n    }\n\n    function setController(address _controller) external {\n        require(msg.sender == governance, \"!governance\");\n        controller = _controller;\n    }\n\n    function setKeepCRV(uint256 _keepCRV) external {\n        require(msg.sender == governance, \"!governance\");\n        keepCRV = _keepCRV;\n    }\n\n    // **** State Mutations ****\n\n    function deposit() public {\n        uint256 _want = IERC20(want).balanceOf(address(this));\n        if (_want > 0) {\n            IERC20(want).safeTransfer(scrvVoter, _want);\n            SCRVVoter(scrvVoter).deposit(scrvGauge, want);\n        }\n    }\n\n    // Controller only function for creating additional rewards from dust\n    function withdraw(IERC20 _asset) external returns (uint256 balance) {\n        require(msg.sender == controller, \"!controller\");\n        require(want != address(_asset), \"want\");\n        require(crv != address(_asset), \"crv\");\n        require(snx != address(_asset), \"snx\");\n        balance = _asset.balanceOf(address(this));\n        _asset.safeTransfer(controller, balance);\n    }\n\n    // Withdraw partial funds, normally used with a jar withdrawal\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == controller, \"!controller\");\n        uint256 _balance = IERC20(want).balanceOf(address(this));\n        if (_balance < _amount) {\n            _amount = _withdrawSome(_amount.sub(_balance));\n            _amount = _amount.add(_balance);\n        }\n\n        uint256 _feeDev = _amount.mul(devFundFee).div(devFundMax);\n        IERC20(want).safeTransfer(IController(controller).devfund(), _feeDev);\n\n        uint256 _feeTreasury = _amount.mul(treasuryFee).div(treasuryMax);\n        IERC20(want).safeTransfer(\n            IController(controller).treasury(),\n            _feeTreasury\n        );\n\n        address _jar = IController(controller).jars(address(want));\n        require(_jar != address(0), \"!jar\"); // additional protection so we don't burn the funds\n\n        IERC20(want).safeTransfer(_jar, _amount.sub(_feeDev).sub(_feeTreasury));\n    }\n\n    // Withdraw all funds, normally used when migrating strategies\n    function withdrawAll() external returns (uint256 balance) {\n        require(msg.sender == controller, \"!controller\");\n        _withdrawAll();\n\n        balance = IERC20(want).balanceOf(address(this));\n\n        address _jar = IController(controller).jars(address(want));\n        require(_jar != address(0), \"!jar\"); // additional protection so we don't burn the funds\n        IERC20(want).safeTransfer(_jar, balance);\n    }\n\n    function _withdrawAll() internal {\n        SCRVVoter(scrvVoter).withdrawAll(scrvGauge, want);\n    }\n\n    function _withdrawSome(uint256 _amount) internal returns (uint256) {\n        return SCRVVoter(scrvVoter).withdraw(scrvGauge, want, _amount);\n    }\n\n    function brine() public {\n        harvest();\n    }\n\n    function harvest() public {\n        // Anyone can harvest it at any given time.\n        // I understand the possibility of being frontrun / sandwiched\n        // But ETH is a dark forest, and I wanna see how this plays out\n        // i.e. will be be heavily frontrunned/sandwiched?\n        //      if so, a new strategy will be deployed.\n\n        require(\n            msg.sender == tx.origin ||\n                msg.sender == strategist ||\n                msg.sender == governance,\n            \"!eoa\"\n        );\n\n        // stablecoin we want to convert to\n        (address to, uint256 toIndex) = getMostPremium();\n\n        // Collects crv tokens\n        // Don't bother voting in v1\n        SCRVVoter(scrvVoter).harvest(scrvGauge);\n        uint256 _crv = IERC20(crv).balanceOf(address(this));\n        if (_crv > 0) {\n            // How much CRV to keep to restake?\n            uint256 _keepCRV = _crv.mul(keepCRV).div(keepCRVMax);\n            IERC20(crv).safeTransfer(address(crvLocker), _keepCRV);\n\n            // How much CRV to swap?\n            _crv = _crv.sub(_keepCRV);\n            _swap(crv, to, _crv);\n        }\n\n        // Collects SNX tokens\n        SCRVVoter(scrvVoter).claimRewards();\n        uint256 _snx = IERC20(snx).balanceOf(address(this));\n        if (_snx > 0) {\n            _swap(snx, to, _snx);\n        }\n\n        // Adds liquidity to curve.fi's susd pool\n        // to get back want (scrv)\n        uint256 _to = IERC20(to).balanceOf(address(this));\n        if (_to > 0) {\n            IERC20(to).safeApprove(curve, 0);\n            IERC20(to).safeApprove(curve, _to);\n            uint256[4] memory liquidity;\n            liquidity[toIndex] = _to;\n            ICurveFi_4(curve).add_liquidity(liquidity, 0);\n        }\n\n        // We want to get back sCRV\n        uint256 _want = IERC20(want).balanceOf(address(this));\n        if (_want > 0) {\n            // 4.5% rewards gets sent to treasury\n            IERC20(want).safeTransfer(\n                IController(controller).treasury(),\n                _want.mul(performanceFee).div(performanceMax)\n            );\n\n            deposit();\n        }\n    }\n\n    function _swap(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        // Swap with uniswap\n        IERC20(_from).safeApprove(univ2Router2, 0);\n        IERC20(_from).safeApprove(univ2Router2, _amount);\n\n        address[] memory path = new address[](3);\n        path[0] = _from;\n        path[1] = weth;\n        path[2] = _to;\n\n        UniswapRouterV2(univ2Router2).swapExactTokensForTokens(\n            _amount,\n            0,\n            path,\n            address(this),\n            now.add(60)\n        );\n    }\n}"
    }
  ]
}