{
  "Title": "[G-07] State variables can be packed into fewer storage slots (3 instances)",
  "Content": "\nIf variables occupying the same slot are both written the same function or by the constructor, avoids a separate Gsset (20000 gas). Reads of the variables can also be cheaper.\n\n**NOTE**: one slot = 32 bytes\n\nDeployment Gas Saved: **23 292**<br>\nMethod Call Gas Saved: **1 711**<br>\n\n*   src/policies/Heart.sol:[32-48](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Heart.sol#L32-L48)\n\nuint256(32), address(20), bool(1)\n\n```solidity\n32     /// @notice Status of the Heart, false = stopped, true = beating\n33     bool public active; // @note put below _operator\n34\n35     /// @notice Timestamp of the last beat (UTC, in seconds)\n36     uint256 public lastBeat;\n37\n38     /// @notice Reward for beating the Heart (in reward token decimals)\n39     uint256 public reward;\n40\n41     /// @notice Reward token address that users are sent for beating the Heart\n42     ERC20 public rewardToken;\n43\n44     // Modules\n45     OlympusPrice internal PRICE;\n46\n47     // Policies\n48     IOperator internal _operator;\n```\n\nfix:\n\n```solidity\nuint256 public lastBeat;\nuint256 public reward;\nERC20 public rewardToken;\nOlympusPrice internal PRICE;\nIOperator internal _operator;\nbool public active;\n```\n\n*   src/modules/PRICE.sol:[31-65](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L31-L65)\n\n**NOTE**: PRICE is Module, Module is KernelAdapter, so real first variable in PRICE is kernel from KernelAdapter\n\nuint256(32), uint32(4), uint48(6), uint8(1), array(32), address(20), bool(1)\n\n```solidity\ninherit Kernel public kernel;\n...\n31     /// @dev    Price feeds. Chainlink typically provides price feeds for an asset in ETH. Therefore, we use two price feeds against ETH, one for OHM and one for the Reserve asset, to calculate the relative price of OHM in the Reserve asset.\n32     AggregatorV2V3Interface internal immutable _ohmEthPriceFeed;\n33     AggregatorV2V3Interface internal immutable _reserveEthPriceFeed;\n34\n35     /// @dev Moving average data\n36     uint256 internal _movingAverage; /// See getMovingAverage()\n37\n38     /// @notice Array of price observations. Check nextObsIndex to determine latest data point.\n39     /// @dev    Observations are stored in a ring buffer where the moving average is the sum of all observations divided by the number of observations.\n40     ///         Observations can be cleared by changing the movingAverageDuration or observationFrequency and must be re-initialized.\n41     uint256[] public observations;\n42\n43     /// @notice Index of the next observation to make. The current value at this index is the oldest observation.\n44     uint32 public nextObsIndex;\n45\n46     /// @notice Number of observations used in the moving average calculation. Computed from movingAverageDuration / observationFrequency.\n47     uint32 public numObservations;\n48\n49     /// @notice Frequency (in seconds) that observations should be stored.\n50     uint48 public observationFrequency;\n51\n52     /// @notice Duration (in seconds) over which the moving average is calculated.\n53     uint48 public movingAverageDuration;\n54\n55     /// @notice Unix timestamp of last observation (in seconds).\n56     uint48 public lastObservationTime;\n57\n58     /// @notice Number of decimals in the price values provided by the contract.\n59     uint8 public constant decimals = 18;\n60\n61     /// @notice Whether the price module is initialized (and therefore active).\n62     bool public initialized;\n63\n64     // Scale factor for converting prices, calculated from decimal values.\n65     uint256 internal immutable _scaleFactor;\n```\n\nfix:\n\n```solidity\nuint48 public observationFrequency;\nuint48 public movingAverageDuration;\nAggregatorV2V3Interface internal immutable _ohmEthPriceFeed;\nAggregatorV2V3Interface internal immutable _reserveEthPriceFeed;\nuint256 internal _movingAverage; /// See getMovingAverage()\nuint256[] public observations;\nuint32 public nextObsIndex;\nuint32 public numObservations;\nuint48 public lastObservationTime;\nuint8 public constant decimals = 18;\nbool public initialized;\nuint256 internal immutable _scaleFactor;\n```\n\n*   src/policies/Operator.sol:[58-89](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L58-L89)\n\nuint32(4), uint8(1), address(20), bool(1)\n\n```solidity\n58     /// Operator variables, defined in the interface on the external getter functions\n59     Status internal _status;\n60     Config internal _config;\n61\n62     /// @notice    Whether the Operator has been initialized\n63     bool public initialized;\n64\n65     /// @notice    Whether the Operator is active\n66     bool public active;\n67\n68     /// Modules\n69     OlympusPrice internal PRICE;\n70     OlympusRange internal RANGE;\n71     OlympusTreasury internal TRSRY;\n72     OlympusMinter internal MINTR;\n73\n74     /// External contracts\n75     /// @notice     Auctioneer contract used for cushion bond market deployments\n76     IBondAuctioneer public auctioneer;\n77     /// @notice     Callback contract used for cushion bond market payouts\n78     IBondCallback public callback;\n79\n80     /// Tokens\n81     /// @notice     OHM token contract\n82     ERC20 public immutable ohm;\n83     uint8 public immutable ohmDecimals;\n84     /// @notice     Reserve token contract\n85     ERC20 public immutable reserve;\n86     uint8 public immutable reserveDecimals;\n87\n88     /// Constants\n89     uint32 public constant FACTOR_SCALE = 1e4;\n```\n\nfix:\n\n```solidity\nStatus internal _status;\nConfig internal _config;\nOlympusPrice internal PRICE;\nOlympusRange internal RANGE;\nOlympusTreasury internal TRSRY;\nOlympusMinter internal MINTR;\nIBondAuctioneer public auctioneer;\nIBondCallback public callback;\nbool public initialized;\nbool public active;\nERC20 public immutable ohm;\nuint8 public immutable ohmDecimals;\nERC20 public immutable reserve;\nuint8 public immutable reserveDecimals;\nuint32 public constant FACTOR_SCALE = 1e4;\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-08-olympus-dao-contest",
  "Code": [
    {
      "filename": "src/policies/Heart.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\nimport {IHeart} from \"policies/interfaces/IHeart.sol\";\nimport {IOperator} from \"policies/interfaces/IOperator.sol\";\n\nimport {OlympusPrice} from \"modules/PRICE.sol\";\n\nimport \"src/Kernel.sol\";\n\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\n/// @title  Olympus Heart\n/// @notice Olympus Heart (Policy) Contract\n/// @dev    The Olympus Heart contract provides keeper rewards to call the heart beat function which fuels\n///         Olympus market operations. The Heart orchestrates state updates in the correct order to ensure\n///         market operations use up to date information.\ncontract OlympusHeart is IHeart, Policy, ReentrancyGuard {\n    using TransferHelper for ERC20;\n\n    error Heart_OutOfCycle();\n    error Heart_BeatStopped();\n    error Heart_InvalidParams();\n\n    event Beat(uint256 timestamp_);\n    event RewardIssued(address to_, uint256 rewardAmount_);\n    event RewardUpdated(ERC20 token_, uint256 rewardAmount_);\n\n    /// @notice Status of the Heart, false = stopped, true = beating\n    bool public active;\n\n    /// @notice Timestamp of the last beat (UTC, in seconds)\n    uint256 public lastBeat;\n\n    /// @notice Reward for beating the Heart (in reward token decimals)\n    uint256 public reward;\n\n    /// @notice Reward token address that users are sent for beating the Heart\n    ERC20 public rewardToken;\n\n    // Modules\n    OlympusPrice internal PRICE;\n\n    // Policies\n    IOperator internal _operator;\n\n    /*//////////////////////////////////////////////////////////////\n                            POLICY INTERFACE\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        Kernel kernel_,\n        IOperator operator_,\n        ERC20 rewardToken_,\n        uint256 reward_\n    ) Policy(kernel_) {\n        _operator = operator_;\n\n        active = true;\n        lastBeat = block.timestamp;\n        rewardToken = rewardToken_;\n        reward = reward_;\n    }\n\n    /// @inheritdoc Policy\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](1);\n        dependencies[0] = toKeycode(\"PRICE\");\n\n        PRICE = OlympusPrice(getModuleAddress(dependencies[0]));\n    }\n\n    /// @inheritdoc Policy\n    function requestPermissions()\n        external\n        view\n        override\n        returns (Permissions[] memory permissions)\n    {\n        permissions = new Permissions[](1);\n        permissions[0] = Permissions(PRICE.KEYCODE(), PRICE.updateMovingAverage.selector);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CORE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IHeart\n    function beat() external nonReentrant {\n        if (!active) revert Heart_BeatStopped();\n        if (block.timestamp < lastBeat + frequency()) revert Heart_OutOfCycle();\n\n        // Update the moving average on the Price module\n        PRICE.updateMovingAverage();\n\n        // Trigger price range update and market operations\n        _operator.operate();\n\n        // Update the last beat timestamp\n        lastBeat += frequency();\n\n        // Issue reward to sender\n        _issueReward(msg.sender);\n\n        emit Beat(block.timestamp);\n    }\n\n    function _issueReward(address to_) internal {\n        rewardToken.safeTransfer(to_, reward);\n        emit RewardIssued(to_, reward);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IHeart\n    function frequency() public view returns (uint256) {\n        return uint256(PRICE.observationFrequency());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IHeart\n    function resetBeat() external onlyRole(\"heart_admin\") {\n        lastBeat = block.timestamp - frequency();\n    }\n\n    /// @inheritdoc IHeart\n    function toggleBeat() external onlyRole(\"heart_admin\") {\n        active = !active;\n    }\n\n    /// @inheritdoc IHeart\n    function setRewardTokenAndAmount(ERC20 token_, uint256 reward_)\n        external\n        onlyRole(\"heart_admin\")\n    {\n        rewardToken = token_;\n        reward = reward_;\n        emit RewardUpdated(token_, reward_);\n    }\n\n    /// @inheritdoc IHeart\n    function withdrawUnspentRewards(ERC20 token_) external onlyRole(\"heart_admin\") {\n        token_.safeTransfer(msg.sender, token_.balanceOf(address(this)));\n    }\n}"
    },
    {
      "filename": "src/modules/PRICE.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {AggregatorV2V3Interface} from \"interfaces/AggregatorV2V3Interface.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport \"src/Kernel.sol\";\n\nimport {FullMath} from \"libraries/FullMath.sol\";\n\n// ERRORS\nerror Price_InvalidParams();\nerror Price_NotInitialized();\nerror Price_AlreadyInitialized();\nerror Price_BadFeed(address priceFeed);\n\n/// @notice Price oracle data storage contract\n/// @dev    The Olympus Price Oracle contract provides a standard interface for OHM price data against a reserve asset.\n///         It also implements a moving average price calculation (same as a TWAP) on the price feed data over a configured\n///         duration and observation frequency. The data provided by this contract is used by the Olympus Range Operator to\n///         perform market operations. The Olympus Price Oracle is updated each epoch by the Olympus Heart contract.\ncontract OlympusPrice is Module {\n    using FullMath for uint256;\n\n    /* ========== EVENTS =========== */\n    event NewObservation(uint256 timestamp_, uint256 price_, uint256 movingAverage_);\n    event MovingAverageDurationChanged(uint48 movingAverageDuration_);\n    event ObservationFrequencyChanged(uint48 observationFrequency_);\n    /* ========== STATE VARIABLES ========== */\n\n    /// @dev    Price feeds. Chainlink typically provides price feeds for an asset in ETH. Therefore, we use two price feeds against ETH, one for OHM and one for the Reserve asset, to calculate the relative price of OHM in the Reserve asset.\n    AggregatorV2V3Interface internal immutable _ohmEthPriceFeed;\n    AggregatorV2V3Interface internal immutable _reserveEthPriceFeed;\n\n    /// @dev Moving average data\n    uint256 internal _movingAverage; /// See getMovingAverage()\n\n    /// @notice Array of price observations. Check nextObsIndex to determine latest data point.\n    /// @dev    Observations are stored in a ring buffer where the moving average is the sum of all observations divided by the number of observations.\n    ///         Observations can be cleared by changing the movingAverageDuration or observationFrequency and must be re-initialized.\n    uint256[] public observations;\n\n    /// @notice Index of the next observation to make. The current value at this index is the oldest observation.\n    uint32 public nextObsIndex;\n\n    /// @notice Number of observations used in the moving average calculation. Computed from movingAverageDuration / observationFrequency.\n    uint32 public numObservations;\n\n    /// @notice Frequency (in seconds) that observations should be stored.\n    uint48 public observationFrequency;\n\n    /// @notice Duration (in seconds) over which the moving average is calculated.\n    uint48 public movingAverageDuration;\n\n    /// @notice Unix timestamp of last observation (in seconds).\n    uint48 public lastObservationTime;\n\n    /// @notice Number of decimals in the price values provided by the contract.\n    uint8 public constant decimals = 18;\n\n    /// @notice Whether the price module is initialized (and therefore active).\n    bool public initialized;\n\n    // Scale factor for converting prices, calculated from decimal values.\n    uint256 internal immutable _scaleFactor;\n\n    /*//////////////////////////////////////////////////////////////\n                            MODULE INTERFACE\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        Kernel kernel_,\n        AggregatorV2V3Interface ohmEthPriceFeed_,\n        AggregatorV2V3Interface reserveEthPriceFeed_,\n        uint48 observationFrequency_,\n        uint48 movingAverageDuration_\n    ) Module(kernel_) {\n        /// @dev Moving Average Duration should be divisible by Observation Frequency to get a whole number of observations\n        if (movingAverageDuration_ == 0 || movingAverageDuration_ % observationFrequency_ != 0)\n            revert Price_InvalidParams();\n\n        // Set price feeds, decimals, and scale factor\n        _ohmEthPriceFeed = ohmEthPriceFeed_;\n        uint8 ohmEthDecimals = _ohmEthPriceFeed.decimals();\n\n        _reserveEthPriceFeed = reserveEthPriceFeed_;\n        uint8 reserveEthDecimals = _reserveEthPriceFeed.decimals();\n\n        uint256 exponent = decimals + reserveEthDecimals - ohmEthDecimals;\n        if (exponent > 38) revert Price_InvalidParams();\n        _scaleFactor = 10**exponent;\n\n        // Set parameters and calculate number of observations\n        observationFrequency = observationFrequency_;\n        movingAverageDuration = movingAverageDuration_;\n\n        numObservations = uint32(movingAverageDuration_ / observationFrequency_);\n\n        // Store blank observations array\n        observations = new uint256[](numObservations);\n        /// nextObsIndex is initialized to 0\n\n        emit MovingAverageDurationChanged(movingAverageDuration_);\n        emit ObservationFrequencyChanged(observationFrequency_);\n    }\n\n    /// @inheritdoc Module\n    function KEYCODE() public pure override returns (Keycode) {\n        return toKeycode(\"PRICE\");\n    }\n\n    /// @inheritdoc Module\n    function VERSION() external pure override returns (uint8 major, uint8 minor) {\n        return (1, 0);\n    }\n\n    /* ========== POLICY FUNCTIONS ========== */\n\n    /// @notice Trigger an update of the moving average. Permissioned.\n    /// @dev    This function does not have a time-gating on the observationFrequency on this contract. It is set on the Heart policy contract.\n    ///         The Heart beat frequency should be set to the same value as the observationFrequency.\n    function updateMovingAverage() external permissioned {\n        // Revert if not initialized\n        if (!initialized) revert Price_NotInitialized();\n\n        // Cache numbe of observations to save gas.\n        uint32 numObs = numObservations;\n\n        // Get earliest observation in window\n        uint256 earliestPrice = observations[nextObsIndex];\n\n        uint256 currentPrice = getCurrentPrice();\n\n        // Calculate new moving average\n        if (currentPrice > earliestPrice) {\n            _movingAverage += (currentPrice - earliestPrice) / numObs;\n        } else {\n            _movingAverage -= (earliestPrice - currentPrice) / numObs;\n        }\n\n        // Push new observation into storage and store timestamp taken at\n        observations[nextObsIndex] = currentPrice;\n        lastObservationTime = uint48(block.timestamp);\n        nextObsIndex = (nextObsIndex + 1) % numObs;\n\n        emit NewObservation(block.timestamp, currentPrice, _movingAverage);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Get the current price of OHM in the Reserve asset from the price feeds\n    function getCurrentPrice() public view returns (uint256) {\n        if (!initialized) revert Price_NotInitialized();\n\n        // Get prices from feeds\n        uint256 ohmEthPrice;\n        uint256 reserveEthPrice;\n        {\n            (, int256 ohmEthPriceInt, , uint256 updatedAt, ) = _ohmEthPriceFeed.latestRoundData();\n            // Use a multiple of observation frequency to determine what is too old to use.\n            // Price feeds will not provide an updated answer if the data doesn't change much.\n            // This would be similar to if the feed just stopped updating; therefore, we need a cutoff.\n            if (updatedAt < block.timestamp - 3 * uint256(observationFrequency))\n                revert Price_BadFeed(address(_ohmEthPriceFeed));\n            ohmEthPrice = uint256(ohmEthPriceInt);\n\n            int256 reserveEthPriceInt;\n            (, reserveEthPriceInt, , updatedAt, ) = _reserveEthPriceFeed.latestRoundData();\n            if (updatedAt < block.timestamp - uint256(observationFrequency))\n                revert Price_BadFeed(address(_reserveEthPriceFeed));\n            reserveEthPrice = uint256(reserveEthPriceInt);\n        }\n\n        // Convert to OHM/RESERVE price\n        uint256 currentPrice = (ohmEthPrice * _scaleFactor) / reserveEthPrice;\n\n        return currentPrice;\n    }\n\n    /// @notice Get the last stored price observation of OHM in the Reserve asset\n    function getLastPrice() external view returns (uint256) {\n        if (!initialized) revert Price_NotInitialized();\n        uint32 lastIndex = nextObsIndex == 0 ? numObservations - 1 : nextObsIndex - 1;\n        return observations[lastIndex];\n    }\n\n    /// @notice Get the moving average of OHM in the Reserve asset over the defined window (see movingAverageDuration and observationFrequency).\n    function getMovingAverage() external view returns (uint256) {\n        if (!initialized) revert Price_NotInitialized();\n        return _movingAverage;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Initialize the price module\n    /// @notice Access restricted to activated policies\n    /// @param  startObservations_ - Array of observations to initialize the moving average with. Must be of length numObservations.\n    /// @param  lastObservationTime_ - Unix timestamp of last observation being provided (in seconds).\n    /// @dev    This function must be called after the Price module is deployed to activate it and after updating the observationFrequency\n    ///         or movingAverageDuration (in certain cases) in order for the Price module to function properly.\n    function initialize(uint256[] memory startObservations_, uint48 lastObservationTime_)\n        external\n        permissioned\n    {\n        if (initialized) revert Price_AlreadyInitialized();\n\n        // Cache numObservations to save gas.\n        uint256 numObs = observations.length;\n\n        // Check that the number of start observations matches the number expected\n        if (startObservations_.length != numObs || lastObservationTime_ > uint48(block.timestamp))\n            revert Price_InvalidParams();\n\n        // Push start observations into storage and total up observations\n        uint256 total;\n        for (uint256 i; i < numObs; ) {\n            if (startObservations_[i] == 0) revert Price_InvalidParams();\n            total += startObservations_[i];\n            observations[i] = startObservations_[i];\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Set moving average, last observation time, and initialized flag\n        _movingAverage = total / numObs;\n        lastObservationTime = lastObservationTime_;\n        initialized = true;\n    }\n\n    /// @notice Change the moving average window (duration)\n    /// @param  movingAverageDuration_ - Moving average duration in seconds, must be a multiple of observation frequency\n    /// @dev    Changing the moving average duration will erase the current observations array\n    ///         and require the initialize function to be called again. Ensure that you have saved\n    ///         the existing data and can re-populate before calling this function.\n    function changeMovingAverageDuration(uint48 movingAverageDuration_) external permissioned {\n        // Moving Average Duration should be divisible by Observation Frequency to get a whole number of observations\n        if (movingAverageDuration_ == 0 || movingAverageDuration_ % observationFrequency != 0)\n            revert Price_InvalidParams();\n\n        // Calculate the new number of observations\n        uint256 newObservations = uint256(movingAverageDuration_ / observationFrequency);\n\n        // Store blank observations array of new size\n        observations = new uint256[](newObservations);\n\n        // Set initialized to false and update state variables\n        initialized = false;\n        lastObservationTime = 0;\n        _movingAverage = 0;\n        nextObsIndex = 0;\n        movingAverageDuration = movingAverageDuration_;\n        numObservations = uint32(newObservations);\n\n        emit MovingAverageDurationChanged(movingAverageDuration_);\n    }\n\n    /// @notice   Change the observation frequency of the moving average (i.e. how often a new observation is taken)\n    /// @param    observationFrequency_ - Observation frequency in seconds, must be a divisor of the moving average duration\n    /// @dev      Changing the observation frequency clears existing observation data since it will not be taken at the right time intervals.\n    ///           Ensure that you have saved the existing data and/or can re-populate before calling this function.\n    function changeObservationFrequency(uint48 observationFrequency_) external permissioned {\n        // Moving Average Duration should be divisible by Observation Frequency to get a whole number of observations\n        if (observationFrequency_ == 0 || movingAverageDuration % observationFrequency_ != 0)\n            revert Price_InvalidParams();\n\n        // Calculate the new number of observations\n        uint256 newObservations = uint256(movingAverageDuration / observationFrequency_);\n\n        // Since the old observations will not be taken at the right intervals,\n        // the observations array will need to be reinitialized.\n        // Although, there are a handful of situations that could be handled\n        // (e.g. clean multiples of the old frequency),\n        // it is easier to do so off-chain and reinitialize the array.\n\n        // Store blank observations array of new size\n        observations = new uint256[](newObservations);\n\n        // Set initialized to false and update state variables\n        initialized = false;\n        lastObservationTime = 0;\n        _movingAverage = 0;\n        nextObsIndex = 0;\n        observationFrequency = observationFrequency_;\n        numObservations = uint32(newObservations);\n\n        emit ObservationFrequencyChanged(observationFrequency_);\n    }\n}"
    },
    {
      "filename": "src/policies/Operator.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IOperator} from \"policies/interfaces/IOperator.sol\";\nimport {IBondAuctioneer} from \"interfaces/IBondAuctioneer.sol\";\nimport {IBondCallback} from \"interfaces/IBondCallback.sol\";\n\nimport {OlympusTreasury} from \"modules/TRSRY.sol\";\nimport {OlympusMinter} from \"modules/MINTR.sol\";\nimport {OlympusPrice} from \"modules/PRICE.sol\";\nimport {OlympusRange} from \"modules/RANGE.sol\";\n\nimport \"src/Kernel.sol\";\n\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\nimport {FullMath} from \"libraries/FullMath.sol\";\n\n/// @title  Olympus Range Operator\n/// @notice Olympus Range Operator (Policy) Contract\n/// @dev    The Olympus Range Operator performs market operations to enforce OlympusDAO's OHM price range\n///         guidance policies against a specific reserve asset. The Operator is maintained by a keeper-triggered\n///         function on the Olympus Heart contract, which orchestrates state updates in the correct order to ensure\n///         market operations use up to date information. When the price of OHM against the reserve asset exceeds\n///         the cushion spread, the Operator deploys bond markets to support the price. The Operator also offers\n///         zero slippage swaps at prices dictated by the wall spread from the moving average. These market operations\n///         are performed up to a specific capacity before the market must stabilize to regenerate the capacity.\ncontract Operator is IOperator, Policy, ReentrancyGuard {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n\n    /* ========== ERRORS =========== */\n\n    error Operator_InvalidParams();\n    error Operator_InsufficientCapacity();\n    error Operator_AmountLessThanMinimum(uint256 amountOut, uint256 minAmountOut);\n    error Operator_WallDown();\n    error Operator_AlreadyInitialized();\n    error Operator_NotInitialized();\n    error Operator_Inactive();\n\n    /* ========== EVENTS =========== */\n    event Swap(\n        ERC20 indexed tokenIn_,\n        ERC20 indexed tokenOut_,\n        uint256 amountIn_,\n        uint256 amountOut_\n    );\n    event CushionFactorChanged(uint32 cushionFactor_);\n    event CushionParamsChanged(uint32 duration_, uint32 debtBuffer_, uint32 depositInterval_);\n    event ReserveFactorChanged(uint32 reserveFactor_);\n    event RegenParamsChanged(uint32 wait_, uint32 threshold_, uint32 observe_);\n\n    /* ========== STATE VARIABLES ========== */\n\n    /// Operator variables, defined in the interface on the external getter functions\n    Status internal _status;\n    Config internal _config;\n\n    /// @notice    Whether the Operator has been initialized\n    bool public initialized;\n\n    /// @notice    Whether the Operator is active\n    bool public active;\n\n    /// Modules\n    OlympusPrice internal PRICE;\n    OlympusRange internal RANGE;\n    OlympusTreasury internal TRSRY;\n    OlympusMinter internal MINTR;\n\n    /// External contracts\n    /// @notice     Auctioneer contract used for cushion bond market deployments\n    IBondAuctioneer public auctioneer;\n    /// @notice     Callback contract used for cushion bond market payouts\n    IBondCallback public callback;\n\n    /// Tokens\n    /// @notice     OHM token contract\n    ERC20 public immutable ohm;\n    uint8 public immutable ohmDecimals;\n    /// @notice     Reserve token contract\n    ERC20 public immutable reserve;\n    uint8 public immutable reserveDecimals;\n\n    /// Constants\n    uint32 public constant FACTOR_SCALE = 1e4;\n\n    /* ========== CONSTRUCTOR ========== */\n    constructor(\n        Kernel kernel_,\n        IBondAuctioneer auctioneer_,\n        IBondCallback callback_,\n        ERC20[2] memory tokens_, // [ohm, reserve]\n        uint32[8] memory configParams // [cushionFactor, cushionDuration, cushionDebtBuffer, cushionDepositInterval, reserveFactor, regenWait, regenThreshold, regenObserve]\n    ) Policy(kernel_) {\n        /// Check params are valid\n        if (address(auctioneer_) == address(0) || address(callback_) == address(0))\n            revert Operator_InvalidParams();\n\n        if (configParams[1] > uint256(7 days) || configParams[1] < uint256(1 days))\n            revert Operator_InvalidParams();\n\n        if (configParams[2] < uint32(10_000)) revert Operator_InvalidParams();\n\n        if (configParams[3] < uint32(1 hours) || configParams[3] > configParams[1])\n            revert Operator_InvalidParams();\n\n        if (configParams[4] > 10000 || configParams[4] < 100) revert Operator_InvalidParams();\n\n        if (\n            configParams[5] < 1 hours ||\n            configParams[6] > configParams[7] ||\n            configParams[7] == uint32(0)\n        ) revert Operator_InvalidParams();\n\n        auctioneer = auctioneer_;\n        callback = callback_;\n        ohm = tokens_[0];\n        ohmDecimals = tokens_[0].decimals();\n        reserve = tokens_[1];\n        reserveDecimals = tokens_[1].decimals();\n\n        Regen memory regen = Regen({\n            count: uint32(0),\n            lastRegen: uint48(block.timestamp),\n            nextObservation: uint32(0),\n            observations: new bool[](configParams[7])\n        });\n\n        _config = Config({\n            cushionFactor: configParams[0],\n            cushionDuration: configParams[1],\n            cushionDebtBuffer: configParams[2],\n            cushionDepositInterval: configParams[3],\n            reserveFactor: configParams[4],\n            regenWait: configParams[5],\n            regenThreshold: configParams[6],\n            regenObserve: configParams[7]\n        });\n\n        _status = Status({low: regen, high: regen});\n\n        emit CushionFactorChanged(configParams[0]);\n        emit CushionParamsChanged(configParams[1], configParams[2], configParams[3]);\n        emit ReserveFactorChanged(configParams[4]);\n        emit RegenParamsChanged(configParams[5], configParams[6], configParams[7]);\n    }\n\n    /* ========== FRAMEWORK CONFIGURATION ========== */\n    /// @inheritdoc Policy\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](4);\n        dependencies[0] = toKeycode(\"PRICE\");\n        dependencies[1] = toKeycode(\"RANGE\");\n        dependencies[2] = toKeycode(\"TRSRY\");\n        dependencies[3] = toKeycode(\"MINTR\");\n\n        PRICE = OlympusPrice(getModuleAddress(dependencies[0]));\n        RANGE = OlympusRange(getModuleAddress(dependencies[1]));\n        TRSRY = OlympusTreasury(getModuleAddress(dependencies[2]));\n        MINTR = OlympusMinter(getModuleAddress(dependencies[3]));\n\n        /// Approve MINTR for burning OHM (called here so that it is re-approved on updates)\n        ohm.safeApprove(address(MINTR), type(uint256).max);\n    }\n\n    /// @inheritdoc Policy\n    function requestPermissions() external view override returns (Permissions[] memory requests) {\n        Keycode RANGE_KEYCODE = RANGE.KEYCODE();\n        Keycode TRSRY_KEYCODE = TRSRY.KEYCODE();\n        Keycode MINTR_KEYCODE = MINTR.KEYCODE();\n\n        requests = new Permissions[](9);\n        requests[0] = Permissions(RANGE_KEYCODE, RANGE.updateCapacity.selector);\n        requests[1] = Permissions(RANGE_KEYCODE, RANGE.updateMarket.selector);\n        requests[2] = Permissions(RANGE_KEYCODE, RANGE.updatePrices.selector);\n        requests[3] = Permissions(RANGE_KEYCODE, RANGE.regenerate.selector);\n        requests[4] = Permissions(RANGE_KEYCODE, RANGE.setSpreads.selector);\n        requests[5] = Permissions(RANGE_KEYCODE, RANGE.setThresholdFactor.selector);\n        requests[6] = Permissions(TRSRY_KEYCODE, TRSRY.setApprovalFor.selector);\n        requests[7] = Permissions(MINTR_KEYCODE, MINTR.mintOhm.selector);\n        requests[8] = Permissions(MINTR_KEYCODE, MINTR.burnOhm.selector);\n    }\n\n    modifier onlyWhileActive() {\n        if (!active) revert Operator_Inactive();\n        _;\n    }\n\n    /* ========== HEART FUNCTIONS ========== */\n    /// @inheritdoc IOperator\n    function operate() external override onlyWhileActive onlyRole(\"operator_operate\") {\n        /// Revert if not initialized\n        if (!initialized) revert Operator_NotInitialized();\n\n        /// Update the prices for the range, save new regen observations, and update capacities based on bond market activity\n        _updateRangePrices();\n        _addObservation();\n        _updateCapacity(true, 0);\n        _updateCapacity(false, 0);\n\n        /// Cache config in memory\n        Config memory config_ = _config;\n\n        /// Check if walls can regenerate capacity\n        if (\n            uint48(block.timestamp) >= RANGE.lastActive(true) + uint48(config_.regenWait) &&\n            _status.high.count >= config_.regenThreshold\n        ) {\n            _regenerate(true);\n        }\n        if (\n            uint48(block.timestamp) >= RANGE.lastActive(false) + uint48(config_.regenWait) &&\n            _status.low.count >= config_.regenThreshold\n        ) {\n            _regenerate(false);\n        }\n\n        /// Cache range data after potential regeneration\n        OlympusRange.Range memory range = RANGE.range();\n\n        /// Get latest price\n        /// See note in addObservation() for more details\n        uint256 currentPrice = PRICE.getLastPrice();\n\n        /// Check if the cushion bond markets are active\n        /// if so, determine if it should stay open or close\n        /// if not, check if a new one should be opened\n        if (range.low.active) {\n            if (auctioneer.isLive(range.low.market)) {\n                /// if active, check if the price is back above the cushion\n                /// or if the price is below the wall\n                /// if so, close the market\n                if (currentPrice > range.cushion.low.price || currentPrice < range.wall.low.price) {\n                    _deactivate(false);\n                }\n            } else {\n                /// if not active, check if the price is below the cushion\n                /// if so, open a new bond market\n                if (currentPrice < range.cushion.low.price && currentPrice > range.wall.low.price) {\n                    _activate(false);\n                }\n            }\n        }\n        if (range.high.active) {\n            if (auctioneer.isLive(range.high.market)) {\n                /// if active, check if the price is back under the cushion\n                /// or if the price is above the wall\n                /// if so, close the market\n                if (\n                    currentPrice < range.cushion.high.price || currentPrice > range.wall.high.price\n                ) {\n                    _deactivate(true);\n                }\n            } else {\n                /// if not active, check if the price is above the cushion\n                /// if so, open a new bond market\n                if (\n                    currentPrice > range.cushion.high.price && currentPrice < range.wall.high.price\n                ) {\n                    _activate(true);\n                }\n            }\n        }\n    }\n\n    /* ========== OPEN MARKET OPERATIONS (WALL) ========== */\n    /// @inheritdoc IOperator\n    function swap(\n        ERC20 tokenIn_,\n        uint256 amountIn_,\n        uint256 minAmountOut_\n    ) external override onlyWhileActive nonReentrant returns (uint256 amountOut) {\n        if (tokenIn_ == ohm) {\n            /// Revert if lower wall is inactive\n            if (!RANGE.active(false)) revert Operator_WallDown();\n\n            /// Calculate amount out (checks for sufficient capacity)\n            amountOut = getAmountOut(tokenIn_, amountIn_);\n\n            /// Revert if amount out less than the minimum specified\n            /// @dev even though price is fixed most of the time,\n            /// it is possible that the amount out could change on a sender\n            /// due to the wall prices being updated before their transaction is processed.\n            /// This would be the equivalent of the heart.beat front-running the sender.\n            if (amountOut < minAmountOut_)\n                revert Operator_AmountLessThanMinimum(amountOut, minAmountOut_);\n\n            /// Decrement wall capacity\n            _updateCapacity(false, amountOut);\n\n            /// If wall is down after swap, deactive the cushion as well\n            _checkCushion(false);\n\n            /// Transfer OHM from sender\n            ohm.safeTransferFrom(msg.sender, address(this), amountIn_);\n\n            /// Burn OHM\n            MINTR.burnOhm(address(this), amountIn_);\n\n            /// Withdraw and transfer reserve to sender\n            TRSRY.withdrawReserves(msg.sender, reserve, amountOut);\n\n            emit Swap(ohm, reserve, amountIn_, amountOut);\n        } else if (tokenIn_ == reserve) {\n            /// Revert if upper wall is inactive\n            if (!RANGE.active(true)) revert Operator_WallDown();\n\n            /// Calculate amount out (checks for sufficient capacity)\n            amountOut = getAmountOut(tokenIn_, amountIn_);\n\n            /// Revert if amount out less than the minimum specified\n            /// @dev even though price is fixed most of the time,\n            /// it is possible that the amount out could change on a sender\n            /// due to the wall prices being updated before their transaction is processed.\n            /// This would be the equivalent of the heart.beat front-running the sender.\n            if (amountOut < minAmountOut_)\n                revert Operator_AmountLessThanMinimum(amountOut, minAmountOut_);\n\n            /// Decrement wall capacity\n            _updateCapacity(true, amountOut);\n\n            /// If wall is down after swap, deactive the cushion as well\n            _checkCushion(true);\n\n            /// Transfer reserves to treasury\n            reserve.safeTransferFrom(msg.sender, address(TRSRY), amountIn_);\n\n            /// Mint OHM to sender\n            MINTR.mintOhm(msg.sender, amountOut);\n\n            emit Swap(reserve, ohm, amountIn_, amountOut);\n        } else {\n            revert Operato"
    }
  ]
}