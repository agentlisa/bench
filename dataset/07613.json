{
  "Title": "[H-06] fee loss in AutoPxGmx and AutoPxGlp and reward loss in AutoPxGlp by calling `PirexRewards.claim(pxGmx/pxGpl, AutoPx*)` directly which transfers rewards to  AutoPx* pool without compound logic get executed and fee calculation logic and pxGmx wouldn't be executed for those rewards",
  "Content": "\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGlp.sol#L197-L296>\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L230-L313>\n\n### Impact\n\nFunction `compound()` in `AutoPxGmx` and `AutoPxGlp` contracts is for compounding `pxGLP` (and additionally `pxGMX`) rewards. it works by calling `PirexGmx.claim(px*, this)` to collect the rewards of the vault and then swap the received amount (to calculate the reward, contract save the balance of a contract in that reward token before and after the call to the `claim()` and by subtracting them finds the received reward amount) and deposit them in `PirexGmx` again for compounding and in doing so it calculates fee based on what it received and in `AutoPxGlp` case it calculates `pxGMX` rewards too based on the extra amount contract receives during the execution of `claim()`. But attacker can call `PirexGmx.claim(px*, PirexGlp)` directly and make `PirexGmx` contract to transfer (`gmxBaseReward` and `pxGmx`) rewards to `AutoPxGlp` and in this case the logics of fee calculation and reward calculation in `compound()` function won't get executed and contract won't get it's fee from rewards and users won't get their `pxGmx` reward. So this bug would cause fee loss in `AutoPxGmx` and `AutoPxGlp` for contract and `pxGmx`'s reward loss for users in `AutoPxGlp`.\n\n### Proof of Concept\n\nThe bug in `AutoPxGmx` is similar to `AutoPxGlp`, so we only give Proof of Concept for `AutoPxGlp`.\n\nThis is `compound()` function code in `AutoPxGlp` contract:\n\n        function compound(\n            uint256 minUsdg,\n            uint256 minGlp,\n            bool optOutIncentive\n        )\n            public\n            returns (\n                uint256 gmxBaseRewardAmountIn,\n                uint256 pxGmxAmountOut,\n                uint256 pxGlpAmountOut,\n                uint256 totalPxGlpFee,\n                uint256 totalPxGmxFee,\n                uint256 pxGlpIncentive,\n                uint256 pxGmxIncentive\n            )\n        {\n            if (minUsdg == 0) revert InvalidParam();\n            if (minGlp == 0) revert InvalidParam();\n\n            uint256 preClaimTotalAssets = asset.balanceOf(address(this));\n            uint256 preClaimPxGmxAmount = pxGmx.balanceOf(address(this));\n\n            PirexRewards(rewardsModule).claim(asset, address(this));\n            PirexRewards(rewardsModule).claim(pxGmx, address(this));\n\n            // Track the amount of rewards received\n            gmxBaseRewardAmountIn = gmxBaseReward.balanceOf(address(this));\n\n            if (gmxBaseRewardAmountIn != 0) {\n                // Deposit received rewards for pxGLP\n                (, pxGlpAmountOut, ) = PirexGmx(platform).depositGlp(\n                    address(gmxBaseReward),\n                    gmxBaseRewardAmountIn,\n                    minUsdg,\n                    minGlp,\n                    address(this)\n                );\n            }\n\n            // Distribute fees if the amount of vault assets increased\n            uint256 newAssets = totalAssets() - preClaimTotalAssets;\n            if (newAssets != 0) {\n                totalPxGlpFee = (newAssets * platformFee) / FEE_DENOMINATOR;\n                pxGlpIncentive = optOutIncentive\n                    ? 0\n                    : (totalPxGlpFee * compoundIncentive) / FEE_DENOMINATOR;\n\n                if (pxGlpIncentive != 0)\n                    asset.safeTransfer(msg.sender, pxGlpIncentive);\n\n                asset.safeTransfer(owner, totalPxGlpFee - pxGlpIncentive);\n            }\n\n            // Track the amount of pxGMX received\n            pxGmxAmountOut = pxGmx.balanceOf(address(this)) - preClaimPxGmxAmount;\n\n            if (pxGmxAmountOut != 0) {\n                // Calculate and distribute pxGMX fees if the amount of pxGMX increased\n                totalPxGmxFee = (pxGmxAmountOut * platformFee) / FEE_DENOMINATOR;\n                pxGmxIncentive = optOutIncentive\n                    ? 0\n                    : (totalPxGmxFee * compoundIncentive) / FEE_DENOMINATOR;\n\n                if (pxGmxIncentive != 0)\n                    pxGmx.safeTransfer(msg.sender, pxGmxIncentive);\n\n                pxGmx.safeTransfer(owner, totalPxGmxFee - pxGmxIncentive);\n\n                // Update the pxGmx reward accrual\n                _harvest(pxGmxAmountOut - totalPxGmxFee);\n            } else {\n                // Required to keep the globalState up-to-date\n                _globalAccrue();\n            }\n\n            emit Compounded(\n                msg.sender,\n                minGlp,\n                gmxBaseRewardAmountIn,\n                pxGmxAmountOut,\n                pxGlpAmountOut,\n                totalPxGlpFee,\n                totalPxGmxFee,\n                pxGlpIncentive,\n                pxGmxIncentive\n            );\n        }\n\nAs you can see contract collects rewards by calling `PirexRewards.claim()` and in the line `uint256 newAssets = totalAssets() - preClaimTotalAssets;` contract calculates the received amount of rewards (by subtracting the balance after and before reward claim) and then calculates fee based on this amount `totalPxGlpFee = (newAssets * platformFee) / FEE_DENOMINATOR;` and then sends the fee in the line `asset.safeTransfer(owner, totalPxGlpFee - pxGlpIncentive)` for `owner`. \n\nThe logic for `pxGmx` rewards are the same. As you can see the calculation of the fee is based on the rewards received, and there is no other logic in the contract to calculate and transfer the fee of protocol. So if `AutoPxGpl` receives rewards without `compound()` getting called then for those rewards fee won't be calculated and transferred and protocol would lose it's fee.\n\nIn the line `_harvest(pxGmxAmountOut - totalPxGmxFee)` contract calls `_harvest()` function to update the `pxGmx` reward accrual and there is no call to `_harvest()` in any other place and this is the only place where `pxGmx` reward accrual gets updated. The contract uses `pxGmxAmountOut` which is the amount of `gmx` contract received during the call (code calculates it by subtracting the balance after and before reward claim: `pxGmxAmountOut = pxGmx.balanceOf(address(this)) - preClaimPxGmxAmount;`) so contract only handles accrual rewards in this function call and if some `pxGmx` rewards claimed for contract without `compund()` logic execution then those rewards won't be used in `_harvest()` and `_globalAccrue()` calculation and users won't receive those rewards.\n\nAs mentioned attacker can call `PirexRewards.claim(pxGmx, AutoPxGpl)` directly and make `PirexRewads` contract to transfer `AutoPxGpl` rewards. This is `claim()` code in `PirexRewards`:\n\n        function claim(ERC20 producerToken, address user) external {\n            if (address(producerToken) == address(0)) revert ZeroAddress();\n            if (user == address(0)) revert ZeroAddress();\n\n            harvest();\n            userAccrue(producerToken, user);\n\n            ProducerToken storage p = producerTokens[producerToken];\n            uint256 globalRewards = p.globalState.rewards;\n            uint256 userRewards = p.userStates[user].rewards;\n\n            // Claim should be skipped and not reverted on zero global/user reward\n            if (globalRewards != 0 && userRewards != 0) {\n                ERC20[] memory rewardTokens = p.rewardTokens;\n                uint256 rLen = rewardTokens.length;\n\n                // Update global and user reward states to reflect the claim\n                p.globalState.rewards = globalRewards - userRewards;\n                p.userStates[user].rewards = 0;\n\n                emit Claim(producerToken, user);\n\n                // Transfer the proportionate reward token amounts to the recipient\n                for (uint256 i; i < rLen; ++i) {\n                    ERC20 rewardToken = rewardTokens[i];\n                    address rewardRecipient = p.rewardRecipients[user][rewardToken];\n                    address recipient = rewardRecipient != address(0)\n                        ? rewardRecipient\n                        : user;\n                    uint256 rewardState = p.rewardStates[rewardToken];\n                    uint256 amount = (rewardState * userRewards) / globalRewards;\n\n                    if (amount != 0) {\n                        // Update reward state (i.e. amount) to reflect reward tokens transferred out\n                        p.rewardStates[rewardToken] = rewardState - amount;\n\n                        producer.claimUserReward(\n                            address(rewardToken),\n                            amount,\n                            recipient\n                        );\n                    }\n                }\n            }\n        }\n\nAs you can see it can be called by anyone for any user. So to perform this attack, attacker would perform these steps:\n\n1.  Suppose `AutoPxGpl` has pending rewards, for example 100 `pxGmx` and 100 `weth`.\n2.  Attacker would call  `PirexRewards.claim(pxGmx, AutoPxGpl)` and  `PirexRewards.claim(pxGpl, AutoPxGpl)` and `PirexRewards` contract would calculate and claim and transfer `pxGmx` rewards and `weth` rewards of `AutoPxGpl` address.\n3.  Then `AutoPxGpl` has no pending rewards but the balance of `pxGmx` and `weth` of contract has been increased.\n4.  If anyone calls `AutoPxGpl.compound()` because there is no pending rewards contract would receive no rewards and because contract only calculates fee and rewards based on received rewards during the call to `compound()` so contract wouldn't calculate any fee or reward accrual for those 1000 `pxGmx` and `weth` rewards.\n5.  `owner` of `AutoPxGpl` would lose his fee for those rewards and users of `AutoPxGpl` would lose their claims for those 1000 `pxGmx` rewards (because the calculation for them didn't happen).\n\nThis bug is because of the fact that the only logic handling rewards is in `compound()` function which is only handling receiving rewards by calling `claim()` during the call to `compound()` but it's possible to call `claim()` directly (`PirexRewards` contract allows this) and `AutoPxGpl` won't get notified about this new rewards and the related logics won't get executed.\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nContract should keep track of it's previous balance when `compound()` get executed and update this balance in deposits and withdraws and claims so it can detect rewards that directly transferred to contract without call to `compound()`.\n\n**[kphed (Redacted Cartel) confirmed](https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/321)** \n\n***\n\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-11-redacted-cartel-contest",
  "Code": [
    {
      "filename": "src/vaults/AutoPxGlp.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {PirexERC4626} from \"src/vaults/PirexERC4626.sol\";\nimport {PxGmxReward} from \"src/vaults/PxGmxReward.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {PirexGmx} from \"src/PirexGmx.sol\";\nimport {PirexRewards} from \"src/PirexRewards.sol\";\n\ncontract AutoPxGlp is PirexERC4626, PxGmxReward, ReentrancyGuard {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    uint256 public constant MAX_WITHDRAWAL_PENALTY = 500;\n    uint256 public constant MAX_PLATFORM_FEE = 2000;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n    uint256 public constant MAX_COMPOUND_INCENTIVE = 5000;\n    uint256 public constant EXPANDED_DECIMALS = 1e30;\n\n    uint256 public withdrawalPenalty = 300;\n    uint256 public platformFee = 1000;\n    uint256 public compoundIncentive = 1000;\n    address public platform;\n\n    // Address of the rewards module (ie. PirexRewards instance)\n    address public immutable rewardsModule;\n\n    // GMX protocol base reward (e.g. WETH)\n    ERC20 public immutable gmxBaseReward;\n\n    event WithdrawalPenaltyUpdated(uint256 penalty);\n    event PlatformFeeUpdated(uint256 fee);\n    event CompoundIncentiveUpdated(uint256 incentive);\n    event PlatformUpdated(address _platform);\n    event Compounded(\n        address indexed caller,\n        uint256 minGlp,\n        uint256 gmxBaseRewardAmount,\n        uint256 pxGmxAmountOut,\n        uint256 pxGlpAmountOut,\n        uint256 totalPxGlpFee,\n        uint256 totalPxGmxFee,\n        uint256 pxGlpIncentive,\n        uint256 pxGmxIncentive\n    );\n\n    error ZeroAmount();\n    error InvalidAssetParam();\n    error ExceedsMax();\n    error InvalidParam();\n    error ZeroShares();\n\n    /**\n        @param  _gmxBaseReward  address  GMX reward token contract address\n        @param  _asset          address  Asset address (vault asset, e.g. pxGLP)\n        @param  _pxGmx          address  pxGMX address (as secondary reward)\n        @param  _name           string   Asset name (e.g. Autocompounding pxGLP)\n        @param  _symbol         string   Asset symbol (e.g. apxGLP)\n        @param  _platform       address  Platform address (e.g. PirexGmx)\n        @param  _rewardsModule  address  Rewards module address\n     */\n    constructor(\n        address _gmxBaseReward,\n        address _asset,\n        address _pxGmx,\n        string memory _name,\n        string memory _symbol,\n        address _platform,\n        address _rewardsModule\n    ) PxGmxReward(_pxGmx) PirexERC4626(ERC20(_asset), _name, _symbol) {\n        if (_gmxBaseReward == address(0)) revert ZeroAddress();\n        if (_asset == address(0)) revert ZeroAddress();\n        if (bytes(_name).length == 0) revert InvalidAssetParam();\n        if (bytes(_symbol).length == 0) revert InvalidAssetParam();\n        if (_platform == address(0)) revert ZeroAddress();\n        if (_rewardsModule == address(0)) revert ZeroAddress();\n\n        gmxBaseReward = ERC20(_gmxBaseReward);\n        platform = _platform;\n        rewardsModule = _rewardsModule;\n\n        // Approve the Uniswap V3 router to manage our base reward (inbound swap token)\n        gmxBaseReward.safeApprove(address(_platform), type(uint256).max);\n    }\n\n    /**\n        @notice Set the withdrawal penalty\n        @param  penalty  uint256  Withdrawal penalty\n     */\n    function setWithdrawalPenalty(uint256 penalty) external onlyOwner {\n        if (penalty > MAX_WITHDRAWAL_PENALTY) revert ExceedsMax();\n\n        withdrawalPenalty = penalty;\n\n        emit WithdrawalPenaltyUpdated(penalty);\n    }\n\n    /**\n        @notice Set the platform fee\n        @param  fee  uint256  Platform fee\n     */\n    function setPlatformFee(uint256 fee) external onlyOwner {\n        if (fee > MAX_PLATFORM_FEE) revert ExceedsMax();\n\n        platformFee = fee;\n\n        emit PlatformFeeUpdated(fee);\n    }\n\n    /**\n        @notice Set the compound incentive\n        @param  incentive  uint256  Compound incentive\n     */\n    function setCompoundIncentive(uint256 incentive) external onlyOwner {\n        if (incentive > MAX_COMPOUND_INCENTIVE) revert ExceedsMax();\n\n        compoundIncentive = incentive;\n\n        emit CompoundIncentiveUpdated(incentive);\n    }\n\n    /**\n        @notice Set the platform\n        @param  _platform  address  Platform\n     */\n    function setPlatform(address _platform) external onlyOwner {\n        if (_platform == address(0)) revert ZeroAddress();\n\n        platform = _platform;\n\n        emit PlatformUpdated(_platform);\n    }\n\n    /**\n        @notice Get the pxGLP custodied by the AutoPxGlp contract\n        @return uint256  Amount of pxGLP custodied by the autocompounder\n     */\n    function totalAssets() public view override returns (uint256) {\n        return asset.balanceOf(address(this));\n    }\n\n    /**\n        @notice Preview the amount of assets a user would receive from redeeming shares\n        @param  shares   uint256  Shares amount\n        @return          uint256  Assets amount\n     */\n    function previewRedeem(uint256 shares)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate assets based on a user's % ownership of vault shares\n        uint256 assets = convertToAssets(shares);\n\n        uint256 _totalSupply = totalSupply;\n\n        // Calculate a penalty - zero if user is the last to withdraw\n        uint256 penalty = (_totalSupply == 0 || _totalSupply - shares == 0)\n            ? 0\n            : assets.mulDivDown(withdrawalPenalty, FEE_DENOMINATOR);\n\n        // Redeemable amount is the post-penalty amount\n        return assets - penalty;\n    }\n\n    /**\n        @notice Preview the amount of shares a user would need to redeem the specified asset amount\n        @notice This modified version takes into consideration the withdrawal fee\n        @param  assets   uint256  Assets amount\n        @return          uint256  Shares amount\n     */\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate shares based on the specified assets' proportion of the pool\n        uint256 shares = convertToShares(assets);\n\n        // Save 1 SLOAD\n        uint256 _totalSupply = totalSupply;\n\n        // Factor in additional shares to fulfill withdrawal if user is not the last to withdraw\n        return\n            (_totalSupply == 0 || _totalSupply - shares == 0)\n                ? shares\n                : (shares * FEE_DENOMINATOR) /\n                    (FEE_DENOMINATOR - withdrawalPenalty);\n    }\n\n    /**\n        @notice Compound pxGLP (and additionally pxGMX) rewards\n        @param  minUsdg                uint256  Minimum USDG amount used when minting GLP\n        @param  minGlp                 uint256  Minimum GLP amount received from the WETH deposit\n        @param  optOutIncentive        bool     Whether to opt out of the incentive\n        @return gmxBaseRewardAmountIn  uint256  WETH inbound amount\n        @return pxGmxAmountOut         uint256  pxGMX outbound amount\n        @return pxGlpAmountOut         uint256  pxGLP outbound amount\n        @return totalPxGlpFee          uint256  Total platform fee for pxGLP\n        @return totalPxGmxFee          uint256  Total platform fee for pxGMX\n        @return pxGlpIncentive         uint256  Compound incentive for pxGLP\n        @return pxGmxIncentive         uint256  Compound incentive for pxGMX\n     */\n    function compound(\n        uint256 minUsdg,\n        uint256 minGlp,\n        bool optOutIncentive\n    )\n        public\n        returns (\n            uint256 gmxBaseRewardAmountIn,\n            uint256 pxGmxAmountOut,\n            uint256 pxGlpAmountOut,\n            uint256 totalPxGlpFee,\n            uint256 totalPxGmxFee,\n            uint256 pxGlpIncentive,\n            uint256 pxGmxIncentive\n        )\n    {\n        if (minUsdg == 0) revert InvalidParam();\n        if (minGlp == 0) revert InvalidParam();\n\n        uint256 preClaimTotalAssets = asset.balanceOf(address(this));\n        uint256 preClaimPxGmxAmount = pxGmx.balanceOf(address(this));\n\n        PirexRewards(rewardsModule).claim(asset, address(this));\n        PirexRewards(rewardsModule).claim(pxGmx, address(this));\n\n        // Track the amount of rewards received\n        gmxBaseRewardAmountIn = gmxBaseReward.balanceOf(address(this));\n\n        if (gmxBaseRewardAmountIn != 0) {\n            // Deposit received rewards for pxGLP\n            (, pxGlpAmountOut, ) = PirexGmx(platform).depositGlp(\n                address(gmxBaseReward),\n                gmxBaseRewardAmountIn,\n                minUsdg,\n                minGlp,\n                address(this)\n            );\n        }\n\n        // Distribute fees if the amount of vault assets increased\n        uint256 newAssets = totalAssets() - preClaimTotalAssets;\n        if (newAssets != 0) {\n            totalPxGlpFee = (newAssets * platformFee) / FEE_DENOMINATOR;\n            pxGlpIncentive = optOutIncentive\n                ? 0\n                : (totalPxGlpFee * compoundIncentive) / FEE_DENOMINATOR;\n\n            if (pxGlpIncentive != 0)\n                asset.safeTransfer(msg.sender, pxGlpIncentive);\n\n            asset.safeTransfer(owner, totalPxGlpFee - pxGlpIncentive);\n        }\n\n        // Track the amount of pxGMX received\n        pxGmxAmountOut = pxGmx.balanceOf(address(this)) - preClaimPxGmxAmount;\n\n        if (pxGmxAmountOut != 0) {\n            // Calculate and distribute pxGMX fees if the amount of pxGMX increased\n            totalPxGmxFee = (pxGmxAmountOut * platformFee) / FEE_DENOMINATOR;\n            pxGmxIncentive = optOutIncentive\n                ? 0\n                : (totalPxGmxFee * compoundIncentive) / FEE_DENOMINATOR;\n\n            if (pxGmxIncentive != 0)\n                pxGmx.safeTransfer(msg.sender, pxGmxIncentive);\n\n            pxGmx.safeTransfer(owner, totalPxGmxFee - pxGmxIncentive);\n\n            // Update the pxGmx reward accrual\n            _harvest(pxGmxAmountOut - totalPxGmxFee);\n        } else {\n            // Required to keep the globalState up-to-date\n            _globalAccrue();\n        }\n\n        emit Compounded(\n            msg.sender,\n            minGlp,\n            gmxBaseRewardAmountIn,\n            pxGmxAmountOut,\n            pxGlpAmountOut,\n            totalPxGlpFee,\n            totalPxGmxFee,\n            pxGlpIncentive,\n            pxGmxIncentive\n        );\n    }\n\n    /**\n        @notice Internal deposit handler\n        @param  assets    uint256  pxGLP amount\n        @param  receiver  address  apxGLP receiver\n        @return shares    uint256  Vault shares (i.e. apxGLP)\n     */\n    function _deposit(uint256 assets, address receiver)\n        internal\n        returns (uint256 shares)\n    {\n        // Check for rounding error since we round down in previewDeposit.\n        uint256 supply = totalSupply;\n\n        if (\n            (shares = supply == 0\n                ? assets\n                : assets.mulDivDown(supply, totalAssets() - assets)) == 0\n        ) revert ZeroShares();\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(receiver, assets, shares);\n    }\n\n    /**\n        @notice Deposit fsGLP for apxGLP\n        @param  amount    uint256  fsGLP amount\n        @param  receiver  address  apxGLP receiver\n        @return           uint256  Vault shares (i.e. apxGLP)\n     */\n    function depositFsGlp(uint256 amount, address receiver)\n        external\n        nonReentrant\n        returns (uint256)\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);\n\n        ERC20 stakedGlp = ERC20(address(PirexGmx(platform).stakedGlp()));\n\n        // Transfer fsGLP from the caller to the vault\n        // before approving PirexGmx to proceed with the deposit\n        stakedGlp.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Approve as needed here since the stakedGlp address is mutable in PirexGmx\n        stakedGlp.safeApprove(platform, amount);\n\n        (, uint256 assets, ) = PirexGmx(platform).depositFsGlp(\n            amount,\n            address(this)\n        );\n\n        // Handle vault deposit after minting pxGLP\n        return _deposit(assets, receiver);\n    }\n\n    /**\n        @notice Deposit GLP (minted with ERC20 tokens) for apxGLP\n        @param  token        address  GMX-whitelisted token for minting GLP\n        @param  tokenAmount  uint256  Whitelisted token amount\n        @param  minUsdg      uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp       uint256  Minimum GLP amount minted from ERC20 tokens\n        @param  receiver     address  apxGLP receiver\n        @return              uint256  Vault shares (i.e. apxGLP)\n     */\n    function depositGlp(\n        address token,\n        uint256 tokenAmount,\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    ) external nonReentrant returns (uint256) {\n        if (token == address(0)) revert ZeroAddress();\n        if (tokenAmount == 0) revert ZeroAmount();\n        if (minUsdg == 0) revert ZeroAmount();\n        if (minGlp == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);\n\n        // PirexGmx will do the check whether the token is whitelisted or not\n        ERC20 erc20Token = ERC20(token);\n\n        // Transfer token from the caller to the vault\n        // before approving PirexGmx to proceed with the deposit\n        erc20Token.safeTransferFrom(msg.sender, address(this), tokenAmount);\n\n        // Approve as needed here since it can be a new whitelisted token (unless it's the baseReward)\n        if (erc20Token != gmxBaseReward) {\n            erc20Token.safeApprove(platform, tokenAmount);\n        }\n\n        (, uint256 assets, ) = PirexGmx(platform).depositGlp(\n            token,\n            tokenAmount,\n            minUsdg,\n            minGlp,\n            address(this)\n        );\n\n        // Handle vault deposit after minting pxGLP\n        return _deposit(assets, receiver);\n    }\n\n    /**\n        @notice Deposit GLP (minted with ETH) for apxGLP\n        @param  minUsdg   uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp    uint256  Minimum GLP amount minted from ETH\n        @param  receiver  address  apxGLP receiver\n        @return           uint256  Vault shares (i.e. apxGLP)\n     */\n    function depositGlpETH(\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    ) external payable nonReentrant returns (uint256) {\n        if (msg.value == 0) revert ZeroAmount();\n        if (minUsdg == 0) revert ZeroAmount();\n        if (minGlp == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);\n\n        (, uint256 assets, ) = PirexGmx(platform).depositGlpETH{\n            value: msg.value\n        }(minUsdg, minGlp, address(this));\n\n        // Handle vault deposit after minting pxGLP\n        return _deposit(assets, receiver);\n    }\n\n    /**\n        @notice Override the withdrawal method to make sure compound is called before withdrawing\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public override returns (uint256 shares) {\n        compound(1, 1, true);\n\n        shares = PirexERC4626.withdraw(assets, receiver, owner);\n    }\n\n    /**\n        @notice Override the redemption method to make sure compound is called before redeeming\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public override returns (uint256 assets) {\n        compound(1, 1, true);\n\n        assets = PirexERC4626.redeem(shares, receiver, owner);\n    }\n\n    /**\n        @notice Compound and internally update pxGMX reward accrual before deposit\n     */\n    function beforeDeposit(\n        address,\n        uint256,\n        uint256\n    ) internal override {\n        compound(1, 1, true);\n    }\n\n    /**\n        @notice Update pxGMX reward accrual after deposit\n        @param  receiver  address  Receiver of the vault shares\n     */\n    function afterDeposit(\n        address receiver,\n        uint256,\n        uint256\n    ) internal override {\n        _globalAccrue();\n        _userAccrue(receiver);\n    }\n\n    /**\n        @notice Update pxGMX reward accrual after withdrawal\n        @param  owner  address  Owner of the vault shares\n     */\n    function afterWithdraw(\n        address owner,\n        uint256,\n        uint256\n    ) internal override {\n        _globalAccrue();\n        _userAccrue(owner);\n    }\n\n    /**\n        @notice Update pxGMX reward accrual for both sender and receiver after transfer\n        @param  owner     address  Owner of the vault shares\n        @param  receiver  address  Receiver of the vault shares\n     */\n    function afterTransfer(\n        address owner,\n        address receiver,\n        uint256\n    ) internal override {\n        _userAccrue(owner);\n        _userAccrue(receiver);\n    }\n}"
    },
    {
      "filename": "src/vaults/AutoPxGmx.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {PirexERC4626} from \"src/vaults/PirexERC4626.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {PirexGmx} from \"src/PirexGmx.sol\";\nimport {PirexRewards} from \"src/PirexRewards.sol\";\nimport {IV3SwapRouter} from \"src/interfaces/IV3SwapRouter.sol\";\n\ncontract AutoPxGmx is ReentrancyGuard, Owned, PirexERC4626 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    IV3SwapRouter public constant SWAP_ROUTER =\n        IV3SwapRouter(0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45);\n    uint256 public constant MAX_WITHDRAWAL_PENALTY = 500;\n    uint256 public constant MAX_PLATFORM_FEE = 2000;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n    uint256 public constant MAX_COMPOUND_INCENTIVE = 5000;\n\n    // Uniswap pool fee\n    uint24 public poolFee = 3000;\n\n    uint256 public withdrawalPenalty = 300;\n    uint256 public platformFee = 1000;\n    uint256 public compoundIncentive = 1000;\n    address public platform;\n\n    // Address of the rewards module (ie. PirexRewards instance)\n    address public immutable rewardsModule;\n\n    ERC20 public immutable gmxBaseReward;\n    ERC20 public immutable gmx;\n\n    event PoolFeeUpdated(uint24 _poolFee);\n    event WithdrawalPenaltyUpdated(uint256 penalty);\n    event PlatformFeeUpdated(uint256 fee);\n    event CompoundIncentiveUpdated(uint256 incentive);\n    event PlatformUpdated(address _platform);\n    event Compounded(\n        address indexed caller,\n        uint24 fee,\n        uint256 amountOutMinimum,\n        uint160 sqrtPriceLimitX96,\n        uint256 gmxBaseRewardAmountIn,\n        uint256 gmxAmountOut,\n        uint256 pxGmxMintAmount,\n        uint256 totalFee,\n        uint256 incentive\n    );\n\n    error ZeroAmount();\n    error ZeroAddress();\n    error InvalidAssetParam();\n    error ExceedsMax();\n    error AlreadySet();\n    error InvalidParam();\n    error ZeroShares();\n\n    /**\n        @param  _gmxBaseReward  address  GMX reward token contract address\n        @param  _gmx            address  GMX token contract address\n        @param  _asset          address  Asset address (e.g. pxGMX)\n        @param  _name           string   Asset name (e.g. Autocompounding pxGMX)\n        @param  _symbol         string   Asset symbol (e.g. apxGMX)\n        @param  _platform       address  Platform address (e.g. PirexGmx)\n        @param  _rewardsModule  address  Rewards module address\n     */\n    constructor(\n        address _gmxBaseReward,\n        address _gmx,\n        address _asset,\n        string memory _name,\n        string memory _symbol,\n        address _platform,\n        address _rewardsModule\n    ) Owned(msg.sender) PirexERC4626(ERC20(_asset), _name, _symbol) {\n        if (_gmxBaseReward == address(0)) revert ZeroAddress();\n        if (_gmx == address(0)) revert ZeroAddress();\n        if (_asset == address(0)) revert ZeroAddress();\n        if (bytes(_name).length == 0) revert InvalidAssetParam();\n        if (bytes(_symbol).length == 0) revert InvalidAssetParam();\n        if (_platform == address(0)) revert ZeroAddress();\n        if (_rewardsModule == address(0)) revert ZeroAddress();\n\n        gmxBaseReward = ERC20(_gmxBaseReward);\n        gmx = ERC20(_gmx);\n        platform = _platform;\n        rewardsModule = _rewardsModule;\n\n        // Approve the Uniswap V3 router to manage our base reward (inbound swap token)\n        gmxBaseReward.safeApprove(address(SWAP_ROUTER), type(uint256).max);\n        gmx.safeApprove(_platform, type(uint256).max);\n    }\n\n    /**\n        @notice Set the Uniswap pool fee\n        @param  _poolFee  uint24  Uniswap pool fee\n     */\n    function setPoolFee(uint24 _poolFee) external onlyOwner {\n        if (_poolFee == 0) revert ZeroAmount();\n\n        poolFee = _poolFee;\n\n        emit PoolFeeUpdated(_poolFee);\n    }\n\n    /**\n        @notice Set the withdrawal penalty\n        @param  penalty  uint256  Withdrawal penalty\n     */\n    function setWithdrawalPenalty(uint256 penalty) external onlyOwner {\n        if (penalty > MAX_WITHDRAWAL_PENALTY) revert ExceedsMax();\n\n        withdrawalPenalty = penalty;\n\n        emit WithdrawalPenaltyUpdated(penalty);\n    }\n\n    /**\n        @notice Set the platform fee\n        @param  fee  uint256  Platform fee\n     */\n    function setPlatformFee(uint256 fee) external onlyOwner {\n        if (fee > MAX_PLATFORM_FEE) revert ExceedsMax();\n\n        platformFee = fee;\n\n        emit PlatformFeeUpdated(fee);\n    }\n\n    /**\n        @notice Set the compound incentive\n        @param  incentive  uint256  Compound incentive\n     */\n    function setCompoundIncentive(uint256 incentive) external onlyOwner {\n        if (incentive > MAX_COMPOUND_INCENTIVE) revert ExceedsMax();\n\n        compoundIncentive = incentive;\n\n        emit CompoundIncentiveUpdated(incentive);\n    }\n\n    /**\n        @notice Set the platform\n        @param  _platform  address  Platform\n     */\n    function setPlatform(address _platform) external onlyOwner {\n        if (_platform == address(0)) revert ZeroAddress();\n\n        platform = _platform;\n\n        emit PlatformUpdated(_platform);\n    }\n\n    /**\n        @notice Get the pxGMX custodied by the AutoPxGmx contract\n        @return uint256  Amount of pxGMX custodied by the autocompounder\n     */\n    function totalAssets() public view override returns (uint256) {\n        return asset.balanceOf(address(this));\n    }\n\n    /**\n        @notice Preview the amount of assets a user would receive from redeeming shares\n        @param  shares  uint256  Shares\n        @return uint256  Assets\n     */\n    function previewRedeem(uint256 shares)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate assets based on a user's % ownership of vault shares\n        uint256 assets = convertToAssets(shares);\n\n        uint256 _totalSupply = totalSupply;\n\n        // Calculate a penalty - zero if user is the last to withdraw\n        uint256 penalty = (_totalSupply == 0 || _totalSupply - shares == 0)\n            ? 0\n            : assets.mulDivDown(withdrawalPenalty, FEE_DENOMINATOR);\n\n        // Redeemable amount is the post-penalty amount\n        return assets - penalty;\n    }\n\n    /**\n        @notice Preview the amount of shares a user would need to redeem the specified asset amount\n        @notice This modified version takes into consideration the withdrawal fee\n        @param  assets  uint256  Assets\n        @return uint256  Shares\n     */\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate shares based on the specified assets' proportion of the pool\n        uint256 shares = convertToShares(assets);\n\n        // Save 1 SLOAD\n        uint256 _totalSupply = totalSupply;\n\n        // Factor in additional shares to fulfill withdrawal if user is not the last to withdraw\n        return\n            (_totalSupply == 0 || _totalSupply - shares == 0)\n                ? shares\n                : (shares * FEE_DENOMINATOR) /\n                    (FEE_DENOMINATOR - withdrawalPenalty);\n    }\n\n    /**\n        @notice Compound pxGMX rewards before depositing\n     */\n    function beforeDeposit(\n        address,\n        uint256,\n        uint256\n    ) internal override {\n        compound(poolFee, 1, 0, true);\n    }\n\n    /**\n        @notice Compound pxGMX rewards\n        @param  fee                    uint24   Uniswap pool tier fee\n        @param  amountOutMinimum       uint256  Outbound token swap amount\n        @param  sqrtPriceLimitX96      uint160  Swap price impact limit (optional)\n        @param  optOutIncentive        bool     Whether to opt out of the incentive\n        @return gmxBaseRewardAmountIn  uint256  GMX base reward inbound swap amount\n        @return gmxAmountOut           uint256  GMX outbound swap amount\n        @return pxGmxMintAmount        uint256  pxGMX minted when depositing GMX\n        @return totalFee               uint256  Total platform fee\n        @return incentive              uint256  Compound incentive\n     */\n    function compound(\n        uint24 fee,\n        uint256 amountOutMinimum,\n        uint160 sqrtPriceLimitX96,\n        bool optOutIncentive\n    )\n        public\n        returns (\n            uint256 gmxBaseRewardAmountIn,\n            uint256 gmxAmountOut,\n            uint256 pxGmxMintAmount,\n            uint256 totalFee,\n            uint256 incentive\n        )\n    {\n        if (fee == 0) revert InvalidParam();\n        if (amountOutMinimum == 0) revert InvalidParam();\n\n        uint256 assetsBeforeClaim = asset.balanceOf(address(this));\n\n        PirexRewards(rewardsModule).claim(asset, address(this));\n\n        // Swap entire reward balance for GMX\n        gmxBaseRewardAmountIn = gmxBaseReward.balanceOf(address(this));\n\n        if (gmxBaseRewardAmountIn != 0) {\n            gmxAmountOut = SWAP_ROUTER.exactInputSingle(\n                IV3SwapRouter.ExactInputSingleParams({\n                    tokenIn: address(gmxBaseReward),\n                    tokenOut: address(gmx),\n                    fee: fee,\n                    recipient: address(this),\n                    amountIn: gmxBaseRewardAmountIn,\n                    amountOutMinimum: amountOutMinimum,\n                    sqrtPriceLimitX96: sqrtPriceLimitX96\n                })\n            );\n\n            // Deposit entire GMX balance for pxGMX, increasing the asset/share amount\n            (, pxGmxMintAmount, ) = PirexGmx(platform).depositGmx(\n                gmx.balanceOf(address(this)),\n                address(this)\n            );\n        }\n\n        // Only distribute fees if the amount of vault assets increased\n        if ((totalAssets() - assetsBeforeClaim) != 0) {\n            totalFee =\n                ((asset.balanceOf(address(this)) - assetsBeforeClaim) *\n                    platformFee) /\n                FEE_DENOMINATOR;\n            incentive = optOutIncentive\n                ? 0\n                : (totalFee * compoundIncentive) / FEE_DENOMINATOR;\n\n            if (incentive != 0) asset.safeTransfer(msg.sender, incentive);\n\n            asset.safeTransfer(owner, totalFee - incentive);\n        }\n\n        emit Compounded(\n            msg.sender,\n            fee,\n            amountOutMinimum,\n            sqrtPriceLimitX96,\n            gmxBaseRewardAmountIn,\n            gmxAmountOut,\n            pxGmxMintAmount,\n            totalFee,\n            incentive\n        );\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public override returns (uint256 shares) {\n        // Compound rewards and ensure they are properly accounted for prior to withdrawal calculation\n        compound(poolFee, 1, 0, true);\n\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max)\n                allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public override returns (uint256 assets) {\n        // Compound rewards and ensure they are properly accounted for prior to redemption calculation\n        compound(poolFee, 1, 0, true);\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max)\n                allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /**\n        @notice Deposit GMX for apxGMX\n        @param  amount    uint256  GMX amount\n        @param  receiver  address  apxGMX receiver\n        @return shares    uint256  Vault shares (i.e. apxGMX)\n     */\n    function depositGmx(uint256 amount, address receiver)\n        external\n        nonReentrant\n        returns (uint256 shares)\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        // Handle compounding of rewards before deposit (arguments are not used by `beforeDeposit` hook)\n        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);\n\n        // Intake sender GMX\n        gmx.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Convert sender GMX into pxGMX and get the post-fee amount (i.e. assets)\n        (, uint256 assets, ) = PirexGmx(platform).depositGmx(\n            amount,\n            address(this)\n        );\n\n        // NOTE: Modified `convertToShares` logic to consider assets already being in the vault\n        // and handle it by deducting the recently-deposited assets from the total\n        uint256 supply = totalSupply;\n\n        if (\n            (shares = supply == 0\n                ? assets\n                : assets.mulDivDown(supply, totalAssets() - assets)) == 0\n        ) revert ZeroShares();\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n}"
    }
  ]
}