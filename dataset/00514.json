{
  "Title": "`UUPSUpgradeable` was not removed from `KintoWallet`.",
  "Content": "##### Description\n\n- https://github.com/KintoXYZ/kinto-core/blob/f7dd98f66b9dfba1f73758703b808051196e740b/src/wallet/KintoWallet.sol#L29\n\nSince `KintoWallet` is currently `BeaconProxy`(https://github.com/KintoXYZ/kinto-core/blob/f7dd98f66b9dfba1f73758703b808051196e740b/src/wallet/KintoWalletFactory.sol#L98), the value `_IMPLEMENTATION_SLOT` does not exist.\n\nSo, the `upgradeTo` and `upgradeToAndCall` methods are not available.\n\n##### Recommendation\nWe recommend removing inheritance from `UUPSUpgradeable`.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/wallet/KintoWallet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\n\nimport '@aa/core/BaseAccount.sol';\nimport '@aa/samples/callback/TokenCallbackHandler.sol';\n\nimport '../interfaces/IKintoID.sol';\nimport '../libraries/ByteSignature.sol';\nimport '../interfaces/IKintoWallet.sol';\nimport '../interfaces/IKintoWalletFactory.sol';\n\n// import 'forge-std/console2.sol';\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable reason-string */\n\n/**\n  * @title KintoWallet\n  * @dev Kinto Smart Contract Wallet. Supports EIP-4337.\n  *     has execute, eth handling methods and has a single signer \n  *     that can send requests through the entryPoint.\n  */\ncontract KintoWallet is Initializable, BaseAccount, TokenCallbackHandler, UUPSUpgradeable, IKintoWallet {\n    using ECDSA for bytes32;\n    using Address for address;\n\n    /* ============ State Variables ============ */\n    IKintoID public override immutable kintoID;\n    IEntryPoint private immutable _entryPoint;\n\n    uint8 public constant override MAX_SIGNERS = 3;\n    uint8 public constant override SINGLE_SIGNER = 1;\n    uint8 public constant override MINUS_ONE_SIGNER = 2;\n    uint8 public constant override ALL_SIGNERS = 3;\n    uint public constant override RECOVERY_TIME = 7 days;\n\n    IKintoWalletFactory override public factory;\n    uint8 public override signerPolicy = 1; // 1 = single signer, 2 = n-1 required, 3 = all required\n    uint public override inRecovery; // 0 if not in recovery, timestamp when initiated otherwise\n\n    address[] public override owners;\n    address public override recoverer;\n    address[] public override withdrawalWhitelist;\n\n    /* ============ Events ============ */\n    event KintoWalletInitialized(IEntryPoint indexed entryPoint, address indexed owner);\n    event WalletPolicyChanged(uint newPolicy, uint oldPolicy);\n\n    /* ============ Modifiers ============ */\n\n    modifier onlySelf() {\n        _onlySelf();\n        _;\n    }\n\n    modifier onlyFactory() {\n        _onlyFactory();\n        _;\n    }\n\n    modifier onlyRecoverer() {\n        _onlyRecoverer();\n        _;\n    }\n\n    /* ============ Constructor & Initializers ============ */\n\n    constructor(IEntryPoint __entryPoint, IKintoID _kintoID) {\n        _entryPoint = __entryPoint;\n        kintoID = _kintoID;\n        _disableInitializers();\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n\n    /**\n     * @dev The _entryPoint member is immutable, to reduce gas consumption.  To upgrade EntryPoint,\n     * a new implementation of SimpleAccount must be deployed with the new EntryPoint address, then upgrading\n     * the implementation by calling `upgradeTo()`\n     */\n    function initialize(address anOwner, address _recoverer) external virtual initializer {\n        // require(anOwner != _recoverer, 'recoverer and signer cannot be the same');\n        __UUPSUpgradeable_init();\n        owners.push(anOwner);\n        signerPolicy = SINGLE_SIGNER;\n        recoverer = _recoverer;\n        factory = IKintoWalletFactory(msg.sender);\n        emit KintoWalletInitialized(_entryPoint, anOwner);\n    }\n\n\n    /* ============ Execution methods ============ */\n    \n    /**\n     * execute a transaction (called directly from owner, or by entryPoint)\n     */\n    function execute(address dest, uint256 value, bytes calldata func) external override {\n        _requireFromEntryPoint();\n        dest.functionCallWithValue(func, value);\n    }\n\n    /**\n     * execute a sequence of transactions\n     */\n    function executeBatch(address[] calldata dest, uint256[] calldata values, bytes[] calldata func) external override {\n        _requireFromEntryPoint();\n        require(dest.length == func.length, 'wrong array lengths');\n        for (uint256 i = 0; i < dest.length; i++) {\n            dest[i].functionCallWithValue(func[i], values[i]);\n        }\n    }\n\n    /* ============ Signer Management ============ */\n    \n    /**\n     * @dev Change the signer policy\n     * @param policy new policy\n     */\n    function setSignerPolicy(uint8 policy) external override onlySelf {\n        require(policy > 0 && policy < 4  && policy != signerPolicy, 'invalid policy');\n        require(policy == 1 || owners.length > 1, 'invalid policy');\n        emit WalletPolicyChanged(policy, signerPolicy);\n        signerPolicy = policy;\n    }\n\n    /**\n     * @dev Changed the signers\n     * @param newSigners new signers array\n     */\n    function resetSigners(address[] calldata newSigners) external override onlySelf {\n        _resetSigners(newSigners);\n    }\n\n    /* ============ Whitelist Management ============ */\n\n    /**\n     * @dev Changed the valid withdrawal addresses\n     * @param newWhitelist new signers array\n     */\n    function resetWithdrawalWhitelist(address[] calldata newWhitelist) external override onlySelf {\n        withdrawalWhitelist = newWhitelist;\n    }\n\n    /* ============ Recovery Process ============ */\n\n    /**\n     * @dev Start the recovery process\n     * Can only be called by the factory through a privileged signer\n     */\n    function startRecovery() external override onlyRecoverer {\n        inRecovery = block.timestamp;\n    }\n\n    /**\n     * @dev Finish the recovery process and resets the signers\n     * Can only be called by the factory through a privileged signer\\\n     * @param newSigners new signers array\n     */\n    function finishRecovery(address[] calldata newSigners) external override onlyRecoverer {\n        require(inRecovery > 0 && block.timestamp > 0 && block.timestamp > (inRecovery + RECOVERY_TIME), 'too early');\n        require(!kintoID.isKYC(owners[0]), 'Old KYC must be burned');\n        require(kintoID.isKYC(newSigners[0]), 'New KYC must be minted');\n        _resetSigners(newSigners);\n        inRecovery = 0;\n    }\n\n    /**\n     * @dev Cancel the recovery process\n     * Can only be called by the account holder if he regains access to his wallet\n     */\n    function cancelRecovery() external override onlySelf {\n        inRecovery = 0;\n    }\n\n    /* ============ View Functions ============ */\n\n    // @inheritdoc BaseAccount\n    function entryPoint() public view virtual override returns (IEntryPoint) {\n        return _entryPoint;\n    }\n\n    function getNonce() public view virtual override(BaseAccount, IKintoWallet) returns (uint) {\n        return super.getNonce();\n    }\n\n    function getOwnersCount() public view override returns (uint) {\n        return owners.length;\n    }\n\n    /* ============ IAccountOverrides ============ */\n\n    /// implement template method of BaseAccount\n    function _validateSignature(UserOperation calldata userOp, bytes32 userOpHash)\n        internal override virtual returns (uint256 validationData) {\n        // We don't want to do requires here as it would revert the whole transaction\n        // Check first owner of this account is still KYC'ed\n        if (!kintoID.isKYC(owners[0])) {\n            return SIG_VALIDATION_FAILED;\n        }\n        if (userOp.signature.length != 65 * owners.length) {\n            return SIG_VALIDATION_FAILED;\n        }\n        bytes32 hash = userOpHash.toEthSignedMessageHash();\n        // Single signer\n        if (signerPolicy == 1) {\n            if (owners[0] != hash.recover(userOp.signature))\n                return SIG_VALIDATION_FAILED;\n            return 0;\n        }\n        uint requiredSigners = signerPolicy == 3 ? owners.length : owners.length - 1;\n        bytes[] memory signatures = new bytes[](owners.length);\n        // Split signature from userOp.signature\n        if (owners.length == 2) {\n            (signatures[0], signatures[1]) = ByteSignature.extractTwoSignatures(userOp.signature);\n        } else {\n            (signatures[0], signatures[1], signatures[2]) = ByteSignature.extractThreeSignatures(userOp.signature);\n        }\n        for (uint i = 0; i < owners.length; i++) {\n            if (owners[i] == hash.recover(signatures[i])) {\n                requiredSigners--;\n            }\n        }\n        return requiredSigners;\n    }\n\n    /* ============ Private Functions ============ */\n\n    function _resetSigners(address[] calldata newSigners) internal {\n        require(newSigners.length > 0 && newSigners.length <= MAX_SIGNERS, 'invalid array');\n        require(newSigners[0] != address(0) && kintoID.isKYC(newSigners[0]), 'KYC Required');\n        require(newSigners.length == 1 ||\n            (newSigners.length == 2 && newSigners[0] != newSigners[1]) ||\n            (newSigners.length == 3 && (newSigners[0] != newSigners[1]) &&\n                (newSigners[1] != newSigners[2]) && newSigners[0] != newSigners[2]),\n            'duplicate owners');\n        owners = newSigners;\n    }\n\n    /**\n     * @dev Authorize the upgrade. Only by an owner.\n     * @param newImplementation address of the new implementation\n     */\n    // This function is called by the proxy contract when the implementation is upgraded\n    function _authorizeUpgrade(address newImplementation) internal view override {\n        (newImplementation);\n        _onlySelf();\n    }\n\n    function _onlySelf() internal view {\n        //directly through the account itself (which gets redirected through execute())\n        require(msg.sender == address(this), 'only self');\n    }\n\n    function _onlyFactory() internal view {\n        //directly through the factory\n        require(msg.sender == address(factory), 'only factory');\n    }\n\n    function _onlyRecoverer() internal view {\n        //directly through the factory\n        require(msg.sender == address(recoverer), 'only recoverer');\n    }\n}"
    },
    {
      "filename": "src/wallet/KintoWalletFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\nimport '@openzeppelin/contracts/utils/Create2.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport { UpgradeableBeacon } from '@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol';\nimport { SafeBeaconProxy } from '../proxy/SafeBeaconProxy.sol';\n\nimport '../interfaces/IKintoID.sol';\nimport '../interfaces/IKintoWalletFactory.sol';\nimport './KintoWallet.sol';\n\n/**\n * @title KintoWalletFactory\n * @dev A kinto wallet factory contract for KintoWallet\n *   Sits behind a proxy. It's upgradeable.\n *   A UserOperations \"initCode\" holds the address of the factory,\n *   and a method call (to createAccount, in this sample factory).\n *   The factory's createAccount returns the target account address even if it is already installed.\n *   This way, the entryPoint.getSenderAddress() can be called either\n *   before or after the account is created.\n */\ncontract KintoWalletFactory is Initializable, UUPSUpgradeable, IKintoWalletFactory {\n\n    /* ============ State Variables ============ */\n    address immutable public override factoryOwner;\n    UpgradeableBeacon public immutable beacon;\n\n    IKintoID public override kintoID;\n    mapping (address => uint256) public override walletTs;\n    uint256 public override factoryWalletVersion;\n    uint256 public override totalWallets;\n\n    /* ============ Events ============ */\n    event KintoWalletFactoryCreation(address indexed account, address indexed owner, uint version);\n    event KintoWalletFactoryUpgraded(address indexed oldImplementation,\n        address indexed newImplementation);\n\n    /* ============ Constructor ============ */\n    constructor(UpgradeableBeacon _beaconp) {\n        factoryOwner = msg.sender;\n        beacon = _beaconp;\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Upgrade calling `upgradeTo()`\n     */\n    function initialize(\n        IKintoID _kintoID\n    ) external virtual initializer {\n        __UUPSUpgradeable_init();\n        factoryWalletVersion = 1;\n        kintoID = _kintoID;\n    }\n\n    /**\n     * @dev Upgrade the wallet implementations using the beacon\n     * @param newImplementationWallet The new implementation\n     */\n    function upgradeAllWalletImplementations(\n        IKintoWallet newImplementationWallet\n    ) external override {\n        require(msg.sender == factoryOwner, 'only owner');\n        require(address(newImplementationWallet) != address(0), 'invalid address');\n        factoryWalletVersion++;\n        emit KintoWalletFactoryUpgraded(address(newImplementationWallet),\n            address(newImplementationWallet));\n        beacon.upgradeTo(address(newImplementationWallet));\n    }\n\n    /**\n     *\n     * @dev Create an account, and return its address.\n     * It returns the address even if the account is already deployed.\n     * Note that during UserOperation execution,\n     * this method is called only if the account is not deployed.\n     * This method returns an existing account address so that entryPoint.getSenderAddress()\n     * would work even after account creation\n     * @param owner The owner address\n     * @param recoverer The recoverer address\n     * @param salt The salt to use for the calculation\n     * @return ret address of the account\n     */\n    function createAccount(address owner, address recoverer, uint256 salt) external override returns (\n        IKintoWallet ret\n    ) {\n        require(kintoID.isKYC(owner), 'KYC required');\n        address addr = getAddress(owner, recoverer, salt);\n        uint codeSize = addr.code.length;\n\n        if (codeSize > 0) {\n            return KintoWallet(payable(addr));\n        }\n\n        ret = KintoWallet(payable(\n            new SafeBeaconProxy{salt : bytes32(salt)}(\n                    address(beacon),\n                    abi.encodeWithSelector(\n                        KintoWallet.initialize.selector,\n                        owner,\n                        recoverer\n                    )\n                )\n        ));\n\n        walletTs[address(ret)] = block.timestamp;\n        totalWallets++;\n        // Emit event\n        emit KintoWalletFactoryCreation(address(ret), owner, factoryWalletVersion);\n    }\n\n    /* ============ Deploy Custom Contract ============ */\n\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     * -  sender myst be KYC'd\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deployContract(\n        uint amount,\n        bytes memory bytecode,\n        bytes32 salt\n    ) external override returns (address) {\n        require(kintoID.isKYC(msg.sender), 'KYC required');\n        return Create2.deploy(amount, salt, bytecode);\n    }\n\n    /* ============ View Functions ============ */\n\n    /**\n     * @dev Gets the creation timestamp of a current wallet\n     * @param wallet The wallet address\n     * @return The timestamp of the wallet. 0 if it is not a wallet\n     */\n    function getWalletTimestamp(address wallet) external view override returns (uint256) {\n        return walletTs[wallet];\n    }\n\n    /**\n     * @dev Calculates the counterfactual address of this account\n     * as it would be returned by createAccount()\n     * @param owner The owner address\n     * @param recoverer The address that can recover the account in an emergency\n     * @param salt The salt to use for the calculation\n     * @return The address of the account\n     */\n    function getAddress(address owner, address recoverer, uint256 salt) public view override returns (address) {\n        return Create2.computeAddress(bytes32(salt), keccak256(abi.encodePacked(\n                type(SafeBeaconProxy).creationCode,\n                abi.encode(\n                    address(beacon),\n                    abi.encodeCall(KintoWallet.initialize, (owner, recoverer))\n                )\n            )));\n    }\n\n    /**\n     * @dev Calculates the counterfactual address of this contract as it\n     * would be returned by deployContract()\n     * @param salt Salt used by CREATE2\n     * @param byteCodeHash The bytecode hash (keccack256) of the contract to deploy\n     * @return address of the contract to deploy\n     */\n    function getContractAddress(\n        bytes32 salt,\n        bytes32 byteCodeHash\n    ) public view override returns (address) {\n        return Create2.computeAddress(salt, byteCodeHash, address(this));\n    }\n\n    /**\n     * @dev Authorize the upgrade. Only by an owner.\n     * @param newImplementation address of the new implementation\n     */\n    // This function is called by the proxy contract when the factory is upgraded\n    function _authorizeUpgrade(address newImplementation) internal view override {\n        (newImplementation);\n        require(msg.sender == factoryOwner, 'only owner');\n    }\n}"
    }
  ]
}