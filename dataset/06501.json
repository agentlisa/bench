{
  "Title": "[G-11] Do not calculate constants",
  "Content": "\nDue to how constant variables are implemented (replacements at compile-time), an expression assigned to a constant variable is recomputed each time the variable is used, which wastes some gas.\n\n```solidity\nFile:   src/hermes/minters/BaseV2Minter.sol\n24      uint256 internal constant week = 86400 * 7;\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/hermes/minters/BaseV2Minter.sol#L24\n\n```solidity\nFile:   src/talos/TalosStrategyVanilla.sol  \n47      uint24 private constant protocolFee = 2 * 1e5; //20%\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/talos/TalosStrategyVanilla.sol#L47\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/hermes/minters/BaseV2Minter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC4626} from \"@ERC4626/ERC4626.sol\";\n\nimport {HERMES} from \"@hermes/tokens/HERMES.sol\";\n\nimport {FlywheelGaugeRewards} from \"@rewards/rewards/FlywheelGaugeRewards.sol\";\n\nimport {IBaseV2Minter} from \"../interfaces/IBaseV2Minter.sol\";\n\n/// @title Base V2 Minter - Mints HERMES tokens for the B(3,3) system\ncontract BaseV2Minter is Ownable, IBaseV2Minter {\n    using SafeTransferLib for address;\n\n    /*//////////////////////////////////////////////////////////////\n                         MINTER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev allows minting once per week (reset every Thursday 00:00 UTC)\n    uint256 internal constant week = 86400 * 7;\n    /// @dev 2% per week target emission\n    uint256 internal constant base = 1000;\n\n    uint256 internal constant max_tail_emission = 100;\n    uint256 internal constant max_dao_share = 300;\n\n    /// @inheritdoc IBaseV2Minter\n    address public immutable override underlying;\n    /// @inheritdoc IBaseV2Minter\n    ERC4626 public immutable override vault;\n\n    /// @inheritdoc IBaseV2Minter\n    FlywheelGaugeRewards public override flywheelGaugeRewards;\n    /// @inheritdoc IBaseV2Minter\n    address public override dao;\n\n    /// @inheritdoc IBaseV2Minter\n    uint256 public override daoShare = 100;\n    uint256 public override tailEmission = 20;\n    /// @inheritdoc IBaseV2Minter\n\n    /// @inheritdoc IBaseV2Minter\n    uint256 public override weekly;\n    /// @inheritdoc IBaseV2Minter\n    uint256 public override activePeriod;\n\n    address internal initializer;\n\n    constructor(\n        address _vault, // the B(3,3) system that will be locked into\n        address _dao,\n        address _owner\n    ) {\n        _initializeOwner(_owner);\n        initializer = msg.sender;\n        dao = _dao;\n        underlying = address(ERC4626(_vault).asset());\n        vault = ERC4626(_vault);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         FALLBACK LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    fallback() external {\n        updatePeriod();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ADMIN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2Minter\n    function initialize(FlywheelGaugeRewards _flywheelGaugeRewards) external {\n        if (initializer != msg.sender) revert NotInitializer();\n        flywheelGaugeRewards = _flywheelGaugeRewards;\n        initializer = address(0);\n        activePeriod = (block.timestamp / week) * week;\n    }\n\n    /// @inheritdoc IBaseV2Minter\n    function setDao(address _dao) external onlyOwner {\n        /// @dev DAO can be set to address(0) to disable DAO rewards.\n        dao = _dao;\n    }\n\n    /// @inheritdoc IBaseV2Minter\n    function setDaoShare(uint256 _daoShare) external onlyOwner {\n        if (_daoShare > max_dao_share) revert DaoShareTooHigh();\n        daoShare = _daoShare;\n    }\n\n    /// @inheritdoc IBaseV2Minter\n    function setTailEmission(uint256 _tail_emission) external onlyOwner {\n        if (_tail_emission > max_tail_emission) revert TailEmissionTooHigh();\n        tailEmission = _tail_emission;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         EMISSION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2Minter\n    function circulatingSupply() public view returns (uint256) {\n        return HERMES(underlying).totalSupply() - vault.totalAssets();\n    }\n\n    /// @inheritdoc IBaseV2Minter\n    function weeklyEmission() public view returns (uint256) {\n        return (circulatingSupply() * tailEmission) / base;\n    }\n\n    /// @inheritdoc IBaseV2Minter\n    function calculateGrowth(uint256 _minted) public view returns (uint256) {\n        return (vault.totalAssets() * _minted) / HERMES(underlying).totalSupply();\n    }\n\n    /// @inheritdoc IBaseV2Minter\n    function updatePeriod() public returns (uint256) {\n        uint256 _period = activePeriod;\n        // only trigger if new week\n        if (block.timestamp >= _period + week && initializer == address(0)) {\n            _period = (block.timestamp / week) * week;\n            activePeriod = _period;\n            uint256 newWeeklyEmission = weeklyEmission();\n            weekly += newWeeklyEmission;\n            uint256 _circulatingSupply = circulatingSupply();\n\n            uint256 _growth = calculateGrowth(newWeeklyEmission);\n            uint256 _required = _growth + newWeeklyEmission;\n            /// @dev share of newWeeklyEmission emissions sent to DAO.\n            uint256 share = (_required * daoShare) / base;\n            _required += share;\n            uint256 _balanceOf = underlying.balanceOf(address(this));\n            if (_balanceOf < _required) {\n                HERMES(underlying).mint(address(this), _required - _balanceOf);\n            }\n\n            underlying.safeTransfer(address(vault), _growth);\n\n            if (dao != address(0)) underlying.safeTransfer(dao, share);\n\n            emit Mint(msg.sender, newWeeklyEmission, _circulatingSupply, _growth, share);\n\n            /// @dev queue rewards for the cycle, anyone can call if fails\n            ///      queueRewardsForCycle will call this function but won't enter\n            ///      here because activePeriod was updated\n            try flywheelGaugeRewards.queueRewardsForCycle() {} catch {}\n        }\n        return _period;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         REWARDS STREAM LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2Minter\n    function getRewards() external returns (uint256 totalQueuedForCycle) {\n        if (address(flywheelGaugeRewards) != msg.sender) revert NotFlywheelGaugeRewards();\n        totalQueuedForCycle = weekly;\n        weekly = 0;\n        underlying.safeTransfer(msg.sender, totalQueuedForCycle);\n    }\n}"
    },
    {
      "filename": "src/talos/TalosStrategyVanilla.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Logic inspired by Popsicle Finance Contracts (PopsicleV3Optimizer/contracts/popsicle-v3-optimizer/PopsicleV3Optimizer.sol)\npragma solidity >=0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport {INonfungiblePositionManager} from \"@uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol\";\n\nimport {ITalosOptimizer} from \"./interfaces/ITalosOptimizer.sol\";\nimport {PoolVariables} from \"./libraries/PoolVariables.sol\";\n\nimport {TalosStrategySimple, TalosBaseStrategy} from \"./strategies/TalosStrategySimple.sol\";\n\n/// @title Deploy Vanilla\n/// @notice This library deploys talos vanilla strategies\nlibrary DeployVanilla {\n    function createTalosV3Vanilla(\n        IUniswapV3Pool pool,\n        ITalosOptimizer optimizer,\n        INonfungiblePositionManager nonfungiblePositionManager,\n        address strategyManager,\n        address owner\n    ) public returns (TalosBaseStrategy) {\n        return new TalosStrategyVanilla(\n                pool,\n                optimizer,\n                nonfungiblePositionManager,\n                strategyManager,\n                owner\n            );\n    }\n}\n\n/// @notice Tokenized Vault implementation for Uniswap V3 Non Fungible Positions.\n/// @author Maia DAO (https://github.com/Maia-DAO)\ncontract TalosStrategyVanilla is TalosStrategySimple {\n    using FixedPointMathLib for uint256;\n    using FixedPointMathLib for uint128;\n    using PoolVariables for IUniswapV3Pool;\n\n    /// @notice The protocol's fee in hundredths of a bip, i.e. 1e-6\n    uint24 private constant protocolFee = 2 * 1e5; //20%\n    uint24 private constant GLOBAL_DIVISIONER = 1e6;\n\n    /**\n     * @notice Constructs a new TalosStrategyVanilla contract.\n     * @param _pool The Uniswap V3 pool to manage.\n     * @param _optimizer The optimizer contract to use.\n     * @param _nonfungiblePositionManager The Uniswap V3 Non Fungible Position Manager contract.\n     * @param _strategyManager The strategy manager contract.\n     * @param _owner The owner of the contract.\n     */\n    constructor(\n        IUniswapV3Pool _pool,\n        ITalosOptimizer _optimizer,\n        INonfungiblePositionManager _nonfungiblePositionManager,\n        address _strategyManager,\n        address _owner\n    ) TalosStrategySimple(_pool, _optimizer, _nonfungiblePositionManager, _strategyManager, _owner) {}\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Performs the necessary actions before a withdraw can take place\n    /// @param _tokenId position id that the user is trying to withdraw from\n    function beforeRedeem(uint256 _tokenId, address) internal override {\n        _earnFees(_tokenId);\n        _compoundFees(_tokenId);\n    }\n\n    /// @notice Performs the necessary actions after a withdraw takes place\n    /// @param _tokenId position id that the user is trying to withdraw from\n    function afterRedeem(uint256 _tokenId) internal override {}\n\n    /// @notice Performs the necessary actions before a deposit can take place\n    /// @param _tokenId position id that the user wants to deposit in\n    function beforeDeposit(uint256 _tokenId, address) internal override {\n        _earnFees(_tokenId);\n        _compoundFees(_tokenId);\n    }\n\n    /// @notice Performs the necessary actions after a deposit takes place\n    /// @param _tokenId position id that the user wants to deposit in\n    function afterDeposit(uint256 _tokenId) internal override {}\n\n    /// @notice Performs the necessary actions before a re-range can take place\n    /// @param _tokenId position id that the user wants to re-range\n    function beforeRerange(uint256 _tokenId) internal override {\n        _earnFees(_tokenId);\n    }\n\n    /// @notice Performs the necessary actions after a re-range takes place\n    /// @param _tokenId position id that the user wants to deposit in\n    function afterRerange(uint256 _tokenId) internal override {}\n\n    /// @notice Collects fees from the pool to the protocol.\n    /// @param _tokenId position id that the user wants to collect fees from\n    function _earnFees(uint256 _tokenId) internal {\n        if (liquidity == 0) return; // no fees to collect when liquidity is zero\n\n        (uint256 collect0, uint256 collect1) = nonfungiblePositionManager.collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: _tokenId,\n                recipient: address(this),\n                amount0Max: type(uint128).max,\n                amount1Max: type(uint128).max\n            })\n        );\n\n        uint24 _protocolFee = protocolFee;\n        uint24 _GLOBAL_DIVISIONER = GLOBAL_DIVISIONER;\n\n        // Calculate protocol's fees\n        uint256 earnedProtocolFees0 = (collect0 * _protocolFee) / _GLOBAL_DIVISIONER;\n        uint256 earnedProtocolFees1 = (collect1 * _protocolFee) / _GLOBAL_DIVISIONER;\n        protocolFees0 += earnedProtocolFees0;\n        protocolFees1 += earnedProtocolFees1;\n        emit CollectFees(earnedProtocolFees0, earnedProtocolFees1, collect0, collect1);\n    }\n\n    /// @notice Compounds fees from the pool from a user prespective\n    /// @param _tokenId position id that the user wants to compound fees from\n    function _compoundFees(uint256 _tokenId) internal returns (uint256 amount0, uint256 amount1) {\n        uint256 balance0 = token0.balanceOf(address(this)) - protocolFees0;\n        uint256 balance1 = token1.balanceOf(address(this)) - protocolFees1;\n\n        emit Snapshot(balance0, balance1);\n\n        //Get Liquidity for Optimizer's balances\n        uint128 _liquidity = pool.liquidityForAmounts(balance0, balance1, tickLower, tickUpper);\n\n        // Add liquidity to the pool\n        if (_liquidity > 0) {\n            uint128 liquidityDifference;\n            (liquidityDifference, amount0, amount1) = nonfungiblePositionManager.increaseLiquidity(\n                INonfungiblePositionManager.IncreaseLiquidityParams({\n                    tokenId: _tokenId,\n                    amount0Desired: balance0,\n                    amount1Desired: balance1,\n                    amount0Min: 0,\n                    amount1Min: 0,\n                    deadline: block.timestamp\n                })\n            );\n            liquidity += liquidityDifference;\n            emit CompoundFees(amount0, amount1);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted when fees was collected from the pool\n    /// @param feesFromPool0 Total amount of fees collected in terms of token 0\n    /// @param feesFromPool1 Total amount of fees collected in terms of token 1\n    /// @param usersFees0 Total amount of fees collected by users in terms of token 0\n    /// @param usersFees1 Total amount of fees collected by users in terms of token 1\n    event CollectFees(uint256 feesFromPool0, uint256 feesFromPool1, uint256 usersFees0, uint256 usersFees1);\n\n    /// @notice Emitted when fees was compuonded to the pool\n    /// @param amount0 Total amount of fees compounded in terms of token 0\n    /// @param amount1 Total amount of fees compounded in terms of token 1\n    event CompoundFees(uint256 amount0, uint256 amount1);\n}"
    }
  ]
}