{
  "Title": "Lack of gap Variable",
  "Content": "The [`CCTPGatewayBase` contract](https://github.com/scroll-tech/scroll/blob/f6894bb82f78228b349267ed814375cae2fc1483/contracts/src/libraries/gateway/CCTPGatewayBase.sol#L9) does not contain a gap variable although it is upgradeable.\n\n\nConsider adding a gap variable following [OpenZeppelin's upgradeable contracts guide](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps) to avoid future storage collisions.\n\n\n***Update:** Resolved in [pull request #929](https://github.com/scroll-tech/scroll/pull/929) at commit [5e61a05](https://github.com/scroll-tech/scroll/pull/929/commits/5e61a05f5f543598f3b99ce484bba243ae664e2e).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/libraries/gateway/CCTPGatewayBase.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {IMessageTransmitter} from \"../../interfaces/IMessageTransmitter.sol\";\n\nimport {ScrollGatewayBase} from \"./ScrollGatewayBase.sol\";\n\nabstract contract CCTPGatewayBase is ScrollGatewayBase {\n    /*********\n     * Enums *\n     *********/\n\n    enum CCTPMessageStatus {\n        None,\n        Pending,\n        Relayed\n    }\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The address of L1 USDC address.\n    address public immutable l1USDC;\n\n    /// @notice The address of L2 USDC address.\n    address public immutable l2USDC;\n\n    /// @notice The destination domain for layer2.\n    uint32 public immutable destinationDomain;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The address of TokenMessenger in local domain.\n    address public cctpMessenger;\n\n    /// @notice The address of MessageTransmitter in local domain.\n    address public cctpTransmitter;\n\n    /// @notice Mapping from destination domain CCTP nonce to status.\n    mapping(uint256 => CCTPMessageStatus) public status;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(\n        address _l1USDC,\n        address _l2USDC,\n        uint32 _destinationDomain\n    ) {\n        l1USDC = _l1USDC;\n        l2USDC = _l2USDC;\n        destinationDomain = _destinationDomain;\n    }\n\n    function _initialize(address _cctpMessenger, address _cctpTransmitter) internal {\n        cctpMessenger = _cctpMessenger;\n        cctpTransmitter = _cctpTransmitter;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Claim USDC that has been cross chained.\n    /// @param _nonce The nonce of the message from CCTP.\n    /// @param _cctpMessage The message passed to MessageTransmitter contract in CCTP.\n    /// @param _cctpSignature The message passed to MessageTransmitter contract in CCTP.\n    function claimUSDC(\n        uint256 _nonce,\n        bytes calldata _cctpMessage,\n        bytes calldata _cctpSignature\n    ) public {\n        // Check `_nonce` match with `_cctpMessage`.\n        // According to the encoding of `_cctpMessage`, the nonce is in bytes 12 to 16.\n        // See here: https://github.com/circlefin/evm-cctp-contracts/blob/master/src/messages/Message.sol#L29\n        uint256 _expectedMessageNonce;\n        assembly {\n            _expectedMessageNonce := and(shr(96, calldataload(_cctpMessage.offset)), 0xffffffffffffffff)\n        }\n        require(_expectedMessageNonce == _nonce, \"nonce mismatch\");\n\n        require(status[_nonce] == CCTPMessageStatus.Pending, \"message not relayed\");\n\n        // call transmitter to mint USDC\n        bool _success = IMessageTransmitter(cctpTransmitter).receiveMessage(_cctpMessage, _cctpSignature);\n        require(_success, \"call transmitter failed\");\n\n        status[_nonce] = CCTPMessageStatus.Relayed;\n    }\n}"
    }
  ]
}