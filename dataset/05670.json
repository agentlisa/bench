{
  "Title": "[M-04] Incorrect max precompile address",
  "Content": "\nTwo new precompiles have been introduced (`ECADD` and `ECMUL`) without updating the pointer that indicates the current maximum precompile address (`CURRENT_MAX_PRECOMPILE_ADDRESS`), causing these new precompiles to not be considered as precompiles in the system.\n\n### Impact\n\nThe updated revision of ZkSync Era has introduced two new precompiles, `ECADD` and `ECMUL` at addresses `0x06` and `0x07`, respectively.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/Constants.sol#L27-L28>\n\n```solidity\n27: address constant ECADD_SYSTEM_CONTRACT = address(0x06);\n28: address constant ECMUL_SYSTEM_CONTRACT = address(0x07);\n```\n\nTheir implementation is available in `code/system-contracts/contracts/precompiles/EcAdd.yul` and `code/system-contracts/contracts/precompiles/EcMul.yul`.\n\nPrecompile addresses are tracked by a constant named `CURRENT_MAX_PRECOMPILE_ADDRESS`, which points to the maximum address that is a precompile. The intention here is to have a way to determine if an address is a precompile, i.e. `precompile <=> address <= CURRENT_MAX_PRECOMPILE_ADDRESS`.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/Constants.sol#L35>\n\n```solidity\n35: uint256 constant CURRENT_MAX_PRECOMPILE_ADDRESS = uint256(uint160(SHA256_SYSTEM_CONTRACT));\n```\n\nNote that the implementation still points to the old maximum precompile, which was `SHA256` at address `0x02`. This means that both `ECADD` and `ECMUL` won't be considered as precompiles, this is because their address are greater than the `CURRENT_MAX_PRECOMPILE_ADDRESS`, breaking the invariant.\n\nParticularly, this impacts the `getCodeHash()` function in `AccountCodeStorage`. The function follows the assumption that a precompile is under the `CURRENT_MAX_PRECOMPILE_ADDRESS` constant in order to return the hash of the empty string (`EMPTY_STRING_KECCAK`).\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/AccountCodeStorage.sol#L89-L95>\n\n```solidity\n89:     function getCodeHash(uint256 _input) external view override returns (bytes32) {\n90:         // We consider the account bytecode hash of the last 20 bytes of the input, because\n91:         // according to the spec \"If EXTCODEHASH of A is X, then EXTCODEHASH of A + 2**160 is X\".\n92:         address account = address(uint160(_input));\n93:         if (uint160(account) <= CURRENT_MAX_PRECOMPILE_ADDRESS) {\n94:             return EMPTY_STRING_KECCAK;\n95:         }\n...\n```\n\nAs both `ECADD` and `ECMUL` are greater than `CURRENT_MAX_PRECOMPILE_ADDRESS`, the implementation of `getCodeHash()` will return zero instead of the expected `EMPTY_STRING_KECCAK` constant, as other precompiles do.\n\n### Proof of Concept\n\nThe following test asks the `AccountCodeStorage` contract for the code hash of the new precompiles. The expected value should be the keccak hash of the empty string.\n\n```typescript\ndescribe('AccountCodeStorage', function() {\n    it('fails to return correct hash for ECADD precompile', async () => {\n        expect(await accountCodeStorage.getCodeHash('0x0000000000000000000000000000000000000006')).to.be.eq(\n            EMPTY_STRING_KECCAK\n        );\n    });\n    \n    it('fails to return correct hash for ECMUL precompile', async () => {\n        expect(await accountCodeStorage.getCodeHash('0x0000000000000000000000000000000000000007')).to.be.eq(\n            EMPTY_STRING_KECCAK\n        );\n    });\n});\n```\n\nThe expected results from these tests fail:\n\n      Audit tests\n        AccountCodeStorage\n          1) fails to return correct hash for ECADD precompile\n          2) fails to return correct hash for ECMUL precompile\n\n\n      0 passing (256ms)\n      2 failing\n\n      1) Audit tests\n           AccountCodeStorage\n             fails to return correct hash for ECADD precompile:\n\n          AssertionError: expected '0x00000000000000000000000000000000000…' to equal '0xc5d2460186f7233c927e7db2dcc703c0e50…'\n          + expected - actual\n\n          -0x0000000000000000000000000000000000000000000000000000000000000000\n          +0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\n\n          at Context.<anonymous> (test/Audit.spec.ts:33:110)\n          at processTicksAndRejections (node:internal/process/task_queues:96:5)\n\n      2) Audit tests\n           AccountCodeStorage\n             fails to return correct hash for ECMUL precompile:\n\n          AssertionError: expected '0x00000000000000000000000000000000000…' to equal '0xc5d2460186f7233c927e7db2dcc703c0e50…'\n          + expected - actual\n\n          -0x0000000000000000000000000000000000000000000000000000000000000000\n          +0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\n\n          at Context.<anonymous> (test/Audit.spec.ts:39:110)\n          at processTicksAndRejections (node:internal/process/task_queues:96:5)\n\n### Recommendation\n\nUpdate the `CURRENT_MAX_PRECOMPILE_ADDRESS` pointer to include the new precompile addresses.\n\n```diff\n-    uint256 constant CURRENT_MAX_PRECOMPILE_ADDRESS = uint256(uint160(SHA256_SYSTEM_CONTRACT));\n+    uint256 constant CURRENT_MAX_PRECOMPILE_ADDRESS = uint256(uint160(ECMUL_SYSTEM_CONTRACT));\n```\n\n**[miladpiri (zkSync) confirmed and commented via duplicate issue #142](https://github.com/code-423n4/2023-10-zksync-findings/issues/142#issuecomment-1794953393):**\n> Valid finding. Medium is fair.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-zksync",
  "Code": [
    {
      "filename": "code/system-contracts/contracts/Constants.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {IAccountCodeStorage}  from \"./interfaces/IAccountCodeStorage.sol\";\nimport {INonceHolder} from \"./interfaces/INonceHolder.sol\";\nimport {IContractDeployer} from \"./interfaces/IContractDeployer.sol\";\nimport {IKnownCodesStorage} from \"./interfaces/IKnownCodesStorage.sol\";\nimport {IImmutableSimulator} from \"./interfaces/IImmutableSimulator.sol\";\nimport {IEthToken} from \"./interfaces/IEthToken.sol\";\nimport {IL1Messenger} from \"./interfaces/IL1Messenger.sol\";\nimport {ISystemContext} from \"./interfaces/ISystemContext.sol\";\nimport {ICompressor} from \"./interfaces/ICompressor.sol\";\nimport {IComplexUpgrader} from \"./interfaces/IComplexUpgrader.sol\";\nimport {IBootloaderUtilities} from \"./interfaces/IBootloaderUtilities.sol\";\n\n/// @dev All the system contracts introduced by zkSync have their addresses\n/// started from 2^15 in order to avoid collision with Ethereum precompiles.\nuint160 constant SYSTEM_CONTRACTS_OFFSET = 0x8000; // 2^15\n\n/// @dev All the system contracts must be located in the kernel space,\n/// i.e. their addresses must be below 2^16.\nuint160 constant MAX_SYSTEM_CONTRACT_ADDRESS = 0xffff; // 2^16 - 1\n\naddress constant ECRECOVER_SYSTEM_CONTRACT = address(0x01);\naddress constant SHA256_SYSTEM_CONTRACT = address(0x02);\naddress constant ECADD_SYSTEM_CONTRACT = address(0x06);\naddress constant ECMUL_SYSTEM_CONTRACT = address(0x07);\n\n/// @dev The current maximum deployed precompile address.\n/// Note: currently only two precompiles are deployed:\n/// 0x01 - ecrecover\n/// 0x02 - sha256\n/// Important! So the constant should be updated if more precompiles are deployed.\nuint256 constant CURRENT_MAX_PRECOMPILE_ADDRESS = uint256(uint160(SHA256_SYSTEM_CONTRACT));\n\naddress payable constant BOOTLOADER_FORMAL_ADDRESS = payable(address(SYSTEM_CONTRACTS_OFFSET + 0x01));\nIAccountCodeStorage constant ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT = IAccountCodeStorage(\n    address(SYSTEM_CONTRACTS_OFFSET + 0x02)\n);\nINonceHolder constant NONCE_HOLDER_SYSTEM_CONTRACT = INonceHolder(address(SYSTEM_CONTRACTS_OFFSET + 0x03));\nIKnownCodesStorage constant KNOWN_CODE_STORAGE_CONTRACT = IKnownCodesStorage(address(SYSTEM_CONTRACTS_OFFSET + 0x04));\nIImmutableSimulator constant IMMUTABLE_SIMULATOR_SYSTEM_CONTRACT = IImmutableSimulator(\n    address(SYSTEM_CONTRACTS_OFFSET + 0x05)\n);\nIContractDeployer constant DEPLOYER_SYSTEM_CONTRACT = IContractDeployer(address(SYSTEM_CONTRACTS_OFFSET + 0x06));\n\n// A contract that is allowed to deploy any codehash\n// on any address. To be used only during an upgrade.\naddress constant FORCE_DEPLOYER = address(SYSTEM_CONTRACTS_OFFSET + 0x07);\nIL1Messenger constant L1_MESSENGER_CONTRACT = IL1Messenger(address(SYSTEM_CONTRACTS_OFFSET + 0x08));\naddress constant MSG_VALUE_SYSTEM_CONTRACT = address(SYSTEM_CONTRACTS_OFFSET + 0x09);\n\nIEthToken constant ETH_TOKEN_SYSTEM_CONTRACT = IEthToken(address(SYSTEM_CONTRACTS_OFFSET + 0x0a));\n\naddress constant KECCAK256_SYSTEM_CONTRACT = address(SYSTEM_CONTRACTS_OFFSET + 0x10);\n\nISystemContext constant SYSTEM_CONTEXT_CONTRACT = ISystemContext(payable(address(SYSTEM_CONTRACTS_OFFSET + 0x0b)));\n\nIBootloaderUtilities constant BOOTLOADER_UTILITIES = IBootloaderUtilities(address(SYSTEM_CONTRACTS_OFFSET + 0x0c));\n\naddress constant EVENT_WRITER_CONTRACT = address(SYSTEM_CONTRACTS_OFFSET + 0x0d);\n\nICompressor constant COMPRESSOR_CONTRACT = ICompressor(address(SYSTEM_CONTRACTS_OFFSET + 0x0e));\n\nIComplexUpgrader constant COMPLEX_UPGRADER_CONTRACT = IComplexUpgrader(address(SYSTEM_CONTRACTS_OFFSET + 0x0f));\n\n/// @dev If the bitwise AND of the extraAbi[2] param when calling the MSG_VALUE_SIMULATOR\n/// is non-zero, the call will be assumed to be a system one.\nuint256 constant MSG_VALUE_SIMULATOR_IS_SYSTEM_BIT = 1;\n\n/// @dev The maximal msg.value that context can have\nuint256 constant MAX_MSG_VALUE = 2 ** 128 - 1;\n\n/// @dev Prefix used during derivation of account addresses using CREATE2\n/// @dev keccak256(\"zksyncCreate2\")\nbytes32 constant CREATE2_PREFIX = 0x2020dba91b30cc0006188af794c2fb30dd8520db7e2c088b7fc7c103c00ca494;\n/// @dev Prefix used during derivation of account addresses using CREATE\n/// @dev keccak256(\"zksyncCreate\")\nbytes32 constant CREATE_PREFIX = 0x63bae3a9951d38e8a3fbb7b70909afc1200610fc5bc55ade242f815974674f23;\n\n/// @dev Each state diff consists of 156 bytes of actual data and 116 bytes of unused padding, needed for circuit efficiency.\nuint256 constant STATE_DIFF_ENTRY_SIZE = 272;\n\n/// @dev While the \"real\" amount of pubdata that can be sent rarely exceeds the 110k - 120k, it is better to\n/// allow the operator to provide any reasonably large value in order to avoid unneeded constraints on the operator.\nuint256 constant MAX_ALLOWED_PUBDATA_PER_BATCH = 520000;\n\nenum SystemLogKey {\n    L2_TO_L1_LOGS_TREE_ROOT_KEY,\n    TOTAL_L2_TO_L1_PUBDATA_KEY,\n    STATE_DIFF_HASH_KEY,\n    PACKED_BATCH_AND_L2_BLOCK_TIMESTAMP_KEY,\n    PREV_BATCH_HASH_KEY,\n    CHAINED_PRIORITY_TXN_HASH_KEY,\n    NUMBER_OF_LAYER_1_TXS_KEY,\n    EXPECTED_SYSTEM_CONTRACT_UPGRADE_TX_HASH_KEY\n}\n\n/// @dev The number of leaves in the L2->L1 log Merkle tree. \n/// While formally a tree of any length is acceptable, the node supports only a constant length of 2048 leaves.\nuint256 constant L2_TO_L1_LOGS_MERKLE_TREE_LEAVES = 2048;\n\n/// @dev The length of the derived key in bytes inside compressed state diffs.\nuint256 constant DERIVED_KEY_LENGTH = 32;\n/// @dev The length of the enum index in bytes inside compressed state diffs.\nuint256 constant ENUM_INDEX_LENGTH = 8;\n/// @dev The length of value in bytes inside compressed state diffs.\nuint256 constant VALUE_LENGTH = 32;\n\n/// @dev The length of the compressed initial storage write in bytes.\nuint256 constant COMPRESSED_INITIAL_WRITE_SIZE = DERIVED_KEY_LENGTH + VALUE_LENGTH;\n/// @dev The length of the compressed repeated storage write in bytes.\nuint256 constant COMPRESSED_REPEATED_WRITE_SIZE = ENUM_INDEX_LENGTH + VALUE_LENGTH;\n\n/// @dev The position from which the initial writes start in the compressed state diffs.\nuint256 constant INITIAL_WRITE_STARTING_POSITION = 4;\n\n/// @dev Each storage diffs consists of the following elements:\n/// [20bytes address][32bytes key][32bytes derived key][8bytes enum index][32bytes initial value][32bytes final value]\n/// @dev The offset of the deriived key in a storage diff.\nuint256 constant STATE_DIFF_DERIVED_KEY_OFFSET = 52;\n/// @dev The offset of the enum index in a storage diff.\nuint256 constant STATE_DIFF_ENUM_INDEX_OFFSET = 84;\n/// @dev The offset of the final value in a storage diff.\nuint256 constant STATE_DIFF_FINAL_VALUE_OFFSET = 124;"
    },
    {
      "filename": "code/system-contracts/contracts/Constants.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {IAccountCodeStorage}  from \"./interfaces/IAccountCodeStorage.sol\";\nimport {INonceHolder} from \"./interfaces/INonceHolder.sol\";\nimport {IContractDeployer} from \"./interfaces/IContractDeployer.sol\";\nimport {IKnownCodesStorage} from \"./interfaces/IKnownCodesStorage.sol\";\nimport {IImmutableSimulator} from \"./interfaces/IImmutableSimulator.sol\";\nimport {IEthToken} from \"./interfaces/IEthToken.sol\";\nimport {IL1Messenger} from \"./interfaces/IL1Messenger.sol\";\nimport {ISystemContext} from \"./interfaces/ISystemContext.sol\";\nimport {ICompressor} from \"./interfaces/ICompressor.sol\";\nimport {IComplexUpgrader} from \"./interfaces/IComplexUpgrader.sol\";\nimport {IBootloaderUtilities} from \"./interfaces/IBootloaderUtilities.sol\";\n\n/// @dev All the system contracts introduced by zkSync have their addresses\n/// started from 2^15 in order to avoid collision with Ethereum precompiles.\nuint160 constant SYSTEM_CONTRACTS_OFFSET = 0x8000; // 2^15\n\n/// @dev All the system contracts must be located in the kernel space,\n/// i.e. their addresses must be below 2^16.\nuint160 constant MAX_SYSTEM_CONTRACT_ADDRESS = 0xffff; // 2^16 - 1\n\naddress constant ECRECOVER_SYSTEM_CONTRACT = address(0x01);\naddress constant SHA256_SYSTEM_CONTRACT = address(0x02);\naddress constant ECADD_SYSTEM_CONTRACT = address(0x06);\naddress constant ECMUL_SYSTEM_CONTRACT = address(0x07);\n\n/// @dev The current maximum deployed precompile address.\n/// Note: currently only two precompiles are deployed:\n/// 0x01 - ecrecover\n/// 0x02 - sha256\n/// Important! So the constant should be updated if more precompiles are deployed.\nuint256 constant CURRENT_MAX_PRECOMPILE_ADDRESS = uint256(uint160(SHA256_SYSTEM_CONTRACT));\n\naddress payable constant BOOTLOADER_FORMAL_ADDRESS = payable(address(SYSTEM_CONTRACTS_OFFSET + 0x01));\nIAccountCodeStorage constant ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT = IAccountCodeStorage(\n    address(SYSTEM_CONTRACTS_OFFSET + 0x02)\n);\nINonceHolder constant NONCE_HOLDER_SYSTEM_CONTRACT = INonceHolder(address(SYSTEM_CONTRACTS_OFFSET + 0x03));\nIKnownCodesStorage constant KNOWN_CODE_STORAGE_CONTRACT = IKnownCodesStorage(address(SYSTEM_CONTRACTS_OFFSET + 0x04));\nIImmutableSimulator constant IMMUTABLE_SIMULATOR_SYSTEM_CONTRACT = IImmutableSimulator(\n    address(SYSTEM_CONTRACTS_OFFSET + 0x05)\n);\nIContractDeployer constant DEPLOYER_SYSTEM_CONTRACT = IContractDeployer(address(SYSTEM_CONTRACTS_OFFSET + 0x06));\n\n// A contract that is allowed to deploy any codehash\n// on any address. To be used only during an upgrade.\naddress constant FORCE_DEPLOYER = address(SYSTEM_CONTRACTS_OFFSET + 0x07);\nIL1Messenger constant L1_MESSENGER_CONTRACT = IL1Messenger(address(SYSTEM_CONTRACTS_OFFSET + 0x08));\naddress constant MSG_VALUE_SYSTEM_CONTRACT = address(SYSTEM_CONTRACTS_OFFSET + 0x09);\n\nIEthToken constant ETH_TOKEN_SYSTEM_CONTRACT = IEthToken(address(SYSTEM_CONTRACTS_OFFSET + 0x0a));\n\naddress constant KECCAK256_SYSTEM_CONTRACT = address(SYSTEM_CONTRACTS_OFFSET + 0x10);\n\nISystemContext constant SYSTEM_CONTEXT_CONTRACT = ISystemContext(payable(address(SYSTEM_CONTRACTS_OFFSET + 0x0b)));\n\nIBootloaderUtilities constant BOOTLOADER_UTILITIES = IBootloaderUtilities(address(SYSTEM_CONTRACTS_OFFSET + 0x0c));\n\naddress constant EVENT_WRITER_CONTRACT = address(SYSTEM_CONTRACTS_OFFSET + 0x0d);\n\nICompressor constant COMPRESSOR_CONTRACT = ICompressor(address(SYSTEM_CONTRACTS_OFFSET + 0x0e));\n\nIComplexUpgrader constant COMPLEX_UPGRADER_CONTRACT = IComplexUpgrader(address(SYSTEM_CONTRACTS_OFFSET + 0x0f));\n\n/// @dev If the bitwise AND of the extraAbi[2] param when calling the MSG_VALUE_SIMULATOR\n/// is non-zero, the call will be assumed to be a system one.\nuint256 constant MSG_VALUE_SIMULATOR_IS_SYSTEM_BIT = 1;\n\n/// @dev The maximal msg.value that context can have\nuint256 constant MAX_MSG_VALUE = 2 ** 128 - 1;\n\n/// @dev Prefix used during derivation of account addresses using CREATE2\n/// @dev keccak256(\"zksyncCreate2\")\nbytes32 constant CREATE2_PREFIX = 0x2020dba91b30cc0006188af794c2fb30dd8520db7e2c088b7fc7c103c00ca494;\n/// @dev Prefix used during derivation of account addresses using CREATE\n/// @dev keccak256(\"zksyncCreate\")\nbytes32 constant CREATE_PREFIX = 0x63bae3a9951d38e8a3fbb7b70909afc1200610fc5bc55ade242f815974674f23;\n\n/// @dev Each state diff consists of 156 bytes of actual data and 116 bytes of unused padding, needed for circuit efficiency.\nuint256 constant STATE_DIFF_ENTRY_SIZE = 272;\n\n/// @dev While the \"real\" amount of pubdata that can be sent rarely exceeds the 110k - 120k, it is better to\n/// allow the operator to provide any reasonably large value in order to avoid unneeded constraints on the operator.\nuint256 constant MAX_ALLOWED_PUBDATA_PER_BATCH = 520000;\n\nenum SystemLogKey {\n    L2_TO_L1_LOGS_TREE_ROOT_KEY,\n    TOTAL_L2_TO_L1_PUBDATA_KEY,\n    STATE_DIFF_HASH_KEY,\n    PACKED_BATCH_AND_L2_BLOCK_TIMESTAMP_KEY,\n    PREV_BATCH_HASH_KEY,\n    CHAINED_PRIORITY_TXN_HASH_KEY,\n    NUMBER_OF_LAYER_1_TXS_KEY,\n    EXPECTED_SYSTEM_CONTRACT_UPGRADE_TX_HASH_KEY\n}\n\n/// @dev The number of leaves in the L2->L1 log Merkle tree. \n/// While formally a tree of any length is acceptable, the node supports only a constant length of 2048 leaves.\nuint256 constant L2_TO_L1_LOGS_MERKLE_TREE_LEAVES = 2048;\n\n/// @dev The length of the derived key in bytes inside compressed state diffs.\nuint256 constant DERIVED_KEY_LENGTH = 32;\n/// @dev The length of the enum index in bytes inside compressed state diffs.\nuint256 constant ENUM_INDEX_LENGTH = 8;\n/// @dev The length of value in bytes inside compressed state diffs.\nuint256 constant VALUE_LENGTH = 32;\n\n/// @dev The length of the compressed initial storage write in bytes.\nuint256 constant COMPRESSED_INITIAL_WRITE_SIZE = DERIVED_KEY_LENGTH + VALUE_LENGTH;\n/// @dev The length of the compressed repeated storage write in bytes.\nuint256 constant COMPRESSED_REPEATED_WRITE_SIZE = ENUM_INDEX_LENGTH + VALUE_LENGTH;\n\n/// @dev The position from which the initial writes start in the compressed state diffs.\nuint256 constant INITIAL_WRITE_STARTING_POSITION = 4;\n\n/// @dev Each storage diffs consists of the following elements:\n/// [20bytes address][32bytes key][32bytes derived key][8bytes enum index][32bytes initial value][32bytes final value]\n/// @dev The offset of the deriived key in a storage diff.\nuint256 constant STATE_DIFF_DERIVED_KEY_OFFSET = 52;\n/// @dev The offset of the enum index in a storage diff.\nuint256 constant STATE_DIFF_ENUM_INDEX_OFFSET = 84;\n/// @dev The offset of the final value in a storage diff.\nuint256 constant STATE_DIFF_FINAL_VALUE_OFFSET = 124;"
    },
    {
      "filename": "code/system-contracts/contracts/AccountCodeStorage.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IAccountCodeStorage.sol\";\nimport \"./libraries/Utils.sol\";\nimport {DEPLOYER_SYSTEM_CONTRACT, NONCE_HOLDER_SYSTEM_CONTRACT, CURRENT_MAX_PRECOMPILE_ADDRESS} from \"./Constants.sol\";\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice The storage of this contract serves as a mapping for the code hashes of the 32-byte account addresses.\n * @dev Code hash is not strictly a hash, it's a structure where the first byte denotes the version of the hash,\n * the second byte denotes whether the contract is constructed, and the next two bytes denote the length in 32-byte words.\n * And then the next 28 bytes are the truncated hash.\n * @dev In this version of zkSync, the first byte of the hash MUST be 1.\n * @dev The length of each bytecode MUST be odd.  It's internal code format requirements, due to padding of SHA256 function.\n * @dev It is also assumed that all the bytecode hashes are *known*, i.e. the full bytecodes\n * were published on L1 as calldata. This contract trusts the ContractDeployer and the KnownCodesStorage\n * system contracts to enforce the invariants mentioned above.\n */\ncontract AccountCodeStorage is IAccountCodeStorage {\n    bytes32 constant EMPTY_STRING_KECCAK = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n    modifier onlyDeployer() {\n        require(msg.sender == address(DEPLOYER_SYSTEM_CONTRACT), \"Callable only by the deployer system contract\");\n        _;\n    }\n\n    /// @notice Stores the bytecodeHash of constructing contract.\n    /// @param _address The address of the account to set the codehash to.\n    /// @param _hash The new bytecode hash of the constructing account.\n    /// @dev This method trusts the ContractDeployer to make sure that the bytecode is known and well-formed,\n    /// but checks whether the bytecode hash corresponds to the constructing smart contract.\n    function storeAccountConstructingCodeHash(address _address, bytes32 _hash) external override onlyDeployer {\n        // Check that code hash corresponds to the deploying smart contract\n        require(Utils.isContractConstructing(_hash), \"Code hash is not for a contract on constructor\");\n        _storeCodeHash(_address, _hash);\n    }\n\n    /// @notice Stores the bytecodeHash of constructed contract.\n    /// @param _address The address of the account to set the codehash to.\n    /// @param _hash The new bytecode hash of the constructed account.\n    /// @dev This method trusts the ContractDeployer to make sure that the bytecode is known and well-formed,\n    /// but checks whether the bytecode hash corresponds to the constructed smart contract.\n    function storeAccountConstructedCodeHash(address _address, bytes32 _hash) external override onlyDeployer {\n        // Check that code hash corresponds to the deploying smart contract\n        require(Utils.isContractConstructed(_hash), \"Code hash is not for a constructed contract\");\n        _storeCodeHash(_address, _hash);\n    }\n\n    /// @notice Marks the account bytecodeHash as constructed.\n    /// @param _address The address of the account to mark as constructed\n    function markAccountCodeHashAsConstructed(address _address) external override onlyDeployer {\n        bytes32 codeHash = getRawCodeHash(_address);\n\n        require(Utils.isContractConstructing(codeHash), \"Code hash is not for a contract on constructor\");\n\n        // Get the bytecode hash with \"isConstructor\" flag equal to false\n        bytes32 constructedBytecodeHash = Utils.constructedBytecodeHash(codeHash);\n\n        _storeCodeHash(_address, constructedBytecodeHash);\n    }\n\n    /// @dev Store the codehash of the account without any checks.\n    /// @param _address The address of the account to set the codehash to.\n    /// @param _hash The new account bytecode hash.\n    function _storeCodeHash(address _address, bytes32 _hash) internal {\n        uint256 addressAsKey = uint256(uint160(_address));\n        assembly {\n            sstore(addressAsKey, _hash)\n        }\n    }\n\n    /// @notice Get the codehash stored for an address.\n    /// @param _address The address of the account of which the codehash to return\n    /// @return codeHash The codehash stored for this account.\n    function getRawCodeHash(address _address) public view override returns (bytes32 codeHash) {\n        uint256 addressAsKey = uint256(uint160(_address));\n\n        assembly {\n            codeHash := sload(addressAsKey)\n        }\n    }\n\n    /// @notice Simulate the behavior of the `extcodehash` EVM opcode.\n    /// @param _input The 256-bit account address.\n    /// @return codeHash - hash of the bytecode according to the EIP-1052 specification.\n    function getCodeHash(uint256 _input) external view override returns (bytes32) {\n        // We consider the account bytecode hash of the last 20 bytes of the input, because\n        // according to the spec \"If EXTCODEHASH of A is X, then EXTCODEHASH of A + 2**160 is X\".\n        address account = address(uint160(_input));\n        if (uint160(account) <= CURRENT_MAX_PRECOMPILE_ADDRESS) {\n            return EMPTY_STRING_KECCAK;\n        }\n\n        bytes32 codeHash = getRawCodeHash(account);\n\n        // The code hash is equal to the `keccak256(\"\")` if the account is an EOA with at least one transaction.\n        // Otherwise, the account is either deployed smart contract or an empty account,\n        // for both cases the code hash is equal to the raw code hash.\n        if (codeHash == 0x00 && NONCE_HOLDER_SYSTEM_CONTRACT.getRawNonce(account) > 0) {\n            codeHash = EMPTY_STRING_KECCAK;\n        }\n        // The contract is still on the constructor, which means it is not deployed yet,\n        // so set `keccak256(\"\")` as a code hash. The EVM has the same behavior.\n        else if (Utils.isContractConstructing(codeHash)) {\n            codeHash = EMPTY_STRING_KECCAK;\n        }\n\n        return codeHash;\n    }\n\n    /// @notice Simulate the behavior of the `extcodesize` EVM opcode.\n    /// @param _input The 256-bit account address.\n    /// @return codeSize - the size of the deployed smart contract in bytes.\n    function getCodeSize(uint256 _input) external view override returns (uint256 codeSize) {\n        // We consider the account bytecode size of the last 20 bytes of the input, because\n        // according to the spec \"If EXTCODESIZE of A is X, then EXTCODESIZE of A + 2**160 is X\".\n        address account = address(uint160(_input));\n        bytes32 codeHash = getRawCodeHash(account);\n\n        // If the contract is a default account or is on constructor the code size is zero,\n        // otherwise extract the proper value for it from the bytecode hash.\n        // NOTE: zero address and precompiles are a special case, they are contracts, but we\n        // want to preserve EVM invariants (see EIP-1052 specification). That's why we automatically\n        // return `0` length in the following cases:\n        // - `codehash(0) == 0`\n        // - `account` is a precompile.\n        // - `account` is currently being constructed\n        if (\n            uint160(account) > CURRENT_MAX_PRECOMPILE_ADDRESS &&\n            codeHash != 0x00 &&\n            !Utils.isContractConstructing(codeHash)\n        ) {\n            codeSize = Utils.bytecodeLenInBytes(codeHash);\n        }\n    }\n}"
    }
  ]
}