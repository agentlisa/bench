{
  "Title": "H-7: Stat calculator returns incorrect report for swETH",
  "Content": "# Issue H-7: Stat calculator returns incorrect report for swETH \n\nSource: https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/587 \n\n## Found by \nxiaoming90\n\nStat calculator returns incorrect reports for swETH, causing multiple implications that could lead to losses to the protocol,\n\n## Vulnerability Detail\n\nThe purpose of the in-scope `SwEthEthOracle` contract is to act as a price oracle specifically for swETH (Swell ETH) per the comment in the contract below and the codebase's [README](https://github.com/sherlock-audit/2023-06-tokemak-xiaoming9090/tree/main/v2-core-audit-2023-07-14/src/oracles#lst-oracles)\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/oracles/providers/SwEthEthOracle.sol#L16\n\n```solidity\nFile: SwEthEthOracle.sol\n12: /**\n13:  * @notice Price oracle specifically for swEth (Swell Eth).\n14:  * @dev getPriceEth is not a view fn to support reentrancy checks. Does not actually change state.\n15:  */\n16: contract SwEthEthOracle is SystemComponent, IPriceOracle {\n```\n\nPer the codebase in the contest repository, the price oracle for the swETH is understood to be configured to the `SwEthEthOracle` contract at Line 252 below.\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/test/oracles/RootOracleIntegrationTest.t.sol#L252\n\n```solidity\nFile: RootOracleIntegrationTest.t.sol\n162:         swEthOracle = new SwEthEthOracle(systemRegistry, IswETH(SWETH_MAINNET));\n..SNIP..\n249:         // Lst special pricing case setup\n250:         // priceOracle.registerMapping(SFRXETH_MAINNET, IPriceOracle(address(sfrxEthOracle)));\n251:         priceOracle.registerMapping(WSTETH_MAINNET, IPriceOracle(address(wstEthOracle)));\n252:         priceOracle.registerMapping(SWETH_MAINNET, IPriceOracle(address(swEthOracle)));\n```\n\nThus, in the context of this audit, the price oracle for the swETH is mapped to the `SwEthEthOracle` contract.\n\nBoth the swETH oracle and calculator use the same built-in [`swEth.swETHToETHRate`](https://etherscan.io/address/0xdda46bf18eeb3e06e2f12975a3a184e40581a72f#code#F1#L148) function to retrieve the price of swETH in ETH.\n\n| LST   | Oracle                                    | Calculator                                                   | Rebasing |\n| ----- | ----------------------------------------- | ------------------------------------------------------------ | -------- |\n| swETH | SwEthEthOracle - `swEth.swETHToETHRate()` | SwethLSTCalculator - `IswETH(lstTokenAddress).swETHToETHRate()` | False    |\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/oracles/providers/SwEthEthOracle.sol#L26\n\n```solidity\nFile: SwEthEthOracle.sol\n25:     /// @inheritdoc IPriceOracle\n26:     function getPriceInEth(address token) external view returns (uint256 price) {\n..SNIP..\n30:         // Returns in 1e18 precision.\n31:         price = swEth.swETHToETHRate();\n32:     }\n```\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/stats/calculators/SwethLSTCalculator.sol#L12\n\n```solidity\nFile: SwethLSTCalculator.sol\n12:     function calculateEthPerToken() public view override returns (uint256) {\n13:         return IswETH(lstTokenAddress).swETHToETHRate();\n14:     }\n```\n\nWithin the `LSTCalculatorBase.current` function, assume that the `swEth.swETHToETHRate` function returns $x$ when called. In this case, the `price` at Line 203 below and `backing` in Line 210 below will be set to $x$ since the `getPriceInEth` and `calculateEthPerToken` functions depend on the same `swEth.swETHToETHRate` function internally. Thus, `priceToBacking` will always be 1e18:\n\n$$\n\\begin{align}\npriceToBacking &= \\frac{price \\times 1e18}{backing} \\\\\n&= \\frac{x \\times 1e18}{x} \\\\\n&= 1e18\n\\end{align}\n$$\n\nSince `priceToBacking` is always 1e18, the `premium` will always be zero:\n\n$$\n\\begin{align}\npremium &= priceToBacking - 1e18 \\\\\n&= 1e18 - 1e18 \\\\\n&= 0\n\\end{align}\n$$\n\nAs a result, the calculator for swETH will always report the wrong statistic report for swETH. If there is a premium or discount, the calculator will wrongly report none.\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/stats/calculators/base/LSTCalculatorBase.sol#L189\n\n\n```solidity\nFile: LSTCalculatorBase.sol\n189:     function current() external returns (LSTStatsData memory) {\n..SNIP..\n202:         IRootPriceOracle pricer = systemRegistry.rootPriceOracle();\n203:         uint256 price = pricer.getPriceInEth(lstTokenAddress);\n..SNIP..\n210:             uint256 backing = calculateEthPerToken();\n211:             // price is always 1e18 and backing is in eth, which is 1e18\n212:             priceToBacking = price * 1e18 / backing;\n213:         }\n214: \n215:         // positive value is a premium; negative value is a discount\n216:         int256 premium = int256(priceToBacking) - 1e18;\n217: \n218:         return LSTStatsData({\n219:             lastSnapshotTimestamp: lastSnapshotTimestamp,\n220:             baseApr: baseApr,\n221:             premium: premium,\n222:             slashingCosts: slashingCosts,\n223:             slashingTimestamps: slashingTimestamps\n224:         });\n225:     }\n```\n\n## Impact\n\nThe purpose of the stats/calculators contracts is to store, augment, and clean data relevant to the LMPs. When the solver proposes a rebalance, the strategy uses the stats contracts to calculate a composite return (score) for the proposed destinations. Using that composite return, it determines if the swap is beneficial for the vault.\n\nIf a stat calculator provides inaccurate information, it can cause multiple implications that lead to losses to the protocol, such as false signals allowing the unprofitable rebalance to be executed.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/stats/calculators/base/LSTCalculatorBase.sol#L189\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWhen handling the swETH within the `LSTCalculatorBase.current` function, consider other methods of obtaining the fair market price of swETH that do not rely on the `swEth.swETHToETHRate` function such as external 3rd-party price oracle.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**Trumpero** commented:\n> invalid, I think it's intended to let premium = 0 in case of swETH. Also I don't see any further vulnerability if premium = 0\n\n\n\n**xiaoming9090**\n\nEscalate\n\nAfter my discussion with the protocol team during the audit period (as shown below), the purpose of the `premium` variable is to determine if an LST is trading at a premium/discount relative to its actual ETH backing. This is one of the signals the protocol team uses to estimate the expected return for holding an LST position.\n\n![image](https://github.com/sherlock-audit/2023-06-tokemak-judging/assets/102820284/533bdb5b-f9fe-4123-88df-ee85b27bed0f)\n\nIt is incorrect that the premium for swETH is intended to be always zero, as mentioned in the judging comment. If the premium always returns zero, the stat calculator for swETH is effectively broken, which is a serious issue. The judging comment is also incorrect in stating there is no vulnerability if the premium is zero. The stat calculator exists for a reason, and an incorrect stat calculator ultimately leads to losses to the protocol, as mentioned in the \"Impact\" section of my report:\n\n> The purpose of the stats/calculators contracts is to store, augment, and clean data relevant to the LMPs. When the solver proposes a rebalance, the strategy uses the stats contracts to calculate a composite return (score) for the proposed destinations. Using that composite return, it determines if the swap is beneficial for the vault.\n>\n> If a stat calculator provides inaccurate information, it can cause multiple implications that lead to losses to the protocol, such as false signals allowing the unprofitable rebalance to be executed.\n\nThus, this is a valid High issue.\n\n\n**sherlock-admin2**\n\n > Escalate\n> \n> After my discussion with the protocol team during the audit period (as shown below), the purpose of the `premium` variable is to determine if an LST is trading at a premium/discount relative to its actual ETH backing. This is one of the signals the protocol team uses to estimate the expected return for holding an LST position.\n> \n> ![image](https://github.com/sherlock-audit/2023-06-tokemak-judging/assets/102820284/533bdb5b-f9fe-4123-88df-ee85b27bed0f)\n> \n> It is incorrect that the premium for swETH is intended to be always zero, as mentioned in the judging comment. If the premium always returns zero, the stat calculator for swETH is effectively broken, which is a serious issue. The judging comment is also incorrect in stating there is no vulnerability if the premium is zero. The stat calculator exists for a reason, and an incorrect stat calculator ultimately leads to losses to the protocol, as mentioned in the \"Impact\" section of my report:\n> \n> > The purpose of the stats/calculators contracts is to store, augment, and clean data relevant to the LMPs. When the solver proposes a rebalance, the strategy uses the stats contracts to calculate a composite return (score) for the proposed destinations. Using that composite return, it determines if the swap is beneficial for the vault.\n> >\n> > If a stat calculator provides inaccurate information, it can cause multiple implications that lead to losses to the protocol, such as false signals allowing the unprofitable rebalance to be executed.\n> \n> Thus, this is a valid High issue.\n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Trumpero**\n\nCan u take a look at this issue @codenutt ? \n\n**codenutt**\n\n> Can u take a look at this issue @codenutt ?\n\nYup definitely an issue. Its more an issue with the oracle itself than the calculator, but an issue none the less.\n\n**Evert0x**\n\nPlanning to accept escalation and make issue high.\n\n**Evert0x**\n\nResult:\nHigh\nUnique\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [xiaoming9090](https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/587/#issuecomment-1748036176): accepted\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/101",
  "Code": [
    {
      "filename": "v2-core-audit-2023-07-14/src/oracles/providers/SwEthEthOracle.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\n\npragma solidity 0.8.17;\n\nimport { Errors } from \"src/utils/Errors.sol\";\nimport { IswETH } from \"src/interfaces/external/swell/IswETH.sol\";\nimport { ISystemRegistry } from \"src/interfaces/ISystemRegistry.sol\";\nimport { IPriceOracle } from \"src/interfaces/oracles/IPriceOracle.sol\";\nimport { SystemComponent } from \"src/SystemComponent.sol\";\n\n/**\n * @notice Price oracle specifically for swEth (Swell Eth).\n * @dev getPriceEth is not a view fn to support reentrancy checks. Does not actually change state.\n */\ncontract SwEthEthOracle is SystemComponent, IPriceOracle {\n    IswETH public immutable swEth;\n\n    constructor(ISystemRegistry _systemRegistry, IswETH _swEth) SystemComponent(_systemRegistry) {\n        Errors.verifyNotZero(address(_swEth), \"_swEth\");\n\n        swEth = _swEth;\n    }\n\n    /// @inheritdoc IPriceOracle\n    function getPriceInEth(address token) external view returns (uint256 price) {\n        // Prevents incorrect config at root level.\n        if (token != address(swEth)) revert Errors.InvalidToken(token);\n\n        // Returns in 1e18 precision.\n        price = swEth.swETHToETHRate();\n    }\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/test/oracles/RootOracleIntegrationTest.t.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\n\npragma solidity 0.8.17;\n\n// solhint-disable func-name-mixedcase\n// solhint-disable var-name-mixedcase\n// solhint-disable max-states-count\nimport { Test } from \"forge-std/Test.sol\";\nimport {\n    BAL_VAULT,\n    CURVE_META_REGISTRY_MAINNET,\n    // SFRXETH_MAINNET,\n    TELLOR_ORACLE,\n    WSTETH_MAINNET,\n    STETH_MAINNET,\n    RETH_MAINNET,\n    DAI_MAINNET,\n    USDC_MAINNET,\n    USDT_MAINNET,\n    CBETH_MAINNET,\n    STETH_CL_FEED_MAINNET,\n    RETH_CL_FEED_MAINNET,\n    DAI_CL_FEED_MAINNET,\n    USDC_CL_FEED_MAINNET,\n    USDT_CL_FEED_MAINNET,\n    CBETH_CL_FEED_MAINNET,\n    // WSETH_RETH_SFRXETH_BAL_POOL,\n    USDC_DAI_USDT_BAL_POOL,\n    CBETH_WSTETH_BAL_POOL,\n    RETH_WETH_BAL_POOL,\n    WSETH_WETH_BAL_POOL,\n    ST_ETH_CURVE_LP_TOKEN_MAINNET,\n    STETH_ETH_CURVE_POOL,\n    THREE_CURVE_POOL_MAINNET_LP,\n    STETH_ETH_UNIV2,\n    ETH_USDT_UNIV2,\n    WETH9_ADDRESS,\n    CURVE_ETH,\n    THREE_CURVE_MAINNET,\n    USDC_IN_USD_CL_FEED_MAINNET,\n    ETH_CL_FEED_MAINNET,\n    // ETH_FRXETH_CURVE_POOL_LP,\n    // ETH_FRXETH_CURVE_POOL,\n    STETH_STABLESWAP_NG_POOL,\n    // STETH_FRXETH_POOL_AND_TOKEN_CURVE,\n    RETH_WSTETH_CURVE_POOL_LP,\n    RETH_WSTETH_CURVE_POOL,\n    RETH_WETH_CURVE_POOL,\n    RETH_ETH_CURVE_LP,\n    // FRXETH_MAINNET,\n    TOKE_MAINNET,\n    WSTETH_WETH_MAV,\n    ETH_SWETH_MAV,\n    SWETH_MAINNET,\n    USDT_IN_USD_CL_FEED_MAINNET,\n    CRVUSD_MAINNET,\n    USDP_CL_FEED_MAINNET,\n    TUSD_CL_FEED_MAINNET,\n    FRAX_MAINNET,\n    SUSD_MAINNET,\n    USDP_MAINNET,\n    TUSD_MAINNET,\n    USDP_CL_FEED_MAINNET,\n    TUSD_CL_FEED_MAINNET,\n    FRAX_CL_FEED_MAINNET,\n    SUSD_CL_FEED_MAINNET,\n    USDC_STABLESWAP_NG_POOL,\n    USDT_STABLESWAP_NG_POOL,\n    TUSD_STABLESWAP_NG_POOL,\n    USDP_STABLESWAP_NG_POOL,\n    FRAX_STABLESWAP_NG_POOL,\n    SUSD_STABLESWAP_NG_POOL,\n    CRV_ETH_CURVE_V2_LP,\n    LDO_ETH_CURVE_V2_LP,\n    CRV_ETH_CURVE_V2_POOL,\n    LDO_ETH_CURVE_V2_POOL,\n    CRV_CL_FEED_MAINNET,\n    LDO_CL_FEED_MAINNET,\n    CRV_MAINNET,\n    LDO_MAINNET\n} from \"../utils/Addresses.sol\";\n\nimport { SystemRegistry } from \"src/SystemRegistry.sol\";\nimport { RootPriceOracle, IPriceOracle } from \"src/oracles/RootPriceOracle.sol\";\nimport { AccessController } from \"src/security/AccessController.sol\";\nimport { BalancerLPComposableStableEthOracle } from \"src/oracles/providers/BalancerLPComposableStableEthOracle.sol\";\nimport { BalancerLPMetaStableEthOracle } from \"src/oracles/providers/BalancerLPMetaStableEthOracle.sol\";\nimport { ChainlinkOracle } from \"src/oracles/providers/ChainlinkOracle.sol\";\nimport { CurveV1StableEthOracle } from \"src/oracles/providers/CurveV1StableEthOracle.sol\";\nimport { EthPeggedOracle } from \"src/oracles/providers/EthPeggedOracle.sol\";\n// import { SfrxEthEthOracle } from \"src/oracles/providers/SfrxEthEthOracle.sol\";\nimport { UniswapV2EthOracle } from \"src/oracles/providers/UniswapV2EthOracle.sol\";\nimport { WstETHEthOracle } from \"src/oracles/providers/WstETHEthOracle.sol\";\nimport { MavEthOracle } from \"src/oracles/providers/MavEthOracle.sol\";\nimport { SwEthEthOracle } from \"src/oracles/providers/SwEthEthOracle.sol\";\nimport { CurveV2CryptoEthOracle } from \"src/oracles/providers/CurveV2CryptoEthOracle.sol\";\nimport { BaseOracleDenominations } from \"src/oracles/providers/base/BaseOracleDenominations.sol\";\nimport { CrvUsdOracle } from \"test/mocks/CrvUsdOracle.sol\";\n\nimport { IVault as IBalancerVault } from \"src/interfaces/external/balancer/IVault.sol\";\nimport { CurveResolverMainnet, ICurveResolver, ICurveMetaRegistry } from \"src/utils/CurveResolverMainnet.sol\";\nimport { IAggregatorV3Interface } from \"src/interfaces/external/chainlink/IAggregatorV3Interface.sol\";\nimport { IswETH } from \"src/interfaces/external/swell/IswETH.sol\";\n\n/**\n * This series of tests compares expected values with contract calculated values for lp token pricing.  Below is a guide\n *      that can be used to add tests to this contract.\n *\n *      1) Using `vm.createSelectFork`, create a new fork at a recent block number.  This ensures that the safe price\n *            calculated is using recent data.\n *      2) Register new pool with `priceOracle`, check to see if individual tokens need to be registered with Chainlink\n *            or Tellor, and if lp token needs to be registered with a specific lp token oracle.\n *      3) Using an external source (coingecko, protocol UI, Etherscan), retrieve total value of the pool in USD.\n *            Divide this value by the current price of Eth in USD to get the total value of the pool in Eth.\n *      4) Normalize value of pool in Eth to e18, divide by total number of lp tokens (will already be in e18 in most\n *            cases). Normalize value returned to e18 decimals, this will be the value expected to be returned by\n *            the safe price contract.\n */\ncontract RootOracleIntegrationTest is Test {\n    SystemRegistry public systemRegistry;\n    RootPriceOracle public priceOracle;\n    AccessController public accessControl;\n    CurveResolverMainnet public curveResolver;\n\n    BalancerLPComposableStableEthOracle public balancerComposableOracle;\n    BalancerLPMetaStableEthOracle public balancerMetaOracle;\n    ChainlinkOracle public chainlinkOracle;\n    CurveV1StableEthOracle public curveStableOracle;\n    EthPeggedOracle public ethPegOracle;\n    // SfrxEthEthOracle public sfrxEthOracle;\n    UniswapV2EthOracle public uniV2EthOracle;\n    WstETHEthOracle public wstEthOracle;\n    MavEthOracle public mavEthOracle;\n    SwEthEthOracle public swEthOracle;\n    CurveV2CryptoEthOracle public curveCryptoOracle;\n    CrvUsdOracle public crvUsdOracle;\n\n    function setUp() external {\n        vm.createSelectFork(vm.envString(\"MAINNET_RPC_URL\"), 17_474_729);\n\n        // Set up system level contracts.\n        systemRegistry = new SystemRegistry(TOKE_MAINNET, WETH9_ADDRESS);\n        accessControl = new AccessController(address(systemRegistry));\n\n        systemRegistry.setAccessController(address(accessControl));\n        priceOracle = new RootPriceOracle(systemRegistry);\n\n        systemRegistry.setRootPriceOracle(address(priceOracle));\n        curveResolver = new CurveResolverMainnet(ICurveMetaRegistry(CURVE_META_REGISTRY_MAINNET));\n\n        // Set up various oracle contracts\n        balancerComposableOracle = new BalancerLPComposableStableEthOracle(systemRegistry, IBalancerVault(BAL_VAULT));\n        balancerMetaOracle = new BalancerLPMetaStableEthOracle(systemRegistry, IBalancerVault(BAL_VAULT));\n        chainlinkOracle = new ChainlinkOracle(systemRegistry);\n        curveStableOracle = new CurveV1StableEthOracle(systemRegistry, ICurveResolver(curveResolver));\n        ethPegOracle = new EthPeggedOracle(systemRegistry);\n        // sfrxEthOracle = new SfrxEthEthOracle(systemRegistry, SFRXETH_MAINNET);\n        uniV2EthOracle = new UniswapV2EthOracle(systemRegistry);\n        wstEthOracle = new WstETHEthOracle(systemRegistry, WSTETH_MAINNET);\n        mavEthOracle = new MavEthOracle(systemRegistry);\n        swEthOracle = new SwEthEthOracle(systemRegistry, IswETH(SWETH_MAINNET));\n        curveCryptoOracle = new CurveV2CryptoEthOracle(systemRegistry, ICurveResolver(curveResolver));\n        crvUsdOracle = new CrvUsdOracle(\n          systemRegistry,\n          IAggregatorV3Interface(USDC_IN_USD_CL_FEED_MAINNET),\n          IAggregatorV3Interface(USDT_IN_USD_CL_FEED_MAINNET),\n          IAggregatorV3Interface(ETH_CL_FEED_MAINNET)\n        );\n\n        //\n        // Make persistent for multiple forks\n        //\n        vm.makePersistent(address(systemRegistry));\n        vm.makePersistent(address(accessControl));\n        vm.makePersistent(address(priceOracle));\n        vm.makePersistent(address(curveResolver));\n        vm.makePersistent(address(balancerComposableOracle));\n        vm.makePersistent(address(balancerMetaOracle));\n        vm.makePersistent(address(chainlinkOracle));\n        vm.makePersistent(address(curveStableOracle));\n        vm.makePersistent(address(ethPegOracle));\n        // vm.makePersistent(address(sfrxEthOracle));\n        vm.makePersistent(address(uniV2EthOracle));\n        vm.makePersistent(address(wstEthOracle));\n        vm.makePersistent(address(mavEthOracle));\n        vm.makePersistent(address(swEthOracle));\n        vm.makePersistent(address(curveCryptoOracle));\n        vm.makePersistent(address(crvUsdOracle));\n\n        //\n        // Root price oracle setup\n        //\n        priceOracle.registerMapping(STETH_MAINNET, IPriceOracle(address(chainlinkOracle)));\n        priceOracle.registerMapping(RETH_MAINNET, IPriceOracle(address(chainlinkOracle)));\n        priceOracle.registerMapping(DAI_MAINNET, IPriceOracle(address(chainlinkOracle)));\n        priceOracle.registerMapping(USDC_MAINNET, IPriceOracle(address(chainlinkOracle)));\n        priceOracle.registerMapping(USDT_MAINNET, IPriceOracle(address(chainlinkOracle)));\n        priceOracle.registerMapping(CBETH_MAINNET, IPriceOracle(address(chainlinkOracle)));\n        priceOracle.registerMapping(FRAX_MAINNET, IPriceOracle(address(chainlinkOracle)));\n        priceOracle.registerMapping(SUSD_MAINNET, IPriceOracle(address(chainlinkOracle)));\n        priceOracle.registerMapping(USDP_MAINNET, IPriceOracle(address(chainlinkOracle)));\n        priceOracle.registerMapping(TUSD_MAINNET, IPriceOracle(address(chainlinkOracle)));\n        priceOracle.registerMapping(CRVUSD_MAINNET, IPriceOracle(address(crvUsdOracle)));\n        priceOracle.registerMapping(CRV_MAINNET, IPriceOracle(address(chainlinkOracle)));\n        priceOracle.registerMapping(LDO_MAINNET, IPriceOracle(address(chainlinkOracle)));\n\n        // Balancer composable stable pool\n        // priceOracle.registerMapping(WSETH_RETH_SFRXETH_BAL_POOL, IPriceOracle(address(balancerComposableOracle)));\n        priceOracle.registerMapping(USDC_DAI_USDT_BAL_POOL, IPriceOracle(address(balancerComposableOracle)));\n\n        // Balancer meta stable pool\n        priceOracle.registerMapping(CBETH_WSTETH_BAL_POOL, IPriceOracle(address(balancerMetaOracle)));\n        priceOracle.registerMapping(RETH_WETH_BAL_POOL, IPriceOracle(address(balancerMetaOracle)));\n        priceOracle.registerMapping(WSETH_WETH_BAL_POOL, IPriceOracle(address(balancerMetaOracle)));\n\n        // Curve V1\n        priceOracle.registerMapping(ST_ETH_CURVE_LP_TOKEN_MAINNET, IPriceOracle(address(curveStableOracle)));\n        priceOracle.registerMapping(THREE_CURVE_POOL_MAINNET_LP, IPriceOracle(address(curveStableOracle)));\n        // priceOracle.registerMapping(ETH_FRXETH_CURVE_POOL_LP, IPriceOracle(address(curveStableOracle)));\n        // priceOracle.registerMapping(STETH_FRXETH_POOL_AND_TOKEN_CURVE, IPriceOracle(address(curveStableOracle)));\n        priceOracle.registerMapping(RETH_WSTETH_CURVE_POOL_LP, IPriceOracle(address(curveStableOracle)));\n        priceOracle.registerMapping(STETH_STABLESWAP_NG_POOL, IPriceOracle(address(curveStableOracle)));\n        priceOracle.registerMapping(USDC_STABLESWAP_NG_POOL, IPriceOracle(address(curveStableOracle)));\n        priceOracle.registerMapping(USDT_STABLESWAP_NG_POOL, IPriceOracle(address(curveStableOracle)));\n        priceOracle.registerMapping(TUSD_STABLESWAP_NG_POOL, IPriceOracle(address(curveStableOracle)));\n        priceOracle.registerMapping(USDP_STABLESWAP_NG_POOL, IPriceOracle(address(curveStableOracle)));\n        priceOracle.registerMapping(FRAX_STABLESWAP_NG_POOL, IPriceOracle(address(curveStableOracle)));\n        priceOracle.registerMapping(SUSD_STABLESWAP_NG_POOL, IPriceOracle(address(curveStableOracle)));\n\n        // CurveV2\n        priceOracle.registerMapping(RETH_ETH_CURVE_LP, IPriceOracle(address(curveCryptoOracle)));\n        priceOracle.registerMapping(CRV_ETH_CURVE_V2_LP, IPriceOracle(address(curveCryptoOracle)));\n        priceOracle.registerMapping(LDO_ETH_CURVE_V2_LP, IPriceOracle(address(curveCryptoOracle)));\n\n        // UniV2\n        priceOracle.registerMapping(STETH_ETH_UNIV2, IPriceOracle(address(uniV2EthOracle)));\n        priceOracle.registerMapping(ETH_USDT_UNIV2, IPriceOracle(address(uniV2EthOracle)));\n\n        // Mav\n        priceOracle.registerMapping(WSTETH_WETH_MAV, IPriceOracle(address(mavEthOracle)));\n        priceOracle.registerMapping(ETH_SWETH_MAV, IPriceOracle(address(mavEthOracle)));\n\n        // Eth 1:1 setup\n        priceOracle.registerMapping(WETH9_ADDRESS, IPriceOracle(address(ethPegOracle)));\n        priceOracle.registerMapping(CURVE_ETH, IPriceOracle(address(ethPegOracle)));\n        // priceOracle.registerMapping(FRXETH_MAINNET, IPriceOracle(address(ethPegOracle)));\n\n        // Lst special pricing case setup\n        // priceOracle.registerMapping(SFRXETH_MAINNET, IPriceOracle(address(sfrxEthOracle)));\n        priceOracle.registerMapping(WSTETH_MAINNET, IPriceOracle(address(wstEthOracle)));\n        priceOracle.registerMapping(SWETH_MAINNET, IPriceOracle(address(swEthOracle)));\n\n        // Chainlink setup\n        chainlinkOracle.registerChainlinkOracle(\n            STETH_MAINNET,\n            IAggregatorV3Interface(STETH_CL_FEED_MAINNET),\n            BaseOracleDenominations.Denomination.ETH,\n            24 hours\n        );\n        chainlinkOracle.registerChainlinkOracle(\n            RETH_MAINNET,\n            IAggregatorV3Interface(RETH_CL_FEED_MAINNET),\n            BaseOracleDenominations.Denomination.ETH,\n            24 hours\n        );\n        chainlinkOracle.registerChainlinkOracle(\n            DAI_MAINNET, IAggregatorV3Interface(DAI_CL_FEED_MAINNET), BaseOracleDenominations.Denomination.ETH, 24 hours\n        );\n        chainlinkOracle.registerChainlinkOracle(\n            USDC_MAINNET,\n            IAggregatorV3Interface(USDC_CL_FEED_MAINNET),\n            BaseOracleDenominations.Denomination.ETH,\n            24 hours\n        );\n        chainlinkOracle.registerChainlinkOracle(\n            USDT_MAINNET,\n            IAggregatorV3Interface(USDT_CL_FEED_MAINNET),\n            BaseOracleDenominations.Denomination.ETH,\n            24 hours\n        );\n        chainlinkOracle.registerChainlinkOracle(\n            CBETH_MAINNET,\n            IAggregatorV3Interface(CBETH_CL_FEED_MAINNET),\n            BaseOracleDenominations.Denomination.ETH,\n            24 hours\n        );\n        chainlinkOracle.registerChainlinkOracle(\n            FRAX_MAINNET,\n            IAggregatorV3Interface(FRAX_CL_FEED_MAINNET),\n            BaseOracleDenominations.Denomination.ETH,\n            24 hours\n        );\n        chainlinkOracle.registerChainlinkOracle(\n            USDP_MAINNET,\n            IAggregatorV3Interface(USDP_CL_FEED_MAINNET),\n            BaseOracleDenominations.Denomination.ETH,\n            24 hours\n        );\n        chainlinkOracle.registerChainlinkOracle(\n            TUSD_MAINNET,\n            IAggregatorV3Interface(TUSD_CL_FEED_MAINNET),\n            BaseOracleDenominations.Denomination.ETH,\n            24 hours\n        );\n        chainlinkOracle.registerChainlinkOracle(\n            SUSD_MAINNET,\n            IAggregatorV3Interface(SUSD_CL_FEED_MAINNET),\n            BaseOracleDenominations.Denomination.ETH,\n            24 hours\n        );\n        chainlinkOracle.registerChainlinkOracle(\n            CRV_MAINNET, IAggregatorV3Interface(CRV_CL_FEED_MAINNET), BaseOracleDenominations.Denomination.ETH, 24 hours\n        );\n        chainlinkOracle.registerChainlinkOracle(\n            LDO_MAINNET, IAggregatorV3Interface(LDO_CL_FEED_MAINNET), BaseOracleDenominations.Denomination.ETH, 24 hours\n        );\n\n        // Curve V1 pool setup\n        curveStableOracle.registerPool(STETH_ETH_CURVE_POOL, ST_ETH_CURVE_LP_TOKEN_MAINNET, true);\n        curveStableOracle.registerPool(THREE_CURVE_MAINNET, THREE_CURVE_POOL_MAINNET_LP, false);\n        // curveStableOracle.registerPool(ETH_FRXETH_CURVE_POOL, ETH_FRXETH_CURVE_POOL_LP, false);\n        curveStableOracle.registerPool(STETH_STABLESWAP_NG_POOL, STETH_STABLESWAP_NG_POOL, false);\n        // curveStableOracle.registerPool(STETH_FRXETH_POOL_AND_TOKEN_CURVE, STETH_FRXETH_POOL_AND_TOKEN_CURVE, false);\n        curveStableOracle.registerPool(RETH_WSTETH_CURVE_POOL, RETH_WSTETH_CURVE_POOL_LP, false);\n        curveStableOracle.registerPool(USDC_STABLESWAP_NG_POOL, USDC_STABLESWAP_NG_POOL, false);\n        curveStableOracle.registerPool(USDT_STABLESWAP_NG_POOL, USDT_STABLESWAP_NG_POOL, false);\n        curveStableOracle.registerPool(TUSD_STABLESWAP_NG_POOL, TUSD_STABLESWAP_NG_POOL, false);\n        curveStableOracle.registerPool(USDP_STABLESWAP_NG_POOL, USDP_STABLESWAP_NG_POOL, false);\n        curveStableOracle.registerPool(FRAX_STABLESWAP_NG_POOL, FRAX_STABLESWAP_NG_POOL, false);\n\n        // Curve V2 pool setup\n        curveCryptoOracle.registerPool(RETH_WETH_CURVE_POOL, RETH_ETH_CURVE_LP, false);\n        curveCryptoOracle.registerPool(CRV_ETH_CURVE_V2_POOL, CRV_ETH_CURVE_V2_LP, false);\n        curveCryptoOracle.registerPool(LDO_ETH_CURVE_V2_POOL, LDO_ETH_CURVE_V2_LP, false);\n\n        // Uni pool setup\n        uniV2EthOracle.register(STETH_ETH_UNIV2);\n        uniV2EthOracle.register(ETH_USDT_UNIV2);\n    }\n\n    //\n    // Test Lp token pricing\n    //\n    function test_BalComposableStablePoolOracle() external {\n        vm.createSelectFork(vm.envString(\"MAINNET_RPC_URL\"), 17_475_350);\n\n        // Calculated - 573334720000000\n        // Safe price - 575991341828605\n        uint256 calculatedPrice = uint256(573_334_720_000_000);\n        uint256 safePrice = priceOracle.getPriceInEth(USDC_DAI_USDT_BAL_POOL);\n        (uint256 upperBound, uint256 lowerBound) = _getTwoPercentTolerance(calculatedPrice);\n        assertGt(upperBound, safePrice);\n        assertLt(lowerBound, safePrice);\n\n        vm.createSelectFork(vm.envString(\"MAINNET_RPC_URL\"), 17_478_924);\n\n        // Calculated - 1010782811000000000\n        // Safe price - 1055299120697408989\n        // calculatedPrice = uint256(1_010_782_811_000_000_000);\n        // safePrice = priceOracle.getPriceInEth(WSETH_RETH_SFRXETH_BAL_POOL);\n        // (upperBound, lowerBound) = _getTwoPercentTolerance(calculatedPrice);\n        // assertGt(upperBound, safePrice);\n        // assertLt(lowerBound, safePrice);\n    }\n\n    function test_CurveStableV1PoolOracle() external {\n        vm.createSelectFork(vm.envString(\"MAINNET_RPC_URL\"), 17_475_426);\n\n        // Calculated - 1073735977000000000\n        // Safe price - 1073637176979605953\n        uint256 calculatedPrice = uint256(1_073_735_977_000_000_000);\n        uint256 safePrice = priceOracle.getPriceInEth(ST_ETH_CURVE_LP_TOKEN_MAINNET);\n        (uint256 upperBound, uint256 lowerBound) = _getTwoPercentTolerance(calculatedPrice);\n        assertGt(upperBound, safePrice);\n        assertLt(lowerBound, safePrice);\n\n        // Calculated - 587546836000000\n        // Safe price - 590481873156925\n        calculatedPrice = uint256(587_546_836_000_000);\n        safePrice = priceOracle.getPriceInEth(THREE_CURVE_POOL_MAINNET_LP);\n        (upperBound, lowerBound) = _getTwoPercentTolerance(calculatedPrice);\n        assertGt(upperBound, safePrice);\n        assertLt(lowerBound, safePrice);\n\n        // Newer tests, new fork.\n        vm.createSelectFork(vm.envString(\"MAINNET_RPC_URL\"), 17_480_014);\n\n        // Calculated - 1003869775000000000\n        // Safe price - 1001074825252786600\n        // calculatedPrice = uint256(1_003_869_775_000_000_000);\n        // safePrice = priceOracle.getPriceInEth(ETH_FRXETH_CURVE_POOL_LP);\n        // (upperBound, lowerBound) = _getTwoPercentTolerance(calculatedPrice);\n        // assertGt(upperBound, safePrice);\n        // assertLt(lowerBound, safePrice);\n\n        // Calculated - 1012223904000000000\n        // Safe price - 1008312837172276871\n        // calculatedPrice = uint256(1_012_223_904_000_000_000);\n        // safePrice = priceOracle.getPriceInEth(STETH_FRXETH_POOL_AND_TOKEN_CURVE);\n        // (upperBound, lowerBound) = _getTwoPercentTolerance(calculatedPrice);\n        // assertGt(upperBound, safePrice);\n        // assertLt(lowerBound, safePrice);\n\n        // Calculated - 1098321582000000000\n        // Safe price - 1077905860822595469\n        calculatedPrice = uint256(1_098_321_582_000_000_000);\n        safePrice = priceOracle.getPriceInEth(RETH_WSTETH_CURVE_POOL_LP);\n        (upperBound, lowerBound) = _getTwoPercentTolerance(calculatedPrice);\n        assertGt(upperBound, safePrice);\n        assertLt(lowerBound, safePrice);\n    }\n\n    function test_UniV2PoolOracle() external {\n        vm.createSelectFork(vm.envString(\"MAINNET_RPC_URL\"), 17_475_530);\n\n        // Calculated - 2692923915000000000\n        // Safe price - 2719124222286442720\n        uint256 calculatedPrice = uint256(2_692_923_915_000_000_000);\n        uint256 safePrice = priceOracle.getPriceInEth(STETH_ETH_UNIV2);\n        (uint256 upperBound, uint256 lowerBound) = _getTwoPercentTolerance(calculatedPrice);\n        assertGt(upperBound, safePrice);\n        assertLt(lowerBound, safePrice);\n\n        // Calculated - 111063607400000000000000\n        // Safe price - 111696966269313545001725\n        calculatedPrice = uint256(111_063_607_400_000_000_000_000);\n        safePrice = priceOracle.getPriceInEth(ETH_USDT_UNIV2);\n        (upperBound, lowerBound) = _getTwoPercentTolerance(calculatedPrice);\n        assertGt(upperBound, safePrice);\n        assertLt(lowerBound, safePrice);\n    }\n\n    function test_BalMetaStablePoolOracle() external {\n        vm.createSelectFork(vm.envString(\"MAINNET_RPC_URL\"), 17_475_744);\n\n        // Calculated - 1010052287000000000\n        // Safe price - 1049623347233950707\n        uint256 calculatedPrice = uint256(1_010_052_287_000_000_000);\n        uint256 safePrice = priceOracle.getPriceInEth(CBETH_WSTETH_BAL_POOL);\n        (uint256 upperBound, uint256 lowerBound) = _getTwoPercentTolerance(calculatedPrice);\n        assertGt(upperBound, safePrice);\n        assertLt(lowerBound, safePrice);\n\n        // Calculated - 1023468806000000000\n        // Safe price - 1023189295745953671\n        calculatedPrice = uint256(1_023_691_743_000_000_000);\n        safePrice = priceOracle.getPriceInEth(RETH_WETH_BAL_POOL);\n        (upperBound, lowerBound) = _getTwoPercentTolerance(calculatedPrice);\n        assertGt(upperBound, safePrice);\n        assertLt(lowerBound, safePrice);\n\n        // Calculated - 1035273715000000000\n        // Safe price - 1035531137827401614\n        calculatedPrice = uint256(1_034_447_288_000_000_000);\n        safePrice = priceOracle.getPriceInEth(WSETH_WETH_BAL_POOL);\n        (upperBound, lowerBound) = _getTwoPercentTolerance(calculatedPrice);\n        assertGt(upperBound, safePrice);\n        assertLt(lowerBound, safePrice);\n    }\n\n    // Reserves from boosted position\n    // price from somewhere\n    // total supply\n    function test_MavEthOracle() external {\n        vm.createSelectFork(vm.envString(\"MAINNET_RPC_URL\"), 17_528_586);\n\n        // Calculated - 1279055722000000000\n        // Safe price - 1281595721753262897\n        uint256 calculatedPrice = uint256(1_279_055_722_000_000_000);\n        uint256 safePrice = priceOracle.getPriceInEth(WSTETH_WETH_MAV);\n        (uint256 upperBound, uint256 lowerBound) = _getTwoPercentTolerance(calculatedPrice);\n        assertGt(upperBound, safePrice);\n        assertLt(lowerBound, safePrice);\n\n        // Calculated - 1477192563000000000\n        // Safe price - 1477192560261437163\n        calculatedPrice = uint256(1_477_192_563_000_000_000);\n        safePrice = priceOracle.getPriceInEth(ETH_SWETH_MAV);\n        (upperBound, lowerBound) = _getTwoPercentTolerance(calculatedPrice);\n        assertGt(upperBound, safePrice);\n        assertLt(lowerBound, safePrice);\n    }\n\n    /**\n     * @notice crvUsd / MIM and TricryptoLLAMA pool excluded as of 6/29/23.  MIM does not have a Chainlink price\n     *      feed, and TricryptoLLAMA is a v2 ng pool.\n     */\n    function test_CurveStableSwapNGPools() external {\n        // Pulled stEth ng pool test from elsewhere, use older fork\n        vm.createSelectFork(vm.envString(\"MAINNET_RPC_URL\"), 17_480_014);\n\n        // Calculated - 1006028244000000000\n        // Safe price - 1001718276876133469\n        uint256 calculatedPrice = uint256(1_006_028_244_000_000_000);\n        uint256 safePrice = priceOracle.getPriceInEth(STETH_STABLESWAP_NG_POOL);\n        (uint256 upperBound, uint256 lowerBound) = _getTwoPercentTolerance(calculatedPrice);\n        assertGt(upperBound, safePrice);\n        assertLt(lowerBound, safePrice);\n\n        vm.createSelectFork(vm.envString(\"MAINNET_RPC_URL\"), 17_586_413);\n\n        // Set up here because pool did not exist at original setup fork.\n        curveStableOracle.registerPool(SUSD_STABLESWAP_NG_POOL, SUSD_STABLESWAP_NG_POOL, false);\n\n        // Calculated - 540613701000000\n        // Safe price - 539414760524139;\n        calculatedPrice = uint256(540_613_701_000_000);\n        safePrice = priceOracle.getPriceInEth(USDC_STABLESWAP_NG_POOL);\n        (upperBound, lowerBound) = _getTwoPercentTolerance(calculatedPrice);\n        assertGt(upperBound, safePrice);\n        assertLt(lowerBound, safePrice);\n\n        // Calculated - 540416370000000\n        // Safe price - 540237542722259\n        calculatedPrice = uint256(540_416_370_000_000);\n        safePrice = priceOracle.getPriceInEth(USDT_STABLESWAP_NG_POOL);\n        (upperBound, lowerBound) = _getTwoPercentTolerance(calculatedPrice);\n        assertGt(upperBound, safePrice);\n        assertLt(lowerBound, safePrice);\n\n        // Calculated - 539978431000000\n        // Safe price - 538905372335699\n        calculatedPrice = uint256(539_978_431_000_000);\n        safePrice = priceOracle.getPriceInEth(TUSD_STABLESWAP_NG_POOL);\n        (upperBound, lowerBound) = _getTwoPercentTolerance(calculatedPrice);\n        assertGt(upperBound, safePrice);\n        assertLt(lowerBound, safePrice);\n\n        // Calculated - 540443002000000\n        // Safe price - 534720896910672\n        calculatedPrice = uint256(540_443_002_000_000);\n        safePrice = priceOracle.getPriceInEth(USDP_STABLESWAP_NG_POOL);\n        (upperBound, lowerBound) = _getTwoPercentTolerance(calculatedPrice);\n        assertGt(upperBound, safePrice);\n        assertLt(lowerBound, safePrice);\n\n        // Calculated - 539914597000000\n        // Safe price - 539944276470054\n        calculatedPrice = uint256(539_914_597_000_000);\n        safePrice = priceOracle.getPriceInEth(FRAX_STABLESWAP_NG_POOL);\n        (upperBound, lowerBound) = _getTwoPercentTolerance(calculatedPrice);\n        assertGt(upperBound, safePrice);\n        assertLt(lowerBound, safePrice);\n\n        // Calculated - 539909058000000\n        // Safe price - 538554606113206\n        calculatedPrice = uint256(539_909_058_000_000);\n        safePrice = priceOracle.getPriceInEth(SUSD_STABLESWAP_NG_POOL);\n        (upperBound, lowerBound) = _getTwoPercentTolerance(calculatedPrice);\n        assertGt(upperBound, safePrice);\n        assertLt(lowerBound, safePrice);\n    }\n\n    /**\n     * @notice Tested against multiple v2 pools that we are not using to test validity of approach.\n     */\n    function test_CurveV2Pools() external {\n        vm.createSelectFork(vm.envString(\"MAINNET_RPC_URL\"), 17_672_343);\n\n        // Calculated - 2079485290000000000\n        // Safe price - 2077740002016828677\n        uint256 calculatedPrice = uint256(2_079_485_290_000_000_000);\n        uint256 safePrice = priceOracle.getPriceInEth(RETH_ETH_CURVE_LP);\n        (uint256 upperBound, uint256 lowerBound) = _getTwoPercentTolerance(calculatedPrice);\n        assertGt(upperBound, safePrice);\n        assertLt(lowerBound, safePrice);\n\n        // 28958009260000000000000\n\n        // Calculated - 42945287200000000\n        // Safe Price - 43072642081141667\n        calculatedPrice = uint256(42_945_287_200_000_000);\n        safePrice = priceOracle.getPriceInEth(CRV_ETH_CURVE_V2_LP);\n        (upperBound, lowerBound) = _getTwoPercentTolerance(calculatedPrice);\n        assertGt(upperBound, safePrice);\n        assertLt(lowerBound, safePrice);\n\n        // Calculated - 64666948400000000\n        // Safe price - 64695922392289196\n        calculatedPrice = uint256(64_695_922_392_289_196);\n        safePrice = priceOracle.getPriceInEth(LDO_ETH_CURVE_V2_LP);\n        (upperBound, lowerBound) = _getTwoPercentTolerance(calculatedPrice);\n        assertGt(upperBound, safePrice);\n        assertLt(lowerBound, safePrice);\n    }\n\n    // Specifically test path when asset is priced in USD\n    function test_EthInUsdPath() external {\n        // Use bal usdc - usdt - dai pool, usdc denominated in USD\n\n        address ETH_IN_USD = address(bytes20(\"ETH_IN_USD\"));\n        vm.createSelectFork(vm.envString(\"MAINNET_RPC_URL\"), 17_475_310);\n\n        chainlinkOracle.removeChainlinkRegistration(USDC_MAINNET);\n        chainlinkOracle.registerChainlinkOracle(\n            USDC_MAINNET,\n            IAggregatorV3Interface(USDC_IN_USD_CL_FEED_MAINNET),\n            BaseOracleDenominations.Denomination.USD,\n            24 hours\n        );\n        priceOracle.registerMapping(ETH_IN_USD, IPriceOracle(address(chainlinkOracle)));\n        chainlinkOracle.registerChainlinkOracle(\n            ETH_IN_USD, IAggregatorV3Interface(ETH_CL_FEED_MAINNET), BaseOracleDenominations.Denomination.USD, 0\n        );\n\n        // calculated - 588167942000000\n        // safe price - 587583813652788\n        uint256 calculatedPrice = uint256(588_167_942_000_000);\n        uint256 safePrice = priceOracle.getPriceInEth(THREE_CURVE_POOL_MAINNET_LP);\n        (uint256 upperBound, uint256 lowerBound) = _getTwoPercentTolerance(calculatedPrice);\n        assertGt(upperBound, safePrice);\n        assertLt(lowerBound, safePrice);\n    }\n\n    function _getTwoPercentTolerance(uint256 price) internal pure returns (uint256 upperBound, uint256 lowerBound) {\n        uint256 twoPercentToleranceValue = (price * 2) / 100;\n\n        upperBound = price + twoPercentToleranceValue;\n        lowerBound = price - twoPercentToleranceValue;\n    }\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/src/oracles/providers/SwEthEthOracle.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\n\npragma solidity 0.8.17;\n\nimport { Errors } from \"src/utils/Errors.sol\";\nimport { IswETH } from \"src/interfaces/external/swell/IswETH.sol\";\nimport { ISystemRegistry } from \"src/interfaces/ISystemRegistry.sol\";\nimport { IPriceOracle } from \"src/interfaces/oracles/IPriceOracle.sol\";\nimport { SystemComponent } from \"src/SystemComponent.sol\";\n\n/**\n * @notice Price oracle specifically for swEth (Swell Eth).\n * @dev getPriceEth is not a view fn to support reentrancy checks. Does not actually change state.\n */\ncontract SwEthEthOracle is SystemComponent, IPriceOracle {\n    IswETH public immutable swEth;\n\n    constructor(ISystemRegistry _systemRegistry, IswETH _swEth) SystemComponent(_systemRegistry) {\n        Errors.verifyNotZero(address(_swEth), \"_swEth\");\n\n        swEth = _swEth;\n    }\n\n    /// @inheritdoc IPriceOracle\n    function getPriceInEth(address token) external view returns (uint256 price) {\n        // Prevents incorrect config at root level.\n        if (token != address(swEth)) revert Errors.InvalidToken(token);\n\n        // Returns in 1e18 precision.\n        price = swEth.swETHToETHRate();\n    }\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/src/stats/calculators/SwethLSTCalculator.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\npragma solidity 0.8.17;\n\nimport { LSTCalculatorBase } from \"src/stats/calculators/base/LSTCalculatorBase.sol\";\nimport { IswETH } from \"src/interfaces/external/swell/IswETH.sol\";\nimport { ISystemRegistry } from \"src/interfaces/ISystemRegistry."
    }
  ]
}