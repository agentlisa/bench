{
  "Title": "[M-06] Oracle data feed is insufficiently validated.",
  "Content": "_Submitted by Jujic, also found by hickuphh3_\n\nPrice can be stale and can lead to wrong `answer` return value.\n\n### Proof of Concept\n\nOracle data feed is insufficiently validated. There is no check for stale price and round completeness. Price can be stale and can lead to wrong  `answer`  return value.\n\n```\nfunction _collateralPriceUsd() internal view returns (uint256) {\n        int256 answer = oracle.latestAnswer();\n        uint8 decimals = oracle.decimals();\n\n        require(answer > 0, \"invalid_oracle_answer\");\n\n        ...\n\n```\n\n[FungibleAssetVaultForDAO.sol#L105](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/FungibleAssetVaultForDAO.sol#L105)<br>\n\n### Recommended Mitigation Steps\n\nValidate data feed\n\n```\nfunction _collateralPriceUsd() internal view returns (uint256) {\n\n(uint80 roundID, int256 answer, , uint256 timestamp, uint80 answeredInRound) = oracle.latestRoundData();\n   \n    require(answer > 0, \"invalid_oracle_answer\");\n    require(answeredInRound >= roundID, \"ChainLink: Stale price\");\n    require(timestamp > 0, \"ChainLink: Round not complete\");\n\n         ...\n\n```\n\n**[0xJPEG (JPEG'd) confirmed, but disagreed with High severity and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/54#issuecomment-1101687980):**\n > Can add validation for round not being complete yet and potentially for stale pricing.<br>\n> This should be medium risk, as shown in past contests [[1]](https://github.com/code-423n4/code423n4.com/blob/65f9f13b7502c264098fe65ab57e79fcf99e956d/_data/reports/2022-01-notional.md#m-01-usage-of-deprecated-chainlink-api-in-eip1271wallet) [[2]](https://github.com/code-423n4/code423n4.com/blob/61f7d00561352d0c312b7f516404840eb68c824e/_data/reports/2021-12-yetifinance.md#m-02-should-check-return-data-from-chainlink-aggregators) [[3]](https://github.com/code-423n4/code423n4.com/blob/582de04e5765ee1953d0f07968fcd46ee2204ac7/_data/reports/2021-05-fairside.md#m-09-should-check-return-data-from-chainlink-aggregators)\n\n**[spaghettieth (JPEG'd) resolved and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/54#issuecomment-1102902675):**\n > Fixed in [jpegd/core#9](https://github.com/jpegd/core/pull/9).\n\n**[LSDan (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/54#issuecomment-1109875877):**\n > Agree with sponsor on the medium risk rating. An oracle with a bad value is by definition an external requirement.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-04-jpegd-contest",
  "Code": [
    {
      "filename": "contracts/vaults/FungibleAssetVaultForDAO.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../interfaces/IAggregatorV3Interface.sol\";\nimport \"../interfaces/IStableCoin.sol\";\nimport \"../interfaces/IERC20Decimals.sol\";\n\n/// @title Fungible asset vault (for DAO and ecosystem contracts)\n/// @notice Allows the DAO and other whitelisted addresses to mint PUSD using fungible assets as collateral\n/// @dev The contract only supports one asset, meaning that multiple instances\n/// of this contract are going to be deployed if support for multiple assets is needed.\n/// The credit limit rate of the supported asset is set at deploy time.\n/// This contract doesn't support liquidations. In case of undercollateralization,\n/// the DAO will promptly deposit more collateral.\n/// The vault implements {AccessControlUpgradeable} and only allows whitelisted wallets\n/// to deposit/borrow/withdraw/repay. The contract doesn't keep track of the individual\n/// debt/deposited collateral of each whitelisted address, it instead uses global debt and deposited collateral.\n/// This is intentional and it's done to allow the DAO to repay debt of ecosystem contracts ({StrategyPUSDConvex}, for example)\ncontract FungibleAssetVaultForDAO is\n    AccessControlUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeERC20Upgradeable for IStableCoin;\n\n    event Deposit(address indexed user, uint256 depositAmount);\n    event Borrow(address indexed user, uint256 borrowAmount);\n    event Repay(address indexed user, uint256 repayAmount);\n    event Withdraw(address indexed user, uint256 withdrawAmount);\n\n    struct Rate {\n        uint128 numerator;\n        uint128 denominator;\n    }\n\n    bytes32 public constant WHITELISTED_ROLE = keccak256(\"WHITELISTED_ROLE\");\n\n    /// @dev This contract can handle unwrapped ETH if `address(0)` is passed as the `_collateralAsset`\n    /// parameter in the {initialize} function\n    address internal constant ETH = address(0);\n\n    address public collateralAsset;\n    IStableCoin public stablecoin;\n    /// @dev We store the value of a single unit of the collateral asset `10 ** decimals`\n    /// instead of fetching it everytime to save gas\n    uint256 private _collateralUnit;\n\n    IAggregatorV3Interface public oracle;\n\n    Rate public creditLimitRate;\n\n    /// @notice Amount of deposited collateral\n    uint256 public collateralAmount;\n    /// @notice Outstanding debt\n    uint256 public debtAmount;\n\n    /// @param _collateralAsset The address of the collateral asset - `address(0)` for ETH\n    /// @param _stablecoin PUSD address\n    /// @param _oracle Chainlink price feed for `_collateralAsset`/USD\n    /// @param _creditLimitRate Max outstanding debt to collateral ratio\n    function initialize(\n        address _collateralAsset,\n        IStableCoin _stablecoin,\n        IAggregatorV3Interface _oracle,\n        Rate memory _creditLimitRate\n    ) external initializer {\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\n        setCreditLimitRate(_creditLimitRate);\n\n        collateralAsset = _collateralAsset;\n        stablecoin = _stablecoin;\n        if (_collateralAsset == ETH) {\n            _collateralUnit = 1 ether;\n        } else {\n            _collateralUnit = 10**IERC20Decimals(_collateralAsset).decimals();\n        }\n\n        oracle = _oracle;\n    }\n\n    /// @notice Allows members of the `DEFAULT_ADMIN_ROLE` to change the max outstanding debt to collateral ratio\n    /// @param _creditLimitRate The new ratio\n    function setCreditLimitRate(Rate memory _creditLimitRate) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(\n            _creditLimitRate.denominator > 0 &&\n                //denominator can be equal to the numerator in some cases (stablecoins used as collateral)\n                _creditLimitRate.denominator >= _creditLimitRate.numerator,\n            \"invalid_rate\"\n        );\n        creditLimitRate = _creditLimitRate;\n    }\n\n    /// @dev Returns the USD price of one unit of collateral asset, using 18 decimals precision\n    /// @return The USD price\n    function _collateralPriceUsd() internal view returns (uint256) {\n        int256 answer = oracle.latestAnswer();\n        uint8 decimals = oracle.decimals();\n\n        require(answer > 0, \"invalid_oracle_answer\");\n\n        //check chainlink's precision and convert it to 18 decimals\n        return\n            decimals > 18\n                ? uint256(answer) / 10**(decimals - 18)\n                : uint256(answer) * 10**(18 - decimals);\n    }\n\n    /// @dev Returns the USD value of `amount` units of collateral, using 18 decimals precision\n    /// @param amount The amount of collateral to calculate the value of\n    /// @return The USD value\n    function _getCollateralValue(uint256 amount)\n        internal\n        view\n        returns (uint256)\n    {\n        return (amount * _collateralPriceUsd()) / _collateralUnit;\n    }\n\n    /// @notice Returns the max debt for `amount` of collateral\n    /// @param amount The amount of collateral to calculate max debt for\n    /// @return Max debt value for `amount`\n    function getCreditLimit(uint256 amount) public view returns (uint256) {\n        uint256 collateralValue = _getCollateralValue(amount);\n        return\n            (collateralValue * creditLimitRate.numerator) /\n            creditLimitRate.denominator;\n    }\n\n    /// @notice Allows members of the `WHITELISTED_ROLE` to deposit `amount` of collateral\n    /// @dev Emits a {Deposit} event\n    /// @param amount The amount of collateral to deposit\n    function deposit(uint256 amount) external payable onlyRole(WHITELISTED_ROLE) {\n        require(amount > 0, \"invalid_amount\");\n\n        if (collateralAsset == ETH) {\n            require(msg.value == amount, \"invalid_msg_value\");\n        } else {\n            require(msg.value == 0, \"non_zero_eth_value\");\n            IERC20Upgradeable(collateralAsset).safeTransferFrom(\n                msg.sender,\n                address(this),\n                amount\n            );\n        }\n\n        collateralAmount += amount;\n\n        emit Deposit(msg.sender, amount);\n    }\n\n    /// @notice Allows members of the `WHITELISTED_ROLE` to borrow `amount` of PUSD against the deposited collateral\n    /// @dev Emits a {Borrow} event\n    /// @param amount The amount of PUSD to borrow\n    function borrow(uint256 amount) external onlyRole(WHITELISTED_ROLE) nonReentrant {\n        require(amount > 0, \"invalid_amount\");\n\n        uint256 creditLimit = getCreditLimit(collateralAmount);\n        uint256 newDebtAmount = debtAmount + amount;\n        require(newDebtAmount <= creditLimit, \"insufficient_credit\");\n\n        debtAmount = newDebtAmount;\n        stablecoin.mint(msg.sender, amount);\n\n        emit Borrow(msg.sender, amount);\n    }\n\n    /// @notice Allows members of the `WHITELISTED_ROLE` to repay `amount` of debt using PUSD\n    /// @dev Emits a {Repay} event\n    /// @param amount The amount of debt to repay\n    function repay(uint256 amount) external onlyRole(WHITELISTED_ROLE) nonReentrant {\n        require(amount > 0, \"invalid_amount\");\n\n        amount = amount > debtAmount ? debtAmount : amount;\n\n        debtAmount -= amount;\n        stablecoin.burnFrom(msg.sender, amount);\n\n        emit Repay(msg.sender, amount);\n    }\n\n    /// @notice Allows members of the `WHITELISTED_ROLE` to withdraw `amount` of deposited collateral\n    /// @dev Emits a {Withdraw} event\n    /// @param amount The amount of collateral to withdraw\n    function withdraw(uint256 amount) external onlyRole(WHITELISTED_ROLE) nonReentrant {\n        require(amount > 0 && amount <= collateralAmount, \"invalid_amount\");\n\n        uint256 creditLimit = getCreditLimit(collateralAmount - amount);\n        require(creditLimit >= debtAmount, \"insufficient_credit\");\n\n        collateralAmount -= amount;\n\n        if (collateralAsset == ETH) payable(msg.sender).transfer(amount);\n        else\n            IERC20Upgradeable(collateralAsset).safeTransfer(msg.sender, amount);\n\n        emit Withdraw(msg.sender, amount);\n    }\n\n    uint256[50] private __gap;\n}"
    },
    {
      "filename": "_data/reports/2022-01-notional.md",
      "content": "---\nsponsor: \"Notional\"\nslug: \"2022-01-notional\"\ndate: \"2022-03-10\"\ntitle: \"Notional contest\"\nfindings: \"https://github.com/code-423n4/2022-01-notional-findings/issues\"\ncontest: 81\n---\n\n# Overview\n\n## About C4\n\nCode4rena (C4) is an open organization consisting of security researchers, auditors, developers, and individuals with domain expertise in smart contracts.\n\nA C4 code contest is an event in which community participants, referred to as Wardens, review, audit, or analyze smart contract logic in exchange for a bounty provided by sponsoring projects.\n\nDuring the code contest outlined in this document, C4 conducted an analysis of the Notional smart contract system written in Solidity. The code contest took place between January 27—February 2 2022.\n\n## Wardens\n\n27 Wardens contributed reports to the Notional contest:\n\n  1. [leastwood](https://twitter.com/liam_eastwood13)\n  1. ShippooorDAO\n  1. [cmichel](https://twitter.com/cmichelio)\n  1. [TomFrenchBlockchain](https://github.com/TomAFrench)\n  1. [gzeon](https://twitter.com/gzeon)\n  1. [Dravee](https://twitter.com/JustDravee)\n  1. gellej\n  1. Jujic\n  1. GeekyLumberjack\n  1. hyh\n  1. [defsec](https://twitter.com/defsec_)\n  1. WatchPug ([jtp](https://github.com/jack-the-pug) and [ming](https://github.com/mingwatch))\n  1. UncleGrandpa925\n  1. samruna\n  1. [sirhashalot](https://twitter.com/SirH4shalot)\n  1. [Tomio](https://twitter.com/meidhiwirara)\n  1. SolidityScan ([cyberboy](https://twitter.com/cyberboyIndia) and [zombie](https://blog.dixitaditya.com/))\n  1. 0x1f8b\n  1. [throttle](https://twitter.com/_no_handlebars)\n  1. robee\n  1. IllIllI\n  1. PranavG\n  1. [0v3rf10w](https://twitter.com/_0v3rf10w)\n  1. cccz\n  1. [camden](https://camden.codes)\n\nThis contest was judged by [pauliax](https://twitter.com/SolidityDev). The judge also competed in the contest as a warden, but forfeited their winnings.\n\nFinal report assembled by [liveactionllama](https://twitter.com/liveactionllama) and [CloudEllie](https://twitter.com/CloudEllie1).\n\n# Summary\n\nThe C4 analysis yielded an aggregated total of 18 unique vulnerabilities and 57 total findings. All of the issues presented here are linked back to their original finding.\n\nOf these vulnerabilities, 3 received a risk rating in the category of HIGH severity, 7 received a risk rating in the category of MEDIUM severity, and 8 received a risk rating in the category of LOW severity.\n\nC4 analysis also identified 16 non-critical recommendations and 23 gas optimizations.\n\n# Scope\n\nThe code under review can be found within the [C4 Notional contest repository](https://github.com/code-423n4/2022-01-notional), and is composed of 18 smart contracts written in the Solidity programming language and includes 1745 lines of Solidity code.\n\n# Severity Criteria\n\nC4 assesses the severity of disclosed vulnerabilities according to a methodology based on [OWASP standards](https://owasp.org/www-community/OWASP_Risk_Rating_Methodology).\n\nVulnerabilities are divided into three primary risk categories: high, medium, and low.\n\nHigh-level considerations for vulnerabilities span the following key areas when conducting assessments:\n\n- Malicious Input Handling\n- Escalation of privileges\n- Arithmetic\n- Gas use\n\nFurther information regarding the severity criteria referenced throughout the submission review process, please refer to the documentation provided on [the C4 website](https://code423n4.com).\n\n# High Risk Findings (3)\n## [[H-01] Treasury cannot claim COMP tokens & COMP tokens are stuck](https://github.com/code-423n4/2022-01-notional-findings/issues/192)\n_Submitted by cmichel, also found by leastwood_\n\nThe `TreasuryAction.claimCOMPAndTransfer` function uses pre- and post-balances of the `COMP` token to check which ones to transfer:\n\n```solidity\nfunction claimCOMPAndTransfer(address[] calldata cTokens)\n    external\n    override\n    onlyManagerContract\n    nonReentrant\n    returns (uint256)\n{\n    // Take a snasphot of the COMP balance before we claim COMP so that we don't inadvertently transfer\n    // something we shouldn't.\n    uint256 balanceBefore = COMP.balanceOf(address(this));\n    // @audit anyone can claim COMP on behalf of this contract and then it's stuck. https://github.com/compound-finance/compound-protocol/blob/master/contracts/Comptroller.sol#L1328\n    COMPTROLLER.claimComp(address(this), cTokens);\n    // NOTE: If Notional ever lists COMP as a collateral asset it will be cCOMP instead and it\n    // will never hold COMP balances directly. In this case we can always transfer all the COMP\n    // off of the contract.\n    uint256 balanceAfter = COMP.balanceOf(address(this));\n    uint256 amountClaimed = balanceAfter.sub(balanceBefore);\n    // NOTE: the onlyManagerContract modifier prevents a transfer to address(0) here\n    COMP.safeTransfer(treasuryManagerContract, amountClaimed);\n    // NOTE: TreasuryManager contract will emit a COMPHarvested event\n    return amountClaimed;\n}\n```\n\nNote that anyone can claim COMP tokens on behalf of any address (see [`Comptroller.claimComp`](https://github.com/compound-finance/compound-protocol/blob/master/contracts/Comptroller.sol#L1328)).\nAn attacker can claim COMP tokens on behalf of the contract and it'll never be able to claim any compound itself.\nThe COMP claimed by the attacker are stuck in the contract and cannot be retrieved.\n(One can eventually get back the stuck COMP by creating a cCOMP market and then transferring it through `transferReserveToTreasury`.)\n\n#### Recommended Mitigation Steps\n\nDon't use pre-and post-balances, can you use the entire balance?\n\n**[jeffywu (Notional) disagreed with severity and commented](https://github.com/code-423n4/2022-01-notional-findings/issues/192#issuecomment-1030843184):**\n > Dispute as a high risk bug. Would categorize this as medium risk.\n> \n> There is no profit to be gained by doing this from the attacker besides denial of service. The protocol could simply upgrade to regain access to the tokens. We will fix this regardless.\n\n**[pauliax (judge) commented](https://github.com/code-423n4/2022-01-notional-findings/issues/192#issuecomment-1041504305):**\n > Very good find. \n> \n> It is a tough decision if this should be classified as High or Medium severity. An exploiter cannot acquire those assets, and the contracts are upgradeable if necessary, however, I think this time I will leave it in favor of wardens who both are experienced enough and submitted this as of high severity:\n> _3 — High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals)._\n\n\n\n***\n\n## [[H-02] Cooldown and redeem windows can be rendered useless](https://github.com/code-423n4/2022-01-notional-findings/issues/68)\n_Submitted by ShippooorDAO_\n\nCooldown and redeem windows can be rendered useless.\n\n#### Proof of Concept\n\n*   Given an account that has not staked sNOTE.\n*   Account calls sNOTE.startCooldown\n*   Account waits for the duration of the cooldown period. Redeem period starts.\n*   Account can then deposit and redeem as they wish, making the cooldown useless.\n*   Multiple accounts could be used to \"hop\" between redeem windows by transfering between them, making the redeem window effictively useless.\n\nCould be used for voting power attacks using flash loan if voting process is not monitored\n<https://www.coindesk.com/tech/2020/10/29/flash-loans-have-made-their-way-to-manipulating-protocol-elections/>\n\n#### Tools Used\n\n*   VS Code\n\n#### Recommended Mitigation Steps\n\nA few ways to mitigate this problem:\nOption A: Remove the cooldown/redeem period as it's not really preventing much in current state.\nOption B: Let the contract start the cooldown on mint, and bind the cooldown/redeem window to the amount that was minted at that time by the account. Don't make sNOTE.startCooldown() available externally. Redeem should verify amount of token available using this new logic.\n\n**[jeffywu (Notional) confirmed and commented](https://github.com/code-423n4/2022-01-notional-findings/issues/68#issuecomment-1030855494):**\n > Propose to increase the severity of this [from Low] to High.\n> \n> This image is a better way to understand the potential attack.\n> ![image](https://user-images.githubusercontent.com/977434/152688228-f26123d4-1c48-4779-8005-b22638e6595c.png)\n> \n\n**[pauliax (judge) increased severity to high and commented](https://github.com/code-423n4/2022-01-notional-findings/issues/68#issuecomment-1041532469):**\n > Great find. Agree with the sponsor, the severity can be upgraded because it destroys the cooldown/redeem protection.\n> \n> \n> Could this be mitigated by including an amount (up to the whole user's balance) when starting a cooldown, and then redeem can't withdraw more than specified during the cooldown init?\n\n**[jeffywu (Notional) commented](https://github.com/code-423n4/2022-01-notional-findings/issues/68#issuecomment-1042982946):**\n > We've prevented this by refactoring how the redemption window is defined.\n\n\n\n***\n\n## [[H-03] A Malicious Treasury Manager Can Burn Treasury Tokens By Setting `makerFee` To The Amount The Maker Receives](https://github.com/code-423n4/2022-01-notional-findings/issues/230)\n_Submitted by leastwood_\n\nThe treasury manager contract holds harvested assets/`COMP` from Notional which are used to perform `NOTE` buybacks or in other areas of the protocol. The manager account is allowed to sign off-chain orders used on 0x to exchange tokens to `WETH` which can then be deposited in the Balancer LP and distributed to `sNOTE` holders.\n\nHowever, `_validateOrder` does not validate that `takerFee` and `makerFee` are set to zero, hence, it is possible for a malicious manager to receive tokens as part of a swap, but the treasury manager contract receives zero tokens as `makerFee` is set to the amount the maker receives. This can be abused to effectively burn treasury tokens at no cost to the order taker.\n\n#### Proof of Concept\n\n<https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange/contracts/src/MixinExchangeCore.sol#L196-L250>\n\n<https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange-libs/contracts/src/LibFillResults.sol#L59-L91>\n\n<https://github.com/code-423n4/2022-01-notional/blob/main/contracts/utils/EIP1271Wallet.sol#L147-L188>\n\n    function _validateOrder(bytes memory order) private view {\n        (\n            address makerToken,\n            address takerToken,\n            address feeRecipient,\n            uint256 makerAmount,\n            uint256 takerAmount\n        ) = _extractOrderInfo(order);\n\n        // No fee recipient allowed\n        require(feeRecipient == address(0), \"no fee recipient allowed\");\n\n        // MakerToken should never be WETH\n        require(makerToken != address(WETH), \"maker token must not be WETH\");\n\n        // TakerToken (proceeds) should always be WETH\n        require(takerToken == address(WETH), \"taker token must be WETH\");\n\n        address priceOracle = priceOracles[makerToken];\n\n        // Price oracle not defined\n        require(priceOracle != address(0), \"price oracle not defined\");\n\n        uint256 slippageLimit = slippageLimits[makerToken];\n\n        // Slippage limit not defined\n        require(slippageLimit != 0, \"slippage limit not defined\");\n\n        uint256 oraclePrice = _toUint(\n            AggregatorV2V3Interface(priceOracle).latestAnswer()\n        );\n\n        uint256 priceFloor = (oraclePrice * slippageLimit) /\n            SLIPPAGE_LIMIT_PRECISION;\n\n        uint256 makerDecimals = 10**ERC20(makerToken).decimals();\n\n        // makerPrice = takerAmount / makerAmount\n        uint256 makerPrice = (takerAmount * makerDecimals) / makerAmount;\n\n        require(makerPrice >= priceFloor, \"slippage is too high\");\n    }\n\n#### Recommended Mitigation Steps\n\nConsider checking that `makerFee == 0` and `takerFee == 0` in `EIP1271Wallet._validateOrder` s.t. the treasury manager cannot sign unfair orders which severely impact the `TreasuryManager` contract.\n\n**[jeffywu (Notional) confirmed and commented](https://github.com/code-423n4/2022-01-notional-findings/issues/230#issuecomment-1030839051):**\n > Confirmed, we will fix this.\n\n**[pauliax (judge) commented](https://github.com/code-423n4/2022-01-notional-findings/issues/230#issuecomment-1041560475):**\n > Good job warden for identifying this issue with 0x integration.\n\n\n\n***\n\n \n# Medium Risk Findings (7)\n## [[M-01] Usage of deprecated ChainLink API in `EIP1271Wallet`](https://github.com/code-423n4/2022-01-notional-findings/issues/197)\n_Submitted by cmichel, also found by 0x1f8b, defsec, leastwood, pauliax, sirhashalot, TomFrenchBlockchain, UncleGrandpa925, and WatchPug_\n\nThe Chainlink API (`latestAnswer`) used in the `EIP1271Wallet` contract is deprecated:\n\n> This API is deprecated. Please see API Reference for the latest Price Feed API. [Chainlink Docs](https://web.archive.org/web/20210304160150/https://docs.chain.link/docs/deprecated-aggregatorinterface-api-reference)\n\nThis function does not error if no answer has been reached but returns 0. Besides, the `latestAnswer` is reported with 18 decimals for crypto quotes but 8 decimals for FX quotes (See Chainlink FAQ for more details). A best practice is to get the decimals from the oracles instead of hard-coding them in the contract.\n\n#### Recommended Mitigation Steps\n\nUse the `latestRoundData` function to get the price instead. Add checks on the return data with proper revert messages if the price is stale or the round is uncomplete, for example:\n\n```solidity\n(uint80 roundID, int256 price, , uint256 timeStamp, uint80 answeredInRound) = priceOracle.latestRoundData();\nrequire(answeredInRound >= roundID, \"...\");\nrequire(timeStamp != 0, \"...\");\n```\n\n**[pauliax (judge) commented](https://github.com/code-423n4/2022-01-notional-findings/issues/197#issuecomment-1037191042):**\n > Valid finding. I am hesitating whether this should be low or medium but decided to leave it as a medium because the likeliness is low but the impact would be huge, and all the wardens submitted this with a medium severity. Also: \"Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\"\n\n\n\n***\n\n## [[M-02] `sNOTE.sol#_mintFromAssets()` Lack of slippage control](https://github.com/code-423n4/2022-01-notional-findings/issues/181)\n_Submitted by WatchPug, also found by cmichel, hyh, pauliax, TomFrenchBlockchain, and UncleGrandpa925_\n\nhttps://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L195-L209\n\n```solidity\nBALANCER_VAULT.joinPool{value: msgValue}(\n    NOTE_ETH_POOL_ID,\n    address(this),\n    address(this), // sNOTE will receive the BPT\n    IVault.JoinPoolRequest(\n        assets,\n        maxAmountsIn,\n        abi.encode(\n            IVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,\n            maxAmountsIn,\n            0 // Accept however much BPT the pool will give us\n        ),\n        false // Don't use internal balances\n    )\n);\n```\n\nThe current implementation of `mintFromNOTE()` and `mintFromETH()` and `mintFromWETH()` (all are using `_mintFromAssets()` with `minimumBPT` hardcoded to `0`) provides no parameter for slippage control, making it vulnerable to front-run attacks.\n\n##### Recommendation\n\nConsider adding a `minAmountOut` parameter for these functions.\n\n**[jeffywu (Notional) confirmed](https://github.com/code-423n4/2022-01-notional-findings/issues/181)**\n\n\n**[pauliax (judge) commented](https://github.com/code-423n4/2022-01-notional-findings/issues/181#issuecomment-1037991707):**\n > Great find, slippage should be configurable and not hardcoded to 0.\n\n\n\n***\n\n## [[M-03] No upper limit on `coolDownTimeInSeconds` allows funds to be locked sNOTE owner](https://github.com/code-423n4/2022-01-notional-findings/issues/40)\n_Submitted by TomFrenchBlockchain, also found by defsec, Dravee, and Jujic_\n\nInability for sNOTE holders to exit the pool in the case of ownership over SNOTE contract being compromised/malicious.\n\n#### Proof of Concept\n\nsNOTE works on a stkAAVE model where users have to wait a set cooldown period before being able to reclaim the underlying tokens. This cooldown period can be set to an arbitrary uint32 value in seconds by the owner of the sNOTE contract.\n\n<https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L94-L97>\n\nBelow in the `startCooldown()` function, it's possible for the owner of the sNOTE contract to choose a value for `coolDownTimeInSeconds` which always causes this function to revert (`_safe32` will always revert if `coolDownTimeInSeconds = type(uint32).max`).\n\n<https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L217-L226>\n\nShould ownership over sNOTE become compromised then all of the users' assets may be locked indefinitely.\n\n#### Recommended Mitigation Steps\n\nProvide a sensible upper limit to `coolDownTimeInSeconds` of, say, a month. This will give plenty of time for NOTE governance to withdraw funds in the event of a shortfall while giving confidence that a user's funds can't be locked forever.\n\n**[pauliax (judge) commented](https://github.com/code-423n4/2022-01-notional-findings/issues/40#issuecomment-1039169763):**\n > Valid concern. I was thinking if this should be left as of medium or low severity, but decided this time in favor of wardens:\n> _\"Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\"_\n\n\n\n***\n\n## [[M-04] MAX_SHORTFALL_WITHDRAW limit on BTP extraction is not enforced](https://github.com/code-423n4/2022-01-notional-findings/issues/209)\n_Submitted by gellej, also found by gzeon_\n\nThe function `extractTokensForCollateralShortfall()` allows the owner of the sNote contract to withdraw up to 50% of the total amount of BPT.\n\nPresumably, this 50% limit is in place to prevent the owner from \"rug-pulling\" the sNote holders (or at least to give them a guarantee that their loss is limited to 50% of the underlying value).\n\nHowever, this limit is easily circumvented as the function can simply be called a second, third and fourth time, to withdraw almost all of the BPT.\n\nAs the contract does not enforce this limit, the bug requires stakers to trust the governance to not withdraw more than 50% of the underlying collateral. This represents a higher risk for the stakers, which may  also result in a larger discount on sNote wrt its BPT collateral (this is why I classified the bug as medium risk - users may lose value - not from an exploit, but from the lack of enforcing the 50% rule)\n\n### Proof of Concept\n\nSee above.\nThe code affected is here: <https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L100>\n\n#### Recommended Mitigation Steps\n\nRewrite the logic and enforce a limit during a time period - i.e. do not allow to withdraw over 50% *per week* (or any time period that is longer than the cooldown period, so that users have time to withdraw their collateral)\n\n**[jeffywu (Notional) confirmed](https://github.com/code-423n4/2022-01-notional-findings/issues/209)**\n\n\n**[pauliax (judge) commented](https://github.com/code-423n4/2022-01-notional-findings/issues/209#issuecomment-1040141667):**\n > Great find, 50% withdrawal limit can be bypassed by invoking the function multiple times.\n\n\n\n***\n\n## [[M-05] `sNOTE` Holders Are Not Incetivized To Vote On Proposals To Call `extractTokensForCollateralShortfall`](https://github.com/code-423n4/2022-01-notional-findings/issues/229)\n_Submitted by leastwood_\n\nAs `sNOTE` have governance voting rights equivalent to the token amount in `NOTE`, users who stake their `NOTE` are also able to vote on governance proposals. In the event a majority of `NOTE` is staked in the `sNOTE` contract, it doesn't seem likely that stakers would be willing to vote on a proposal which liquidates a portion of their staked position.\n\nHence, the protocol may be put into a state where stakers are unwilling to vote on a proposal to call `extractTokensForCollateralShortfall`, leaving Notional insolvent as stakers continue to dump their holdings.\n\n#### Proof of Concept\n\n<https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L99-L129>\n\n    function extractTokensForCollateralShortfall(uint256 requestedWithdraw) external nonReentrant onlyOwner {\n        uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));\n        uint256 maxBPTWithdraw = (bptBalance * MAX_SHORTFALL_WITHDRAW) / 100;\n        // Do not allow a withdraw of more than the MAX_SHORTFALL_WITHDRAW percentage. Specifically don't\n        // revert here since there may be a delay between when governance issues the token amount and when\n        // the withdraw actually occurs.\n        uint256 bptExitAmount = requestedWithdraw > maxBPTWithdraw ? maxBPTWithdraw : requestedWithdraw;\n\n        IAsset[] memory assets = new IAsset[](2);\n        assets[0] = IAsset(address(WETH));\n        assets[1] = IAsset(address(NOTE));\n        uint256[] memory minAmountsOut = new uint256[](2);\n        minAmountsOut[0] = 0;\n        minAmountsOut[1] = 0;\n\n        BALANCER_VAULT.exitPool(\n            NOTE_ETH_POOL_ID,\n            address(this),\n            payable(owner), // Owner will receive the NOTE and WETH\n            IVault.ExitPoolRequest(\n                assets,\n                minAmountsOut,\n                abi.encode(\n                    IVault.ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT,\n                    bptExitAmount\n                ),\n                false // Don't use internal balances\n            )\n        );\n    }\n\n#### Recommended Mitigation Steps\n\nConsider redesigning this mechanism to better align stakers with the health of the protocol. It might be useful to allocate a percentage of generated fees to an insurance fund which will be used to cover any collateral shortfall events. This fund can be staked to generate additional yield.\n\n**[jeffywu (Notional) acknowledged and commented](https://github.com/code-423n4/2022-01-notional-findings/issues/229#issuecomment-1030839281):**\n > Acknowledged, however, there are technical difficulties with programmatic collateral shortfall detection at this moment. We will look to develop a method that allows for programmatic detection in the future (these issues have been discussed with the warden).\n\n**[pauliax (judge) commented](https://github.com/code-423n4/2022-01-notional-findings/issues/229#issuecomment-1041536723):**\n > A hypothetical but valid concern.\n\n\n\n***\n\n## [[M-06] `getVotingPower` Is Not Equipped To Handle On-Chain Voting](https://github.com/code-423n4/2022-01-notional-findings/issues/165)\n_Submitted by leastwood_\n\nAs `NOTE` continues to be staked in the `sNOTE` contract, it is important that Notional's governance is able to correctly handle on-chain voting by calculating the relative power `sNOTE` has in terms of its equivalent `NOTE` amount.\n\n`getVotingPower` is a useful function in tracking the relative voting power a staker has, however, it does not utilise any checkpointing mechanism to ensure the user's voting power is a snapshot of a specific block number. As a result, it would be possible to manipulate a user's voting power by casting a vote on-chain and then have them transfer their `sNOTE` to another account to then vote again.\n\n#### Proof of Concept\n\n<https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L271-L293>\n\n    function getVotingPower(uint256 sNOTEAmount) public view returns (uint256) {\n        // Gets the BPT token price (in ETH)\n        uint256 bptPrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.BPT_PRICE);\n        // Gets the NOTE token price (in ETH)\n        uint256 notePrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.PAIR_PRICE);\n        \n        // Since both bptPrice and notePrice are denominated in ETH, we can use\n        // this formula to calculate noteAmount\n        // bptBalance * bptPrice = notePrice * noteAmount\n        // noteAm"
    }
  ]
}