{
  "Title": "[G-09] Default value initialization",
  "Content": "\n### Problem\nIf a variable is not set/initialized, it is assumed to have the default value (`0`, `false`, `0x0` etc depending on the data type).<br>\nExplicitly initializing it with its default value is an anti-pattern and wastes gas.<br>\n*Instances include:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L45\n```solidity\nFile:\tcontracts/rewards/RewardDistributor.sol\n45:  uint256 public epoch = 0;\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L50\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowDelegation.sol\nuint256 public MIN_VOTING_POWER_REQUIRED = 0;\n```\n\n### Proof of Concept\nIn case of `RewardDistributor`<br>\n`hardhat-gas-reporter` results<br>\nbefore fix:<br>\n| Deployments ||||\n|-|:-:|:-:|:-:|\n| Contract | min | max | avg |\n| GolomTrader | 2379507  | 2379543  |  2379537\t|\nafter fix:\n| Deployments ||||\n|-|:-:|:-:|:-:|\n| Contract | min | max | avg |\n| GolomTrader | 2377233  | 2377269  |  2377263\t|\n\n### Mitigation\nRemove explicit initialization for default values.\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-07-golom-contest",
  "Code": [
    {
      "filename": "contracts/rewards/RewardDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\n// stores daily trades\n// is minter of token, first interaction mints tokens and distributes tokens\n// gives prorata tokens to traders and exchange daily\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport 'hardhat/console.sol';\n\ninterface ERC20 {\n    function totalSupply() external returns (uint256);\n\n    function balanceOf(address account) external returns (uint256);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function mint(address account, uint256 amount) external;\n\n    function balanceOfNFTAt(uint256 _tokenId, uint256 _t) external view returns (uint256);\n\n    function deposit() external payable;\n}\n\ninterface VE {\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function totalSupplyAtT(uint256 t) external view returns (uint256);\n\n    function balanceOfNFTAt(uint256 _tokenId, uint256 _t) external view returns (uint256);\n\n    function totalSupplyAt(uint256 _block) external view returns (uint256);\n\n    function balanceOfAtNFT(uint256 _tokenId, uint256 _block) external view returns (uint256);\n}\n\ncontract RewardDistributor is Ownable {\n    address public trader;\n    uint256 public epoch = 0;\n    uint256 public startTime; // timestamp at which the contracts need to be activated\n\n    uint256 constant dailyEmission = 600000 * 10**18;\n\n    address public pendingTrader;\n    uint256 public traderEnableDate;\n\n    address public pendingVoteEscrow;\n    uint256 public voteEscrowEnableDate;\n    VE public ve;\n\n    uint256 constant secsInDay = 24 * 60 * 60;\n    mapping(address => mapping(uint256 => uint256)) public feesTrader; // fees accumulated by address of trader per epoch\n    mapping(address => mapping(uint256 => uint256)) public feesExchange; // fees accumulated by exchange of trader per epoch\n    mapping(uint256 => uint256) public epochTotalFee; // total fee of epoch\n    mapping(uint256 => uint256) public rewardTrader; // reward minted each epoc for trader\n    mapping(uint256 => uint256) public rewardExchange; // reward minted each epoc for exhange\n    mapping(uint256 => uint256) public rewardLP; // reward minted each epoc for LP\n    mapping(uint256 => uint256) public rewardStaker; // reward minted each epoc for stakers\n    mapping(uint256 => uint256) public epochBeginTime; // what time previous epoch ended\n    mapping(uint256 => uint256) public claimedUpto; // epoch upto which tokenid has claimed\n    mapping(uint256 => mapping(uint256 => uint256)) public claimed; // epoch upto which tokenid has claimed\n    ERC20 public rewardToken;\n    ERC20 public weth;\n    event NewEpoch(uint256 indexed epochNo, uint256 tokenMinted, uint256 rewardStaker, uint256 previousEpochFee);\n\n    // epochs,trader, token\n\n    constructor(\n        address _weth,\n        address _trader,\n        address _token,\n        address _governance\n    ) {\n        weth = ERC20(_weth);\n        trader = _trader;\n        rewardToken = ERC20(_token);\n        _transferOwnership(_governance); // set the new owner\n        startTime = 1659211200;\n    }\n\n    modifier onlyTrader() {\n        require(msg.sender == trader);\n        _;\n    }\n\n    // at starttime epoch 1 starts , first trade changes epoch from 0 to 1 , emits tokens stores the rewards for epoch 1 ,\n    // after 1 day , first trade changes epoch from 1 to 2, changes eth in contract to weth and stores rewardstakedeth , emits tokens stores the rewards for epoch 2\n\n    /// @dev Add fees contributed by the Seller of nft and the exchange/frontend that facilated the trade\n    /// @param addr the address that contributed in fees\n    /// @param fee the fee contributed by these addresses\n    function addFee(address[2] memory addr, uint256 fee) public onlyTrader {\n        //console.log(block.timestamp,epoch,fee);\n        if (rewardToken.totalSupply() > 1000000000 * 10**18) {\n            // if supply is greater then a billion dont mint anything, dont add trades\n            return;\n        }\n\n        // if 24 hours have passed since last epoch change\n        if (block.timestamp > startTime + (epoch) * secsInDay) {\n            // this assumes atleast 1 trade is done daily??????\n            // logic to decide how much token to emit\n            // emission = daily * (1 - (balance of locker/ total supply))  full if 0 locked and 0 if all locked\n            // uint256 tokenToEmit = dailyEmission * rewardToken.balanceOf()/\n            // emissions is decided by epoch begiining locked/circulating , and amount each nft gets also decided at epoch begining\n            uint256 tokenToEmit = (dailyEmission * (rewardToken.totalSupply() - rewardToken.balanceOf(address(ve)))) /\n                rewardToken.totalSupply();\n            uint256 stakerReward = (tokenToEmit * rewardToken.balanceOf(address(ve))) / rewardToken.totalSupply();\n            // deposit previous epoch fee to weth for distribution to stakers\n\n            uint256 previousEpochFee = epochTotalFee[epoch];\n            epoch = epoch + 1;\n            rewardStaker[epoch] = stakerReward;\n            rewardTrader[epoch] = ((tokenToEmit - stakerReward) * 67) / 100;\n            rewardExchange[epoch] = ((tokenToEmit - stakerReward) * 33) / 100;\n            rewardToken.mint(address(this), tokenToEmit);\n            epochBeginTime[epoch] = block.number;\n            if (previousEpochFee > 0) {\n                if (epoch == 1){\n                    epochTotalFee[0] =  address(this).balance; // staking and trading rewards start at epoch 1, for epoch 0 all contract ETH balance is converted to staker rewards rewards.\n                    weth.deposit{value: address(this).balance}();  \n                }else{\n                    weth.deposit{value: previousEpochFee}();\n                }\n            }\n            emit NewEpoch(epoch, tokenToEmit, stakerReward, previousEpochFee);\n        }\n        feesTrader[addr[0]][epoch] = feesTrader[addr[0]][epoch] + fee;\n        feesExchange[addr[1]][epoch] = feesExchange[addr[1]][epoch] + fee;\n        epochTotalFee[epoch] = epochTotalFee[epoch] + fee;\n        return;\n    }\n\n    // allows sellers of nft to claim there previous epoch rewards\n    function traderClaim(address addr, uint256[] memory epochs) public {\n        uint256 reward = 0;\n        for (uint256 index = 0; index < epochs.length; index++) {\n            require(epochs[index] < epoch);\n            reward =\n                reward +\n                (rewardTrader[epochs[index]] * feesTrader[addr][epochs[index]]) /\n                epochTotalFee[epochs[index]];\n            feesTrader[addr][epochs[index]] = 0;\n        }\n        rewardToken.transfer(addr, reward);\n    }\n\n    // allows exchange that facilated the nft trades to claim there previous epoch rewards\n    function exchangeClaim(address addr, uint256[] memory epochs) public {\n        uint256 reward = 0;\n        for (uint256 index = 0; index < epochs.length; index++) {\n            require(epochs[index] < epoch);\n            reward =\n                reward +\n                (rewardExchange[epochs[index]] * feesExchange[addr][epochs[index]]) /\n                epochTotalFee[epochs[index]];\n            feesExchange[addr][epochs[index]] = 0;\n        }\n        rewardToken.transfer(addr, reward);\n    }\n\n    /// @dev allows VeNFT holders to claim there token and eth rewards\n    ///      all tokenids must have a common owner\n    /// @param tokenids the nft ids to claim rewards for all ids in the list must belong to 1 address\n    /// @param epochs the list of epochs to claim rewards\n    function multiStakerClaim(uint256[] memory tokenids, uint256[] memory epochs) public {\n        require(address(ve) != address(0), ' VE not added yet');\n\n        uint256 reward = 0;\n        uint256 rewardEth = 0;\n        address tokenowner = ve.ownerOf(tokenids[0]);\n\n        // for each tokenid\n        for (uint256 tindex = 0; tindex < tokenids.length; tindex++) {\n            require(tokenowner == ve.ownerOf(tokenids[tindex]), 'Can only claim for a single Address together');\n            // for each epoch\n            for (uint256 index = 0; index < epochs.length; index++) {\n                require(epochs[index] < epoch, 'cant claim for future epochs');\n                require(claimed[tokenids[tindex]][epochs[index]] == 0, 'cant claim if already claimed');\n                claimed[tokenids[tindex]][epochs[index]] = 1;\n                if (epochs[index] == 0){\n                    rewardEth =\n                        rewardEth +\n                        (epochTotalFee[0] *\n                            ve.balanceOfAtNFT(tokenids[tindex], epochBeginTime[1])) /\n                        ve.totalSupplyAt(epochBeginTime[1]);\n\n                }else{\n                    reward =\n                        reward +\n                        (rewardStaker[epochs[index]] * ve.balanceOfAtNFT(tokenids[tindex], epochBeginTime[epochs[index]])) /\n                        ve.totalSupplyAt(epochBeginTime[epochs[index]]);\n                    rewardEth =\n                        rewardEth +\n                        (epochTotalFee[epochs[index]] *\n                            ve.balanceOfAtNFT(tokenids[tindex], epochBeginTime[epochs[index]])) /\n                        ve.totalSupplyAt(epochBeginTime[epochs[index]]);\n                }\n\n            }\n        }\n        rewardToken.transfer(tokenowner, reward);\n        weth.transfer(tokenowner, rewardEth);\n    }\n\n\n    /// @dev returns unclaimed rewards of an NFT, returns (unclaimed golom rewards, unclaimed eth rewards, unclaimed epochs)\n    /// @param tokenid the nft id to claim rewards for all ids in the list must belong to 1 address\n    function stakerRewards(uint256 tokenid) public view returns (\n            uint256,\n            uint256,\n            uint256[] memory\n        ){\n        require(address(ve) != address(0), ' VE not added yet');\n\n        uint256 reward = 0;\n        uint256 rewardEth = 0;\n        uint256[] memory unclaimedepochs = new uint256[](epoch);\n        // for each epoch\n        for (uint256 index = 0; index < epoch; index++) {\n            unclaimedepochs[index]=claimed[tokenid][index];\n            if (claimed[tokenid][index] == 0){\n                if (index == 0){\n                    rewardEth =\n                        rewardEth +\n                        (epochTotalFee[0] *\n                            ve.balanceOfAtNFT(tokenid, epochBeginTime[1])) /\n                        ve.totalSupplyAt(epochBeginTime[1]);\n\n                }else{\n                    reward =\n                        reward +\n                        (rewardStaker[index] * ve.balanceOfAtNFT(tokenid, epochBeginTime[index])) /\n                        ve.totalSupplyAt(epochBeginTime[index]);\n                    rewardEth =\n                        rewardEth +\n                        (epochTotalFee[index] *\n                            ve.balanceOfAtNFT(tokenid, epochBeginTime[index])) /\n                        ve.totalSupplyAt(epochBeginTime[index]);\n                }\n            }\n        }\n        return (reward, rewardEth, unclaimedepochs);\n    }\n\n    /// @dev returns unclaimed rewards of an NFT, returns (unclaimed golom rewards, unclaimed eth rewards, unclaimed epochs)\n    /// @param addr the nft id to claim rewards for all ids in the list must belong to 1 address\n    function traderRewards(address addr) public view returns (\n            uint256        \n            ){\n        uint256 reward = 0;\n        for (uint256 index = 0; index < epoch; index++) {\n            reward =\n                reward +\n                (rewardTrader[index] * feesTrader[addr][index]) /\n                epochTotalFee[index];\n        }\n        return (reward);\n    }\n\n    /// @dev returns unclaimed golom rewards of a trader\n    /// @param addr the nft id to claim rewards for all ids in the list must belong to 1 address\n    function exchangeRewards(address addr) public view returns (\n            uint256\n        ){\n        uint256 reward = 0;\n        for (uint256 index = 0; index < epoch; index++) {\n            reward =\n                reward +\n                (rewardExchange[index] * feesExchange[addr][index]) /\n                epochTotalFee[index];\n        }\n        return (reward);\n    }\n\n    /// @notice Changes the trader address with timelock\n    /// @dev executeChangeTrader needs to be called after 1 days\n    /// @param _trader New trader address\n    function changeTrader(address _trader) external onlyOwner {\n        traderEnableDate = block.timestamp + 1 days;\n        pendingTrader = _trader;\n    }\n\n    /// @notice Execute's the change trader function\n    function executeChangeTrader() external onlyOwner {\n        require(traderEnableDate <= block.timestamp, 'RewardDistributor: time not over yet');\n        trader = pendingTrader;\n    }\n\n    /// @notice Adds vote escrow contract for multi staker claim\n    /// @param _voteEscrow Address of the voteEscrow contract\n    function addVoteEscrow(address _voteEscrow) external onlyOwner {\n        if (address(ve) == address(0)) {\n            ve = VE(pendingVoteEscrow);\n        } else {\n            voteEscrowEnableDate = block.timestamp + 1 days;\n            pendingVoteEscrow = _voteEscrow;\n        }\n    }\n\n    /// @notice Adds vote escrow contract for multi staker claim\n    function executeAddVoteEscrow() external onlyOwner {\n        require(voteEscrowEnableDate <= block.timestamp, 'RewardDistributor: time not over yet');\n        ve = VE(pendingVoteEscrow);\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/vote-escrow/VoteEscrowDelegation.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\n/// votescrow extended with delegation\n\n// import {Math} from '@openzeppelin-contracts/utils/math/SafeCast.sol';\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\n\nimport {VoteEscrowCore} from './VoteEscrowCore.sol';\n\ninterface IVoteEscrow {\n    function balanceOf(uint256) external view returns (uint256);\n\n    function balanceOfAtNFT(uint256, uint256) external view returns (uint256);\n\n    function ownerOf(uint256) external view returns (address);\n}\n\ncontract VoteEscrow is VoteEscrowCore, Ownable {\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(uint256 indexed tokenId, uint256 indexed toTokenId, address indexed currentOwner);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /// @notice Delegate of the specific token\n    mapping(uint256 => uint256) public delegates;\n\n    /// @notice Total delegated tokens to specific token\n    mapping(uint256 => uint256[]) public delegatedTokenIds;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint256 fromBlock;\n        uint256[] delegatedTokenIds;\n    }\n\n    /// @notice A record of votes checkpoints for each tokenId, by index\n    mapping(uint256 => mapping(uint256 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each delegated tokenId\n    mapping(uint256 => uint256) public numCheckpoints;\n\n    /// @notice minimum voting power required for delegation\n    uint256 public MIN_VOTING_POWER_REQUIRED = 0;\n\n    constructor(address _token) {\n        token = _token;\n        voter = msg.sender;\n        point_history[0].blk = block.number;\n        point_history[0].ts = block.timestamp;\n\n        supportedInterfaces[ERC165_INTERFACE_ID] = true;\n        supportedInterfaces[ERC721_INTERFACE_ID] = true;\n        supportedInterfaces[ERC721_METADATA_INTERFACE_ID] = true;\n\n        // mint-ish\n        emit Transfer(address(0), address(this), tokenId);\n        // burn-ish\n        emit Transfer(address(this), address(0), tokenId);\n    }\n\n    /// @notice Explain to an end user what this does\n    /// @param tokenId token ID which is being delegated\n    /// @param toTokenId token ID to which the {tokenId} is being delegated\n    function delegate(uint256 tokenId, uint256 toTokenId) external {\n        require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n        require(this.balanceOfNFT(tokenId) >= MIN_VOTING_POWER_REQUIRED, 'VEDelegation: Need more voting power');\n\n        delegates[tokenId] = toTokenId;\n        uint256 nCheckpoints = numCheckpoints[toTokenId];\n\n        if (nCheckpoints > 0) {\n            Checkpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1];\n            checkpoint.delegatedTokenIds.push(tokenId);\n            _writeCheckpoint(toTokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n        } else {\n            uint256[] memory array = new uint256[](1);\n            array[0] = tokenId;\n            _writeCheckpoint(toTokenId, nCheckpoints, array);\n        }\n\n        emit DelegateChanged(tokenId, toTokenId, msg.sender);\n    }\n\n    /**\n     * @notice Writes the checkpoint to store current NFTs in the specific block\n     */\n    function _writeCheckpoint(\n        uint256 toTokenId,\n        uint256 nCheckpoints,\n        uint256[] memory _delegatedTokenIds\n    ) internal {\n        require(_delegatedTokenIds.length < 500, 'VVDelegation: Cannot stake more');\n\n        Checkpoint memory oldCheckpoint = checkpoints[toTokenId][nCheckpoints - 1];\n\n        if (nCheckpoints > 0 && oldCheckpoint.fromBlock == block.number) {\n            oldCheckpoint.delegatedTokenIds = _delegatedTokenIds;\n        } else {\n            checkpoints[toTokenId][nCheckpoints] = Checkpoint(block.number, _delegatedTokenIds);\n            numCheckpoints[toTokenId] = nCheckpoints + 1;\n        }\n    }\n\n    /**\n     * @notice Gets the current delegated nfts array for `nftid`\n     * @param tokenId The address to get votes balance\n     * @return The current delegated nfts array for `account`\n     */\n    function _getCurrentDelegated(uint256 tokenId) internal view returns (uint256[] memory) {\n        uint256 nCheckpoints = numCheckpoints[tokenId];\n        uint256[] memory myArray;\n        return nCheckpoints > 0 ? checkpoints[tokenId][nCheckpoints - 1].delegatedTokenIds : myArray;\n    }\n\n    /**\n     * @notice Determine the prior delegated nfts array for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param nftId The id of the nft to check\n     * @param blockNumber The block number to get the delegate nft array at\n     * @return The number of delegated nfts the account had as of the given block\n     */\n    function _getPriorDelegated(uint256 nftId, uint256 blockNumber) internal view returns (uint256[] memory) {\n        require(blockNumber < block.number, 'VEDelegation: not yet determined');\n        uint256[] memory myArray;\n        uint256 nCheckpoints = numCheckpoints[nftId];\n        if (nCheckpoints == 0) {\n            return myArray;\n        }\n\n        // First check most recent balance\n        if (checkpoints[nftId][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[nftId][nCheckpoints - 1].delegatedTokenIds;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[nftId][0].fromBlock > blockNumber) {\n            return myArray;\n        }\n\n        uint256 lower = 0;\n        uint256 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[nftId][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.delegatedTokenIds;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[nftId][lower].delegatedTokenIds;\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param tokenId The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getVotes(uint256 tokenId) external view returns (uint256) {\n        uint256[] memory delegated = _getCurrentDelegated(tokenId);\n        uint256 votes = 0;\n        for (uint256 index = 0; index < delegated.length; index++) {\n            votes = votes + this.balanceOfNFT(delegated[index]);\n        }\n        return votes;\n    }\n\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param tokenId The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(uint256 tokenId, uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, 'VEDelegation: not yet determined');\n        uint256[] memory delegatednft = _getPriorDelegated(tokenId, blockNumber);\n        uint256 votes = 0;\n        for (uint256 index = 0; index < delegatednft.length; index++) {\n            votes = votes + this.balanceOfAtNFT(delegatednft[index], blockNumber);\n        }\n        return votes;\n    }\n\n    /// @notice Removes specific element from the array\n    /// @param _array Whole array\n    /// @param _element The element which we need to remove\n    function removeElement(uint256[] storage _array, uint256 _element) internal {\n        for (uint256 i; i < _array.length; i++) {\n            if (_array[i] == _element) {\n                _array[i] = _array[_array.length - 1];\n                _array.pop();\n                break;\n            }\n        }\n    }\n\n    /// @notice Remove delegation\n    /// @param tokenId TokenId of which delegation needs to be removed\n    function removeDelegation(uint256 tokenId) external {\n        require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n        uint256 nCheckpoints = numCheckpoints[tokenId];\n        Checkpoint storage checkpoint = checkpoints[tokenId][nCheckpoints - 1];\n        removeElement(checkpoint.delegatedTokenIds, tokenId);\n        _writeCheckpoint(tokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n    }\n\n    // /// @notice Remove delegation by user\n    // function removeDelegationByOwner(uint256 delegatedTokenId, uint256 ownerTokenId) external {\n    //     require(ownerOf(ownerTokenId) == msg.sender, 'VEDelegation: Not allowed');\n    //     uint256 nCheckpoints = numCheckpoints[delegatedTokenId];\n    //     Checkpoint storage checkpoint = checkpoints[delegatedTokenId][nCheckpoints - 1];\n    //     removeElement(checkpoint.delegatedTokenIds, delegatedTokenId);\n    //     _writeCheckpoint(ownerTokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n    // }\n\n    /// @dev Exeute transfer of a NFT.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n    ///      address for this NFT. (NOTE: `msg.sender` not allowed in internal function so pass `_sender`.)\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    function _transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        address _sender\n    ) internal override {\n        require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');\n\n        // remove the delegation\n        this.removeDelegation(_tokenId);\n\n        // Check requirements\n        require(_isApprovedOrOwner(_sender, _tokenId));\n        // Clear approval. Throws if `_from` is not the current owner\n        _clearApproval(_from, _tokenId);\n        // Remove NFT. Throws if `_tokenId` is not a valid NFT\n        _removeTokenFrom(_from, _tokenId);\n        // Add NFT\n        _addTokenTo(_to, _tokenId);\n        // Set the block of ownership transfer (for Flash NFT protection)\n        ownership_change[_tokenId] = block.number;\n        // Log the transfer\n        emit Transfer(_from, _to, _tokenId);\n    }\n\n    /// @notice Changes minimum voting power required for delegation\n    /// @param _newMinVotingPower New minimum voting power required\n    function changeMinVotingPower(uint256 _newMinVotingPower) external onlyOwner {\n        MIN_VOTING_POWER_REQUIRED = _newMinVotingPower;\n    }\n}"
    }
  ]
}