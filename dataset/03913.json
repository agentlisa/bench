{
  "Title": "Unresolved `TODO`",
  "Content": "##### Description\nUnresolved `TODO` was found in https://github.com/Grandthrax/yearnV2-generic-lender-strat/blob/979ef2f0e5da39ca59a5907c37ba2064fcd6be82/contracts/GenericLender/GenericDyDx.sol#L29.\n\n##### Recommendation\nIt is recommended to resolve it.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/GenericLender/GenericDyDx.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../Interfaces/DyDx/ISoloMargin.sol\";\nimport \"../Interfaces/DyDx/IInterestSetter.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../Interfaces/UniswapInterfaces/IUniswapV2Router02.sol\";\n\nimport \"./GenericLenderBase.sol\";\n\n/********************\n *   A lender plugin for LenderYieldOptimiser for DyDx\n *   Made by SamPriestley.com\n *   https://github.com/Grandthrax/yearnv2/blob/master/contracts/GenericLender/GenericDyDx.sol\n *\n ********************* */\n\ncontract GenericDyDx is GenericLenderBase {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    uint256 private constant secondPerYear = 31_153_900; //todo\n    address private constant SOLO = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;\n    uint256 public dydxMarketId;\n\n    constructor(address _strategy, string memory name) public GenericLenderBase(_strategy, name) {\n        want.approve(SOLO, uint256(-1));\n\n        ISoloMargin solo = ISoloMargin(SOLO);\n        uint256 numMarkets = solo.getNumMarkets();\n        address curToken;\n        for (uint256 i = 0; i < numMarkets; i++) {\n            curToken = solo.getMarketTokenAddress(i);\n\n            if (curToken == address(want)) {\n                dydxMarketId = i;\n                return;\n            }\n        }\n        revert(\"No marketId found for provided token\");\n    }\n\n    function nav() external view override returns (uint256) {\n        return _nav();\n    }\n\n    function _nav() internal view returns (uint256) {\n        uint256 underlying = underlyingBalanceStored();\n        return want.balanceOf(address(this)).add(underlying);\n    }\n\n    function underlyingBalanceStored() public view returns (uint256) {\n        (address[] memory cur, , Types.Wei[] memory balance) = ISoloMargin(SOLO).getAccountBalances(_getAccountInfo());\n\n        for (uint256 i = 0; i < cur.length; i++) {\n            if (cur[i] == address(want)) {\n                return balance[i].value;\n            }\n        }\n    }\n\n    function apr() external view override returns (uint256) {\n        return _apr(0);\n    }\n\n    function weightedApr() external view override returns (uint256) {\n        uint256 a = _apr(0);\n        return a.mul(_nav());\n    }\n\n    function withdraw(uint256 amount) external override management returns (uint256) {\n        return _withdraw(amount);\n    }\n\n    //emergency withdraw. sends balance plus amount to governance\n    function emergencyWithdraw(uint256 amount) external override management {\n        _withdraw(amount);\n        want.safeTransfer(vault.governance(), want.balanceOf(address(this)));\n    }\n\n    //withdraw an amount including any want balance\n    function _withdraw(uint256 amount) internal returns (uint256) {\n        uint256 balanceUnderlying = underlyingBalanceStored();\n        uint256 looseBalance = want.balanceOf(address(this));\n        uint256 total = balanceUnderlying.add(looseBalance);\n\n        if (amount > total) {\n            //cant withdraw more than we own\n            amount = total;\n        }\n        if (looseBalance >= amount) {\n            want.safeTransfer(address(strategy), amount);\n            return amount;\n        }\n\n        //not state changing but OK because of previous call\n        uint256 liquidity = want.balanceOf(SOLO);\n\n        if (liquidity > 1) {\n            uint256 toWithdraw = amount.sub(looseBalance);\n\n            if (toWithdraw <= liquidity) {\n                //we can take all\n                dydxWithdraw(toWithdraw);\n            } else {\n                //take all we can\n                dydxWithdraw(liquidity);\n            }\n        }\n        looseBalance = want.balanceOf(address(this));\n        want.safeTransfer(address(strategy), looseBalance);\n        return looseBalance;\n    }\n\n    function dydxDeposit(uint256 depositAmount) internal {\n        ISoloMargin solo = ISoloMargin(SOLO);\n\n        Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](1);\n\n        operations[0] = _getDepositAction(dydxMarketId, depositAmount);\n\n        Account.Info[] memory accountInfos = new Account.Info[](1);\n        accountInfos[0] = _getAccountInfo();\n\n        solo.operate(accountInfos, operations);\n    }\n\n    function dydxWithdraw(uint256 amount) internal {\n        ISoloMargin solo = ISoloMargin(SOLO);\n\n        Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](1);\n\n        operations[0] = _getWithdrawAction(dydxMarketId, amount);\n\n        Account.Info[] memory accountInfos = new Account.Info[](1);\n        accountInfos[0] = _getAccountInfo();\n\n        solo.operate(accountInfos, operations);\n    }\n\n    function deposit() external override management {\n        uint256 balance = want.balanceOf(address(this));\n        dydxDeposit(balance);\n    }\n\n    function withdrawAll() external override management returns (bool) {\n        uint256 balance = _nav();\n        uint256 returned = _withdraw(balance);\n        return returned >= balance;\n    }\n\n    //think about this\n    function enabled() external view override returns (bool) {\n        return true;\n    }\n\n    function hasAssets() external view override returns (bool) {\n        return underlyingBalanceStored() > 0;\n    }\n\n    function aprAfterDeposit(uint256 amount) external view override returns (uint256) {\n        return _apr(amount);\n    }\n\n    function _apr(uint256 extraSupply) internal view returns (uint256) {\n        ISoloMargin solo = ISoloMargin(SOLO);\n        Types.TotalPar memory par = solo.getMarketTotalPar(dydxMarketId);\n        Interest.Index memory index = solo.getMarketCurrentIndex(dydxMarketId);\n        address interestSetter = solo.getMarketInterestSetter(dydxMarketId);\n        uint256 borrow = uint256(par.borrow).mul(index.borrow).div(1e18);\n        uint256 supply = (uint256(par.supply).mul(index.supply).div(1e18)).add(extraSupply);\n\n        uint256 borrowInterestRate = IInterestSetter(interestSetter).getInterestRate(address(want), borrow, supply).value;\n        uint256 lendInterestRate = borrowInterestRate.mul(borrow).div(supply);\n        return lendInterestRate.mul(secondPerYear);\n    }\n\n    function protectedTokens() internal view override returns (address[] memory) {\n        address[] memory protected = new address[](1);\n        protected[0] = address(want);\n        return protected;\n    }\n\n    function _getWithdrawAction(uint256 marketId, uint256 amount) internal view returns (Actions.ActionArgs memory) {\n        return\n            Actions.ActionArgs({\n                actionType: Actions.ActionType.Withdraw,\n                accountId: 0,\n                amount: Types.AssetAmount({\n                    sign: false,\n                    denomination: Types.AssetDenomination.Wei,\n                    ref: Types.AssetReference.Delta,\n                    value: amount\n                }),\n                primaryMarketId: marketId,\n                secondaryMarketId: 0,\n                otherAddress: address(this),\n                otherAccountId: 0,\n                data: \"\"\n            });\n    }\n\n    function _getDepositAction(uint256 marketId, uint256 amount) internal view returns (Actions.ActionArgs memory) {\n        return\n            Actions.ActionArgs({\n                actionType: Actions.ActionType.Deposit,\n                accountId: 0,\n                amount: Types.AssetAmount({\n                    sign: true,\n                    denomination: Types.AssetDenomination.Wei,\n                    ref: Types.AssetReference.Delta,\n                    value: amount\n                }),\n                primaryMarketId: marketId,\n                secondaryMarketId: 0,\n                otherAddress: address(this),\n                otherAccountId: 0,\n                data: \"\"\n            });\n    }\n\n    function _getAccountInfo() internal view returns (Account.Info memory) {\n        return Account.Info({owner: address(this), number: 0});\n    }\n}"
    }
  ]
}