{
  "Title": "Unused isMaxCapReached",
  "Content": "[isMaxCapReached](https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/Crowdsale.sol#L209) is not used in Crowdsale.sol, but seems like it could be used in [line 186](https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/Crowdsale.sol#L186) or in [the finalize function](https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/Crowdsale.sol#L293).\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Crowdsale.sol",
      "content": "pragma solidity ^0.4.8;\nimport \"./SafeMath.sol\";\nimport \"./RLC.sol\";\nimport \"./PullPayment.sol\";\nimport \"./Pausable.sol\";\n\n/*\n  Crowdsale Smart Contract for the iEx.ec project\n\n  This smart contract collects ETH and BTC, and in return emits RLC tokens to the backers\n\n  Thanks to BeyondTheVoid and TokenMarket who helped us shaping this code.\n\n */\n\n// To do : create a generic test with parameter to run abitrary simulation\n// To test: RLC allowance when reach Maxcap, Unlock transfer, pausable\n\n\ncontract Crowdsale is SafeMath, PullPayment, Pausable {\n\n  \tstruct Backer {\n  \t  uint weiReceived;\t// Amount of ETH given\n\t  string btc_address;  //store the btc address for full tracability\n\t  uint satoshiReceived;\t// Amount of BTC given\n\t  uint rlcToSend;   \t// rlc to distribute when the min cap is reached\n\t  uint rlcSent;\n\t}\n\n\tRLC \tpublic rlc;         // RLC contract reference\n\taddress public owner;       // Contract owner (iEx.ec team)\n\taddress public multisigETH; // Multisig contract that will receive the ETH\n\taddress public BTCproxy;\t// addess of the BTC Proxy\n\n\tuint public RLCPerETH;      // Number of RLC per ETH\n\tuint public RLCPerSATOSHI;  // Number of RLC per SATOSHI\n\tuint public ETHReceived;    // Number of ETH received\n\tuint public BTCReceived;    // Number of BTC received\n\tuint public RLCSentToETH;   // Number of RLC sent to ETH contributors\n\tuint public RLCSentToBTC;   // Number of RLC sent to BTC contributors\n\tuint public RLCEmitted;\t\t// Number of RLC emitted \n\tuint public startBlock;     // Crowdsale start block\n\tuint public endBlock;       // Crowdsale end block\n\tuint public minCap;         // Minimum number of RLC to sell\n\tuint public maxCap;         // Maximum number of RLC to sell\n\tbool public maxCapReached;  // Max cap has been reached\n\tuint public minInvestETH;   // Minimum amount to invest\n\tuint public minInvestBTC;   // Minimum amount to invest\n\tbool public crowdsaleClosed;// Is crowdsale still on going\n\t\n\taddress public bounty;\t\t// address at which the bounty RLC will be sent\n\taddress public reserve; \t// address at which the contingency reserve will be sent\n\taddress public team;\t\t// address at which the team RLC will be sent\n\n\tuint public rlc_bounty;\t\t// amount of bounties RLC\n\tuint public rlc_reserve;\t// amount of the contingency reserve\n\tuint public rlc_team;\t\t// amount of the team RLC \n\t\n\tmapping(address => Backer) public backers; //backersETH indexed by their ETH address\n\t//mapping(address => BackerBTC) public backersBTC; //backersBTC indexed by their (BTC,ETH) address\n\n    // Auth modifier, if the msg.sender isn't the expected address, throw.\n\tmodifier onlyBy(address a){\n\t    if (msg.sender != a) throw;  \n\t    _;\n\t}\n\n\tmodifier minCapNotReached() {\n\t\tif ((now<endBlock) || isMinCapReached() || (now > endBlock + 15 days)) throw;\n\t\t_;\n\t}\n\n\t/*\n\t *  /!\\ FUNCTION FOR TEST ONLY - WILL BE REMOVE IN THE FINAL CONTRACT\n\t */\n\n\tfunction closeCrowdsaleForRefund() {\n\t\tendBlock = now;\n\t}\n\t// same than finalise() without time condition\n\tfunction finalizeTEST() onlyBy(owner) {\n\t\t//moves the remaining ETH to the multisig address\n\t\tif (!multisigETH.send(this.balance)) throw;\n\t\t//moves RLC to the team, reserve and bounty address\n\t    if (!transferRLC(team,rlc_team)) throw;\n\t    if (!transferRLC(reserve,rlc_reserve)) throw;\t\n\t    if (!transferRLC(bounty,rlc_bounty)) throw;\n\t    rlc.burn(rlc.totalSupply() - RLCEmitted);\n\t\tcrowdsaleClosed = true;\n\t}\n\n\t/*\n\t * /!\\ END TEST FUNCTION\n\t */\n\n\n\tevent ReceivedETH(address addr, uint value);\n\tevent ReceivedBTC(address addr, string from, uint value);\n\tevent RefundBTC(string to, uint value);\n\tevent Logs(address indexed from, uint amount, string value);\n\t// Constructor of the contract.\n\tfunction Crowdsale(address _token, address _btcproxy) {\n\t\t\n\t  //set the different variables\n\t  owner = msg.sender;\n\t  BTCproxy = _btcproxy; // to change\n\t  rlc = RLC(_token); \t// RLC contract address\n\t  multisigETH = 0x8cd6B3D8713df6aA35894c8beA200c27Ebe92550;\n\t  team = 0x1000000000000000000000000000000000000000;\n\t  reserve = 0x2000000000000000000000000000000000000000;\n\t  bounty = 0x3000000000000000000000000000000000000000;\n\t  RLCSentToETH = 0;\n\t  RLCSentToBTC = 0;\n\t  minInvestETH = 100 finney; // 0.1 ether\n\t  minInvestBTC = 100000;     // approx 1 USD or 0.00100000 BTC\n\t  startBlock = now ;            // now (testnet)\n\t  endBlock =  now + 30 days;    // ever (testnet) startdate + 30 days\n\t  RLCPerETH = 5000000000000;    // FIXME  will be update\n\t  RLCPerSATOSHI = 50000;         // 5000 RLC par BTC == 50,000 RLC per satoshi\n\t  minCap=12000000000000000;\n\t  maxCap=60000000000000000;\n\t  rlc_bounty=1700000000000000;\t\t\n\t  //rlc_reserve=17000000000000000;\n\t  rlc_reserve=1700000000000000;\n\t  rlc_team=12000000000000000;\n\t  RLCEmitted = rlc_bounty + rlc_reserve + rlc_team;\n\t}\n\n\t/* \n\t* The fallback function corresponds to a donation in ETH\n\t*/\n\tfunction() payable\t{\n\t  receiveETH(msg.sender);\n\t}\n\n\t/*\n\t*\tReceives a donation in ETH\n\t*/\n\tfunction receiveETH(address beneficiary) stopInEmergency payable {\n\n\t  //don't accept funding under a predefined treshold\n\t  if (msg.value < minInvestETH) throw;  \n\n\t  // check if we are in the correct time slot\n\t  if ((now < startBlock) || (now > endBlock )) throw;  \n\n\t  //compute the number of RLC to send\n\t  uint rlcToSend = bonus((msg.value*RLCPerETH)/(1 ether));\n\t  //uint rlcToSend = bonus((msg.value*RLCPerFINNEY)/(1 finney));\n\n\t  // check if we are not reaching the maxCap by accepting this donation\n\t  if ((rlcToSend + RLCSentToETH + RLCSentToBTC) > maxCap) throw;\n\n\t  //update the backer\n\t  Backer backer = backers[beneficiary];\n\n\t  if (!transferRLC(beneficiary, rlcToSend)) throw;     // Do the transfer right now \n\n\t  backer.rlcSent = safeAdd(backer.rlcSent, rlcToSend);\n\t  backer.weiReceived = safeAdd(backer.weiReceived, msg.value); // Update the total wei collcted during the crowdfunding     \n\t  ETHReceived = safeAdd(ETHReceived, msg.value); // Update the total wei collcted during the crowdfunding\n\t  RLCSentToETH = safeAdd(RLCSentToETH, rlcToSend);\n\n\t  emitRLC(rlcToSend);\n\t  // send the corresponding contribution event\n\t  ReceivedETH(beneficiary,ETHReceived);\n\t}\n\t\n\t/*\n\t* receives a donation in BTC\n\t*/\n\n\t// Refund BTC in JS if function throw\n\n\tfunction receiveBTC(address beneficiary, string btc_address, uint value) stopInEmergency onlyBy(BTCproxy){\n\t  //don't accept funding under a predefined treshold\n\t  if (value < minInvestBTC) throw;  \n\n\t  // if we are in the correct time slot\n\t  if ((now < startBlock) || (now > endBlock )) throw;  \n\n\t  //compute the number of RLC to send\n\t  uint rlcToSend = bonus((value*RLCPerSATOSHI));\n\n\t  // check if we are not reaching the maxCap\n\t  if ((rlcToSend + RLCSentToETH + RLCSentToBTC) > maxCap) throw;\n\n\t  //update the backer\n\t  Backer backer = backers[beneficiary];\n\n\t  // if the min cap is reached, token transfer happens immediately possibly along\n\t  // with the previous donation\n\t  if (!transferRLC(beneficiary, rlcToSend)) throw;     // Do the transfer right now \n\n\t  backer.rlcSent = safeAdd(backer.rlcSent , rlcToSend);\n\t  backer.btc_address = btc_address;\n\t  backer.satoshiReceived = safeAdd(backer.satoshiReceived, value);\n\t  BTCReceived =  safeAdd(BTCReceived, value);// Update the total satoshi collcted during the crowdfunding \n\t  RLCSentToBTC = safeAdd(RLCSentToBTC, rlcToSend);\n\t  emitRLC(rlcToSend);\n\t  \n\t  ReceivedBTC(beneficiary, btc_address, BTCReceived);\n\t}\n\t\n\tfunction isMinCapReached() internal returns (bool) {\n\t\treturn (RLCSentToETH + RLCSentToBTC ) > minCap;\n\t}\n\n\tfunction isMaxCapReached() internal returns (bool) { \n\t\treturn (RLCSentToETH + RLCSentToBTC ) == maxCap;\n\t}\n\n\t// Compute the variable part\n\tfunction emitRLC(uint amount) internal {\n\t\tLogs(msg.sender ,amount, \"emitRLC\");\n\t\trlc_bounty+=amount/10;      // bounty is 10% of the crowdsale\n\t\trlc_team+=amount/20;        // team is 5% of the crowdsale\n\t\trlc_reserve+=amount/10; \t// contingency is 10% of the crowdsale\n\t\tRLCEmitted+=amount + amount/4;\t// adjust the total number of RLC emitted\n\t}\n\n\t/*\n\t  Compute the RLC bonus according to the investment period\n\t*/\n\tfunction bonus(uint amount) internal returns (uint) {\n\t  if (now < (startBlock + 10 days)) return (amount + amount/5);  // bonus 20%\n\t  if (now < startBlock + 20 days) return (amount + amount/10);  // bonus 10%\n\t  return amount;\n\t}\n\t\n\t/*\n\t * Transfer RLC to backers\n\t * Assumes that the owner of the token contract and the crowdsale contract is the same\n\t */\n\tfunction transferRLC(address to, uint amount) internal returns (bool) {\n\t  return rlc.transfer(to, amount);\n\t}\n\n\t/* \n\t * When mincap is not reach backer can call the approveAndCall function of the RLC token contract\n\t * whith this crowdsale contract on parameter with all the RLC they get in order to be refund\n\t */\n\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData, bytes _extraData2) minCapNotReached public {\n        if (msg.sender != address(rlc)) throw; \n        if (_extraData.length != 0) throw;  // no extradata needed\n        if (_extraData2.length != 0) throw;  // no extradata needed\n        if (_value != backers[_from].rlcSent) throw; // compare value from backer balance\n        if (!rlc.transferFrom(_from, address(this), _value)) throw ; // get the token back to the crowdsale contract\n\t\tuint ETHToSend = backers[_from].weiReceived;\n\t\tbackers[_from].weiReceived=0;\n\t\tuint BTCToSend = backers[_from].satoshiReceived;\n\t\tbackers[_from].satoshiReceived = 0;\n\t\tif (ETHToSend > 0) {\n\t\t\tasyncSend(_from,ETHToSend);\n\t\t}\n\t\tif (BTCToSend > 0)\n\t\t\tRefundBTC(backers[_from].btc_address ,BTCToSend); // event message to manually refund BTC\n    }\n/*\n    function receiveApprovalOLD(address _from, uint256 _value, address _token, bytes _extraData, bytes _extraData2) minCapNotReached public {\n        if (msg.sender != address(rlc)) throw; \n        if (bytes(_extraData).length != 0) throw;  // no extradata needed\n        if (bytes(_extraData2).length!= 0) throw;  // no extradata needed\n        if (_value != backers[_from].rlcSent) throw; // compare value from backer balance\n        if (!rlc.transferFrom(_from, address(this), _value)) throw ; // get the token back to the crowdsale contract\n\t\tuint ETHToSend = backers[_from].weiReceived;\n\t\tbackers[_from].weiReceived=0;\n\t\tuint BTCToSend = backers[_from].satoshiReceived;\n\t\tbackers[_from].satoshiReceived = 0;\n\t\tif (ETHToSend > 0) {\n\t\t\tif (_from.send(ETHToSend)) {\n\t\t\t\t\tRefundETH(_from,ETHToSend);\n\t\t\t\t} else {\n\t\t\t\t\tbackers[_from].weiReceived = ETHToSend;\n\t\t\t\t}\n\t\t}\n\t\tif (BTCToSend > 0)\n\t\t\tRefundBTC(backers[msg.sender].btc_address ,BTCToSend); // event message to manually refund BTC\n    }\n*/\n\n\t/*\n\t* Update the rate RLC per ETH, computed externally by using the BTCETH index on kraken every 10min\n\t*/\n\tfunction setRLCPerETH(uint rate) onlyBy(BTCproxy) {\n\t\tRLCPerETH=rate;\n\t}\n\t\n\t/*\t\n\t* Finalize the crowdsale, should be called after the refund period\n\t*/\n\tfunction finalize() onlyBy(owner) {\n\t\t//if ((now < endBlock + 15 days ) || (now > endBlock + 60 days)) throw;\n\t\tif (now < endBlock + 15 days ) throw;\n\t\t//moves the remaining ETH to the multisig address\n\t\tif (!multisigETH.send(this.balance)) throw;\n\t\t//moves RLC to the team, reserve and bounty address\n\t    if (!transferRLC(team,rlc_team)) throw;\n\t    if (!transferRLC(reserve,rlc_reserve)) throw;\t\n\t    if (!transferRLC(bounty,rlc_bounty)) throw;\n\t    rlc.burn(rlc.totalSupply() - RLCEmitted);\n\t\tcrowdsaleClosed = true;\n\t}\n}"
    }
  ]
}