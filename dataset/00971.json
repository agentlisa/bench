{
  "Title": "Users withdraw more assets than should when `mintFee` was called long ago",
  "Content": "# Users withdraw more assets than should when `mintFee` was called long ago\n\n### Severity\nHigh Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXWithdraw.sol#L67-L72\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXWithdraw.sol#L67-L72</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXWithdraw.sol#L101\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXWithdraw.sol#L101</a>\n\n\n## Summary\nThe amount of LP-tokens to withdraw is calculated at the `GMXWithdraw.withdraw` before the `mintFee` function is called. The `mintFee` function increases the `totalSupply` amount. This way  users receive more tokens than should be at the current timestamp. The longer the period since the last `mintFee` was called the more excess tokens the user receives.\n\n## Vulnerability Details\nThe protocol mints vault token shares as management fees to protocol treasury with the [`mintFee`](https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXVault.sol#L334-L337) function. This increases the `totalSupply` of the shares. The amount of minted fees depends on the time since the last `mintFee` call.\n```solidity\n  function mintFee() public {\n    _mint(_store.treasury, GMXReader.pendingFee(_store));\n    _store.lastFeeCollected = block.timestamp;\n  }\n```\nWhile withdrawal amount of LP-token can be [calculated](https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXWithdraw.sol#L67-L72) with outdated `totalSupply`:\n```solidity\n67    _wc.shareRatio = wp.shareAmt\n68      * SAFE_MULTIPLIER\n69      / IERC20(address(self.vault)).totalSupply();\n70    _wc.lpAmt = _wc.shareRatio\n71      * GMXReader.lpAmt(self)\n72      / SAFE_MULTIPLIER;\n\n101    self.vault.mintFee();\n```\nThe `mintFee` is called only after this calculation.\n\n## Impact\nUsers can receive excess amounts of tokens during withdrawal. Other users and the protocol management lose value of their shares.\n\n## Tools used\nManual Review\n\n## Recommendations\nConsider calling the `mintFee` before the `_wc.shareRatio` calculation.",
  "Impact": "HIGH",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "contracts/strategy/gmx/GMXWithdraw.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\nimport { GMXProcessWithdraw } from \"./GMXProcessWithdraw.sol\";\n\n/**\n  * @title GMXWithdraw\n  * @author Steadefi\n  * @notice Re-usable library functions for withdraw operations for Steadefi leveraged vaults\n*/\nlibrary GMXWithdraw {\n  using SafeERC20 for IERC20;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ======================== EVENTS ========================= */\n\n  event WithdrawCreated(address indexed user, uint256 shareAmt);\n  event WithdrawCompleted(\n    address indexed user,\n    address token,\n    uint256 tokenAmt\n  );\n  event WithdrawCancelled(address indexed user);\n  event WithdrawFailed(bytes reason);\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function withdraw(\n    GMXTypes.Store storage self,\n    GMXTypes.WithdrawParams memory wp\n  ) external {\n    // Sweep any tokenA/B in vault to the temporary trove for future compouding and to prevent\n    // it from being considered as part of withdrawers assets\n    if (self.tokenA.balanceOf(address(this)) > 0) {\n      self.tokenA.safeTransfer(self.trove, self.tokenA.balanceOf(address(this)));\n    }\n    if (self.tokenB.balanceOf(address(this)) > 0) {\n      self.tokenB.safeTransfer(self.trove, self.tokenB.balanceOf(address(this)));\n    }\n\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.HealthParams memory _hp;\n\n    _hp.equityBefore = GMXReader.equityValue(self);\n    _hp.lpAmtBefore = GMXReader.lpAmt(self);\n    _hp.debtRatioBefore = GMXReader.debtRatio(self);\n    _hp.deltaBefore = GMXReader.delta(self);\n\n    GMXTypes.WithdrawCache memory _wc;\n\n    _wc.user = payable(msg.sender);\n\n    _wc.shareRatio = wp.shareAmt\n      * SAFE_MULTIPLIER\n      / IERC20(address(self.vault)).totalSupply();\n    _wc.lpAmt = _wc.shareRatio\n      * GMXReader.lpAmt(self)\n      / SAFE_MULTIPLIER;\n    _wc.withdrawValue = _wc.lpAmt\n      * self.gmxOracle.getLpTokenValue(\n        address(self.lpToken),\n        address(self.tokenA),\n        address(self.tokenA),\n        address(self.tokenB),\n        false,\n        false\n      )\n      / SAFE_MULTIPLIER;\n\n    _wc.withdrawParams = wp;\n    _wc.healthParams = _hp;\n\n    (\n      uint256 _repayTokenAAmt,\n      uint256 _repayTokenBAmt\n    ) = GMXManager.calcRepay(self, _wc.shareRatio);\n\n    _wc.repayParams.repayTokenAAmt = _repayTokenAAmt;\n    _wc.repayParams.repayTokenBAmt = _repayTokenBAmt;\n\n    self.withdrawCache = _wc;\n\n    GMXChecks.beforeWithdrawChecks(self);\n\n    self.status = GMXTypes.Status.Withdraw;\n\n    self.vault.mintFee();\n\n    GMXTypes.RemoveLiquidityParams memory _rlp;\n\n    // If user wants to withdraw LP tokens, only remove liquidity of\n    // LP tokens that are proportionately borrowed to repay debt\n    // If not, we just remove all LP tokens computed in _wc.lpAmt\n    if (wp.token == address(self.lpToken)) {\n      // LP amount to be removed for leverage debt repayment\n      // Multiply LP amt to remove by 2% to account for price differential,\n      // fees on LP removal, slippages to ensure payment of debt is covered\n      // Excess tokenA/B will be returned to the user regardless\n      uint256 _lpAmtToRemove = _wc.lpAmt\n        * (self.leverage - SAFE_MULTIPLIER)\n        / self.leverage\n        * 10200 / 10000;\n\n      _wc.tokensToUser = _wc.lpAmt - _lpAmtToRemove;\n      _wc.lpAmt = _lpAmtToRemove;\n    }\n\n\n    // If delta strategy is Long, remove all in tokenB to make it more\n    // efficent to repay tokenB debt as Long strategy only borrows tokenB\n    if (self.delta == GMXTypes.Delta.Long) {\n      address[] memory _tokenASwapPath = new address[](1);\n      _tokenASwapPath[0] = address(self.lpToken);\n      _rlp.tokenASwapPath = _tokenASwapPath;\n\n      (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n        self,\n        _wc.lpAmt,\n        address(self.tokenB),\n        address(self.tokenB),\n        wp.slippage\n      );\n    } else {\n      (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n        self,\n        _wc.lpAmt,\n        address(self.tokenA),\n        address(self.tokenB),\n        wp.slippage\n      );\n    }\n\n    _rlp.lpAmt = _wc.lpAmt;\n    _rlp.executionFee = wp.executionFee;\n\n    _wc.withdrawKey = GMXManager.removeLiquidity(\n      self,\n      _rlp\n    );\n\n    // Add withdrawKey to store\n    self.withdrawCache = _wc;\n\n    emit WithdrawCreated(\n      _wc.user,\n      _wc.withdrawParams.shareAmt\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdraw(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessWithdrawChecks(self);\n\n    // We transfer the core logic of this function to GMXProcessWithdraw.processWithdraw()\n    // to allow try/catch here to catch for any issues such as any token swaps failing or\n    // debt repayment failing, or any checks in afterWithdrawChecks() failing.\n    // If there are any issues, a WithdrawFailed event will be emitted and processWithdrawFailure()\n    // should be triggered to refund assets accordingly and reset the vault status to Open again.\n    try GMXProcessWithdraw.processWithdraw(self) {\n      // If native token is being withdrawn, we convert wrapped to native\n      if (self.withdrawCache.withdrawParams.token == address(self.WNT)) {\n        self.WNT.withdraw(self.withdrawCache.tokensToUser);\n        (bool success, ) = self.withdrawCache.user.call{value: address(this).balance}(\"\");\n        require(success, \"Transfer failed.\");\n      } else {\n        // Transfer requested withdraw asset to user\n        IERC20(self.withdrawCache.withdrawParams.token).safeTransfer(\n          self.withdrawCache.user,\n          self.withdrawCache.tokensToUser\n        );\n      }\n\n      // Transfer any remaining tokenA/B that was unused (due to slippage) to user as well\n      self.tokenA.safeTransfer(self.withdrawCache.user, self.tokenA.balanceOf(address(this)));\n      self.tokenB.safeTransfer(self.withdrawCache.user, self.tokenB.balanceOf(address(this)));\n\n      // Burn user shares\n      self.vault.burn(self.withdrawCache.user, self.withdrawCache.withdrawParams.shareAmt);\n\n      self.status = GMXTypes.Status.Open;\n\n      emit WithdrawCompleted(\n        self.withdrawCache.user,\n        self.withdrawCache.withdrawParams.token,\n        self.withdrawCache.tokensToUser\n      );\n    } catch (bytes memory reason) {\n      self.status = GMXTypes.Status.Withdraw_Failed;\n\n      emit WithdrawFailed(reason);\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdrawCancellation(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessWithdrawCancellationChecks(self);\n\n    self.status = GMXTypes.Status.Open;\n\n    emit WithdrawCancelled(self.withdrawCache.user);\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdrawFailure(\n    GMXTypes.Store storage self,\n    uint256 slippage,\n    uint256 executionFee\n  ) external {\n    GMXChecks.beforeProcessAfterWithdrawFailureChecks(self);\n\n    // Re-borrow assets based on the repaid amount\n    GMXManager.borrow(\n      self,\n      self.withdrawCache.repayParams.repayTokenAAmt,\n      self.withdrawCache.repayParams.repayTokenBAmt\n    );\n\n    // Re-add liquidity using all available tokenA/B in vault\n    GMXTypes.AddLiquidityParams memory _alp;\n\n    _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n    _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n\n    // Calculate slippage\n    uint256 _depositValue = GMXReader.convertToUsdValue(\n      self,\n      address(self.tokenA),\n      self.tokenA.balanceOf(address(this))\n    )\n    + GMXReader.convertToUsdValue(\n      self,\n      address(self.tokenB),\n      self.tokenB.balanceOf(address(this))\n    );\n\n    _alp.minMarketTokenAmt = GMXManager.calcMinMarketSlippageAmt(\n      self,\n      _depositValue,\n      slippage\n    );\n    _alp.executionFee = executionFee;\n\n    // Re-add liquidity with all tokenA/tokenB in vault\n    self.withdrawCache.depositKey = GMXManager.addLiquidity(\n      self,\n      _alp\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdrawFailureLiquidityAdded(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessAfterWithdrawFailureLiquidityAdded(self);\n\n    self.status = GMXTypes.Status.Open;\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXWithdraw.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\nimport { GMXProcessWithdraw } from \"./GMXProcessWithdraw.sol\";\n\n/**\n  * @title GMXWithdraw\n  * @author Steadefi\n  * @notice Re-usable library functions for withdraw operations for Steadefi leveraged vaults\n*/\nlibrary GMXWithdraw {\n  using SafeERC20 for IERC20;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ======================== EVENTS ========================= */\n\n  event WithdrawCreated(address indexed user, uint256 shareAmt);\n  event WithdrawCompleted(\n    address indexed user,\n    address token,\n    uint256 tokenAmt\n  );\n  event WithdrawCancelled(address indexed user);\n  event WithdrawFailed(bytes reason);\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function withdraw(\n    GMXTypes.Store storage self,\n    GMXTypes.WithdrawParams memory wp\n  ) external {\n    // Sweep any tokenA/B in vault to the temporary trove for future compouding and to prevent\n    // it from being considered as part of withdrawers assets\n    if (self.tokenA.balanceOf(address(this)) > 0) {\n      self.tokenA.safeTransfer(self.trove, self.tokenA.balanceOf(address(this)));\n    }\n    if (self.tokenB.balanceOf(address(this)) > 0) {\n      self.tokenB.safeTransfer(self.trove, self.tokenB.balanceOf(address(this)));\n    }\n\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.HealthParams memory _hp;\n\n    _hp.equityBefore = GMXReader.equityValue(self);\n    _hp.lpAmtBefore = GMXReader.lpAmt(self);\n    _hp.debtRatioBefore = GMXReader.debtRatio(self);\n    _hp.deltaBefore = GMXReader.delta(self);\n\n    GMXTypes.WithdrawCache memory _wc;\n\n    _wc.user = payable(msg.sender);\n\n    _wc.shareRatio = wp.shareAmt\n      * SAFE_MULTIPLIER\n      / IERC20(address(self.vault)).totalSupply();\n    _wc.lpAmt = _wc.shareRatio\n      * GMXReader.lpAmt(self)\n      / SAFE_MULTIPLIER;\n    _wc.withdrawValue = _wc.lpAmt\n      * self.gmxOracle.getLpTokenValue(\n        address(self.lpToken),\n        address(self.tokenA),\n        address(self.tokenA),\n        address(self.tokenB),\n        false,\n        false\n      )\n      / SAFE_MULTIPLIER;\n\n    _wc.withdrawParams = wp;\n    _wc.healthParams = _hp;\n\n    (\n      uint256 _repayTokenAAmt,\n      uint256 _repayTokenBAmt\n    ) = GMXManager.calcRepay(self, _wc.shareRatio);\n\n    _wc.repayParams.repayTokenAAmt = _repayTokenAAmt;\n    _wc.repayParams.repayTokenBAmt = _repayTokenBAmt;\n\n    self.withdrawCache = _wc;\n\n    GMXChecks.beforeWithdrawChecks(self);\n\n    self.status = GMXTypes.Status.Withdraw;\n\n    self.vault.mintFee();\n\n    GMXTypes.RemoveLiquidityParams memory _rlp;\n\n    // If user wants to withdraw LP tokens, only remove liquidity of\n    // LP tokens that are proportionately borrowed to repay debt\n    // If not, we just remove all LP tokens computed in _wc.lpAmt\n    if (wp.token == address(self.lpToken)) {\n      // LP amount to be removed for leverage debt repayment\n      // Multiply LP amt to remove by 2% to account for price differential,\n      // fees on LP removal, slippages to ensure payment of debt is covered\n      // Excess tokenA/B will be returned to the user regardless\n      uint256 _lpAmtToRemove = _wc.lpAmt\n        * (self.leverage - SAFE_MULTIPLIER)\n        / self.leverage\n        * 10200 / 10000;\n\n      _wc.tokensToUser = _wc.lpAmt - _lpAmtToRemove;\n      _wc.lpAmt = _lpAmtToRemove;\n    }\n\n\n    // If delta strategy is Long, remove all in tokenB to make it more\n    // efficent to repay tokenB debt as Long strategy only borrows tokenB\n    if (self.delta == GMXTypes.Delta.Long) {\n      address[] memory _tokenASwapPath = new address[](1);\n      _tokenASwapPath[0] = address(self.lpToken);\n      _rlp.tokenASwapPath = _tokenASwapPath;\n\n      (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n        self,\n        _wc.lpAmt,\n        address(self.tokenB),\n        address(self.tokenB),\n        wp.slippage\n      );\n    } else {\n      (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n        self,\n        _wc.lpAmt,\n        address(self.tokenA),\n        address(self.tokenB),\n        wp.slippage\n      );\n    }\n\n    _rlp.lpAmt = _wc.lpAmt;\n    _rlp.executionFee = wp.executionFee;\n\n    _wc.withdrawKey = GMXManager.removeLiquidity(\n      self,\n      _rlp\n    );\n\n    // Add withdrawKey to store\n    self.withdrawCache = _wc;\n\n    emit WithdrawCreated(\n      _wc.user,\n      _wc.withdrawParams.shareAmt\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdraw(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessWithdrawChecks(self);\n\n    // We transfer the core logic of this function to GMXProcessWithdraw.processWithdraw()\n    // to allow try/catch here to catch for any issues such as any token swaps failing or\n    // debt repayment failing, or any checks in afterWithdrawChecks() failing.\n    // If there are any issues, a WithdrawFailed event will be emitted and processWithdrawFailure()\n    // should be triggered to refund assets accordingly and reset the vault status to Open again.\n    try GMXProcessWithdraw.processWithdraw(self) {\n      // If native token is being withdrawn, we convert wrapped to native\n      if (self.withdrawCache.withdrawParams.token == address(self.WNT)) {\n        self.WNT.withdraw(self.withdrawCache.tokensToUser);\n        (bool success, ) = self.withdrawCache.user.call{value: address(this).balance}(\"\");\n        require(success, \"Transfer failed.\");\n      } else {\n        // Transfer requested withdraw asset to user\n        IERC20(self.withdrawCache.withdrawParams.token).safeTransfer(\n          self.withdrawCache.user,\n          self.withdrawCache.tokensToUser\n        );\n      }\n\n      // Transfer any remaining tokenA/B that was unused (due to slippage) to user as well\n      self.tokenA.safeTransfer(self.withdrawCache.user, self.tokenA.balanceOf(address(this)));\n      self.tokenB.safeTransfer(self.withdrawCache.user, self.tokenB.balanceOf(address(this)));\n\n      // Burn user shares\n      self.vault.burn(self.withdrawCache.user, self.withdrawCache.withdrawParams.shareAmt);\n\n      self.status = GMXTypes.Status.Open;\n\n      emit WithdrawCompleted(\n        self.withdrawCache.user,\n        self.withdrawCache.withdrawParams.token,\n        self.withdrawCache.tokensToUser\n      );\n    } catch (bytes memory reason) {\n      self.status = GMXTypes.Status.Withdraw_Failed;\n\n      emit WithdrawFailed(reason);\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdrawCancellation(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessWithdrawCancellationChecks(self);\n\n    self.status = GMXTypes.Status.Open;\n\n    emit WithdrawCancelled(self.withdrawCache.user);\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdrawFailure(\n    GMXTypes.Store storage self,\n    uint256 slippage,\n    uint256 executionFee\n  ) external {\n    GMXChecks.beforeProcessAfterWithdrawFailureChecks(self);\n\n    // Re-borrow assets based on the repaid amount\n    GMXManager.borrow(\n      self,\n      self.withdrawCache.repayParams.repayTokenAAmt,\n      self.withdrawCache.repayParams.repayTokenBAmt\n    );\n\n    // Re-add liquidity using all available tokenA/B in vault\n    GMXTypes.AddLiquidityParams memory _alp;\n\n    _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n    _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n\n    // Calculate slippage\n    uint256 _depositValue = GMXReader.convertToUsdValue(\n      self,\n      address(self.tokenA),\n      self.tokenA.balanceOf(address(this))\n    )\n    + GMXReader.convertToUsdValue(\n      self,\n      address(self.tokenB),\n      self.tokenB.balanceOf(address(this))\n    );\n\n    _alp.minMarketTokenAmt = GMXManager.calcMinMarketSlippageAmt(\n      self,\n      _depositValue,\n      slippage\n    );\n    _alp.executionFee = executionFee;\n\n    // Re-add liquidity with all tokenA/tokenB in vault\n    self.withdrawCache.depositKey = GMXManager.addLiquidity(\n      self,\n      _alp\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdrawFailureLiquidityAdded(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessAfterWithdrawFailureLiquidityAdded(self);\n\n    self.status = GMXTypes.Status.Open;\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Ownable2Step } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport { IWNT } from  \"../../interfaces/tokens/IWNT.sol\";\nimport { IGMXVault } from  \"../../interfaces/strategy/gmx/IGMXVault.sol\";\nimport { IGMXVaultEvents } from  \"../../interfaces/strategy/gmx/IGMXVaultEvents.sol\";\nimport { ILendingVault } from  \"../../interfaces/lending/ILendingVault.sol\";\nimport { IChainlinkOracle } from  \"../../interfaces/oracles/IChainlinkOracle.sol\";\nimport { IGMXOracle } from  \"../../interfaces/oracles/IGMXOracle.sol\";\nimport { IExchangeRouter } from \"../../interfaces/protocols/gmx/IExchangeRouter.sol\";\nimport { ISwap } from \"../../interfaces/swap/ISwap.sol\";\nimport { Errors } from  \"../../utils/Errors.sol\";\nimport { GMXTypes } from  \"./GMXTypes.sol\";\nimport { GMXDeposit } from  \"./GMXDeposit.sol\";\nimport { GMXWithdraw } from  \"./GMXWithdraw.sol\";\nimport { GMXRebalance } from  \"./GMXRebalance.sol\";\nimport { GMXCompound } from  \"./GMXCompound.sol\";\nimport { GMXEmergency } from  \"./GMXEmergency.sol\";\nimport { GMXReader } from  \"./GMXReader.sol\";\n\n/**\n  * @title GMXVault\n  * @author Steadefi\n  * @notice Main point of interaction with a Steadefi leveraged strategy vault\n*/\ncontract GMXVault is ERC20, Ownable2Step, ReentrancyGuard, IGMXVault, IGMXVaultEvents {\n\n  /* ==================== STATE VARIABLES ==================== */\n\n  // GMXTypes.Store\n  GMXTypes.Store internal _store;\n\n  /* ======================= MAPPINGS ======================== */\n\n  // Approved keepers\n  mapping(address => bool) public keepers;\n  // Approved tokens for deposit and withdraw\n  mapping(address => bool) public tokens;\n\n  /* ======================= MODIFIERS ======================= */\n\n  // Allow only vault modifier\n  modifier onlyVault() {\n    _onlyVault();\n    _;\n  }\n\n  // Allow only keeper modifier\n  modifier onlyKeeper() {\n    _onlyKeeper();\n    _;\n  }\n\n  /* ====================== CONSTRUCTOR ====================== */\n\n  /**\n    * @notice Initialize and configure vault's store, token approvals and whitelists\n    * @param name Name of vault\n    * @param symbol Symbol for vault token\n    * @param store_ GMXTypes.Store\n  */\n  constructor (\n    string memory name,\n    string memory symbol,\n    GMXTypes.Store memory store_\n  ) ERC20(name, symbol) Ownable(msg.sender) {\n    _store.leverage = uint256(store_.leverage);\n    _store.delta = store_.delta;\n    _store.feePerSecond = uint256(store_.feePerSecond);\n    _store.treasury = address(store_.treasury);\n\n    _store.debtRatioStepThreshold = uint256(store_.debtRatioStepThreshold);\n    _store.debtRatioUpperLimit = uint256(store_.debtRatioUpperLimit);\n    _store.debtRatioLowerLimit = uint256(store_.debtRatioLowerLimit);\n    _store.deltaUpperLimit = int256(store_.deltaUpperLimit);\n    _store.deltaLowerLimit = int256(store_.deltaLowerLimit);\n    _store.minSlippage = store_.minSlippage;\n    _store.minExecutionFee = store_.minExecutionFee;\n\n    _store.tokenA = IERC20(store_.tokenA);\n    _store.tokenB = IERC20(store_.tokenB);\n    _store.lpToken = IERC20(store_.lpToken);\n    _store.WNT = IWNT(store_.WNT);\n\n    _store.tokenALendingVault = ILendingVault(store_.tokenALendingVault);\n    _store.tokenBLendingVault = ILendingVault(store_.tokenBLendingVault);\n\n    _store.vault = IGMXVault(address(this));\n    _store.trove = store_.trove;\n    _store.callback = store_.callback;\n\n    _store.chainlinkOracle = IChainlinkOracle(store_.chainlinkOracle);\n    _store.gmxOracle = IGMXOracle(store_.gmxOracle);\n\n    _store.exchangeRouter = IExchangeRouter(store_.exchangeRouter);\n    _store.router = store_.router;\n    _store.depositVault = store_.depositVault;\n    _store.withdrawalVault = store_.withdrawalVault;\n    _store.roleStore = store_.roleStore;\n\n    _store.swapRouter = ISwap(store_.swapRouter);\n\n    _store.status = GMXTypes.Status.Open;\n\n    _store.lastFeeCollected = block.timestamp;\n\n    // Set token whitelist for this vault\n    tokens[address(_store.tokenA)] = true;\n    tokens[address(_store.tokenB)] = true;\n    tokens[address(_store.lpToken)] = true;\n\n    // Set token approvals for this vault\n    _store.tokenA.approve(address(_store.router), type(uint256).max);\n    _store.tokenB.approve(address(_store.router), type(uint256).max);\n    _store.lpToken.approve(address(_store.router), type(uint256).max);\n\n    _store.tokenA.approve(address(_store.depositVault), type(uint256).max);\n    _store.tokenB.approve(address(_store.depositVault), type(uint256).max);\n\n    _store.lpToken.approve(address(_store.withdrawalVault), type(uint256).max);\n\n    _store.tokenA.approve(address(_store.tokenALendingVault), type(uint256).max);\n    _store.tokenB.approve(address(_store.tokenBLendingVault), type(uint256).max);\n\n    // Set callback contract as keeper\n    keepers[_store.callback] = true;\n  }\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice View vault store data\n    * @return GMXTypes.Store\n  */\n  function store() public view returns (GMXTypes.Store memory) {\n    return _store;\n  }\n\n  /**\n    * @notice Check if token is whitelisted for deposit/withdraw for this vault\n    * @param token Address of token to check\n    * @return Boolean of whether token is whitelisted\n  */\n  function isTokenWhitelisted(address token) public view returns (bool) {\n    return tokens[token];\n  }\n\n  /**\n    * @notice Returns the value of each strategy vault share token; equityValue / totalSupply()\n    * @return svTokenValue  USD value of each share token in 1e18\n  */\n  function svTokenValue() public view returns (uint256) {\n    return GMXReader.svTokenValue(_store);\n  }\n\n  /**\n    * @notice Amount of share pending for minting as a form of management fee\n    * @return pendingFee in 1e18\n  */\n  function pendingFee() public view returns (uint256) {\n    return GMXReader.pendingFee(_store);\n  }\n\n  /**\n    * @notice Conversion of equity value to svToken shares\n    * @param value Equity value change after deposit in 1e18\n    * @param currentEquity Current equity value of vault in 1e18\n    * @return sharesAmt in 1e18\n  */\n  function valueToShares(uint256 value, uint256 currentEquity) public view returns (uint256) {\n    return GMXReader.valueToShares(_store, value, currentEquity);\n  }\n\n  /**\n    * @notice Convert token amount to USD value using price from oracle\n    * @param token Token address\n    * @param amt Amount in token decimals\n    @ @return tokenValue USD value in 1e18\n  */\n  function convertToUsdValue(address token, uint256 amt) public view returns (uint256) {\n    return GMXReader.convertToUsdValue(_store, token, amt);\n  }\n\n  /**\n    * @notice Return token weights (%) in LP\n    @ @return tokenAWeight in 1e18; e.g. 50% = 5e17\n    @ @return tokenBWeight in 1e18; e.g. 50% = 5e17\n  */\n  function tokenWeights() public view returns (uint256, uint256) {\n    return GMXReader.tokenWeights(_store);\n  }\n\n  /**\n    * @notice Returns the total USD value of tokenA & tokenB assets held by the vault\n    * @notice Asset = Debt + Equity\n    * @return assetValue USD value of total assets in 1e18\n  */\n  function assetValue() public view returns (uint256) {\n    return GMXReader.assetValue(_store);\n  }\n\n  /**\n    * @notice Returns the USD value of tokenA & tokenB debt held by the vault\n    * @notice Asset = Debt + Equity\n    * @return tokenADebtValue USD value of tokenA debt in 1e18\n    * @return tokenBDebtValue USD value of tokenB debt in 1e18\n  */\n  function debtValue() public view returns (uint256, uint256) {\n    return GMXReader.debtValue(_store);\n  }\n\n  /**\n    * @notice Returns the USD value of tokenA & tokenB equity held by the vault;\n    * @notice Asset = Debt + Equity\n    * @return equityValue USD value of total equity in 1e18\n  */\n  function equityValue() public view returns (uint256) {\n    return GMXReader.equityValue(_store);\n  }\n\n  /**\n    * @notice Returns the amt of tokenA & tokenB assets held by vault\n    * @return tokenAAssetAmt in tokenA decimals\n    * @return tokenBAssetAmt in tokenB decimals\n  */\n  function assetAmt() public view returns (uint256, uint256) {\n    return GMXReader.assetAmt(_store);\n  }\n\n  /**\n    * @notice Returns the amt of tokenA & tokenB debt held by vault\n    * @return tokenADebtAmt in tokenA decimals\n    * @return tokenBDebtAmt in tokenB decimals\n  */\n  function debtAmt() public view returns (uint256, uint256) {\n    return GMXReader.debtAmt(_store);\n  }\n\n  /**\n    * @notice Returns the amt of LP tokens held by vault\n    * @return lpAmt in 1e18\n  */\n  function lpAmt() public view returns (uint256) {\n    return GMXReader.lpAmt(_store);\n  }\n\n  /**\n    * @notice Returns the current leverage (asset / equity)\n    * @return leverage Current leverage in 1e18\n  */\n  function leverage() public view returns (uint256) {\n    return GMXReader.leverage(_store);\n  }\n\n  /**\n    * @notice Returns the current delta (tokenA equityValue / vault equityValue)\n    * @notice Delta refers to the position exposure of this vault's strategy to the\n    * underlying volatile asset. Delta can be a negative value\n    * @return delta in 1e18 (0 = Neutral, > 0 = Long, < 0 = Short)\n  */\n  function delta() public view returns (int256) {\n    return GMXReader.delta(_store);\n  }\n\n  /**\n    * @notice Returns the debt ratio (tokenA and tokenB debtValue) / (total assetValue)\n    * @notice When assetValue is 0, we assume the debt ratio to also be 0\n    * @return debtRatio % in 1e18\n  */\n  function debtRatio() public view returns (uint256) {\n    return GMXReader.debtRatio(_store);\n  }\n\n  /**\n    * @notice Additional capacity vault that can be deposited to vault based on available lending liquidity\n    @ @return additionalCapacity USD value in 1e18\n  */\n  function additionalCapacity() public view returns (uint256) {\n    return GMXReader.additionalCapacity(_store);\n  }\n\n  /**\n    * @notice Total capacity of vault; additionalCapacity + equityValue\n    @ @return capacity USD value in 1e18\n  */\n  function capacity() public view returns (uint256) {\n    return GMXReader.capacity(_store);\n  }\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice Deposit a whitelisted asset into vault and mint strategy vault share tokens to user\n    * @param dp GMXTypes.DepositParams\n  */\n  function deposit(GMXTypes.DepositParams memory dp) external payable nonReentrant {\n    GMXDeposit.deposit(_store, dp, false);\n  }\n\n  /**\n    * @notice Deposit native asset (e.g. ETH) into vault and mint strategy vault share tokens to user\n    * @notice This function is only function if vault accepts native token\n    * @param dp GMXTypes.DepositParams\n  */\n  function depositNative(GMXTypes.DepositParams memory dp) external payable nonReentrant {\n    GMXDeposit.deposit(_store, dp, true);\n  }\n\n  /**\n    * @notice Withdraws a whitelisted asset from vault and burns strategy vault share tokens from user\n    * @param wp GMXTypes.WithdrawParams\n  */\n  function withdraw(GMXTypes.WithdrawParams memory wp) external payable nonReentrant {\n    GMXWithdraw.withdraw(_store, wp);\n  }\n\n  /**\n    * @notice Emergency withdraw function, enabled only when vault status is Closed, burns\n    svToken from user while withdrawing assets from vault to user\n    * @param shareAmt Amount of vault token shares to withdraw in 1e18\n  */\n  function emergencyWithdraw(uint256 shareAmt) external nonReentrant {\n    GMXEmergency.emergencyWithdraw(_store, shareAmt);\n  }\n\n  /**\n    * @notice Mint vault token shares as management fees to protocol treasury\n  */\n  function mintFee() public {\n    _mint(_store.treasury, GMXReader.pendingFee(_store));\n    _store.lastFeeCollected = block.timestamp;\n  }\n\n  /* ================== INTERNAL FUNCTIONS =================== */\n\n  /**\n    * @notice Allow only vault\n  */\n  function _onlyVault() internal view {\n    if (msg.sender != address(_store.vault)) revert Errors.OnlyVaultAllowed();\n  }\n\n  /**\n    * @notice Allow only keeper\n  */\n  function _onlyKeeper() internal view {\n    if (!keepers[msg.sender]) revert Errors.OnlyKeeperAllowed();\n  }\n\n  /* ================= RESTRICTED FUNCTIONS ================== */\n\n  /**\n    * @notice Post deposit operations if adding liquidity is successful to GMX\n    * @dev Should be called only after deposit() / depositNative() is called\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processDeposit() external onlyKeeper {\n    GMXDeposit.processDeposit(_store);\n  }\n\n  /**\n    * @notice Post deposit operations if adding liquidity has been cancelled by GMX\n    * @dev To be called only after deposit()/depositNative() is called\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processDepositCancellation() external onlyKeeper {\n    GMXDeposit.processDepositCancellation(_store);\n  }\n\n  /**\n    * @notice Post deposit operations if after deposit checks failed by GMXChecks.afterDepositChecks()\n    * @dev Should be called by approved Keeper after error event is picked up\n    * @param slippage Slippage for liquidity removal\n    * @param executionFee Execution fee passed in to remove liquidity\n  */\n  function processDepositFailure(\n    uint256 slippage,\n    uint256 executionFee\n  ) external payable onlyKeeper {\n    GMXDeposit.processDepositFailure(_store, slippage, executionFee);\n  }\n\n  /**\n    * @notice Post deposit failure operations\n    * @dev To be called after processDepositFailure()\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processDepositFailureLiquidityWithdrawal() external onlyKeeper {\n    GMXDeposit.processDepositFailureLiquidityWithdrawal(_store);\n  }\n\n  /**\n    * @notice Post withdraw operations if removing liquidity is successful from GMX\n    * @dev Should be called only after withdraw() is called\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processWithdraw() external onlyKeeper {\n    GMXWithdraw.processWithdraw(_store);\n  }\n\n  /**\n    * @notice Post withdraw operations if removing liquidity has been cancelled by GMX\n    * @dev To be called only after withdraw() is called\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processWithdrawCancellation() external onlyKeeper {\n    GMXWithdraw.processWithdrawCancellation(_store);\n  }\n\n  /**\n    * @notice Post withdraw operations if after withdraw checks failed by GMXChecks.afterWithdrawChecks()\n    * @dev Should be called by approved Keeper after error event is picked up\n    * @param slippage Slippage for liquidity removal\n    * @param executionFee Execution fee passed in to remove liquidity\n  */\n  function processWithdr"
    }
  ]
}