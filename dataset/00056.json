{
  "Title": "Missing validation for ```totalUsdNeeded``` in ```LibUnripe::getPenalizedUnderlying``` can lead to the ```urBean``` chopping block ",
  "Content": "# Missing validation for ```totalUsdNeeded``` in ```LibUnripe::getPenalizedUnderlying``` can lead to the ```urBean``` chopping block \n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-05-Beanstalk-3/blob/662d26f12ee219ee92dc485c06e01a4cb5ee8dfb/protocol/contracts/libraries/LibUnripe.sol#L167\">https://github.com/Cyfrin/2024-05-Beanstalk-3/blob/662d26f12ee219ee92dc485c06e01a4cb5ee8dfb/protocol/contracts/libraries/LibUnripe.sol#L167</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-05-Beanstalk-3/blob/662d26f12ee219ee92dc485c06e01a4cb5ee8dfb/protocol/contracts/beanstalk/barn/UnripeFacet.sol#L89-L93\">https://github.com/Cyfrin/2024-05-Beanstalk-3/blob/662d26f12ee219ee92dc485c06e01a4cb5ee8dfb/protocol/contracts/beanstalk/barn/UnripeFacet.sol#L89-L93</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-05-Beanstalk-3/blob/662d26f12ee219ee92dc485c06e01a4cb5ee8dfb/protocol/contracts/libraries/LibChop.sol#L33\">https://github.com/Cyfrin/2024-05-Beanstalk-3/blob/662d26f12ee219ee92dc485c06e01a4cb5ee8dfb/protocol/contracts/libraries/LibChop.sol#L33</a>\n\n\n## Summary\nThe ```LibUnripe::getPenalizedUnderlying()``` calculates the penalized amount of Ripe Tokens corresponding to the amount of Unripe Tokens that are chopped, according to the current chop rate into the protocol. When the Beanstalk is fully recapitalized, the ```totalUsdNeeded``` variable becomes ```0```. In the possible scenario where all ```urLP``` is chopped before ```urBeans```, the division by zero error causes the transaction to revert preventing users from chopping ```urBean``` into Ripe Bean.\n\n## Vulnerability Details\n```solidity\n    function getPenalizedUnderlying(\n        address unripeToken,\n        uint256 amount,\n        uint256 supply\n    ) internal view returns (uint256 redeem) {\n        require(isUnripe(unripeToken), \"not vesting\");\n        AppStorage storage s = LibAppStorage.diamondStorage();\n     \n\t    uint256 totalUsdNeeded = unripeToken == C.UNRIPE_LP ? LibFertilizer.getTotalRecapDollarsNeeded(supply) \n            : LibFertilizer.getTotalRecapDollarsNeeded();\n       \n        uint256 underlyingAmount = s.u[unripeToken].balanceOfUnderlying;\n@>        redeem = underlyingAmount.mul(s.recapitalized).div(totalUsdNeeded).mul(amount).div(supply);\n       \n        if(redeem > underlyingAmount) redeem = underlyingAmount;\n    }\n```\n\n## Impact\nWhen the Beanstalk is fully recapitalized the ```urToken``` holders should be able to redeem the ripe underlying assets at a 1:1 rate. This can't happen in the scenario where all ```urLP``` is chopped before ```urBeans```. \n\nConsidering the scenario where the recapitalization is completed and all ```urLP``` is chopped before ```urBeans```:  the ```totalUsdNeeded``` variable is 0  (the ```LibFertilizer.getTotalRecapDollarsNeeded()``` return 0 because ```C.unripeLP().totalSupply()``` is 0). \nThe ```LibUnripe::getPenalizedUnderlying()```will perform a divion by zero error causing the transaction to revert preventing users from chopping ```urBean``` into Ripe Bean. The  ```urBean``` chop into Ripe Bean can't happen and the funds are stuck.\n\nImpact: high because funds are directly at risk.\n\nLikelihood: low because all ```urLP``` should be chopped before ```urBeans```. \n\n## Tools Used\nManual review\n\n## Recommendations\nTo handle this scenario, appropriate checks should be added to ensure that in the case of full recapitalization the users can redeem at the new chop rate also in the case where all ```urLP``` is chopped before ```urBeans```.",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clvo5kwin00078k6jhhjobn22",
  "Code": [
    {
      "filename": "protocol/contracts/libraries/LibUnripe.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IBean} from \"../interfaces/IBean.sol\";\nimport {AppStorage, LibAppStorage} from \"./LibAppStorage.sol\";\nimport {C} from \"../C.sol\";\nimport {LibWell} from \"./Well/LibWell.sol\";\nimport {Call, IWell} from \"contracts/interfaces/basin/IWell.sol\";\nimport {IWellFunction} from \"contracts/interfaces/basin/IWellFunction.sol\";\nimport {LibLockedUnderlying} from \"./LibLockedUnderlying.sol\";\nimport {LibFertilizer} from \"./LibFertilizer.sol\";\n\n/**\n * @title LibUnripe\n * @author Publius\n * @notice Library for handling functionality related to Unripe Tokens and their Ripe Tokens.\n */\nlibrary LibUnripe {\n    using SafeMath for uint256;\n\n    event ChangeUnderlying(address indexed token, int256 underlying);\n    event SwitchUnderlyingToken(address indexed token, address indexed underlyingToken);\n\n    uint256 constant DECIMALS = 1e6;\n\n    /**\n     * @notice Returns the percentage that Unripe Beans have been recapitalized.\n     */\n    function percentBeansRecapped() internal view returns (uint256 percent) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return\n            s.u[C.UNRIPE_BEAN].balanceOfUnderlying.mul(DECIMALS).div(C.unripeBean().totalSupply());\n    }\n\n    /**\n     * @notice Returns the percentage that Unripe LP have been recapitalized.\n     */\n    function percentLPRecapped() internal view returns (uint256 percent) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return C.unripeLPPerDollar().mul(s.recapitalized).div(C.unripeLP().totalSupply());\n    }\n\n    /**\n     * @notice Increments the underlying balance of an Unripe Token.\n     * @param token The address of the unripe token.\n     * @param amount The amount of the of the unripe token to be added to the storage reserves\n     */\n    function incrementUnderlying(address token, uint256 amount) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.u[token].balanceOfUnderlying = s.u[token].balanceOfUnderlying.add(amount);\n        emit ChangeUnderlying(token, int256(amount));\n    }\n\n    /**\n     * @notice Decrements the underlying balance of an Unripe Token.\n     * @param token The address of the Unripe Token.\n     * @param amount The amount of the of the Unripe Token to be removed from storage reserves\n     */\n    function decrementUnderlying(address token, uint256 amount) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.u[token].balanceOfUnderlying = s.u[token].balanceOfUnderlying.sub(amount);\n        emit ChangeUnderlying(token, -int256(amount));\n    }\n\n    /**\n     * @notice Calculates the amount of Ripe Tokens that underly a given amount of Unripe Tokens.\n     * @param unripeToken The address of the Unripe Token\n     * @param unripe The amount of Unripe Tokens.\n     * @return underlying The amount of Ripe Tokens that underly the Unripe Tokens.\n     */\n    function unripeToUnderlying(\n        address unripeToken,\n        uint256 unripe,\n        uint256 supply\n    ) internal view returns (uint256 underlying) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        underlying = s.u[unripeToken].balanceOfUnderlying.mul(unripe).div(supply);\n    }\n\n    /**\n     * @notice Calculates the amount of Unripe Tokens that are underlaid by a given amount of Ripe Tokens.\n     * @param unripeToken The address of the Unripe Tokens.\n     * @param underlying The amount of Ripe Tokens.\n     * @return unripe The amount of the of the Unripe Tokens that are underlaid by the Ripe Tokens.\n     */\n    function underlyingToUnripe(\n        address unripeToken,\n        uint256 underlying\n    ) internal view returns (uint256 unripe) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        unripe = IBean(unripeToken).totalSupply().mul(underlying).div(\n            s.u[unripeToken].balanceOfUnderlying\n        );\n    }\n\n    /**\n     * @notice Adds Ripe Tokens to an Unripe Token. Also, increments the recapitalized\n     * amount proportionally if the Unripe Token is Unripe LP.\n     * @param token The address of the Unripe Token to add Ripe Tokens to.\n     * @param underlying The amount of the of the underlying token to be taken as input.\n     */\n    function addUnderlying(address token, uint256 underlying) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        if (token == C.UNRIPE_LP) {\n            uint256 recapped = underlying.mul(s.recapitalized).div(\n                s.u[C.UNRIPE_LP].balanceOfUnderlying\n            );\n            s.recapitalized = s.recapitalized.add(recapped);\n        }\n        incrementUnderlying(token, underlying);\n    }\n\n    /**\n     * @notice Removes Ripe Tokens from an Unripe Token. Also, decrements the recapitalized\n     * amount proportionally if the Unripe Token is Unripe LP.\n     * @param token The address of the unripe token to be removed.\n     * @param underlying The amount of the of the underlying token to be removed.\n     */\n    function removeUnderlying(address token, uint256 underlying) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        if (token == C.UNRIPE_LP) {\n            uint256 recapped = underlying.mul(s.recapitalized).div(\n                s.u[C.UNRIPE_LP].balanceOfUnderlying\n            );\n            s.recapitalized = s.recapitalized.sub(recapped);\n        }\n        decrementUnderlying(token, underlying);\n    }\n\n    /**\n     * @dev Switches the underlying token of an unripe token.\n     * Should only be called if `s.u[unripeToken].balanceOfUnderlying == 0`.\n     */\n    function switchUnderlyingToken(address unripeToken, address newUnderlyingToken) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.u[unripeToken].underlyingToken = newUnderlyingToken;\n        emit SwitchUnderlyingToken(unripeToken, newUnderlyingToken);\n    }\n\n    /**\n     * @notice Calculates the the penalized amount of Ripe Tokens corresponding to \n     * the amount of Unripe Tokens that are Chopped according to the current Chop Rate.\n     * The new chop rate is %Recapitalized^2.\n     */\n    function getPenalizedUnderlying(\n        address unripeToken,\n        uint256 amount,\n        uint256 supply\n    ) internal view returns (uint256 redeem) {\n        require(isUnripe(unripeToken), \"not vesting\");\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        // getTotalRecapDollarsNeeded() queries for the total urLP supply which is burned upon a chop\n        // If the token being chopped is unripeLP, getting the current supply here is inaccurate due to the burn\n        // Instead, we use the supply passed in as an argument to getTotalRecapDollarsNeeded since the supply variable\n        // here is the total urToken supply queried before burnning the unripe token\n\t    uint256 totalUsdNeeded = unripeToken == C.UNRIPE_LP ? LibFertilizer.getTotalRecapDollarsNeeded(supply) \n            : LibFertilizer.getTotalRecapDollarsNeeded();\n        // chop rate = total redeemable * (%DollarRecapitalized)^2 * share of unripe tokens\n        // redeem = totalRipeUnderlying * (usdValueRaised/totalUsdNeeded)^2 * UnripeAmountIn/UnripeSupply;\n        // But totalRipeUnderlying = CurrentUnderlying * totalUsdNeeded/usdValueRaised to get the total underlying\n        // redeem = currentRipeUnderlying * (usdValueRaised/totalUsdNeeded) * UnripeAmountIn/UnripeSupply\n        uint256 underlyingAmount = s.u[unripeToken].balanceOfUnderlying;\n        redeem = underlyingAmount.mul(s.recapitalized).div(totalUsdNeeded).mul(amount).div(supply);\n        // cap `redeem to `balanceOfUnderlying in the case that `s.recapitalized` exceeds `totalUsdNeeded`.\n        // this can occur due to unripe LP chops.\n        if(redeem > underlyingAmount) redeem = underlyingAmount;\n    }\n\n    /**\n     * @notice returns the total percentage that beanstalk has recapitalized.\n     * @dev this is calculated by the ratio of s.recapitalized and the total dollars the barnraise needs to raise.\n     * returns the same precision as `getRecapPaidPercentAmount` (100% recapitalized = 1e6).\n     */\n    function getTotalRecapitalizedPercent() internal view returns (uint256 recapitalizedPercent) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 totalUsdNeeded = LibFertilizer.getTotalRecapDollarsNeeded();\n        if(totalUsdNeeded == 0) return 0;\n        return s.recapitalized.mul(DECIMALS).div(totalUsdNeeded);\n    }\n\n    /**\n     * @notice Returns the amount of beans that are locked in the unripe token.\n     * @dev Locked beans are the beans that are forfeited if the unripe token is chopped.\n     * @param reserves the reserves of the LP that underly the unripe token.\n     * @dev reserves are used as a parameter for gas effiency purposes (see LibEvaluate.calcLPToSupplyRatio}.\n     */\n    function getLockedBeans(\n        uint256[] memory reserves\n    ) internal view returns (uint256 lockedAmount) {\n        lockedAmount = LibLockedUnderlying\n            .getLockedUnderlying(C.UNRIPE_BEAN, getTotalRecapitalizedPercent())\n            .add(getLockedBeansFromLP(reserves));\n    }\n\n    /**\n     * @notice Returns the amount of beans that are locked in the unripeLP token.\n     * @param reserves the reserves of the LP that underly the unripe token.\n     */\n    function getLockedBeansFromLP(\n        uint256[] memory reserves\n    ) internal view returns (uint256 lockedBeanAmount) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        \n        // if reserves return 0, then skip calculations.\n        if (reserves[0] == 0) return 0;\n        uint256 lockedLpAmount = LibLockedUnderlying.getLockedUnderlying(\n            C.UNRIPE_LP,\n            getTotalRecapitalizedPercent()\n        );\n        address underlying = s.u[C.UNRIPE_LP].underlyingToken;\n        uint256 beanIndex = LibWell.getBeanIndexFromWell(underlying);\n\n        // lpTokenSupply is calculated rather than calling totalSupply(),\n        // because the Well's lpTokenSupply is not MEV resistant.\n        Call memory wellFunction = IWell(underlying).wellFunction();\n        uint lpTokenSupply = IWellFunction(wellFunction.target).calcLpTokenSupply(\n            reserves,\n            wellFunction.data\n        );\n        lockedBeanAmount = lockedLpAmount.mul(reserves[beanIndex]).div(lpTokenSupply);\n    }\n\n    /**\n     * @notice Calculates the penalized amount based the amount of Sprouts that are Rinsable\n     * or Rinsed (Fertilized).\n     * @param amount The amount of the Unripe Tokens.\n     * @return penalizedAmount The penalized amount of the Ripe Tokens received from Chopping.\n     */\n    function getRecapPaidPercentAmount(\n        uint256 amount\n    ) internal view returns (uint256 penalizedAmount) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.fertilizedIndex.mul(amount).div(s.unfertilizedIndex);\n    }\n\n    /**\n     * @notice Returns true if the token is unripe.\n     */\n    function isUnripe(address unripeToken) internal view returns (bool unripe) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        unripe = s.u[unripeToken].underlyingToken != address(0);\n    }\n\n    function getTotalRecapDollarsNeeded() internal view returns (uint256 totalUsdNeeded) {\n        return LibFertilizer.getTotalRecapDollarsNeeded();\n    }\n}"
    },
    {
      "filename": "protocol/contracts/beanstalk/barn/UnripeFacet.sol",
      "content": "/*\n * SPDX-License-Identifier: MIT\n */\n\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {MerkleProof} from \"@openzeppelin/contracts/cryptography/MerkleProof.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IBean} from \"contracts/interfaces/IBean.sol\";\nimport {LibDiamond} from \"contracts/libraries/LibDiamond.sol\";\nimport {LibUnripe} from \"contracts/libraries/LibUnripe.sol\";\nimport {LibTransfer} from \"contracts/libraries/Token/LibTransfer.sol\";\nimport {LibWell} from \"contracts/libraries/Well/LibWell.sol\";\nimport {C} from \"contracts/C.sol\";\nimport {ReentrancyGuard} from \"contracts/beanstalk/ReentrancyGuard.sol\";\nimport {LibLockedUnderlying} from \"contracts/libraries/LibLockedUnderlying.sol\";\nimport {LibChop} from \"contracts/libraries/LibChop.sol\";\nimport {LibBarnRaise} from \"contracts/libraries/LibBarnRaise.sol\";\n\n/**\n * @title UnripeFacet\n * @author ZrowGz, Publius, deadmanwalking\n * @notice Handles functionality related to Unripe Tokens including Chopping, Picking,\n * managing Unripe Tokens. Also, contains view functions to fetch Unripe Token data.\n */\n\ncontract UnripeFacet is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using LibTransfer for IERC20;\n    using SafeMath for uint256;\n\n    /**\n     * @notice Emitted when a new unripe token is added to Beanstalk.\n     */\n    event AddUnripeToken(\n        address indexed unripeToken,\n        address indexed underlyingToken,\n        bytes32 merkleRoot\n    );\n\n    /**\n     * @notice Emitted when the Ripe Token of an Unripe Token increases or decreases.\n     * @param token The token of which the Underlying changes.\n     * @param underlying `amount` that has changed.\n     */\n    event ChangeUnderlying(address indexed token, int256 underlying);\n\n    /**\n     * @notice Emitted when the Ripe Token of an unripe asset changes.\n     * @param token The Unripe Token to change the Ripe Token of.\n     * @param underlyingToken The new Ripe Token.\n     */\n    event SwitchUnderlyingToken(address indexed token, address indexed underlyingToken);\n\n    /**\n     * @notice emitted when a Farmer Chops.\n     */\n    event Chop(address indexed account, address indexed token, uint256 amount, uint256 underlying);\n\n    /**\n     * @notice emitted when a user `picks`.\n     * @dev `picking` is claiming non-Deposited Unripe Tokens.\n     */\n    event Pick(address indexed account, address indexed token, uint256 amount);\n\n    /**\n     * @notice Chops an unripe asset into its ripe counterpart according to the recapitalization %\n     * @param unripeToken The address of the unripe token to be chopped into its ripe counterpart\n     * @param amount The amount of the of the unripe token to be chopped into its ripe counterpart\n     * @param fromMode Enum value to distinguish the type of account used to charge the funds before chopping.\n     * @param toMode Enum value to distinguish the type of account used to credit the funds after chopping.\n     * fromMode can be EXTERNAL,INTERNAL, EXTERNAL_INTERNAL,INTERNAL_TOLERANT.\n     * toMode can be EXTERNAL or INTERNAL.\n     * @return underlyingAmount the amount of ripe tokens received after the chop\n     */\n    function chop(\n        address unripeToken,\n        uint256 amount,\n        LibTransfer.From fromMode,\n        LibTransfer.To toMode\n    ) external payable nonReentrant returns (uint256) {\n        // burn the token from the msg.sender address\n        uint256 supply = IBean(unripeToken).totalSupply();\n        amount = LibTransfer.burnToken(IBean(unripeToken), amount, msg.sender, fromMode);\n        // get ripe address and ripe amount\n        (address underlyingToken, uint256 underlyingAmount) = LibChop.chop(\n            unripeToken,\n            amount,\n            supply\n        );\n        // send the corresponding amount of ripe token to the user address\n        require(underlyingAmount > 0, \"Chop: no underlying\");\n        IERC20(underlyingToken).sendToken(underlyingAmount, msg.sender, toMode);\n        // emit the event\n        emit Chop(msg.sender, unripeToken, amount, underlyingAmount);\n        return underlyingAmount;\n    }\n\n    /**\n     * @notice Picks a Farmer's Pickable Unripe Tokens.\n     * @dev Pickable Unripe Tokens were distributed to all non-Deposited pre-exploit Bean and Bean LP Tokens.\n     * @param token The Unripe Token address to Pick.\n     * @param amount The amount of Unripe Tokens to Pick.\n     * @param proof The merkle proof used to validate that the Pick is valid.\n     * @param mode The destination balance that the Unripe Tokens are sent to.\n     */\n    function pick(\n        address token,\n        uint256 amount,\n        bytes32[] memory proof,\n        LibTransfer.To mode\n    ) external payable nonReentrant {\n        bytes32 root = s.u[token].merkleRoot;\n        require(root != bytes32(0), \"UnripeClaim: invalid token\");\n        require(!picked(msg.sender, token), \"UnripeClaim: already picked\");\n\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, amount));\n        require(MerkleProof.verify(proof, root, leaf), \"UnripeClaim: invalid proof\");\n        s.unripeClaimed[token][msg.sender] = true;\n\n        LibTransfer.sendToken(IERC20(token), amount, msg.sender, mode);\n\n        emit Pick(msg.sender, token, amount);\n    }\n\n    /**\n     * @notice Returns whether a given `account` has picked a given `token`.\n     * @param account The address of the account to check.\n     * @param token The address of the Unripe Token to check.\n     */\n    function picked(address account, address token) public view returns (bool) {\n        return s.unripeClaimed[token][account];\n    }\n\n    /**\n     * @notice Returns the amount of Ripe Tokens that underly a given amount of Unripe Tokens.\n     * @dev Does NOT include the penalty associated with the percent of Sprouts that are Rinsable\n     * or Rinsed.\n     * @param unripeToken The address of the Unripe Token.\n     * @param amount The amount of the Unripe Token.\n     * @return underlyingAmount The amount of Ripe Tokens that underly the given amount of\n     * Unripe Tokens.\n     */\n    function getUnderlying(\n        address unripeToken,\n        uint256 amount\n    ) public view returns (uint256 underlyingAmount) {\n        return LibUnripe.unripeToUnderlying(unripeToken, amount, IBean(unripeToken).totalSupply());\n    }\n\n    /**\n     * @notice Getter function to get the corresponding penalty associated with an unripe asset.\n     * @param unripeToken The address of the unripe token.\n     * @return penalty The current penalty for converting unripe --> ripe\n     */\n    function getPenalty(address unripeToken) external view returns (uint256 penalty) {\n        return getPenalizedUnderlying(unripeToken, LibUnripe.DECIMALS);\n    }\n\n    /**\n     * @notice Getter function to get the corresponding amount\n     * of ripe tokens from a set amount of unripe tokens according to current state.\n     * @param unripeToken The address of the unripe token.\n     * @param amount The amount of the unripe token.\n     * @return redeem The amount of the corresponding ripe tokens\n     */\n    function getPenalizedUnderlying(\n        address unripeToken,\n        uint256 amount\n    ) public view returns (uint256 redeem) {\n        return LibUnripe.getPenalizedUnderlying(unripeToken, amount, IBean(unripeToken).totalSupply());\n    }\n\n    /**\n     * @notice Returns whether a token is an Unripe Token.\n     * @param unripeToken The token address to check.\n     * @return unripe Whether the token is Unripe or not.\n     */\n    function isUnripe(address unripeToken) external view returns (bool unripe) {\n        unripe = LibUnripe.isUnripe(unripeToken);\n    }\n\n    /**\n     * @notice Returns the amount of Ripe Tokens that underly a Farmer's balance of Unripe\n     * Tokens.\n     * @param unripeToken The address of the Unripe Token.\n     * @param account The address of the Farmer to check.\n     * @return underlying The amount of Ripe Tokens that underly the Farmer's balance.\n     */\n    function balanceOfUnderlying(\n        address unripeToken,\n        address account\n    ) external view returns (uint256 underlying) {\n        return getUnderlying(unripeToken, IERC20(unripeToken).balanceOf(account));\n    }\n\n    /**\n     * @notice Returns the amount of Ripe Tokens that underly a Farmer's balance of Unripe\n     * @param unripeToken The address of the unripe token.\n     * @param account The address of the account to check.\n     * @return underlying The theoretical amount of the ripe asset in the account.\n     */\n    function balanceOfPenalizedUnderlying(\n        address unripeToken,\n        address account\n    ) external view returns (uint256 underlying) {\n        return getPenalizedUnderlying(unripeToken, IERC20(unripeToken).balanceOf(account));\n    }\n\n    /**\n     * @notice Returns the % of Ripe Tokens that have been recapiatlized for a given Unripe Token.\n     * @param unripeToken The address of the Unripe Token.\n     * @return percent The recap % of the token.\n     */\n    function getRecapFundedPercent(address unripeToken) public view returns (uint256 percent) {\n        if (unripeToken == C.UNRIPE_BEAN) {\n            return LibUnripe.percentBeansRecapped();\n        } else if (unripeToken == C.UNRIPE_LP) {\n            return LibUnripe.percentLPRecapped();\n        }\n        revert(\"not vesting\");\n    }\n\n    /**\n     * @notice Returns the % penalty of Chopping an Unripe Token into its Ripe Token.\n     * @param unripeToken The address of the Unripe Token.\n     * @return penalty The penalty % of Chopping derived from %Recapitalized^2.\n     * @dev `address` parameter retained for backwards compatiability.\n     */\n    function getPercentPenalty(address unripeToken) external view returns (uint256 penalty) {\n        if (unripeToken == C.UNRIPE_BEAN) { \n            return LibUnripe.getPenalizedUnderlying(\n                unripeToken,\n                LibUnripe.DECIMALS,\n                IERC20(unripeToken).totalSupply()\n            );\n        }\n        \n        if (unripeToken == C.UNRIPE_LP) { \n            return LibUnripe.getTotalRecapitalizedPercent()\n                .mul(LibUnripe.getTotalRecapitalizedPercent())\n                .div(LibUnripe.DECIMALS);\n        }\n    }\n\n    /**\n     * @notice Returns % of Sprouts that are Rinsable or Rinsed.\n     * @return percent The % stemming from the recap.\n     */\n    function getRecapPaidPercent() external view returns (uint256 percent) {\n        percent = LibUnripe.getRecapPaidPercentAmount(LibUnripe.DECIMALS);\n    }\n\n    /**\n     * @notice Returns the amount of Ripe Tokens that underly a single Unripe Token.\n     * @dev has 6 decimals of precision.\n     * @param unripeToken The address of the unripe token.\n     * @return underlyingPerToken The underlying ripe token per unripe token. \n     */\n    function getUnderlyingPerUnripeToken(address unripeToken)\n        external\n        view\n        returns (uint256 underlyingPerToken)\n    {\n        underlyingPerToken = s\n            .u[unripeToken]\n            .balanceOfUnderlying\n            .mul(LibUnripe.DECIMALS)\n            .div(IERC20(unripeToken).totalSupply());\n    }\n\n    /**\n     * @notice Returns the total amount of Ripe Tokens for a given Unripe Token.\n     * @param unripeToken The address of the unripe token.\n     * @return underlying The total balance of the token. \n     */\n    function getTotalUnderlying(address unripeToken)\n        external\n        view\n        returns (uint256 underlying)\n    {\n        return s.u[unripeToken].balanceOfUnderlying;\n    }\n\n\n    /**\n     * @notice Adds an Unripe Token to Beanstalk.\n     * @param unripeToken The address of the Unripe Token to be added.\n     * @param underlyingToken The address of the Ripe Token.\n     * @param root The merkle root, which is used to verify claims.\n     */\n    function addUnripeToken(\n        address unripeToken,\n        address underlyingToken,\n        bytes32 root\n    ) external payable nonReentrant {\n        LibDiamond.enforceIsOwnerOrContract();\n        s.u[unripeToken].underlyingToken = underlyingToken;\n        s.u[unripeToken].merkleRoot = root;\n        emit AddUnripeToken(unripeToken, underlyingToken, root);\n    }\n\n    /**\n     * @notice Returns the Ripe Token of an Unripe Token.\n     * @param unripeToken The address of the Unripe Token.\n     * @return underlyingToken The address of the Ripe Token.\n     */\n    function getUnderlyingToken(address unripeToken)\n        external\n        view\n        returns (address underlyingToken)\n    {\n        return s.u[unripeToken].underlyingToken;\n    }\n\n    /////////////// UNDERLYING TOKEN MIGRATION //////////////////\n\n    /**\n     * @notice Adds Ripe Tokens to an Unripe Token. Used when changing the Ripe Token.\n     * @param unripeToken The Unripe Token to add Underlying tokens to.\n     * @param amount The amount of Ripe Tokens to add.\n     * @dev Used to migrate the Ripe Token of an Unripe Token to a new token.\n     * Only callable by the contract owner.\n     */\n    function addMigratedUnderlying(\n        address unripeToken,\n        uint256 amount\n    ) external payable nonReentrant {\n        LibDiamond.enforceIsContractOwner();\n        IERC20(s.u[unripeToken].underlyingToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n        LibUnripe.incrementUnderlying(unripeToken, amount);\n    }\n\n    /**\n     * @notice Switches the Ripe Token of an Unripe Token.\n     * @param unripeToken The Unripe Token to switch the Ripe Token of.\n     * @param newUnderlyingToken The new Ripe Token to switch to.\n     * @dev `s.u[unripeToken].balanceOfUnderlying` must be 0.\n     */\n    function switchUnderlyingToken(\n        address unripeToken,\n        address newUnderlyingToken\n    ) external payable {\n        LibDiamond.enforceIsContractOwner();\n        require(s.u[unripeToken].balanceOfUnderlying == 0, \"Unripe: Underlying balance > 0\");\n        LibUnripe.switchUnderlyingToken(unripeToken, newUnderlyingToken);\n    }\n\n    /**\n     * @notice Returns the number of Beans that are locked (not in circulation) using the TWA reserves in\n     * the Bean:Eth Well including the Unchoppable Beans underlying the Unripe Bean and Unripe LP\n     * Tokens.\n     */\n    function getLockedBeans() external view returns (uint256) {\n        uint256[] memory twaReserves = LibWell.getTwaReservesFromBeanstalkPump(LibBarnRaise.getBarnRaiseWell());\n        return LibUnripe.getLockedBeans(twaReserves);\n    }\n\n    /**\n     * @notice Returns the number of Beans that are locked underneath the Unripe Bean token.\n     */\n    function getLockedBeansUnderlyingUnripeBean() external view returns (uint256) {\n        return LibLockedUnderlying.getLockedUnderlying(\n            C.UNRIPE_BEAN,\n            LibUnripe.getTotalRecapitalizedPercent()\n        );\n    }\n\n    /**\n     * @notice Returns the number of Beans that are locked underneath the Unripe LP Token.\n     */\n    function getLockedBeansUnderlyingUnripeLP() external view returns (uint256) {\n        uint256[] memory twaReserves = LibWell.getTwaReservesFromBeanstalkPump(LibBarnRaise.getBarnRaiseWell());\n        return LibUnripe.getLockedBeansFromLP(twaReserves);\n    }\n\n    /**\n     * @notice returns the amount of dollarsÂ recapitalized in the barn raise.\n     */\n    function getRecapitalized() external view returns (uint256) {\n        return s.recapitalized;\n    }\n}"
    },
    {
      "filename": "protocol/contracts/libraries/LibChop.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {LibUnripe, SafeMath, AppStorage} from \"contracts/libraries/LibUnripe.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IBean} from \"contracts/interfaces/IBean.sol\";\nimport {LibAppStorage} from \"./LibAppStorage.sol\";\n\n/**\n * @title LibChop\n * @author deadmanwalking\n */\nlibrary LibChop {\n    using SafeMath for uint256;\n\n    /**\n     * @notice Chops an Unripe Token into its Ripe Token.\n     * @dev The output amount is based on the % of Sprouts that are Rinsable or Rinsed\n     * and the % of Fertilizer that has been bought.\n     * @param unripeToken The address of the Unripe Token to be Chopped.\n     * @param amount The amount of the of the Unripe Token to be Chopped.\n     * @return underlyingToken The address of Ripe Tokens received after the Chop.\n     * @return underlyingAmount The amount of Ripe Tokens received after the Chop.\n     */\n    function chop(\n        address unripeToken,\n        uint256 amount,\n        uint256 supply\n    ) internal returns (address underlyingToken, uint256 underlyingAmount) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        underlyingAmount = LibUnripe.getPenalizedUnderlying(unripeToken, amount, supply);\n        // remove the underlying amount and decrease s.recapitalized if token is unripe LP\n        LibUnripe.removeUnderlying(unripeToken, underlyingAmount);\n        underlyingToken = s.u[unripeToken].underlyingToken;\n    }\n}"
    }
  ]
}