{
  "Title": "Fillers Can Incur a Loss Without a Chance to Revert",
  "Content": "\n\n\nWhen fillers execute an order, they have a chance to revert at the end of their [callback](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/reactors/BaseReactor.sol#L54) if the trade was not profitable for them. However, the `executeWithCallback` flow (and its batch equivalent) does not end right after the callback. Instead, once the callback is over, the [output balances are transferred](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/reactors/BaseReactor.sol#L110-L133) from the filler to the swapper by the reactor. \n\n\nIf one of the output tokens is either a malicious ERC-20 implementation controlled by the swapper or a legitimate ERC-777 implementation, the swapper can receive one more callback within the `transferFrom` function call to perform arbitrary operations. These operations might be gas intensive and will be funded by the filler. At this point, the filler has no more execution control. As such, given a high enough overall transaction gas limit, even if a profit was made on the trade, the filler could incur a loss. \n\n\nA malicious swapper might use this technique to perform a legitimate swap as well as let the filler subsidize a potentially gas-intensive operation (e.g., minting gas tokens on applicable chains, performing more swaps, deploying contracts, etc). \n\n\nConsider adding a final callback to the filler to allow reverts if a profit was not made after fees. This will turn this vector into a griefing attack since the filler will be charged for the revert, but at least the swapper will not profit from the filler. In order to make the extra callback more gas efficient, consider either making it optional or having the filler call an external version of [`_fill`](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/reactors/BaseReactor.sol#L110) as the last step on their callback. It is imperative to ensure the filler has called the `_fill` function, but this must be done without checking the balances of the recipients. \n\n\n\n\n\n***Update:** Acknowledged, not resolved. This issue is only applicable if the filler is using an EOA to target the various `execute` entrypoints directly (without using an intermediate contract of their own) and / or not using a private mempool to relay their transactions in order to avoid paying for reverts. The Uniswap team stated:*\n\n\n\n> *Fillers generally estimateGas on their transaction before including them anyways, and they will only send it if it is profitable net of gas. They also generally use private mempools like flashbots or mevblocker to get protection from loss due to gas. Further,* they do have the chance to revert after the order is filled in their `fillContract`, after the execution is finished.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/reactors/BaseReactor.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {SafeTransferLib} from \"solmate/src/utils/SafeTransferLib.sol\";\nimport {ReentrancyGuard} from \"openzeppelin-contracts/security/ReentrancyGuard.sol\";\nimport {IPermit2} from \"permit2/src/interfaces/IPermit2.sol\";\nimport {ERC20} from \"solmate/src/tokens/ERC20.sol\";\nimport {ReactorEvents} from \"../base/ReactorEvents.sol\";\nimport {ResolvedOrderLib} from \"../lib/ResolvedOrderLib.sol\";\nimport {CurrencyLibrary, NATIVE} from \"../lib/CurrencyLibrary.sol\";\nimport {IReactorCallback} from \"../interfaces/IReactorCallback.sol\";\nimport {IReactor} from \"../interfaces/IReactor.sol\";\nimport {ProtocolFees} from \"../base/ProtocolFees.sol\";\nimport {SignedOrder, ResolvedOrder, OutputToken} from \"../base/ReactorStructs.sol\";\n\n/// @notice Generic reactor logic for settling off-chain signed orders\n///     using arbitrary fill methods specified by a filler\nabstract contract BaseReactor is IReactor, ReactorEvents, ProtocolFees, ReentrancyGuard {\n    using SafeTransferLib for ERC20;\n    using ResolvedOrderLib for ResolvedOrder;\n    using CurrencyLibrary for address;\n\n    // Occurs when an output = ETH and the reactor does contain enough ETH but\n    // the direct filler did not include enough ETH in their call to execute/executeBatch\n    error InsufficientEth();\n\n    /// @notice permit2 address used for token transfers and signature verification\n    IPermit2 public immutable permit2;\n\n    constructor(IPermit2 _permit2, address _protocolFeeOwner) ProtocolFees(_protocolFeeOwner) {\n        permit2 = _permit2;\n    }\n\n    /// @inheritdoc IReactor\n    function execute(SignedOrder calldata order) external payable override nonReentrant {\n        ResolvedOrder[] memory resolvedOrders = new ResolvedOrder[](1);\n        resolvedOrders[0] = resolve(order);\n\n        _prepare(resolvedOrders);\n        _fill(resolvedOrders);\n    }\n\n    /// @inheritdoc IReactor\n    function executeWithCallback(SignedOrder calldata order, bytes calldata callbackData)\n        external\n        payable\n        override\n        nonReentrant\n    {\n        ResolvedOrder[] memory resolvedOrders = new ResolvedOrder[](1);\n        resolvedOrders[0] = resolve(order);\n\n        _prepare(resolvedOrders);\n        IReactorCallback(msg.sender).reactorCallback(resolvedOrders, callbackData);\n        _fill(resolvedOrders);\n    }\n\n    /// @inheritdoc IReactor\n    function executeBatch(SignedOrder[] calldata orders) external payable override nonReentrant {\n        uint256 ordersLength = orders.length;\n        ResolvedOrder[] memory resolvedOrders = new ResolvedOrder[](ordersLength);\n\n        unchecked {\n            for (uint256 i = 0; i < ordersLength; i++) {\n                resolvedOrders[i] = resolve(orders[i]);\n            }\n        }\n\n        _prepare(resolvedOrders);\n        _fill(resolvedOrders);\n    }\n\n    /// @inheritdoc IReactor\n    function executeBatchWithCallback(SignedOrder[] calldata orders, bytes calldata callbackData)\n        external\n        payable\n        override\n        nonReentrant\n    {\n        uint256 ordersLength = orders.length;\n        ResolvedOrder[] memory resolvedOrders = new ResolvedOrder[](ordersLength);\n\n        unchecked {\n            for (uint256 i = 0; i < ordersLength; i++) {\n                resolvedOrders[i] = resolve(orders[i]);\n            }\n        }\n\n        _prepare(resolvedOrders);\n        IReactorCallback(msg.sender).reactorCallback(resolvedOrders, callbackData);\n        _fill(resolvedOrders);\n    }\n\n    /// @notice validates, injects fees, and transfers input tokens in preparation for order fill\n    /// @param orders The orders to prepare\n    function _prepare(ResolvedOrder[] memory orders) internal {\n        uint256 ordersLength = orders.length;\n        unchecked {\n            for (uint256 i = 0; i < ordersLength; i++) {\n                ResolvedOrder memory order = orders[i];\n                _injectFees(order);\n                order.validate(msg.sender);\n                transferInputTokens(order, msg.sender);\n            }\n        }\n    }\n\n    /// @notice fills a list of orders, ensuring all outputs are satisfied\n    /// @param orders The orders to fill\n    function _fill(ResolvedOrder[] memory orders) internal {\n        uint256 ordersLength = orders.length;\n        // attempt to transfer all currencies to all recipients\n        unchecked {\n            // transfer output tokens to their respective recipients\n            for (uint256 i = 0; i < ordersLength; i++) {\n                ResolvedOrder memory resolvedOrder = orders[i];\n                uint256 outputsLength = resolvedOrder.outputs.length;\n                for (uint256 j = 0; j < outputsLength; j++) {\n                    OutputToken memory output = resolvedOrder.outputs[j];\n                    output.token.transferFill(output.recipient, output.amount);\n                }\n\n                emit Fill(orders[i].hash, msg.sender, resolvedOrder.info.swapper, resolvedOrder.info.nonce);\n            }\n        }\n\n        // refund any remaining ETH to the filler. Only occurs when filler sends more ETH than required to\n        // `execute()` or `executeBatch()`, or when there is excess contract balance remaining from others\n        // incorrectly calling execute/executeBatch without direct filler method but with a msg.value\n        if (address(this).balance > 0) {\n            CurrencyLibrary.transferNative(msg.sender, address(this).balance);\n        }\n    }\n\n    receive() external payable {\n        // receive native asset to support native output\n    }\n\n    /// @notice Resolve order-type specific requirements into a generic order with the final inputs and outputs.\n    /// @param order The encoded order to resolve\n    /// @return resolvedOrder generic resolved order of inputs and outputs\n    /// @dev should revert on any order-type-specific validation errors\n    function resolve(SignedOrder calldata order) internal view virtual returns (ResolvedOrder memory resolvedOrder);\n\n    /// @notice Transfers tokens to the fillContract\n    /// @param order The encoded order to transfer tokens for\n    /// @param to The address to transfer tokens to\n    function transferInputTokens(ResolvedOrder memory order, address to) internal virtual;\n}"
    },
    {
      "filename": "src/reactors/BaseReactor.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {SafeTransferLib} from \"solmate/src/utils/SafeTransferLib.sol\";\nimport {ReentrancyGuard} from \"openzeppelin-contracts/security/ReentrancyGuard.sol\";\nimport {IPermit2} from \"permit2/src/interfaces/IPermit2.sol\";\nimport {ERC20} from \"solmate/src/tokens/ERC20.sol\";\nimport {ReactorEvents} from \"../base/ReactorEvents.sol\";\nimport {ResolvedOrderLib} from \"../lib/ResolvedOrderLib.sol\";\nimport {CurrencyLibrary, NATIVE} from \"../lib/CurrencyLibrary.sol\";\nimport {IReactorCallback} from \"../interfaces/IReactorCallback.sol\";\nimport {IReactor} from \"../interfaces/IReactor.sol\";\nimport {ProtocolFees} from \"../base/ProtocolFees.sol\";\nimport {SignedOrder, ResolvedOrder, OutputToken} from \"../base/ReactorStructs.sol\";\n\n/// @notice Generic reactor logic for settling off-chain signed orders\n///     using arbitrary fill methods specified by a filler\nabstract contract BaseReactor is IReactor, ReactorEvents, ProtocolFees, ReentrancyGuard {\n    using SafeTransferLib for ERC20;\n    using ResolvedOrderLib for ResolvedOrder;\n    using CurrencyLibrary for address;\n\n    // Occurs when an output = ETH and the reactor does contain enough ETH but\n    // the direct filler did not include enough ETH in their call to execute/executeBatch\n    error InsufficientEth();\n\n    /// @notice permit2 address used for token transfers and signature verification\n    IPermit2 public immutable permit2;\n\n    constructor(IPermit2 _permit2, address _protocolFeeOwner) ProtocolFees(_protocolFeeOwner) {\n        permit2 = _permit2;\n    }\n\n    /// @inheritdoc IReactor\n    function execute(SignedOrder calldata order) external payable override nonReentrant {\n        ResolvedOrder[] memory resolvedOrders = new ResolvedOrder[](1);\n        resolvedOrders[0] = resolve(order);\n\n        _prepare(resolvedOrders);\n        _fill(resolvedOrders);\n    }\n\n    /// @inheritdoc IReactor\n    function executeWithCallback(SignedOrder calldata order, bytes calldata callbackData)\n        external\n        payable\n        override\n        nonReentrant\n    {\n        ResolvedOrder[] memory resolvedOrders = new ResolvedOrder[](1);\n        resolvedOrders[0] = resolve(order);\n\n        _prepare(resolvedOrders);\n        IReactorCallback(msg.sender).reactorCallback(resolvedOrders, callbackData);\n        _fill(resolvedOrders);\n    }\n\n    /// @inheritdoc IReactor\n    function executeBatch(SignedOrder[] calldata orders) external payable override nonReentrant {\n        uint256 ordersLength = orders.length;\n        ResolvedOrder[] memory resolvedOrders = new ResolvedOrder[](ordersLength);\n\n        unchecked {\n            for (uint256 i = 0; i < ordersLength; i++) {\n                resolvedOrders[i] = resolve(orders[i]);\n            }\n        }\n\n        _prepare(resolvedOrders);\n        _fill(resolvedOrders);\n    }\n\n    /// @inheritdoc IReactor\n    function executeBatchWithCallback(SignedOrder[] calldata orders, bytes calldata callbackData)\n        external\n        payable\n        override\n        nonReentrant\n    {\n        uint256 ordersLength = orders.length;\n        ResolvedOrder[] memory resolvedOrders = new ResolvedOrder[](ordersLength);\n\n        unchecked {\n            for (uint256 i = 0; i < ordersLength; i++) {\n                resolvedOrders[i] = resolve(orders[i]);\n            }\n        }\n\n        _prepare(resolvedOrders);\n        IReactorCallback(msg.sender).reactorCallback(resolvedOrders, callbackData);\n        _fill(resolvedOrders);\n    }\n\n    /// @notice validates, injects fees, and transfers input tokens in preparation for order fill\n    /// @param orders The orders to prepare\n    function _prepare(ResolvedOrder[] memory orders) internal {\n        uint256 ordersLength = orders.length;\n        unchecked {\n            for (uint256 i = 0; i < ordersLength; i++) {\n                ResolvedOrder memory order = orders[i];\n                _injectFees(order);\n                order.validate(msg.sender);\n                transferInputTokens(order, msg.sender);\n            }\n        }\n    }\n\n    /// @notice fills a list of orders, ensuring all outputs are satisfied\n    /// @param orders The orders to fill\n    function _fill(ResolvedOrder[] memory orders) internal {\n        uint256 ordersLength = orders.length;\n        // attempt to transfer all currencies to all recipients\n        unchecked {\n            // transfer output tokens to their respective recipients\n            for (uint256 i = 0; i < ordersLength; i++) {\n                ResolvedOrder memory resolvedOrder = orders[i];\n                uint256 outputsLength = resolvedOrder.outputs.length;\n                for (uint256 j = 0; j < outputsLength; j++) {\n                    OutputToken memory output = resolvedOrder.outputs[j];\n                    output.token.transferFill(output.recipient, output.amount);\n                }\n\n                emit Fill(orders[i].hash, msg.sender, resolvedOrder.info.swapper, resolvedOrder.info.nonce);\n            }\n        }\n\n        // refund any remaining ETH to the filler. Only occurs when filler sends more ETH than required to\n        // `execute()` or `executeBatch()`, or when there is excess contract balance remaining from others\n        // incorrectly calling execute/executeBatch without direct filler method but with a msg.value\n        if (address(this).balance > 0) {\n            CurrencyLibrary.transferNative(msg.sender, address(this).balance);\n        }\n    }\n\n    receive() external payable {\n        // receive native asset to support native output\n    }\n\n    /// @notice Resolve order-type specific requirements into a generic order with the final inputs and outputs.\n    /// @param order The encoded order to resolve\n    /// @return resolvedOrder generic resolved order of inputs and outputs\n    /// @dev should revert on any order-type-specific validation errors\n    function resolve(SignedOrder calldata order) internal view virtual returns (ResolvedOrder memory resolvedOrder);\n\n    /// @notice Transfers tokens to the fillContract\n    /// @param order The encoded order to transfer tokens for\n    /// @param to The address to transfer tokens to\n    function transferInputTokens(ResolvedOrder memory order, address to) internal virtual;\n}"
    }
  ]
}