{
  "Title": "[M-04] Amount distributed can be inaccurate when updating weights",
  "Content": "# Lines of code\n\n https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L220\n https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/InflationManager.sol#L559\n https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/InflationManager.sol#L572\n https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/InflationManager.sol#L586\n\n\n# Vulnerability details\n\n\n## Impact\n\nWhen updating pool inflation rates, other pools see their `currentRate` being modified without having `poolCheckpoint` called, which leads to false computations.\n\nThis will lead to either users losing a part of their claims, but can also lead to too many tokens could be distributed, preventing some users from claiming due to the `totalAvailableToNow` requirement in `Minter`.\n\n## Proof of concept\n\nImagine you have 2 AMM pools A and B, both with an `ammPoolWeight` of 100, where `poolCheckpoint` has not been called for a moment. Then, imagine calling [`executeAmmTokenWeight`](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/InflationManager.sol#L318) to reduce the weight of A to 0. \n\nOnly A is checkpointed [here](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/InflationManager.sol#L591), so when B will be checkpointed it will call `getAmmRateForToken`, which will see a pool weight of 100 and a total weight of 100 over the whole period since the last checkpoint of B, which is false, therefore it will distribute too many tokens. This is critical has the minter expects an exact or lower than expected distribution due to the requirement of `totalAvailableToNow`.\n\nIn the opposite direction, when increasing weights, it will lead to less tokens being distributed in some pools than planned, leading to a loss for users.\n\n## Mitigation steps\nCheckpoint every `LpStakerVault`, `KeeperGauge` or `AmmGauge` when updating the weights of one of them.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-backd-tokenomics-contest",
  "Code": [
    {
      "filename": "protocol/contracts/tokenomics/Minter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../../interfaces/IController.sol\";\nimport \"../../interfaces/tokenomics/IBkdToken.sol\";\nimport \"../../interfaces/tokenomics/IMinter.sol\";\n\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/ScaledMath.sol\";\nimport \"../../libraries/AddressProviderHelpers.sol\";\n\nimport \"./BkdToken.sol\";\nimport \"../access/Authorization.sol\";\n\ncontract Minter is IMinter, Authorization, ReentrancyGuard {\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    uint256 private constant _INFLATION_DECAY_PERIOD = 365 days;\n\n    // Lp Rates\n    uint256 public immutable initialAnnualInflationRateLp;\n    uint256 public immutable annualInflationDecayLp;\n    uint256 public currentInflationAmountLp;\n\n    // Keeper Rates\n    uint256 public immutable initialPeriodKeeperInflation;\n    uint256 public immutable initialAnnualInflationRateKeeper;\n    uint256 public immutable annualInflationDecayKeeper;\n    uint256 public currentInflationAmountKeeper;\n\n    // AMM Rates\n    uint256 public immutable initialPeriodAmmInflation;\n    uint256 public immutable initialAnnualInflationRateAmm;\n    uint256 public immutable annualInflationDecayAmm;\n    uint256 public currentInflationAmountAmm;\n\n    bool public initialPeriodEnded;\n\n    // Non-inflation rates\n    uint256 public immutable nonInflationDistribution;\n    uint256 public issuedNonInflationSupply;\n\n    uint256 public lastInflationDecay;\n    uint256 public currentTotalInflation;\n\n    // Used for final safety check to ensure inflation is not exceeded\n    uint256 public totalAvailableToNow;\n    uint256 public totalMintedToNow;\n    uint256 public lastEvent;\n\n    IController public immutable controller;\n    BkdToken public token;\n\n    event TokensMinted(address beneficiary, uint256 amount);\n\n    constructor(\n        uint256 _annualInflationRateLp,\n        uint256 _annualInflationRateKeeper,\n        uint256 _annualInflationRateAmm,\n        uint256 _annualInflationDecayLp,\n        uint256 _annualInflationDecayKeeper,\n        uint256 _annualInflationDecayAmm,\n        uint256 _initialPeriodKeeperInflation,\n        uint256 _initialPeriodAmmInflation,\n        uint256 _nonInflationDistribution,\n        IController _controller\n    ) Authorization(_controller.addressProvider().getRoleManager()) {\n        require(_annualInflationDecayLp < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE);\n        require(_annualInflationDecayKeeper < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE);\n        require(_annualInflationDecayAmm < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE);\n        initialAnnualInflationRateLp = _annualInflationRateLp;\n        initialAnnualInflationRateKeeper = _annualInflationRateKeeper;\n        initialAnnualInflationRateAmm = _annualInflationRateAmm;\n\n        annualInflationDecayLp = _annualInflationDecayLp;\n        annualInflationDecayKeeper = _annualInflationDecayKeeper;\n        annualInflationDecayAmm = _annualInflationDecayAmm;\n\n        initialPeriodKeeperInflation = _initialPeriodKeeperInflation;\n        initialPeriodAmmInflation = _initialPeriodAmmInflation;\n\n        currentInflationAmountLp = _annualInflationRateLp / _INFLATION_DECAY_PERIOD;\n        currentInflationAmountKeeper = _initialPeriodKeeperInflation / _INFLATION_DECAY_PERIOD;\n        currentInflationAmountAmm = _initialPeriodAmmInflation / _INFLATION_DECAY_PERIOD;\n\n        currentTotalInflation =\n            currentInflationAmountLp +\n            currentInflationAmountKeeper +\n            currentInflationAmountAmm;\n\n        nonInflationDistribution = _nonInflationDistribution;\n        controller = _controller;\n    }\n\n    function setToken(address _token) external override onlyGovernance {\n        require(address(token) == address(0), \"Token already set!\");\n        token = BkdToken(_token);\n    }\n\n    function startInflation() external override onlyGovernance {\n        require(lastEvent == 0, \"Inflation has already started.\");\n        lastEvent = block.timestamp;\n        lastInflationDecay = block.timestamp;\n    }\n\n    /**\n     * @notice Update the inflation rate according to the piecewise linear schedule.\n     * @dev This updates the inflation rate to the next linear segment in the inflations schedule.\n     * @return `true` if successful.\n     */\n    function executeInflationRateUpdate() external override returns (bool) {\n        return _executeInflationRateUpdate();\n    }\n\n    /**\n     * @notice Mints BKD tokens to a specified address.\n     * @dev Can only be called by the controller.\n     * @param beneficiary Address to mint tokens for.\n     * @param amount Amount of tokens to mint.\n     * @return `true` if successful.\n     */\n    function mint(address beneficiary, uint256 amount)\n        external\n        override\n        nonReentrant\n        returns (bool)\n    {\n        require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS);\n        if (lastEvent == 0) return false;\n        return _mint(beneficiary, amount);\n    }\n\n    /**\n     * @notice Mint tokens that are not part of the inflation schedule.\n     * @dev The amount of tokens that can be minted in total is subject to a pre-set upper limit.\n     * @param beneficiary Address to mint tokens for.\n     * @param amount Amount of tokens to mint.\n     * @return `true` if successful.\n     */\n    function mintNonInflationTokens(address beneficiary, uint256 amount)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        require(\n            issuedNonInflationSupply + amount <= nonInflationDistribution,\n            \"Maximum non-inflation amount exceeded.\"\n        );\n        issuedNonInflationSupply += amount;\n        token.mint(beneficiary, amount);\n        emit TokensMinted(beneficiary, amount);\n        return true;\n    }\n\n    /**\n     * @notice Supplies the inflation rate for LPs per unit of time (seconds).\n     * @return LP inflation rate.\n     */\n    function getLpInflationRate() external view override returns (uint256) {\n        if (lastEvent == 0) return 0;\n        return currentInflationAmountLp;\n    }\n\n    /**\n     * @notice Supplies the inflation rate for keepers per unit of time (seconds).\n     * @return keeper inflation rate.\n     */\n    function getKeeperInflationRate() external view override returns (uint256) {\n        if (lastEvent == 0) return 0;\n        return currentInflationAmountKeeper;\n    }\n\n    /**\n     * @notice Supplies the inflation rate for LPs on AMMs per unit of time (seconds).\n     * @return AMM inflation rate.\n     */\n    function getAmmInflationRate() external view override returns (uint256) {\n        if (lastEvent == 0) return 0;\n        return currentInflationAmountAmm;\n    }\n\n    function _executeInflationRateUpdate() internal returns (bool) {\n        totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));\n        lastEvent = block.timestamp;\n        if (block.timestamp >= lastInflationDecay + _INFLATION_DECAY_PERIOD) {\n            currentInflationAmountLp = currentInflationAmountLp.scaledMul(annualInflationDecayLp);\n            if (initialPeriodEnded) {\n                currentInflationAmountKeeper = currentInflationAmountKeeper.scaledMul(\n                    annualInflationDecayKeeper\n                );\n                currentInflationAmountAmm = currentInflationAmountAmm.scaledMul(\n                    annualInflationDecayAmm\n                );\n            } else {\n                currentInflationAmountKeeper =\n                    initialAnnualInflationRateKeeper /\n                    _INFLATION_DECAY_PERIOD;\n\n                currentInflationAmountAmm = initialAnnualInflationRateAmm / _INFLATION_DECAY_PERIOD;\n                initialPeriodEnded = true;\n            }\n            currentTotalInflation =\n                currentInflationAmountLp +\n                currentInflationAmountKeeper +\n                currentInflationAmountAmm;\n            controller.inflationManager().checkpointAllGauges();\n            lastInflationDecay = block.timestamp;\n        }\n        return true;\n    }\n\n    function _mint(address beneficiary, uint256 amount) internal returns (bool) {\n        totalAvailableToNow += ((block.timestamp - lastEvent) * currentTotalInflation);\n        uint256 newTotalMintedToNow = totalMintedToNow + amount;\n        require(newTotalMintedToNow <= totalAvailableToNow, \"Mintable amount exceeded\");\n        totalMintedToNow = newTotalMintedToNow;\n        lastEvent = block.timestamp;\n        token.mint(beneficiary, amount);\n        _executeInflationRateUpdate();\n        emit TokensMinted(beneficiary, amount);\n        return true;\n    }\n}"
    },
    {
      "filename": "backd/contracts/tokenomics/InflationManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"../../interfaces/IStakerVault.sol\";\nimport \"../../interfaces/tokenomics/IInflationManager.sol\";\nimport \"../../interfaces/tokenomics/IKeeperGauge.sol\";\nimport \"../../interfaces/tokenomics/IAmmGauge.sol\";\n\nimport \"../../libraries/EnumerableMapping.sol\";\nimport \"../../libraries/EnumerableExtensions.sol\";\nimport \"../../libraries/AddressProviderHelpers.sol\";\n\nimport \"./Minter.sol\";\nimport \"../utils/Preparable.sol\";\nimport \"../access/Authorization.sol\";\n\ncontract InflationManager is Authorization, IInflationManager, Preparable {\n    using EnumerableMapping for EnumerableMapping.AddressToAddressMap;\n    using EnumerableExtensions for EnumerableMapping.AddressToAddressMap;\n    using AddressProviderHelpers for IAddressProvider;\n\n    IAddressProvider public immutable addressProvider;\n\n    bytes32 internal constant _KEEPER_WEIGHT_KEY = \"keeperWeight\";\n    bytes32 internal constant _AMM_WEIGHT_KEY = \"ammWeight\";\n    bytes32 internal constant _LP_WEIGHT_KEY = \"lpWeight\";\n\n    address public minter;\n    bool public weightBasedKeeperDistributionDeactivated;\n    uint256 public totalKeeperPoolWeight;\n    uint256 public totalLpPoolWeight;\n    uint256 public totalAmmTokenWeight;\n\n    // Pool -> keeperGauge\n    EnumerableMapping.AddressToAddressMap private _keeperGauges;\n    // AMM token -> ammGauge\n    EnumerableMapping.AddressToAddressMap private _ammGauges;\n\n    mapping(address => bool) public gauges;\n\n    event NewKeeperWeight(address indexed pool, uint256 newWeight);\n    event NewLpWeight(address indexed pool, uint256 newWeight);\n    event NewAmmTokenWeight(address indexed token, uint256 newWeight);\n\n    modifier onlyGauge() {\n        require(gauges[msg.sender], Error.UNAUTHORIZED_ACCESS);\n        _;\n    }\n\n    constructor(IAddressProvider _addressProvider)\n        Authorization(_addressProvider.getRoleManager())\n    {\n        addressProvider = _addressProvider;\n    }\n\n    function setMinter(address _minter) external onlyGovernance returns (bool) {\n        require(minter == address(0), Error.ADDRESS_ALREADY_SET);\n        require(_minter != address(0), Error.INVALID_MINTER);\n        minter = _minter;\n        return true;\n    }\n\n    /**\n     * @notice Advance the keeper gauge for a pool by on epoch.\n     * @param pool Pool for which the keeper gauge is advanced.\n     * @return `true` if successful.\n     */\n    function advanceKeeperGaugeEpoch(address pool) external onlyGovernance returns (bool) {\n        IKeeperGauge(_keeperGauges.get(pool)).advanceEpoch();\n        return true;\n    }\n\n    /**\n     * @notice Mints BKD tokens.\n     * @param beneficiary Address to receive the tokens.\n     * @param amount Amount of tokens to mint.\n     */\n    function mintRewards(address beneficiary, uint256 amount) external override onlyGauge {\n        Minter(minter).mint(beneficiary, amount);\n    }\n\n    /**\n     * @notice Deactivates the weight-based distribution of keeper inflation.\n     * @dev This can only be done once, when the keeper inflation mechanism is altered.\n     * @return `true` if successful.\n     */\n    function deactivateWeightBasedKeeperDistribution() external onlyGovernance returns (bool) {\n        require(!weightBasedKeeperDistributionDeactivated, \"Weight-based dist. deactivated.\");\n        address[] memory liquidityPools = addressProvider.allPools();\n        uint256 length = liquidityPools.length;\n        for (uint256 i = 0; i < length; i++) {\n            _removeKeeperGauge(address(liquidityPools[i]));\n        }\n        weightBasedKeeperDistributionDeactivated = true;\n        return true;\n    }\n\n    /**\n     * @notice Checkpoints all gauges.\n     * @dev This is mostly used upon inflation rate updates.\n     * @return `true` if successful.\n     */\n    function checkpointAllGauges() external override returns (bool) {\n        uint256 length = _keeperGauges.length();\n        for (uint256 i = 0; i < length; i++) {\n            IKeeperGauge(_keeperGauges.valueAt(i)).poolCheckpoint();\n        }\n        address[] memory stakerVaults = addressProvider.allStakerVaults();\n        for (uint256 i = 0; i < stakerVaults.length; i++) {\n            IStakerVault(stakerVaults[i]).poolCheckpoint();\n        }\n\n        length = _ammGauges.length();\n        for (uint256 i = 0; i < length; i++) {\n            IAmmGauge(_ammGauges.valueAt(i)).poolCheckpoint();\n        }\n        return true;\n    }\n\n    /**\n     * @notice Prepare update of a keeper pool weight (with time delay enforced).\n     * @param pool Pool to update the keeper weight for.\n     * @param newPoolWeight New weight for the keeper inflation for the pool.\n     * @return `true` if successful.\n     */\n    function prepareKeeperPoolWeight(address pool, uint256 newPoolWeight)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        require(_keeperGauges.contains(pool), Error.INVALID_ARGUMENT);\n        bytes32 key = _getKeeperGaugeKey(pool);\n        _prepare(key, newPoolWeight);\n        return true;\n    }\n\n    /**\n     * @notice Execute update of keeper pool weight (with time delay enforced).\n     * @param pool Pool to execute the keeper weight update for.\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New keeper pool weight.\n     */\n    function executeKeeperPoolWeight(address pool) external override returns (uint256) {\n        bytes32 key = _getKeeperGaugeKey(pool);\n        _executeKeeperPoolWeight(key, pool, isInflationWeightManager(msg.sender));\n        return currentUInts256[key];\n    }\n\n    /**\n     * @notice Prepare update of a batch of keeperGauge weights (with time delay enforced).\n     * @dev Each entry in the pools array corresponds to an entry in the weights array.\n     * @param pools Pools to update the keeper weight for.\n     * @param weights New weights for the keeper inflation for the pools.\n     * @return `true` if successful.\n     */\n    function batchPrepareKeeperPoolWeights(address[] calldata pools, uint256[] calldata weights)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        uint256 length = pools.length;\n        require(length == weights.length, Error.INVALID_ARGUMENT);\n        bytes32 key;\n        for (uint256 i = 0; i < length; i++) {\n            require(_keeperGauges.contains(pools[i]), Error.INVALID_ARGUMENT);\n            key = _getKeeperGaugeKey(pools[i]);\n            _prepare(key, weights[i]);\n        }\n        return true;\n    }\n\n    function whitelistGauge(address gauge) external onlyRole(Roles.CONTROLLER) {\n        gauges[gauge] = true;\n    }\n\n    /**\n     * @notice Execute weight updates for a batch of _keeperGauges.\n     * @param pools Pools to execute the keeper weight updates for.\n     * @return `true` if successful.\n     */\n    function batchExecuteKeeperPoolWeights(address[] calldata pools)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)\n        returns (bool)\n    {\n        uint256 length = pools.length;\n        bytes32 key;\n        for (uint256 i = 0; i < length; i++) {\n            key = _getKeeperGaugeKey(pools[i]);\n            _executeKeeperPoolWeight(key, pools[i], isInflationWeightManager(msg.sender));\n        }\n        return true;\n    }\n\n    function removeStakerVaultFromInflation(address stakerVault, address lpToken)\n        external\n        onlyRole(Roles.CONTROLLER)\n    {\n        bytes32 key = _getLpStakerVaultKey(stakerVault);\n        _prepare(key, 0);\n        _executeLpPoolWeight(key, lpToken, stakerVault, true);\n    }\n\n    /**\n     * @notice Prepare update of a lp pool weight (with time delay enforced).\n     * @param lpToken LP token to update the weight for.\n     * @param newPoolWeight New LP inflation weight.\n     * @return `true` if successful.\n     */\n    function prepareLpPoolWeight(address lpToken, uint256 newPoolWeight)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)\n        returns (bool)\n    {\n        address stakerVault = addressProvider.getStakerVault(lpToken);\n        // Require both that gauge is registered and that pool is still in action\n        require(gauges[IStakerVault(stakerVault).getLpGauge()], Error.GAUGE_DOES_NOT_EXIST);\n        _ensurePoolExists(lpToken);\n        bytes32 key = _getLpStakerVaultKey(stakerVault);\n        _prepare(key, newPoolWeight);\n        return true;\n    }\n\n    /**\n     * @notice Execute update of lp pool weight (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return New lp pool weight.\n     */\n    function executeLpPoolWeight(address lpToken) external override returns (uint256) {\n        address stakerVault = addressProvider.getStakerVault(lpToken);\n        // Require both that gauge is registered and that pool is still in action\n        require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND);\n        _ensurePoolExists(lpToken);\n        bytes32 key = _getLpStakerVaultKey(stakerVault);\n        _executeLpPoolWeight(key, lpToken, stakerVault, isInflationWeightManager(msg.sender));\n        return currentUInts256[key];\n    }\n\n    /**\n     * @notice Prepare update of a batch of LP token weights (with time delay enforced).\n     * @dev Each entry in the lpTokens array corresponds to an entry in the weights array.\n     * @param lpTokens LpTokens to update the inflation weight for.\n     * @param weights New weights for the inflation for the LpTokens.\n     * @return `true` if successful.\n     */\n    function batchPrepareLpPoolWeights(address[] calldata lpTokens, uint256[] calldata weights)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)\n        returns (bool)\n    {\n        uint256 length = lpTokens.length;\n        require(length == weights.length, \"Invalid length of arguments\");\n        bytes32 key;\n        for (uint256 i = 0; i < length; i++) {\n            address stakerVault = addressProvider.getStakerVault(lpTokens[i]);\n            // Require both that gauge is registered and that pool is still in action\n            require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND);\n            _ensurePoolExists(lpTokens[i]);\n            key = _getLpStakerVaultKey(stakerVault);\n            _prepare(key, weights[i]);\n        }\n        return true;\n    }\n\n    /**\n     * @notice Execute weight updates for a batch of LpTokens.\n     * @dev If this is called by the INFLATION_MANAGER role address, no time delay is enforced.\n     * @param lpTokens LpTokens to execute the weight updates for.\n     * @return `true` if successful.\n     */\n    function batchExecuteLpPoolWeights(address[] calldata lpTokens)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)\n        returns (bool)\n    {\n        uint256 length = lpTokens.length;\n        for (uint256 i = 0; i < length; i++) {\n            address lpToken = lpTokens[i];\n            address stakerVault = addressProvider.getStakerVault(lpToken);\n            // Require both that gauge is registered and that pool is still in action\n            require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND);\n            _ensurePoolExists(lpToken);\n            bytes32 key = _getLpStakerVaultKey(stakerVault);\n            _executeLpPoolWeight(key, lpToken, stakerVault, isInflationWeightManager(msg.sender));\n        }\n        return true;\n    }\n\n    /**\n     * @notice Prepare an inflation weight update for an AMM token (with time delay enforced).\n     * @param token AMM token to update the weight for.\n     * @param newTokenWeight New AMM token inflation weight.\n     * @return `true` if successful.\n     */\n    function prepareAmmTokenWeight(address token, uint256 newTokenWeight)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)\n        returns (bool)\n    {\n        require(_ammGauges.contains(token), \"amm gauge not found\");\n        bytes32 key = _getAmmGaugeKey(token);\n        _prepare(key, newTokenWeight);\n        return true;\n    }\n\n    /**\n     * @notice Execute update of lp pool weight (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New lp pool weight.\n     */\n    function executeAmmTokenWeight(address token) external override returns (uint256) {\n        bytes32 key = _getAmmGaugeKey(token);\n        _executeAmmTokenWeight(token, key, isInflationWeightManager(msg.sender));\n        return currentUInts256[key];\n    }\n\n    /**\n     * @notice Registers a pool's strategy with the stakerVault of the pool where the strategy deposits.\n     * @dev This simply avoids the strategy accumulating tokens in the deposit pool.\n     * @param depositStakerVault StakerVault of the pool where the strategy deposits.\n     * @param strategyPool The pool of the strategy to register (avoids blacklisting other addresses).\n     * @return `true` if successful.\n     */\n    function addStrategyToDepositStakerVault(address depositStakerVault, address strategyPool)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        IVault _vault = ILiquidityPool(strategyPool).getVault();\n        IStakerVault(depositStakerVault).addStrategy(address(_vault.getStrategy()));\n        return true;\n    }\n\n    /**\n     * @notice Prepare update of a batch of AMM token weights (with time delay enforced).\n     * @dev Each entry in the tokens array corresponds to an entry in the weights array.\n     * @param tokens AMM tokens to update the inflation weight for.\n     * @param weights New weights for the inflation for the AMM tokens.\n     * @return `true` if successful.\n     */\n    function batchPrepareAmmTokenWeights(address[] calldata tokens, uint256[] calldata weights)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)\n        returns (bool)\n    {\n        uint256 length = tokens.length;\n        bytes32 key;\n        require(length == weights.length, \"Invalid length of arguments\");\n        for (uint256 i = 0; i < length; i++) {\n            require(_ammGauges.contains(tokens[i]), \"amm gauge not found\");\n            key = _getAmmGaugeKey(tokens[i]);\n            _prepare(key, weights[i]);\n        }\n        return true;\n    }\n\n    /**\n     * @notice Execute weight updates for a batch of AMM tokens.\n     * @dev If this is called by the INFLATION_MANAGER role address, no time delay is enforced.\n     * @param tokens AMM tokens to execute the weight updates for.\n     * @return `true` if successful.\n     */\n    function batchExecuteAmmTokenWeights(address[] calldata tokens)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)\n        returns (bool)\n    {\n        uint256 length = tokens.length;\n        bool isWeightManager = isInflationWeightManager(msg.sender);\n        bytes32 key;\n        address token;\n        for (uint256 i = 0; i < length; i++) {\n            token = tokens[i];\n            key = _getAmmGaugeKey(token);\n            _executeAmmTokenWeight(token, key, isWeightManager);\n        }\n        return true;\n    }\n\n    /**\n     * @notice Sets the KeeperGauge for a pool.\n     * @dev Multiple pools can have the same KeeperGauge.\n     * @param pool Address of pool to set the KeeperGauge for.\n     * @param _keeperGauge Address of KeeperGauge.\n     * @return `true` if successful.\n     */\n    function setKeeperGauge(address pool, address _keeperGauge)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        uint256 length = _keeperGauges.length();\n        bool keeperGaugeExists = false;\n        for (uint256 i = 0; i < length; i++) {\n            if (address(_keeperGauges.valueAt(i)) == _keeperGauge) {\n                keeperGaugeExists = true;\n                break;\n            }\n        }\n        // Check to make sure that once weight-based dist is deactivated, only one gauge can exist\n        if (!keeperGaugeExists && weightBasedKeeperDistributionDeactivated && length >= 1) {\n            return false;\n        }\n        (bool exists, address keeperGauge) = _keeperGauges.tryGet(pool);\n        require(!exists || keeperGauge != _keeperGauge, Error.INVALID_ARGUMENT);\n\n        if (exists && !IKeeperGauge(keeperGauge).killed()) {\n            IKeeperGauge(keeperGauge).poolCheckpoint();\n            IKeeperGauge(keeperGauge).kill();\n        }\n        _keeperGauges.set(pool, _keeperGauge);\n        gauges[_keeperGauge] = true;\n        return true;\n    }\n\n    function removeKeeperGauge(address pool) external onlyGovernance returns (bool) {\n        _removeKeeperGauge(pool);\n        return true;\n    }\n\n    /**\n     * @notice Sets the AmmGauge for a particular AMM token.\n     * @param token Address of the amm token.\n     * @param _ammGauge Address of AmmGauge.\n     * @return `true` if successful.\n     */\n    function setAmmGauge(address token, address _ammGauge)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        require(IAmmGauge(_ammGauge).isAmmToken(token), Error.ADDRESS_NOT_WHITELISTED);\n        uint256 length = _ammGauges.length();\n        for (uint256 i = 0; i < length; i++) {\n            if (address(_ammGauges.valueAt(i)) == _ammGauge) {\n                return false;\n            }\n        }\n        if (_ammGauges.contains(token)) {\n            address ammGauge = _ammGauges.get(token);\n            IAmmGauge(ammGauge).poolCheckpoint();\n            IAmmGauge(ammGauge).kill();\n        }\n        _ammGauges.set(token, _ammGauge);\n        gauges[_ammGauge] = true;\n        return true;\n    }\n\n    function removeAmmGauge(address token) external onlyGovernance returns (bool) {\n        if (!_ammGauges.contains(token)) return false;\n        address ammGauge = _ammGauges.get(token);\n        bytes32 key = _getAmmGaugeKey(token);\n        _prepare(key, 0);\n        _executeAmmTokenWeight(token, key, true);\n        IAmmGauge(ammGauge).kill();\n        _ammGauges.remove(token);\n        // Do not delete from the gauges map to allow claiming of remaining balances\n        emit AmmGaugeDelisted(token, ammGauge);\n        return true;\n    }\n\n    function addGaugeForVault(address lpToken) external override returns (bool) {\n        IStakerVault _stakerVault = IStakerVault(msg.sender);\n        require(addressProvider.isStakerVault(msg.sender, lpToken), Error.UNAUTHORIZED_ACCESS);\n        address lpGauge = _stakerVault.getLpGauge();\n        require(lpGauge != address(0), Error.GAUGE_DOES_NOT_EXIST);\n        gauges[lpGauge] = true;\n        return true;\n    }\n\n    function getAllAmmGauges() external view override returns (address[] memory) {\n        return _ammGauges.valuesArray();\n    }\n\n    function getLpRateForStakerVault(address stakerVault) external view override returns (uint256) {\n        if (minter == address(0) || totalLpPoolWeight == 0) {\n            return 0;\n        }\n\n        bytes32 key = _getLpStakerVaultKey(stakerVault);\n        uint256 lpInflationRate = Minter(minter).getLpInflationRate();\n        uint256 poolInflationRate = (currentUInts256[key] * lpInflationRate) / totalLpPoolWeight;\n\n        return poolInflationRate;\n    }\n\n    function getKeeperRateForPool(address pool) external view override returns (uint256) {\n        if (minter == address(0)) {\n            return 0;\n        }\n        uint256 keeperInflationRate = Minter(minter).getKeeperInflationRate();\n        // After deactivation of weight based dist, KeeperGauge handles the splitting\n        if (weightBasedKeeperDistributionDeactivated) return keeperInflationRate;\n        if (totalKeeperPoolWeight == 0) return 0;\n        bytes32 key = _getKeeperGaugeKey(pool);\n        uint256 poolInflationRate = (currentUInts256[key] * keeperInflationRate) /\n            totalKeeperPoolWeight;\n        return poolInflationRate;\n    }\n\n    function getAmmRateForToken(address token) external view override returns (uint256) {\n        if (minter == address(0) || totalAmmTokenWeight == 0) {\n            return 0;\n        }\n        bytes32 key = _getAmmGaugeKey(token);\n        uint256 ammInflationRate = Minter(minter).getAmmInflationRate();\n        uint256 ammTokenInflationRate = (currentUInts256[key] * ammInflationRate) /\n            totalAmmTokenWeight;\n        return ammTokenInflationRate;\n    }\n\n    //TOOD: See if this is still needed somewhere\n    function getKeeperWeightForPool(address pool) external view override returns (uint256) {\n        bytes32 key = _getKeeperGaugeKey(pool);\n        return currentUInts256[key];\n    }\n\n    function getAmmWeightForToken(address token) external view override returns (uint256) {\n        bytes32 key = _getAmmGaugeKey(token);\n        return currentUInts256[key];\n    }\n\n    function getLpPoolWeight(address lpToken) external view override returns (uint256) {\n        address stakerVault = addressProvider.getStakerVault(lpToken);\n        bytes32 key = _getLpStakerVaultKey(stakerVault);\n        return currentUInts256[key];\n    }\n\n    function getKeeperGaugeForPool(address pool) external view override returns (address) {\n        (, address keeperGauge) = _keeperGauges.tryGet(pool);\n        return keeperGauge;\n    }\n\n    function getAmmGaugeForToken(address token) external view override returns (address) {\n        (, address ammGauge) = _ammGauges.tryGet(token);\n        return ammGauge;\n    }\n\n    /**\n     * @notice Check if an account is governance proxy.\n     * @param account Address to check.\n     * @return `true` if account is governance proxy.\n     */\n    function isInflationWeightManager(address account) public view override returns (bool) {\n        return _roleManager().hasRole(Roles.INFLATION_MANAGER, account);\n    }\n\n    function _executeKeeperPoolWeight(\n        bytes32 key,\n        address pool,\n        bool isWeightManager\n    ) internal returns (bool) {\n        IKeeperGauge(_keeperGauges.get(pool)).poolCheckpoint();\n        totalKeeperPoolWeight = totalKeeperPoolWeight - currentUInts256[key] + pendingUInts256[key];\n        totalKeeperPoolWeight = totalKeeperPoolWeight > 0 ? totalKeeperPoolWeight : 0;\n        isWeightManager ? _setConfig(key, pendingUInts256[key]) : _executeUInt256(key);\n        emit NewKeeperWeight(pool, currentUInts256[key]);\n        return true;\n    }\n\n    function _executeLpPoolWeight(\n        bytes32 key,\n        address lpToken,\n        address stakerVault,\n        bool isWeightManager\n    ) internal returns (bool) {\n        IStakerVault(stakerVault).poolCheckpoint();\n        totalLpPoolWeight = totalLpPoolWeight - currentUInts256[key] + pendingUInts256[key];\n        totalLpPoolWeight = totalLpPoolWeight > 0 ? totalLpPoolWeight : 0;\n        isWeightManager ? _setConfig(key, pendingUInts256[key]) : _executeUInt256(key);\n        emit NewLpWeight(lpToken, currentUInts256[key]);\n        return true;\n    }\n\n    function _executeAmmTokenWeight(\n        address token,\n        bytes32 key,\n        bool isWeightManager\n    ) internal returns (bool) {\n        IAmmGauge(_ammGauges.get(token)).poolCheckpoint();\n        totalAmmTokenWeight = totalAmmTokenWeight - currentUInts256[key] + pendingUInts256[key];\n        totalAmmTokenWeight = totalAmmTokenWeight > 0 ? totalAmmTokenWeight : 0;\n        isWeightManager ? _setConfig(key, pendingUInts256[key]) : _executeUInt256(key);\n        // Do pool checkpoint to update the pool integrals\n        emit NewAmmTokenWeight(token, currentUInts256[key]);\n        return true;\n    }\n\n    function _removeKeeperGauge(address pool) internal {\n        address keeperGauge = _keeperGauges.get(pool);\n        bytes32 key = _getKeeperGaugeKey(pool);\n        _prepare(key, 0);\n        _executeKeeperPoolWeight(key, pool, true);\n        _keeperGauges.remove(pool"
    }
  ]
}