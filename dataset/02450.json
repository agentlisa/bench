{
  "Title": "H-4: Adversary can permanently break percentage tier bounties by funding certain ERC20 tokens then refunding",
  "Content": "# Issue H-4: Adversary can permanently break percentage tier bounties by funding certain ERC20 tokens then refunding \n\nSource: https://github.com/sherlock-audit/2023-02-openq-judging/issues/267 \n\n## Found by \nrvierdiiev, 0x52, bin2chen, TrungOre, cccz, tsvetanovv, unforgiven, ctf\\_sec\n\n## Summary\n\nSome ERC20 tokens don't support 0 value transfers. An adversary can abuse this by adding it to a percentage tier bounty then refunding it. This is because after the refund the token will still be on the list of tokens to distribute but it will have a value saved of 0. This means that no matter what it will always try to transfer 0 token and this will always revert because the specified token doesn't support zero transfers.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-02-openq/blob/main/contracts/Bounty/Implementations/TieredPercentageBountyV1.sol#L123-L136\n\nTieredPercentageBountyV1#closeCompetition set the final fundingTotals for each token. If a token has no balance then the fundingTotals for that token will be zero.\n\nhttps://github.com/sherlock-audit/2023-02-openq/blob/main/contracts/Bounty/Implementations/TieredPercentageBountyV1.sol#L104-L120\n\nFor each token in tokenAddresses it will send the claimedBalance to the claimant. If fundingTotal is 0 then it will attempt to call transfer with an amount of 0. Some ERC20 tokens will revert on transfers like this. \n\nAn adversary can purposefully trigger these conditions by making a deposit with ERC20 token that has this problem. This will add the ERC20 token to tokenAddresses and cause the contract to try to send 0 when making a payout. Payouts will become completely bricked, with no way to recover since fundingTotals can't be set anywhere else.\n\nSubmitting as high because it can be used in conjunction with methods of breaking refunds to permanently trap user funds.\n\n## Impact\n\nPayouts are permanently bricked\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-openq/blob/main/contracts/Bounty/Implementations/TieredPercentageBountyV1.sol#L104-L120\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd two fixes:\n\n1) If a deposit is refunded and the contract has no tokens left then remove that token from the list of tokens\n2) Add a condition to _transferERC20 that only transfers if _volume != 0\n\n## Discussion\n\n**FlacoJones**\n\nValid. Will fix with an explicity token whitelist and requiring funder == issuer\n\n**FlacoJones**\n\nhttps://github.com/OpenQDev/OpenQ-Contracts/pull/112\n\nand \n\nhttps://github.com/OpenQDev/OpenQ-Contracts/pull/113\n\nand \n\nhttps://github.com/OpenQDev/OpenQ-Contracts/pull/116\n\n**kiseln**\n\nEscalate for 27 USDC\n\n> Some ERC20 tokens don't support 0 value transfers\n\nThere are no relevant tokens that revert on 0 value transfers. `LEND` is often provided as an example, however, it was discontinued in 2020 and is supposed to be migrated to AAVE https://docs.aave.com/faq/migration-and-staking. I'd say there is 0 chance this token is whitelisted as a valid bounty token by the protocol owners.\n\nI would consider `LEND` in the same category as any invalid/malicious token that can be added in a permissionless way, in which case this group of issues is a duplicate of #62 \n\n\n**sherlock-admin**\n\n > Escalate for 27 USDC\n> \n> > Some ERC20 tokens don't support 0 value transfers\n> \n> There are no relevant tokens that revert on 0 value transfers. `LEND` is often provided as an example, however, it was discontinued in 2020 and is supposed to be migrated to AAVE https://docs.aave.com/faq/migration-and-staking. I'd say there is 0 chance this token is whitelisted as a valid bounty token by the protocol owners.\n> \n> I would consider `LEND` in the same category as any invalid/malicious token that can be added in a permissionless way, in which case this group of issues is a duplicate of #62 \n> \n\nYou've created a valid escalation for 27 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation rejected.\n\nProtocol signaled they were planning to use `any` token in this protocol, reverting on 0 transfer is uncommon but not unlikely to happen on a legit token.\n\n**sherlock-admin**\n\n> Escalation rejected.\n> \n> Protocol signaled they were planning to use `any` token in this protocol, reverting on 0 transfer is uncommon but not unlikely to happen on a legit token.\n\nThis issue's escalations have been rejected!\n\nWatsons who escalated this issue will have their escalation amount deducted from their next payout.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/39",
  "Code": [
    {
      "filename": "contracts/Bounty/Implementations/TieredPercentageBountyV1.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport '../Storage/TieredPercentageBountyStorage.sol';\n\n/// @title TieredPercentageBountyV1\n/// @notice TieredPercentageBountyV1 is a bounty implementation contract for single contributor, single payout circumstances\n/// @dev TieredPercentageBountyV1 -> TieredPercentageBountyStorageV1 -> TieredBountyCore -> TieredBountyStorageCore -> (BountyCore -> BountyStorageCore) -> (Third Party Deps + Custom )\n/// @dev Do not add any new storage variables here. Put them in a TieredPercentageBountyStorageV# and release new implementation\ncontract TieredPercentageBountyV1 is TieredPercentageBountyStorageV1 {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address payable;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    constructor() {}\n\n    /// @notice Initializes a bounty proxy with initial state\n    /// @param _bountyId The unique bounty identifier\n    /// @param _issuer The sender of the mint bounty transaction\n    /// @param _organization The organization associated with the bounty\n    /// @param _openQ The OpenQProxy address\n    /// @param _claimManager The Claim Manager proxy address\n    /// @param _depositManager The Deposit Manager proxy address\n    /// @param _operation The ABI encoded data determining the type of bounty being initialized and associated data\n    /// @dev see IBountyCore.initialize.(_operation) for _operation ABI encoding schema for TIERED PERCENTAGE\n    function initialize(\n        string memory _bountyId,\n        address _issuer,\n        string memory _organization,\n        address _openQ,\n        address _claimManager,\n        address _depositManager,\n        OpenQDefinitions.InitOperation memory _operation\n    ) external initializer {\n        require(bytes(_bountyId).length != 0, Errors.NO_EMPTY_BOUNTY_ID);\n        require(bytes(_organization).length != 0, Errors.NO_EMPTY_ORGANIZATION);\n\n        __ReentrancyGuard_init();\n\n        __OnlyOpenQ_init(_openQ);\n        __ClaimManagerOwnable_init(_claimManager);\n        __DepositManagerOwnable_init(_depositManager);\n\n        bountyId = _bountyId;\n        issuer = _issuer;\n        organization = _organization;\n        bountyCreatedTime = block.timestamp;\n        nftDepositLimit = 5;\n\n        (\n            uint256[] memory _payoutSchedule,\n            bool _hasFundingGoal,\n            address _fundingToken,\n            uint256 _fundingGoal,\n            bool _invoiceRequired,\n            bool _kycRequired,\n            bool _supportingDocumentsRequired,\n            string memory _issuerExternalUserId,\n            ,\n\n        ) = abi.decode(\n                _operation.data,\n                (\n                    uint256[],\n                    bool,\n                    address,\n                    uint256,\n                    bool,\n                    bool,\n                    bool,\n                    string,\n                    string,\n                    string\n                )\n            );\n\n        uint256 sum;\n        for (uint256 i = 0; i < _payoutSchedule.length; i++) {\n            sum += _payoutSchedule[i];\n        }\n        require(sum == 100, Errors.PAYOUT_SCHEDULE_MUST_ADD_TO_100);\n        payoutSchedule = _payoutSchedule;\n\n        bountyType = OpenQDefinitions.TIERED_PERCENTAGE;\n        hasFundingGoal = _hasFundingGoal;\n        fundingToken = _fundingToken;\n        fundingGoal = _fundingGoal;\n        invoiceRequired = _invoiceRequired;\n        kycRequired = _kycRequired;\n        supportingDocumentsRequired = _supportingDocumentsRequired;\n        issuerExternalUserId = _issuerExternalUserId;\n\n        // Initialize metadata arrays to same number of tiers\n        tierWinners = new string[](_payoutSchedule.length);\n        invoiceComplete = new bool[](_payoutSchedule.length);\n        supportingDocumentsComplete = new bool[](_payoutSchedule.length);\n    }\n\n    /// @notice Transfers the tiered percentage of the token balance of _tokenAddress from bounty to _payoutAddress\n    /// @param _payoutAddress The destination address for the fund\n    /// @param _tier The ordinal of the claimant (e.g. 1st place, 2nd place)\n    /// @param _tokenAddress The token address being claimed\n    /// @return Volume of claimed token payout\n    function claimTiered(\n        address _payoutAddress,\n        uint256 _tier,\n        address _tokenAddress\n    ) external onlyClaimManager nonReentrant returns (uint256) {\n        require(\n            bountyType == OpenQDefinitions.TIERED_PERCENTAGE,\n            Errors.NOT_A_TIERED_BOUNTY\n        );\n        require(!tierClaimed[_tier], Errors.TIER_ALREADY_CLAIMED);\n\n        uint256 claimedBalance = (payoutSchedule[_tier] *\n            fundingTotals[_tokenAddress]) / 100;\n\n        _transferToken(_tokenAddress, claimedBalance, _payoutAddress);\n        return claimedBalance;\n    }\n\n    /// @notice Similar to close() for single priced bounties. closeCompetition() freezes the current funds for the competition.\n    function closeCompetition() external onlyClaimManager {\n        require(\n            status == OpenQDefinitions.OPEN,\n            Errors.CONTRACT_ALREADY_CLOSED\n        );\n\n        status = OpenQDefinitions.CLOSED;\n        bountyClosedTime = block.timestamp;\n\n        for (uint256 i = 0; i < getTokenAddresses().length; i++) {\n            address _tokenAddress = getTokenAddresses()[i];\n            fundingTotals[_tokenAddress] = getTokenBalance(_tokenAddress);\n        }\n    }\n\n    /// @notice Sets the payout schedule\n    /// @notice There is no tokenAddress needed here - payouts on percentage tiered bounties is a percentage of whatever is deposited on the contract\n    /// @param _payoutSchedule An array of payout volumes for each tier\n    function setPayoutSchedule(uint256[] calldata _payoutSchedule)\n        external\n        onlyOpenQ\n    {\n        require(\n            bountyType == OpenQDefinitions.TIERED_PERCENTAGE,\n            Errors.NOT_A_TIERED_BOUNTY\n        );\n        uint256 sum;\n        for (uint256 i = 0; i < _payoutSchedule.length; i++) {\n            sum += _payoutSchedule[i];\n        }\n        require(sum == 100, Errors.PAYOUT_SCHEDULE_MUST_ADD_TO_100);\n\n        payoutSchedule = _payoutSchedule;\n\n        // Resize metadata arrays and copy current members to new array\n        // NOTE: If resizing to fewer tiers than previously, the final indexes will be removed\n        string[] memory newTierWinners = new string[](payoutSchedule.length);\n        bool[] memory newInvoiceComplete = new bool[](payoutSchedule.length);\n        bool[] memory newSupportingDocumentsCompleted = new bool[](\n            payoutSchedule.length\n        );\n\n        for (uint256 i = 0; i < tierWinners.length; i++) {\n            newTierWinners[i] = tierWinners[i];\n        }\n        tierWinners = newTierWinners;\n\n        for (uint256 i = 0; i < invoiceComplete.length; i++) {\n            newInvoiceComplete[i] = invoiceComplete[i];\n        }\n        invoiceComplete = newInvoiceComplete;\n\n        for (uint256 i = 0; i < supportingDocumentsComplete.length; i++) {\n            newSupportingDocumentsCompleted[i] = supportingDocumentsComplete[i];\n        }\n        supportingDocumentsComplete = newSupportingDocumentsCompleted;\n    }\n\n    /// @notice receive() method to accept protocol tokens\n    receive() external payable {\n        revert(\n            'Cannot send Ether directly to boutny contract. Please use the BountyV1.receiveFunds() method.'\n        );\n    }\n}"
    },
    {
      "filename": "contracts/Bounty/Implementations/TieredPercentageBountyV1.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport '../Storage/TieredPercentageBountyStorage.sol';\n\n/// @title TieredPercentageBountyV1\n/// @notice TieredPercentageBountyV1 is a bounty implementation contract for single contributor, single payout circumstances\n/// @dev TieredPercentageBountyV1 -> TieredPercentageBountyStorageV1 -> TieredBountyCore -> TieredBountyStorageCore -> (BountyCore -> BountyStorageCore) -> (Third Party Deps + Custom )\n/// @dev Do not add any new storage variables here. Put them in a TieredPercentageBountyStorageV# and release new implementation\ncontract TieredPercentageBountyV1 is TieredPercentageBountyStorageV1 {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address payable;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    constructor() {}\n\n    /// @notice Initializes a bounty proxy with initial state\n    /// @param _bountyId The unique bounty identifier\n    /// @param _issuer The sender of the mint bounty transaction\n    /// @param _organization The organization associated with the bounty\n    /// @param _openQ The OpenQProxy address\n    /// @param _claimManager The Claim Manager proxy address\n    /// @param _depositManager The Deposit Manager proxy address\n    /// @param _operation The ABI encoded data determining the type of bounty being initialized and associated data\n    /// @dev see IBountyCore.initialize.(_operation) for _operation ABI encoding schema for TIERED PERCENTAGE\n    function initialize(\n        string memory _bountyId,\n        address _issuer,\n        string memory _organization,\n        address _openQ,\n        address _claimManager,\n        address _depositManager,\n        OpenQDefinitions.InitOperation memory _operation\n    ) external initializer {\n        require(bytes(_bountyId).length != 0, Errors.NO_EMPTY_BOUNTY_ID);\n        require(bytes(_organization).length != 0, Errors.NO_EMPTY_ORGANIZATION);\n\n        __ReentrancyGuard_init();\n\n        __OnlyOpenQ_init(_openQ);\n        __ClaimManagerOwnable_init(_claimManager);\n        __DepositManagerOwnable_init(_depositManager);\n\n        bountyId = _bountyId;\n        issuer = _issuer;\n        organization = _organization;\n        bountyCreatedTime = block.timestamp;\n        nftDepositLimit = 5;\n\n        (\n            uint256[] memory _payoutSchedule,\n            bool _hasFundingGoal,\n            address _fundingToken,\n            uint256 _fundingGoal,\n            bool _invoiceRequired,\n            bool _kycRequired,\n            bool _supportingDocumentsRequired,\n            string memory _issuerExternalUserId,\n            ,\n\n        ) = abi.decode(\n                _operation.data,\n                (\n                    uint256[],\n                    bool,\n                    address,\n                    uint256,\n                    bool,\n                    bool,\n                    bool,\n                    string,\n                    string,\n                    string\n                )\n            );\n\n        uint256 sum;\n        for (uint256 i = 0; i < _payoutSchedule.length; i++) {\n            sum += _payoutSchedule[i];\n        }\n        require(sum == 100, Errors.PAYOUT_SCHEDULE_MUST_ADD_TO_100);\n        payoutSchedule = _payoutSchedule;\n\n        bountyType = OpenQDefinitions.TIERED_PERCENTAGE;\n        hasFundingGoal = _hasFundingGoal;\n        fundingToken = _fundingToken;\n        fundingGoal = _fundingGoal;\n        invoiceRequired = _invoiceRequired;\n        kycRequired = _kycRequired;\n        supportingDocumentsRequired = _supportingDocumentsRequired;\n        issuerExternalUserId = _issuerExternalUserId;\n\n        // Initialize metadata arrays to same number of tiers\n        tierWinners = new string[](_payoutSchedule.length);\n        invoiceComplete = new bool[](_payoutSchedule.length);\n        supportingDocumentsComplete = new bool[](_payoutSchedule.length);\n    }\n\n    /// @notice Transfers the tiered percentage of the token balance of _tokenAddress from bounty to _payoutAddress\n    /// @param _payoutAddress The destination address for the fund\n    /// @param _tier The ordinal of the claimant (e.g. 1st place, 2nd place)\n    /// @param _tokenAddress The token address being claimed\n    /// @return Volume of claimed token payout\n    function claimTiered(\n        address _payoutAddress,\n        uint256 _tier,\n        address _tokenAddress\n    ) external onlyClaimManager nonReentrant returns (uint256) {\n        require(\n            bountyType == OpenQDefinitions.TIERED_PERCENTAGE,\n            Errors.NOT_A_TIERED_BOUNTY\n        );\n        require(!tierClaimed[_tier], Errors.TIER_ALREADY_CLAIMED);\n\n        uint256 claimedBalance = (payoutSchedule[_tier] *\n            fundingTotals[_tokenAddress]) / 100;\n\n        _transferToken(_tokenAddress, claimedBalance, _payoutAddress);\n        return claimedBalance;\n    }\n\n    /// @notice Similar to close() for single priced bounties. closeCompetition() freezes the current funds for the competition.\n    function closeCompetition() external onlyClaimManager {\n        require(\n            status == OpenQDefinitions.OPEN,\n            Errors.CONTRACT_ALREADY_CLOSED\n        );\n\n        status = OpenQDefinitions.CLOSED;\n        bountyClosedTime = block.timestamp;\n\n        for (uint256 i = 0; i < getTokenAddresses().length; i++) {\n            address _tokenAddress = getTokenAddresses()[i];\n            fundingTotals[_tokenAddress] = getTokenBalance(_tokenAddress);\n        }\n    }\n\n    /// @notice Sets the payout schedule\n    /// @notice There is no tokenAddress needed here - payouts on percentage tiered bounties is a percentage of whatever is deposited on the contract\n    /// @param _payoutSchedule An array of payout volumes for each tier\n    function setPayoutSchedule(uint256[] calldata _payoutSchedule)\n        external\n        onlyOpenQ\n    {\n        require(\n            bountyType == OpenQDefinitions.TIERED_PERCENTAGE,\n            Errors.NOT_A_TIERED_BOUNTY\n        );\n        uint256 sum;\n        for (uint256 i = 0; i < _payoutSchedule.length; i++) {\n            sum += _payoutSchedule[i];\n        }\n        require(sum == 100, Errors.PAYOUT_SCHEDULE_MUST_ADD_TO_100);\n\n        payoutSchedule = _payoutSchedule;\n\n        // Resize metadata arrays and copy current members to new array\n        // NOTE: If resizing to fewer tiers than previously, the final indexes will be removed\n        string[] memory newTierWinners = new string[](payoutSchedule.length);\n        bool[] memory newInvoiceComplete = new bool[](payoutSchedule.length);\n        bool[] memory newSupportingDocumentsCompleted = new bool[](\n            payoutSchedule.length\n        );\n\n        for (uint256 i = 0; i < tierWinners.length; i++) {\n            newTierWinners[i] = tierWinners[i];\n        }\n        tierWinners = newTierWinners;\n\n        for (uint256 i = 0; i < invoiceComplete.length; i++) {\n            newInvoiceComplete[i] = invoiceComplete[i];\n        }\n        invoiceComplete = newInvoiceComplete;\n\n        for (uint256 i = 0; i < supportingDocumentsComplete.length; i++) {\n            newSupportingDocumentsCompleted[i] = supportingDocumentsComplete[i];\n        }\n        supportingDocumentsComplete = newSupportingDocumentsCompleted;\n    }\n\n    /// @notice receive() method to accept protocol tokens\n    receive() external payable {\n        revert(\n            'Cannot send Ether directly to boutny contract. Please use the BountyV1.receiveFunds() method.'\n        );\n    }\n}"
    },
    {
      "filename": "contracts/Bounty/Implementations/TieredPercentageBountyV1.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport '../Storage/TieredPercentageBountyStorage.sol';\n\n/// @title TieredPercentageBountyV1\n/// @notice TieredPercentageBountyV1 is a bounty implementation contract for single contributor, single payout circumstances\n/// @dev TieredPercentageBountyV1 -> TieredPercentageBountyStorageV1 -> TieredBountyCore -> TieredBountyStorageCore -> (BountyCore -> BountyStorageCore) -> (Third Party Deps + Custom )\n/// @dev Do not add any new storage variables here. Put them in a TieredPercentageBountyStorageV# and release new implementation\ncontract TieredPercentageBountyV1 is TieredPercentageBountyStorageV1 {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address payable;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    constructor() {}\n\n    /// @notice Initializes a bounty proxy with initial state\n    /// @param _bountyId The unique bounty identifier\n    /// @param _issuer The sender of the mint bounty transaction\n    /// @param _organization The organization associated with the bounty\n    /// @param _openQ The OpenQProxy address\n    /// @param _claimManager The Claim Manager proxy address\n    /// @param _depositManager The Deposit Manager proxy address\n    /// @param _operation The ABI encoded data determining the type of bounty being initialized and associated data\n    /// @dev see IBountyCore.initialize.(_operation) for _operation ABI encoding schema for TIERED PERCENTAGE\n    function initialize(\n        string memory _bountyId,\n        address _issuer,\n        string memory _organization,\n        address _openQ,\n        address _claimManager,\n        address _depositManager,\n        OpenQDefinitions.InitOperation memory _operation\n    ) external initializer {\n        require(bytes(_bountyId).length != 0, Errors.NO_EMPTY_BOUNTY_ID);\n        require(bytes(_organization).length != 0, Errors.NO_EMPTY_ORGANIZATION);\n\n        __ReentrancyGuard_init();\n\n        __OnlyOpenQ_init(_openQ);\n        __ClaimManagerOwnable_init(_claimManager);\n        __DepositManagerOwnable_init(_depositManager);\n\n        bountyId = _bountyId;\n        issuer = _issuer;\n        organization = _organization;\n        bountyCreatedTime = block.timestamp;\n        nftDepositLimit = 5;\n\n        (\n            uint256[] memory _payoutSchedule,\n            bool _hasFundingGoal,\n            address _fundingToken,\n            uint256 _fundingGoal,\n            bool _invoiceRequired,\n            bool _kycRequired,\n            bool _supportingDocumentsRequired,\n            string memory _issuerExternalUserId,\n            ,\n\n        ) = abi.decode(\n                _operation.data,\n                (\n                    uint256[],\n                    bool,\n                    address,\n                    uint256,\n                    bool,\n                    bool,\n                    bool,\n                    string,\n                    string,\n                    string\n                )\n            );\n\n        uint256 sum;\n        for (uint256 i = 0; i < _payoutSchedule.length; i++) {\n            sum += _payoutSchedule[i];\n        }\n        require(sum == 100, Errors.PAYOUT_SCHEDULE_MUST_ADD_TO_100);\n        payoutSchedule = _payoutSchedule;\n\n        bountyType = OpenQDefinitions.TIERED_PERCENTAGE;\n        hasFundingGoal = _hasFundingGoal;\n        fundingToken = _fundingToken;\n        fundingGoal = _fundingGoal;\n        invoiceRequired = _invoiceRequired;\n        kycRequired = _kycRequired;\n        supportingDocumentsRequired = _supportingDocumentsRequired;\n        issuerExternalUserId = _issuerExternalUserId;\n\n        // Initialize metadata arrays to same number of tiers\n        tierWinners = new string[](_payoutSchedule.length);\n        invoiceComplete = new bool[](_payoutSchedule.length);\n        supportingDocumentsComplete = new bool[](_payoutSchedule.length);\n    }\n\n    /// @notice Transfers the tiered percentage of the token balance of _tokenAddress from bounty to _payoutAddress\n    /// @param _payoutAddress The destination address for the fund\n    /// @param _tier The ordinal of the claimant (e.g. 1st place, 2nd place)\n    /// @param _tokenAddress The token address being claimed\n    /// @return Volume of claimed token payout\n    function claimTiered(\n        address _payoutAddress,\n        uint256 _tier,\n        address _tokenAddress\n    ) external onlyClaimManager nonReentrant returns (uint256) {\n        require(\n            bountyType == OpenQDefinitions.TIERED_PERCENTAGE,\n            Errors.NOT_A_TIERED_BOUNTY\n        );\n        require(!tierClaimed[_tier], Errors.TIER_ALREADY_CLAIMED);\n\n        uint256 claimedBalance = (payoutSchedule[_tier] *\n            fundingTotals[_tokenAddress]) / 100;\n\n        _transferToken(_tokenAddress, claimedBalance, _payoutAddress);\n        return claimedBalance;\n    }\n\n    /// @notice Similar to close() for single priced bounties. closeCompetition() freezes the current funds for the competition.\n    function closeCompetition() external onlyClaimManager {\n        require(\n            status == OpenQDefinitions.OPEN,\n            Errors.CONTRACT_ALREADY_CLOSED\n        );\n\n        status = OpenQDefinitions.CLOSED;\n        bountyClosedTime = block.timestamp;\n\n        for (uint256 i = 0; i < getTokenAddresses().length; i++) {\n            address _tokenAddress = getTokenAddresses()[i];\n            fundingTotals[_tokenAddress] = getTokenBalance(_tokenAddress);\n        }\n    }\n\n    /// @notice Sets the payout schedule\n    /// @notice There is no tokenAddress needed here - payouts on percentage tiered bounties is a percentage of whatever is deposited on the contract\n    /// @param _payoutSchedule An array of payout volumes for each tier\n    function setPayoutSchedule(uint256[] calldata _payoutSchedule)\n        external\n        onlyOpenQ\n    {\n        require(\n            bountyType == OpenQDefinitions.TIERED_PERCENTAGE,\n            Errors.NOT_A_TIERED_BOUNTY\n        );\n        uint256 sum;\n        for (uint256 i = 0; i < _payoutSchedule.length; i++) {\n            sum += _payoutSchedule[i];\n        }\n        require(sum == 100, Errors.PAYOUT_SCHEDULE_MUST_ADD_TO_100);\n\n        payoutSchedule = _payoutSchedule;\n\n        // Resize metadata arrays and copy current members to new array\n        // NOTE: If resizing to fewer tiers than previously, the final indexes will be removed\n        string[] memory newTierWinners = new string[](payoutSchedule.length);\n        bool[] memory newInvoiceComplete = new bool[](payoutSchedule.length);\n        bool[] memory newSupportingDocumentsCompleted = new bool[](\n            payoutSchedule.length\n        );\n\n        for (uint256 i = 0; i < tierWinners.length; i++) {\n            newTierWinners[i] = tierWinners[i];\n        }\n        tierWinners = newTierWinners;\n\n        for (uint256 i = 0; i < invoiceComplete.length; i++) {\n            newInvoiceComplete[i] = invoiceComplete[i];\n        }\n        invoiceComplete = newInvoiceComplete;\n\n        for (uint256 i = 0; i < supportingDocumentsComplete.length; i++) {\n            newSupportingDocumentsCompleted[i] = supportingDocumentsComplete[i];\n        }\n        supportingDocumentsComplete = newSupportingDocumentsCompleted;\n    }\n\n    /// @notice receive() method to accept protocol tokens\n    receive() external payable {\n        revert(\n            'Cannot send Ether directly to boutny contract. Please use the BountyV1.receiveFunds() method.'\n        );\n    }\n}"
    }
  ]
}