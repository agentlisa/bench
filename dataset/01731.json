{
  "Title": "M-8: Malicious trader can bypass utilization buffer",
  "Content": "# Issue M-8: Malicious trader can bypass utilization buffer \n\nSource: https://github.com/sherlock-audit/2023-05-perennial-judging/issues/75 \n\n## Found by \nast3ros, cergyk\n## Summary\nA malicious trader can bypass the Utilisation buffer, and push utilisation to 1 on any product.\n\n## Vulnerability Detail\nPerenial products use a utilization buffer to prevent taker side to DOS maker by taking up all the liquidity:\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial/contracts/product/Product.sol#L547-L556\n\nMakers would not be able to withdraw if utilization would reach 100% because of `takerInvariant` which is enforced during `closeMake`:\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial/contracts/product/Product.sol#L535-L544\n\nA malicious trader can bypass the utilisation buffer by first opening a maker position, open taker position and close previous maker position.\nThe only constraint is that she has to use different accounts to open the maker positions and the taker positions, since perennial doesn't allow to have maker and taker positions on a product simultaneously.\n\nSo here's a concrete example:\n\nLet's say the state of product is `900 USD` on the maker side, `800 USD` on the taker side, which respects the 10% utilization buffer.\n\n### Example\n>Using account 1, Alice opens up a maker position for `100 USD`, bringing maker total to `1000 USD`.\n\n>Using account 2, Alice can open a taker position for `100 USD`, bringing taker to `900 USD`, which respects the 10% utilization buffer still.\n\n>Now using account 1 again, Alice can close her `100 USD` maker position and withdraw collateral, clearing account 1 on perennial completely.\n\n>This brings the utilization to `100%`, since taker = maker = `900 USD`. \n\n>This is allowed, since only `takerInvariant` is checked when closing a maker position, which enforces that utilization ratio is lower than or equal to `100%`.\n\n## Impact\nAny trader can bring the utilization up to 100%, and use that to DoS withdrawals from Products and Balanced vaults for an indefinite amount of time.\nThis is especially critical for vaults, since when any product related to any market is fully utilized, all redeems from the balanced vault are blocked.\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\nIf a safety buffer needs to be enforced for the utilisation of products, it needs to be enforced on closing make positions as well.\n\n\n\n## Discussion\n\n**arjun-io**\n\nThis is a good callout and a valid issue but since the _impact_ existed before this utilization buffer feature was added we disagree with the severity. The utilization buffer is not intended to totally fix the 100% utilization issue against malicious users, but instead provide a buffer in the normal operating case.\n\n**KenzoAgada**\n\nIn addition to the sponsor's comment, also worth noting that a malicious user will not gain anything from doing this.\nIndeed seems like medium severity is more appropriate. Downgrading to medium.\n\n**sherlock-admin**\n\n> Escalate for 10 USDC\n> \n> The assumption here is that Alice can close position immediately. However, in order to close a position Alice needs to wait the settlement and the meanwhile Alice can occur losses or profit. This is not a safe operation for Alice to do. Alice can do this if she is willing to take the risk. I think the utilization buffer works as intented in this scenario, where it forces Alice to create a maker position in order to create a taker position first and since Alice can't withdraw immediately she is subject to her maker positions pnl for at least an oracle version.\n> \n> I think this an invalid issue \n\n    You've deleted an escalation for this issue.\n\n**SergeKireev**\n\n>The assumption here is that Alice can close position immediately. However, in order to close a position Alice needs to wait the settlement and the meanwhile Alice can occur losses or profit. This is not a safe operation for Alice to do. Alice can do this if she is willing to take the risk. I think the utilization buffer works as intented in this scenario, where it forces Alice to create a maker position in order to create a taker position first and since Alice can't withdraw immediately she is subject to her maker positions pnl for at least an oracle version.\n\n>I think this an invalid issue\n\nThe described operation can be done atomically because the invariant `takerInvariant` which is bypassed here checks only next amounts, and so Alice does not in fact need to expose herself to the market (She can just fill all maker capacity before Bob's transaction, and close after the tx and before next settlement)\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial/contracts/product/Product.sol#L535-L544\n\n\n**mstpr**\n\n> > The assumption here is that Alice can close position immediately. However, in order to close a position Alice needs to wait the settlement and the meanwhile Alice can occur losses or profit. This is not a safe operation for Alice to do. Alice can do this if she is willing to take the risk. I think the utilization buffer works as intented in this scenario, where it forces Alice to create a maker position in order to create a taker position first and since Alice can't withdraw immediately she is subject to her maker positions pnl for at least an oracle version.\n> \n> > I think this an invalid issue\n> \n> The described operation can be done atomically because the invariant `takerInvariant` which is bypassed here checks only next amounts, and so Alice does not in fact need to expose herself to the market (She can just fill all maker capacity before Bob's transaction, and close after the tx and before next settlement) https://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial/contracts/product/Product.sol#L535-L544\n\nYou are correct, sorry for the misunderstanding of the scenario you described above. Deleting my escalations comment \n\n**mstpr**\n\nEscalate for 10 USDC\n\nI rethought of the issue and I think this is a low issue.\n\nIssue does not add any benefits to the user and in fact, it is even discouraging for the user to not take this action due to the funding fee increase. Since the funding fee follows a curve model the funding fee will be taken at 100% utilization is quite high and it is not a good thing that any taker would want. There are no funds in danger and there isn't any benefits of doing such thing. \n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> I rethought of the issue and I think this is a low issue.\n> \n> Issue does not add any benefits to the user and in fact, it is even discouraging for the user to not take this action due to the funding fee increase. Since the funding fee follows a curve model the funding fee will be taken at 100% utilization is quite high and it is not a good thing that any taker would want. There are no funds in danger and there isn't any benefits of doing such thing. \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**KenzoAgada**\n\nHmm... Rethinking about the issue, I admit it might not be enough for medium severity. Leaving for Sherlock to decide.\n\n**jacksanford1**\n\nImpact from issue:\n> Any trader can bring the utilization up to 100%, and use that to DoS withdrawals from Products and Balanced vaults for an indefinite amount of time.\n> This is especially critical for vaults, since when any product related to any market is fully utilized, all redeems from the balanced vault are blocked.\n\nBased on Sherlock's DOS rules:\nhttps://docs.sherlock.xyz/audits/judging/judging#some-standards-observed\n\nDoesn't seem like this should be a valid Medium. @cergyk would need to explain how the attack can be profitable for the attacker or show a difference between cost incurred and damage created that is many orders of magnitude. \n\n**SergeKireev**\n\n> @CergyK would need to explain how the attack can be profitable for the attacker or show a difference between cost incurred and damage created that is many orders of magnitude.\n\nDue to the nature of BalancedVault, multiple markets of different nature are linked together. If one is fully utilized, it blocks the BalancedVault for all of the markets as stated in the initial report:\n> This is especially critical for vaults, since when any product related to any market is fully utilized, all redeems from the balanced vault are blocked.\n\nSo there can indeed be a magnitude between cost incurred and damage created. \n\nSuppose Balanced Vault on markets:\n- .$PEPE with 100$ worth of liquidity \n- .$ETH with 1.000.000$ of liquidity\n\nMalicious user Alice would only have to fully utilize 100$ on the .$PEPE market to block 1.000.000$ in redeemable assets on $ETH because the two markets are linked by the BalancedVault\n\n**jacksanford1**\n\nThanks @SergeKireev. Agree in that case the cost could be very low for a DOS of significant magnitude. I don't think it's a High, but it seems like it's worthwhile to make this a Medium. \n\nOpen to arguments from @mstpr on why it should be Low instead. \n\n**jacksanford1**\n\nResult:\nMedium\nHas duplicates \nBased on argument from Serge and no follow-up response from mstpr, leaving this as a Medium. \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [mstpr](https://github.com/sherlock-audit/2023-05-perennial-judging/issues/75/#issuecomment-1615259598): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/79",
  "Code": [
    {
      "filename": "perennial-mono/packages/perennial/contracts/product/Product.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport \"@equilibria/root/control/unstructured/UInitializable.sol\";\nimport \"@equilibria/root/control/unstructured/UReentrancyGuard.sol\";\nimport \"../controller/UControllerProvider.sol\";\nimport \"./UPayoffProvider.sol\";\nimport \"./UParamProvider.sol\";\nimport \"./types/position/AccountPosition.sol\";\nimport \"./types/accumulator/AccountAccumulator.sol\";\n\n/**\n * @title Product\n * @notice Manages logic and state for a single product market.\n * @dev Cloned by the Controller contract to launch new product markets.\n */\ncontract Product is IProduct, UInitializable, UParamProvider, UPayoffProvider, UReentrancyGuard {\n    /// @dev Whether or not the product is closed\n    BoolStorage private constant _closed = BoolStorage.wrap(keccak256(\"equilibria.perennial.Product.closed\"));\n\n    function closed() public view returns (bool) {\n        return _closed.read();\n    }\n\n    /// @dev The name of the product\n    string public name;\n\n    /// @dev The symbol of the product\n    string public symbol;\n\n    /// @dev The individual position state for each account\n    mapping(address => AccountPosition) private _positions;\n\n    /// @dev The global position state for the product\n    VersionedPosition private _position;\n\n    /// @dev The individual accumulator state for each account\n    mapping(address => AccountAccumulator) private _accumulators;\n\n    /// @dev The global accumulator state for the product\n    VersionedAccumulator private _accumulator;\n\n    /**\n     * @notice Initializes the contract state\n     * @param productInfo_ Product initialization params\n     */\n    function initialize(ProductInfo calldata productInfo_) external initializer(1) {\n        __UControllerProvider__initialize(IController(msg.sender));\n        __UPayoffProvider__initialize(productInfo_.oracle, productInfo_.payoffDefinition);\n        __UReentrancyGuard__initialize();\n        __UParamProvider__initialize(\n            productInfo_.maintenance,\n            productInfo_.fundingFee,\n            productInfo_.makerFee,\n            productInfo_.takerFee,\n            productInfo_.positionFee,\n            productInfo_.makerLimit,\n            productInfo_.utilizationCurve\n        );\n\n        name = productInfo_.name;\n        symbol = productInfo_.symbol;\n    }\n\n    /**\n     * @notice Surfaces global settlement externally\n     */\n    function settle() external nonReentrant notPaused {\n        _settle();\n    }\n\n    /**\n     * @notice Core global settlement flywheel\n     * @dev\n     *  a) last settle oracle version\n     *  b) latest pre position oracle version\n     *  c) current oracle version\n     *\n     *  Settles from a->b then from b->c if either interval is non-zero to account for a change\n     *  in position quantity at (b).\n     *\n     *  Syncs each to instantaneously after the oracle update.\n     */\n    function _settle() private returns (IOracleProvider.OracleVersion memory currentOracleVersion) {\n        IController _controller = controller();\n\n        // Get current oracle version\n        currentOracleVersion = _sync();\n\n        // Get latest oracle version\n        uint256 _latestVersion = latestVersion();\n        if (_latestVersion == currentOracleVersion.version) return currentOracleVersion; // short circuit entirely if a == c\n        IOracleProvider.OracleVersion memory latestOracleVersion = atVersion(_latestVersion);\n\n        // Get settle oracle version\n        uint256 _settleVersion = _position.pre.settleVersion(currentOracleVersion.version);\n        IOracleProvider.OracleVersion memory settleOracleVersion = _settleVersion == currentOracleVersion.version\n            ? currentOracleVersion // if b == c, don't re-call provider for oracle version\n            : atVersion(_settleVersion);\n\n        // Initiate\n        _controller.incentivizer().sync(currentOracleVersion);\n        UFixed18 boundedFundingFee = _boundedFundingFee();\n\n        // value a->b\n        UFixed18 accumulatedFee = _accumulator.accumulate(\n            boundedFundingFee, _position, latestOracleVersion, settleOracleVersion);\n\n        // position a->b\n        _position.settle(_latestVersion, settleOracleVersion);\n\n        // Apply any pending fee updates if present\n        _settleFeeUpdates();\n\n        // short-circuit from a->c if b == c\n        if (settleOracleVersion.version != currentOracleVersion.version) {\n            // value b->c\n            accumulatedFee = accumulatedFee.add(\n                _accumulator.accumulate(boundedFundingFee, _position, settleOracleVersion, currentOracleVersion)\n            );\n\n            // position b->c (every accumulator version needs a position stamp)\n            _position.settle(settleOracleVersion.version, currentOracleVersion);\n        }\n\n        // settle collateral\n        _controller.collateral().settleProduct(accumulatedFee);\n\n        emit Settle(settleOracleVersion.version, currentOracleVersion.version);\n    }\n\n    /**\n     * @notice Surfaces account settlement externally\n     * @param account Account to settle\n     */\n    function settleAccount(address account) external nonReentrant notPaused {\n        IOracleProvider.OracleVersion memory currentOracleVersion = _settle();\n        _settleAccount(account, currentOracleVersion);\n    }\n\n    /**\n     * @notice Core account settlement flywheel\n     * @param account Account to settle\n     * @dev\n     *  a) last settle oracle version\n     *  b) latest pre position oracle version\n     *  c) current oracle version\n     *\n     *  Settles from a->b then from b->c if either interval is non-zero to account for a change\n     *  in position quantity at (b).\n     *\n     *  Syncs each to instantaneously after the oracle update.\n     */\n    function _settleAccount(address account, IOracleProvider.OracleVersion memory currentOracleVersion) private {\n        IController _controller = controller();\n\n        // Get latest oracle version\n        if (latestVersion(account) == currentOracleVersion.version) return; // short circuit entirely if a == c\n\n        // Get settle oracle version\n        uint256 _settleVersion = _positions[account].pre.settleVersion(currentOracleVersion.version);\n        IOracleProvider.OracleVersion memory settleOracleVersion = _settleVersion == currentOracleVersion.version\n            ? currentOracleVersion // if b == c, don't re-call provider for oracle version\n            : atVersion(_settleVersion);\n\n        // sync incentivizer before accumulator\n        _controller.incentivizer().syncAccount(account, settleOracleVersion);\n\n        // value a->b\n        Fixed18 accumulated = _accumulators[account].syncTo(\n            _accumulator, _positions[account], settleOracleVersion.version).sum();\n\n        // position a->b\n        _positions[account].settle(settleOracleVersion);\n\n        // short-circuit from a->c if b == c\n        if (settleOracleVersion.version != currentOracleVersion.version) {\n            // sync incentivizer before accumulator\n            _controller.incentivizer().syncAccount(account, currentOracleVersion);\n\n            // value b->c\n            accumulated = accumulated.add(\n                _accumulators[account].syncTo(_accumulator, _positions[account], currentOracleVersion.version).sum()\n            );\n        }\n\n        // settle collateral\n        _controller.collateral().settleAccount(account, accumulated);\n\n        emit AccountSettle(account, settleOracleVersion.version, currentOracleVersion.version);\n    }\n\n    /**\n     * @notice Opens a taker position for `msg.sender`\n     * @param amount Amount of the position to open\n     */\n    function openTake(UFixed18 amount) external {\n        openTakeFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Opens a taker position for `account`. Deducts position fee based on notional value at `latestVersion`\n     * @param account Account to open the position for\n     * @param amount Amount of the position to open\n     */\n    function openTakeFor(address account, UFixed18 amount)\n        public\n        nonReentrant\n        notPaused\n        notClosed\n        onlyAccountOrMultiInvoker(account)\n        settleForAccount(account)\n        maxUtilizationInvariant\n        positionInvariant(account)\n        liquidationInvariant(account)\n        maintenanceInvariant(account)\n    {\n        IOracleProvider.OracleVersion memory latestOracleVersion = atVersion(latestVersion());\n\n        _positions[account].pre.openTake(latestOracleVersion.version, amount);\n        _position.pre.openTake(latestOracleVersion.version, amount);\n\n        UFixed18 positionFee = amount.mul(latestOracleVersion.price.abs()).mul(takerFee());\n        if (!positionFee.isZero()) {\n            controller().collateral().settleAccount(account, Fixed18Lib.from(-1, positionFee));\n            emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        }\n\n        emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        emit TakeOpened(account, latestOracleVersion.version, amount);\n    }\n\n    /**\n     * @notice Closes a taker position for `msg.sender`\n     * @param amount Amount of the position to close\n     */\n    function closeTake(UFixed18 amount) external {\n        closeTakeFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Closes a taker position for `account`. Deducts position fee based on notional value at `latestVersion`\n     * @param account Account to close the position for\n     * @param amount Amount of the position to close\n     */\n    function closeTakeFor(address account, UFixed18 amount)\n        public\n        nonReentrant\n        notPaused\n        onlyAccountOrMultiInvoker(account)\n        settleForAccount(account)\n        closeInvariant(account)\n        liquidationInvariant(account)\n    {\n        _closeTake(account, amount);\n    }\n\n    function _closeTake(address account, UFixed18 amount) private {\n        IOracleProvider.OracleVersion memory latestOracleVersion = atVersion(latestVersion());\n\n        _positions[account].pre.closeTake(latestOracleVersion.version, amount);\n        _position.pre.closeTake(latestOracleVersion.version, amount);\n\n        UFixed18 positionFee = amount.mul(latestOracleVersion.price.abs()).mul(takerFee());\n        if (!positionFee.isZero()) {\n            controller().collateral().settleAccount(account, Fixed18Lib.from(-1, positionFee));\n            emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        }\n\n        emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        emit TakeClosed(account, latestOracleVersion.version, amount);\n    }\n\n    /**\n     * @notice Opens a maker position for `msg.sender`\n     * @param amount Amount of the position to open\n     */\n    function openMake(UFixed18 amount) external {\n        openMakeFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Opens a maker position for `account`. Deducts position fee based on notional value at `latestVersion`\n     * @param account Account to open position for\n     * @param amount Amount of the position to open\n     */\n    function openMakeFor(address account, UFixed18 amount)\n        public\n        nonReentrant\n        notPaused\n        notClosed\n        onlyAccountOrMultiInvoker(account)\n        settleForAccount(account)\n        nonZeroVersionInvariant\n        makerInvariant\n        positionInvariant(account)\n        liquidationInvariant(account)\n        maintenanceInvariant(account)\n    {\n        IOracleProvider.OracleVersion memory latestOracleVersion = atVersion(latestVersion());\n\n        _positions[account].pre.openMake(latestOracleVersion.version, amount);\n        _position.pre.openMake(latestOracleVersion.version, amount);\n\n        UFixed18 positionFee = amount.mul(latestOracleVersion.price.abs()).mul(makerFee());\n        if (!positionFee.isZero()) {\n            controller().collateral().settleAccount(account, Fixed18Lib.from(-1, positionFee));\n            emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        }\n\n        emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        emit MakeOpened(account, latestOracleVersion.version, amount);\n    }\n\n    /**\n     * @notice Closes a maker position for `msg.sender`\n     * @param amount Amount of the position to close\n     */\n    function closeMake(UFixed18 amount) external {\n        closeMakeFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Closes a maker position for `account`. Deducts position fee based on notional value at `latestVersion`\n     * @param account Account to close the position for\n     * @param amount Amount of the position to close\n     */\n    function closeMakeFor(address account, UFixed18 amount)\n        public\n        nonReentrant\n        notPaused\n        onlyAccountOrMultiInvoker(account)\n        settleForAccount(account)\n        takerInvariant\n        closeInvariant(account)\n        liquidationInvariant(account)\n    {\n        _closeMake(account, amount);\n    }\n\n    function _closeMake(address account, UFixed18 amount) private {\n        IOracleProvider.OracleVersion memory latestOracleVersion = atVersion(latestVersion());\n\n        _positions[account].pre.closeMake(latestOracleVersion.version, amount);\n        _position.pre.closeMake(latestOracleVersion.version, amount);\n\n        UFixed18 positionFee = amount.mul(latestOracleVersion.price.abs()).mul(makerFee());\n        if (!positionFee.isZero()) {\n            controller().collateral().settleAccount(account, Fixed18Lib.from(-1, positionFee));\n            emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        }\n\n        emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        emit MakeClosed(account, latestOracleVersion.version, amount);\n    }\n\n    /**\n     * @notice Closes all open and pending positions, locking for liquidation\n     * @dev Only callable by the Collateral contract as part of the liquidation flow\n     * @param account Account to close out\n     */\n    function closeAll(address account) external onlyCollateral notClosed settleForAccount(account) {\n        AccountPosition storage accountPosition = _positions[account];\n        Position memory p = accountPosition.position.next(_positions[account].pre);\n\n        // Close all positions\n        _closeMake(account, p.maker);\n        _closeTake(account, p.taker);\n\n        // Mark liquidation to lock position\n        accountPosition.liquidation = true;\n    }\n\n    /**\n     * @notice Returns the maintenance requirement for `account`\n     * @param account Account to return for\n     * @return The current maintenance requirement\n     */\n    function maintenance(address account) external view returns (UFixed18) {\n        return _positions[account].maintenance();\n    }\n\n    /**\n     * @notice Returns the maintenance requirement for `account` after next settlement\n     * @dev Assumes no price change and no funding, used to protect user from over-opening\n     * @param account Account to return for\n     * @return The next maintenance requirement\n     */\n    function maintenanceNext(address account) external view returns (UFixed18) {\n        return _positions[account].maintenanceNext();\n    }\n\n    /**\n     * @notice Returns whether `account` has a completely zero'd position\n     * @param account Account to return for\n     * @return The the account is closed\n     */\n    function isClosed(address account) external view returns (bool) {\n        return _positions[account].isClosed();\n    }\n\n    /**\n     * @notice Returns whether `account` is currently locked for an in-progress liquidation\n     * @param account Account to return for\n     * @return Whether the account is in liquidation\n     */\n    function isLiquidating(address account) external view returns (bool) {\n        return _positions[account].liquidation;\n    }\n\n    /**\n     * @notice Returns `account`'s current position\n     * @param account Account to return for\n     * @return Current position of the account\n     */\n    function position(address account) external view returns (Position memory) {\n        return _positions[account].position;\n    }\n\n    /**\n     * @notice Returns `account`'s current pending-settlement position\n     * @param account Account to return for\n     * @return Current pre-position of the account\n     */\n    function pre(address account) external view returns (PrePosition memory) {\n        return _positions[account].pre;\n    }\n\n    /**\n     * @notice Returns the global latest settled oracle version\n     * @return Latest settled oracle version of the product\n     */\n    function latestVersion() public view returns (uint256) {\n        return _accumulator.latestVersion;\n    }\n\n    /**\n     * @notice Returns the global position at oracleVersion `oracleVersion`\n     * @dev Only valid for the version at which a global settlement occurred\n     * @param oracleVersion Oracle version to return for\n     * @return Global position at oracle version\n     */\n    function positionAtVersion(uint256 oracleVersion) public view returns (Position memory) {\n        return _position.positionAtVersion(oracleVersion);\n    }\n\n    /**\n     * @notice Returns the current global pending-settlement position\n     * @return Global pending-settlement position\n     */\n    function pre() external view returns (PrePosition memory) {\n        return _position.pre;\n    }\n\n    /**\n     * @notice Returns the global accumulator value at oracleVersion `oracleVersion`\n     * @dev Only valid for the version at which a global settlement occurred\n     * @param oracleVersion Oracle version to return for\n     * @return Global accumulator value at oracle version\n     */\n    function valueAtVersion(uint256 oracleVersion) external view returns (Accumulator memory) {\n        return _accumulator.valueAtVersion(oracleVersion);\n    }\n\n    /**\n     * @notice Returns the global accumulator share at oracleVersion `oracleVersion`\n     * @dev Only valid for the version at which a global settlement occurred\n     * @param oracleVersion Oracle version to return for\n     * @return Global accumulator share at oracle version\n     */\n    function shareAtVersion(uint256 oracleVersion) external view returns (Accumulator memory) {\n        return _accumulator.shareAtVersion(oracleVersion);\n    }\n\n    /**\n     * @notice Returns `account`'s latest settled oracle version\n     * @param account Account to return for\n     * @return Latest settled oracle version of the account\n     */\n    function latestVersion(address account) public view returns (uint256) {\n        return _accumulators[account].latestVersion;\n    }\n\n    /**\n     * @notice Returns The per-second rate based on the provided `position`\n     * @dev Handles 0-maker/taker edge cases\n     * @param position_ Position to base utilization on\n     * @return The per-second rate\n     */\n    function rate(Position calldata position_) public view returns (Fixed18) {\n        UFixed18 utilization = position_.taker.unsafeDiv(position_.maker);\n        Fixed18 annualizedRate = utilizationCurve().compute(utilization);\n        return annualizedRate.div(Fixed18Lib.from(365 days));\n    }\n\n    /**\n     * @notice Returns the minimum funding fee parameter with a capped range for safety\n     * @dev Caps controller.minFundingFee() <= fundingFee() <= 1\n     * @return Safe minimum funding fee parameter\n     */\n    function _boundedFundingFee() private view returns (UFixed18) {\n        return fundingFee().max(controller().minFundingFee());\n    }\n\n    /**\n     * @notice Updates product closed state\n     * @dev only callable by product owner. Settles the product before flipping the flag\n     * @param newClosed new closed value\n     */\n    function updateClosed(bool newClosed) external nonReentrant notPaused onlyProductOwner {\n        IOracleProvider.OracleVersion memory oracleVersion = _settle();\n        _closed.store(newClosed);\n        emit ClosedUpdated(newClosed, oracleVersion.version);\n    }\n\n    /**\n     * @notice Updates underlying product oracle\n     * @dev only callable by product owner\n     * @param newOracle new oracle address\n     */\n    function updateOracle(IOracleProvider newOracle) external onlyProductOwner {\n        _updateOracle(address(newOracle), latestVersion());\n    }\n\n    /// @dev Limit total maker for guarded rollouts\n    modifier makerInvariant() {\n        _;\n\n        Position memory next = positionAtVersion(latestVersion()).next(_position.pre);\n\n        if (next.maker.gt(makerLimit())) revert ProductMakerOverLimitError();\n    }\n\n    /// @dev Limit maker short exposure to the range 0.0-1.0x of their position. Does not apply when in closeOnly state\n    modifier takerInvariant() {\n        _;\n\n        if (closed()) return;\n\n        Position memory next = positionAtVersion(latestVersion()).next(_position.pre);\n        UFixed18 socializationFactor = next.socializationFactor();\n\n        if (socializationFactor.lt(UFixed18Lib.ONE)) revert ProductInsufficientLiquidityError(socializationFactor);\n    }\n\n    /// @dev Limit utilization to (1 - utilizationBuffer)\n    modifier maxUtilizationInvariant() {\n        _;\n\n        if (closed()) return;\n\n        Position memory next = positionAtVersion(latestVersion()).next(_position.pre);\n        UFixed18 utilization = next.taker.unsafeDiv(next.maker);\n        if (utilization.gt(UFixed18Lib.ONE.sub(utilizationBuffer())))\n            revert ProductInsufficientLiquidityError(utilization);\n    }\n\n    /// @dev Ensure that the user has only taken a maker or taker position, but not both\n    modifier positionInvariant(address account) {\n        _;\n\n        if (_positions[account].isDoubleSided()) revert ProductDoubleSidedError();\n    }\n\n    /// @dev Ensure that the user hasn't closed more than is open\n    modifier closeInvariant(address account) {\n        _;\n\n        if (_positions[account].isOverClosed()) revert ProductOverClosedError();\n    }\n\n    /// @dev Ensure that the user will have sufficient margin for maintenance after next settlement\n    modifier maintenanceInvariant(address account) {\n        _;\n\n        if (controller().collateral().liquidatableNext(account, IProduct(this)))\n            revert ProductInsufficientCollateralError();\n    }\n\n    /// @dev Ensure that the user is not currently being liquidated\n    modifier liquidationInvariant(address account) {\n        if (_positions[account].liquidation) revert ProductInLiquidationError();\n\n        _;\n    }\n\n    /// @dev Helper to fully settle an account's state\n    modifier settleForAccount(address account) {\n        IOracleProvider.OracleVersion memory _currentVersion = _settle();\n        _settleAccount(account, _currentVersion);\n\n        _;\n    }\n\n    /// @dev Ensure we have bootstraped the oracle before creating positions\n    modifier nonZeroVersionInvariant() {\n        if (latestVersion() == 0) revert ProductOracleBootstrappingError();\n\n        _;\n    }\n\n    /// @dev Ensure the product is not closed\n    modifier notClosed() {\n        if (closed()) revert ProductClosedError();\n\n        _;\n    }\n}"
    },
    {
      "filename": "perennial-mono/packages/perennial/contracts/product/Product.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport \"@equilibria/root/control/unstructured/UInitializable.sol\";\nimport \"@equilibria/root/control/unstructured/UReentrancyGuard.sol\";\nimport \"../controller/UControllerProvider.sol\";\nimport \"./UPayoffProvider.sol\";\nimport \"./UParamProvider.sol\";\nimport \"./types/position/AccountPosition.sol\";\nimport \"./types/accumulator/AccountAccumulator.sol\";\n\n/**\n * @title Product\n * @notice Manages logic and state for a single product market.\n * @dev Cloned by the Controller contract to launch new product markets.\n */\ncontract Product is IProduct, UInitializable, UParamProvider, UPayoffProvider, UReentrancyGuard {\n    /// @dev Whether or not the product is closed\n    BoolStorage private constant _closed = BoolStorage.wrap(keccak256(\"equilibria.perennial.Product.closed\"));\n\n    function closed() public view returns (bool) {\n        return _closed.read();\n    }\n\n    /// @dev The name of the product\n    string public name;\n\n    /// @dev The symbol of the product\n    string public symbol;\n\n    /// @dev The individual position state for each account\n    mapping(address => AccountPosition) private _positions;\n\n    /// @dev The global position state for the product\n    VersionedPosition private _position;\n\n    /// @dev The individual accumulator state for each account\n    mapping(address => AccountAccumulator) private _accumulators;\n\n    /// @dev The global accumulator state for the product\n    VersionedAccumulator private _accumulator;\n\n    /**\n     * @notice Initializes the contract state\n     * @param productInfo_ Product initialization params\n     */\n    function initialize(ProductInfo calldata productInfo_) external initializer(1) {\n        __UControllerProvider__initialize(IController(msg.sender));\n        __UPayoffProvider__initialize(productInfo_.oracle, productInfo_.payoffDefinition);\n        __UReentrancyGuard__initialize();\n        __UParamProvider__initialize(\n            productInfo_.maintenance,\n            productInfo_.fundingFee,\n            productInfo_.makerFee,\n            productInfo_.takerFee,\n            productInfo_.positionFee,\n            productInfo_.makerLimit,\n            productInfo_.utilizationCurve\n        );\n\n        name = productInfo_.name;\n        symbol = productInfo_.symbol;\n    }\n\n    /**\n     * @notice Surfaces global settlement externally\n     */\n    function settle() external nonReentrant notPaused {\n        _settle();\n    }\n\n    /**\n     * @notice Core global settlement flywheel\n     * @dev\n     *  a) last settle oracle version\n     *  b) latest pre position oracle version\n     *  c) current oracle version\n     *\n     *  Settles from a->b then from b->c if either interval is non-zero to account for a change\n     *  in position quantity at (b).\n     *\n     *  Syncs each to instantaneously after the oracle update.\n     */\n    function _settle() private returns (IOracleProvider.OracleVersion memory currentOracleVersion) {\n        IController _controller = controller();\n\n        // Get current oracle version\n        currentOracleVersion = _sync();\n\n        // Get latest oracle version\n        uint256 _latestVersion = latestVersion();\n        if (_latestVersion == currentOracleVersion.version) return currentOracleVersion; // short circuit entirely if a == c\n        IOracleProvider.OracleVersion memory latestOracleVersion = atVersion(_latestVersion);\n\n        // Get settle oracle version\n        uint256 _settleVersion = _position.pre.settleVersion(currentOracleVersion.version);\n        IOracleProvider.OracleVersion memory settleOracleVersion = _settleVersion == currentOracleVersion.version\n            ? currentOracleVersion // if b == c, don't re-call provider for oracle version\n            : atVersion(_settleVersion);\n\n        // Initiate\n        _controller.incentivizer().sync(currentOracleVersion);\n        UFixed18 boundedFundingFee = _boundedFundingFee();\n\n        // value a->b\n        UFixed18 accumulatedFee = _accumulator.accumulate(\n            boundedFundingFee, _position, latestOracleVersion, settleOracleVersion);\n\n        // position a->b\n        _position.settle(_latestVersion, settleOracleVersion);\n\n        // Apply any pending fee updates if present\n        _settleFeeUpdates();\n\n        // short-circuit from a->c if b == c\n        if (settleOracleVersion.version != currentOracleVersion.version) {\n            // value b->c\n            accumulatedFee = accumulatedFee.add(\n                _accumulator.accumulate(boundedFundingFee, _position, settleOracleVersion, currentOracleVersion)\n            );\n\n            // position b->c (every accumulator version needs a position stamp)\n            _position.settle(settleOracleVersion.version, currentOracleVersion);\n        }\n\n        // settle collateral\n        _controller.collateral().settleProduct(accumulatedFee);\n\n        emit Settle(settleOracleVersion.version, currentOracleVersion.version);\n    }\n\n    /**\n     * @notice Surfaces account settlement externally\n     * @param account Account to settle\n     */\n    function settleAccount(address account) external nonReentrant notPaused {\n        IOracleProvider.OracleVersion memory currentOracleVersion = _settle();\n        _settleAccount(account, currentOracleVersion);\n    }\n\n    /**\n     * @notice Core account settlement flywheel\n     * @param account Account to settle\n     * @dev\n     *  a) last settle oracle version\n     *  b) latest pre position oracle version\n     *  c) current oracle version\n     *\n     *  Settles from a->b then from b->c if either interval is non-zero to account for a change\n     *  in position quantity at (b).\n     *\n     *  Syncs each to instantaneously after the oracle update.\n     */\n    function _settleAccount(address account, IOracleProvider.OracleVersion memory currentOracleVersion) private {\n        IController _controller = controller();\n\n        // Get latest oracle version\n        if (latestVersion(account) == currentOracleVersion.version) return; // short circuit entirely if a == c\n\n        // Get settle oracle version\n        uint256 _settleVersion = _positions[account].pre.settleVersion(currentOracleVersion.version);\n        IOracleProvider.OracleVersion memory settleOracleVersion = _settleVersion == currentOracleVersion.version\n            ? currentOracleVersion // if b == c, don't re-call provider for oracle version\n            : atVersion(_settleVersion);\n\n        // sync incentivizer before accumulator\n        _controller.incentivizer().syncAccount(account, settleOracleVersion);\n\n        // value a->b\n        Fixed18 accumulated = _accumulators[account].syncTo(\n            _accumulator, _positions[account], settleOracleVersion.version).sum();\n\n        // position a->b\n        _positions[account].settle(settleOracleVersion);\n\n        // short-circuit from a->c if b == c\n        if (settleOracleVersion.version != currentOracleVersion.version) {\n            // sync incentivizer before accumulator\n            _controller.incentivizer().syncAccount(account, currentOracleVersion);\n\n            // value b->c\n            accumulated = accumulated.add(\n                _accumulators[account].syncTo(_accumulator, _positions[account], currentOracleVersion.version).sum()\n            );\n        }\n\n        // settle collateral\n        _controller.collateral().settleAccount(account, accumulated);\n\n        emit AccountSettle(account, settleOracleVersion.version, currentOracleVersion.version);\n    }\n\n    /**\n     * @notice Opens a taker position for `msg.sender`\n     * @param amount Amount of the position to open\n     */\n    function openTake(UFixed18 amount) external {\n        openTakeFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Opens a taker position for `account`. Deducts position fee based on notional value at `latestVersion`\n     * @param account Account to open the position for\n     * @param amount Amount of the position to open\n     */\n    function openTakeFor(address account, UFixed18 amount)\n        public\n        nonReentrant\n        notPaused\n        notClosed\n        onlyAccountOrMultiInvoker(account)\n        settleForAccount(account)\n        maxUtilizationInvariant\n        positionInvariant(account)\n        liquidationInvariant(account)\n        maintenanceInvariant(account)\n    {\n        IOracleProvider.OracleVersion memory latestOracleVersion = atVersion(latestVersion());\n\n        _positions[account].pre.openTake(latestOracleVersion.version, amount);\n        _position.pre.openTake(latestOracleVersion.version, amount);\n\n        UFixed18 positionFee = amount.mul(latestOracleVersion.price.abs()).mul(takerFee());\n        if (!positionFee.isZero()) {\n            controller().collateral().settleAccount(account, Fixed18Lib.from(-1, positionFee));\n            emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        }\n\n        emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        emit TakeOpened(account, latestOracleVersion.version, amount);\n    }\n\n    /**\n     * @notice Closes a taker position for `msg.sender`\n     * @param amount Amount of the position to close\n     */\n    function closeTake(UFixed18 amount) external {\n        closeTakeFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Closes a taker position for `account`. Deducts position fee based on notional value at `latestVersion`\n     * @param account Account to close the position for\n     * @param amount Amount of the position to close\n     */\n    function closeTakeFor(address account, UFixed18 amount)\n        public\n        nonReentrant\n        notPaused\n        onlyAccountOrMultiInvoker(account)\n        settleForAccount(account)"
    }
  ]
}