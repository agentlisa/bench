{
  "Title": "[L-06] Missing events for governor only functions that change critical parameters",
  "Content": "<h2 id=\"l-06-missing-events-for-governor-only-functions-that-change-critical-parameters\" style=\"position:relative;\"><a href=\"#l-06-missing-events-for-governor-only-functions-that-change-critical-parameters\" aria-label=\"l 06 missing events for governor only functions that change critical parameters permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-06] Missing events for governor only functions that change critical parameters</h2>\n<p>The governor only functions that change critical parameters should emit events. Events allow capturing the changed parameters so that off-chain tools/interfaces can register such changes with timelocks that allow users to evaluate them and consider if they would like to engage/exit based on how they perceive the changes as affecting the trustworthiness of the protocol or profitability of the implemented financial services. The alternative of directly querying on-chain contract state for such changes is not considered practical for most users/usages.</p>\n<p>Missing events and timelocks do not promote transparency and if such changes immediately affect users’ perception of fairness or trustworthiness, they could exit the protocol causing a reduction in liquidity which could negatively impact protocol TVL and reputation.</p>\n<p>There are owner functions that do not emit any events in the contracts.</p>\n<h3 id=\"proof-of-concept-22\" style=\"position:relative;\"><a href=\"#proof-of-concept-22\" aria-label=\"proof of concept 22 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h3>\n<p>Navigate to the following contracts:</p>\n<ul>\n<li><a href=\"https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L616\">https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L616</a><br></li>\n<li><a href=\"https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/legos/Governable.sol#L19\">https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/legos/Governable.sol#L19</a><br></li>\n<li><a href=\"https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/Oracle.sol#L162\">https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/Oracle.sol#L162</a><br></li>\n<li><a href=\"https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/VUSD.sol#L74\">https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/VUSD.sol#L74</a><br></li>\n<li><a href=\"https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/AMM.sol#L722\">https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/AMM.sol#L722</a><br></li>\n<li><a href=\"https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/AMM.sol#L737\">https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/AMM.sol#L737</a><br></li>\n</ul>\n<p>See similar High-severity H03 finding <a href=\"https://blog.openzeppelin.com/audius-contracts-audit/#high\">OpenZeppelin’s Audit of Audius</a> and Medium-severity M01 finding <a href=\"https://blog.openzeppelin.com/uma-audit-phase-4/\">OpenZeppelin’s Audit of UMA Phase 4</a>.</p>\n<h3 id=\"recommended-mitigation-steps-24\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-24\" aria-label=\"recommended mitigation steps 24 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<p>Add events to all admin/privileged functions that change critical parameters.</p>\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-02-hubble-contest",
  "Code": [
    {
      "filename": "contracts/MarginAccount.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { HubbleBase } from \"./legos/HubbleBase.sol\";\nimport {\n    ERC20Detailed,\n    IClearingHouse,\n    IInsuranceFund,\n    IOracle,\n    IRegistry,\n    IMarginAccount,\n    IERC20FlexibleSupply\n} from \"./Interfaces.sol\";\n\n/**\n* @title This contract is used for posting margin (collateral), realizing PnL etc.\n* @notice Most notable operations include addMargin, removeMargin and liquidations\n*/\ncontract MarginAccount is IMarginAccount, HubbleBase {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    // Hubble vUSD is necessitated to be the first whitelisted collateral\n    uint constant VUSD_IDX = 0;\n\n    // used for all usd based values\n    uint constant PRECISION = 1e6;\n\n    error NOT_LIQUIDATABLE(IMarginAccount.LiquidationStatus);\n\n    /**\n    * @dev This is only used to group variables to avoid a solidity stack too deep error\n    *   incentivePerDollar How many $ liquidator gets for each $ they repay e.g. they might get $1.05 for every $1 liquidation. >= PRECISION\n    *   repayAble The maximum debt that can be settled for an account undergoing a liquidation\n    *   priceCollateral Most recent oracle price (chainlink) of the collateral that is being seized for an account undergoing a liquidation\n    *   decimals Decimals for the collateral being seized\n    */\n    struct LiquidationBuffer {\n        LiquidationStatus status;\n        uint8 decimals;\n        uint incentivePerDollar;\n        uint repayAble;\n        uint priceCollateral;\n    }\n\n    /* ****************** */\n    /*       Storage      */\n    /* ****************** */\n\n    IClearingHouse public clearingHouse;\n    IOracle public oracle;\n    IInsuranceFund public insuranceFund;\n    IERC20FlexibleSupply public vusd;\n    uint public credit;\n\n    /// @notice Array of supported collateral\n    Collateral[] public supportedCollateral;\n\n    /**\n    * @notice How many $ liquidator gets for each $ they repay e.g. they might get $1.05 for every $1 liquidation\n    * @dev In the above scenario, this value will be %0.05 i.e. 5 cents incentive per dollar repayed\n    */\n    uint public liquidationIncentive;\n\n    /**\n    * @notice Maps index in supportedCollateral => trader => balance\n    * @dev equivalent to margin(uint idx, address user)\n    */\n    mapping(uint => mapping(address => int)) override public margin;\n\n    uint256[50] private __gap;\n\n    /* ****************** */\n    /*       Events       */\n    /* ****************** */\n\n    /// @notice Emitted when user adds margin for any of the supported collaterals\n    event MarginAdded(address indexed trader, uint256 indexed idx, uint amount, uint256 timestamp);\n\n    /// @notice Emitted when user removes margin for any of the supported collaterals\n    event MarginRemoved(address indexed trader, uint256 indexed idx, uint256 amount, uint256 timestamp);\n\n    /**\n    * @notice Mutates trader's vUSD balance\n    * @param trader Account who is realizing PnL\n    * @param realizedPnl Increase or decrease trader's vUSD balace by. +ve/-ve value means vUSD is added/removed respectively from trader's margin\n    */\n    event PnLRealized(address indexed trader, int256 realizedPnl, uint256 timestamp);\n\n    /**\n    * @notice Emitted when a trader's margin account is liquidated i.e. their vUSD debt is repayed in exchange for their collateral\n    * @param trader Trader whose margin account was liquidated\n    * @param idx Index of the collateral that was seized during the liquidation\n    * @param seizeAmount Amount of the collateral that was seized during the liquidation\n    * @param repayAmount The debt that was repayed\n    */\n    event MarginAccountLiquidated(address indexed trader, uint indexed idx, uint seizeAmount, uint repayAmount, uint256 timestamp);\n\n    /**\n    * @notice Emitted when funds from insurance fund are tasked to settle system's bad debt\n    * @param trader Account for which the bad debt was settled\n    * @param seized Collateral amounts that were seized\n    * @param repayAmount Debt that was settled. it's exactly equal to -vUSD when vUSD < 0\n    */\n    event SettledBadDebt(address indexed trader, uint[] seized, uint repayAmount, uint256 timestamp);\n\n    modifier onlyClearingHouse() {\n        require(_msgSender() == address(clearingHouse), \"Only clearingHouse\");\n        _;\n    }\n\n    constructor(address _trustedForwarder) HubbleBase(_trustedForwarder) {}\n\n    function initialize(\n        address _governance,\n        address _vusd\n    ) external initializer {\n        _setGovernace(_governance);\n        _addCollateral(_vusd, PRECISION); // weight = 1 * PRECISION\n        vusd = IERC20FlexibleSupply(_vusd);\n    }\n\n    /* ****************** */\n    /*       Margin       */\n    /* ****************** */\n\n    /**\n    * @notice Post margin\n    * @param idx Index of the supported collateral\n    * @param amount Amount to deposit (scaled same as the asset)\n    */\n    function addMargin(uint idx, uint amount) override external whenNotPaused {\n        addMarginFor(idx, amount, _msgSender());\n    }\n\n    /**\n    * @notice Post margin for another account\n    * @param idx Index of the supported collateral\n    * @param amount Amount to deposit (scaled same as the asset)\n    * @param to Account to post margin for\n    */\n    function addMarginFor(uint idx, uint amount, address to) override public whenNotPaused {\n        require(amount > 0, \"Add non-zero margin\");\n        // will revert for idx >= supportedCollateral.length\n        if (idx == VUSD_IDX) {\n            _transferInVusd(_msgSender(), amount);\n        } else {\n            supportedCollateral[idx].token.safeTransferFrom(_msgSender(), address(this), amount);\n        }\n        margin[idx][to] += amount.toInt256();\n        emit MarginAdded(to, idx, amount, _blockTimestamp());\n    }\n\n    /**\n    * @notice Withdraw margin.\n    *   Collateral can not be withdrawn if vUSD balance is < 0.\n    * @dev If the contract has insufficient vUSD balance, a loan is taken from the vUSD contract.\n    * @param idx Index of the supported collateral\n    * @param amount Amount to withdraw (scaled same as the asset)\n    */\n    function removeMargin(uint idx, uint256 amount) override external whenNotPaused {\n        address trader = _msgSender();\n\n        // credit funding payments\n        clearingHouse.updatePositions(trader);\n\n        require(margin[VUSD_IDX][trader] >= 0, \"Cannot remove margin when vusd balance is negative\");\n        require(margin[idx][trader] >= amount.toInt256(), \"Insufficient balance\");\n\n        margin[idx][trader] -= amount.toInt256();\n\n        // Check minimum margin requirement after withdrawal\n        require(clearingHouse.isAboveMinAllowableMargin(trader), \"MA.removeMargin.Below_MM\");\n\n        if (idx == VUSD_IDX) {\n            _transferOutVusd(trader, amount);\n        } else {\n            supportedCollateral[idx].token.safeTransfer(trader, amount);\n        }\n        emit MarginRemoved(trader, idx, amount, _blockTimestamp());\n    }\n\n    /**\n    * @notice Invoked to realize PnL, credit/debit funding payments, pay trade and liquidation fee\n    * @dev Will only make a change to VUSD balance.\n    *   only clearingHouse is authorized to call.\n    * @param trader Account to realize PnL for\n    * @param realizedPnl Amount to credit/debit\n    */\n    function realizePnL(address trader, int256 realizedPnl)\n        override\n        external\n        onlyClearingHouse\n    {\n        // -ve PnL will reduce balance\n        if (realizedPnl != 0) {\n            margin[VUSD_IDX][trader] += realizedPnl;\n            emit PnLRealized(trader, realizedPnl, _blockTimestamp());\n        }\n    }\n\n    function transferOutVusd(address recipient, uint amount)\n        override\n        external\n        onlyClearingHouse\n    {\n        _transferOutVusd(recipient, amount);\n    }\n\n    /* ****************** */\n    /*    Liquidations    */\n    /* ****************** */\n\n    /**\n    * @notice Determines if a trader's margin account can be liquidated now\n    * @param trader Account to check liquidation status for\n    * @param includeFunding whether to include funding payments before checking liquidation status\n    * @return _isLiquidatable Whether the account can be liquidated; reason if not\n    * @return repayAmount Trader's debt i.e. the max amount that they can be liquidated for\n    * @return incentivePerDollar How many $ liquidator gets for each $ they repay\n    *   e.g. they might get $1.05 for every $1 that is repayed.\n    */\n    function isLiquidatable(address trader, bool includeFunding)\n        override\n        public\n        view\n        returns(IMarginAccount.LiquidationStatus _isLiquidatable, uint repayAmount, uint incentivePerDollar)\n    {\n        int vusdBal = margin[VUSD_IDX][trader];\n        if (includeFunding) {\n            vusdBal -= clearingHouse.getTotalFunding(trader);\n        }\n        if (vusdBal >= 0) { // nothing to liquidate\n            return (IMarginAccount.LiquidationStatus.NO_DEBT, 0, 0);\n        }\n\n        (uint256 notionalPosition,) = clearingHouse.getTotalNotionalPositionAndUnrealizedPnl(trader);\n        if (notionalPosition != 0) { // Liquidate positions before liquidating margin account\n            return (IMarginAccount.LiquidationStatus.OPEN_POSITIONS, 0, 0);\n        }\n\n        (int256 weighted, int256 spot) = weightedAndSpotCollateral(trader);\n        if (weighted >= 0) {\n            return (IMarginAccount.LiquidationStatus.ABOVE_THRESHOLD, 0, 0);\n        }\n\n        // _isLiquidatable = IMarginAccount.LiquidationStatus.IS_LIQUIDATABLE;\n        repayAmount = (-vusdBal).toUint256();\n        incentivePerDollar = PRECISION; // get atleast $1 worth of collateral for every $1 paid\n\n        if (spot > 0) {\n            /**\n                Liquidation scenario B, where Cw < |vUSD| < Cusd\n                => Cw - |vUSD| < 0\n                => Cw + vUSD (=weighted) < 0; since vUSD < 0\n                Max possible liquidationIncentive (for repaying |vUSD|) is Cusd\n            */\n            incentivePerDollar += _min(\n                liquidationIncentive, // incentivePerDollar = PRECISION + liquidationIncentive <= 1.1\n                // divide up all the extra dollars in proportion to repay amount\n                // note that spot value here is inclusive of the -ve vUSD value\n                spot.toUint256() * PRECISION / repayAmount\n            );\n        } /* else {\n            Since the protocol is already in deficit we don't have any money to give out as liquidationIncentive\n            Liquidation scenario C, where Cusd <= |vUSD|\n            => Cusd - |vUSD| <= 0\n            => Cusd + vUSD (=spot) <= 0; since vUSD < 0\n\n            @todo consider providing some incentive from insurance fund to execute a liquidation in this scenario.\n            That fee is basically provided so that insurance fund has to settle a lower bad debt and seize lesser amount of assets.\n            (because seized assets then need to sold/auctioned off, so that's extra work)\n        } */\n    }\n\n    /**\n    * @notice Liquidate a trader while mentioning the exact repay amount while capping \"slippage\" on the seized collateral\n    *   This maybe be considered as a \"swapExactInput\" operation.\n    *   It's required that trader has no open positions.\n    * @param trader Account to liquidate\n    * @param repay Amount to repay\n    * @param idx Index of the collateral to seize\n    * @param minSeizeAmount Min collateral output amount\n    */\n    function liquidateExactRepay(address trader, uint repay, uint idx, uint minSeizeAmount) external whenNotPaused {\n        clearingHouse.updatePositions(trader); // credits/debits funding\n        LiquidationBuffer memory buffer = _getLiquidationInfo(trader, idx);\n        if (buffer.status != IMarginAccount.LiquidationStatus.IS_LIQUIDATABLE) {\n            revert NOT_LIQUIDATABLE(buffer.status);\n        }\n        _liquidateExactRepay(buffer, trader, repay, idx, minSeizeAmount);\n    }\n\n    /**\n    * @notice Liquidate a trader while mentioning the exact collateral amount to be seized while capping \"slippage\" on the repay amount.\n    *   This maybe be considered as a \"swapExactOutput\" operation.\n    *   It's required that trader has no open positions.\n    * @param trader Account to liquidate\n    * @param maxRepay Max vUSD input amount\n    * @param idx Index of the collateral to seize\n    * @param seize Exact collateral amount desired to be seized\n    */\n    function liquidateExactSeize(address trader, uint maxRepay, uint idx, uint seize) external whenNotPaused {\n        clearingHouse.updatePositions(trader); // credits/debits funding\n        LiquidationBuffer memory buffer = _getLiquidationInfo(trader, idx);\n        if (buffer.status != IMarginAccount.LiquidationStatus.IS_LIQUIDATABLE) {\n            revert NOT_LIQUIDATABLE(buffer.status);\n        }\n        _liquidateExactSeize(buffer, trader, maxRepay, idx, seize);\n    }\n\n    /**\n    * @notice Either seize all available collateral\n    *   OR settle debt completely with (most likely) left over collateral.\n    *   It's required that trader has no open positions.\n    *   Seized collateral at it's current oracle price should be acceptable to the liquidator.\n    * @param trader Account to liquidate\n    * @param maxRepay Max vUSD input amount\n    * @param idxs Indices of the collateral to seize\n    */\n    function liquidateFlexible(address trader, uint maxRepay, uint[] calldata idxs) external whenNotPaused {\n        clearingHouse.updatePositions(trader); // credits/debits funding\n        uint repayed;\n        for (uint i = 0; i < idxs.length; i++) {\n            LiquidationBuffer memory buffer = _getLiquidationInfo(trader, idxs[i]);\n            // revert only if trader has open positions, otherwise fail silently\n            if (buffer.status == IMarginAccount.LiquidationStatus.OPEN_POSITIONS) {\n                revert NOT_LIQUIDATABLE(buffer.status);\n            }\n            if (buffer.status != IMarginAccount.LiquidationStatus.IS_LIQUIDATABLE) {\n                break;\n            }\n            repayed = _liquidateFlexible(trader, maxRepay, idxs[i]);\n            maxRepay -= repayed;\n        }\n    }\n\n    /**\n    * @notice Invoke a bad debt settlement using the insurance fund.\n    *   It's required that trader has no open positions when settling bad debt.\n    * @dev Debt is said to be bad when the spot value of user's collateral is not enough to cover their -ve vUSD balance\n    *   Since there are no open positions, debit/credit funding payments is not required.\n    * @param trader Account for which the bad debt needs to be settled\n    */\n    function settleBadDebt(address trader) external whenNotPaused {\n        (uint256 notionalPosition,) = clearingHouse.getTotalNotionalPositionAndUnrealizedPnl(trader);\n        require(notionalPosition == 0, \"Liquidate positions before settling bad debt\");\n\n        // The spot value of their collateral minus their vUSD obligation is a negative value\n        require(getSpotCollateralValue(trader) < 0, \"Above bad debt threshold\");\n\n        int vusdBal = margin[VUSD_IDX][trader];\n\n        // this check is not strictly required because getSpotCollateralValue(trader) < 0 is a stronger assertion\n        require(vusdBal < 0, \"Nothing to repay\");\n\n        uint badDebt = (-vusdBal).toUint256();\n        Collateral[] memory assets = supportedCollateral;\n\n        // This pulls the obligation\n        insuranceFund.seizeBadDebt(badDebt);\n        margin[VUSD_IDX][trader] = 0;\n\n        // Insurance fund gets all the available collateral\n        uint[] memory seized = new uint[](assets.length);\n        for (uint i = 1 /* skip vusd */; i < assets.length; i++) {\n            int amount = margin[i][trader];\n            if (amount > 0) {\n                margin[i][trader] = 0;\n                assets[i].token.safeTransfer(address(insuranceFund), amount.toUint256());\n                seized[i] = amount.toUint256();\n            }\n        }\n        emit SettledBadDebt(trader, seized, badDebt, _blockTimestamp());\n    }\n\n    /* ********************* */\n    /* Liquidations Internal */\n    /* ********************* */\n\n    /**\n    * @dev This function wil either seize all available collateral of type idx\n    * OR settle debt completely with (most likely) left over collateral\n    * @return Debt repayed <= repayble i.e. user's max debt\n    */\n    function _liquidateFlexible(address trader, uint maxRepay, uint idx) internal whenNotPaused returns(uint /* repayed */) {\n        LiquidationBuffer memory buffer = _getLiquidationInfo(trader, idx);\n\n        // Q. Can user's margin cover the entire debt?\n        uint repay = _seizeToRepay(buffer, margin[idx][trader].toUint256());\n\n        // A.1 Yes, it can cover the entire debt. Settle repayAble\n        if (repay >= buffer.repayAble) {\n            _liquidateExactRepay(\n                buffer,\n                trader,\n                buffer.repayAble, // exact repay amount\n                idx,\n                0 // minSeizeAmount=0 implies accept whatever the oracle price is\n            );\n            return buffer.repayAble; // repayed exactly repayAble and 0 is left to repay now\n        }\n\n        // A.2 No, collateral can not cover the entire debt. Seize all of it.\n        return _liquidateExactSeize(\n            buffer,\n            trader,\n            maxRepay,\n            idx,\n            margin[idx][trader].toUint256()\n        );\n    }\n\n    function _liquidateExactRepay(\n        LiquidationBuffer memory buffer,\n        address trader,\n        uint repay,\n        uint idx,\n        uint minSeizeAmount\n    )\n        internal\n        returns (uint seized)\n    {\n        // determine the seizable collateral amount on the basis of the most recent chainlink price feed\n        seized = _min(\n            _scaleDecimals(repay * buffer.incentivePerDollar, buffer.decimals - 6) / buffer.priceCollateral,\n            // can't seize more than available\n            // this also protects the liquidator in the scenario that they were front-run and only a small seize isn't worth it for them\n            margin[idx][trader].toUint256()\n        );\n        require(seized >= minSeizeAmount, \"Not seizing enough\");\n        _executeLiquidation(trader, repay, idx, seized, buffer.repayAble);\n    }\n\n    function _liquidateExactSeize(\n        LiquidationBuffer memory buffer,\n        address trader,\n        uint maxRepay,\n        uint idx,\n        uint seize\n    )\n        internal\n        returns (uint repay)\n    {\n        repay = _seizeToRepay(buffer, seize);\n        require(repay <= maxRepay, \"Need to repay more to seize that much\");\n        _executeLiquidation(trader, repay, idx, seize, buffer.repayAble);\n    }\n\n    /**\n    * @dev reverts if margin account is not liquidatable\n    */\n    function _getLiquidationInfo(address trader, uint idx) internal view returns (LiquidationBuffer memory buffer) {\n        require(idx > VUSD_IDX && idx < supportedCollateral.length, \"collateral not seizable\");\n        (buffer.status, buffer.repayAble, buffer.incentivePerDollar) = isLiquidatable(trader, false);\n        if (buffer.status == IMarginAccount.LiquidationStatus.IS_LIQUIDATABLE) {\n            Collateral memory coll = supportedCollateral[idx];\n            buffer.priceCollateral = oracle.getUnderlyingPrice(address(coll.token)).toUint256();\n            buffer.decimals = coll.decimals;\n        }\n    }\n\n    /**\n    * @dev Peform the actual liquidation.\n    *   1. Pull the repay amount from liquidator's account and credit trader's VUSD margin\n    *   2. Debit the seize amount and transfer to liquidator\n    * @return The debt that is leftover to be paid\n    */\n    function _executeLiquidation(address trader, uint repay, uint idx, uint seize, uint repayAble)\n        internal\n        returns (uint /* left over repayable */)\n    {\n        if (repay == 0 || seize == 0) { // provides more flexibility, so prefer not reverting\n            return repayAble;\n        }\n\n        _transferInVusd(_msgSender(), repay);\n        margin[VUSD_IDX][trader] += repay.toInt256();\n\n        margin[idx][trader] -= seize.toInt256();\n        supportedCollateral[idx].token.safeTransfer(_msgSender(), seize);\n\n        emit MarginAccountLiquidated(trader, idx, seize, repay, _blockTimestamp());\n        return repayAble - repay; // will ensure that the liquidator isn't repaying more than user's debt (and seizing a bigger amount of their collateral)\n    }\n\n    function _seizeToRepay(LiquidationBuffer memory buffer, uint seize) internal pure returns (uint repay) {\n        repay = seize * buffer.priceCollateral / (10 ** buffer.decimals);\n        if (buffer.incentivePerDollar > 0) {\n            repay = repay * PRECISION / buffer.incentivePerDollar;\n        }\n    }\n\n    /* ****************** */\n    /*        View        */\n    /* ****************** */\n\n    function getSpotCollateralValue(address trader) override public view returns(int256 spot) {\n        (,spot) = weightedAndSpotCollateral(trader);\n    }\n\n    function getNormalizedMargin(address trader) override public view returns(int256 weighted) {\n        (weighted,) = weightedAndSpotCollateral(trader);\n    }\n\n    function weightedAndSpotCollateral(address trader)\n        public\n        view\n        returns (int256 weighted, int256 spot)\n    {\n        Collateral[] memory assets = supportedCollateral;\n        Collateral memory _collateral;\n\n        for (uint i = 0; i < assets.length; i++) {\n            _collateral = assets[i];\n\n            int numerator = margin[i][trader] * oracle.getUnderlyingPrice(address(assets[i].token));\n            uint denomDecimals = _collateral.decimals;\n\n            spot += (numerator / int(10 ** denomDecimals));\n            weighted += (numerator * _collateral.weight.toInt256() / int(10 ** (denomDecimals + 6)));\n        }\n    }\n\n    /* ****************** */\n    /*     UI Helpers     */\n    /* ****************** */\n\n    function supportedAssets() external view override returns (Collateral[] memory) {\n        return supportedCollateral;\n    }\n\n    function supportedAssetsLen() override external view returns (uint) {\n        return supportedCollateral.length;\n    }\n\n    /* ****************** */\n    /*    Misc Internal   */\n    /* ****************** */\n\n    function _addCollateral(address _coin, uint _weight) internal {\n        require(_weight <= PRECISION, \"weight > 1e6\");\n\n        Collateral[] memory _collaterals = supportedCollateral;\n        for (uint i = 0; i < _collaterals.length; i++) {\n            require(address(_collaterals[i].token) != _coin, \"collateral exists\");\n        }\n        supportedCollateral.push(\n            Collateral({\n                token: IERC20(_coin),\n                weight: _weight,\n                decimals: ERC20Detailed(_coin).decimals() // will fail if .decimals() is not defined on the contract\n            })\n        );\n    }\n\n    function _scaleDecimals(uint256 amount, uint8 decimals) internal pure returns(uint256) {\n        return amount * (10 ** decimals);\n    }\n\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function _transferInVusd(address from, uint amount) internal {\n        IERC20(address(vusd)).safeTransferFrom(from, address(this), amount);\n        if (credit > 0) {\n            uint toBurn = Math.min(vusd.balanceOf(address(this)), credit);\n            credit -= toBurn;\n            vusd.burn(toBurn);\n        }\n    }\n\n    function _transferOutVusd(address recipient, uint amount) internal {\n        uint bal = vusd.balanceOf(address(this));\n        if (bal < amount) {\n            // Say there are 2 traders, Alice and Bob.\n            // Alice has a profitable position and realizes their PnL in form of vusd margin.\n            // But bob has not yet realized their -ve PnL.\n            // In that case we'll take a credit from vusd contract, which will eventually be returned when Bob pays their debt back.\n            uint _credit = amount - bal;\n            credit += _credit;\n            vusd.mint(address(this), _credit);\n        }\n        IERC20(address(vusd)).safeTransfer(recipient, amount);\n    }\n\n    /* ****************** */\n    /*     Governance     */\n    /* ****************** */\n\n    function syncDeps(address _registry, uint _liquidationIncentive) public onlyGovernance {\n        // protecting against setting a very high liquidation incentive. Max 10%\n        require(_liquidationIncentive <= PRECISION / 10, \"MA.syncDeps.LI_GT_10_percent\");\n        IRegistry registry = IRegistry(_registry);\n        require(registry.marginAccount() == address(this), \"Incorrect setup\");\n\n        clearingHouse = IClearingHouse(registry.clearingHouse());\n        oracle = IOracle(registry.oracle());\n        insuranceFund = IInsuranceFund(registry.insuranceFund());\n        liquidationIncentive = _liquidationIncentive;\n    }\n\n    function whitelistCollateral(address _coin, uint _weight) external onlyGovernance {\n        _addCollateral(_coin, _weight);\n    }\n\n    // function to change weight of an asset\n    function changeCollateralWeight(uint idx, uint _weight) external onlyGovernance {\n        require(_weight <= PRECISION, \"weight > 1e6\");\n        require(idx < supportedCollateral.length, \"Collateral not supported\");\n        supportedCollateral[idx].weight = _weight;\n    }\n}"
    },
    {
      "filename": "contracts/legos/Governable.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\ncontract VanillaGovernable {\n    address public governance;\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance, \"ONLY_GOVERNANCE\");\n        _;\n    }\n\n    function setGovernace(address _governance) external onlyGovernance {\n        _setGovernace(_governance);\n    }\n\n    function _setGovernace(address _governance) internal {\n        governance = _governance;\n    }\n}\n\ncontract Governable is VanillaGovernable, Initializable {}"
    },
    {
      "filename": "contracts/Oracle.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { Governable } from \"./legos/Governable.sol\";\nimport { AggregatorV3Interface } from \"./Interfaces.sol\";\n\ncontract Oracle is Governable {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    mapping(address => address) public chainLinkAggregatorMap;\n    mapping(address => int256) public stablePrice;\n\n    uint256[50] private __gap;\n\n    function initialize(address _governance) external initializer {\n        _setGovernace(_governance);\n    }\n\n    function getUnderlyingPrice(address underlying)\n        virtual\n        external\n        view\n        returns(int256 answer)\n    {\n        if (stablePrice[underlying] != 0) {\n            return stablePrice[underlying];\n        }\n        (,answer,,,) = AggregatorV3Interface(chainLinkAggregatorMap[underlying]).latestRoundData();\n        answer /= 100;\n    }\n\n    function getUnderlyingTwapPrice(address underlying, uint256 intervalInSeconds)\n        virtual\n        public\n        view\n        returns (int256)\n    {\n        if (stablePrice[underlying] != 0) {\n            return stablePrice[underlying];\n        }\n        AggregatorV3Interface aggregator = AggregatorV3Interface(chainLinkAggregatorMap[underlying]);\n        requireNonEmptyAddress(address(aggregator));\n        require(intervalInSeconds != 0, \"interval can't be 0\");\n\n        // 3 different timestamps, `previous`, `current`, `target`\n        // `base` = now - intervalInSeconds\n        // `current` = current round timestamp from aggregator\n        // `previous` = previous round timestamp form aggregator\n        // now >= previous > current > = < base\n        //\n        //  while loop i = 0\n        //  --+------+-----+-----+-----+-----+-----+\n        //         base                 current  now(previous)\n        //\n        //  while loop i = 1\n        //  --+------+-----+-----+-----+-----+-----+\n        //         base           current previous now\n\n        (uint80 round, uint256 latestPrice, uint256 latestTimestamp) = getLatestRoundData(aggregator);\n        uint256 baseTimestamp = _blockTimestamp() - intervalInSeconds;\n        // if latest updated timestamp is earlier than target timestamp, return the latest price.\n        if (latestTimestamp < baseTimestamp || round == 0) {\n            return formatPrice(latestPrice);\n        }\n\n        // rounds are like snapshots, latestRound means the latest price snapshot. follow chainlink naming\n        uint256 previousTimestamp = latestTimestamp;\n        uint256 cumulativeTime = _blockTimestamp() - previousTimestamp;\n        uint256 weightedPrice = latestPrice * cumulativeTime;\n        while (true) {\n            if (round == 0) {\n                // if cumulative time is less than requested interval, return current twap price\n                return formatPrice(weightedPrice / cumulativeTime);\n            }\n\n            round = round - 1; // check round sanity\n            (, uint256 currentPrice, uint256 currentTimestamp) = getRoundData(aggregator, round);\n\n            // check if current round timestamp is earlier than target timestamp\n            if (currentTimestamp <= baseTimestamp) {\n                // weighted time period will be (target timestamp - previous timestamp). For example,\n                // now is 1000, intervalInSeconds is 100, then target timestamp is 900. If timestamp of current round is 970,\n                // and timestamp of NEXT round is 880, then the weighted time period will be (970 - 900) = 70,\n                // instead of (970 - 880)\n                weightedPrice = weightedPrice + (currentPrice * (previousTimestamp - baseTimestamp));\n                break;\n            }\n\n            uint256 timeFraction = previousTimestamp - currentTimestamp;\n            weightedPrice = weightedPrice + (currentPrice * timeFraction);\n            cumulativeTime = cumulativeTime + timeFraction;\n            previousTimestamp = currentTimestamp;\n        }\n        return formatPrice(weightedPrice / intervalInSeconds);\n    }\n\n    //\n    // INTERNAL VIEW FUNCTIONS\n    //\n\n    function getLatestRoundData(AggregatorV3Interface _aggregator)\n        internal\n        view\n        returns (\n            uint80,\n            uint256 finalPrice,\n            uint256\n        )\n    {\n        (uint80 round, int256 latestPrice, , uint256 latestTimestamp, ) = _aggregator.latestRoundData();\n        finalPrice = uint256(latestPrice);\n        if (latestPrice < 0) {\n            requireEnoughHistory(round);\n            (round, finalPrice, latestTimestamp) = getRoundData(_aggregator, round - 1);\n        }\n        return (round, finalPrice, latestTimestamp);\n    }\n\n    function getRoundData(AggregatorV3Interface _aggregator, uint80 _round)\n        internal\n        view\n        returns (\n            uint80,\n            uint256,\n            uint256\n        )\n    {\n        (uint80 round, int256 latestPrice, , uint256 latestTimestamp, ) = _aggregator.getRoundData(_round);\n        while (latestPrice < 0) {\n            requireEnoughHistory(round);\n            round = round - 1;\n            (, latestPrice, , latestTimestamp, ) = _aggregator.getRoundData(round);\n        }\n        return (round, uint256(latestPrice), latestTimestamp);\n    }\n\n    function formatPrice(uint256 _price) internal pure returns (int256) {\n        return (_price / 100).toInt256(); // 6 decimals\n    }\n\n    function _blockTimestamp() internal view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    // Internal\n\n    function requireEnoughHistory(uint80 _round) internal pure {\n        require(_round > 0, \"Not enough history\");\n    }\n\n    function requireNonEmptyAddress(address _addr) internal pure {\n        require(_addr != address(0), \"empty address\");\n    }\n\n    // Governance\n\n    function setAggregator(address underlying, address aggregator) external onlyGovernance {\n        requireNonEmptyAddress(underlying);\n        requireNonEmptyAddress(aggregator);\n        chainLinkAggregatorMap[underlying] = aggregator;\n        // AggregatorV3Interface(chainLinkAggregatorMap[underlying]).latestRoundData(); // sanity check\n    }\n\n    function setStablePrice(address underlying, int256 price) external onlyGovernance {\n        requireNonEmptyAddress(underlying);\n        stablePrice[underlying] = price;\n    }\n}"
    },
    {
      "filename": "contracts/VUSD.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragm"
    }
  ]
}