{
  "Title": "[H-02] Wrong implementation of `withdrawAdminFees()` can cause the `adminFees` to be charged multiple times and therefore cause users' fund loss",
  "Content": "_Submitted by WatchPug_\n\n[SwapUtils.sol#L1053-L1062](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/SwapUtils.sol#L1053-L1062)<br>\n\n```solidity\nfunction withdrawAdminFees(Swap storage self, address to) internal {\n  IERC20[] memory pooledTokens = self.pooledTokens;\n  for (uint256 i = 0; i < pooledTokens.length; i++) {\n    IERC20 token = pooledTokens[i];\n    uint256 balance = self.adminFees[i];\n    if (balance != 0) {\n      token.safeTransfer(to, balance);\n    }\n  }\n}\n```\n\n`self.adminFees[i]` should be reset to 0 every time it's withdrawn. Otherwise, the `adminFees` can be withdrawn multiple times.\n\nThe admin may just be unaware of this issue and casualty `withdrawAdminFees()` from time to time, and rug all the users slowly.\n\n### Recommended Mitigation Steps\n\nChange to:\n\n```solidity\nfunction withdrawAdminFees(Swap storage self, address to) internal {\n  IERC20[] memory pooledTokens = self.pooledTokens;\n  for (uint256 i = 0; i < pooledTokens.length; i++) {\n    IERC20 token = pooledTokens[i];\n    uint256 balance = self.adminFees[i];\n    if (balance != 0) {\n      self.adminFees[i] = 0;\n      token.safeTransfer(to, balance);\n    }\n  }\n}\n```\n\n**[LayneHaber (Connext) confirmed and resolved](https://github.com/code-423n4/2022-06-connext-findings/issues/202#issuecomment-1167495532):**\n > [connext/nxtp@8eef974](https://github.com/connext/nxtp/pull/1450/commits/8eef974724bf2b9cdd506a1a63d8cc869303c3e5)\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-06-connext-findings/issues/202#issuecomment-1206907050):**\n > Completely agree with the validity of this finding. Even if the admin was _not_ malicious, the bug will still continue to withdraw additional fees which were not included as part of the swap calculations. LPs would lose considerable value as a result.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2022-06-connext",
  "Code": [
    {
      "filename": "contracts/contracts/core/connext/libraries/SwapUtils.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {LPToken} from \"../helpers/LPToken.sol\";\nimport {AmplificationUtils} from \"./AmplificationUtils.sol\";\nimport {MathUtils} from \"./MathUtils.sol\";\n\n/**\n * @title SwapUtils library\n * @notice A library to be used within Swap.sol. Contains functions responsible for custody and AMM functionalities.\n * @dev Contracts relying on this library must initialize SwapUtils.Swap struct then use this library\n * for SwapUtils.Swap struct. Note that this library contains both functions called by users and admins.\n * Admin functions should be protected within contracts using this library.\n */\nlibrary SwapUtils {\n  using SafeERC20 for IERC20;\n  using SafeMath for uint256;\n  using MathUtils for uint256;\n\n  /*** EVENTS ***/\n\n  event TokenSwap(address indexed buyer, uint256 tokensSold, uint256 tokensBought, uint128 soldId, uint128 boughtId);\n  event AddLiquidity(\n    address indexed provider,\n    uint256[] tokenAmounts,\n    uint256[] fees,\n    uint256 invariant,\n    uint256 lpTokenSupply\n  );\n  event RemoveLiquidity(address indexed provider, uint256[] tokenAmounts, uint256 lpTokenSupply);\n  event RemoveLiquidityOne(\n    address indexed provider,\n    uint256 lpTokenAmount,\n    uint256 lpTokenSupply,\n    uint256 boughtId,\n    uint256 tokensBought\n  );\n  event RemoveLiquidityImbalance(\n    address indexed provider,\n    uint256[] tokenAmounts,\n    uint256[] fees,\n    uint256 invariant,\n    uint256 lpTokenSupply\n  );\n  event NewAdminFee(uint256 newAdminFee);\n  event NewSwapFee(uint256 newSwapFee);\n\n  struct Swap {\n    // variables around the ramp management of A,\n    // the amplification coefficient * n * (n - 1)\n    // see https://www.curve.fi/stableswap-paper.pdf for details\n    uint256 initialA;\n    uint256 futureA;\n    uint256 initialATime;\n    uint256 futureATime;\n    // fee calculation\n    uint256 swapFee;\n    uint256 adminFee;\n    LPToken lpToken;\n    // contract references for all tokens being pooled\n    IERC20[] pooledTokens;\n    // multipliers for each pooled token's precision to get to POOL_PRECISION_DECIMALS\n    // for example, TBTC has 18 decimals, so the multiplier should be 1. WBTC\n    // has 8, so the multiplier should be 10 ** 18 / 10 ** 8 => 10 ** 10\n    uint256[] tokenPrecisionMultipliers;\n    // the pool balance of each token, in the token's precision\n    // the contract's actual token balance might differ\n    uint256[] balances;\n    // the admin fee balance of each token, in the token's precision\n    uint256[] adminFees;\n  }\n\n  // Struct storing variables used in calculations in the\n  // calculateWithdrawOneTokenDY function to avoid stack too deep errors\n  struct CalculateWithdrawOneTokenDYInfo {\n    uint256 d0;\n    uint256 d1;\n    uint256 newY;\n    uint256 feePerToken;\n    uint256 preciseA;\n  }\n\n  // Struct storing variables used in calculations in the\n  // {add,remove}Liquidity functions to avoid stack too deep errors\n  struct ManageLiquidityInfo {\n    uint256 d0;\n    uint256 d1;\n    uint256 d2;\n    uint256 preciseA;\n    LPToken lpToken;\n    uint256 totalSupply;\n    uint256[] balances;\n    uint256[] multipliers;\n  }\n\n  // the precision all pools tokens will be converted to\n  uint8 internal constant POOL_PRECISION_DECIMALS = 18;\n\n  // the denominator used to calculate admin and LP fees. For example, an\n  // LP fee might be something like tradeAmount.mul(fee).div(FEE_DENOMINATOR)\n  uint256 internal constant FEE_DENOMINATOR = 10**10;\n\n  // Max swap fee is 1% or 100bps of each swap\n  uint256 internal constant MAX_SWAP_FEE = 10**8;\n\n  // Max adminFee is 100% of the swapFee\n  // adminFee does not add additional fee on top of swapFee\n  // Instead it takes a certain % of the swapFee. Therefore it has no impact on the\n  // users but only on the earnings of LPs\n  uint256 internal constant MAX_ADMIN_FEE = 10**10;\n\n  // Constant value used as max loop limit\n  uint256 internal constant MAX_LOOP_LIMIT = 256;\n\n  /*** VIEW & PURE FUNCTIONS ***/\n\n  function _getAPrecise(Swap storage self) private view returns (uint256) {\n    return AmplificationUtils._getAPrecise(self);\n  }\n\n  /**\n   * @notice Calculate the dy, the amount of selected token that user receives and\n   * the fee of withdrawing in one token\n   * @param tokenAmount the amount to withdraw in the pool's precision\n   * @param tokenIndex which token will be withdrawn\n   * @param self Swap struct to read from\n   * @return the amount of token user will receive\n   */\n  function calculateWithdrawOneToken(\n    Swap storage self,\n    uint256 tokenAmount,\n    uint8 tokenIndex\n  ) internal view returns (uint256) {\n    (uint256 availableTokenAmount, ) = _calculateWithdrawOneToken(\n      self,\n      tokenAmount,\n      tokenIndex,\n      self.lpToken.totalSupply()\n    );\n    return availableTokenAmount;\n  }\n\n  function _calculateWithdrawOneToken(\n    Swap storage self,\n    uint256 tokenAmount,\n    uint8 tokenIndex,\n    uint256 totalSupply\n  ) private view returns (uint256, uint256) {\n    uint256 dy;\n    uint256 newY;\n    uint256 currentY;\n\n    (dy, newY, currentY) = calculateWithdrawOneTokenDY(self, tokenIndex, tokenAmount, totalSupply);\n\n    // dy_0 (without fees)\n    // dy, dy_0 - dy\n\n    uint256 dySwapFee = currentY.sub(newY).div(self.tokenPrecisionMultipliers[tokenIndex]).sub(dy);\n\n    return (dy, dySwapFee);\n  }\n\n  /**\n   * @notice Calculate the dy of withdrawing in one token\n   * @param self Swap struct to read from\n   * @param tokenIndex which token will be withdrawn\n   * @param tokenAmount the amount to withdraw in the pools precision\n   * @return the d and the new y after withdrawing one token\n   */\n  function calculateWithdrawOneTokenDY(\n    Swap storage self,\n    uint8 tokenIndex,\n    uint256 tokenAmount,\n    uint256 totalSupply\n  )\n    internal\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    // Get the current D, then solve the stableswap invariant\n    // y_i for D - tokenAmount\n    uint256[] memory xp = _xp(self);\n\n    require(tokenIndex < xp.length, \"Token index out of range\");\n\n    CalculateWithdrawOneTokenDYInfo memory v = CalculateWithdrawOneTokenDYInfo(0, 0, 0, 0, 0);\n    v.preciseA = _getAPrecise(self);\n    v.d0 = getD(xp, v.preciseA);\n    v.d1 = v.d0.sub(tokenAmount.mul(v.d0).div(totalSupply));\n\n    require(tokenAmount <= xp[tokenIndex], \"Withdraw exceeds available\");\n\n    v.newY = getYD(v.preciseA, tokenIndex, xp, v.d1);\n\n    uint256[] memory xpReduced = new uint256[](xp.length);\n\n    v.feePerToken = _feePerToken(self.swapFee, xp.length);\n    for (uint256 i = 0; i < xp.length; i++) {\n      uint256 xpi = xp[i];\n      // if i == tokenIndex, dxExpected = xp[i] * d1 / d0 - newY\n      // else dxExpected = xp[i] - (xp[i] * d1 / d0)\n      // xpReduced[i] -= dxExpected * fee / FEE_DENOMINATOR\n      xpReduced[i] = xpi.sub(\n        ((i == tokenIndex) ? xpi.mul(v.d1).div(v.d0).sub(v.newY) : xpi.sub(xpi.mul(v.d1).div(v.d0)))\n          .mul(v.feePerToken)\n          .div(FEE_DENOMINATOR)\n      );\n    }\n\n    uint256 dy = xpReduced[tokenIndex].sub(getYD(v.preciseA, tokenIndex, xpReduced, v.d1));\n    dy = dy.sub(1).div(self.tokenPrecisionMultipliers[tokenIndex]);\n\n    return (dy, v.newY, xp[tokenIndex]);\n  }\n\n  /**\n   * @notice Calculate the price of a token in the pool with given\n   * precision-adjusted balances and a particular D.\n   *\n   * @dev This is accomplished via solving the invariant iteratively.\n   * See the StableSwap paper and Curve.fi implementation for further details.\n   *\n   * x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\n   * x_1**2 + b*x_1 = c\n   * x_1 = (x_1**2 + c) / (2*x_1 + b)\n   *\n   * @param a the amplification coefficient * n * (n - 1). See the StableSwap paper for details.\n   * @param tokenIndex Index of token we are calculating for.\n   * @param xp a precision-adjusted set of pool balances. Array should be\n   * the same cardinality as the pool.\n   * @param d the stableswap invariant\n   * @return the price of the token, in the same precision as in xp\n   */\n  function getYD(\n    uint256 a,\n    uint8 tokenIndex,\n    uint256[] memory xp,\n    uint256 d\n  ) internal pure returns (uint256) {\n    uint256 numTokens = xp.length;\n    require(tokenIndex < numTokens, \"Token not found\");\n\n    uint256 c = d;\n    uint256 s;\n    uint256 nA = a.mul(numTokens);\n\n    for (uint256 i = 0; i < numTokens; i++) {\n      if (i != tokenIndex) {\n        s = s.add(xp[i]);\n        c = c.mul(d).div(xp[i].mul(numTokens));\n        // If we were to protect the division loss we would have to keep the denominator separate\n        // and divide at the end. However this leads to overflow with large numTokens or/and D.\n        // c = c * D * D * D * ... overflow!\n      }\n    }\n    c = c.mul(d).mul(AmplificationUtils.A_PRECISION).div(nA.mul(numTokens));\n\n    uint256 b = s.add(d.mul(AmplificationUtils.A_PRECISION).div(nA));\n    uint256 yPrev;\n    uint256 y = d;\n    for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n      yPrev = y;\n      y = y.mul(y).add(c).div(y.mul(2).add(b).sub(d));\n      if (y.within1(yPrev)) {\n        return y;\n      }\n    }\n    revert(\"Approximation did not converge\");\n  }\n\n  /**\n   * @notice Get D, the StableSwap invariant, based on a set of balances and a particular A.\n   * @param xp a precision-adjusted set of pool balances. Array should be the same cardinality\n   * as the pool.\n   * @param a the amplification coefficient * n * (n - 1) in A_PRECISION.\n   * See the StableSwap paper for details\n   * @return the invariant, at the precision of the pool\n   */\n  function getD(uint256[] memory xp, uint256 a) internal pure returns (uint256) {\n    uint256 numTokens = xp.length;\n    uint256 s;\n    for (uint256 i = 0; i < numTokens; i++) {\n      s = s.add(xp[i]);\n    }\n    if (s == 0) {\n      return 0;\n    }\n\n    uint256 prevD;\n    uint256 d = s;\n    uint256 nA = a.mul(numTokens);\n\n    for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n      uint256 dP = d;\n      for (uint256 j = 0; j < numTokens; j++) {\n        dP = dP.mul(d).div(xp[j].mul(numTokens));\n        // If we were to protect the division loss we would have to keep the denominator separate\n        // and divide at the end. However this leads to overflow with large numTokens or/and D.\n        // dP = dP * D * D * D * ... overflow!\n      }\n      prevD = d;\n      d = nA.mul(s).div(AmplificationUtils.A_PRECISION).add(dP.mul(numTokens)).mul(d).div(\n        nA.sub(AmplificationUtils.A_PRECISION).mul(d).div(AmplificationUtils.A_PRECISION).add(numTokens.add(1).mul(dP))\n      );\n      if (d.within1(prevD)) {\n        return d;\n      }\n    }\n\n    // Convergence should occur in 4 loops or less. If this is reached, there may be something wrong\n    // with the pool. If this were to occur repeatedly, LPs should withdraw via `removeLiquidity()`\n    // function which does not rely on D.\n    revert(\"D does not converge\");\n  }\n\n  /**\n   * @notice Given a set of balances and precision multipliers, return the\n   * precision-adjusted balances.\n   *\n   * @param balances an array of token balances, in their native precisions.\n   * These should generally correspond with pooled tokens.\n   *\n   * @param precisionMultipliers an array of multipliers, corresponding to\n   * the amounts in the balances array. When multiplied together they\n   * should yield amounts at the pool's precision.\n   *\n   * @return an array of amounts \"scaled\" to the pool's precision\n   */\n  function _xp(uint256[] memory balances, uint256[] memory precisionMultipliers)\n    internal\n    pure\n    returns (uint256[] memory)\n  {\n    uint256 numTokens = balances.length;\n    require(numTokens == precisionMultipliers.length, \"Balances must match multipliers\");\n    uint256[] memory xp = new uint256[](numTokens);\n    for (uint256 i = 0; i < numTokens; i++) {\n      xp[i] = balances[i].mul(precisionMultipliers[i]);\n    }\n    return xp;\n  }\n\n  /**\n   * @notice Return the precision-adjusted balances of all tokens in the pool\n   * @param self Swap struct to read from\n   * @return the pool balances \"scaled\" to the pool's precision, allowing\n   * them to be more easily compared.\n   */\n  function _xp(Swap storage self) internal view returns (uint256[] memory) {\n    return _xp(self.balances, self.tokenPrecisionMultipliers);\n  }\n\n  /**\n   * @notice Get the virtual price, to help calculate profit\n   * @param self Swap struct to read from\n   * @return the virtual price, scaled to precision of POOL_PRECISION_DECIMALS\n   */\n  function getVirtualPrice(Swap storage self) internal view returns (uint256) {\n    uint256 d = getD(_xp(self), _getAPrecise(self));\n    LPToken lpToken = self.lpToken;\n    uint256 supply = lpToken.totalSupply();\n    if (supply > 0) {\n      return d.mul(10**uint256(POOL_PRECISION_DECIMALS)).div(supply);\n    }\n    return 0;\n  }\n\n  /**\n   * @notice Calculate the new balances of the tokens given the indexes of the token\n   * that is swapped from (FROM) and the token that is swapped to (TO).\n   * This function is used as a helper function to calculate how much TO token\n   * the user should receive on swap.\n   *\n   * @param preciseA precise form of amplification coefficient\n   * @param tokenIndexFrom index of FROM token\n   * @param tokenIndexTo index of TO token\n   * @param x the new total amount of FROM token\n   * @param xp balances of the tokens in the pool\n   * @return the amount of TO token that should remain in the pool\n   */\n  function getY(\n    uint256 preciseA,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 x,\n    uint256[] memory xp\n  ) internal pure returns (uint256) {\n    uint256 numTokens = xp.length;\n    require(tokenIndexFrom != tokenIndexTo, \"Can't compare token to itself\");\n    require(tokenIndexFrom < numTokens && tokenIndexTo < numTokens, \"Tokens must be in pool\");\n\n    uint256 d = getD(xp, preciseA);\n    uint256 c = d;\n    uint256 s;\n    uint256 nA = numTokens.mul(preciseA);\n\n    uint256 _x;\n    for (uint256 i = 0; i < numTokens; i++) {\n      if (i == tokenIndexFrom) {\n        _x = x;\n      } else if (i != tokenIndexTo) {\n        _x = xp[i];\n      } else {\n        continue;\n      }\n      s = s.add(_x);\n      c = c.mul(d).div(_x.mul(numTokens));\n      // If we were to protect the division loss we would have to keep the denominator separate\n      // and divide at the end. However this leads to overflow with large numTokens or/and D.\n      // c = c * D * D * D * ... overflow!\n    }\n    c = c.mul(d).mul(AmplificationUtils.A_PRECISION).div(nA.mul(numTokens));\n    uint256 b = s.add(d.mul(AmplificationUtils.A_PRECISION).div(nA));\n    uint256 yPrev;\n    uint256 y = d;\n\n    // iterative approximation\n    for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n      yPrev = y;\n      y = y.mul(y).add(c).div(y.mul(2).add(b).sub(d));\n      if (y.within1(yPrev)) {\n        return y;\n      }\n    }\n    revert(\"Approximation did not converge\");\n  }\n\n  /**\n   * @notice Externally calculates a swap between two tokens.\n   * @param self Swap struct to read from\n   * @param tokenIndexFrom the token to sell\n   * @param tokenIndexTo the token to buy\n   * @param dx the number of tokens to sell. If the token charges a fee on transfers,\n   * use the amount that gets transferred after the fee.\n   * @return dy the number of tokens the user will get\n   */\n  function calculateSwap(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx\n  ) internal view returns (uint256 dy) {\n    (dy, ) = _calculateSwap(self, tokenIndexFrom, tokenIndexTo, dx, self.balances);\n  }\n\n  /**\n   * @notice Externally calculates a swap between two tokens.\n   * @param self Swap struct to read from\n   * @param tokenIndexFrom the token to sell\n   * @param tokenIndexTo the token to buy\n   * @param dy the number of tokens to buy.\n   * @return dx the number of tokens the user have to transfer + fee\n   */\n  function calculateSwapInv(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dy\n  ) internal view returns (uint256 dx) {\n    (dx, ) = _calculateSwapInv(self, tokenIndexFrom, tokenIndexTo, dy, self.balances);\n  }\n\n  /**\n   * @notice Internally calculates a swap between two tokens.\n   *\n   * @dev The caller is expected to transfer the actual amounts (dx and dy)\n   * using the token contracts.\n   *\n   * @param self Swap struct to read from\n   * @param tokenIndexFrom the token to sell\n   * @param tokenIndexTo the token to buy\n   * @param dx the number of tokens to sell. If the token charges a fee on transfers,\n   * use the amount that gets transferred after the fee.\n   * @return dy the number of tokens the user will get\n   * @return dyFee the associated fee\n   */\n  function _calculateSwap(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx,\n    uint256[] memory balances\n  ) internal view returns (uint256 dy, uint256 dyFee) {\n    uint256[] memory multipliers = self.tokenPrecisionMultipliers;\n    uint256[] memory xp = _xp(balances, multipliers);\n    require(tokenIndexFrom < xp.length && tokenIndexTo < xp.length, \"Token index out of range\");\n    uint256 x = dx.mul(multipliers[tokenIndexFrom]).add(xp[tokenIndexFrom]);\n    uint256 y = getY(_getAPrecise(self), tokenIndexFrom, tokenIndexTo, x, xp);\n    dy = xp[tokenIndexTo].sub(y).sub(1);\n    dyFee = dy.mul(self.swapFee).div(FEE_DENOMINATOR);\n    dy = dy.sub(dyFee).div(multipliers[tokenIndexTo]);\n  }\n\n  /**\n   * @notice Internally calculates a swap between two tokens.\n   *\n   * @dev The caller is expected to transfer the actual amounts (dx and dy)\n   * using the token contracts.\n   *\n   * @param self Swap struct to read from\n   * @param tokenIndexFrom the token to sell\n   * @param tokenIndexTo the token to buy\n   * @param dy the number of tokens to buy. If the token charges a fee on transfers,\n   * use the amount that gets transferred after the fee.\n   * @return dx the number of tokens the user have to deposit\n   * @return dxFee the associated fee\n   */\n  function _calculateSwapInv(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dy,\n    uint256[] memory balances\n  ) internal view returns (uint256 dx, uint256 dxFee) {\n    uint256[] memory multipliers = self.tokenPrecisionMultipliers;\n    uint256[] memory xp = _xp(balances, multipliers);\n    require(tokenIndexFrom < xp.length && tokenIndexTo < xp.length, \"Token index out of range\");\n\n    uint256 a = _getAPrecise(self);\n    uint256 d0 = getD(xp, a);\n\n    xp[tokenIndexTo] = xp[tokenIndexTo].sub(dy.mul(multipliers[tokenIndexTo]));\n    uint256 x = getYD(a, tokenIndexFrom, xp, d0);\n    dx = x.sub(xp[tokenIndexFrom]).add(1);\n    dxFee = dx.mul(self.swapFee).div(FEE_DENOMINATOR);\n    dx = dx.add(dxFee).div(multipliers[tokenIndexFrom]);\n  }\n\n  /**\n   * @notice A simple method to calculate amount of each underlying\n   * tokens that is returned upon burning given amount of\n   * LP tokens\n   *\n   * @param amount the amount of LP tokens that would to be burned on\n   * withdrawal\n   * @return array of amounts of tokens user will receive\n   */\n  function calculateRemoveLiquidity(Swap storage self, uint256 amount) internal view returns (uint256[] memory) {\n    return _calculateRemoveLiquidity(self.balances, amount, self.lpToken.totalSupply());\n  }\n\n  function _calculateRemoveLiquidity(\n    uint256[] memory balances,\n    uint256 amount,\n    uint256 totalSupply\n  ) internal pure returns (uint256[] memory) {\n    require(amount <= totalSupply, \"Cannot exceed total supply\");\n\n    uint256[] memory amounts = new uint256[](balances.length);\n\n    for (uint256 i = 0; i < balances.length; i++) {\n      amounts[i] = balances[i].mul(amount).div(totalSupply);\n    }\n    return amounts;\n  }\n\n  /**\n   * @notice A simple method to calculate prices from deposits or\n   * withdrawals, excluding fees but including slippage. This is\n   * helpful as an input into the various \"min\" parameters on calls\n   * to fight front-running\n   *\n   * @dev This shouldn't be used outside frontends for user estimates.\n   *\n   * @param self Swap struct to read from\n   * @param amounts an array of token amounts to deposit or withdrawal,\n   * corresponding to pooledTokens. The amount should be in each\n   * pooled token's native precision. If a token charges a fee on transfers,\n   * use the amount that gets transferred after the fee.\n   * @param deposit whether this is a deposit or a withdrawal\n   * @return if deposit was true, total amount of lp token that will be minted and if\n   * deposit was false, total amount of lp token that will be burned\n   */\n  function calculateTokenAmount(\n    Swap storage self,\n    uint256[] calldata amounts,\n    bool deposit\n  ) internal view returns (uint256) {\n    uint256 a = _getAPrecise(self);\n    uint256[] memory balances = self.balances;\n    uint256[] memory multipliers = self.tokenPrecisionMultipliers;\n\n    uint256 d0 = getD(_xp(balances, multipliers), a);\n    for (uint256 i = 0; i < balances.length; i++) {\n      if (deposit) {\n        balances[i] = balances[i].add(amounts[i]);\n      } else {\n        balances[i] = balances[i].sub(amounts[i], \"Cannot withdraw more than available\");\n      }\n    }\n    uint256 d1 = getD(_xp(balances, multipliers), a);\n    uint256 totalSupply = self.lpToken.totalSupply();\n\n    if (deposit) {\n      return d1.sub(d0).mul(totalSupply).div(d0);\n    } else {\n      return d0.sub(d1).mul(totalSupply).div(d0);\n    }\n  }\n\n  /**\n   * @notice return accumulated amount of admin fees of the token with given index\n   * @param self Swap struct to read from\n   * @param index Index of the pooled token\n   * @return admin balance in the token's precision\n   */\n  function getAdminBalance(Swap storage self, uint256 index) internal view returns (uint256) {\n    require(index < self.pooledTokens.length, \"Token index out of range\");\n    return self.adminFees[index];\n  }\n\n  /**\n   * @notice internal helper function to calculate fee per token multiplier used in\n   * swap fee calculations\n   * @param swapFee swap fee for the tokens\n   * @param numTokens number of tokens pooled\n   */\n  function _feePerToken(uint256 swapFee, uint256 numTokens) internal pure returns (uint256) {\n    return swapFee.mul(numTokens).div(numTokens.sub(1).mul(4));\n  }\n\n  /*** STATE MODIFYING FUNCTIONS ***/\n\n  /**\n   * @notice swap two tokens in the pool\n   * @param self Swap struct to read from and write to\n   * @param tokenIndexFrom the token the user wants to sell\n   * @param tokenIndexTo the token the user wants to buy\n   * @param dx the amount of tokens the user wants to sell\n   * @param minDy the min amount the user would like to receive, or revert.\n   * @return amount of token user received on swap\n   */\n  function swap(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx,\n    uint256 minDy\n  ) internal returns (uint256) {\n    {\n      IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom];\n      require(dx <= tokenFrom.balanceOf(msg.sender), \"Cannot swap more than you own\");\n      // Transfer tokens first to see if a fee was charged on transfer\n      uint256 beforeBalance = tokenFrom.balanceOf(address(this));\n      tokenFrom.safeTransferFrom(msg.sender, address(this), dx);\n\n      // Use the actual transferred amount for AMM math\n      dx = tokenFrom.balanceOf(address(this)).sub(beforeBalance);\n    }\n\n    uint256 dy;\n    uint256 dyFee;\n    uint256[] memory balances = self.balances;\n    (dy, dyFee) = _calculateSwap(self, tokenIndexFrom, tokenIndexTo, dx, balances);\n    require(dy >= minDy, \"Swap didn't result in min tokens\");\n\n    uint256 dyAdminFee = dyFee.mul(self.adminFee).div(FEE_DENOMINATOR).div(\n      self.tokenPrecisionMultipliers[tokenIndexTo]\n    );\n\n    self.balances[tokenIndexFrom] = balances[tokenIndexFrom].add(dx);\n    self.balances[tokenIndexTo] = balances[tokenIndexTo].sub(dy).sub(dyAdminFee);\n    if (dyAdminFee > 0) {\n      self.adminFees[tokenIndexTo] = self.adminFees[tokenIndexTo].add(dyAdminFee);\n    }\n\n    self.pooledTokens[tokenIndexTo].safeTransfer(msg.sender, dy);\n\n    emit TokenSwap(msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);\n\n    return dy;\n  }\n\n  /**\n   * @notice swap two tokens in the pool\n   * @param self Swap struct to read from and write to\n   * @param tokenIndexFrom the token the user wants to sell\n   * @param tokenIndexTo the token the user wants to buy\n   * @param dy the amount of tokens the user wants to buy\n   * @param maxDx the max amount the user would like to send.\n   * @return amount of token user have to transfer on swap\n   */\n  function swapOut(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dy,\n    uint256 maxDx\n  ) internal returns (uint256) {\n    require(dy <= self.balances[tokenIndexTo], \"Cannot get more than pool balance\");\n\n    uint256 dx;\n    uint256 dxFee;\n    uint256[] memory balances = self.balances;\n    (dx, dxFee) = _calculateSwapInv(self, tokenIndexFrom, tokenIndexTo, dy, balances);\n    require(dx <= maxDx, \"Swap needs more than max tokens\");\n\n    uint256 dxAdminFee = dxFee.mul(self.adminFee).div(FEE_DENOMINATOR).div(\n      self.tokenPrecisionMultipliers[tokenIndexFrom]\n    );\n\n    self.balances[tokenIndexFrom] = balances[tokenIndexFrom].add(dx).sub(dxAdminFee);\n    self.balances[tokenIndexTo] = balances[tokenIndexTo].sub(dy);\n    if (dxAdminFee > 0) {\n      self.adminFees[tokenIndexFrom] = self.adminFees[tokenIndexFrom].add(dxAdminFee);\n    }\n\n    {\n      IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom];\n      require(dx <= tokenFrom.balanceOf(msg.sender), \"Cannot swap more than you own\");\n      // Transfer tokens first to see if a fee was charged on transfer\n      uint256 beforeBalance = tokenFrom.balanceOf(address(this));\n      tokenFrom.safeTransferFrom(msg.sender, address(this), dx);\n\n      // Use the actual transferred amount for AMM math\n      require(dx == tokenFrom.balanceOf(address(this)).sub(beforeBalance), \"not support fee token\");\n    }\n\n    self.pooledTokens[tokenIndexTo].safeTransfer(msg.sender, dy);\n\n    emit TokenSwap(msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);\n\n    return dx;\n  }\n\n  /**\n   * @notice swap two tokens in the pool internally\n   * @param self Swap struct to read from and write to\n   * @param tokenIndexFrom the token the user wants to sell\n   * @param tokenIndexTo the token the user wants to buy\n   * @param dx the amount of tokens the user wants to sell\n   * @param minDy the min amount the user would like to receive, or revert.\n   * @return amount of token user received on swap\n   */\n  function swapInternal(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx,\n    uint256 minDy\n  ) internal returns (uint256) {\n    IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom];\n    require(dx <= tokenFrom.balanceOf(msg.sender), \"Cannot swap more than you own\");\n\n    uint256 dy;\n    uint256 dyFee;\n    uint256[] memory balances = self.balances;\n    (dy, dyFee) = _calculateSwap(self, tokenIndexFrom, tokenIndexTo, dx, balances);\n    require(dy >= minDy, \"Swap didn't result in min tokens\");\n\n    uint256 dyAdminFee = dyFee.mul(self.adminFee).div(FEE_DENOMINATOR).div(\n      self.tokenPrecisionMultipliers[tokenIndexTo]\n    );\n\n    self.balances[tokenIndexFrom] = balances[tokenIndexFrom].add(dx);\n    self.balances[tokenIndexTo] = balances[tokenIndexTo].sub(dy).sub(dyAdminFee);\n\n    if (dyAdminFee > 0) {\n      self.adminFees[tokenIndexTo] = self.adminFees[tokenIndexTo].add(dyAdminFee);\n    }\n\n    emit TokenSwap(msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);\n\n    return dy;\n  }\n\n  /**\n   * @notice Should get exact amount out of AMM for asset put in\n   */\n  function swapInternalOut(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dy,\n    uint256 maxDx\n  ) internal returns (uint256) {\n    require(dy <= self.balances[tokenIndexTo], \"Cannot get more than pool balance\");\n\n    uint256 dx;\n    uint256 dxFee;\n    uint256[] memory balances = self.balances;\n    (dx, dxFee) = _calculateSwapInv(self, tokenIndexFrom, tokenIndexTo, dy, balances);\n    require(dx <= maxDx, \"Swap didn't result in min tokens\");\n\n    uint256 dxAdminFee = dxFee.mul(self.adminFee).div(FEE_DENOMINATOR).div(\n      self.tokenPrecisionMultipliers[tokenIndexFrom]\n    );\n\n    self.balances[tokenIndexFrom] = balances[tokenIndexFrom].add(dx).sub(dxAdminFee);\n    self.balances[tokenIndexTo] = balances[tokenIndexTo].sub(dy);\n\n    if (dxAdminFee > 0) {\n      self.adminFees[tokenIndexFrom] = self.adminFees[tokenIndexFrom].add(dxAdminFee);\n    }\n\n    emit TokenSwap(msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);\n\n    return dx;\n  }\n\n  /**\n   * @notice Add liquidity to the pool\n   * @param self Swap struct to read from and write to\n   * @param amounts the amounts of each token to add, in their native precision\n   * @param minToMint the minimum LP tokens adding this amount of liquidity\n   * should mint, otherwise revert. Handy for front-running mitigation\n   * allowed addresses. If the pool is not in the guarded launch phase, this parameter will be ignored.\n   * @return amount of LP token user received\n   */\n  function addLiquidity(\n    Swap storage self,\n    uint256[] memory amounts,\n    uint256 minToMint\n  ) internal returns (uint256) {\n    IERC20[] memory pooledTokens = self.pooledTokens;\n    require(amounts.length == pooledTokens.length, \"Amounts must match pooled tokens\");\n\n    // current state\n    ManageLiquidityInfo memory v = ManageLiquidityInfo(\n      0,\n      0,\n      0,\n      _getAPrecise(self),\n      self.lpToken,\n      0,\n      self.balances,\n      self.tokenPrecisionMultipliers\n    );\n    v.totalSupply = v.lpToken.totalSupply();\n\n    if (v.totalSupply != 0) {\n      v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\n    }\n\n    uint256[] memory newBalances = new uint256[](pooledTokens.length);\n\n    for (uint256 i = 0; i < pooledTokens.length; i++) {\n      require(v.totalSupply != 0 || amounts[i] > 0, \"Must supply all tokens in pool\");\n\n      // Transfer tokens first to see if a fee was charged on transfer\n      if (amounts[i] != 0) {\n        uint256 beforeBalance = pooledTokens[i].balanceOf(address(this));\n        pooledTokens[i].safeTransferFrom(msg.sender, address(this), amounts[i]);\n\n        // Update the amounts[] with actual transfer amount\n        amounts[i] = pooledTokens[i].balanceOf(address(this)).sub(beforeBalance);\n      }\n\n      newBalances[i] = v.balances[i].add(amounts[i]);\n    }\n\n    // invariant after change\n    v.d1 = getD(_xp(newBalances, v.multipliers), v.preciseA);\n    require(v.d1 > v.d0, \"D should increase\");\n\n    // updated to reflect fees and calculate the user's LP tokens\n    v.d2 = v.d1;\n    uint256[] memory fees = new uint256[](pooledTokens.length);\n\n    if (v.totalSupply != 0) {\n      uint256 feePerToken = _feePerToken(self.swapFee, pooledTokens.length);\n      for (uint256 i = 0; i < pooledTokens.length; i++) {\n        uint256 idealBalance = v.d1.mul(v.balances[i]).div(v.d0);\n        fees[i] = feePerToken.mul(idealBalance.difference(newBalances[i])).div(FEE_DENOMINATOR);\n        uint256 adminFee = fees[i].mul(self.adminFee).div(FEE_DENOMINATOR);\n        self.balances[i] = newBalances[i].sub(adminFee);\n        self.adminFees[i] = self.adminFees[i].add(adminFee);\n        newBalances[i] = newBalances[i].sub(fees[i]);\n      }\n      v.d2 = getD(_xp(newBalances, v.multipliers), v.preciseA);\n    } else {\n      // the initial depositor doesn't pay fees\n      self.balances = newBalances;\n    }\n\n    uint256 toMint;\n    if (v.totalSupply == 0) {\n      toMint = v.d1;\n    } else {\n      toMint = v.d2.sub(v.d0).mul(v.totalSupply).div(v.d0);\n    }\n\n    require(toMint >= minToMint, \"Couldn't mint min requested\");\n\n    // mint the user's LP tokens\n    v.lpToken.mint(msg.sender, toMint);\n\n    emit AddLiquidity(msg.sender, amounts, fees, v.d1, v.totalSupply.add(toMint));\n\n    return toMint;\n  }\n\n  /**\n   * @notice Burn LP tokens to remove liquidity from the pool.\n   * @dev Liquidity can always be removed, even when the pool is paused.\n   * @param self Swap struct to read from and write to\n   * @param amount the amount of LP tokens to burn\n   * @param minAmounts the minimum amounts of each token in the pool\n   * acceptable for this burn. Useful as a front-running mitigation\n   * @return amounts of tokens the user received\n   */\n  function removeLiquidity(\n    Swap storage self,\n    uint256 amount,\n    uint256[] calldata minAmounts\n  ) internal returns (uint256[] memory) {\n    LPToken lpToken = self.lpToken;\n    IERC20[] memory pooledTokens = self.pooledTokens;\n    require(amount <= lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\n    require(minAmounts.length == pooledTokens.length, \"minA"
    }
  ]
}