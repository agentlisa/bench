{
  "Title": "[M-08] If an airdrop happens before a mint the price could skyrocket",
  "Content": "\nAs explained by the [docs](https://seize-io.gitbook.io/nextgen/nextgen-smart-contracts/features#minting-process), several steps can occur during the minting process. However, an airdrop before `salesOption` 3 can lead to price inflation.\n\n### Proof of Concept\n\nUnder `salesOption` 3, [getPrice](https://github.com/code-423n4/2023-10-nextgen/blob/main/smart-contracts/MinterContract.sol#L536) returns:\n\n```solidity\nreturn collectionPhases[_collectionId].collectionMintCost\n                    + ((collectionPhases[_collectionId].collectionMintCost / collectionPhases[_collectionId].rate) * gencore.viewCirSupply(_collectionId));\n```\n\nThis is the increased rate based on the NFTs **already in circulation**. If an airdrop occurs before a mint with `salesOption` 3, the price will be much higher than intended.\n\nExample:\n\n| Steps         | Option     | NFTs    | Price | Rate                  |\n| ------------- | ---------- | ------- | ----- | --------------------- |\n| 1 OG users    | Airdropped | 20 NFTs | free  | -                     |\n| 2 Whitelisted | Sales 3    | 10 NFTs | 1 ETH | 10 (0.1 ETH increase) |\n| 3 Public      | Sales 1    | 70 NFTs | 2 ETH | -                     |\n\nWith the current three steps, after the airdrop, `salesOption` 3 should start at 1 ETH and gradually increase to 2 ETH. Afterward, it should mint at a constant rate of 2 ETH.\n\nHowever, when sales option 3 starts, [getPrice](https://github.com/code-423n4/2023-10-nextgen/blob/main/smart-contracts/MinterContract.sol#L536) will return 3 ETH instead of 1 ETH. This will cause the initial users to pay an inflated price, which was not intended by the owner and can harm their reputation. It's also unfair to the users, as these so-called special (whitelisted) users will pay increased prices.\n\n```\n$$\n\\begin{align/ast}\n\\text{collectionMintCost} + \\left(\\frac{\\text{collectionMintCost}}{\\text{rate}}\\right) \\times \\text{cirSupply}  \\\\\n&= 1 \\text{eth} + 0.1 \\text{eth} \\times 20 \\\\\n&= 1 \\text{eth} + 2 \\text{eth} \\\\\n&= 3 \\text{eth}\n\\end{align/ast}\n$$\n```\n\n### POC\n\nGist [here](https://gist.github.com/0x3b33/558b919a57101e7a0942e557a464078a). \n\nAdd to remappings - `contracts/=smart-contracts/` and run it with `forge test --match-test test_airdrop  --lib-paths ../smart-contracts`.\n\n### Recommended Mitigation Steps\n\nYou can implement a mapping with the airdropped NFTs and deduct this value from `gencore.viewCirSupply(_collectionId)` to avoid disrupting the minting process.\n\n### Assessed type\n\nError\n\n**[a2rocket (NextGen) confirmed via duplicate issue #246](https://github.com/code-423n4/2023-10-nextgen-findings/issues/246#issuecomment-1824028646)**\n\n**[0xsomeone (judge) commented](https://github.com/code-423n4/2023-10-nextgen-findings/issues/381#issuecomment-1845253491):**\n > After further consideration, I have decided to merge several periodic mint-related findings into two separate categories:\n> \n> - Incorrect Price Calculations ([#381](https://github.com/code-423n4/2023-10-nextgen-findings/issues/381))\n> - Incorrect Enforcement of Periodic Mint Limitations ([#380](https://github.com/code-423n4/2023-10-nextgen-findings/issues/380)) \n> \n> The reasoning behind this change is that both rely on different aspects of the code and have different root causes. The former highlights a flaw in the `getPrice` function and how it calculates prices, whilst the latter highlights a flaw in the `mint` function and how it calculates the `lastMintDate`. Fixing one does not infer that the other is fixed, reinforcing the idea that they are separate vulnerabilities.\n> \n> I consider this submission to be of a lower severity than #380, correctly given that it can be rectified. Specifically, a `lastMintDate` update in the future per [#2012](https://github.com/code-423n4/2023-10-nextgen-findings/issues/2012) **cannot be reversed**, while an incorrect price as indicated in this and relevant submissions can be reversed by reconfiguring the collection and can be controlled by the user simply not willing to pay the inflated price until the price is corrected.\n> \n> A problem when selecting the best report in this submission is that all Warden submissions make mention of \"airdropped\" tokens and fail to identify **that the general circulating supply affects the price in their proposed remediation**, such as #380. I have thus chosen this report as the best given that it cites the relevant documentation, contains a privately accessible valid PoC, and provides a basic representation of the pricing formula using mathematical notation to illustrate the problem.\n\n**[MrPotatoMagic (warden) commented](https://github.com/code-423n4/2023-10-nextgen-findings/issues/381#issuecomment-1848456338):**\n > @0xsomeone, here is why I believe this issue (and its duplicates) should be marked as a duplicate of #380 but with a partial grading.\n> \n> 1. The root cause is the same, i.e. existing circulating supply causes sale model 3 to work incorrectly.\n> 2. The impact mentioned here and that in #380 are two sides of the same coin.\n> 3. The issue mentions that prices will skyrocket (which is true) but the issue also mentions that `initial users to pay an inflated price`, which is incorrect since the user cannot mint (pay) in the first place due to the `lastMintDate` being set to a date far ahead in the future.\n> 4. I mention partial grading because although the root cause is correct, the impact demonstrated is invalid. Thus, according to the [C4 final SC verdict in the docs](https://docs.code4rena.com/awarding/judging-criteria/supreme-court-decisions-fall-2023#verdict-penalty-award-standardization-duplicate-report-poc-thoroughness), the issue should deserve a partial-grading, while being marked as a dup of #380 due to the root cause being the same.\n\n**[0xsomeone (judge) commented](https://github.com/code-423n4/2023-10-nextgen-findings/issues/381#issuecomment-1848638016):**\n > @MrPotatoMagic, thanks for contributing! The root cause is not the presence of the circulating supply, it is the incorrect price calculation of a sale model 3. **While it may make sense to carry over sale model 3 sales across different periods, it does not make sense to carry over mint restrictions**. For example:\n> \n> - Collection A runs a periodic sale, amassing 10 NFTs sold, and reaching a price of 10 ETH per NFT.\n> - Collection A performs an airdrop as part of an incentive program.\n> - Collection A opens up the periodic sale for a public run, wanting to maintain the 10 ETH per NFT price.\n> \n> To fix this:\n> - Issue 381 would need to update its price calculation to use solely the circulating supply minted via the periodic sale.\n> - Issue 380 would need to **reset its `lastMintDate` entirely**.\n> \n> A fix for #380 does not fix #381 and vice versa. Both concern different parts of the code and require different alleviations.\n>\n> Based on the above, I will maintain these submissions as separate. \n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-nextgen",
  "Code": [
    {
      "filename": "smart-contracts/MinterContract.sol",
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n *\n *  @title: NextGen Minter Contract\n *  @date: 18-October-2023 \n *  @version: 1.8\n *  @author: 6529 team\n */\n\npragma solidity ^0.8.19;\n\nimport \"./INextGenCore.sol\";\nimport \"./Ownable.sol\";\nimport \"./IDelegationManagementContract.sol\";\nimport \"./MerkleProof.sol\";\nimport \"./INextGenAdmins.sol\";\nimport \"./IERC721.sol\";\n\ncontract NextGenMinterContract is Ownable {\n\n    // total amount collected during minting from collections\n    mapping (uint256 => uint256) public collectionTotalAmount;\n\n    // sales Option3 timestamp of last mint\n    mapping (uint256 => uint) public lastMintDate;\n\n    // burn or swap address for external collections\n    mapping (bytes32 => address) public burnOrSwapAddress;\n\n    // burn or swap external collection ids\n    mapping (bytes32 => uint256[2]) private burnOrSwapIds;\n\n    // mint tokens on a specific collection after burning a token on a NextGen collection\n    mapping (uint256 => mapping (uint256 => bool)) public burnToMintCollections;\n\n    // mint tokens on a specific collection after burning a token on an external collection\n    mapping (bytes32 => mapping (uint256 => bool)) public burnExternalToMintCollections;\n\n    // check if minting costs were set\n    mapping (uint256 => bool) private setMintingCosts;\n\n    // collectionPhasesData struct declaration\n    struct collectionPhasesDataStructure {\n        uint allowlistStartTime;\n        uint allowlistEndTime;\n        uint publicStartTime;\n        uint publicEndTime;\n        bytes32 merkleRoot;\n        uint256 collectionMintCost;\n        uint256 collectionEndMintCost;\n        uint256 timePeriod;\n        uint256 rate;\n        uint8 salesOption;\n        address delAddress;\n    }\n\n    // mapping of collectionPhasesData struct\n    mapping (uint256 => collectionPhasesDataStructure) private collectionPhases;\n\n    // royalties primary splits structure\n\n    struct royaltiesPrimarySplits {\n        uint256 artistPercentage;\n        uint256 teamPercentage;\n    }\n\n    // mapping of royaltiesPrimarySplits struct\n\n    mapping (uint256 => royaltiesPrimarySplits) private collectionRoyaltiesPrimarySplits;\n\n    // artists primary Addresses\n    struct collectionPrimaryAddresses {\n        address primaryAdd1;\n        address primaryAdd2;\n        address primaryAdd3;\n        uint256 add1Percentage;\n        uint256 add2Percentage;\n        uint256 add3Percentage;\n        bool status;\n    }\n\n    // mapping of collectionPrimaryAndSecondaryAddresses struct\n    mapping (uint256 => collectionPrimaryAddresses) private collectionArtistPrimaryAddresses;\n\n    // royalties secondary splits structure\n\n    struct royaltiesSecondarySplits {\n        uint256 artistPercentage;\n        uint256 teamPercentage;\n    }\n\n    // mapping of royaltiesSecondarySplits struct\n\n    mapping (uint256 => royaltiesSecondarySplits) private collectionRoyaltiesSecondarySplits;\n\n    // artists secondary Addresses\n    struct collectionSecondaryAddresses {\n        address secondaryAdd1;\n        address secondaryAdd2;\n        address secondaryAdd3;\n        uint256 add1Percentage;\n        uint256 add2Percentage;\n        uint256 add3Percentage;\n        bool status;\n    }\n\n    // mapping of collectionSecondaryAddresses struct\n    mapping (uint256 => collectionSecondaryAddresses) private collectionArtistSecondaryAddresses;\n\n    // mapping of token id and auction end time\n    mapping (uint256 => uint) private mintToAuctionData;\n\n    // mapping of token id and status\n    mapping (uint256 => bool) private mintToAuctionStatus;\n\n    //external contracts declaration\n    INextGenCore public gencore;\n    IDelegationManagementContract private dmc;\n    INextGenAdmins private adminsContract;\n\n    // events\n\n    event PayArtist(address indexed _add, bool status, uint256 indexed funds);\n    event PayTeam(address indexed _add, bool status, uint256 indexed funds);\n    event Withdraw(address indexed _add, bool status, uint256 indexed funds);\n\n    // constructor\n    constructor (address _gencore, address _del, address _adminsContract) {\n        gencore = INextGenCore(_gencore);\n        dmc = IDelegationManagementContract(_del);\n        adminsContract = INextGenAdmins(_adminsContract);\n    }\n\n    // certain functions can only be called by an admin or the artist\n    modifier ArtistOrAdminRequired(uint256 _collectionID, bytes4 _selector) {\n      require(msg.sender == gencore.retrieveArtistAddress(_collectionID) || adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true, \"Not allowed\");\n      _;\n    }\n\n    // certain functions can only be called by a global or function admin\n\n    modifier FunctionAdminRequired(bytes4 _selector) {\n      require(adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true , \"Not allowed\");\n      _;\n    }\n\n    // certain functions can only be called by a collection, global or function admin\n\n    modifier CollectionAdminRequired(uint256 _collectionID, bytes4 _selector) {\n      require(adminsContract.retrieveCollectionAdmin(msg.sender,_collectionID) == true || adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true, \"Not allowed\");\n      _;\n    }\n\n    // function to add a collection's minting costs\n\n    function setCollectionCosts(uint256 _collectionID, uint256 _collectionMintCost, uint256 _collectionEndMintCost, uint256 _rate, uint256 _timePeriod, uint8 _salesOption, address _delAddress) public CollectionAdminRequired(_collectionID, this.setCollectionCosts.selector) {\n        require(gencore.retrievewereDataAdded(_collectionID) == true, \"Add data\");\n        collectionPhases[_collectionID].collectionMintCost = _collectionMintCost;\n        collectionPhases[_collectionID].collectionEndMintCost = _collectionEndMintCost;\n        collectionPhases[_collectionID].rate = _rate;\n        collectionPhases[_collectionID].timePeriod = _timePeriod;\n        collectionPhases[_collectionID].salesOption = _salesOption;\n        collectionPhases[_collectionID].delAddress = _delAddress;\n        setMintingCosts[_collectionID] = true;\n    }\n\n    // function to add a collection's start/end times and merkleroot\n\n    function setCollectionPhases(uint256 _collectionID, uint _allowlistStartTime, uint _allowlistEndTime, uint _publicStartTime, uint _publicEndTime, bytes32 _merkleRoot) public CollectionAdminRequired(_collectionID, this.setCollectionPhases.selector) {\n        require(setMintingCosts[_collectionID] == true, \"Set Minting Costs\");\n        collectionPhases[_collectionID].allowlistStartTime = _allowlistStartTime;\n        collectionPhases[_collectionID].allowlistEndTime = _allowlistEndTime;\n        collectionPhases[_collectionID].merkleRoot = _merkleRoot;\n        collectionPhases[_collectionID].publicStartTime = _publicStartTime;\n        collectionPhases[_collectionID].publicEndTime = _publicEndTime;\n    }\n\n    // airdrop function\n    \n    function airDropTokens(address[] memory _recipients, string[] memory _tokenData, uint256[] memory _saltfun_o, uint256 _collectionID, uint256[] memory _numberOfTokens) public FunctionAdminRequired(this.airDropTokens.selector) {\n        require(gencore.retrievewereDataAdded(_collectionID) == true, \"Add data\");\n        uint256 collectionTokenMintIndex;\n        for (uint256 y=0; y< _recipients.length; y++) {\n            collectionTokenMintIndex = gencore.viewTokensIndexMin(_collectionID) + gencore.viewCirSupply(_collectionID) + _numberOfTokens[y] - 1;\n            require(collectionTokenMintIndex <= gencore.viewTokensIndexMax(_collectionID), \"No supply\");\n            for(uint256 i = 0; i < _numberOfTokens[y]; i++) {\n                uint256 mintIndex = gencore.viewTokensIndexMin(_collectionID) + gencore.viewCirSupply(_collectionID);\n                gencore.airDropTokens(mintIndex, _recipients[y], _tokenData[y], _saltfun_o[y], _collectionID);\n            }\n        }\n    }\n\n    // mint function\n\n    function mint(uint256 _collectionID, uint256 _numberOfTokens, uint256 _maxAllowance, string memory _tokenData, address _mintTo, bytes32[] calldata merkleProof, address _delegator, uint256 _saltfun_o) public payable {\n        require(setMintingCosts[_collectionID] == true, \"Set Minting Costs\");\n        uint256 col = _collectionID;\n        address mintingAddress;\n        uint256 phase;\n        string memory tokData = _tokenData;\n        if (block.timestamp >= collectionPhases[col].allowlistStartTime && block.timestamp <= collectionPhases[col].allowlistEndTime) {\n            phase = 1;\n            bytes32 node;\n            if (_delegator != 0x0000000000000000000000000000000000000000) {\n                bool isAllowedToMint;\n                isAllowedToMint = dmc.retrieveGlobalStatusOfDelegation(_delegator, 0x8888888888888888888888888888888888888888, msg.sender, 1) || dmc.retrieveGlobalStatusOfDelegation(_delegator, 0x8888888888888888888888888888888888888888, msg.sender, 2);\n                if (isAllowedToMint == false) {\n                isAllowedToMint = dmc.retrieveGlobalStatusOfDelegation(_delegator, collectionPhases[col].delAddress, msg.sender, 1) || dmc.retrieveGlobalStatusOfDelegation(_delegator, collectionPhases[col].delAddress, msg.sender, 2);    \n                }\n                require(isAllowedToMint == true, \"No delegation\");\n                node = keccak256(abi.encodePacked(_delegator, _maxAllowance, tokData));\n                require(_maxAllowance >= gencore.retrieveTokensMintedALPerAddress(col, _delegator) + _numberOfTokens, \"AL limit\");\n                mintingAddress = _delegator;\n            } else {\n                node = keccak256(abi.encodePacked(msg.sender, _maxAllowance, tokData));\n                require(_maxAllowance >= gencore.retrieveTokensMintedALPerAddress(col, msg.sender) + _numberOfTokens, \"AL limit\");\n                mintingAddress = msg.sender;\n            }\n            require(MerkleProof.verifyCalldata(merkleProof, collectionPhases[col].merkleRoot, node), 'invalid proof');\n        } else if (block.timestamp >= collectionPhases[col].publicStartTime && block.timestamp <= collectionPhases[col].publicEndTime) {\n            phase = 2;\n            require(_numberOfTokens <= gencore.viewMaxAllowance(col), \"Change no of tokens\");\n            require(gencore.retrieveTokensMintedPublicPerAddress(col, msg.sender) + _numberOfTokens <= gencore.viewMaxAllowance(col), \"Max\");\n            mintingAddress = msg.sender;\n            tokData = '\"public\"';\n        } else {\n            revert(\"No minting\");\n        }\n        uint256 collectionTokenMintIndex;\n        collectionTokenMintIndex = gencore.viewTokensIndexMin(col) + gencore.viewCirSupply(col) + _numberOfTokens - 1;\n        require(collectionTokenMintIndex <= gencore.viewTokensIndexMax(col), \"No supply\");\n        require(msg.value >= (getPrice(col) * _numberOfTokens), \"Wrong ETH\");\n        for(uint256 i = 0; i < _numberOfTokens; i++) {\n            uint256 mintIndex = gencore.viewTokensIndexMin(col) + gencore.viewCirSupply(col);\n            gencore.mint(mintIndex, mintingAddress, _mintTo, tokData, _saltfun_o, col, phase);\n        }\n        collectionTotalAmount[col] = collectionTotalAmount[col] + msg.value;\n        // control mechanism for sale option 3\n        if (collectionPhases[col].salesOption == 3) {\n            uint timeOfLastMint;\n            if (lastMintDate[col] == 0) {\n                // for public sale set the allowlist the same time as publicsale\n                timeOfLastMint = collectionPhases[col].allowlistStartTime - collectionPhases[col].timePeriod;\n            } else {\n                timeOfLastMint =  lastMintDate[col];\n            }\n            // uint calculates if period has passed in order to allow minting\n            uint tDiff = (block.timestamp - timeOfLastMint) / collectionPhases[col].timePeriod;\n            // users are able to mint after a day passes\n            require(tDiff>=1 && _numberOfTokens == 1, \"1 mint/period\");\n            lastMintDate[col] = collectionPhases[col].allowlistStartTime + (collectionPhases[col].timePeriod * (gencore.viewCirSupply(col) - 1));\n        }\n    }\n\n    // burn to mint function (does not require contract approval)\n\n    function burnToMint(uint256 _burnCollectionID, uint256 _tokenId, uint256 _mintCollectionID, uint256 _saltfun_o) public payable {\n        require(burnToMintCollections[_burnCollectionID][_mintCollectionID] == true, \"Initialize burn\");\n        require(block.timestamp >= collectionPhases[_mintCollectionID].publicStartTime && block.timestamp<=collectionPhases[_mintCollectionID].publicEndTime,\"No minting\");\n        require ((_tokenId >= gencore.viewTokensIndexMin(_burnCollectionID)) && (_tokenId <= gencore.viewTokensIndexMax(_burnCollectionID)), \"col/token id error\");\n        // minting new token\n        uint256 collectionTokenMintIndex;\n        collectionTokenMintIndex = gencore.viewTokensIndexMin(_mintCollectionID) + gencore.viewCirSupply(_mintCollectionID);\n        require(collectionTokenMintIndex <= gencore.viewTokensIndexMax(_mintCollectionID), \"No supply\");\n        require(msg.value >= getPrice(_mintCollectionID), \"Wrong ETH\");\n        uint256 mintIndex = gencore.viewTokensIndexMin(_mintCollectionID) + gencore.viewCirSupply(_mintCollectionID);\n        // burn and mint token\n        address burner = msg.sender;\n        gencore.burnToMint(mintIndex, _burnCollectionID, _tokenId, _mintCollectionID, _saltfun_o, burner);\n        collectionTotalAmount[_mintCollectionID] = collectionTotalAmount[_mintCollectionID] + msg.value;\n    }\n\n    // mint and auction\n    \n    function mintAndAuction(address _recipient, string memory _tokenData, uint256 _saltfun_o, uint256 _collectionID, uint _auctionEndTime) public FunctionAdminRequired(this.mintAndAuction.selector) {\n        require(gencore.retrievewereDataAdded(_collectionID) == true, \"Add data\");\n        uint256 collectionTokenMintIndex;\n        collectionTokenMintIndex = gencore.viewTokensIndexMin(_collectionID) + gencore.viewCirSupply(_collectionID);\n        require(collectionTokenMintIndex <= gencore.viewTokensIndexMax(_collectionID), \"No supply\");\n        uint256 mintIndex = gencore.viewTokensIndexMin(_collectionID) + gencore.viewCirSupply(_collectionID);\n        gencore.airDropTokens(mintIndex, _recipient, _tokenData, _saltfun_o, _collectionID);\n        uint timeOfLastMint;\n        // check 1 per period\n        if (lastMintDate[_collectionID] == 0) {\n        // for public sale set the allowlist the same time as publicsale\n            timeOfLastMint = collectionPhases[_collectionID].allowlistStartTime - collectionPhases[_collectionID].timePeriod;\n        } else {\n            timeOfLastMint =  lastMintDate[_collectionID];\n        }\n        // uint calculates if period has passed in order to allow minting\n        uint tDiff = (block.timestamp - timeOfLastMint) / collectionPhases[_collectionID].timePeriod;\n        // users are able to mint after a day passes\n        require(tDiff>=1, \"1 mint/period\");\n        lastMintDate[_collectionID] = collectionPhases[_collectionID].allowlistStartTime + (collectionPhases[_collectionID].timePeriod * (gencore.viewCirSupply(_collectionID) - 1));\n        mintToAuctionData[mintIndex] = _auctionEndTime;\n        mintToAuctionStatus[mintIndex] = true;\n    }\n\n    // function to update allowlist mint delegation collection\n\n    function updateDelegationCollection(uint256 _collectionID, address _collectionAddress) public FunctionAdminRequired(this.updateDelegationCollection.selector) { \n        collectionPhases[_collectionID].delAddress = _collectionAddress;\n    }\n\n    // function to initialize burn to mint for NextGen collections\n\n    function initializeBurn(uint256 _burnCollectionID, uint256 _mintCollectionID, bool _status) public FunctionAdminRequired(this.initializeBurn.selector) { \n        require((gencore.retrievewereDataAdded(_burnCollectionID) == true) && (gencore.retrievewereDataAdded(_mintCollectionID) == true), \"No data\");\n        burnToMintCollections[_burnCollectionID][_mintCollectionID] = _status;\n    }\n\n    // function to initialize external burn or swap to mint (requires contract approval)\n\n    function initializeExternalBurnOrSwap(address _erc721Collection, uint256 _burnCollectionID, uint256 _mintCollectionID, uint256 _tokmin, uint256 _tokmax, address _burnOrSwapAddress, bool _status) public FunctionAdminRequired(this.initializeExternalBurnOrSwap.selector) { \n        bytes32 externalCol = keccak256(abi.encodePacked(_erc721Collection,_burnCollectionID));\n        require((gencore.retrievewereDataAdded(_mintCollectionID) == true), \"No data\");\n        burnExternalToMintCollections[externalCol][_mintCollectionID] = _status;\n        burnOrSwapAddress[externalCol] = _burnOrSwapAddress;\n        burnOrSwapIds[externalCol][0] = _tokmin;\n        burnOrSwapIds[externalCol][1] = _tokmax;\n    }\n\n    // burn or swap to mint (requires contract approval)\n\n    function burnOrSwapExternalToMint(address _erc721Collection, uint256 _burnCollectionID, uint256 _tokenId, uint256 _mintCollectionID, string memory _tokenData, bytes32[] calldata merkleProof, uint256 _saltfun_o) public payable {\n        bytes32 externalCol = keccak256(abi.encodePacked(_erc721Collection,_burnCollectionID));\n        require(burnExternalToMintCollections[externalCol][_mintCollectionID] == true, \"Initialize external burn\");\n        require(setMintingCosts[_mintCollectionID] == true, \"Set Minting Costs\");\n        address ownerOfToken = IERC721(_erc721Collection).ownerOf(_tokenId);\n        if (msg.sender != ownerOfToken) {\n            bool isAllowedToMint;\n            isAllowedToMint = dmc.retrieveGlobalStatusOfDelegation(ownerOfToken, 0x8888888888888888888888888888888888888888, msg.sender, 1) || dmc.retrieveGlobalStatusOfDelegation(ownerOfToken, 0x8888888888888888888888888888888888888888, msg.sender, 2);\n            if (isAllowedToMint == false) {\n            isAllowedToMint = dmc.retrieveGlobalStatusOfDelegation(ownerOfToken, _erc721Collection, msg.sender, 1) || dmc.retrieveGlobalStatusOfDelegation(ownerOfToken, _erc721Collection, msg.sender, 2);    \n            }\n            require(isAllowedToMint == true, \"No delegation\");\n        }\n        require(_tokenId >= burnOrSwapIds[externalCol][0] && _tokenId <= burnOrSwapIds[externalCol][1], \"Token id does not match\");\n        IERC721(_erc721Collection).safeTransferFrom(ownerOfToken, burnOrSwapAddress[externalCol], _tokenId);\n        uint256 col = _mintCollectionID;\n        address mintingAddress;\n        uint256 phase;\n        string memory tokData = _tokenData;\n        if (block.timestamp >= collectionPhases[col].allowlistStartTime && block.timestamp <= collectionPhases[col].allowlistEndTime) {\n            phase = 1;\n            bytes32 node;\n            node = keccak256(abi.encodePacked(_tokenId, tokData));\n            mintingAddress = ownerOfToken;\n            require(MerkleProof.verifyCalldata(merkleProof, collectionPhases[col].merkleRoot, node), 'invalid proof');            \n        } else if (block.timestamp >= collectionPhases[col].publicStartTime && block.timestamp <= collectionPhases[col].publicEndTime) {\n            phase = 2;\n            mintingAddress = ownerOfToken;\n            tokData = '\"public\"';\n        } else {\n            revert(\"No minting\");\n        }\n        uint256 collectionTokenMintIndex;\n        collectionTokenMintIndex = gencore.viewTokensIndexMin(col) + gencore.viewCirSupply(col);\n        require(collectionTokenMintIndex <= gencore.viewTokensIndexMax(col), \"No supply\");\n        require(msg.value >= (getPrice(col) * 1), \"Wrong ETH\");\n        uint256 mintIndex = gencore.viewTokensIndexMin(col) + gencore.viewCirSupply(col);\n        gencore.mint(mintIndex, mintingAddress, ownerOfToken, tokData, _saltfun_o, col, phase);\n        collectionTotalAmount[col] = collectionTotalAmount[col] + msg.value;\n    }\n\n    // function to set primary splits\n\n    function setPrimaryAndSecondarySplits(uint256 _collectionID, uint256 _artistPrSplit, uint256 _teamPrSplit, uint256 _artistSecSplit, uint256 _teamSecSplit) public FunctionAdminRequired(this.setPrimaryAndSecondarySplits.selector) {\n        require(_artistPrSplit + _teamPrSplit == 100, \"splits need to be 100%\");\n        require(_artistSecSplit + _teamSecSplit == 100, \"splits need to be 100%\");\n        collectionRoyaltiesPrimarySplits[_collectionID].artistPercentage = _artistPrSplit;\n        collectionRoyaltiesPrimarySplits[_collectionID].teamPercentage = _teamPrSplit;\n        collectionRoyaltiesSecondarySplits[_collectionID].artistPercentage = _artistSecSplit;\n        collectionRoyaltiesSecondarySplits[_collectionID].teamPercentage = _teamSecSplit;\n    }\n\n    // function to propose primary addresses and percentages for each address\n\n    function proposePrimaryAddressesAndPercentages(uint256 _collectionID, address _primaryAdd1, address _primaryAdd2, address _primaryAdd3, uint256 _add1Percentage, uint256 _add2Percentage, uint256 _add3Percentage) public ArtistOrAdminRequired(_collectionID, this.proposePrimaryAddressesAndPercentages.selector) {\n        require (collectionArtistPrimaryAddresses[_collectionID].status == false, \"Already approved\");\n        require (_add1Percentage + _add2Percentage + _add3Percentage == collectionRoyaltiesPrimarySplits[_collectionID].artistPercentage, \"Check %\");\n        collectionArtistPrimaryAddresses[_collectionID].primaryAdd1 = _primaryAdd1;\n        collectionArtistPrimaryAddresses[_collectionID].primaryAdd2 = _primaryAdd2;\n        collectionArtistPrimaryAddresses[_collectionID].primaryAdd3 = _primaryAdd3;\n        collectionArtistPrimaryAddresses[_collectionID].add1Percentage = _add1Percentage;\n        collectionArtistPrimaryAddresses[_collectionID].add2Percentage = _add2Percentage;\n        collectionArtistPrimaryAddresses[_collectionID].add3Percentage = _add3Percentage;\n        collectionArtistPrimaryAddresses[_collectionID].status = false;\n    }\n\n    // function to propose secondary addresses and percentages for each address\n\n    function proposeSecondaryAddressesAndPercentages(uint256 _collectionID, address _secondaryAdd1, address _secondaryAdd2, address _secondaryAdd3, uint256 _add1Percentage, uint256 _add2Percentage, uint256 _add3Percentage) public ArtistOrAdminRequired(_collectionID, this.proposeSecondaryAddressesAndPercentages.selector) {\n        require (collectionArtistSecondaryAddresses[_collectionID].status == false, \"Already approved\");\n        require (_add1Percentage + _add2Percentage + _add3Percentage == collectionRoyaltiesSecondarySplits[_collectionID].artistPercentage, \"Check %\");\n        collectionArtistSecondaryAddresses[_collectionID].secondaryAdd1 = _secondaryAdd1;\n        collectionArtistSecondaryAddresses[_collectionID].secondaryAdd2 = _secondaryAdd2;\n        collectionArtistSecondaryAddresses[_collectionID].secondaryAdd3 = _secondaryAdd3;\n        collectionArtistSecondaryAddresses[_collectionID].add1Percentage = _add1Percentage;\n        collectionArtistSecondaryAddresses[_collectionID].add2Percentage = _add2Percentage;\n        collectionArtistSecondaryAddresses[_collectionID].add3Percentage = _add3Percentage;\n        collectionArtistSecondaryAddresses[_collectionID].status = false;\n    }\n\n    // function to accept primary addresses and percentages\n\n    function acceptAddressesAndPercentages(uint256 _collectionID, bool _statusPrimary, bool _statusSecondary) public FunctionAdminRequired(this.acceptAddressesAndPercentages.selector) {\n        collectionArtistPrimaryAddresses[_collectionID].status = _statusPrimary;\n        collectionArtistSecondaryAddresses[_collectionID].status = _statusSecondary;\n    }\n\n    // function to pay the artist\n\n    function payArtist(uint256 _collectionID, address _team1, address _team2, uint256 _teamperc1, uint256 _teamperc2) public FunctionAdminRequired(this.payArtist.selector) {\n        require(collectionArtistPrimaryAddresses[_collectionID].status == true, \"Accept Royalties\");\n        require(collectionTotalAmount[_collectionID] > 0, \"Collection Balance must be grater than 0\");\n        require(collectionRoyaltiesPrimarySplits[_collectionID].artistPercentage + _teamperc1 + _teamperc2 == 100, \"Change percentages\");\n        uint256 royalties = collectionTotalAmount[_collectionID];\n        collectionTotalAmount[_collectionID] = 0;\n        address tm1 = _team1;\n        address tm2 = _team2;\n        uint256 colId = _collectionID;\n        uint256 artistRoyalties1;\n        uint256 artistRoyalties2;\n        uint256 artistRoyalties3;\n        uint256 teamRoyalties1;\n        uint256 teamRoyalties2;\n        artistRoyalties1 = royalties * collectionArtistPrimaryAddresses[colId].add1Percentage / 100;\n        artistRoyalties2 = royalties * collectionArtistPrimaryAddresses[colId].add2Percentage / 100;\n        artistRoyalties3 = royalties * collectionArtistPrimaryAddresses[colId].add3Percentage / 100;\n        teamRoyalties1 = royalties * _teamperc1 / 100;\n        teamRoyalties2 = royalties * _teamperc2 / 100;\n        (bool success1, ) = payable(collectionArtistPrimaryAddresses[colId].primaryAdd1).call{value: artistRoyalties1}(\"\");\n        (bool success2, ) = payable(collectionArtistPrimaryAddresses[colId].primaryAdd2).call{value: artistRoyalties2}(\"\");\n        (bool success3, ) = payable(collectionArtistPrimaryAddresses[colId].primaryAdd3).call{value: artistRoyalties3}(\"\");\n        (bool success4, ) = payable(tm1).call{value: teamRoyalties1}(\"\");\n        (bool success5, ) = payable(tm2).call{value: teamRoyalties2}(\"\");\n        emit PayArtist(collectionArtistPrimaryAddresses[colId].primaryAdd1, success1, artistRoyalties1);\n        emit PayArtist(collectionArtistPrimaryAddresses[colId].primaryAdd2, success2, artistRoyalties2);\n        emit PayArtist(collectionArtistPrimaryAddresses[colId].primaryAdd3, success3, artistRoyalties3);\n        emit PayTeam(tm1, success4, teamRoyalties1);\n        emit PayTeam(tm2, success5, teamRoyalties2);\n    }\n\n    // function to update core contract\n\n    function updateCoreContract(address _gencore) public FunctionAdminRequired(this.updateCoreContract.selector) { \n        gencore = INextGenCore(_gencore);\n    }\n\n    // function to update admin contract\n\n    function updateAdminContract(address _newadminsContract) public FunctionAdminRequired(this.updateAdminContract.selector) {\n        require(INextGenAdmins(_newadminsContract).isAdminContract() == true, \"Contract is not Admin\");\n        adminsContract = INextGenAdmins(_newadminsContract);\n    }\n\n    // function to withdraw any balance from the smart contract\n\n    function emergencyWithdraw() public FunctionAdminRequired(this.emergencyWithdraw.selector) {\n        uint balance = address(this).balance;\n        address admin = adminsContract.owner();\n        (bool success, ) = payable(admin).call{value: balance}(\"\");\n        emit Withdraw(msg.sender, success, balance);\n    }\n\n    // function to retrieve primary splits between artist and team\n\n    function retrievePrimarySplits(uint256 _collectionID) public view returns(uint256, uint256){\n        return (collectionRoyaltiesPrimarySplits[_collectionID].artistPercentage, collectionRoyaltiesPrimarySplits[_collectionID].teamPercentage);\n    }\n\n    // function to retrieve primary addresses and percentages\n\n    function retrievePrimaryAddressesAndPercentages(uint256 _collectionID) public view returns(address, address, address, uint256, uint256, uint256, bool){\n        return (collectionArtistPrimaryAddresses[_collectionID].primaryAdd1, collectionArtistPrimaryAddresses[_collectionID].primaryAdd2, collectionArtistPrimaryAddresses[_collectionID].primaryAdd3, collectionArtistPrimaryAddresses[_collectionID].add1Percentage, collectionArtistPrimaryAddresses[_collectionID].add2Percentage, collectionArtistPrimaryAddresses[_collectionID].add3Percentage, collectionArtistPrimaryAddresses[_collectionID].status);\n    }\n\n    // function to retrieve secondary splits between artist and team\n\n    function retrieveSecondarySplits(uint256 _collectionID) public view returns(uint256, uint256){\n        return (collectionRoyaltiesSecondarySplits[_collectionID].artistPercentage, collectionRoyaltiesSecondarySplits[_collectionID].teamPercentage);\n    }\n\n    // function to retrieve secondary addresses and percentages\n\n    function retrieveSecondaryAddressesAndPercentages(uint256 _collectionID) public view returns(address, address, address, uint256, uint256, uint256, bool){\n        return (collectionArtistSecondaryAddresses[_collectionID].secondaryAdd1, collectionArtistSecondaryAddresses[_collectionID].secondaryAdd2, collectionArtistSecondaryAddresses[_collectionID].secondaryAdd3, collectionArtistSecondaryAddresses[_collectionID].add1Percentage, collectionArtistSecondaryAddresses[_collectionID].add2Percentage, collectionArtistSecondaryAddresses[_collectionID].add3Percentage, collectionArtistSecondaryAddresses[_collectionID].status);\n    }\n\n    // function to retrieve the Collection phases times and merkle root of a collection\n\n    function retrieveCollectionPhases(uint256 _collectionID) public view returns(uint, uint, bytes32, uint, uint){\n        return (collectionPhases[_collectionID].allowlistStartTime, collectionPhases[_collectionID].allowlistEndTime, collectionPhases[_collectionID].merkleRoot, collectionPhases[_collectionID].publicStartTime, collectionPhases[_collectionID].publicEndTime);\n    }\n\n    // function to retrieve the minting details of a collection\n\n    function retrieveCollectionMintingDetails(uint256 _collectionID) public view returns(uint256, uint256, uint256, uint256, uint8, address){\n        return (collectionPhases[_collectionID].collectionMintCost, collectionPhases[_collectionID].collectionEndMintCost, collectionPhases[_collectionID].rate, collectionPhases[_collectionID].timePeriod, collectionPhases[_collectionID].salesOption, collectionPhases[_collectionID].delAddress);\n    }\n\n    // get minter contract status\n\n    function isMinterContract() external view returns (bool) {\n        return true;\n    }\n\n    // get minting end time\n\n    function getEndTime(uint256 _collectionID) external view returns (uint) {\n        return collectionPhases[_collectionID].publicEndTime;\n    }\n\n    // get auction end time\n\n    function getAuctionEndTime(uint256 _tokenId) external view returns (uint) {\n        return mintToAuctionData[_tokenId];\n    }\n\n    // get auction status\n\n    function getAuctionStatus(uint256 _tokenId) external view  returns (bool) {\n        return mintToAuctionStatus[_tokenId];\n    }\n\n    // get the minting price of collection\n\n    function getPrice(uint256 _collectionId) public view returns (uint256) {\n        uint tDiff;\n        if (collectionPhases[_collectionId].salesOption == 3) {\n            // increase minting price by mintcost / collectionPhases[_collectionId].rate every mint (1mint/period)\n            // to get the price rate needs to be set\n            if (collectionPhases[_collectionId].rate > 0) {\n                return collectionPhases[_collectionId].collectionMintCost + ((collectionPhases[_collectionId].collectionMintCost / collectionPhases[_collectionId].rate) * gencore.viewCirSupply(_collectionId));\n            } else {\n                return collectionPhases[_collectionId].collectionMintCost;\n            }\n        } else if (collectionPhases[_collectionId].salesOption == 2 && block.timestamp > collectionPhases[_collectionId].allowlistStartTime && block.timestamp < collectionPhases[_collectionId].publicEndTime){\n            // decreases exponentially every time period\n            // collectionPhases[_collectionId].timePeriod sets the time period for decreasing the mintcost\n            // if just public mint set the publicStartTime = allowlistStartTime\n            // if rate = 0 exponetialy decrease\n            // if rate is set the linear decrase each period per rate\n            tDiff = (block.timestamp - collectionPhases[_collectionId].allowlistStartTime) / collectionPhases[_collectionId].timePeriod;\n            uint256 price;\n            uint256 decreaserate;\n            if (collectionPhases[_collectionId].rate == 0) {\n                price = collectionPhases[_collectionId].collectionMintCost / (tDiff + 1);\n                decreaserate = ((price - (collectionPhases[_collectionId].collectionMintCost / (tDiff + 2))) / collectionPhases[_collectionId].timePeriod) * ((block.timestamp - (tDiff * collectionPhases[_collectionId].timePeriod) - collectionPhases[_collectionId].allowlistStartTime));\n            } else {\n                if (((collectionPhases[_collectionId].collectionMintCost - collectionPhases[_collectionId].collectionEndMintCost) / (collectionPhases[_collectionId].rate)) > tDiff) {\n                    price = collectionPhases[_collectionId].collectionMintC"
    }
  ]
}