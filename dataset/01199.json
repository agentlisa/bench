{
  "Title": "renounceVesting Does Not Return ETH",
  "Content": "\nCurrently, the `[renounceVesting](https://github.com/oceanprotocol/vw-cli/blob/0397c74da60ae50db5c6414307849120b899af6e/contracts/VestingWalletHalving.sol#L210-L215)` function of the `VestingWalletHalving` contract only sweeps a single ERC-20 token and cannot return ETH to the owner. The [`VestingWalletHalving`](https://github.com/oceanprotocol/vw-cli/blob/0397c74da60ae50db5c6414307849120b899af6e/contracts/VestingWalletHalving.sol) contract has the ability to handle both ERC-20 tokens and ETH. The contract also has a function called `renounceVesting` used by the owner to return a specific ERC-20 token and renounce vesting. \n\n\nHowever, the function does not allow the owner to have any ETH returned upon renouncing. This would leave the ETH stuck in the contract until the end of the given schedule period. \n\n\nConsider adding a variant implementation of renounceVesting that allows the owner to recover ETH.\n\n\n***Update:** Resolved in [pull request #40](https://github.com/oceanprotocol/vw-cli/pull/40) at commit [543fb5c](https://github.com/oceanprotocol/vw-cli/pull/40/commits/543fb5c4e980a978c8b79ab5ac6c19feb83170e1).*\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/VestingWalletHalving.sol",
      "content": "// Copyright OpenZeppelin, BigchainDB GmbH and Ocean Protocol contributors\n// SPDX-License-Identifier: (Apache-2.0 AND MIT)\npragma solidity ^0.8.0;\n\nimport \"OpenZeppelin/openzeppelin-contracts@4.7.0/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"OpenZeppelin/openzeppelin-contracts@4.7.0/contracts/utils/Address.sol\";\nimport \"OpenZeppelin/openzeppelin-contracts@4.7.0/contracts/utils/Context.sol\";\nimport \"OpenZeppelin/openzeppelin-contracts@4.7.0/contracts/access/Ownable.sol\";\n\n/**\n * @title VestingWalletHalving\n * @dev This contract handles the vesting of Eth and ERC20 tokens for a given beneficiary. Custody of multiple tokens\n * can be given to this contract, which will release the token to the beneficiary following a given vesting schedule.\n * The vesting schedule is customizable through the {vestedAmount} function.\n *\n * Any token transferred to this contract will follow the vesting schedule as if they were locked from the beginning.\n * Consequently, if the vesting has already started, any amount of tokens sent to this contract will (at least partly)\n * be immediately releasable.\n */\ncontract VestingWalletHalving is Context, Ownable {\n    event EtherReleased(address indexed beneficiary, uint256 amount);\n    event ERC20Released(address indexed beneficiary, address indexed token, uint256 amount);\n    \n    event BeneficiaryChanged(address indexed newBeneficiary);\n    event RenounceVesting(address indexed token, address indexed owner, uint256 amount);\n    \n\n    uint256 private _released;\n    mapping(address => uint256) private _erc20Released;\n    address private _beneficiary;\n    uint64 private immutable _start;\n    uint256 private immutable _halfLife;\n    uint256 private immutable _duration;\n\n    /**\n     * @dev Set the beneficiary, start timestamp and vesting duration of the vesting wallet.\n     */\n    constructor(\n        address beneficiaryAddress,\n        uint64 startTimestamp,\n        uint256 halfLife,\n        uint256 duration\n    ) payable {\n        require(\n            beneficiaryAddress != address(0),\n            \"VestingWallet: beneficiary is zero address\"\n        );\n        _beneficiary = beneficiaryAddress;\n        _start = startTimestamp;\n        _halfLife = halfLife;\n        _duration = duration;\n    }\n\n    /**\n     * @dev The contract should be able to receive Eth.\n     */\n    receive() external payable virtual {}\n\n    /**\n     * @dev Getter for the beneficiary address.\n     */\n    function beneficiary() public view virtual returns (address) {\n        return _beneficiary;\n    }\n\n    /**\n     * @dev Getter for the start timestamp.\n     */\n    function start() public view virtual returns (uint256) {\n        return _start;\n    }\n\n    /**\n     * @dev Getter for the half life.\n     */\n    function halfLife() public view returns (uint256) {\n        return _halfLife;\n    }\n\n    /**\n     * @dev Getter for duration.\n     */\n    function duration() public view returns (uint256) {\n        return _duration;\n    }\n\n    /**\n     * @dev Amount of eth already released\n     */\n    function released() public view virtual returns (uint256) {\n        return _released;\n    }\n\n    /**\n     * @dev Amount of token already released\n     */\n    function released(address token) public view virtual returns (uint256) {\n        return _erc20Released[token];\n    }\n\n    /**\n     * @dev Getter for the amount of releasable eth.\n     */\n    function releasable() public view virtual returns (uint256) {\n        return vestedAmount(uint64(block.timestamp)) - released();\n    }\n\n    /**\n     * @dev Getter for the amount of releasable `token` tokens. `token` should be the address of an\n     * IERC20 contract.\n     */\n    function releasable(address token) public view virtual returns (uint256) {\n        return vestedAmount(token, uint64(block.timestamp)) - released(token);\n    }\n\n    /**\n     * @dev Release the native token (ether) that have already vested.\n     *\n     * Emits a {EtherReleased} event.\n     */\n    function release() public virtual {\n        require(\n            beneficiary() != address(0),\n            \"VestingWallet: beneficiary is zero address\"\n        );\n        uint256 amount = releasable();\n        _released += amount;\n        emit EtherReleased(beneficiary(), amount);\n        Address.sendValue(payable(beneficiary()), amount);\n    }\n\n    /**\n     * @dev Release the tokens that have already vested.\n     *\n     * Emits a {ERC20Released} event.\n     */\n    function release(address token) public virtual {\n        require(\n            beneficiary() != address(0),\n            \"VestingWallet: beneficiary is zero address\"\n        );\n        uint256 amount = releasable(token);\n        _erc20Released[token] += amount;\n        emit ERC20Released(beneficiary(), token, amount);\n        SafeERC20.safeTransfer(IERC20(token), beneficiary(), amount);\n    }\n\n    /**\n     * @dev Calculates the amount of ether that has already vested. Default implementation is a linear vesting curve.\n     */\n    function vestedAmount(uint64 timestamp)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return _vestingSchedule(address(this).balance + released(), timestamp);\n    }\n\n    /**\n     * @dev Calculates the amount of tokens that has already vested. Default implementation is a linear vesting curve.\n     */\n    function vestedAmount(address token, uint64 timestamp)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return\n            _vestingSchedule(\n                IERC20(token).balanceOf(address(this)) + released(token),\n                timestamp\n            );\n    }\n\n    /**\n     * @dev Approximation of half life formula (1-(0.5^(t/h)))*value\n     */\n    function getAmount(\n        uint256 value,\n        uint256 t,\n        uint256 h\n    ) public pure returns (uint256) {\n        uint256 p = value >> (t / h);\n        t %= h;\n        return value - p + (p * t) / h / 2;\n    }\n\n    /**\n     * @dev Virtual implementation of the vesting formula. This returns the amount vested, as a function of time, for\n     * an asset given its total historical allocation.\n     */\n    function _vestingSchedule(uint256 totalAllocation, uint64 timestamp)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        if (timestamp < start()) {\n            return 0;\n        } else if (timestamp > start() + duration()) {\n            return totalAllocation;\n        } else {\n            uint256 timePassed = timestamp - start();\n            return getAmount(totalAllocation, timePassed, halfLife());\n        }\n    }\n\n    // ----- ADMIN FUNCTIONS -----\n    function renounceVesting(address token) external onlyOwner {\n        uint256 amount = IERC20(token).balanceOf(address(this));\n        emit RenounceVesting(token, owner(), amount);\n        SafeERC20.safeTransfer(IERC20(token), owner(), amount);\n        \n    }\n\n    function changeBeneficiary(address beneficiary) external onlyOwner {\n        require(beneficiary!= address(0),\"VestingWallet: beneficiary is zero address\");\n        _beneficiary = beneficiary;\n        emit BeneficiaryChanged(beneficiary);\n    }\n    \n}"
    }
  ]
}