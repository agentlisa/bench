{
  "Title": "Unrestricted Access to the `createLot` Function in the `Auction` Contract",
  "Content": "\nhttps://github.com/code-423n4/2023-06-stader/blob/main/contracts/Auction.sol#L48-L60\n\nIn the current design of the Stader ecosystem's smart contracts, the `createLot` function of the `Auction` contract can be called by anyone. This allows arbitrary users to create an auction lot, leading to unintentional donations of their Stader tokens. As these tokens are upon completion of the auction, they are then transferred to the `treasury` if there is no bidder:\n\nhttps://github.com/code-423n4/2023-06-stader/blob/main/contracts/Auction.sol#L114\n\n```solidity\n        if (!IERC20(staderConfig.getStaderToken()).transfer(staderConfig.getStaderTreasury(), _sdAmount)) {\n```\nor the ETH proceeds to the `stake pool manager`:\n\nhttps://github.com/code-423n4/2023-06-stader/blob/main/contracts/Auction.sol#L102\n\n```solidity\n        IStaderStakePoolManager(staderConfig.getStakePoolManager()).receiveEthFromAuction{value: ethAmount}();\n```\n\n This can lead to a loss of Stader tokens for users without any benefit in return.\n\n### Proof of Concept\nIn the `Auction` contract, the `createLot` function is open to all users:\n\nhttps://github.com/code-423n4/2023-06-stader/blob/main/contracts/Auction.sol#L48\n\n```solidity\n    function createLot(uint256 _sdAmount) external override whenNotPaused {\n        ...\n    }\n```\nIn the `SDCollateral` contract, `createLot` is called in the context of slashing:\n\nhttps://github.com/code-423n4/2023-06-stader/blob/main/contracts/SDCollateral.sol#L97\n\n```solidity\n    function slashSD(address _operator, uint256 _sdToSlash) internal {\n        ...\n        IAuction(staderConfig.getAuctionContract()).createLot(sdSlashed);\n        ...\n    }\n```\nUnfortunately, there is no restriction in place in the `Auction` contract that would prevent arbitrary users from calling `createLot` outside of a slashing context.\n\n### Recommended Mitigation Steps\nTo address this vulnerability, consider applying one or both of the following changes:\n\n1. Modify the `Auction` contract to restrict the `createLot` function only to the `SDCollateral` contract or a specific privileged role. This can be achieved through the OpenZeppelin's `AccessControl` contract or similar mechanism and it would ensure that the function can't be trapping arbitrary users.\n\n2. Implement checks within the `createLot` function to validate the context of the call. For instance, the function could verify that the transaction is part of a slashing event before proceeding.\n\nIn addition, make sure to properly communicate to your users the consequences and conditions of interacting with the `createLot` function to avoid unintentional token losses. Thoroughly test all changes to the contract to ensure they behave as expected without introducing new vulnerabilities.\n\n\n### Assessed type\n\nAccess Control\n\n**[manoj9april (Stader) disputed and commented](https://github.com/code-423n4/2022-06-stader-findings/issues/106#issuecomment-1596604208):**\n>No person should be able to interact with this contract without understanding what it does.\n\n**[Picodes (judge) decreased severity to QA and commented](https://github.com/code-423n4/2022-06-stader-findings/issues/236#issuecomment-1618246169):**\n>This would be a safety check to prevent users from doing mistakes, so is of Non-Critical severity.\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-06-stader",
  "Code": [
    {
      "filename": "contracts/Auction.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport './library/UtilLib.sol';\n\nimport '../contracts/interfaces/SDCollateral/IAuction.sol';\nimport '../contracts/interfaces/IStaderStakePoolManager.sol';\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol';\n\ncontract Auction is IAuction, Initializable, AccessControlUpgradeable, PausableUpgradeable, ReentrancyGuardUpgradeable {\n    IStaderConfig public override staderConfig;\n    uint256 public override nextLot;\n    uint256 public override bidIncrement;\n    uint256 public override duration;\n\n    mapping(uint256 => LotItem) public lots;\n\n    uint256 public constant MIN_AUCTION_DURATION = 7200; // 24 hours\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _admin, address _staderConfig) external initializer {\n        UtilLib.checkNonZeroAddress(_admin);\n        UtilLib.checkNonZeroAddress(_staderConfig);\n\n        __AccessControl_init();\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        staderConfig = IStaderConfig(_staderConfig);\n        duration = 2 * MIN_AUCTION_DURATION;\n        bidIncrement = 5e15;\n        nextLot = 1;\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n        emit UpdatedStaderConfig(_staderConfig);\n        emit AuctionDurationUpdated(duration);\n        emit BidIncrementUpdated(bidIncrement);\n    }\n\n    function createLot(uint256 _sdAmount) external override whenNotPaused {\n        lots[nextLot].startBlock = block.number;\n        lots[nextLot].endBlock = block.number + duration;\n        lots[nextLot].sdAmount = _sdAmount;\n\n        LotItem storage lotItem = lots[nextLot];\n\n        if (!IERC20(staderConfig.getStaderToken()).transferFrom(msg.sender, address(this), _sdAmount)) {\n            revert SDTransferFailed();\n        }\n        emit LotCreated(nextLot, lotItem.sdAmount, lotItem.startBlock, lotItem.endBlock, bidIncrement);\n        nextLot++;\n    }\n\n    function addBid(uint256 lotId) external payable override whenNotPaused {\n        // reject payments of 0 ETH\n        if (msg.value == 0) revert InSufficientETH();\n\n        LotItem storage lotItem = lots[lotId];\n        if (block.number > lotItem.endBlock) revert AuctionEnded();\n\n        uint256 totalUserBid = lotItem.bids[msg.sender] + msg.value;\n\n        if (totalUserBid < lotItem.highestBidAmount + bidIncrement) revert InSufficientBid();\n\n        lotItem.highestBidder = msg.sender;\n        lotItem.highestBidAmount = totalUserBid;\n        lotItem.bids[msg.sender] = totalUserBid;\n\n        emit BidPlaced(lotId, msg.sender, totalUserBid);\n    }\n\n    function claimSD(uint256 lotId) external override {\n        LotItem storage lotItem = lots[lotId];\n        if (block.number <= lotItem.endBlock) revert AuctionNotEnded();\n        if (msg.sender != lotItem.highestBidder) revert notQualified();\n        if (lotItem.sdClaimed) revert AlreadyClaimed();\n\n        lotItem.sdClaimed = true;\n        if (!IERC20(staderConfig.getStaderToken()).transfer(lotItem.highestBidder, lotItem.sdAmount)) {\n            revert SDTransferFailed();\n        }\n        emit SDClaimed(lotId, lotItem.highestBidder, lotItem.sdAmount);\n    }\n\n    function transferHighestBidToSSPM(uint256 lotId) external override nonReentrant {\n        LotItem storage lotItem = lots[lotId];\n        uint256 ethAmount = lotItem.highestBidAmount;\n\n        if (block.number <= lotItem.endBlock) revert AuctionNotEnded();\n        if (ethAmount == 0) revert NoBidPlaced();\n        if (lotItem.ethExtracted) revert AlreadyClaimed();\n\n        lotItem.ethExtracted = true;\n        IStaderStakePoolManager(staderConfig.getStakePoolManager()).receiveEthFromAuction{value: ethAmount}();\n        emit ETHClaimed(lotId, staderConfig.getStakePoolManager(), ethAmount);\n    }\n\n    function extractNonBidSD(uint256 lotId) external override {\n        LotItem storage lotItem = lots[lotId];\n        if (block.number <= lotItem.endBlock) revert AuctionNotEnded();\n        if (lotItem.highestBidAmount > 0) revert LotWasAuctioned();\n        if (lotItem.sdAmount == 0) revert AlreadyClaimed();\n\n        uint256 _sdAmount = lotItem.sdAmount;\n        lotItem.sdAmount = 0;\n        if (!IERC20(staderConfig.getStaderToken()).transfer(staderConfig.getStaderTreasury(), _sdAmount)) {\n            revert SDTransferFailed();\n        }\n        emit UnsuccessfulSDAuctionExtracted(lotId, _sdAmount, staderConfig.getStaderTreasury());\n    }\n\n    function withdrawUnselectedBid(uint256 lotId) external override nonReentrant {\n        LotItem storage lotItem = lots[lotId];\n        if (block.number <= lotItem.endBlock) revert AuctionNotEnded();\n        if (msg.sender == lotItem.highestBidder) revert BidWasSuccessful();\n\n        uint256 withdrawalAmount = lotItem.bids[msg.sender];\n        if (withdrawalAmount == 0) revert InSufficientETH();\n\n        lotItem.bids[msg.sender] -= withdrawalAmount;\n\n        // send the funds\n        (bool success, ) = payable(msg.sender).call{value: withdrawalAmount}('');\n        if (!success) revert ETHWithdrawFailed();\n\n        emit BidWithdrawn(lotId, msg.sender, withdrawalAmount);\n    }\n\n    // SETTERS\n    function updateStaderConfig(address _staderConfig) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n        UtilLib.checkNonZeroAddress(_staderConfig);\n        staderConfig = IStaderConfig(_staderConfig);\n        emit UpdatedStaderConfig(_staderConfig);\n    }\n\n    function updateDuration(uint256 _duration) external override {\n        UtilLib.onlyManagerRole(msg.sender, staderConfig);\n        if (_duration < MIN_AUCTION_DURATION) revert ShortDuration();\n        duration = _duration;\n        emit AuctionDurationUpdated(duration);\n    }\n\n    function updateBidIncrement(uint256 _bidIncrement) external override {\n        UtilLib.onlyManagerRole(msg.sender, staderConfig);\n        bidIncrement = _bidIncrement;\n        emit BidIncrementUpdated(_bidIncrement);\n    }\n}"
    },
    {
      "filename": "contracts/Auction.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport './library/UtilLib.sol';\n\nimport '../contracts/interfaces/SDCollateral/IAuction.sol';\nimport '../contracts/interfaces/IStaderStakePoolManager.sol';\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol';\n\ncontract Auction is IAuction, Initializable, AccessControlUpgradeable, PausableUpgradeable, ReentrancyGuardUpgradeable {\n    IStaderConfig public override staderConfig;\n    uint256 public override nextLot;\n    uint256 public override bidIncrement;\n    uint256 public override duration;\n\n    mapping(uint256 => LotItem) public lots;\n\n    uint256 public constant MIN_AUCTION_DURATION = 7200; // 24 hours\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _admin, address _staderConfig) external initializer {\n        UtilLib.checkNonZeroAddress(_admin);\n        UtilLib.checkNonZeroAddress(_staderConfig);\n\n        __AccessControl_init();\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        staderConfig = IStaderConfig(_staderConfig);\n        duration = 2 * MIN_AUCTION_DURATION;\n        bidIncrement = 5e15;\n        nextLot = 1;\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n        emit UpdatedStaderConfig(_staderConfig);\n        emit AuctionDurationUpdated(duration);\n        emit BidIncrementUpdated(bidIncrement);\n    }\n\n    function createLot(uint256 _sdAmount) external override whenNotPaused {\n        lots[nextLot].startBlock = block.number;\n        lots[nextLot].endBlock = block.number + duration;\n        lots[nextLot].sdAmount = _sdAmount;\n\n        LotItem storage lotItem = lots[nextLot];\n\n        if (!IERC20(staderConfig.getStaderToken()).transferFrom(msg.sender, address(this), _sdAmount)) {\n            revert SDTransferFailed();\n        }\n        emit LotCreated(nextLot, lotItem.sdAmount, lotItem.startBlock, lotItem.endBlock, bidIncrement);\n        nextLot++;\n    }\n\n    function addBid(uint256 lotId) external payable override whenNotPaused {\n        // reject payments of 0 ETH\n        if (msg.value == 0) revert InSufficientETH();\n\n        LotItem storage lotItem = lots[lotId];\n        if (block.number > lotItem.endBlock) revert AuctionEnded();\n\n        uint256 totalUserBid = lotItem.bids[msg.sender] + msg.value;\n\n        if (totalUserBid < lotItem.highestBidAmount + bidIncrement) revert InSufficientBid();\n\n        lotItem.highestBidder = msg.sender;\n        lotItem.highestBidAmount = totalUserBid;\n        lotItem.bids[msg.sender] = totalUserBid;\n\n        emit BidPlaced(lotId, msg.sender, totalUserBid);\n    }\n\n    function claimSD(uint256 lotId) external override {\n        LotItem storage lotItem = lots[lotId];\n        if (block.number <= lotItem.endBlock) revert AuctionNotEnded();\n        if (msg.sender != lotItem.highestBidder) revert notQualified();\n        if (lotItem.sdClaimed) revert AlreadyClaimed();\n\n        lotItem.sdClaimed = true;\n        if (!IERC20(staderConfig.getStaderToken()).transfer(lotItem.highestBidder, lotItem.sdAmount)) {\n            revert SDTransferFailed();\n        }\n        emit SDClaimed(lotId, lotItem.highestBidder, lotItem.sdAmount);\n    }\n\n    function transferHighestBidToSSPM(uint256 lotId) external override nonReentrant {\n        LotItem storage lotItem = lots[lotId];\n        uint256 ethAmount = lotItem.highestBidAmount;\n\n        if (block.number <= lotItem.endBlock) revert AuctionNotEnded();\n        if (ethAmount == 0) revert NoBidPlaced();\n        if (lotItem.ethExtracted) revert AlreadyClaimed();\n\n        lotItem.ethExtracted = true;\n        IStaderStakePoolManager(staderConfig.getStakePoolManager()).receiveEthFromAuction{value: ethAmount}();\n        emit ETHClaimed(lotId, staderConfig.getStakePoolManager(), ethAmount);\n    }\n\n    function extractNonBidSD(uint256 lotId) external override {\n        LotItem storage lotItem = lots[lotId];\n        if (block.number <= lotItem.endBlock) revert AuctionNotEnded();\n        if (lotItem.highestBidAmount > 0) revert LotWasAuctioned();\n        if (lotItem.sdAmount == 0) revert AlreadyClaimed();\n\n        uint256 _sdAmount = lotItem.sdAmount;\n        lotItem.sdAmount = 0;\n        if (!IERC20(staderConfig.getStaderToken()).transfer(staderConfig.getStaderTreasury(), _sdAmount)) {\n            revert SDTransferFailed();\n        }\n        emit UnsuccessfulSDAuctionExtracted(lotId, _sdAmount, staderConfig.getStaderTreasury());\n    }\n\n    function withdrawUnselectedBid(uint256 lotId) external override nonReentrant {\n        LotItem storage lotItem = lots[lotId];\n        if (block.number <= lotItem.endBlock) revert AuctionNotEnded();\n        if (msg.sender == lotItem.highestBidder) revert BidWasSuccessful();\n\n        uint256 withdrawalAmount = lotItem.bids[msg.sender];\n        if (withdrawalAmount == 0) revert InSufficientETH();\n\n        lotItem.bids[msg.sender] -= withdrawalAmount;\n\n        // send the funds\n        (bool success, ) = payable(msg.sender).call{value: withdrawalAmount}('');\n        if (!success) revert ETHWithdrawFailed();\n\n        emit BidWithdrawn(lotId, msg.sender, withdrawalAmount);\n    }\n\n    // SETTERS\n    function updateStaderConfig(address _staderConfig) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n        UtilLib.checkNonZeroAddress(_staderConfig);\n        staderConfig = IStaderConfig(_staderConfig);\n        emit UpdatedStaderConfig(_staderConfig);\n    }\n\n    function updateDuration(uint256 _duration) external override {\n        UtilLib.onlyManagerRole(msg.sender, staderConfig);\n        if (_duration < MIN_AUCTION_DURATION) revert ShortDuration();\n        duration = _duration;\n        emit AuctionDurationUpdated(duration);\n    }\n\n    function updateBidIncrement(uint256 _bidIncrement) external override {\n        UtilLib.onlyManagerRole(msg.sender, staderConfig);\n        bidIncrement = _bidIncrement;\n        emit BidIncrementUpdated(_bidIncrement);\n    }\n}"
    },
    {
      "filename": "contracts/Auction.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport './library/UtilLib.sol';\n\nimport '../contracts/interfaces/SDCollateral/IAuction.sol';\nimport '../contracts/interfaces/IStaderStakePoolManager.sol';\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol';\n\ncontract Auction is IAuction, Initializable, AccessControlUpgradeable, PausableUpgradeable, ReentrancyGuardUpgradeable {\n    IStaderConfig public override staderConfig;\n    uint256 public override nextLot;\n    uint256 public override bidIncrement;\n    uint256 public override duration;\n\n    mapping(uint256 => LotItem) public lots;\n\n    uint256 public constant MIN_AUCTION_DURATION = 7200; // 24 hours\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _admin, address _staderConfig) external initializer {\n        UtilLib.checkNonZeroAddress(_admin);\n        UtilLib.checkNonZeroAddress(_staderConfig);\n\n        __AccessControl_init();\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        staderConfig = IStaderConfig(_staderConfig);\n        duration = 2 * MIN_AUCTION_DURATION;\n        bidIncrement = 5e15;\n        nextLot = 1;\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n        emit UpdatedStaderConfig(_staderConfig);\n        emit AuctionDurationUpdated(duration);\n        emit BidIncrementUpdated(bidIncrement);\n    }\n\n    function createLot(uint256 _sdAmount) external override whenNotPaused {\n        lots[nextLot].startBlock = block.number;\n        lots[nextLot].endBlock = block.number + duration;\n        lots[nextLot].sdAmount = _sdAmount;\n\n        LotItem storage lotItem = lots[nextLot];\n\n        if (!IERC20(staderConfig.getStaderToken()).transferFrom(msg.sender, address(this), _sdAmount)) {\n            revert SDTransferFailed();\n        }\n        emit LotCreated(nextLot, lotItem.sdAmount, lotItem.startBlock, lotItem.endBlock, bidIncrement);\n        nextLot++;\n    }\n\n    function addBid(uint256 lotId) external payable override whenNotPaused {\n        // reject payments of 0 ETH\n        if (msg.value == 0) revert InSufficientETH();\n\n        LotItem storage lotItem = lots[lotId];\n        if (block.number > lotItem.endBlock) revert AuctionEnded();\n\n        uint256 totalUserBid = lotItem.bids[msg.sender] + msg.value;\n\n        if (totalUserBid < lotItem.highestBidAmount + bidIncrement) revert InSufficientBid();\n\n        lotItem.highestBidder = msg.sender;\n        lotItem.highestBidAmount = totalUserBid;\n        lotItem.bids[msg.sender] = totalUserBid;\n\n        emit BidPlaced(lotId, msg.sender, totalUserBid);\n    }\n\n    function claimSD(uint256 lotId) external override {\n        LotItem storage lotItem = lots[lotId];\n        if (block.number <= lotItem.endBlock) revert AuctionNotEnded();\n        if (msg.sender != lotItem.highestBidder) revert notQualified();\n        if (lotItem.sdClaimed) revert AlreadyClaimed();\n\n        lotItem.sdClaimed = true;\n        if (!IERC20(staderConfig.getStaderToken()).transfer(lotItem.highestBidder, lotItem.sdAmount)) {\n            revert SDTransferFailed();\n        }\n        emit SDClaimed(lotId, lotItem.highestBidder, lotItem.sdAmount);\n    }\n\n    function transferHighestBidToSSPM(uint256 lotId) external override nonReentrant {\n        LotItem storage lotItem = lots[lotId];\n        uint256 ethAmount = lotItem.highestBidAmount;\n\n        if (block.number <= lotItem.endBlock) revert AuctionNotEnded();\n        if (ethAmount == 0) revert NoBidPlaced();\n        if (lotItem.ethExtracted) revert AlreadyClaimed();\n\n        lotItem.ethExtracted = true;\n        IStaderStakePoolManager(staderConfig.getStakePoolManager()).receiveEthFromAuction{value: ethAmount}();\n        emit ETHClaimed(lotId, staderConfig.getStakePoolManager(), ethAmount);\n    }\n\n    function extractNonBidSD(uint256 lotId) external override {\n        LotItem storage lotItem = lots[lotId];\n        if (block.number <= lotItem.endBlock) revert AuctionNotEnded();\n        if (lotItem.highestBidAmount > 0) revert LotWasAuctioned();\n        if (lotItem.sdAmount == 0) revert AlreadyClaimed();\n\n        uint256 _sdAmount = lotItem.sdAmount;\n        lotItem.sdAmount = 0;\n        if (!IERC20(staderConfig.getStaderToken()).transfer(staderConfig.getStaderTreasury(), _sdAmount)) {\n            revert SDTransferFailed();\n        }\n        emit UnsuccessfulSDAuctionExtracted(lotId, _sdAmount, staderConfig.getStaderTreasury());\n    }\n\n    function withdrawUnselectedBid(uint256 lotId) external override nonReentrant {\n        LotItem storage lotItem = lots[lotId];\n        if (block.number <= lotItem.endBlock) revert AuctionNotEnded();\n        if (msg.sender == lotItem.highestBidder) revert BidWasSuccessful();\n\n        uint256 withdrawalAmount = lotItem.bids[msg.sender];\n        if (withdrawalAmount == 0) revert InSufficientETH();\n\n        lotItem.bids[msg.sender] -= withdrawalAmount;\n\n        // send the funds\n        (bool success, ) = payable(msg.sender).call{value: withdrawalAmount}('');\n        if (!success) revert ETHWithdrawFailed();\n\n        emit BidWithdrawn(lotId, msg.sender, withdrawalAmount);\n    }\n\n    // SETTERS\n    function updateStaderConfig(address _staderConfig) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n        UtilLib.checkNonZeroAddress(_staderConfig);\n        staderConfig = IStaderConfig(_staderConfig);\n        emit UpdatedStaderConfig(_staderConfig);\n    }\n\n    function updateDuration(uint256 _duration) external override {\n        UtilLib.onlyManagerRole(msg.sender, staderConfig);\n        if (_duration < MIN_AUCTION_DURATION) revert ShortDuration();\n        duration = _duration;\n        emit AuctionDurationUpdated(duration);\n    }\n\n    function updateBidIncrement(uint256 _bidIncrement) external override {\n        UtilLib.onlyManagerRole(msg.sender, staderConfig);\n        bidIncrement = _bidIncrement;\n        emit BidIncrementUpdated(_bidIncrement);\n    }\n}"
    },
    {
      "filename": "contracts/Auction.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport './library/UtilLib.sol';\n\nimport '../contracts/interfaces/SDCollateral/IAuction.sol';\nimport '../contracts/interfaces/IStaderStakePoolManager.sol';\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol';\n\ncontract Auction is IAuction, Initializable, AccessControlUpgradeable, PausableUpgradeable, ReentrancyGuardUpgradeable {\n    IStaderConfig public override staderConfig;\n    uint256 public override nextLot;\n    uint256 public override bidIncrement;\n    uint256 public override duration;\n\n    mapping(uint256 => LotItem) public lots;\n\n    uint256 public constant MIN_AUCTION_DURATION = 7200; // 24 hours\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _admin, address _staderConfig) external initializer {\n        UtilLib.checkNonZeroAddress(_admin);\n        UtilLib.checkNonZeroAddress(_staderConfig);\n\n        __AccessControl_init();\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        staderConfig = IStaderConfig(_staderConfig);\n        duration = 2 * MIN_AUCTION_DURATION;\n        bidIncrement = 5e15;\n        nextLot = 1;\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n        emit UpdatedStaderConfig(_staderConfig);\n        emit AuctionDurationUpdated(duration);\n        emit BidIncrementUpdated(bidIncrement);\n    }\n\n    function createLot(uint256 _sdAmount) external override whenNotPaused {\n        lots[nextLot].startBlock = block.number;\n        lots[nextLot].endBlock = block.number + duration;\n        lots[nextLot].sdAmount = _sdAmount;\n\n        LotItem storage lotItem = lots[nextLot];\n\n        if (!IERC20(staderConfig.getStaderToken()).transferFrom(msg.sender, address(this), _sdAmount)) {\n            revert SDTransferFailed();\n        }\n        emit LotCreated(nextLot, lotItem.sdAmount, lotItem.startBlock, lotItem.endBlock, bidIncrement);\n        nextLot++;\n    }\n\n    function addBid(uint256 lotId) external payable override whenNotPaused {\n        // reject payments of 0 ETH\n        if (msg.value == 0) revert InSufficientETH();\n\n        LotItem storage lotItem = lots[lotId];\n        if (block.number > lotItem.endBlock) revert AuctionEnded();\n\n        uint256 totalUserBid = lotItem.bids[msg.sender] + msg.value;\n\n        if (totalUserBid < lotItem.highestBidAmount + bidIncrement) revert InSufficientBid();\n\n        lotItem.highestBidder = msg.sender;\n        lotItem.highestBidAmount = totalUserBid;\n        lotItem.bids[msg.sender] = totalUserBid;\n\n        emit BidPlaced(lotId, msg.sender, totalUserBid);\n    }\n\n    function claimSD(uint256 lotId) external override {\n        LotItem storage lotItem = lots[lotId];\n        if (block.number <= lotItem.endBlock) revert AuctionNotEnded();\n        if (msg.sender != lotItem.highestBidder) revert notQualified();\n        if (lotItem.sdClaimed) revert AlreadyClaimed();\n\n        lotItem.sdClaimed = true;\n        if (!IERC20(staderConfig.getStaderToken()).transfer(lotItem.highestBidder, lotItem.sdAmount)) {\n            revert SDTransferFailed();\n        }\n        emit SDClaimed(lotId, lotItem.highestBidder, lotItem.sdAmount);\n    }\n\n    function transferHighestBidToSSPM(uint256 lotId) external override nonReentrant {\n        LotItem storage lotItem = lots[lotId];\n        uint256 ethAmount = lotItem.highestBidAmount;\n\n        if (block.number <= lotItem.endBlock) revert AuctionNotEnded();\n        if (ethAmount == 0) revert NoBidPlaced();\n        if (lotItem.ethExtracted) revert AlreadyClaimed();\n\n        lotItem.ethExtracted = true;\n        IStaderStakePoolManager(staderConfig.getStakePoolManager()).receiveEthFromAuction{value: ethAmount}();\n        emit ETHClaimed(lotId, staderConfig.getStakePoolManager(), ethAmount);\n    }\n\n    function extractNonBidSD(uint256 lotId) external override {\n        LotItem storage lotItem = lots[lotId];\n        if (block.number <= lotItem.endBlock) revert AuctionNotEnded();\n        if (lotItem.highestBidAmount > 0) revert LotWasAuctioned();\n        if (lotItem.sdAmount == 0) revert AlreadyClaimed();\n\n        uint256 _sdAmount = lotItem.sdAmount;\n        lotItem.sdAmount = 0;\n        if (!IERC20(staderConfig.getStaderToken()).transfer(staderConfig.getStaderTreasury(), _sdAmount)) {\n            revert SDTransferFailed();\n        }\n        emit UnsuccessfulSDAuctionExtracted(lotId, _sdAmount, staderConfig.getStaderTreasury());\n    }\n\n    function withdrawUnselectedBid(uint256 lotId) external override nonReentrant {\n        LotItem storage lotItem = lots[lotId];\n        if (block.number <= lotItem.endBlock) revert AuctionNotEnded();\n        if (msg.sender == lotItem.highestBidder) revert BidWasSuccessful();\n\n        uint256 withdrawalAmount = lotItem.bids[msg.sender];\n        if (withdrawalAmount == 0) revert InSufficientETH();\n\n        lotItem.bids[msg.sender] -= withdrawalAmount;\n\n        // send the funds\n        (bool success, ) = payable(msg.sender).call{value: withdrawalAmount}('');\n        if (!success) revert ETHWithdrawFailed();\n\n        emit BidWithdrawn(lotId, msg.sender, withdrawalAmount);\n    }\n\n    // SETTERS\n    function updateStaderConfig(address _staderConfig) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n        UtilLib.checkNonZeroAddress(_staderConfig);\n        staderConfig = IStaderConfig(_staderConfig);\n        emit UpdatedStaderConfig(_staderConfig);\n    }\n\n    function updateDuration(uint256 _duration) external override {\n        UtilLib.onlyManagerRole(msg.sender, staderConfig);\n        if (_duration < MIN_AUCTION_DURATION) revert ShortDuration();\n        duration = _duration;\n        emit AuctionDurationUpdated(duration);\n    }\n\n    function updateBidIncrement(uint256 _bidIncrement) external override {\n        UtilLib.onlyManagerRole(msg.sender, staderConfig);\n        bidIncrement = _bidIncrement;\n        emit BidIncrementUpdated(_bidIncrement);\n    }\n}"
    },
    {
      "filename": "contracts/SDCollateral.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport './library/UtilLib.sol';\n\nimport '../contracts/interfaces/IPoolUtils.sol';\nimport '../contracts/interfaces/SDCollateral/ISDCollateral.sol';\nimport '../contracts/interfaces/SDCollateral/IAuction.sol';\nimport '../contracts/interfaces/IStaderOracle.sol';\n\nimport '@openzeppelin/contracts/utils/math/Math.sol';\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ncontract SDCollateral is ISDCollateral, Initializable, AccessControlUpgradeable, ReentrancyGuardUpgradeable {\n    IStaderConfig public override staderConfig;\n    mapping(uint8 => PoolThresholdInfo) public poolThresholdbyPoolId;\n    mapping(address => uint256) public override operatorSDBalance;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _admin, address _staderConfig) public initializer {\n        UtilLib.checkNonZeroAddress(_admin);\n        UtilLib.checkNonZeroAddress(_staderConfig);\n\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n\n        staderConfig = IStaderConfig(_staderConfig);\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n\n        emit UpdatedStaderConfig(_staderConfig);\n    }\n\n    /**\n     * @param _sdAmount SD Token Amount to Deposit\n     * @dev sender should approve this contract for spending SD\n     */\n    function depositSDAsCollateral(uint256 _sdAmount) external override {\n        address operator = msg.sender;\n        operatorSDBalance[operator] += _sdAmount;\n\n        if (!IERC20(staderConfig.getStaderToken()).transferFrom(operator, address(this), _sdAmount)) {\n            revert SDTransferFailed();\n        }\n\n        emit SDDeposited(operator, _sdAmount);\n    }\n\n    /// @notice for operator to request withdraw of sd\n    /// @dev it does not transfer sd tokens immediately\n    /// operator should come back after withdrawal-delay time to claim\n    /// this requested sd is subject to slashes\n    function withdraw(uint256 _requestedSD) external override {\n        address operator = msg.sender;\n        uint256 opSDBalance = operatorSDBalance[operator];\n\n        if (opSDBalance < getOperatorWithdrawThreshold(operator) + _requestedSD) {\n            revert InsufficientSDToWithdraw(opSDBalance);\n        }\n        operatorSDBalance[operator] -= _requestedSD;\n\n        // cannot use safeERC20 as this contract is an upgradeable contract\n        if (!IERC20(staderConfig.getStaderToken()).transfer(payable(operator), _requestedSD)) {\n            revert SDTransferFailed();\n        }\n\n        emit SDWithdrawn(operator, _requestedSD);\n    }\n\n    /// @notice slashes one validator equi. SD amount\n    /// @dev callable only by respective withdrawVaults\n    /// @param _validatorId validator SD collateral to slash\n    function slashValidatorSD(uint256 _validatorId, uint8 _poolId) external override nonReentrant {\n        address operator = UtilLib.getOperatorForValidSender(_poolId, _validatorId, msg.sender, staderConfig);\n        isPoolThresholdValid(_poolId);\n        PoolThresholdInfo storage poolThreshold = poolThresholdbyPoolId[_poolId];\n        uint256 sdToSlash = convertETHToSD(poolThreshold.minThreshold);\n        slashSD(operator, sdToSlash);\n    }\n\n    /// @notice used to slash operator SD, incase of operator default\n    /// @dev do provide SD approval to auction contract using `maxApproveSD()`\n    /// @param _operator which operator SD collateral to slash\n    /// @param _sdToSlash amount of SD to slash\n    function slashSD(address _operator, uint256 _sdToSlash) internal {\n        uint256 sdBalance = operatorSDBalance[_operator];\n        uint256 sdSlashed = Math.min(_sdToSlash, sdBalance);\n        if (sdSlashed == 0) {\n            return;\n        }\n        operatorSDBalance[_operator] -= sdSlashed;\n        IAuction(staderConfig.getAuctionContract()).createLot(sdSlashed);\n        emit SDSlashed(_operator, staderConfig.getAuctionContract(), sdSlashed);\n    }\n\n    /// @notice for max approval to auction contract for spending SD tokens\n    function maxApproveSD() external override {\n        UtilLib.onlyManagerRole(msg.sender, staderConfig);\n        address auctionContract = staderConfig.getAuctionContract();\n        UtilLib.checkNonZeroAddress(auctionContract);\n        IERC20(staderConfig.getStaderToken()).approve(auctionContract, type(uint256).max);\n    }\n\n    // SETTERS\n    function updateStaderConfig(address _staderConfig) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n        UtilLib.checkNonZeroAddress(_staderConfig);\n        if (_staderConfig == address(staderConfig)) {\n            revert NoStateChange();\n        }\n        staderConfig = IStaderConfig(_staderConfig);\n        emit UpdatedStaderConfig(_staderConfig);\n    }\n\n    function updatePoolThreshold(\n        uint8 _poolId,\n        uint256 _minThreshold,\n        uint256 _maxThreshold,\n        uint256 _withdrawThreshold,\n        string memory _units\n    ) external override {\n        UtilLib.onlyManagerRole(msg.sender, staderConfig);\n        if ((_minThreshold > _withdrawThreshold) || (_minThreshold > _maxThreshold)) {\n            revert InvalidPoolLimit();\n        }\n\n        poolThresholdbyPoolId[_poolId] = PoolThresholdInfo({\n            minThreshold: _minThreshold,\n            maxThreshold: _maxThreshold,\n            withdrawThreshold: _withdrawThreshold,\n            units: _units\n        });\n\n        emit UpdatedPoolThreshold(_poolId, _minThreshold, _withdrawThreshold);\n    }\n\n    // GETTERS\n\n    // returns sum of withdraw threshold accounting for all its(op's) validators\n    function getOperatorWithdrawThreshold(address _operator) public view returns (uint256 operatorWithdrawThreshold) {\n        (uint8 poolId, , uint256 validatorCount) = getOperatorInfo(_operator);\n        isPoolThresholdValid(poolId);\n        PoolThresholdInfo storage poolThreshold = poolThresholdbyPoolId[poolId];\n        return convertETHToSD(poolThreshold.withdrawThreshold * validatorCount);\n    }\n\n    /// @notice checks if operator has enough SD collateral to onboard validators in a specific pool\n    /// @param _operator node operator addr who want to onboard validators\n    /// @param _poolId pool id, where operator wants to onboard validators\n    /// @param _numValidator number of validators to onBoard\n    function hasEnoughSDCollateral(\n        address _operator,\n        uint8 _poolId,\n        uint256 _numValidator\n    ) external view override returns (bool) {\n        return (getRemainingSDToBond(_operator, _poolId, _numValidator) == 0);\n    }\n\n    /// @notice returns minimum amount of SD required to onboard _numValidators in a pool\n    /// @param _poolId pool id, where operator wants to onboard validators\n    /// @param _numValidator number of validators to onBoard (including already onboarded, if any)\n    function getMinimumSDToBond(uint8 _poolId, uint256 _numValidator)\n        public\n        view\n        override\n        returns (uint256 _minSDToBond)\n    {\n        isPoolThresholdValid(_poolId);\n        PoolThresholdInfo storage poolThreshold = poolThresholdbyPoolId[_poolId];\n\n        _minSDToBond = convertETHToSD(poolThreshold.minThreshold);\n        _minSDToBond *= _numValidator;\n    }\n\n    /// @notice returns remaining amount of SD required to onboard _numValidators\n    /// @param _operator node operator addr who want to onboard validators\n    /// @param _poolId pool id, where operator wants to onboard validators\n    /// @param _numValidator number of validators to onBoard (including already onboarded, if any)\n    function getRemainingSDToBond(\n        address _operator,\n        uint8 _poolId,\n        uint256 _numValidator\n    ) public view override returns (uint256) {\n        uint256 sdBalance = operatorSDBalance[_o"
    }
  ]
}