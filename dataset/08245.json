{
  "Title": "[G-02] Caching storage values in memory",
  "Content": "\nThe code can be optimized by minimizing the number of SLOADs.\n\nSLOADs are expensive (100 gas after the 1st one) compared to MLOADs/MSTOREs (3 gas each). Storage values read multiple times should instead be cached in memory the first time (costing 1 SLOAD) and then read from this cache to avoid multiple SLOADs.\n\n*   [Saving many SLOADs (including in a for-loop)](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/NFTDropCollection.sol#L171-L187):\n\n```diff\nFile: NFTDropCollection.sol\n171:   function mintCountTo(uint16 count, address to) external onlyMinterOrAdmin returns (uint256 firstTokenId) { //@audit-ok\n172:     require(count != 0, \"NFTDropCollection: `count` must be greater than 0\");\n173: \n+ 173:      uint32 _latestTokenId = latestTokenId;\n174:     unchecked {\n175:       // If +1 overflows then +count would also overflow, unless count==0 in which case the loop would exceed gas limits\n- 176:       firstTokenId = latestTokenId + 1; //@audit gas: SLOAD 1 (latestTokenId)\n+ 176:       firstTokenId = _latestTokenId + 1;\n177:     }\n- 178:     latestTokenId = latestTokenId + count; //@audit gas: SLOAD 2 (latestTokenId)\n+ 178:     _latestTokenId = _latestTokenId + count;\n+ 178:     latestTokenId = _latestTokenId;\n- 179:     require(latestTokenId <= maxTokenId, \"NFTDropCollection: Exceeds max tokenId\"); //@audit gas: SLOAD 3 (latestTokenId)\n+ 179:     require(_latestTokenId <= maxTokenId, \"NFTDropCollection: Exceeds max tokenId\");\n180: \n- 181:     for (uint256 i = firstTokenId; i <= latestTokenId; ) {  //@audit gas: SLOAD \"latestTokenId - firstTokenId + 1\" (latestTokenId)\n+ 181:     for (uint256 i = firstTokenId; i <= _latestTokenId; ) {\n182:       _mint(to, i);\n183:       unchecked {\n184:         ++i;\n185:       }\n186:     }\n187:   }\n```\n\n*   [Saving 3 SLOADs (+ a pre-increment is cheaper, but this is counter-balanced with the memory variable)](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/NFTCollectionFactory.sol#L202-L218):\n\n```diff\nFile: NFTCollectionFactory.sol\n202:   function adminUpdateNFTCollectionImplementation(address _implementation) external onlyAdmin {\n203:     require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\n204:     implementationNFTCollection = _implementation;\n+ 204:     uint32 _versionNFTCollection;\n205:     unchecked {\n206:       // Version cannot overflow 256 bits.\n- 207:       versionNFTCollection++;\n+ 207:       _versionNFTCollection = ++versionNFTCollection;\n208:     }\n209: \n210:     // The implementation is initialized when assigned so that others may not claim it as their own.\n211:     INFTCollectionInitializer(_implementation).initialize(\n212:       payable(address(rolesContract)),\n- 213:       string.concat(\"NFT Collection Implementation v\", versionNFTCollection.toString()),\n+ 213:       string.concat(\"NFT Collection Implementation v\", _versionNFTCollection.toString()),\n- 214:       string.concat(\"NFTv\", versionNFTCollection.toString())\n+ 214:       string.concat(\"NFTv\", _versionNFTCollection.toString())\n215:     );\n216: \n- 217:     emit ImplementationNFTCollectionUpdated(_implementation, versionNFTCollection);\n+ 217:     emit ImplementationNFTCollectionUpdated(_implementation, _versionNFTCollection);\n218:   }\n```\n\n*   [Saving 3 SLOADs (+ a pre-increment is cheaper, but this is counter-balanced with the memory variable)](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/NFTCollectionFactory.sol#L226-L247)\n\n```diff\nFile: NFTCollectionFactory.sol\n226:   function adminUpdateNFTDropCollectionImplementation(address _implementation) external onlyAdmin {\n227:     require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\n228:     implementationNFTDropCollection = _implementation;\n+ 228:         uint32 _versionNFTDropCollection;\n229:     unchecked {\n230:       // Version cannot overflow 256 bits.\n- 231:       versionNFTDropCollection++;\n+ 231:       _versionNFTDropCollection = ++versionNFTDropCollection;\n232:     }\n233: \n- 234:     emit ImplementationNFTDropCollectionUpdated(_implementation, versionNFTDropCollection);\n+ 234:     emit ImplementationNFTDropCollectionUpdated(_implementation, _versionNFTDropCollection);\n235: \n236:     // The implementation is initialized when assigned so that others may not claim it as their own.\n237:     INFTDropCollectionInitializer(_implementation).initialize(\n238:       payable(address(this)),\n- 239:       string.concat(\"NFT Drop Collection Implementation v\", versionNFTDropCollection.toString()),\n- 240:       string.concat(\"NFTDropV\", versionNFTDropCollection.toString()),\n+ 239:       string.concat(\"NFT Drop Collection Implementation v\", _versionNFTDropCollection.toString()),\n+ 240:       string.concat(\"NFTDropV\", _versionNFTDropCollection.toString()),\n241:       \"ipfs://bafybeibvxnuaqtvaxu26gdgly2rm4g2piu7b2tqlx2dsz6wwhqbey2gddy/\",\n242:       0x1337000000000000000000000000000000000000000000000000000000001337,\n243:       1,\n244:       address(0),\n245:       payable(0)\n246:     );\n247:   }\n```\n\n*   [Saving 1 SLOAD. If we're optimistic towards the presence of a `baseURI_` string here, this should be cached](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/NFTCollection.sol#L332-L337):\n\n```diff\nFile: NFTCollection.sol\n332:   function _baseURI() internal view override returns (string memory) {\n- 333:     if (bytes(baseURI_).length != 0) {\n+ 333:     string memory memBaseURI = baseURI_;\n+ 333:     if (bytes(memBaseURI).length != 0) {\n- 334:       return baseURI_;\n+ 334:       return memBaseURI;\n335:     }\n336:     return \"ipfs://\";\n337:   }\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-08-foundation-drop-contest",
  "Code": [
    {
      "filename": "contracts/NFTDropCollection.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"./interfaces/INFTDropCollectionInitializer.sol\";\nimport \"./interfaces/INFTDropCollectionMint.sol\";\n\nimport \"./mixins/collections/CollectionRoyalties.sol\";\nimport \"./mixins/collections/SequentialMintCollection.sol\";\nimport \"./mixins/roles/AdminRole.sol\";\nimport \"./mixins/roles/MinterRole.sol\";\nimport \"./mixins/shared/Constants.sol\";\nimport \"./mixins/shared/ContractFactory.sol\";\n\n/**\n * @title A contract to batch mint a collection of NFTs.\n * @notice A 10% royalty to the creator is included which may be split with collaborators.\n * @dev A collection can have up to 4,294,967,295 (2^32-1) tokens\n */\ncontract NFTDropCollection is\n  INFTDropCollectionInitializer,\n  INFTDropCollectionMint,\n  IGetRoyalties,\n  IGetFees,\n  IRoyaltyInfo,\n  ITokenCreator,\n  ContractFactory,\n  Initializable,\n  ContextUpgradeable,\n  ERC165Upgradeable,\n  AccessControlUpgradeable,\n  AdminRole,\n  MinterRole,\n  ERC721Upgradeable,\n  ERC721BurnableUpgradeable,\n  SequentialMintCollection,\n  CollectionRoyalties\n{\n  using Strings for uint256;\n\n  /****** Slot 0 (after inheritance) ******/\n  /**\n   * @notice The address to pay the proceeds/royalties for the collection.\n   * @dev If this is set to address(0) then the proceeds go to the creator.\n   */\n  address payable private paymentAddress;\n  // 96 bits free space\n\n  /****** Slot 1 ******/\n  /**\n   * @notice The base URI used for all NFTs in this collection.\n   * @dev The `<tokenId>.json` is appended to this to obtain an NFT's `tokenURI`.\n   *      e.g. The URI for `tokenId`: \"1\" with `baseURI`: \"ipfs://foo/\" is \"ipfs://foo/1.json\".\n   * @return The base URI used by this collection.\n   */\n  string public baseURI;\n\n  /****** Slot 2 ******/\n  /**\n   * @notice The hash of the revealed baseURI for the collection.\n   * @dev This can be used to verify that the content was not changed after NFTs were minted.\n   * @return bytes32(0) if the content has been revealed.\n   * In pre-reveal state this is set to bytes32(1) when the final content is unknown\n   * otherwise set to keccak256(finalContentBaseURI).\n   */\n  bytes32 public postRevealBaseURIHash;\n\n  /****** End of storage ******/\n\n  /**\n   * @notice Emitted when the collection is revealed.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   */\n  event URIUpdated(string baseURI, bytes32 postRevealBaseURIHash);\n\n  modifier validBaseURI(string calldata _baseURI) {\n    require(bytes(_baseURI).length > 0, \"NFTDropCollection: `_baseURI` must be set\");\n    _;\n  }\n\n  modifier onlyWhileUnrevealed() {\n    require(postRevealBaseURIHash != bytes32(0), \"NFTDropCollection: Already revealed\");\n    _;\n  }\n\n  /**\n   * @notice Initialize the template's immutable variables.\n   * @param _contractFactory The factory which will be used to create collection contracts.\n   */\n  constructor(address _contractFactory)\n    ContractFactory(_contractFactory) // solhint-disable-next-line no-empty-blocks\n  {}\n\n  /**\n   * @notice Called by the contract factory on creation.\n   * @param _creator The creator of this collection.\n   * This account is the default admin for this collection.\n   * @param _name The collection's `name`.\n   * @param _symbol The collection's `symbol`.\n   * @param _baseURI The base URI for the collection.\n   * @param _postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param _maxTokenId The max token id for this collection.\n   * @param _approvedMinter An optional address to grant the MINTER_ROLE.\n   * Set to address(0) if only admins should be granted permission to mint.\n   * @param _paymentAddress The address that will receive royalties and mint payments.\n   */\n  function initialize(\n    address payable _creator,\n    string calldata _name,\n    string calldata _symbol,\n    string calldata _baseURI,\n    bytes32 _postRevealBaseURIHash,\n    uint32 _maxTokenId,\n    address _approvedMinter,\n    address payable _paymentAddress\n  ) external initializer onlyContractFactory validBaseURI(_baseURI) {\n    require(bytes(_symbol).length > 0, \"NFTDropCollection: `_symbol` must be set\");\n    require(_maxTokenId > 0, \"NFTDropCollection: `_maxTokenId` must be set\");\n\n    // Initialize the NFT\n    __ERC721_init(_name, _symbol);\n    _initializeSequentialMintCollection(_creator, _maxTokenId);\n\n    // Initialize royalties\n    if (_paymentAddress != address(0)) {\n      // If no payment address was defined, use the creator's address.\n      paymentAddress = _paymentAddress;\n    }\n\n    // Initialize URI\n    baseURI = _baseURI;\n    postRevealBaseURIHash = _postRevealBaseURIHash;\n\n    // Initialize access control\n    AdminRole._initializeAdminRole(_creator);\n    if (_approvedMinter != address(0)) {\n      MinterRole._initializeMinterRole(_approvedMinter);\n    }\n  }\n\n  /**\n   * @notice Allows the collection admin to burn a specific token if they currently own the NFT.\n   * @param tokenId The ID of the NFT to burn.\n   * @dev The function here asserts `onlyAdmin` while the super confirms ownership.\n   */\n  function burn(uint256 tokenId) public override onlyAdmin {\n    super.burn(tokenId);\n  }\n\n  /**\n   * @notice Mint `count` number of NFTs for the `to` address.\n   * @dev This is only callable by an address with either the MINTER_ROLE or the DEFAULT_ADMIN_ROLE.\n   * @param count The number of NFTs to mint.\n   * @param to The address to mint the NFTs for.\n   * @return firstTokenId The tokenId for the first NFT minted.\n   * The other minted tokens are assigned sequentially, so `firstTokenId` - `firstTokenId + count - 1` were minted.\n   */\n  function mintCountTo(uint16 count, address to) external onlyMinterOrAdmin returns (uint256 firstTokenId) {\n    require(count != 0, \"NFTDropCollection: `count` must be greater than 0\");\n\n    unchecked {\n      // If +1 overflows then +count would also overflow, unless count==0 in which case the loop would exceed gas limits\n      firstTokenId = latestTokenId + 1;\n    }\n    latestTokenId = latestTokenId + count;\n    require(latestTokenId <= maxTokenId, \"NFTDropCollection: Exceeds max tokenId\");\n\n    for (uint256 i = firstTokenId; i <= latestTokenId; ) {\n      _mint(to, i);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice Allows a collection admin to reveal the collection's final content.\n   * @dev Once revealed, the collection's content is immutable.\n   * Use `updatePreRevealContent` to update content while unrevealed.\n   * @param _baseURI The base URI of the final content for this collection.\n   */\n  function reveal(string calldata _baseURI) external onlyAdmin validBaseURI(_baseURI) onlyWhileUnrevealed {\n    // `postRevealBaseURIHash` == 0 indicates that the collection has been revealed.\n    delete postRevealBaseURIHash;\n\n    // Set the new base URI.\n    baseURI = _baseURI;\n    emit URIUpdated(_baseURI, \"\");\n  }\n\n  /**\n   * @notice Allows a collection admin to destroy this contract only if\n   * no NFTs have been minted yet or the minted NFTs have been burned.\n   * @dev Once destructed, a new collection could be deployed to this address (although that's discouraged).\n   */\n  function selfDestruct() external onlyAdmin {\n    _selfDestruct();\n  }\n\n  /**\n   * @notice Allows the owner to set a max tokenID.\n   * This provides a guarantee to collectors about the limit of this collection contract.\n   * @dev Once this value has been set, it may be decreased but can never be increased.\n   * This max may be less than the final `totalSupply` if 1 or more tokens were burned.\n   * @param _maxTokenId The max tokenId to set, all NFTs must have a tokenId less than or equal to this value.\n   */\n  function updateMaxTokenId(uint32 _maxTokenId) external onlyAdmin {\n    _updateMaxTokenId(_maxTokenId);\n  }\n\n  /**\n   * @notice Allows a collection admin to update the pre-reveal content.\n   * @dev Use `reveal` to reveal the final content for this collection.\n   * @param _baseURI The base URI of the pre-reveal content.\n   * @param _postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   */\n  function updatePreRevealContent(string calldata _baseURI, bytes32 _postRevealBaseURIHash)\n    external\n    validBaseURI(_baseURI)\n    onlyWhileUnrevealed\n    onlyAdmin\n  {\n    require(_postRevealBaseURIHash != bytes32(0), \"NFTDropCollection: use `reveal` instead\");\n\n    postRevealBaseURIHash = _postRevealBaseURIHash;\n    baseURI = _baseURI;\n    emit URIUpdated(baseURI, postRevealBaseURIHash);\n  }\n\n  function _burn(uint256 tokenId) internal override(ERC721Upgradeable, SequentialMintCollection) {\n    super._burn(tokenId);\n  }\n\n  /**\n   * @inheritdoc CollectionRoyalties\n   */\n  function getTokenCreatorPaymentAddress(\n    uint256 /* tokenId */\n  ) public view override returns (address payable creatorPaymentAddress) {\n    creatorPaymentAddress = paymentAddress;\n    if (creatorPaymentAddress == address(0)) {\n      creatorPaymentAddress = owner;\n    }\n  }\n\n  /**\n   * @notice Returns whether the collection has been revealed.\n   * @dev Once revealed, the collection's content is immutable.\n   * @return revealed True if the collection has been revealed.\n   */\n  function isRevealed() external view returns (bool revealed) {\n    revealed = postRevealBaseURIHash == bytes32(0);\n  }\n\n  /**\n   * @notice Get the number of tokens which can still be minted.\n   * @return count The max number of additional NFTs that can be minted by this collection.\n   */\n  function numberOfTokensAvailableToMint() external view returns (uint256 count) {\n    // Mint ensures that latestTokenId is always <= maxTokenId\n    unchecked {\n      count = maxTokenId - latestTokenId;\n    }\n  }\n\n  /**\n   * @inheritdoc IERC165Upgradeable\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC165Upgradeable, AccessControlUpgradeable, ERC721Upgradeable, CollectionRoyalties)\n    returns (bool interfaceSupported)\n  {\n    if (interfaceId == type(INFTDropCollectionMint).interfaceId) {\n      interfaceSupported = true;\n    } else {\n      interfaceSupported = super.supportsInterface(interfaceId);\n    }\n  }\n\n  /**\n   * @inheritdoc IERC721MetadataUpgradeable\n   */\n  function tokenURI(uint256 tokenId) public view override returns (string memory uri) {\n    _requireMinted(tokenId);\n\n    return string.concat(baseURI, tokenId.toString(), \".json\");\n  }\n}"
    },
    {
      "filename": "contracts/NFTCollectionFactory.sol",
      "content": "/*\n  ･\n   *　★\n      ･ ｡\n        　･　ﾟ☆ ｡\n  　　　 *　★ ﾟ･｡ *  ｡\n          　　* ☆ ｡･ﾟ*.｡\n      　　　ﾟ *.｡☆｡★　･\n​\n                      `                     .-:::::-.`              `-::---...```\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\n                                              `````\n   *　\n      ･ ｡\n　　　　･　　ﾟ☆ ｡\n  　　　 *　★ ﾟ･｡ *  ｡\n          　　* ☆ ｡･ﾟ*.｡\n      　　　ﾟ *.｡☆｡★　･\n    *　　ﾟ｡·*･｡ ﾟ*\n  　　　☆ﾟ･｡°*. ﾟ\n　 ･ ﾟ*｡･ﾟ★｡\n　　･ *ﾟ｡　　 *\n　･ﾟ*｡★･\n ☆∴｡　*\n･ ｡\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport \"./interfaces/ICollectionFactory.sol\";\nimport \"./interfaces/INFTDropCollectionInitializer.sol\";\nimport \"./interfaces/INFTCollectionInitializer.sol\";\nimport \"./interfaces/IRoles.sol\";\n\nimport \"./libraries/AddressLibrary.sol\";\nimport \"./mixins/shared/Gap10000.sol\";\n\n/**\n * @title A factory to create NFT collections.\n * @notice Call this factory to create NFT collections.\n * @dev This creates and initializes an ERC-1165 minimal proxy pointing to a NFT collection contract implementation.\n */\ncontract NFTCollectionFactory is ICollectionFactory, Initializable, Gap10000 {\n  using AddressUpgradeable for address;\n  using Clones for address;\n  using Strings for uint32;\n\n  /****** Slot 0 (after inheritance) ******/\n  /**\n   * @notice The address of the implementation all new NFTCollections will leverage.\n   * @dev When this is changed, `versionNFTCollection` is incremented.\n   * @return The implementation address for NFTCollection.\n   */\n  address public implementationNFTCollection;\n\n  /**\n   * @notice The implementation version of new NFTCollections.\n   * @dev This is auto-incremented each time `implementationNFTCollection` is changed.\n   * @return The current NFTCollection implementation version.\n   */\n  uint32 public versionNFTCollection;\n\n  /****** Slot 1 ******/\n  /**\n   * @notice The address of the implementation all new NFTDropCollections will leverage.\n   * @dev When this is changed, `versionNFTDropCollection` is incremented.\n   * @return The implementation address for NFTDropCollection.\n   */\n  address public implementationNFTDropCollection;\n\n  /**\n   * @notice The implementation version of new NFTDropCollections.\n   * @dev This is auto-incremented each time `implementationNFTDropCollection` is changed.\n   * @return The current NFTDropCollection implementation version.\n   */\n  uint32 public versionNFTDropCollection;\n\n  /****** End of storage ******/\n\n  /**\n   * @notice The contract address which manages common roles.\n   * @dev Defines a centralized admin role definition for permissioned functions below.\n   * @return The contract address with role definitions.\n   */\n  IRoles public immutable rolesContract;\n\n  /**\n   * @notice Emitted when the implementation of NFTCollection used by new collections is updated.\n   * @param implementation The new implementation contract address.\n   * @param version The version of the new implementation, auto-incremented.\n   */\n  event ImplementationNFTCollectionUpdated(address indexed implementation, uint256 indexed version);\n\n  /**\n   * @notice Emitted when the implementation of NFTDropCollection used by new collections is updated.\n   * @param implementationNFTDropCollection The new implementation contract address.\n   * @param version The version of the new implementation, auto-incremented.\n   */\n  event ImplementationNFTDropCollectionUpdated(\n    address indexed implementationNFTDropCollection,\n    uint256 indexed version\n  );\n\n  /**\n   * @notice Emitted when a new NFTCollection is created from this factory.\n   * @param collection The address of the new NFT collection contract.\n   * @param creator The address of the creator which owns the new collection.\n   * @param version The implementation version used by the new collection.\n   * @param name The name of the collection contract created.\n   * @param symbol The symbol of the collection contract created.\n   * @param nonce The nonce used by the creator when creating the collection,\n   * used to define the address of the collection.\n   */\n  event NFTCollectionCreated(\n    address indexed collection,\n    address indexed creator,\n    uint256 indexed version,\n    string name,\n    string symbol,\n    uint256 nonce\n  );\n\n  /**\n   * @notice Emitted when a new NFTDropCollection is created from this factory.\n   * @param collection The address of the new NFT drop collection contract.\n   * @param creator The address of the creator which owns the new collection.\n   * @param approvedMinter An optional address to grant the MINTER_ROLE.\n   * @param name The collection's `name`.\n   * @param symbol The collection's `symbol`.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param maxTokenId The max `tokenID` for this collection.\n   * @param paymentAddress The address that will receive royalties and mint payments.\n   * @param version The implementation version used by the new NFTDropCollection collection.\n   * @param nonce The nonce used by the creator to create this collection.\n   */\n  event NFTDropCollectionCreated(\n    address indexed collection,\n    address indexed creator,\n    address indexed approvedMinter,\n    string name,\n    string symbol,\n    string baseURI,\n    bytes32 postRevealBaseURIHash,\n    uint256 maxTokenId,\n    address paymentAddress,\n    uint256 version,\n    uint256 nonce\n  );\n\n  modifier onlyAdmin() {\n    require(rolesContract.isAdmin(msg.sender), \"NFTCollectionFactory: Caller does not have the Admin role\");\n    _;\n  }\n\n  /**\n   * @notice Defines requirements for the collection drop factory at deployment time.\n   * @param _rolesContract The address of the contract defining roles for collections to use.\n   */\n  constructor(address _rolesContract) {\n    require(_rolesContract.isContract(), \"NFTCollectionFactory: RolesContract is not a contract\");\n\n    rolesContract = IRoles(_rolesContract);\n  }\n\n  /**\n   * @notice Initializer called after contract creation.\n   * @dev This is used so that this factory will resume versions from where our original factory had left off.\n   * @param _versionNFTCollection The current implementation version for NFTCollections.\n   */\n  function initialize(uint32 _versionNFTCollection) external initializer {\n    versionNFTCollection = _versionNFTCollection;\n  }\n\n  /**\n   * @notice Allows Foundation to change the NFTCollection implementation used for future collections.\n   * This call will auto-increment the version.\n   * Existing collections are not impacted.\n   * @param _implementation The new NFTCollection collection implementation address.\n   */\n  function adminUpdateNFTCollectionImplementation(address _implementation) external onlyAdmin {\n    require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\n    implementationNFTCollection = _implementation;\n    unchecked {\n      // Version cannot overflow 256 bits.\n      versionNFTCollection++;\n    }\n\n    // The implementation is initialized when assigned so that others may not claim it as their own.\n    INFTCollectionInitializer(_implementation).initialize(\n      payable(address(rolesContract)),\n      string.concat(\"NFT Collection Implementation v\", versionNFTCollection.toString()),\n      string.concat(\"NFTv\", versionNFTCollection.toString())\n    );\n\n    emit ImplementationNFTCollectionUpdated(_implementation, versionNFTCollection);\n  }\n\n  /**\n   * @notice Allows Foundation to change the NFTDropCollection implementation used for future collections.\n   * This call will auto-increment the version.\n   * Existing collections are not impacted.\n   * @param _implementation The new NFTDropCollection collection implementation address.\n   */\n  function adminUpdateNFTDropCollectionImplementation(address _implementation) external onlyAdmin {\n    require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\n    implementationNFTDropCollection = _implementation;\n    unchecked {\n      // Version cannot overflow 256 bits.\n      versionNFTDropCollection++;\n    }\n\n    emit ImplementationNFTDropCollectionUpdated(_implementation, versionNFTDropCollection);\n\n    // The implementation is initialized when assigned so that others may not claim it as their own.\n    INFTDropCollectionInitializer(_implementation).initialize(\n      payable(address(this)),\n      string.concat(\"NFT Drop Collection Implementation v\", versionNFTDropCollection.toString()),\n      string.concat(\"NFTDropV\", versionNFTDropCollection.toString()),\n      \"ipfs://bafybeibvxnuaqtvaxu26gdgly2rm4g2piu7b2tqlx2dsz6wwhqbey2gddy/\",\n      0x1337000000000000000000000000000000000000000000000000000000001337,\n      1,\n      address(0),\n      payable(0)\n    );\n  }\n\n  /**\n   * @notice Create a new collection contract.\n   * @dev The nonce must be unique for the msg.sender + implementation version, otherwise this call will revert.\n   * @param name The collection's `name`.\n   * @param symbol The collection's `symbol`.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @return collection The address of the newly created collection contract.\n   */\n  function createNFTCollection(\n    string calldata name,\n    string calldata symbol,\n    uint256 nonce\n  ) external returns (address collection) {\n    require(bytes(symbol).length != 0, \"NFTCollectionFactory: Symbol is required\");\n\n    // This reverts if the NFT was previously created using this implementation version + msg.sender + nonce\n    collection = implementationNFTCollection.cloneDeterministic(_getSalt(msg.sender, nonce));\n\n    INFTCollectionInitializer(collection).initialize(payable(msg.sender), name, symbol);\n\n    emit NFTCollectionCreated(collection, msg.sender, versionNFTCollection, name, symbol, nonce);\n  }\n\n  /**\n   * @notice Create a new drop collection contract.\n   * @dev The nonce must be unique for the msg.sender + implementation version, otherwise this call will revert.\n   * @param name The collection's `name`.\n   * @param symbol The collection's `symbol`.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param maxTokenId The max token id for this collection.\n   * @param approvedMinter An optional address to grant the MINTER_ROLE.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @return collection The address of the newly created collection contract.\n   */\n  function createNFTDropCollection(\n    string calldata name,\n    string calldata symbol,\n    string calldata baseURI,\n    bytes32 postRevealBaseURIHash,\n    uint32 maxTokenId,\n    address approvedMinter,\n    uint256 nonce\n  ) external returns (address collection) {\n    return\n      _createNFTDropCollection(\n        name,\n        symbol,\n        baseURI,\n        postRevealBaseURIHash,\n        maxTokenId,\n        approvedMinter,\n        payable(0),\n        nonce\n      );\n  }\n\n  /**\n   * @notice Create a new drop collection contract with a custom payment address.\n   * @dev All params other than `paymentAddress` are the same as in `createNFTDropCollection`.\n   * The nonce must be unique for the msg.sender + implementation version, otherwise this call will revert.\n   * @param name The collection's `name`.\n   * @param symbol The collection's `symbol`.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param maxTokenId The max token id for this collection.\n   * @param approvedMinter An optional address to grant the MINTER_ROLE.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @param paymentAddress The address that will receive royalties and mint payments.\n   * @return collection The address of the newly created collection contract.\n   */\n  function createNFTDropCollectionWithPaymentAddress(\n    string calldata name,\n    string calldata symbol,\n    string calldata baseURI,\n    bytes32 postRevealBaseURIHash,\n    uint32 maxTokenId,\n    address approvedMinter,\n    uint256 nonce,\n    address payable paymentAddress\n  ) external returns (address collection) {\n    return\n      _createNFTDropCollection(\n        name,\n        symbol,\n        baseURI,\n        postRevealBaseURIHash,\n        maxTokenId,\n        approvedMinter,\n        paymentAddress != msg.sender ? paymentAddress : payable(0),\n        nonce\n      );\n  }\n\n  /**\n   * @notice Create a new drop collection contract with a custom payment address derived from the factory.\n   * @dev All params other than `paymentAddressFactoryCall` are the same as in `createNFTDropCollection`.\n   * The nonce must be unique for the msg.sender + implementation version, otherwise this call will revert.\n   * @param name The collection's `name`.\n   * @param symbol The collection's `symbol`.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param maxTokenId The max token id for this collection.\n   * @param approvedMinter An optional address to grant the MINTER_ROLE.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @param paymentAddressFactoryCall The contract call which will return the address to use for payments.\n   * @return collection The address of the newly created collection contract.\n   */\n  function createNFTDropCollectionWithPaymentFactory(\n    string calldata name,\n    string calldata symbol,\n    string calldata baseURI,\n    bytes32 postRevealBaseURIHash,\n    uint32 maxTokenId,\n    address approvedMinter,\n    uint256 nonce,\n    CallWithoutValue memory paymentAddressFactoryCall\n  ) external returns (address collection) {\n    return\n      _createNFTDropCollection(\n        name,\n        symbol,\n        baseURI,\n        postRevealBaseURIHash,\n        maxTokenId,\n        approvedMinter,\n        AddressLibrary.callAndReturnContractAddress(paymentAddressFactoryCall),\n        nonce\n      );\n  }\n\n  function _createNFTDropCollection(\n    string calldata name,\n    string calldata symbol,\n    string calldata baseURI,\n    bytes32 postRevealBaseURIHash,\n    uint32 maxTokenId,\n    address approvedMinter,\n    address payable paymentAddress,\n    uint256 nonce\n  ) private returns (address collection) {\n    // This reverts if the NFT was previously created using this implementation version + msg.sender + nonce\n    collection = implementationNFTDropCollection.cloneDeterministic(_getSalt(msg.sender, nonce));\n\n    INFTDropCollectionInitializer(collection).initialize(\n      payable(msg.sender),\n      name,\n      symbol,\n      baseURI,\n      postRevealBaseURIHash,\n      maxTokenId,\n      approvedMinter,\n      paymentAddress\n    );\n\n    emit NFTDropCollectionCreated(\n      collection,\n      msg.sender,\n      approvedMinter,\n      name,\n      symbol,\n      baseURI,\n      postRevealBaseURIHash,\n      maxTokenId,\n      paymentAddress,\n      versionNFTDropCollection,\n      nonce\n    );\n  }\n\n  /**\n   * @notice Returns the address of a collection given the current implementation version, creator, and nonce.\n   * This will return the same address whether the collection has already been created or not.\n   * @param creator The creator of the collection.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @return collection The address of the collection contract that would be created by this nonce.\n   */\n  function predictNFTCollectionAddress(address creator, uint256 nonce) external view returns (address collection) {\n    collection = implementationNFTCollection.predictDeterministicAddress(_getSalt(creator, nonce));\n  }\n\n  /**\n   * @notice Returns the address of a NFTDropCollection collection given the current\n   * implementation version, creator, and nonce.\n   * This will return the same address whether the collection has already been created or not.\n   * @param creator The creator of the collection.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @return collection The address of the collection contract that would be created by this nonce.\n   */\n  function predictNFTDropCollectionAddress(address creator, uint256 nonce) external view returns (address collection) {\n    collection = implementationNFTDropCollection.predictDeterministicAddress(_getSalt(creator, nonce));\n  }\n\n  function _getSalt(address creator, uint256 nonce) private pure returns (bytes32) {\n    return keccak256(abi.encodePacked(creator, nonce));\n  }\n}"
    },
    {
      "filename": "contracts/NFTCollectionFactory.sol",
      "content": "/*\n  ･\n   *　★\n      ･ ｡\n        　･　ﾟ☆ ｡\n  　　　 *　★ ﾟ･｡ *  ｡\n          　　* ☆ ｡･ﾟ*.｡\n      　　　ﾟ *.｡☆｡★　･\n​\n                      `                     .-:::::-.`              `-::---...```\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\n                                              `````\n   *　\n      ･ ｡\n　　　　･　　ﾟ☆ ｡\n  　　　 *　★ ﾟ･｡ *  ｡\n          　　* ☆ ｡･ﾟ*.｡\n      　　　ﾟ *.｡☆｡★　･\n    *　　ﾟ｡·*･｡ ﾟ*\n  　　　☆ﾟ･｡°*. ﾟ\n　 ･ ﾟ*｡･ﾟ★｡\n　　･ *ﾟ｡　　 *\n　･ﾟ*｡★･\n ☆∴｡　*\n･ ｡\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport \"./interfaces/ICollectionFactory.sol\";\nimport \"./interfaces/INFTDropCollectionInitializer.sol\";"
    }
  ]
}