{
  "Title": "[01] Admin is a single point of failure",
  "Content": "\nMultiple instances in code where the admin logic could lead to a brick in normal functionality.\n\nFor example take a look [here](https://github.com/code-423n4/2024-03-acala/blob/9c71c05cf2d9f0a2603984c50f76fc8a315d4d65/src/modules/incentives/src/lib.rs#L83-L85).\n\n```rust\n\t\t/// The origin which may update incentive related params\n\t\ttype UpdateOrigin: EnsureOrigin<Self::RuntimeOrigin>;\n```\n\nThis is an instance where a somewhat `admin` logic has been applied, note that this is passed in the config's constant paller. Now using [this search command](https://github.com/search?q=repo%3Acode-423n4%2F2024-03-acala%20UpdateOrigin&type=code), we can see that there are three function calls where the expected caller is only accepted to be the `update incentive related params`.\n\n### Impact\n\nInaccess to update incentive related params if anything was to happen to the `UpdateOrigin`.\n\n### Recommended Mitigation Steps\n\nConsider implementing a backdoor that the admins could use to change the incentive related params if anything were to happen to `UpdateOrigin`.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-acala",
  "Code": [
    {
      "filename": "src/modules/incentives/src/lib.rs",
      "content": "// This file is part of Acala.\n\n// Copyright (C) 2020-2024 Acala Foundation.\n// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\n\n//! # Incentives Module\n//!\n//! ## Overview\n//!\n//! Acala platform need support different types of rewards for some other protocol.\n//! Each Pool has its own multi currencies rewards and reward accumulation\n//! mechanism. ORML rewards module records the total shares, total multi currencies rewards anduser\n//! shares of specific pool. Incentives module provides hooks to other protocals to manage shares,\n//! accumulates rewards and distributes rewards to users based on their shares.\n//!\n//! Pool types:\n//! 1. Loans: record the shares and rewards for users of Loans(Honzon protocol).\n//! 2. Dex: record the shares and rewards for DEX makers who staking LP token.\n//!\n//! Rewards accumulation:\n//! 1. Incentives: periodicly(AccumulatePeriod), accumulate fixed amount according to Incentive.\n//! Rewards come from RewardsSource, please transfer enough tokens to RewardsSource before\n//! start incentive plan.\n\n#![cfg_attr(not(feature = \"std\"), no_std)]\n#![allow(clippy::unused_unit)]\n#![allow(clippy::upper_case_acronyms)]\n\nuse frame_support::{pallet_prelude::*, transactional, PalletId};\nuse frame_system::pallet_prelude::*;\nuse module_support::{DEXIncentives, EmergencyShutdown, FractionalRate, IncentivesManager, PoolId, Rate};\nuse orml_traits::{Happened, MultiCurrency, RewardHandler};\nuse primitives::{Amount, Balance, CurrencyId};\nuse sp_runtime::{\n\ttraits::{AccountIdConversion, UniqueSaturatedInto, Zero},\n\tDispatchResult, FixedPointNumber,\n};\nuse sp_std::{collections::btree_map::BTreeMap, prelude::*};\n\nmod mock;\nmod tests;\npub mod weights;\n\npub use module::*;\npub use weights::WeightInfo;\n\n#[frame_support::pallet]\npub mod module {\n\tuse super::*;\n\n\t#[pallet::config]\n\tpub trait Config:\n\t\tframe_system::Config\n\t\t+ orml_rewards::Config<Share = Balance, Balance = Balance, PoolId = PoolId, CurrencyId = CurrencyId>\n\t{\n\t\ttype RuntimeEvent: From<Event<Self>> + IsType<<Self as frame_system::Config>::RuntimeEvent>;\n\n\t\t/// The period to accumulate rewards\n\t\t#[pallet::constant]\n\t\ttype AccumulatePeriod: Get<BlockNumberFor<Self>>;\n\n\t\t/// The native currency for earning staking\n\t\t#[pallet::constant]\n\t\ttype NativeCurrencyId: Get<CurrencyId>;\n\n\t\t/// The source account for native token rewards.\n\t\t#[pallet::constant]\n\t\ttype RewardsSource: Get<Self::AccountId>;\n\n\t\t/// The origin which may update incentive related params\n\t\ttype UpdateOrigin: EnsureOrigin<Self::RuntimeOrigin>;\n\n\t\t/// Currency for transfer assets\n\t\ttype Currency: MultiCurrency<Self::AccountId, CurrencyId = CurrencyId, Balance = Balance>;\n\n\t\t/// Emergency shutdown.\n\t\ttype EmergencyShutdown: EmergencyShutdown;\n\n\t\t/// The module id, keep DexShare LP.\n\t\t#[pallet::constant]\n\t\ttype PalletId: Get<PalletId>;\n\n\t\t/// Weight information for the extrinsics in this module.\n\t\ttype WeightInfo: WeightInfo;\n\t}\n\n\t#[pallet::error]\n\tpub enum Error<T> {\n\t\t/// Share amount is not enough\n\t\tNotEnough,\n\t\t/// Invalid currency id\n\t\tInvalidCurrencyId,\n\t\t/// Invalid pool id\n\t\tInvalidPoolId,\n\t\t/// Invalid rate\n\t\tInvalidRate,\n\t}\n\n\t#[pallet::event]\n\t#[pallet::generate_deposit(pub(crate) fn deposit_event)]\n\tpub enum Event<T: Config> {\n\t\t/// Deposit DEX share.\n\t\tDepositDexShare {\n\t\t\twho: T::AccountId,\n\t\t\tdex_share_type: CurrencyId,\n\t\t\tdeposit: Balance,\n\t\t},\n\t\t/// Withdraw DEX share.\n\t\tWithdrawDexShare {\n\t\t\twho: T::AccountId,\n\t\t\tdex_share_type: CurrencyId,\n\t\t\twithdraw: Balance,\n\t\t},\n\t\t/// Claim rewards.\n\t\tClaimRewards {\n\t\t\twho: T::AccountId,\n\t\t\tpool: PoolId,\n\t\t\treward_currency_id: CurrencyId,\n\t\t\tactual_amount: Balance,\n\t\t\tdeduction_amount: Balance,\n\t\t},\n\t\t/// Incentive reward amount updated.\n\t\tIncentiveRewardAmountUpdated {\n\t\t\tpool: PoolId,\n\t\t\treward_currency_id: CurrencyId,\n\t\t\treward_amount_per_period: Balance,\n\t\t},\n\t\t/// Payout deduction rate updated.\n\t\tClaimRewardDeductionRateUpdated { pool: PoolId, deduction_rate: Rate },\n\t\t/// Payout deduction currency updated.\n\t\tClaimRewardDeductionCurrencyUpdated { pool: PoolId, currency: Option<CurrencyId> },\n\t}\n\n\t/// Mapping from pool to its fixed incentive amounts of multi currencies per period.\n\t///\n\t/// IncentiveRewardAmounts: double_map Pool, RewardCurrencyId => RewardAmountPerPeriod\n\t#[pallet::storage]\n\t#[pallet::getter(fn incentive_reward_amounts)]\n\tpub type IncentiveRewardAmounts<T: Config> =\n\t\tStorageDoubleMap<_, Twox64Concat, PoolId, Twox64Concat, CurrencyId, Balance, ValueQuery>;\n\n\t/// Mapping from pool to its claim reward deduction rate.\n\t///\n\t/// ClaimRewardDeductionRates: map Pool => DeductionRate\n\t#[pallet::storage]\n\tpub type ClaimRewardDeductionRates<T: Config> = StorageMap<_, Twox64Concat, PoolId, FractionalRate, ValueQuery>;\n\n\t/// If specified, ClaimRewardDeductionRates only apply to this currency.\n\t///\n\t/// ClaimRewardDeductionCurrency: map Pool => Option<RewardCurrencyId>\n\t#[pallet::storage]\n\tpub type ClaimRewardDeductionCurrency<T: Config> = StorageMap<_, Twox64Concat, PoolId, CurrencyId, OptionQuery>;\n\n\t/// The pending rewards amount, actual available rewards amount may be deducted\n\t///\n\t/// PendingMultiRewards: double_map PoolId, AccountId => BTreeMap<CurrencyId, Balance>\n\t#[pallet::storage]\n\t#[pallet::getter(fn pending_multi_rewards)]\n\tpub type PendingMultiRewards<T: Config> = StorageDoubleMap<\n\t\t_,\n\t\tTwox64Concat,\n\t\tPoolId,\n\t\tTwox64Concat,\n\t\tT::AccountId,\n\t\tBTreeMap<CurrencyId, Balance>,\n\t\tValueQuery,\n\t>;\n\n\t#[pallet::pallet]\n\t#[pallet::without_storage_info]\n\tpub struct Pallet<T>(_);\n\n\t#[pallet::hooks]\n\timpl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {\n\t\tfn on_initialize(now: BlockNumberFor<T>) -> Weight {\n\t\t\t// accumulate reward periodically\n\t\t\tif now % T::AccumulatePeriod::get() == Zero::zero() {\n\t\t\t\tlet mut count: u32 = 0;\n\t\t\t\tlet shutdown = T::EmergencyShutdown::is_shutdown();\n\n\t\t\t\tfor (pool_id, pool_info) in orml_rewards::PoolInfos::<T>::iter() {\n\t\t\t\t\tif !pool_info.total_shares.is_zero() {\n\t\t\t\t\t\tmatch pool_id {\n\t\t\t\t\t\t\t// do not accumulate incentives for PoolId::Loans after shutdown\n\t\t\t\t\t\t\tPoolId::Loans(_) if shutdown => {\n\t\t\t\t\t\t\t\tlog::debug!(\n\t\t\t\t\t\t\t\t\ttarget: \"incentives\",\n\t\t\t\t\t\t\t\t\t\"on_initialize: skip accumulate incentives for pool {:?} after shutdown\",\n\t\t\t\t\t\t\t\t\tpool_id\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_ => {\n\t\t\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\t\t\tSelf::accumulate_incentives(pool_id);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tT::WeightInfo::on_initialize(count)\n\t\t\t} else {\n\t\t\t\tWeight::zero()\n\t\t\t}\n\t\t}\n\t}\n\n\t#[pallet::call]\n\timpl<T: Config> Pallet<T> {\n\t\t/// Stake LP token to add shares of Pool::Dex\n\t\t///\n\t\t/// The dispatch origin of this call must be `Signed` by the transactor.\n\t\t///\n\t\t/// - `lp_currency_id`: LP token type\n\t\t/// - `amount`: amount to stake\n\t\t#[pallet::call_index(0)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::deposit_dex_share())]\n\t\tpub fn deposit_dex_share(\n\t\t\torigin: OriginFor<T>,\n\t\t\tlp_currency_id: CurrencyId,\n\t\t\t#[pallet::compact] amount: Balance,\n\t\t) -> DispatchResult {\n\t\t\tlet who = ensure_signed(origin)?;\n\t\t\tSelf::do_deposit_dex_share(&who, lp_currency_id, amount)?;\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Unstake LP token to remove shares of Pool::Dex\n\t\t///\n\t\t/// The dispatch origin of this call must be `Signed` by the transactor.\n\t\t///\n\t\t/// - `lp_currency_id`: LP token type\n\t\t/// - `amount`: amount to unstake\n\t\t#[pallet::call_index(1)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::withdraw_dex_share())]\n\t\tpub fn withdraw_dex_share(\n\t\t\torigin: OriginFor<T>,\n\t\t\tlp_currency_id: CurrencyId,\n\t\t\t#[pallet::compact] amount: Balance,\n\t\t) -> DispatchResult {\n\t\t\tlet who = ensure_signed(origin)?;\n\t\t\tSelf::do_withdraw_dex_share(&who, lp_currency_id, amount)?;\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Claim all avalible multi currencies rewards for specific PoolId.\n\t\t///\n\t\t/// The dispatch origin of this call must be `Signed` by the transactor.\n\t\t///\n\t\t/// - `pool_id`: pool type\n\t\t#[pallet::call_index(2)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::claim_rewards())]\n\t\tpub fn claim_rewards(origin: OriginFor<T>, pool_id: PoolId) -> DispatchResult {\n\t\t\tlet who = ensure_signed(origin)?;\n\n\t\t\tSelf::do_claim_rewards(who, pool_id)\n\t\t}\n\n\t\t/// Update incentive reward amount for specific PoolId\n\t\t///\n\t\t/// The dispatch origin of this call must be `UpdateOrigin`.\n\t\t///\n\t\t/// - `updates`: Vec<(PoolId, Vec<(RewardCurrencyId, FixedAmountPerPeriod)>)>\n\t\t#[pallet::call_index(3)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::update_incentive_rewards(\n\t\t\tupdates.iter().fold(0, |count, x| count + x.1.len()) as u32\n\t\t))]\n\t\tpub fn update_incentive_rewards(\n\t\t\torigin: OriginFor<T>,\n\t\t\tupdates: Vec<(PoolId, Vec<(CurrencyId, Balance)>)>,\n\t\t) -> DispatchResult {\n\t\t\tT::UpdateOrigin::ensure_origin(origin)?;\n\t\t\tfor (pool_id, update_list) in updates {\n\t\t\t\tif let PoolId::Dex(currency_id) = pool_id {\n\t\t\t\t\tensure!(currency_id.is_dex_share_currency_id(), Error::<T>::InvalidPoolId);\n\t\t\t\t}\n\n\t\t\t\tfor (currency_id, amount) in update_list {\n\t\t\t\t\tIncentiveRewardAmounts::<T>::mutate_exists(pool_id, currency_id, |maybe_amount| {\n\t\t\t\t\t\tlet mut v = maybe_amount.unwrap_or_default();\n\t\t\t\t\t\tif amount != v {\n\t\t\t\t\t\t\tv = amount;\n\t\t\t\t\t\t\tSelf::deposit_event(Event::IncentiveRewardAmountUpdated {\n\t\t\t\t\t\t\t\tpool: pool_id,\n\t\t\t\t\t\t\t\treward_currency_id: currency_id,\n\t\t\t\t\t\t\t\treward_amount_per_period: amount,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif v.is_zero() {\n\t\t\t\t\t\t\t*maybe_amount = None;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t*maybe_amount = Some(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Update claim rewards deduction rates for all rewards currencies of specific PoolId\n\t\t///\n\t\t/// The dispatch origin of this call must be `UpdateOrigin`.\n\t\t///\n\t\t/// - `updates`: Vec<(PoolId, DecutionRate>)>\n\t\t#[pallet::call_index(4)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::update_claim_reward_deduction_rates(updates.len() as u32))]\n\t\tpub fn update_claim_reward_deduction_rates(\n\t\t\torigin: OriginFor<T>,\n\t\t\tupdates: Vec<(PoolId, Rate)>,\n\t\t) -> DispatchResult {\n\t\t\tT::UpdateOrigin::ensure_origin(origin)?;\n\t\t\tfor (pool_id, deduction_rate) in updates {\n\t\t\t\tif let PoolId::Dex(currency_id) = pool_id {\n\t\t\t\t\tensure!(currency_id.is_dex_share_currency_id(), Error::<T>::InvalidPoolId);\n\t\t\t\t}\n\t\t\t\tClaimRewardDeductionRates::<T>::mutate_exists(pool_id, |maybe_rate| -> DispatchResult {\n\t\t\t\t\tlet mut v = maybe_rate.unwrap_or_default();\n\t\t\t\t\tif deduction_rate != *v.inner() {\n\t\t\t\t\t\tv.try_set(deduction_rate).map_err(|_| Error::<T>::InvalidRate)?;\n\t\t\t\t\t\tSelf::deposit_event(Event::ClaimRewardDeductionRateUpdated {\n\t\t\t\t\t\t\tpool: pool_id,\n\t\t\t\t\t\t\tdeduction_rate,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tif v.inner().is_zero() {\n\t\t\t\t\t\t*maybe_rate = None;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t*maybe_rate = Some(v);\n\t\t\t\t\t}\n\t\t\t\t\tOk(())\n\t\t\t\t})?;\n\t\t\t}\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Update claim rewards deduction rates currency\n\t\t///\n\t\t/// The dispatch origin of this call must be `UpdateOrigin`.\n\t\t#[pallet::call_index(5)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::update_claim_reward_deduction_currency())]\n\t\tpub fn update_claim_reward_deduction_currency(\n\t\t\torigin: OriginFor<T>,\n\t\t\tpool_id: PoolId,\n\t\t\tcurrency_id: Option<CurrencyId>,\n\t\t) -> DispatchResult {\n\t\t\tT::UpdateOrigin::ensure_origin(origin)?;\n\t\t\tClaimRewardDeductionCurrency::<T>::mutate_exists(pool_id, |c| *c = currency_id);\n\t\t\tSelf::deposit_event(Event::ClaimRewardDeductionCurrencyUpdated {\n\t\t\t\tpool: pool_id,\n\t\t\t\tcurrency: currency_id,\n\t\t\t});\n\t\t\tOk(())\n\t\t}\n\t}\n}\n\nimpl<T: Config> Pallet<T> {\n\tpub fn account_id() -> T::AccountId {\n\t\tT::PalletId::get().into_account_truncating()\n\t}\n\n\tpub(crate) fn claim_reward_deduction_rates(pool_id: &PoolId) -> Rate {\n\t\tClaimRewardDeductionRates::<T>::get(pool_id).into_inner()\n\t}\n\n\t// accumulate incentive rewards of multi currencies\n\tfn accumulate_incentives(pool_id: PoolId) {\n\t\tfor (reward_currency_id, reward_amount) in IncentiveRewardAmounts::<T>::iter_prefix(pool_id) {\n\t\t\tif reward_amount.is_zero() {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// ignore result so that failure will not block accumulate other type reward for the pool\n\t\t\tlet _ =\n\t\t\t\tSelf::transfer_rewards_and_update_records(pool_id, reward_currency_id, reward_amount).map_err(|e| {\n\t\t\t\t\tlog::warn!(\n\t\t\t\t\t\ttarget: \"incentives\",\n\t\t\t\t\t\t\"accumulate_incentives: failed to accumulate {:?} {:?} rewards for pool {:?} : {:?}\",\n\t\t\t\t\t\treward_amount, reward_currency_id, pool_id, e\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t}\n\t}\n\n\t/// Ensure atomic\n\t#[transactional]\n\tfn transfer_rewards_and_update_records(\n\t\tpool_id: PoolId,\n\t\treward_currency_id: CurrencyId,\n\t\treward_amount: Balance,\n\t) -> DispatchResult {\n\t\tT::Currency::transfer(\n\t\t\treward_currency_id,\n\t\t\t&T::RewardsSource::get(),\n\t\t\t&Self::account_id(),\n\t\t\treward_amount,\n\t\t)?;\n\t\t<orml_rewards::Pallet<T>>::accumulate_reward(&pool_id, reward_currency_id, reward_amount)?;\n\t\tOk(())\n\t}\n\n\tfn do_claim_rewards(who: T::AccountId, pool_id: PoolId) -> DispatchResult {\n\t\t// orml_rewards will claim rewards for all currencies rewards\n\t\t<orml_rewards::Pallet<T>>::claim_rewards(&who, &pool_id);\n\n\t\tPendingMultiRewards::<T>::mutate_exists(pool_id, &who, |maybe_pending_multi_rewards| {\n\t\t\tif let Some(pending_multi_rewards) = maybe_pending_multi_rewards {\n\t\t\t\tlet deduction_rate = Self::claim_reward_deduction_rates(&pool_id);\n\t\t\t\tlet deduction_currency = ClaimRewardDeductionCurrency::<T>::get(pool_id);\n\n\t\t\t\tfor (currency_id, pending_reward) in pending_multi_rewards.iter_mut() {\n\t\t\t\t\tif pending_reward.is_zero() {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet deduction_rate = if let Some(deduction_currency) = deduction_currency {\n\t\t\t\t\t\t// only apply deduction rate to specified currency\n\t\t\t\t\t\tif deduction_currency == *currency_id {\n\t\t\t\t\t\t\tdeduction_rate\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tZero::zero()\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// apply deduction rate to all currencies\n\t\t\t\t\t\tdeduction_rate\n\t\t\t\t\t};\n\n\t\t\t\t\tlet (payout_amount, deduction_amount) = {\n\t\t\t\t\t\tlet should_deduction_amount = deduction_rate.saturating_mul_int(*pending_reward);\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tpending_reward.saturating_sub(should_deduction_amount),\n\t\t\t\t\t\t\tshould_deduction_amount,\n\t\t\t\t\t\t)\n\t\t\t\t\t};\n\n\t\t\t\t\t// payout reward to claimer and re-accumuated reward.\n\t\t\t\t\tmatch Self::payout_reward_and_reaccumulate_reward(\n\t\t\t\t\t\tpool_id,\n\t\t\t\t\t\t&who,\n\t\t\t\t\t\t*currency_id,\n\t\t\t\t\t\tpayout_amount,\n\t\t\t\t\t\tdeduction_amount,\n\t\t\t\t\t) {\n\t\t\t\t\t\tOk(_) => {\n\t\t\t\t\t\t\t// update state\n\t\t\t\t\t\t\t*pending_reward = Zero::zero();\n\n\t\t\t\t\t\t\tSelf::deposit_event(Event::ClaimRewards {\n\t\t\t\t\t\t\t\twho: who.clone(),\n\t\t\t\t\t\t\t\tpool: pool_id,\n\t\t\t\t\t\t\t\treward_currency_id: *currency_id,\n\t\t\t\t\t\t\t\tactual_amount: payout_amount,\n\t\t\t\t\t\t\t\tdeduction_amount,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tErr(e) => {\n\t\t\t\t\t\t\tlog::error!(\n\t\t\t\t\t\t\t\ttarget: \"incentives\",\n\t\t\t\t\t\t\t\t\"payout_reward_and_reaccumulate_reward: failed to payout {:?} to {:?} and re-accumulate {:?} {:?} to pool {:?}: {:?}\",\n\t\t\t\t\t\t\t\tpayout_amount, who, deduction_amount, currency_id, pool_id, e\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// clear zero value item of BTreeMap\n\t\t\t\tpending_multi_rewards.retain(|_, v| *v != 0);\n\n\t\t\t\t// if pending_multi_rewards is default, clear the storage\n\t\t\t\tif pending_multi_rewards.is_empty() {\n\t\t\t\t\t*maybe_pending_multi_rewards = None;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tOk(())\n\t}\n\n\t/// Ensure atomic\n\t#[transactional]\n\tfn payout_reward_and_reaccumulate_reward(\n\t\tpool_id: PoolId,\n\t\twho: &T::AccountId,\n\t\treward_currency_id: CurrencyId,\n\t\tpayout_amount: Balance,\n\t\treaccumulate_amount: Balance,\n\t) -> DispatchResult {\n\t\tif !reaccumulate_amount.is_zero() {\n\t\t\t<orml_rewards::Pallet<T>>::accumulate_reward(&pool_id, reward_currency_id, reaccumulate_amount)?;\n\t\t}\n\t\tT::Currency::transfer(reward_currency_id, &Self::account_id(), who, payout_amount)?;\n\t\tOk(())\n\t}\n}\n\nimpl<T: Config> DEXIncentives<T::AccountId, CurrencyId, Balance> for Pallet<T> {\n\tfn do_deposit_dex_share(who: &T::AccountId, lp_currency_id: CurrencyId, amount: Balance) -> DispatchResult {\n\t\tensure!(lp_currency_id.is_dex_share_currency_id(), Error::<T>::InvalidCurrencyId);\n\n\t\tT::Currency::transfer(lp_currency_id, who, &Self::account_id(), amount)?;\n\t\t<orml_rewards::Pallet<T>>::add_share(who, &PoolId::Dex(lp_currency_id), amount.unique_saturated_into());\n\n\t\tSelf::deposit_event(Event::DepositDexShare {\n\t\t\twho: who.clone(),\n\t\t\tdex_share_type: lp_currency_id,\n\t\t\tdeposit: amount,\n\t\t});\n\t\tOk(())\n\t}\n\n\tfn do_withdraw_dex_share(who: &T::AccountId, lp_currency_id: CurrencyId, amount: Balance) -> DispatchResult {\n\t\tensure!(lp_currency_id.is_dex_share_currency_id(), Error::<T>::InvalidCurrencyId);\n\t\tensure!(\n\t\t\t<orml_rewards::Pallet<T>>::shares_and_withdrawn_rewards(&PoolId::Dex(lp_currency_id), &who).0 >= amount,\n\t\t\tError::<T>::NotEnough,\n\t\t);\n\n\t\tT::Currency::transfer(lp_currency_id, &Self::account_id(), who, amount)?;\n\t\t<orml_rewards::Pallet<T>>::remove_share(who, &PoolId::Dex(lp_currency_id), amount.unique_saturated_into());\n\n\t\tSelf::deposit_event(Event::WithdrawDexShare {\n\t\t\twho: who.clone(),\n\t\t\tdex_share_type: lp_currency_id,\n\t\t\twithdraw: amount,\n\t\t});\n\t\tOk(())\n\t}\n}\n\nimpl<T: Config> IncentivesManager<T::AccountId, Balance, CurrencyId, PoolId> for Pallet<T> {\n\tfn get_incentive_reward_amount(pool_id: PoolId, currency_id: CurrencyId) -> Balance {\n\t\tIncentiveRewardAmounts::<T>::get(pool_id, currency_id)\n\t}\n\n\tfn deposit_dex_share(who: &T::AccountId, lp_currency_id: CurrencyId, amount: Balance) -> DispatchResult {\n\t\tSelf::do_deposit_dex_share(who, lp_currency_id, amount)\n\t}\n\n\tfn withdraw_dex_share(who: &T::AccountId, lp_currency_id: CurrencyId, amount: Balance) -> DispatchResult {\n\t\tSelf::do_withdraw_dex_share(who, lp_currency_id, amount)\n\t}\n\n\tfn claim_rewards(who: T::AccountId, pool_id: PoolId) -> DispatchResult {\n\t\tSelf::do_claim_rewards(who, pool_id)\n\t}\n\n\tfn get_claim_reward_deduction_rate(pool_id: PoolId) -> Rate {\n\t\tSelf::claim_reward_deduction_rates(&pool_id)\n\t}\n\n\tfn get_pending_rewards(pool_id: PoolId, who: T::AccountId, reward_currencies: Vec<CurrencyId>) -> Vec<Balance> {\n\t\tlet rewards_map = PendingMultiRewards::<T>::get(pool_id, who);\n\t\tlet mut reward_balances = Vec::new();\n\t\tfor reward_currency in reward_currencies {\n\t\t\tlet reward_amount = rewards_map.get(&reward_currency).copied().unwrap_or_default();\n\t\t\treward_balances.push(reward_amount);\n\t\t}\n\t\treward_balances\n\t}\n}\n\npub struct OnUpdateLoan<T>(sp_std::marker::PhantomData<T>);\nimpl<T: Config> Happened<(T::AccountId, CurrencyId, Amount, Balance)> for OnUpdateLoan<T> {\n\tfn happened(info: &(T::AccountId, CurrencyId, Amount, Balance)) {\n\t\tlet (who, currency_id, adjustment, _previous_amount) = info;\n\t\tlet adjustment_abs = TryInto::<Balance>::try_into(adjustment.saturating_abs()).unwrap_or_default();\n\n\t\tif adjustment.is_positive() {\n\t\t\t<orml_rewards::Pallet<T>>::add_share(who, &PoolId::Loans(*currency_id), adjustment_abs);\n\t\t} else {\n\t\t\t<orml_rewards::Pallet<T>>::remove_share(who, &PoolId::Loans(*currency_id), adjustment_abs);\n\t\t};\n\t}\n}\n\nimpl<T: Config> RewardHandler<T::AccountId, CurrencyId> for Pallet<T> {\n\ttype Balance = Balance;\n\ttype PoolId = PoolId;\n\n\tfn payout(who: &T::AccountId, pool_id: &Self::PoolId, currency_id: CurrencyId, payout_amount: Self::Balance) {\n\t\tif payout_amount.is_zero() {\n\t\t\treturn;\n\t\t}\n\t\tPendingMultiRewards::<T>::mutate(pool_id, who, |rewards| {\n\t\t\trewards\n\t\t\t\t.entry(currency_id)\n\t\t\t\t.and_modify(|current| *current = current.saturating_add(payout_amount))\n\t\t\t\t.or_insert(payout_amount);\n\t\t});\n\t}\n}\n\npub struct OnEarningBonded<T>(sp_std::marker::PhantomData<T>);\nimpl<T: Config> Happened<(T::AccountId, Balance)> for OnEarningBonded<T> {\n\tfn happened((who, amount): &(T::AccountId, Balance)) {\n\t\t<orml_rewards::Pallet<T>>::add_share(who, &PoolId::Earning(T::NativeCurrencyId::get()), *amount);\n\t}\n}\n\npub struct OnEarningUnbonded<T>(sp_std::marker::PhantomData<T>);\nimpl<T: Config> Happened<(T::AccountId, Balance)> for OnEarningUnbonded<T> {\n\tfn happened((who, amount): &(T::AccountId, Balance)) {\n\t\t<orml_rewards::Pallet<T>>::remove_share(who, &PoolId::Earning(T::NativeCurrencyId::get()), *amount);\n\t}\n}"
    }
  ]
}