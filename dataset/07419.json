{
  "Title": "[M-06] Inflation rate can be reduced by half at most if it gets called every 1.99 interval",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/RewardsPool.sol#L98\n\n\n# Vulnerability details\n\n## Impact\nWhen doing inflation, function `getInflationAmt()` calculated number of intervals elapsed by dividing the duration with interval length. \n```solidity\nfunction getInflationIntervalsElapsed() public view returns (uint256) {\n    ProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n    uint256 startTime = getInflationIntervalStartTime();\n    if (startTime == 0) {\n        revert ContractHasNotBeenInitialized();\n    }\n    return (block.timestamp - startTime) / dao.getInflationIntervalSeconds();\n}\n```\n\nAs we can noticed that, this calculation is rounding down, it means if `block.timestamp - startTime = 1.99 intervals`, it only account for `1 interval`.\n\nHowever, when updating start time after inflating, it still update to current timestamp while it should only increased by `intervalLength * intervalsElapsed` instead.\n```solidity\naddUint(keccak256(\"RewardsPool.InflationIntervalStartTime\"), inflationIntervalElapsedSeconds); \n// @audit should only update to oldStartTime + inverval * numInterval\nsetUint(keccak256(\"RewardsPool.RewardsCycleTotalAmt\"), newTokens);\n```\n\nSince default value of inflation interval = 1 days and reward cycle length = 14 days, so the impact is reduced. However, these configs can be changed in the future.\n\n## Proof of Concept\nConsider the scenario: \n1. Assume last inflation time is `InflationIntervalStartTime = 100`. `InflationIntervalSeconds = 50`.\n2. At `timestamp = 199`, function `getInflationAmt()` will calculate\n```solidity\ninflationIntervalsElapsed = (199 - 100) / 50 = 1\n// Compute inflation for total inflation intervals elapsed\nfor (uint256 i = 0; i < inflationIntervalsElapsed; i++) {\n    newTotalSupply = newTotalSupply.mulWadDown(inflationRate);\n} // @audit only loop once.\n```\n3. And then in `inflate()` function, `InflationIntervalStartTime` is still updated to current timestamp, so `InflationIntervalStartTime = 199`.\n4. If this sequence of actions are repeatedly used, we can easily see\n```solidity\nInflationIntervalStartTime = 199, inflated count = 1\nInflationIntervalStartTime = 298, inflated count = 2\nInflationIntervalStartTime = 397, inflated count = 3\nInflationIntervalStartTime = 496, inflated count = 4\nInflationIntervalStartTime = 595, inflated count = 5\n```\n\nWhile at `timestamp = 595`, inflated times should be \n`(595 - 100) / 50 = 9` instead.\n\n\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nConsider only increasing `InflationIntervalStartTime` by the amount of intervals time interval length.\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-12-gogopool-contest",
  "Code": [
    {
      "filename": "contracts/contract/RewardsPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport \"./Base.sol\";\nimport {ClaimNodeOp} from \"./ClaimNodeOp.sol\";\nimport {MultisigManager} from \"./MultisigManager.sol\";\nimport {ProtocolDAO} from \"./ProtocolDAO.sol\";\nimport {Storage} from \"./Storage.sol\";\nimport {TokenGGP} from \"./tokens/TokenGGP.sol\";\nimport {Vault} from \"./Vault.sol\";\n\nimport {FixedPointMathLib} from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\n\n/// @title Vault for GGP Rewards\ncontract RewardsPool is Base {\n\tusing FixedPointMathLib for uint256;\n\n\t/// @notice Distribution cannot exceed total rewards\n\terror IncorrectRewardsDistribution();\n\terror UnableToStartRewardsCycle();\n\terror ContractHasNotBeenInitialized();\n\terror MaximumTokensReached();\n\n\tevent GGPInflated(uint256 newTokens);\n\tevent NewRewardsCycleStarted(uint256 totalRewardsAmt);\n\tevent ClaimNodeOpRewardsTransfered(uint256 value);\n\tevent ProtocolDAORewardsTransfered(uint256 value);\n\tevent MultisigRewardsTransfered(uint256 value);\n\n\tconstructor(Storage storageAddress) Base(storageAddress) {\n\t\tversion = 1;\n\t}\n\n\tfunction initialize() external onlyGuardian {\n\t\tif (getBool(keccak256(\"RewardsPool.initialized\"))) {\n\t\t\treturn;\n\t\t}\n\t\tsetBool(keccak256(\"RewardsPool.initialized\"), true);\n\n\t\tsetUint(keccak256(\"RewardsPool.RewardsCycleStartTime\"), block.timestamp);\n\t\tsetUint(keccak256(\"RewardsPool.InflationIntervalStartTime\"), block.timestamp);\n\t}\n\n\t/* INFLATION */\n\n\t/// @notice Get the last time that inflation was calculated at\n\t/// @return timestamp when inflation was last calculated\n\tfunction getInflationIntervalStartTime() public view returns (uint256) {\n\t\treturn getUint(keccak256(\"RewardsPool.InflationIntervalStartTime\"));\n\t}\n\n\t/// @notice Inflation intervals that have elapsed since inflation was last calculated\n\t/// @return Number of intervals since last inflation cycle (0, 1, 2, etc)\n\tfunction getInflationIntervalsElapsed() public view returns (uint256) {\n\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tuint256 startTime = getInflationIntervalStartTime();\n\t\tif (startTime == 0) {\n\t\t\trevert ContractHasNotBeenInitialized();\n\t\t}\n\t\treturn (block.timestamp - startTime) / dao.getInflationIntervalSeconds();\n\t}\n\n\t/// @notice Function to compute how many tokens should be minted\n\t/// @return currentTotalSupply current total supply\n\t/// @return newTotalSupply supply after mint\n\tfunction getInflationAmt() public view returns (uint256 currentTotalSupply, uint256 newTotalSupply) {\n\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tuint256 inflationRate = dao.getInflationIntervalRate();\n\t\tuint256 inflationIntervalsElapsed = getInflationIntervalsElapsed();\n\t\tcurrentTotalSupply = dao.getTotalGGPCirculatingSupply();\n\t\tnewTotalSupply = currentTotalSupply;\n\n\t\t// Compute inflation for total inflation intervals elapsed\n\t\tfor (uint256 i = 0; i < inflationIntervalsElapsed; i++) {\n\t\t\tnewTotalSupply = newTotalSupply.mulWadDown(inflationRate);\n\t\t}\n\t\treturn (currentTotalSupply, newTotalSupply);\n\t}\n\n\t/// @notice Releases more GGP if appropriate\n\t/// @dev Mint new tokens if enough time has elapsed since last mint\n\tfunction inflate() internal {\n\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tuint256 inflationIntervalElapsedSeconds = (block.timestamp - getInflationIntervalStartTime());\n\t\t(uint256 currentTotalSupply, uint256 newTotalSupply) = getInflationAmt();\n\n\t\tTokenGGP ggp = TokenGGP(getContractAddress(\"TokenGGP\"));\n\t\tif (newTotalSupply > ggp.totalSupply()) {\n\t\t\trevert MaximumTokensReached();\n\t\t}\n\n\t\tuint256 newTokens = newTotalSupply - currentTotalSupply;\n\n\t\temit GGPInflated(newTokens);\n\n\t\tdao.setTotalGGPCirculatingSupply(newTotalSupply);\n\n\t\taddUint(keccak256(\"RewardsPool.InflationIntervalStartTime\"), inflationIntervalElapsedSeconds);\n\t\tsetUint(keccak256(\"RewardsPool.RewardsCycleTotalAmt\"), newTokens);\n\t}\n\n\t/* REWARDS */\n\n\t/// @notice The current cycle number for GGP rewards\n\tfunction getRewardsCycleCount() public view returns (uint256) {\n\t\treturn getUint(keccak256(\"RewardsPool.RewardsCycleCount\"));\n\t}\n\n\t/// @notice Increase the cycle number for GGP rewards\n\tfunction increaseRewardsCycleCount() internal {\n\t\taddUint(keccak256(\"RewardsPool.RewardsCycleCount\"), 1);\n\t}\n\n\t/// @notice The current rewards cycle start time\n\tfunction getRewardsCycleStartTime() public view returns (uint256) {\n\t\treturn getUint(keccak256(\"RewardsPool.RewardsCycleStartTime\"));\n\t}\n\n\t/// @notice The current rewards cycle total amount of GGP\n\tfunction getRewardsCycleTotalAmt() public view returns (uint256) {\n\t\treturn getUint(keccak256(\"RewardsPool.RewardsCycleTotalAmt\"));\n\t}\n\n\t/// @notice The number of reward cycles that have elapsed\n\tfunction getRewardsCyclesElapsed() public view returns (uint256) {\n\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tuint256 startTime = getRewardsCycleStartTime();\n\t\treturn (block.timestamp - startTime) / dao.getRewardsCycleSeconds();\n\t}\n\n\t/// @notice Get the approx amount of GGP rewards owed for this cycle per claiming contract\n\t/// @param claimingContract Name of the contract being claimed for\n\t/// @return GGP Rewards amount for current cycle per claiming contract\n\tfunction getClaimingContractDistribution(string memory claimingContract) public view returns (uint256) {\n\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tuint256 claimContractPct = dao.getClaimingContractPct(claimingContract);\n\t\t// How much rewards are available for this claim interval?\n\t\tuint256 currentCycleRewardsTotal = getRewardsCycleTotalAmt();\n\n\t\t// How much this claiming contract is entitled to in perc\n\t\tuint256 contractRewardsTotal = 0;\n\t\tif (claimContractPct > 0 && currentCycleRewardsTotal > 0) {\n\t\t\t// Calculate how much rewards this claimer will receive based on their claiming perc\n\t\t\tcontractRewardsTotal = claimContractPct.mulWadDown(currentCycleRewardsTotal);\n\t\t}\n\t\treturn contractRewardsTotal;\n\t}\n\n\t/// @notice Checking if enough time has passed since the last rewards cycle\n\t/// @dev Rialto calls this to see if at least one cycle has passed\n\tfunction canStartRewardsCycle() public view returns (bool) {\n\t\treturn getRewardsCyclesElapsed() > 0 && getInflationIntervalsElapsed() > 0;\n\t}\n\n\t/// @notice Public function that will run a GGP rewards cycle if possible\n\tfunction startRewardsCycle() external {\n\t\tif (!canStartRewardsCycle()) {\n\t\t\trevert UnableToStartRewardsCycle();\n\t\t}\n\n\t\temit NewRewardsCycleStarted(getRewardsCycleTotalAmt());\n\n\t\t// Set start of new rewards cycle\n\t\tsetUint(keccak256(\"RewardsPool.RewardsCycleStartTime\"), block.timestamp);\n\t\tincreaseRewardsCycleCount();\n\t\t// Mint any new tokens from GGP inflation\n\t\t// This will always 'mint' (release) new tokens if the rewards cycle length requirement is met\n\t\t// \t\tsince inflation is on a 1 day interval and it needs at least one cycle since last calculation\n\t\tinflate();\n\n\t\tuint256 multisigClaimContractAllotment = getClaimingContractDistribution(\"ClaimMultisig\");\n\t\tuint256 nopClaimContractAllotment = getClaimingContractDistribution(\"ClaimNodeOp\");\n\t\tuint256 daoClaimContractAllotment = getClaimingContractDistribution(\"ClaimProtocolDAO\");\n\t\tif (daoClaimContractAllotment + nopClaimContractAllotment + multisigClaimContractAllotment > getRewardsCycleTotalAmt()) {\n\t\t\trevert IncorrectRewardsDistribution();\n\t\t}\n\n\t\tTokenGGP ggp = TokenGGP(getContractAddress(\"TokenGGP\"));\n\t\tVault vault = Vault(getContractAddress(\"Vault\"));\n\n\t\tif (daoClaimContractAllotment > 0) {\n\t\t\temit ProtocolDAORewardsTransfered(daoClaimContractAllotment);\n\t\t\tvault.transferToken(\"ClaimProtocolDAO\", ggp, daoClaimContractAllotment);\n\t\t}\n\n\t\tif (multisigClaimContractAllotment > 0) {\n\t\t\temit MultisigRewardsTransfered(multisigClaimContractAllotment);\n\t\t\tdistributeMultisigAllotment(multisigClaimContractAllotment, vault, ggp);\n\t\t}\n\n\t\tif (nopClaimContractAllotment > 0) {\n\t\t\temit ClaimNodeOpRewardsTransfered(nopClaimContractAllotment);\n\t\t\tClaimNodeOp nopClaim = ClaimNodeOp(getContractAddress(\"ClaimNodeOp\"));\n\t\t\tnopClaim.setRewardsCycleTotal(nopClaimContractAllotment);\n\t\t\tvault.transferToken(\"ClaimNodeOp\", ggp, nopClaimContractAllotment);\n\t\t}\n\t}\n\n\t/// @notice Distributes GGP to enabled Multisigs\n\t/// @param allotment Total GGP for Multisigs\n\t/// @param vault Vault contract\n\t/// @param ggp TokenGGP contract\n\tfunction distributeMultisigAllotment(\n\t\tuint256 allotment,\n\t\tVault vault,\n\t\tTokenGGP ggp\n\t) internal {\n\t\tMultisigManager mm = MultisigManager(getContractAddress(\"MultisigManager\"));\n\n\t\tuint256 enabledCount;\n\t\tuint256 count = mm.getCount();\n\t\taddress[] memory enabledMultisigs = new address[](count);\n\n\t\t// there should never be more than a few multisigs, so a loop should be fine here\n\t\tfor (uint256 i = 0; i < count; i++) {\n\t\t\t(address addr, bool enabled) = mm.getMultisig(i);\n\t\t\tif (enabled) {\n\t\t\t\tenabledMultisigs[enabledCount] = addr;\n\t\t\t\tenabledCount++;\n\t\t\t}\n\t\t}\n\n\t\t// Dirty hack to cut unused elements off end of return value (from RP)\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly {\n\t\t\tmstore(enabledMultisigs, enabledCount)\n\t\t}\n\n\t\tuint256 tokensPerMultisig = allotment / enabledCount;\n\t\tfor (uint256 i = 0; i < enabledMultisigs.length; i++) {\n\t\t\tvault.withdrawToken(enabledMultisigs[i], ggp, tokensPerMultisig);\n\t\t}\n\t}\n}"
    }
  ]
}