{
  "Title": "Gas inefficiencies",
  "Content": "There are many places throughout the codebase where changes can be made to improve gas consumption. For example:\n\n\n#### Arbitrary use of different `uint` types can lead to unwanted effects\n\n\nNumerous unsigned integer (`uint`) values of various sizes are used. Those less than 256-bits (`uint256`) are used extensively. Non-`uint256` sizes are generally chosen to facilitate tight packing inside of `struct`s to save on storage costs. However, projects must carefully weigh the realized gas savings against the additional complexity such a design decision introduces.\n\n\nSince the Ethereum Virtual Machine operates on 256-bit integers, additional operations must be performed to process non-`uint256` values. These additional operations increase the bytecode size of contracts and consume additional gas during execution.\n\n\nIn the Comp contract, for example, it was necessary to include some [specific functions](https://etherscan.io/address/0xc00e94cb662c3520282e6f5717214004a7f26888#code#L279) to manage these units safely but causing extra gas costs for the additional operations. Other than that, the variables are [not properly packed](https://etherscan.io/address/0xc00e94cb662c3520282e6f5717214004a7f26888#code#L31) in the slots of the contract, so the choice of picking these units is not justified.\n\n\n#### The code in some loops is executed unnecessarily\n\n\nIn `GovernorBravoDelegate`, the function [`cancel`](https://etherscan.io/address/0x563a63d650a5d259abae9248dddc6867813d3f87#code#F1#L156) should verify `ProposalState` before calling `cancelTransaction` on the `Timelock` contract to avoid unnecessary gas spending. If the proposal has not been added to the queue, it is not necessary to enter the loop to cancel the transactions, since they have not even been added to the `Timelock` yet.\n\n\n#### Some variables are being unnecessarily initialized to their default value\n\n\nInitializing a variable to its default value wastes gas uselessly. In the codebase, there are variables explicitly set to 0. this happens several times: – In [`getPriorVotes`](https://etherscan.io/address/0xc00e94cb662c3520282e6f5717214004a7f26888#code#L193) function the local variable `lower`. – In [`transferTokens`](https://github.com/equilibria-xyz/compound-protocol/blob/01948c6a2075b35e6953984c41356ad2fc884d98/contracts/CToken.sol#L81) function the local variable `startingAllowance`. – In `TokenErrorReporter` contract the variable [`NO_ERROR`](https://github.com/equilibria-xyz/compound-protocol/blob/01948c6a2075b35e6953984c41356ad2fc884d98/contracts/ErrorReporter.sol#L75).\n\n\n#### The loops of some functions are not properly optimized\n\n\nIn many loops in the codebase, the size of the array to iterate through is always read on each iteration. Here some examples: – [`getHypotheticalAccountLiquidityInternal`](https://etherscan.io/address/0xbafe01ff935c7305907c33bf824352ee5979b526#code#F4#L722), [`_addMarketInternal`](https://etherscan.io/address/0xbafe01ff935c7305907c33bf824352ee5979b526#code#F4#L953), [`fixBadAccruals`](https://etherscan.io/address/0xbafe01ff935c7305907c33bf824352ee5979b526#code#F4#L1089) and [`claimComp`](https://etherscan.io/address/0xbafe01ff935c7305907c33bf824352ee5979b526#code#F4#L1341), in `Comptroller`. – [`queue`](https://etherscan.io/address/0x563a63d650a5d259abae9248dddc6867813d3f87#code#F1#L122), [`execute`](https://etherscan.io/address/0x563a63d650a5d259abae9248dddc6867813d3f87#code#F1#L142) and [`cancel`](https://etherscan.io/address/0x563a63d650a5d259abae9248dddc6867813d3f87#code#F1#L156) in `GovernorBravoDelegate`.\n\n\n1. if it is a `storage` array, this is an extra `sload` operation(100 additional extra gas ([EIP-2929](https://eips.ethereum.org/EIPS/eip-2929)) for each iteration except for the first),\n2. if it is a `memory` array, this is an extra `mload` operation (3 additional gas for each iteration except for the first),\n3. if it is a `calldata` array, this is an extra `calldataload` operation (3 additional gas for each iteration except for the first)\n\n\nThese extra costs are avoidable by creating a variable with the array length (caching the array length in stack).\n\n\n#### Arguments with read-only parameters are using `memory` instead of `calldata`\n\n\nSome protocol contract functions have parameters in which they use the keyboard memory. This may not be very efficient as it performs unnecessary steps if the argument is read-only. Here some examples:\n\n\n* [`safe32`](https://etherscan.io/address/0xc00e94cb662c3520282e6f5717214004a7f26888#code#L279), [`safe96`](https://etherscan.io/address/0xc00e94cb662c3520282e6f5717214004a7f26888#code#L284), [`add96`](https://etherscan.io/address/0xc00e94cb662c3520282e6f5717214004a7f26888#code#L289) and [`sub96`](https://etherscan.io/address/0xc00e94cb662c3520282e6f5717214004a7f26888#code#L295) in `Comp.sol`\n* [`enterMarkets`](https://etherscan.io/address/0xbafe01ff935c7305907c33bf824352ee5979b526#code#F4#L120), [`updateCompBorrowIndex`](https://etherscan.io/address/0xbafe01ff935c7305907c33bf824352ee5979b526#code#F4#L1205), [`distributeBorrowerComp`](https://etherscan.io/address/0xbafe01ff935c7305907c33bf824352ee5979b526#code#F4#L1265), [`claimComp`](https://etherscan.io/address/0xbafe01ff935c7305907c33bf824352ee5979b526#code#F4#L1328), [`_setCompSpeeds`](https://etherscan.io/address/0xbafe01ff935c7305907c33bf824352ee5979b526#code#F4#L1402) in `Comptroller.sol`\n* [`propose`](https://etherscan.io/address/0x563a63d650a5d259abae9248dddc6867813d3f87#code#F1#L74) in `GovernorBravoDelegate.sol`\n\n\nConsider using `calldata` instead of `memory` if the function argument is only read.\n\n\n#### Storage slots read multiple times\n\n\nOperations that load values onto the execution stack can be expensive. On several occasions, some variables are read multiple times and cause gas cost overruns in the execution. Here are some examples:\n\n\n* [`doTransferIn`](https://github.com/equilibria-xyz/compound-protocol/blob/01948c6a2075b35e6953984c41356ad2fc884d98/contracts/CErc20.sol#L161) in the CToken contract reads three times the `underlying` state variable.\n* [`propose`](https://etherscan.io/address/0x563a63d650a5d259abae9248dddc6867813d3f87#code#F1#L74) in the GovernorBravoDelegate contract reads three times the `targets.length` memory variable.\n* [`state`](https://etherscan.io/address/0x563a63d650a5d259abae9248dddc6867813d3f87#code#F1#L205) in Governor Bravo Delegate, the local variable `proposal` is unnecessarily defined with the keyword `storage`, causing multiple reads from storage.\n* Line [254](https://etherscan.io/address/0xfcb924ae46c7ddc6ad4f873a59ad6f3b5a2e20d5#code#F3#L254) of `cToken` contract is defining a `storage` variable when `memory` can be used instead.\n\n\nTo avoid this, consider only loading the variable onto the stack once and reusing it from the stack itself.\n\n\n#### Redundant validations\n\n\nThe [`exitMarket`](https://etherscan.io/address/0xbafe01ff935c7305907c33bf824352ee5979b526#code#F4#L172) function performs a redundant check to verify if the sender is not already *‘in’* the market. The internal function [`redeemAllowedInternal`](https://etherscan.io/address/0xbafe01ff935c7305907c33bf824352ee5979b526#code#F4#L292) called by the former performs the same validation.\n\n\nConsider removing the redundant validation.\n\n\n#### Unnecessary extra steps\n\n\n[`transferTokens`](https://github.com/equilibria-xyz/compound-protocol/blob/01948c6a2075b35e6953984c41356ad2fc884d98/contracts/CToken.sol#L81) has local variables and validations that are wasting gas without adding any value and reducing readability.\n\n\nConsider removing intermediate variable definitions to act directly on storage variables and and synthesize the validations.\n\n\n#### Redundant usage of the `Exp` type\n\n\nUsage of `Exp` type can be avoided at [lines 308-310](https://etherscan.io/address/0xfcb924ae46c7ddc6ad4f873a59ad6f3b5a2e20d5#code#F3#L308) in favour of `uint exchangeRate = cashPlusBorrowsMinusReserves * expScale / _totalSupply;`.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/CToken.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.6;\n\nimport \"./ComptrollerInterface.sol\";\nimport \"./CTokenInterfaces.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./EIP20Interface.sol\";\nimport \"./InterestRateModel.sol\";\nimport \"./ExponentialNoError.sol\";\n\n/**\n * @title Compound's CToken Contract\n * @notice Abstract base for CTokens\n * @author Compound\n */\nabstract contract CToken is CTokenInterface, ExponentialNoError, TokenErrorReporter {\n    /**\n     * @notice Initialize the money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ EIP-20 name of this token\n     * @param symbol_ EIP-20 symbol of this token\n     * @param decimals_ EIP-20 decimal precision of this token\n     */\n    function initialize(ComptrollerInterface comptroller_,\n                        InterestRateModel interestRateModel_,\n                        uint initialExchangeRateMantissa_,\n                        string memory name_,\n                        string memory symbol_,\n                        uint8 decimals_) public {\n        require(msg.sender == admin, \"only admin may initialize the market\");\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n        // Set the comptroller\n        uint err = _setComptroller(comptroller_);\n        require(err == NO_ERROR, \"setting comptroller failed\");\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = mantissaOne;\n\n        // Set the interest rate model (depends on block number / borrow index)\n        err = _setInterestRateModelFresh(interestRateModel_);\n        require(err == NO_ERROR, \"setting interest rate model failed\");\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n        _notEntered = true;\n    }\n\n    /**\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n     * @dev Called by both `transfer` and `transferFrom` internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return 0 if the transfer succeeded, else revert\n     */\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n        /* Fail if transfer not allowed */\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n        if (allowed != 0) {\n            revert TransferComptrollerRejection(allowed);\n        }\n\n        /* Do not allow self-transfers */\n        if (src == dst) {\n            revert TransferNotAllowed();\n        }\n\n        /* Get the allowance, infinite for the account owner */\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = type(uint).max;\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        /* Do the calculations, checking for {under,over}flow */\n        uint allowanceNew = startingAllowance - tokens;\n        uint srcTokensNew = accountTokens[src] - tokens;\n        uint dstTokensNew = accountTokens[dst] + tokens;\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        /* Eat some of the allowance (if necessary) */\n        if (startingAllowance != type(uint).max) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n\n        /* We emit a Transfer event */\n        emit Transfer(src, dst, tokens);\n\n        // unused function\n        // comptroller.transferVerify(address(this), src, dst, tokens);\n\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 amount) override external nonReentrant returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount) == NO_ERROR;\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint256 amount) override external nonReentrant returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount) == NO_ERROR;\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) override external returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (-1 means infinite)\n     */\n    function allowance(address owner, address spender) override external view returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /**\n     * @notice Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) override external view returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) override external returns (uint) {\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\n        return mul_ScalarTruncate(exchangeRate, accountTokens[owner]);\n    }\n\n    /**\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n     */\n    function getAccountSnapshot(address account) override external view returns (uint, uint, uint, uint) {\n        return (\n            NO_ERROR,\n            accountTokens[account],\n            borrowBalanceStoredInternal(account),\n            exchangeRateStoredInternal()\n        );\n    }\n\n    /**\n     * @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     */\n    function getBlockNumber() virtual internal view returns (uint) {\n        return block.number;\n    }\n\n    /**\n     * @notice Returns the current per-block borrow interest rate for this cToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() override external view returns (uint) {\n        return interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n    }\n\n    /**\n     * @notice Returns the current per-block supply interest rate for this cToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() override external view returns (uint) {\n        return interestRateModel.getSupplyRate(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n    }\n\n    /**\n     * @notice Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     */\n    function totalBorrowsCurrent() override external nonReentrant returns (uint) {\n        require(accrueInterest() == NO_ERROR, \"accrue interest failed\");\n        return totalBorrows;\n    }\n\n    /**\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) override external nonReentrant returns (uint) {\n        require(accrueInterest() == NO_ERROR, \"accrue interest failed\");\n        return borrowBalanceStored(account);\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return The calculated balance\n     */\n    function borrowBalanceStored(address account) override public view returns (uint) {\n        return borrowBalanceStoredInternal(account);\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     */\n    function borrowBalanceStoredInternal(address account) internal view returns (uint) {\n        /* Get borrowBalance and borrowIndex */\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         */\n        if (borrowSnapshot.principal == 0) {\n            return 0;\n        }\n\n        /* Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         */\n        uint principalTimesIndex = borrowSnapshot.principal * borrowIndex;\n        return principalTimesIndex / borrowSnapshot.interestIndex;\n    }\n\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() override public nonReentrant returns (uint) {\n        require(accrueInterest() == NO_ERROR, \"accrue interest failed\");\n        return exchangeRateStored();\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() override public view returns (uint) {\n        return exchangeRateStoredInternal();\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return (error code, calculated exchange rate scaled by 1e18)\n     */\n    function exchangeRateStoredInternal() virtual internal view returns (uint) {\n        uint _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /*\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             */\n            return initialExchangeRateMantissa;\n        } else {\n            /*\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             */\n            uint totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves = totalCash + totalBorrows - totalReserves;\n            Exp memory exchangeRate = Exp({mantissa: cashPlusBorrowsMinusReserves * expScale / _totalSupply});\n\n            return exchangeRate.mantissa;\n        }\n    }\n\n    /**\n     * @notice Get cash balance of this cToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() override external view returns (uint) {\n        return getCashPrior();\n    }\n\n    /**\n     * @notice Applies accrued interest to total borrows and reserves\n     * @dev This calculates interest accrued from the last checkpointed block\n     *   up to the current block and writes new checkpoint to storage.\n     */\n    function accrueInterest() virtual override public returns (uint) {\n        /* Remember the initial block number */\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return NO_ERROR;\n        }\n\n        /* Read the previous values out of storage */\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint reservesPrior = totalReserves;\n        uint borrowIndexPrior = borrowIndex;\n\n        /* Calculate the current borrow interest rate */\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        uint blockDelta = currentBlockNumber - accrualBlockNumberPrior;\n\n        /*\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         */\n\n        Exp memory simpleInterestFactor = mul_(Exp({mantissa: borrowRateMantissa}), blockDelta);\n        uint interestAccumulated = mul_ScalarTruncate(simpleInterestFactor, borrowsPrior);\n        uint totalBorrowsNew = interestAccumulated + borrowsPrior;\n        uint totalReservesNew = mul_ScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), interestAccumulated, reservesPrior);\n        uint borrowIndexNew = mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n\n        /* We emit an AccrueInterest event */\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     */\n    function mintInternal(uint mintAmount) internal nonReentrant {\n        uint error = accrueInterest();\n        if (error != NO_ERROR) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            revert MintAccrueInterestFailed(error);\n        }\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        mintFresh(msg.sender, mintAmount);\n    }\n\n    /**\n     * @notice User supplies assets into the market and receives cTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     */\n    function mintFresh(address minter, uint mintAmount) internal {\n        /* Fail if mint not allowed */\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n        if (allowed != 0) {\n            revert MintComptrollerRejection(allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            revert MintFreshnessCheck();\n        }\n\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal()});\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         *  We call `doTransferIn` for the minter and the mintAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n         *  of cash.\n         */\n        uint actualMintAmount = doTransferIn(minter, mintAmount);\n\n        /*\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         */\n\n        uint mintTokens = div_(actualMintAmount, exchangeRate);\n\n        /*\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         * And write them into storage\n         */\n        totalSupply = totalSupply + mintTokens;\n        accountTokens[minter] = accountTokens[minter] + mintTokens;\n\n        /* We emit a Mint event, and a Transfer event */\n        emit Mint(minter, actualMintAmount, mintTokens);\n        emit Transfer(address(this), minter, mintTokens);\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.mintVerify(address(this), minter, actualMintAmount, mintTokens);\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     */\n    function redeemInternal(uint redeemTokens) internal nonReentrant {\n        uint error = accrueInterest();\n        if (error != NO_ERROR) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            revert RedeemAccrueInterestFailed(error);\n        }\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        redeemFresh(payable(msg.sender), redeemTokens, 0);\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to receive from redeeming cTokens\n     */\n    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant {\n        uint error = accrueInterest();\n        if (error != NO_ERROR) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            revert RedeemAccrueInterestFailed(error);\n        }\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        redeemFresh(payable(msg.sender), 0, redeemAmount);\n    }\n\n    /**\n     * @notice User redeems cTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     */\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal() });\n\n        uint redeemTokens;\n        uint redeemAmount;\n        /* If redeemTokensIn > 0: */\n        if (redeemTokensIn > 0) {\n            /*\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             */\n            redeemTokens = redeemTokensIn;\n            redeemAmount = mul_ScalarTruncate(exchangeRate, redeemTokensIn);\n        } else {\n            /*\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             */\n            redeemTokens = div_(redeemAmountIn, exchangeRate);\n            redeemAmount = redeemAmountIn;\n        }\n\n        /* Fail if redeem not allowed */\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, redeemTokens);\n        if (allowed != 0) {\n            revert RedeemComptrollerRejection(allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            revert RedeemFreshnessCheck();\n        }\n\n        /* Fail gracefully if protocol has insufficient cash */\n        if (getCashPrior() < redeemAmount) {\n            revert RedeemTransferOutNotPossible();\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n\n        /*\n         * We write the previously calculated values into storage.\n         *  Note: Avoid token reentrancy attacks by writing reduced supply before external transfer.\n         */\n        totalSupply = totalSupply - redeemTokens;\n        accountTokens[redeemer] = accountTokens[redeemer] - redeemTokens;\n\n        /*\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(redeemer, redeemAmount);\n\n        /* We emit a Transfer event, and a Redeem event */\n        emit Transfer(redeemer, address(this), redeemTokens);\n        emit Redeem(redeemer, redeemAmount, redeemTokens);\n\n        /* We call the defense hook */\n        comptroller.redeemVerify(address(this), redeemer, redeemAmount, redeemTokens);\n    }\n\n    /**\n      * @notice Sender borrows assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      */\n    function borrowInternal(uint borrowAmount) internal nonReentrant {\n        uint error = accrueInterest();\n        if (error != NO_ERROR) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            revert BorrowAccrueInterestFailed(error);\n        }\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n        borrowFresh(payable(msg.sender), borrowAmount);\n    }\n\n    /**\n      * @notice Users borrow assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      */\n    function borrowFresh(address payable borrower, uint borrowAmount) internal {\n        /* Fail if borrow not allowed */\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n        if (allowed != 0) {\n            revert BorrowComptrollerRejection(allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            revert BorrowFreshnessCheck();\n        }\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n        if (getCashPrior() < borrowAmount) {\n            revert BorrowCashNotAvailable();\n        }\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n         *  accountBorrowNew = accountBorrow + borrowAmount\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n         */\n        uint accountBorrowsPrev = borrowBalanceStoredInternal(borrower);\n        uint accountBorrowsNew = accountBorrowsPrev + borrowAmount;\n        uint totalBorrowsNew = totalBorrows + borrowAmount;\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We write the previously calculated values into storage.\n         *  Note: Avoid token reentrancy attacks by writing increased borrow before external transfer.\n        `*/\n        accountBorrows[borrower].principal = accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = totalBorrowsNew;\n\n        /*\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken borrowAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(borrower, borrowAmount);\n\n        /* We emit a Borrow event */\n        emit Borrow(borrower, borrowAmount, accountBorrowsNew, totalBorrowsNew);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n     */\n    function repayBorrowInternal(uint repayAmount) internal nonReentrant {\n        uint error = accrueInterest();\n        if (error != NO_ERROR) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            revert RepayBorrowAccrueInterestFailed(error);\n        }\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n     */\n    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant {\n        uint error = accrueInterest();\n        if (error != NO_ERROR) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            revert RepayBehalfAccrueInterestFailed(error);\n        }\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        repayBorrowFresh(msg.sender, borrower, repayAmount);\n    }\n\n    /**\n     * @notice Borrows are repaid by another user (possibly the borrower).\n     * @param payer the account paying off the borrow\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount the amount of underlying tokens being returned, or -1 for the full outstanding amount\n     * @return (uint) the actual repayment amount.\n     */\n    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n        /* Fail if repayBorrow not allowed */\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n        if (allowed != 0) {\n            revert RepayBorrowComptrollerRejection(allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            revert RepayBorrowFreshnessCheck();\n        }\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n        uint accountBorrowsPrev = borrowBalanceStoredInternal(borrower);\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n        uint repayAmountFinal = repayAmount == type(uint).max ? accountBorrowsPrev : repayAmount;\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We call doTransferIn for the payer and the repayAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional repayAmount of cash.\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         *   it returns the amount actually transferred, in case of a fee.\n         */\n        uint actualRepayAmount = doTransferIn(payer, repayAmountFinal);\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n         */\n        uint accountBorrowsNew = accountBorrowsPrev - actualRepayAmount;\n        uint totalBorrowsNew = totalBorrows - actualRepayAmount;\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = totalBorrowsNew;\n\n        /* We emit a RepayBorrow event */\n        emit RepayBorrow(payer, borrower, actualRepayAmount, accountBorrowsNew, totalBorrowsNew);\n\n        return actualRepayAmount;\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     */\n    function liquidateBorrowInternal(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal nonReentrant {\n        uint error = accrueInterest();\n        if (error != NO_ERROR) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            revert LiquidateAccrueBorrowInterestFailed(error);\n        }\n\n        error = cTokenCollateral.accrueInterest();\n        if (error != NO_ERROR) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            revert LiquidateAccrueCollateralInterestFailed(error);\n        }\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n        liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n    }\n\n    /**\n     * @notice The liquidator liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param liquidator The address repaying the borrow and seizing collateral\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     */\n    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CTokenInterf"
    }
  ]
}