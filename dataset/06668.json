{
  "Title": "[L-02] `processInclusionProofKeccak` does not work as expected",
  "Content": "\n### Proof of Concept\nThe function `verifyInclusionKeccak` is not used anywhere but its in the scope of this audit. There is no validation that proof is a tree and a valid tree like it described in the comments. E.x. if proof is less than 32 length, that function will just return a leaf without reverting. In my opinion, function doesn't work as expected and can be exploited. I've submitted the same issue with `processInclusionProofSha256` function that lead to loss a funds for validator due the same issue.\n\n```solidity\n    function processInclusionProofKeccak(bytes memory proof, bytes32 leaf, uint256 index) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 32; i <= proof.length; i+=32) {\n            if(index % 2 == 0) {\n                // if ith bit of index is 0, then computedHash is a left sibling\n                assembly {\n                    mstore(0x00, computedHash)\n                    mstore(0x20, mload(add(proof, i)))\n                    computedHash := keccak256(0x00, 0x40)\n                    index := div(index, 2)\n                }\n            } else {\n                // if ith bit of index is 1, then computedHash is a right sibling\n                assembly {\n                    mstore(0x00, mload(add(proof, i)))\n                    mstore(0x20, computedHash)\n                    computedHash := keccak256(0x00, 0x40)\n                    index := div(index, 2)\n                }            \n            }\n        }\n        return computedHash;\n    }\n```\n[src/contracts/libraries/Merkle.sol#L49](https://github.com/code-423n4/2023-04-eigenlayer/blob/398cc428541b91948f717482ec973583c9e76232/src/contracts/libraries/Merkle.sol#L48)\n\n### Recommended Mitigation Steps\nI think its important to add security to that function like this:\n\n```diff\n    function processInclusionProofKeccak(bytes memory proof, bytes32 leaf, uint256 index) internal pure returns (bytes32) {\n+        require(proof.length % 32 == 0 && proof.length > 0, \"Invalid proof length\");\n\n        bytes32 computedHash = leaf;\n        for (uint256 i = 32; i <= proof.length; i+=32) {\n            if(index % 2 == 0) {\n                // if ith bit of index is 0, then computedHash is a left sibling\n                assembly {\n                    mstore(0x00, computedHash)\n                    mstore(0x20, mload(add(proof, i)))\n                    computedHash := keccak256(0x00, 0x40)\n                    index := div(index, 2)\n                }\n            } else {\n                // if ith bit of index is 1, then computedHash is a right sibling\n                assembly {\n                    mstore(0x00, mload(add(proof, i)))\n                    mstore(0x20, computedHash)\n                    computedHash := keccak256(0x00, 0x40)\n                    index := div(index, 2)\n                }            \n            }\n        }\n        return computedHash;\n    }\n```\n\n**[Sidu28 (EigenLayer) confirmed](https://github.com/code-423n4/2023-04-eigenlayer-findings/issues/22#issuecomment-1545180646)**\n\n**[Alex the Entreprenerd (judge) decreased severity to QA and commented](https://github.com/code-423n4/2023-04-eigenlayer-findings/issues/22#issuecomment-1572151682):**\n > https://github.com/code-423n4/2023-04-eigenlayer/blob/398cc428541b91948f717482ec973583c9e76232/src/contracts/operators/MerkleDelegationTerms.sol#L97-L107\n\n```solidity\n        // check inclusion of the leafHash in the tree corresponding to `merkleRoots[rootIndex]`\n        require(\n            Merkle.verifyInclusionKeccak(\n                proof,\n                merkleRoots[rootIndex].root,\n                leafHash,\n                nodeIndex\n            ),\n            \"MerkleDelegationTerms.proveEarningsAndWithdraw: proof of inclusion failed\"\n        );\n\n```\n\n>Which calls `processInclusionProofKeccak`\n>\n>For this reason, I believe the finding to be a Refactoring. Adding the check in the function is a good idea, but the code in scope is safe.\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-04-eigenlayer",
  "Code": [
    {
      "filename": "src/contracts/libraries/Merkle.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Adapted from OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity =0.8.12;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary Merkle {\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is \n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     * \n     * Note this is for a Merkle tree using the keccak/sha3 hash function\n     */\n    function verifyInclusionKeccak(\n        bytes memory proof,\n        bytes32 root,\n        bytes32 leaf,\n        uint256 index\n    ) internal pure returns (bool) {\n        return processInclusionProofKeccak(proof, leaf, index) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is \n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     * \n     * _Available since v4.4._\n     * \n     * Note this is for a Merkle tree using the keccak/sha3 hash function\n     */\n    function processInclusionProofKeccak(bytes memory proof, bytes32 leaf, uint256 index) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 32; i <= proof.length; i+=32) {\n            if(index % 2 == 0) {\n                // if ith bit of index is 0, then computedHash is a left sibling\n                assembly {\n                    mstore(0x00, computedHash)\n                    mstore(0x20, mload(add(proof, i)))\n                    computedHash := keccak256(0x00, 0x40)\n                    index := div(index, 2)\n                }\n            } else {\n                // if ith bit of index is 1, then computedHash is a right sibling\n                assembly {\n                    mstore(0x00, mload(add(proof, i)))\n                    mstore(0x20, computedHash)\n                    computedHash := keccak256(0x00, 0x40)\n                    index := div(index, 2)\n                }            \n            }\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is \n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     * \n     * Note this is for a Merkle tree using the sha256 hash function\n     */\n    function verifyInclusionSha256(\n        bytes memory proof,\n        bytes32 root,\n        bytes32 leaf,\n        uint256 index\n    ) internal view returns (bool) {\n        return processInclusionProofSha256(proof, leaf, index) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is \n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     *\n     * _Available since v4.4._\n     * \n     * Note this is for a Merkle tree using the sha256 hash function\n     */\n    function processInclusionProofSha256(bytes memory proof, bytes32 leaf, uint256 index) internal view returns (bytes32) {\n        bytes32[1] memory computedHash = [leaf];\n        for (uint256 i = 32; i <= proof.length; i+=32) {\n            if(index % 2 == 0) {\n                // if ith bit of index is 0, then computedHash is a left sibling\n                assembly {\n                    mstore(0x00, mload(computedHash))\n                    mstore(0x20, mload(add(proof, i)))\n                    if iszero(staticcall(sub(gas(), 2000), 2, 0x00, 0x40, computedHash, 0x20)) {revert(0, 0)}\n                    index := div(index, 2)\n                }\n            } else {\n                // if ith bit of index is 1, then computedHash is a right sibling\n                assembly {\n                    mstore(0x00, mload(add(proof, i)))\n                    mstore(0x20, mload(computedHash))\n                    if iszero(staticcall(sub(gas(), 2000), 2, 0x00, 0x40, computedHash, 0x20)) {revert(0, 0)}\n                    index := div(index, 2)\n                }            \n            }\n        }\n        return computedHash[0];\n    }\n\n    /**\n     @notice this function returns the merkle root of a tree created from a set of leaves using sha256 as its hash function\n     @param leaves the leaves of the merkle tree\n\n     @notice requires the leaves.length is a power of 2\n     */ \n    function merkleizeSha256(\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32) {\n        //there are half as many nodes in the layer above the leaves\n        uint256 numNodesInLayer = leaves.length / 2;\n        //create a layer to store the internal nodes\n        bytes32[] memory layer = new bytes32[](numNodesInLayer);\n        //fill the layer with the pairwise hashes of the leaves\n        for (uint i = 0; i < numNodesInLayer; i++) {\n            layer[i] = sha256(abi.encodePacked(leaves[2*i], leaves[2*i+1]));\n        }\n        //the next layer above has half as many nodes\n        numNodesInLayer /= 2;\n        //while we haven't computed the root\n        while (numNodesInLayer != 0) {\n            //overwrite the first numNodesInLayer nodes in layer with the pairwise hashes of their children\n            for (uint i = 0; i < numNodesInLayer; i++) {\n                layer[i] = sha256(abi.encodePacked(layer[2*i], layer[2*i+1]));\n            }\n            //the next layer above has half as many nodes\n            numNodesInLayer /= 2;\n        }\n        //the first node in the layer is the root\n        return layer[0];\n    }\n}"
    },
    {
      "filename": "src/contracts/operators/MerkleDelegationTerms.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity =0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/IDelegationTerms.sol\";\nimport \"../libraries/Merkle.sol\";\n\n/**\n * @title A 'Delegation Terms' contract that an operator can use to distribute earnings to stakers by periodically posting Merkle roots\n * @author Layr Labs, Inc.\n * @notice This contract specifies the delegation terms of a given operator. When a staker delegates its stake to an operator,\n * it has to agrees to the terms set in the operator's 'Delegation Terms' contract. Payments to an operator are routed through\n * their specified 'Delegation Terms' contract for subsequent distribution of earnings to individual stakers.\n * There are also hooks that call into an operator's DelegationTerms contract when a staker delegates to or undelegates from\n * the operator.\n * @dev This contract uses a system in which the operator posts roots of a *sparse Merkle tree*. Each leaf of the tree is expected\n * to contain the **cumulative** earnings of a staker. This will reduce the total number of actions that stakers who claim only rarely\n * have to take, while allowing stakers to claim their earnings as often as new Merkle roots are posted.\n */\ncontract MerkleDelegationTerms is Ownable, IDelegationTerms {\n    using SafeERC20 for IERC20;\n\n    struct TokenAndAmount {\n        IERC20 token;\n        uint256 amount;\n    }\n\n    struct MerkleRootAndTreeHeight {\n        bytes32 root;\n        uint256 height;\n    }\n\n    // sanity-check parameter on Merkle tree height\n    uint256 internal constant MAX_HEIGHT = 256;\n\n    /// @notice staker => token => cumulative amount *claimed*\n    mapping(address => mapping(IERC20 => uint256)) public cumulativeClaimedByStakerOfToken;\n\n    /// @notice Array of Merkle roots with heights, each posted by the operator (contract owner)\n    MerkleRootAndTreeHeight[] public merkleRoots;\n\n    // TODO: more events?\n    event NewMerkleRootPosted(bytes32 newRoot, uint256 height);\n\n    /**\n     * @notice Used by the operator to withdraw tokens directly from this contract.\n     * @param tokensAndAmounts ERC20 tokens to withdraw and the amount of each respective ERC20 token to withdraw.\n     */ \n    function operatorWithdrawal(TokenAndAmount[] calldata tokensAndAmounts) external onlyOwner {\n        uint256 tokensAndAmountsLength = tokensAndAmounts.length;\n        for (uint256 i; i < tokensAndAmountsLength;) {\n            tokensAndAmounts[i].token.safeTransfer(msg.sender, tokensAndAmounts[i].amount);\n            cumulativeClaimedByStakerOfToken[msg.sender][tokensAndAmounts[i].token] += tokensAndAmounts[i].amount;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Used by the operator to post an updated root of the stakers' all-time earnings\n    function postMerkleRoot(bytes32 newRoot, uint256 height) external onlyOwner {\n        // sanity check\n        require(height <= MAX_HEIGHT, \"MerkleDelegationTerms.postMerkleRoot: height input too large\");\n        merkleRoots.push(\n            MerkleRootAndTreeHeight({\n                root: newRoot,\n                height: height\n            })\n        );\n        emit NewMerkleRootPosted(newRoot, height);\n    }\n\n    /** \n     * @notice Called by a staker to prove the inclusion of their earnings in a Merkle root (posted by the operator) and claim them.\n     * @param tokensAndAmounts ERC20 tokens to withdraw and the amount of each respective ERC20 token to withdraw.\n     * @param proof Merkle proof showing that a leaf containing `(msg.sender, tokensAndAmounts)` was included in the `rootIndex`-th\n     * Merkle root posted by the operator.\n     * @param nodeIndex Specifies the node inside the Merkle tree corresponding to the specified root, `merkleRoots[rootIndex].root`.\n     * @param rootIndex Specifies the Merkle root to look up, using `merkleRoots[rootIndex]`\n     */\n    function proveEarningsAndWithdraw(\n        TokenAndAmount[] calldata tokensAndAmounts,\n        bytes memory proof,\n        uint256 nodeIndex,\n        uint256 rootIndex\n    ) external {\n        // calculate the leaf that the `msg.sender` is claiming\n        bytes32 leafHash = calculateLeafHash(msg.sender, tokensAndAmounts);\n\n        // verify that the proof length is appropriate for the chosen root\n        require(proof.length == 32 * merkleRoots[rootIndex].height, \"MerkleDelegationTerms.proveEarningsAndWithdraw: incorrect proof length\");\n\n        // check inclusion of the leafHash in the tree corresponding to `merkleRoots[rootIndex]`\n        require(\n            Merkle.verifyInclusionKeccak(\n                proof,\n                merkleRoots[rootIndex].root,\n                leafHash,\n                nodeIndex\n            ),\n            \"MerkleDelegationTerms.proveEarningsAndWithdraw: proof of inclusion failed\"\n        );\n\n        uint256 tokensAndAmountsLength = tokensAndAmounts.length;\n        for (uint256 i; i < tokensAndAmountsLength;) {\n            // calculate amount to send\n            uint256 amountToSend = tokensAndAmounts[i].amount - cumulativeClaimedByStakerOfToken[msg.sender][tokensAndAmounts[i].token];\n\n            if (amountToSend != 0) {\n                // update claimed amount in storage\n                cumulativeClaimedByStakerOfToken[msg.sender][tokensAndAmounts[i].token] = tokensAndAmounts[i].amount;\n\n                // actually send the tokens\n                tokensAndAmounts[i].token.safeTransfer(msg.sender, amountToSend);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Helper function for calculating a leaf in a Merkle tree formatted as `(address staker, TokenAndAmount[] calldata tokensAndAmounts)`\n    function calculateLeafHash(address staker, TokenAndAmount[] calldata tokensAndAmounts) public pure returns (bytes32) {\n        return keccak256(abi.encode(staker, tokensAndAmounts));\n    }\n\n    // FUNCTIONS FROM INTERFACE\n    function payForService(IERC20, uint256) external payable\n    // solhint-disable-next-line no-empty-blocks\n    {}\n\n    /// @notice Hook for receiving new delegation   \n    function onDelegationReceived(\n        address,\n        IStrategy[] memory,\n        uint256[] memory\n    ) external pure returns(bytes memory)\n    // solhint-disable-next-line no-empty-blocks\n    {}\n\n    /// @notice Hook for withdrawing delegation   \n    function onDelegationWithdrawn(\n        address,\n        IStrategy[] memory,\n        uint256[] memory\n    ) external pure returns(bytes memory)\n    // solhint-disable-next-line no-empty-blocks\n    {}\n}"
    }
  ]
}