{
  "Title": "[L04] Contract registry has no entry for BRL",
  "Content": "In [PR #8831](https://github.com/celo-org/celo-monorepo/pull/8831), the [`UsingRegistryV2` contract](https://github.com/celo-org/celo-monorepo/blob/63f75e33df2fe8f1a9005fce53de302d126fe2c3/packages/protocol/contracts/common/UsingRegistryV2.sol) provides various getters returning addresses for contracts comprising the Celo protocol. For each featured protocol contract, a constant pointer is defined and used to inform the corresponding getter. While this mechanism isn’t too complex, duplicating this process in code for a particular contract can lead to errors.\n\n\nThe problem is that the EUR token [has corresponding getters](https://github.com/celo-org/celo-monorepo/blob/63f75e33df2fe8f1a9005fce53de302d126fe2c3/packages/protocol/contracts/common/UsingRegistryV2.sol#L86) for its registry and exchange, while the BRL token does not. So retrieval of corresponding BRL contract address would require code that may be error prone and not follow the standard defined by the `UsingRegistryV2` contract.\n\n\nConsider defining within the `UsingRegistryV2` contract getters corresponding to the BRL token.\n\n\n**Update:** *Fixed as of commit [`0afc15a6dac109ada329e12c0d40fec7dcb9f40c`](https://github.com/luisgj/celo-monorepo/commit/0afc15a6dac109ada329e12c0d40fec7dcb9f40c). cLab’s statement for this issue:*\n\n\n\n> *“we were indeed missing the getters, but the contract UsingRegistryV2 is not actually used anywhere and the contract to update should have been UsingRegistry.”*\n> \n> \n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/common/UsingRegistryV2.sol",
      "content": "pragma solidity ^0.5.13;\n\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/IAccounts.sol\";\nimport \"./interfaces/IFeeCurrencyWhitelist.sol\";\nimport \"./interfaces/IFreezer.sol\";\nimport \"./interfaces/IRegistry.sol\";\n\nimport \"../governance/interfaces/IElection.sol\";\nimport \"../governance/interfaces/IGovernance.sol\";\nimport \"../governance/interfaces/ILockedGold.sol\";\nimport \"../governance/interfaces/IValidators.sol\";\n\nimport \"../identity/interfaces/IRandom.sol\";\nimport \"../identity/interfaces/IAttestations.sol\";\n\nimport \"../stability/interfaces/IExchange.sol\";\nimport \"../stability/interfaces/IReserve.sol\";\nimport \"../stability/interfaces/ISortedOracles.sol\";\nimport \"../stability/interfaces/IStableToken.sol\";\n\ncontract UsingRegistryV2 {\n  address constant registryAddress = 0x000000000000000000000000000000000000ce10;\n  IRegistry public constant registry = IRegistry(registryAddress);\n\n  // solhint-disable state-visibility\n  bytes32 constant ACCOUNTS_REGISTRY_ID = keccak256(abi.encodePacked(\"Accounts\"));\n  bytes32 constant ATTESTATIONS_REGISTRY_ID = keccak256(abi.encodePacked(\"Attestations\"));\n  bytes32 constant DOWNTIME_SLASHER_REGISTRY_ID = keccak256(abi.encodePacked(\"DowntimeSlasher\"));\n  bytes32 constant DOUBLE_SIGNING_SLASHER_REGISTRY_ID = keccak256(\n    abi.encodePacked(\"DoubleSigningSlasher\")\n  );\n  bytes32 constant ELECTION_REGISTRY_ID = keccak256(abi.encodePacked(\"Election\"));\n  bytes32 constant EXCHANGE_REGISTRY_ID = keccak256(abi.encodePacked(\"Exchange\"));\n  bytes32 constant EXCHANGE_EURO_REGISTRY_ID = keccak256(abi.encodePacked(\"ExchangeEUR\"));\n  bytes32 constant FEE_CURRENCY_WHITELIST_REGISTRY_ID = keccak256(\n    abi.encodePacked(\"FeeCurrencyWhitelist\")\n  );\n  bytes32 constant FREEZER_REGISTRY_ID = keccak256(abi.encodePacked(\"Freezer\"));\n  bytes32 constant GOLD_TOKEN_REGISTRY_ID = keccak256(abi.encodePacked(\"GoldToken\"));\n  bytes32 constant GOVERNANCE_REGISTRY_ID = keccak256(abi.encodePacked(\"Governance\"));\n  bytes32 constant GOVERNANCE_SLASHER_REGISTRY_ID = keccak256(\n    abi.encodePacked(\"GovernanceSlasher\")\n  );\n  bytes32 constant LOCKED_GOLD_REGISTRY_ID = keccak256(abi.encodePacked(\"LockedGold\"));\n  bytes32 constant RESERVE_REGISTRY_ID = keccak256(abi.encodePacked(\"Reserve\"));\n  bytes32 constant RANDOM_REGISTRY_ID = keccak256(abi.encodePacked(\"Random\"));\n  bytes32 constant SORTED_ORACLES_REGISTRY_ID = keccak256(abi.encodePacked(\"SortedOracles\"));\n  bytes32 constant STABLE_TOKEN_REGISTRY_ID = keccak256(abi.encodePacked(\"StableToken\"));\n  bytes32 constant STABLE_EURO_TOKEN_REGISTRY_ID = keccak256(abi.encodePacked(\"StableTokenEUR\"));\n  bytes32 constant VALIDATORS_REGISTRY_ID = keccak256(abi.encodePacked(\"Validators\"));\n  // solhint-enable state-visibility\n\n  modifier onlyRegisteredContract(bytes32 identifierHash) {\n    require(registry.getAddressForOrDie(identifierHash) == msg.sender, \"only registered contract\");\n    _;\n  }\n\n  modifier onlyRegisteredContracts(bytes32[] memory identifierHashes) {\n    require(registry.isOneOf(identifierHashes, msg.sender), \"only registered contracts\");\n    _;\n  }\n\n  function getAccounts() internal view returns (IAccounts) {\n    return IAccounts(registry.getAddressForOrDie(ACCOUNTS_REGISTRY_ID));\n  }\n\n  function getAttestations() internal view returns (IAttestations) {\n    return IAttestations(registry.getAddressForOrDie(ATTESTATIONS_REGISTRY_ID));\n  }\n\n  function getElection() internal view returns (IElection) {\n    return IElection(registry.getAddressForOrDie(ELECTION_REGISTRY_ID));\n  }\n\n  function getExchange() internal view returns (IExchange) {\n    return IExchange(registry.getAddressForOrDie(EXCHANGE_REGISTRY_ID));\n  }\n\n  function getExchangeDollar() internal view returns (IExchange) {\n    return getExchange();\n  }\n\n  function getExchangeEuro() internal view returns (IExchange) {\n    return IExchange(registry.getAddressForOrDie(EXCHANGE_EURO_REGISTRY_ID));\n  }\n\n  function getFeeCurrencyWhitelistRegistry() internal view returns (IFeeCurrencyWhitelist) {\n    return IFeeCurrencyWhitelist(registry.getAddressForOrDie(FEE_CURRENCY_WHITELIST_REGISTRY_ID));\n  }\n\n  function getFreezer() internal view returns (IFreezer) {\n    return IFreezer(registry.getAddressForOrDie(FREEZER_REGISTRY_ID));\n  }\n\n  function getGoldToken() internal view returns (IERC20) {\n    return IERC20(registry.getAddressForOrDie(GOLD_TOKEN_REGISTRY_ID));\n  }\n\n  function getGovernance() internal view returns (IGovernance) {\n    return IGovernance(registry.getAddressForOrDie(GOVERNANCE_REGISTRY_ID));\n  }\n\n  function getLockedGold() internal view returns (ILockedGold) {\n    return ILockedGold(registry.getAddressForOrDie(LOCKED_GOLD_REGISTRY_ID));\n  }\n\n  function getRandom() internal view returns (IRandom) {\n    return IRandom(registry.getAddressForOrDie(RANDOM_REGISTRY_ID));\n  }\n\n  function getReserve() internal view returns (IReserve) {\n    return IReserve(registry.getAddressForOrDie(RESERVE_REGISTRY_ID));\n  }\n\n  function getSortedOracles() internal view returns (ISortedOracles) {\n    return ISortedOracles(registry.getAddressForOrDie(SORTED_ORACLES_REGISTRY_ID));\n  }\n\n  function getStableToken() internal view returns (IStableToken) {\n    return IStableToken(registry.getAddressForOrDie(STABLE_TOKEN_REGISTRY_ID));\n  }\n\n  function getStableDollarToken() internal view returns (IStableToken) {\n    return getStableToken();\n  }\n\n  function getStableEuroToken() internal view returns (IStableToken) {\n    return IStableToken(registry.getAddressForOrDie(STABLE_EURO_TOKEN_REGISTRY_ID));\n  }\n\n  function getValidators() internal view returns (IValidators) {\n    return IValidators(registry.getAddressForOrDie(VALIDATORS_REGISTRY_ID));\n  }\n}"
    }
  ]
}