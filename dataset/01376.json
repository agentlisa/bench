{
  "Title": "Incorrect `defaultedDebt` interest accrual",
  "Content": "##### Description\nhttps://github.com/prisma-fi/prisma-contracts/blob/52b26b8a2f1904b048754d5443e08d2144610b92/contracts/core/TroveManager.sol#L1201\n\nIn Prisma, there are liquidations which distribute the debt and collateral from liquidated troves among the remaining ones. For example, these are liquidations when ICR < 100% or liquidations the size of which the StabilityPool cannot cover. Each liquidation of this kind increases the values of `defaultedDebt`, `L_debt`, and `L_collateral` in the relevant TroveManager. These variables are used to track the total debt for each trove.\n\nThe `_applyPendingRewards()` function is triggered with every user interaction with a trove and increases the `trove.debt` by the pending debt from the `defaultedDebt` pool, but only if `rewardSnapshots[trove].collateral < L_collateral`:\n```\nfunction _applyPendingRewards\n    ...\n    if (rewardSnapshots[_borrower].collateral < L_collateral) {\n        ...\n        // add pending interest\n        debt = debt + pendingDebtReward;\n        ...\n    }\n    ...\n    // update trove debt\n    t.debt = debt;\n```\nhttps://github.com/prisma-fi/prisma-contracts/blob/52b26b8a2f1904b048754d5443e08d2144610b92/contracts/core/TroveManager.sol#L1201\n\nOver time, the value of `L_debt` and the size of `defaultedDebt` increase:\n```\nfunction _redistributeDebtAndColl\n    ...\n    if (lastIndexUpdateCached < block.timestamp) {\n        ...\n        uint256 accruedInterest = Math.mulDiv(defaultedDebt, interestFactor,\n        INTEREST_PRECISION);\n        ...\n        debtWithInterests += accruedInterest;\n    }\n    ...\n    defaultedDebt += debtWithInterests;\n```\nhttps://github.com/prisma-fi/prisma-contracts/blob/52b26b8a2f1904b048754d5443e08d2144610b92/contracts/core/TroveManager.sol#L1367\n\nHowever, `L_collateral` can remain the same until the next bad liquidation (i.e., a liquidation with ICR < 100% or a liquidation which StabilityPool cannot cover).\n\nThus, if a hacker triggers `_applyPendingRewards()` for themselves after a bad liquidation (which increases `L_collateral` and `L_debt`), for example, using the `claimReward()` function, they will set their `rewardSnapshots[hacker].collateral` equal to the new `L_collateral`, and subsequent increases in the `L_debt` variable over time will be incorrectly tracked for them.\n\nFor example, the `getTroveCollAndDebt()` function will return the correct debt for the hacker, including the accumulated `defaultedDebt` interest. However, `_applyPendingRewards()` will not update the `trove.debt` variable because the condition `rewardSnapshots[hacker].collateral < L_collateral` is not satisfied as `L_collateral` remained unchanged. This allows the hacker to close their trove without paying the accrued `defaultedDebt` interest, which can be arbitrarily large. Upon trove closure, all their pending interest will be distributed among unsuspecting remaining troves.\n\nThis leads to instant losses for all troves, which will be forced to pay off the accumulated debt in `defaultedDebt` on behalf of the hacker, and it also leads to instability in the system when a multitude of troves can suddenly go underwater due to the sudden distribution of unpaid debt by the hacker.\n\nThe PoC was sent to the Prism team.\n\n##### Recommendation\nThe issue with incorrect interest accrual could be addressed by expanding the check in the `_applyPendingRewards()` function as follows:\n```\nif (\n    (rewardSnapshots[_borrower].collateral < L_collateral)\n    ||\n    (rewardSnapshots[_borrower].debt < L_debt)\n)\n```\n\nHowever, it's worth noting that the `defaultedDebt` pool can only be zeroed out if after a bad liquidation, the `_applyPendingRewards()` function is called for absolutely all troves in the system, which transfers the debt from `defaultedDebt` to the `totalActiveDebt` pool:\n```\n_movePendingTroveRewardsToActiveBalance(pendingDebtReward, \npendingCollateralReward);\n```\n\nThis is not practically possible. Therefore, `defaultedDebt` will remain positive because some accounts in the system will be inactive. Consequently, the interest accumulated over time in the `defaultedDebt` pool will be distributed among all other active accounts. This seems unfair to active accounts, who will have to pay for the debts of inactive users.\n\nTherefore, the best solution seems to be a complete abandonment of interest accrual on the `defaultedDebt` pool.\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/core/TroveManager.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../interfaces/IBorrowerOperations.sol\";\nimport \"../interfaces/IDebtToken.sol\";\nimport \"../interfaces/ISortedTroves.sol\";\nimport \"../interfaces/ITreasury.sol\";\nimport \"../interfaces/IPriceFeed.sol\";\nimport \"../dependencies/SystemStart.sol\";\nimport \"../dependencies/PrismaBase.sol\";\nimport \"../dependencies/PrismaMath.sol\";\nimport \"../dependencies/PrismaOwnable.sol\";\n\n/**\n    @title Prisma Trove Manager\n    @notice Based on Liquity's `TroveManager`\n            https://github.com/liquity/dev/blob/main/packages/contracts/contracts/TroveManager.sol\n\n            Prisma's implementation is modified so that multiple `TroveManager` and `SortedTroves`\n            contracts are deployed in tandem, with each pair managing troves of a single collateral\n            type.\n\n            Functionality related to liquidations has been moved to `LiquidationManager`. This was\n            necessary to avoid the restriction on deployed bytecode size.\n */\ncontract TroveManager is PrismaBase, PrismaOwnable, SystemStart {\n    // --- Connected contract declarations ---\n\n    address public immutable borrowerOperationsAddress;\n    address public immutable liquidationManager;\n    address immutable gasPoolAddress;\n    IDebtToken public immutable debtToken;\n    IPrismaTreasury public immutable treasury;\n\n    IPriceFeed public priceFeed;\n    IERC20 public collateralToken;\n\n    // A doubly linked list of Troves, sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    EmissionId public emissionId;\n\n    uint256 constant SECONDS_IN_ONE_MINUTE = 60;\n    uint256 constant INTEREST_PRECISION = 1e27;\n    uint256 constant SECONDS_IN_YEAR = 365 days;\n    uint256 constant REWARD_DURATION = 1 weeks;\n\n    // volume-based amounts are divided by this value to allow storing as uint32\n    uint256 constant VOLUME_MULTIPLIER = 1e20;\n\n    // Maximum interest rate must be lower than the minimum LST staking yield\n    // so that over time the actual TCR becomes greater than the calculated TCR.\n    uint256 public constant MAX_INTEREST_RATE_IN_BPS = 400; // 4%\n    uint256 public constant SUNSETTING_INTEREST_RATE = (INTEREST_PRECISION * 5000) / (10000 * SECONDS_IN_YEAR); //50%\n\n    // During bootsrap period redemptions are not allowed\n    uint256 public constant BOOTSTRAP_PERIOD = 14 days;\n\n    /*\n     * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption.\n     * Corresponds to (1 / ALPHA) in the white paper.\n     */\n    uint256 constant BETA = 2;\n\n    // commented values are prisma's fixed settings for each parameter\n    uint256 public minuteDecayFactor; // 999037758833783000;\n    uint256 public redemptionFeeFloor; // DECIMAL_PRECISION / 1000 * 5; // 0.5%\n    uint256 public maxRedemptionFee; // DECIMAL_PRECISION; // 100%\n    uint256 public borrowingFeeFloor; // DECIMAL_PRECISION / 1000 * 5; // 0.5%\n    uint256 public maxBorrowingFee; // DECIMAL_PRECISION / 100 * 5; // 5%\n    uint256 public maxSystemDebt;\n\n    uint256 public interestRate;\n    uint256 public activeInterestIndex;\n    uint256 public lastActiveIndexUpdate;\n\n    uint256 public systemDeploymentTime;\n    bool public sunsetting;\n    bool public paused;\n\n    uint256 public baseRate;\n\n    // The timestamp of the latest fee operation (redemption or new debt issuance)\n    uint256 public lastFeeOperationTime;\n\n    uint256 public totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    uint256 public totalStakesSnapshot;\n\n    // Snapshot of the total collateral taken immediately after the latest liquidation.\n    uint256 public totalCollateralSnapshot;\n\n    /*\n     * L_collateral and L_debt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\n     *\n     * An collateral gain of ( stake * [L_collateral - L_collateral(0)] )\n     * A debt increase  of ( stake * [L_debt - L_debt(0)] )\n     *\n     * Where L_collateral(0) and L_debt(0) are snapshots of L_collateral and L_debt for the active Trove taken at the instant the stake was made\n     */\n    uint256 public L_collateral;\n    uint256 public L_debt;\n    uint256 public lastDefaultInterestUpdate;\n\n    // Error trackers for the trove redistribution calculation\n    uint256 public lastCollateralError_Redistribution;\n    uint256 public lastDebtError_Redistribution;\n\n    uint256 internal totalActiveCollateral;\n    uint256 internal totalActiveDebt;\n    uint256 public interestPayable;\n\n    uint256 public defaultedCollateral;\n    uint256 public defaultedDebt;\n\n    uint256 public rewardIntegral;\n    uint128 public rewardRate;\n    uint32 public lastUpdate;\n    uint32 public periodFinish;\n\n    mapping(address => uint256) public rewardIntegralFor;\n    mapping(address => uint256) private pendingRewardFor;\n\n    // week -> total available rewards for 1 day within this week\n    uint256[65535] public dailyMintReward;\n\n    // week -> day -> total amount redeemed this day\n    uint32[7][65535] private totalMints;\n\n    // account -> data for latest activity\n    mapping(address => VolumeData) public accountLatestMint;\n\n    mapping(address => Trove) public Troves;\n    mapping(address => uint256) public surplusBalances;\n\n    // Map addresses with active troves to their RewardSnapshot\n    mapping(address => RewardSnapshot) public rewardSnapshots;\n\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\n    address[] TroveOwners;\n\n    struct VolumeData {\n        uint32 amount;\n        uint32 week;\n        uint32 day;\n    }\n\n    struct EmissionId {\n        uint16 debt;\n        uint16 minting;\n    }\n\n    // Store the necessary data for a trove\n    struct Trove {\n        uint256 debt;\n        uint256 coll;\n        uint256 stake;\n        Status status;\n        uint128 arrayIndex;\n        uint256 activeInterestIndex;\n    }\n\n    struct RedemptionTotals {\n        uint256 remainingDebt;\n        uint256 totalDebtToRedeem;\n        uint256 totalCollateralDrawn;\n        uint256 collateralFee;\n        uint256 collateralToSendToRedeemer;\n        uint256 decayedBaseRate;\n        uint256 price;\n        uint256 totalDebtSupplyAtStart;\n    }\n\n    struct SingleRedemptionValues {\n        uint256 debtLot;\n        uint256 collateralLot;\n        bool cancelledPartial;\n    }\n\n    // Object containing the collateral and debt snapshots for a given active trove\n    struct RewardSnapshot {\n        uint256 collateral;\n        uint256 debt;\n    }\n\n    enum TroveManagerOperation {\n        applyPendingRewards,\n        liquidateInNormalMode,\n        liquidateInRecoveryMode,\n        redeemCollateral\n    }\n\n    enum Status {\n        nonExistent,\n        active,\n        closedByOwner,\n        closedByLiquidation,\n        closedByRedemption\n    }\n\n    event TroveUpdated(\n        address indexed _borrower,\n        uint256 _debt,\n        uint256 _coll,\n        uint256 _stake,\n        TroveManagerOperation _operation\n    );\n    event Redemption(\n        uint256 _attemptedDebtAmount,\n        uint256 _actualDebtAmount,\n        uint256 _collateralSent,\n        uint256 _collateralFee\n    );\n    event TroveUpdated(address indexed _borrower, uint256 _debt, uint256 _coll, uint256 stake, uint8 operation);\n    event BaseRateUpdated(uint256 _baseRate);\n    event LastFeeOpTimeUpdated(uint256 _lastFeeOpTime);\n    event TotalStakesUpdated(uint256 _newTotalStakes);\n    event SystemSnapshotsUpdated(uint256 _totalStakesSnapshot, uint256 _totalCollateralSnapshot);\n    event LTermsUpdated(uint256 _L_collateral, uint256 _L_debt);\n    event TroveSnapshotsUpdated(uint256 _L_collateral, uint256 _L_debt);\n    event TroveIndexUpdated(address _borrower, uint256 _newIndex);\n    event EtherSent(address _to, uint256 _amount);\n    event RewardClaimed(address indexed account, address indexed recipient, uint256 claimed);\n\n    modifier whenNotPaused() {\n        require(!paused, \"Collateral Paused\");\n        _;\n    }\n\n    constructor(\n        address _prismaCore,\n        address _gasPoolAddress,\n        address _debtTokenAddress,\n        address _borrowerOperationsAddress,\n        address _treasury,\n        address _liquidationManager,\n        uint256 _gasCompensation\n    ) PrismaOwnable(_prismaCore) PrismaBase(_gasCompensation) SystemStart(_prismaCore) {\n        gasPoolAddress = _gasPoolAddress;\n        debtToken = IDebtToken(_debtTokenAddress);\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        treasury = IPrismaTreasury(_treasury);\n        liquidationManager = _liquidationManager;\n    }\n\n    function setAddresses(address _priceFeedAddress, address _sortedTrovesAddress, address _collateralToken) external {\n        require(address(sortedTroves) == address(0));\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        collateralToken = IERC20(_collateralToken);\n\n        systemDeploymentTime = block.timestamp;\n        sunsetting = false;\n        activeInterestIndex = INTEREST_PRECISION;\n        lastActiveIndexUpdate = block.timestamp;\n        lastDefaultInterestUpdate = block.timestamp;\n    }\n\n    function notifyRegisteredId(uint256[] calldata _assignedIds) external returns (bool) {\n        require(msg.sender == address(treasury));\n        require(emissionId.debt == 0, \"Already assigned\");\n        uint256 length = _assignedIds.length;\n        require(length == 2, \"Incorrect ID count\");\n        emissionId = EmissionId({ debt: uint16(_assignedIds[0]), minting: uint16(_assignedIds[1]) });\n        periodFinish = uint32(((block.timestamp / 1 weeks) + 1) * 1 weeks);\n\n        return true;\n    }\n\n    /**\n     * @notice Sets the pause state for this trove manager\n     *         Pausing is used to mitigate risks in exceptional circumstances\n     *         Functionalities affected by pausing are:\n     *         - New borrowing is not possible\n     *         - New collateral deposits are not possible\n     * @param _paused If true the protocol is paused\n     */\n    function setPaused(bool _paused) external {\n        require((_paused && msg.sender == guardian()) || msg.sender == owner(), \"Unauthorized\");\n        paused = _paused;\n    }\n\n    /**\n     * @notice Sets a custom price feed for this trove manager\n     * @param _priceFeedAddress Price feed address\n     */\n    function setPriceFeed(address _priceFeedAddress) external onlyOwner {\n        priceFeed = IPriceFeed(_priceFeedAddress);\n    }\n\n    /*\n        When sunsetting we:\n        1) Disable collateral handoff to SP\n        2) Greatly Increase interest rate to incentivize redemptions\n        3) Remove redemptions fees\n        4) Disable new loans\n     */\n    function startCollateralSunset() external {\n        require(msg.sender == address(PRISMA_CORE), \"Not prisma core\");\n        sunsetting = true;\n        _accrueActiveInterests();\n        _redistributeDebtAndColl(0, 0); //Accrue defaults interests\n        interestRate = SUNSETTING_INTEREST_RATE;\n        // accrual function doesn't update timestamp if interest was 0\n        lastActiveIndexUpdate = block.timestamp;\n        redemptionFeeFloor = 0;\n        maxSystemDebt = 0;\n    }\n\n    /*\n        _minuteDecayFactor is calculated as\n\n            10**18 * (1/2)**(1/n)\n\n        where n = the half-life in minutes\n     */\n    function setParameters(\n        uint256 _minuteDecayFactor,\n        uint256 _redemptionFeeFloor,\n        uint256 _maxRedemptionFee,\n        uint256 _borrowingFeeFloor,\n        uint256 _maxBorrowingFee,\n        uint256 _interestRateInBPS,\n        uint256 _maxSystemDebt\n    ) public {\n        require(!sunsetting, \"Cannot change after sunset\");\n        if (minuteDecayFactor != 0) {\n            require(msg.sender == owner(), \"Only owner\");\n        }\n        require(\n            _minuteDecayFactor >= 977159968434245000 && // half-life of 30 minutes\n                _minuteDecayFactor <= 999931237762985000 // half-life of 1 week\n        );\n        require(_redemptionFeeFloor <= _maxRedemptionFee && _maxRedemptionFee <= DECIMAL_PRECISION);\n        require(_borrowingFeeFloor <= _maxBorrowingFee && _maxBorrowingFee <= DECIMAL_PRECISION);\n\n        _decayBaseRate();\n\n        minuteDecayFactor = _minuteDecayFactor;\n        redemptionFeeFloor = _redemptionFeeFloor;\n        maxRedemptionFee = _maxRedemptionFee;\n        borrowingFeeFloor = _borrowingFeeFloor;\n        maxBorrowingFee = _maxBorrowingFee;\n        maxSystemDebt = _maxSystemDebt;\n\n        require(_interestRateInBPS <= MAX_INTEREST_RATE_IN_BPS, \"Interest > Maximum\");\n\n        uint256 newInterestRate = (INTEREST_PRECISION * _interestRateInBPS) / (10000 * SECONDS_IN_YEAR);\n        if (newInterestRate != interestRate) {\n            _accrueActiveInterests();\n            // accrual function doesn't update timestamp if interest was 0\n            lastActiveIndexUpdate = block.timestamp;\n            _redistributeDebtAndColl(0, 0); //Accrue defaults interests\n            interestRate = newInterestRate;\n        }\n    }\n\n    function collectInterests() external {\n        require(interestPayable > 0, \"Nothing to collect\");\n        debtToken.mint(PRISMA_CORE.feeReceiver(), interestPayable);\n        interestPayable = 0;\n    }\n\n    // --- Getters ---\n\n    function fetchPrice() public returns (uint256) {\n        IPriceFeed _priceFeed = priceFeed;\n        if (address(_priceFeed) == address(0)) {\n            _priceFeed = IPriceFeed(PRISMA_CORE.priceFeed());\n        }\n        return _priceFeed.fetchPrice();\n    }\n\n    function getWeekAndDay() public view returns (uint256, uint256) {\n        uint256 duration = (block.timestamp - startTime);\n        uint256 week = duration / 1 weeks;\n        uint256 day = (duration % 1 weeks) / 1 days;\n        return (week, day);\n    }\n\n    function getTotalMints(uint256 week) external view returns (uint32[7] memory) {\n        return totalMints[week];\n    }\n\n    function getTroveOwnersCount() external view returns (uint256) {\n        return TroveOwners.length;\n    }\n\n    function getTroveFromTroveOwnersArray(uint256 _index) external view returns (address) {\n        return TroveOwners[_index];\n    }\n\n    function getTroveStatus(address _borrower) external view returns (uint256) {\n        return uint256(Troves[_borrower].status);\n    }\n\n    function getTroveStake(address _borrower) external view returns (uint256) {\n        return Troves[_borrower].stake;\n    }\n\n    /**\n        @notice Get the current total collateral and debt amounts for a trove\n        @dev Also includes pending rewards from redistribution\n     */\n    function getTroveCollAndDebt(address _borrower) public view returns (uint256 coll, uint256 debt) {\n        (debt, coll, , ) = getEntireDebtAndColl(_borrower);\n        return (coll, debt);\n    }\n\n    /**\n        @notice Get the total and pending collateral and debt amounts for a trove\n        @dev Used by the liquidation manager\n     */\n    function getEntireDebtAndColl(\n        address _borrower\n    ) public view returns (uint256 debt, uint256 coll, uint256 pendingDebtReward, uint256 pendingCollateralReward) {\n        Trove storage t = Troves[_borrower];\n        debt = t.debt;\n        coll = t.coll;\n\n        (pendingCollateralReward, pendingDebtReward) = getPendingCollAndDebtRewards(_borrower);\n        // Accrued trove interest for correct liquidation values. This assumes the index to be updated.\n        uint256 troveInterestIndex = t.activeInterestIndex;\n        if (troveInterestIndex > 0) {\n            (uint256 currentIndex, ) = _calculateInterestIndex();\n            debt = (debt * currentIndex) / troveInterestIndex;\n        }\n\n        debt = debt + pendingDebtReward;\n        coll = coll + pendingCollateralReward;\n    }\n\n    function getEntireSystemColl() public view returns (uint256) {\n        return totalActiveCollateral + defaultedCollateral;\n    }\n\n    function getEntireSystemDebt() public view returns (uint256) {\n        uint256 currentActiveDebt = totalActiveDebt;\n        uint256 currentDefaultedDebt = defaultedDebt;\n        (, uint256 interestFactor) = _calculateInterestIndex();\n        if (interestFactor > 0) {\n            uint256 activeInterests = Math.mulDiv(currentActiveDebt, interestFactor, INTEREST_PRECISION);\n            currentActiveDebt = currentActiveDebt + activeInterests;\n        }\n        uint256 lastIndexUpdateCached = lastDefaultInterestUpdate;\n        if (lastIndexUpdateCached < block.timestamp) {\n            uint256 deltaT = block.timestamp - lastIndexUpdateCached;\n            interestFactor = deltaT * interestRate;\n            uint256 accruedInterest = Math.mulDiv(currentDefaultedDebt, interestFactor, INTEREST_PRECISION);\n            currentDefaultedDebt += accruedInterest;\n        }\n        return currentActiveDebt + currentDefaultedDebt;\n    }\n\n    function getEntireSystemBalances() external returns (uint256, uint256, uint256) {\n        return (getEntireSystemColl(), getEntireSystemDebt(), fetchPrice());\n    }\n\n    // --- Helper functions ---\n\n    // Return the nominal collateral ratio (ICR) of a given Trove, without the price. Takes a trove's pending coll and debt rewards from redistributions into account.\n    function getNominalICR(address _borrower) public view returns (uint256) {\n        (uint256 currentCollateral, uint256 currentDebt) = getTroveCollAndDebt(_borrower);\n\n        uint256 NICR = PrismaMath._computeNominalCR(currentCollateral, currentDebt);\n        return NICR;\n    }\n\n    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(address _borrower, uint256 _price) public view returns (uint256) {\n        (uint256 currentCollateral, uint256 currentDebt) = getTroveCollAndDebt(_borrower);\n\n        uint256 ICR = PrismaMath._computeCR(currentCollateral, currentDebt, _price);\n        return ICR;\n    }\n\n    function getTCR(uint256 _price) public view returns (uint256 TCR) {\n        uint256 entireSystemColl = getEntireSystemColl();\n        uint256 entireSystemDebt = getEntireSystemDebt();\n\n        TCR = PrismaMath._computeCR(entireSystemColl, entireSystemDebt, _price);\n\n        return TCR;\n    }\n\n    function getTotalActiveCollateral() public view returns (uint256) {\n        return totalActiveCollateral;\n    }\n\n    function getTotalActiveDebt() public view returns (uint256) {\n        uint256 currentActiveDebt = totalActiveDebt;\n        (, uint256 interestFactor) = _calculateInterestIndex();\n        if (interestFactor > 0) {\n            uint256 activeInterests = Math.mulDiv(currentActiveDebt, interestFactor, INTEREST_PRECISION);\n            currentActiveDebt = currentActiveDebt + activeInterests;\n        }\n        return currentActiveDebt;\n    }\n\n    // Get the borrower's pending accumulated collateral and debt rewards, earned by their stake\n    function getPendingCollAndDebtRewards(address _borrower) public view returns (uint256, uint256) {\n        RewardSnapshot memory snapshot = rewardSnapshots[_borrower];\n\n        uint256 coll = L_collateral - snapshot.collateral;\n        uint256 debt = L_debt - snapshot.debt;\n\n        if (coll + debt == 0 || Troves[_borrower].status != Status.active) return (0, 0);\n\n        uint256 stake = Troves[_borrower].stake;\n        return ((stake * coll) / DECIMAL_PRECISION, (stake * debt) / DECIMAL_PRECISION);\n    }\n\n    function hasPendingRewards(address _borrower) public view returns (bool) {\n        /*\n         * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\n         * this indicates that rewards have occured since the snapshot was made, and the user therefore has\n         * pending rewards\n         */\n        if (Troves[_borrower].status != Status.active) {\n            return false;\n        }\n\n        return (rewardSnapshots[_borrower].collateral < L_collateral);\n    }\n\n    // --- Redemption fee functions ---\n\n    /*\n     * This function has two impacts on the baseRate state variable:\n     * 1) decays the baseRate based on time passed since last redemption or debt borrowing operation.\n     * then,\n     * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply\n     */\n    function _updateBaseRateFromRedemption(\n        uint256 _collateralDrawn,\n        uint256 _price,\n        uint256 _totalDebtSupply\n    ) internal returns (uint256) {\n        uint256 decayedBaseRate = _calcDecayedBaseRate();\n\n        /* Convert the drawn collateral back to debt at face value rate (1 debt:1 USD), in order to get\n         * the fraction of total supply that was redeemed at face value. */\n        uint256 redeemedDebtFraction = (_collateralDrawn * _price) / _totalDebtSupply;\n\n        uint256 newBaseRate = decayedBaseRate + (redeemedDebtFraction / BETA);\n        newBaseRate = PrismaMath._min(newBaseRate, DECIMAL_PRECISION); // cap baseRate at a maximum of 100%\n\n        // Update the baseRate state variable\n        baseRate = newBaseRate;\n        emit BaseRateUpdated(newBaseRate);\n\n        _updateLastFeeOpTime();\n\n        return newBaseRate;\n    }\n\n    function getRedemptionRate() public view returns (uint256) {\n        return _calcRedemptionRate(baseRate);\n    }\n\n    function getRedemptionRateWithDecay() public view returns (uint256) {\n        return _calcRedemptionRate(_calcDecayedBaseRate());\n    }\n\n    function _calcRedemptionRate(uint256 _baseRate) internal view returns (uint256) {\n        return\n            PrismaMath._min(\n                redemptionFeeFloor + _baseRate,\n                maxRedemptionFee // cap at a maximum of 100%\n            );\n    }\n\n    function getRedemptionFeeWithDecay(uint256 _collateralDrawn) external view returns (uint256) {\n        return _calcRedemptionFee(getRedemptionRateWithDecay(), _collateralDrawn);\n    }\n\n    function _calcRedemptionFee(uint256 _redemptionRate, uint256 _collateralDrawn) internal pure returns (uint256) {\n        uint256 redemptionFee = (_redemptionRate * _collateralDrawn) / DECIMAL_PRECISION;\n        require(redemptionFee < _collateralDrawn, \"Fee exceeds returned collateral\");\n        return redemptionFee;\n    }\n\n    // --- Borrowing fee functions ---\n\n    function getBorrowingRate() public view returns (uint256) {\n        return _calcBorrowingRate(baseRate);\n    }\n\n    function getBorrowingRateWithDecay() public view returns (uint256) {\n        return _calcBorrowingRate(_calcDecayedBaseRate());\n    }\n\n    function _calcBorrowingRate(uint256 _baseRate) internal view returns (uint256) {\n        return PrismaMath._min(borrowingFeeFloor + _baseRate, maxBorrowingFee);\n    }\n\n    function getBorrowingFee(uint256 _debt) external view returns (uint256) {\n        return _calcBorrowingFee(getBorrowingRate(), _debt);\n    }\n\n    function getBorrowingFeeWithDecay(uint256 _debt) external view returns (uint256) {\n        return _calcBorrowingFee(getBorrowingRateWithDecay(), _debt);\n    }\n\n    function _calcBorrowingFee(uint256 _borrowingRate, uint256 _debt) internal pure returns (uint256) {\n        return (_borrowingRate * _debt) / DECIMAL_PRECISION;\n    }\n\n    // --- Internal fee functions ---\n\n    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\n    function _updateLastFeeOpTime() internal {\n        uint256 timePassed = block.timestamp - lastFeeOperationTime;\n\n        if (timePassed >= SECONDS_IN_ONE_MINUTE) {\n            lastFeeOperationTime = block.timestamp;\n            emit LastFeeOpTimeUpdated(block.timestamp);\n        }\n    }\n\n    function _calcDecayedBaseRate() internal view returns (uint256) {\n        uint256 minutesPassed = (block.timestamp - lastFeeOperationTime) / SECONDS_IN_ONE_MINUTE;\n        uint256 decayFactor = PrismaMath._decPow(minuteDecayFactor, minutesPassed);\n\n        return (baseRate * decayFactor) / DECIMAL_PRECISION;\n    }\n\n    // --- Redemption functions ---\n\n    /* Send _debtAmount debt to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n     * request.  Applies pending rewards to a Trove before reducing its debt and coll.\n     *\n     * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by\n     * splitting the total _amount in appropriate chunks and calling the function multiple times.\n     *\n     * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to\n     * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”\n     * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode\n     * costs can vary.\n     *\n     * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n     * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.\n     * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position\n     * in the sortedTroves list along with the ICR value that the hint was found for.\n     *\n     * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n     * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n     * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining debt amount, which they can attempt\n     * to redeem later.\n     */\n    function redeemCollateral(\n        uint256 _debtAmount,\n        address _firstRedemptionHint,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint256 _partialRedemptionHintNICR,\n        uint256 _maxIterations,\n        uint256 _maxFeePercentage\n    ) external {\n        ISortedTroves _sortedTrovesCached = sortedTroves;\n        RedemptionTotals memory totals;\n\n        require(\n            _maxFeePercentage >= redemptionFeeFloor && _maxFeePercentage <= maxRedemptionFee,\n            \"Max fee 0.5% to 100%\"\n        );\n        require(block.timestamp >= systemDeploymentTime + BOOTSTRAP_PERIOD, \"BOOTSTRAP_PERIOD\");\n        totals.price = fetchPrice();\n        require(getTCR(totals.price) >= MCR, \"Cannot redeem when TCR < MCR\");\n        require(_debtAmount > 0, \"Amount must be greater than zero\");\n        require(debtToken.balanceOf(msg.sender) >= _debtAmount, \"Insufficient balance\");\n        _updateBalances();\n        totals.totalDebtSupplyAtStart = getEntireSystemDebt();\n\n        totals.remainingDebt = _debtAmount;\n        address currentBorrower;\n\n        if (_isValidFirstRedemptionHint(_sortedTrovesCached, _firstRedemptionHint, totals.price)) {\n            currentBorrower = _firstRedemptionHint;\n        } else {\n            currentBorrower = _sortedTrovesCached.getLast();\n            // Find the first trove with ICR >= MCR\n            while (currentBorrower != address(0) && getCurrentICR(currentBorrower, totals.price) < MCR) {\n                currentBorrower = _sortedTrovesCached.getPrev(currentBorrower);\n            }\n        }\n\n        // Loop through the Troves starting from the one with lowest collateral ratio until _amount of debt is exchanged for collateral\n        if (_maxIterations == 0) {\n            _maxIterations = type(uint256).max;\n        }\n        while (currentBorrower != address(0) && totals.remainingDebt > 0 && _maxIterations > 0) {\n            _maxIterations--;\n            // Save the address of the Trove preceding the current one, before potentially modifying the list\n            address nextUserToCheck = _sortedTrovesCached.getPrev(currentBorrower);\n\n            _applyPendingRewards(currentBorrower);\n            SingleRedemptionValues memory singleRedemption = _redeemCollateralFromTrove(\n                _sortedTrovesCached,\n                currentBorrower,\n                totals.remainingDebt,\n                totals.price,\n                _upperPartialRedemptionHint,\n                _lowerPartialRedemptionHint,\n                _partialRedemptionHintNICR\n            );\n\n            if (singleRedemption.cancelledPartial) break; // Partial redemption was cancelled (out-of-date hint, or new net debt < minimum), therefore we could not redeem from the last Trove\n\n            totals.totalDebtToRedeem = totals.totalDebtToRedeem + singleRedemption.debtLot;\n            totals.totalCollateralDrawn = totals.totalCollateralDrawn + singleRedemption.collateralLot;\n\n            totals.remainingDebt = totals.remainingDebt - singleRedemption.debtLot;\n            currentBorrower = nextUserToCheck;\n        }\n        require(totals.totalCollateralDrawn > 0, \"Unable to redeem any amount\");\n\n        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption.\n        // Use the saved total debt supply value, from before it was reduced by the redemption.\n        _updateBaseRateFromRedemption(totals.totalCollateralDrawn, totals.price, totals.totalDebtSupplyAtStart);\n\n        // Calculate the collateral fee\n        totals.collateralFee = sunsetting ? 0 : _calcRedemptionFee(getRedemptionRate(), totals.totalCollateralDrawn);\n\n        _requireUserAcceptsFee(totals.collateralFee, totals.totalCollateralDrawn, _maxFeePercentage);\n\n        _sendCollateral(PRISMA_CORE.feeReceiver(), totals.collateralFee);\n\n        totals.collateralToSendToRedeemer = totals.totalCollateralDrawn - totals.collateralFee;\n\n        emit Redemption(_debtAmount, totals.totalDebtToRedeem, totals.totalCollateralDrawn, totals.collateralFee);\n\n        // Burn the total debt that is cancelled with debt, and send the redeemed collateral to msg.sender\n        debtToken.burn(msg.sender, totals.totalDebtToRedeem);\n        // Update Trove Manager debt, and send collateral to account\n        totalActiveDebt = totalActiveDebt - totals.totalDebtToRedeem;\n        _sendCollateral(msg.sender, totals.collateralToSendToRedeemer);\n        _resetState();\n    }\n\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for debt up to _maxDebtAmount\n    function _redeemCollateralFromTrove(\n        ISortedTroves _sortedTrovesCached,\n        address _borrower,\n        uint256 _maxDebtAmount,\n        uint256 _price,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint256 _partialRedemptionHintNICR\n    ) internal returns (SingleRedemptionValues memory singleRedemption) {\n        Trove storage t = Troves[_borrower];\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the liquidation reserve\n        singleRedemption.debtLot = PrismaMath._min(_maxDebtAmount, t.debt - DEBT_GAS_COMPENSATION);\n\n        // Get the CollateralLot of equivalent value in USD\n        singleRedemption.collateralLot = (singleRedemption.debtLot * DECIMAL_PRECISION) / _price;\n\n        // Decrease the debt and collateral of the current Trove according to the debt lot and corresponding collateral to send\n        uint256 newDebt = (t.debt) - singleRedemption.debtLot;\n        uint256 newColl = (t.coll) - singleRedemption.collateralLot;\n\n        if (newDebt == DEBT_GAS_COMPENSATION) {\n            // No debt left in the Trove (except for the liquidation reserve), therefore the trove gets closed\n            _removeStake(_borrower);\n            _closeTrove(_borrower, Status.closedByRedemption);\n            _redeemCloseTrove(_borrower, DEBT_GAS_COMPENSATION, newColl);\n            emit TroveUpdated(_borrower, 0, 0, 0, TroveManagerOperation.redeemCollateral);\n        } else {\n            uint256 newNICR = PrismaMath._computeNominalCR(newColl, newDebt);\n            /*\n             * If the provided hint is out of date, we bail since trying to reinsert without a good hint will almost\n             * certainly result in running out of gas.\n             *\n             * If the resultant net debt of the partial is less than the minimum, net debt we bail.\n             */\n\n            {\n                // We check if the ICR hint is reasonable up to date, with continuous interest there might be slight differences (<1bps)\n                uint256 icrError = _partialRedemptionHintNICR > newNICR"
    }
  ]
}