{
  "Title": "[L11] Unused struct",
  "Content": "The `struct` `CollateralCurrencyParameters` declared on [line 33 of `Liquidation.sol`](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/utils/Liquidation.sol#L33) is never used elsewhere in the codebase. Consider removing unused code to improve overall legibility.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/utils/Liquidation.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"./Common.sol\";\nimport \"./ExchangeRate.sol\";\n\nimport \"../lib/SafeInt256.sol\";\nimport \"../lib/SafeMath.sol\";\nimport \"../lib/SafeUInt128.sol\";\n\nimport \"../interface/IPortfoliosCallable.sol\";\nimport \"../storage/EscrowStorage.sol\";\n\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\n\nlibrary Liquidation {\n    using SafeMath for uint256;\n    using SafeInt256 for int256;\n    using SafeUInt128 for uint128;\n\n    // This buffer is used to account for the potential of decimal truncation causing accounts to be\n    // permanently undercollateralized.\n    int256 public constant LIQUIDATION_BUFFER = 1.01e18;\n\n    struct TransferAmounts {\n        int256 netLocalCurrencyLiquidator;\n        uint128 netLocalCurrencyPayer;\n        uint128 collateralTransfer;\n        int256 payerCollateralBalance;\n    }\n\n    struct CollateralCurrencyParameters {\n        uint128 localCurrencyRequired;\n        int256 localCurrencyAvailable;\n        uint16 collateralCurrency;\n        int256 collateralCurrencyCashClaim;\n        int256 collateralCurrencyAvailable;\n        uint128 discountFactor;\n        uint128 liquidityHaircut;\n        IPortfoliosCallable Portfolios;\n    }\n\n    struct RateParameters {\n        uint256 rate;\n        uint16 localCurrency;\n        uint16 collateralCurrency;\n        uint256 localDecimals;\n        uint256 collateralDecimals;\n        ExchangeRate.Rate localToETH;\n    }\n\n    /**\n     * @notice Given an account that has liquidity tokens denominated in the currency, liquidates only enough to\n     * recollateralize the account.\n     * @param payer account that will be liquidated\n     * @param localCurrency that the tokens will be denominated in\n     * @param localCurrencyRequired the amount that we need to liquidate\n     * @param liquidityHaircut the haircut on liquidity tokens\n     * @param localCurrencyNetAvailable the amount of local currency we can liquidate up to\n     * @param Portfolios the portfolio contract to call\n     * @return (\n     *   netLocalCurrencyLiquidator\n     *   netLocalCurrencyPayer\n     *   localCurrencyNetAvailable after the action,\n     *   localCurrencyRequired after action\n     *  )\n     */\n    function _liquidateLocalLiquidityTokens(\n        address payer,\n        uint16 localCurrency,\n        uint128 localCurrencyRequired,\n        uint128 liquidityHaircut,\n        int256 localCurrencyNetAvailable,\n        IPortfoliosCallable Portfolios\n    ) internal returns (int256, uint128, int256, uint128) {\n        // Calculate amount of liquidity tokens to withdraw and do the action.\n        (uint128 cashClaimWithdrawn, uint128 localCurrencyRaised) = Liquidation._localLiquidityTokenTrade(\n            payer,\n            localCurrency,\n            localCurrencyRequired,\n            liquidityHaircut,\n            Portfolios\n        );\n\n        // Calculates relevant parameters post trade.\n        return _calculatePostTradeFactors(\n            cashClaimWithdrawn,\n            localCurrencyNetAvailable,\n            localCurrencyRequired,\n            localCurrencyRaised,\n            liquidityHaircut\n        );\n    }\n\n    /** @notice Trades liquidity tokens in order to attempt to raise `localCurrencyRequired` */\n    function _localLiquidityTokenTrade(\n        address account,\n        uint16 currency,\n        uint128 localCurrencyRequired,\n        uint128 liquidityHaircut,\n        IPortfoliosCallable Portfolios\n    ) internal returns (uint128, uint128) {\n        uint128 liquidityRepoIncentive = EscrowStorageSlot._liquidityTokenRepoIncentive();\n\n        // We can only recollateralize the local currency using the part of the liquidity token that\n        // between the pre-haircut cash claim and the post-haircut cash claim.\n        // cashClaim - cashClaim * haircut = required * (1 + incentive)\n        // cashClaim * (1 - haircut) = required * (1 + incentive)\n        // cashClaim = required * (1 + incentive) / (1 - haircut)\n        uint128 cashClaimsToTrade = SafeCast.toUint128(\n            uint256(localCurrencyRequired)\n                .mul(liquidityRepoIncentive)\n                .div(Common.DECIMALS.sub(liquidityHaircut))\n        );\n\n        uint128 remainder = Portfolios.raiseCurrentCashViaLiquidityToken(\n            account,\n            currency,\n            cashClaimsToTrade\n        );\n\n        uint128 localCurrencyRaised;\n        uint128 cashClaimWithdrawn = cashClaimsToTrade.sub(remainder);\n        if (remainder > 0) {\n            // cashClaim = required * (1 + incentive) / (1 - haircut)\n            // (cashClaim - remainder) = (required - delta) * (1 + incentive) / (1 - haircut)\n            // cashClaimWithdrawn = (required - delta) * (1 + incentive) / (1 - haircut)\n            // cashClaimWithdrawn * (1 - haircut) = (required - delta) * (1 + incentive)\n            // cashClaimWithdrawn * (1 - haircut) / (1 + incentive) = (required - delta) = localCurrencyRaised\n            localCurrencyRaised = SafeCast.toUint128(\n                uint256(cashClaimWithdrawn)\n                    .mul(Common.DECIMALS.sub(liquidityHaircut))\n                    .div(liquidityRepoIncentive)\n            );\n        } else {\n            localCurrencyRaised = localCurrencyRequired;\n        }\n\n        return (cashClaimWithdrawn, localCurrencyRaised);\n    }\n\n    function _calculatePostTradeFactors(\n        uint128 cashClaimWithdrawn,\n        int256 netCurrencyAvailable,\n        uint128 localCurrencyRequired,\n        uint128 localCurrencyRaised,\n        uint128 liquidityHaircut\n    ) internal pure returns (int256, uint128, int256, uint128) {\n        // This is the portion of the cashClaimWithdrawn that is available to recollateralize the account.\n        // cashClaimWithdrawn = value * (1 + incentive) / (1 - haircut)\n        // cashClaimWithdrawn * (1 - haircut) = value * (1 + incentive)\n        uint128 haircutClaimAmount = SafeCast.toUint128(\n            uint256(cashClaimWithdrawn)\n                .mul(Common.DECIMALS.sub(liquidityHaircut))\n                .div(Common.DECIMALS)\n        );\n\n\n        // This is the incentive paid to the liquidator for extracting liquidity tokens.\n        uint128 incentive = haircutClaimAmount.sub(localCurrencyRaised);\n\n        return (\n            int256(incentive).neg(),\n            // This is what will be credited back to the account\n            cashClaimWithdrawn.sub(incentive),\n            // The haircutClaimAmount - incentive is added to netCurrencyAvailable because it is now recollateralizing the account. This\n            // is used in the next step to guard against raising too much local currency (to the point where netCurrencyAvailable is positive)\n            // such that additional local currency does not actually help the account's free collateral position.\n            netCurrencyAvailable.add(haircutClaimAmount).sub(incentive),\n            // The new local currency required is what we required before minus the amount we added to netCurrencyAvailable to\n            // recollateralize the account in the previous step.\n            localCurrencyRequired.add(incentive).sub(haircutClaimAmount)\n        );\n    }\n\n    /**\n     * @notice Liquidates an account, first attempting to extract liquidity tokens then moving on to collateral.\n     * @param payer account that is being liquidated\n     * @param payerCollateralBalance payer's collateral currency account balance\n     * @param fc free collateral factors object\n     * @param rateParam collateral currency exchange rate parameters\n     * @param Portfolios address of portfolio contract to call\n     */\n    function liquidate(\n        address payer,\n        int256 payerCollateralBalance,\n        Common.FreeCollateralFactors memory fc,\n        RateParameters memory rateParam,\n        address Portfolios\n    ) public returns (TransferAmounts memory) {\n        uint128 localCurrencyRequired = _fcAggregateToLocal(fc.aggregate, rateParam);\n\n        TransferAmounts memory transfer = TransferAmounts(0, 0, 0, payerCollateralBalance);\n        uint128 liquidityHaircut = EscrowStorageSlot._liquidityHaircut();\n        if (fc.localCashClaim > 0) {\n            // Account has a local currency cash claim denominated in liquidity tokens. We first extract that here.\n            (\n                transfer.netLocalCurrencyLiquidator,\n                transfer.netLocalCurrencyPayer,\n                fc.localNetAvailable,\n                localCurrencyRequired\n            ) = _liquidateLocalLiquidityTokens(\n                payer,\n                rateParam.localCurrency,\n                localCurrencyRequired,\n                liquidityHaircut,\n                fc.localNetAvailable,\n                IPortfoliosCallable(Portfolios)\n            );\n        }\n\n\n        // If we still require more local currency and we have debts in the local currency then we will trade\n        // collateral currency for local currency here.\n        if (localCurrencyRequired > 0 && fc.localNetAvailable < 0) {\n            _liquidateCollateralCurrency(\n                payer,\n                localCurrencyRequired,\n                liquidityHaircut,\n                transfer,\n                fc,\n                rateParam,\n                Portfolios\n            );\n        }\n\n        return transfer;\n    }\n\n\n    function _fcAggregateToLocal(\n        int256 fcAggregate,\n        RateParameters memory rateParam\n    ) internal view returns (uint128) {\n        // Safety check\n        require(fcAggregate < 0);\n\n        return uint128(\n            ExchangeRate._convertETHTo(\n                rateParam.localToETH,\n                rateParam.localDecimals,\n                fcAggregate.mul(LIQUIDATION_BUFFER).div(Common.DECIMALS).neg()\n            )\n        );\n    }\n\n    /**\n     * @notice Settles current debts using collateral currency. First attempst to raise cash in local currency liquidity tokens before moving\n     * on to collateral currency.\n     * @param payer account that has current debts\n     * @param payerCollateralBalance payer's collateral currency account balance\n     * @param fc free collateral factors object\n     * @param rateParam collateral currency exchange rate parameters\n     * @param Portfolios address of portfolio contract to call\n     */\n    function settle(\n        address payer,\n        int256 payerCollateralBalance,\n        uint128 valueToSettle,\n        Common.FreeCollateralFactors memory fc,\n        RateParameters memory rateParam,\n        address Portfolios\n    ) public returns (TransferAmounts memory) {\n        TransferAmounts memory transfer = TransferAmounts(0, 0, 0, payerCollateralBalance);\n        if (fc.localCashClaim > 0) {\n            uint128 remainder = IPortfoliosCallable(Portfolios).raiseCurrentCashViaLiquidityToken(\n                payer,\n                rateParam.localCurrency,\n                valueToSettle\n            );\n\n            transfer.netLocalCurrencyPayer = valueToSettle.sub(remainder);\n\n            if (transfer.netLocalCurrencyPayer > fc.localCashClaim) {\n                // If this is the case then we've raised cash that sits inside the haircut of the liquidity token\n                // and it will add collateral to the account. We calculate these factors here before moving on.\n                uint128 haircutAmount = transfer.netLocalCurrencyPayer.sub(uint128(fc.localCashClaim));\n\n                int256 netFC = ExchangeRate._convertToETH(\n                    rateParam.localToETH,\n                    rateParam.localDecimals,\n                    haircutAmount,\n                    fc.localNetAvailable < 0\n                );\n\n                fc.aggregate = fc.aggregate.add(netFC);\n            }\n        }\n\n        if (valueToSettle > transfer.netLocalCurrencyPayer && fc.aggregate >= 0) {\n            uint128 liquidityHaircut = EscrowStorageSlot._liquidityHaircut();\n            uint128 settlementDiscount = EscrowStorageSlot._settlementDiscount();\n            uint128 localCurrencyRequired = valueToSettle.sub(transfer.netLocalCurrencyPayer);\n\n            _tradeCollateralCurrency(\n                payer,\n                localCurrencyRequired,\n                liquidityHaircut,\n                settlementDiscount,\n                transfer,\n                fc,\n                rateParam,\n                Portfolios\n            );\n        }\n\n        return transfer;\n    }\n\n    function _calculateLocalCurrencyToTrade(\n        uint128 localCurrencyRequired,\n        uint128 liquidationDiscount,\n        uint128 localCurrencyBuffer,\n        uint128 maxLocalCurrencyDebt\n    ) internal pure returns (uint128) {\n        // We calculate the max amount of local currency that the liquidator can trade for here. We set it to the min of the\n        // netCurrencyAvailable and the localCurrencyToTrade figure calculated below. The math for this figure is as follows:\n\n        // The benefit given to free collateral in local currency terms:\n        //   localCurrencyBenefit = localCurrencyToTrade * localCurrencyBuffer\n        // NOTE: this only holds true while maxLocalCurrencyDebt <= 0\n\n        // The penalty for trading collateral currency in local currency terms:\n        //   localCurrencyPenalty = collateralCurrencyPurchased * exchangeRate[collateralCurrency][localCurrency]\n        //\n        //  netLocalCurrencyBenefit = localCurrencyBenefit - localCurrencyPenalty\n        //\n        // collateralCurrencyPurchased = localCurrencyToTrade * exchangeRate[localCurrency][collateralCurrency] * liquidationDiscount\n        // localCurrencyPenalty = localCurrencyToTrade * exchangeRate[localCurrency][collateralCurrency] * exchangeRate[collateralCurrency][localCurrency] * liquidationDiscount\n        // localCurrencyPenalty = localCurrencyToTrade * liquidationDiscount\n        // netLocalCurrencyBenefit =  localCurrencyToTrade * localCurrencyBuffer - localCurrencyToTrade * liquidationDiscount\n        // netLocalCurrencyBenefit =  localCurrencyToTrade * (localCurrencyBuffer - liquidationDiscount)\n        // localCurrencyToTrade =  netLocalCurrencyBenefit / (buffer - discount)\n        //\n        // localCurrencyRequired is netLocalCurrencyBenefit after removing liquidity tokens\n        // localCurrencyToTrade =  localCurrencyRequired / (buffer - discount)\n\n        uint128 localCurrencyToTrade = SafeCast.toUint128(\n            uint256(localCurrencyRequired)\n                .mul(Common.DECIMALS)\n                .div(localCurrencyBuffer.sub(liquidationDiscount))\n        );\n\n        // We do not trade past the amount of local currency debt the account has or this benefit will not longer be effective.\n        localCurrencyToTrade = maxLocalCurrencyDebt < localCurrencyToTrade ? maxLocalCurrencyDebt : localCurrencyToTrade;\n\n        return localCurrencyToTrade;\n    }\n\n    function _liquidateCollateralCurrency(\n        address payer,\n        uint128 localCurrencyRequired,\n        uint128 liquidityHaircut,\n        TransferAmounts memory transfer,\n        Common.FreeCollateralFactors memory fc,\n        RateParameters memory rateParam,\n        address Portfolios\n    ) internal {\n        uint128 discountFactor = EscrowStorageSlot._liquidationDiscount();\n        localCurrencyRequired = _calculateLocalCurrencyToTrade(\n            localCurrencyRequired,\n            discountFactor,\n            rateParam.localToETH.buffer,\n            uint128(fc.localNetAvailable.neg())\n        );\n\n        _tradeCollateralCurrency(\n            payer,\n            localCurrencyRequired,\n            liquidityHaircut,\n            discountFactor,\n            transfer,\n            fc,\n            rateParam,\n            Portfolios\n        );\n    }\n\n    function _tradeCollateralCurrency(\n        address payer,\n        uint128 localCurrencyRequired,\n        uint128 liquidityHaircut,\n        uint128 discountFactor,\n        TransferAmounts memory transfer,\n        Common.FreeCollateralFactors memory fc,\n        RateParameters memory rateParam,\n        address Portfolios\n    ) internal {\n        uint128 amountToRaise;\n        uint128 localToPurchase;\n\n        uint128 haircutClaim = _calculateLiquidityTokenHaircut(\n            fc.collateralCashClaim,\n            liquidityHaircut\n        );\n\n        int256 collateralToSell = _calculateCollateralToSell(\n            discountFactor,\n            localCurrencyRequired,\n            rateParam\n        );\n\n        // It's possible that collateralToSell is zero even if localCurrencyRequired > 0, this can be caused\n        // by very small amounts of localCurrencyRequired\n        if (collateralToSell == 0) return;\n        \n        int256 balanceAdjustment;\n        (fc.collateralNetAvailable, balanceAdjustment) = _calculatePostfCashValue(fc, transfer);\n        require(fc.collateralNetAvailable > 0, $$(ErrorCode(INSUFFICIENT_BALANCE)));\n\n        (amountToRaise, localToPurchase, transfer.collateralTransfer) = _calculatePurchaseAmounts(\n            localCurrencyRequired,\n            discountFactor,\n            liquidityHaircut,\n            haircutClaim,\n            collateralToSell,\n            fc,\n            rateParam\n        );\n\n        // The result of this calculation is a new collateral currency balance for the payer.\n        transfer.payerCollateralBalance = _calculateCollateralBalances(\n            payer,\n            transfer.payerCollateralBalance.add(balanceAdjustment),\n            rateParam.collateralCurrency,\n            transfer.collateralTransfer,\n            amountToRaise,\n            IPortfoliosCallable(Portfolios)\n        );\n\n        transfer.payerCollateralBalance = transfer.payerCollateralBalance.sub(balanceAdjustment);\n        transfer.netLocalCurrencyPayer = transfer.netLocalCurrencyPayer.add(localToPurchase);\n        transfer.netLocalCurrencyLiquidator = transfer.netLocalCurrencyLiquidator.add(localToPurchase);\n    }\n\n    /**\n     * @notice Calculates collateralNetAvailable and payerCollateralBalance post fCashValue. We do not trade fCashValue\n     * in this scenario so we want to only allow fCashValue to net out against negative collateral balance and no more.\n     */\n    function _calculatePostfCashValue(\n        Common.FreeCollateralFactors memory fc,\n        TransferAmounts memory transfer\n    ) internal pure returns (int256, int256) {\n        int256 fCashValue = fc.collateralNetAvailable\n            .sub(transfer.payerCollateralBalance)\n            .sub(fc.collateralCashClaim);\n\n        if (fCashValue <= 0) {\n            // If we have negative fCashValue then no adjustments are required.\n            return (fc.collateralNetAvailable, 0);\n        }\n\n        if (transfer.payerCollateralBalance >= 0) {\n            // If payer has a positive collateral balance then we don't need to net off against it. We remove\n            // the fCashValue from net available.\n            return (fc.collateralNetAvailable.sub(fCashValue), 0);\n        }\n\n        // In these scenarios the payer has a negative collateral balance and we need to partially offset the balance\n        // so that the payer gets the benefit of their positive fCashValue.\n        int256 netBalanceWithfCashValue = transfer.payerCollateralBalance.add(fCashValue);\n        if (netBalanceWithfCashValue > 0) {\n            // We have more fCashValue than required to net out the balance. We remove the excess from collateralNetAvailable\n            // and adjust the netPayerBalance to zero.\n            return (fc.collateralNetAvailable.sub(netBalanceWithfCashValue), transfer.payerCollateralBalance.neg());\n        } else {\n            // We don't have enough fCashValue to net out the balance. collateralNetAvailable is unchanged because it already takes\n            // into account this netting. We adjust the balance to account for fCash only\n            return (fc.collateralNetAvailable, fCashValue);\n        }\n    }\n\n    function _calculateLiquidityTokenHaircut(\n        int256 postHaircutCashClaim,\n        uint128 liquidityHaircut\n    ) internal pure returns (uint128) {\n        require(postHaircutCashClaim >= 0);\n        // liquidityTokenHaircut = cashClaim / haircut - cashClaim\n        uint256 x = uint256(postHaircutCashClaim);\n\n        return SafeCast.toUint128(\n            uint256(x)\n                .mul(Common.DECIMALS)\n                .div(liquidityHaircut)\n                .sub(x)\n        );\n    }\n\n    function _calculatePurchaseAmounts(\n        uint128 localCurrencyRequired,\n        uint128 discountFactor,\n        uint128 liquidityHaircut,\n        uint128 haircutClaim,\n        int256 collateralToSell,\n        Common.FreeCollateralFactors memory fc,\n        RateParameters memory rateParam\n    ) internal pure returns (uint128, uint128, uint128) {\n        require(fc.collateralNetAvailable > 0, $$(ErrorCode(INSUFFICIENT_BALANCE)));\n\n        uint128 localToPurchase;\n        uint128 amountToRaise;\n        // This calculation is described in Appendix B of the whitepaper. It is split between this function and\n        // _calculateCollateralBalances to deal with stack issues.\n        if (fc.collateralNetAvailable >= collateralToSell) {\n            // We have enough collateral currency available to fulfill the purchase. It is either locked up inside\n            // liquidity tokens or in the account's balance. If the account's balance is negative then we will have\n            // to raise additional amount to fulfill collateralToSell.\n            localToPurchase = localCurrencyRequired;\n        } else if (fc.collateralNetAvailable.add(haircutClaim) >= collateralToSell) {\n            // We have enough collateral currency available if we account for the liquidity token haircut that\n            // is not part of the collateralNetAvailable figure. Here we raise an additional amount. \n\n            // This has to be scaled to the preHaircutCashClaim amount:\n            // haircutClaim = preHaircutCashClaim - preHaircutCashClaim * haircut\n            // haircutClaim = preHaircutCashClaim * (1 - haircut)\n            // liquidiytTokenHaircut / (1 - haircut) = preHaircutCashClaim\n            amountToRaise = SafeCast.toUint128(\n                uint256(collateralToSell.sub(fc.collateralNetAvailable))\n                    .mul(Common.DECIMALS)\n                    .div(Common.DECIMALS.sub(liquidityHaircut))\n            );\n            localToPurchase = localCurrencyRequired;\n        } else if (collateralToSell > fc.collateralNetAvailable.add(haircutClaim)) {\n            // There is not enough value collateral currency in the account to fulfill the purchase, we\n            // specify the maximum amount that we can get from the account to partially settle.\n            collateralToSell = fc.collateralNetAvailable.add(haircutClaim);\n\n            // stack frame isn't big enough for this calculation\n            // haircutClaim * 1e18 / (1e18 - liquidityHaircut), this is the maximum amountToRaise\n            uint256 x = haircutClaim.mul(Common.DECIMALS);\n            x = x.div(Common.DECIMALS.sub(liquidityHaircut));\n            amountToRaise = SafeCast.toUint128(x);\n\n            // In this case we partially settle the collateralToSell amount.\n            require(collateralToSell > 0);\n            localToPurchase = _calculateLocalCurrencyAmount(discountFactor, uint128(collateralToSell), rateParam);\n        }\n\n        require(collateralToSell > 0);\n\n        return (amountToRaise, localToPurchase, uint128(collateralToSell));\n    }\n\n    function _calculateLocalCurrencyAmount(\n        uint128 discountFactor,\n        uint128 collateralToSell,\n        RateParameters memory rateParam\n    ) internal pure returns (uint128) {\n        // collateralDecimals * rateDecimals * 1e18 * localDecimals\n        //         / (rateDecimals * 1e18 * collateralDecimals) = localDecimals\n        uint256 x = uint256(collateralToSell)\n            .mul(rateParam.localToETH.rateDecimals)\n            // Discount factor uses 1e18 as its decimal precision\n            .mul(Common.DECIMALS);\n\n        x = x\n            .mul(rateParam.localDecimals)\n            .div(rateParam.rate);\n\n        return SafeCast.toUint128(x\n            .div(discountFactor)\n            .div(rateParam.collateralDecimals)\n        );\n    }\n\n    function _calculateCollateralToSell(\n        uint128 discountFactor,\n        uint128 localCurrencyRequired,\n        RateParameters memory rateParam\n    ) internal pure returns (uint128) {\n        uint256 x = rateParam.rate\n            .mul(localCurrencyRequired)\n            .mul(discountFactor);\n\n        x = x\n            .div(rateParam.localToETH.rateDecimals)\n            .div(rateParam.localDecimals);\n        \n        // Splitting calculation to handle stack depth\n        return SafeCast.toUint128(x\n            // Multiplying to the quote decimal precision (may not be the same as the rate precision)\n            .mul(rateParam.collateralDecimals)\n            // discountFactor uses 1e18 as its decimal precision\n            .div(Common.DECIMALS)\n        );\n    }\n\n    function _calculateCollateralBalances(\n        address payer,\n        int256 payerBalance,\n        uint16 collateralCurrency,\n        uint128 collateralToSell,\n        uint128 amountToRaise,\n        IPortfoliosCallable Portfolios\n    ) internal returns (int256) {\n        // We must deterimine how to transfer collateral from the payer to liquidator. The collateral may be in cashBalances\n        // or it may be locked up in liquidity tokens.\n        int256 balance = payerBalance;\n        bool creditBalance;\n\n        if (balance >= collateralToSell) {\n            balance = balance.sub(collateralToSell);\n            creditBalance = true;\n        } else {\n            // If amountToRaise is greater than (collateralToSell - balance) this means that we're tapping into the\n            // haircut claim amount. We need to credit back the difference to the account to ensure that the collateral\n            // position does not get worse.\n            int256 x = int256(collateralToSell).sub(balance);\n            require(x > 0);\n            uint128 tmp = uint128(x);\n\n            if (amountToRaise > tmp) {\n                balance = int256(amountToRaise).sub(tmp);\n            } else {\n                amountToRaise = tmp;\n                balance = 0;\n            }\n\n            creditBalance = false;\n        }\n\n        if (amountToRaise > 0) {\n            uint128 remainder = Portfolios.raiseCurrentCashViaLiquidityToken(\n                payer,\n                collateralCurrency,\n                amountToRaise\n            );\n\n            if (creditBalance) {\n                balance = balance.add(amountToRaise).sub(remainder);\n            } else {\n                // Generally we expect remainder to equal zero but this can be off by small amounts due\n                // to truncation in the different calculations on the liquidity token haircuts. The upper bound on\n                // amountToRaise is based on collateralCurrencyAvailable and the balance. Also note that when removing\n                // liquidity tokens some amount of cash receiver is credited back to the account as well. The concern\n                // here is that if this is not true then remainder could put the account into a debt that it cannot pay off.\n                require(remainder <= 1, $$(ErrorCode(RAISING_LIQUIDITY_TOKEN_BALANCE_ERROR)));\n                balance = balance.sub(remainder);\n            }\n        }\n\n        return balance;\n    }\n\n    /**\n     * @notice Settles fCash between local and collateral currency.\n     * @param payer address of account that has current cash debts\n     * @param liquidator address of account liquidating\n     * @param valueToSettle amount of local currency debt to settle\n     * @param collateralNetAvailable net amount of collateral available to trade\n     * @param rateParam exchange rate parameters\n     * @param Portfolios address of the portfolios contract\n     */\n    function settlefCash(\n        address payer,\n        address liquidator,\n        uint128 valueToSettle,\n        int256 collateralNetAvailable,\n        RateParameters memory rateParam,\n        address Portfolios\n    ) public returns (int256, uint128) {\n        uint128 discountFactor = EscrowStorageSlot._settlementDiscount();\n\n        return _tradefCash(\n            payer,\n            liquidator,\n            valueToSettle,\n            collateralNetAvailable,\n            discountFactor,\n            rateParam,\n            Portfolios\n        );\n    }\n\n    /**\n     * @notice Liquidates fCash between local and collateral currency.\n     * @param payer address of account that has current cash debts\n     * @param liquidator address of account liquidating\n     * @param fcAggregate free collateral shortfall denominated in ETH\n     * @param localNetAvailable amount of local currency debts available to recollateralize, dictates max trading amount\n     * @param collateralNetAvailable net amount of collateral available to trade\n     * @param rateParam exchange rate parameters\n     * @param Portfolios address of the portfolios contract\n     */\n    function liquidatefCash(\n        address payer,\n        address liquidator,\n        int256 fcAggregate,\n        int256 localNetAvailable,\n        int256 collateralNetAvailable,\n        RateParameters memory rateParam,\n        address Portfolios\n    ) public returns (int256, uint128) {\n        uint128 localCurrencyRequired = _fcAggregateToLocal(fcAggregate, rateParam);\n        uint128 discountFactor = EscrowStorageSlot._liquidationDiscount();\n        require (localNetAvailable < 0, $$(ErrorCode(INSUFFICIENT_LOCAL_CURRENCY_DEBT)));\n\n        localCurrencyRequired = _calculateLocalCurrencyToTrade(\n            localCurrencyRequired,\n            discountFactor,\n            rateParam.localToETH.buffer,\n            uint128(localNetAvailable.neg())\n        );\n\n        return _tradefCash(\n            payer,\n            liquidator,\n            localCurrencyRequired,\n            collateralNetAvailable,\n            discountFactor,\n            rateParam,\n            Portfolios\n        );\n    }\n\n    /** @notice Trades fCash denominated in collateral currency in exchange for local currency. */\n    function _tradefCash(\n        address payer,\n        address liquidator,\n        uint128 localCurrencyRequired,\n        int256 collateralNetAvailable,\n        uint128 discountFactor,\n        RateParameters memory rateParam,\n        address Portfolios\n    ) internal returns (int256, uint128) {\n        require(collateralNetAvailable > 0, $$(ErrorCode(MUST_HAVE_NET_POSITIVE_COLLATERAL)));\n\n        uint128 collateralCurrencyRequired = _calculateCollateralToSell(discountFactor, localCurrencyRequired, rateParam);\n        if (collateralCurrencyRequired > collateralNetAvailable) {\n            // We limit trading to the amount of collateralNetAvailable so that we don't put the account further undercollateralized\n            // in the collateral currency.\n            collateralCurrencyRequired = uint128(collateralNetAvailable);\n            localCurrencyRequired = _calculateLocalCurrencyAmount(\n                discountFactor,\n                collateralCurrencyRequired,\n                rateParam\n            );\n        }\n\n        (uint128 shortfall, uint128 liquidatorPayment) = IPortfoliosCallable(Portfolios).raiseCurrentCashViaCashReceiver(\n            payer,\n            liquidator,\n            rateParam.collateralCurrency,\n            collateralCurrencyRequired\n        );\n\n        int256 netCollateralCurrencyLiquidator = int256(liquidatorPayment).sub(collateralCurrencyRequired.sub(shortfall));\n\n        uint128 netLocalCurrencyPayer = localCurrencyRequired;\n        if (shortfall > 0) {\n            // (rate * discountFactor * (localCurrencyRequired - localShortfall)) = (collateralToSell - shortfall)\n            // (rate * discountFactor * localShortfall) = shortfall\n            // shortfall / (rate * discountFactor) = localCurrencyShortfall\n            uint128 localCurrencyShortfall = \n                _calculateLocalCurrencyAmount(\n                    discountFactor,\n                    shortfall,\n                    rateParam\n                );\n\n            netLocalCurrencyPayer = netLocalCurrencyPayer.sub(localCurrencyShortfall);\n        }\n\n        return (netCollateralCurrencyLiquidator, netLocalCurrencyPayer);\n    }\n}"
    }
  ]
}