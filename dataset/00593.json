{
  "Title": "Encapsulation Recommendation",
  "Content": "There are several examples throughout the codebase where rendering functions make strong assumptions about how and when they are called. For example, the [`renderDecodeDynamicFieldPartial` function](https://github.com/latticexyz/mud/blob/f6133591a86eb169a7b1b2b8d342733a887af610/packages/store/ts/codegen/record.ts#L275) assumes that the `_blob`, `_start` and `_end` variables exist, and that `SliceLib` will be available. While the example is intended to illustrate the claim, this pattern is a broad feature of the entire codebase, which is error-prone and makes local reasoning difficult.\n\n\nThe rest of this report includes suggestions for specific trivial simplifications, but we also believe that the codebase could benefit from a more structured approach. Our core recommendation is to make extensive use of TypeScript objects instead of strings to accumulate and synthesize business logic. The final rendering should focus entirely on describing the object in Solidity syntax.\n\n\nFor example, there could be a `SolidityFunction` object that individually tracks comments, input arguments, return values, local variables, visibility, etc. The arguments would also be objects that track type, location and name. Possible advantages include:\n\n\n* The body of the function could reference specific named parameters or local variables. If the variable did not exist, it would raise an error.\n* Functions could only invoke other functions if they exist in the higher `SolidityContract` object.\n* Instead of using [configurable callbacks](https://github.com/latticexyz/mud/blob/66728380b7a2d5d4b2a1473cc733258e753febb0/packages/common/src/codegen/render-solidity/common.ts#L140-L145) to create similar functions, the object could simply be copied and modified to add new parameters or return values.\n* The objects could use partial (or [`Pick`](https://www.typescriptlang.org/docs/handbook/utility-types.html#picktype-keys)) types to clearly indicate partially complete structures.\n\n\nConsider restructuring the rendering code to focus on manipulating TypeScript objects instead of strings.\n\n\n***Update:** Acknowledged, not resolved. The Lattice Labs team stated:*\n\n\n\n> *We are going to punt on this because we believe that an object-oriented approach may be meaningful for a standalone library designed for generating arbitrary solidity code. On the other hand, MUD codegen has a very narrow purpose and most of its functions are not meant for external use. Overly generalising it will complicate its development and maintenance with little benefit to the MUD codebase.*\n> \n> \n> *A `SolidityFunction` object could be a full AST which requires unparsing it (using slang, which is in alpha, or writing our own unparser). This removes any context assumptions but adds a lot of code. This also does not create typescript compile-time typechecks. An object with some structured properties (like arguments, name, comment, etc.) and an unstructured body. The body has to allow many possible operations besides assignment.*\n> \n> \n> *This slightly isolates context assumptions, but at the cost of replacing simple strings with complicated objects, and additional helpers that work on said objects. A `SolidityContract` object would only be meaningful for `renderTable`, which is redundant - it would verify imports and variables which are mostly static and verified by the Solidity compiler.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/store/ts/codegen/record.ts",
      "content": "import {\n  RenderDynamicField,\n  renderArguments,\n  renderCommonData,\n  renderList,\n  renderWithStore,\n} from \"@latticexyz/common/codegen\";\nimport { renderDecodeValueType } from \"./field\";\nimport { RenderTableOptions } from \"./types\";\n\nexport function renderRecordMethods(options: RenderTableOptions) {\n  const { structName, storeArgument } = options;\n  const { _typedTableId, _typedKeyArgs, _keyTupleDefinition } = renderCommonData(options);\n\n  let result = \"\";\n\n  if (options.withGetters) {\n    result += renderWithStore(\n      storeArgument,\n      (_typedStore, _store, _commentSuffix, _untypedStore, _methodNamePrefix) => `\n        /**\n         * @notice Get the full data${_commentSuffix}.\n         */\n        function ${_methodNamePrefix}get(${renderArguments([\n        _typedStore,\n        _typedTableId,\n        _typedKeyArgs,\n      ])}) internal view returns (${renderDecodedRecord(options)}) {\n          ${_keyTupleDefinition}\n          \n          (\n            bytes memory _staticData,\n            PackedCounter _encodedLengths,\n            bytes memory _dynamicData\n            ) = ${_store}.getRecord(_tableId, _keyTuple, _fieldLayout);\n            return decode(_staticData, _encodedLengths, _dynamicData);\n          }\n        `\n    );\n  }\n\n  result += renderWithStore(\n    storeArgument,\n    (_typedStore, _store, _commentSuffix, _untypedStore, _methodNamePrefix, _internal) => {\n      const externalArguments = renderArguments([\n        _typedStore,\n        _typedTableId,\n        _typedKeyArgs,\n        renderArguments(options.fields.map(({ name, typeWithLocation }) => `${typeWithLocation} ${name}`)),\n      ]);\n\n      const internalArguments =\n        \"_tableId, _keyTuple, _staticData, _encodedLengths, _dynamicData\" + (_internal ? \", _fieldLayout\" : \"\");\n\n      return `\n        /** \n         * @notice Set the full data using individual values${_commentSuffix}.\n         */\n        function ${_methodNamePrefix}set(${externalArguments}) internal {\n          ${renderRecordData(options)}\n\n          ${_keyTupleDefinition}\n\n          ${_store}.setRecord(${internalArguments});\n        }\n    `;\n    }\n  );\n\n  if (structName !== undefined) {\n    result += renderWithStore(\n      storeArgument,\n      (_typedStore, _store, _commentSuffix, _untypedStore, _methodNamePrefix, _internal) => {\n        const externalArguments = renderArguments([\n          _typedStore,\n          _typedTableId,\n          _typedKeyArgs,\n          `${structName} memory _table`,\n        ]);\n\n        const internalArguments =\n          \"_tableId, _keyTuple, _staticData, _encodedLengths, _dynamicData\" + (_internal ? \", _fieldLayout\" : \"\");\n\n        return `\n          /**\n           * @notice Set the full data using the data struct${_commentSuffix}.\n           */\n          function ${_methodNamePrefix}set(${externalArguments}) internal {\n            ${renderRecordData(options, \"_table.\")}\n\n            ${_keyTupleDefinition}\n\n            ${_store}.setRecord(${internalArguments});\n          }\n      `;\n      }\n    );\n  }\n\n  result += renderDecodeFunctions(options);\n\n  return result;\n}\n\nexport function renderRecordData(options: RenderTableOptions, namePrefix = \"\") {\n  let result = \"\";\n  if (options.staticFields.length > 0) {\n    result += `\n      bytes memory _staticData = encodeStatic(\n        ${renderArguments(options.staticFields.map(({ name }) => `${namePrefix}${name}`))}\n      );\n    `;\n  } else {\n    result += `bytes memory _staticData;`;\n  }\n\n  if (options.dynamicFields.length > 0) {\n    result += `\n      PackedCounter _encodedLengths = encodeLengths(\n        ${renderArguments(options.dynamicFields.map(({ name }) => `${namePrefix}${name}`))}\n      );\n      bytes memory _dynamicData = encodeDynamic(\n        ${renderArguments(options.dynamicFields.map(({ name }) => `${namePrefix}${name}`))}\n      );\n    `;\n  } else {\n    result += `\n      PackedCounter _encodedLengths;\n      bytes memory _dynamicData;\n    `;\n  }\n\n  return result;\n}\n\nexport function renderDeleteRecordMethods(options: RenderTableOptions) {\n  const { storeArgument } = options;\n  const { _typedTableId, _typedKeyArgs, _keyTupleDefinition } = renderCommonData(options);\n\n  return renderWithStore(\n    storeArgument,\n    (_typedStore, _store, _commentSuffix, _untypedStore, _methodNamePrefix, _internal) => {\n      const externalArguments = renderArguments([_typedStore, _typedTableId, _typedKeyArgs]);\n      const internalArguments = \"_tableId, _keyTuple\" + (_internal ? \", _fieldLayout\" : \"\");\n\n      return `\n      /** \n       * @notice Delete all data for given keys${_commentSuffix}.\n       */\n      function ${_methodNamePrefix}deleteRecord(${externalArguments}) internal {\n        ${_keyTupleDefinition}\n        ${_store}.deleteRecord(${internalArguments});\n      }\n    `;\n    }\n  );\n}\n\n// Renders the `decode` function that parses a bytes blob into the table data\nfunction renderDecodeFunctions({ structName, fields, staticFields, dynamicFields }: RenderTableOptions) {\n  // either set struct properties, or just variables\n  const renderedDecodedRecord = structName\n    ? `${structName} memory _table`\n    : renderArguments(fields.map(({ name, typeWithLocation }) => `${typeWithLocation} ${name}`));\n  const fieldNamePrefix = structName ? \"_table.\" : \"\";\n\n  // Static field offsets\n  const staticOffsets = staticFields.map(() => 0);\n  let _acc = 0;\n  for (const [index, field] of staticFields.entries()) {\n    staticOffsets[index] = _acc;\n    _acc += field.staticByteLength;\n  }\n\n  let result = \"\";\n\n  if (staticFields.length > 0) {\n    result += `\n      /**\n       * @notice Decode the tightly packed blob of static data using this table's field layout.\n       */\n      function decodeStatic(bytes memory _blob) internal pure returns (${renderArguments(\n        staticFields.map(({ name, typeWithLocation }) => `${typeWithLocation} ${name}`)\n      )}) {\n        ${renderList(\n          staticFields,\n          (field, index) => `\n          ${field.name} = ${renderDecodeValueType(field, staticOffsets[index])};\n          `\n        )}\n      }\n    `;\n  }\n\n  if (dynamicFields.length > 0) {\n    result += `\n      /**\n       * @notice Decode the tightly packed blob of dynamic data using the encoded lengths.\n       */\n      function decodeDynamic(PackedCounter _encodedLengths, bytes memory _blob) internal pure returns (${renderArguments(\n        dynamicFields.map(({ name, typeWithLocation }) => `${typeWithLocation} ${name}`)\n      )}) {\n        ${renderList(\n          dynamicFields,\n          // unchecked is only dangerous if _encodedLengths (and _blob) is invalid,\n          // but it's assumed to be valid, and this function is meant to be mostly used internally\n          (field, index) => {\n            if (index === 0) {\n              return `\n                uint256 _start;\n                uint256 _end;\n                unchecked {\n                  _end = _encodedLengths.atIndex(${index});\n                }\n                ${field.name} = ${renderDecodeDynamicFieldPartial(field)};\n              `;\n            } else {\n              return `\n                _start = _end;\n                unchecked {\n                  _end += _encodedLengths.atIndex(${index});\n                }\n                ${field.name} = ${renderDecodeDynamicFieldPartial(field)};\n              `;\n            }\n          }\n        )}\n      }\n    `;\n  }\n\n  result += `\n    /**\n     * @notice Decode the tightly packed blobs using this table's field layout.\n     * ${staticFields.length > 0 ? \"@param _staticData Tightly packed static fields.\" : \"\"}\n    * ${dynamicFields.length > 0 ? \"@param _encodedLengths Encoded lengths of dynamic fields.\" : \"\"}\n    * ${dynamicFields.length > 0 ? \"@param _dynamicData Tightly packed dynamic fields.\" : \"\"}\n    */\n    function decode(\n      bytes memory ${staticFields.length > 0 ? \"_staticData\" : \"\"},\n      PackedCounter ${dynamicFields.length > 0 ? \"_encodedLengths\" : \"\"},\n      bytes memory ${dynamicFields.length > 0 ? \"_dynamicData\" : \"\"}\n    ) internal pure returns (${renderedDecodedRecord}) {\n  `;\n\n  if (staticFields.length > 0) {\n    result += `\n      (${renderArguments(staticFields.map((field) => `${fieldNamePrefix}${field.name}`))}) = decodeStatic(_staticData);\n    `;\n  }\n  if (dynamicFields.length > 0) {\n    result += `\n      (${renderArguments(\n        dynamicFields.map((field) => `${fieldNamePrefix}${field.name}`)\n      )}) = decodeDynamic(_encodedLengths, _dynamicData);\n    `;\n  }\n\n  result += `\n    }\n  `;\n\n  return result;\n}\n\n// contents of `returns (...)` for record getter/decoder\nfunction renderDecodedRecord({ structName, fields }: RenderTableOptions) {\n  if (structName) {\n    return `${structName} memory _table`;\n  } else {\n    return renderArguments(fields.map(({ name, typeWithLocation }) => `${typeWithLocation} ${name}`));\n  }\n}\n\nfunction renderDecodeDynamicFieldPartial(field: RenderDynamicField) {\n  const { typeId, arrayElement, typeWrap } = field;\n  if (arrayElement) {\n    // arrays\n    return `${typeWrap}(\n      SliceLib.getSubslice(_blob, _start, _end).decodeArray_${arrayElement.typeId}()\n    )`;\n  } else {\n    // bytes/string\n    return `${typeWrap}(\n      ${typeId}(\n        SliceLib.getSubslice(_blob, _start, _end).toBytes()\n      )\n    )`;\n  }\n}"
    },
    {
      "filename": "packages/common/src/codegen/render-solidity/common.ts",
      "content": "import path from \"path\";\nimport {\n  AbsoluteImportDatum,\n  RelativeImportDatum,\n  ImportDatum,\n  StaticResourceData,\n  RenderKeyTuple,\n  RenderType,\n} from \"./types\";\nimport { posixPath } from \"../utils\";\n\nexport const renderedSolidityHeader = `// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\n/* Autogenerated file. Do not edit manually. */`;\n\n/**\n * Renders a list of lines\n */\nexport function renderList<T>(list: T[], renderItem: (item: T, index: number) => string): string {\n  return internalRenderList(\"\", list, renderItem);\n}\n\n/**\n * Renders a comma-separated list of arguments for solidity functions, ignoring empty and undefined ones\n */\nexport function renderArguments(args: (string | undefined)[]): string {\n  const filteredArgs = args.filter((arg) => arg !== undefined && arg !== \"\") as string[];\n  return internalRenderList(\",\", filteredArgs, (arg) => arg);\n}\n\nexport function renderCommonData({\n  staticResourceData,\n  keyTuple,\n}: {\n  staticResourceData?: StaticResourceData;\n  keyTuple: RenderKeyTuple[];\n}): {\n  _tableId: string;\n  _typedTableId: string;\n  _keyArgs: string;\n  _typedKeyArgs: string;\n  _keyTupleDefinition: string;\n} {\n  // static resource means static tableId as well, and no tableId arguments\n  const _tableId = staticResourceData ? \"\" : \"_tableId\";\n  const _typedTableId = staticResourceData ? \"\" : \"ResourceId _tableId\";\n\n  const _keyArgs = renderArguments(keyTuple.map(({ name }) => name));\n  const _typedKeyArgs = renderArguments(keyTuple.map(({ name, typeWithLocation }) => `${typeWithLocation} ${name}`));\n\n  const _keyTupleDefinition = `\n    bytes32[] memory _keyTuple = new bytes32[](${keyTuple.length});\n    ${renderList(keyTuple, (key, index) => `_keyTuple[${index}] = ${renderValueTypeToBytes32(key.name, key)};`)}\n  `;\n\n  return {\n    _tableId,\n    _typedTableId,\n    _keyArgs,\n    _typedKeyArgs,\n    _keyTupleDefinition,\n  };\n}\n\n/** For 2 paths which are relative to a common root, create a relative import path from one to another */\nexport function solidityRelativeImportPath(fromPath: string, usedInPath: string): string {\n  // 1st \"./\" must be added because path strips it,\n  // but solidity expects it unless there's \"../\" (\"./../\" is fine).\n  // 2nd and 3rd \"./\" forcefully avoid absolute paths (everything is relative to `src`).\n  return posixPath(\"./\" + path.relative(\"./\" + usedInPath, \"./\" + fromPath));\n}\n\n/**\n * Aggregates, deduplicates and renders imports for symbols per path.\n * Identical symbols from different paths are NOT handled, they should be checked before rendering.\n */\nexport function renderImports(imports: ImportDatum[]): string {\n  return renderAbsoluteImports(\n    imports.map((importDatum) => {\n      if (\"path\" in importDatum) {\n        return importDatum;\n      } else {\n        return {\n          symbol: importDatum.symbol,\n          path: solidityRelativeImportPath(importDatum.fromPath, importDatum.usedInPath),\n        };\n      }\n    })\n  );\n}\n\n/**\n * Aggregates, deduplicates and renders imports for symbols per path.\n * Identical symbols from different paths are NOT handled, they should be checked before rendering.\n */\nexport function renderRelativeImports(imports: RelativeImportDatum[]): string {\n  return renderAbsoluteImports(\n    imports.map(({ symbol, fromPath, usedInPath }) => ({\n      symbol,\n      path: solidityRelativeImportPath(fromPath, usedInPath),\n    }))\n  );\n}\n\n/**\n * Aggregates, deduplicates and renders imports for symbols per path.\n * Identical symbols from different paths are NOT handled, they should be checked before rendering.\n */\nexport function renderAbsoluteImports(imports: AbsoluteImportDatum[]): string {\n  // Aggregate symbols by import path, also deduplicating them\n  const aggregatedImports = new Map<string, Set<string>>();\n  for (const { symbol, path } of imports) {\n    if (!aggregatedImports.has(path)) {\n      aggregatedImports.set(path, new Set());\n    }\n    aggregatedImports.get(path)?.add(symbol);\n  }\n  // Render imports\n  const renderedImports = [];\n  for (const [path, symbols] of aggregatedImports) {\n    const renderedSymbols = [...symbols].join(\", \");\n    renderedImports.push(`import { ${renderedSymbols} } from \"${posixPath(path)}\";`);\n  }\n  return renderedImports.join(\"\\n\");\n}\n\nexport function renderWithStore(\n  storeArgument: boolean,\n  callback: (\n    _typedStore: string | undefined,\n    _store: string,\n    _commentSuffix: string,\n    _untypedStore: string | undefined,\n    _methodPrefix: string,\n    _internal?: boolean\n  ) => string\n): string {\n  let result = \"\";\n  result += callback(undefined, \"StoreSwitch\", \"\", undefined, \"\");\n  result += callback(undefined, \"StoreCore\", \"\", undefined, \"_\", true);\n\n  if (storeArgument) {\n    result += \"\\n\" + callback(\"IStore _store\", \"_store\", \" (using the specified store)\", \"_store\", \"\");\n  }\n\n  return result;\n}\n\nexport function renderWithFieldSuffix(\n  withSuffixlessFieldMethods: boolean,\n  fieldName: string,\n  callback: (_methodNameSuffix: string) => string\n): string {\n  const methodNameSuffix = `${fieldName[0].toUpperCase()}${fieldName.slice(1)}`;\n  let result = \"\";\n  result += callback(methodNameSuffix);\n\n  if (withSuffixlessFieldMethods) {\n    result += \"\\n\" + callback(\"\");\n  }\n\n  return result;\n}\n\nexport function renderTableId({ namespace, name, offchainOnly, tableIdName }: StaticResourceData): {\n  hardcodedTableId: string;\n  tableIdDefinition: string;\n} {\n  const hardcodedTableId = `\n    ResourceId.wrap(\n      bytes32(\n        abi.encodePacked(\n          ${offchainOnly ? \"RESOURCE_OFFCHAIN_TABLE\" : \"RESOURCE_TABLE\"},\n          bytes14(\"${namespace}\"),\n          bytes16(\"${name}\")\n        )\n      )\n    )\n  `;\n\n  const tableIdDefinition = `\n    ResourceId constant _tableId = ${hardcodedTableId};\n    ResourceId constant ${tableIdName} = _tableId;\n  `;\n  return {\n    hardcodedTableId,\n    tableIdDefinition,\n  };\n}\n\nexport function renderValueTypeToBytes32(name: string, { typeUnwrap, internalTypeId }: RenderType): string {\n  const innerText = typeUnwrap.length ? `${typeUnwrap}(${name})` : name;\n\n  if (internalTypeId === \"bytes32\") {\n    return innerText;\n  } else if (internalTypeId.match(/^bytes\\d{1,2}$/)) {\n    return `bytes32(${innerText})`;\n  } else if (internalTypeId.match(/^uint\\d{1,3}$/)) {\n    return `bytes32(uint256(${innerText}))`;\n  } else if (internalTypeId.match(/^int\\d{1,3}$/)) {\n    return `bytes32(uint256(int256(${innerText})))`;\n  } else if (internalTypeId === \"address\") {\n    return `bytes32(uint256(uint160(${innerText})))`;\n  } else if (internalTypeId === \"bool\") {\n    return `_boolToBytes32(${innerText})`;\n  } else {\n    throw new Error(`Unknown value type id ${internalTypeId}`);\n  }\n}\n\nexport function isLeftAligned(field: Pick<RenderType, \"internalTypeId\">): boolean {\n  return field.internalTypeId.match(/^bytes\\d{1,2}$/) !== null;\n}\n\nexport function getLeftPaddingBits(field: Pick<RenderType, \"internalTypeId\" | \"staticByteLength\">): number {\n  if (isLeftAligned(field)) {\n    return 0;\n  } else {\n    return 256 - field.staticByteLength * 8;\n  }\n}\n\nfunction internalRenderList<T>(\n  lineTerminator: string,\n  list: T[],\n  renderItem: (item: T, index: number) => string\n): string {\n  return list\n    .map((item, index) => renderItem(item, index) + (index === list.length - 1 ? \"\" : lineTerminator))\n    .join(\"\\n\");\n}"
    }
  ]
}