{
  "Title": "Outdated Interest Rates",
  "Content": "In the `CToken` contract, [borrowRatePerBlock](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/CToken.sol#L410) and [supplyRatePerBlock](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/CToken.sol#L420) are supposed to return the current rates but they may be outdated. This is because those rates depend on variables that are updated when `accrueInterest` is called. Consider calling [`accrueInterest`](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/CToken.sol#L597) at the beginning of these functions.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/CToken.sol",
      "content": "pragma solidity ^0.5.8;\n\nimport \"./ComptrollerInterface.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./Exponential.sol\";\nimport \"./EIP20Interface.sol\";\nimport \"./EIP20NonStandardInterface.sol\";\nimport \"./ReentrancyGuard.sol\";\nimport \"./InterestRateModel.sol\";\n\n/**\n * @title Compound's CToken Contract\n * @notice Abstract base for CTokens\n * @author Compound\n */\ncontract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {\n    /**\n     * @notice Indicator that this is a CToken contract (for inspection)\n     */\n    bool public constant isCToken = true;\n\n    /**\n     * @notice EIP-20 token name for this token\n     */\n    string public name;\n\n    /**\n     * @notice EIP-20 token symbol for this token\n     */\n    string public symbol;\n\n    /**\n     * @notice EIP-20 token decimals for this token\n     */\n    uint public decimals;\n\n    /**\n     * @notice Maximum borrow rate that can ever be applied (.0005% / block)\n     */\n    uint constant borrowRateMaxMantissa = 5e14;\n\n    /**\n     * @notice Maximum fraction of interest that can be set aside for reserves\n     */\n    uint constant reserveFactorMaxMantissa = 1e18;\n\n    /**\n     * @notice Administrator for this contract\n     */\n    address payable public admin;\n\n    /**\n     * @notice Pending administrator for this contract\n     */\n    address payable public pendingAdmin;\n\n    /**\n     * @notice Contract which oversees inter-cToken operations\n     */\n    ComptrollerInterface public comptroller;\n\n    /**\n     * @notice Model which tells what the current interest rate should be\n     */\n    InterestRateModel public interestRateModel;\n\n    /**\n     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)\n     */\n    uint public initialExchangeRateMantissa;\n\n    /**\n     * @notice Fraction of interest currently set aside for reserves\n     */\n    uint public reserveFactorMantissa;\n\n    /**\n     * @notice Block number that interest was last accrued at\n     */\n    uint public accrualBlockNumber;\n\n    /**\n     * @notice Accumulator of total earned interest since the opening of the market\n     */\n    uint public borrowIndex;\n\n    /**\n     * @notice Total amount of outstanding borrows of the underlying in this market\n     */\n    uint public totalBorrows;\n\n    /**\n     * @notice Total amount of reserves of the underlying held in this market\n     */\n    uint public totalReserves;\n\n    /**\n     * @notice Total number of tokens in circulation\n     */\n    uint256 public totalSupply;\n\n    /**\n     * @notice Official record of token balances for each account\n     */\n    mapping (address => uint256) accountTokens;\n\n    /**\n     * @notice Approved token transfer amounts on behalf of others\n     */\n    mapping (address => mapping (address => uint256)) transferAllowances;\n\n    /**\n     * @notice Container for borrow balance information\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\n     */\n    struct BorrowSnapshot {\n        uint principal;\n        uint interestIndex;\n    }\n\n    /**\n     * @notice Mapping of account addresses to outstanding borrow balances\n     */\n    mapping(address => BorrowSnapshot) accountBorrows;\n\n\n    /*** Market Events ***/\n\n    /**\n     * @notice Event emitted when interest is accrued\n     */\n    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);\n\n    /**\n     * @notice Event emitted when tokens are minted\n     */\n    event Mint(address minter, uint mintAmount, uint mintTokens);\n\n    /**\n     * @notice Event emitted when tokens are redeemed\n     */\n    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);\n\n    /**\n     * @notice Event emitted when underlying is borrowed\n     */\n    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);\n\n    /**\n     * @notice Event emitted when a borrow is repaid\n     */\n    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);\n\n    /**\n     * @notice Event emitted when a borrow is liquidated\n     */\n    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);\n\n\n    /*** Admin Events ***/\n\n    /**\n     * @notice Event emitted when pendingAdmin is changed\n     */\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /**\n     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated\n     */\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /**\n     * @notice Event emitted when comptroller is changed\n     */\n    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);\n\n    /**\n     * @notice Event emitted when interestRateModel is changed\n     */\n    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);\n\n    /**\n     * @notice Event emitted when the reserve factor is changed\n     */\n    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);\n\n    /**\n     * @notice Event emitted when the reserves are reduced\n     */\n    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);\n\n\n    /**\n     * @notice Construct a new money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ EIP-20 name of this token\n     * @param symbol_ EIP-20 symbol of this token\n     * @param decimals_ EIP-20 decimal precision of this token\n     */\n    constructor(ComptrollerInterface comptroller_,\n                InterestRateModel interestRateModel_,\n                uint initialExchangeRateMantissa_,\n                string memory name_,\n                string memory symbol_,\n                uint decimals_) internal {\n        // Set admin to msg.sender\n        admin = msg.sender;\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n        // Set the comptroller\n        uint err = _setComptroller(comptroller_);\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = mantissaOne;\n\n        // Set the interest rate model (depends on block number / borrow index)\n        err = _setInterestRateModelFresh(interestRateModel_);\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n    }\n\n    /**\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n     * @dev Called by both `transfer` and `transferFrom` internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n        /* Fail if transfer not allowed */\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Do not allow self-transfers */\n        if (src == dst) {\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        /* Get the allowance, infinite for the account owner */\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint(-1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        /* Do the calculations, checking for {under,over}flow */\n        MathError mathErr;\n        uint allowanceNew;\n        uint srcTokensNew;\n        uint dstTokensNew;\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n        }\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        /* Eat some of the allowance (if necessary) */\n        if (startingAllowance != uint(-1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n\n        /* We emit a Transfer event */\n        emit Transfer(src, dst, tokens);\n\n        /* We call the defense hook (which checks for under-collateralization) */\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (-1 means infinite)\n     */\n    function allowance(address owner, address spender) external view returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /**\n     * @notice Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) external view returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) external returns (uint) {\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        require(mErr == MathError.NO_ERROR);\n        return balance;\n    }\n\n    /**\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n     */\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n        uint cTokenBalance = accountTokens[account];\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n\n        MathError mErr;\n\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);\n    }\n\n    /**\n     * @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     */\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n\n    /**\n     * @notice Returns the current per-block borrow interest rate for this cToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() external view returns (uint) {\n        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n        return borrowRateMantissa;\n    }\n\n    /**\n     * @notice Returns the current per-block supply interest rate for this cToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() external view returns (uint) {\n        /* We calculate the supply rate:\n         *  underlying = totalSupply × exchangeRate\n         *  borrowsPer = totalBorrows ÷ underlying\n         *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer\n         */\n        uint exchangeRateMantissa = exchangeRateStored();\n\n        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n\n        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);\n        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n\n        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);\n        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n\n        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));\n        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n\n        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);\n        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n\n        return supplyRate.mantissa;\n    }\n\n    /**\n     * @notice Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     */\n    function totalBorrowsCurrent() external nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n        return totalBorrows;\n    }\n\n    /**\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n        return borrowBalanceStored(account);\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return The calculated balance\n     */\n    function borrowBalanceStored(address account) public view returns (uint) {\n        (MathError err, uint result) = borrowBalanceStoredInternal(account);\n        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n        return result;\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     */\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n        /* Note: we do not assert that the market is up to date */\n        MathError mathErr;\n        uint principalTimesIndex;\n        uint result;\n\n        /* Get borrowBalance and borrowIndex */\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         */\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        /* Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         */\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, result);\n    }\n\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n        return exchangeRateStored();\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() public view returns (uint) {\n        (MathError err, uint result) = exchangeRateStoredInternal();\n        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n        return result;\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return (error code, calculated exchange rate scaled by 1e18)\n     */\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n        if (totalSupply == 0) {\n            /*\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             */\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /*\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             */\n            uint totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n\n    /**\n     * @notice Get cash balance of this cToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() external view returns (uint) {\n        return getCashPrior();\n    }\n\n    struct AccrueInterestLocalVars {\n        MathError mathErr;\n        uint opaqueErr;\n        uint borrowRateMantissa;\n        uint currentBlockNumber;\n        uint blockDelta;\n\n        Exp simpleInterestFactor;\n\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n        uint totalReservesNew;\n        uint borrowIndexNew;\n    }\n\n    /**\n      * @notice Applies accrued interest to total borrows and reserves.\n      * @dev This calculates interest accrued from the last checkpointed block\n      *      up to the current block and writes new checkpoint to storage.\n      */\n    function accrueInterest() public returns (uint) {\n        AccrueInterestLocalVars memory vars;\n\n        /* Calculate the current borrow interest rate */\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n        if (vars.opaqueErr != 0) {\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n        }\n\n        /* Remember the initial block number */\n        vars.currentBlockNumber = getBlockNumber();\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n        /*\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         */\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        accrualBlockNumber = vars.currentBlockNumber;\n        borrowIndex = vars.borrowIndexNew;\n        totalBorrows = vars.totalBorrowsNew;\n        totalReserves = vars.totalReservesNew;\n\n        /* We emit an AccrueInterest event */\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);\n        }\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        return mintFresh(msg.sender, mintAmount);\n    }\n\n    struct MintLocalVars {\n        Error err;\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n\n    /**\n     * @notice User supplies assets into the market and receives cTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function mintFresh(address minter, uint mintAmount) internal returns (uint) {\n        /* Fail if mint not allowed */\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n        }\n\n        MintLocalVars memory vars;\n\n        /* Fail if checkTransferIn fails */\n        vars.err = checkTransferIn(minter, mintAmount);\n        if (vars.err != Error.NO_ERROR) {\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n        }\n\n        /*\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n         *  mintTokens = mintAmount / exchangeRate\n         */\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        /*\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         */\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We call doTransferIn for the minter and the mintAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional mintAmount of cash.\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n         *   we revert because we can't be sure if side effects occurred.\n         */\n        vars.err = doTransferIn(minter, mintAmount);\n        if (vars.err != Error.NO_ERROR) {\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n        }\n\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[minter] = vars.accountTokensNew;\n\n        /* We emit a Mint event, and a Transfer event */\n        emit Mint(minter, mintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        /* We call the defense hook */\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n        }\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        return redeemFresh(msg.sender, redeemTokens, 0);\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n        }\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        return redeemFresh(msg.sender, 0, redeemAmount);\n    }\n\n    struct RedeemLocalVars {\n        Error err;\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint redeemTokens;\n        uint redeemAmount;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n\n    /**\n     * @notice User redeems cTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param redeemer The addres"
    }
  ]
}