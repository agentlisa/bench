{
  "Title": "M-3: In case if symbol is not valid it should be not possible to open position",
  "Content": "# Issue M-3: In case if symbol is not valid it should be not possible to open position \n\nSource: https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/122 \n\n## Found by \n0xcrunch, AkshaySrivastav, Juntao, circlelooper, rvierdiiev\n## Summary\nIn case if symbol is not valid it should be not possible to open position\n## Vulnerability Detail\nWhen user creates a quote, then there is a check [that symbol is valid](In case if symbol is not active it should be not possible to open position). Otherwise, you can't create quote.\n\nIt's possible that after some time of trading, symbol [will be switched off](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/control/ControlFacet.sol#L136-L144).\n\nWhen this happened, then all trades that use old symbol should be closed in some time. And new trades should not be started. All pending qoutes should be canceled adn locked to be unlocked.\nHowever, there is no check if symbol is valid in `PartyBFacetImpl.openPosition` function. As result partyB still can open position for not valid symbol.\n\nIt's possible that later, oracle will stop provide signatures with prices for that symbol, which means that position can be stucked.\n## Impact\nPossible to open position for invalid symbol.\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\nDo not allow to open position for invalid symbol.\n\n\n\n## Discussion\n\n**mstpr**\n\nEscalate\n\n<img width=\"861\" alt=\"image\" src=\"https://github.com/sherlock-audit/2023-06-symmetrical-judging/assets/120012681/5bc1f22f-fb19-4583-8600-786e29cce50c\">\nSymbol manager is trusted. Symbol manager should not do this action when there are any symbols actively being traded or queued. \nIn addition to trust factor, funds will not be stucked. The pnl will be calculated as usual. Please check the Muon code here\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/muon/crypto_v3.js\n\n**sherlock-admin2**\n\n > Escalate\n> \n> <img width=\"861\" alt=\"image\" src=\"https://github.com/sherlock-audit/2023-06-symmetrical-judging/assets/120012681/5bc1f22f-fb19-4583-8600-786e29cce50c\">\n> Symbol manager is trusted. Symbol manager should not do this action when there are any symbols actively being traded or queued. \n> In addition to trust factor, funds will not be stucked. The pnl will be calculated as usual. Please check the Muon code here\n> \n> https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/muon/crypto_v3.js\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nAgree with escalation\n\n**circlelooper**\n\nThere should be no doubt this one is valid.\n1. It's impractical to assume symbol manager would not invalidate a symbol when there are any symbols actively being traded or queued, symbol manager could be DOSed otherwise (even if there is no trading, when symbol manager tries to invalidate a symbol, malicious user can front-run and create a quote with that symbol);\n2. Opening a quote with invalid symbol breaks the invariant that no invalid symbol should be used in a quote, clearly code does not work as intended, also leading to various issues and potentially losses for the users\n\n**mstpr**\n\n@circlelooper \n\n\n1- Symbol manager can easily avoid front-running: Pausing the partyA, partyB actions and then does the symbol update\n2- When a symbol is invalid, no quotes can be opened anymore by any partyA https://github.com/sherlock-audit/2023-06-symmetrical/blob/6d2b64b6732fcfbd07c8217897dd233dbb6cd1f5/symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol#L44\n3- Even there are some trades that going on with an invalid symbol, there is still no problem because the Muon app will be getting the correct pnl. MuonApp checks the quotes symbolId, calculates the price and returns the pnl. Nothing can go wrong here as long as the MuonApp works as intended. \n\n\n\n**circlelooper**\n\n@mstpr \n\n1. Malicious user can still front-run pausing to send out quote with invalid symbol, there is not much difference;\n2. A honest user may send quotes with long expiration dates, it's irrational for admin to wait for time to expire then invalidate the symbol;\n3.  MuonApp won't work as intended with invalid symbolId, as mentioned in the report:\n\n> It's possible that later, oracle will stop provide signatures with prices for that symbol, which means that position can be stucked.\n\nThis can be seen from verify method:\n\n> The verify method takes several inputs, including the signature, reqId, nonceAddress, start, size, v3Contract, partyA, nonce, uPnl, loss, symbolIds, prices, timestamp, and chainId. It verifies the signature by comparing it with a generated hash of the provided parameters. If the signature is successfully verified, the method returns a subset of the input data, including the v3contract, partyA, nonce, uPnl, loss, symbolIds within a specified range, prices corresponding to those symbolIds, timestamp, and chainId. If the signature verification fails, an error is thrown.\n\n```javascript\n            case 'verify': {\n                let { signature, reqId, nonceAddress, start, size, v3Contract, partyA, nonce, uPnl, loss, symbolIds, prices, timestamp, chainId } = params\n                const seedRequest = { ...request, method: 'partyA_overview', reqId }\n                start = parseInt(start)\n                size = parseInt(size)\n                symbolIds = JSON.parse(symbolIds)\n                prices = JSON.parse(prices)\n                const seedSignParams = [\n                    { type: 'address', value: v3Contract },\n                    { type: 'address', value: partyA },\n                    { type: 'uint256', value: nonce },\n                    { type: 'int256', value: uPnl },\n                    { type: 'int256', value: loss },\n                    { type: 'uint256[]', value: symbolIds },\n                    { type: 'uint256[]', value: prices },\n                    { type: 'uint256', value: timestamp },\n                    { type: 'uint256', value: chainId },\n                ]\n                const hash = this.hashAppSignParams(seedRequest, seedSignParams)\n                if (!await this.verify(hash, signature, nonceAddress))\n                    throw `signature not verified`\n\n\n                return {\n                    v3Contract,\n                    partyA,\n                    nonce,\n                    uPnl,\n                    loss,\n                    symbolIds: symbolIds.slice(start, start + size),\n                    prices: prices.slice(start, start + size),\n                    timestamp,\n                    chainId\n                }\n\n\n            }\n```\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/6d2b64b6732fcfbd07c8217897dd233dbb6cd1f5/symmio-core/muon/crypto_v3.js#L412-L446\n\n4. Symmetrical gets prices from Binance, Kucoin and Mexc, things will go wrong if use an symbol not supported by those platforms\n```javascript\n    getPrices: async function (symbols) {\n        const promises = [\n            this.getBinancePrices(),\n            this.getKucoinPrices(),\n            this.getMexcPrices(),\n        ]\n\n\n        const result = await Promise.all(promises)\n        const markPrices = {\n            'binance': result[0],\n            'kucoin': result[1],\n            'mexc': result[2],\n        }\n\n\n        if (!this.checkPrices(symbols, markPrices)) throw { message: `Corrupted Price` }\n\n\n        return { pricesMap: markPrices['binance'], markPrices }\n    },\n```\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/6d2b64b6732fcfbd07c8217897dd233dbb6cd1f5/symmio-core/muon/crypto_v3.js#L125-L142\n\nOpening a quote with invalid symbol is not an intended behavior, can lead to unexpected results.\n\n**hrishibhat**\n\n@mstpr Do you have additonal comments?\n\n**mstpr**\n\n> @mstpr\n> \n> 1. Malicious user can still front-run pausing to send out quote with invalid symbol, there is not much difference;\n> 2. A honest user may send quotes with long expiration dates, it's irrational for admin to wait for time to expire then invalidate the symbol;\n> 3. MuonApp won't work as intended with invalid symbolId, as mentioned in the report:\n> \n> > It's possible that later, oracle will stop provide signatures with prices for that symbol, which means that position can be stucked.\n> \n> This can be seen from verify method:\n> \n> > The verify method takes several inputs, including the signature, reqId, nonceAddress, start, size, v3Contract, partyA, nonce, uPnl, loss, symbolIds, prices, timestamp, and chainId. It verifies the signature by comparing it with a generated hash of the provided parameters. If the signature is successfully verified, the method returns a subset of the input data, including the v3contract, partyA, nonce, uPnl, loss, symbolIds within a specified range, prices corresponding to those symbolIds, timestamp, and chainId. If the signature verification fails, an error is thrown.\n> \n> ```js\n>             case 'verify': {\n>                 let { signature, reqId, nonceAddress, start, size, v3Contract, partyA, nonce, uPnl, loss, symbolIds, prices, timestamp, chainId } = params\n>                 const seedRequest = { ...request, method: 'partyA_overview', reqId }\n>                 start = parseInt(start)\n>                 size = parseInt(size)\n>                 symbolIds = JSON.parse(symbolIds)\n>                 prices = JSON.parse(prices)\n>                 const seedSignParams = [\n>                     { type: 'address', value: v3Contract },\n>                     { type: 'address', value: partyA },\n>                     { type: 'uint256', value: nonce },\n>                     { type: 'int256', value: uPnl },\n>                     { type: 'int256', value: loss },\n>                     { type: 'uint256[]', value: symbolIds },\n>                     { type: 'uint256[]', value: prices },\n>                     { type: 'uint256', value: timestamp },\n>                     { type: 'uint256', value: chainId },\n>                 ]\n>                 const hash = this.hashAppSignParams(seedRequest, seedSignParams)\n>                 if (!await this.verify(hash, signature, nonceAddress))\n>                     throw `signature not verified`\n> \n> \n>                 return {\n>                     v3Contract,\n>                     partyA,\n>                     nonce,\n>                     uPnl,\n>                     loss,\n>                     symbolIds: symbolIds.slice(start, start + size),\n>                     prices: prices.slice(start, start + size),\n>                     timestamp,\n>                     chainId\n>                 }\n> \n> \n>             }\n> ```\n> \n> https://github.com/sherlock-audit/2023-06-symmetrical/blob/6d2b64b6732fcfbd07c8217897dd233dbb6cd1f5/symmio-core/muon/crypto_v3.js#L412-L446\n> \n> 4. Symmetrical gets prices from Binance, Kucoin and Mexc, things will go wrong if use an symbol not supported by those platforms\n> \n> ```js\n>     getPrices: async function (symbols) {\n>         const promises = [\n>             this.getBinancePrices(),\n>             this.getKucoinPrices(),\n>             this.getMexcPrices(),\n>         ]\n> \n> \n>         const result = await Promise.all(promises)\n>         const markPrices = {\n>             'binance': result[0],\n>             'kucoin': result[1],\n>             'mexc': result[2],\n>         }\n> \n> \n>         if (!this.checkPrices(symbols, markPrices)) throw { message: `Corrupted Price` }\n> \n> \n>         return { pricesMap: markPrices['binance'], markPrices }\n>     },\n> ```\n> \n> https://github.com/sherlock-audit/2023-06-symmetrical/blob/6d2b64b6732fcfbd07c8217897dd233dbb6cd1f5/symmio-core/muon/crypto_v3.js#L125-L142\n> \n> Opening a quote with invalid symbol is not an intended behavior, can lead to unexpected results.\n\nYou can't frontrun if you pause first, if you try to frontrun pause Symbol manager will check and will not update the symbol. \n\nI agree that symbols shouldn't be opened if they are invalid however, I don't think this is a medium finding considering symbol manager is trusted, also as long as the Muon oracle gives price there is no real harm. \n\nRemember, symbol manager can update a symbol while a quote is actually opened aswell, so it all comes down to Symbol managers actions \n\n**panprog**\n\nI'd like to add to the discussion: if there are positions opened with the symbol, which is switched off, there is no way to forcedly close all those positions, which is a much bigger problem than opening quotes and somewhat similar as well: positions already opened (and quotes already sent) will remain valid even after symbol is switched off. I'd say it's no big deal if quotes can be opened for invalid symbol as it's not much different from already opened quotes with invalid symbol. Yes, it's better if it's not allowed, but it's not much different from already opened quotes, so I'd say it's low impact.\nI've also seen this problem but didn't report it exactly because I thought that already opened positions with invalid symbol are what really matters and since those can't be closed, there is no real harm in letting open position with invalid symbol. \n\n**circlelooper**\n\n> You can't frontrun if you pause first, if you try to frontrun pause Symbol manager will check and will not update the symbol.\n\nSounds like a DOS attack.\n\n> I agree that symbols shouldn't be opened if they are invalid however, I don't think this is a medium finding considering symbol manager is trusted, also as long as the Muon oracle gives price there is no real harm.\nRemember, symbol manager can update a symbol while a quote is actually opened aswell, so it all comes down to Symbol managers actions\n\nSymbol manager is trusted doesn't mean he/she can do everything at perfect timing, symbol manager will have to update a symbol even if there are pending requests, because some requests may have no expiration date.\n\n> I'd like to add to the discussion: if there are positions opened with the symbol, which is switched off, there is no way to forcedly close all those positions, which is a much bigger problem than opening quotes and somewhat similar as well: positions already opened (and quotes already sent) will remain valid even after symbol is switched off. I'd say it's no big deal if quotes can be opened for invalid symbol as it's not much different from already opened quotes with invalid symbol. Yes, it's better if it's not allowed, but it's not much different from already opened quotes, so I'd say it's low impact.\nI've also seen this problem but didn't report it exactly because I thought that already opened positions with invalid symbol are what really matters and since those can't be closed, there is no real harm in letting open position with invalid symbol.\n\nSymbol can be invalidated for various reasons:\n1. If Muon gives no price data for the invalid symbol and user's position is opened, user's position cannot be closed and funds will be locked;\n2. If Muon gives incorrect price data for the invalid symbol and user's position is opened, user's position can be closed but user will suffer a huge loss.\n\nThe already opened positions with invalid symbol will no doubt bring damages, that's exactly why we should not allow new positions to be opended with invalid symbol, only by doing that we can mitigate futher damages to the protocol.\n\n\n\n**panprog**\n\n> The already opened positions with invalid symbol will no doubt bring damages, that's exactly why we should not allow new positions to be opended with invalid symbol, only by doing that we can mitigate futher damages to the protocol.\n\nMy point is that there is no way to remove already opened positions with invalid symbol. So if there are opened positions, it doesn't matter if we also let the pending quotes with this symbol be opened - there are the other opened positions anyway. So in this sense pending quotes are no worse than opened position, and since opened positions can not be mitigated anyway, pending quotes can't cause any harm not already present.\n\nNow thinking of it, I guess the real bug is that there is no symbol \"settlement\" functionality - like if the price feed stops working for the symbol, or is about to be stopped, all positions with this symbol should be settled (closed) at the market (or some average) price. Maybe this should happen when symbol is set invalid. So the problem is not in letting quotes open, the problem is with not settling already opened positions. But this is not mentioned anywhere.\n\n**circlelooper**\n\n> So the problem is not in letting quotes open, the problem is with not settling already opened positions. But this is not mentioned anywhere.\n\nActually this is metioned in the report:\n\n> It's possible that later, oracle will stop provide signatures with prices for that symbol, which means that position can be stucked.\n\nI think this is very obvious: \n`positions opened with invalid symbol -> opened positions with invalid symbol -> positions cannot be settled`\n\nThe rootcause is the same, so the issue is valid.\n\n**panprog**\n\n> The rootcause is the same, so the issue is valid.\n\nYes, I agree that issue is valid, but I think that impact is low, because fixing this issue won't improve the situation significantly: if pending -> open transition is prohibited for invalid symbol, there are still open positions with this invalid symbol, meaning nothing really changed.\n\nThe only scenario when fixing this issue will help is if there are no open positions, but there are pending quotes (for example: an incorrect symbol was accidently allowed, some users already started sending quotes, but the admin noticed this and invalidated the symbol). In such scenario, yes, fixing this issue will help. But it can be classified as admin mistake which should be invalid then. Or it can happen on a mature market, where all users have closed positions but there are still pending quotes (which is extremely unlikely but possible). I'm not sure if such scenario is enough for the medium impact.\n\n**circlelooper**\n\n> if pending -> open transition is prohibited for invalid symbol, there are still open positions with this invalid symbol, meaning nothing really changed\n\nThey are essentially the same:\nIf there are no opening positions, this issue leads to invalid symbol used in opening positions;\nIf there are opening positions, this issue makes things worse and more funds are locked  (oracle provides no price data) or lost  (oracle provides compromised price data).\n\n> But it can be classified as admin mistake which should be invalid then.\n\nIt's not admin error, as I mentioned above: \"symbol manager will have to update a symbol even if there are pending requests, because some requests may have no expiration date\".\n\nOpening quotes with invalid symbol leads to user's funds being locked or lost, it's enough for a medium.\n\n**MoonKnightDev**\n\nFixed code PR link:\nhttps://github.com/SYMM-IO/symmio-core/pull/6\n\n**panprog**\n\n> this issue makes things worse and more funds are locked (oracle provides no price data) or lost (oracle provides compromised price data).\n\nGood point, agree. However, this can be fixed off-chain and I don't think funds will be stuck/lost due to this issue, because the protocol doesn't use the oracle feeds directly, and off-chain muon app can simply return and sign the same (settled) price for malfunctioning feed as a \"settlement\" measure for invalid symbols with invalid oracle feed.\n\nHowever, @hrishibhat says that historically Sherlock rules consider issues that can be fixed off-chain to be valid medium, because they must be fixed on-chain. This issue can be fixed both off-chain and on-chain, so according to this rule it should probably be a valid medium.\n\nIn addition, I'd like to add that this issue is only part of the story. I think that the whole process of making a symbol invalid is just not well thought out by developers. They should think what to do with open positions. And the best fix should most probably be on-chain, something like:\n1. Instead of valid/invalid they should make a symbol status like: invalid, active, closeonly, settled, paused\n2. For certain statuses like \"settled\" admin should also be able to set the settlement price\n3. If status is not active, new quotes should not be opened and pending/locked quotes should only be able to be cancelled\n4. Open positions should be closed using fixed settlement price in settled status, be denied to be closed in paused and invalid status.\n\nThis issue only tackles point 3, but is still valid.\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nAfter considering all the comments above and further internal discussion, there seems to be a lot of factors to be considered here and this issue can be considered on the borderline regarding the impact of the issue and that it can be handled on the muon app end. However, given some of the comments above, Sponsor's opinion, and the fix applied, this can be considered a valid issue as this can cause issues if positions are opened with some of these quotes as the check is currently only for send quotes. \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [mstpr](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/122/#issuecomment-1653684214): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/85",
  "Code": [
    {
      "filename": "symmio-core/contracts/facets/control/ControlFacet.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../utils/Ownable.sol\";\nimport \"../../utils/Accessibility.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../storages/GlobalAppStorage.sol\";\nimport \"../../storages/SymbolStorage.sol\";\nimport \"./IControlEvents.sol\";\n\ncontract ControlFacet is Accessibility, Ownable, IControlEvents {\n    // Just For Testnet\n    function init(address user, address collateral, address feeCollector) external onlyOwner {\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        GlobalAppStorage.Layout storage appLayout = GlobalAppStorage.layout();\n\n        appLayout.collateral = collateral;\n        appLayout.balanceLimitPerUser = 500e18;\n        appLayout.feeCollector = feeCollector;\n        maLayout.deallocateCooldown = 300;\n        maLayout.forceCancelCooldown = 3000000000000000;\n        maLayout.forceCloseCooldown = 3000000000000000;\n        maLayout.forceCancelCloseCooldown = 3000000000000000;\n        maLayout.pendingQuotesValidLength = 15;\n        maLayout.liquidatorShare = 80e16;\n        maLayout.liquidationTimeout = 600;\n        appLayout.hasRole[user][LibAccessibility.DEFAULT_ADMIN_ROLE] = true;\n        appLayout.hasRole[user][LibAccessibility.SYMBOL_MANAGER_ROLE] = true;\n        appLayout.hasRole[user][LibAccessibility.MUON_SETTER_ROLE] = true;\n        appLayout.hasRole[user][LibAccessibility.SETTER_ROLE] = true;\n        appLayout.hasRole[user][LibAccessibility.PARTY_B_MANAGER_ROLE] = true;\n    }\n\n    function setAdmin(address user) external onlyOwner {\n        GlobalAppStorage.layout().hasRole[user][LibAccessibility.DEFAULT_ADMIN_ROLE] = true;\n        emit RoleGranted(LibAccessibility.DEFAULT_ADMIN_ROLE, user);\n    }\n\n    function grantRole(\n        address user,\n        bytes32 role\n    ) external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\n        GlobalAppStorage.layout().hasRole[user][role] = true;\n        emit RoleGranted(role, user);\n    }\n\n    function revokeRole(\n        address user,\n        bytes32 role\n    ) external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\n        GlobalAppStorage.layout().hasRole[user][role] = false;\n        emit RoleRevoked(role, user);\n    }\n\n    function registerPartyB(\n        address partyB\n    ) external onlyRole(LibAccessibility.PARTY_B_MANAGER_ROLE) {\n        require(\n            !MAStorage.layout().partyBStatus[partyB],\n            \"ControlFacet: Address is already registered\"\n        );\n        MAStorage.layout().partyBStatus[partyB] = true;\n        MAStorage.layout().partyBList.push(partyB);\n        emit RegisterPartyB(partyB);\n    }\n\n    function setMuonConfig(\n        uint256 upnlValidTime,\n        uint256 priceValidTime,\n        uint256 priceQuantityValidTime\n    ) external onlyRole(LibAccessibility.MUON_SETTER_ROLE) {\n        emit SetMuonConfig(upnlValidTime, priceValidTime, priceQuantityValidTime);\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n        muonLayout.upnlValidTime = upnlValidTime;\n        muonLayout.priceValidTime = priceValidTime;\n        muonLayout.priceQuantityValidTime = priceQuantityValidTime;\n    }\n\n    function setMuonIds(\n        uint256 muonAppId,\n        address validGateway,\n        PublicKey memory publicKey\n    ) external onlyRole(LibAccessibility.MUON_SETTER_ROLE) {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n        muonLayout.muonAppId = muonAppId;\n        muonLayout.validGateway = validGateway;\n        muonLayout.muonPublicKey = publicKey;\n        emit SetMuonIds(muonAppId, validGateway, publicKey.x, publicKey.parity);\n    }\n\n    function setCollateral(\n        address collateral\n    ) external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\n        GlobalAppStorage.layout().collateral = collateral;\n        emit SetCollateral(collateral);\n    }\n\n    // Symbol State\n\n    function addSymbol(\n        string memory name,\n        uint256 minAcceptableQuoteValue,\n        uint256 minAcceptablePortionLF,\n        uint256 tradingFee\n    ) public onlyRole(LibAccessibility.SYMBOL_MANAGER_ROLE) {\n        uint256 lastId = ++SymbolStorage.layout().lastId;\n        Symbol memory symbol = Symbol(\n            lastId,\n            name,\n            true,\n            minAcceptableQuoteValue,\n            minAcceptablePortionLF,\n            tradingFee\n        );\n        SymbolStorage.layout().symbols[lastId] = symbol;\n        emit AddSymbol(lastId, name, minAcceptableQuoteValue, minAcceptablePortionLF, tradingFee);\n    }\n\n    function addSymbols(\n        Symbol[] memory symbols\n    ) external onlyRole(LibAccessibility.SYMBOL_MANAGER_ROLE) {\n        for (uint8 i; i < symbols.length; i++) {\n            addSymbol(\n                symbols[i].name,\n                symbols[i].minAcceptableQuoteValue,\n                symbols[i].minAcceptablePortionLF,\n                symbols[i].tradingFee\n            );\n        }\n    }\n\n    function setSymbolValidationState(\n        uint256 symbolId,\n        bool isValid\n    ) external onlyRole(LibAccessibility.SYMBOL_MANAGER_ROLE) {\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\n        require(symbolId >= 1 && symbolId <= symbolLayout.lastId, \"ControlFacet: Invalid id\");\n        emit SetSymbolValidationState(symbolId, symbolLayout.symbols[symbolId].isValid, isValid);\n        symbolLayout.symbols[symbolId].isValid = isValid;\n    }\n\n    function setSymbolAcceptableValues(\n        uint256 symbolId,\n        uint256 minAcceptableQuoteValue,\n        uint256 minAcceptablePortionLF\n    ) external onlyRole(LibAccessibility.SYMBOL_MANAGER_ROLE) {\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\n        require(symbolId >= 1 && symbolId <= symbolLayout.lastId, \"ControlFacet: Invalid id\");\n        emit SetSymbolAcceptableValues(\n            symbolId,\n            symbolLayout.symbols[symbolId].minAcceptableQuoteValue,\n            symbolLayout.symbols[symbolId].minAcceptablePortionLF,\n            minAcceptableQuoteValue,\n            minAcceptablePortionLF\n        );\n        symbolLayout.symbols[symbolId].minAcceptableQuoteValue = minAcceptableQuoteValue;\n        symbolLayout.symbols[symbolId].minAcceptablePortionLF = minAcceptablePortionLF;\n    }\n\n    function setSymbolTradingFee(\n        uint256 symbolId,\n        uint256 tradingFee\n    ) external onlyRole(LibAccessibility.SYMBOL_MANAGER_ROLE) {\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\n        require(symbolId >= 1 && symbolId <= symbolLayout.lastId, \"ControlFacet: Invalid id\");\n        emit SetSymbolTradingFee(symbolId, symbolLayout.symbols[symbolId].tradingFee, tradingFee);\n        symbolLayout.symbols[symbolId].tradingFee = tradingFee;\n    }\n\n    /////////////////////////////////////\n\n    // CoolDowns\n\n    function setDeallocateCooldown(\n        uint256 deallocateCooldown\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\n        emit SetDeallocateCooldown(MAStorage.layout().deallocateCooldown, deallocateCooldown);\n        MAStorage.layout().deallocateCooldown = deallocateCooldown;\n    }\n\n    function setForceCancelCooldown(\n        uint256 forceCancelCooldown\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\n        emit SetForceCancelCooldown(MAStorage.layout().forceCancelCooldown, forceCancelCooldown);\n        MAStorage.layout().forceCancelCooldown = forceCancelCooldown;\n    }\n\n    function setForceCloseCooldown(\n        uint256 forceCloseCooldown\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\n        emit SetForceCloseCooldown(MAStorage.layout().forceCloseCooldown, forceCloseCooldown);\n        MAStorage.layout().forceCloseCooldown = forceCloseCooldown;\n    }\n\n    function setForceCancelCloseCooldown(\n        uint256 forceCancelCloseCooldown\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\n        emit SetForceCancelCloseCooldown(\n            MAStorage.layout().forceCancelCloseCooldown,\n            forceCancelCloseCooldown\n        );\n        MAStorage.layout().forceCancelCloseCooldown = forceCancelCloseCooldown;\n    }\n\n    function setLiquidatorShare(\n        uint256 liquidatorShare\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\n        emit SetLiquidatorShare(MAStorage.layout().liquidatorShare, liquidatorShare);\n        MAStorage.layout().liquidatorShare = liquidatorShare;\n    }\n\n    function setForceCloseGapRatio(\n        uint256 forceCloseGapRatio\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\n        emit SetForceCloseGapRatio(MAStorage.layout().forceCloseGapRatio, forceCloseGapRatio);\n        MAStorage.layout().forceCloseGapRatio = forceCloseGapRatio;\n    }\n\n    function setPendingQuotesValidLength(\n        uint256 pendingQuotesValidLength\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\n        emit SetPendingQuotesValidLength(\n            MAStorage.layout().pendingQuotesValidLength,\n            pendingQuotesValidLength\n        );\n        MAStorage.layout().pendingQuotesValidLength = pendingQuotesValidLength;\n    }\n\n    // Pause State\n\n    function setFeeCollector(\n        address feeCollector\n    ) external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\n        emit SetFeeCollector(GlobalAppStorage.layout().feeCollector, feeCollector);\n        GlobalAppStorage.layout().feeCollector = feeCollector;\n    }\n\n    function pauseGlobal() external onlyRole(LibAccessibility.PAUSER_ROLE) {\n        GlobalAppStorage.layout().globalPaused = true;\n        emit PauseGlobal();\n    }\n\n    function pauseLiquidation() external onlyRole(LibAccessibility.PAUSER_ROLE) {\n        GlobalAppStorage.layout().liquidationPaused = true;\n        emit PauseLiquidation();\n    }\n\n    function pauseAccounting() external onlyRole(LibAccessibility.PAUSER_ROLE) {\n        GlobalAppStorage.layout().accountingPaused = true;\n        emit PauseAccounting();\n    }\n\n    function pausePartyAActions() external onlyRole(LibAccessibility.PAUSER_ROLE) {\n        GlobalAppStorage.layout().partyAActionsPaused = true;\n        emit PausePartyAActions();\n    }\n\n    function pausePartyBActions() external onlyRole(LibAccessibility.PAUSER_ROLE) {\n        GlobalAppStorage.layout().partyBActionsPaused = true;\n        emit PausePartyBActions();\n    }\n\n    function activeEmergencyMode() external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\n        GlobalAppStorage.layout().emergencyMode = true;\n        emit ActiveEmergencyMode();\n    }\n\n    function unpauseGlobal() external onlyRole(LibAccessibility.UNPAUSER_ROLE) {\n        GlobalAppStorage.layout().globalPaused = false;\n        emit UnpauseGlobal();\n    }\n\n    function unpauseLiquidation() external onlyRole(LibAccessibility.UNPAUSER_ROLE) {\n        GlobalAppStorage.layout().liquidationPaused = false;\n        emit UnpauseLiquidation();\n    }\n\n    function unpauseAccounting() external onlyRole(LibAccessibility.UNPAUSER_ROLE) {\n        GlobalAppStorage.layout().accountingPaused = false;\n        emit UnpauseAccounting();\n    }\n\n    function unpausePartyAActions() external onlyRole(LibAccessibility.UNPAUSER_ROLE) {\n        GlobalAppStorage.layout().partyAActionsPaused = false;\n        emit UnpausePartyAActions();\n    }\n\n    function unpausePartyBActions() external onlyRole(LibAccessibility.UNPAUSER_ROLE) {\n        GlobalAppStorage.layout().partyBActionsPaused = false;\n        emit UnpausePartyBActions();\n    }\n\n    function setLiquidationTimeout(\n        uint256 liquidationTimeout\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\n        emit SetLiquidationTimeout(MAStorage.layout().liquidationTimeout, liquidationTimeout);\n        MAStorage.layout().liquidationTimeout = liquidationTimeout;\n    }\n\n    function setSuspendedAddress(\n        address user,\n        bool isSuspended\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\n        emit SetSuspendedAddress(user, isSuspended);\n        AccountStorage.layout().suspendedAddresses[user] = isSuspended;\n    }\n\n    function deactiveEmergencyMode() external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\n        GlobalAppStorage.layout().emergencyMode = false;\n        emit DeactiveEmergencyMode();\n    }\n\n    function setBalanceLimitPerUser(\n        uint256 balanceLimitPerUser\n    ) external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\n        emit SetBalanceLimitPerUser(balanceLimitPerUser);\n        GlobalAppStorage.layout().balanceLimitPerUser = balanceLimitPerUser;\n    }\n\n    function setPartyBEmergencyStatus(\n        address[] memory partyBs,\n        bool status\n    ) external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\n        for (uint8 i; i < partyBs.length; i++) {\n            GlobalAppStorage.layout().partyBEmergencyStatus[partyBs[i]] = status;\n            emit SetPartyBEmergencyStatus(partyBs[i], status);\n        }\n    }\n}"
    },
    {
      "filename": "symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../libraries/LibLockedValues.sol\";\nimport \"../../libraries/LibMuon.sol\";\nimport \"../../libraries/LibAccount.sol\";\nimport \"../../libraries/LibSolvency.sol\";\nimport \"../../libraries/LibQuote.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/QuoteStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../storages/AccountStorage.sol\";\nimport \"../../storages/SymbolStorage.sol\";\n\nlibrary PartyAFacetImpl {\n    using LockedValuesOps for LockedValues;\n\n    function sendQuote(\n        address[] memory partyBsWhiteList,\n        uint256 symbolId,\n        PositionType positionType,\n        OrderType orderType,\n        uint256 price,\n        uint256 quantity,\n        uint256 cva,\n        uint256 mm,\n        uint256 lf,\n        uint256 maxInterestRate,\n        uint256 deadline,\n        SingleUpnlAndPriceSig memory upnlSig\n    ) internal returns (uint256 currentId) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\n\n        require(\n            quoteLayout.partyAPendingQuotes[msg.sender].length < maLayout.pendingQuotesValidLength,\n            \"PartyAFacet: Number of pending quotes out of range\"\n        );\n        require(symbolLayout.symbols[symbolId].isValid, \"PartyAFacet: Symbol is not valid\");\n        require(deadline >= block.timestamp, \"PartyAFacet: Low deadline\");\n\n        LockedValues memory lockedValues = LockedValues(cva, mm, lf);\n        uint256 tradingPrice = orderType == OrderType.LIMIT ? price : upnlSig.price;\n        uint256 notionalValue = (quantity * tradingPrice) / 1e18;\n        require(\n            lockedValues.total() <= notionalValue,\n            \"PartyAFacet: Leverage can't be lower than one\"\n        );\n\n        require(\n            lockedValues.lf >=\n                (symbolLayout.symbols[symbolId].minAcceptablePortionLF * lockedValues.total()) /\n                    1e18,\n            \"PartyAFacet: LF is not enough\"\n        );\n\n        require(\n            lockedValues.total() >= symbolLayout.symbols[symbolId].minAcceptableQuoteValue,\n            \"PartyAFacet: Quote value is low\"\n        );\n        for (uint8 i = 0; i < partyBsWhiteList.length; i++) {\n            require(\n                partyBsWhiteList[i] != msg.sender,\n                \"PartyAFacet: Sender isn't allowed in partyBWhiteList\"\n            );\n        }\n\n        LibMuon.verifyPartyAUpnlAndPrice(upnlSig, msg.sender, symbolId);\n\n        int256 availableBalance = LibAccount.partyAAvailableForQuote(upnlSig.upnl, msg.sender);\n        require(availableBalance > 0, \"PartyAFacet: Available balance is lower than zero\");\n        require(\n            uint256(availableBalance) >=\n                lockedValues.total() +\n                    ((quantity * tradingPrice * symbolLayout.symbols[symbolId].tradingFee) / 1e36),\n            \"PartyAFacet: insufficient available balance\"\n        );\n\n        // lock funds the in middle of way\n        accountLayout.pendingLockedBalances[msg.sender].add(lockedValues);\n        currentId = ++quoteLayout.lastId;\n        accountLayout.partyANonces[msg.sender] += 1;\n\n        // create quote.\n        Quote memory quote = Quote({\n            id: currentId,\n            partyBsWhiteList: partyBsWhiteList,\n            symbolId: symbolId,\n            positionType: positionType,\n            orderType: orderType,\n            openedPrice: 0,\n            requestedOpenPrice: price,\n            marketPrice: upnlSig.price,\n            quantity: quantity,\n            closedAmount: 0,\n            lockedValues: lockedValues,\n            initialLockedValues: lockedValues,\n            maxInterestRate: maxInterestRate,\n            partyA: msg.sender,\n            partyB: address(0),\n            quoteStatus: QuoteStatus.PENDING,\n            avgClosedPrice: 0,\n            requestedClosePrice: 0,\n            parentId: 0,\n            createTimestamp: block.timestamp,\n            modifyTimestamp: block.timestamp,\n            quantityToClose: 0,\n            deadline: deadline\n        });\n        quoteLayout.quoteIdsOf[msg.sender].push(currentId);\n        quoteLayout.partyAPendingQuotes[msg.sender].push(currentId);\n        quoteLayout.quotes[currentId] = quote;\n\n        LibQuote.receiveTradingFee(currentId);\n    }\n\n    function requestToCancelQuote(uint256 quoteId) internal returns (QuoteStatus result) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(\n            quote.quoteStatus == QuoteStatus.PENDING || quote.quoteStatus == QuoteStatus.LOCKED,\n            \"PartyAFacet: Invalid state\"\n        );\n        accountLayout.partyANonces[quote.partyA] += 1;\n\n        if (block.timestamp > quote.deadline) {\n            result = LibQuote.expireQuote(quoteId);\n        } else if (quote.quoteStatus == QuoteStatus.PENDING) {\n            quote.quoteStatus = QuoteStatus.CANCELED;\n            LibQuote.returnTradingFee(quoteId);\n            accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n            LibQuote.removeFromPartyAPendingQuotes(quote);\n            result = QuoteStatus.CANCELED;\n        } else {\n            // Quote is locked\n            quote.quoteStatus = QuoteStatus.CANCEL_PENDING;\n            result = QuoteStatus.CANCEL_PENDING;\n        }\n        quote.modifyTimestamp = block.timestamp;\n    }\n\n    function requestToClosePosition(\n        uint256 quoteId,\n        uint256 closePrice,\n        uint256 quantityToClose,\n        OrderType orderType,\n        uint256 deadline,\n        SingleUpnlAndPriceSig memory upnlSig\n    ) internal {\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(quote.quoteStatus == QuoteStatus.OPENED, \"PartyAFacet: Invalid state\");\n        require(deadline >= block.timestamp, \"PartyAFacet: Low deadline\");\n        require(\n            LibQuote.quoteOpenAmount(quote) >= quantityToClose,\n            \"PartyAFacet: Invalid quantityToClose\"\n        );\n        LibMuon.verifyPartyAUpnlAndPrice(upnlSig, quote.partyA, quote.symbolId);\n        LibSolvency.isSolventAfterRequestToClosePosition(\n            quoteId,\n            closePrice,\n            quantityToClose,\n            upnlSig\n        );\n\n        // check that remaining position is not too small\n        if (LibQuote.quoteOpenAmount(quote) > quantityToClose) {\n            require(\n                ((LibQuote.quoteOpenAmount(quote) - quantityToClose) * quote.lockedValues.total()) /\n                    LibQuote.quoteOpenAmount(quote) >=\n                    symbolLayout.symbols[quote.symbolId].minAcceptableQuoteValue,\n                \"PartyAFacet: Remaining quote value is low\"\n            );\n        }\n\n        accountLayout.partyANonces[quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.CLOSE_PENDING;\n        quote.requestedClosePrice = closePrice;\n        quote.quantityToClose = quantityToClose;\n        quote.orderType = orderType;\n        quote.deadline = deadline;\n    }\n\n    function requestToCancelCloseRequest(uint256 quoteId) internal returns (QuoteStatus) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(quote.quoteStatus == QuoteStatus.CLOSE_PENDING, \"PartyAFacet: Invalid state\");\n        if (block.timestamp > quote.deadline) {\n            LibQuote.expireQuote(quoteId);\n            return QuoteStatus.OPENED;\n        } else {\n            accountLayout.partyANonces[quote.partyA] += 1;\n            quote.modifyTimestamp = block.timestamp;\n            quote.quoteStatus = QuoteStatus.CANCEL_CLOSE_PENDING;\n            return QuoteStatus.CANCEL_CLOSE_PENDING;\n        }\n    }\n\n    function forceCancelQuote(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(quote.quoteStatus == QuoteStatus.CANCEL_PENDING, \"PartyAFacet: Invalid state\");\n        require(\n            block.timestamp > quote.modifyTimestamp + maLayout.forceCancelCooldown,\n            \"PartyAFacet: Cooldown not reached\"\n        );\n        accountLayout.partyANonces[quote.partyA] += 1;\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.CANCELED;\n        accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n        accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(quote);\n\n        // send trading Fee back to partyA\n        LibQuote.returnTradingFee(quoteId);\n\n        LibQuote.removeFromPendingQuotes(quote);\n    }\n\n    function forceCancelCloseRequest(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n            \"PartyAFacet: Invalid state\"\n        );\n        require(\n            block.timestamp > quote.modifyTimestamp + maLayout.forceCancelCloseCooldown,\n            \"PartyAFacet: Cooldown not reached\"\n        );\n\n        accountLayout.partyANonces[quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.OPENED;\n        quote.requestedClosePrice = 0;\n        quote.quantityToClose = 0;\n    }\n\n    function forceClosePosition(uint256 quoteId, PairUpnlAndPriceSig memory upnlSig) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        uint256 filledAmount = quote.quantityToClose;\n        require(quote.quoteStatus == QuoteStatus.CLOSE_PENDING, \"PartyAFacet: Invalid state\");\n        require(\n            block.timestamp > quote.modifyTimestamp + maLayout.forceCloseCooldown,\n            \"PartyAFacet: Cooldown not reached\"\n        );\n        require(block.timestamp <= quote.deadline, \"PartyBFacet: Quote is expired\");\n        require(\n            quote.orderType == OrderType.LIMIT,\n            \"PartyBFacet: Quote's order type should be LIMIT\"\n        );\n        if (quote.positionType == PositionType.LONG) {\n            require(\n                upnlSig.price >=\n                    quote.requestedClosePrice +\n                        (quote.requestedClosePrice * maLayout.forceCloseGapRatio) /\n                        1e18,\n                \"PartyAFacet: Requested close price not reached\"\n            );\n        } else {\n            require(\n                upnlSig.price <=\n                    quote.requestedClosePrice -\n                        (quote.requestedClosePrice * maLayout.forceCloseGapRatio) /\n                        1e18,\n                \"PartyAFacet: Requested close price not reached\"\n            );\n        }\n\n        LibMuon.verifyPairUpnlAndPrice(upnlSig, quote.partyB, quote.partyA, quote.symbolId);\n        LibSolvency.isSolventAfterClosePosition(\n            quoteId,\n            filledAmount,\n            quote.requestedClosePrice,\n            upnlSig\n        );\n        accountLayout.partyANonces[quote.partyA] += 1;\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        LibQuote.closeQuote(quote, filledAmount, quote.requestedClosePrice);\n    }\n}"
    },
    {
      "filename": "symmio-core/muon/crypto_v3.js",
      "content": "const { axios, BN, toBaseUnit, ethCall } = MuonAppUtils\nconst HttpsProxyAgent = require('https-proxy-agent');\nconst scale = new BN(toBaseUnit('1', 18))\nconst ZERO = new BN(0)\nconst scaleUp = (value) => new BN(toBaseUnit(String(value), 18))\n\nconst ABI = [{ \"inputs\": [{ \"internalType\": \"uint256[]\", \"name\": \"quoteIds\", \"type\": \"uint256[]\" }], \"name\": \"symbolNameByQuoteId\", \"outputs\": [{ \"internalType\": \"string[]\", \"name\": \"\", \"type\": \"string[]\" }], \"stateMutability\": \"view\", \"type\": \"function\" }, { \"inputs\": [{ \"internalType\": \"address\", \"name\": \"partyA\", \"type\": \"address\" }], \"name\": \"nonceOfPartyA\", \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }], \"stateMutability\": \"view\", \"type\": \"function\" }, { \"inputs\": [{ \"internalType\": \"address\", \"name\": \"partyB\", \"type\": \"address\" }, { \"internalType\": \"address\", \"name\": \"partyA\", \"type\": \"address\" }], \"name\": \"nonceOfPartyB\", \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }], \"stateMutability\": \"view\", \"type\": \"function\" }, { \"inputs\": [{ \"internalType\": \"address\", \"name\": \"partyA\", \"type\": \"address\" }], \"name\": \"partyAPositionsCount\", \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }], \"stateMutability\": \"view\", \"type\": \"function\" }, { \"inputs\": [{ \"internalType\": \"address\", \"name\": \"partyB\", \"type\": \"address\" }, { \"internalType\": \"address\", \"name\": \"partyA\", \"type\": \"address\" }], \"name\": \"partyBPositionsCount\", \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }], \"stateMutability\": \"view\", \"type\": \"function\" }, { \"inputs\": [{ \"internalType\": \"address\", \"name\": \"partyA\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"start\", \"type\": \"uint256\" }, { \"internalType\": \"uint256\", \"name\": \"size\", \"type\": \"uint256\" }], \"name\": \"getPartyAOpenPositions\", \"outputs\": [{ \"components\": [{ \"internalType\": \"uint256\", \"name\": \"id\", \"type\": \"uint256\" }, { \"internalType\": \"address[]\", \"name\": \"partyBsWhiteList\", \"type\": \"address[]\" }, { \"internalType\": \"uint256\", \"name\": \"symbolId\", \"type\": \"uint256\" }, { \"internalType\": \"enum PositionType\", \"name\": \"positionType\", \"type\": \"uint8\" }, { \"internalType\": \"enum OrderType\", \"name\": \"orderType\", \"type\": \"uint8\" }, { \"internalType\": \"uint256\", \"name\": \"openedPrice\", \"type\": \"uint256\" }, { \"internalType\": \"uint256\", \"name\": \"requestedOpenPrice\", \"type\": \"uint256\" }, { \"internalType\": \"uint256\", \"name\": \"marketPrice\", \"type\": \"uint256\" }, { \"internalType\": \"uint256\", \"name\": \"quantity\", \"type\": \"uint256\" }, { \"internalType\": \"uint256\", \"name\": \"closedAmount\", \"type\": \"uint256\" }, { \"components\": [{ \"internalType\": \"uint256\", \"name\": \"cva\", \"type\": \"uint256\" }, { \"internalType\": \"uint256\", \"name\": \"mm\", \"type\": \"uint256\" }, { \"internalType\": \"uint256\", \"name\": \"lf\", \"type\": \"uint256\" }], \"internalType\": \"struct LockedValues\", \"name\": \"initialLockedValues\", \"type\": \"tuple\" }, { \"components\": [{ \"internalType\": \"uint256\", \"name\": \"cva\", \"type\": \"uint256\" }, { \"internalType\": \"uint256\", \"name\": \"mm\", \"type\": \"uint256\" }, { \"internalType\": \"uint256\", \"name\": \"lf\", \"type\": \"uint256\" }], \"internalType\": \"struct LockedValues\", \"name\": \"lockedValues\", \"type\": \"tuple\" }, { \"internalType\": \"uint256\", \"name\": \"maxInterestRate\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"partyA\", \"type\": \"address\" }, { \"internalType\": \"address\", \"name\": \"partyB\", \"type\": \"address\" }, { \"internalType\": \"enum QuoteStatus\", \"name\": \"quoteStatus\", \"type\": \"uint8\" }, { \"internalType\": \"uint256\", \"name\": \"avgClosedPrice\", \"type\": \"uint256\" }, { \"internalType\": \"uint256\", \"name\": \"requestedClosePrice\", \"type\": \"uint256\" }, { \"internalType\": \"uint256\", \"name\": \"quantityToClose\", \"type\": \"uint256\" }, { \"internalType\": \"uint256\", \"name\": \"parentId\", \"type\": \"uint256\" }, { \"internalType\": \"uint256\", \"name\": \"createTimestamp\", \"type\": \"uint256\" }, { \"internalType\": \"uint256\", \"name\": \"modifyTimestamp\", \"type\": \"uint256\" }, { \"internalType\": \"uint256\", \"name\": \"deadline\", \"type\": \"uint256\" }], \"internalType\": \"struct Quote[]\", \"name\": \"\", \"type\": \"tuple[]\" }], \"stateMutability\": \"view\", \"type\": \"function\" }, { \"inputs\": [{ \"internalType\": \"address\", \"name\": \"partyB\", \"type\": \"address\" }, { \"internalType\": \"address\", \"name\": \"partyA\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"start\", \"type\": \"uint256\" }, { \"internalType\": \"uint256\", \"name\": \"size\", \"type\": \"uint256\" }], \"name\": \"getPartyBOpenPositions\", \"outputs\": [{ \"components\": [{ \"internalType\": \"uint256\", \"name\": \"id\", \"type\": \"uint256\" }, { \"internalType\": \"address[]\", \"name\": \"partyBsWhiteList\", \"type\": \"address[]\" }, { \"internalType\": \"uint256\", \"name\": \"symbolId\", \"type\": \"uint256\" }, { \"internalType\": \"enum PositionType\", \"name\": \"positionType\", \"type\": \"uint8\" }, { \"internalType\": \"enum OrderType\", \"name\": \"orderType\", \"type\": \"uint8\" }, { \"internalType\": \"uint256\", \"name\": \"openedPrice\", \"type\": \"uint256\" }, { \"internalType\": \"uint256\", \"name\": \"requestedOpenPrice\", \"type\": \"uint256\" }, { \"internalType\": \"uint256\", \"name\": \"marketPrice\", \"type\": \"uint256\" }, { \"internalType\": \"uint256\", \"name\": \"quantity\", \"type\": \"uint256\" }, { \"internalType\": \"uint256\", \"name\": \"closedAmount\", \"type\": \"uint256\" }, { \"components\": [{ \"internalType\": \"uint256\", \"name\": \"cva\", \"type\": \"uint256\" }, { \"internalType\": \"uint256\", \"name\": \"mm\", \"type\": \"uint256\" }, { \"internalType\": \"uint256\", \"name\": \"lf\", \"type\": \"uint256\" }], \"internalType\": \"struct LockedValues\", \"name\": \"initialLockedValues\", \"type\": \"tuple\" }, { \"components\": [{ \"internalType\": \"uint256\", \"name\": \"cva\", \"type\": \"uint256\" }, { \"internalType\": \"uint256\", \"name\": \"mm\", \"type\": \"uint256\" }, { \"internalType\": \"uint256\", \"name\": \"lf\", \"type\": \"uint256\" }], \"internalType\": \"struct LockedValues\", \"name\": \"lockedValues\", \"type\": \"tuple\" }, { \"internalType\": \"uint256\", \"name\": \"maxInterestRate\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"partyA\", \"type\": \"address\" }, { \"internalType\": \"address\", \"name\": \"partyB\", \"type\": \"address\" }, { \"internalType\": \"enum QuoteStatus\", \"name\": \"quoteStatus\", \"type\": \"uint8\" }, { \"internalType\": \"uint256\", \"name\": \"avgClosedPrice\", \"type\": \"uint256\" }, { \"internalType\": \"uint256\", \"name\": \"requestedClosePrice\", \"type\": \"uint256\" }, { \"internalType\": \"uint256\", \"name\": \"quantityToClose\", \"type\": \"uint256\" }, { \"internalType\": \"uint256\", \"name\": \"parentId\", \"type\": \"uint256\" }, { \"internalType\": \"uint256\", \"name\": \"createTimestamp\", \"type\": \"uint256\" }, { \"internalType\": \"uint256\", \"name\": \"modifyTimestamp\", \"type\": \"uint256\" }, { \"internalType\": \"uint256\", \"name\": \"deadline\", \"type\": \"uint256\" }], \"internalType\": \"struct Quote[]\", \"name\": \"\", \"type\": \"tuple[]\" }], \"stateMutability\": \"view\", \"type\": \"function\" }, { \"inputs\": [{ \"internalType\": \"uint256[]\", \"name\": \"symbolIds\", \"type\": \"uint256[]\" }], \"name\": \"symbolNameById\", \"outputs\": [{ \"internalType\": \"string[]\", \"name\": \"\", \"type\": \"string[]\" }], \"stateMutability\": \"view\", \"type\": \"function\" }]\nconst UPNL_TOLERANCE = scaleUp('0.001')\nconst PRICE_TOLERANCE = scaleUp('0.005')\nconst minusOne = new BN(-1)\n\nconst proxy = process.env.PROXY\n\nconst kucoinThousandPairs = ['PEPEUSDT', 'SHIBUSDT', 'FLOKIUSDT', 'LUNCUSDT']\nconst mexcThousandPairs = ['PEPEUSDT', 'SHIBUSDT', 'FLOKIUSDT', 'LUNCUSDT', 'XECUSDT']\n\nmodule.exports = {\n    APP_NAME: 'crypto_v3',\n\n    isP"
    }
  ]
}