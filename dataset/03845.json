{
  "Title": "Wrongly calculated ETH amount to transfer",
  "Content": "##### Description\nAt lines https://github.com/bondappetit/bondappetit-protocol/blob/355180f0aca0b29d60d808f761052956b7a3a159/contracts/profit/ProfitSplitter.sol#L198-L205 contract swaps whole `splitterIncomingBalance` to ETH if `splitterIncomingBalance` insufficient to cover gap between `splitterEthBalance` and `amount`, in other words contract try to get as much as closer to `amount` ETH amount. However as we can see in this block of code contract assigns `amountsOut[1]` to `amount`, it's wrong because we need to assign `splitterEthBalance.add(amountsOut[1])`\n\n##### Recommendation\nWe recommend to assign `splitterEthBalance.add(amountsOut[1])` to `amount` instead of `amountsOut[1]`\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/profit/ProfitSplitter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"../utils/OwnablePausable.sol\";\nimport \"../uniswap/IUniswapV2Router02.sol\";\n\ncontract ProfitSplitter is OwnablePausable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 public constant SHARE_ACCURACY = 6;\n\n    uint256 public constant SHARE_DIGITS = 2;\n\n    /// @notice Incoming token.\n    ERC20 public incoming;\n\n    /// @notice Budget contract address.\n    address payable public budget;\n\n    /// @notice Target budget ETH balance.\n    uint256 public budgetBalance;\n\n    /// @notice Recipients share.\n    mapping(address => uint256) public shares;\n\n    /// @dev Recipients addresses index.\n    EnumerableSet.AddressSet private recipientsIndex;\n\n    /// @notice Uniswap router contract address.\n    IUniswapV2Router02 public uniswapRouter;\n\n    /// @notice An event thats emitted when an incoming token transferred to recipient.\n    event Transfer(address recipient, uint256 amount);\n\n    /// @notice An event thats emitted when an budget contract address and target balance changed.\n    event BudgetChanged(address newBudget, uint256 newBalance);\n\n    /// @notice An event thats emitted when an incoming token changed.\n    event IncomingChanged(address newIncoming);\n\n    /// @notice An event thats emitted when an uniswap router contract address changed.\n    event UniswapRouterChanged(address newUniswapRouter);\n\n    /// @notice An event thats emitted when an recipient added.\n    event RecipientAdded(address recipient, uint256 share);\n\n    /// @notice An event thats emitted when an recipient removed.\n    event RecipientRemoved(address recipient);\n\n    /// @notice An event thats emitted when an profit payed to budget.\n    event PayToBudget(address recipient, uint256 amount);\n\n    /// @notice An event thats emitted when an profit payed to recipient.\n    event PayToRecipient(address recipient, uint256 amount);\n\n    receive() external payable {}\n\n    /**\n     * @param _incoming Address of incoming token.\n     * @param _uniswapRouter Address of Uniswap router contract.\n     */\n    constructor(address _incoming, address _uniswapRouter) public {\n        incoming = ERC20(_incoming);\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n    }\n\n    /**\n     * @notice Changed uniswap router contract address.\n     * @param _uniswapRouter Address new uniswap router contract.\n     */\n    function changeUniswapRouter(address _uniswapRouter) external onlyOwner {\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n        emit UniswapRouterChanged(_uniswapRouter);\n    }\n\n    /**\n     * @notice Changed budget contract address and target balance.\n     * @param _budget Address of budget contract.\n     * @param _budgetBalance Target budget balance.\n     */\n    function changeBudget(address payable _budget, uint256 _budgetBalance) external onlyOwner {\n        budget = _budget;\n        budgetBalance = _budgetBalance;\n        emit BudgetChanged(budget, budgetBalance);\n    }\n\n    /**\n     * @notice Transfer incoming token to recipient.\n     * @param _recipient Address of recipient.\n     * @param amount Amount of transferred token.\n     */\n    function transfer(address _recipient, uint256 amount) public onlyOwner {\n        require(_recipient != address(0), \"ProfitSplitter::transfer: cannot transfer to the zero address\");\n\n        incoming.safeTransfer(_recipient, amount);\n        emit Transfer(_recipient, amount);\n    }\n\n    /**\n     * @notice Change incoming token address.\n     * @param _incoming New incoming token address.\n     * @param _recipient Address of recipient.\n     */\n    function changeIncoming(address _incoming, address _recipient) external onlyOwner {\n        require(address(incoming) != _incoming, \"ProfitSplitter::changeIncoming: duplicate incoming token address\");\n\n        uint256 balance = incoming.balanceOf(address(this));\n        if (balance > 0) {\n            transfer(_recipient, balance);\n        }\n        incoming = ERC20(_incoming);\n        emit IncomingChanged(_incoming);\n    }\n\n    /**\n     * @dev Current share value.\n     * @return result Current share value.\n     */\n    function _currentShare() internal view returns (uint256 result) {\n        for (uint256 i = 0; i < recipientsIndex.length(); i++) {\n            result = result.add(shares[recipientsIndex.at(i)]);\n        }\n    }\n\n    /**\n     * @notice Add recipient.\n     * @param recipient Address of recipient contract.\n     * @param share Target share.\n     */\n    function addRecipient(address recipient, uint256 share) external onlyOwner {\n        require(!recipientsIndex.contains(recipient), \"ProfitSplitter::addRecipient: recipient already added\");\n        require(_currentShare().add(share) <= 100, \"ProfitSplitter::addRecipient: invalid share\");\n\n        recipientsIndex.add(recipient);\n        shares[recipient] = share;\n        emit RecipientAdded(recipient, share);\n    }\n\n    /**\n     * @notice Remove recipient.\n     * @param recipient Address of recipient contract.\n     */\n    function removeRecipient(address recipient) external onlyOwner {\n        require(recipientsIndex.contains(recipient), \"ProfitSplitter::removeRecipient: recipient already removed\");\n\n        recipientsIndex.remove(recipient);\n        shares[recipient] = 0;\n        emit RecipientRemoved(recipient);\n    }\n\n    /**\n     * @notice Get addresses of recipients.\n     * @return Current recipients list.\n     */\n    function getRecipients() public view returns (address[] memory) {\n        address[] memory result = new address[](recipientsIndex.length());\n\n        for (uint256 i = 0; i < recipientsIndex.length(); i++) {\n            result[i] = recipientsIndex.at(i);\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Pay ETH to budget contract.\n     */\n    function _payToBudget() internal returns (bool) {\n        uint256 splitterIncomingBalance = incoming.balanceOf(address(this));\n        if (splitterIncomingBalance == 0) return false;\n\n        uint256 currentBudgetBalance = budget.balance;\n        if (currentBudgetBalance >= budgetBalance) return false;\n\n        uint256 amount = budgetBalance.sub(currentBudgetBalance);\n        uint256 splitterEthBalance = address(this).balance;\n        if (splitterEthBalance < amount) {\n            uint256 amountOut = amount.sub(splitterEthBalance);\n\n            address[] memory path = new address[](2);\n            path[0] = address(incoming);\n            path[1] = uniswapRouter.WETH();\n\n            uint256[] memory amountsIn = uniswapRouter.getAmountsIn(amountOut, path);\n            require(amountsIn.length == 2, \"ProfitSplitter::_payToBudget: invalid amounts in length\");\n            require(amountsIn[0] > 0, \"ProfitSplitter::_payToBudget: liquidity pool is empty\");\n            if (amountsIn[0] <= splitterIncomingBalance) {\n                incoming.safeApprove(address(uniswapRouter), amountsIn[0]);\n                uniswapRouter.swapTokensForExactETH(amountOut, amountsIn[0], path, address(this), block.timestamp);\n            } else {\n                uint256[] memory amountsOut = uniswapRouter.getAmountsOut(splitterIncomingBalance, path);\n                require(amountsOut.length == 2, \"ProfitSplitter::_payToBudget: invalid amounts out length\");\n                require(amountsOut[1] > 0, \"ProfitSplitter::_payToBudget: amounts out liquidity pool is empty\");\n\n                amount = amountsOut[1];\n\n                incoming.safeApprove(address(uniswapRouter), splitterIncomingBalance);\n                uniswapRouter.swapExactTokensForETH(splitterIncomingBalance, amountsOut[1], path, address(this), block.timestamp);\n            }\n        }\n\n        budget.transfer(amount);\n        emit PayToBudget(budget, amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Pay incoming token to all recipients.\n     */\n    function _payToRecipients() internal returns (bool) {\n        uint256 splitterIncomingBalance = incoming.balanceOf(address(this));\n        if (splitterIncomingBalance == 0) return false;\n\n        for (uint256 i = 0; i < recipientsIndex.length(); i++) {\n            address recipient = recipientsIndex.at(i);\n            uint256 share = shares[recipient];\n\n            uint256 amount = splitterIncomingBalance.mul(10**SHARE_ACCURACY).mul(share).div(10**SHARE_ACCURACY.add(SHARE_DIGITS));\n            incoming.safeTransfer(recipient, amount);\n\n            emit PayToRecipient(recipient, amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Split all incoming token balance to recipients and budget contract.\n     * @param amount Approved amount incoming token.\n     */\n    function split(uint256 amount) external whenNotPaused {\n        if (amount > 0) {\n            incoming.safeTransferFrom(_msgSender(), address(this), amount);\n        }\n\n        _payToBudget();\n        _payToRecipients();\n    }\n}"
    }
  ]
}