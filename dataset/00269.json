{
  "Title": "M-1: L1 data fees are not reimbursed",
  "Content": "# Issue M-1: L1 data fees are not reimbursed \n\nSource: https://github.com/sherlock-audit/2024-04-xkeeper-judging/issues/57 \n\n## Found by \nIllIllI, Kirkeelee, Kose, LTDingZhen, s1ce\n## Summary\n\nL1 data fees are not reimbursed, and they are often orders of magnitude more expensive than the L2 gas fees being reimbursed. Not reimbursing these fees will lead to jobs not being executed on L2s.\n\n\n## Vulnerability Detail\n\nWhile the contest README says that the protocol is interested in all EVM-compatible chains, its not clear to what extent they need compatibility. For instance, many chains have workarounds for the fact that they need to publish data from the L2 to the L1 via calldata, and therefore charge for those operations directly. Such caveats indicate that the compatibility is not 100% and therefore we can't really assume that any random chain will be supported. However, the README explicitly mentions Optimism as a target chain, so its idiosyncracies are in-scope.\n\nThe Gelato protocol [properly](https://docs.gelato.network/web3-services/relay/gelatos-fee-oracle#arguments-2) handles L1 data fees, but neither Keep3r nor OpenRelay do. It could be argued that for Keep3r, it's possible to modify a job's fee rate dynamically and therefore it's not that big a risk, but for OpenRelay, the reimbursement formula is hard-coded, which means there's no workaround.\n\nLooking at a [transaction](https://optimistic.etherscan.io/tx/0x3c6aa4e1f5de25b14638147d6db893fdf8bff6a29dbe1fad86c93d6bfad2badd/advanced) from [this](https://xkeeper.network/optimism/vault/0xB1f5Ee0Ad3C469e9a88A77258dA5B56f9de2F219) vault, the transaction cost was 0.000305237594921218 ETH ($1.17) but only 0.00000008929694256 ETH (<$0.01) was reimbursed. The L1 data fee was 0.000304676890061656 Eth, whereas the gas fee was 0.000000111805735391.\n\n\n## Impact\n\nAs is shown in [this](https://github.com/sherlock-audit/2023-07-perennial-judging/issues/91#issuecomment-1704791659) analysis for another contest, the two fees do not have a fixed ratio, and the L1 data fee is frequently much larger than the L2 gas fee, for extended periods of time. This essentially means that the protocol is broken on L2s for any use case which requires timely executions. The contest README states that the sponsor is interested in issues where future integrations would be negatively impacted, and one such case would be where an exchange is trying to use xkeeper to handle customer operations, as is outlined at the end of the linked-to comment above. Operations will appear to hang for multiple hours at a time, causing loss of funds for customers trying to close their orders.\n\n\n## Code Snippet\n\nOnly the L2 gas is reimbursed, not any of the L1 data fees:\n```solidity\n// File: solidity/contracts/relays/OpenRelay.sol : OpenRelay.exec()   #1\n\n28        // Execute the automation vault counting the gas spent\n29        uint256 _initialGas = gasleft();\n30        _automationVault.exec(msg.sender, _execData, new IAutomationVault.FeeData[](0));\n31        uint256 _gasSpent = _initialGas - gasleft();\n32    \n33        // Calculate the payment for the relayer\n34        uint256 _payment = (_gasSpent + GAS_BONUS) * block.basefee * GAS_MULTIPLIER / BASE;\n35    \n36        // Send the payment to the relayer\n37        IAutomationVault.FeeData[] memory _feeData = new IAutomationVault.FeeData[](1);\n38        _feeData[0] = IAutomationVault.FeeData(_feeRecipient, _NATIVE_TOKEN, _payment);\n39:       _automationVault.exec(msg.sender, new IAutomationVault.ExecData[](0), _feeData);\n```\nhttps://github.com/sherlock-audit/2024-04-xkeeper/blob/main/xkeeper-core/solidity/contracts/relays/OpenRelay.sol#L28-L39\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nEvery L2 has its own formula for calculating the L1 data fee, so different versions of the code will have to be written for each L2. [This](https://docs.optimism.io/stack/transactions/fees#l1-data-fee) is the description for Optimism. Note that the Ecotone upgrade has occurred, so be sure to implement based on those or [these](https://specs.optimism.io/protocol/exec-engine.html#ecotone-l1-cost-fee-changes-eip-4844-da) instructions.\n\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**Kose** commented:\n>  medium\n\n\n\n**realfugazzi**\n\nWhy is this an issue? This is not the responsibility of the OpenRelay contract.\n\n**adam-idarrha**\n\n@realfugazzi because that contract is in scope , and written by xkeeper .\n\n**realfugazzi**\n\n@IllIllI000 how is this not a feature request, according to your logic? \n\nYou are stating that L1 fees are not reimbursed, but there is no place where this is posted as protocol requirement. Job executioners will simulate the op and see if reimbursement is fit for them. Looks like a feature request then, correct?\n\n**ashitakah**\n\nI agree, it is true that the payments in L2 would be too low to incentivize the work and we are working on improving the system, but it is not a vulnerability and continues to pay although in a residual way.\n\n**IllIllI000**\n\n@ashitakah isn't \"too low to incentivize the work\" a future integration issue for any project looking to use xkeeper on an L2?\n\n**BoRonG0d**\n\nContest readme explicitly states that the contract will be deployed on OP mainnet, and ALL information watson received during the competition did not indicate that OpenRelay would be used as future integration. So this is a valid issue.\n\nAnd, this was judged as high in the past:\n\nhttps://github.com/sherlock-audit/2023-07-perennial-judging/issues/91\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/248",
  "Code": [
    {
      "filename": "xkeeper-core/solidity/contracts/relays/OpenRelay.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\nimport {IOpenRelay} from '../../interfaces/relays/IOpenRelay.sol';\nimport {IAutomationVault} from '../../interfaces/core/IAutomationVault.sol';\nimport {_NATIVE_TOKEN} from '../../utils/Constants.sol';\n\n/**\n * @title  OpenRelay\n * @notice This contract will manage all executions coming from any bot\n */\ncontract OpenRelay is IOpenRelay {\n  /// @inheritdoc IOpenRelay\n  uint256 public constant GAS_BONUS = 53_000;\n  /// @inheritdoc IOpenRelay\n  uint256 public constant GAS_MULTIPLIER = 12_000;\n  /// @inheritdoc IOpenRelay\n  uint32 public constant BASE = 10_000;\n\n  /// @inheritdoc IOpenRelay\n  function exec(\n    IAutomationVault _automationVault,\n    IAutomationVault.ExecData[] calldata _execData,\n    address _feeRecipient\n  ) external {\n    if (_execData.length == 0) revert OpenRelay_NoExecData();\n\n    // Execute the automation vault counting the gas spent\n    uint256 _initialGas = gasleft();\n    _automationVault.exec(msg.sender, _execData, new IAutomationVault.FeeData[](0));\n    uint256 _gasSpent = _initialGas - gasleft();\n\n    // Calculate the payment for the relayer\n    uint256 _payment = (_gasSpent + GAS_BONUS) * block.basefee * GAS_MULTIPLIER / BASE;\n\n    // Send the payment to the relayer\n    IAutomationVault.FeeData[] memory _feeData = new IAutomationVault.FeeData[](1);\n    _feeData[0] = IAutomationVault.FeeData(_feeRecipient, _NATIVE_TOKEN, _payment);\n    _automationVault.exec(msg.sender, new IAutomationVault.ExecData[](0), _feeData);\n\n    // Emit the event\n    emit AutomationVaultExecuted(_automationVault, msg.sender, _execData, _feeData);\n  }\n}"
    }
  ]
}