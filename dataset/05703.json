{
  "Title": "[16] If `_enumerationIndexSize` is `0`, `compressedEnumIndex` equals `metadata`",
  "Content": "\nIn [Compressor, lines 175 to 177](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/Compressor.sol#L175C1-L179C81):\n\n```solidity\n            uint256 compressedEnumIndex = _sliceToUint256(_compressedStateDiffs[stateDiffPtr:stateDiffPtr + _enumerationIndexSize]);\n            require(enumIndex == compressedEnumIndex, \"rw: enum key mismatch\");\n            stateDiffPtr += _enumerationIndexSize;\n            \n            uint8 metadata = uint8(bytes1(_compressedStateDiffs[stateDiffPtr]));\n```\n\nIf `_enumerationIndexSize` is zero, then `compressedEnumIndex` and `metadata` will have the same value, as `stateDiffPtr += 0` equals `stateDiffPtr`.\n\n[Compressor, lines 117 to 126](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/Compressor.sol#L117C1-L126C109)\n\n```diff\n    function verifyCompressedStateDiffs(\n        uint256 _numberOfStateDiffs,\n        uint256 _enumerationIndexSize,\n        bytes calldata _stateDiffs,\n        bytes calldata _compressedStateDiffs\n    ) external payable onlyCallFrom(address(L1_MESSENGER_CONTRACT)) returns (bytes32 stateDiffHash) {\n        // We do not enforce the operator to use the optimal, i.e. the minimally possible _enumerationIndexSize. \n        // We do enforce however, that the _enumerationIndexSize is not larger than 8 bytes long, which is the \n        // maximal ever possible size for enumeration index.\n+       require(_enumerationIndexSize != 0, \"whatever\");\n        require(_enumerationIndexSize <= MAX_ENUMERATION_INDEX_SIZE, \"enumeration index size is too large\");\n\n        ...\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-10-zksync",
  "Code": [
    {
      "filename": "code/system-contracts/contracts/Compressor.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {ICompressor, OPERATION_BITMASK, LENGTH_BITS_OFFSET, MAX_ENUMERATION_INDEX_SIZE} from \"./interfaces/ICompressor.sol\";\nimport {ISystemContract} from \"./interfaces/ISystemContract.sol\";\nimport {Utils} from \"./libraries/Utils.sol\";\nimport {UnsafeBytesCalldata} from \"./libraries/UnsafeBytesCalldata.sol\";\nimport {EfficientCall} from \"./libraries/EfficientCall.sol\";\nimport {\n    L1_MESSENGER_CONTRACT,\n    INITIAL_WRITE_STARTING_POSITION,\n    COMPRESSED_INITIAL_WRITE_SIZE,\n    STATE_DIFF_ENTRY_SIZE,\n    STATE_DIFF_ENUM_INDEX_OFFSET,\n    STATE_DIFF_FINAL_VALUE_OFFSET,\n    STATE_DIFF_DERIVED_KEY_OFFSET,\n    DERIVED_KEY_LENGTH,\n    VALUE_LENGTH,\n    ENUM_INDEX_LENGTH,\n    KNOWN_CODE_STORAGE_CONTRACT\n} from \"./Constants.sol\";\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice Contract with code pertaining to compression for zkEVM; at the moment this is used for bytecode compression\n * and state diff compression validation.\n * @dev Every deployed bytecode/published state diffs in zkEVM should be publicly restorable from the L1 data availability.\n * For this reason, the user may request the sequencer to publish the original bytecode and mark it as known.\n * Or the user may compress the bytecode and publish it instead (fewer data onchain!). At the end of every L1 Batch\n * we publish pubdata, part of which contains the state diffs that occurred within the batch.\n */\ncontract Compressor is ICompressor, ISystemContract {\n    using UnsafeBytesCalldata for bytes;\n\n    /// @notice Verify the compressed bytecode and publish it on the L1.\n    /// @param _bytecode The original bytecode to be verified against.\n    /// @param _rawCompressedData The compressed bytecode in a format of:\n    ///    - 2 bytes: the length of the dictionary\n    ///    - N bytes: the dictionary\n    ///    - M bytes: the encoded data\n    /// @dev The dictionary is a sequence of 8-byte chunks, each of them has the associated index.\n    /// @dev The encoded data is a sequence of 2-byte chunks, each of them is an index of the dictionary.\n    /// @dev The compression algorithm works as follows:\n    ///     1. The original bytecode is split into 8-byte chunks.\n    ///     Since the bytecode size is always a multiple of 32, this is always possible.\n    ///     2. For each 8-byte chunk in the original bytecode:\n    ///         * If the chunk is not already in the dictionary, it is added to the dictionary array.\n    ///         * If the dictionary becomes overcrowded (2^16 + 1 elements), the compression process will fail.\n    ///         * The 2-byte index of the chunk in the dictionary is added to the encoded data.\n    /// @dev Currently, the method may be called only from the bootloader because the server is not ready to publish bytecodes\n    /// in internal transactions. However, in the future, we will allow everyone to publish compressed bytecodes.\n    function publishCompressedBytecode(\n        bytes calldata _bytecode,\n        bytes calldata _rawCompressedData\n    ) external payable onlyCallFromBootloader returns (bytes32 bytecodeHash) {\n        unchecked {\n            (bytes calldata dictionary, bytes calldata encodedData) = _decodeRawBytecode(_rawCompressedData);\n\n            require(dictionary.length % 8 == 0, \"Dictionary length should be a multiple of 8\");\n            require(dictionary.length <= 2 ** 16 * 8, \"Dictionary is too big\");\n            require(\n                encodedData.length * 4 == _bytecode.length,\n                \"Encoded data length should be 4 times shorter than the original bytecode\"\n            );\n\n            for (uint256 encodedDataPointer = 0; encodedDataPointer < encodedData.length; encodedDataPointer += 2) {\n                uint256 indexOfEncodedChunk = uint256(encodedData.readUint16(encodedDataPointer)) * 8;\n                require(indexOfEncodedChunk < dictionary.length, \"Encoded chunk index is out of bounds\");\n\n                uint64 encodedChunk = dictionary.readUint64(indexOfEncodedChunk);\n                uint64 realChunk = _bytecode.readUint64(encodedDataPointer * 4);\n\n                require(encodedChunk == realChunk, \"Encoded chunk does not match the original bytecode\");\n            }\n        }\n\n        bytecodeHash = Utils.hashL2Bytecode(_bytecode);\n        L1_MESSENGER_CONTRACT.sendToL1(_rawCompressedData);\n        KNOWN_CODE_STORAGE_CONTRACT.markBytecodeAsPublished(bytecodeHash);\n    }\n\n    /// @notice Verifies that the compression of state diffs has been done correctly for the {_stateDiffs} param.\n    /// @param _numberOfStateDiffs The number of state diffs being checked.\n    /// @param _enumerationIndexSize Number of bytes used to represent an enumeration index for repeated writes.\n    /// @param _stateDiffs Encoded full state diff structs. See the first dev comment below for encoding.\n    /// @param _compressedStateDiffs The compressed state diffs\n    /// @dev We don't verify that the size of {_stateDiffs} is equivalent to {_numberOfStateDiffs} * STATE_DIFF_ENTRY_SIZE since that check is\n    ///      done within the L1Messenger calling contract.\n    /// @return stateDiffHash Hash of the encoded (uncompressed) state diffs to be committed to via system log.\n    /// @dev This check assumes that the ordering of state diffs are sorted by (address, key) for the encoded state diffs and\n    ///      then the compressed are sorted the same but with all the initial writes coming before the repeated writes.\n    /// @dev state diff:   [20bytes address][32bytes key][32bytes derived key][8bytes enum index][32bytes initial value][32bytes final value]\n    /// @dev The compression format:\n    ///     - 2 bytes: number of initial writes\n    ///     - N bytes initial writes\n    ///         - 32 bytes derived key\n    ///         - 1 byte metadata: \n    ///             - first 5 bits: length in bytes of compressed value\n    ///             - last 3 bits: operation\n    ///                 - 0 -> Nothing (32 bytes)\n    ///                 - 1 -> Add\n    ///                 - 2 -> Subtract\n    ///                 - 3 -> Transform (< 32 bytes)\n    ///         - Len Bytes: Compressed Value\n    ///     - M bytes repeated writes\n    ///         - {_enumerationIndexSize} bytes for enumeration index\n    ///         - 1 byte metadata: \n    ///             - first 5 bits: length in bytes of compressed value\n    ///             - last 3 bits: operation\n    ///                 - 0 -> Nothing (32 bytes)\n    ///                 - 1 -> Add\n    ///                 - 2 -> Subtract\n    ///                 - 3 -> Transform (< 32 bytes)\n    ///         - Len Bytes: Compressed Value\n    function verifyCompressedStateDiffs(\n        uint256 _numberOfStateDiffs,\n        uint256 _enumerationIndexSize,\n        bytes calldata _stateDiffs,\n        bytes calldata _compressedStateDiffs\n    ) external payable onlyCallFrom(address(L1_MESSENGER_CONTRACT)) returns (bytes32 stateDiffHash) {\n        // We do not enforce the operator to use the optimal, i.e. the minimally possible _enumerationIndexSize. \n        // We do enforce however, that the _enumerationIndexSize is not larger than 8 bytes long, which is the \n        // maximal ever possible size for enumeration index.\n        require(_enumerationIndexSize <= MAX_ENUMERATION_INDEX_SIZE, \"enumeration index size is too large\");\n\n        uint256 numberOfInitialWrites = uint256(_compressedStateDiffs.readUint16(0));\n\n        uint256 stateDiffPtr = 2;\n        uint256 numInitialWritesProcessed = 0;\n\n        // Process initial writes\n        for (uint256 i = 0; i < _numberOfStateDiffs * STATE_DIFF_ENTRY_SIZE; i += STATE_DIFF_ENTRY_SIZE) {\n            bytes calldata stateDiff = _stateDiffs[i:i + STATE_DIFF_ENTRY_SIZE];\n            uint64 enumIndex = stateDiff.readUint64(84);\n            if (enumIndex != 0) {\n                // It is a repeated write, so we skip it.\n                continue;\n            }\n\n            numInitialWritesProcessed++;\n\n            bytes32 derivedKey = stateDiff.readBytes32(52);\n            uint256 initValue = stateDiff.readUint256(92);\n            uint256 finalValue = stateDiff.readUint256(124);\n            require(derivedKey == _compressedStateDiffs.readBytes32(stateDiffPtr), \"iw: initial key mismatch\");            \n            stateDiffPtr += 32;\n\n            uint8 metadata = uint8(bytes1(_compressedStateDiffs[stateDiffPtr]));\n            stateDiffPtr++;\n            uint8 operation = metadata & OPERATION_BITMASK;\n            uint8 len = operation == 0 ? 32 : metadata >> LENGTH_BITS_OFFSET;\n            _verifyValueCompression(\n                initValue,\n                finalValue,\n                operation,\n                _compressedStateDiffs[stateDiffPtr:stateDiffPtr + len]\n            );\n            stateDiffPtr += len;\n        }\n\n        require(numInitialWritesProcessed == numberOfInitialWrites, \"Incorrect number of initial storage diffs\");\n\n        // Process repeated writes\n        for (uint256 i = 0; i < _numberOfStateDiffs * STATE_DIFF_ENTRY_SIZE; i += STATE_DIFF_ENTRY_SIZE) {\n            bytes calldata stateDiff = _stateDiffs[i:i + STATE_DIFF_ENTRY_SIZE];\n            uint64 enumIndex = stateDiff.readUint64(84);\n            if (enumIndex == 0) {\n                continue;\n            }\n\n            uint256 initValue = stateDiff.readUint256(92);\n            uint256 finalValue = stateDiff.readUint256(124);\n            uint256 compressedEnumIndex = _sliceToUint256(_compressedStateDiffs[stateDiffPtr:stateDiffPtr + _enumerationIndexSize]);\n            require(enumIndex == compressedEnumIndex, \"rw: enum key mismatch\");\n            stateDiffPtr += _enumerationIndexSize;\n\n            uint8 metadata = uint8(bytes1(_compressedStateDiffs[stateDiffPtr]));\n            stateDiffPtr += 1;\n            uint8 operation = metadata & OPERATION_BITMASK;\n            uint8 len = operation == 0 ? 32 : metadata >> LENGTH_BITS_OFFSET;\n            _verifyValueCompression(\n                initValue,\n                finalValue,\n                operation,\n                _compressedStateDiffs[stateDiffPtr:stateDiffPtr + len]\n            );\n            stateDiffPtr += len;\n        }\n\n        require(stateDiffPtr == _compressedStateDiffs.length, \"Extra data in _compressedStateDiffs\");\n\n        stateDiffHash = EfficientCall.keccak(_stateDiffs);\n    }\n\n    /// @notice Decode the raw compressed data into the dictionary and the encoded data.\n    /// @param _rawCompressedData The compressed bytecode in a format of:\n    ///    - 2 bytes: the bytes length of the dictionary\n    ///    - N bytes: the dictionary\n    ///    - M bytes: the encoded data\n    function _decodeRawBytecode(\n        bytes calldata _rawCompressedData\n    ) internal pure returns (bytes calldata dictionary, bytes calldata encodedData) {\n        unchecked {\n            // The dictionary length can't be more than 2^16, so it fits into 2 bytes.\n            uint256 dictionaryLen = uint256(_rawCompressedData.readUint16(0));\n            dictionary = _rawCompressedData[2:2 + dictionaryLen * 8];\n            encodedData = _rawCompressedData[2 + dictionaryLen * 8:];\n        }\n    }\n\n    /// @notice Verify value compression was done correct given initial value, final value, operation, and compressed value\n    /// @param _initialValue Previous value of key/enumeration index.\n    /// @param _finalValue Updated value of key/enumeration index.\n    /// @param _operation The operation that was performed on value.\n    /// @param _compressedValue The slice of calldata with compressed value either representing the final \n    /// value or difference between initial and final value. It should be of arbitrary length less than or equal to 32 bytes.\n    /// @dev It is the responsibility of the caller of this function to ensure that the `_compressedValue` has length no longer than 32 bytes.\n    /// @dev Operation id mapping:\n    /// 0 -> Nothing (32 bytes)\n    /// 1 -> Add\n    /// 2 -> Subtract\n    /// 3 -> Transform (< 32 bytes)\n    function _verifyValueCompression(\n        uint256 _initialValue,\n        uint256 _finalValue,\n        uint256 _operation,\n        bytes calldata _compressedValue\n    ) internal pure {\n        uint256 convertedValue = _sliceToUint256(_compressedValue);\n\n        unchecked {\n            if (_operation == 0 || _operation == 3) {\n                require(convertedValue == _finalValue, \"transform or no compression: compressed and final mismatch\");\n            } else if (_operation == 1) {\n                require(_initialValue + convertedValue == _finalValue, \"add: initial plus converted not equal to final\");\n            } else if (_operation == 2) {\n                require(_initialValue - convertedValue == _finalValue, \"sub: initial minus converted not equal to final\");\n            } else {\n                revert(\"unsupported operation\");\n            }\n        }\n    }\n\n    /// @notice Converts a calldata slice into uint256. It is the responsibility of the caller to ensure that\n    /// the _calldataSlice has length no longer than 32 bytes\n    /// @param _calldataSlice The calldata slice to convert to uint256\n    /// @return number The uint256 representation of the calldata slice\n    function _sliceToUint256(bytes calldata _calldataSlice) internal pure returns (uint256 number) {\n        number = uint256(bytes32(_calldataSlice));\n        number >>= (256 - (_calldataSlice.length * 8));\n    }\n}"
    },
    {
      "filename": "code/system-contracts/contracts/Compressor.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {ICompressor, OPERATION_BITMASK, LENGTH_BITS_OFFSET, MAX_ENUMERATION_INDEX_SIZE} from \"./interfaces/ICompressor.sol\";\nimport {ISystemContract} from \"./interfaces/ISystemContract.sol\";\nimport {Utils} from \"./libraries/Utils.sol\";\nimport {UnsafeBytesCalldata} from \"./libraries/UnsafeBytesCalldata.sol\";\nimport {EfficientCall} from \"./libraries/EfficientCall.sol\";\nimport {\n    L1_MESSENGER_CONTRACT,\n    INITIAL_WRITE_STARTING_POSITION,\n    COMPRESSED_INITIAL_WRITE_SIZE,\n    STATE_DIFF_ENTRY_SIZE,\n    STATE_DIFF_ENUM_INDEX_OFFSET,\n    STATE_DIFF_FINAL_VALUE_OFFSET,\n    STATE_DIFF_DERIVED_KEY_OFFSET,\n    DERIVED_KEY_LENGTH,\n    VALUE_LENGTH,\n    ENUM_INDEX_LENGTH,\n    KNOWN_CODE_STORAGE_CONTRACT\n} from \"./Constants.sol\";\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice Contract with code pertaining to compression for zkEVM; at the moment this is used for bytecode compression\n * and state diff compression validation.\n * @dev Every deployed bytecode/published state diffs in zkEVM should be publicly restorable from the L1 data availability.\n * For this reason, the user may request the sequencer to publish the original bytecode and mark it as known.\n * Or the user may compress the bytecode and publish it instead (fewer data onchain!). At the end of every L1 Batch\n * we publish pubdata, part of which contains the state diffs that occurred within the batch.\n */\ncontract Compressor is ICompressor, ISystemContract {\n    using UnsafeBytesCalldata for bytes;\n\n    /// @notice Verify the compressed bytecode and publish it on the L1.\n    /// @param _bytecode The original bytecode to be verified against.\n    /// @param _rawCompressedData The compressed bytecode in a format of:\n    ///    - 2 bytes: the length of the dictionary\n    ///    - N bytes: the dictionary\n    ///    - M bytes: the encoded data\n    /// @dev The dictionary is a sequence of 8-byte chunks, each of them has the associated index.\n    /// @dev The encoded data is a sequence of 2-byte chunks, each of them is an index of the dictionary.\n    /// @dev The compression algorithm works as follows:\n    ///     1. The original bytecode is split into 8-byte chunks.\n    ///     Since the bytecode size is always a multiple of 32, this is always possible.\n    ///     2. For each 8-byte chunk in the original bytecode:\n    ///         * If the chunk is not already in the dictionary, it is added to the dictionary array.\n    ///         * If the dictionary becomes overcrowded (2^16 + 1 elements), the compression process will fail.\n    ///         * The 2-byte index of the chunk in the dictionary is added to the encoded data.\n    /// @dev Currently, the method may be called only from the bootloader because the server is not ready to publish bytecodes\n    /// in internal transactions. However, in the future, we will allow everyone to publish compressed bytecodes.\n    function publishCompressedBytecode(\n        bytes calldata _bytecode,\n        bytes calldata _rawCompressedData\n    ) external payable onlyCallFromBootloader returns (bytes32 bytecodeHash) {\n        unchecked {\n            (bytes calldata dictionary, bytes calldata encodedData) = _decodeRawBytecode(_rawCompressedData);\n\n            require(dictionary.length % 8 == 0, \"Dictionary length should be a multiple of 8\");\n            require(dictionary.length <= 2 ** 16 * 8, \"Dictionary is too big\");\n            require(\n                encodedData.length * 4 == _bytecode.length,\n                \"Encoded data length should be 4 times shorter than the original bytecode\"\n            );\n\n            for (uint256 encodedDataPointer = 0; encodedDataPointer < encodedData.length; encodedDataPointer += 2) {\n                uint256 indexOfEncodedChunk = uint256(encodedData.readUint16(encodedDataPointer)) * 8;\n                require(indexOfEncodedChunk < dictionary.length, \"Encoded chunk index is out of bounds\");\n\n                uint64 encodedChunk = dictionary.readUint64(indexOfEncodedChunk);\n                uint64 realChunk = _bytecode.readUint64(encodedDataPointer * 4);\n\n                require(encodedChunk == realChunk, \"Encoded chunk does not match the original bytecode\");\n            }\n        }\n\n        bytecodeHash = Utils.hashL2Bytecode(_bytecode);\n        L1_MESSENGER_CONTRACT.sendToL1(_rawCompressedData);\n        KNOWN_CODE_STORAGE_CONTRACT.markBytecodeAsPublished(bytecodeHash);\n    }\n\n    /// @notice Verifies that the compression of state diffs has been done correctly for the {_stateDiffs} param.\n    /// @param _numberOfStateDiffs The number of state diffs being checked.\n    /// @param _enumerationIndexSize Number of bytes used to represent an enumeration index for repeated writes.\n    /// @param _stateDiffs Encoded full state diff structs. See the first dev comment below for encoding.\n    /// @param _compressedStateDiffs The compressed state diffs\n    /// @dev We don't verify that the size of {_stateDiffs} is equivalent to {_numberOfStateDiffs} * STATE_DIFF_ENTRY_SIZE since that check is\n    ///      done within the L1Messenger calling contract.\n    /// @return stateDiffHash Hash of the encoded (uncompressed) state diffs to be committed to via system log.\n    /// @dev This check assumes that the ordering of state diffs are sorted by (address, key) for the encoded state diffs and\n    ///      then the compressed are sorted the same but with all the initial writes coming before the repeated writes.\n    /// @dev state diff:   [20bytes address][32bytes key][32bytes derived key][8bytes enum index][32bytes initial value][32bytes final value]\n    /// @dev The compression format:\n    ///     - 2 bytes: number of initial writes\n    ///     - N bytes initial writes\n    ///         - 32 bytes derived key\n    ///         - 1 byte metadata: \n    ///             - first 5 bits: length in bytes of compressed value\n    ///             - last 3 bits: operation\n    ///                 - 0 -> Nothing (32 bytes)\n    ///                 - 1 -> Add\n    ///                 - 2 -> Subtract\n    ///                 - 3 -> Transform (< 32 bytes)\n    ///         - Len Bytes: Compressed Value\n    ///     - M bytes repeated writes\n    ///         - {_enumerationIndexSize} bytes for enumeration index\n    ///         - 1 byte metadata: \n    ///             - first 5 bits: length in bytes of compressed value\n    ///             - last 3 bits: operation\n    ///                 - 0 -> Nothing (32 bytes)\n    ///                 - 1 -> Add\n    ///                 - 2 -> Subtract\n    ///                 - 3 -> Transform (< 32 bytes)\n    ///         - Len Bytes: Compressed Value\n    function verifyCompressedStateDiffs(\n        uint256 _numberOfStateDiffs,\n        uint256 _enumerationIndexSize,\n        bytes calldata _stateDiffs,\n        bytes calldata _compressedStateDiffs\n    ) external payable onlyCallFrom(address(L1_MESSENGER_CONTRACT)) returns (bytes32 stateDiffHash) {\n        // We do not enforce the operator to use the optimal, i.e. the minimally possible _enumerationIndexSize. \n        // We do enforce however, that the _enumerationIndexSize is not larger than 8 bytes long, which is the \n        // maximal ever possible size for enumeration index.\n        require(_enumerationIndexSize <= MAX_ENUMERATION_INDEX_SIZE, \"enumeration index size is too large\");\n\n        uint256 numberOfInitialWrites = uint256(_compressedStateDiffs.readUint16(0));\n\n        uint256 stateDiffPtr = 2;\n        uint256 numInitialWritesProcessed = 0;\n\n        // Process initial writes\n        for (uint256 i = 0; i < _numberOfStateDiffs * STATE_DIFF_ENTRY_SIZE; i += STATE_DIFF_ENTRY_SIZE) {\n            bytes calldata stateDiff = _stateDiffs[i:i + STATE_DIFF_ENTRY_SIZE];\n            uint64 enumIndex = stateDiff.readUint64(84);\n            if (enumIndex != 0) {\n                // It is a repeated write, so we skip it.\n                continue;\n            }\n\n            numInitialWritesProcessed++;\n\n            bytes32 derivedKey = stateDiff.readBytes32(52);\n            uint256 initValue = stateDiff.readUint256(92);\n            uint256 finalValue = stateDiff.readUint256(124);\n            require(derivedKey == _compressedStateDiffs.readBytes32(stateDiffPtr), \"iw: initial key mismatch\");            \n            stateDiffPtr += 32;\n\n            uint8 metadata = uint8(bytes1(_compressedStateDiffs[stateDiffPtr]));\n            stateDiffPtr++;\n            uint8 operation = metadata & OPERATION_BITMASK;\n            uint8 len = operation == 0 ? 32 : metadata >> LENGTH_BITS_OFFSET;\n            _verifyValueCompression(\n                initValue,\n                finalValue,\n                operation,\n                _compressedStateDiffs[stateDiffPtr:stateDiffPtr + len]\n            );\n            stateDiffPtr += len;\n        }\n\n        require(numInitialWritesProcessed == numberOfInitialWrites, \"Incorrect number of initial storage diffs\");\n\n        // Process repeated writes\n        for (uint256 i = 0; i < _numberOfStateDiffs * STATE_DIFF_ENTRY_SIZE; i += STATE_DIFF_ENTRY_SIZE) {\n            bytes calldata stateDiff = _stateDiffs[i:i + STATE_DIFF_ENTRY_SIZE];\n            uint64 enumIndex = stateDiff.readUint64(84);\n            if (enumIndex == 0) {\n                continue;\n            }\n\n            uint256 initValue = stateDiff.readUint256(92);\n            uint256 finalValue = stateDiff.readUint256(124);\n            uint256 compressedEnumIndex = _sliceToUint256(_compressedStateDiffs[stateDiffPtr:stateDiffPtr + _enumerationIndexSize]);\n            require(enumIndex == compressedEnumIndex, \"rw: enum key mismatch\");\n            stateDiffPtr += _enumerationIndexSize;\n\n            uint8 metadata = uint8(bytes1(_compressedStateDiffs[stateDiffPtr]));\n            stateDiffPtr += 1;\n            uint8 operation = metadata & OPERATION_BITMASK;\n            uint8 len = operation == 0 ? 32 : metadata >> LENGTH_BITS_OFFSET;\n            _verifyValueCompression(\n                initValue,\n                finalValue,\n                operation,\n                _compressedStateDiffs[stateDiffPtr:stateDiffPtr + len]\n            );\n            stateDiffPtr += len;\n        }\n\n        require(stateDiffPtr == _compressedStateDiffs.length, \"Extra data in _compressedStateDiffs\");\n\n        stateDiffHash = EfficientCall.keccak(_stateDiffs);\n    }\n\n    /// @notice Decode the raw compressed data into the dictionary and the encoded data.\n    /// @param _rawCompressedData The compressed bytecode in a format of:\n    ///    - 2 bytes: the bytes length of the dictionary\n    ///    - N bytes: the dictionary\n    ///    - M bytes: the encoded data\n    function _decodeRawBytecode(\n        bytes calldata _rawCompressedData\n    ) internal pure returns (bytes calldata dictionary, bytes calldata encodedData) {\n        unchecked {\n            // The dictionary length can't be more than 2^16, so it fits into 2 bytes.\n            uint256 dictionaryLen = uint256(_rawCompressedData.readUint16(0));\n            dictionary = _rawCompressedData[2:2 + dictionaryLen * 8];\n            encodedData = _rawCompressedData[2 + dictionaryLen * 8:];\n        }\n    }\n\n    /// @notice Verify value compression was done correct given initial value, final value, operation, and compressed value\n    /// @param _initialValue Previous value of key/enumeration index.\n    /// @param _finalValue Updated value of key/enumeration index.\n    /// @param _operation The operation that was performed on value.\n    /// @param _compressedValue The slice of calldata with compressed value either representing the final \n    /// value or difference between initial and final value. It should be of arbitrary length less than or equal to 32 bytes.\n    /// @dev It is the responsibility of the caller of this function to ensure that the `_compressedValue` has length no longer than 32 bytes.\n    /// @dev Operation id mapping:\n    /// 0 -> Nothing (32 bytes)\n    /// 1 -> Add\n    /// 2 -> Subtract\n    /// 3 -> Transform (< 32 bytes)\n    function _verifyValueCompression(\n        uint256 _initialValue,\n        uint256 _finalValue,\n        uint256 _operation,\n        bytes calldata _compressedValue\n    ) internal pure {\n        uint256 convertedValue = _sliceToUint256(_compressedValue);\n\n        unchecked {\n            if (_operation == 0 || _operation == 3) {\n                require(convertedValue == _finalValue, \"transform or no compression: compressed and final mismatch\");\n            } else if (_operation == 1) {\n                require(_initialValue + convertedValue == _finalValue, \"add: initial plus converted not equal to final\");\n            } else if (_operation == 2) {\n                require(_initialValue - convertedValue == _finalValue, \"sub: initial minus converted not equal to final\");\n            } else {\n                revert(\"unsupported operation\");\n            }\n        }\n    }\n\n    /// @notice Converts a calldata slice into uint256. It is the responsibility of the caller to ensure that\n    /// the _calldataSlice has length no longer than 32 bytes\n    /// @param _calldataSlice The calldata slice to convert to uint256\n    /// @return number The uint256 representation of the calldata slice\n    function _sliceToUint256(bytes calldata _calldataSlice) internal pure returns (uint256 number) {\n        number = uint256(bytes32(_calldataSlice));\n        number >>= (256 - (_calldataSlice.length * 8));\n    }\n}"
    }
  ]
}