{
  "Title": "M-5: BBCommon::_accrue wrong value is used to prevent overflow",
  "Content": "# Issue M-5: BBCommon::_accrue wrong value is used to prevent overflow \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/41 \n\n## Found by \ncergyk, duc\n## Summary\nA mechanism is used in `_accrue`, to prevent overflow in order to avoid Dos on multiple entrypoints of a BigBang market (many external functions call on `_accrue` before executing their logic). However the wrong value is used to prevent an overflow, and even though it could be prevented the first time, it should overflow the second one it is called\n\n## Vulnerability Detail\nWe can see that the value to be accrued is clamped to [type(uint128).max - totalBorrowCap](https://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/bigBang/BBCommon.sol#L107)\n\nWhich works the first time to avoid an overflow since `totalBorrow.elastic` should be less than `totalBorrowCap`. However if `totalBorrow.elastic` is already bigger than `totalBorrowCap` (due to a previous accrual), this clamping does not prevent overflow.\n\n## Impact\n`_accrue` can still revert due to an overflow blocking most of the functions of a `BigBang` market.\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\nClamp accrued value to `type(uint128).max - totalBorrow.elastic` instead\n\n\n\n## Discussion\n\n**cryptotechmaker**\n\nFixed by https://github.com/Tapioca-DAO/Tapioca-bar/pull/351\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/Tapioca-bar/pull/351.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "Tapioca-bar/contracts/markets/bigBang/BBCommon.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\n\n// Tapioca\nimport {IBigBang} from \"tapioca-periph/interfaces/bar/IBigBang.sol\";\nimport {SafeApprove} from \"../../libraries/SafeApprove.sol\";\nimport {BBStorage} from \"./BBStorage.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract BBCommon is BBStorage {\n    using RebaseLibrary for Rebase;\n    using SafeCast for uint256;\n    using SafeApprove for address;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error NotEnough();\n    error TransferFailed();\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice returns total market debt\n    function getTotalDebt() external view returns (uint256) {\n        return totalBorrow.elastic;\n    }\n\n    /// @notice returns the current debt rate\n    function getDebtRate() public view returns (uint256) {\n        if (isMainMarket) return penrose.bigBangEthDebtRate(); // default 0.5%\n        if (totalBorrow.elastic == 0) return minDebtRate;\n\n        uint256 _ethMarketTotalDebt = IBigBang(penrose.bigBangEthMarket()).getTotalDebt();\n        uint256 _currentDebt = totalBorrow.elastic;\n        uint256 _maxDebtPoint = (_ethMarketTotalDebt * debtRateAgainstEthMarket) / 1e18;\n\n        if (_currentDebt >= _maxDebtPoint) return maxDebtRate;\n\n        uint256 debtPercentage = (_currentDebt * DEBT_PRECISION) / _maxDebtPoint;\n        uint256 debt = ((maxDebtRate - minDebtRate) * debtPercentage) / DEBT_PRECISION + minDebtRate;\n\n        if (debt > maxDebtRate) return maxDebtRate;\n\n        return debt;\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice Accrues the interest on the borrowed tokens and handles the accumulation of fees.\n    function accrue() external {\n        _accrue();\n    }\n\n    function _accrueView() internal view override returns (Rebase memory _totalBorrow) {\n        uint256 elapsedTime = block.timestamp - accrueInfo.lastAccrued;\n        if (elapsedTime == 0) {\n            return totalBorrow;\n        }\n\n        // Calculate fees\n        _totalBorrow = totalBorrow;\n        uint256 extraAmount = (uint256(_totalBorrow.elastic) * (getDebtRate() / 31536000) * elapsedTime) / 1e18;\n        uint256 max = type(uint128).max - totalBorrowCap;\n\n        if (extraAmount > max) {\n            extraAmount = max;\n        }\n        _totalBorrow.elastic += extraAmount.toUint128();\n    }\n\n    function _accrue() internal override {\n        IBigBang.AccrueInfo memory _accrueInfo = accrueInfo;\n        // Number of seconds since accrue was called\n        uint256 elapsedTime = block.timestamp - _accrueInfo.lastAccrued;\n        if (elapsedTime == 0) {\n            return;\n        }\n        //update debt rate\n        uint256 annumDebtRate = getDebtRate();\n        _accrueInfo.debtRate = (annumDebtRate / 31557600).toUint64(); //per second; account for leap years\n        _accrueInfo.lastAccrued = block.timestamp.toUint64();\n\n        Rebase memory _totalBorrow = totalBorrow;\n\n        // Calculate fees\n        uint256 extraAmount = 0;\n        extraAmount = (uint256(_totalBorrow.elastic) * _accrueInfo.debtRate * elapsedTime) / 1e18;\n\n        // cap `extraAmount` to avoid overflow risk when converting it from uint256 to uint128\n        uint256 max = type(uint128).max - totalBorrowCap;\n\n        if (extraAmount > max) {\n            extraAmount = max;\n        }\n        _totalBorrow.elastic += extraAmount.toUint128();\n\n        totalBorrow = _totalBorrow;\n        accrueInfo = _accrueInfo;\n\n        emit LogAccrue(extraAmount, _accrueInfo.debtRate);\n    }\n\n    /// @dev Helper function to move tokens.\n    /// @param from Account to debit tokens from, in `yieldBox`.\n    /// @param _tokenId The ERC-20 token asset ID in yieldBox.\n    /// @param share The amount in shares to add.\n    /// @param total Grand total amount to deduct from this contract's balance. Only applicable if `skim` is True.\n    /// Only used for accounting checks.\n    /// @param skim If True, only does a balance check on this contract.\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\n    function _addTokens(address from, uint256 _tokenId, uint256 share, uint256 total, bool skim) internal {\n        if (skim) {\n            require(share <= yieldBox.balanceOf(address(this), _tokenId) - total, \"BB: too much\");\n        } else {\n            // yieldBox.transfer(from, address(this), _tokenId, share);\n            bool isErr = pearlmit.transferFromERC1155(from, address(this), address(yieldBox), _tokenId, share);\n            if (isErr) {\n                revert TransferFailed();\n            }\n        }\n    }\n\n    /// @notice deposits an amount to YieldBox\n    /// @param token the IERC20 token to deposit\n    /// @param to the shares receiver\n    /// @param id the IERC20 YieldBox asset id\n    /// @param amount the amount to deposit\n    function _depositAmountToYb(IERC20 token, address to, uint256 id, uint256 amount)\n        internal\n        returns (uint256 share)\n    {\n        address(token).safeApprove(address(yieldBox), amount);\n        (, share) = yieldBox.depositAsset(id, address(this), to, amount, 0);\n    }\n}"
    }
  ]
}