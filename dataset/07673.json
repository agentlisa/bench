{
  "Title": "[M-20] smartWallet address is not guaranteed correct. ETH may be lost",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/SavETHVault.sol#L206-L207\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/SavETHVault.sol#L209\n\n\n# Vulnerability details\n\n## Impact\nLiquid staking manager call `function withdrawETHForStaking(address _smartWallet, uint256 _amount)` to withdraw ETH for staking. It's manager's responsibility to set the correct `_smartWallet` address. However, there is no way to guarantee this. If a typo (or any other reasons) leads to a non-zero non-existent `_smartWallet` address, this function won't be able to detect the problem, and the [ETH transfer statement](https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/SavETHVault.sol#L209) will always return `true`. This will result in the ETH permanently locked to a non-existent account.\n\n## Proof of Concept\nLiquid staking manager call `function withdrawETHForStaking(address _smartWallet, uint256 _amount)` with a non-zero non-existent `_smartWallet` address and some `_amount` of ETH. Function call will succeed but the ETH will be locked to the non-existent `_smartWallet` address.\n\n## Tools Used\nManual audit.\n\n## Recommended Mitigation Steps\nThe problem can be solved if we can verify the `_smartWallet` is a valid existent smartWallet before ETH transfer. The easiest solution is to verify the smartWallet has a valid owner since the smart wallet we are using is ownable. So, just add the checking owner code before [ETH transfer](https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/SavETHVault.sol#L209).",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-lsd-network-stakehouse-contest",
  "Code": [
    {
      "filename": "contracts/liquid-staking/SavETHVault.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { IDataStructures } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol\";\n\nimport { ILiquidStakingManager } from \"../interfaces/ILiquidStakingManager.sol\";\n\nimport { StakingFundsVault } from \"./StakingFundsVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { ETHPoolLPFactory } from \"./ETHPoolLPFactory.sol\";\nimport { LPTokenFactory } from \"./LPTokenFactory.sol\";\n\ncontract SavETHVault is Initializable, ETHPoolLPFactory, ReentrancyGuard {\n\n    /// @notice signalize transfer of dETH to depositor\n    event DETHRedeemed(address depositor, uint256 amount);\n\n    /// @notice signalize withdrawal of ETH for staking\n    event ETHWithdrawnForStaking(address withdrawalAddress, address liquidStakingManager, uint256 amount);\n\n    /// @notice Liquid staking manager instance\n    ILiquidStakingManager public liquidStakingManager;\n\n    /// @notice index id of the savETH index owned by the vault\n    uint256 public indexOwnedByTheVault;\n\n    /// @notice dETH related details for a KNOT\n    /// @dev If dETH is not withdrawn, then for a non-existing dETH balance\n    /// the structure would result in zero balance even though dETH isn't withdrawn for KNOT\n    /// withdrawn parameter tracks the status of dETH for a KNOT\n    struct KnotDETHDetails {\n        uint256 savETHBalance;\n        bool withdrawn;\n    }\n\n    /// @notice dETH associated with the KNOT\n    mapping(bytes => KnotDETHDetails) public dETHForKnot;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    function init(address _liquidStakingManagerAddress, LPTokenFactory _lpTokenFactory) external virtual initializer {\n        _init(_liquidStakingManagerAddress, _lpTokenFactory);\n    }\n\n    modifier onlyManager {\n        require(msg.sender == address(liquidStakingManager), \"Not the savETH vault manager\");\n        _;\n    }\n\n    /// @notice Stake ETH against multiple BLS keys and specify the amount of ETH being supplied for each key\n    /// @param _blsPublicKeyOfKnots BLS public key of the validators being staked and that are registered with the LSD network\n    /// @param _amounts Amount of ETH being supplied for the BLS public key at the same array index\n    function batchDepositETHForStaking(bytes[] calldata _blsPublicKeyOfKnots, uint256[] calldata _amounts) external payable {\n        uint256 numOfValidators = _blsPublicKeyOfKnots.length;\n        require(numOfValidators > 0, \"Empty arrays\");\n        require(numOfValidators == _amounts.length, \"Inconsistent array lengths\");\n\n        uint256 totalAmount;\n        for (uint256 i; i < numOfValidators; ++i) {\n            require(liquidStakingManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnots[i]) == false, \"BLS public key is not part of LSD network\");\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnots[i]) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n                \"Lifecycle status must be one\"\n            );\n\n            uint256 amount = _amounts[i];\n            totalAmount += amount;\n            _depositETHForStaking(_blsPublicKeyOfKnots[i], amount, false);\n        }\n\n        // Ensure that the sum of LP tokens issued equals the ETH deposited into the contract\n        require(msg.value == totalAmount, \"Invalid ETH amount attached\");\n    }\n\n    /// @notice function to allow users to deposit any amount of ETH for staking\n    /// @param _blsPublicKeyOfKnot BLS Public Key of the potential KNOT for which user is contributing\n    /// @param _amount number of ETH (input in wei) contributed by the user for staking\n    /// @return amount of ETH contributed for staking by the user\n    function depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount) public payable returns (uint256) {\n        require(liquidStakingManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key is banned or not a part of LSD network\");\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Lifecycle status must be one\"\n        );\n\n        require(msg.value == _amount, \"Must provide correct amount of ETH\");\n        _depositETHForStaking(_blsPublicKeyOfKnot, _amount, false);\n\n        return _amount;\n    }\n\n    /// @notice Burn multiple LP tokens in a batch to claim either ETH (if not staked) or dETH (if derivatives minted)\n    /// @param _blsPublicKeys List of BLS public keys that have received liquidity\n    /// @param _amounts Amount of each LP token that the user wants to burn in exchange for either ETH (if not staked) or dETH (if derivatives minted)\n    function burnLPTokensByBLS(bytes[] calldata _blsPublicKeys, uint256[] calldata _amounts) external {\n        uint256 numOfTokens = _blsPublicKeys.length;\n        require(numOfTokens > 0, \"Empty arrays\");\n        require(numOfTokens == _amounts.length, \"Inconsistent array length\");\n        for (uint256 i; i < numOfTokens; ++i) {\n            LPToken token = lpTokenForKnot[_blsPublicKeys[i]];\n            burnLPToken(token, _amounts[i]);\n        }\n    }\n\n    /// @notice Burn multiple LP tokens in a batch to claim either ETH (if not staked) or dETH (if derivatives minted)\n    /// @param _lpTokens List of LP token addresses held by the caller\n    /// @param _amounts Amount of each LP token that the user wants to burn in exchange for either ETH (if not staked) or dETH (if derivatives minted)\n    function burnLPTokens(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external {\n        uint256 numOfTokens = _lpTokens.length;\n        require(numOfTokens > 0, \"Empty arrays\");\n        require(numOfTokens == _amounts.length, \"Inconsisent array length\");\n        for (uint256 i; i < numOfTokens; ++i) {\n            burnLPToken(_lpTokens[i], _amounts[i]);\n        }\n    }\n\n    event CurrentStamp(uint256 stamp, uint256 last, bool isConditionTrue);\n    /// @notice function to allow users to burn LP token in exchange of ETH or dETH\n    /// @param _lpToken instance of LP token to be burnt\n    /// @param _amount number of LP tokens the user wants to burn\n    /// @return amount of ETH withdrawn\n    function burnLPToken(LPToken _lpToken, uint256 _amount) public nonReentrant returns (uint256) {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Amount cannot be zero\");\n        require(_amount <= _lpToken.balanceOf(msg.sender), \"Not enough balance\");\n\n        // get BLS public key for the LP token\n        bytes memory blsPublicKeyOfKnot = KnotAssociatedWithLPToken[_lpToken];\n        IDataStructures.LifecycleStatus validatorStatus = getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfKnot);\n\n        require(\n            validatorStatus == IDataStructures.LifecycleStatus.INITIALS_REGISTERED ||\n            validatorStatus == IDataStructures.LifecycleStatus.TOKENS_MINTED,\n            \"Cannot burn LP tokens\"\n        );\n\n        // before burning, check the last LP token interaction and make sure its more than 30 mins old before permitting ETH withdrawals\n        bool isStaleLiquidity = _lpToken.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp;\n\n        // burn the amount of LP token from depositor's wallet\n        _lpToken.burn(msg.sender, _amount);\n        emit LPTokenBurnt(blsPublicKeyOfKnot, address(_lpToken), msg.sender, _amount);\n\n        if(validatorStatus == IDataStructures.LifecycleStatus.TOKENS_MINTED) {\n            // return dETH\n            // amount of dETH redeemed by user for given LP token\n            uint256 redemptionValue;\n\n            KnotDETHDetails storage dETHDetails = dETHForKnot[blsPublicKeyOfKnot];\n\n            if(!dETHDetails.withdrawn) {\n                // withdraw dETH if not done already\n\n                // get dETH balance for the KNOT\n                uint256 dETHBalance = getSavETHRegistry().knotDETHBalanceInIndex(indexOwnedByTheVault, blsPublicKeyOfKnot);\n                uint256 savETHBalance = getSavETHRegistry().dETHToSavETH(dETHBalance);\n                // This require should never fail but is there for sanity purposes\n                require(dETHBalance >= 24 ether, \"Nothing to withdraw\");\n\n                // withdraw savETH from savETH index to the savETH vault\n                // contract gets savETH and not the dETH\n                getSavETHRegistry().addKnotToOpenIndex(liquidStakingManager.stakehouse(), blsPublicKeyOfKnot, address(this));\n\n                // update mapping\n                dETHDetails.withdrawn = true;\n                dETHDetails.savETHBalance = savETHBalance;\n                dETHForKnot[blsPublicKeyOfKnot] = dETHDetails;\n            }\n\n            // redeem savETH from the vault\n            redemptionValue = (dETHDetails.savETHBalance * _amount) / 24 ether;\n\n            // withdraw dETH (after burning the savETH)\n            getSavETHRegistry().withdraw(msg.sender, uint128(redemptionValue));\n\n            uint256 dETHRedeemed = getSavETHRegistry().savETHToDETH(redemptionValue);\n\n            emit DETHRedeemed(msg.sender, dETHRedeemed);\n            return redemptionValue;\n        }\n\n        // Before allowing ETH withdrawals we check the value of isStaleLiquidity fetched before burn\n        require(isStaleLiquidity, \"Liquidity is still fresh\");\n\n        // return ETH for LifecycleStatus.INITIALS_REGISTERED\n        (bool result,) = msg.sender.call{value: _amount}(\"\");\n        require(result, \"Transfer failed\");\n        emit ETHWithdrawnByDepositor(msg.sender, _amount);\n\n        return _amount;\n    }\n\n    /// @notice function to allow liquid staking manager to withdraw ETH for staking\n    /// @param _smartWallet address of the smart wallet that receives ETH\n    /// @param _amount amount of ETH to be withdrawn\n    /// @return amount of ETH withdrawn\n    function withdrawETHForStaking(\n        address _smartWallet,\n        uint256 _amount\n    ) public onlyManager nonReentrant returns (uint256) {\n        require(_amount >= 24 ether, \"Amount cannot be less than 24 ether\");\n        require(address(this).balance >= _amount, \"Insufficient withdrawal amount\");\n        require(_smartWallet != address(0), \"Zero address\");\n        require(_smartWallet != address(this), \"This address\");\n\n        (bool result,) = _smartWallet.call{value: _amount}(\"\");\n        require(result, \"Transfer failed\");\n\n        emit ETHWithdrawnForStaking(_smartWallet, msg.sender, _amount);\n\n        return _amount;\n    }\n\n    /// @notice Utility function that proxies through to the liquid staking manager to check whether the BLS key ever registered with the network\n    function isBLSPublicKeyPartOfLSDNetwork(bytes calldata _blsPublicKeyOfKnot) public virtual view returns (bool) {\n        return liquidStakingManager.isBLSPublicKeyPartOfLSDNetwork(_blsPublicKeyOfKnot);\n    }\n\n    /// @notice Utility function that proxies through to the liquid staking manager to check whether the BLS key ever registered with the network but is now banned\n    function isBLSPublicKeyBanned(bytes calldata _blsPublicKeyOfKnot) public view returns (bool) {\n        return liquidStakingManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnot);\n    }\n\n    /// @notice Utility function that determins whether an LP can be burned for dETH if the associated derivatives have been minted\n    function isDETHReadyForWithdrawal(address _lpTokenAddress) external view returns (bool) {\n        bytes memory blsPublicKeyOfKnot = KnotAssociatedWithLPToken[LPToken(_lpTokenAddress)];\n        IDataStructures.LifecycleStatus validatorStatus = getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfKnot);\n        return validatorStatus == IDataStructures.LifecycleStatus.TOKENS_MINTED;\n    }\n\n    /// @dev Logic required for initialization\n    function _init(address _liquidStakingManagerAddress, LPTokenFactory _lpTokenFactory) internal {\n        require(_liquidStakingManagerAddress != address(0), \"Zero address\");\n        require(address(_lpTokenFactory) != address(0), \"Zero address\");\n\n        lpTokenFactory = _lpTokenFactory;\n        liquidStakingManager = ILiquidStakingManager(_liquidStakingManagerAddress);\n\n        baseLPTokenName = \"dstETHToken_\";\n        baseLPTokenSymbol = \"dstETH_\";\n        maxStakingAmountPerValidator = 24 ether;\n\n        // create a savETH index owned by the vault\n        indexOwnedByTheVault = getSavETHRegistry().createIndex(address(this));\n    }\n}"
    },
    {
      "filename": "contracts/liquid-staking/SavETHVault.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { IDataStructures } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol\";\n\nimport { ILiquidStakingManager } from \"../interfaces/ILiquidStakingManager.sol\";\n\nimport { StakingFundsVault } from \"./StakingFundsVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { ETHPoolLPFactory } from \"./ETHPoolLPFactory.sol\";\nimport { LPTokenFactory } from \"./LPTokenFactory.sol\";\n\ncontract SavETHVault is Initializable, ETHPoolLPFactory, ReentrancyGuard {\n\n    /// @notice signalize transfer of dETH to depositor\n    event DETHRedeemed(address depositor, uint256 amount);\n\n    /// @notice signalize withdrawal of ETH for staking\n    event ETHWithdrawnForStaking(address withdrawalAddress, address liquidStakingManager, uint256 amount);\n\n    /// @notice Liquid staking manager instance\n    ILiquidStakingManager public liquidStakingManager;\n\n    /// @notice index id of the savETH index owned by the vault\n    uint256 public indexOwnedByTheVault;\n\n    /// @notice dETH related details for a KNOT\n    /// @dev If dETH is not withdrawn, then for a non-existing dETH balance\n    /// the structure would result in zero balance even though dETH isn't withdrawn for KNOT\n    /// withdrawn parameter tracks the status of dETH for a KNOT\n    struct KnotDETHDetails {\n        uint256 savETHBalance;\n        bool withdrawn;\n    }\n\n    /// @notice dETH associated with the KNOT\n    mapping(bytes => KnotDETHDetails) public dETHForKnot;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    function init(address _liquidStakingManagerAddress, LPTokenFactory _lpTokenFactory) external virtual initializer {\n        _init(_liquidStakingManagerAddress, _lpTokenFactory);\n    }\n\n    modifier onlyManager {\n        require(msg.sender == address(liquidStakingManager), \"Not the savETH vault manager\");\n        _;\n    }\n\n    /// @notice Stake ETH against multiple BLS keys and specify the amount of ETH being supplied for each key\n    /// @param _blsPublicKeyOfKnots BLS public key of the validators being staked and that are registered with the LSD network\n    /// @param _amounts Amount of ETH being supplied for the BLS public key at the same array index\n    function batchDepositETHForStaking(bytes[] calldata _blsPublicKeyOfKnots, uint256[] calldata _amounts) external payable {\n        uint256 numOfValidators = _blsPublicKeyOfKnots.length;\n        require(numOfValidators > 0, \"Empty arrays\");\n        require(numOfValidators == _amounts.length, \"Inconsistent array lengths\");\n\n        uint256 totalAmount;\n        for (uint256 i; i < numOfValidators; ++i) {\n            require(liquidStakingManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnots[i]) == false, \"BLS public key is not part of LSD network\");\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnots[i]) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n                \"Lifecycle status must be one\"\n            );\n\n            uint256 amount = _amounts[i];\n            totalAmount += amount;\n            _depositETHForStaking(_blsPublicKeyOfKnots[i], amount, false);\n        }\n\n        // Ensure that the sum of LP tokens issued equals the ETH deposited into the contract\n        require(msg.value == totalAmount, \"Invalid ETH amount attached\");\n    }\n\n    /// @notice function to allow users to deposit any amount of ETH for staking\n    /// @param _blsPublicKeyOfKnot BLS Public Key of the potential KNOT for which user is contributing\n    /// @param _amount number of ETH (input in wei) contributed by the user for staking\n    /// @return amount of ETH contributed for staking by the user\n    function depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount) public payable returns (uint256) {\n        require(liquidStakingManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key is banned or not a part of LSD network\");\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Lifecycle status must be one\"\n        );\n\n        require(msg.value == _amount, \"Must provide correct amount of ETH\");\n        _depositETHForStaking(_blsPublicKeyOfKnot, _amount, false);\n\n        return _amount;\n    }\n\n    /// @notice Burn multiple LP tokens in a batch to claim either ETH (if not staked) or dETH (if derivatives minted)\n    /// @param _blsPublicKeys List of BLS public keys that have received liquidity\n    /// @param _amounts Amount of each LP token that the user wants to burn in exchange for either ETH (if not staked) or dETH (if derivatives minted)\n    function burnLPTokensByBLS(bytes[] calldata _blsPublicKeys, uint256[] calldata _amounts) external {\n        uint256 numOfTokens = _blsPublicKeys.length;\n        require(numOfTokens > 0, \"Empty arrays\");\n        require(numOfTokens == _amounts.length, \"Inconsistent array length\");\n        for (uint256 i; i < numOfTokens; ++i) {\n            LPToken token = lpTokenForKnot[_blsPublicKeys[i]];\n            burnLPToken(token, _amounts[i]);\n        }\n    }\n\n    /// @notice Burn multiple LP tokens in a batch to claim either ETH (if not staked) or dETH (if derivatives minted)\n    /// @param _lpTokens List of LP token addresses held by the caller\n    /// @param _amounts Amount of each LP token that the user wants to burn in exchange for either ETH (if not staked) or dETH (if derivatives minted)\n    function burnLPTokens(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external {\n        uint256 numOfTokens = _lpTokens.length;\n        require(numOfTokens > 0, \"Empty arrays\");\n        require(numOfTokens == _amounts.length, \"Inconsisent array length\");\n        for (uint256 i; i < numOfTokens; ++i) {\n            burnLPToken(_lpTokens[i], _amounts[i]);\n        }\n    }\n\n    event CurrentStamp(uint256 stamp, uint256 last, bool isConditionTrue);\n    /// @notice function to allow users to burn LP token in exchange of ETH or dETH\n    /// @param _lpToken instance of LP token to be burnt\n    /// @param _amount number of LP tokens the user wants to burn\n    /// @return amount of ETH withdrawn\n    function burnLPToken(LPToken _lpToken, uint256 _amount) public nonReentrant returns (uint256) {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Amount cannot be zero\");\n        require(_amount <= _lpToken.balanceOf(msg.sender), \"Not enough balance\");\n\n        // get BLS public key for the LP token\n        bytes memory blsPublicKeyOfKnot = KnotAssociatedWithLPToken[_lpToken];\n        IDataStructures.LifecycleStatus validatorStatus = getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfKnot);\n\n        require(\n            validatorStatus == IDataStructures.LifecycleStatus.INITIALS_REGISTERED ||\n            validatorStatus == IDataStructures.LifecycleStatus.TOKENS_MINTED,\n            \"Cannot burn LP tokens\"\n        );\n\n        // before burning, check the last LP token interaction and make sure its more than 30 mins old before permitting ETH withdrawals\n        bool isStaleLiquidity = _lpToken.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp;\n\n        // burn the amount of LP token from depositor's wallet\n        _lpToken.burn(msg.sender, _amount);\n        emit LPTokenBurnt(blsPublicKeyOfKnot, address(_lpToken), msg.sender, _amount);\n\n        if(validatorStatus == IDataStructures.LifecycleStatus.TOKENS_MINTED) {\n            // return dETH\n            // amount of dETH redeemed by user for given LP token\n            uint256 redemptionValue;\n\n            KnotDETHDetails storage dETHDetails = dETHForKnot[blsPublicKeyOfKnot];\n\n            if(!dETHDetails.withdrawn) {\n                // withdraw dETH if not done already\n\n                // get dETH balance for the KNOT\n                uint256 dETHBalance = getSavETHRegistry().knotDETHBalanceInIndex(indexOwnedByTheVault, blsPublicKeyOfKnot);\n                uint256 savETHBalance = getSavETHRegistry().dETHToSavETH(dETHBalance);\n                // This require should never fail but is there for sanity purposes\n                require(dETHBalance >= 24 ether, \"Nothing to withdraw\");\n\n                // withdraw savETH from savETH index to the savETH vault\n                // contract gets savETH and not the dETH\n                getSavETHRegistry().addKnotToOpenIndex(liquidStakingManager.stakehouse(), blsPublicKeyOfKnot, address(this));\n\n                // update mapping\n                dETHDetails.withdrawn = true;\n                dETHDetails.savETHBalance = savETHBalance;\n                dETHForKnot[blsPublicKeyOfKnot] = dETHDetails;\n            }\n\n            // redeem savETH from the vault\n            redemptionValue = (dETHDetails.savETHBalance * _amount) / 24 ether;\n\n            // withdraw dETH (after burning the savETH)\n            getSavETHRegistry().withdraw(msg.sender, uint128(redemptionValue));\n\n            uint256 dETHRedeemed = getSavETHRegistry().savETHToDETH(redemptionValue);\n\n            emit DETHRedeemed(msg.sender, dETHRedeemed);\n            return redemptionValue;\n        }\n\n        // Before allowing ETH withdrawals we check the value of isStaleLiquidity fetched before burn\n        require(isStaleLiquidity, \"Liquidity is still fresh\");\n\n        // return ETH for LifecycleStatus.INITIALS_REGISTERED\n        (bool result,) = msg.sender.call{value: _amount}(\"\");\n        require(result, \"Transfer failed\");\n        emit ETHWithdrawnByDepositor(msg.sender, _amount);\n\n        return _amount;\n    }\n\n    /// @notice function to allow liquid staking manager to withdraw ETH for staking\n    /// @param _smartWallet address of the smart wallet that receives ETH\n    /// @param _amount amount of ETH to be withdrawn\n    /// @return amount of ETH withdrawn\n    function withdrawETHForStaking(\n        address _smartWallet,\n        uint256 _amount\n    ) public onlyManager nonReentrant returns (uint256) {\n        require(_amount >= 24 ether, \"Amount cannot be less than 24 ether\");\n        require(address(this).balance >= _amount, \"Insufficient withdrawal amount\");\n        require(_smartWallet != address(0), \"Zero address\");\n        require(_smartWallet != address(this), \"This address\");\n\n        (bool result,) = _smartWallet.call{value: _amount}(\"\");\n        require(result, \"Transfer failed\");\n\n        emit ETHWithdrawnForStaking(_smartWallet, msg.sender, _amount);\n\n        return _amount;\n    }\n\n    /// @notice Utility function that proxies through to the liquid staking manager to check whether the BLS key ever registered with the network\n    function isBLSPublicKeyPartOfLSDNetwork(bytes calldata _blsPublicKeyOfKnot) public virtual view returns (bool) {\n        return liquidStakingManager.isBLSPublicKeyPartOfLSDNetwork(_blsPublicKeyOfKnot);\n    }\n\n    /// @notice Utility function that proxies through to the liquid staking manager to check whether the BLS key ever registered with the network but is now banned\n    function isBLSPublicKeyBanned(bytes calldata _blsPublicKeyOfKnot) public view returns (bool) {\n        return liquidStakingManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnot);\n    }\n\n    /// @notice Utility function that determins whether an LP can be burned for dETH if the associated derivatives have been minted\n    function isDETHReadyForWithdrawal(address _lpTokenAddress) external view returns (bool) {\n        bytes memory blsPublicKeyOfKnot = KnotAssociatedWithLPToken[LPToken(_lpTokenAddress)];\n        IDataStructures.LifecycleStatus validatorStatus = getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfKnot);\n        return validatorStatus == IDataStructures.LifecycleStatus.TOKENS_MINTED;\n    }\n\n    /// @dev Logic required for initialization\n    function _init(address _liquidStakingManagerAddress, LPTokenFactory _lpTokenFactory) internal {\n        require(_liquidStakingManagerAddress != address(0), \"Zero address\");\n        require(address(_lpTokenFactory) != address(0), \"Zero address\");\n\n        lpTokenFactory = _lpTokenFactory;\n        liquidStakingManager = ILiquidStakingManager(_liquidStakingManagerAddress);\n\n        baseLPTokenName = \"dstETHToken_\";\n        baseLPTokenSymbol = \"dstETH_\";\n        maxStakingAmountPerValidator = 24 ether;\n\n        // create a savETH index owned by the vault\n        indexOwnedByTheVault = getSavETHRegistry().createIndex(address(this));\n    }\n}"
    }
  ]
}