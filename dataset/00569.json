{
  "Title": "M-1: Stargate `STG` rewards are accounted incorrectly by `StakedStargateAM.sol`",
  "Content": "# Issue M-1: Stargate `STG` rewards are accounted incorrectly by `StakedStargateAM.sol` \n\nSource: https://github.com/sherlock-audit/2023-12-arcadia-judging/issues/38 \n\n## Found by \n0xVolodya, 0xrice.cooker, AuditorPraise, FCSE507, Hajime, Tricko, ast3ros, cu5t0mPe0, deth, ge6a, infect3d, mstpr-brainbot, pash0k, pkqs90, rvierdiiev, zzykxx\n## Summary\nStargate [LP_STAKING_TIME](https://basescan.org/address/0x06Eb48763f117c7Be887296CDcdfad2E4092739C#code) contract clears and sends rewards to the caller every time `deposit()` is called but [StakedStargateAM](https://github.com/sherlock-audit/2023-12-arcadia/blob/main/accounts-v2/src/asset-modules/Stargate-Finance/StakedStargateAM.sol) does not take it into account.\n\n## Vulnerability Detail\n When either [mint()](https://github.com/sherlock-audit/2023-12-arcadia/blob/main/accounts-v2/src/asset-modules/abstracts/AbstractStakingAM.sol#L285-L320) or [increaseLiquidity()](https://github.com/sherlock-audit/2023-12-arcadia/blob/main/accounts-v2/src/asset-modules/abstracts/AbstractStakingAM.sol#L327-L354) are called the `assetState[asset].lastRewardGlobal` variable is not reset to `0` even though the rewards have been transferred and accounted for on stargate side.\n\nAfter a call to [mint()](https://github.com/sherlock-audit/2023-12-arcadia/blob/main/accounts-v2/src/asset-modules/abstracts/AbstractStakingAM.sol#L285-L320) or [increaseLiquidity()](https://github.com/sherlock-audit/2023-12-arcadia/blob/main/accounts-v2/src/asset-modules/abstracts/AbstractStakingAM.sol#L327-L354) any subsequent call to either [mint()](https://github.com/sherlock-audit/2023-12-arcadia/blob/main/accounts-v2/src/asset-modules/abstracts/AbstractStakingAM.sol#L285-L320), [increaseLiquidity()](https://github.com/sherlock-audit/2023-12-arcadia/blob/main/accounts-v2/src/asset-modules/abstracts/AbstractStakingAM.sol#L327-L354), [burn()](https://github.com/sherlock-audit/2023-12-arcadia/blob/main/accounts-v2/src/asset-modules/abstracts/AbstractStakingAM.sol#L360), [decreaseLiquidity()](https://github.com/sherlock-audit/2023-12-arcadia/blob/main/accounts-v2/src/asset-modules/abstracts/AbstractStakingAM.sol#L371), [claimRewards()](https://github.com/sherlock-audit/2023-12-arcadia/blob/main/accounts-v2/src/asset-modules/abstracts/AbstractStakingAM.sol#L430) or [rewardOf()](https://github.com/sherlock-audit/2023-12-arcadia/blob/main/accounts-v2/src/asset-modules/abstracts/AbstractStakingAM.sol#L511-L520), which all internally call [_getRewardBalances()](https://github.com/sherlock-audit/2023-12-arcadia/blob/main/accounts-v2/src/asset-modules/abstracts/AbstractStakingAM.sol#L529-L569),  will either revert for underflow or account for less rewards than it should because `assetState_.lastRewardGlobal` has not been correctly reset to `0` but `currentRewardGlobal` (which is fetched from stargate) has:\n```solidity\nuint256 currentRewardGlobal = _getCurrentReward(positionState_.asset);\nuint256 deltaReward = currentRewardGlobal - assetState_.lastRewardGlobal; ❌\n```\n```solidity\nfunction _getCurrentReward(address asset) internal view override returns (uint256 currentReward) {\n    currentReward = LP_STAKING_TIME.pendingEmissionToken(assetToPid[asset], address(this));\n}\n```\n### POC\nTo copy-paste in `USDbCPool.fork.t.sol`:\n```solidity\nfunction testFork_WrongRewards() public {\n    uint256 initBalance = 1000 * 10 ** USDbC.decimals();\n    // Given : A user deposits in the Stargate USDbC pool, in exchange of an LP token.\n    vm.startPrank(users.accountOwner);\n    deal(address(USDbC), users.accountOwner, initBalance);\n\n    USDbC.approve(address(router), initBalance);\n    router.addLiquidity(poolId, initBalance, users.accountOwner);\n    // assert(ERC20(address(pool)).balanceOf(users.accountOwner) > 0);\n\n    // And : The user stakes the LP token via the StargateAssetModule\n    uint256 stakedAmount = ERC20(address(pool)).balanceOf(users.accountOwner);\n    ERC20(address(pool)).approve(address(stakedStargateAM), stakedAmount);\n    uint256 tokenId = stakedStargateAM.mint(address(pool), uint128(stakedAmount) / 4);\n\n    //We let 10 days pass to accumulate rewards.\n    vm.warp(block.timestamp + 10 days);\n\n    // User increases liquidity of the position.\n    uint256 initialRewards = stakedStargateAM.rewardOf(tokenId);\n    stakedStargateAM.increaseLiquidity(tokenId, 1);\n\n    vm.expectRevert();\n    stakedStargateAM.burn(tokenId); //❌ User can't call burn because of underflow\n\n    //We let 10 days pass, this accumulates enough rewards for the call to burn to succeed\n    vm.warp(block.timestamp + 10 days);\n    uint256 currentRewards = stakedStargateAM.rewardOf(tokenId);\n    stakedStargateAM.burn(tokenId);\n\n    assert(currentRewards - initialRewards < 1e10); //❌ User gets less rewards than he should. The rewards of the 10 days the user couldn't withdraw his position are basically zeroed out.\n    vm.stopPrank();\n}\n```\n\n\n## Impact\n\nUsers will not be able to take any action on their positions until `currentRewardGlobal` is greater or equal to `assetState_.lastRewardGlobal`. After that they will be able to perform actions but their position will account for less rewards than it should because a total amount of `assetState_.lastRewardGlobal` rewards is nullified. \n\nThis will also DOS the whole lending/borrowing system if an Arcadia Stargate position is used as collateral because [rewardOf()](https://github.com/sherlock-audit/2023-12-arcadia/blob/main/accounts-v2/src/asset-modules/abstracts/AbstractStakingAM.sol#L511-L520), which is called to estimate the collateral value, also reverts.\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdjust the `assetState[asset].lastRewardGlobal` correctly or since every action (`mint()`, `burn()`, `increaseLiquidity()`, `decreaseliquidity()`, `claimReward()`) will have the effect of withdrawing all the current rewards it's possible to change the function [_getRewardBalances()](https://github.com/sherlock-audit/2023-12-arcadia/blob/main/accounts-v2/src/asset-modules/abstracts/AbstractStakingAM.sol#L529-L569) to use the amount returned by [_getCurrentReward()](https://github.com/sherlock-audit/2023-12-arcadia/blob/main/accounts-v2/src/asset-modules/Stargate-Finance/StakedStargateAM.sol#L113-L115) as the `deltaReward` directly:\n```solidity\nuint256 deltaReward = _getCurrentReward(positionState_.asset);\n```\n\n\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid: high(1)\n\n\n\n**Thomas-Smets**\n\nDuplicate from https://github.com/sherlock-audit/2023-12-arcadia-judging/issues/18\n\n**sherlock-admin**\n\nThe protocol team fixed this issue in PR/commit https://github.com/arcadia-finance/accounts-v2/pull/170.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/137",
  "Code": [
    {
      "filename": "accounts-v2/src/asset-modules/abstracts/AbstractStakingAM.sol",
      "content": "/**\n * Created by Pragma Labs\n * SPDX-License-Identifier: BUSL-1.1\n */\npragma solidity 0.8.22;\n\nimport { AssetValuationLib, AssetValueAndRiskFactors } from \"../../libraries/AssetValuationLib.sol\";\nimport { ERC20 } from \"../../../lib/solmate/src/tokens/ERC20.sol\";\nimport { ERC721 } from \"../../../lib/solmate/src/tokens/ERC721.sol\";\nimport { DerivedAM, FixedPointMathLib, IRegistry } from \"./AbstractDerivedAM.sol\";\nimport { ReentrancyGuard } from \"../../../lib/solmate/src/utils/ReentrancyGuard.sol\";\nimport { SafeCastLib } from \"../../../lib/solmate/src/utils/SafeCastLib.sol\";\nimport { SafeTransferLib } from \"../../../lib/solmate/src/utils/SafeTransferLib.sol\";\nimport { Strings } from \"../../libraries/Strings.sol\";\n\n/**\n * @title Staking Module\n * @author Pragma Labs\n * @notice Abstract contract with the minimal implementation of a wrapper contract for Assets staked in an external staking contract.\n * @dev The staking Module is an ERC721 contract that does the accounting per Asset (staking token) and per position owner for:\n *  - The balances of Assets staked through this contract.\n *  - The balances of reward tokens earned for staking the Assets.\n * Next to keeping the accounting of balances, this contract manages the interactions with the external staking contract:\n *  - Staking Assets.\n *  - Withdrawing the Assets from staked positions.\n *  - Claiming reward tokens.\n */\nabstract contract StakingAM is DerivedAM, ERC721, ReentrancyGuard {\n    using FixedPointMathLib for uint256;\n    using Strings for uint256;\n    using SafeTransferLib for ERC20;\n\n    /* //////////////////////////////////////////////////////////////\n                                CONSTANTS\n    ////////////////////////////////////////////////////////////// */\n\n    // The reward token.\n    ERC20 public immutable REWARD_TOKEN;\n\n    /* //////////////////////////////////////////////////////////////\n                                STORAGE\n    ////////////////////////////////////////////////////////////// */\n\n    // The id of last minted position.\n    uint256 internal lastPositionId;\n\n    // The baseURI of the ERC721 tokens.\n    string public baseURI;\n\n    // Map Asset to its corresponding struct with global state.\n    mapping(address asset => AssetState) public assetState;\n    // Map a position id to its corresponding struct with the position state.\n    mapping(uint256 position => PositionState) public positionState;\n\n    // Struct with the global state per Asset.\n    struct AssetState {\n        // Flag indicating if the asset is allowed.\n        bool allowed;\n        // The growth of reward tokens per Asset staked, at the last interaction with this contract,\n        // with 18 decimals precision.\n        uint128 lastRewardPerTokenGlobal;\n        // The unclaimed amount of reward tokens, at the last interaction with this contract.\n        uint128 lastRewardGlobal;\n        // The total amount of Assets staked.\n        uint128 totalStaked;\n    }\n\n    // Struct with the Position specific state.\n    struct PositionState {\n        // The staked Asset.\n        address asset;\n        // Total amount of Asset staked for this position.\n        uint128 amountStaked;\n        // The growth of reward tokens per Asset staked, at the last interaction of the position owner with this contract,\n        // with 18 decimals precision.\n        uint128 lastRewardPerTokenPosition;\n        // The unclaimed amount of reward tokens of the position owner, at the last interaction of the owner with this contract.\n        uint128 lastRewardPosition;\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                                EVENTS\n    ////////////////////////////////////////////////////////////// */\n\n    event LiquidityDecreased(uint256 indexed positionId, address indexed asset, uint128 amount);\n    event LiquidityIncreased(uint256 indexed positionId, address indexed asset, uint128 amount);\n    event RewardPaid(uint256 indexed positionId, address indexed reward, uint128 amount);\n\n    /* //////////////////////////////////////////////////////////////\n                                ERRORS\n    ////////////////////////////////////////////////////////////// */\n\n    error AssetNotAllowed();\n    error NotOwner();\n    error ZeroAmount();\n\n    /* //////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    ////////////////////////////////////////////////////////////// */\n\n    constructor(address registry, string memory name_, string memory symbol_)\n        DerivedAM(registry, 1)\n        ERC721(name_, symbol_)\n    { }\n\n    /* //////////////////////////////////////////////////////////////\n                               INITIALIZE\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice This function will add this contract as an asset in the Registry.\n     * @dev Will revert if called more than once.\n     */\n    function initialize() external onlyOwner {\n        inAssetModule[address(this)] = true;\n\n        IRegistry(REGISTRY).addAsset(address(this));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ASSET MANAGEMENT\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Adds an asset that can be staked to this contract.\n     * @param asset The contract address of the Asset.\n     */\n    function _addAsset(address asset) internal {\n        assetState[asset].allowed = true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ASSET INFORMATION\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Checks for a token address and the corresponding id if it is allowed.\n     * @param asset The contract address of the asset.\n     * @param assetId The id of the asset.\n     * @return allowed A boolean, indicating if the asset is allowed.\n     */\n    function isAllowed(address asset, uint256 assetId) public view override returns (bool allowed) {\n        if (asset == address(this) && assetId <= lastPositionId) allowed = true;\n    }\n\n    /**\n     * @notice Returns the unique identifiers of the underlying assets.\n     * @param assetKey The unique identifier of the asset.\n     * @return underlyingAssetKeys The unique identifiers of the underlying assets.\n     */\n    function _getUnderlyingAssets(bytes32 assetKey)\n        internal\n        view\n        virtual\n        override\n        returns (bytes32[] memory underlyingAssetKeys)\n    {\n        (, uint256 positionId) = _getAssetFromKey(assetKey);\n\n        underlyingAssetKeys = new bytes32[](2);\n        underlyingAssetKeys[0] = _getKeyFromAsset(positionState[positionId].asset, 0);\n        underlyingAssetKeys[1] = _getKeyFromAsset(address(REWARD_TOKEN), 0);\n    }\n\n    /**\n     * @notice Calculates for a given amount of Asset the corresponding amount(s) of underlying asset(s).\n     * param creditor The contract address of the creditor.\n     * @param assetKey The unique identifier of the asset.\n     * @param amount The amount of the Asset, in the decimal precision of the Asset.\n     * param underlyingAssetKeys The unique identifiers of the underlying assets.\n     * @return underlyingAssetsAmounts The corresponding amount(s) of Underlying Asset(s), in the decimal precision of the Underlying Asset.\n     * @return rateUnderlyingAssetsToUsd The usd rates of 10**18 tokens of underlying asset, with 18 decimals precision.\n     */\n    function _getUnderlyingAssetsAmounts(address, bytes32 assetKey, uint256 amount, bytes32[] memory)\n        internal\n        view\n        virtual\n        override\n        returns (uint256[] memory underlyingAssetsAmounts, AssetValueAndRiskFactors[] memory rateUnderlyingAssetsToUsd)\n    {\n        // Amount of a Staked position in the Asset Module can only be either 0 or 1.\n        if (amount == 0) return (new uint256[](2), rateUnderlyingAssetsToUsd);\n\n        (, uint256 positionId) = _getAssetFromKey(assetKey);\n\n        underlyingAssetsAmounts = new uint256[](2);\n        underlyingAssetsAmounts[0] = positionState[positionId].amountStaked;\n        underlyingAssetsAmounts[1] = rewardOf(positionId);\n\n        return (underlyingAssetsAmounts, rateUnderlyingAssetsToUsd);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                          PRICING LOGIC\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the risk factors of an asset for a Creditor.\n     * @param creditor The contract address of the Creditor.\n     * @param asset The contract address of the asset.\n     * @param assetId The id of the asset.\n     * @return collateralFactor The collateral factor of the asset for the Creditor, 4 decimals precision.\n     * @return liquidationFactor The liquidation factor of the asset for the Creditor, 4 decimals precision.\n     */\n    function getRiskFactors(address creditor, address asset, uint256 assetId)\n        external\n        view\n        virtual\n        override\n        returns (uint16 collateralFactor, uint16 liquidationFactor)\n    {\n        bytes32 assetKey = _getKeyFromAsset(asset, assetId);\n        bytes32[] memory underlyingAssetKeys = _getUnderlyingAssets(assetKey);\n\n        uint256[] memory underlyingAssetsAmounts;\n        (underlyingAssetsAmounts,) = _getUnderlyingAssetsAmounts(creditor, assetKey, 1, underlyingAssetKeys);\n        AssetValueAndRiskFactors[] memory rateUnderlyingAssetsToUsd =\n            _getRateUnderlyingAssetsToUsd(creditor, underlyingAssetKeys);\n\n        (, uint256 collateralFactor_, uint256 liquidationFactor_) =\n            _calculateValueAndRiskFactors(creditor, underlyingAssetsAmounts, rateUnderlyingAssetsToUsd);\n\n        // Unsafe cast: collateralFactor_ and liquidationFactor_ are smaller than or equal to 1e4.\n        return (uint16(collateralFactor_), uint16(liquidationFactor_));\n    }\n\n    /**\n     * @notice Returns the USD value of an asset.\n     * @param creditor The contract address of the Creditor.\n     * @param underlyingAssetsAmounts The corresponding amount(s) of Underlying Asset(s), in the decimal precision of the Underlying Asset.\n     * @param rateUnderlyingAssetsToUsd The USD rates of 10**18 tokens of underlying asset, with 18 decimals precision.\n     * @return valueInUsd The value of the asset denominated in USD, with 18 Decimals precision.\n     * @return collateralFactor The collateral factor of the asset for a given Creditor, with 4 decimals precision.\n     * @return liquidationFactor The liquidation factor of the asset for a given Creditor, with 4 decimals precision.\n     * @dev We take a weighted risk factor of both underlying assets.\n     */\n    function _calculateValueAndRiskFactors(\n        address creditor,\n        uint256[] memory underlyingAssetsAmounts,\n        AssetValueAndRiskFactors[] memory rateUnderlyingAssetsToUsd\n    )\n        internal\n        view\n        virtual\n        override\n        returns (uint256 valueInUsd, uint256 collateralFactor, uint256 liquidationFactor)\n    {\n        // \"rateUnderlyingAssetsToUsd\" is the USD value with 18 decimals precision for 10**18 tokens of Underlying Asset.\n        // To get the USD value (also with 18 decimals) of the actual amount of underlying assets, we have to multiply\n        // the actual amount with the rate for 10**18 tokens, and divide by 10**18.\n        uint256 valueStakedAsset = underlyingAssetsAmounts[0].mulDivDown(rateUnderlyingAssetsToUsd[0].assetValue, 1e18);\n        uint256 valueRewardAsset = underlyingAssetsAmounts[1].mulDivDown(rateUnderlyingAssetsToUsd[1].assetValue, 1e18);\n        valueInUsd = valueStakedAsset + valueRewardAsset;\n\n        // Calculate weighted risk factors.\n        if (valueInUsd > 0) {\n            unchecked {\n                collateralFactor = (\n                    valueStakedAsset * rateUnderlyingAssetsToUsd[0].collateralFactor\n                        + valueRewardAsset * rateUnderlyingAssetsToUsd[1].collateralFactor\n                ) / valueInUsd;\n                liquidationFactor = (\n                    valueStakedAsset * rateUnderlyingAssetsToUsd[0].liquidationFactor\n                        + valueRewardAsset * rateUnderlyingAssetsToUsd[1].liquidationFactor\n                ) / valueInUsd;\n            }\n        }\n\n        // Lower risk factors with the protocol wide risk factor.\n        uint256 riskFactor = riskParams[creditor].riskFactor;\n        collateralFactor = riskFactor.mulDivDown(collateralFactor, AssetValuationLib.ONE_4);\n        liquidationFactor = riskFactor.mulDivDown(liquidationFactor, AssetValuationLib.ONE_4);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                         STAKING MODULE LOGIC\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Stakes an amount of Assets in the external staking contract and mints a new position.\n     * @param asset The contract address of the asset to stake.\n     * @param amount The amount of Assets to stake.\n     * @return positionId The id of the minted position.\n     */\n    function mint(address asset, uint128 amount) external virtual nonReentrant returns (uint256 positionId) {\n        if (amount == 0) revert ZeroAmount();\n\n        // Need to transfer before minting or ERC777s could reenter.\n        ERC20(asset).safeTransferFrom(msg.sender, address(this), amount);\n\n        // Cache the old assetState.\n        AssetState memory assetState_ = assetState[asset];\n        if (!assetState_.allowed) revert AssetNotAllowed();\n\n        // Create a new positionState.\n        PositionState memory positionState_;\n        positionState_.asset = asset;\n\n        // Calculate the new reward balances.\n        (assetState_, positionState_) = _getRewardBalances(assetState_, positionState_);\n\n        // Calculate the new staked amounts.\n        assetState_.totalStaked = assetState_.totalStaked + amount;\n        positionState_.amountStaked = amount;\n\n        // Store the new positionState and assetState.\n        unchecked {\n            positionId = ++lastPositionId;\n        }\n        positionState[positionId] = positionState_;\n        assetState[asset] = assetState_;\n\n        // Stake Asset in external staking contract.\n        _stake(asset, amount);\n\n        // Mint the new position.\n        _safeMint(msg.sender, positionId);\n\n        emit LiquidityIncreased(positionId, asset, amount);\n    }\n\n    /**\n     * @notice Stakes additional Assets in the external staking contract for an existing position.\n     * @param positionId The id of the position.\n     * @param amount The amount of Assets to stake.\n     */\n    function increaseLiquidity(uint256 positionId, uint128 amount) external virtual nonReentrant {\n        if (amount == 0) revert ZeroAmount();\n        if (_ownerOf[positionId] != msg.sender) revert NotOwner();\n\n        // Cache the old positionState and assetState.\n        PositionState memory positionState_ = positionState[positionId];\n        address asset = positionState_.asset;\n        AssetState memory assetState_ = assetState[asset];\n\n        // Need to transfer before increasing liquidity or ERC777s could reenter.\n        ERC20(asset).safeTransferFrom(msg.sender, address(this), amount);\n\n        // Calculate the new reward balances.\n        (assetState_, positionState_) = _getRewardBalances(assetState_, positionState_);\n\n        // Calculate the new staked amounts.\n        assetState_.totalStaked = assetState_.totalStaked + amount;\n        positionState_.amountStaked = positionState_.amountStaked + amount;\n\n        // Store the new positionState and assetState.\n        positionState[positionId] = positionState_;\n        assetState[asset] = assetState_;\n\n        // Stake Asset in external staking contract.\n        _stake(asset, amount);\n\n        emit LiquidityIncreased(positionId, asset, amount);\n    }\n\n    /**\n     * @notice Unstakes, withdraws and claims rewards for total amount staked of Asset in position.\n     * @param positionId The id of the position to burn.\n     */\n    function burn(uint256 positionId) external virtual {\n        decreaseLiquidity(positionId, positionState[positionId].amountStaked);\n    }\n\n    /**\n     * @notice Unstakes and withdraws the asset from the external staking contract.\n     * @param positionId The id of the position to withdraw from.\n     * @param amount The amount of Asset to unstake and withdraw.\n     * @return rewards The amount of reward tokens claimed.\n     * @dev Also claims and transfers the staking rewards of the position.\n     */\n    function decreaseLiquidity(uint256 positionId, uint128 amount)\n        public\n        virtual\n        nonReentrant\n        returns (uint256 rewards)\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (_ownerOf[positionId] != msg.sender) revert NotOwner();\n\n        // Cache the old positionState and assetState.\n        PositionState memory positionState_ = positionState[positionId];\n        address asset = positionState_.asset;\n        AssetState memory assetState_ = assetState[asset];\n\n        // Calculate the new reward balances.\n        (assetState_, positionState_) = _getRewardBalances(assetState_, positionState_);\n\n        // Calculate the new staked amounts.\n        assetState_.totalStaked = assetState_.totalStaked - amount;\n        positionState_.amountStaked = positionState_.amountStaked - amount;\n\n        // Rewards are claimed and paid out to the owner on a decreaseLiquidity.\n        // -> Reset the balances of the pending rewards for the asset and the position.\n        rewards = positionState_.lastRewardPosition;\n        positionState_.lastRewardPosition = 0;\n        assetState_.lastRewardGlobal = 0;\n\n        // Store the new positionState and assetState.\n        if (positionState_.amountStaked > 0) {\n            positionState[positionId] = positionState_;\n        } else {\n            delete positionState[positionId];\n            _burn(positionId);\n        }\n        assetState[asset] = assetState_;\n\n        // Withdraw the Assets from external staking contract.\n        _withdraw(asset, amount);\n\n        // Claim the reward from the external staking contract.\n        _claimReward(asset);\n\n        // Pay out the rewards to the position owner.\n        if (rewards > 0) {\n            // Transfer reward\n            REWARD_TOKEN.safeTransfer(msg.sender, rewards);\n            emit RewardPaid(positionId, address(REWARD_TOKEN), uint128(rewards));\n        }\n\n        // Transfer the asset back to the position owner.\n        ERC20(asset).safeTransfer(msg.sender, amount);\n        emit LiquidityDecreased(positionId, asset, amount);\n    }\n\n    /**\n     * @notice Claims and transfers the staking rewards of the position.\n     * @param positionId The id of the position.\n     * @return rewards The amount of reward tokens claimed.\n     */\n    function claimReward(uint256 positionId) external virtual nonReentrant returns (uint256 rewards) {\n        if (_ownerOf[positionId] != msg.sender) revert NotOwner();\n\n        // Cache the old positionState and assetState.\n        PositionState memory positionState_ = positionState[positionId];\n        address asset = positionState_.asset;\n        AssetState memory assetState_ = assetState[asset];\n\n        // Calculate the new reward balances.\n        (assetState_, positionState_) = _getRewardBalances(assetState_, positionState_);\n\n        // Rewards are claimed and paid out to the owner on a claimReward.\n        // -> Reset the balances of the pending rewards for the asset and the position.\n        rewards = positionState_.lastRewardPosition;\n        positionState_.lastRewardPosition = 0;\n        assetState_.lastRewardGlobal = 0;\n\n        // Store the new positionState and assetState.\n        positionState[positionId] = positionState_;\n        assetState[asset] = assetState_;\n\n        // Claim the reward from the external staking contract.\n        _claimReward(asset);\n\n        // Pay out the share of the reward owed to the position owner.\n        if (rewards > 0) {\n            // Transfer reward\n            REWARD_TOKEN.safeTransfer(msg.sender, rewards);\n            emit RewardPaid(positionId, address(REWARD_TOKEN), uint128(rewards));\n        }\n    }\n\n    /**\n     * @notice Returns the total amount of Asset staked via this contract.\n     * @param asset The Asset staked via this contract.\n     * @return totalStaked_ The total amount of Asset staked via this contract.\n     */\n    function totalStaked(address asset) external view returns (uint256 totalStaked_) {\n        return assetState[asset].totalStaked;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    INTERACTIONS STAKING CONTRACT\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Stakes an amount of tokens in the external staking contract.\n     * @param asset The Asset to stake.\n     * @param amount The amount of Asset to stake.\n     */\n    function _stake(address asset, uint256 amount) internal virtual;\n\n    /**\n     * @notice Unstakes and withdraws the asset from the external contract.\n     * @param asset The Asset to withdraw.\n     * @param amount The amount of Asset to unstake and withdraw.\n     */\n    function _withdraw(address asset, uint256 amount) internal virtual;\n\n    /**\n     * @notice Claims the rewards available for this contract.\n     * @param asset The Asset for which rewards will be claimed.\n     */\n    function _claimReward(address asset) internal virtual;\n\n    /**\n     * @notice Returns the amount of reward tokens that can be claimed by this contract for a specific Asset.\n     * @param asset The Asset that is earning rewards from staking.\n     * @return currentReward The amount of rewards tokens that can be claimed.\n     */\n    function _getCurrentReward(address asset) internal view virtual returns (uint256 currentReward);\n\n    /*///////////////////////////////////////////////////////////////\n                         REWARDS VIEW FUNCTIONS\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the amount of reward tokens claimable by a position.\n     * @param positionId The id of the position to check the rewards for.\n     * @return currentRewardClaimable The current amount of reward tokens claimable by the owner of the position.\n     */\n    function rewardOf(uint256 positionId) public view virtual returns (uint256 currentRewardClaimable) {\n        // Cache the old positionState and assetState.\n        PositionState memory positionState_ = positionState[positionId];\n        AssetState memory assetState_ = assetState[positionState_.asset];\n\n        // Calculate the new reward balances.\n        (, positionState_) = _getRewardBalances(assetState_, positionState_);\n\n        currentRewardClaimable = positionState_.lastRewardPosition;\n    }\n\n    /**\n     * @notice Calculates the current global and position specific reward balances.\n     * @param assetState_ Struct with the old rewards state of the Asset.\n     * @param positionState_ Struct with the old rewards state of the position.\n     * @return currentAssetState Struct with the current rewards state of the Asset.\n     * @return currentPositionState Struct with the current rewards state of the position.\n     */\n    function _getRewardBalances(AssetState memory assetState_, PositionState memory positionState_)\n        internal\n        view\n        returns (AssetState memory, PositionState memory)\n    {\n        if (assetState_.totalStaked > 0) {\n            // Calculate the new assetState\n            // Fetch the current reward balance from the staking contract.\n            uint256 currentRewardGlobal = _getCurrentReward(positionState_.asset);\n            // Calculate the increase in rewards since last Asset interaction.\n            uint256 deltaReward = currentRewardGlobal - assetState_.lastRewardGlobal;\n            uint256 deltaRewardPerToken = deltaReward.mulDivDown(1e18, assetState_.totalStaked);\n            // Calculate and update the new RewardPerToken of the asset.\n            // unchecked: RewardPerToken can overflow, what matters is the delta in RewardPerToken between two interactions.\n            unchecked {\n                assetState_.lastRewardPerTokenGlobal =\n                    assetState_.lastRewardPerTokenGlobal + SafeCastLib.safeCastTo128(deltaRewardPerToken);\n            }\n            // Update the reward balance of the asset.\n            assetState_.lastRewardGlobal = SafeCastLib.safeCastTo128(currentRewardGlobal);\n\n            // Calculate the new positionState.\n            // Calculate the difference in rewardPerToken since the last position interaction.\n            // unchecked: RewardPerToken can underflow, what matters is the delta in RewardPerToken between two interactions.\n            unchecked {\n                deltaRewardPerToken = assetState_.lastRewardPerTokenGlobal - positionState_.lastRewardPerTokenPosition;\n            }\n            // Calculate the rewards earned by the position since its last interaction.\n            // unchecked: deltaRewardPerToken and positionState_.amountStaked are smaller than type(uint128).max.\n            unchecked {\n                deltaReward = deltaRewardPerToken * positionState_.amountStaked / 1e18;\n            }\n            // Update the reward balance of the position.\n            positionState_.lastRewardPosition =\n                SafeCastLib.safeCastTo128(positionState_.lastRewardPosition + deltaReward);\n        }\n        // Update the RewardPerToken of the position.\n        positionState_.lastRewardPerTokenPosition = assetState_.lastRewardPerTokenGlobal;\n\n        return (assetState_, positionState_);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ERC-721 LOGIC\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function that stores a new base URI.\n     * @param newBaseURI The new base URI to store.\n     */\n    function setBaseURI(string calldata newBaseURI) external virtual onlyOwner {\n        baseURI = newBaseURI;\n    }\n\n    /**\n     * @notice Function that returns the token URI as defined in the ERC721 standard.\n     * @param tokenId The id of the Account.\n     * @return uri The token URI.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory uri) {\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n}"
    },
    {
      "filename": "accounts-v2/src/asset-modules/abstracts/AbstractStakingAM.sol",
      "content": "/**\n * Created by Pragma Labs\n * SPDX-License-Identifier: BUSL-1.1\n */\npragma solidity 0.8.22;\n\nimport { AssetValuationLib, AssetValueAndRiskFactors } from \"../../libraries/AssetValuationLib.sol\";\nimport { ERC20 } from \"../../../lib/solmate/src/tokens/ERC20.sol\";\nimport { ERC721 } from \"../../../lib/solmate/src/tokens/ERC721.sol\";\nimport { DerivedAM, FixedPointMathLib, IRegistry } from \"./AbstractDerivedAM.sol\";\nimport { ReentrancyGuard } from \"../../../lib/solmate/src/utils/ReentrancyGuard.sol\";\nimport { SafeCastLib } from \"../../../lib/solmate/src/utils/SafeCastLib.sol\";\nimport { SafeTransferLib } from \"../../../lib/solmate/src/utils/SafeTransferLib.sol\";\nimport { Strings } from \"../../libraries/Strings.sol\";\n\n/**\n * @title Staking Module\n * @author Pragma Labs\n * @notice Abstract contract with the minimal implementation of a wrapper contract for Assets staked in an external staking contract.\n * @dev The staking Module is an ERC721 contract that does the accounting per Asset (staking token) and per position owner for:\n *  - The balances of Assets staked through this contract.\n *  - The balances of reward tokens earned for staking the Assets.\n * Next to keeping the accounting of balances, this contract manages the interactions with the external staking contract:\n *  - Staking Assets.\n *  - Withdrawing the Assets from staked positions.\n *  - Claiming reward tokens.\n */\nabstract contract StakingAM is DerivedAM, ERC721, ReentrancyGuard {\n    using FixedPointMathLib for uint256;\n    using Strings for uint256;\n    using SafeTransferLib for ERC20;\n\n    /* //////////////////////////////////////////////////////////////\n                                CONSTANTS\n    ////////////////////////////////////////////////////////////// */\n\n    // The reward token.\n    ERC20 public immutable REWARD_TOKEN;\n\n    /* //////////////////////////////////////////////////////////////\n                                STORAGE\n    ////////////////////////////////////////////////////////////// */\n\n    // The id of last minted position.\n    uint256 internal lastPositionId;\n\n    // The baseURI of the ERC721 tokens.\n    string public baseURI;\n\n    // Map Asset to its corresponding struct with global state.\n    mapping(address asset => AssetState) public assetState;\n    // Map a position id to its corresponding struct with the position state.\n    mapping(uint256 position => PositionState) public positionState;\n\n    // Struct with the global state per Asset.\n    struct AssetState {\n        // Flag indicating if the asset is allowed.\n        bool allowed;\n        // The growth of reward tokens per Asset staked, at the last interaction with this contract,\n        // with 18 decimals precision.\n        uint128 lastRewardPerTokenGlobal;\n        // The unclaimed amount of reward tokens, at the last interaction with this contract.\n        uint128 lastRewardGlobal;\n        // The total amount of Assets staked.\n        uint128 totalStaked;\n    }\n\n    // Struct with the Position specific state.\n    struct PositionState {\n        // The staked Asset.\n        address asset;\n        // Total amount of Asset staked for this position.\n        uint128 amountStaked;\n        // The growth of reward tokens per Asset staked, at the last interaction of the position owner with this contract,\n        // with 18 decimals precision.\n        uint128 lastRewardPerTokenPosition;\n        // The unclaimed amount of reward tokens of the position owner, at the last interaction of the owner with this contract.\n        uint128 lastRewardPosition;\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                                EVENTS\n    ////////////////////////////////////////////////////////////// */\n\n    event LiquidityDecreased(uint256 indexed positionId, address indexed asset, uint128 amount);\n    event LiquidityIncreased(uint256 indexed positionId, address indexed asset, uint128 amount);\n    event RewardPaid(uint256 indexed positionId, address indexed reward, uint128 amount);\n\n    /* //////////////////////////////////////////////////////////////\n                                ERRORS\n    ////////////////////////////////////////////////////////////// */\n\n    error AssetNotAllowed();\n    error NotOwner();\n    error ZeroAmount();\n\n    /* //////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    ////////////////////////////////////////////////////////////// */\n\n    constructor(address registry, string memory name_, string memory symbol_)\n        DerivedAM(registry, 1)\n        ERC721(name_, symbol_)\n    { }\n\n    /* //////////////////////////////////////////////////////////////\n                               INITIALIZE\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice This function will add this contract as an asset in the Registry.\n     * @dev Will revert if called more than once.\n     */\n    function initialize() external onlyOwner {\n        inAssetModule[address(this)] = true;\n\n        IRegistry(REGISTRY).addAsset(address(this));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ASSET MANAGEMENT\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Adds an asset that can be staked to this contract.\n     * @param asset The contract address of the Asset.\n     */\n    function _addAsset(address asset) internal {\n        assetState[asset].allowed = true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ASSET INFORMATION\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Checks for a token address and the corresponding id if it is allowed.\n     * @param asset The contract address of the asset.\n     * @param assetId The id of the asset.\n     * @return allowed A boolean, indicating if the asset is allowed.\n     */\n    function isAllowed(address asset, uint256 assetId) public view override returns (bool allowed) {\n        if (asset == address(this) && asset"
    }
  ]
}