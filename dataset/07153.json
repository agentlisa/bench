{
  "Title": "[M-02] Burning a `ERC1155Enumerable` token doesn't remove it from the enumeration",
  "Content": "\nThe `ERC1155Enumerable` base contract used in the `TimeswapV2Token` and `TimeswapV2LiquidityToken` tokens provides a functionality to enumerate all token ids that have been minted in the contract.\n\nThe logic to remove the token from the enumeration if the last token is burned is implemented in the `_afterTokenTransfer` hook:\n\n<https://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-token/src/base/ERC1155Enumerable.sol#L81-L101>\n\n```solidity\nfunction _afterTokenTransfer(address, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory) internal virtual override {\n    for (uint256 i; i < ids.length; ) {\n        if (amounts[i] != 0) _removeTokenEnumeration(from, to, ids[i], amounts[i]);\n\n        unchecked {\n            ++i;\n        }\n    }\n}\n\n/// @dev Remove token enumeration list if necessary.\n\nfunction _removeTokenEnumeration(address from, address to, uint256 id, uint256 amount) internal {\n    if (to == address(0)) {\n        if (_idTotalSupply[id] == 0 && _additionalConditionRemoveTokenFromAllTokensEnumeration(id)) _removeTokenFromAllTokensEnumeration(id);\n        _idTotalSupply[id] -= amount;\n    }\n\n    if (from != address(0) && from != to) {\n        if (balanceOf(from, id) == 0 && _additionalConditionRemoveTokenFromOwnerEnumeration(from, id)) _removeTokenFromOwnerEnumeration(from, id);\n    }\n}\n```\n\nThe `_removeTokenEnumeration` condition to check if the supply is 0 happens before the function decreases the burned amount. This will `_removeTokenFromAllTokensEnumeration` from being called when the last token(s) is(are) burned.\n\n### Impact\n\nThe token isn't removed from the enumeration since `_removeTokenFromAllTokensEnumeration` will never be called. This will cause the enumeration to always contain a minted token even though it is burned afterwards. The function `totalSupply` and `tokenByIndex` will report wrong values.\n\nThis will also cause the enumeration to contain duplicate values or multiple copies of the same token. If the token is minted again after all tokens were previously burned, the token will be re added to the enumeration.\n\n### Proof of Concept\n\nThe following test demonstrates the issue. Alice is minted a token and that token is then burned, the token is still present in the enumeration. The token is minted again, causing the enumeration to contain the token by duplicate.\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.8;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/base/ERC1155Enumerable.sol\";\n\ncontract TestERC1155Enumerable is ERC1155Enumerable {\n    constructor() ERC1155(\"\") {\n    }\n\n    function mint(address to, uint256 id, uint256 amount) external {\n        _mint(to, id, amount, \"\");\n    }\n\n    function burn(address from, uint256 id, uint256 amount) external {\n        _burn(from, id, amount);\n    }\n}\n\ncontract AuditTest is Test {\n    function test_ERC1155Enumerable_BadRemoveFromEnumeration() public {\n        TestERC1155Enumerable token = new TestERC1155Enumerable();\n        address alice = makeAddr(\"alice\");\n        uint256 tokenId = 0;\n        uint256 amount = 1;\n\n        token.mint(alice, tokenId, amount);\n\n        // tokenByIndex and totalSupply are ok\n        assertEq(token.tokenByIndex(0), tokenId);\n        assertEq(token.totalSupply(), 1);\n\n        // now we burn the token\n        token.burn(alice, tokenId, amount);\n\n        // tokenByIndex and totalSupply still report previous values\n        // tokenByIndex should throw index out of bounds, and supply should return 0\n        assertEq(token.tokenByIndex(0), tokenId);\n        assertEq(token.totalSupply(), 1);\n\n        // Now we mint it again, this will re-add the token to the enumeration, duplicating it\n        token.mint(alice, tokenId, amount);\n        assertEq(token.totalSupply(), 2);\n        assertEq(token.tokenByIndex(0), tokenId);\n        assertEq(token.tokenByIndex(1), tokenId);\n    }\n}\n```\n\n### Recommendation\n\nDecrease the amount before checking if the supply is 0.\n\n```solidity\nfunction _removeTokenEnumeration(address from, address to, uint256 id, uint256 amount) internal {\n    if (to == address(0)) {\n        _idTotalSupply[id] -= amount;\n        if (_idTotalSupply[id] == 0 && _additionalConditionRemoveTokenFromAllTokensEnumeration(id)) _removeTokenFromAllTokensEnumeration(id);\n    }\n\n    if (from != address(0) && from != to) {\n        if (balanceOf(from, id) == 0 && _additionalConditionRemoveTokenFromOwnerEnumeration(from, id)) _removeTokenFromOwnerEnumeration(from, id);\n    }\n}\n```\n**[vhawk19 (Timeswap) confirmed and resolved](https://github.com/code-423n4/2023-01-timeswap-findings/issues/248#issuecomment-1434505035):**\n > Resolved in [PR](https://github.com/Timeswap-Labs/Timeswap-V2-Monorepo/commit/dd7d3c247235f0750516151c44873bbf23377212).\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-01-timeswap",
  "Code": [
    {
      "filename": "packages/v2-token/src/base/ERC1155Enumerable.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport {ERC1155} from \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n\nimport {IERC1155Enumerable} from \"../interfaces/IERC1155Enumerable.sol\";\n\n/// Extension of {ERC1155} that adds\n/// enumerability of all the token ids in the contract as well as all token ids owned by each\n/// account.\nabstract contract ERC1155Enumerable is IERC1155Enumerable, ERC1155 {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens; // An index of all tokens\n\n    mapping(address => uint256) private _currentIndex; // the current index for an address\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    mapping(uint256 => uint256) private _idTotalSupply;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /// @inheritdoc IERC1155Enumerable\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view override returns (uint256) {\n        return _ownedTokens[owner][index];\n    }\n\n    /// @inheritdoc IERC1155Enumerable\n    function totalSupply() public view override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /// @inheritdoc IERC1155Enumerable\n    function tokenByIndex(uint256 index) external view override returns (uint256) {\n        return _allTokens[index];\n    }\n\n    /// @dev Hook that is called before any token transfer. This includes minting\n    /// and burning.\n    function _beforeTokenTransfer(address, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory) internal virtual override {\n        for (uint256 i; i < ids.length; ) {\n            if (amounts[i] != 0) _addTokenEnumeration(from, to, ids[i], amounts[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Add token enumeration list if necessary.\n    function _addTokenEnumeration(address from, address to, uint256 id, uint256 amount) internal {\n        if (from == address(0)) {\n            if (_idTotalSupply[id] == 0 && _additionalConditionAddTokenToAllTokensEnumeration(id)) _addTokenToAllTokensEnumeration(id);\n            _idTotalSupply[id] += amount;\n        }\n\n        if (to != address(0) && to != from) {\n            if (balanceOf(to, id) == 0 && _additionalConditionAddTokenToOwnerEnumeration(to, id)) _addTokenToOwnerEnumeration(to, id);\n        }\n    }\n\n    /// @dev Any additional condition to add token enumeration when overidden.\n    function _additionalConditionAddTokenToAllTokensEnumeration(uint256) internal virtual returns (bool) {\n        return true;\n    }\n\n    /// @dev Any additional condition to add token enumeration when overidden.\n    function _additionalConditionAddTokenToOwnerEnumeration(address, uint256) internal virtual returns (bool) {\n        return true;\n    }\n\n    /// @dev Hook that is called after any token transfer. This includes minting\n    /// and burning.\n    function _afterTokenTransfer(address, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory) internal virtual override {\n        for (uint256 i; i < ids.length; ) {\n            if (amounts[i] != 0) _removeTokenEnumeration(from, to, ids[i], amounts[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Remove token enumeration list if necessary.\n    function _removeTokenEnumeration(address from, address to, uint256 id, uint256 amount) internal {\n        if (to == address(0)) {\n            if (_idTotalSupply[id] == 0 && _additionalConditionRemoveTokenFromAllTokensEnumeration(id)) _removeTokenFromAllTokensEnumeration(id);\n            _idTotalSupply[id] -= amount;\n        }\n\n        if (from != address(0) && from != to) {\n            if (balanceOf(from, id) == 0 && _additionalConditionRemoveTokenFromOwnerEnumeration(from, id)) _removeTokenFromOwnerEnumeration(from, id);\n        }\n    }\n\n    /// @dev Any additional condition to remove token enumeration when overidden.\n    function _additionalConditionRemoveTokenFromAllTokensEnumeration(uint256) internal virtual returns (bool) {\n        return true;\n    }\n\n    /// @dev Any additional condition to remove token enumeration when overidden.\n    function _additionalConditionRemoveTokenFromOwnerEnumeration(address, uint256) internal virtual returns (bool) {\n        return true;\n    }\n\n    /// @dev Private function to add a token to this extension's ownership-tracking data structures.\n    /// @param to address representing the new owner of the given token ID\n    /// @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        _currentIndex[to] += 1;\n        uint256 length = _currentIndex[to];\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /// @dev Private function to add a token to this extension's token tracking data structures.\n    /// @param tokenId uint256 ID of the token to be added to the tokens list\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /// @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n    /// while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n    /// gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n    /// This has O(1) time complexity, but alters the order of the _ownedTokens array.\n    /// @param from address representing the previous owner of the given token ID\n    /// @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        uint256 lastTokenIndex = _currentIndex[from] - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId;\n            _ownedTokensIndex[lastTokenId] = tokenIndex;\n        }\n\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /// @dev Private function to remove a token from this extension's token tracking data structures.\n    /// This has O(1) time complexity, but alters the order of the _allTokens array.\n    /// @param tokenId uint256 ID of the token to be removed from the tokens list\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId;\n        _allTokensIndex[lastTokenId] = tokenIndex;\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}"
    }
  ]
}