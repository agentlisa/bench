{
  "Title": "H-2: User can game protection via renewal to get free insurance",
  "Content": "# Issue H-2: User can game protection via renewal to get free insurance \n\nSource: https://github.com/sherlock-audit/2023-02-carapace-judging/issues/293 \n\n## Found by \nlibratus, monrel, minhtrng, rvierdiiev, jkoppel, 0Kage, 0x52, KingNFT\n\n## Summary\n\nWhen renewing a position, the new protectionAmount can be higher than what was previously bought. A user can abuse this to get insurance for free. Most of the time they would keep the protection amount at 1 and pay virtually no premium. Since late payments can be seen very far in advance they would simply renew their insurance at the max value of token right before the borrower was officially late and gain the full protection.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/libraries/ProtectionPoolHelper.sol#L383-L398\n\nWhen evaluating if a user can renew their insurance only the time, token and lending contract are verified. It never checks the amount of protection that the user is renewing for. This can be abused to renew for MORE protection than originally bought. A user could abuse this to renew right before there was a late payment for the full amount of protection.\n\nThey can abuse another quirk of the renewal system to make sure they they are always able to renew at any time. Since a user is allowed to open an unlimited number of positions on a single LP token they can open a large number of positions with 1 protection amount. They would space out each protection to expire exactly with the grace period. The results it that they would be able to renew any position at a moments notice. \n\nThey would abuse this by choosing to renew their protection for the max value of the token right before a payment was officially late. This would allow them to collect a full repayment while paying basically nothing in premium.\n\n## Impact\n\nUser can get full protection for free\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/core/pool/ProtectionPool.sol#L176-L195\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWhen renewing protection, the user should only be allowed to renew up to the value of their expired insurance\n\n## Discussion\n\n**vnadoda**\n\n@clems4ev3r what's the basis for the following claim? How would a buyer know abt late payment in advance?\n\"Since late payments can be seen very far in advance they would simply renew their insurance at the max value of token right before the borrower was officially late and gain the full protection.\"\nCc @taisukemino \n\n**clems4ev3r**\n\n> @clems4ev3r what's the basis for the following claim? How would a buyer know abt late payment in advance? \"Since late payments can be seen very far in advance they would simply renew their insurance at the max value of token right before the borrower was officially late and gain the full protection.\" Cc @taisukemino\n\nI think this is possible due to the fact that any user can go fetch lending pool status from goldfinch directly. So they are aware of state changes not yet triggered on Carapace and can adjust their positions accordingly\n\n**vnadoda**\n\n> > @clems4ev3r what's the basis for the following claim? How would a buyer know abt late payment in advance? \"Since late payments can be seen very far in advance they would simply renew their insurance at the max value of token right before the borrower was officially late and gain the full protection.\" Cc @taisukemino\n> \n> I think this is possible due to the fact that any user can go fetch lending pool status from goldfinch directly. So they are aware of state changes not yet triggered on Carapace and can adjust their positions accordingly\n\nYeah, buyers can't see far in the future, but even early knowledge of the late payment by a couple of hours can be exploited.\n\nWe are planning to fix this issue. @taisukemino \n\n**vnadoda**\n\n@clems4ev3r PR for this fix is: https://github.com/carapace-finance/credit-default-swaps-contracts/pull/56\n\nwhen you review fix PRs, please do it in sequence, they are created as I am creating a new fix branch on top of the previous fix branch to avoid merge conflicts.\nCc @hrishibhat \n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/40",
  "Code": [
    {
      "filename": "contracts/libraries/ProtectionPoolHelper.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {EnumerableSetUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\nimport {ProtectionPurchaseParams, LendingPoolStatus, IReferenceLendingPools} from \"../interfaces/IReferenceLendingPools.sol\";\nimport {ProtectionPoolInfo, ProtectionInfo, ProtectionBuyerAccount, IProtectionPool, LendingPoolDetail, ProtectionPoolPhase} from \"../interfaces/IProtectionPool.sol\";\nimport {IProtectionPoolCycleManager} from \"../interfaces/IProtectionPoolCycleManager.sol\";\nimport {IDefaultStateManager} from \"../interfaces/IDefaultStateManager.sol\";\nimport {IPremiumCalculator} from \"../interfaces/IPremiumCalculator.sol\";\n\nimport \"./AccruedPremiumCalculator.sol\";\nimport \"./Constants.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * @title ProtectionPoolHelper\n * @author Carapace Finance\n * @notice Helper library contract for ProtectionPool contract, mainly for size reduction.\n */\nlibrary ProtectionPoolHelper {\n  using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n\n  /**\n   * @notice Verifies that the status of the lending pool is ACTIVE and protection can be bought,\n   * otherwise reverts with the appropriate error message.\n   * @param poolCycleManager the pool cycle manager contract\n   * @param defaultStateManager the default state manager contract\n   * @param _protectionPool the address of the protection pool\n   * @param poolInfo storage pointer to the protection pool info\n   * @param _protectionStartTimestamp the timestamp when the protection starts\n   * @param _protectionPurchaseParams the protection purchase params\n   * @param _isRenewal whether the protection is being renewed or not\n   */\n  function verifyProtection(\n    IProtectionPoolCycleManager poolCycleManager,\n    IDefaultStateManager defaultStateManager,\n    address _protectionPool,\n    ProtectionPoolInfo storage poolInfo,\n    uint256 _protectionStartTimestamp,\n    ProtectionPurchaseParams calldata _protectionPurchaseParams,\n    bool _isRenewal\n  ) external {\n    /// Verify that the pool is not in OpenToSellers phase\n    if (poolInfo.currentPhase == ProtectionPoolPhase.OpenToSellers) {\n      revert IProtectionPool.ProtectionPoolInOpenToSellersPhase();\n    }\n\n    /// a buyer needs to buy protection longer than min protection duration specified in the pool params\n    /// or to renew protection longer than a day\n    _verifyProtectionDuration(\n      poolCycleManager,\n      _protectionPool,\n      _protectionStartTimestamp,\n      _protectionPurchaseParams.protectionDurationInSeconds,\n      _isRenewal\n        ? Constants.SECONDS_IN_DAY_UINT\n        : poolInfo.params.minProtectionDurationInSeconds\n    );\n\n    /// Verify that the lending pool is active\n    _verifyLendingPoolIsActive(\n      defaultStateManager,\n      _protectionPool,\n      _protectionPurchaseParams.lendingPoolAddress\n    );\n\n    if (\n      !poolInfo.referenceLendingPools.canBuyProtection(\n        msg.sender,\n        _protectionPurchaseParams,\n        _isRenewal\n      )\n    ) {\n      revert IProtectionPool.ProtectionPurchaseNotAllowed(\n        _protectionPurchaseParams\n      );\n    }\n  }\n\n  /**\n   * @notice Calculates the protection premium amount and related vars.\n   * @param premiumCalculator the premium calculator contract\n   * @param poolInfo storage pointer to the protection pool info\n   * @param _protectionPurchaseParams the protection purchase params\n   * @param totalSTokenUnderlying the total sToken underlying amount\n   * @param _leverageRatio the leverage ratio scaled to 18 decimals\n   * @return _premiumAmountIn18Decimals The premium amount scaled to 18 decimals.\n   * @return _premiumAmount The premium amount in underlying token decimals.\n   * @return _isMinPremium True if the premium amount is equal to the minimum premium amount, false otherwise.\n   */\n  function calculateProtectionPremium(\n    IPremiumCalculator premiumCalculator,\n    ProtectionPoolInfo storage poolInfo,\n    ProtectionPurchaseParams calldata _protectionPurchaseParams,\n    uint256 totalSTokenUnderlying,\n    uint256 _leverageRatio\n  )\n    public\n    view\n    returns (\n      uint256 _premiumAmountIn18Decimals,\n      uint256 _premiumAmount,\n      bool _isMinPremium\n    )\n  {\n    /// Calculate the protection premium amount scaled to 18 decimals and scale it to the underlying token decimals.\n    /// This function call has bunch of inline vars to avoid \"Stack too deep\" error.\n    (_premiumAmountIn18Decimals, _isMinPremium) = premiumCalculator\n      .calculatePremium(\n        /// the protection duration in seconds\n        _protectionPurchaseParams.protectionDurationInSeconds,\n        /// the protection amount scaled to 18 decimals\n        scaleUnderlyingAmtTo18Decimals(\n          _protectionPurchaseParams.protectionAmount,\n          poolInfo.underlyingToken.decimals()\n        ),\n        /// the buyer's APR scaled to 18 decimals\n        poolInfo.referenceLendingPools.calculateProtectionBuyerAPR(\n          _protectionPurchaseParams.lendingPoolAddress\n        ),\n        _leverageRatio,\n        totalSTokenUnderlying,\n        poolInfo.params\n      );\n\n    _premiumAmount = scale18DecimalsAmtToUnderlyingDecimals(\n      _premiumAmountIn18Decimals,\n      poolInfo.underlyingToken.decimals()\n    );\n  }\n\n  /**\n   * @notice Calculates & tracks the premium amount for the protection purchase.\n   * @param premiumCalculator the premium calculator contract\n   * @param protectionBuyerAccounts storage pointer to the protection buyer accounts\n   * @param poolInfo storage pointer to the protection pool info\n   * @param lendingPoolDetail storage pointer to the lending pool detail\n   * @param _protectionPurchaseParams the protection purchase params\n   * @param _maxPremiumAmount the maximum premium amount\n   * @return _premiumAmountIn18Decimals The premium amount scaled to 18 decimals.\n   * @return _premiumAmount The premium amount in underlying token decimals.\n   * @return _isMinPremium True if the premium amount is equal to the minimum premium amount, false otherwise.\n   */\n  function calculateAndTrackPremium(\n    IPremiumCalculator premiumCalculator,\n    mapping(address => ProtectionBuyerAccount) storage protectionBuyerAccounts,\n    ProtectionPoolInfo storage poolInfo,\n    LendingPoolDetail storage lendingPoolDetail,\n    ProtectionPurchaseParams calldata _protectionPurchaseParams,\n    uint256 _maxPremiumAmount,\n    uint256 totalSTokenUnderlying,\n    uint256 _leverageRatio\n  )\n    external\n    returns (\n      uint256 _premiumAmountIn18Decimals,\n      uint256 _premiumAmount,\n      bool _isMinPremium\n    )\n  {\n    /// Calculate the protection premium\n    (\n      _premiumAmountIn18Decimals,\n      _premiumAmount,\n      _isMinPremium\n    ) = calculateProtectionPremium(\n      premiumCalculator,\n      poolInfo,\n      _protectionPurchaseParams,\n      totalSTokenUnderlying,\n      _leverageRatio\n    );\n\n    // If calculated premium amount is higher than the max premium amount, revert.\n    if (_premiumAmount > _maxPremiumAmount) {\n      revert IProtectionPool.PremiumExceedsMaxPremiumAmount(\n        _premiumAmount,\n        _maxPremiumAmount\n      );\n    }\n\n    /// Increase the premium amount in the protection buyer account for the given lending pool\n    protectionBuyerAccounts[msg.sender].lendingPoolToPremium[\n      _protectionPurchaseParams.lendingPoolAddress\n    ] += _premiumAmount;\n\n    /// Increase the total premium amount in the lending pool detail\n    lendingPoolDetail.totalPremium += _premiumAmount;\n  }\n\n  /**\n   * @dev Accrues premium for given loan protection from last premium accrual to the latest payment timestamp.\n   * @param protectionInfo The loan protection to accrue premium for.\n   * @param _lastPremiumAccrualTimestamp The timestamp of last premium accrual.\n   * @param _latestPaymentTimestamp The timestamp of latest payment made to the underlying lending pool.\n   * @return _accruedPremiumInUnderlying The premium accrued for the protection.\n   * @return _protectionExpired Whether the loan protection has expired or not.\n   */\n  function verifyAndAccruePremium(\n    ProtectionPoolInfo storage poolInfo,\n    ProtectionInfo storage protectionInfo,\n    uint256 _lastPremiumAccrualTimestamp,\n    uint256 _latestPaymentTimestamp\n  )\n    external\n    view\n    returns (uint256 _accruedPremiumInUnderlying, bool _protectionExpired)\n  {\n    uint256 _startTimestamp = protectionInfo.startTimestamp;\n\n    /// This means no payment has been made after the protection is bought or protection starts in the future.\n    /// so no premium needs to be accrued.\n    if (\n      _latestPaymentTimestamp < _startTimestamp ||\n      _startTimestamp > block.timestamp\n    ) {\n      return (0, false);\n    }\n\n    /// Calculate the protection expiration timestamp and\n    /// Check if the protection is expired or not.\n    uint256 _expirationTimestamp = protectionInfo.startTimestamp +\n      protectionInfo.purchaseParams.protectionDurationInSeconds;\n    _protectionExpired = block.timestamp > _expirationTimestamp;\n\n    /// Only accrue premium if the protection is expired\n    /// or latest payment is made after the protection start & last premium accrual\n    if (\n      _protectionExpired ||\n      (_latestPaymentTimestamp > _startTimestamp &&\n        _latestPaymentTimestamp > _lastPremiumAccrualTimestamp)\n    ) {\n      /**\n       * <-Protection Bought(second: 0) --- last accrual --- now(latestPaymentTimestamp) --- Expiration->\n       * The time line starts when protection is bought and ends when protection is expired.\n       * secondsUntilLastPremiumAccrual is the second elapsed since the last accrual timestamp.\n       * secondsUntilLatestPayment is the second elapsed until latest payment is made.\n       */\n\n      // When premium is accrued for the first time, the _secondsUntilLastPremiumAccrual is 0.\n      uint256 _secondsUntilLastPremiumAccrual;\n      if (_lastPremiumAccrualTimestamp > _startTimestamp) {\n        _secondsUntilLastPremiumAccrual =\n          _lastPremiumAccrualTimestamp -\n          _startTimestamp;\n      }\n\n      /// if loan protection is expired, then accrue premium till expiration and mark it for removal\n      uint256 _secondsUntilLatestPayment;\n      if (_protectionExpired) {\n        _secondsUntilLatestPayment = _expirationTimestamp - _startTimestamp;\n        console.log(\n          \"Protection expired for amt: %s\",\n          protectionInfo.purchaseParams.protectionAmount\n        );\n      } else {\n        _secondsUntilLatestPayment = _latestPaymentTimestamp - _startTimestamp;\n      }\n\n      /// Calculate the accrued premium amount scaled to 18 decimals\n      uint256 _accruedPremiumIn18Decimals = AccruedPremiumCalculator\n        .calculateAccruedPremium(\n          _secondsUntilLastPremiumAccrual,\n          _secondsUntilLatestPayment,\n          protectionInfo.K,\n          protectionInfo.lambda\n        );\n\n      console.log(\n        \"accruedPremium from second %s to %s: \",\n        _secondsUntilLastPremiumAccrual,\n        _secondsUntilLatestPayment,\n        _accruedPremiumIn18Decimals\n      );\n\n      /// Scale the premium amount to underlying decimals\n      _accruedPremiumInUnderlying = scale18DecimalsAmtToUnderlyingDecimals(\n        _accruedPremiumIn18Decimals,\n        poolInfo.underlyingToken.decimals()\n      );\n    }\n  }\n\n  /**\n   * @notice Marks the given protection as expired and moves it from active to expired protection indexes.\n   * @param protectionBuyerAccounts storage pointer to protection buyer accounts\n   * @param protectionInfo storage pointer to protection info\n   * @param lendingPoolDetail storage pointer to lending pool detail\n   * @param _protectionIndex The index of the protection to expire.\n   */\n  function expireProtection(\n    mapping(address => ProtectionBuyerAccount) storage protectionBuyerAccounts,\n    ProtectionInfo storage protectionInfo,\n    LendingPoolDetail storage lendingPoolDetail,\n    uint256 _protectionIndex\n  ) public {\n    /// Update protection info to mark it as expired\n    protectionInfo.expired = true;\n\n    /// remove expired protection index from activeProtectionIndexes of lendingPool & buyer account\n    address _buyer = protectionInfo.buyer;\n    lendingPoolDetail.activeProtectionIndexes.remove(_protectionIndex);\n    ProtectionBuyerAccount storage buyerAccount = protectionBuyerAccounts[\n      _buyer\n    ];\n    buyerAccount.activeProtectionIndexes.remove(_protectionIndex);\n\n    /// Update buyer account to add expired protection index to expiredProtectionIndexes of lendingPool\n    ProtectionPurchaseParams storage purchaseParams = protectionInfo\n      .purchaseParams;\n    buyerAccount.expiredProtectionIndexByLendingPool[\n      purchaseParams.lendingPoolAddress\n    ][purchaseParams.nftLpTokenId] = _protectionIndex;\n\n    /// update total protection amount of lending pool by subtracting the expired protection amount\n    lendingPoolDetail.totalProtection -= protectionInfo\n      .purchaseParams\n      .protectionAmount;\n  }\n\n  /**\n   * @notice Scales the given underlying token amount to the amount with 18 decimals.\n   * @param _underlyingAmt The amount to scale.\n   * @param _underlyingTokenDecimals The number of decimals of the underlying token.\n   * @return The scaled amount with 18 decimals.\n   */\n  function scaleUnderlyingAmtTo18Decimals(\n    uint256 _underlyingAmt,\n    uint256 _underlyingTokenDecimals\n  ) public pure returns (uint256) {\n    return\n      (_underlyingAmt * Constants.SCALE_18_DECIMALS) /\n      10**(_underlyingTokenDecimals);\n  }\n\n  /**\n   * @notice Scales the given amount from 18 decimals to specified number of decimals.\n   * @param amt The amount to scale.\n   * @param _targetDecimals The number of decimals to scale to.\n   * @return The scaled amount with target decimals.\n   */\n  function scale18DecimalsAmtToUnderlyingDecimals(\n    uint256 amt,\n    uint256 _targetDecimals\n  ) public pure returns (uint256) {\n    return (amt * 10**_targetDecimals) / Constants.SCALE_18_DECIMALS;\n  }\n\n  /**\n   * @notice Verifies whether a buyer can renew protection for same lending position\n   * in the same lending pool specified in the protection purchase params, otherwise reverts.\n   * Protection can be renewed only within grace period after the protection is expired.\n   * @param protectionBuyerAccounts storage pointer to protection buyer accounts\n   * @param protectionInfos storage pointer to protection infos\n   * @param _protectionPurchaseParams The protection purchase params.\n   * @param _renewalGracePeriodInSeconds The grace period in seconds for renewal.\n   */\n  function verifyBuyerCanRenewProtection(\n    mapping(address => ProtectionBuyerAccount) storage protectionBuyerAccounts,\n    ProtectionInfo[] storage protectionInfos,\n    ProtectionPurchaseParams calldata _protectionPurchaseParams,\n    uint256 _renewalGracePeriodInSeconds\n  ) external view {\n    uint256 _renewalProtectionIndex = protectionBuyerAccounts[msg.sender]\n      .expiredProtectionIndexByLendingPool[\n        _protectionPurchaseParams.lendingPoolAddress\n      ][_protectionPurchaseParams.nftLpTokenId];\n\n    if (_renewalProtectionIndex == 0) {\n      revert IProtectionPool.NoExpiredProtectionToRenew();\n    }\n\n    ProtectionInfo storage expiredProtectionInfo = protectionInfos[\n      _renewalProtectionIndex\n    ];\n    ProtectionPurchaseParams\n      storage expiredProtectionPurchaseParams = expiredProtectionInfo\n        .purchaseParams;\n\n    /// This means a buyer has expired protection for the same lending position\n    if (\n      expiredProtectionPurchaseParams.lendingPoolAddress ==\n      _protectionPurchaseParams.lendingPoolAddress &&\n      expiredProtectionPurchaseParams.nftLpTokenId ==\n      _protectionPurchaseParams.nftLpTokenId\n    ) {\n      /// If we are NOT within grace period after the protection is expired, then revert\n      if (\n        block.timestamp >\n        (expiredProtectionInfo.startTimestamp +\n          expiredProtectionPurchaseParams.protectionDurationInSeconds +\n          _renewalGracePeriodInSeconds)\n      ) {\n        revert IProtectionPool.CanNotRenewProtectionAfterGracePeriod();\n      }\n    }\n  }\n\n  /**\n   * @dev Verify that the lending pool is active, otherwise revert.\n   * @param defaultStateManager The default state manager contract.\n   * @param _protectionPoolAddress The address of the protection pool.\n   * @param _lendingPoolAddress The address of the lending pool.\n   */\n  function _verifyLendingPoolIsActive(\n    IDefaultStateManager defaultStateManager,\n    address _protectionPoolAddress,\n    address _lendingPoolAddress\n  ) internal view {\n    LendingPoolStatus poolStatus = defaultStateManager.getLendingPoolStatus(\n      _protectionPoolAddress,\n      _lendingPoolAddress\n    );\n\n    if (poolStatus == LendingPoolStatus.NotSupported) {\n      revert IProtectionPool.LendingPoolNotSupported(_lendingPoolAddress);\n    }\n\n    if (\n      poolStatus == LendingPoolStatus.LateWithinGracePeriod ||\n      poolStatus == LendingPoolStatus.Late\n    ) {\n      revert IProtectionPool.LendingPoolHasLatePayment(_lendingPoolAddress);\n    }\n\n    if (poolStatus == LendingPoolStatus.Expired) {\n      revert IProtectionPool.LendingPoolExpired(_lendingPoolAddress);\n    }\n\n    if (poolStatus == LendingPoolStatus.Defaulted) {\n      revert IProtectionPool.LendingPoolDefaulted(_lendingPoolAddress);\n    }\n  }\n\n  /**\n   * @dev Verify that the protection duration is valid, otherwise revert.\n   * @param poolCycleManager The pool cycle manager contract.\n   * @param _poolAddress The address of the protection pool.\n   * @param _protectionStartTimestamp The protection start timestamp.\n   * @param _protectionDurationInSeconds The protection duration in seconds.\n   * @param _minProtectionDurationInSeconds The minimum protection duration in seconds.\n   */\n  function _verifyProtectionDuration(\n    IProtectionPoolCycleManager poolCycleManager,\n    address _poolAddress,\n    uint256 _protectionStartTimestamp,\n    uint256 _protectionDurationInSeconds,\n    uint256 _minProtectionDurationInSeconds\n  ) internal {\n    uint256 _protectionExpirationTimestamp = _protectionStartTimestamp +\n      _protectionDurationInSeconds;\n    /// protection duration must be longer than specified minimum\n    if (_protectionDurationInSeconds < _minProtectionDurationInSeconds) {\n      revert IProtectionPool.ProtectionDurationTooShort(\n        _protectionDurationInSeconds\n      );\n    }\n\n    /// protection expiry can not be be after the next cycle end\n    poolCycleManager.calculateAndSetPoolCycleState(_poolAddress);\n    uint256 _nextCycleEndTimestamp = poolCycleManager.getNextCycleEndTimestamp(\n      _poolAddress\n    );\n\n    if (_protectionExpirationTimestamp > _nextCycleEndTimestamp) {\n      revert IProtectionPool.ProtectionDurationTooLong(\n        _protectionDurationInSeconds\n      );\n    }\n  }\n}"
    },
    {
      "filename": "contracts/core/pool/ProtectionPool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {EnumerableSetUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport {IERC20MetadataUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport {UUPSUpgradeableBase} from \"../../UUPSUpgradeableBase.sol\";\nimport {SToken} from \"./SToken.sol\";\nimport {IPremiumCalculator} from \"../../interfaces/IPremiumCalculator.sol\";\nimport {IReferenceLendingPools, LendingPoolStatus, ProtectionPurchaseParams} from \"../../interfaces/IReferenceLendingPools.sol\";\nimport {IProtectionPoolCycleManager, ProtectionPoolCycleState} from \"../../interfaces/IProtectionPoolCycleManager.sol\";\nimport {IProtectionPool, ProtectionPoolParams, ProtectionPoolInfo, ProtectionInfo, LendingPoolDetail, WithdrawalCycleDetail, ProtectionBuyerAccount, ProtectionPoolPhase} from \"../../interfaces/IProtectionPool.sol\";\nimport {IDefaultStateManager} from \"../../interfaces/IDefaultStateManager.sol\";\n\nimport \"../../libraries/AccruedPremiumCalculator.sol\";\nimport \"../../libraries/Constants.sol\";\nimport \"../../libraries/ProtectionPoolHelper.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * @title ProtectionPool\n * @author Carapace Finance\n * @notice ProtectionPool is the core contract of the protocol.\n * Each protection pool is a market where protection sellers\n * and buyers can swap credit default risks of designated/referenced underlying loans.\n * Protection buyers purchase protections by paying a premium in underlying tokens to the pool.\n * Protection sellers deposit underlying tokens into the pool and receives proportionate shares of STokens.\n * Protection sellers can withdraw their underlying tokens from the pool after requesting a withdrawal\n * and only during the open period following the next pool cycle's end.\n *\n * This contract is upgradeable using the UUPS pattern.\n */\ncontract ProtectionPool is\n  UUPSUpgradeableBase,\n  ReentrancyGuardUpgradeable,\n  IProtectionPool,\n  SToken\n{\n  /*** libraries ***/\n  using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n  using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n\n  //////////////////////////////////////////////////////\n  ///             STORAGE- START                   ///\n  /////////////////////////////////////////////////////\n  /**\n   * @dev DO NOT CHANGE THE ORDER OF THESE VARIABLES ONCE DEPLOYED\n   */\n\n  /// @notice Reference to the PremiumPricing contract\n  IPremiumCalculator private premiumCalculator;\n\n  /// @notice Reference to the ProtectionPoolCycleManager contract\n  IProtectionPoolCycleManager private poolCycleManager;\n\n  /// @notice Reference to default state manager contract\n  IDefaultStateManager private defaultStateManager;\n\n  /// @notice information about this protection pool\n  ProtectionPoolInfo private poolInfo;\n\n  /// @notice The total underlying amount of premium paid to the pool by protection buyers\n  uint256 private totalPremium;\n\n  /// @notice The total underlying amount of protection bought from this pool by protection buyers\n  uint256 private totalProtection;\n\n  /// @notice The total premium accrued in underlying token up to the last premium accrual timestamp\n  uint256 private totalPremiumAccrued;\n\n  /**\n   * @notice The total underlying amount in the pool backing the value of STokens.\n   * @notice This is the total capital deposited by sellers + accrued premiums from buyers - locked capital - default payouts.\n   */\n  uint256 private totalSTokenUnderlying;\n\n  /// @notice The array to track all protections bought from this pool\n  /// @dev This array has dummy element at index 0 to validate the index of the protection\n  ProtectionInfo[] private protectionInfos;\n\n  /// @notice The mapping to track pool cycle index at which actual withdrawal will happen to withdrawal details\n  mapping(uint256 => WithdrawalCycleDetail) private withdrawalCycleDetails;\n\n  /// @notice The mapping to track all lending pool details by address\n  mapping(address => LendingPoolDetail) private lendingPoolDetails;\n\n  /// @notice The mapping to track all protection buyer accounts by address\n  mapping(address => ProtectionBuyerAccount) private protectionBuyerAccounts;\n\n  //////////////////////////////////////////////////////\n  ///             STORAGE - END                     ///\n  /////////////////////////////////////////////////////\n\n  /*** modifiers ***/\n\n  /// @notice Checks whether pool cycle is in open state. If not, reverts.\n  /// @dev This modifier is used to restrict certain functions to be called only during the open period of a pool cycle.\n  /// @dev This modifier also updates the pool cycle state before verifying the state.\n  modifier whenPoolIsOpen() {\n    /// Update the pool cycle state\n    ProtectionPoolCycleState cycleState = poolCycleManager\n      .calculateAndSetPoolCycleState(address(this));\n\n    if (cycleState != ProtectionPoolCycleState.Open) {\n      revert ProtectionPoolIsNotOpen();\n    }\n    _;\n  }\n\n  /// @notice Checks caller is DefaultStateManager contract. If not, reverts.\n  /// @dev This modifier is used to restrict certain functions to be called only by the DefaultStateManager contract.\n  modifier onlyDefaultStateManager() {\n    if (msg.sender != address(defaultStateManager)) {\n      revert OnlyDefaultStateManager(msg.sender);\n    }\n    _;\n  }\n\n  /*** initializer ***/\n\n  /// @inheritdoc IProtectionPool\n  function initialize(\n    address _owner,\n    ProtectionPoolInfo calldata _poolInfo,\n    IPremiumCalculator _premiumCalculator,\n    IProtectionPoolCycleManager _poolCycleManager,\n    IDefaultStateManager _defaultStateManager,\n    string calldata _name,\n    string calldata _symbol\n  ) external override initializer {\n    /// initialize parent contracts in same order as they are inherited to mimic the behavior of a constructor\n    __UUPSUpgradeableBase_init();\n    __ReentrancyGuard_init();\n    __sToken_init(_name, _symbol);\n\n    /// set the storage variables\n    poolInfo = _poolInfo;\n    premiumCalculator = _premiumCalculator;\n    poolCycleManager = _poolCycleManager;\n    defaultStateManager = _defaultStateManager;\n\n    emit ProtectionPoolInitialized(\n      _name,\n      _symbol,\n      poolInfo.underlyingToken,\n      poolInfo.referenceLendingPools\n    );\n\n    /// Transfer the ownership of this pool to the specified owner\n    _transferOwnership(_owner);\n\n    /// Add dummy protection info to make index 0 invalid\n    protectionInfos.push();\n  }\n\n  /*** state-changing functions ***/\n\n  /// @inheritdoc IProtectionPool\n  function buyProtection(\n    ProtectionPurchaseParams calldata _protectionPurchaseParams,\n    uint256 _maxPremiumAmount\n  ) external override whenNotPaused nonReentrant {\n    /// Verify that user can buy protection and then create protection\n    _verifyAndCreateProtection(\n      block.timestamp,\n      _protectionPurchaseParams,\n      _maxPremiumAmount,\n      false\n    );\n  }\n\n  /// @inheritdoc IProtectionPool\n  function renewProtection(\n    ProtectionPurchaseParams calldata _protectionPurchaseParams,\n    uint256 _maxPremiumAmount\n  ) external override whenNotPaused nonReentrant {\n    /// Verify that user can renew protection\n    ProtectionPoolHelper.verifyBuyerCanRenewProtection(\n      protectionBuyerAccounts,\n      protectionInfos,\n      _protectionPurchaseParams,\n      poolInfo.params.protectionRenewalGracePeriodInSeconds\n    );\n\n    /// Verify that user can buy protection and then create a new protection for renewal\n    _verifyAndCreateProtection(\n      block.timestamp,\n      _protectionPurchaseParams,\n      _maxPremiumAmount,\n      true\n    );\n  }\n\n  /// @inheritdoc IProtectionPool\n  function deposit(uint256 _underlyingAmount, address _receiver)\n    external\n    override\n    whenNotPaused\n    nonReentrant\n  {\n    _deposit(_underlyingAmount, _receiver);\n  }\n\n  /// @inheritdoc IProtectionPool\n  function requestWithdrawal(uint256 _sTokenAmount)\n    external\n    override\n    whenNotPaused\n  {\n    _requestWithdrawal(_sTokenAmount);\n  }\n\n  /// @inheritdoc IProtectionPool\n  function depositAndRequestWithdrawal(\n    uint256 _underlyingAmountToDeposit,\n    uint256 _sTokenAmountToWithdraw\n  ) external virtual override whenNotPaused nonReentrant {\n    _deposit(_underlyingAmountToDeposit, msg.sender);\n    _requestWithdrawal(_sTokenAmountToWithdraw);\n  }\n\n  /// @inheritdoc IProtectionPool\n  function withdraw(uint256 _sTokenWithdrawalAmount, address _receiver)\n    external\n    override\n    whenPoolIsOpen\n    whenNotPaused\n    nonReentrant\n  {\n    /// Step 1: Retrieve withdrawal details for current pool cycle index\n    uint256 _currentCycleIndex = poolCycleManager.getCurrentCycleIndex(\n      address(this)\n    );\n    WithdrawalCycleDetail storage withdrawalCycle = withdrawalCycleDetails[\n      _currentCycleIndex\n    ];\n\n    /// Step 2: Verify withdrawal request exists in this withdrawal cycle for the user\n    uint256 _sTokenRequested = withdrawalCycle.withdrawalRequests[msg.sender];\n    if (_sTokenRequested == 0) {\n      revert NoWithdrawalRequested(msg.sender, _currentCycleIndex);\n    }\n\n    /// Step 3: Verify that withdrawal amount is not more than the requested amount.\n    if (_sTokenWithdrawalAmount > _sTokenRequested) {\n      revert WithdrawalHigherThanRequested(msg.sender, _sTokenRequested);\n    }\n\n    /// Step 4: calculate underlying amount to transfer based on sToken withdrawal amount\n    uint256 _underlyingAmountToTransfer = convertToUnderlying(\n      _sTokenWithdrawalAmount\n    );\n\n    /// Step 5: burn sTokens shares.\n    /// This step must be done after calculating underlying amount to be transferred\n    _burn(msg.sender, _sTokenWithdrawalAmount);\n\n    /// Step 6: Update total sToken underlying amount\n    totalSTokenUnderlying -= _underlyingAmountToTransfer;\n\n    /// Step 7: update seller's withdrawal amount and total requested withdrawal amount\n    withdrawalCycle.withdrawalRequests[msg.sender] -= _sTokenWithdrawalAmount;\n    withdrawalCycle.totalSTokenRequested -= _sTokenWithdrawalAmount;\n\n    /// Step 8: transfer underlying token to receiver\n    poolInfo.underlyingToken.safeTransfer(\n      _receiver,\n      _underlyingAmountToTransfer\n    );\n\n    emit WithdrawalMade(msg.sender, _sTokenWithdrawalAmount, _receiver);\n  }\n\n  /// @inheritdoc IProtectionPool\n  /// @dev Can't use 'calldata` for _lendingPools parameter because of potential re-assignment in the function\n  function accruePremiumAndExpireProtections(address[] memory _lendingPools)\n    external\n    override\n  {\n    /// When no lending pools are passed, accrue premium for all lending pools\n    if (_lendingPools.length == 0) {\n      _lendingPools = poolInfo.referenceLendingPools.getLendingPools();\n    }\n\n    /// Track total premium accrued and protection removed for all lending pools\n    uint256 _totalPremiumAccrued;\n    uint256 _totalProtectionRemoved;\n\n    /// Iterate all lending pools of this protection pool to check if there is new payment after last premium accrual\n    uint256 length = _lendingPools.length;\n    for (uint256 _lendingPoolIndex; _lendingPoolIndex < length; ) {\n      /// Retrieve lending pool detail from the storage\n      address _lendingPool = _lendingPools[_lendingPoolIndex];\n      LendingPoolDetail storage lendingPoolDetail = lendingPoolDetails[\n        _lendingPool\n      ];\n\n      /// Get the latest payment timestamp for the lending pool\n      uint256 _latestPaymentTimestamp = poolInfo\n        .referenceLendingPools\n        .getLatestPaymentTimestamp(_lendingPool);\n\n      /// Get the last premium accrual timestamp for the lending pool from the storage\n      uint256 _lastPremiumAccrualTimestamp = lendingPoolDetail\n        .lastPremiumAccrualTimestamp;\n\n      console.log(\n        \"lendingPool: %s, lastPremiumAccrualTimestamp: %s, latestPaymentTimestamp: %s\",\n        _lendingPool,\n        _lastPremiumAccrualTimestamp,\n        _latestPaymentTimestamp\n      );\n\n      /// Iterate all active protections for this lending pool and\n      /// accrue premium and expire protections if there is new payment\n      (\n        uint256 _accruedPremiumForLendingPool,\n        uint256 _totalProtectionRemovedForLendingPool\n      ) = _accruePremiumAndExpireProtections(\n          lendingPoolDetail,\n          _lastPremiumAccrualTimestamp,\n          _latestPaymentTimestamp\n        );\n      _totalPremiumAccrued += _accruedPremiumForLendingPool;\n      _totalProtectionRemoved += _totalProtectionRemovedForLendingPool;\n\n      /// Persist the last premium accrual of the lending pool in the storage,\n      /// only if there was premium accrued\n      if (_accruedPremiumForLendingPool > 0) {\n        lendingPoolDetail.lastPremiumAccrualTimestamp = _latestPaymentTimestamp;\n\n        emit PremiumAccrued(_lendingPool, _latestPaymentTimestamp);\n      }\n\n      unchecked {\n        ++_lendingPoolIndex;\n      }\n    }\n\n    /// Gas optimization: only update storage vars if there was premium accrued\n    if (_totalPremiumAccrued > 0) {\n      totalPremiumAccrued += _totalPremiumAccrued;\n      totalSTokenUnderlying += _totalPremiumAccrued;\n    }\n\n    /// Reduce the total protection amount of this protection pool\n    /// by the total protection amount of the expired protections\n    if (_totalProtectionRemoved > 0) {\n      totalProtection -= _totalProtectionRemoved;\n    }\n  }\n\n  /// @inheritdoc IProtectionPool\n  function lockCapital(address _lendingPoolAddress)\n    external\n    payable\n    override\n    onlyDefaultStateManager\n    whenNotPaused\n    returns (uint256 _lockedAmount, uint256 _snapshotId)\n  {\n    /// step 1: Capture protection pool's current investors by creating a snapshot of the token balance by using ERC20Snapshot in SToken\n    _snapshotId = _snapshot();\n\n    /// step 2: calculate total"
    }
  ]
}