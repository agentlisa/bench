{
  "Title": "[M-12] Single hardcoded cap used for multiple tokens in a pump causing some assets to be more stale, while having no effects on other stable assets",
  "Content": "\n<https://github.com/code-423n4/2023-07-basin/blob/c1b72d4e372a6246e0efbd57b47fb4cbb5d77062/src/pumps/MultiFlowPump.sol#L36-L37> \n\n<https://github.com/code-423n4/2023-07-basin/blob/c1b72d4e372a6246e0efbd57b47fb4cbb5d77062/src/pumps/MultiFlowPump.sol#L205-L208> \n\n<https://github.com/code-423n4/2023-07-basin/blob/c1b72d4e372a6246e0efbd57b47fb4cbb5d77062/src/pumps/MultiFlowPump.sol#L212-L215>\n\n### Impact\n\nWhen multiple tokens are handled in MultiFlowPump.sol, during trading, the pump might either unfairly reflects volatile assets to be more stale than normal trading activities, Or may fail to have any effects on relatively more stable assets.\n\nThis could distort SMA and EMA token reserve values and unfairly reflect some token prices because it uses a one-size-fits-all approach to multiple token asset prices indiscriminate of their normal volatility levels.\n\n### Proof of Concept\n\nIn MultiFlowPump.sol, a universal cap of maximum percentage change of a token reserve is set up as immutable variables - `LOG_MAX_INCREASE` and `LOG_MAX_DECREASE`. These two values are benchmarks for all tokens handled by the pump and are used to cap token reserve change per block in `_capReserve()`. And this cap is applied and checked on every single `update()` invoked by Well.sol.\n\n```solidity\n//MultiFlowPump.sol\n    bytes16 immutable LOG_MAX_INCREASE;\n    bytes16 immutable LOG_MAX_DECREASE;\n```\n\n```solidity\n//MultiFlowPump.sol-update()\n...\n  for (uint256 i; i < numberOfReserves; ++i) {\n            // Use a minimum of 1 for reserve. Geometric means will be set to 0 if a reserve is 0.\n|>            pumpState.lastReserves[i] = _capReserve(\n                pumpState.lastReserves[i], (reserves[i] > 0 ? reserves[i] : 1).fromUIntToLog2(), blocksPassed\n            );\n...\n```\n\n```solidity\n//MultiFlowPump.sol-_capReserve()\n...\n        if (lastReserve.cmp(reserve) == 1) {\n|>            bytes16 minReserve = lastReserve.add(blocksPassed.mul(LOG_MAX_DECREASE));\n            // if reserve < minimum reserve, set reserve to minimum reserve\n            if (minReserve.cmp(reserve) == 1) reserve = minReserve;\n        }\n        // Rerserve Increasing or staying the same.\n        else {\n|>            bytes16 maxReserve = blocksPassed.mul(LOG_MAX_INCREASE);\n            maxReserve = lastReserve.add(maxReserve);\n            // If reserve > maximum reserve, set reserve to maximum reserve\n            if (reserve.cmp(maxReserve) == 1) reserve = maxReserve;\n        }\n        cappedReserve = reserve;\n...\n```\n\nAs seen from above, whenever a token reserve change is over the percentage dictated by `LOG_MAX_INCREASE` or `LOG_MAX_DECREASE`, the token reserve change will be capped at the maximum percentage and rewritten as calculated `minReserve` or `maxReserve` value. This is fine if the pump is only managing one trading pair(two tokens) because their trading volatility level can be determined.\n\nHowever, this is highly vulnerable when multiple trading pairs and multiple token assets are handled by a pump. And this is the intended scenario, which can be seen in Well.sol `_updatePumps()` where all token reserves handled by well will be passed to MultiFlowPump.sol. In this case, either volatile tokens will become more stale compared to their normal trading activities, or some stable tokens are allowed to deviate more than their normal trading activities which are vulnerable to exploits.\n\nSee POC below as an example to show the above scenario. Full test file [here](https://gist.github.com/bzpassersby/bae15f0dec2ed656758ff468b734ec07).\n\n```solidity\n//Pump.HardCap.t.sol\n...\n function setUp() public {\n        mWell = new MockReserveWell();\n        initUser();\n        pump = new MultiFlowPump(\n            from18(0.5e18),\n            from18(0.333333333333333333e18),\n            12,\n            from18(0.9e18)\n        );\n    }\n\n    function test_HardCap() public {\n        uint256[] memory initReserves = new uint256[](4);\n        //initiate for mWell and pump\n        initReserves[0] = 100e8; //wBTC\n        initReserves[1] = 1600e18; //wETH\n        initReserves[2] = 99000e4; //USDC\n        initReserves[3] = 98000e4; //USDT\n        mWell.update(address(pump), initReserves, new bytes(0));\n        increaseTime(12);\n        //Reserve update\n        uint256[] memory updateReserves = new uint256[](4);\n        updateReserves[0] = 160e8; //wBTC\n        updateReserves[1] = 1000e18; //wETH\n        updateReserves[2] = 96000e4; //USDC\n        updateReserves[3] = 101000e4; //USDT\n        mWell.update(address(pump), updateReserves, new bytes(0));\n        // lastReserves0 reflects initReserves[i]\n        uint256[] memory lastReserves0 = pump.readLastReserves(address(mWell));\n        increaseTime(12);\n        mWell.update(address(pump), updateReserves, new bytes(0));\n        // lastReserves1 reflects 1st reserve update\n        uint256[] memory lastReserves1 = pump.readLastReserves(address(mWell));\n        assertEq(\n            ((lastReserves1[0] - lastReserves0[0]) * 1000) / lastReserves0[0],\n            500\n        ); //wBTC: 50% reserve change versus 60% reserve change in well\n        console.log(lastReserves1[0]); //14999999999\n        assertEq(\n            ((lastReserves0[1] - lastReserves1[1]) * 1000) / lastReserves0[1],\n            333\n        ); //wETH: 33% reserve change versus 37.5% reserve change in well\n        console.log(lastReserves1[1]); //1066666666666666667199\n        assertApproxEqAbs(lastReserves1[2], 96000e4, 1); //USDC: reserve change matches well, 3% change decrease\n        assertApproxEqAbs(lastReserves1[3], 101000e4, 1); //USDT: reserve change matches well, 3% reserve increase\n    }\n...\n```\n\nAs seen in POC, USDT/USDC reserve changes of more than 3% are allowed, whereas WBTC/WETH reserve changes are restricted. The test is based on 50% for max percentage per block increase and 33% max percentage per block decrease. Although the exact percentage change settings can be different and the actual token reserve changes per block differ by assets, the idea is such universal cap value likely will not fit multiple tokens or trading pairs. The cap can be either set too wide which is then no need to have a cap at all, or be set in a manner that restricts some volatile token assets.\n\nSee test results.\n\n```\nRunning 1 test for test/pumps/Pump.HardCap.t.sol:PumpHardCapTest\n[PASS] test_HardCap() (gas: 489346)\nLogs:\n  14999999999\n  1066666666666666667199\n\nTest result: ok. 1 passed; 0 failed; finished in 18.07ms\n\n```\n\n### Tools Used\n\nVS Code.\n\n### Recommended Mitigation Steps\n\nDifferent assets have different levels of volatility, and such variations in volatility are typically taken into account in an AMM or oracle. (Think UniswapV3 with different tick spacings, or chainlink with different price reporting intervals).\n\nIt’s better to avoid setting up `LOG_MAX_INCREASE`, `LOG_MIN_INCREASE` directly in MultiFlowPump.sol.\n\n(1) Instead, in Well.sol allow `MAX_INCREASE` and `MAX_DECREASE` to be token specific and included as part of the immutable data created at the time of Well.sol development from Aquifer.sol, such that a token address can be included together with `MAX_INCREASE` and `MAX_DECREASE` as immutable constants.\n\n(2) Then in `_updatePumps()`, pass current token reserves, and pass token `MAX_INCREASE` and `MAX_DECREASE` as `_pump.data` to MultiFlowPump.sol `update()`.\n\n(3) In MultiFlowPump.sol `update()` , when calculating `_capReserve()` , use decoded `_pump.data` to pass `MAX_INCREASE`, `MAX_DECREASE` for token specific cap calculation.\n\n**[publiuss (Basin) disagreed with severity and commented](https://github.com/code-423n4/2023-07-basin-findings/issues/55#issuecomment-1640000231):**\n > A separate Beanstalk Pump could always be deployed. Plus, the effects of manipulation are the same whether it is volatile or stable. Recommend changing to low.\n\n**[alcueca (Judge) commented](https://github.com/code-423n4/2023-07-basin-findings/issues/55#issuecomment-1664672424):**\n > The documentation provided makes no mention that the all the tokens in MultiFlowPump should have similar typical volatility. The MultiFlowPump is vulnerable exactly as described.\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-basin",
  "Code": [
    {
      "filename": "src/pumps/MultiFlowPump.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport {IPump} from \"src/interfaces/pumps/IPump.sol\";\nimport {IMultiFlowPumpErrors} from \"src/interfaces/pumps/IMultiFlowPumpErrors.sol\";\nimport {IWell} from \"src/interfaces/IWell.sol\";\nimport {IInstantaneousPump} from \"src/interfaces/pumps/IInstantaneousPump.sol\";\nimport {ICumulativePump} from \"src/interfaces/pumps/ICumulativePump.sol\";\nimport {ABDKMathQuad} from \"src/libraries/ABDKMathQuad.sol\";\nimport {LibBytes16} from \"src/libraries/LibBytes16.sol\";\nimport {LibLastReserveBytes} from \"src/libraries/LibLastReserveBytes.sol\";\nimport {SafeCast} from \"oz/utils/math/SafeCast.sol\";\n\n/**\n * @title MultiFlowPump\n * @author Publius\n * @notice Stores a geometric EMA and cumulative geometric SMA for each reserve.\n * @dev A Pump designed for use in Beanstalk with 2 tokens.\n *\n * This Pump has 3 main features:\n *  1. Multi-block MEV resistence reserves\n *  2. MEV-resistant Geometric EMA intended for instantaneous reserve queries\n *  3. MEV-resistant Cumulative Geometric intended for SMA reserve queries\n *\n * Note: If an `update` call is made with a reserve of 0, the Geometric mean oracles will be set to 0.\n * Each Well is responsible for ensuring that an `update` call cannot be made with a reserve of 0.\n */\ncontract MultiFlowPump is IPump, IMultiFlowPumpErrors, IInstantaneousPump, ICumulativePump {\n    using SafeCast for uint256;\n    using LibLastReserveBytes for bytes32;\n    using LibBytes16 for bytes32;\n    using ABDKMathQuad for bytes16;\n    using ABDKMathQuad for uint256;\n\n    bytes16 immutable LOG_MAX_INCREASE;\n    bytes16 immutable LOG_MAX_DECREASE;\n    bytes16 immutable ALPHA;\n    uint256 immutable BLOCK_TIME;\n\n    struct PumpState {\n        uint40 lastTimestamp;\n        bytes16[] lastReserves;\n        bytes16[] emaReserves;\n        bytes16[] cumulativeReserves;\n    }\n\n    /**\n     * @param _maxPercentIncrease The maximum percent increase allowed in a single block. Must be in quadruple precision format (See {ABDKMathQuad}).\n     * @param _maxPercentDecrease The maximum percent decrease allowed in a single block. Must be in quadruple precision format (See {ABDKMathQuad}).\n     * @param _blockTime The block time in the current EVM in seconds.\n     * @param _alpha The geometric EMA constant. Must be in quadruple precision format (See {ABDKMathQuad}).\n     */\n    constructor(bytes16 _maxPercentIncrease, bytes16 _maxPercentDecrease, uint256 _blockTime, bytes16 _alpha) {\n        LOG_MAX_INCREASE = ABDKMathQuad.ONE.add(_maxPercentIncrease).log_2();\n        // _maxPercentDecrease <= 100%\n        if (_maxPercentDecrease > ABDKMathQuad.ONE) {\n            revert InvalidMaxPercentDecreaseArgument(_maxPercentDecrease);\n        }\n        LOG_MAX_DECREASE = ABDKMathQuad.ONE.sub(_maxPercentDecrease).log_2();\n        BLOCK_TIME = _blockTime;\n\n        // ALPHA <= 1\n        if (_alpha > ABDKMathQuad.ONE) {\n            revert InvalidAArgument(_alpha);\n        }\n        ALPHA = _alpha;\n    }\n\n    //////////////////// PUMP ////////////////////\n\n    function update(uint256[] calldata reserves, bytes calldata) external {\n        uint256 numberOfReserves = reserves.length;\n        PumpState memory pumpState;\n\n        // All reserves are stored starting at the msg.sender address slot in storage.\n        bytes32 slot = _getSlotForAddress(msg.sender);\n\n        // Read: Last Timestamp & Last Reserves\n        (, pumpState.lastTimestamp, pumpState.lastReserves) = slot.readLastReserves();\n\n        // If the last timestamp is 0, then the pump has never been used before.\n        if (pumpState.lastTimestamp == 0) {\n            for (uint256 i; i < numberOfReserves; ++i) {\n                // If a reserve is 0, then the pump cannot be initialized.\n                if (reserves[i] == 0) return;\n            }\n            _init(slot, uint40(block.timestamp), reserves);\n            return;\n        }\n\n        // Read: Cumulative & EMA Reserves\n        // Start at the slot after `pumpState.lastReserves`\n        uint256 numSlots = _getSlotsOffset(numberOfReserves);\n        assembly {\n            slot := add(slot, numSlots)\n        }\n        pumpState.emaReserves = slot.readBytes16(numberOfReserves);\n        assembly {\n            slot := add(slot, numSlots)\n        }\n        pumpState.cumulativeReserves = slot.readBytes16(numberOfReserves);\n\n        bytes16 alphaN;\n        bytes16 deltaTimestampBytes;\n        bytes16 blocksPassed;\n        // Isolate in brackets to prevent stack too deep errors\n        {\n            uint256 deltaTimestamp = _getDeltaTimestamp(pumpState.lastTimestamp);\n            alphaN = ALPHA.powu(deltaTimestamp);\n            deltaTimestampBytes = deltaTimestamp.fromUInt();\n            // Relies on the assumption that a block can only occur every `BLOCK_TIME` seconds.\n            blocksPassed = (deltaTimestamp / BLOCK_TIME).fromUInt();\n        }\n\n        for (uint256 i; i < numberOfReserves; ++i) {\n            // Use a minimum of 1 for reserve. Geometric means will be set to 0 if a reserve is 0.\n            pumpState.lastReserves[i] = _capReserve(\n                pumpState.lastReserves[i], (reserves[i] > 0 ? reserves[i] : 1).fromUIntToLog2(), blocksPassed\n            );\n            pumpState.emaReserves[i] =\n                pumpState.lastReserves[i].mul((ABDKMathQuad.ONE.sub(alphaN))).add(pumpState.emaReserves[i].mul(alphaN));\n            pumpState.cumulativeReserves[i] =\n                pumpState.cumulativeReserves[i].add(pumpState.lastReserves[i].mul(deltaTimestampBytes));\n        }\n\n        // Write: Cumulative & EMA Reserves\n        // Order matters: work backwards to avoid using a new memory var to count up\n        slot.storeBytes16(pumpState.cumulativeReserves);\n        assembly {\n            slot := sub(slot, numSlots)\n        }\n        slot.storeBytes16(pumpState.emaReserves);\n        assembly {\n            slot := sub(slot, numSlots)\n        }\n\n        // Write: Last Timestamp & Last Reserves\n        slot.storeLastReserves(uint40(block.timestamp), pumpState.lastReserves);\n    }\n\n    /**\n     * @dev On first update for a particular Well, initialize oracle with\n     * reserves data.\n     */\n    function _init(bytes32 slot, uint40 lastTimestamp, uint256[] memory reserves) internal {\n        uint256 numberOfReserves = reserves.length;\n        bytes16[] memory byteReserves = new bytes16[](numberOfReserves);\n\n        // Skip {_capReserve} since we have no prior reference\n\n        for (uint256 i; i < numberOfReserves; ++i) {\n            if (reserves[i] == 0) return;\n            byteReserves[i] = reserves[i].fromUIntToLog2();\n        }\n\n        // Write: Last Timestamp & Last Reserves\n        slot.storeLastReserves(lastTimestamp, byteReserves);\n\n        // Write: EMA Reserves\n        // Start at the slot after `byteReserves`\n        uint256 numSlots = _getSlotsOffset(byteReserves.length);\n        assembly {\n            slot := add(slot, numSlots)\n        }\n        slot.storeBytes16(byteReserves); // EMA Reserves\n    }\n\n    //////////////////// LAST RESERVES ////////////////////\n\n    function readLastReserves(address well) public view returns (uint256[] memory reserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        (uint8 numberOfReserves,, bytes16[] memory bytesReserves) = slot.readLastReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        reserves = new uint256[](numberOfReserves);\n        for (uint256 i; i < numberOfReserves; ++i) {\n            reserves[i] = bytesReserves[i].pow_2ToUInt();\n        }\n    }\n\n    /**\n     * @dev Adds a cap to the reserve value to prevent extreme changes.\n     *\n     *  Linear space:\n     *     max reserve = (last reserve) * ((1 + MAX_PERCENT_CHANGE_PER_BLOCK) ^ blocks)\n     *\n     *  Log space:\n     *     log2(max reserve) = log2(last reserve) + blocks*log2(1 + MAX_PERCENT_CHANGE_PER_BLOCK)\n     *\n     *     `bytes16 lastReserve`      <- log2(last reserve)\n     *     `bytes16 blocksPassed`     <- log2(blocks)\n     *     `bytes16 LOG_MAX_INCREASE` <- log2(1 + MAX_PERCENT_CHANGE_PER_BLOCK)\n     *\n     *     ∴ `maxReserve = lastReserve + blocks*LOG_MAX_INCREASE`\n     *\n     */\n    function _capReserve(\n        bytes16 lastReserve,\n        bytes16 reserve,\n        bytes16 blocksPassed\n    ) internal view returns (bytes16 cappedReserve) {\n        // Reserve decreasing (lastReserve > reserve)\n        if (lastReserve.cmp(reserve) == 1) {\n            bytes16 minReserve = lastReserve.add(blocksPassed.mul(LOG_MAX_DECREASE));\n            // if reserve < minimum reserve, set reserve to minimum reserve\n            if (minReserve.cmp(reserve) == 1) reserve = minReserve;\n        }\n        // Rerserve Increasing or staying the same.\n        else {\n            bytes16 maxReserve = blocksPassed.mul(LOG_MAX_INCREASE);\n            maxReserve = lastReserve.add(maxReserve);\n            // If reserve > maximum reserve, set reserve to maximum reserve\n            if (reserve.cmp(maxReserve) == 1) reserve = maxReserve;\n        }\n        cappedReserve = reserve;\n    }\n\n    //////////////////// EMA RESERVES ////////////////////\n\n    function readLastInstantaneousReserves(address well) public view returns (uint256[] memory reserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        uint8 numberOfReserves = slot.readNumberOfReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        uint256 offset = _getSlotsOffset(numberOfReserves);\n        assembly {\n            slot := add(slot, offset)\n        }\n        bytes16[] memory byteReserves = slot.readBytes16(numberOfReserves);\n        reserves = new uint256[](numberOfReserves);\n        for (uint256 i; i < numberOfReserves; ++i) {\n            reserves[i] = byteReserves[i].pow_2ToUInt();\n        }\n    }\n\n    function readInstantaneousReserves(address well, bytes memory) public view returns (uint256[] memory emaReserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        uint256[] memory reserves = IWell(well).getReserves();\n        (uint8 numberOfReserves, uint40 lastTimestamp, bytes16[] memory lastReserves) = slot.readLastReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        uint256 offset = _getSlotsOffset(numberOfReserves);\n        assembly {\n            slot := add(slot, offset)\n        }\n        bytes16[] memory lastEmaReserves = slot.readBytes16(numberOfReserves);\n        uint256 deltaTimestamp = _getDeltaTimestamp(lastTimestamp);\n        bytes16 blocksPassed = (deltaTimestamp / BLOCK_TIME).fromUInt();\n        bytes16 alphaN = ALPHA.powu(deltaTimestamp);\n        emaReserves = new uint256[](numberOfReserves);\n        for (uint256 i; i < numberOfReserves; ++i) {\n            lastReserves[i] = _capReserve(lastReserves[i], reserves[i].fromUIntToLog2(), blocksPassed);\n            emaReserves[i] =\n                lastReserves[i].mul((ABDKMathQuad.ONE.sub(alphaN))).add(lastEmaReserves[i].mul(alphaN)).pow_2ToUInt();\n        }\n    }\n\n    //////////////////// CUMULATIVE RESERVES ////////////////////\n\n    /**\n     * @notice Read the latest cumulative reserves of `well`.\n     */\n    function readLastCumulativeReserves(address well) public view returns (bytes16[] memory reserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        uint8 numberOfReserves = slot.readNumberOfReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        uint256 offset = _getSlotsOffset(numberOfReserves) << 1;\n        assembly {\n            slot := add(slot, offset)\n        }\n        reserves = slot.readBytes16(numberOfReserves);\n    }\n\n    function readCumulativeReserves(address well, bytes memory) public view returns (bytes memory cumulativeReserves) {\n        bytes16[] memory byteCumulativeReserves = _readCumulativeReserves(well);\n        cumulativeReserves = abi.encode(byteCumulativeReserves);\n    }\n\n    function _readCumulativeReserves(address well) internal view returns (bytes16[] memory cumulativeReserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        uint256[] memory reserves = IWell(well).getReserves();\n        (uint8 numberOfReserves, uint40 lastTimestamp, bytes16[] memory lastReserves) = slot.readLastReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        uint256 offset = _getSlotsOffset(numberOfReserves) << 1;\n        assembly {\n            slot := add(slot, offset)\n        }\n        cumulativeReserves = slot.readBytes16(numberOfReserves);\n        uint256 deltaTimestamp = _getDeltaTimestamp(lastTimestamp);\n        bytes16 deltaTimestampBytes = deltaTimestamp.fromUInt();\n        bytes16 blocksPassed = (deltaTimestamp / BLOCK_TIME).fromUInt();\n        // Currently, there is so support for overflow.\n        for (uint256 i; i < cumulativeReserves.length; ++i) {\n            lastReserves[i] = _capReserve(lastReserves[i], reserves[i].fromUIntToLog2(), blocksPassed);\n            cumulativeReserves[i] = cumulativeReserves[i].add(lastReserves[i].mul(deltaTimestampBytes));\n        }\n    }\n\n    function readTwaReserves(\n        address well,\n        bytes calldata startCumulativeReserves,\n        uint256 startTimestamp,\n        bytes memory\n    ) public view returns (uint256[] memory twaReserves, bytes memory cumulativeReserves) {\n        bytes16[] memory byteCumulativeReserves = _readCumulativeReserves(well);\n        bytes16[] memory byteStartCumulativeReserves = abi.decode(startCumulativeReserves, (bytes16[]));\n        twaReserves = new uint256[](byteCumulativeReserves.length);\n\n        // Overflow is desired on `startTimestamp`, so SafeCast is not used.\n        bytes16 deltaTimestamp = _getDeltaTimestamp(uint40(startTimestamp)).fromUInt();\n        if (deltaTimestamp == bytes16(0)) {\n            revert NoTimePassed();\n        }\n        for (uint256 i; i < byteCumulativeReserves.length; ++i) {\n            // Currently, there is no support for overflow.\n            twaReserves[i] =\n                (byteCumulativeReserves[i].sub(byteStartCumulativeReserves[i])).div(deltaTimestamp).pow_2ToUInt();\n        }\n        cumulativeReserves = abi.encode(byteCumulativeReserves);\n    }\n\n    //////////////////// HELPERS ////////////////////\n\n    /**\n     * @dev Convert an `address` into a `bytes32` by zero padding the right 12 bytes.\n     */\n    function _getSlotForAddress(address addressValue) internal pure returns (bytes32) {\n        return bytes32(bytes20(addressValue)); // Because right padded, no collision on adjacent\n    }\n\n    /**\n     * @dev Get the starting byte of the slot that contains the `n`th element of an array.\n     */\n    function _getSlotsOffset(uint256 numberOfReserves) internal pure returns (uint256) {\n        return ((numberOfReserves - 1) / 2 + 1) << 5;\n    }\n\n    /**\n     * @dev Get the delta between the current and provided timestamp as a `uint256`.\n     */\n    function _getDeltaTimestamp(uint40 lastTimestamp) internal view returns (uint256) {\n        return uint256(uint40(block.timestamp) - lastTimestamp);\n    }\n}"
    },
    {
      "filename": "src/pumps/MultiFlowPump.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport {IPump} from \"src/interfaces/pumps/IPump.sol\";\nimport {IMultiFlowPumpErrors} from \"src/interfaces/pumps/IMultiFlowPumpErrors.sol\";\nimport {IWell} from \"src/interfaces/IWell.sol\";\nimport {IInstantaneousPump} from \"src/interfaces/pumps/IInstantaneousPump.sol\";\nimport {ICumulativePump} from \"src/interfaces/pumps/ICumulativePump.sol\";\nimport {ABDKMathQuad} from \"src/libraries/ABDKMathQuad.sol\";\nimport {LibBytes16} from \"src/libraries/LibBytes16.sol\";\nimport {LibLastReserveBytes} from \"src/libraries/LibLastReserveBytes.sol\";\nimport {SafeCast} from \"oz/utils/math/SafeCast.sol\";\n\n/**\n * @title MultiFlowPump\n * @author Publius\n * @notice Stores a geometric EMA and cumulative geometric SMA for each reserve.\n * @dev A Pump designed for use in Beanstalk with 2 tokens.\n *\n * This Pump has 3 main features:\n *  1. Multi-block MEV resistence reserves\n *  2. MEV-resistant Geometric EMA intended for instantaneous reserve queries\n *  3. MEV-resistant Cumulative Geometric intended for SMA reserve queries\n *\n * Note: If an `update` call is made with a reserve of 0, the Geometric mean oracles will be set to 0.\n * Each Well is responsible for ensuring that an `update` call cannot be made with a reserve of 0.\n */\ncontract MultiFlowPump is IPump, IMultiFlowPumpErrors, IInstantaneousPump, ICumulativePump {\n    using SafeCast for uint256;\n    using LibLastReserveBytes for bytes32;\n    using LibBytes16 for bytes32;\n    using ABDKMathQuad for bytes16;\n    using ABDKMathQuad for uint256;\n\n    bytes16 immutable LOG_MAX_INCREASE;\n    bytes16 immutable LOG_MAX_DECREASE;\n    bytes16 immutable ALPHA;\n    uint256 immutable BLOCK_TIME;\n\n    struct PumpState {\n        uint40 lastTimestamp;\n        bytes16[] lastReserves;\n        bytes16[] emaReserves;\n        bytes16[] cumulativeReserves;\n    }\n\n    /**\n     * @param _maxPercentIncrease The maximum percent increase allowed in a single block. Must be in quadruple precision format (See {ABDKMathQuad}).\n     * @param _maxPercentDecrease The maximum percent decrease allowed in a single block. Must be in quadruple precision format (See {ABDKMathQuad}).\n     * @param _blockTime The block time in the current EVM in seconds.\n     * @param _alpha The geometric EMA constant. Must be in quadruple precision format (See {ABDKMathQuad}).\n     */\n    constructor(bytes16 _maxPercentIncrease, bytes16 _maxPercentDecrease, uint256 _blockTime, bytes16 _alpha) {\n        LOG_MAX_INCREASE = ABDKMathQuad.ONE.add(_maxPercentIncrease).log_2();\n        // _maxPercentDecrease <= 100%\n        if (_maxPercentDecrease > ABDKMathQuad.ONE) {\n            revert InvalidMaxPercentDecreaseArgument(_maxPercentDecrease);\n        }\n        LOG_MAX_DECREASE = ABDKMathQuad.ONE.sub(_maxPercentDecrease).log_2();\n        BLOCK_TIME = _blockTime;\n\n        // ALPHA <= 1\n        if (_alpha > ABDKMathQuad.ONE) {\n            revert InvalidAArgument(_alpha);\n        }\n        ALPHA = _alpha;\n    }\n\n    //////////////////// PUMP ////////////////////\n\n    function update(uint256[] calldata reserves, bytes calldata) external {\n        uint256 numberOfReserves = reserves.length;\n        PumpState memory pumpState;\n\n        // All reserves are stored starting at the msg.sender address slot in storage.\n        bytes32 slot = _getSlotForAddress(msg.sender);\n\n        // Read: Last Timestamp & Last Reserves\n        (, pumpState.lastTimestamp, pumpState.lastReserves) = slot.readLastReserves();\n\n        // If the last timestamp is 0, then the pump has never been used before.\n        if (pumpState.lastTimestamp == 0) {\n            for (uint256 i; i < numberOfReserves; ++i) {\n                // If a reserve is 0, then the pump cannot be initialized.\n                if (reserves[i] == 0) return;\n            }\n            _init(slot, uint40(block.timestamp), reserves);\n            return;\n        }\n\n        // Read: Cumulative & EMA Reserves\n        // Start at the slot after `pumpState.lastReserves`\n        uint256 numSlots = _getSlotsOffset(numberOfReserves);\n        assembly {\n            slot := add(slot, numSlots)\n        }\n        pumpState.emaReserves = slot.readBytes16(numberOfReserves);\n        assembly {\n            slot := add(slot, numSlots)\n        }\n        pumpState.cumulativeReserves = slot.readBytes16(numberOfReserves);\n\n        bytes16 alphaN;\n        bytes16 deltaTimestampBytes;\n        bytes16 blocksPassed;\n        // Isolate in brackets to prevent stack too deep errors\n        {\n            uint256 deltaTimestamp = _getDeltaTimestamp(pumpState.lastTimestamp);\n            alphaN = ALPHA.powu(deltaTimestamp);\n            deltaTimestampBytes = deltaTimestamp.fromUInt();\n            // Relies on the assumption that a block can only occur every `BLOCK_TIME` seconds.\n            blocksPassed = (deltaTimestamp / BLOCK_TIME).fromUInt();\n        }\n\n        for (uint256 i; i < numberOfReserves; ++i) {\n            // Use a minimum of 1 for reserve. Geometric means will be set to 0 if a reserve is 0.\n            pumpState.lastReserves[i] = _capReserve(\n                pumpState.lastReserves[i], (reserves[i] > 0 ? reserves[i] : 1).fromUIntToLog2(), blocksPassed\n            );\n            pumpState.emaReserves[i] =\n                pumpState.lastReserves[i].mul((ABDKMathQuad.ONE.sub(alphaN))).add(pumpState.emaReserves[i].mul(alphaN));\n            pumpState.cumulativeReserves[i] =\n                pumpState.cumulativeReserves[i].add(pumpState.lastReserves[i].mul(deltaTimestampBytes));\n        }\n\n        // Write: Cumulative & EMA Reserves\n        // Order matters: work backwards to avoid using a new memory var to count up\n        slot.storeBytes16(pumpState.cumulativeReserves);\n        assembly {\n            slot := sub(slot, numSlots)\n        }\n        slot.storeBytes16(pumpState.emaReserves);\n        assembly {\n            slot := sub(slot, numSlots)\n        }\n\n        // Write: Last Timestamp & Last Reserves\n        slot.storeLastReserves(uint40(block.timestamp), pumpState.lastReserves);\n    }\n\n    /**\n     * @dev On first update for a particular Well, initialize oracle with\n     * reserves data.\n     */\n    function _init(bytes32 slot, uint40 lastTimestamp, uint256[] memory reserves) internal {\n        uint256 numberOfReserves = reserves.length;\n        bytes16[] memory byteReserves = new bytes16[](numberOfReserves);\n\n        // Skip {_capReserve} since we have no prior reference\n\n        for (uint256 i; i < numberOfReserves; ++i) {\n            if (reserves[i] == 0) return;\n            byteReserves[i] = reserves[i].fromUIntToLog2();\n        }\n\n        // Write: Last Timestamp & Last Reserves\n        slot.storeLastReserves(lastTimestamp, byteReserves);\n\n        // Write: EMA Reserves\n        // Start at the slot after `byteReserves`\n        uint256 numSlots = _getSlotsOffset(byteReserves.length);\n        assembly {\n            slot := add(slot, numSlots)\n        }\n        slot.storeBytes16(byteReserves); // EMA Reserves\n    }\n\n    //////////////////// LAST RESERVES ////////////////////\n\n    function readLastReserves(address well) public view returns (uint256[] memory reserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        (uint8 numberOfReserves,, bytes16[] memory bytesReserves) = slot.readLastReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        reserves = new uint256[](numberOfReserves);\n        for (uint256 i; i < numberOfReserves; ++i) {\n            reserves[i] = bytesReserves[i].pow_2ToUInt();\n        }\n    }\n\n    /**\n     * @dev Adds a cap to the reserve value to prevent extreme changes.\n     *\n     *  Linear space:\n     *     max reserve = (last reserve) * ((1 + MAX_PERCENT_CHANGE_PER_BLOCK) ^ blocks)\n     *\n     *  Log space:\n     *     log2(max reserve) = log2(last reserve) + blocks*log2(1 + MAX_PERCENT_CHANGE_PER_BLOCK)\n     *\n     *     `bytes16 lastReserve`      <- log2(last reserve)\n     *     `bytes16 blocksPassed`     <- log2(blocks)\n     *     `bytes16 LOG_MAX_INCREASE` <- log2(1 + MAX_PERCENT_CHANGE_PER_BLOCK)\n     *\n     *     ∴ `maxReserve = lastReserve + blocks*LOG_MAX_INCREASE`\n     *\n     */\n    function _capReserve(\n        bytes16 lastReserve,\n        bytes16 reserve,\n        bytes16 blocksPassed\n    ) internal view returns (bytes16 cappedReserve) {\n        // Reserve decreasing (lastReserve > reserve)\n        if (lastReserve.cmp(reserve) == 1) {\n            bytes16 minReserve = lastReserve.add(blocksPassed.mul(LOG_MAX_DECREASE));\n            // if reserve < minimum reserve, set reserve to minimum reserve\n            if (minReserve.cmp(reserve) == 1) reserve = minReserve;\n        }\n        // Rerserve Increasing or staying the same.\n        else {\n            bytes16 maxReserve = blocksPassed.mul(LOG_MAX_INCREASE);\n            maxReserve = lastReserve.add(maxReserve);\n            // If reserve > maximum reserve, set reserve to maximum reserve\n            if (reserve.cmp(maxReserve) == 1) reserve = maxReserve;\n        }\n        cappedReserve = reserve;\n    }\n\n    //////////////////// EMA RESERVES ////////////////////\n\n    function readLastInstantaneousReserves(address well) public view returns (uint256[] memory reserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        uint8 numberOfReserves = slot.readNumberOfReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        uint256 offset = _getSlotsOffset(numberOfReserves);\n        assembly {\n            slot := add(slot, offset)\n        }\n        bytes16[] memory byteReserves = slot.readBytes16(numberOfReserves);\n        reserves = new uint256[](numberOfReserves);\n        for (uint256 i; i < numberOfReserves; ++i) {\n            reserves[i] = byteReserves[i].pow_2ToUInt();\n        }\n    }\n\n    function readInstantaneousReserves(address well, bytes memory) public view returns (uint256[] memory emaReserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        uint256[] memory reserves = IWell(well).getReserves();\n        (uint8 numberOfReserves, uint40 lastTimestamp, bytes16[] memory lastReserves) = slot.readLastReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        uint256 offset = _getSlotsOffset(numberOfReserves);\n        assembly {\n            slot := add(slot, offset)\n        }\n        bytes16[] memory lastEmaReserves = slot.readBytes16(numberOfReserves);\n        uint256 deltaTimestamp = _getDeltaTimestamp(lastTimestamp);\n        bytes16 blocksPassed = (deltaTimestamp / BLOCK_TIME).fromUInt();\n        bytes16 alphaN = ALPHA.powu(deltaTimestamp);\n        emaReserves = new uint256[](numberOfReserves);\n        for (uint256 i; i < numberOfReserves; ++i) {\n            lastReserves[i] = _capReserve(lastReserves[i], reserves[i].fromUIntToLog2(), blocksPassed);\n            emaReserves[i] =\n                lastReserves[i].mul((ABDKMathQuad.ONE.sub(alphaN))).add(lastEmaReserves[i].mul(alphaN)).pow_2ToUInt();\n        }\n    }\n\n    //////////////////// CUMULATIVE RESERVES ////////////////////\n\n    /**\n     * @notice Read the latest cumulative reserves of `well`.\n     */\n    function readLastCumulativeReserves(address well) public view returns (bytes16[] memory reserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        uint8 numberOfReserves = slot.readNumberOfReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        uint256 offset = _getSlotsOffset(numberOfReserves) << 1;\n        assembly {\n            slot := add(slot, offset)\n        }\n        reserves = slot.readBytes16(numberOfReserves);\n    }\n\n    function readCumulativeReserves(address well, bytes memory) public view returns (bytes memory cumulativeReserves) {\n        bytes16[] memory byteCumulativeReserves = _readCumulativeReserves(well);\n        cumulativeReserves = abi.encode(byteCumulativeReserves);\n    }\n\n    function _readCumulativeReserves(address well) internal view returns (bytes16[] memory cumulativeReserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        uint256[] memory reserves = IWell(well).getReserves();\n        (uint8 numberOfReserves, uint40 lastTimestamp, bytes16[] memory lastReserves) = slot.readLastReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        uint256 offset = _getSlotsOffset(numberOfReserves) << 1;\n        assembly {\n            slot := add(slot, offset)\n        }\n        cumulativeReserves = slot.readBytes16(numberOfReserves);\n        uint256 deltaTimestamp = _getDeltaTimestamp(lastTimestamp);\n        bytes16 deltaTimestampBytes = deltaTimestamp.fromUInt();\n        bytes16 blocksPassed = (deltaTimestamp / BLOCK_TIME).fromUInt();\n        // Currently, there is so support for overflow.\n        for (uint256 i; i < cumulativeReserves.length; ++i) {\n            lastReserves[i] = _capReserve(lastReserves[i], reserves[i].fromUIntToLog2(), blocksPassed);\n            cumulativeReserves[i] = cumulativeReserves[i].add(lastReserves[i].mul(deltaTimestampBytes));\n        }\n    }\n\n    function readTwaReserves(\n        address well,\n        bytes calldata startCumulativeReserves,\n        uint256 startTimestamp,\n        bytes memory\n    ) public view returns (uint256[] memory twaReserves, bytes memory cumulativeReserves) {\n        bytes16[] memory byteCumulativeReserves = _readCumulativeReserves(well);\n        bytes16[] memory byteStartCumulativeReserves = abi.decode(startCumulativeReserves, (bytes16[]));\n        twaReserves = new uint256[](byteCumulativeReserves.length);\n\n        // Overflow is desired on `startTimestamp`, so SafeCast is not used.\n        bytes16 deltaTimestamp = _getDeltaTimestamp(uint40(startTimestamp)).fromUInt();\n        if (deltaTimestamp == bytes16(0)) {\n            revert NoTimePassed();\n        }\n        for (uint256 i; i < byteCumulativeReserves.length; ++i) {\n            // Currently, there is no support for overflow.\n            twaReserves[i] =\n                (byteCumulativeReserves[i].sub(byteStartCumulativeReserves[i])).div(deltaTimestamp).pow_2ToUInt();\n        }\n        cumulativeReserves = abi.encode(byteCumulativeReserves);\n    }\n\n    //////////////////// HELPERS ////////////////////\n\n    /**\n     * @dev Convert an `address` into a `bytes32` by zero padding the right 12 bytes.\n     */\n    function _getSlotForAddress(address addressValue) internal pure returns (bytes32) {\n        return bytes32(bytes20(addressValue)); // Because right padded, no collision on adjacent\n    }\n\n    /**\n     * @dev Get the starting byte of the slot that contains the `n`th element of an array.\n     */\n    function _getSlotsOffset(uint256 numberOfReserves) internal pure returns (uint256) {\n        return ((numberOfReserves - 1) / 2 + 1) << 5;\n    }\n\n    /**\n     * @dev Get the delta between the current and provided timestamp as a `uint256`.\n     */\n    function _getDeltaTimestamp(uint40 lastTimestamp) internal view returns (uint256) {\n        return uint256(uint40(block.timestamp) - lastTimestamp);\n    }\n}"
    },
    {
      "filename": "src/pumps/MultiFlowPump.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport {IPump} from \"src/interfaces/pumps/IPump.sol\";\nimport {IMultiFlowPumpErrors} from \"src/interfaces/pumps/IMultiFlowPumpErrors.sol\";\nimport {IWell} from \"src/interfaces/IWell.sol\";\nimport {IInstantaneousPump} from \"src/interfaces/pumps/IInstantaneousPump.sol\";\nimport {ICumulativePump} from \"src/interfaces/pumps/ICumulativePump.sol\";\nimport {ABDKMathQuad} from \"src/libraries/ABDKMathQuad.sol\";\nimport {LibBytes16} from \"src/libraries/LibBytes16.sol\";\nimport {LibLastReserveBytes} from \"src/libraries/LibLastReserveBytes.sol\";\nimport {SafeCast} from \"oz/utils/math/SafeCast.sol\";\n\n/**\n * @title MultiFlowPump\n * @author Publius\n * @notice Stores a geometric EMA and cumulative geometric SMA for each reserve.\n * @dev A Pump designed for use in Beanstalk with 2 tokens.\n *\n * This Pump has 3 main features:\n *  1. Multi-block MEV resistence reserves\n *  2. MEV-resistant Geometric EMA intended for instantaneous reserve queries\n *  3. MEV-resistant Cumulative Geometric intended for SMA reserve queries\n *\n * Note: If an `update` call is made with a reserve of 0, the Geometric mean oracles will be set to 0.\n * Each Well is responsible for ensuring that an `update` call cannot be made with a reserve of 0.\n */\ncontract MultiFlowPump is IPump, IMultiFlowPumpErrors, IInstantaneousPump, ICumulativePump {\n    using SafeCast for uint256;\n    using LibLastReserveBytes for bytes32;\n    using LibBytes16 for bytes32;\n    using ABDKMathQuad for bytes16;\n    using ABDKMathQuad for uint256;\n\n    bytes16 immutable LOG_MAX_INCREASE;\n    bytes16 immutable LOG_MAX_DECREASE;\n    bytes16 immutable ALPHA;\n    uint256 immutable BLOCK_TIME;\n\n    struct PumpState {\n        uint40 lastTimestamp;\n        bytes16[] lastReserves;\n        bytes16[] emaReserves;\n        bytes16[] cumulativeReserves;\n    }\n\n    /**\n     * @param _maxPercentIncrease The maximum percent increase allowed in a single block. Must be in quadruple precision format (See {ABDKMathQuad}).\n     * @param _maxPercentDecrease The maximum percent decrease allowed in a single block. Must be in quadruple precision format (See {ABDKMathQuad}).\n     * @param _blockTime The block time in the current EVM in seconds.\n     * @param _alpha The geometric EMA constant. Must be in quadruple precision format (See {ABDKMathQuad}).\n     */\n    constructor(bytes16 _maxPercentIncrease, bytes16 _maxPercentDecrease, uint256 _blockTime, bytes16 _alpha) {\n        LOG_MAX_INCREASE = ABDKMathQuad.ONE.add(_maxPercentIncrease).log_2();\n        // _maxPercentDecrease <="
    }
  ]
}