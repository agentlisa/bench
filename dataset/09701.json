{
  "Title": "[M-06] DexManagerFacet: batchRemoveDex() removes first dex only",
  "Content": "_Submitted by hickuphh3, also found by 0xDjango, catchup, csanuragjain, hyh, shw, WatchPug, and ych18_\n\n[DexManagerFacet.sol#L71-L73](https://github.com/code-423n4/2022-03-lifinance/blob/main/src/Facets/DexManagerFacet.sol#L71-L73)<br>\n\nThe function intends to allow the removal of multiple dexes approved for swaps. However, the function will only remove the first DEX because `return` is used instead of `break` in the inner for loop.\n\n```jsx\nif (s.dexs[j] == _dexs[i]) {\n  _removeDex(j);\n  // should be replaced with break;\n  return;\n}\n```\n\nThis error is likely to have gone unnoticed because no event is emitted when a DEX is added or removed.\n\n### Proof of Concept\n\nAdd the following lines below [L44 of](https://github.com/code-423n4/2022-03-Li.finance/blob/main/test/facets/AnyswapFacet.test.ts#L44) `[AnyswapFacet.test.ts](https://github.com/code-423n4/2022-03-lifinance/blob/main/test/facets/AnyswapFacet.test.ts#L44)`\n\n```jsx\nawait dexMgr.addDex(ANYSWAP_ROUTER)\nawait dexMgr.batchRemoveDex([ANYSWAP_ROUTER, UNISWAP_ADDRESS])\n// UNISWAP_ADDRESS remains as approved dex when it should have been removed\nconsole.log(await dexMgr.approvedDexs())\n```\n\n### Recommended Mitigation Steps\n\nReplace `return` with `break`.\n\n```jsx\nif (s.dexs[j] == _dexs[i]) {\n  _removeDex(j);\n  break;\n}\n```\n\nIn addition, it is recommend to emit an event whenever a DEX is added or removed.\n\n**[H3xept (Li.Fi) resolved and commented](https://github.com/code-423n4/2022-03-lifinance-findings/issues/34#issuecomment-1096504104):**\n > Fixed in lifinance/lifi-contracts@0a078bbbdf8ec92bd72efc4257900af416d537d4\n> \n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-03-lifinance-findings/issues/34#issuecomment-1100702209):**\n > Valid POC and sponsor confirmed with fix.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-03-lifinance",
  "Code": [
    {
      "filename": "src/Facets/DexManagerFacet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"../Libraries/LibStorage.sol\";\nimport \"../Libraries/LibDiamond.sol\";\n\n/**\n * @title Optics Router Facet\n * @author Li.Finance (https://li.finance)\n * @notice Facet contract for managing approved DEXs to be used in swaps.\n */\ncontract DexManagerFacet {\n    LibStorage internal s;\n\n    /// @notice Register the address of a DEX contract to be approved for swapping.\n    /// @param _dex The address of the DEX contract to be approved.\n    function addDex(address _dex) external {\n        LibDiamond.enforceIsContractOwner();\n\n        if (s.dexWhitelist[_dex] == true) {\n            return;\n        }\n\n        s.dexWhitelist[_dex] = true;\n        s.dexs.push(_dex);\n    }\n\n    /// @notice Batch register the addresss of DEX contracts to be approved for swapping.\n    /// @param _dexs The addresses of the DEX contracts to be approved.\n    function batchAddDex(address[] calldata _dexs) external {\n        LibDiamond.enforceIsContractOwner();\n\n        for (uint256 i; i < _dexs.length; i++) {\n            if (s.dexWhitelist[_dexs[i]] == true) {\n                continue;\n            }\n            s.dexWhitelist[_dexs[i]] = true;\n            s.dexs.push(_dexs[i]);\n        }\n    }\n\n    /// @notice Unregister the address of a DEX contract approved for swapping.\n    /// @param _dex The address of the DEX contract to be unregistered.\n    function removeDex(address _dex) external {\n        LibDiamond.enforceIsContractOwner();\n\n        if (s.dexWhitelist[_dex] == false) {\n            return;\n        }\n\n        s.dexWhitelist[_dex] = false;\n        for (uint256 i; i < s.dexs.length; i++) {\n            if (s.dexs[i] == _dex) {\n                _removeDex(i);\n                return;\n            }\n        }\n    }\n\n    /// @notice Batch unregister the addresses of DEX contracts approved for swapping.\n    /// @param _dexs The addresses of the DEX contracts to be unregistered.\n    function batchRemoveDex(address[] calldata _dexs) external {\n        LibDiamond.enforceIsContractOwner();\n\n        for (uint256 i; i < _dexs.length; i++) {\n            if (s.dexWhitelist[_dexs[i]] == false) {\n                continue;\n            }\n            s.dexWhitelist[_dexs[i]] = false;\n            for (uint256 j; j < s.dexs.length; j++) {\n                if (s.dexs[j] == _dexs[i]) {\n                    _removeDex(j);\n                    return;\n                }\n            }\n        }\n    }\n\n    function approvedDexs() external view returns (address[] memory) {\n        return s.dexs;\n    }\n\n    function _removeDex(uint256 index) private {\n        // Move the last element into the place to delete\n        s.dexs[index] = s.dexs[s.dexs.length - 1];\n        // Remove the last element\n        s.dexs.pop();\n    }\n}"
    },
    {
      "filename": "test/facets/AnyswapFacet.test.ts",
      "content": "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n  AnyswapFacet,\n  DexManagerFacet,\n  IERC20,\n  IERC20__factory,\n} from '../../typechain'\nimport { deployments, network } from 'hardhat'\nimport { constants, utils } from 'ethers'\nimport { node_url } from '../../utils/network'\nimport { SignerWithAddress } from '@nomiclabs/hardhat-ethers/dist/src/signers'\nimport { expect } from '../chai-setup'\n\nconst ANYSWAP_ROUTER = '0x4f3aff3a747fcade12598081e80c6605a8be192f'\nconst USDT_ADDRESS = '0xc2132D05D31c914a87C6611C10748AEb04B58e8F'\nconst WMATIC_ADDRESS = '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270'\nconst MATIC_ROUTER = '0x2ef4a574b72e1f555185afa8a09c6d1a8ac4025c'\nconst anyMATIC_ADDRESS = '0x21804205c744dd98fbc87898704564d5094bb167'\nconst anyUSDT_ADDRESS = '0xE3eeDa11f06a656FcAee19de663E84C7e61d3Cac'\nconst UNISWAP_ADDRESS = '0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff'\nconst BEEFY_ADDRESS = '0xFbdd194376de19a88118e84E279b977f165d01b8'\nconst BEEFY_ROUTER = '0x6fF0609046A38D76Bd40C5863b4D1a2dCe687f73'\n\ndescribe('AnyswapFacet', function () {\n  let lifi: AnyswapFacet\n  let dexMgr: DexManagerFacet\n  let alice: SignerWithAddress\n  let beefHolder: SignerWithAddress\n  let lifiData: any\n  let token: IERC20\n  let usdt: IERC20\n  let wmatic: IERC20\n\n  const setupTest = deployments.createFixture(\n    async ({ deployments, ethers }) => {\n      await deployments.fixture('DeployAnyswapFacet')\n      const diamond = await ethers.getContract('LiFiDiamond')\n      lifi = <AnyswapFacet>(\n        await ethers.getContractAt('AnyswapFacet', diamond.address)\n      )\n      dexMgr = <DexManagerFacet>(\n        await ethers.getContractAt('DexManagerFacet', diamond.address)\n      )\n      await dexMgr.addDex(UNISWAP_ADDRESS)\n\n      await network.provider.request({\n        method: 'hardhat_impersonateAccount',\n        params: ['0x6722846282868a9c084b423aee79eb8ff69fc497'],\n      })\n\n      await network.provider.request({\n        method: 'hardhat_impersonateAccount',\n        params: ['0xf71b335a1d9449c381d867f4172fc1bb3d2bfb7b'],\n      })\n\n      alice = await ethers.getSigner(\n        '0x6722846282868a9c084b423aee79eb8ff69fc497'\n      )\n\n      beefHolder = await ethers.getSigner(\n        '0xf71b335a1d9449c381d867f4172fc1bb3d2bfb7b'\n      )\n\n      wmatic = IERC20__factory.connect(WMATIC_ADDRESS, alice)\n\n      usdt = IERC20__factory.connect(USDT_ADDRESS, alice)\n      lifiData = {\n        transactionId: utils.randomBytes(32),\n        integrator: 'ACME Devs',\n        referrer: constants.AddressZero,\n        sendingAssetId: usdt.address,\n        receivingAssetId: usdt.address,\n        receiver: alice.address,\n        destinationChainId: 100,\n        amount: utils.parseUnits('1000', 6),\n      }\n      token = IERC20__factory.connect(anyUSDT_ADDRESS, alice)\n      await usdt.approve(lifi.address, utils.parseUnits('1000', 6))\n    }\n  )\n\n  before(async function () {\n    this.timeout(0)\n    await network.provider.request({\n      method: 'hardhat_reset',\n      params: [\n        {\n          forking: {\n            jsonRpcUrl: node_url('polygon'),\n            blockNumber: 25689963,\n          },\n        },\n      ],\n    })\n  })\n\n  beforeEach(async () => {\n    await setupTest()\n  })\n\n  it('starts a bridge transaction using native token on the sending chain', async () => {\n    const AnyswapData = {\n      token: anyMATIC_ADDRESS,\n      router: MATIC_ROUTER,\n      amount: utils.parseEther('1000'),\n      recipient: alice.address,\n      toChainId: 100,\n    }\n\n    await lifi\n      .connect(alice)\n      .startBridgeTokensViaAnyswap(lifiData, AnyswapData, {\n        gasLimit: 500000,\n        value: utils.parseEther('1000'),\n      })\n  })\n\n  it('starts a bridge transaction using anyToken implementation on the sending chain', async () => {\n    const beefy = IERC20__factory.connect(BEEFY_ADDRESS, beefHolder)\n    await beefy.approve(lifi.address, utils.parseEther('10'))\n\n    const AnyswapData = {\n      token: BEEFY_ADDRESS,\n      router: BEEFY_ROUTER,\n      amount: utils.parseEther('10'),\n      recipient: beefHolder.address,\n      toChainId: 100,\n    }\n\n    await lifi\n      .connect(beefHolder)\n      .startBridgeTokensViaAnyswap(lifiData, AnyswapData, {\n        gasLimit: 500000,\n      })\n  })\n\n  it('starts a bridge transaction on the sending chain', async () => {\n    const AnyswapData = {\n      token: token.address,\n      router: ANYSWAP_ROUTER,\n      amount: utils.parseUnits('1000', 6),\n      recipient: alice.address,\n      toChainId: 100,\n    }\n\n    await lifi\n      .connect(alice)\n      .startBridgeTokensViaAnyswap(lifiData, AnyswapData, {\n        gasLimit: 500000,\n      })\n  })\n\n  it('performs a swap then starts bridge transaction on the sending chain', async () => {\n    const to = lifi.address // should be a checksummed recipient address\n    const deadline = Math.floor(Date.now() / 1000) + 60 * 20 // 20 minutes from the current Unix time\n\n    const iface = new utils.Interface([\n      'function swapETHForExactTokens(uint,address[],address,uint256)',\n    ])\n\n    // Generate swap calldata\n    const uniswapData = iface.encodeFunctionData('swapETHForExactTokens', [\n      utils.parseUnits('1000', 6),\n      [wmatic.address, usdt.address],\n      to,\n      deadline,\n    ])\n\n    const swapData = [\n      {\n        callTo: UNISWAP_ADDRESS,\n        approveTo: UNISWAP_ADDRESS,\n        sendingAssetId: '0x0000000000000000000000000000000000000000',\n        receivingAssetId: usdt.address,\n        fromAmount: utils.parseEther('700'),\n        callData: uniswapData,\n      },\n    ]\n\n    const AnyswapData = {\n      token: token.address,\n      router: ANYSWAP_ROUTER,\n      amount: utils.parseUnits('1000', 6),\n      recipient: alice.address,\n      toChainId: 137,\n    }\n\n    await lifi\n      .connect(alice)\n      .swapAndStartBridgeTokensViaAnyswap(lifiData, swapData, AnyswapData, {\n        gasLimit: 500000,\n        value: utils.parseEther('700'),\n      })\n  })\n\n  it('fails to perform a swap when the dex is not approved', async () => {\n    await dexMgr.removeDex(UNISWAP_ADDRESS)\n    const to = lifi.address // should be a checksummed recipient address\n    const deadline = Math.floor(Date.now() / 1000) + 60 * 20 // 20 minutes from the current Unix time\n\n    const iface = new utils.Interface([\n      'function swapETHForExactTokens(uint,address[],address,uint256)',\n    ])\n\n    // Generate swap calldata\n    const uniswapData = iface.encodeFunctionData('swapETHForExactTokens', [\n      utils.parseUnits('1000', 6),\n      [wmatic.address, usdt.address],\n      to,\n      deadline,\n    ])\n\n    const swapData = [\n      {\n        callTo: UNISWAP_ADDRESS,\n        approveTo: UNISWAP_ADDRESS,\n        sendingAssetId: '0x0000000000000000000000000000000000000000',\n        receivingAssetId: usdt.address,\n        fromAmount: utils.parseEther('700'),\n        callData: uniswapData,\n      },\n    ]\n\n    const AnyswapData = {\n      token: token.address,\n      router: ANYSWAP_ROUTER,\n      amount: utils.parseUnits('1000', 6),\n      recipient: alice.address,\n      toChainId: 137,\n    }\n\n    await expect(\n      lifi\n        .connect(alice)\n        .swapAndStartBridgeTokensViaAnyswap(lifiData, swapData, AnyswapData, {\n          gasLimit: 500000,\n          value: utils.parseEther('700'),\n        })\n    ).to.be.revertedWith('Contract call not allowed!')\n  })\n})"
    }
  ]
}