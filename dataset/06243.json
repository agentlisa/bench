{
  "Title": "[H-44] `BigBang::repay` and `Singularity::repay` spend more than allowed amount",
  "Content": "\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/bigBang/BigBang.sol#L263-L268> \n\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/bigBang/BigBang.sol#L721-L732> \n\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/a4793e75a79060f8332927f97c6451362ae30201/contracts/markets/singularity/SGLLendingCommon.sol#L83-L95> \n\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/a4793e75a79060f8332927f97c6451362ae30201/contracts/markets/singularity/SGLBorrow.sol#L45-L52>\n\nWhen an user allows certain amount to a spender, the spender can spend more than the allowance.\n\nNote that this is a different issue from the misuse of `allowedBorrow` for the share amount\n(i.e. issue \"`BigBang::repay` uses `allowedBorrow` with the asset amount, whereas other functions use it with share of collateral\"), as the fix in the other issue will not mitigate this issue.\nThis issue is the misuse of `part` and `elastic`, whereas the other issue is the misuse of the `share` and `asset`.\n\n### Proof of Concept\n\nThe spec in the `MarketERC20::approve` function specifies that the approved amount is the maximum amount that the spender can draw.\n\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/364dead3a42b06a34c802eee951cea1a654d438e/contracts/markets/MarketERC20.sol#L189-L200>\n\n        /// @notice Approves `amount` from sender to be spend by `spender`.\n        /// @param spender Address of the party that can draw from msg.sender's account.\n        /// @param amount The maximum collective amount that `spender` can draw.\n        /// @return (bool) Returns True if approved.\n        function approve( \n            address spender,\n            uint256 amount\n        ) public override returns (bool) {\n\nHowever, the spender can draw more than the allowance if the `totalBorrow.base` is more thant `totalBorrow.elastic`, which is likely condition.\n\nThe proof of concept below demonstrates that more asset was pulled than allowed.\nIt is only a part of proof of concept; to see the full proof of concept see <https://gist.github.com/zzzitron/8dd809c0ea39dc0ea727534c3ba804f9>\nTo use it, put it in the `test/bigBang.test.ts` in the tapiocabar-audit repo\n\nThe eoa1 allows deployer 1e18. After the `timeTravel`, the elastic of `totalBorrow` is more than the `base`. Under the condition, the deployer uses the allowance with the `BigBang::repay` function. As the result, more asset than allowance was pulled from eoa1.\n\n```javascript\n        it('should not allow repay more PoCRepayMoreThanAllowed', async () => {\n            \n            ////////\n            // setup steps are omitted\n            // the full proof of concept is\n            // https://gist.github.com/zzzitron/8dd809c0ea39dc0ea727534c3ba804f9\n            ////////\n\n            // eoa1 allows deployer (it should be `approve`, if the modifier in the repay is `allowedLend`)\n            const allowedPart = ethers.BigNumber.from((1e18).toString());\n            await wethBigBangMarket.connect(eoa1).approveBorrow(deployer.address, allowedPart);\n\n            //repay from eoa1\n            // check more than the allowed amount is pulled from yieldBox\n           \n            timeTravel(10 * 86400);\n\n            // repay from eoa1 the allowed amount\n            // balance before repay of eoa in the yieldBox for the asset\n            const usdoAssetId = await wethBigBangMarket.assetId();\n            const eoa1ShareBalanceBefore = await yieldBox.balanceOf(eoa1.address, usdoAssetId);\n            const eoa1AmountBefore = await yieldBox.toAmount(usdoAssetId, eoa1ShareBalanceBefore, false);\n            await wethBigBangMarket.repay(\n                eoa1.address,\n                deployer.address,\n                false,\n                allowedPart,\n            );\n            const eoa1ShareBalanceAfter = await yieldBox.balanceOf(eoa1.address, usdoAssetId);\n            const eoa1AmountAfter = await yieldBox.toAmount(usdoAssetId, eoa1ShareBalanceAfter, false);\n            console.log(eoa1AmountBefore.sub(eoa1AmountAfter).toString());\n            expect(eoa1AmountBefore.sub(eoa1AmountAfter).gt(allowedPart)).to.be.true;\n        });\n```\n\nThe result of the poc is below, which shows that `1000136987569097987` is pulled from the eoa1, which is more than the allowance (i.e. 1e18).\n\n      BigBang test\n        poc\n    1000136987569097987\n          âœ” should not allow repay more PoCRepayMoreThanAllowed (11934ms)\n\nThe same issue is also in the `Singularity`. In the same manner shown above, the spender will pull more than allowed when the `totalBorrow.elastic` is bigger than the `totalBorrow.base`.\n\n### Details of the bug\n\nThe function `BigBang::repay` uses `part` to check for the allowance.\n\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/bigBang/BigBang.sol#L263-L268>\n\nHowever, the `BigBang::_repay` draws actually the corresponding `elastic` of the `part` from the `from` address.\n\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/bigBang/BigBang.sol#L721-L732>\n\n```solidity\n    function _repay(\n        address from,\n        address to,\n        uint256 part\n    ) internal returns (uint256 amount) {\n        (totalBorrow, amount) = totalBorrow.sub(part, true);\n\n        userBorrowPart[to] -= part;\n\n        uint256 toWithdraw = (amount - part); //acrrued\n        uint256 toBurn = amount - toWithdraw;\n        yieldBox.withdraw(assetId, from, address(this), amount, 0);\n```\n\nThe similar lines of code is also in the `Singularity`. The `Singularity::repay` will delegate call on the `SGLBorrow::repay`, which has the modifier of `allowedBorrow(from, part)`:\n\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/a4793e75a79060f8332927f97c6451362ae30201/contracts/markets/singularity/SGLBorrow.sol#L45-L51>\n\n```solidity\n// SGLBorrow\n\n    function repay(\n        address from,\n        address to,\n        bool skim,\n        uint256 part\n    ) public notPaused allowedBorrow(from, part) returns (uint256 amount) {\n        updateExchangeRate();\n\n```\n\nThen, `amount` is calculated from the `part`, and the `amount` is pulled from the `from` address in the below code snippet.\n\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/a4793e75a79060f8332927f97c6451362ae30201/contracts/markets/singularity/SGLLendingCommon.sol#L83-L95>\n\n```solidity\n    function _repay(\n        address from,\n        address to,\n        bool skim,\n        uint256 part\n    ) internal returns (uint256 amount) {\n        (totalBorrow, amount) = totalBorrow.sub(part, true);\n\n        userBorrowPart[to] -= part;\n\n        uint256 share = yieldBox.toShare(assetId, amount, true);\n        uint128 totalShare = totalAsset.elastic;\n        _addTokens(from, to, assetId, share, uint256(totalShare), skim);\n        totalAsset.elastic = totalShare + uint128(share);\n        emit LogRepay(skim ? address(yieldBox) : from, to, amount, part);\n    }\n```\n\nThe `amount` is likely to be bigger than the `part`, since the calculation is based on the `totalBorrow`'s ratio between `elastic` and `base`.\nThen the `amount` is used to withdraw from `from` address, meaning that more than the allowance is withdrawn.\n\nThe discrepancy between the allowance and actually spendable amount is going to grow in time, as the `totalBorrow`'s elastic will outgrow the base in time.\n\n### Tools Used\n\nHardhat\n\n### Recommended Mitigation Steps\n\nInstead of using the `part` to check the allowance, calculate the actual amount to be pulled and use the amount to check the allowance.\n\n<!-- zzzitron H-BigBang-PoCRepayMoreThanAllowed -->\n\n**[0xRektora (Tapioca) confirmed](https://github.com/code-423n4/2023-07-tapioca-findings/issues/918#issuecomment-1701266875)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-tapioca",
  "Code": [
    {
      "filename": "contracts/markets/bigBang/BigBang.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\n\nimport \"tapioca-periph/contracts/interfaces/IBigBang.sol\";\nimport \"tapioca-periph/contracts/interfaces/ISendFrom.sol\";\nimport \"tapioca-periph/contracts/interfaces/ISwapper.sol\";\nimport {IUSDOBase} from \"tapioca-periph/contracts/interfaces/IUSDO.sol\";\n\nimport \"../Market.sol\";\n\n// solhint-disable max-line-length\n/*\n\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\n\n*/\n\n/// @title BigBang market\n/// @notice Adaptation of the Singularity contract\n/// @dev owner of the contract is Penrose\n///     - the borrow action performs a mint on USDO\n///     - the repay action performs a burn on USDO\n///     - interest rate is not fixed, but dynamic based on the main BigBang market, minDebtRate, maxDebtRate and debtRateAgainstEthMarket\n///         - BigBang markets can either be main or secondary markets; the main market is set on Penrose and has a fixed rate\n///         - BigBang secondary markets has a dynamic interest rate which is starts from `minDebtRate` to `maxDebtRate`\n///             - if current debt is over _maxDebtPoint = (_ethMarketTotalDebt * debtRateAgainstEthMarket) / 1e18, the interest rate is automatically `maxDebtRate`\n///         - simulation: https://dotnetfiddle.net/cuKVpf\ncontract BigBang is BoringOwnable, Market {\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    mapping(address => mapping(address => bool)) public operators;\n\n    IBigBang.AccrueInfo public accrueInfo;\n\n    uint256 public totalFees;\n\n    bool private _isEthMarket;\n    uint256 public maxDebtRate;\n    uint256 public minDebtRate;\n    uint256 public debtRateAgainstEthMarket;\n    uint256 public debtStartPoint;\n    uint256 private constant DEBT_PRECISION = 1e18;\n\n    // ************** //\n    // *** EVENTS *** //\n    // ************** //\n    /// @notice event emitted when accrue is called\n    event LogAccrue(uint256 accruedAmount, uint64 rate);\n    /// @notice event emitted when collateral is added\n    event LogAddCollateral(\n        address indexed from,\n        address indexed to,\n        uint256 share\n    );\n    /// @notice event emitted when collateral is removed\n    event LogRemoveCollateral(\n        address indexed from,\n        address indexed to,\n        uint256 share\n    );\n    /// @notice event emitted when borrow is performed\n    event LogBorrow(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        uint256 feeAmount,\n        uint256 part\n    );\n    /// @notice event emitted when a repay operation is performed\n    event LogRepay(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        uint256 part\n    );\n    /// @notice event emitted when the minimum debt rate is updated\n    event MinDebtRateUpdated(uint256 oldVal, uint256 newVal);\n    /// @notice event emitted when the maximum debt rate is updated\n    event MaxDebtRateUpdated(uint256 oldVal, uint256 newVal);\n    /// @notice event emitted when the debt rate against the main market is updated\n    event DebtRateAgainstEthUpdated(uint256 oldVal, uint256 newVal);\n\n    constructor() MarketERC20(\"Tapioca BigBang\") {}\n\n    /// @notice The init function that acts as a constructor\n    function init(bytes calldata data) external onlyOnce {\n        (\n            IPenrose tapiocaBar_,\n            IERC20 _collateral,\n            uint256 _collateralId,\n            IOracle _oracle,\n            uint256 _exchangeRatePrecision,\n            uint256 _debtRateAgainstEth,\n            uint256 _debtRateMin,\n            uint256 _debtRateMax,\n            uint256 _debtStartPoint\n        ) = abi.decode(\n                data,\n                (\n                    IPenrose,\n                    IERC20,\n                    uint256,\n                    IOracle,\n                    uint256,\n                    uint256,\n                    uint256,\n                    uint256,\n                    uint256\n                )\n            );\n\n        penrose = tapiocaBar_;\n        yieldBox = YieldBox(tapiocaBar_.yieldBox());\n        owner = address(penrose);\n\n        address _asset = penrose.usdoToken();\n\n        require(\n            address(_collateral) != address(0) &&\n                address(_asset) != address(0) &&\n                address(_oracle) != address(0),\n            \"BigBang: bad pair\"\n        );\n\n        asset = IERC20(_asset);\n        assetId = penrose.usdoAssetId();\n        collateral = _collateral;\n        collateralId = _collateralId;\n        oracle = _oracle;\n\n        updateExchangeRate();\n\n        callerFee = 90000; // 90%\n        protocolFee = 10000; // 10%\n        collateralizationRate = 75000; // 75%\n\n        EXCHANGE_RATE_PRECISION = _exchangeRatePrecision > 0\n            ? _exchangeRatePrecision\n            : 1e18;\n\n        _isEthMarket = collateralId == penrose.wethAssetId();\n        if (!_isEthMarket) {\n            debtRateAgainstEthMarket = _debtRateAgainstEth;\n            maxDebtRate = _debtRateMax;\n            minDebtRate = _debtRateMin;\n            debtStartPoint = _debtStartPoint;\n        }\n\n        minLiquidatorReward = 1e3;\n        maxLiquidatorReward = 1e4;\n        liquidationBonusAmount = 1e4;\n        borrowOpeningFee = 50; // 0.05%\n        liquidationMultiplier = 12000; //12%\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice returns total market debt\n    function getTotalDebt() external view returns (uint256) {\n        return totalBorrow.elastic;\n    }\n\n    /// @notice returns the current debt rate\n    function getDebtRate() public view returns (uint256) {\n        if (_isEthMarket) return penrose.bigBangEthDebtRate(); // default 0.5%\n        if (totalBorrow.elastic == 0) return minDebtRate;\n\n        uint256 _ethMarketTotalDebt = BigBang(penrose.bigBangEthMarket())\n            .getTotalDebt();\n        uint256 _currentDebt = totalBorrow.elastic;\n        uint256 _maxDebtPoint = (_ethMarketTotalDebt *\n            debtRateAgainstEthMarket) / 1e18;\n\n        if (_currentDebt >= _maxDebtPoint) return maxDebtRate;\n\n        uint256 debtPercentage = ((_currentDebt - debtStartPoint) *\n            DEBT_PRECISION) / (_maxDebtPoint - debtStartPoint);\n        uint256 debt = ((maxDebtRate - minDebtRate) * debtPercentage) /\n            DEBT_PRECISION +\n            minDebtRate;\n\n        if (debt > maxDebtRate) return maxDebtRate;\n\n        return debt;\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice Allows batched call to BingBang.\n    /// @param calls An array encoded call data.\n    /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.\n    function execute(\n        bytes[] calldata calls,\n        bool revertOnFail\n    ) external returns (bool[] memory successes, string[] memory results) {\n        successes = new bool[](calls.length);\n        results = new string[](calls.length);\n        for (uint256 i = 0; i < calls.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(\n                calls[i]\n            );\n            require(success || !revertOnFail, _getRevertMsg(result));\n            successes[i] = success;\n            results[i] = _getRevertMsg(result);\n        }\n    }\n\n    /// @notice allows 'operator' to act on behalf of the sender\n    /// @param status true/false\n    function updateOperator(address operator, bool status) external {\n        operators[msg.sender][operator] = status;\n    }\n\n    /// @notice Accrues the interest on the borrowed tokens and handles the accumulation of fees.\n    function accrue() public {\n        _accrue();\n    }\n\n    /// @notice Sender borrows `amount` and transfers it to `to`.\n    /// @param from Account to borrow for.\n    /// @param to The receiver of borrowed tokens.\n    /// @param amount Amount to borrow.\n    /// @return part Total part of the debt held by borrowers.\n    /// @return share Total amount in shares borrowed.\n    function borrow(\n        address from,\n        address to,\n        uint256 amount\n    ) public notPaused solvent(from) returns (uint256 part, uint256 share) {\n        uint256 allowanceShare = _computeAllowanceAmountInAsset(\n            from,\n            exchangeRate,\n            amount,\n            asset.safeDecimals()\n        );\n        _allowedBorrow(from, allowanceShare);\n        (part, share) = _borrow(from, to, amount);\n    }\n\n    /// @notice Repays a loan.\n    /// @dev The bool param is not used but we added it to respect the ISingularity interface for MarketsHelper compatibility\n    /// @param from Address to repay from.\n    /// @param to Address of the user this payment should go.\n    /// @param part The amount to repay. See `userBorrowPart`.\n    /// @return amount The total amount repayed.\n    function repay(\n        address from,\n        address to,\n        bool,\n        uint256 part\n    ) public notPaused allowedBorrow(from, part) returns (uint256 amount) {\n        updateExchangeRate();\n\n        accrue();\n\n        amount = _repay(from, to, part);\n    }\n\n    /// @notice Adds `collateral` from msg.sender to the account `to`.\n    /// @param from Account to transfer shares from.\n    /// @param to The receiver of the tokens.\n    /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\n    /// @param share The amount of shares to add for `to`.\n    function addCollateral(\n        address from,\n        address to,\n        bool skim,\n        uint256 amount,\n        uint256 share\n    ) public allowedBorrow(from, share) notPaused {\n        _addCollateral(from, to, skim, amount, share);\n    }\n\n    /// @notice Removes `share` amount of collateral and transfers it to `to`.\n    /// @param from Account to debit collateral from.\n    /// @param to The receiver of the shares.\n    /// @param share Amount of shares to remove.\n    function removeCollateral(\n        address from,\n        address to,\n        uint256 share\n    ) public notPaused solvent(from) allowedBorrow(from, share) {\n        _removeCollateral(from, to, share);\n    }\n\n    /// @notice Entry point for liquidations.\n    /// @param users An array of user addresses.\n    /// @param maxBorrowParts A one-to-one mapping to `users`, contains maximum (partial) borrow amounts (to liquidate) of the respective user.\n    /// @param swapper Contract address of the `MultiSwapper` implementation. See `setSwapper`.\n    /// @param collateralToAssetSwapData Extra swap data\n    function liquidate(\n        address[] calldata users,\n        uint256[] calldata maxBorrowParts,\n        ISwapper swapper,\n        bytes calldata collateralToAssetSwapData\n    ) external notPaused {\n        // Oracle can fail but we still need to allow liquidations\n        (, uint256 _exchangeRate) = updateExchangeRate();\n        _accrue();\n\n        _closedLiquidation(\n            users,\n            maxBorrowParts,\n            swapper,\n            _exchangeRate,\n            collateralToAssetSwapData\n        );\n    }\n\n    /// @notice Lever up: Borrow more and buy collateral with it.\n    /// @param from The user who buys\n    /// @param borrowAmount Amount of extra asset borrowed\n    /// @param supplyAmount Amount of asset supplied (down payment)\n    /// @param minAmountOut Mininal collateral amount to receive\n    /// @param swapper Swapper to execute the purchase\n    /// @param dexData Additional data to pass to the swapper\n    /// @return amountOut Actual collateral amount purchased\n    function buyCollateral(\n        address from,\n        uint256 borrowAmount,\n        uint256 supplyAmount,\n        uint256 minAmountOut,\n        ISwapper swapper,\n        bytes calldata dexData\n    ) external notPaused solvent(from) returns (uint256 amountOut) {\n        require(penrose.swappers(swapper), \"SGL: Invalid swapper\");\n\n        // Let this fail first to save gas:\n        uint256 supplyShare = yieldBox.toShare(assetId, supplyAmount, true);\n        if (supplyShare > 0) {\n            yieldBox.transfer(from, address(swapper), assetId, supplyShare);\n        }\n\n        uint256 borrowShare;\n        (, borrowShare) = _borrow(from, address(swapper), borrowAmount);\n\n        ISwapper.SwapData memory swapData = swapper.buildSwapData(\n            assetId,\n            collateralId,\n            0,\n            supplyShare + borrowShare,\n            true,\n            true\n        );\n\n        uint256 collateralShare;\n        (amountOut, collateralShare) = swapper.swap(\n            swapData,\n            minAmountOut,\n            from,\n            dexData\n        );\n        require(amountOut >= minAmountOut, \"SGL: not enough\");\n\n        _allowedBorrow(from, collateralShare);\n        _addCollateral(from, from, false, 0, collateralShare);\n    }\n\n    /// @notice Lever down: Sell collateral to repay debt; excess goes to YB\n    /// @param from The user who sells\n    /// @param share Collateral YieldBox-shares to sell\n    /// @param minAmountOut Mininal proceeds required for the sale\n    /// @param swapper Swapper to execute the sale\n    /// @param dexData Additional data to pass to the swapper\n    /// @return amountOut Actual asset amount received in the sale\n    function sellCollateral(\n        address from,\n        uint256 share,\n        uint256 minAmountOut,\n        ISwapper swapper,\n        bytes calldata dexData\n    ) external notPaused solvent(from) returns (uint256 amountOut) {\n        require(penrose.swappers(swapper), \"SGL: Invalid swapper\");\n\n        _allowedBorrow(from, share);\n        _removeCollateral(from, address(swapper), share);\n        ISwapper.SwapData memory swapData = swapper.buildSwapData(\n            collateralId,\n            assetId,\n            0,\n            share,\n            true,\n            true\n        );\n        uint256 shareOut;\n        (amountOut, shareOut) = swapper.swap(\n            swapData,\n            minAmountOut,\n            from,\n            dexData\n        );\n        // As long as the ratio is correct, we trust `amountOut` resp.\n        // `shareOut`, because all money received by the swapper gets used up\n        // one way or another, or the transaction will revert.\n        require(amountOut >= minAmountOut, \"SGL: not enough\");\n        uint256 partOwed = userBorrowPart[from];\n        uint256 amountOwed = totalBorrow.toElastic(partOwed, true);\n        uint256 shareOwed = yieldBox.toShare(assetId, amountOwed, true);\n        if (shareOwed <= shareOut) {\n            _repay(from, from, partOwed);\n        } else {\n            //repay as much as we can\n            uint256 partOut = totalBorrow.toBase(amountOut, false);\n            _repay(from, from, partOut);\n        }\n    }\n\n    function transfer(\n        address to,\n        uint256 amount\n    ) public override returns (bool) {}\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public override returns (bool) {}\n\n    // ************************* //\n    // *** OWNER FUNCTIONS ***** //\n    // ************************* //\n\n    /// @notice Transfers fees to penrose\n    function refreshPenroseFees(\n        address\n    ) external onlyOwner notPaused returns (uint256 feeShares) {\n        uint256 balance = asset.balanceOf(address(this));\n        totalFees += balance;\n        feeShares = yieldBox.toShare(assetId, totalFees, false);\n\n        if (totalFees > 0) {\n            asset.approve(address(yieldBox), totalFees);\n\n            yieldBox.depositAsset(\n                assetId,\n                address(this),\n                msg.sender,\n                totalFees,\n                0\n            );\n\n            totalFees = 0;\n        }\n    }\n\n    /// @notice sets BigBang specific configuration\n    /// @dev values are updated only if > 0 or not address(0)\n    function setBigBangConfig(\n        uint256 _minDebtRate,\n        uint256 _maxDebtRate,\n        uint256 _debtRateAgainstEthMarket,\n        uint256 _liquidationMultiplier\n    ) external onlyOwner {\n        _isEthMarket = collateralId == penrose.wethAssetId();\n\n        if (!_isEthMarket) {\n            if (_minDebtRate > 0) {\n                require(_minDebtRate < maxDebtRate, \"BigBang: not valid\");\n                emit MinDebtRateUpdated(minDebtRate, _minDebtRate);\n                minDebtRate = _minDebtRate;\n            }\n\n            if (_maxDebtRate > 0) {\n                require(_maxDebtRate > minDebtRate, \"BigBang: not valid\");\n                emit MaxDebtRateUpdated(maxDebtRate, _maxDebtRate);\n                maxDebtRate = _maxDebtRate;\n            }\n\n            if (_debtRateAgainstEthMarket > 0) {\n                emit DebtRateAgainstEthUpdated(\n                    debtRateAgainstEthMarket,\n                    _debtRateAgainstEthMarket\n                );\n                debtRateAgainstEthMarket = _debtRateAgainstEthMarket;\n            }\n\n            if (_liquidationMultiplier > 0) {\n                require(\n                    _liquidationMultiplier < FEE_PRECISION,\n                    \"BigBang: not valid\"\n                );\n                emit LiquidationMultiplierUpdated(\n                    liquidationMultiplier,\n                    _liquidationMultiplier\n                );\n                liquidationMultiplier = _liquidationMultiplier;\n            }\n        }\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _accrue() internal override {\n        IBigBang.AccrueInfo memory _accrueInfo = accrueInfo;\n        // Number of seconds since accrue was called\n        uint256 elapsedTime = block.timestamp - _accrueInfo.lastAccrued;\n        if (elapsedTime == 0) {\n            return;\n        }\n        //update debt rate\n        uint256 annumDebtRate = getDebtRate();\n        _accrueInfo.debtRate = uint64(annumDebtRate / 31536000); //per second\n\n        _accrueInfo.lastAccrued = uint64(block.timestamp);\n\n        Rebase memory _totalBorrow = totalBorrow;\n\n        uint256 extraAmount = 0;\n\n        // Calculate fees\n        extraAmount =\n            (uint256(_totalBorrow.elastic) *\n                _accrueInfo.debtRate *\n                elapsedTime) /\n            1e18;\n        _totalBorrow.elastic += uint128(extraAmount);\n\n        totalBorrow = _totalBorrow;\n        accrueInfo = _accrueInfo;\n\n        emit LogAccrue(extraAmount, _accrueInfo.debtRate);\n    }\n\n    function _addCollateral(\n        address from,\n        address to,\n        bool skim,\n        uint256 amount,\n        uint256 share\n    ) internal {\n        if (share == 0) {\n            share = yieldBox.toShare(collateralId, amount, false);\n        }\n        userCollateralShare[to] += share;\n        uint256 oldTotalCollateralShare = totalCollateralShare;\n        totalCollateralShare = oldTotalCollateralShare + share;\n        _addTokens(from, collateralId, share, oldTotalCollateralShare, skim);\n        emit LogAddCollateral(skim ? address(yieldBox) : from, to, share);\n    }\n\n    function _liquidateUser(\n        address user,\n        uint256 maxBorrowPart,\n        ISwapper swapper,\n        uint256 _exchangeRate,\n        bytes calldata _dexData\n    ) private {\n        if (_isSolvent(user, _exchangeRate)) return;\n\n        (\n            uint256 startTVLInAsset,\n            uint256 maxTVLInAsset\n        ) = _computeMaxAndMinLTVInAsset(\n                userCollateralShare[user],\n                _exchangeRate\n            );\n        uint256 callerReward = _getCallerReward(\n            userBorrowPart[user],\n            startTVLInAsset,\n            maxTVLInAsset\n        );\n\n        (\n            uint256 borrowAmount,\n            uint256 borrowPart,\n            uint256 collateralShare\n        ) = _updateBorrowAndCollateralShare(user, maxBorrowPart, _exchangeRate);\n        emit LogRemoveCollateral(user, address(swapper), collateralShare);\n        emit LogRepay(address(swapper), user, borrowAmount, borrowPart);\n\n        uint256 borrowShare = yieldBox.toShare(assetId, borrowAmount, true);\n\n        // Closed liquidation using a pre-approved swapper\n        require(penrose.swappers(swapper), \"BigBang: Invalid swapper\");\n\n        // Swaps the users collateral for the borrowed asset\n        yieldBox.transfer(\n            address(this),\n            address(swapper),\n            collateralId,\n            collateralShare\n        );\n\n        uint256 minAssetMount = 0;\n        if (_dexData.length > 0) {\n            minAssetMount = abi.decode(_dexData, (uint256));\n        }\n\n        uint256 balanceBefore = yieldBox.balanceOf(address(this), assetId);\n\n        ISwapper.SwapData memory swapData = swapper.buildSwapData(\n            collateralId,\n            assetId,\n            0,\n            collateralShare,\n            true,\n            true\n        );\n        swapper.swap(swapData, minAssetMount, address(this), \"\");\n        uint256 balanceAfter = yieldBox.balanceOf(address(this), assetId);\n\n        uint256 returnedShare = balanceAfter - balanceBefore;\n        (uint256 feeShare, uint256 callerShare) = _extractLiquidationFees(\n            returnedShare,\n            borrowShare,\n            callerReward\n        );\n        address[] memory _users = new address[](1);\n        _users[0] = user;\n        emit Liquidated(\n            msg.sender,\n            _users,\n            callerShare,\n            feeShare,\n            borrowAmount,\n            collateralShare\n        );\n    }\n\n    function _extractLiquidationFees(\n        uint256 returnedShare,\n        uint256 borrowShare,\n        uint256 callerReward\n    ) private returns (uint256 feeShare, uint256 callerShare) {\n        uint256 extraShare = returnedShare - borrowShare;\n        feeShare = (extraShare * protocolFee) / FEE_PRECISION; // x% of profit goes to fee.\n        callerShare = (extraShare * callerReward) / FEE_PRECISION; //  y%  of profit goes to caller.\n\n        yieldBox.transfer(address(this), penrose.feeTo(), assetId, feeShare);\n        yieldBox.transfer(address(this), msg.sender, assetId, callerShare);\n    }\n\n    /// @notice Handles the liquidation of users' balances, once the users' amount of collateral is too low.\n    /// @dev Closed liquidations Only, 90% of extra shares goes to caller and 10% to protocol\n    /// @param users An array of user addresses.\n    /// @param maxBorrowParts A one-to-one mapping to `users`, contains maximum (partial) borrow amounts (to liquidate) of the respective user.\n    /// @param swapper Contract address of the `MultiSwapper` implementation. See `setSwapper`.\n    /// @param swapData Swap necessar data\n    function _closedLiquidation(\n        address[] calldata users,\n        uint256[] calldata maxBorrowParts,\n        ISwapper swapper,\n        uint256 _exchangeRate,\n        bytes calldata swapData\n    ) private {\n        uint256 liquidatedCount = 0;\n        for (uint256 i = 0; i < users.length; i++) {\n            address user = users[i];\n            if (!_isSolvent(user, _exchangeRate)) {\n                liquidatedCount++;\n                _liquidateUser(\n                    user,\n                    maxBorrowParts[i],\n                    swapper,\n                    _exchangeRate,\n                    swapData\n                );\n            }\n        }\n\n        require(liquidatedCount > 0, \"SGL: no users found\");\n    }\n\n    /// @dev Helper function to move tokens.\n    /// @param from Account to debit tokens from, in `yieldBox`.\n    /// @param _tokenId The ERC-20 token asset ID in yieldBox.\n    /// @param share The amount in shares to add.\n    /// @param total Grand total amount to deduct from this contract's balance. Only applicable if `skim` is True.\n    /// Only used for accounting checks.\n    /// @param skim If True, only does a balance check on this contract.\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\n    function _addTokens(\n        address from,\n        uint256 _tokenId,\n        uint256 share,\n        uint256 total,\n        bool skim\n    ) internal {\n        if (skim) {\n            require(\n                share <= yieldBox.balanceOf(address(this), _tokenId) - total,\n                \"BigBang: too much\"\n            );\n        } else {\n            yieldBox.transfer(from, address(this), _tokenId, share);\n        }\n    }\n\n    /// @dev Concrete implementation of `removeCollateral`.\n    function _removeCollateral(\n        address from,\n        address to,\n        uint256 share\n    ) internal {\n        userCollateralShare[from] -= share;\n        totalCollateralShare -= share;\n        emit LogRemoveCollateral(from, to, share);\n        yieldBox.transfer(address(this), to, collateralId, share);\n    }\n\n    /// @dev Concrete implementation of `repay`.\n    function _repay(\n        address from,\n        address to,\n        uint256 part\n    ) internal returns (uint256 amount) {\n        (totalBorrow, amount) = totalBorrow.sub(part, true);\n\n        userBorrowPart[to] -= part;\n\n        uint256 toWithdraw = (amount - part); //acrrued\n        uint256 toBurn = amount - toWithdraw;\n        yieldBox.withdraw(assetId, from, address(this), amount, 0);\n        //burn USDO\n        if (toBurn > 0) {\n            IUSDOBase(address(asset)).burn(address(this), toBurn);\n        }\n\n        emit LogRepay(from, to, amount, part);\n    }\n\n    /// @dev Concrete implementation of `borrow`.\n    function _borrow(\n        address from,\n        address to,\n        uint256 amount\n    ) internal returns (uint256 part, uint256 share) {\n        uint256 feeAmount = (amount * borrowOpeningFee) / FEE_PRECISION; // A flat % fee is charged for any borrow\n\n        (totalBorrow, part) = totalBorrow.add(amount + feeAmount, true);\n        require(\n            totalBorrowCap == 0 || totalBorrow.elastic <= totalBorrowCap,\n            \"BigBang: borrow cap reached\"\n        );\n\n        userBorrowPart[from] += part;\n\n        //mint USDO\n        IUSDOBase(address(asset)).mint(address(this), amount);\n\n        //deposit borrowed amount to user\n        asset.approve(address(yieldBox), amount);\n        yieldBox.depositAsset(assetId, address(this), to, amount, 0);\n\n        share = yieldBox.toShare(assetId, amount, false);\n\n        emit LogBorrow(from, to, amount, feeAmount, part);\n    }\n\n    function _updateBorrowAndCollateralShare(\n        address user,\n        uint256 maxBorrowPart,\n        uint256 _exchangeRate\n    )\n        private\n        returns (\n            uint256 borrowAmount,\n            uint256 borrowPart,\n            uint256 collateralShare\n        )\n    {\n        uint256 collateralPartInAsset = (yieldBox.toAmount(\n            collateralId,\n            userCollateralShare[user],\n            false\n        ) * EXCHANGE_RATE_PRECISION) / _exchangeRate;\n\n        uint256 borrowAssetDecimals = asset.safeDecimals();\n        uint256 collateralDecimals = collateral.safeDecimals();\n\n        uint256 availableBorrowPart = computeClosingFactor(\n            userBorrowPart[user],\n            collateralPartInAsset,\n            borrowAssetDecimals,\n            collateralDecimals,\n            FEE_PRECISION_DECIMALS\n        );\n        borrowPart = maxBorrowPart > availableBorrowPart\n            ? availableBorrowPart\n            : maxBorrowPart;\n\n        if (borrowPart > userBorrowPart[user]) {\n            borrowPart = userBorrowPart[user];\n        }\n\n        userBorrowPart[user] = userBorrowPart[user] - borrowPart;\n\n        borrowAmount = totalBorrow.toElastic(borrowPart, false);\n        uint256 amountWithBonus = borrowAmount +\n            (borrowAmount * liquidationMultiplier) /\n            FEE_PRECISION;\n        collateralShare = yieldBox.toShare(\n            collateralId,\n            (amountWithBonus * _exchangeRate) / EXCHANGE_RATE_PRECISION,\n            false\n        );\n        if (collateralShare > userCollateralShare[user]) {\n            collateralShare = userCollateralShare[user];\n        }\n        userCollateralShare[user] -= collateralShare;\n        require(borrowAmount != 0, \"SGL: solvent\");\n\n        totalBorrow.elastic -= uint128(borrowAmount);\n        totalBorrow.base -= uint128(borrowPart);\n    }\n}"
    },
    {
      "filename": "contracts/markets/bigBang/BigBang.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\n\nimport \"tapioca-periph/contracts/interfaces/IBigBang.sol\";\nimport \"tapioca-periph/contracts/interfaces/ISendFrom.sol\";\nimport \"tapioca-periph/contracts/interfaces/ISwapper.sol\";\nimport {IUSDOBase} from \"tapioca-periph/contracts/interfaces/IUSDO.sol\";\n\nimport \"../Market.sol\";\n\n// solhint-disable max-line-length\n/*\n\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\n\n*/\n\n/// @title BigBang market\n/// @notice Adaptation of the Singularity contract\n/// @dev owner of the contract is Penrose\n///     - the borrow action performs a mint on USDO\n///     - the repay action performs a burn on USDO\n///     - interest rate is not fixed, but dynamic based on the main BigBang market, minDebtRate, maxDebtRate and debtRateAgainstEthMarket\n///         - BigBang markets can either be main or secondary markets; the main market is set on Penrose and has a fixed rate\n///         - BigBang secondary markets has a dynamic interest rate which is starts from `minDebtRate` to `maxDebtRate`\n///             - if current debt is over _maxDebtPoint = (_ethMarketTotalDebt * debtRateAgainstEthMarket) / 1e18, the interest rate is automatically `maxDebtRate`\n///         - simulation: https://dotnetfiddle.net/cuKVpf\ncontract BigBang is BoringOwnable, Market {\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    mapping(address => mapping(address => bool)) public operators;\n\n    IBigBang.AccrueInfo public accrueInfo;\n\n    uint256 public totalFees;\n\n    bool private _isEthMarket;\n    uint256 public maxDebtRate;\n    uint256 public minDebtRate;\n    uint256 public debtRateAgainstEthMarket;\n    uint256 public debtStartPoint;\n    uint256 private constant DEBT_PRECISION = 1e18;\n\n    // ************** //\n    // *** EVENTS *** //\n    // ************** //\n    /// @notice event emitted when accrue is called\n    event LogAccrue(uint256 accruedAmount, uint64 rate);\n    /// @notice event emitted when collateral is add"
    }
  ]
}