{
  "Title": "[M-08] `reLPContract.reLP()` is susceptible to sandwich attack due to user control over `bond()`",
  "Content": "\n<https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/core/RdpxV2Core.sol#L873> \n\n<https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/core/RdpxV2Core.sol#L930>\n\n`RdpxV2Core.bond()` calls `reLPContract.reLP()` at the end of the bonding to adjust the LP for the rDPX/ETH pool and swap ETH for rDPX.\nWithin `reLPContract.reLP()`, it first calls `removeLiquidity()` to remove liquidity (rDPX and ETH), followed by `swapExactTokensForTokens()` and `addLiquidity()`.\n\nHowever, the issue is that an attacker has control over `RdpxV2Core.bond()` and can use it to indirectly call `reLPContract.reLP()`. That means the attacker can basically frontrunned/backrunned `reLP()` without a mempool. It also reduces the attack cost as attacker does not pay high gas to frontrun it.\n\nOne may argue that the slippage protection is in place, but that only makes it less profitable and would not help in this case because the attacker is able to increase the trade size of the UniswapV2 transactions. That is because the attacker can adjust the bonding amount to increase the amount of liquidity removed by `reLP()` (and also swap/add liquidity), allowing the attacker to craft a profitable sandwich attack.\n\nIt is not recommended to allow users to have indirect control over the UniswapV2 transaction in `reLPContract`.\n\n<https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/core/RdpxV2Core.sol#L873>\n\n```Solidity\n  function bond(\n    uint256 _amount,\n    uint256 rdpxBondId,\n    address _to\n  ) public returns (uint256 receiptTokenAmount) {\n\n    ...\n    //@audit an attacker can indirectly trigger this to perform a large trade and sandwich attack it\n    // reLP\n    if (isReLPActive) IReLP(addresses.reLPContract).reLP(_amount);\n\n```\n\n### Impact\n\nAn attacker can steal from `rdpxV2Core` by crafting an profitable sandwich attack on `bond()`.\n\n### Proof of Concept\n\nAn attacker can perform a sandwich attack as follows:\n\n1.  Perform a flash loan to borrow ETH.\n2.  Use the borrowed ETH to perform a ETH-to-rDPX swap on the UniswapV2 rDPX/ETH pool. This is to increase the price of rDPX before `reLPContract.reLP()`.\n3.  Call `rdpxV2Core.bond()` to indirectly trigger `reLPContract.reLP()`, which will `removeLiquidity()`, causing it receive lesser rDPX due to the price manipulation.\n4.  `reLPContract.reLP()` will then `swapExactTokensForTokens()` to swap ETH-to-rDPX using ETH from removed liquidity. This further increase price of rDPX.\n5.  `addLiquidity()` is then called by `reLPContract.reLP()` to return part of the liquidity into the pool.\n6.  Attacker now swap rDPX back to ETH to realize profit from the attack and pay back the flash loan.\n\n### Recommended Mitigation Steps\n\nRemove `reLPContract.ReLP()` from `bond()` and trigger separately to prevent user access to it.\n\n**[psytama (Dopex) confirmed and commented](https://github.com/code-423n4/2023-08-dopex-findings/issues/976#issuecomment-1733781720):**\n > The re-LP contract and process will be modified.\n\n**[Alex the Entreprenerd (Judge) commented](https://github.com/code-423n4/2023-08-dopex-findings/issues/976#issuecomment-1759437289):**\n > I would have liked to see a Coded POC.\n> \n> Removing Liquidity is not as simple to exploit as swap.\n\n**[Alex the Entreprenerd (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-08-dopex-findings/issues/976#issuecomment-1763994630):**\n > UniV2 Code is as follows:<br>\n> https://github.com/Uniswap/v2-core/blob/ee547b17853e71ed4e0101ccfd52e70d5acded58/contracts/UniswapV2Pair.sol#L144-L155\n> \n> Offering Pro Rata Distribution\n> \n> In lack of a coded POC\n> \n> The maximum skimmable is the delta excess value in the UniV2 Reserves vs the value that the caller has to pay to imbalance them.\n> \n> The cost of imbalancing and the nature of it + the fact that other people would have ownership of the LP token means that profitability is dependent on those factors, which IMO have not been properly factored in.\n> \n> In the presence of a Coded POC as part of the original submission, I would have considered a High Severity.\n> \n> In lack of it, Medium Severity for Skimming the excess value seems more appropriate.\n\n**[peakbolt (Warden) commented](https://github.com/code-423n4/2023-08-dopex-findings/issues/976#issuecomment-1774193810):**\n > Hi @Alex the Entreprenerd, \n> \n> I understand your judgement as you have raised valid points, though the circumstances here are different (explained below), which make it more profitable as compared to a typical sandwich attack on removeLiquidity().\n> \n> **1. Coded POC**  \n> Below is the printout from the POC, which shows it is more than just skimming of excess value (profit of 42.79 ETH using 1000 ETH flash loan vs minimal cost in point 2 below). \n> For your reference, I have uploaded it [here](https://gist.github.com/peakbolt/f2d9a44714b1a2a693debea737128696).\n> \n> ```\n>  --------------  setup copied from testReLpContract() ------------\n>   -------------- 1. attacker perform first swap to get rDPX with flashloaned WETH ------------\n>   attacker weth balance (initial) : 10000000000000000000000 [from flashloan]\n>   attacker rdpx balance (initial) : 0 \n>   attacker weth balance (after 1st swap): 0 \n>   attacker rdpx balance (after 1st swap): 33799781371440793668463\n>   rDPX price in WETH (after 1st swap): 435429977934145959 \n>   -------------- 2. Attacker triggers bond() that indirectly perform removeLiquidity() in reLPContract.reLP() ------------\n>   rDPX price in WETH (after bond): 440827346696573406 \n>   -------------- 3. Attacker performs 2nd swap rDPX back to WETH and profit ------------\n>   attacker weth balance (after 2nd swap): 10042795347724107931994 \n>   attacker rdpx balance (after 2nd swap): 0\n>   attacker profit in WETH (after repaying flashloan): 42795347724107931994\n> ```\n> \n> **2. Cost of imbalancing** \n> There are 3 main attack cost implicitly mentioned in the original submission. Based on the POC, they are ~11 ETH, minimal as compared to the 42.79 ETH profit.\n> - Flash loan cost - as mentioned, use of flash loan for WETH in POC. If we take Aave as a reference, flash loan fee is 0.09% of flash loan amount, which will be 9 ETH based on POC, lower than the 42.79 ETH profit.\n> - Gas cost - as mentioned this attack does not involve mempool to frontrun, so attacker does not need to pay high gas fee.\n> - Bonding cost - obviously rDPX and ETH are required to trigger bond(), this is negligible as it can be recouped by redeeming/selling the bonded dpxETH. If we take Aave ETH borrow cost at a conservative 2% APY for 1e20 dpxETH bonding amount, that will be 2 ETH, which is even lower than flash loan fee.\n> \n> **3. Control over amount of LP tokens to remove** \n> As mentioned in my submission, in this case, the attacker has control of the trade size of removeLiquidity() via bond() amount. By increasing the bond amount, which increase amount of LP tokens to remove, the attacker can increase the profitability of the attack.\n> \n> **4. During the bootstrap phase, majority of LP holders are dopex funds/partners**\n> The docs stated that during bootstrap phase, Dopex Treasury funds and Partners will partake in the dpxETH bonding first to ensure sufficient dpxETH in circulation. In addition, the backing reserve will be used to seed the liquidity for the Uniswap V2 Pool. So during that period, there are little other LP holders. I did not state this in submission as it is already in the docs.<br>\n> https://dopex.notion.site/rDPX-V2-RI-b45b5b402af54bcab758d62fb7c69cb4 (see Launch Details)\n\n**[Alex the Entreprenerd (Judge) commented](https://github.com/code-423n4/2023-08-dopex-findings/issues/976#issuecomment-1778702756):**\n > @peakbolt \n> - What's the value in Pool?\n> - Can you repeat the attack more than once?\n> - What's the profit / value drained per iteration?\n> - What's the threshold of TVL before the attack is profitable given 30BPS swap fees?\n\n**[peakbolt (warden) commented](https://github.com/code-423n4/2023-08-dopex-findings/issues/976#issuecomment-1779856524):**\n > Hi @Alex the Entreprenerd, \n> \n> I have adjusted the POC to a liquidity pool value of ~800 ETH with flashloan attack amount of 15e20 and ran it to provide the answers below. Used 800ETH TVL as the assumed amount to bootstrap, judging by the lower range of TVL in the top uniswap pools. Note that the initial TVL value in the test suite is actually 4000 ETH.<br>\n> See link for updated poc: https://gist.github.com/peakbolt/a8fdbe18759ac2e25d15716af6faa76b.\n> \n> 1. Yes, it is possible to repeat the attack more than once by bonding multiple times to trigger consecutive removal of liquidity after imbalancing the pool. \n> - Printout for the updated poc below, shows an attack with 5 `bond()` iterations. \n> - Beyond 5 `bond()` will hit a revert as there will be insufficient WETH collateral in `PerpetualAltanticVault` for purchase of put options (during bonding). \n> - The attacker can workaround that by waiting for users to deposit more WETH into PerpetualAltanticVault before carrying out the attack.\n> \n> ```\n>   Total Liquidity (in WETH) for RDPX/WETH UniswapV2 Pool (before attack): 804803971980485176292 \n>   attacker weth balance (initial) : 1500000000000000000000 [from flashloan]\n>   attacker rdpx balance (initial) : 0\n>   bond() Iteration 1\n>   bond() Iteration 2\n>   bond() Iteration 3\n>   bond() Iteration 4\n>   bond() Iteration 5\n>   attacker profit in WETH (after repaying flashloan): 22067892940781745930\n> ```\n> \n> 2. Based on the poc (~800ETH TVL), the attack with 5 iterations will gain ~22 ETH (inclusive of swap fees as shown in POC using Arb mainnet fork). \n> - For 800 ETH TVL, the flash loan cost for attack is lower at 1.35 ETH (0.09% of 15e20 ETH)\n> - After flash loan cost profit will be 22-1.35 = 20.65 ETH\n> - That works out to be 20.65/800 ETH = ~2.58% profit/TVL. \n> - Per iteration will be 0.516% profit/TVL.\n> \n> - For bonding, it will require upfront capital of 1e20 WETH/iteration to bond the dpxETH, which can be recouped by selling the dpxETH later on. To keep it simple, I have omitted the loan cost for this and assume attacker has the capital. Otherwise, attacker can get a loan and reduces attack profit. \n> \n> 3. As for the TVL threshold, I have tried lower TVL at 400 ETH and attack is still viable, with a profit 11.32 ETH (12.04 ETH - flash loan cost of 0.72 ETH). Did not try lower as I assume protocol will not bootstrap lower than that. Though profit is still possible to a certain extent, but likely insignificant.\n\n**[Alex the Entreprenerd (Judge) commented](https://github.com/code-423n4/2023-08-dopex-findings/issues/976#issuecomment-1781331660):**\n > The finding shows that the attacker has access to the \"button\", this allows them to cause the contract to auto-rebalance.\n> \n> The auto-rebalancing is part of the \"button\" that attack can trigger.\n> \n> Initially I believed that the attacker only had control over the amounts from remove liquidity, which by definition will give pro-rata of the tokens.\n> \n> The pro-rata can be manipulated based on attacking the `X * Y = k` uniswap invariant to have the contract take a loss that is relative to the new spot balance, vs the fair LP pricing.\n> \n> That was Medium Severity imo and most Judges would agree with me, however, after talking with 2 more judges, we agreed that the code also impacts the rebalancing, done via `swapExactTokensForTokens` meaning that the attacker is not only causing the \"skimmin\" of the LP token value, they are able to influence the swap via `swapExactTokensForTokens`.\n> \n> However, upon further inspection, that is protected by the Oracle Pricing, which could be argued to protect against it.\n> \n> That said, the default slippage protection is 50 BPS, which is above the 30BPS avg cost of a swap on UnIV2, the oracles also can have drift which in general should make the cost of backrunning sustainable.\n> \n> The profit of the attack would come due to:\n> -> Swap taking a Loss -> generally seen as Med but since it's repeatable High is acceptable\n> -> Ability to trigger the Withdrawal at any time, which causes the Pro-Rata received `X * Y` being less valuable than the fair valuation of the LP Token.\n> \n> This means that under most circumnstances, a risk free trade is available for attacker at the detriment of the `reLP` contract, leading me to believe High Severity to be appropriate.\n> \n> However, given the circumnstances, and given the original submission did not contain the POC, also considering that the POC shows an impact of 2% of funds, I'm maintaining Medium Severity due to the POC not being present in the original submission.\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-08-dopex",
  "Code": [
    {
      "filename": "contracts/core/RdpxV2Core.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// Contracts\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { ERC721Holder } from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport { ContractWhitelist } from \"../helper/ContractWhitelist.sol\";\nimport { Pausable } from \"../helper/Pausable.sol\";\nimport { RdpxV2Bond } from \"./RdpxV2Bond.sol\";\n\n// Interfaces\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\nimport { IUniswapV2Router } from \"../uniswap_V2/IUniswapV2Router.sol\";\nimport { IStableSwap } from \"../interfaces/IStableSwap.sol\";\nimport { IRdpxDecayingBonds } from \"../decaying-bonds/IRdpxDecayingBonds.sol\";\nimport { IDpxEthToken } from \"../dpxETH/IDpxEthToken.sol\";\nimport { IPerpetualAtlanticVault } from \"../perp-vault/IPerpetualAtlanticVault.sol\";\nimport { IRdpxEthOracle } from \"../interfaces/IRdpxEthOracle.sol\";\nimport { IDpxEthOracle } from \"../oracles/IDpxEthOracle.sol\";\nimport { IRdpxReserve } from \"../reserve/IRdpxReserve.sol\";\nimport { IRdpxV2Core } from \"./IRdpxV2Core.sol\";\nimport { IRdpxV2ReceiptToken } from \"../interfaces/IRdpxV2ReceiptToken.sol\";\nimport { IReLP } from \"../interfaces/IReLP.sol\";\n\n// Libraries\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/// @title Rdpx V2 Core contract\n/// @author Dopex\n/// @notice The Rdpx V2 Corecontracts handles the bonding mechanism and peg of DpxEth\ncontract RdpxV2Core is\n  IRdpxV2Core,\n  AccessControl,\n  ContractWhitelist,\n  ERC721Holder,\n  Pausable\n{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using SafeERC20 for IERC20WithBurn;\n  using SafeERC20 for IDpxEthToken;\n\n  // ================================ STATE VARIABLES ================================ //\n\n  /// @notice Addresses used by the contract\n  Addresses public addresses;\n\n  /// @notice The pricing oracle addresses\n  PricingOracleAddresses public pricingOracleAddresses;\n\n  /* Inital tokens in the reserve\n     index0: ZERO address\n     index1: weth\n     index2: rdpx\n     index3: dpxEth\n     index4: crv\n  */\n\n  /// @notice Array containg the reserve assets\n  ReserveAsset[] public reserveAsset;\n\n  /// @notice Array that contains the addresses of the AMO\n  address[] public amoAddresses;\n\n  /// @notice Token address that dpxEth is pegged to\n  address public weth;\n\n  /// @notice Array that contains the symbol of the reserve tokens\n  string[] public reserveTokens;\n\n  /// @notice Mapping that contains the index for a specific token in the reserves\n  mapping(string => uint256) public reservesIndex;\n\n  /// @dev Bond id => Bond\n  mapping(uint256 => Bond) public bonds;\n\n  /// @dev Option id => owned or not (boolean)\n  mapping(uint256 => bool) public optionsOwned;\n\n  /// @dev Funding paid for epoch\n  mapping(uint256 => bool) public fundingPaidFor;\n\n  /// @notice Precision used for prices, percentages and other calculations\n  uint256 public constant DEFAULT_PRECISION = 1e8;\n\n  /// @notice rDPX Ratio required when bonding\n  uint256 public constant RDPX_RATIO_PERCENTAGE = 25 * DEFAULT_PRECISION;\n\n  /// @notice ETH Ratio required when bonding\n  uint256 public constant ETH_RATIO_PERCENTAGE = 75 * DEFAULT_PRECISION;\n\n  /// @notice The % of rdpx to burn while bonding\n  uint256 public rdpxBurnPercentage = 50 * DEFAULT_PRECISION;\n\n  /// @notice The % of rdpx sent to fee distributor while bonding\n  uint256 public rdpxFeePercentage = 50 * DEFAULT_PRECISION;\n\n  /// @notice The slippage tolernce in swaps in 1e8 precision\n  uint256 public slippageTolerance = 5e5; // 0.5%\n\n  /// @notice Liquidity slippage tolerance\n  uint256 public liquiditySlippageTolerance = 5e5; // 0.5%\n\n  /// @notice Bond maturity\n  uint256 public bondMaturity;\n\n  /// @notice rDPX LP bond discount factor\n  uint256 public bondDiscountFactor;\n\n  /// @notice Total weth delegated\n  uint256 public totalWethDelegated;\n\n  /// @notice Whether reLP is active or not\n  bool public isReLPActive;\n\n  /// @notice Whether put options are requred\n  bool public putOptionsRequired;\n\n  /// @notice Delegates array\n  Delegate[] public delegates;\n\n  // ================================ CONSTRUCTOR ================================ //\n  constructor(address _weth) {\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    weth = _weth;\n\n    // add Zero asset to reserveAsset\n    ReserveAsset memory zeroAsset = ReserveAsset({\n      tokenAddress: address(0),\n      tokenBalance: 0,\n      tokenSymbol: \"ZERO\"\n    });\n    reserveAsset.push(zeroAsset);\n    putOptionsRequired = true;\n  }\n\n  // ================================ ADMIN FUNCTIONS ================================ //\n\n  /**\n   * @notice Pauses the vault for emergency cases\n   * @dev    Can only be called by the owner\n   **/\n  function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _pause();\n  }\n\n  /**\n   * @notice Unpauses the vault\n   * @dev    Can only be called by the owner\n   **/\n  function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _unpause();\n  }\n\n  /**\n   * @notice Transfers all funds to msg.sender\n   * @dev    Can only be called by the owner\n   * @param  tokens The list of erc20 tokens to withdraw\n   **/\n  function emergencyWithdraw(\n    address[] calldata tokens\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _whenPaused();\n    IERC20WithBurn token;\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      token = IERC20WithBurn(tokens[i]);\n      token.safeTransfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    emit LogEmergencyWithdraw(msg.sender, tokens);\n  }\n\n  /**\n   * @notice Sets the rdpx burn percentage\n   * @dev    Can only be called by admin\n   * @param  _rdpxBurnPercentage the burn percentage to set in 1e8 precision\n   **/\n  function setRdpxBurnPercentage(\n    uint256 _rdpxBurnPercentage\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_rdpxBurnPercentage > 0, 3);\n    rdpxBurnPercentage = _rdpxBurnPercentage;\n    emit LogSetRdpxBurnPercentage(_rdpxBurnPercentage);\n  }\n\n  /**\n   * @notice Sets the rdpx fee percentage\n   * @dev    Can only be called by admin\n   * @param  _rdpxFeePercentage the fee percentage to set in 1e8 precision\n   **/\n  function setRdpxFeePercentage(\n    uint256 _rdpxFeePercentage\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_rdpxFeePercentage > 0, 3);\n    rdpxFeePercentage = _rdpxFeePercentage;\n    emit LogSetRdpxFeePercentage(_rdpxFeePercentage);\n  }\n\n  /**\n   * @notice Sets whether reLP is true or false\n   * @dev    Can only be called by admin\n   * @param  _isReLPActive the value to set\n   */\n  function setIsreLP(bool _isReLPActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    isReLPActive = _isReLPActive;\n    emit LogSetIsReLPActive(_isReLPActive);\n  }\n\n  /**\n   * @notice Sets whether put options are required or not\n   * @dev    Can only be called by admin\n   * @param  _putOptionsRequired the value to set\n   */\n  function setPutOptionsRequired(\n    bool _putOptionsRequired\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    putOptionsRequired = _putOptionsRequired;\n    emit LogSetputOptionsRequired(_putOptionsRequired);\n  }\n\n  /**\n   * @notice Update the bond maturity\n   * @dev    Can only be called by admin\n   * @param  _bondMaturity bond maturity\n   **/\n  function setBondMaturity(\n    uint256 _bondMaturity\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_bondMaturity > 0, 3);\n    bondMaturity = _bondMaturity;\n    emit LogSetBondMaturity(_bondMaturity);\n  }\n\n  /**\n   * @notice Adds a asset to the reserves tokens\n   * @dev    Can only be called by admin\n   **/\n  function addAssetTotokenReserves(\n    address _asset,\n    string memory _assetSymbol\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    require(_asset != address(0), \"RdpxV2Core: asset cannot be 0 address\");\n\n    for (uint256 i = 1; i < reserveAsset.length; i++) {\n      require(\n        reserveAsset[i].tokenAddress != _asset,\n        \"RdpxV2Core: asset already exists\"\n      );\n    }\n\n    ReserveAsset memory asset = ReserveAsset({\n      tokenAddress: _asset,\n      tokenBalance: 0,\n      tokenSymbol: _assetSymbol\n    });\n    reserveAsset.push(asset);\n    reserveTokens.push(_assetSymbol);\n\n    reservesIndex[_assetSymbol] = reserveAsset.length - 1;\n\n    emit LogAssetAddedTotokenReserves(_asset, _assetSymbol);\n  }\n\n  /**\n   * @notice Removes a asset from the reserves tokens\n   * @dev    Can only be called by admin\n   **/\n  function removeAssetFromtokenReserves(\n    string memory _assetSymbol\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 index = reservesIndex[_assetSymbol];\n    _validate(index != 0, 18);\n\n    // remove the asset from the mapping\n    reservesIndex[_assetSymbol] = 0;\n\n    // add new index for the last element\n    reservesIndex[reserveTokens[reserveTokens.length - 1]] = index;\n\n    // update the index of reserveAsset with the last element\n    reserveAsset[index] = reserveAsset[reserveAsset.length - 1];\n\n    // remove the last element\n    reserveAsset.pop();\n    reserveTokens.pop();\n\n    emit LogAssetRemovedFromtokenReserves(_assetSymbol, index);\n  }\n\n  /**\n   * @notice Update contract addresses\n   * @dev    Can only be called by admin\n   * @param  _dopexAMMRouter dopex AMM router address\n   * @param  _dpxEthCurvePool DpxEth curve pool address\n   * @param  _rdpxDecayingBonds rdpx decaying bonds address\n   * @param  _perpetualAtlanticVault perpetual atlantic vault address\n   * @param  _perpetualAtlanticVaultLP perpetual atlantic vault LP address\n   * @param  _rdpxReserve rdpx reserve address\n   * @param  _rdpxV2ReceiptToken rdpxV2ReceiptToken contract address\n   * @param  _feeDistributor fee distributor address\n   **/\n  function setAddresses(\n    address _dopexAMMRouter,\n    address _dpxEthCurvePool,\n    address _rdpxDecayingBonds,\n    address _perpetualAtlanticVault,\n    address _perpetualAtlanticVaultLP,\n    address _rdpxReserve,\n    address _rdpxV2ReceiptToken,\n    address _feeDistributor,\n    address _reLPContract,\n    address _receiptTokenBonds\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_dopexAMMRouter != address(0), 17);\n    _validate(_dpxEthCurvePool != address(0), 17);\n    _validate(_rdpxDecayingBonds != address(0), 17);\n    _validate(_perpetualAtlanticVault != address(0), 17);\n    _validate(_perpetualAtlanticVaultLP != address(0), 17);\n    _validate(_rdpxReserve != address(0), 17);\n    _validate(_rdpxV2ReceiptToken != address(0), 17);\n    _validate(_feeDistributor != address(0), 17);\n    _validate(_reLPContract != address(0), 17);\n    _validate(_receiptTokenBonds != address(0), 17);\n\n    addresses = Addresses({\n      dopexAMMRouter: _dopexAMMRouter,\n      dpxEthCurvePool: _dpxEthCurvePool,\n      rdpxDecayingBonds: _rdpxDecayingBonds,\n      perpetualAtlanticVault: _perpetualAtlanticVault,\n      perpetualAtlanticVaultLP: _perpetualAtlanticVaultLP,\n      rdpxReserve: _rdpxReserve,\n      rdpxV2ReceiptToken: _rdpxV2ReceiptToken,\n      feeDistributor: _feeDistributor,\n      reLPContract: _reLPContract,\n      receiptTokenBonds: _receiptTokenBonds\n    });\n    IERC20WithBurn(weth).approve(\n      addresses.perpetualAtlanticVault,\n      type(uint256).max\n    );\n    IERC20WithBurn(weth).approve(addresses.dopexAMMRouter, type(uint256).max);\n    IERC20WithBurn(weth).approve(addresses.dpxEthCurvePool, type(uint256).max);\n    IERC20WithBurn(weth).approve(\n      addresses.rdpxV2ReceiptToken,\n      type(uint256).max\n    );\n    emit LogSetAddresses(addresses);\n  }\n\n  /**\n   * @notice Update token contract addresses\n   * @dev    Can only be called by admin\n   * @param  _rdpxPriceOracle rdpx price oracle address\n   * @param  _dpxEthPriceOracle DpxEth price oracle address\n   **/\n  function setPricingOracleAddresses(\n    address _rdpxPriceOracle,\n    address _dpxEthPriceOracle\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_rdpxPriceOracle != address(0), 17);\n    _validate(_dpxEthPriceOracle != address(0), 17);\n\n    pricingOracleAddresses = PricingOracleAddresses({\n      rdpxPriceOracle: _rdpxPriceOracle,\n      dpxEthPriceOracle: _dpxEthPriceOracle\n    });\n\n    emit LogSetPricingOracleAddresses(pricingOracleAddresses);\n  }\n\n  /**\n   * @notice Adds a AMO contract to the AMO address array\n   * @dev    Can only be called by admin\n   * @param  _addr the address to add to the AMO address array\n   */\n  function addAMOAddress(address _addr) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_addr != address(0), 17);\n    amoAddresses.push(_addr);\n  }\n\n  /**\n   * @notice Removes a AMO contract from the AMO address array\n   * @dev    Can only be called by admin\n   * @param  _index the index of the address to remove from the AMO address array\n   */\n  function removeAMOAddress(\n    uint256 _index\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_index < amoAddresses.length, 18);\n    amoAddresses[_index] = amoAddresses[amoAddresses.length - 1];\n    amoAddresses.pop();\n  }\n\n  /**\n   * @notice Approve a contract to spend a certain amount of tokens\n   * @dev    Can only be called by admin\n   * @param  _token the address of the token to approve\n   * @param  _spender the address of the contract to approve\n   * @param  _amount the amount to approve\n   */\n  function approveContractToSpend(\n    address _token,\n    address _spender,\n    uint256 _amount\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_token != address(0), 17);\n    _validate(_spender != address(0), 17);\n    _validate(_amount > 0, 17);\n    IERC20WithBurn(_token).approve(_spender, _amount);\n  }\n\n  /**\n   * @notice Adds a contract to the contract whitelist\n   * @dev    Can only be called by admin\n   * @param  _addr the address to add to the contract whitelist\n   **/\n  function addToContractWhitelist(\n    address _addr\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _addToContractWhitelist(_addr);\n  }\n\n  /**\n   * @notice Removes a contract from the contract whitelist\n   * @dev    Can only be called by admin\n   * @param  _addr the address to remove from the contract whitelist\n   **/\n  function removeFromContractWhitelist(\n    address _addr\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _removeFromContractWhitelist(_addr);\n  }\n\n  /**\n   * @notice Set the rDPX LP bond discount factor\n   * @dev    Can only be called by admin\n   * @param  _bondDiscountFactor the bond discount factor\n   **/\n  function setBondDiscount(\n    uint256 _bondDiscountFactor\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_bondDiscountFactor > 0, 3);\n    bondDiscountFactor = _bondDiscountFactor;\n\n    emit LogSetBondDiscountFactor(_bondDiscountFactor);\n  }\n\n  /**\n   * @notice Set the slippage tolerance\n   * @dev    Can only be called by admin\n   * @param  _slippageTolerance the slipage tolerance\n   **/\n  function setSlippageTolerance(\n    uint256 _slippageTolerance\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_slippageTolerance > 0, 3);\n    slippageTolerance = _slippageTolerance;\n\n    emit LogSetSlippageTolerance(_slippageTolerance);\n  }\n\n  // ================================ INTERNAL FUNCTIONS ================================ //\n\n  /**\n   * @notice Purchase rdpx put options\n   * @param _amount amount of rdpx to purchase\n   * @return premium amount of premium paid\n   */\n  function _purchaseOptions(\n    uint256 _amount\n  ) internal returns (uint256 premium) {\n    /**\n     * Purchase options and store ERC721 option id\n     * Note that the amount of options purchased is the amount of rDPX received\n     * from the user to sufficiently collateralize the underlying DpxEth stored in the bond\n     **/\n    uint256 optionId;\n\n    (premium, optionId) = IPerpetualAtlanticVault(\n      addresses.perpetualAtlanticVault\n    ).purchase(_amount, address(this));\n\n    optionsOwned[optionId] = true;\n    reserveAsset[reservesIndex[\"WETH\"]].tokenBalance -= premium;\n  }\n\n  /**\n   * @notice issue bonds\n   * @param  _to The address to send the bond to\n   * @param  _amount The bond amount\n   * @return bondId The bond id\n   **/\n  function _issueBond(\n    address _to,\n    uint256 _amount\n  ) internal returns (uint256 bondId) {\n    bondId = RdpxV2Bond(addresses.receiptTokenBonds).mint(_to);\n    bonds[bondId] = Bond({\n      amount: _amount,\n      maturity: block.timestamp + bondMaturity,\n      timestamp: block.timestamp\n    });\n  }\n\n  /**\n   * @notice Swaps _amount of token a to token b\n   * @param _amount amount to swap\n   * @param _ethToDpxEth whether to swap ETH to dpxETH or dpxETH to ETH\n   * @param validate whether to validate the swap\n   * @param minAmount minimum amount of token b to receive\n   * @return amountOut amount of token b received\n   */\n  function _curveSwap(\n    uint256 _amount,\n    bool _ethToDpxEth,\n    bool validate,\n    uint256 minAmount\n  ) internal returns (uint256 amountOut) {\n    IStableSwap dpxEthCurvePool = IStableSwap(addresses.dpxEthCurvePool);\n\n    // First compute a reverse swapping of dpxETH to ETH to compute the amount of ETH required\n    address coin0 = dpxEthCurvePool.coins(0);\n    (uint256 a, uint256 b) = coin0 == weth ? (0, 1) : (1, 0);\n\n    // validate the swap for peg functions\n    if (validate) {\n      uint256 ethBalance = IStableSwap(addresses.dpxEthCurvePool).balances(a);\n      uint256 dpxEthBalance = IStableSwap(addresses.dpxEthCurvePool).balances(\n        b\n      );\n      _ethToDpxEth\n        ? _validate(\n          ethBalance + _amount <= (ethBalance + dpxEthBalance) / 2,\n          14\n        )\n        : _validate(\n          dpxEthBalance + _amount <= (ethBalance + dpxEthBalance) / 2,\n          14\n        );\n    }\n\n    // calculate minimum amount out\n    uint256 minOut = _ethToDpxEth\n      ? (((_amount * getDpxEthPrice()) / 1e8) -\n        (((_amount * getDpxEthPrice()) * slippageTolerance) / 1e16))\n      : (((_amount * getEthPrice()) / 1e8) -\n        (((_amount * getEthPrice()) * slippageTolerance) / 1e16));\n\n    // Swap the tokens\n    amountOut = dpxEthCurvePool.exchange(\n      _ethToDpxEth ? int128(int256(a)) : int128(int256(b)),\n      _ethToDpxEth ? int128(int256(b)) : int128(int256(a)),\n      _amount,\n      minAmount > 0 ? minAmount : minOut\n    );\n  }\n\n  /**\n   * @notice Deposits ETH and dpxETH to the ReceiptToken contract\n   * @param  _to The address to send the bond to\n   * @param  _amount The amount of ETH to add liquidity with\n   * @return receiptTokenAmount The amount of receipt token received\n   **/\n  function _stake(\n    address _to,\n    uint256 _amount\n  ) internal returns (uint256 receiptTokenAmount) {\n    reserveAsset[reservesIndex[\"WETH\"]].tokenBalance -= _amount / 2;\n\n    IDpxEthToken(reserveAsset[reservesIndex[\"DPXETH\"]].tokenAddress).mint(\n      address(this),\n      _amount / 2\n    );\n\n    // deposit into the rdpxV2ReceiptToken contract\n    receiptTokenAmount = IRdpxV2ReceiptToken(addresses.rdpxV2ReceiptToken)\n      .deposit(_amount / 2);\n\n    // mint receipt token bonds\n    _issueBond(_to, receiptTokenAmount);\n  }\n\n  /**\n   * @notice Calculate the amounts received by delegate and delegatee after accounting for\n   *         delegate fee.\n   * @dev    Mint receipt tokens based on its respective share with a discount % in 1e8 precision.\n   *         The delegate fee is the percentage of the discount received by the delegatee\n   *         that is cut for them.\n   * @param  _wethRequired The wethRequired to bond\n   * @param  _rdpxRequired The rdpxRequired to bond\n   * @param  _amount The bond amount\n   * @param  _delegateFee The delegate fee\n   * @return amount1 The amount received by the delegate\n   * @return amount2 The amount received by the delegatee\n   **/\n  function _calculateAmounts(\n    uint256 _wethRequired,\n    uint256 _rdpxRequired,\n    uint256 _amount,\n    uint256 _delegateFee\n  ) internal view returns (uint256 amount1, uint256 amount2) {\n    // Commented below for better clarity\n    uint256 rdpxRequiredInWeth = (_rdpxRequired * getRdpxPrice()) / 1e8;\n\n    // amount required for delegatee\n    amount1 = ((rdpxRequiredInWeth * _amount) /\n      (rdpxRequiredInWeth + _wethRequired));\n\n    // account for delegate fee\n    amount1 = (amount1 * (100e8 - _delegateFee)) / 1e10;\n\n    amount2 = _amount - amount1;\n  }\n\n  /**\n   * @notice Transfers rdpx or burns the equivalent in rDPX Decaying bonds\n   * @param  _rdpxAmount The rdpx amount\n   * @param  _wethAmount The weth amount\n   * @param  _bondAmount The bond amount\n   * @param  _bondId The bond id of the rdpx decaying bond\n   **/\n  function _transfer(\n    uint256 _rdpxAmount,\n    uint256 _wethAmount,\n    uint256 _bondAmount,\n    uint256 _bondId\n  ) internal {\n    if (_bondId != 0) {\n      (, uint256 expiry, uint256 amount) = IRdpxDecayingBonds(\n        addresses.rdpxDecayingBonds\n      ).bonds(_bondId);\n\n      _validate(amount >= _rdpxAmount, 1);\n      _validate(expiry >= block.timestamp, 2);\n      _validate(\n        IRdpxDecayingBonds(addresses.rdpxDecayingBonds).ownerOf(_bondId) ==\n          msg.sender,\n        9\n      );\n\n      IRdpxDecayingBonds(addresses.rdpxDecayingBonds).decreaseAmount(\n        _bondId,\n        amount - _rdpxAmount\n      );\n\n      IRdpxReserve(addresses.rdpxReserve).withdraw(_rdpxAmount);\n\n      reserveAsset[reservesIndex[\"RDPX\"]].tokenBalance += _rdpxAmount;\n    } else {\n      // Transfer rDPX and ETH token from user\n      IERC20WithBurn(reserveAsset[reservesIndex[\"RDPX\"]].tokenAddress)\n        .safeTransferFrom(msg.sender, address(this), _rdpxAmount);\n\n      // burn the rdpx\n      IERC20WithBurn(reserveAsset[reservesIndex[\"RDPX\"]].tokenAddress).burn(\n        (_rdpxAmount * rdpxBurnPercentage) / 1e10\n      );\n\n      // transfer the rdpx to the fee distributor\n      IERC20WithBurn(reserveAsset[reservesIndex[\"RDPX\"]].tokenAddress)\n        .safeTransfer(\n          addresses.feeDistributor,\n          (_rdpxAmount * rdpxFeePercentage) / 1e10\n        );\n\n      // calculate extra rdpx to withdraw to compensate for discount\n      uint256 rdpxAmountInWeth = (_rdpxAmount * getRdpxPrice()) / 1e8;\n      uint256 discountReceivedInWeth = _bondAmount -\n        _wethAmount -\n        rdpxAmountInWeth;\n      uint256 extraRdpxToWithdraw = (discountReceivedInWeth * 1e8) /\n        getRdpxPrice();\n\n      // withdraw the rdpx\n      IRdpxReserve(addresses.rdpxReserve).withdraw(\n        _rdpxAmount + extraRdpxToWithdraw\n      );\n\n      reserveAsset[reservesIndex[\"RDPX\"]].tokenBalance +=\n        _rdpxAmount +\n        extraRdpxToWithdraw;\n    }\n  }\n\n  /**\n   * @notice Internal function to bond with delegates\n   * @param  _amount The amount of DpxEth to bond\n   * @param  rdpxBondId The bond id\n   * @param  delegateId The id of the delegate position being used\n   * @return  returnValues {\n    uint256 delegateReceiptTokenAmount;\n    uint256 bondAmountForUser;\n    uint256 rdpxRequired;\n    uint256 wethRequired;\n  }\n   **/\n  function _bondWithDelegate(\n    uint256 _amount,\n    uint256 rdpxBondId,\n    uint256 delegateId\n  ) internal returns (BondWithDelegateReturnValue memory returnValues) {\n    // Compute the bond cost\n    (uint256 rdpxRequired, uint256 wethRequired) = calculateBondCost(\n      _amount,\n      rdpxBondId\n    );\n\n    // update ETH token reserve\n    reserveAsset[reservesIndex[\"WETH\"]].tokenBalance += wethRequired;\n\n    Delegate storage delegate = delegates[delegateId];\n\n    // update delegate active collateral\n    _validate(delegate.amount - delegate.activeCollateral >= wethRequired, 5);\n    delegate.activeCollateral += wethRequired;\n\n    // update total weth delegated\n    totalWethDelegated -= wethRequired;\n\n    // Calculate the amount of bond token to mint for the delegate and user based on the fee\n    (uint256 amount1, uint256 amount2) = _calculateAmounts(\n      wethRequired,\n      rdpxRequired,\n      _amount,\n      delegate.fee\n    );\n\n    // update user amounts\n    // ETH token amount remaining after LP for the user\n    uint256 bondAmountForUser = amount1;\n\n    // Mint bond token for delegate\n    // ETH token amount remaining after LP for the delegate\n    uint256 delegateReceiptTokenAmount = _stake(delegate.owner, amount2);\n\n    returnValues = BondWithDelegateReturnValue(\n      delegateReceiptTokenAmount,\n      bondAmountForUser,\n      rdpxRequired,\n      wethRequired\n    );\n  }\n\n  /**\n   * @dev    Internal function to validate checks\n   * @param  _clause the boolean clause to validate\n   * @param  _errorCode error code for error mapping below\n   **/\n  function _validate(bool _clause, uint256 _errorCode) internal pure {\n    if (!_clause) revert RdpxV2CoreError(_errorCode);\n  }\n\n  // ================================ CORE ================================ //\n\n  /**\n   * @notice Settles the options\n   * @dev    Can only be called by admin\n   * @param  optionIds the ids of the option to be settled\n   * @return amountOfWeth the amount of eth received\n   * @return rdpxAmount the amount of rdpx sent out\n   */\n  function settle(\n    uint256[] memory optionIds\n  )\n    external\n    onlyRole(DEFAULT_ADMIN_ROLE)\n    returns (uint256 amountOfWeth, uint256 rdpxAmount)\n  {\n    _whenNotPaused();\n    (amountOfWeth, rdpxAmount) = IPerpetualAtlanticVault(\n      addresses.perpetualAtlanticVault\n    ).settle(optionIds);\n    for (uint256 i = 0; i < optionIds.length; i++) {\n      optionsOwned[optionIds[i]] = false;\n    }\n\n    reserveAsset[reservesIndex[\"WETH\"]].tokenBalance += amountOfWeth;\n    reserveAsset[reservesIndex[\"RDPX\"]].tokenBalance -= rdpxAmount;\n\n    emit LogSettle(optionIds);\n  }\n\n  /**\n   * @notice Calculates and sends the funding amount to the vault\n   * @dev    Can only be called by admin\n   * @return fundingAmount the amount of funding paid\n   **/\n  function provideFunding()\n    external\n    onlyRole(DEFAULT_ADMIN_ROLE)\n    returns (uint256 fundingAmount)\n  {\n    _whenNotPaused();\n    uint256 pointer = IPerpetualAtlanticVault(addresses.perpetualAtlanticVault)\n      .latestFundingPaymentPointer();\n    _validate(fundingPaidFor[pointer] == false, 16);\n\n    fundingAmount = IPerpetualAtlanticVault(addresses.perpetualAtlanticVault)\n      .payFunding();\n\n    reserveAsset[reservesIndex[\"WETH\"]].tokenBalance -= fundingAmount;\n\n    fundingPaidFor[pointer] = true;\n\n    emit LogProvideFunding(pointer, fundingAmount);\n  }\n\n  /**\n   * @notice The Bonding function to bond with delegates\n   * @param  _to The address to send the bond to\n   * @param  _amounts The amounts of DpxEth to lock in the bond\n   * @param  _delegateIds the id of the delegate position's being used\n   * @param  rdpxBondId The bond id\n   * @return receiptTokenAmount The amount of receipt tokens recieved\n   * @return delegateTokenAmounts The amount of receipt tokens recieved for each delegate\n   **/\n  function bondWithDelegate(\n    address _to,\n    uint256[] memory _amounts,\n    uint256[] memory _delegateIds,\n    uint256 rdpxBondId\n  ) public returns (uint256 receiptTokenAmount, uint256[] memory) {\n    _whenNotPaused();\n    // Validate amount\n    _validate(_amounts.length == _delegateIds.length, 3);\n\n    uint256 userTotalBondAmount;\n    uint256 totalBondAmount;\n\n    uint256[] memory delegateReceiptTokenAmounts = new uint256[](\n      _amounts.length\n    );\n\n    for (uint256 i = 0; i < _amounts.length; i++) {\n      // Validate amount\n      _validate(_amounts[i] > 0, 4);\n\n      BondWithDelegateReturnValue\n        memory returnValues = BondWithDelegateReturnValue(0, 0, 0, 0);\n\n      returnValues = _bondWithDelegate(\n        _amounts[i],\n        rdpxBondId,\n        _delegateIds[i]\n      );\n\n      delegateReceiptTokenAmounts[i] = returnValues.delegateReceiptTokenAmount;\n\n      userTotalBondAmount += returnValues.bondAmountForUser;\n      totalBondAmount += _amounts[i];\n\n      // purchase options\n      uint256 premium;\n      if (putOptionsRequired) {\n        premium = _purchaseOptions(returnValues.rdpxRequired);\n      }\n\n      // transfer the required rdpx\n      _transfer(\n        returnValues.rdpxRequired,\n        returnValues.wethRequired - premium,\n        _amounts[i],\n        rdpxBondId\n      );\n    }\n\n    // Mint bond token for user\n    receiptTokenAmount = _stake(_to, userTotalBondAmount);\n\n    // reLP\n    if (isReLPActive) IReLP(addresses.reLPContract).reLP(totalBondAmount);\n\n    emit LogBondWithDelegate(\n      _to,\n      _delegateIds,\n      _amounts,\n      rdpxBondId,\n      receiptTokenAmount,\n      delegateReceiptTokenAmounts\n    );\n\n    return (receiptTokenAmount, delegateReceiptTokenAmounts);\n  }\n\n  /**\n   * @notice The primary bonding function\n   * @param  _amount The amount of DpxEth to bond for\n   * @param  rdpxBondId The bond id\n   * @param  _to The address to send the bond to\n   * @return receiptTokenAmount the amount of receipt tokens received\n   **/\n  function bond(\n    uint256 _amount,\n    uint256 rdpxBondId,\n    address _to\n  ) public returns (uint256 receiptTokenAmount) {\n    _whenNotPaused();\n    // Validate amount\n    _validate(_amount > 0, 4);\n\n    // Compute the bond cost\n    (uint256 rdpxRequired, uint256 wethRequired) = calculateBondCost(\n      _amount,\n      rdpxBondId\n    );\n\n    IERC20WithBurn(weth).safeTransferFrom(\n      msg.sender,\n      address(this),\n      wethRequired\n    );\n\n    // update weth reserve\n    reserveAsset[reservesIndex[\"WETH\"]].tokenBalance += wethRequired;\n\n    // purchase options\n    uint256 premium;\n    if (putOptionsRequired) {\n      premium = _purchaseOptions(rdpxRequired);\n    }\n\n    _transfer(rdpxRequired, wethRequired - premium, _amount, rdpxBondId);\n\n    // Stake the ETH in the ReceiptToken contract\n    receiptTokenAmount = _stake(_to, _amount);\n\n    // reLP\n    if (isReLPActive) IReLP(addresses.reLPContract).reLP(_amount);\n\n    emit LogBond(rdpxRequired, wethRequired, receiptTokenAmount);\n  }\n\n  /**\n   * @notice Lets users delegate WETH\n   * @param  _amount The amount of WETH to delegate\n   * @param  _fee The fee to charge for the delegated WETH\n   * @return uint256 the ID of the delegate\n   **/\n  function addToDelegate(\n    uint256 _amount,\n    uint256 _fee\n  ) external returns (uint256) {\n    _whenNotPaused();\n    // fee less than 100%\n    _validate(_fee < 100e8, 8);\n    // amount greater than 0.01 WETH\n    _validate(_amount > 1e16, 4);\n    // fee greater than 1%\n    _validate(_fee >= 1e8, 8);\n\n    IERC20WithBurn(weth).safeTransferFrom(msg.sender, address(this), _amount);\n\n    Delegate memory delegatePosition = Delegate({\n      amount: _amount,\n      fee: _fee,\n      owner: msg.sender,\n      activeCollateral: 0\n    });\n    delegates.push(delegatePosition);\n\n    // add amount to total weth delegated\n    totalWethDelegated += _amount;\n\n    emit LogAddToDelegate(_amount, _fee, delegates.length - 1);\n    return (delegates.length - 1);\n  }\n\n  /**\n   * @notice Lets the delegate withdraw unused WETH\n   * @param  delegateId The ID of the delegate\n   * @return amountWithdrawn The amount of WETH withdrawn\n   **/\n  function withdraw(\n    uint256 delegateId\n  ) external returns (uint256 amountWithdrawn) {\n    _whenNotPaused();\n    _validate(delegateId < delegates.length, 14);\n    Delegate storage delegate = delegates[delegateId];\n    _validate(delegate.owner == msg.sender, 9);\n\n    amountWithdrawn = delegate.amount - delegate.activeCollateral;\n    _validate(amountWithdrawn > 0, 15);\n    delegate.amount = delegate.activeCollateral;\n\n    IERC20WithBurn(weth).safeTransfer(msg.sender, amountWithdrawn);\n\n    emit LogDelegateWithdraw(delegateId, amountWithdrawn);\n  }\n\n  /**\n   * @notice Syncs asset reserves with contract balances\n   **/\n  function sync() external {\n    for (uint256 i = 1; i < reserveAsset.length; i++) {\n      uint256 balance = IERC20WithBurn(reserveAsset[i].tokenAddress).balanceOf(\n        address(this)\n      );\n\n      if (weth == reserveAsset[i].tokenAddress) {\n        balance = balance - totalWethDelegated;\n      }\n      reserveAsset[i].tokenBalance = balance;\n    }\n\n    emit LogSync();\n  }\n\n   /**\n   * @notice Withdraws DSC from a matured bond\n   * @param  id bond ID\n   * @param  to the address to send the DSC too\n   * @return receiptTokenAmount the amount of receipt Tokens to transfer\n   **/\n  function redeem(\n    uint256 id,\n    address to\n  ) external returns (uint256 receiptTokenAmount) {\n    // Validate bond ID\n    _validate(bonds[id].timestamp > 0, 6);\n    // Validate if bond has matured\n    _validate(block.timestamp > bonds[id].maturity, 7);\n\n    _validate(\n      msg.sender == RdpxV2Bond(addresses.receiptTokenBonds).ownerOf(id),\n      9\n    );\n\n    // Burn the bond token\n    // Note requires an approval of the bond token to this contract\n    RdpxV2Bond(addresses.receiptTokenBonds).burn(id);\n\n    // transfer receipt tokens to user\n    receiptTokenAmount = bonds[id].amount;\n    IERC20WithBurn(addresses.rdpxV2ReceiptToken).safeTransfer(\n      to,\n      receiptTokenAmount\n    );\n\n    emit LogRedeem(to, receiptTokenAmount);\n  }\n\n  // ================================ REPEG FUNCTIONS =========================="
    }
  ]
}