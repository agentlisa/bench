{
  "Title": "Code-in-Address Does Not Guarantee Compatibility",
  "Content": "In a few cases, the protocol checks if an address possesses code as a validation before proceeding with the assignment. However, this does not guarantee that it could be another contract implementing a totally different logic. In particular:\n\n\n* The [`initialize` function](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/modules/Initialize.sol#L35) from the `Initialize` contract module has code in what is supposed to be the Vault's underlying asset. However, it does not necessarily mean it is a compatible ERC-20 token.\n* The [`setHookConfig` function](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/modules/Governance.sol#L247-L251) does not verify if the `newHookTarget` implements the expected methods and complies with the rest of the hooks.\n\n\nConsider using an introspection standard on the protocol-complementary contracts that interact with the Vaults, and take into consideration that addresses with code added as assets might not have a compliant ERC-20 token behind them.\n\n\n***Update:** Acknowledged, not resolved. The Euler team stated:*\n\n\n\n> *We acknowledge the issue. We acknowledge that checking for the existence of code at an address does not guarantee that the contract conforms to the required interface. The checks are not intended to provide guarantees, they are performed as a basic validation, making sure the user did not make an obvious mistake.*\n> \n> \n> *The check is a small improvement over a common practice to check for the zero address. We do not see a need to use introspection standards, which themselves do not provide strong guarantees about a contractâ€™s interface or implemented behavior. If the complementary contract does not implement the required functions, the vault will simply not function.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/EVault/modules/Initialize.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {IInitialize, IERC20} from \"../IEVault.sol\";\nimport {Base} from \"../shared/Base.sol\";\nimport {BorrowUtils} from \"../shared/BorrowUtils.sol\";\nimport {DToken} from \"../DToken.sol\";\nimport {ProxyUtils} from \"../shared/lib/ProxyUtils.sol\";\nimport {VaultCache} from \"../shared/types/VaultCache.sol\";\n\nimport \"../shared/Constants.sol\";\nimport \"../shared/types/Types.sol\";\n\n/// @title InitializeModule\n/// @author Euler Labs (https://www.eulerlabs.com/)\n/// @notice An EVault module implementing the initialization of the new vault contract\nabstract contract InitializeModule is IInitialize, Base, BorrowUtils {\n    using TypesLib for uint16;\n\n    uint256 constant INITIAL_INTEREST_ACCUMULATOR = 1e27; // 1 ray\n    uint16 constant DEFAULT_INTEREST_FEE = 0.1e4;\n\n    /// @inheritdoc IInitialize\n    function initialize(address proxyCreator) public virtual reentrantOK {\n        if (initialized) revert E_Initialized();\n        initialized = true;\n\n        // Validate proxy immutables\n\n        // Calldata should include: signature and abi encoded creator address (4 + 32 bytes), followed by proxy metadata\n        if (msg.data.length != 4 + 32 + PROXY_METADATA_LENGTH) revert E_ProxyMetadata();\n        (IERC20 asset,,) = ProxyUtils.metadata();\n        // Make sure the asset is a contract. Token transfers using a library will not revert if address has no code.\n        if (address(asset).code.length == 0) revert E_BadAddress();\n        // Other constraints on values should be enforced by product line\n\n        // Create sidecar DToken\n\n        address dToken = address(new DToken());\n\n        // Initialize storage\n\n        vaultStorage.lastInterestAccumulatorUpdate = uint48(block.timestamp);\n        vaultStorage.interestAccumulator = INITIAL_INTEREST_ACCUMULATOR;\n        vaultStorage.interestFee = DEFAULT_INTEREST_FEE.toConfigAmount();\n        vaultStorage.creator = vaultStorage.governorAdmin = proxyCreator;\n\n        snapshot.reset();\n\n        // Emit logs\n\n        emit EVaultCreated(proxyCreator, address(asset), dToken);\n        logVaultStatus(loadVault(), 0);\n    }\n\n    // prevent initialization of the implementation contract\n    constructor() {\n        initialized = true;\n    }\n}\n\n/// @dev Deployable module contract\ncontract Initialize is InitializeModule {\n    constructor(Integrations memory integrations) Base(integrations) {}\n}"
    },
    {
      "filename": "src/EVault/modules/Governance.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {IGovernance} from \"../IEVault.sol\";\nimport {IPriceOracle} from \"../../interfaces/IPriceOracle.sol\";\nimport {Base} from \"../shared/Base.sol\";\nimport {BalanceUtils} from \"../shared/BalanceUtils.sol\";\nimport {LTVUtils} from \"../shared/LTVUtils.sol\";\nimport {BorrowUtils} from \"../shared/BorrowUtils.sol\";\nimport {ProxyUtils} from \"../shared/lib/ProxyUtils.sol\";\n\nimport \"../shared/types/Types.sol\";\n\n/// @title GovernanceModule\n/// @author Euler Labs (https://www.eulerlabs.com/)\n/// @notice An EVault module handling governance, including configuration and fees\nabstract contract GovernanceModule is IGovernance, Base, BalanceUtils, BorrowUtils, LTVUtils {\n    using TypesLib for uint16;\n\n    // Protocol guarantees\n    uint16 constant MAX_PROTOCOL_FEE_SHARE = 0.5e4;\n    uint16 constant GUARANTEED_INTEREST_FEE_MIN = 0.1e4;\n    uint16 constant GUARANTEED_INTEREST_FEE_MAX = 1e4;\n\n    event GovSetName(string newName);\n    event GovSetSymbol(string newSymbol);\n    event GovSetGovernorAdmin(address indexed newGovernorAdmin);\n    event GovSetFeeReceiver(address indexed newFeeReceiver);\n    event GovSetLTV(\n        address indexed collateral, uint48 targetTimestamp, uint16 targetLTV, uint32 rampDuration, uint16 originalLTV\n    );\n    event GovSetInterestRateModel(address interestRateModel);\n    event GovSetHookConfig(address indexed newHookTarget, uint32 newHookedOps);\n    event GovSetConfigFlags(uint32 newConfigFlags);\n    event GovSetCaps(uint16 newSupplyCap, uint16 newBorrowCap);\n    event GovSetInterestFee(uint16 newFee);\n\n    modifier governorOnly() {\n        if (msg.sender != vaultStorage.governorAdmin) revert E_Unauthorized();\n        _;\n    }\n\n    /// @inheritdoc IGovernance\n    function governorAdmin() public view virtual reentrantOK returns (address) {\n        return vaultStorage.governorAdmin;\n    }\n\n    /// @inheritdoc IGovernance\n    function feeReceiver() public view virtual reentrantOK returns (address) {\n        return vaultStorage.feeReceiver;\n    }\n\n    /// @inheritdoc IGovernance\n    function interestFee() public view virtual reentrantOK returns (uint16) {\n        return vaultStorage.interestFee.toUint16();\n    }\n\n    /// @inheritdoc IGovernance\n    function interestRateModel() public view virtual reentrantOK returns (address) {\n        return vaultStorage.interestRateModel;\n    }\n\n    /// @inheritdoc IGovernance\n    function protocolConfigAddress() public view virtual reentrantOK returns (address) {\n        return address(protocolConfig);\n    }\n\n    /// @inheritdoc IGovernance\n    function protocolFeeShare() public view virtual reentrantOK returns (uint256) {\n        (, uint256 protocolShare) = protocolConfig.protocolFeeConfig(address(this));\n        return protocolShare;\n    }\n\n    /// @inheritdoc IGovernance\n    function protocolFeeReceiver() public view virtual reentrantOK returns (address) {\n        (address protocolReceiver,) = protocolConfig.protocolFeeConfig(address(this));\n        return protocolReceiver;\n    }\n\n    /// @inheritdoc IGovernance\n    function caps() public view virtual reentrantOK returns (uint16, uint16) {\n        return (vaultStorage.supplyCap.toRawUint16(), vaultStorage.borrowCap.toRawUint16());\n    }\n\n    /// @inheritdoc IGovernance\n    function borrowingLTV(address collateral) public view virtual reentrantOK returns (uint16) {\n        return getLTV(collateral, LTVType.BORROWING).toUint16();\n    }\n\n    /// @inheritdoc IGovernance\n    function liquidationLTV(address collateral) public view virtual reentrantOK returns (uint16) {\n        return getLTV(collateral, LTVType.LIQUIDATION).toUint16();\n    }\n\n    /// @inheritdoc IGovernance\n    function LTVFull(address collateral) public view virtual reentrantOK returns (uint48, uint16, uint32, uint16) {\n        LTVConfig memory ltv = vaultStorage.ltvLookup[collateral];\n        return (ltv.targetTimestamp, ltv.targetLTV.toUint16(), ltv.rampDuration, ltv.originalLTV.toUint16());\n    }\n\n    /// @inheritdoc IGovernance\n    function LTVList() public view virtual reentrantOK returns (address[] memory) {\n        return vaultStorage.ltvList;\n    }\n\n    /// @inheritdoc IGovernance\n    function hookConfig() public view virtual reentrantOK returns (address, uint32) {\n        return (vaultStorage.hookTarget, vaultStorage.hookedOps.toUint32());\n    }\n\n    /// @inheritdoc IGovernance\n    function configFlags() public view virtual reentrantOK returns (uint32) {\n        return (vaultStorage.configFlags.toUint32());\n    }\n\n    /// @inheritdoc IGovernance\n    function EVC() public view virtual reentrantOK returns (address) {\n        return address(evc);\n    }\n\n    /// @inheritdoc IGovernance\n    function unitOfAccount() public view virtual reentrantOK returns (address) {\n        (,, address _unitOfAccount) = ProxyUtils.metadata();\n        return _unitOfAccount;\n    }\n\n    /// @inheritdoc IGovernance\n    function oracle() public view virtual reentrantOK returns (address) {\n        (, IPriceOracle _oracle,) = ProxyUtils.metadata();\n        return address(_oracle);\n    }\n\n    /// @inheritdoc IGovernance\n    function permit2Address() public view virtual reentrantOK returns (address) {\n        return permit2;\n    }\n\n    /// @inheritdoc IGovernance\n    function convertFees() public virtual nonReentrant {\n        (VaultCache memory vaultCache, address account) = initOperation(OP_CONVERT_FEES, CHECKACCOUNT_NONE);\n\n        if (vaultCache.accumulatedFees.isZero()) return;\n\n        (address protocolReceiver, uint16 protocolFee) = protocolConfig.protocolFeeConfig(address(this));\n        address governorReceiver = vaultStorage.feeReceiver;\n\n        if (governorReceiver == address(0)) {\n            protocolFee = 1e4; // governor forfeits fees\n        } else if (protocolFee > MAX_PROTOCOL_FEE_SHARE) {\n            protocolFee = MAX_PROTOCOL_FEE_SHARE;\n        }\n\n        Shares governorShares = vaultCache.accumulatedFees.mulDiv(1e4 - protocolFee, 1e4);\n        Shares protocolShares = vaultCache.accumulatedFees - governorShares;\n\n        // Decrease totalShares because increaseBalance will increase it by that total amount\n        vaultStorage.totalShares = vaultCache.totalShares = vaultCache.totalShares - vaultCache.accumulatedFees;\n\n        vaultStorage.accumulatedFees = vaultCache.accumulatedFees = Shares.wrap(0);\n\n        // For the Deposit events in increaseBalance the assets amount is zero - the shares are covered with the accrued interest\n        if (!governorShares.isZero()) {\n            increaseBalance(vaultCache, governorReceiver, address(0), governorShares, Assets.wrap(0));\n        }\n\n        if (!protocolShares.isZero()) {\n            increaseBalance(vaultCache, protocolReceiver, address(0), protocolShares, Assets.wrap(0));\n        }\n\n        emit ConvertFees(account, protocolReceiver, governorReceiver, protocolShares.toUint(), governorShares.toUint());\n    }\n\n    /// @inheritdoc IGovernance\n    function setName(string calldata newName) public virtual nonReentrant governorOnly {\n        vaultStorage.name = newName;\n        emit GovSetName(newName);\n    }\n\n    /// @inheritdoc IGovernance\n    function setSymbol(string calldata newSymbol) public virtual nonReentrant governorOnly {\n        vaultStorage.symbol = newSymbol;\n        emit GovSetSymbol(newSymbol);\n    }\n\n    /// @inheritdoc IGovernance\n    function setGovernorAdmin(address newGovernorAdmin) public virtual nonReentrant governorOnly {\n        vaultStorage.governorAdmin = newGovernorAdmin;\n        emit GovSetGovernorAdmin(newGovernorAdmin);\n    }\n\n    /// @inheritdoc IGovernance\n    function setFeeReceiver(address newFeeReceiver) public virtual nonReentrant governorOnly {\n        vaultStorage.feeReceiver = newFeeReceiver;\n        emit GovSetFeeReceiver(newFeeReceiver);\n    }\n\n    /// @inheritdoc IGovernance\n    function setLTV(address collateral, uint16 ltv, uint32 rampDuration) public virtual nonReentrant governorOnly {\n        // self-collateralization is not allowed\n        if (collateral == address(this)) revert E_InvalidLTVAsset();\n\n        ConfigAmount newLTVAmount = ltv.toConfigAmount();\n        LTVConfig memory origLTV = vaultStorage.ltvLookup[collateral];\n\n        // If new LTV is higher than the previous, or the same, it should take effect immediately\n        if (newLTVAmount >= origLTV.getLTV(LTVType.LIQUIDATION) && rampDuration > 0) revert E_LTVRamp();\n\n        LTVConfig memory newLTV = origLTV.setLTV(newLTVAmount, rampDuration);\n\n        vaultStorage.ltvLookup[collateral] = newLTV;\n\n        if (!origLTV.initialized) vaultStorage.ltvList.push(collateral);\n\n        emit GovSetLTV(\n            collateral,\n            newLTV.targetTimestamp,\n            newLTV.targetLTV.toUint16(),\n            newLTV.rampDuration,\n            newLTV.originalLTV.toUint16()\n        );\n    }\n\n    /// @inheritdoc IGovernance\n    function clearLTV(address collateral) public virtual nonReentrant governorOnly {\n        uint16 originalLTV = getLTV(collateral, LTVType.LIQUIDATION).toUint16();\n        vaultStorage.ltvLookup[collateral].clear();\n\n        emit GovSetLTV(collateral, 0, 0, 0, originalLTV);\n    }\n\n    /// @inheritdoc IGovernance\n    function setInterestRateModel(address newModel) public virtual nonReentrant governorOnly {\n        VaultCache memory vaultCache = updateVault();\n\n        vaultStorage.interestRateModel = newModel;\n        vaultStorage.interestRate = 0;\n\n        uint256 newInterestRate = computeInterestRate(vaultCache);\n\n        logVaultStatus(vaultCache, newInterestRate);\n\n        emit GovSetInterestRateModel(newModel);\n    }\n\n    /// @inheritdoc IGovernance\n    function setHookConfig(address newHookTarget, uint32 newHookedOps) public virtual nonReentrant governorOnly {\n        vaultStorage.hookTarget = newHookTarget;\n        vaultStorage.hookedOps = Flags.wrap(newHookedOps);\n        emit GovSetHookConfig(newHookTarget, newHookedOps);\n    }\n\n    /// @inheritdoc IGovernance\n    function setConfigFlags(uint32 newConfigFlags) public virtual nonReentrant governorOnly {\n        vaultStorage.configFlags = Flags.wrap(newConfigFlags);\n        emit GovSetConfigFlags(newConfigFlags);\n    }\n\n    /// @inheritdoc IGovernance\n    function setCaps(uint16 supplyCap, uint16 borrowCap) public virtual nonReentrant governorOnly {\n        AmountCap _supplyCap = AmountCap.wrap(supplyCap);\n        // Max total assets is a sum of max cash size and max total debt, both Assets type\n        if (supplyCap > 0 && _supplyCap.resolve() > 2 * MAX_SANE_AMOUNT) revert E_BadSupplyCap();\n\n        AmountCap _borrowCap = AmountCap.wrap(borrowCap);\n        if (borrowCap > 0 && _borrowCap.resolve() > MAX_SANE_AMOUNT) revert E_BadBorrowCap();\n\n        vaultStorage.supplyCap = _supplyCap;\n        vaultStorage.borrowCap = _borrowCap;\n\n        emit GovSetCaps(supplyCap, borrowCap);\n    }\n\n    /// @inheritdoc IGovernance\n    function setInterestFee(uint16 newInterestFee) public virtual nonReentrant governorOnly {\n        // Update vault to apply the current interest fee to the pending interest\n        VaultCache memory vaultCache = updateVault();\n        logVaultStatus(vaultCache, vaultStorage.interestRate);\n\n        // Interest fees in guaranteed range are always allowed, otherwise ask protocolConfig\n        if (newInterestFee < GUARANTEED_INTEREST_FEE_MIN || newInterestFee > GUARANTEED_INTEREST_FEE_MAX) {\n            if (!protocolConfig.isValidInterestFee(address(this), newInterestFee)) revert E_BadFee();\n        }\n\n        vaultStorage.interestFee = newInterestFee.toConfigAmount();\n\n        emit GovSetInterestFee(newInterestFee);\n    }\n}\n\n/// @dev Deployable module contract\ncontract Governance is GovernanceModule {\n    constructor(Integrations memory integrations) Base(integrations) {}\n}"
    }
  ]
}