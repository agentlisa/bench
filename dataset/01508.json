{
  "Title": "Lack of input id validation in the _ownerOf function",
  "Content": "The `_ownerOf` function in both [Ethereum](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/Land/erc721/LandBaseTokenV3.sol#L656) and [Polygon](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/polygon/child/land/PolygonLandBaseTokenV2.sol#L729) implementations does not validate that the input `id` corresponds to a quad of size 1x1. This allows token ids that correspond to quads of size greater than 1 to be passed. External functions such as `burn`, `approve` and `approveFor` do not expect IDs for quads of such size, leading to unexpected consequences. For example, if a quad with a size greater than 1 were to be burnt, it would lead to the incorrect amount being decremented from `_numNFTPerAddress`.\n\n\nConsider validating that the input ID corresponds to a single token. This can be done by adding additional checks to the function to ensure that only valid token IDs are processed.\n\n\n***Update:** Resolved in [pull request #921](https://github.com/thesandboxgame/sandbox-smart-contracts/pull/921) at commit [97da7fb](https://github.com/thesandboxgame/sandbox-smart-contracts/pull/921/commits/97da7fb98e11c900f77ebac8c3b5459979441372).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/solc_0.5/Land/erc721/LandBaseTokenV3.sol",
      "content": "/* solhint-disable func-order, code-complexity */\npragma solidity 0.5.9;\n\nimport \"./ERC721BaseTokenV2.sol\";\n\ncontract LandBaseTokenV3 is ERC721BaseTokenV2 {\n    // Our grid is 408 x 408 lands\n    uint256 internal constant GRID_SIZE = 408;\n\n    uint256 internal constant LAYER = 0xFF00000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_1x1 = 0x0000000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_3x3 = 0x0100000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_6x6 = 0x0200000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_12x12 = 0x0300000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_24x24 = 0x0400000000000000000000000000000000000000000000000000000000000000;\n\n    mapping(address => bool) internal _minters;\n    event Minter(address superOperator, bool enabled);\n\n    struct Land {\n        uint256 x;\n        uint256 y;\n        uint256 size;\n    }\n\n    /**\n     * @notice Mint a new quad (aligned to a quad tree with size 1, 3, 6, 12 or 24 only)\n     * @param to The recipient of the new quad\n     * @param size The size of the new quad\n     * @param x The top left x coordinate of the new quad\n     * @param y The top left y coordinate of the new quad\n     * @param data extra data to pass to the transfer\n     */\n    function mintQuad(\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes calldata data\n    ) external {\n        require(to != address(0), \"to is zero address\");\n        require(isMinter(msg.sender), \"Only a minter can mint\");\n        require(x % size == 0 && y % size == 0, \"Invalid coordinates\");\n        require(x <= GRID_SIZE - size && y <= GRID_SIZE - size, \"Out of bounds\");\n\n        (uint256 layer, , ) = _getQuadLayer(size);\n        uint256 quadId = _getQuadId(layer, x, y);\n\n        _checkOwner(size, x, y, 24);\n        for (uint256 i = 0; i < size * size; i++) {\n            uint256 _id = _idInPath(i, size, x, y);\n            require(_owners[_id] == 0, \"Already minted\");\n            emit Transfer(address(0), to, _id);\n        }\n\n        _owners[quadId] = uint256(to);\n        _numNFTPerAddress[to] += size * size;\n\n        _checkBatchReceiverAcceptQuad(msg.sender, address(0), to, size, x, y, data);\n    }\n\n    /**\n     * @notice Checks if a parent quad has child quads already minted.\n     *  Then mints the rest child quads and transfers the parent quad.\n     *  Should only be called by the tunnel.\n     * @param to The recipient of the new quad\n     * @param size The size of the new quad\n     * @param x The top left x coordinate of the new quad\n     * @param y The top left y coordinate of the new quad\n     * @param data extra data to pass to the transfer\n     */\n    function mintAndTransferQuad(\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes calldata data\n    ) external {\n        require(to != address(0), \"to is zero address\");\n        require(isMinter(msg.sender), \"Only a minter can mint\");\n        \n        if (exists(size, x, y) == true) {\n            _transferQuad(msg.sender, to, size, x, y);\n            _numNFTPerAddress[msg.sender] -= size * size;\n            _numNFTPerAddress[to] += size * size;\n            _checkBatchReceiverAcceptQuad(msg.sender, msg.sender, to, size, x, y, data);\n        } else {\n            _mintAndTransferQuad(to, size, x, y, data);\n        }\n    }\n\n    /// @notice transfer one quad (aligned to a quad tree with size 3, 6, 12 or 24 only)\n    /// @param from current owner of the quad\n    /// @param to destination\n    /// @param size size of the quad\n    /// @param x The top left x coordinate of the quad\n    /// @param y The top left y coordinate of the quad\n    /// @param data additional data\n    function transferQuad(\n        address from,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes calldata data\n    ) external {\n        require(from != address(0), \"from is zero address\");\n        require(to != address(0), \"can't send to zero address\");\n        bool metaTx = msg.sender != from && _metaTransactionContracts[msg.sender];\n        if (msg.sender != from && !metaTx) {\n            require(\n                _operatorsForAll[from][msg.sender] || _superOperators[msg.sender],\n                \"not authorized to transferQuad\"\n            );\n        }\n        _transferQuad(from, to, size, x, y);\n        _numNFTPerAddress[from] -= size * size;\n        _numNFTPerAddress[to] += size * size;\n\n        _checkBatchReceiverAcceptQuad(metaTx ? from : msg.sender, from, to, size, x, y, data);\n    }\n\n    /// @notice transfer multiple quad (aligned to a quad tree with size 3, 6, 12 or 24 only)\n    /// @param from current owner of the quad\n    /// @param to destination\n    /// @param sizes list of sizes for each quad\n    /// @param xs list of top left x coordinates for each quad\n    /// @param ys list of top left y coordinates for each quad\n    /// @param data additional data\n    function batchTransferQuad(\n        address from,\n        address to,\n        uint256[] calldata sizes,\n        uint256[] calldata xs,\n        uint256[] calldata ys,\n        bytes calldata data\n    ) external {\n        require(from != address(0), \"from is zero address\");\n        require(to != address(0), \"can't send to zero address\");\n        require(sizes.length == xs.length && xs.length == ys.length, \"invalid data\");\n        bool metaTx = msg.sender != from && _metaTransactionContracts[msg.sender];\n        if (msg.sender != from && !metaTx) {\n            require(\n                _operatorsForAll[from][msg.sender] || _superOperators[msg.sender],\n                \"not authorized to transferMultiQuads\"\n            );\n        }\n        uint256 numTokensTransfered = 0;\n        for (uint256 i = 0; i < sizes.length; i++) {\n            uint256 size = sizes[i];\n            _transferQuad(from, to, size, xs[i], ys[i]);\n            numTokensTransfered += size * size;\n        }\n        _numNFTPerAddress[from] -= numTokensTransfered;\n        _numNFTPerAddress[to] += numTokensTransfered;\n\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            uint256[] memory ids = new uint256[](numTokensTransfered);\n            uint256 counter = 0;\n            for (uint256 j = 0; j < sizes.length; j++) {\n                uint256 size = sizes[j];\n                for (uint256 i = 0; i < size * size; i++) {\n                    ids[counter] = _idInPath(i, size, xs[j], ys[j]);\n                    counter++;\n                }\n            }\n            require(\n                _checkOnERC721BatchReceived(metaTx ? from : msg.sender, from, to, ids, data),\n                \"erc721 batch transfer rejected by to\"\n            );\n        }\n    }\n\n    /// @notice Enable or disable the ability of `minter` to mint tokens\n    /// @param minter address that will be given/removed minter right.\n    /// @param enabled set whether the minter is enabled or disabled.\n    function setMinter(address minter, bool enabled) external onlyAdmin {\n        require(minter != address(0), \"address 0 is not allowed as minter\");\n        require(enabled != _minters[minter], \"the status should be different than the current one\");\n        _minters[minter] = enabled;\n        emit Minter(minter, enabled);\n    }\n\n    /// @notice total width of the map\n    /// @return width\n    function width() external pure returns (uint256) {\n        return GRID_SIZE;\n    }\n\n    /// @notice total height of the map\n    /// @return height\n    function height() external pure returns (uint256) {\n        return GRID_SIZE;\n    }\n\n    /// @notice x coordinate of Land token\n    /// @param id tokenId\n    /// @return the x coordinates\n    function getX(uint256 id) external pure returns (uint256) {\n        return _getX(id);\n    }\n\n    /// @notice y coordinate of Land token\n    /// @param id tokenId\n    /// @return the y coordinates\n    function getY(uint256 id) external pure returns (uint256) {\n        return _getY(id);\n    }\n\n    /// @notice check whether address `who` is given minter rights.\n    /// @param who The address to query.\n    /// @return whether the address has minter rights.\n    function isMinter(address who) public view returns (bool) {\n        return _minters[who];\n    }\n\n    /// @notice checks if Land has been minted or not\n    /// @param size size of the\n    /// @param x x coordinate of the quad\n    /// @param y y coordinate of the quad\n    /// @return bool for if Land has been minted or not\n    function exists(\n        uint256 size,\n        uint256 x,\n        uint256 y\n    ) public view returns (bool) {\n        require(x % size == 0 && y % size == 0, \"Invalid coordinates\");\n        require(x <= GRID_SIZE - size && y <= GRID_SIZE - size, \"Out of bounds\");\n        return _ownerOfQuad(size, x, y) != address(0);\n    }\n\n    function _mintAndTransferQuad(\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes memory data\n    ) internal {\n        (uint256 layer, , ) = _getQuadLayer(size);\n        uint256 quadId = _getQuadId(layer, x, y);\n\n        // Length of array is equal to number of 3x3 child quad a 24x24 quad can have\n        Land[] memory quadMinted = new Land[](64);\n        uint256 index;\n        uint256 landMinted;\n\n        if (size > 3) {\n            (index, landMinted) = _checkAndClearOwner(\n                Land({x: x, y: y, size: size}),\n                quadMinted,\n                landMinted,\n                index,\n                size / 2\n            );\n        }\n\n        {\n            for (uint256 i = 0; i < size * size; i++) {\n                uint256 _id = _idInPath(i, size, x, y);\n                bool isAlreadyMinted = _isQuadMinted(quadMinted, Land({x: _getX(_id), y: _getY(_id), size: 1}), index);\n                if (isAlreadyMinted) {\n                    emit Transfer(msg.sender, to, _id);\n                } else {\n                    if (_owners[_id] == uint256(msg.sender)) {\n                        landMinted += 1;\n                        emit Transfer(msg.sender, to, _id);\n                    } else {\n                        require(_owners[_id] == 0, \"Already minted\");\n\n                        emit Transfer(address(0), to, _id);\n                    }\n                }\n            }\n        }\n\n        _checkBatchReceiverAcceptQuadAndClearOwner(quadMinted, index, landMinted, to, size, x, y, data);\n\n        _owners[quadId] = uint256(to);\n        _numNFTPerAddress[to] += size * size;\n        _numNFTPerAddress[msg.sender] -= landMinted;\n    }\n\n    function _checkBatchReceiverAcceptQuad(\n        address operator,\n        address from,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes memory data\n    ) internal {\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            uint256[] memory ids = new uint256[](size * size);\n            for (uint256 i = 0; i < size * size; i++) {\n                ids[i] = _idInPath(i, size, x, y);\n            }\n            require(_checkOnERC721BatchReceived(operator, from, to, ids, data), \"erc721 batch transfer rejected by to\");\n        }\n    }\n\n    function _checkBatchReceiverAcceptQuadAndClearOwner(\n        Land[] memory quadMinted,\n        uint256 index,\n        uint256 landMinted,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes memory data\n    ) internal {\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            uint256[] memory idsToTransfer = new uint256[](landMinted);\n            uint256 transferIndex;\n            uint256[] memory idsToMint = new uint256[]((size * size) - landMinted);\n            uint256 mintIndex;\n\n            for (uint256 i = 0; i < size * size; i++) {\n                uint256 id = _idInPath(i, size, x, y);\n\n                if (_isQuadMinted(quadMinted, Land({x: _getX(id), y: _getY(id), size: 1}), index)) {\n                    idsToTransfer[transferIndex] = id;\n                    transferIndex++;\n                } else if (_owners[id] == uint256(msg.sender)) {\n                    _owners[id] = 0;\n                    idsToTransfer[transferIndex] = id;\n                    transferIndex++;\n                } else {\n                    idsToMint[mintIndex] = id;\n                    mintIndex++;\n                }\n            }\n            require(\n                _checkOnERC721BatchReceived(msg.sender, address(0), to, idsToMint, data),\n                \"erc721 batch transfer rejected by to\"\n            );\n            require(\n                _checkOnERC721BatchReceived(msg.sender, msg.sender, to, idsToTransfer, data),\n                \"erc721 batch transfer rejected by to\"\n            );\n        } else {\n            for (uint256 i = 0; i < size * size; i++) {\n                uint256 id = _idInPath(i, size, x, y);\n                if (_owners[id] == uint256(msg.sender)) _owners[id] = 0;\n            }\n        }\n    }\n\n    function _transferQuad(\n        address from,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y\n    ) internal {\n        if (size == 1) {\n            uint256 id1x1 = _getQuadId(LAYER_1x1, x, y);\n            address owner = _ownerOf(id1x1);\n            require(owner != address(0), \"token does not exist\");\n            require(owner == from, \"not owner in _transferQuad\");\n            _owners[id1x1] = uint256(to);\n        } else {\n            _regroup(from, to, size, x, y);\n        }\n        for (uint256 i = 0; i < size * size; i++) {\n            emit Transfer(from, to, _idInPath(i, size, x, y));\n        }\n    }\n\n    function _checkOwner(\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        uint256 quadCompareSize\n    ) internal view {\n        (uint256 layer, , ) = _getQuadLayer(quadCompareSize);\n\n        if (size <= quadCompareSize) {\n            // when the size of the quad is smaller than the quadCompareSize(size to be compared with),\n            // then it is checked if the bigger quad which encapsulates the quad to be minted\n            // of with size equals the quadCompareSize has been minted or not\n            require(\n                _owners[\n                    _getQuadId(layer, (x / quadCompareSize) * quadCompareSize, (y / quadCompareSize) * quadCompareSize)\n                ] == 0,\n                \"Already minted\"\n            );\n        } else {\n            // when the size is smaller than the quadCompare size the owner of all the smaller quads with size\n            // quadCompare size in the quad to be minted are checked if they are minted or not\n            uint256 toX = x + size;\n            uint256 toY = y + size;\n            for (uint256 xi = x; xi < toX; xi += quadCompareSize) {\n                for (uint256 yi = y; yi < toY; yi += quadCompareSize) {\n                    require(_owners[_getQuadId(layer, xi, yi)] == 0, \"Already minted\");\n                }\n            }\n        }\n\n        quadCompareSize = quadCompareSize / 2;\n        if (quadCompareSize >= 3) _checkOwner(size, x, y, quadCompareSize);\n    }\n\n    function _checkAndClear(address from, uint256 id) internal returns (bool) {\n        uint256 owner = _owners[id];\n        if (owner != 0) {\n            require(address(owner) == from, \"not owner\");\n            _owners[id] = 0;\n            return true;\n        }\n        return false;\n    }\n\n    function _regroup(\n        address from,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y\n    ) internal {\n        require(x % size == 0 && y % size == 0, \"Invalid coordinates\");\n        require(x <= GRID_SIZE - size && y <= GRID_SIZE - size, \"Out of bounds\");\n        if (size == 3 || size == 6 || size == 12 || size == 24) {\n            _regroupQuad(from, to, Land({x: x, y: y, size: size}), true, size / 2);\n        } else {\n            require(false, \"Invalid size\");\n        }\n    }\n\n    function _checkAndClearOwner(\n        Land memory land,\n        Land[] memory quadMinted,\n        uint256 landMinted,\n        uint256 index,\n        uint256 quadCompareSize\n    ) internal returns (uint256, uint256) {\n        (uint256 layer, , ) = _getQuadLayer(quadCompareSize);\n        uint256 toX = land.x + land.size;\n        uint256 toY = land.y + land.size;\n\n        for (uint256 xi = land.x; xi < toX; xi += quadCompareSize) {\n            for (uint256 yi = land.y; yi < toY; yi += quadCompareSize) {\n                bool isQuadChecked = _isQuadMinted(quadMinted, Land({x: xi, y: yi, size: quadCompareSize}), index);\n                if (!isQuadChecked) {\n                    uint256 id = _getQuadId(layer, xi, yi);\n                    address owner = address(uint160(_owners[id]));\n\n                    if (owner == msg.sender) {\n                        quadMinted[index] = Land({x: xi, y: yi, size: quadCompareSize});\n                        index++;\n                        landMinted += quadCompareSize * quadCompareSize;\n                        _owners[id] = 0;\n                    } else {\n                        require(owner == address(0), \"Already minted\");\n                    }\n                }\n            }\n        }\n\n        quadCompareSize = quadCompareSize / 2;\n        if (quadCompareSize >= 3)\n            (index, landMinted) = _checkAndClearOwner(land, quadMinted, landMinted, index, quadCompareSize);\n        return (index, landMinted);\n    }\n\n    /// @dev checks if the Land's child quads are owned by the from address and clears all the previous owners\n    /// if all the child quads are not owned by the \"from\" address then the owner of parent quad to the land\n    /// is checked if owned by the \"from\" address. If from is the owner then land owner is set to \"to\" address\n    /// @param from address of the previous owner\n    /// @param to address of the new owner\n    /// @param land the quad to be regrouped and transfered\n    /// @param set for setting the new owner\n    /// @param childQuadSize  size of the child quad to be checked for owner in the regrouping\n    function _regroupQuad(\n        address from,\n        address to,\n        Land memory land,\n        bool set,\n        uint256 childQuadSize\n    ) internal returns (bool) {\n        (uint256 layer, , uint256 childLayer) = _getQuadLayer(land.size);\n        uint256 quadId = _getQuadId(layer, land.x, land.y);\n        bool ownerOfAll = true;\n\n        {\n            // double for loop itereates and checks owner of all the smaller quads in land\n            for (uint256 xi = land.x; xi < land.x + land.size; xi += childQuadSize) {\n                for (uint256 yi = land.y; yi < land.y + land.size; yi += childQuadSize) {\n                    uint256 ownerChild;\n                    bool ownAllIndividual;\n                    if (childQuadSize < 3) {\n                        // case when the smaller quad is 1x1,\n                        ownAllIndividual = _checkAndClear(from, _getQuadId(LAYER_1x1, xi, yi)) && ownerOfAll;\n                    } else {\n                        // recursively calling the _regroupQuad function to check the owner of child quads.\n                        ownAllIndividual = _regroupQuad(\n                            from,\n                            to,\n                            Land({x: xi, y: yi, size: childQuadSize}),\n                            false,\n                            childQuadSize / 2\n                        );\n                        uint256 idChild = _getQuadId(childLayer, xi, yi);\n                        ownerChild = _owners[idChild];\n                        if (ownerChild != 0) {\n                            if (!ownAllIndividual) {\n                                // checking the owner of child quad\n                                require(ownerChild == uint256(from), \"not owner of child Quad\");\n                            }\n                            // clearing owner of child quad\n                            _owners[idChild] = 0;\n                        }\n                    }\n                    // ownerOfAll should be true if \"from\" is owner of all the child quads ittereated over\n                    ownerOfAll = (ownAllIndividual || ownerChild != 0) && ownerOfAll;\n                }\n            }\n        }\n\n        // if set is true it check if the \"from\" is owner of all else checks for the owner of parent quad is\n        // owned by \"from\" and sets the owner for the id of land to \"to\" address.\n        if (set) {\n            if (!ownerOfAll) {\n                require(_ownerOfQuad(land.size, land.x, land.y) == from, \"not owner of all sub quads nor parent quads\");\n            }\n            _owners[quadId] = uint256(to);\n            return true;\n        }\n\n        return ownerOfAll;\n    }\n\n    function _idInPath(\n        uint256 i,\n        uint256 size,\n        uint256 x,\n        uint256 y\n    ) internal pure returns (uint256) {\n        uint256 row = i / size;\n        if (row % 2 == 0) {\n            // allow ids to follow a path in a quad\n            return _getQuadId(LAYER_1x1, (x + (i % size)), (y + row));\n        } else {\n            return _getQuadId(LAYER_1x1, (x + size) - (1 + (i % size)), (y + row));\n        }\n    }\n\n    function _isQuadMinted(\n        Land[] memory mintedLand,\n        Land memory quad,\n        uint256 index\n    ) internal pure returns (bool) {\n        for (uint256 i = 0; i < index; i++) {\n            Land memory land = mintedLand[i];\n            if (\n                land.size > quad.size &&\n                quad.x >= land.x &&\n                quad.x < land.x + land.size &&\n                quad.y >= land.y &&\n                quad.y < land.y + land.size\n            ) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _getX(uint256 id) internal pure returns (uint256) {\n        return ((id << 8) >> 8) % GRID_SIZE;\n    }\n\n    function _getY(uint256 id) internal pure returns (uint256) {\n        return ((id << 8) >> 8) / GRID_SIZE;\n    }\n\n    function _getQuadLayer(uint256 size)\n        internal\n        pure\n        returns (\n            uint256 layer,\n            uint256 parentSize,\n            uint256 childLayer\n        )\n    {\n        if (size == 1) {\n            layer = LAYER_1x1;\n            parentSize = 3;\n        } else if (size == 3) {\n            layer = LAYER_3x3;\n            parentSize = 6;\n        } else if (size == 6) {\n            layer = LAYER_6x6;\n            parentSize = 12;\n            childLayer = LAYER_3x3;\n        } else if (size == 12) {\n            layer = LAYER_12x12;\n            parentSize = 24;\n            childLayer = LAYER_6x6;\n        } else if (size == 24) {\n            layer = LAYER_24x24;\n            childLayer = LAYER_12x12;\n        } else {\n            require(false, \"Invalid size\");\n        }\n    }\n\n    function _getQuadId(\n        uint256 layer,\n        uint256 x,\n        uint256 y\n    ) internal pure returns (uint256 quadId) {\n        quadId = layer + x + y * GRID_SIZE;\n    }\n\n    function _ownerOfQuad(\n        uint256 size,\n        uint256 x,\n        uint256 y\n    ) internal view returns (address) {\n        (uint256 layer, uint256 parentSize, ) = _getQuadLayer(size);\n        address owner = address(_owners[_getQuadId(layer, (x / size) * size, (y / size) * size)]);\n        if (owner != address(0)) {\n            return owner;\n        } else if (size < 24) {\n            return _ownerOfQuad(parentSize, x, y);\n        }\n        return address(0);\n    }\n\n    function _getQuadById(uint256 id)\n        internal\n        pure\n        returns (\n            uint256 size,\n            uint256 x,\n            uint256 y\n        )\n    {\n        x = _getX(id);\n        y = _getY(id);\n        uint256 layer = id & LAYER;\n        if (layer == LAYER_1x1) {\n            size = 1;\n        } else if (layer == LAYER_3x3) {\n            size = 3;\n        } else if (layer == LAYER_6x6) {\n            size = 6;\n        } else if (layer == LAYER_12x12) {\n            size = 12;\n        } else if (layer == LAYER_24x24) {\n            size = 24;\n        } else {\n            require(false, \"Invalid token id\");\n        }\n    }\n\n    function _ownerOf(uint256 id) internal view returns (address) {\n        (uint256 size, uint256 x, uint256 y) = _getQuadById(id);\n        require(x % size == 0 && y % size == 0, \"Invalid token id\");\n        return _ownerOfQuad(size, x, y);\n    }\n\n    function _ownerAndOperatorEnabledOf(uint256 id) internal view returns (address owner, bool operatorEnabled) {\n        require(id & LAYER == 0, \"Invalid token id\");\n        uint256 x = _getX(id);\n        uint256 y = _getY(id);\n        uint256 owner1x1 = _owners[id];\n\n        if (owner1x1 != 0) {\n            owner = address(owner1x1);\n            operatorEnabled = (owner1x1 / 2**255) == 1;\n        } else {\n            owner = _ownerOfQuad(3, (x * 3) / 3, (y * 3) / 3);\n            operatorEnabled = false;\n        }\n    }\n}"
    }
  ]
}