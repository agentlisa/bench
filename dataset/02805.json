{
  "Title": "H-12: Illuminate's PT doesn't respect users' slippage specifications",
  "Content": "# Issue H-12: Illuminate's PT doesn't respect users' slippage specifications \n\nSource: https://github.com/sherlock-audit/2022-10-illuminate-judging/issues/114 \n\n## Found by \nIllIllI\n\n## Summary\n\nIlluminate's PT doesn't respect users' slippage specifications, and allows more slippage than is requested\n\n\n## Vulnerability Detail\n\n`ERC5095.withdraw()/redeem()`'s code adds extra slippage on top of what the user requests\n\n\n## Impact\n\n_Direct theft of any user funds, whether at-rest or in-motion, other than unclaimed yield_\n_Miner-extractable value (MEV)_\n\nAt the end of withdrawal/redemption, the user will end up losing more underlying than they wished to, due to slippage. If the user had used a external PT to mint the Illuminate PT, they will have lost part of their principal.\n\n\n## Code Snippet\n\nThe NatSpec says `Before maturity, sends 'assets' by selling shares of PT on a YieldSpace AMM.`, so it's clear that the intention is to send back the amount of tokens specified in the input argument. In spite of this, extra slippage is allowed for the amount:\n```solidity\n// File: src/tokens/ERC5095.sol : ERC5095.withdraw()   #1\n\n219                    uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n220                        underlying,\n221                        maturity,\n222                        shares,\n223 @>                     Cast.u128(a - (a / 100))\n224                    );\n225                    Safe.transfer(IERC20(underlying), r, returned);\n226:                   return returned;\n```\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/tokens/ERC5095.sol#L219-L226\n\n\n```solidity\n// File: src/tokens/ERC5095.sol : ERC5095.withdraw()   #2\n\n240                    uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n241                        underlying,\n242                        maturity,\n243                        Cast.u128(shares),\n244 @>                     Cast.u128(a - (a / 100))\n245                    );\n246                    Safe.transfer(IERC20(underlying), r, returned);\n247:                   return returned;\n```\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/tokens/ERC5095.sol#L240-L247\n\n\n(`redeem()` has the [same](https://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/tokens/ERC5095.sol#L294-L314) issue\n\nand `IMarketPlace.sellPrincipalToken()` also considers the amount as an amount that already includes slippage:\n```solidity\n// File: src/MarketPlace.sol : MarketPlace.a   #3\n\n279        /// @notice sells the PT for the underlying via the pool\n280        /// @param u address of an underlying asset\n281        /// @param m maturity (timestamp) of the market\n282        /// @param a amount of PTs to sell\n283 @>     /// @param s slippage cap, minimum amount of underlying that must be received\n284        /// @return uint128 amount of underlying bought\n285        function sellPrincipalToken(\n286            address u,\n287            uint256 m,\n288            uint128 a,\n289 @>         uint128 s\n290:        ) external returns (uint128) {\n```\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Marketplace.sol#L285-L298\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\nPass `Cast.u128(a)` to the two calls instead\n\n\n\n## Discussion\n\n**sourabhmarathe**\n\nUnfortunately, there isn't a clean solution here for users. When using the preview methods as suggested in the recommendation, an invalid slippage is used for the fourth parameter to `sellPrincipalToken`. As a result, we are finding that this does not work on fork-mode tests. For now, we're going to keep the method in place with the knowledge that users should have other avenues available to them (via using the pool directly) to reduce their slippage risk.\n\nIn addition, I would disagree with the severity of this issue on that basis as well, and I am open to hearing other ideas the judges have.\n\n**IllIllI000**\n\nEven if there are other paths that the user can take, the presence of a path where they lose principal means there's still a high-severity issue. I believe the problem you're facing is that convert* is using preview*, when it's supposed to be a flash-resistant method of getting the value. The ERC5095 spec specifically only requires that convertToUnderlying() only work at maturity, because according to one of the spec authors, it's an 'open question' about how to get a valid price before then.\n\n**sourabhmarathe**\n\nAs an alternative solution, should we have user provide the slippage then? Given that `withdrawPreview()` tells us how many `shares` will be required and the fact that it could change depending on where in the block the swap occurs, I think that's the only way around this (other than providing the 1% slippage built-in value we provide) \n\n**IllIllI000**\n\nThe 5095 standard has specific arguments for `withdraw()`, so I don't think you should add another argument. The standard also mentions `Note that some implementations will require pre-requesting to the principal token contract before a withdrawal may be performed. Those methods should be performed separately.` so you could have a function that pre-specifies the slippage before each withdrawal, or you could have a completely separate pre-maturity withdrawal function, and have the normal `withdraw()` revert before maturity, as is done in the sample contract in the EIP\n\n**JTraversa**\n\nYeah unfortunately we also intended some backwards compatability with 4626 (specifically for some integrations like the aztec 4626 bridge as this product targets their sort of batched design in particular). W/ that context we cant quite remove that sort of integration compatibility with pre-maturity redemptions, nor can add any params without breaking those integrations.\n\nSo its difficult to find a great solution other than writing overrides that *do* include additional parameters for slippage protection. IIRC we had issues with bytecode size limits and didnt want to add them but perhaps through other efforts we reduced some headroom there?\n\n**0x00052**\n\nEscalate for 10 USDC\n\nSlight-moderate incorrect slippage controls historically have been graded as medium not high. Seems like there is still ongoing discussion about this issue, but medium seems appropriate if deemed valid.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> Slight-moderate incorrect slippage controls historically have been graded as medium not high. Seems like there is still ongoing discussion about this issue, but medium seems appropriate if deemed valid.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**dmitriia**\n\nEscalate for 10 USDC\nJust to add another point: this should be open/close simultaneously with #181 as the root issue is the same.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> Just to add another point: this should be open/close simultaneously with #181 as the root issue is the same.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/12",
  "Code": [
    {
      "filename": "src/tokens/ERC5095.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport 'src/tokens/ERC20Permit.sol';\nimport 'src/interfaces/IERC5095.sol';\nimport 'src/interfaces/IRedeemer.sol';\nimport 'src/interfaces/IMarketPlace.sol';\nimport 'src/interfaces/IYield.sol';\nimport 'src/errors/Exception.sol';\nimport 'src/lib/Cast.sol';\nimport 'src/lib/Safe.sol';\n\ncontract ERC5095 is ERC20Permit, IERC5095 {\n    /// @dev unix timestamp when the ERC5095 token can be redeemed\n    uint256 public immutable override maturity;\n    /// @dev address of the ERC20 token that is returned on ERC5095 redemption\n    address public immutable override underlying;\n    /// @dev address of the minting authority\n    address public immutable lender;\n    /// @dev address of the \"marketplace\" YieldSpace AMM router\n    address public immutable marketplace;\n    ///@dev Interface to interact with the pool\n    address public immutable pool;\n\n    /// @dev address and interface for an external custody contract (necessary for some project's backwards compatability)\n    address public immutable redeemer;\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Exception(0, 0, 0, msg.sender, a);\n        }\n        _;\n    }\n\n    constructor(\n        address _underlying,\n        uint256 _maturity,\n        address _redeemer,\n        address _lender,\n        address _marketplace,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) ERC20Permit(name_, symbol_, decimals_) {\n        underlying = _underlying;\n        maturity = _maturity;\n        redeemer = _redeemer;\n        lender = _lender;\n        marketplace = _marketplace;\n        pool = IMarketPlace(marketplace).pools(underlying, maturity);\n    }\n\n    /// @notice Post or at maturity converts an amount of principal tokens to an amount of underlying that would be returned.\n    /// @param s The amount of principal tokens to convert\n    /// @return uint256 The amount of underlying tokens returned by the conversion\n    function convertToUnderlying(uint256 s)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (block.timestamp < maturity) {\n            return previewRedeem(s);\n        }\n        return s;\n    }\n\n    /// @notice Post or at maturity converts a desired amount of underlying tokens returned to principal tokens needed.\n    /// @param a The amount of underlying tokens to convert\n    /// @return uint256 The amount of principal tokens returned by the conversion\n    function convertToShares(uint256 a)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (block.timestamp < maturity) {\n            return previewWithdraw(a);\n        }\n        return a;\n    }\n\n    /// @notice Post or at maturity returns user's PT balance. Pre maturity, returns a previewRedeem for owner's PT balance.\n    /// @param o The address of the owner for which redemption is calculated\n    /// @return uint256 The maximum amount of principal tokens that `owner` can redeem.\n    function maxRedeem(address o) external view override returns (uint256) {\n        if (block.timestamp < maturity) {\n            return previewRedeem(_balanceOf[o]);\n        }\n        return _balanceOf[o];\n    }\n\n    /// @notice Post or at maturity returns user's PT balance. Pre maturity, returns a previewWithdraw for owner's PT balance.\n    /// @param  o The address of the owner for which withdrawal is calculated\n    /// @return uint256 maximum amount of underlying tokens that `owner` can withdraw.\n    function maxWithdraw(address o) external view override returns (uint256) {\n        if (block.timestamp < maturity) {\n            return previewWithdraw(_balanceOf[address(this)]);\n        }\n        return _balanceOf[o];\n    }\n\n    /// @notice Post or at maturity returns 0. Pre maturity returns the amount of `shares` when spending `assets` in underlying on a YieldSpace AMM.\n    /// @param a The amount of underlying spent\n    /// @return uint256 The amount of PT purchased by spending `assets` of underlying\n    function previewDeposit(uint256 a) public view returns (uint256) {\n        if (block.timestamp < maturity) {\n            return IYield(pool).sellBasePreview(Cast.u128(a));\n        }\n        return 0;\n    }\n\n    /// @notice Post or at maturity returns 0. Pre maturity returns the amount of `assets` in underlying spent on a purchase of `shares` in PT on a YieldSpace AMM.\n    /// @param s the amount of principal tokens bought in the simulation\n    /// @return uint256 The amount of underlying spent to purchase `shares` of PT\n    function previewMint(uint256 s) public view returns (uint256) {\n        if (block.timestamp < maturity) {\n            return IYield(pool).buyFYTokenPreview(Cast.u128(s));\n        }\n        return 0;\n    }\n\n    /// @notice Post or at maturity simulates the effects of redeemption at the current block. Pre maturity returns the amount of `assets from a sale of `shares` in PT from a sale of PT on a YieldSpace AMM.\n    /// @param s the amount of principal tokens redeemed in the simulation\n    /// @return uint256 The amount of underlying returned by `shares` of PT redemption\n    function previewRedeem(uint256 s) public view override returns (uint256) {\n        if (block.timestamp > maturity) {\n            return s;\n        }\n        return IYield(pool).sellFYTokenPreview(Cast.u128(s));\n    }\n\n    /// @notice Post or at maturity simulates the effects of withdrawal at the current block. Pre maturity simulates the amount of `shares` in PT necessary to receive `assets` in underlying from a sale of PT on a YieldSpace AMM.\n    /// @param a the amount of underlying tokens withdrawn in the simulation\n    /// @return uint256 The amount of principal tokens required for the withdrawal of `assets`\n    function previewWithdraw(uint256 a) public view override returns (uint256) {\n        if (block.timestamp > maturity) {\n            return a;\n        }\n        return IYield(pool).buyBasePreview(Cast.u128(a));\n    }\n\n    /// @notice Before maturity spends `assets` of underlying, and sends `shares` of PTs to `receiver`. Post or at maturity, reverts.\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param a The amount of underlying tokens withdrawn\n    /// @return uint256 The amount of principal tokens burnt by the withdrawal\n    function deposit(address r, uint256 a) external override returns (uint256) {\n        if (block.timestamp > maturity) {\n            revert Exception(\n                21,\n                block.timestamp,\n                maturity,\n                address(0),\n                address(0)\n            );\n        }\n        uint128 shares = Cast.u128(previewDeposit(a));\n        Safe.transferFrom(IERC20(underlying), msg.sender, address(this), a);\n        // consider the hardcoded slippage limit, 4626 compliance requires no minimum param.\n        uint128 returned = IMarketPlace(marketplace).sellUnderlying(\n            underlying,\n            maturity,\n            Cast.u128(a),\n            shares - (shares / 100)\n        );\n        _transfer(address(this), r, returned);\n        return returned;\n    }\n\n    /// @notice Before maturity mints `shares` of PTs to `receiver` and spending `assets` of underlying. Post or at maturity, reverts.\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param s The amount of underlying tokens withdrawn\n    /// @return uint256 The amount of principal tokens burnt by the withdrawal\n    function mint(address r, uint256 s) external override returns (uint256) {\n        if (block.timestamp > maturity) {\n            revert Exception(\n                21,\n                block.timestamp,\n                maturity,\n                address(0),\n                address(0)\n            );\n        }\n        uint128 assets = Cast.u128(previewMint(s));\n        Safe.transferFrom(\n            IERC20(underlying),\n            msg.sender,\n            address(this),\n            assets\n        );\n        // consider the hardcoded slippage limit, 4626 compliance requires no minimum param.\n        uint128 returned = IMarketPlace(marketplace).sellUnderlying(\n            underlying,\n            maturity,\n            assets,\n            assets - (assets / 100)\n        );\n        _transfer(address(this), r, returned);\n        return returned;\n    }\n\n    /// @notice At or after maturity, Burns `shares` from `owner` and sends exactly `assets` of underlying tokens to `receiver`. Before maturity, sends `assets` by selling shares of PT on a YieldSpace AMM.\n    /// @param a The amount of underlying tokens withdrawn\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param o The owner of the underlying tokens\n    /// @return uint256 The amount of principal tokens burnt by the withdrawal\n    function withdraw(\n        uint256 a,\n        address r,\n        address o\n    ) external override returns (uint256) {\n        // Pre maturity\n        if (block.timestamp < maturity) {\n            uint128 shares = Cast.u128(previewWithdraw(a));\n            // If owner is the sender, sell PT without allowance check\n            if (o == msg.sender) {\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    shares,\n                    Cast.u128(a - (a / 100))\n                );\n                Safe.transfer(IERC20(underlying), r, returned);\n                return returned;\n                // Else, sell PT with allowance check\n            } else {\n                uint256 allowance = _allowance[o][msg.sender];\n                if (allowance < shares) {\n                    revert Exception(\n                        20,\n                        allowance,\n                        shares,\n                        address(0),\n                        address(0)\n                    );\n                }\n                _allowance[o][msg.sender] = allowance - shares;\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    Cast.u128(shares),\n                    Cast.u128(a - (a / 100))\n                );\n                Safe.transfer(IERC20(underlying), r, returned);\n                return returned;\n            }\n        }\n        // Post maturity\n        else {\n            if (o == msg.sender) {\n                return\n                    IRedeemer(redeemer).authRedeem(\n                        underlying,\n                        maturity,\n                        msg.sender,\n                        r,\n                        a\n                    );\n            } else {\n                uint256 allowance = _allowance[o][msg.sender];\n                if (allowance < a) {\n                    revert Exception(20, allowance, a, address(0), address(0));\n                }\n                _allowance[o][msg.sender] = allowance - a;\n                return\n                    IRedeemer(redeemer).authRedeem(\n                        underlying,\n                        maturity,\n                        o,\n                        r,\n                        a\n                    );\n            }\n        }\n    }\n\n    /// @notice At or after maturity, burns exactly `shares` of Principal Tokens from `owner` and sends `assets` of underlying tokens to `receiver`. Before maturity, sends `assets` by selling `shares` of PT on a YieldSpace AMM.\n    /// @param s The number of shares to be burned in exchange for the underlying asset\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param o Address of the owner of the shares being burned\n    /// @return uint256 The amount of underlying tokens distributed by the redemption\n    function redeem(\n        uint256 s,\n        address r,\n        address o\n    ) external override returns (uint256) {\n        // Pre-maturity\n        if (block.timestamp < maturity) {\n            uint128 assets = Cast.u128(previewRedeem(s));\n            // If owner is the sender, sell PT without allowance check\n            if (o == msg.sender) {\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    Cast.u128(s),\n                    assets - (assets / 100)\n                );\n                Safe.transfer(IERC20(underlying), r, returned);\n                return returned;\n                // Else, sell PT with allowance check\n            } else {\n                uint256 allowance = _allowance[o][msg.sender];\n                if (allowance < s) {\n                    revert Exception(20, allowance, s, address(0), address(0));\n                }\n                _allowance[o][msg.sender] = allowance - s;\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    Cast.u128(s),\n                    assets - (assets / 100)\n                );\n                Safe.transfer(IERC20(underlying), r, returned);\n                return returned;\n            }\n            // Post-maturity\n        } else {\n            if (o == msg.sender) {\n                return\n                    IRedeemer(redeemer).authRedeem(\n                        underlying,\n                        maturity,\n                        msg.sender,\n                        r,\n                        s\n                    );\n            } else {\n                uint256 allowance = _allowance[o][msg.sender];\n                if (allowance < s) {\n                    revert Exception(20, allowance, s, address(0), address(0));\n                }\n                _allowance[o][msg.sender] = allowance - s;\n                return\n                    IRedeemer(redeemer).authRedeem(\n                        underlying,\n                        maturity,\n                        o,\n                        r,\n                        s\n                    );\n            }\n        }\n    }\n\n    /// @param f Address to burn from\n    /// @param a Amount to burn\n    /// @return bool true if successful\n    function authBurn(address f, uint256 a)\n        external\n        authorized(redeemer)\n        returns (bool)\n    {\n        _burn(f, a);\n        return true;\n    }\n\n    /// @param t Address recieving the minted amount\n    /// @param a The amount to mint\n    /// @return bool true if successful\n    function authMint(address t, uint256 a)\n        external\n        authorized(lender)\n        returns (bool)\n    {\n        _mint(t, a);\n        return true;\n    }\n}"
    },
    {
      "filename": "src/tokens/ERC5095.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport 'src/tokens/ERC20Permit.sol';\nimport 'src/interfaces/IERC5095.sol';\nimport 'src/interfaces/IRedeemer.sol';\nimport 'src/interfaces/IMarketPlace.sol';\nimport 'src/interfaces/IYield.sol';\nimport 'src/errors/Exception.sol';\nimport 'src/lib/Cast.sol';\nimport 'src/lib/Safe.sol';\n\ncontract ERC5095 is ERC20Permit, IERC5095 {\n    /// @dev unix timestamp when the ERC5095 token can be redeemed\n    uint256 public immutable override maturity;\n    /// @dev address of the ERC20 token that is returned on ERC5095 redemption\n    address public immutable override underlying;\n    /// @dev address of the minting authority\n    address public immutable lender;\n    /// @dev address of the \"marketplace\" YieldSpace AMM router\n    address public immutable marketplace;\n    ///@dev Interface to interact with the pool\n    address public immutable pool;\n\n    /// @dev address and interface for an external custody contract (necessary for some project's backwards compatability)\n    address public immutable redeemer;\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Exception(0, 0, 0, msg.sender, a);\n        }\n        _;\n    }\n\n    constructor(\n        address _underlying,\n        uint256 _maturity,\n        address _redeemer,\n        address _lender,\n        address _marketplace,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) ERC20Permit(name_, symbol_, decimals_) {\n        underlying = _underlying;\n        maturity = _maturity;\n        redeemer = _redeemer;\n        lender = _lender;\n        marketplace = _marketplace;\n        pool = IMarketPlace(marketplace).pools(underlying, maturity);\n    }\n\n    /// @notice Post or at maturity converts an amount of principal tokens to an amount of underlying that would be returned.\n    /// @param s The amount of principal tokens to convert\n    /// @return uint256 The amount of underlying tokens returned by the conversion\n    function convertToUnderlying(uint256 s)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (block.timestamp < maturity) {\n            return previewRedeem(s);\n        }\n        return s;\n    }\n\n    /// @notice Post or at maturity converts a desired amount of underlying tokens returned to principal tokens needed.\n    /// @param a The amount of underlying tokens to convert\n    /// @return uint256 The amount of principal tokens returned by the conversion\n    function convertToShares(uint256 a)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (block.timestamp < maturity) {\n            return previewWithdraw(a);\n        }\n        return a;\n    }\n\n    /// @notice Post or at maturity returns user's PT balance. Pre maturity, returns a previewRedeem for owner's PT balance.\n    /// @param o The address of the owner for which redemption is calculated\n    /// @return uint256 The maximum amount of principal tokens that `owner` can redeem.\n    function maxRedeem(address o) external view override returns (uint256) {\n        if (block.timestamp < maturity) {\n            return previewRedeem(_balanceOf[o]);\n        }\n        return _balanceOf[o];\n    }\n\n    /// @notice Post or at maturity returns user's PT balance. Pre maturity, returns a previewWithdraw for owner's PT balance.\n    /// @param  o The address of the owner for which withdrawal is calculated\n    /// @return uint256 maximum amount of underlying tokens that `owner` can withdraw.\n    function maxWithdraw(address o) external view override returns (uint256) {\n        if (block.timestamp < maturity) {\n            return previewWithdraw(_balanceOf[address(this)]);\n        }\n        return _balanceOf[o];\n    }\n\n    /// @notice Post or at maturity returns 0. Pre maturity returns the amount of `shares` when spending `assets` in underlying on a YieldSpace AMM.\n    /// @param a The amount of underlying spent\n    /// @return uint256 The amount of PT purchased by spending `assets` of underlying\n    function previewDeposit(uint256 a) public view returns (uint256) {\n        if (block.timestamp < maturity) {\n            return IYield(pool).sellBasePreview(Cast.u128(a));\n        }\n        return 0;\n    }\n\n    /// @notice Post or at maturity returns 0. Pre maturity returns the amount of `assets` in underlying spent on a purchase of `shares` in PT on a YieldSpace AMM.\n    /// @param s the amount of principal tokens bought in the simulation\n    /// @return uint256 The amount of underlying spent to purchase `shares` of PT\n    function previewMint(uint256 s) public view returns (uint256) {\n        if (block.timestamp < maturity) {\n            return IYield(pool).buyFYTokenPreview(Cast.u128(s));\n        }\n        return 0;\n    }\n\n    /// @notice Post or at maturity simulates the effects of redeemption at the current block. Pre maturity returns the amount of `assets from a sale of `shares` in PT from a sale of PT on a YieldSpace AMM.\n    /// @param s the amount of principal tokens redeemed in the simulation\n    /// @return uint256 The amount of underlying returned by `shares` of PT redemption\n    function previewRedeem(uint256 s) public view override returns (uint256) {\n        if (block.timestamp > maturity) {\n            return s;\n        }\n        return IYield(pool).sellFYTokenPreview(Cast.u128(s));\n    }\n\n    /// @notice Post or at maturity simulates the effects of withdrawal at the current block. Pre maturity simulates the amount of `shares` in PT necessary to receive `assets` in underlying from a sale of PT on a YieldSpace AMM.\n    /// @param a the amount of underlying tokens withdrawn in the simulation\n    /// @return uint256 The amount of principal tokens required for the withdrawal of `assets`\n    function previewWithdraw(uint256 a) public view override returns (uint256) {\n        if (block.timestamp > maturity) {\n            return a;\n        }\n        return IYield(pool).buyBasePreview(Cast.u128(a));\n    }\n\n    /// @notice Before maturity spends `assets` of underlying, and sends `shares` of PTs to `receiver`. Post or at maturity, reverts.\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param a The amount of underlying tokens withdrawn\n    /// @return uint256 The amount of principal tokens burnt by the withdrawal\n    function deposit(address r, uint256 a) external override returns (uint256) {\n        if (block.timestamp > maturity) {\n            revert Exception(\n                21,\n                block.timestamp,\n                maturity,\n                address(0),\n                address(0)\n            );\n        }\n        uint128 shares = Cast.u128(previewDeposit(a));\n        Safe.transferFrom(IERC20(underlying), msg.sender, address(this), a);\n        // consider the hardcoded slippage limit, 4626 compliance requires no minimum param.\n        uint128 returned = IMarketPlace(marketplace).sellUnderlying(\n            underlying,\n            maturity,\n            Cast.u128(a),\n            shares - (shares / 100)\n        );\n        _transfer(address(this), r, returned);\n        return returned;\n    }\n\n    /// @notice Before maturity mints `shares` of PTs to `receiver` and spending `assets` of underlying. Post or at maturity, reverts.\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param s The amount of underlying tokens withdrawn\n    /// @return uint256 The amount of principal tokens burnt by the withdrawal\n    function mint(address r, uint256 s) external override returns (uint256) {\n        if (block.timestamp > maturity) {\n            revert Exception(\n                21,\n                block.timestamp,\n                maturity,\n                address(0),\n                address(0)\n            );\n        }\n        uint128 assets = Cast.u128(previewMint(s));\n        Safe.transferFrom(\n            IERC20(underlying),\n            msg.sender,\n            address(this),\n            assets\n        );\n        // consider the hardcoded slippage limit, 4626 compliance requires no minimum param.\n        uint128 returned = IMarketPlace(marketplace).sellUnderlying(\n            underlying,\n            maturity,\n            assets,\n            assets - (assets / 100)\n        );\n        _transfer(address(this), r, returned);\n        return returned;\n    }\n\n    /// @notice At or after maturity, Burns `shares` from `owner` and sends exactly `assets` of underlying tokens to `receiver`. Before maturity, sends `assets` by selling shares of PT on a YieldSpace AMM.\n    /// @param a The amount of underlying tokens withdrawn\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param o The owner of the underlying tokens\n    /// @return uint256 The amount of principal tokens burnt by the withdrawal\n    function withdraw(\n        uint256 a,\n        address r,\n        address o\n    ) external override returns (uint256) {\n        // Pre maturity\n        if (block.timestamp < maturity) {\n            uint128 shares = Cast.u128(previewWithdraw(a));\n            // If owner is the sender, sell PT without allowance check\n            if (o == msg.sender) {\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    shares,\n                    Cast.u128(a - (a / 100))\n                );\n                Safe.transfer(IERC20(underlying), r, returned);\n                return returned;\n                // Else, sell PT with allowance check\n            } else {\n                uint256 allowance = _allowance[o][msg.sender];\n                if (allowance < shares) {\n                    revert Exception(\n                        20,\n                        allowance,\n                        shares,\n                        address(0),\n                        address(0)\n                    );\n                }\n                _allowance[o][msg.sender] = allowance - shares;\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    Cast.u128(shares),\n                    Cast.u128(a - (a / 100))\n                );\n                Safe.transfer(IERC20(underlying), r, returned);\n                return returned;\n            }\n        }\n        // Post maturity\n        else {\n            if (o == msg.sender) {\n                return\n                    IRedeemer(redeemer).authRedeem(\n                        underlying,\n                        maturity,\n                        msg.sender,\n                        r,\n                        a\n                    );\n            } else {\n                uint256 allowance = _allowance[o][msg.sender];\n                if (allowance < a) {\n                    revert Exception(20, allowance, a, address(0), address(0));\n                }\n                _allowance[o][msg.sender] = allowance - a;\n                return\n                    IRedeemer(redeemer).authRedeem(\n                        underlying,\n                        maturity,\n                        o,\n                        r,\n                        a\n                    );\n            }\n        }\n    }\n\n    /// @notice At or after maturity, burns exactly `shares` of Principal Tokens from `owner` and sends `assets` of underlying tokens to `receiver`. Before maturity, sends `assets` by selling `shares` of PT on a YieldSpace AMM.\n    /// @param s The number of shares to be burned in exchange for the underlying asset\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param o Address of the owner of the shares being burned\n    /// @return uint256 The amount of underlying tokens distributed by the redemption\n    function redeem(\n        uint256 s,\n        address r,\n        address o\n    ) external override returns (uint256) {\n        // Pre-maturity\n        if (block.timestamp < maturity) {\n            uint128 assets = Cast.u128(previewRedeem(s));\n            // If owner is the sender, sell PT without allowance check\n            if (o == msg.sender) {\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    Cast.u128(s),\n                    assets - (assets / 100)\n                );\n                Safe.transfer(IERC20(underlying), r, returned);\n                return returned;\n                // Else, sell PT with allowance check\n            } else {\n                uint256 allowance = _allowance[o][msg.sender];\n                if (allowance < s) {\n                    revert Exception(20, allowance, s, address(0), address(0));\n                }\n                _allowance[o][msg.sender] = allowance - s;\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    Cast.u128(s),\n                    assets - (assets / 100)\n                );\n                Safe.transfer(IERC20(underlying), r, returned);\n                return returned;\n            }\n            // Post-maturity\n        } else {\n            if (o == msg.sender) {\n                return\n                    IRedeemer(redeemer).authRedeem(\n                        underlying,\n                        maturity,\n                        msg.sender,\n                        r,\n                        s\n                    );\n            } else {\n                uint256 allowance = _allowance[o][msg.sender];\n                if (allowance < s) {\n                    revert Exception(20, allowance, s, address(0), address(0));\n                }\n                _allowance[o][msg.sender] = allowance - s;\n                return\n                    IRedeemer(redeemer).authRedeem(\n                        underlying,\n                        maturity,\n                        o,\n                        r,\n                        s\n                    );\n            }\n        }\n    }\n\n    /// @param f Address to burn from\n    /// @param a Amount to burn\n    /// @return bool true if successful\n    function authBurn(address f, uint256 a)\n        external\n        authorized(redeemer)\n        returns (bool)\n    {\n        _burn(f, a);\n        return true;\n    }\n\n    /// @param t Address recieving the minted amount\n    /// @param a The amount to mint\n    /// @return bool true if successful\n    function authMint(address t, uint256 a)\n        external\n        authorized(lender)\n        returns (bool)\n    {\n        _mint(t, a);\n        return true;\n    }\n}"
    },
    {
      "filename": "src/tokens/ERC5095.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport 'src/tokens/ERC20Permit.sol';\nimport 'src/interfaces/IERC5095.sol';\nimport 'src/interfaces/IRedeemer.sol';\nimport 'src/interfaces/IMarketPlace.sol';\nimport 'src/interfaces/IYield.sol';\nimport 'src/errors/Exception.sol';\nimport 'src/lib/Cast.sol';\nimport 'src/lib/Safe.sol';\n\ncontract ERC5095 is ERC20Permit, IERC5095 {\n    /// @dev unix timestamp when the ERC5095 token can be redeemed\n    uint256 public immutable override maturity;\n    /// @dev address of the ERC20 token that is returned on ERC5095 redemption\n    address public immutable override underlying;\n    /// @dev address of the minting authority\n    address public immutable lender;\n    /// @dev address of the \"marketplace\" YieldSpace AMM router\n    address public immutable marketplace;\n    ///@dev Interface to interact with the pool\n    address public immutable pool;\n\n    /// @dev address and interface for an external custody contract (necessary for some project's backwards compatability)\n    address public immutable redeemer;\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Exception(0, 0, 0, msg.sender, a);\n        }\n        _;\n    }\n\n    constructor(\n        address _underlying,\n        uint256 _maturity,\n        address _redeemer,\n        address _lender,\n        address _marketplace,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) ERC20Permit(name_, symbol_, decimals_) {\n        underlying = _underlying;\n        maturity = _maturity;\n        redeemer = _redeemer;\n        lender = _lender;\n        marketplace = _marketplace;\n        pool = IMarketPlace(marketplace).pools(underlying, maturity);\n    }\n\n    /// @notice Post or at maturity converts an amount of principal tokens to an amount of underlying that would be returned.\n    /// @param s The amount of principal tokens to convert\n    /// @return uint256 The amount of underlying tokens returned by the conversion\n    function convertToUnderlying(uint256 s)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (block.timestamp < maturity) {\n            return previewRedeem(s);\n        }\n        return s;\n    }\n\n    /// @notice Post or at maturity converts a desired amount of underlying tokens returned to principal tokens needed.\n    /// @param a The amount of underlying tokens to convert\n    /// @return uint256 The amount of principal tokens returned by the conversion\n    function convertToShares(uint256 a)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (block.timestamp < maturity) {\n            return previewWithdraw(a);\n        }\n        return a;\n    }\n\n    /// @notice Post or at maturity returns user's PT balance. Pre maturity, returns a previewRedeem for owner's PT balance.\n    /// @param o The address of the owner for which redemption is calculated\n    /// @return uint256 The maximum amount of principal tokens that `owner` c"
    }
  ]
}