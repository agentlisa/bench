{
  "Title": "Inconsistent transaction expiry",
  "Content": "Within the [`executeTransaction` function](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/bridges/BaseBridgeReceiver.sol#L175) from the `Timelock` contract, a transaction is considered valid and will be executed as long as the transaction block’s timestamp is *less than or equal* to `eta + GRACE_PERIOD`. However, the [`BaseBridgeReciever` contract](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/vendor/Timelock.sol#L82) only considers a transaction valid if the transaction block’s timestamp is instead *strictly less than* that same calculation.\n\n\nConsider updating the contracts’ logic to agree on the expiration of a transaction.\n\n\n***Update:** Resolved in [pull request 666](https://github.com/compound-finance/comet/pull/666/) at commit [fcb9ef3](https://github.com/compound-finance/comet/pull/666/commits/fcb9ef3241503d209a76178d205a2dd6b4fd876f).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/bridges/BaseBridgeReceiver.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.15;\n\nimport \"../ITimelock.sol\";\n\ncontract BaseBridgeReceiver {\n    /** Custom errors **/\n    error AlreadyInitialized();\n    error BadData();\n    error InvalidProposalId();\n    error ProposalNotQueued();\n    error TransactionAlreadyQueued();\n    error Unauthorized();\n\n    /** Events **/\n    event Initialized(address indexed govTimelock, address indexed localTimelock);\n    event NewLocalTimelock(address indexed oldLocalTimelock, address indexed newLocalTimelock);\n    event NewGovTimelock(address indexed oldGovTimelock, address indexed newGovTimelock);\n    event ProposalCreated(address indexed messageSender, uint id, address[] targets, uint[] values, string[] signatures, bytes[] calldatas, uint eta);\n    event ProposalExecuted(uint id);\n\n    /** Public variables **/\n\n    /// @notice Address of the governing contract that this bridge receiver expects to\n    ///  receive messages from; likely an address from another chain (e.g. mainnet)\n    address public govTimelock;\n\n    /// @notice Address of the timelock on this chain that the bridge receiver\n    /// will send messages to\n    address public localTimelock;\n\n    /// @notice Whether contract has been initialized\n    bool public initialized;\n\n    /// @notice Total count of proposals generated\n    uint public proposalCount;\n\n    struct Proposal {\n        uint id;\n        address[] targets;\n        uint[] values;\n        string[] signatures;\n        bytes[] calldatas;\n        uint eta;\n        bool executed;\n    }\n\n    /// @notice Mapping of proposal ids to their full proposal data\n    mapping (uint => Proposal) public proposals;\n\n    enum ProposalState {\n        Queued,\n        Expired,\n        Executed\n    }\n\n    /**\n     * @notice Initialize the contract\n     * @param _govTimelock Address of the governing contract that this contract\n     * will receive messages from (likely on another chain)\n     * @param _localTimelock Address of the timelock contract that this contract\n     * will send messages to\n     */\n    function initialize(address _govTimelock, address _localTimelock) external {\n        if (initialized) revert AlreadyInitialized();\n        govTimelock = _govTimelock;\n        localTimelock = _localTimelock;\n        initialized = true;\n        emit Initialized(_govTimelock, _localTimelock);\n    }\n\n    /**\n     * @notice Accept admin role for the localTimelock\n     */\n    function acceptLocalTimelockAdmin() external {\n        if (msg.sender != localTimelock) revert Unauthorized();\n        ITimelock(localTimelock).acceptAdmin();\n    }\n\n    /**\n     * @notice Set localTimelock address\n     * @param newTimelock Address to set as the localTimelock\n     */\n    function setLocalTimelock(address newTimelock) public {\n        if (msg.sender != localTimelock) revert Unauthorized();\n        address oldLocalTimelock = localTimelock;\n        localTimelock = newTimelock;\n        emit NewLocalTimelock(oldLocalTimelock, newTimelock);\n    }\n\n    /**\n     * @notice Set govTimelock address\n     * @param newTimelock Address to set as the govTimelock\n     */\n    function setGovTimelock(address newTimelock) public {\n        if (msg.sender != localTimelock) revert Unauthorized();\n        address oldGovTimelock = govTimelock;\n        govTimelock = newTimelock;\n        emit NewGovTimelock(oldGovTimelock, newTimelock);\n    }\n\n    /**\n     * @notice Process a message sent from the governing timelock (across a bridge)\n     * @param messageSender Address of the contract that sent the bridged message\n     * @param data ABI-encoded bytes containing the transactions to be queued on the local timelock\n     */\n    function processMessage(\n        address messageSender,\n        bytes calldata data\n    ) internal {\n        if (messageSender != govTimelock) revert Unauthorized();\n\n        address[] memory targets;\n        uint256[] memory values;\n        string[] memory signatures;\n        bytes[] memory calldatas;\n\n        (targets, values, signatures, calldatas) = abi.decode(\n            data,\n            (address[], uint256[], string[], bytes[])\n        );\n\n        if (values.length != targets.length) revert BadData();\n        if (signatures.length != targets.length) revert BadData();\n        if (calldatas.length != targets.length) revert BadData();\n\n        uint delay = ITimelock(localTimelock).delay();\n        uint eta = block.timestamp + delay;\n\n        for (uint8 i = 0; i < targets.length; ) {\n            if (ITimelock(localTimelock).queuedTransactions(keccak256(abi.encode(targets[i], values[i], signatures[i], calldatas[i], eta)))) revert TransactionAlreadyQueued();\n            ITimelock(localTimelock).queueTransaction(targets[i], values[i], signatures[i], calldatas[i], eta);\n            unchecked { i++; }\n        }\n\n        proposalCount++;\n        Proposal memory proposal = Proposal({\n            id: proposalCount,\n            targets: targets,\n            values: values,\n            signatures: signatures,\n            calldatas: calldatas,\n            eta: eta,\n            executed: false\n        });\n\n        proposals[proposal.id] = proposal;\n        emit ProposalCreated(messageSender, proposal.id, targets, values, signatures, calldatas, eta);\n    }\n\n    /**\n     * @notice Execute a queued proposal\n     * @param proposalId The id of the proposal to execute\n     */\n    function executeProposal(uint proposalId) external {\n        if (state(proposalId) != ProposalState.Queued) revert ProposalNotQueued();\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n        for (uint i = 0; i < proposal.targets.length; i++) {\n            ITimelock(localTimelock).executeTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n        }\n        emit ProposalExecuted(proposalId);\n    }\n\n    /**\n     * @notice Get the state of a proposal\n     * @param proposalId Id of the proposal\n     * @return The state of the given proposal (queued, expired or executed)\n     */\n    function state(uint proposalId) public view returns (ProposalState) {\n        if (proposalId > proposalCount || proposalId == 0) revert InvalidProposalId();\n        Proposal memory proposal = proposals[proposalId];\n        if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= (proposal.eta + ITimelock(localTimelock).GRACE_PERIOD())) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n}"
    }
  ]
}