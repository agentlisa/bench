{
  "Title": "[M01] Malicious actors can lock all FEI and TRIBE in the GenesisGroup",
  "Content": "The [`GenesisGroup` contract](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/genesis/GenesisGroup.sol#L141) calculates whether or not the `maxGenesisPrice` has been reached using [`address(this).balance`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/genesis/GenesisGroup.sol#L143). While this balance is usually indicative of how much ETH has been deposited using the [`purchase` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/genesis/GenesisGroup.sol#L80), malicious actors can increase the contract’s ETH balance directly using `selfdestruct`. Performing a `selfdestruct` allows the attacker to bypass the [checks](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/genesis/GenesisGroup.sol#L80-L82) and [token minting](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/genesis/GenesisGroup.sol#L84) performed in an execution of `purchase`, merely altering the balance directly.\n\n\nWhile incredibly unlikely, if an attacker were to `selfdestruct` enough ETH into the `GenesisGroup` for the contract to reach the `maxGenesisPrice`, they could call [`launch`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/genesis/GenesisGroup.sol#L105) to bootstrap the protocol while leaving the `FGEN.totalSupply` at 0. With 0 `FGEN` in existence, no users would be able to exeucte [`redeem`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/genesis/GenesisGroup.sol#L89) to extract the `FEI` and `TRIBE` balances from the contract, leaving them locked inside. If an attacker instead deposited a smaller amount of ETH using `selfdestruct`, they would cause each valid contributor to receive more `FEI` and `TRIBE` than they were intended to receive.\n\n\nWhile such an attack has no clear motivation, it can still affect the state of the system. Consider performing price calculations using `FGEN.totalSupply` instead of `address(this).balance` in both [`isAtMaxPrice`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/genesis/GenesisGroup.sol#L143) and [`launch`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/genesis/GenesisGroup.sol#L110-L111) so that a `selfdestruct` would not affect the system.\n\n\n**Update:** *Not fixed. In the words of the Fei team: “Did not fix because it is an obscure vector which is pure self-inflicted loss”.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/genesis/GenesisGroup.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./IGenesisGroup.sol\";\nimport \"./IDOInterface.sol\";\nimport \"../utils/Timed.sol\";\nimport \"../refs/CoreRef.sol\";\nimport \"../pool/IPool.sol\";\nimport \"../oracle/IBondingCurveOracle.sol\";\nimport \"../bondingcurve/IBondingCurve.sol\";\n\ninterface IOrchestrator {\n\tfunction launchGovernance() external;\n\tfunction pool() external returns(address);\n\tfunction bondingCurveOracle() external returns(address);\n}\n\n/// @title IGenesisGroup implementation\n/// @author Fei Protocol\ncontract GenesisGroup is IGenesisGroup, CoreRef, ERC20, ERC20Burnable, Timed {\n\tusing Decimal for Decimal.D256;\n\n\tIOrchestrator private orchestrator;\n\n\tIBondingCurve private bondingcurve;\n\n\tIBondingCurveOracle private bondingCurveOracle;\n\n\tIPool private pool;\n\n\tIDOInterface private ido;\n\tuint private exchangeRateDiscount;\n\n\t/// @notice a cap on the genesis group purchase price\n\tDecimal.D256 public maxGenesisPrice;\n\n\t/// @notice GenesisGroup constructor\n\t/// @param _core Fei Core address to reference\n\t/// @param _bondingcurve Bonding curve address for purchase\n\t/// @param _ido IDO contract to deploy\n\t/// @param _oracle Bonding curve oracle\n\t/// @param _pool Staking Pool\n\t/// @param _duration duration of the Genesis Period\n\t/// @param _maxPriceBPs max price of FEI allowed in Genesis Group in dollar terms\n\t/// @param _exchangeRateDiscount a divisor on the FEI/TRIBE ratio at Genesis to deploy to the IDO\n\tconstructor(\n\t\taddress _core, \n\t\taddress _bondingcurve,\n\t\taddress _ido,\n\t\taddress _oracle,\n\t\taddress _pool,\n\t\tuint32 _duration,\n\t\tuint _maxPriceBPs,\n\t\tuint _exchangeRateDiscount\n\t) public\n\t\tCoreRef(_core)\n\t\tERC20(\"Fei Genesis Group\", \"FGEN\")\n\t\tTimed(_duration)\n\t{\n\t\tbondingcurve = IBondingCurve(_bondingcurve);\n\n\t\texchangeRateDiscount = _exchangeRateDiscount;\n\t\tido = IDOInterface(_ido);\n\n\t\tpool = IPool(_pool);\n\t\tbondingCurveOracle = IBondingCurveOracle(_oracle);\n\n\t\t_initTimed();\n\n\t\tmaxGenesisPrice = Decimal.ratio(_maxPriceBPs, 10000);\n\t}\n\n\tmodifier onlyGenesisPeriod() {\n\t\trequire(!isTimeEnded(), \"GenesisGroup: Not in Genesis Period\");\n\t\t_;\n\t}\n\n\tfunction purchase(address to, uint value) external override payable onlyGenesisPeriod {\n\t\trequire(msg.value == value, \"GenesisGroup: value mismatch\");\n\t\trequire(value != 0, \"GenesisGroup: no value sent\");\n\n\t\t_mint(to, value);\n\n\t\temit Purchase(to, value);\n\t}\n\n\tfunction redeem(address to) external override postGenesis {\n\t\tDecimal.D256 memory ratio = _fgenRatio(to);\n\t\trequire(!ratio.equals(Decimal.zero()), \"GensisGroup: No balance to redeem\");\n\n\t\tuint amountIn = balanceOf(to);\n\t\tburnFrom(to, amountIn);\n\n\t\tuint feiAmount = ratio.mul(feiBalance()).asUint256();\n\t\tfei().transfer(to, feiAmount);\n\n\t\tuint tribeAmount = ratio.mul(tribeBalance()).asUint256();\n\t\ttribe().transfer(to, tribeAmount);\n\n\t\temit Redeem(to, amountIn, feiAmount, tribeAmount);\n\t}\n\n\tfunction launch() external override {\n\t\trequire(isTimeEnded() || isAtMaxPrice(), \"GenesisGroup: Still in Genesis Period\");\n\n\t\tcore().completeGenesisGroup();\n\n\t\taddress genesisGroup = address(this);\n\t\tuint balance = genesisGroup.balance;\n\n\t\tbondingCurveOracle.init(bondingcurve.getAveragePrice(balance));\n\n\t\tbondingcurve.purchase{value: balance}(genesisGroup, balance);\n\t\tbondingcurve.allocate();\n\n\t\tpool.init();\n\n\t\tido.deploy(_feiTribeExchangeRate());\n\n\t\t// solhint-disable-next-line not-rely-on-time\n\t\temit Launch(now);\n\t}\n\n\tfunction getAmountOut(\n\t\tuint amountIn, \n\t\tbool inclusive\n\t) public view override returns (uint feiAmount, uint tribeAmount) {\n\t\tuint totalIn = totalSupply();\n\t\tif (!inclusive) {\n\t\t\ttotalIn += amountIn;\n\t\t}\n\t\trequire(amountIn <= totalIn, \"GenesisGroup: Not enough supply\");\n\n\t\tuint totalFei = bondingcurve.getAmountOut(totalIn);\n\t\tuint totalTribe = tribeBalance();\n\n\t\treturn (totalFei * amountIn / totalIn, totalTribe * amountIn / totalIn);\n\t}\n\n\tfunction isAtMaxPrice() public view override returns(bool) {\n\t\tuint balance = address(this).balance;\n\t\trequire(balance != 0, \"GenesisGroup: No balance\");\n\n\t\treturn bondingcurve.getAveragePrice(balance).greaterThanOrEqualTo(maxGenesisPrice);\n\t}\n\n\tfunction burnFrom(address account, uint amount) public override {\n\t\t// Sender doesn't need approval\n\t\tif (msg.sender == account) {\n\t\t\tincreaseAllowance(account, amount);\n\t\t}\n\t\tsuper.burnFrom(account, amount);\n\t}\n\n\tfunction _fgenRatio(address account) internal view returns (Decimal.D256 memory) {\n\t\treturn Decimal.ratio(balanceOf(account), totalSupply());\n\t}\n\n\tfunction _feiTribeExchangeRate() public view returns (Decimal.D256 memory) {\n\t\treturn Decimal.ratio(feiBalance(), tribeBalance()).div(exchangeRateDiscount);\n\t}\n}"
    },
    {
      "filename": "contracts/genesis/GenesisGroup.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./IGenesisGroup.sol\";\nimport \"./IDOInterface.sol\";\nimport \"../utils/Timed.sol\";\nimport \"../refs/CoreRef.sol\";\nimport \"../pool/IPool.sol\";\nimport \"../oracle/IBondingCurveOracle.sol\";\nimport \"../bondingcurve/IBondingCurve.sol\";\n\ninterface IOrchestrator {\n\tfunction launchGovernance() external;\n\tfunction pool() external returns(address);\n\tfunction bondingCurveOracle() external returns(address);\n}\n\n/// @title IGenesisGroup implementation\n/// @author Fei Protocol\ncontract GenesisGroup is IGenesisGroup, CoreRef, ERC20, ERC20Burnable, Timed {\n\tusing Decimal for Decimal.D256;\n\n\tIOrchestrator private orchestrator;\n\n\tIBondingCurve private bondingcurve;\n\n\tIBondingCurveOracle private bondingCurveOracle;\n\n\tIPool private pool;\n\n\tIDOInterface private ido;\n\tuint private exchangeRateDiscount;\n\n\t/// @notice a cap on the genesis group purchase price\n\tDecimal.D256 public maxGenesisPrice;\n\n\t/// @notice GenesisGroup constructor\n\t/// @param _core Fei Core address to reference\n\t/// @param _bondingcurve Bonding curve address for purchase\n\t/// @param _ido IDO contract to deploy\n\t/// @param _oracle Bonding curve oracle\n\t/// @param _pool Staking Pool\n\t/// @param _duration duration of the Genesis Period\n\t/// @param _maxPriceBPs max price of FEI allowed in Genesis Group in dollar terms\n\t/// @param _exchangeRateDiscount a divisor on the FEI/TRIBE ratio at Genesis to deploy to the IDO\n\tconstructor(\n\t\taddress _core, \n\t\taddress _bondingcurve,\n\t\taddress _ido,\n\t\taddress _oracle,\n\t\taddress _pool,\n\t\tuint32 _duration,\n\t\tuint _maxPriceBPs,\n\t\tuint _exchangeRateDiscount\n\t) public\n\t\tCoreRef(_core)\n\t\tERC20(\"Fei Genesis Group\", \"FGEN\")\n\t\tTimed(_duration)\n\t{\n\t\tbondingcurve = IBondingCurve(_bondingcurve);\n\n\t\texchangeRateDiscount = _exchangeRateDiscount;\n\t\tido = IDOInterface(_ido);\n\n\t\tpool = IPool(_pool);\n\t\tbondingCurveOracle = IBondingCurveOracle(_oracle);\n\n\t\t_initTimed();\n\n\t\tmaxGenesisPrice = Decimal.ratio(_maxPriceBPs, 10000);\n\t}\n\n\tmodifier onlyGenesisPeriod() {\n\t\trequire(!isTimeEnded(), \"GenesisGroup: Not in Genesis Period\");\n\t\t_;\n\t}\n\n\tfunction purchase(address to, uint value) external override payable onlyGenesisPeriod {\n\t\trequire(msg.value == value, \"GenesisGroup: value mismatch\");\n\t\trequire(value != 0, \"GenesisGroup: no value sent\");\n\n\t\t_mint(to, value);\n\n\t\temit Purchase(to, value);\n\t}\n\n\tfunction redeem(address to) external override postGenesis {\n\t\tDecimal.D256 memory ratio = _fgenRatio(to);\n\t\trequire(!ratio.equals(Decimal.zero()), \"GensisGroup: No balance to redeem\");\n\n\t\tuint amountIn = balanceOf(to);\n\t\tburnFrom(to, amountIn);\n\n\t\tuint feiAmount = ratio.mul(feiBalance()).asUint256();\n\t\tfei().transfer(to, feiAmount);\n\n\t\tuint tribeAmount = ratio.mul(tribeBalance()).asUint256();\n\t\ttribe().transfer(to, tribeAmount);\n\n\t\temit Redeem(to, amountIn, feiAmount, tribeAmount);\n\t}\n\n\tfunction launch() external override {\n\t\trequire(isTimeEnded() || isAtMaxPrice(), \"GenesisGroup: Still in Genesis Period\");\n\n\t\tcore().completeGenesisGroup();\n\n\t\taddress genesisGroup = address(this);\n\t\tuint balance = genesisGroup.balance;\n\n\t\tbondingCurveOracle.init(bondingcurve.getAveragePrice(balance));\n\n\t\tbondingcurve.purchase{value: balance}(genesisGroup, balance);\n\t\tbondingcurve.allocate();\n\n\t\tpool.init();\n\n\t\tido.deploy(_feiTribeExchangeRate());\n\n\t\t// solhint-disable-next-line not-rely-on-time\n\t\temit Launch(now);\n\t}\n\n\tfunction getAmountOut(\n\t\tuint amountIn, \n\t\tbool inclusive\n\t) public view override returns (uint feiAmount, uint tribeAmount) {\n\t\tuint totalIn = totalSupply();\n\t\tif (!inclusive) {\n\t\t\ttotalIn += amountIn;\n\t\t}\n\t\trequire(amountIn <= totalIn, \"GenesisGroup: Not enough supply\");\n\n\t\tuint totalFei = bondingcurve.getAmountOut(totalIn);\n\t\tuint totalTribe = tribeBalance();\n\n\t\treturn (totalFei * amountIn / totalIn, totalTribe * amountIn / totalIn);\n\t}\n\n\tfunction isAtMaxPrice() public view override returns(bool) {\n\t\tuint balance = address(this).balance;\n\t\trequire(balance != 0, \"GenesisGroup: No balance\");\n\n\t\treturn bondingcurve.getAveragePrice(balance).greaterThanOrEqualTo(maxGenesisPrice);\n\t}\n\n\tfunction burnFrom(address account, uint amount) public override {\n\t\t// Sender doesn't need approval\n\t\tif (msg.sender == account) {\n\t\t\tincreaseAllowance(account, amount);\n\t\t}\n\t\tsuper.burnFrom(account, amount);\n\t}\n\n\tfunction _fgenRatio(address account) internal view returns (Decimal.D256 memory) {\n\t\treturn Decimal.ratio(balanceOf(account), totalSupply());\n\t}\n\n\tfunction _feiTribeExchangeRate() public view returns (Decimal.D256 memory) {\n\t\treturn Decimal.ratio(feiBalance(), tribeBalance()).div(exchangeRateDiscount);\n\t}\n}"
    },
    {
      "filename": "contracts/genesis/GenesisGroup.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./IGenesisGroup.sol\";\nimport \"./IDOInterface.sol\";\nimport \"../utils/Timed.sol\";\nimport \"../refs/CoreRef.sol\";\nimport \"../pool/IPool.sol\";\nimport \"../oracle/IBondingCurveOracle.sol\";\nimport \"../bondingcurve/IBondingCurve.sol\";\n\ninterface IOrchestrator {\n\tfunction launchGovernance() external;\n\tfunction pool() external returns(address);\n\tfunction bondingCurveOracle() external returns(address);\n}\n\n/// @title IGenesisGroup implementation\n/// @author Fei Protocol\ncontract GenesisGroup is IGenesisGroup, CoreRef, ERC20, ERC20Burnable, Timed {\n\tusing Decimal for Decimal.D256;\n\n\tIOrchestrator private orchestrator;\n\n\tIBondingCurve private bondingcurve;\n\n\tIBondingCurveOracle private bondingCurveOracle;\n\n\tIPool private pool;\n\n\tIDOInterface private ido;\n\tuint private exchangeRateDiscount;\n\n\t/// @notice a cap on the genesis group purchase price\n\tDecimal.D256 public maxGenesisPrice;\n\n\t/// @notice GenesisGroup constructor\n\t/// @param _core Fei Core address to reference\n\t/// @param _bondingcurve Bonding curve address for purchase\n\t/// @param _ido IDO contract to deploy\n\t/// @param _oracle Bonding curve oracle\n\t/// @param _pool Staking Pool\n\t/// @param _duration duration of the Genesis Period\n\t/// @param _maxPriceBPs max price of FEI allowed in Genesis Group in dollar terms\n\t/// @param _exchangeRateDiscount a divisor on the FEI/TRIBE ratio at Genesis to deploy to the IDO\n\tconstructor(\n\t\taddress _core, \n\t\taddress _bondingcurve,\n\t\taddress _ido,\n\t\taddress _oracle,\n\t\taddress _pool,\n\t\tuint32 _duration,\n\t\tuint _maxPriceBPs,\n\t\tuint _exchangeRateDiscount\n\t) public\n\t\tCoreRef(_core)\n\t\tERC20(\"Fei Genesis Group\", \"FGEN\")\n\t\tTimed(_duration)\n\t{\n\t\tbondingcurve = IBondingCurve(_bondingcurve);\n\n\t\texchangeRateDiscount = _exchangeRateDiscount;\n\t\tido = IDOInterface(_ido);\n\n\t\tpool = IPool(_pool);\n\t\tbondingCurveOracle = IBondingCurveOracle(_oracle);\n\n\t\t_initTimed();\n\n\t\tmaxGenesisPrice = Decimal.ratio(_maxPriceBPs, 10000);\n\t}\n\n\tmodifier onlyGenesisPeriod() {\n\t\trequire(!isTimeEnded(), \"GenesisGroup: Not in Genesis Period\");\n\t\t_;\n\t}\n\n\tfunction purchase(address to, uint value) external override payable onlyGenesisPeriod {\n\t\trequire(msg.value == value, \"GenesisGroup: value mismatch\");\n\t\trequire(value != 0, \"GenesisGroup: no value sent\");\n\n\t\t_mint(to, value);\n\n\t\temit Purchase(to, value);\n\t}\n\n\tfunction redeem(address to) external override postGenesis {\n\t\tDecimal.D256 memory ratio = _fgenRatio(to);\n\t\trequire(!ratio.equals(Decimal.zero()), \"GensisGroup: No balance to redeem\");\n\n\t\tuint amountIn = balanceOf(to);\n\t\tburnFrom(to, amountIn);\n\n\t\tuint feiAmount = ratio.mul(feiBalance()).asUint256();\n\t\tfei().transfer(to, feiAmount);\n\n\t\tuint tribeAmount = ratio.mul(tribeBalance()).asUint256();\n\t\ttribe().transfer(to, tribeAmount);\n\n\t\temit Redeem(to, amountIn, feiAmount, tribeAmount);\n\t}\n\n\tfunction launch() external override {\n\t\trequire(isTimeEnded() || isAtMaxPrice(), \"GenesisGroup: Still in Genesis Period\");\n\n\t\tcore().completeGenesisGroup();\n\n\t\taddress genesisGroup = address(this);\n\t\tuint balance = genesisGroup.balance;\n\n\t\tbondingCurveOracle.init(bondingcurve.getAveragePrice(balance));\n\n\t\tbondingcurve.purchase{value: balance}(genesisGroup, balance);\n\t\tbondingcurve.allocate();\n\n\t\tpool.init();\n\n\t\tido.deploy(_feiTribeExchangeRate());\n\n\t\t// solhint-disable-next-line not-rely-on-time\n\t\temit Launch(now);\n\t}\n\n\tfunction getAmountOut(\n\t\tuint amountIn, \n\t\tbool inclusive\n\t) public view override returns (uint feiAmount, uint tribeAmount) {\n\t\tuint totalIn = totalSupply();\n\t\tif (!inclusive) {\n\t\t\ttotalIn += amountIn;\n\t\t}\n\t\trequire(amountIn <= totalIn, \"GenesisGroup: Not enough supply\");\n\n\t\tuint totalFei = bondingcurve.getAmountOut(totalIn);\n\t\tuint totalTribe = tribeBalance();\n\n\t\treturn (totalFei * amountIn / totalIn, totalTribe * amountIn / totalIn);\n\t}\n\n\tfunction isAtMaxPrice() public view override returns(bool) {\n\t\tuint balance = address(this).balance;\n\t\trequire(balance != 0, \"GenesisGroup: No balance\");\n\n\t\treturn bondingcurve.getAveragePrice(balance).greaterThanOrEqualTo(maxGenesisPrice);\n\t}\n\n\tfunction burnFrom(address account, uint amount) public override {\n\t\t// Sender doesn't need approval\n\t\tif (msg.sender == account) {\n\t\t\tincreaseAllowance(account, amount);\n\t\t}\n\t\tsuper.burnFrom(account, amount);\n\t}\n\n\tfunction _fgenRatio(address account) internal view returns (Decimal.D256 memory) {\n\t\treturn Decimal.ratio(balanceOf(account), totalSupply());\n\t}\n\n\tfunction _feiTribeExchangeRate() public view returns (Decimal.D256 memory) {\n\t\treturn Decimal.ratio(feiBalance(), tribeBalance()).div(exchangeRateDiscount);\n\t}\n}"
    }
  ]
}