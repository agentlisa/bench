{
  "Title": "[L04] Unnecessary event emission after replay of reporter invalidation",
  "Content": "The sole reporter of the `UniswapAnchoredView` contract can be permanently invalidated calling the [`invalidateReporter` function](https://github.com/compound-finance/open-oracle/blob/d0a0d0301bff08457d9dfc5861080d3124d079cd/contracts/Uniswap/UniswapAnchoredView.sol#L258), as long as a valid message (signed by the reporter) is provided. Upon success, the function [sets the `reporterInvalidated` flag to `true`](https://github.com/compound-finance/open-oracle/blob/d0a0d0301bff08457d9dfc5861080d3124d079cd/contracts/Uniswap/UniswapAnchoredView.sol#L262), and [emits a `ReporterInvalidated` event](https://github.com/compound-finance/open-oracle/blob/d0a0d0301bff08457d9dfc5861080d3124d079cd/contracts/Uniswap/UniswapAnchoredView.sol#L263). However, it must be noted that anyone can replay a successful call to the `invalidateReporter` function, even if the `reporterInvalidated` flag is already `true`. In this scenario, successful calls will unnecessarily emit the `ReporterInvalidated` event every time.\n\n\nFollowing the “fail early” principle, and to avoid unnecessary event emissions that may cause confusion in off-chain clients tracking them, consider reverting any call to the `invalidateReporter` function once the `reporterInvalidated` flag has been set to `true`.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Uniswap/UniswapAnchoredView.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.6.10;\npragma experimental ABIEncoderV2;\n\nimport \"../OpenOraclePriceData.sol\";\nimport \"./UniswapConfig.sol\";\nimport \"./UniswapLib.sol\";\n\nstruct Observation {\n    uint timestamp;\n    uint acc;\n}\n\ncontract UniswapAnchoredView is UniswapConfig {\n    using FixedPoint for *;\n\n    /// @notice The Open Oracle Price Data contract\n    OpenOraclePriceData public immutable priceData;\n\n    /// @notice the Open Oracle Reporter\n    address public immutable reporter;\n\n    /// @notice The highest ratio of the new median price to the anchor price that will still trigger the median price to be updated\n    uint public immutable upperBoundAnchorRatio;\n\n    /// @notice The lowest ratio of the new median price to the anchor price that will still trigger the median price to be updated\n    uint public immutable lowerBoundAnchorRatio;\n\n    /// @notice The minimum amount of time required for the old uniswap price accumulator to be replaced\n    uint public immutable anchorPeriod;\n\n    /// @notice Official prices by symbol hash\n    mapping(bytes32 => uint) public prices;\n\n    /// @notice Circuit breaker for using anchor price oracle directly, ignoring reporter\n    bool public reporterInvalidated;\n\n    /// @notice The old observation for each uniswap market\n    mapping(address => Observation) public oldObservations;\n    /// @notice The new observation for each uniswap market\n    mapping(address => Observation) public newObservations;\n\n    /// @notice The event emitted when the stored price is updated\n    event PriceUpdated(string symbol, uint price);\n\n    /// @notice The event emitted when new prices are posted but the stored price is not updated due to the anchor\n    event PriceGuarded(string symbol, uint reporter, uint anchor);\n\n    /// @notice The event emitted when reporter invalidates itself\n    event ReporterInvalidated(address reporter);\n\n    /// @notice The event emitted when the uniswap window changes\n    event UniswapWindowUpdate(address indexed uniswapMarket, uint oldTimestamp, uint newTimestamp, uint oldPrice, uint newPrice);\n\n    /// @notice The event emitted when anchor price is updated\n    event AnchorPriceUpdate(address indexed uniswapMarket, uint anchorPrice, uint nowCumulativePrice, uint oldCumulativePrice, uint oldTimestamp);\n\n    bytes32 constant ethHash = keccak256(abi.encodePacked(\"ETH\"));\n    bytes32 constant rotateHash = keccak256(abi.encodePacked(\"rotate\"));\n\n    /**\n     * @notice Construct a uniswap anchored view for a set of token configurations\n     * @param reporter_ The reporter whose prices are to be used\n     * @param anchorToleranceMantissa_ The percentage tolerance that the reporter may deviate from the uniswap anchor\n     * @param anchorPeriod_ The minimum amount of time required for the old uniswap price accumulator to be replaced\n     */\n    constructor(OpenOraclePriceData priceData_,\n                address reporter_,\n                uint anchorToleranceMantissa_,\n                uint anchorPeriod_,\n                TokenConfig[] memory configs) UniswapConfig(configs) public {\n        priceData = priceData_;\n        reporter = reporter_;\n        anchorPeriod = anchorPeriod_;\n\n        require(anchorToleranceMantissa_ < 100e16, \"anchor tolerance is too high\");\n        upperBoundAnchorRatio = 100e16 + anchorToleranceMantissa_;\n        lowerBoundAnchorRatio = 100e16 - anchorToleranceMantissa_;\n\n        for (uint i = 0; i < configs.length; i++) {\n            TokenConfig memory config = configs[i];\n            address uniswapMarket = config.uniswapMarket;\n            if (config.priceSource == PriceSource.REPORTER) {\n                require(uniswapMarket != address(0), \"reported prices must have an anchor\");\n                uint cumulativePrice = currentCumulativePrice(config);\n                oldObservations[uniswapMarket].timestamp = block.timestamp;\n                newObservations[uniswapMarket].timestamp = block.timestamp;\n                oldObservations[uniswapMarket].acc = cumulativePrice;\n                newObservations[uniswapMarket].acc = cumulativePrice;\n            } else {\n                require(uniswapMarket == address(0), \"only reported prices utilize an anchor\");\n            }\n        }\n    }\n\n    /**\n     * @notice Get the official price for a symbol\n     * @param symbol The symbol to fetch the price of\n     * @return Price denominated in USD, with 6 decimals\n     */\n    function price(string memory symbol) public view returns (uint) {\n        TokenConfig memory config = getTokenConfigBySymbol(symbol);\n        return priceInternal(config);\n    }\n\n    function priceInternal(TokenConfig memory config) internal view returns (uint) {\n        if (config.priceSource == PriceSource.REPORTER) return prices[config.symbolHash];\n        if (config.priceSource == PriceSource.FIXED_USD) return config.fixedPrice;\n        if (config.priceSource == PriceSource.FIXED_ETH) {\n            uint usdPerEth = prices[ethHash];\n            require(usdPerEth > 0, \"ETH price not set, cannot convert to dollars\");\n            return mul(usdPerEth, config.fixedPrice) / config.baseUnit;\n        }\n    }\n\n    /**\n     * @notice Get the underlying price of a cToken\n     * @dev Implements the PriceOracle interface for Compound v2.\n     * @param cToken The cToken address for price retrieval\n     * @return The price for the given cToken address\n     */\n    function getUnderlyingPrice(address cToken) public view returns (uint) {\n        TokenConfig memory config = getTokenConfigByCToken(cToken);\n        return mul(1e30, priceInternal(config)) / config.baseUnit;\n    }\n\n    /**\n     * @notice Post open oracle reporter prices, and recalculate stored price by comparing to anchor\n     * @dev We let anyone pay to post anything, but only prices from configured reporter will be stored in the view.\n     * @param messages The messages to post to the oracle\n     * @param signatures The signatures for the corresponding messages\n     * @param symbols The symbols to compare to anchor for authoritative reading\n     */\n    function postPrices(bytes[] calldata messages, bytes[] calldata signatures, string[] calldata symbols) external {\n        require(messages.length == signatures.length, \"messages and signatures must be 1:1\");\n\n        // Save the prices\n        for (uint i = 0; i < messages.length; i++) {\n            priceData.put(messages[i], signatures[i]);\n        }\n\n        uint ethPrice = fetchEthPrice();\n\n        // Try to update the view storage\n        for (uint i = 0; i < symbols.length; i++) {\n            TokenConfig memory config = getTokenConfigBySymbol(symbols[i]);\n            string memory symbol = symbols[i];\n            bytes32 symbolHash = keccak256(abi.encodePacked(symbol));\n            if (source(messages[i], signatures[i]) != reporter) continue;\n\n            uint reporterPrice = priceData.getPrice(reporter, symbol);\n            uint anchorPrice;\n            if (symbolHash == ethHash) {\n                anchorPrice = ethPrice;\n            } else {\n                anchorPrice = fetchAnchorPrice(config, ethPrice);\n            }\n\n            if (reporterInvalidated == true) {\n                prices[symbolHash] = anchorPrice;\n                emit PriceUpdated(symbol, anchorPrice);\n            } else if (isWithinAnchor(reporterPrice, anchorPrice)) {\n                prices[symbolHash] = reporterPrice;\n                emit PriceUpdated(symbol, reporterPrice);\n            } else {\n                emit PriceGuarded(symbol, reporterPrice, anchorPrice);\n            }\n        }\n    }\n\n    function isWithinAnchor(uint reporterPrice, uint anchorPrice) internal view returns (bool) {\n        if (reporterPrice > 0) {\n            uint anchorRatio = mul(anchorPrice, 100e16) / reporterPrice;\n            return anchorRatio <= upperBoundAnchorRatio && anchorRatio >= lowerBoundAnchorRatio;\n        }\n        return false;\n    }\n\n    /**\n     * @dev Fetches the current token/eth price accumulator from uniswap.\n     */\n    function currentCumulativePrice(TokenConfig memory config) internal view returns (uint) {\n        (uint cumulativePrice0, uint cumulativePrice1,) = UniswapV2OracleLibrary.currentCumulativePrices(config.uniswapMarket);\n        if (config.isUniswapReversed) {\n            return cumulativePrice1;\n        } else {\n            return cumulativePrice0;\n        }\n    }\n\n    /**\n     * @dev Fetches the current eth/usd price from unsiwap, with 6 decimals of precision.\n     *  Conversion factor is 1e18 for eth/usdc market, since we decode uniswap price statically with 18 decimals.\n     */\n    function fetchEthPrice() internal returns (uint) {\n        return fetchAnchorPrice(getTokenConfigBySymbolHash(ethHash), 1e18);\n    }\n\n    /**\n     * @dev Fetches the current token/usd price from uniswap, with 6 decimals of precision.\n     */\n    function fetchAnchorPrice(TokenConfig memory config, uint conversionFactor) internal virtual returns (uint) {\n        (uint nowCumulativePrice, uint oldCumulativePrice, uint oldTimestamp) = pokeWindowValues(config);\n\n        // This should be impossible, but better safe than sorry\n        require(block.timestamp > oldTimestamp, \"now must come after before\");\n        uint timeElapsed = block.timestamp - oldTimestamp;\n\n        // Calculate uniswap time-weighted average price\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(uint224((nowCumulativePrice - oldCumulativePrice) / timeElapsed));\n        uint anchorPriceUnscaled = mul(priceAverage.decode112with18(), conversionFactor);\n        uint anchorPrice;\n\n        // Adjust anchor price to val * 1e6 decimals format\n        if (config.isUniswapReversed) {\n            anchorPrice = anchorPriceUnscaled / config.baseUnit;\n        } else {\n            anchorPrice = mul(anchorPriceUnscaled, config.baseUnit) / 1e36;\n        }\n\n        emit AnchorPriceUpdate(config.uniswapMarket, anchorPrice, nowCumulativePrice, oldCumulativePrice, oldTimestamp);\n\n        return anchorPrice;\n    }\n\n    /**\n     * @dev Get time-weighted average prices for a token at the current timestamp.\n     *  Update new and old observations of lagging window if period elapsed.\n     */\n    function pokeWindowValues(TokenConfig memory config) internal returns (uint, uint, uint) {\n        address uniswapMarket = config.uniswapMarket;\n        uint cumulativePrice = currentCumulativePrice(config);\n\n        Observation storage newObservation = newObservations[uniswapMarket];\n        Observation storage oldObservation = oldObservations[uniswapMarket];\n\n        // Update new and old observations if elapsed time is greater than or equal to anchor period\n        uint timeElapsed = block.timestamp - newObservation.timestamp;\n        if (timeElapsed >= anchorPeriod) {\n            emit UniswapWindowUpdate(uniswapMarket, oldObservation.timestamp, newObservation.timestamp, oldObservation.acc, newObservation.acc);\n            oldObservation.timestamp = newObservation.timestamp;\n            oldObservation.acc = newObservation.acc;\n\n            newObservation.timestamp = block.timestamp;\n            newObservation.acc = cumulativePrice;\n        }\n        return (cumulativePrice, oldObservation.acc, oldObservation.timestamp);\n    }\n\n    /**\n     * @notice Invalidate the reporter, and fall back to using anchor directly in all cases\n     * @dev Only the reporter may sign a message which allows it to invalidate itself.\n     *  To be used in cases of emergency, if the reporter thinks their key may be compromised.\n     * @param message The data that was presumably signed\n     * @param signature The fingerprint of the data + private key\n     */\n    function invalidateReporter(bytes memory message, bytes memory signature) external {\n        (string memory decoded_message, ) = abi.decode(message, (string, address));\n        require(keccak256(abi.encodePacked(decoded_message)) == rotateHash, \"invalid message must be 'rotate'\");\n        require(source(message, signature) == reporter, \"invalidation message must come from the reporter\");\n        reporterInvalidated = true;\n        emit ReporterInvalidated(reporter);\n    }\n\n    /**\n     * @notice Recovers the source address which signed a message\n     * @dev Comparing to a claimed address would add nothing,\n     *  as the caller could simply perform the recover and claim that address.\n     * @param message The data that was presumably signed\n     * @param signature The fingerprint of the data + private key\n     * @return The source address which signed the message, presumably\n     */\n    function source(bytes memory message, bytes memory signature) public pure returns (address) {\n        (bytes32 r, bytes32 s, uint8 v) = abi.decode(signature, (bytes32, bytes32, uint8));\n        bytes32 hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", keccak256(message)));\n        return ecrecover(hash, v, r, s);\n    }\n\n    /// @dev Overflow proof multiplication\n    function mul(uint a, uint b) internal pure returns (uint) {\n        if (a == 0) return 0;\n        uint c = a * b;\n        require(c / a == b, \"multiplication overflow\");\n        return c;\n    }\n}"
    }
  ]
}