{
  "Title": "M-6: Loss of funds during user adjusting",
  "Content": "# Issue M-6: Loss of funds during user adjusting \n\nSource: https://github.com/sherlock-audit/2023-06-tokensoft-judging/issues/195 \n\n## Found by \n0xMAKEOUTHILL, Yuki\n## Summary\n\nAdjusting a user's total claimable value not working correctly\n\n## Vulnerability Detail\n\nWhenever the owner is adjusting user's total claimable value, the `records[beneficiary].total` is decreased or increased by `uint256 diff = uint256(amount > 0 ? amount : -amount);`.\n\nHowever some assumptions made are not correct. **Scenario**: \n\n1. User has bought 200 FOO tokens for example.\n2. In `PriceTierVestingSale_2_0.sol` he calls the `initializeDistributionRecord` which sets his `records[beneficiary].total` to the purchased amount || 200. So **records[beneficiary].total = 200**\n3. After that the owner decides to adjust his `records[beneficiary].total` to 300. So **records[beneficiary].total = 300**\n4. User decides to claim his claimable amount which should be equal to 300. He calls the `claim` function in `PriceTierVestingSale_2_0.sol`.\n\n```solidity\nfunction claim(\n    address beneficiary // the address that will receive tokens\n  ) external validSaleParticipant(beneficiary) nonReentrant {\n    uint256 claimableAmount = getClaimableAmount(beneficiary);\n    uint256 purchasedAmount = getPurchasedAmount(beneficiary);\n\n    // effects\n    uint256 claimedAmount = super._executeClaim(beneficiary, purchasedAmount);\n\n    // interactions\n    super._settleClaim(beneficiary, claimedAmount);\n  }\n```\nAs we can see here the `_executeClaim` is called with the `purchasedAmount` of the user which is still 200.\n\n```solidity\nfunction _executeClaim(\n    address beneficiary,\n    uint256 _totalAmount\n  ) internal virtual returns (uint256) {\n    uint120 totalAmount = uint120(_totalAmount);\n\n    // effects\n    if (records[beneficiary].total != totalAmount) {\n      // re-initialize if the total has been updated\n      _initializeDistributionRecord(beneficiary, totalAmount);\n    }\n    \n    uint120 claimableAmount = uint120(getClaimableAmount(beneficiary));\n    require(claimableAmount > 0, 'Distributor: no more tokens claimable right now');\n\n    records[beneficiary].claimed += claimableAmount;\n    claimed += claimableAmount;\n\n    return claimableAmount;\n  }\n```\n\nNow check the `if` statement: \n\n```solidity\n if (records[beneficiary].total != totalAmount) {\n      // re-initialize if the total has been updated\n      _initializeDistributionRecord(beneficiary, totalAmount);\n    }\n\n```\n\nThe point of this is if the `total` of the user has been adjusted, to re-initialize to the corresponding amount, but since it's updated by the input value which is 200, **records[beneficiary].total = 200** , the user will lose the 100 added from the owner during the `adjust`\n\n## Impact\n\nLoss of funds for the user and the protocol\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-tokensoft/blob/main/contracts/contracts/claim/PriceTierVestingSale_2_0.sol#L75-L109\n\nhttps://github.com/sherlock-audit/2023-06-tokensoft/blob/main/contracts/contracts/claim/abstract/AdvancedDistributor.sol#L105-L131\n\nhttps://github.com/sherlock-audit/2023-06-tokensoft/blob/main/contracts/contracts/claim/abstract/Distributor.sol#L66-L84\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nI am not sure if it is enough to just set it the following way:\n\n```solidity\n if (records[beneficiary].total != totalAmount) {\n      // re-initialize if the total has been updated\n      `--` _initializeDistributionRecord(beneficiary, totalAmount);\n     `++` _initializeDistributionRecord(beneficiary, records[beneficiary].total);\n    }\n\n```\n\nThink of different scenarios if it is done that way and also keep in mind that the same holds for the decrease of `records[beneficiary].total` by `adjust`\n\n\n\n## Discussion\n\n**MAKEOUTHILL6**\n\nEscalate\nI think this issue is wrongly excluded as judge thinks it's a type of an admin error. However I believe it should be addressed, because the functionality of this `adjust` function is broken for `PriceTierVestingSale_2_0.sol` regardless of any admin actions taken. The function just doesn't work right and as intended.\n\n**sherlock-admin2**\n\n > Escalate\n> I think this issue is wrongly excluded as judge thinks it's a type of an admin error. However I believe it should be addressed, because the functionality of this `adjust` function is broken for `PriceTierVestingSale_2_0.sol` regardless of any admin actions taken. The function just doesn't work right and as intended.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Shogoki**\n\nI do not think the adjust function is intended to be called for the PriceTierVestingSale Distributor, as it does not really make a lot of sense imho.\nThat is why i think it is an admin error if it is called for this kind of Distributor.\n\n**cr-walker**\n\n@Shogoki - Alas, I think this is a valid issue because we might want to adjust distributors that refer to sales.\n\nReal world use cases:\n* A user participated in a sale but shouldn't have: their distribution record needs to be adjusted downward\n* A user participated in a sale and complains a lot about the project: adjust their distribution record upward\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nConsidering this a valid medium based on the issue and Sponsor comments\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [MAKEOUTHILL6](https://github.com/sherlock-audit/2023-06-tokensoft-judging/issues/195/#issuecomment-1670816225): accepted\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/100",
  "Code": [
    {
      "filename": "contracts/contracts/claim/PriceTierVestingSale_2_0.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { SafeERC20 } from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport { AggregatorV3Interface } from '@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol';\n\nimport { DistributionRecord } from '../interfaces/IDistributor.sol';\nimport { PriceTierVesting, PriceTier } from './abstract/PriceTierVesting.sol';\nimport { MerkleSet } from './abstract/MerkleSet.sol';\nimport { FlatPriceSale } from '../sale/v2/FlatPriceSale.sol';\n\ncontract PriceTierVestingSale_2_0 is PriceTierVesting {\n  FlatPriceSale public immutable sale;\n  uint256 public immutable price;\n  uint8 public immutable soldTokenDecimals;\n\n  modifier validSaleParticipant(address beneficiary) {\n    require(sale.buyerTotal(beneficiary) != 0, 'no purchases found');\n\n    _;\n  }\n\n  constructor(\n    FlatPriceSale _sale, // where the purchase occurred\n    IERC20 _token, // the purchased token\n    uint8 _soldTokenDecimals, // the number of decimals used by the purchased token\n    // the price of the purchased token denominated in the sale's base currency with 8 decimals\n    // e.g. if the sale was selling $FOO at $0.55 per token, price = 55000000\n    uint256 _price,\n    // when price tier vesting opens (seconds past epoch)\n    uint256 _start,\n    // when price tier vesting ends (seconds past epoch) and all tokens are unlocked\n    uint256 _end,\n    // source for pricing info\n    AggregatorV3Interface _oracle,\n    PriceTier[] memory priceTiers, // vesting PriceTiers\n    uint256 _voteFactor, // the factor for voting power in basis points (e.g. 15000 means users have a 50% voting bonus for unclaimed tokens)\n    string memory _uri // information on the sale (e.g. merkle proofs)\n  )\n    PriceTierVesting(\n      _token,\n      (_sale.total() * 10 ** _soldTokenDecimals) / _price,\n      _uri,\n      _voteFactor,\n      _start,\n      _end,\n      _oracle,\n      priceTiers,\n      0, // no delay\n      0 // no salt\n    )\n  {\n    require(address(_sale) != address(0), 'sale is address(0)');\n\n    // previously deployed v2.0 sales did not implement the isOver() method\n    (, , , , , , uint256 endTime, , ) = _sale.config();\n    require(endTime < block.timestamp, 'sale not over yet');\n    require(_price != 0, 'price is 0');\n\n    sale = _sale;\n    soldTokenDecimals = _soldTokenDecimals;\n    price = _price;\n  }\n\n  function NAME() external pure virtual override returns (string memory) {\n    return 'PriceTierVestingSale_2_0';\n  }\n\n  // File specific version - starts at 1, increments on every solidity diff\n  function VERSION() external pure virtual override returns (uint256) {\n    return 3;\n  }\n\n  function getPurchasedAmount(address buyer) public view returns (uint256) {\n    /**\n    Get the quantity purchased from the sale and convert it to native tokens\n  \n    Example: if a user buys $1.11 of a FOO token worth $0.50 each, the purchased amount will be 2.22 FOO\n    - buyer total: 111000000 ($1.11 with 8 decimals)\n    - decimals: 6 (the token being purchased has 6 decimals)\n    - price: 50000000 ($0.50 with 8 decimals)\n\n    Calculation: 111000000 * 1000000 / 50000000\n\n    Returns purchased amount: 2220000 (2.22 with 6 decimals)\n    */\n    return (sale.buyerTotal(buyer) * (10 ** soldTokenDecimals)) / price;\n  }\n\n  function initializeDistributionRecord(\n    address beneficiary // the address that will receive tokens\n  ) external validSaleParticipant(beneficiary) {\n    _initializeDistributionRecord(beneficiary, getPurchasedAmount(beneficiary));\n  }\n\n  function claim(\n    address beneficiary // the address that will receive tokens\n  ) external validSaleParticipant(beneficiary) nonReentrant {\n    uint256 claimableAmount = getClaimableAmount(beneficiary);\n    uint256 purchasedAmount = getPurchasedAmount(beneficiary);\n\n    // effects\n    uint256 claimedAmount = super._executeClaim(beneficiary, purchasedAmount);\n\n    // interactions\n    super._settleClaim(beneficiary, claimedAmount);\n  }\n\n  function getDistributionRecord(\n    address beneficiary\n  ) external view virtual override returns (DistributionRecord memory) {\n    DistributionRecord memory record = records[beneficiary];\n\n    // workaround prior to initialization\n    if (!record.initialized) {\n      record.total = uint120(getPurchasedAmount(beneficiary));\n    }\n    return record;\n  }\n\n  // get the number of tokens currently claimable by a specific user\n  function getClaimableAmount(address beneficiary) public view override returns (uint256) {\n    if (records[beneficiary].initialized) return super.getClaimableAmount(beneficiary);\n\n    // we can get the claimable amount prior to initialization\n    return\n      (getPurchasedAmount(beneficiary) * getVestedFraction(beneficiary, block.timestamp)) /\n      fractionDenominator;\n  }\n}"
    },
    {
      "filename": "contracts/contracts/claim/abstract/AdvancedDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport { ERC20Votes, ERC20Permit, ERC20 } from '@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol';\nimport { SafeERC20 } from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport { Distributor, DistributionRecord, IERC20 } from './Distributor.sol';\nimport { IAdjustable } from '../../interfaces/IAdjustable.sol';\nimport { IVoting } from '../../interfaces/IVoting.sol';\nimport { Sweepable } from '../../utilities/Sweepable.sol';\nimport { FairQueue } from '../../utilities/FairQueue.sol';\n\n/**\n * @title AdvancedDistributor\n * @notice Distributes tokens to beneficiaries with voting-while-vesting and administrative controls.\n * The contract owner can control these distribution parameters:\n * - the merkle root determining all distribution details\n * - adjustments to specific distributions\n * - the token being distributed\n * - the total amount to distribute\n * - the metadata URI\n * - the voting power of undistributed tokens\n * - the recipient of swept funds\n *\n * This contract also allows owners to perform several other admin functions\n * - updating the contract owner\n * - sweeping tokens and native currency to a recipient\n *\n * This contract tracks beneficiary voting power through an internal ERC20Votes token that cannot be transferred. The\n * beneficiary must delegate to an address to use this voting power. Their voting power decreases when the token is claimed.\n *\n * @dev Updates to the contract must follow these constraints:\n * - If a merkle root update alters the total token quantity to distribute across all users, also adjust the total value.\n *   The DistributionRecord for each beneficiary updated in the merkle root will be incorrect until a claim is executed.\n * - If the total changes, make sure to add or withdraw tokens being distributed to match the new total.\n */\nabstract contract AdvancedDistributor is\n  Ownable,\n  Sweepable,\n  ERC20Votes,\n  Distributor,\n  IAdjustable,\n  IVoting,\n  FairQueue\n{\n  using SafeERC20 for IERC20;\n\n  uint256 private voteFactor;\n\n  constructor(\n    IERC20 _token,\n    uint256 _total,\n    string memory _uri,\n    uint256 _voteFactor,\n    uint256 _fractionDenominator,\n    uint160 maxDelayTime,\n    uint160 salt\n  )\n    Distributor(_token, _total, _uri, _fractionDenominator)\n    ERC20Permit('Internal vote tracker')\n    ERC20('Internal vote tracker', 'IVT')\n    Sweepable(payable(msg.sender))\n    FairQueue(maxDelayTime, salt)\n  {\n    voteFactor = _voteFactor;\n    emit SetVoteFactor(voteFactor);\n  }\n\n  /**\n   * convert a token quantity to a vote quantity\n   */\n  function tokensToVotes(uint256 tokenAmount) private view returns (uint256) {\n    return (tokenAmount * voteFactor) / fractionDenominator;\n  }\n\n  function _initializeDistributionRecord(\n    address beneficiary,\n    uint256 totalAmount\n  ) internal virtual override {\n    super._initializeDistributionRecord(beneficiary, totalAmount);\n\n    // add voting power through ERC20Votes extension\n    _mint(beneficiary, tokensToVotes(totalAmount));\n  }\n\n  function _executeClaim(\n    address beneficiary,\n    uint256 totalAmount\n  ) internal virtual override returns (uint256 _claimed) {\n    _claimed = super._executeClaim(beneficiary, totalAmount);\n\n    // reduce voting power through ERC20Votes extension\n    _burn(beneficiary, tokensToVotes(_claimed));\n  }\n\n  /**\n   * @dev Adjust the quantity claimable by a user, overriding the value in the distribution record.\n   *\n   * Note: If used in combination with merkle proofs, adjustments to a beneficiary's total could be\n   * reset by anyone to the value in the merkle leaf at any time. Update the merkle root instead.\n   *\n   * Amount is limited to type(uint120).max to allow each DistributionRecord to be packed into a single storage slot.\n   */\n  function adjust(address beneficiary, int256 amount) external onlyOwner {\n    DistributionRecord memory distributionRecord = records[beneficiary];\n    require(distributionRecord.initialized, 'must initialize before adjusting');\n\n    uint256 diff = uint256(amount > 0 ? amount : -amount);\n    require(diff < type(uint120).max, 'adjustment > max uint120');\n\n    if (amount < 0) {\n      // decreasing claimable tokens\n      require(total >= diff, 'decrease greater than distributor total');\n      require(distributionRecord.total >= diff, 'decrease greater than distributionRecord total');\n      total -= diff;\n      records[beneficiary].total -= uint120(diff);\n      token.safeTransfer(owner(), diff);\n      // reduce voting power\n      _burn(beneficiary, tokensToVotes(diff));\n    } else {\n      // increasing claimable tokens\n      total += diff;\n      records[beneficiary].total += uint120(diff);\n      // increase voting pwoer\n      _mint(beneficiary, tokensToVotes(diff));\n    }\n\n    emit Adjust(beneficiary, amount);\n  }\n\n\n  function _setToken(IERC20 _token) internal virtual {\n    require(address(_token) != address(0), 'token is address(0)');\n    token = _token;\n    emit SetToken(token);\n  }\n\n  // Set the token being distributed\n  function setToken(IERC20 _token) external virtual onlyOwner {\n    _setToken(_token);\n  }\n\n  function _setTotal(uint256 _total) internal virtual {\n    total = _total;\n    emit SetTotal(total);\n  }\n\n  // Set the total to distribute\n  function setTotal(uint256 _total) external virtual onlyOwner {\n    _setTotal(_total);\n  }\n\n  // Set the distributor metadata URI\n  function setUri(string memory _uri) external onlyOwner {\n    uri = _uri;\n    emit SetUri(uri);\n  }\n\n  // set the recipient of swept funds\n  function setSweepRecipient(address payable _recipient) external onlyOwner {\n    _setSweepRecipient(_recipient);\n  }\n\n  function getTotalVotes() external view returns (uint256) {\n    // supply of internal token used to track voting power\n    return totalSupply();\n  }\n\n  function getVoteFactor(address) external view returns (uint256) {\n    return voteFactor;\n  }\n\n  /**\n\t* @notice Set the voting power of undistributed tokens\n\t* @param _voteFactor The voting power multiplier as a fraction of fractionDenominator\n\t* @dev The vote factor can be any integer. If voteFactor / fractionDenominator == 1,\n\t* one unclaimed token provides one vote. If voteFactor / fractionDenominator == 2, one\n\t* unclaimed token counts as two votes.\n\t*/\n  function setVoteFactor(uint256 _voteFactor) external onlyOwner {\n    voteFactor = _voteFactor;\n    emit SetVoteFactor(voteFactor);\n  }\n\n  /**\n   * @dev the internal token used only for tracking voting power cannot be transferred\n   */\n  function _approve(address, address, uint256) internal pure override {\n    revert('disabled for voting power');\n  }\n\n  /**\n   * @dev the internal token used only f\tor tracking voting power cannot be transferred\n   */\n  function _transfer(address, address, uint256) internal pure override {\n    revert('disabled for voting power');\n  }\n}"
    },
    {
      "filename": "contracts/contracts/claim/abstract/Distributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { SafeERC20 } from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { ReentrancyGuard } from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\n\nimport { IDistributor, DistributionRecord } from '../../interfaces/IDistributor.sol';\n\n/**\n * @title Distributor\n * @notice Distributes funds to beneficiaries and tracks distribution status\n */\nabstract contract Distributor is IDistributor, ReentrancyGuard {\n  using SafeERC20 for IERC20;\n\n  mapping(address => DistributionRecord) internal records; // track distribution records per user\n  IERC20 public token; // the token being claimed\n  uint256 public total; // total tokens allocated for claims\n  uint256 public claimed; // tokens already claimed\n  string public uri; // ipfs link on distributor info\n  uint256 immutable fractionDenominator; // denominator for vesting fraction (e.g. if vested fraction is 100 and fractionDenominator is 10000, 1% of tokens have vested)\n\n  // provide context on the contract name and version\n  function NAME() external view virtual returns (string memory);\n\n  function VERSION() external view virtual returns (uint256);\n\n  constructor(IERC20 _token, uint256 _total, string memory _uri, uint256 _fractionDenominator) {\n    require(address(_token) != address(0), 'Distributor: token is address(0)');\n    require(_total > 0, 'Distributor: total is 0');\n\n    token = _token;\n    total = _total;\n    uri = _uri;\n    fractionDenominator = _fractionDenominator;\n    emit InitializeDistributor(token, total, uri, fractionDenominator);\n  }\n\n  /**\n   * @dev Set up the distribution record for a user. Permissions are not checked in this function.\n   * Amount is limited to type(uint120).max to allow each DistributionRecord to be packed into a single storage slot.\n   * \n   * @param beneficiary The address of the beneficiary\n   * @param _totalAmount The total amount of tokens to be distributed to the beneficiary\n   */\n  function _initializeDistributionRecord(\n    address beneficiary,\n    uint256 _totalAmount\n  ) internal virtual {\n    uint120 totalAmount = uint120(_totalAmount);\n\n    // Checks\n    require(totalAmount <= type(uint120).max, 'Distributor: totalAmount > type(uint120).max');\n\n    // Effects - note that the existing claimed quantity is re-used during re-initialization\n    records[beneficiary] = DistributionRecord(true, totalAmount, records[beneficiary].claimed);\n    emit InitializeDistributionRecord(beneficiary, totalAmount);\n  }\n\n  /**\n   * @notice Record the claim internally:\n   * @dev This function does not check permissions: caller must verify the claim is valid!\n   * this function should not call any untrusted external contracts to avoid reentrancy\n   */\n  function _executeClaim(\n    address beneficiary,\n    uint256 _totalAmount\n  ) internal virtual returns (uint256) {\n    uint120 totalAmount = uint120(_totalAmount);\n\n    // effects\n    if (records[beneficiary].total != totalAmount) {\n      // re-initialize if the total has been updated\n      _initializeDistributionRecord(beneficiary, totalAmount);\n    }\n    \n    uint120 claimableAmount = uint120(getClaimableAmount(beneficiary));\n    require(claimableAmount > 0, 'Distributor: no more tokens claimable right now');\n\n    records[beneficiary].claimed += claimableAmount;\n    claimed += claimableAmount;\n\n    return claimableAmount;\n  }\n\n  /**\n   * @dev Move tokens associated with the claim to the recipient. This function should be called\n   * after the claim has been executed internally to avoid reentrancy issues.\n   * @param _recipient The address of the recipient\n   * @param _amount The amount of tokens to be transferred during this claim\n   */\n  function _settleClaim(address _recipient, uint256 _amount) internal virtual {\n    token.safeTransfer(_recipient, _amount);\n    emit Claim(_recipient, _amount);\n  }\n\n  /// @notice return a distribution record\n  function getDistributionRecord(\n    address beneficiary\n  ) external view virtual returns (DistributionRecord memory) {\n    return records[beneficiary];\n  }\n\n  // Get tokens vested as fraction of fractionDenominator\n  function getVestedFraction(\n    address beneficiary,\n    uint256 time\n  ) public view virtual returns (uint256);\n\n  function getFractionDenominator() public view returns (uint256) {\n    return fractionDenominator;\n  }\n\n  // get the number of tokens currently claimable by a specific use\n  function getClaimableAmount(address beneficiary) public view virtual returns (uint256) {\n    require(records[beneficiary].initialized, 'Distributor: claim not initialized');\n\n    DistributionRecord memory record = records[beneficiary];\n\n    uint256 claimable = (record.total * getVestedFraction(beneficiary, block.timestamp)) /\n      fractionDenominator;\n    return\n      record.claimed >= claimable\n        ? 0 // no more tokens to claim\n        : claimable - record.claimed; // claim all available tokens\n  }\n}"
    }
  ]
}