{
  "Title": "[L-05] Inlined duplicate `_resolveTokenValue` logic",
  "Content": "In [`Dispatcher.sol#L87`](https://github.com/perspectivefi/spectra-core/blob/fec59dc6720fb4861b07b30845ef2c1a42f947bf/src/router/Dispatcher.sol#L87) , there is an inconsistency in how the token value is resolved for the `TRANSFER` command. Unlike other commands that utilize the `_resolveTokenValue` method to handle the `Constants.CONTRACT_BALANCE` special cases, the logic for the `TRANSFER` command is inlined, directly checking and substituting the value. This approach not only duplicates logic but also deviates from the established pattern of using helper methods for value resolution, potentially leading to maintenance issues and inconsistencies in how token values are handled across different commands.\n\nRecommendation: Refactor the `TRANSFER` command execution logic within the `_dispatch` function to utilize the `_resolveTokenValue` method for resolving token values.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/router/Dispatcher.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.20;\n\nimport \"openzeppelin-math/Math.sol\";\nimport \"../libraries/RayMath.sol\";\nimport \"../libraries/CurvePoolUtil.sol\";\nimport \"openzeppelin-contracts-upgradeable/access/manager/AccessManagedUpgradeable.sol\";\nimport {IERC20Permit} from \"openzeppelin-contracts/token/ERC20/extensions/IERC20Permit.sol\";\nimport {IERC4626} from \"openzeppelin-contracts/interfaces/IERC4626.sol\";\nimport {IPrincipalToken} from \"src/interfaces/IPrincipalToken.sol\";\nimport {SafeERC20} from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC3156FlashBorrower} from \"openzeppelin-contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport {IERC3156FlashLender} from \"openzeppelin-contracts/interfaces/IERC3156FlashLender.sol\";\nimport {Commands} from \"./Commands.sol\";\nimport {Constants} from \"./Constants.sol\";\nimport {ICurvePool} from \"../interfaces/ICurvePool.sol\";\nimport {RouterUtil} from \"./util/RouterUtil.sol\";\n\nabstract contract Dispatcher is AccessManagedUpgradeable {\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n    using RayMath for uint256;\n\n    error InvalidCommandType(uint256 commandType);\n    error MinimumBalanceNotReached(\n        address token,\n        address owner,\n        uint256 minimumBalance,\n        uint256 actualBalance\n    );\n    error InvalidTokenIndex(uint256 i, uint256 j);\n    error AddressError();\n\n    address internal msgSender;\n    address public routerUtil;\n\n    function initializeDispatcher(\n        address _routerUtil,\n        address _initialAuthority\n    ) internal initializer {\n        if (_routerUtil == address(0)) {\n            revert AddressError();\n        }\n        routerUtil = _routerUtil;\n        __AccessManaged_init(_initialAuthority);\n    }\n\n    /**\n     * @dev Setter for the router utility contract\n     * @param _newRouterUtil the new address of the router utility contract\n     */\n    function setRouterUtil(address _newRouterUtil) external restricted {\n        if (_newRouterUtil == address(0)) {\n            revert AddressError();\n        }\n        if (_newRouterUtil == routerUtil) {\n            return;\n        }\n        routerUtil = _newRouterUtil;\n    }\n\n    /**\n     * @dev Executes a single command along with its encoded input data\n     * @param _commandType encoded representation of the command\n     * @param _inputs calldata carrying the arguments to the functions that should be called\n     */\n    function _dispatch(bytes1 _commandType, bytes calldata _inputs) internal {\n        uint256 command = uint8(_commandType & Commands.COMMAND_TYPE_MASK);\n\n        if (command == Commands.TRANSFER_FROM) {\n            (address token, uint256 value) = abi.decode(_inputs, (address, uint256));\n            IERC20(token).safeTransferFrom(msgSender, address(this), value);\n        } else if (command == Commands.TRANSFER_FROM_WITH_PERMIT) {\n            (address token, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) = abi\n                .decode(_inputs, (address, uint256, uint256, uint8, bytes32, bytes32));\n            IERC20Permit(token).permit(msgSender, address(this), value, deadline, v, r, s);\n            IERC20(token).safeTransferFrom(msgSender, address(this), value);\n        } else if (command == Commands.TRANSFER) {\n            (address token, address recipient, uint256 value) = abi.decode(\n                _inputs,\n                (address, address, uint256)\n            );\n            recipient = _resolveAddress(recipient);\n            IERC20(token).safeTransfer(\n                recipient,\n                value == Constants.CONTRACT_BALANCE ? IERC20(token).balanceOf(address(this)) : value\n            );\n        } else if (command == Commands.CURVE_SWAP) {\n            (\n                address pool,\n                uint256 i,\n                uint256 j,\n                uint256 amountIn,\n                uint256 minAmountOut,\n                address recipient\n            ) = abi.decode(_inputs, (address, uint256, uint256, uint256, uint256, address));\n            address token = ICurvePool(pool).coins(i);\n            amountIn = _resolveTokenValue(token, amountIn);\n            recipient = _resolveAddress(recipient);\n            _ensureApproved(token, pool, amountIn); // pool.coins(i) is the token to be swapped\n            ICurvePool(pool).exchange(\n                i,\n                j,\n                amountIn,\n                minAmountOut,\n                false, // Do not use ETH\n                recipient\n            );\n        } else if (command == Commands.DEPOSIT_ASSET_IN_IBT) {\n            (address ibt, uint256 assets, address recipient) = abi.decode(\n                _inputs,\n                (address, uint256, address)\n            );\n            address asset = IERC4626(ibt).asset();\n            assets = _resolveTokenValue(asset, assets);\n            recipient = _resolveAddress(recipient);\n            _ensureApproved(asset, ibt, assets);\n            IERC4626(ibt).deposit(assets, recipient);\n        } else if (command == Commands.DEPOSIT_ASSET_IN_PT) {\n            (address pt, uint256 assets, address recipient) = abi.decode(\n                _inputs,\n                (address, uint256, address)\n            );\n            address asset = IPrincipalToken(pt).underlying();\n            assets = _resolveTokenValue(asset, assets);\n            recipient = _resolveAddress(recipient);\n            _ensureApproved(asset, pt, assets);\n            IPrincipalToken(pt).deposit(assets, recipient);\n        } else if (command == Commands.DEPOSIT_IBT_IN_PT) {\n            (address pt, uint256 ibts, address recipient) = abi.decode(\n                _inputs,\n                (address, uint256, address)\n            );\n            address ibt = IPrincipalToken(pt).getIBT();\n            ibts = _resolveTokenValue(ibt, ibts);\n            recipient = _resolveAddress(recipient);\n            _ensureApproved(ibt, pt, ibts);\n            IPrincipalToken(pt).depositIBT(ibts, recipient);\n        } else if (\n            command == Commands.REDEEM_IBT_FOR_ASSET || command == Commands.REDEEM_PT_FOR_ASSET\n        ) {\n            // Redeems an ERC4626 IBT or a PT for the corresponding ERC20 underlying\n            // token represents the target IBT/PT and shares represents the amount of IBT/PT to redeem\n            (address token, uint256 shares, address recipient) = abi.decode(\n                _inputs,\n                (address, uint256, address)\n            );\n            shares = _resolveTokenValue(token, shares);\n            recipient = _resolveAddress(recipient);\n            IERC4626(token).redeem(shares, recipient, address(this));\n        } else if (command == Commands.REDEEM_PT_FOR_IBT) {\n            (address pt, uint256 shares, address recipient) = abi.decode(\n                _inputs,\n                (address, uint256, address)\n            );\n            shares = _resolveTokenValue(pt, shares);\n            recipient = _resolveAddress(recipient);\n            IPrincipalToken(pt).redeemForIBT(shares, recipient, address(this));\n        } else if (command == Commands.FLASH_LOAN) {\n            (\n                IERC3156FlashLender lender,\n                IERC3156FlashBorrower receiver,\n                address token,\n                uint256 amount,\n                bytes memory data\n            ) = abi.decode(\n                    _inputs,\n                    (IERC3156FlashLender, IERC3156FlashBorrower, address, uint256, bytes)\n                );\n            lender.flashLoan(receiver, token, amount, data);\n        } else if (command == Commands.CURVE_SPLIT_IBT_LIQUIDITY) {\n            (address pool, uint256 ibts, address recipient, address ytRecipient) = abi.decode(\n                _inputs,\n                (address, uint256, address, address)\n            );\n            recipient = _resolveAddress(recipient);\n            ytRecipient = _resolveAddress(ytRecipient);\n            address ibt = ICurvePool(pool).coins(0);\n            address pt = ICurvePool(pool).coins(1);\n            ibts = _resolveTokenValue(ibt, ibts);\n            uint256 ibtToDepositInPT = CurvePoolUtil.calcIBTsToTokenizeForCurvePool(ibts, pool, pt);\n            if (ibtToDepositInPT != 0) {\n                _ensureApproved(ibt, pt, ibtToDepositInPT);\n                IPrincipalToken(pt).depositIBT(ibtToDepositInPT, recipient, ytRecipient);\n            }\n            if (recipient != address(this)) {\n                IERC20(ibt).safeTransfer(recipient, ibts - ibtToDepositInPT);\n            }\n        } else if (command == Commands.CURVE_ADD_LIQUIDITY) {\n            (\n                address pool,\n                uint256[2] memory amounts,\n                uint256 min_mint_amount,\n                address recipient\n            ) = abi.decode(_inputs, (address, uint256[2], uint256, address));\n            recipient = _resolveAddress(recipient);\n            address ibt = ICurvePool(pool).coins(0);\n            address pt = ICurvePool(pool).coins(1);\n            amounts[0] = _resolveTokenValue(ibt, amounts[0]);\n            amounts[1] = _resolveTokenValue(pt, amounts[1]);\n            _ensureApproved(ibt, pool, amounts[0]);\n            _ensureApproved(pt, pool, amounts[1]);\n            ICurvePool(pool).add_liquidity(amounts, min_mint_amount, false, recipient);\n        } else if (command == Commands.CURVE_REMOVE_LIQUIDITY) {\n            (address pool, uint256 lps, uint256[2] memory min_amounts, address recipient) = abi\n                .decode(_inputs, (address, uint256, uint256[2], address));\n            recipient = _resolveAddress(recipient);\n            address lpToken = ICurvePool(pool).token();\n            lps = _resolveTokenValue(lpToken, lps);\n            _ensureApproved(lpToken, pool, lps);\n            ICurvePool(pool).remove_liquidity(lps, min_amounts, false, recipient);\n        } else if (command == Commands.CURVE_REMOVE_LIQUIDITY_ONE_COIN) {\n            (address pool, uint256 lps, uint256 i, uint256 min_amount, address recipient) = abi\n                .decode(_inputs, (address, uint256, uint256, uint256, address));\n            recipient = _resolveAddress(recipient);\n            address lpToken = ICurvePool(pool).token();\n            lps = _resolveTokenValue(lpToken, lps);\n            _ensureApproved(lpToken, pool, lps);\n            ICurvePool(pool).remove_liquidity_one_coin(lps, i, min_amount, false, recipient);\n        } else if (command == Commands.ASSERT_MIN_BALANCE) {\n            (address token, address owner, uint256 minValue) = abi.decode(\n                _inputs,\n                (address, address, uint256)\n            );\n            owner = _resolveAddress(owner);\n            uint256 balance = IERC20(token).balanceOf(owner);\n            if (balance < minValue) {\n                revert MinimumBalanceNotReached(token, owner, minValue, balance);\n            }\n        } else {\n            revert InvalidCommandType(command);\n        }\n    }\n\n    /**\n     * @dev Returns either the input token value as is, or replaced with its corresponding behaviour in Constants.sol\n     * @param _token address of the token\n     * @param _value token amount\n     * @return The amount stored previously if current amount used for detecting contract balance, else current value\n     */\n    function _resolveTokenValue(address _token, uint256 _value) internal view returns (uint256) {\n        if (_value == Constants.CONTRACT_BALANCE) {\n            return IERC20(_token).balanceOf(address(this));\n        } else {\n            return _value;\n        }\n    }\n\n    /**\n     * @dev Returns either the input address as is, or replaced with its corresponding behaviour in Constants.sol\n     * @param _input input address\n     * @return address corresponding to input\n     */\n    function _resolveAddress(address _input) internal view returns (address) {\n        if (_input == Constants.ADDRESS_THIS) {\n            return address(this);\n        } else if (_input == Constants.MSG_SENDER) {\n            return msgSender;\n        } else {\n            return _input;\n        }\n    }\n\n    /**\n     * @dev Checks the allowance of a token and approves the spender if necessary\n     * @param _token address of the token to be approved\n     * @param _spender address of the spender\n     * @param _value token amount\n     */\n    function _ensureApproved(address _token, address _spender, uint256 _value) internal {\n        uint256 allowance = IERC20(_token).allowance(address(this), _spender);\n        if (allowance < _value) {\n            // This approval will only be executed the first time to save gas for subsequent operations\n            IERC20(_token).safeIncreaseAllowance(_spender, type(uint256).max - allowance);\n        }\n    }\n\n    /**\n     * Simulates the execution of batched commands.\n     * @param _commandType Type of command to be executed.\n     * @param _inputs Calldata for the commands.\n     * @param _spot If true, the preview uses the spot exchange rate. Otherwise, includes price impact and curve pool fees.\n     * @param _previousAmount Amount of tokens from the previous command.\n     * @return The preview of the rate and token amount in 27 decimals precision.\n     */\n    function _dispatchPreviewRate(\n        bytes1 _commandType,\n        bytes calldata _inputs,\n        bool _spot,\n        uint256 _previousAmount\n    ) internal view returns (uint256, uint256) {\n        uint256 command = uint8(_commandType & Commands.COMMAND_TYPE_MASK);\n        if (command == Commands.TRANSFER_FROM || command == Commands.TRANSFER_FROM_WITH_PERMIT) {\n            // Does not affect the rate, but amount is now set as the input value\n            (address token, uint256 value) = abi.decode(_inputs, (address, uint256));\n            if (_spot) {\n                return (RayMath.RAY_UNIT, RouterUtil(routerUtil).getUnit(token));\n            } else {\n                return (RayMath.RAY_UNIT, value);\n            }\n        } else if (command == Commands.TRANSFER) {\n            return (RayMath.RAY_UNIT, 0);\n        }\n        // Does not affect the amount\n        else if (command == Commands.CURVE_SWAP) {\n            (address pool, uint256 i, uint256 j, uint256 amountIn, , ) = abi.decode(\n                _inputs,\n                (address, uint256, uint256, uint256, uint256, address)\n            );\n            uint256 exchangeRate;\n            if (_spot) {\n                exchangeRate = RouterUtil(routerUtil).spotExchangeRate(pool, i, j).toRay(\n                    CurvePoolUtil.CURVE_DECIMALS\n                );\n            } else {\n                amountIn = _resolvePreviewTokenValue(amountIn, _previousAmount);\n                exchangeRate = ICurvePool(pool).get_dy(i, j, amountIn).mulDiv(\n                    RayMath.RAY_UNIT,\n                    amountIn\n                );\n            }\n            return (exchangeRate, 0);\n        } else if (command == Commands.DEPOSIT_ASSET_IN_IBT) {\n            (address ibt, uint256 assets, ) = abi.decode(_inputs, (address, uint256, address));\n            if (_spot) {\n                assets = RouterUtil(routerUtil).getUnit(ibt);\n            } else {\n                assets = _resolvePreviewTokenValue(assets, _previousAmount);\n            }\n            // rate : shares * rayUnit / assets\n            return (IERC4626(ibt).previewDeposit(assets).mulDiv(RayMath.RAY_UNIT, assets), 0);\n        } else if (command == Commands.DEPOSIT_ASSET_IN_PT) {\n            (address pt, uint256 assets, ) = abi.decode(_inputs, (address, uint256, address));\n            if (_spot) {\n                assets = RouterUtil(routerUtil).getUnderlyingUnit(pt);\n            } else {\n                assets = _resolvePreviewTokenValue(assets, _previousAmount);\n            }\n            // rate : shares * rayUnit / assets\n            return (IPrincipalToken(pt).previewDeposit(assets).mulDiv(RayMath.RAY_UNIT, assets), 0);\n        } else if (command == Commands.DEPOSIT_IBT_IN_PT) {\n            (address pt, uint256 ibts, ) = abi.decode(_inputs, (address, uint256, address));\n            if (_spot) {\n                ibts = RouterUtil(routerUtil).getUnit(pt);\n            } else {\n                ibts = _resolvePreviewTokenValue(ibts, _previousAmount);\n            }\n            // rate : shares * rayUnit / ibts\n            return (IPrincipalToken(pt).previewDepositIBT(ibts).mulDiv(RayMath.RAY_UNIT, ibts), 0);\n        } else if (\n            command == Commands.REDEEM_IBT_FOR_ASSET || command == Commands.REDEEM_PT_FOR_ASSET\n        ) {\n            (address token, uint256 shares, ) = abi.decode(_inputs, (address, uint256, address));\n            if (_spot) {\n                shares = RouterUtil(routerUtil).getUnit(token);\n            } else {\n                shares = _resolvePreviewTokenValue(shares, _previousAmount);\n            }\n            // rate : assets * rayUnit / shares\n            return (IERC4626(token).previewRedeem(shares).mulDiv(RayMath.RAY_UNIT, shares), 0);\n        } else if (command == Commands.REDEEM_PT_FOR_IBT) {\n            (address pt, uint256 shares, ) = abi.decode(_inputs, (address, uint256, address));\n            if (_spot) {\n                shares = RouterUtil(routerUtil).getUnit(pt);\n            } else {\n                shares = _resolvePreviewTokenValue(shares, _previousAmount);\n            }\n            // rate : ibts * rayUnit / shares\n            return (\n                IPrincipalToken(pt).previewRedeemForIBT(shares).mulDiv(RayMath.RAY_UNIT, shares),\n                0\n            );\n        } else if (command == Commands.ASSERT_MIN_BALANCE) {\n            return (RayMath.RAY_UNIT, 0);\n        } else {\n            revert InvalidCommandType(command);\n        }\n    }\n\n    /**\n     * @dev Returns either the input value as is or replaced with its corresponding behaviour in Constants.sol,\n     * taking into account the previous amount in preview mode as if it were the contract balance\n     * @param _value current value\n     * @param _previousAmount previous value\n     * @return The actual amount of tokens one needs\n     */\n    function _resolvePreviewTokenValue(\n        uint256 _value,\n        uint256 _previousAmount\n    ) internal pure returns (uint256) {\n        // In preview mode, the amount returned from the previous operation is used\n        // to simulate the contract balance.\n        if (_value == Constants.CONTRACT_BALANCE) {\n            return _previousAmount;\n        } else {\n            return _value;\n        }\n    }\n}"
    }
  ]
}