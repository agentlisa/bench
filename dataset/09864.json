{
  "Title": "[M-07] `transferredAmount` on mainnet can be drained if a malicious account can mint more tokens on Schain",
  "Content": "_Submitted by kyliek, also found by cccz_\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/mainnet/DepositBoxes/DepositBoxERC20.sol#L45>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/schain/tokens/ERC20OnChain.sol#L49-L50>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/mainnet/DepositBoxes/DepositBoxERC20.sol#L95>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/schain/tokens/ERC20OnChain.sol#L60-L63>\n\n### Impact\n\nAnyone on Schain that is able to mint more tokens, other than the mint action from `postMessage` in `tokenManagerERC20` by bridging tokens over, can potentially drain the locked tokens in `transferredAmount` in `depositBoxERC20` on mainnet by calling exit with the same amount of tokens in `transferredAmount[schainHash][token]`.\n\nThis will trap other users' funds on sChain and lost those funds on mainnet to the malicious attacker.\n\nAn example of proof of concept using `ERC20OnChian` is given below. This case may seem to be special as the deployer of the clone contract is malicious.  However, this is a potential risk that generalises to other custom contracts with any `mint` functionality.\n\n### Proof of Concept (with ERC20)\n\n*   Malicious account deploys an ERC20 clone `ERC20OnChain` on Schain.\n\n*   By deployment, the malicious account is assigned the MINTER_ROLE on `ERC20OnChain` in the constructor.\n\n<!---->\n\n        constructor(\n            string memory contractName,\n            string memory contractSymbol\n        ) initializer\n        {\n            AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();\n            ERC20Upgradeable.__ERC20_init(contractName, contractSymbol);\n            ERC20BurnableUpgradeable.__ERC20Burnable_init();\n            _setRoleAdmin(MINTER_ROLE, MINTER_ROLE);\n            _setupRole(MINTER_ROLE, _msgSender());\n        }\n\n*   This ERC20 clone get registered on `tokenMangagerERC20.sol` by function `addERC20TokenByOwner`.\n\n<!---->\n\n        function addERC20TokenByOwner(\n            string calldata targetChainName,\n            address erc20OnMainChain,\n            address erc20OnSchain\n         )\n\n*   The malicious account wait for more users to deposit tokens on `depositBoxERC20.depositERC20`, which will increase the amount in `transferredAmount[schainHash][token]`\n\n<!---->\n\n        function depositERC20(\n            string calldata schainName,\n            address erc20OnMainnet,\n            uint256 amount\n        )\n\n*   Malicious account mint to his account the amount equal to `transferredAmount[schainHash][token]` on `ERC20OnChain`\n\n<!---->\n\n        function mint(address account, uint256 value) external override {\n            require(hasRole(MINTER_ROLE, _msgSender()), \"Sender is not a Minter\");\n            _mint(account, value);\n        }\n\n*   Malicious account calls `exitToMainERC20` in `TokenManagerERC20`.\n\n<!---->\n\n        function exitToMainERC20(\n            address contractOnMainnet,\n            uint256 amount\n        )\n            external\n            override\n        {\n            communityLocker.checkAllowedToSendMessage(msg.sender);\n            _exit(MAINNET_HASH, depositBox, contractOnMainnet, msg.sender, amount);\n        }\n\n*   `transferredAmount[schainHash][token]` is drained to the malicious account on mainnet and victims' tokens get stranded on schain.\n\n### Recommended Mitigation Steps\n\nDisable minting function to be called directly in `ERC20OnChain`. Only allow minting when bridging tokens over.\n\n\n**[cstrangedk (SKALE) disputed and commented](https://github.com/code-423n4/2022-02-skale-findings/issues/38#issuecomment-1058709283):**\n > Issue is acknowledged and work is pending on the roadmap.  SKALE Chain owners must carefully manage MINTER_ROLE, and end-users carefully monitor role.\n\n\n**[GalloDaSballo (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-02-skale-findings/issues/38#issuecomment-1143850380):**\n > I believe the sponsor reply sheds further light into how the system will be used in 99% of cases.\n> \n> That said we have to judge the codebase for how it could be exploited and used by malicious actors, and I do agree with he warden that if the MINTER_ROLE is granted to someone (let's say the admin) then they could use it to drain funds from the mainnet side of the bridge.\n> \n> Because this is contingent on setup and Admin Privilege, I believe Medium Severity to be more appropriate.\n> \n> Switching from a role based system to an immutable Minter Address (the bridge contract) can be used as mitigation, alternatively sChain end users will have to monitor for these types of changes and act accordingly\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-skale-contest",
  "Code": [
    {
      "filename": "contracts/mainnet/DepositBoxes/DepositBoxERC20.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   DepositBoxERC20.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2019-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/mainnet/DepositBoxes/IDepositBoxERC20.sol\";\n\nimport \"../../Messages.sol\";\nimport \"../DepositBox.sol\";\n\n\n/**\n * @title DepositBoxERC20\n * @dev Runs on mainnet,\n * accepts messages from schain,\n * stores deposits of ERC20.\n */\ncontract DepositBoxERC20 is DepositBox, IDepositBoxERC20 {\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    // schainHash => address of ERC20 on Mainnet\n    mapping(bytes32 => mapping(address => bool)) private _deprecatedSchainToERC20;\n    mapping(bytes32 => mapping(address => uint256)) public transferredAmount;\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _schainToERC20;\n\n    /**\n     * @dev Emitted when token is mapped in DepositBoxERC20.\n     */\n    event ERC20TokenAdded(string schainName, address indexed contractOnMainnet);\n    \n    /**\n     * @dev Emitted when token is received by DepositBox and is ready to be cloned\n     * or transferred on SKALE chain.\n     */\n    event ERC20TokenReady(address indexed contractOnMainnet, uint256 amount);\n\n    /**\n     * @dev Allows DEFAULT_ADMIN_ROLE to initialize token mapping\n     * Notice - this function will be executed only once during upgrade\n     * \n     * Requirements:\n     * \n     * `msg.sender` should has DEFAULT_ADMIN_ROLE\n     */\n    function initializeAllTokensForSchain(\n        string calldata schainName,\n        address[] calldata tokens\n    )\n        external\n        override\n    {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"Sender is not authorized\");\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        for (uint256 i = 0; i < tokens.length; i++) {\n            if (_deprecatedSchainToERC20[schainHash][tokens[i]] && !_schainToERC20[schainHash].contains(tokens[i])) {\n                _schainToERC20[schainHash].add(tokens[i]);\n                delete _deprecatedSchainToERC20[schainHash][tokens[i]];\n            }\n        }\n    }\n\n    /**\n     * @dev Allows `msg.sender` to send ERC20 token from mainnet to schain\n     * \n     * Requirements:\n     * \n     * - Schain name must not be `Mainnet`.\n     * - Receiver account on schain cannot be null.\n     * - Schain that receives tokens should not be killed.\n     * - Receiver contract should be defined.\n     * - `msg.sender` should approve their tokens for DepositBoxERC20 address.\n     */\n    function depositERC20(\n        string calldata schainName,\n        address erc20OnMainnet,\n        uint256 amount\n    )\n        external\n        override\n        rightTransaction(schainName, msg.sender)\n        whenNotKilled(keccak256(abi.encodePacked(schainName)))\n    {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        address contractReceiver = schainLinks[schainHash];\n        require(contractReceiver != address(0), \"Unconnected chain\");\n        require(\n            ERC20Upgradeable(erc20OnMainnet).allowance(msg.sender, address(this)) >= amount,\n            \"DepositBox was not approved for ERC20 token\"\n        );\n        bytes memory data = _receiveERC20(\n            schainName,\n            erc20OnMainnet,\n            msg.sender,\n            amount\n        );\n        _saveTransferredAmount(schainHash, erc20OnMainnet, amount);\n        require(\n            ERC20Upgradeable(erc20OnMainnet).transferFrom(\n                msg.sender,\n                address(this),\n                amount\n            ),\n            \"Transfer was failed\"\n        );\n        messageProxy.postOutgoingMessage(\n            schainHash,\n            contractReceiver,\n            data\n        );\n    }\n\n    /**\n     * @dev Allows MessageProxyForMainnet contract to execute transferring ERC20 token from schain to mainnet.\n     * \n     * Requirements:\n     * \n     * - Schain from which the tokens came should not be killed.\n     * - Sender contract should be defined and schain name cannot be `Mainnet`.\n     * - Amount of tokens on DepositBoxERC20 should be equal or more than transferred amount.\n     */\n    function postMessage(\n        bytes32 schainHash,\n        address sender,\n        bytes calldata data\n    )\n        external\n        override\n        onlyMessageProxy\n        whenNotKilled(schainHash)\n        checkReceiverChain(schainHash, sender)\n        returns (address)\n    {\n        Messages.TransferErc20Message memory message = Messages.decodeTransferErc20Message(data);\n        require(message.token.isContract(), \"Given address is not a contract\");\n        require(ERC20Upgradeable(message.token).balanceOf(address(this)) >= message.amount, \"Not enough money\");\n        _removeTransferredAmount(schainHash, message.token, message.amount);\n        require(\n            ERC20Upgradeable(message.token).transfer(message.receiver, message.amount),\n            \"Transfer was failed\"\n        );\n        return message.receiver;\n    }\n\n    /**\n     * @dev Allows Schain owner to add an ERC20 token to DepositBoxERC20.\n     * \n     * Emits an {ERC20TokenAdded} event.\n     * \n     * Requirements:\n     * \n     * - Schain should not be killed.\n     * - Only owner of the schain able to run function.\n     */\n    function addERC20TokenByOwner(string calldata schainName, address erc20OnMainnet)\n        external\n        override\n        onlySchainOwner(schainName)\n        whenNotKilled(keccak256(abi.encodePacked(schainName)))\n    {\n        _addERC20ForSchain(schainName, erc20OnMainnet);\n    }\n\n    /**\n     * @dev Allows Schain owner to return each user their tokens.\n     * The Schain owner decides which tokens to send to which address, \n     * since the contract on mainnet does not store information about which tokens belong to whom.\n     *\n     * Requirements:\n     * \n     * - Amount of tokens on schain should be equal or more than transferred amount.\n     * - msg.sender should be an owner of schain\n     * - IMA transfers Mainnet <-> schain should be killed\n     */\n    function getFunds(string calldata schainName, address erc20OnMainnet, address receiver, uint amount)\n        external\n        override\n        onlySchainOwner(schainName)\n        whenKilled(keccak256(abi.encodePacked(schainName)))\n    {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(transferredAmount[schainHash][erc20OnMainnet] >= amount, \"Incorrect amount\");\n        _removeTransferredAmount(schainHash, erc20OnMainnet, amount);\n        require(\n            ERC20Upgradeable(erc20OnMainnet).transfer(receiver, amount),\n            \"Transfer was failed\"\n        );\n    }\n\n    /**\n     * @dev Returns receiver of message.\n     *\n     * Requirements:\n     *\n     * - Sender contract should be defined and schain name cannot be `Mainnet`.\n     */\n    function gasPayer(\n        bytes32 schainHash,\n        address sender,\n        bytes calldata data\n    )\n        external\n        view\n        override\n        checkReceiverChain(schainHash, sender)\n        returns (address)\n    {\n        Messages.TransferErc20Message memory message = Messages.decodeTransferErc20Message(data);\n        return message.receiver;\n    }\n\n    /**\n     * @dev Should return true if token was added by Schain owner or \n     * added automatically after sending to schain if whitelist was turned off.\n     */\n    function getSchainToERC20(\n        string calldata schainName,\n        address erc20OnMainnet\n    )\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _schainToERC20[keccak256(abi.encodePacked(schainName))].contains(erc20OnMainnet);\n    }\n\n    /**\n     * @dev Should return length of a set of all mapped tokens which were added by Schain owner \n     * or added automatically after sending to schain if whitelist was turned off.\n     */\n    function getSchainToAllERC20Length(string calldata schainName) external view override returns (uint256) {\n        return _schainToERC20[keccak256(abi.encodePacked(schainName))].length();\n    }\n\n    /**\n     * @dev Should return an array of range of tokens were added by Schain owner \n     * or added automatically after sending to schain if whitelist was turned off.\n     */\n    function getSchainToAllERC20(\n        string calldata schainName,\n        uint256 from,\n        uint256 to\n    )\n        external\n        view\n        override\n        returns (address[] memory tokensInRange)\n    {\n        require(\n            from < to && to - from <= 10 && to <= _schainToERC20[keccak256(abi.encodePacked(schainName))].length(),\n            \"Range is incorrect\"\n        );\n        tokensInRange = new address[](to - from);\n        for (uint256 i = from; i < to; i++) {\n            tokensInRange[i - from] = _schainToERC20[keccak256(abi.encodePacked(schainName))].at(i);\n        }\n    }\n\n    /**\n     * @dev Creates a new DepositBoxERC20 contract.\n     */\n    function initialize(\n        IContractManager contractManagerOfSkaleManagerValue,\n        ILinker linkerValue,\n        IMessageProxyForMainnet messageProxyValue\n    )\n        public\n        override(DepositBox, IDepositBox)\n        initializer\n    {\n        DepositBox.initialize(contractManagerOfSkaleManagerValue, linkerValue, messageProxyValue);\n    }\n\n    /**\n     * @dev Saves amount of tokens that was transferred to schain.\n     */\n    function _saveTransferredAmount(bytes32 schainHash, address erc20Token, uint256 amount) private {\n        transferredAmount[schainHash][erc20Token] += amount;\n    }\n\n    /**\n     * @dev Removes amount of tokens that was transferred from schain.\n     */\n    function _removeTransferredAmount(bytes32 schainHash, address erc20Token, uint256 amount) private {\n        transferredAmount[schainHash][erc20Token] -= amount;\n    }\n\n    /**\n     * @dev Allows DepositBoxERC20 to receive ERC20 tokens.\n     * \n     * Emits an {ERC20TokenReady} event.\n     * \n     * Requirements:\n     * \n     * - Amount must be less than or equal to the total supply of the ERC20 contract.\n     * - Whitelist should be turned off for auto adding tokens to DepositBoxERC20.\n     */\n    function _receiveERC20(\n        string calldata schainName,\n        address erc20OnMainnet,\n        address to,\n        uint256 amount\n    )\n        private\n        returns (bytes memory data)\n    {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        ERC20Upgradeable erc20 = ERC20Upgradeable(erc20OnMainnet);\n        uint256 totalSupply = erc20.totalSupply();\n        require(amount <= totalSupply, \"Amount is incorrect\");\n        bool isERC20AddedToSchain = _schainToERC20[schainHash].contains(erc20OnMainnet);\n        if (!isERC20AddedToSchain) {\n            require(!isWhitelisted(schainName), \"Whitelist is enabled\");\n            _addERC20ForSchain(schainName, erc20OnMainnet);\n            data = Messages.encodeTransferErc20AndTokenInfoMessage(\n                erc20OnMainnet,\n                to,\n                amount,\n                _getErc20TotalSupply(erc20),\n                _getErc20TokenInfo(erc20)\n            );\n        } else {\n            data = Messages.encodeTransferErc20AndTotalSupplyMessage(\n                erc20OnMainnet,\n                to,\n                amount,\n                _getErc20TotalSupply(erc20)\n            );\n        }\n        emit ERC20TokenReady(erc20OnMainnet, amount);\n    }\n\n    /**\n     * @dev Adds an ERC20 token to DepositBoxERC20.\n     * \n     * Emits an {ERC20TokenAdded} event.\n     * \n     * Requirements:\n     * \n     * - Given address should be contract.\n     */\n    function _addERC20ForSchain(string calldata schainName, address erc20OnMainnet) private {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(erc20OnMainnet.isContract(), \"Given address is not a contract\");\n        require(!_schainToERC20[schainHash].contains(erc20OnMainnet), \"ERC20 Token was already added\");\n        _schainToERC20[schainHash].add(erc20OnMainnet);\n        emit ERC20TokenAdded(schainName, erc20OnMainnet);\n    }\n\n    /**\n     * @dev Returns total supply of ERC20 token.\n     */\n    function _getErc20TotalSupply(ERC20Upgradeable erc20Token) private view returns (uint256) {\n        return erc20Token.totalSupply();\n    }\n\n    /**\n     * @dev Returns info about ERC20 token such as token name, decimals, symbol.\n     */\n    function _getErc20TokenInfo(ERC20Upgradeable erc20Token) private view returns (Messages.Erc20TokenInfo memory) {\n        return Messages.Erc20TokenInfo({\n            name: erc20Token.name(),\n            decimals: erc20Token.decimals(),\n            symbol: erc20Token.symbol()\n        });\n    }\n}"
    },
    {
      "filename": "contracts/schain/tokens/ERC20OnChain.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   ERC20OnChain.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Artem Payvin\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/schain/tokens/IERC20OnChain.sol\";\n\n\n/**\n * @title ERC20OnChain\n * @dev ERC20 token that is used as an automatically deployed clone of ERC20 on mainnet.\n */\ncontract ERC20OnChain is AccessControlEnumerableUpgradeable, ERC20BurnableUpgradeable, IERC20OnChain {\n\n    /**\n     * @dev id of a role that allows token minting.\n     */\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n    constructor(\n        string memory contractName,\n        string memory contractSymbol\n    ) initializer\n    {\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();\n        ERC20Upgradeable.__ERC20_init(contractName, contractSymbol);\n        ERC20BurnableUpgradeable.__ERC20Burnable_init();\n        _setRoleAdmin(MINTER_ROLE, MINTER_ROLE);\n        _setupRole(MINTER_ROLE, _msgSender());\n    }\n\n    /**\n     * @dev Mint tokens.\n     * \n     * Requirements:\n     * \n     * - sender must be granted with {MINTER_ROLE}.\n     */\n    function mint(address account, uint256 value) external override {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"Sender is not a Minter\");\n        _mint(account, value);\n    }\n}"
    },
    {
      "filename": "contracts/mainnet/DepositBoxes/DepositBoxERC20.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   DepositBoxERC20.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2019-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/mainnet/DepositBoxes/IDepositBoxERC20.sol\";\n\nimport \"../../Messages.sol\";\nimport \"../DepositBox.sol\";\n\n\n/**\n * @title DepositBoxERC20\n * @dev Runs on mainnet,\n * accepts messages from schain,\n * stores deposits of ERC20.\n */\ncontract DepositBoxERC20 is DepositBox, IDepositBoxERC20 {\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    // schainHash => address of ERC20 on Mainnet\n    mapping(bytes32 => mapping(address => bool)) private _deprecatedSchainToERC20;\n    mapping(bytes32 => mapping(address => uint256)) public transferredAmount;\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _schainToERC20;\n\n    /**\n     * @dev Emitted when token is mapped in DepositBoxERC20.\n     */\n    event ERC20TokenAdded(string schainName, address indexed contractOnMainnet);\n    \n    /**\n     * @dev Emitted when token is received by DepositBox and is ready to be cloned\n     * or transferred on SKALE chain.\n     */\n    event ERC20TokenReady(address indexed contractOnMainnet, uint256 amount);\n\n    /**\n     * @dev Allows DEFAULT_ADMIN_ROLE to initialize token mapping\n     * Notice - this function will be executed only once during upgrade\n     * \n     * Requirements:\n     * \n     * `msg.sender` should has DEFAULT_ADMIN_ROLE\n     */\n    function initializeAllTokensForSchain(\n        string calldata schainName,\n        address[] calldata tokens\n    )\n        external\n        override\n    {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"Sender is not authorized\");\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        for (uint256 i = 0; i < tokens.length; i++) {\n            if (_deprecatedSchainToERC20[schainHash][tokens[i]] && !_schainToERC20[schainHash].contains(tokens[i])) {\n                _schainToERC20[schainHash].add(tokens[i]);\n                delete _deprecatedSchainToERC20[schainHash][tokens[i]];\n            }\n        }\n    }\n\n    /**\n     * @dev Allows `msg.sender` to send ERC20 token from mainnet to schain\n     * \n     * Requirements:\n     * \n     * - Schain name must not be `Mainnet`.\n     * - Receiver account on schain cannot be null.\n     * - Schain that receives tokens should not be killed.\n     * - Receiver contract should be defined.\n     * - `msg.sender` should approve their tokens for DepositBoxERC20 address.\n     */\n    function depositERC20(\n        string calldata schainName,\n        address erc20OnMainnet,\n        uint256 amount\n    )\n        external\n        override\n        rightTransaction(schainName, msg.sender)\n        whenNotKilled(keccak256(abi.encodePacked(schainName)))\n    {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        address contractReceiver = schainLinks[schainHash];\n        require(contractReceiver != address(0), \"Unconnected chain\");\n        require(\n            ERC20Upgradeable(erc20OnMainnet).allowance(msg.sender, address(this)) >= amount,\n            \"DepositBox was not approved for ERC20 token\"\n        );\n        bytes memory data = _receiveERC20(\n            schainName,\n            erc20OnMainnet,\n            msg.sender,\n            amount\n        );\n        _saveTransferredAmount(schainHash, erc20OnMainnet, amount);\n        require(\n            ERC20Upgradeable(erc20OnMainnet).transferFrom(\n                msg.sender,\n                address(this),\n                amount\n            ),\n            \"Transfer was failed\"\n        );\n        messageProxy.postOutgoingMessage(\n            schainHash,\n            contractReceiver,\n            data\n        );\n    }\n\n    /**\n     * @dev Allows MessageProxyForMainnet contract to execute transferring ERC20 token from schain to mainnet.\n     * \n     * Requirements:\n     * \n     * - Schain from which the tokens came should not be killed.\n     * - Sender contract should be defined and schain name cannot be `Mainnet`.\n     * - Amount of tokens on DepositBoxERC20 should be equal or more than transferred amount.\n     */\n    function postMessage(\n        bytes32 schainHash,\n        address sender,\n        bytes calldata data\n    )\n        external\n        override\n        onlyMessageProxy\n        whenNotKilled(schainHash)\n        checkReceiverChain(schainHash, sender)\n        returns (address)\n    {\n        Messages.TransferErc20Message memory message = Messages.decodeTransferErc20Message(data);\n        require(message.token.isContract(), \"Given address is not a contract\");\n        require(ERC20Upgradeable(message.token).balanceOf(address(this)) >= message.amount, \"Not enough money\");\n        _removeTransferredAmount(schainHash, message.token, message.amount);\n        require(\n            ERC20Upgradeable(message.token).transfer(message.receiver, message.amount),\n            \"Transfer was failed\"\n        );\n        return message.receiver;\n    }\n\n    /**\n     * @dev Allows Schain owner to add an ERC20 token to DepositBoxERC20.\n     * \n     * Emits an {ERC20TokenAdded} event.\n     * \n     * Requirements:\n     * \n     * - Schain should not be killed.\n     * - Only owner of the schain able to run function.\n     */\n    function addERC20TokenByOwner(string calldata schainName, address erc20OnMainnet)\n        external\n        override\n        onlySchainOwner(schainName)\n        whenNotKilled(keccak256(abi.encodePacked(schainName)))\n    {\n        _addERC20ForSchain(schainName, erc20OnMainnet);\n    }\n\n    /**\n     * @dev Allows Schain owner to return each user their tokens.\n     * The Schain owner decides which tokens to send to which address, \n     * since the contract on mainnet does not store information about which tokens belong to whom.\n     *\n     * Requirements:\n     * \n     * - Amount of tokens on schain should be equal or more than transferred amount.\n     * - msg.sender should be an owner of schain\n     * - IMA transfers Mainnet <-> schain should be killed\n     */\n    function getFunds(string calldata schainName, address erc20OnMainnet, address receiver, uint amount)\n        external\n        override\n        onlySchainOwner(schainName)\n        whenKilled(keccak256(abi.encodePacked(schainName)))\n    {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(transferredAmount[schainHash][erc20OnMainnet] >= amount, \"Incorrect amount\");\n        _removeTransferredAmount(schainHash, erc20OnMainnet, amount);\n        require(\n            ERC20Upgradeable(erc20OnMainnet).transfer(receiver, amount),\n            \"Transfer was failed\"\n        );\n    }\n\n    /**\n     * @dev Returns receiver of message.\n     *\n     * Requirements:\n     *\n     * - Sender contract should be defined and schain name cannot be `Mainnet`.\n     */\n    function gasPayer(\n        bytes32 schainHash,\n        address sender,\n        bytes calldata data\n    )\n        external\n        view\n        override\n        checkReceiverChain(schainHash, sender)\n        returns (address)\n    {\n        Messages.TransferErc20Message memory message = Messages.decodeTransferErc20Message(data);\n        return message.receiver;\n    }\n\n    /**\n     * @dev Should return true if token was added by Schain owner or \n     * added automatically after sending to schain if whitelist was turned off.\n     */\n    function getSchainToERC20(\n        string calldata schainName,\n        address erc20OnMainnet\n    )\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _schainToERC20[keccak256(abi.encodePacked(schainName))].contains(erc20OnMainnet);\n    }\n\n    /**\n     * @dev Should return length of a set of all mapped tokens which were added by Schain owner \n     * or added automatically after sending to schain if whitelist was turned off.\n     */\n    function getSchainToAllERC20Length(string calldata schainName) external view override returns (uint256) {\n        return _schainToERC20[keccak256(abi.encodePacked(schainName))].length();\n    }\n\n    /**\n     * @dev Should return an array of range of tokens were added by Schain owner \n     * or added automatically after sending to schain if whitelist was turned off.\n     */\n    function getSchainToAllERC20(\n        string calldata schainName,\n        uint256 from,\n        uint256 to\n    )\n        external\n        view\n        override\n        returns (address[] memory tokensInRange)\n    {\n        require(\n            from < to && to - from <= 10 && to <= _schainToERC20[keccak256(abi.encodePacked(schainName))].length(),\n            \"Range is incorrect\"\n        );\n        tokensInRange = new address[](to - from);\n        for (uint256 i = from; i < to; i++) {\n            tokensInRange[i - from] = _schainToERC20[keccak256(abi.encodePacked(schainName))].at(i);\n        }\n    }\n\n    /**\n     * @dev Creates a new DepositBoxERC20 contract.\n     */\n    function initialize(\n        IContractManager contractManagerOfSkaleManagerValue,\n        ILinker linkerValue,\n        IMessageProxyForMainnet messageProxyValue\n    )\n        public\n        override(DepositBox, IDepositBox)\n        initializer\n    {\n        DepositBox.initialize(contractManagerOfSkaleManagerValue, linkerValue, messageProxyValue);\n    }\n\n    /**\n     * @dev Saves amount of tokens that was transferred to schain.\n     */\n    function _saveTransferredAmount(bytes32 schainHash, address erc20Token, uint256 amount) private {\n        transferredAmount[schainHash][erc20Token] += amount;\n    }\n\n    /**\n     * @dev Removes amount of tokens that was transferred from schain.\n     */\n    function _removeTransferredAmount(bytes32 schainHash, address erc20Token, uint256 amount) private {\n        transferredAmount[schainHash][erc20Token] -= amount;\n    }\n\n    /**\n     * @dev Allows DepositBoxERC20 to receive ERC20 tokens.\n     * \n     * Emits an {ERC20TokenReady} event.\n     * \n     * Requirements:\n     * \n     * - Amount must be less than or equal to the total supply of the ERC20 contract.\n     * - Whitelist should be turned off for auto adding tokens to DepositBoxERC20.\n     */\n    function _receiveERC20(\n        string calldata schainName,\n        address erc20OnMainnet,\n        address to,\n        uint256 amount\n    )\n        private\n        returns (bytes memory data)\n    {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        ERC20Upgradeable erc20 = ERC20Upgradeable(erc20OnMainnet);\n        uint256 totalSupply = erc20.totalSupply();\n        require(amount <= totalSupply, \"Amount is incorrect\");\n        bool isERC20AddedToSchain = _schainToERC20[schainHash].contains(erc20OnMainnet);\n        if (!isERC20AddedToSchain) {\n            require(!isWhitelisted(schainName), \"Whitelist is enabled\");\n            _addERC20ForSchain(schainName, erc20OnMainnet);\n            data = Messages.encodeTransferErc20AndTokenInfoMessage(\n                erc20OnMainnet,\n                to,\n                amount,\n                _getErc20TotalSupply(erc20),\n                _getErc20TokenInfo(erc20)\n            );\n        } else {\n            data = Messages.encodeTransferErc20AndTotalSupplyMessage(\n                erc20OnMainnet,\n                to,\n                amount,\n                _getErc20TotalSupply(erc20)\n            );\n        }\n        emit ERC20TokenReady(erc20OnMainnet, amount);\n    }\n\n    /**\n     * @dev Adds an ERC20 token to DepositBoxERC20.\n     * \n     * Emits an {ERC20TokenAdded} event.\n     * \n     * Requirements:\n     * \n     * - Given address should be contract.\n     */\n    function _addERC20ForSchain(string calldata schainName, address erc20OnMainnet) private {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(erc20OnMainnet.isContract(), \"Given address is not a contract\");\n        require(!_schainToERC20[schainHash].contains(erc20OnMainnet), \"ERC20 Token was already added\");\n        _schainToERC20[schainHash].add(erc20OnMainnet);\n        emit ERC20TokenAdded(schainName, erc20OnMainnet);\n    }\n\n    /**\n     * @dev Returns total supply of ERC20 token.\n     */\n    function _getErc20TotalSupply(ERC20Upgradeable erc20Token) private view returns (uint256) {\n        return erc20Token.totalSupply();\n    }\n\n    /**\n     * @dev Returns info about ERC20 token such as token name, decimals, symbol.\n     */\n    function _getErc20TokenInfo(ERC20Upgradeable erc20Token) private view returns (Messages.Erc20TokenInfo memory) {\n        return Messages.Erc20TokenInfo({\n            name: erc20Token.name(),\n            decimals: erc20Token.decimals(),\n            symbol: erc20Token.symbol()\n        });\n    }\n}"
    },
    {
      "filename": "contracts/schain/tokens/ERC20OnChain.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   ERC20OnChain.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Artem Payvin\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/schain/tokens/IERC20OnChain.sol\";\n\n\n/**\n * @title ERC20OnChain\n * @dev ERC20 token that is used as an automatically deployed clone of ERC20 on mainnet.\n */\ncontract ERC20OnChain is AccessControlEnumerableUpgradeable, ERC20BurnableUpgradeable, IERC20OnChain {\n\n    /**\n     * @dev id of a role that allows token minting.\n     */\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n    constructor(\n        string memory contractName,\n        string memory contractSymbol\n    ) initializer\n    {\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();\n        ERC20Upgradeable.__ERC20_init(contractName, contractSymbol);\n        ERC20BurnableUpgradeable.__ERC20Burnable_init();\n        _setRoleAdmin(MINTER_ROLE, MINTER_ROLE);\n        _setupRole(MINTER_ROLE, _msgSender());\n    }\n\n    /**\n     * @dev Mint tokens.\n     * \n     * Requirements:\n     * \n     * - sender must be granted with {MINTER_ROLE}.\n     */\n    function mint(address account, uint256 value) external override {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"Sender is not a Minter\");\n        _mint(account, value);\n    }\n}"
    }
  ]
}