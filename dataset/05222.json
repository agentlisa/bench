{
  "Title": "[H-04] Users will lose their cross-chain transaction if the destination router do not have enough WETH reserves.",
  "Content": "\nWhen the DecentEthRouter receives the dcntEth OFT token from a cross-chain transaction, if the WETH balance of the destination router is less than amount of dcntEth received (this could be due to the router receiving more cross-chain transactions than than sending cross-chain transactions which depletes its WETH reserves), then the dcntEth will get transferred to the address specified by `_to`.\n\n[DecentEthRouter.sol#L266-L281](https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DecentEthRouter.sol#L266-L281)\n\n```solidity\n    function onOFTReceived(\n        uint16 _srcChainId,\n        bytes calldata,\n        uint64,\n        bytes32,\n        uint _amount,\n        bytes memory _payload\n    ) external override onlyLzApp {\n        ...\n        if (weth.balanceOf(address(this)) < _amount) {\n=>          dcntEth.transfer(_to, _amount);\n            return;\n        }\n\n        if (msgType == MT_ETH_TRANSFER) {\n            if (!gasCurrencyIsEth || !deliverEth) {\n                weth.transfer(_to, _amount);\n            } else {\n                weth.withdraw(_amount);\n                payable(_to).transfer(_amount);\n            }\n        } else {\n            weth.approve(address(executor), _amount);\n            executor.execute(_from, _to, deliverEth, _amount, callPayload);\n        }\n    }\n```\n\nThis dcntEth is sent to the user so that they can either redeem the WETH / ETH from the router once the WETH balance is refilled or send it back to the source chain to redeem back the WETH.\n\nThe problem is that if the msgType != MT_ETH_TRANSFER, then the `_to` address is not the user, it is instead the target meant to be called by the destination chain's bridge executor (if the source chain uses a decent bridge adapter, the target is always the destination chain's bridge adapter which does not have a way to withdraw the dcntEth).\n\nThe following snippet shows what occurs in the bridge executor (`_executeEth` omitted as it does largely the same thing as `_executeWeth`):\n\n[DecentBridgeExecutor.sol#L24-L82](https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DecentBridgeExecutor.sol#L24-L82)\n\n```solidity\n    function _executeWeth(\n        address from,\n        address target,\n        uint256 amount,\n        bytes memory callPayload\n    ) private {\n        uint256 balanceBefore = weth.balanceOf(address(this));\n        weth.approve(target, amount);\n\n        (bool success, ) = target.call(callPayload);\n\n        if (!success) {\n            weth.transfer(from, amount);\n            return;\n        }\n\n        uint256 remainingAfterCall = amount -\n            (balanceBefore - weth.balanceOf(address(this)));\n\n        // refund the sender with excess WETH\n        weth.transfer(from, remainingAfterCall);\n    }\n    ...\n    function execute(\n        address from,\n        address target,\n        bool deliverEth,\n        uint256 amount,\n        bytes memory callPayload\n    ) public onlyOwner {\n        weth.transferFrom(msg.sender, address(this), amount);\n\n        if (!gasCurrencyIsEth || !deliverEth) {\n            _executeWeth(from, target, amount, callPayload);\n        } else {\n            _executeEth(from, target, amount, callPayload);\n        }\n    }\n```\n\nTherefore, once the dcntEth is transferred to the execution target (which is almost always the destination chain bridge adapter, see Appendix for the code walkthrough). The user cannot do anything to retrieve the dcntEth out of the execution target, so the cross-chain transaction is lost.\n\n### Recommended Mitigation Steps\n\nPass a destination chain refund address into the payload sent cross-chain and replace the `_to` address used in [DecentEthRouter.sol#L267](https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DecentEthRouter.sol#L267):\n\n```solidity\n        if (weth.balanceOf(address(this)) < _amount) {\n        // REPLACE '_to' with the destination chain refund address\n=>          dcntEth.transfer(_to, _amount);\n            return;\n        }\n```\n\n\n\n<details> <summary> Appendix </summary>\n\nTo see why the target is always the destination bridge adapter if the source chain is a decent bridge adapter:\n\nUTB.sol will first call the `bridge` function in the adapter with the destination bridge adapter address as the 2nd argument.\n\n[DecentBridgeAdapter.sol#L117C1-L124C11](https://github.com/code-423n4/2024-01-decent/blob/main/src/bridge_adapters/DecentBridgeAdapter.sol#L117C1-L124C11)\n\n```solidity\n    function bridge(\n        ...\n        router.bridgeWithPayload{value: msg.value}(\n            lzIdLookup[dstChainId],\n            destinationBridgeAdapter[dstChainId],\n            swapParams.amountIn,\n            false,\n            dstGas,\n            bridgePayload\n        );\n    }\n```\n\nWhich calls the below function in the router, where the `_toAddress` is the 2nd argument and therefore is the destination bridge adapter address:\n\n[DecentEthRouter.sol#L196C1-L204C23](https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DecentEthRouter.sol#L196C1-L204C23)\n\n```solidity\n    /// @inheritdoc IDecentEthRouter\n    function bridgeWithPayload(\n        uint16 _dstChainId,\n        address _toAddress,\n        uint _amount,\n        bool deliverEth,\n        uint64 _dstGasForCall,\n        bytes memory additionalPayload\n    ) public payable {\n           return\n            _bridgeWithPayload(\n                MT_ETH_TRANSFER_WITH_PAYLOAD,\n                _dstChainId,\n                _toAddress,\n                _amount,\n                _dstGasForCall,\n                additionalPayload,\n                deliverEth\n            );\n           ...\n```\n\nwhich calls `_bridgeWithPayload` which calls `_getCallParams` to encode the payload to send to the destination chain:\n\n[DecentEthRouter.sol#L148C1-L168C15](https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DecentEthRouter.sol#L148C1-L168C15)\n\n```solidity\n    function _bridgeWithPayload(\n        uint8 msgType,\n        uint16 _dstChainId,\n        address _toAddress,\n        uint _amount,\n        uint64 _dstGasForCall,\n        bytes memory additionalPayload,\n        bool deliverEth\n    ) internal {\n        (\n            bytes32 destinationBridge,\n            bytes memory adapterParams,\n            bytes memory payload\n        ) = _getCallParams(\n                msgType,\n                _toAddress,\n                _dstChainId,\n                _dstGasForCall,\n                deliverEth,\n                additionalPayload\n            );\n            ...\n```\n\nThe `_toAddress` parameter is always the 3rd parameter in the payload sent.\n\n[DecentEthRouter.sol#L101-L110](https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DecentEthRouter.sol#L101-L110)\n\n            function _getCallParams\n            ...\n            if (msgType == MT_ETH_TRANSFER) {\n                payload = abi.encode(msgType, msg.sender, _toAddress, deliverEth);\n            } else {\n                payload = abi.encode(\n                    msgType,\n                    msg.sender,\n                    _toAddress,\n                    deliverEth,\n                    additionalPayload\n                );\n            }\n            ...\n\nWhich matches `_to` variable in `onOFTReceived`\n\n[DecentEthRouter.sol#L236](https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DecentEthRouter.sol#L236)\n\n```solidity\n    /// @inheritdoc IOFTReceiverV2\n    function onOFTReceived(\n        uint16 _srcChainId,\n        bytes calldata,\n        uint64,\n        bytes32,\n        uint _amount,\n        bytes memory _payload\n    ) external override onlyLzApp {\n        (uint8 msgType, address _from, address _to, bool deliverEth) = abi\n            .decode(_payload, (uint8, address, address, bool));\n\n        bytes memory callPayload = \"\";\n\n        if (msgType == MT_ETH_TRANSFER_WITH_PAYLOAD) {\n            (, , , , callPayload) = abi.decode(\n                _payload,\n                (uint8, address, address, bool, bytes)\n            );\n        }\n        ...\n```\n</details>\n\n\n**[wkantaros (Decent) confirmed but disagreed with severity](https://github.com/code-423n4/2024-01-decent-findings/issues/59#issuecomment-1917406086)**\n\n**[0xsomeone (Judge) commented](https://github.com/code-423n4/2024-01-decent-findings/issues/59#issuecomment-1924077034):**\n > This and all duplicate submissions detail an interesting way in which cross-chain relays will fail to properly invoke the target recipient of the relayed call, effectively leading to loss of funds as the assets will be transferred to an entity that potentially is not equipped to handle the token. \n> \n> Based on discussions in [#505](https://github.com/code-423n4/2024-01-decent-findings/issues/505), this is a very likely scenario and thus a high-risk severity is appropriate as the vulnerability should manifest consistently in non-Ethereum chains.\n\n***\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-01-decent",
  "Code": [
    {
      "filename": "src/DecentEthRouter.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {IDcntEth} from \"./interfaces/IDcntEth.sol\";\nimport {ICommonOFT} from \"solidity-examples/token/oft/v2/interfaces/ICommonOFT.sol\";\nimport {IOFTReceiverV2} from \"solidity-examples/token/oft/v2/interfaces/IOFTReceiverV2.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {IDecentBridgeExecutor} from \"./interfaces/IDecentBridgeExecutor.sol\";\nimport {IDecentEthRouter} from \"./interfaces/IDecentEthRouter.sol\";\n\ncontract DecentEthRouter is IDecentEthRouter, IOFTReceiverV2, Owned {\n    IWETH public weth;\n    IDcntEth public dcntEth;\n    IDecentBridgeExecutor public executor;\n\n    uint8 public constant MT_ETH_TRANSFER = 0;\n    uint8 public constant MT_ETH_TRANSFER_WITH_PAYLOAD = 1;\n\n    uint16 public constant PT_SEND_AND_CALL = 1;\n\n    bool public gasCurrencyIsEth; // for chains that use ETH as gas currency\n\n    mapping(uint16 => address) public destinationBridges;\n    mapping(address => uint256) public balanceOf;\n\n    constructor(\n        address payable _wethAddress,\n        bool gasIsEth,\n        address _executor\n    ) Owned(msg.sender) {\n        weth = IWETH(_wethAddress);\n        gasCurrencyIsEth = gasIsEth;\n        executor = IDecentBridgeExecutor(payable(_executor));\n    }\n\n    modifier onlyEthChain() {\n        require(gasCurrencyIsEth, \"Gas currency is not ETH\");\n        _;\n    }\n\n    modifier onlyLzApp() {\n        require(\n            address(dcntEth) == msg.sender,\n            \"DecentEthRouter: only lz App can call\"\n        );\n        _;\n    }\n\n    modifier onlyIfWeHaveEnoughReserves(uint256 amount) {\n        require(weth.balanceOf(address(this)) > amount, \"not enough reserves\");\n        _;\n    }\n\n    modifier userDepositing(uint256 amount) {\n        balanceOf[msg.sender] += amount;\n        _;\n    }\n\n    modifier userIsWithdrawing(uint256 amount) {\n        uint256 balance = balanceOf[msg.sender];\n        require(balance >= amount, \"not enough balance\");\n        _;\n        balanceOf[msg.sender] -= amount;\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function registerDcntEth(address _addr) public onlyOwner {\n        dcntEth = IDcntEth(_addr);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function addDestinationBridge(\n        uint16 _dstChainId,\n        address _routerAddress\n    ) public onlyOwner {\n        destinationBridges[_dstChainId] = _routerAddress;\n    }\n\n    function _getCallParams(\n        uint8 msgType,\n        address _toAddress,\n        uint16 _dstChainId,\n        uint64 _dstGasForCall,\n        bool deliverEth,\n        bytes memory additionalPayload\n    )\n        private\n        view\n        returns (\n            bytes32 destBridge,\n            bytes memory adapterParams,\n            bytes memory payload\n        )\n    {\n        uint256 GAS_FOR_RELAY = 100000;\n        uint256 gasAmount = GAS_FOR_RELAY + _dstGasForCall;\n        adapterParams = abi.encodePacked(PT_SEND_AND_CALL, gasAmount);\n        destBridge = bytes32(abi.encode(destinationBridges[_dstChainId]));\n        if (msgType == MT_ETH_TRANSFER) {\n            payload = abi.encode(msgType, msg.sender, _toAddress, deliverEth);\n        } else {\n            payload = abi.encode(\n                msgType,\n                msg.sender,\n                _toAddress,\n                deliverEth,\n                additionalPayload\n            );\n        }\n    }\n\n    function estimateSendAndCallFee(\n        uint8 msgType,\n        uint16 _dstChainId,\n        address _toAddress,\n        uint _amount,\n        uint64 _dstGasForCall,\n        bool deliverEth,\n        bytes memory payload\n    ) public view returns (uint nativeFee, uint zroFee) {\n        (\n            bytes32 destinationBridge,\n            bytes memory adapterParams,\n            bytes memory _payload\n        ) = _getCallParams(\n                msgType,\n                _toAddress,\n                _dstChainId,\n                _dstGasForCall,\n                deliverEth,\n                payload\n            );\n\n        return\n            dcntEth.estimateSendAndCallFee(\n                _dstChainId,\n                destinationBridge,\n                _amount,\n                _payload,\n                _dstGasForCall,\n                false, // useZero\n                adapterParams // Relayer adapter parameters\n                // contains packet type (send and call in this case) and gasAmount\n            );\n    }\n\n    function _bridgeWithPayload(\n        uint8 msgType,\n        uint16 _dstChainId,\n        address _toAddress,\n        uint _amount,\n        uint64 _dstGasForCall,\n        bytes memory additionalPayload,\n        bool deliverEth\n    ) internal {\n        (\n            bytes32 destinationBridge,\n            bytes memory adapterParams,\n            bytes memory payload\n        ) = _getCallParams(\n                msgType,\n                _toAddress,\n                _dstChainId,\n                _dstGasForCall,\n                deliverEth,\n                additionalPayload\n            );\n\n        ICommonOFT.LzCallParams memory callParams = ICommonOFT.LzCallParams({\n            refundAddress: payable(msg.sender),\n            zroPaymentAddress: address(0x0),\n            adapterParams: adapterParams\n        });\n\n        uint gasValue;\n        if (gasCurrencyIsEth) {\n            weth.deposit{value: _amount}();\n            gasValue = msg.value - _amount;\n        } else {\n            weth.transferFrom(msg.sender, address(this), _amount);\n            gasValue = msg.value;\n        }\n\n        dcntEth.sendAndCall{value: gasValue}(\n            address(this), // from address that has dcntEth (so DecentRouter)\n            _dstChainId,\n            destinationBridge, // toAddress\n            _amount, // amount\n            payload, //payload (will have recipients address)\n            _dstGasForCall, // dstGasForCall\n            callParams // refundAddress, zroPaymentAddress, adapterParams\n        );\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function bridgeWithPayload(\n        uint16 _dstChainId,\n        address _toAddress,\n        uint _amount,\n        bool deliverEth,\n        uint64 _dstGasForCall,\n        bytes memory additionalPayload\n    ) public payable {\n        return\n            _bridgeWithPayload(\n                MT_ETH_TRANSFER_WITH_PAYLOAD,\n                _dstChainId,\n                _toAddress,\n                _amount,\n                _dstGasForCall,\n                additionalPayload,\n                deliverEth\n            );\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function bridge(\n        uint16 _dstChainId,\n        address _toAddress,\n        uint _amount,\n        uint64 _dstGasForCall,\n        bool deliverEth // if false, delivers WETH\n    ) public payable {\n        _bridgeWithPayload(\n            MT_ETH_TRANSFER,\n            _dstChainId,\n            _toAddress,\n            _amount,\n            _dstGasForCall,\n            bytes(\"\"),\n            deliverEth\n        );\n    }\n\n    /// @inheritdoc IOFTReceiverV2\n    function onOFTReceived(\n        uint16 _srcChainId,\n        bytes calldata,\n        uint64,\n        bytes32,\n        uint _amount,\n        bytes memory _payload\n    ) external override onlyLzApp {\n        (uint8 msgType, address _from, address _to, bool deliverEth) = abi\n            .decode(_payload, (uint8, address, address, bool));\n\n        bytes memory callPayload = \"\";\n\n        if (msgType == MT_ETH_TRANSFER_WITH_PAYLOAD) {\n            (, , , , callPayload) = abi.decode(\n                _payload,\n                (uint8, address, address, bool, bytes)\n            );\n        }\n\n        emit ReceivedDecentEth(\n            msgType,\n            _srcChainId,\n            _from,\n            _to,\n            _amount,\n            callPayload\n        );\n\n        if (weth.balanceOf(address(this)) < _amount) {\n            dcntEth.transfer(_to, _amount);\n            return;\n        }\n\n        if (msgType == MT_ETH_TRANSFER) {\n            if (!gasCurrencyIsEth || !deliverEth) {\n                weth.transfer(_to, _amount);\n            } else {\n                weth.withdraw(_amount);\n                payable(_to).transfer(_amount);\n            }\n        } else {\n            weth.approve(address(executor), _amount);\n            executor.execute(_from, _to, deliverEth, _amount, callPayload);\n        }\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function redeemEth(\n        uint256 amount\n    ) public onlyIfWeHaveEnoughReserves(amount) {\n        dcntEth.transferFrom(msg.sender, address(this), amount);\n        weth.withdraw(amount);\n        payable(msg.sender).transfer(amount);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function redeemWeth(\n        uint256 amount\n    ) public onlyIfWeHaveEnoughReserves(amount) {\n        dcntEth.transferFrom(msg.sender, address(this), amount);\n        weth.transfer(msg.sender, amount);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function addLiquidityEth()\n        public\n        payable\n        onlyEthChain\n        userDepositing(msg.value)\n    {\n        weth.deposit{value: msg.value}();\n        dcntEth.mint(address(this), msg.value);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function removeLiquidityEth(\n        uint256 amount\n    ) public onlyEthChain userIsWithdrawing(amount) {\n        dcntEth.burn(address(this), amount);\n        weth.withdraw(amount);\n        payable(msg.sender).transfer(amount);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function addLiquidityWeth(\n        uint256 amount\n    ) public payable userDepositing(amount) {\n        weth.transferFrom(msg.sender, address(this), amount);\n        dcntEth.mint(address(this), amount);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function removeLiquidityWeth(\n        uint256 amount\n    ) public userIsWithdrawing(amount) {\n        dcntEth.burn(address(this), amount);\n        weth.transfer(msg.sender, amount);\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n}"
    },
    {
      "filename": "src/DecentBridgeExecutor.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {IDecentBridgeExecutor} from \"./interfaces/IDecentBridgeExecutor.sol\";\n\ncontract DecentBridgeExecutor is IDecentBridgeExecutor, Owned {\n    IWETH weth;\n    bool public gasCurrencyIsEth; // for chains that use ETH as gas currency\n\n    constructor(address _weth, bool gasIsEth) Owned(msg.sender) {\n        weth = IWETH(payable(_weth));\n        gasCurrencyIsEth = gasIsEth;\n    }\n\n    /**\n     * @dev helper function for execute\n     * @param from caller of the function\n     * @param target target contract\n     * @param amount amount of the in eth\n     * @param callPayload payload for the tx\n     */\n    function _executeWeth(\n        address from,\n        address target,\n        uint256 amount,\n        bytes memory callPayload\n    ) private {\n        uint256 balanceBefore = weth.balanceOf(address(this));\n        weth.approve(target, amount);\n\n        (bool success, ) = target.call(callPayload);\n\n        if (!success) {\n            weth.transfer(from, amount);\n            return;\n        }\n\n        uint256 remainingAfterCall = amount -\n            (balanceBefore - weth.balanceOf(address(this)));\n\n        // refund the sender with excess WETH\n        weth.transfer(from, remainingAfterCall);\n    }\n\n    /**\n     * @dev helper function for execute\n     * @param from caller of the function\n     * @param target target contract\n     * @param amount amount of the transaction\n     * @param callPayload payload for the tx\n     */\n    function _executeEth(\n        address from,\n        address target,\n        uint256 amount,\n        bytes memory callPayload\n    ) private {\n        weth.withdraw(amount);\n        (bool success, ) = target.call{value: amount}(callPayload);\n        if (!success) {\n            payable(from).transfer(amount);\n        }\n    }\n\n    /// @inheritdoc IDecentBridgeExecutor\n    function execute(\n        address from,\n        address target,\n        bool deliverEth,\n        uint256 amount,\n        bytes memory callPayload\n    ) public onlyOwner {\n        weth.transferFrom(msg.sender, address(this), amount);\n\n        if (!gasCurrencyIsEth || !deliverEth) {\n            _executeWeth(from, target, amount, callPayload);\n        } else {\n            _executeEth(from, target, amount, callPayload);\n        }\n    }\n\n    // Function to receive Ether. msg.data must be empty\n    receive() external payable {}\n\n    // Fallback function is called when msg.data is not empty\n    fallback() external payable {}\n}"
    },
    {
      "filename": "src/DecentEthRouter.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {IDcntEth} from \"./interfaces/IDcntEth.sol\";\nimport {ICommonOFT} from \"solidity-examples/token/oft/v2/interfaces/ICommonOFT.sol\";\nimport {IOFTReceiverV2} from \"solidity-examples/token/oft/v2/interfaces/IOFTReceiverV2.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {IDecentBridgeExecutor} from \"./interfaces/IDecentBridgeExecutor.sol\";\nimport {IDecentEthRouter} from \"./interfaces/IDecentEthRouter.sol\";\n\ncontract DecentEthRouter is IDecentEthRouter, IOFTReceiverV2, Owned {\n    IWETH public weth;\n    IDcntEth public dcntEth;\n    IDecentBridgeExecutor public executor;\n\n    uint8 public constant MT_ETH_TRANSFER = 0;\n    uint8 public constant MT_ETH_TRANSFER_WITH_PAYLOAD = 1;\n\n    uint16 public constant PT_SEND_AND_CALL = 1;\n\n    bool public gasCurrencyIsEth; // for chains that use ETH as gas currency\n\n    mapping(uint16 => address) public destinationBridges;\n    mapping(address => uint256) public balanceOf;\n\n    constructor(\n        address payable _wethAddress,\n        bool gasIsEth,\n        address _executor\n    ) Owned(msg.sender) {\n        weth = IWETH(_wethAddress);\n        gasCurrencyIsEth = gasIsEth;\n        executor = IDecentBridgeExecutor(payable(_executor));\n    }\n\n    modifier onlyEthChain() {\n        require(gasCurrencyIsEth, \"Gas currency is not ETH\");\n        _;\n    }\n\n    modifier onlyLzApp() {\n        require(\n            address(dcntEth) == msg.sender,\n            \"DecentEthRouter: only lz App can call\"\n        );\n        _;\n    }\n\n    modifier onlyIfWeHaveEnoughReserves(uint256 amount) {\n        require(weth.balanceOf(address(this)) > amount, \"not enough reserves\");\n        _;\n    }\n\n    modifier userDepositing(uint256 amount) {\n        balanceOf[msg.sender] += amount;\n        _;\n    }\n\n    modifier userIsWithdrawing(uint256 amount) {\n        uint256 balance = balanceOf[msg.sender];\n        require(balance >= amount, \"not enough balance\");\n        _;\n        balanceOf[msg.sender] -= amount;\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function registerDcntEth(address _addr) public onlyOwner {\n        dcntEth = IDcntEth(_addr);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function addDestinationBridge(\n        uint16 _dstChainId,\n        address _routerAddress\n    ) public onlyOwner {\n        destinationBridges[_dstChainId] = _routerAddress;\n    }\n\n    function _getCallParams(\n        uint8 msgType,\n        address _toAddress,\n        uint16 _dstChainId,\n        uint64 _dstGasForCall,\n        bool deliverEth,\n        bytes memory additionalPayload\n    )\n        private\n        view\n        returns (\n            bytes32 destBridge,\n            bytes memory adapterParams,\n            bytes memory payload\n        )\n    {\n        uint256 GAS_FOR_RELAY = 100000;\n        uint256 gasAmount = GAS_FOR_RELAY + _dstGasForCall;\n        adapterParams = abi.encodePacked(PT_SEND_AND_CALL, gasAmount);\n        destBridge = bytes32(abi.encode(destinationBridges[_dstChainId]));\n        if (msgType == MT_ETH_TRANSFER) {\n            payload = abi.encode(msgType, msg.sender, _toAddress, deliverEth);\n        } else {\n            payload = abi.encode(\n                msgType,\n                msg.sender,\n                _toAddress,\n                deliverEth,\n                additionalPayload\n            );\n        }\n    }\n\n    function estimateSendAndCallFee(\n        uint8 msgType,\n        uint16 _dstChainId,\n        address _toAddress,\n        uint _amount,\n        uint64 _dstGasForCall,\n        bool deliverEth,\n        bytes memory payload\n    ) public view returns (uint nativeFee, uint zroFee) {\n        (\n            bytes32 destinationBridge,\n            bytes memory adapterParams,\n            bytes memory _payload\n        ) = _getCallParams(\n                msgType,\n                _toAddress,\n                _dstChainId,\n                _dstGasForCall,\n                deliverEth,\n                payload\n            );\n\n        return\n            dcntEth.estimateSendAndCallFee(\n                _dstChainId,\n                destinationBridge,\n                _amount,\n                _payload,\n                _dstGasForCall,\n                false, // useZero\n                adapterParams // Relayer adapter parameters\n                // contains packet type (send and call in this case) and gasAmount\n            );\n    }\n\n    function _bridgeWithPayload(\n        uint8 msgType,\n        uint16 _dstChainId,\n        address _toAddress,\n        uint _amount,\n        uint64 _dstGasForCall,\n        bytes memory additionalPayload,\n        bool deliverEth\n    ) internal {\n        (\n            bytes32 destinationBridge,\n            bytes memory adapterParams,\n            bytes memory payload\n        ) = _getCallParams(\n                msgType,\n                _toAddress,\n                _dstChainId,\n                _dstGasForCall,\n                deliverEth,\n                additionalPayload\n            );\n\n        ICommonOFT.LzCallParams memory callParams = ICommonOFT.LzCallParams({\n            refundAddress: payable(msg.sender),\n            zroPaymentAddress: address(0x0),\n            adapterParams: adapterParams\n        });\n\n        uint gasValue;\n        if (gasCurrencyIsEth) {\n            weth.deposit{value: _amount}();\n            gasValue = msg.value - _amount;\n        } else {\n            weth.transferFrom(msg.sender, address(this), _amount);\n            gasValue = msg.value;\n        }\n\n        dcntEth.sendAndCall{value: gasValue}(\n            address(this), // from address that has dcntEth (so DecentRouter)\n            _dstChainId,\n            destinationBridge, // toAddress\n            _amount, // amount\n            payload, //payload (will have recipients address)\n            _dstGasForCall, // dstGasForCall\n            callParams // refundAddress, zroPaymentAddress, adapterParams\n        );\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function bridgeWithPayload(\n        uint16 _dstChainId,\n        address _toAddress,\n        uint _amount,\n        bool deliverEth,\n        uint64 _dstGasForCall,\n        bytes memory additionalPayload\n    ) public payable {\n        return\n            _bridgeWithPayload(\n                MT_ETH_TRANSFER_WITH_PAYLOAD,\n                _dstChainId,\n                _toAddress,\n                _amount,\n                _dstGasForCall,\n                additionalPayload,\n                deliverEth\n            );\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function bridge(\n        uint16 _dstChainId,\n        address _toAddress,\n        uint _amount,\n        uint64 _dstGasForCall,\n        bool deliverEth // if false, delivers WETH\n    ) public payable {\n        _bridgeWithPayload(\n            MT_ETH_TRANSFER,\n            _dstChainId,\n            _toAddress,\n            _amount,\n            _dstGasForCall,\n            bytes(\"\"),\n            deliverEth\n        );\n    }\n\n    /// @inheritdoc IOFTReceiverV2\n    function onOFTReceived(\n        uint16 _srcChainId,\n        bytes calldata,\n        uint64,\n        bytes32,\n        uint _amount,\n        bytes memory _payload\n    ) external override onlyLzApp {\n        (uint8 msgType, address _from, address _to, bool deliverEth) = abi\n            .decode(_payload, (uint8, address, address, bool));\n\n        bytes memory callPayload = \"\";\n\n        if (msgType == MT_ETH_TRANSFER_WITH_PAYLOAD) {\n            (, , , , callPayload) = abi.decode(\n                _payload,\n                (uint8, address, address, bool, bytes)\n            );\n        }\n\n        emit ReceivedDecentEth(\n            msgType,\n            _srcChainId,\n            _from,\n            _to,\n            _amount,\n            callPayload\n        );\n\n        if (weth.balanceOf(address(this)) < _amount) {\n            dcntEth.transfer(_to, _amount);\n            return;\n        }\n\n        if (msgType == MT_ETH_TRANSFER) {\n            if (!gasCurrencyIsEth || !deliverEth) {\n                weth.transfer(_to, _amount);\n            } else {\n                weth.withdraw(_amount);\n                payable(_to).transfer(_amount);\n            }\n        } else {\n            weth.approve(address(executor), _amount);\n            executor.execute(_from, _to, deliverEth, _amount, callPayload);\n        }\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function redeemEth(\n        uint256 amount\n    ) public onlyIfWeHaveEnoughReserves(amount) {\n        dcntEth.transferFrom(msg.sender, address(this), amount);\n        weth.withdraw(amount);\n        payable(msg.sender).transfer(amount);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function redeemWeth(\n        uint256 amount\n    ) public onlyIfWeHaveEnoughReserves(amount) {\n        dcntEth.transferFrom(msg.sender, address(this), amount);\n        weth.transfer(msg.sender, amount);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function addLiquidityEth()\n        public\n        payable\n        onlyEthChain\n        userDepositing(msg.value)\n    {\n        weth.deposit{value: msg.value}();\n        dcntEth.mint(address(this), msg.value);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function removeLiquidityEth(\n        uint256 amount\n    ) public onlyEthChain userIsWithdrawing(amount) {\n        dcntEth.burn(address(this), amount);\n        weth.withdraw(amount);\n        payable(msg.sender).transfer(amount);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function addLiquidityWeth(\n        uint256 amount\n    ) public payable userDepositing(amount) {\n        weth.transferFrom(msg.sender, address(this), amount);\n        dcntEth.mint(address(this), amount);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function removeLiquidityWeth(\n        uint256 amount\n    ) public userIsWithdrawing(amount) {\n        dcntEth.burn(address(this), amount);\n        weth.transfer(msg.sender, amount);\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n}"
    },
    {
      "filename": "src/bridge_adapters/DecentBridgeAdapter.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\nimport {IUTB} from \"../interfaces/IUTB.sol\";\nimport {IBridgeAdapter} from \"../interfaces/IBridgeAdapter.sol\";\nimport {SwapInstructions} from \"../CommonTypes.sol\";\nimport {SwapParams} from \"../swappers/SwapParams.sol\";\nimport {IDecentEthRouter} from \"decent-bridge/src/interfaces/IDecentEthRouter.sol\";\nimport {BaseAdapter} from \"./BaseAdapter.sol\";\n\ncontract DecentBridgeAdapter is BaseAdapter, IBridgeAdapter {\n    uint8 public constant BRIDGE_ID = 0;\n    mapping(uint256 => address) public destinationBridgeAdapter;\n    IDecentEthRouter public router;\n    mapping(uint256 => uint16) lzIdLookup;\n    mapping(uint16 => uint256) chainIdLookup;\n    bool gasIsEth;\n    address bridgeToken;\n\n    constructor(bool _gasIsEth, address _bridgeToken) BaseAdapter() {\n        gasIsEth = _gasIsEth;\n        bridgeToken = _bridgeToken;\n    }\n\n    function setRouter(address _router) public onlyOwner {\n        router = IDecentEthRouter(payable(_router));\n    }\n\n    function getId() public pure returns (uint8) {\n        return BRIDGE_ID;\n    }\n\n    function registerRemoteBridgeAdapter(\n        uint256 dstChainId,\n        uint16 dstLzId,\n        address decentBridgeAdapter\n    ) public onlyOwner {\n        lzIdLookup[dstChainId] = dstLzId;\n        chainIdLookup[dstLzId] = dstChainId;\n        destinationBridgeAdapter[dstChainId] = decentBridgeAdapter;\n    }\n\n    function estimateFees(\n        SwapInstructions memory postBridge,\n        uint256 dstChainId,\n        address target,\n        uint64 dstGas,\n        bytes memory payload\n    ) public view returns (uint nativeFee, uint zroFee) {\n        SwapParams memory swapParams = abi.decode(\n            postBridge.swapPayload,\n            (SwapParams)\n        );\n        return\n            router.estimateSendAndCallFee(\n                router.MT_ETH_TRANSFER_WITH_PAYLOAD(),\n                lzIdLookup[dstChainId],\n                target,\n                swapParams.amountIn,\n                dstGas,\n                false,\n                payload\n            );\n    }\n\n    function getBridgeToken(\n        bytes calldata /*additionalArgs*/\n    ) external view returns (address) {\n        return bridgeToken;\n    }\n\n    function getBridgedAmount(\n        uint256 amt2Bridge,\n        address /*tokenIn*/,\n        address /*tokenOut*/\n    ) external pure returns (uint256) {\n        return amt2Bridge;\n    }\n\n    function bridge(\n        uint256 amt2Bridge,\n        SwapInstructions memory postBridge,\n        uint256 dstChainId,\n        address target,\n        address paymentOperator,\n        bytes memory payload,\n        bytes calldata additionalArgs,\n        address payable refund\n    ) public payable onlyUtb returns (bytes memory bridgePayload) {\n        require(\n            destinationBridgeAdapter[dstChainId] != address(0),\n            string.concat(\"dst chain address not set \")\n        );\n\n        uint64 dstGas = abi.decode(additionalArgs, (uint64));\n\n        bridgePayload = abi.encodeCall(\n            this.receiveFromBridge,\n            (postBridge, target, paymentOperator, payload, refund)\n        );\n\n        SwapParams memory swapParams = abi.decode(\n            postBridge.swapPayload,\n            (SwapParams)\n        );\n\n        if (!gasIsEth) {\n            IERC20(bridgeToken).transferFrom(\n                msg.sender,\n                address(this),\n                amt2Bridge\n            );\n            IERC20(bridgeToken).approve(address(router), amt2Bridge);\n        }\n\n        router.bridgeWithPayload{value: msg.value}(\n            lzIdLookup[dstChainId],\n            destinationBridgeAdapter[dstChainId],\n            swapParams.amountIn,\n            false,\n            dstGas,\n            bridgePayload\n        );\n    }\n\n    function receiveFromBridge(\n        SwapInstructions memory postBridge,\n        address target,\n        address paymentOperator,\n        bytes memory payload,\n        address payable refund\n    ) public onlyExecutor {\n        SwapParams memory swapParams = abi.decode(\n            postBridge.swapPayload,\n            (SwapParams)\n        );\n\n        IERC20(swapParams.tokenIn).transferFrom(\n            msg.sender,\n            address(this),\n            swapParams.amountIn\n        );\n\n        IERC20(swapParams.tokenIn).approve(utb, swapParams.amountIn);\n\n        IUTB(utb).receiveFromBridge(\n            postBridge,\n            target,\n            paymentOperator,\n            payload,\n            refund\n        );\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n}"
    },
    {
      "filename": "src/DecentEthRouter.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {IDcntEth} from \"./interfaces/IDcntEth.sol\";\nimport {ICommonOFT} from \"solidity-examples/token/oft/v2/interfaces/ICommonOFT.sol\";\nimport {IOFTReceiverV2} from \"solidity-examples/token/oft/v2/interfaces/IOFTReceiverV2.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {IDecentBridgeExecutor} from \"./interfaces/IDecentBridgeExecutor.sol\";\nimport {IDecentEthRouter} from \"./interfaces/IDecentEthRouter.sol\";\n\ncontract DecentEthRouter is IDecentEthRouter, IOFTReceiverV2, Owned {\n    IWETH public weth;\n    IDcntEth public dcntEth;\n    IDecentBridgeExecutor public executor;\n\n    uint8 public constant MT_ETH_TRANSFER = 0;\n    uint8 public constant MT_ETH_TRANSFER_WITH_PAYLOAD = 1;\n\n    uint16 public constant PT_SEND_AND_CALL = 1;\n\n    bool public gasCurrencyIsEth; // for chains that use ETH as gas currency\n\n    mapping(uint16 => address) public destinationBridges;\n    mapping(address => uint256) public balanceOf;\n\n    constructor(\n        address payable _wethAddress,\n        bool gasIsEth,\n        address _executor\n    ) Owned(msg.sender) {\n        weth = IWETH(_wethAddress);\n        gasCurrencyIsEth = gasIsEth;\n        executor = IDecentBridgeExecutor(payable(_executor));\n    }\n\n    modifier onlyEthChain() {\n        require(gasCurrencyIsEth, \"Gas currency is not ETH\");\n        _;\n    }\n\n    modifier onlyLzApp() {\n        require(\n            address(dcntEth) == msg.sender,\n            \"DecentEthRouter: only lz App can call\"\n        );\n        _;\n    }\n\n    modifier onlyIfWeHaveEnoughReserves(uint256 amount) {\n        require(weth.balanceOf(address(this)) > amount, \"not enough reserves\");\n        _;\n    }\n\n    modifier userDepositing(uint256 amount) {\n        balanceOf[msg.sender] += amount;\n        _;\n    }\n\n    modifier userIsWithdrawing(uint256 amount) {\n        uint256 balance = balanceOf[msg.sender];\n        require(balance >= amount, \"not enough balance\");\n        _;\n        balanceOf[msg.sender] -= amount;\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function registerDcntEth(address _addr) public onlyOwner {\n        dcntEth = IDcntEth(_addr);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function addDestinationBridge(\n        uint16 _dstChainId,\n        address _routerAddress\n    ) public onlyOwner {\n        destinationBridges[_dstChainId] = _routerAddress;\n    }\n\n    function _getCallParams(\n        uint8 msgType,\n        address _toAddress,\n        uint16 _dstChainId,\n        uint64 _dstGasForCall,\n        bool deliverEth,\n        bytes memory additionalPayload\n    )\n        private\n        view\n        returns (\n            bytes32 destBridge,\n            bytes memory adapterParams,\n            bytes memory payload\n        )\n    {\n        uint256 GAS_FOR_RELAY = 100000;\n        uint256 gasAmount = GAS_FOR_RELAY + _dstGasForCall;\n        adapterParams = abi.encodePacked(PT_SEND_AND_CALL, gasAmount);\n        destBridge = bytes32(abi.encode(destinationBridges[_dstChainId]));\n        if (msgType == MT_ETH_TRANSFER) {\n            payload = abi.encode(msgType, msg.sender, _toAddress, deliverEth);\n        } else {\n            payload = abi.encode(\n                msgType,\n                msg.sender,\n                _toAddress,\n                deliverEth,\n                additionalPayload\n            );\n        }\n    }\n\n    function estimateSendAndCallFee(\n        uint8 msgType,\n        uint16 _dstChainId,\n        address _toAddress,\n        uint _amount,\n        uint64 _dstGasForCall,\n        bool deliverEth,\n        bytes memory payload\n    ) public view returns (uint nativeFee, uint zroFee) {\n        (\n            bytes32 destinationBridge,\n            bytes memory adapterParams,\n            bytes memory _payload\n        ) = _getCallParams(\n                msgType,\n                _toAddress,\n                _dstChainId,\n                _dstGasForCall,\n                deliverEth,\n                payload\n            );\n\n        return\n            dcntEth.estimateSendAndCallFee(\n                _dstChainId,\n                destinationBridge,\n                _amount,\n                _payload,\n                _dstGasForCall,\n                false, // useZero\n                adapterParams // Relayer adapter parameters\n                // contains packet type (send and call in this case) and gasAmount\n            );\n    }\n\n    function _bridgeWithPayload(\n        uint8 msgType,\n        uint16 _dstChainId,\n        address _toAddress,\n        uint _amount,\n        uint64 _dstGasForCall,\n        bytes memory additionalPayload,\n        bool deliverEth\n    ) internal {\n        (\n            bytes32 destinationBridge,\n            bytes memory adapterParams,\n            bytes memory payload\n        ) = _getCallParams(\n                msgType,\n                _toAddress,\n                _dstChainId,\n                _dstGasForCall,\n                deliverEth,\n                additionalPayload\n            );\n\n        ICommonOFT.LzCallParams memory callParams = ICommonOFT.LzCallParams({\n            refundAddress: payable(msg.sender),\n            zroPaymentAddress: address(0x0),\n            adapterParams: adapterParams\n        });\n\n        uint gasValue;\n        if (gasCurrencyIsEth) {\n            weth.deposit{value: _amount}();\n            gasValue = msg.value - _amount;\n        } else {\n            weth.transferFrom(msg.sender, address(this), _amount);\n            gasValue = msg.value;\n        }\n\n        dcntE"
    }
  ]
}