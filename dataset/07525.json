{
  "Title": "[H-04] Anyone can prevent themselves from being liquidated as long as they hold one of the supported NFTs",
  "Content": "\nContrary to what the function comments say, `removeFeeder()` is able to be called by anyone, not just the owner. By removing all feeders (i.e. floor twap price oracle keepers), a malicious user can cause all queries for the price of NFTs reliant on the `NFTFloorOracle` (all NFTs except for the UniswapV3 ones), to revert, which will cause all calls to `liquidateERC721()` to revert.\n\n### Impact\n\nIf NFTs can't be liquidated, positions will remain open for longer than they should, and the protocol may become insolvent by the time the issue is resolved.\n\n### Proof of Concept\n\nThe `onlyRole(DEFAULT_ADMIN_ROLE)` should have been used instead of `onlyWhenFeederExisted`...\n\n```solidity\nFile: /paraspace-core/contracts/misc/NFTFloorOracle.sol   #1\n\n165      /// @notice Allows owner to remove feeder.\n166      /// @param _feeder feeder to remove\n167      function removeFeeder(address _feeder)\n168          external\n169          onlyWhenFeederExisted(_feeder)\n170      {\n171          _removeFeeder(_feeder);\n172:     }\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L165-L172><br>\n\n... since `onlyWhenFeederExisted` is already on the internal call to `_removeFeeder()` (`onlyWhenFeederExisted` doesn't do any authentication of the caller):\n\n```solidity\nFile: /paraspace-core/contracts/misc/NFTFloorOracle.sol   #2\n\n326      function _removeFeeder(address _feeder)\n327          internal\n328          onlyWhenFeederExisted(_feeder)\n329      {\n330          uint8 feederIndex = feederPositionMap[_feeder].index;\n331          if (feederIndex >= 0 && feeders[feederIndex] == _feeder) {\n332              feeders[feederIndex] = feeders[feeders.length - 1];\n333              feeders.pop();\n334          }\n335          delete feederPositionMap[_feeder];\n336          revokeRole(UPDATER_ROLE, _feeder);\n337          emit FeederRemoved(_feeder);\n338:     }\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L326-L338><br>\n\nNote that `feeders` must have the `UPDATER_ROLE` (revoked above) in order to update the price.\n\nThe fetching of the price will revert if the price is stale:\n\n```solidity\nFile: /paraspace-core/contracts/misc/NFTFloorOracle.sol   #3\n\n234      /// @param _asset The nft contract\n235      /// @return price The most recent price on chain\n236      function getPrice(address _asset)\n237          external\n238          view\n239          override\n240          returns (uint256 price)\n241      {\n242          uint256 updatedAt = assetPriceMap[_asset].updatedAt;\n243          require(\n244 @>           (block.number - updatedAt) <= config.expirationPeriod,\n245              \"NFTOracle: asset price expired\"\n246          );\n247          return assetPriceMap[_asset].twap;\n248:     }\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L234-L248><br>\n\nAnd it will become stale if there are no feeders for enough time:\n\n```solidity\nFile: /paraspace-core/contracts/misc/NFTFloorOracle.sol   #4\n\n195      function setPrice(address _asset, uint256 _twap)\n196          public\n197 @>       onlyRole(UPDATER_ROLE)\n198          onlyWhenAssetExisted(_asset)\n199          whenNotPaused(_asset)\n200      {\n201          bool dataValidity = false;\n202          if (hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n203 @>           _finalizePrice(_asset, _twap);\n204              return;\n205          }\n206          dataValidity = _checkValidity(_asset, _twap);\n207          require(dataValidity, \"NFTOracle: invalid price data\");\n208          // add price to raw feeder storage\n209          _addRawValue(_asset, _twap);\n210          uint256 medianPrice;\n211          // set twap price only when median value is valid\n212          (dataValidity, medianPrice) = _combine(_asset, _twap);\n213          if (dataValidity) {\n214 @>           _finalizePrice(_asset, medianPrice);\n215          }\n216:     }\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L195-L216><br>\n\n```solidity\nFile: /paraspace-core/contracts/misc/NFTFloorOracle.sol   #5\n\n376      function _finalizePrice(address _asset, uint256 _twap) internal {\n377          PriceInformation storage assetPriceMapEntry = assetPriceMap[_asset];\n378          assetPriceMapEntry.twap = _twap;\n379 @>       assetPriceMapEntry.updatedAt = block.number;\n380          assetPriceMapEntry.updatedTimestamp = block.timestamp;\n381          emit AssetDataSet(\n382              _asset,\n383              assetPriceMapEntry.twap,\n384              assetPriceMapEntry.updatedAt\n385          );\n386:     }\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L376-L386><br>\n\nNote that the default staleness interval is six hours:\n\n```solidity\nFile: /paraspace-core/contracts/misc/NFTFloorOracle.sol   #6\n\n10   //expirationPeriod at least the interval of client to feed data(currently 6h=21600s/12=1800 in mainnet)\n11   //we do not accept price lags behind to much\n12:  uint128 constant EXPIRATION_PERIOD = 1800;\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L10-L12><br>\n\nThe reverting `getPrice()` function is called from the `ERC721OracleWrapper` where it is not caught:\n\n```solidity\nFile: /paraspace-core/contracts/misc/ERC721OracleWrapper.sol   #7\n\n44       function setOracle(address _oracleAddress)\n45           external\n46           onlyAssetListingOrPoolAdmins\n47       {\n48 @>        oracleAddress = INFTFloorOracle(_oracleAddress);\n49       }\n50   \n...\n54   \n55       function latestAnswer() external view override returns (int256) {\n56 @>        return int256(oracleAddress.getPrice(asset));\n57:      }\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/ERC721OracleWrapper.sol#L44-L57><br>\n\nAnd neither is it caught from any of the callers further up the chain (note that the fallback oracle can't be hit since the call reverts before that):\n\n```solidity\nFile: /paraspace-core/contracts/misc/ERC721OracleWrapper.sol   #8\n\n10:  contract ERC721OracleWrapper is IEACAggregatorProxy {\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/ERC721OracleWrapper.sol#L10><br>\n\n```solidity\nFile: /paraspace-core/contracts/misc/ParaSpaceOracle.sol   #9\n\n114      /// @inheritdoc IPriceOracleGetter\n115      function getAssetPrice(address asset)\n116          public\n117          view\n118          override\n119          returns (uint256)\n120      {\n121          if (asset == BASE_CURRENCY) {\n122              return BASE_CURRENCY_UNIT;\n123          }\n124  \n125          uint256 price = 0;\n126 @>       IEACAggregatorProxy source = IEACAggregatorProxy(assetsSources[asset]);\n127          if (address(source) != address(0)) {\n128 @>           price = uint256(source.latestAnswer());\n129          }\n130          if (price == 0 && address(_fallbackOracle) != address(0)) {\n131              price = _fallbackOracle.getAssetPrice(asset);\n132          }\n133  \n134          require(price != 0, Errors.ORACLE_PRICE_NOT_READY);\n135          return price;\n136:     }\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/ParaSpaceOracle.sol#L114-L136><br>\n\n```solidity\nFile: /paraspace-core/contracts/protocol/libraries/logic/GenericLogic.sol   #10\n\n535      function _getAssetPrice(address oracle, address currentReserveAddress)\n536          internal\n537          view\n538          returns (uint256)\n539      {\n540 @>       return IPriceOracleGetter(oracle).getAssetPrice(currentReserveAddress);\n541:     }\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/logic/GenericLogic.sol#L535-L541><br>\n\n```solidity\nFile: /paraspace-core/contracts/protocol/libraries/logic/GenericLogic.sol : _getUserBalanceForERC721()  #11\n\n388 @>           uint256 assetPrice = _getAssetPrice(\n389                  params.oracle,\n390                  vars.currentReserveAddress\n391              );\n392              totalValue =\n393                  ICollateralizableERC721(vars.xTokenAddress)\n394                      .collateralizedBalanceOf(params.user) *\n395                  assetPrice;\n396:         }\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/logic/GenericLogic.sol#L388-L396><br>\n\n```solidity\nFile: /paraspace-core/contracts/protocol/libraries/logic/GenericLogic.sol : calculateUserAccountData()  #12\n\n214                          vars\n215                              .userBalanceInBaseCurrency = _getUserBalanceForERC721(\n216                              params,\n217                              vars\n218:                         );\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/logic/GenericLogic.sol#L214-L218><br>\n\n```solidity\nFile: /paraspace-core/contracts/protocol/libraries/logic/LiquidationLogic.sol   #13\n\n286      function executeLiquidateERC721(\n287          mapping(address => DataTypes.ReserveData) storage reservesData,\n288          mapping(uint256 => address) storage reservesList,\n289          mapping(address => DataTypes.UserConfigurationMap) storage usersConfig,\n290          DataTypes.ExecuteLiquidateParams memory params\n291      ) external returns (uint256) {\n292          ExecuteLiquidateLocalVars memory vars;\n...\n311          (\n312              vars.userGlobalCollateral,\n313              ,\n314              vars.userGlobalDebt, //in base currency\n315              ,\n316              ,\n317              ,\n318              ,\n319              ,\n320              vars.healthFactor,\n321  \n322 @>       ) = GenericLogic.calculateUserAccountData(\n323              reservesData,\n324              reservesList,\n325              DataTypes.CalculateUserAccountDataParams({\n326                  userConfig: userConfig,\n327                  reservesCount: params.reservesCount,\n328                  user: params.borrower,\n329                  oracle: params.priceOracle\n330              })\n331:         );\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/logic/LiquidationLogic.sol#L286-L331><br>\n\n```solidity\nFile: /paraspace-core/contracts/protocol/pool/PoolCore.sol   #14\n\n457      /// @inheritdoc IPoolCore\n458      function liquidateERC721(\n459          address collateralAsset,\n460          address borrower,\n461          uint256 collateralTokenId,\n462          uint256 maxLiquidationAmount,\n463          bool receiveNToken\n464      ) external payable virtual override nonReentrant {\n465          DataTypes.PoolStorage storage ps = poolStorage();\n466  \n467 @>       LiquidationLogic.executeLiquidateERC721(\n468              ps._reserves,\n469              ps._reservesList,\n470:             ps._usersConfig,\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/pool/PoolCore.sol#L457-L470><br>\n\nA person close to liquidation can remove all feeders, giving themselves a free option on whether the extra time it takes for the admins to resolve the issue, is enough time for their position to go back into the green. Alternatively, a competitor can analyze what price most liquidations will occur at (based on on-chain data about every user's account health), and can time the removal of feeders for maximum effect. Note that even if the admins re-add the feeders, the malicious user can just remove them again.\n\n### Recommended Mitigation Steps\n\nAdd the `onlyRole(DEFAULT_ADMIN_ROLE)` modifier to `removeFeeder()`.\n\n**[yubo-ruan (Paraspace) confirmed via duplicate issue `#55`](https://github.com/code-423n4/2022-11-paraspace-findings/issues/55#issuecomment-1338712962)**\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-11-paraspace-contest",
  "Code": [
    {
      "filename": "paraspace-core/contracts/misc/NFTFloorOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"../dependencies/openzeppelin/contracts/AccessControl.sol\";\nimport \"../dependencies/openzeppelin/upgradeability/Initializable.sol\";\nimport \"./interfaces/INFTFloorOracle.sol\";\n\n//we need to deploy 3 oracles at least\nuint8 constant MIN_ORACLES_NUM = 3;\n//expirationPeriod at least the interval of client to feed data(currently 6h=21600s/12=1800 in mainnet)\n//we do not accept price lags behind to much\nuint128 constant EXPIRATION_PERIOD = 1800;\n//reject when price increase/decrease 1.5 times more than original value\nuint128 constant MAX_DEVIATION_RATE = 150;\n\nstruct OracleConfig {\n    // Expiration Period for each feed price\n    uint128 expirationPeriod;\n    // Maximum deviation allowed between two consecutive oracle prices\n    uint128 maxPriceDeviation;\n}\n\nstruct PriceInformation {\n    // last reported floor price(offchain twap)\n    uint256 twap;\n    // last updated blocknumber\n    uint256 updatedAt;\n    // last updated timestamp\n    uint256 updatedTimestamp;\n}\n\nstruct FeederRegistrar {\n    // if asset registered or not\n    bool registered;\n    // index in asset list\n    uint8 index;\n    // if asset paused,reject the price\n    bool paused;\n    // feeder -> PriceInformation\n    mapping(address => PriceInformation) feederPrice;\n}\n\nstruct FeederPosition {\n    // if feeder registered or not\n    bool registered;\n    // index in feeder list\n    uint8 index;\n}\n\n/// @title A simple on-chain price oracle mechanism\n/// @author github.com/drbh,github.com/yrong\n/// @notice Offchain clients can update the prices in this contract. The public can read prices\n/// aggeregate prices which are not expired from different feeders, if number of valid/unexpired prices\n/// not enough, we do not aggeregate and just use previous price\ncontract NFTFloorOracle is Initializable, AccessControl, INFTFloorOracle {\n    event AssetAdded(address indexed asset);\n    event AssetRemoved(address indexed asset);\n    event AssetPaused(address indexed asset, bool paused);\n\n    event FeederAdded(address indexed feeder);\n    event FeederRemoved(address indexed feeder);\n\n    event OracleConfigSet(uint128 expirationPeriod, uint128 maxPriceDeviation);\n    event AssetDataSet(\n        address indexed asset,\n        uint256 twap,\n        uint256 lastUpdatedBlock\n    );\n\n    bytes32 public constant UPDATER_ROLE = keccak256(\"UPDATER_ROLE\");\n\n    /// @dev Aggregated price with address\n    // the NFT contract -> latest price information\n    mapping(address => PriceInformation) public assetPriceMap;\n\n    /// @dev All feeders\n    address[] public feeders;\n\n    /// @dev feeder map\n    // feeder address -> index in feeder list\n    mapping(address => FeederPosition) private feederPositionMap;\n\n    /// @dev All asset list\n    address[] public assets;\n\n    /// @dev Original raw value to aggregate with\n    // the NFT contract address -> FeederRegistrar which contains price from each feeder\n    mapping(address => FeederRegistrar) public assetFeederMap;\n\n    /// @dev storage for oracle configurations\n    OracleConfig public config;\n\n    /// @notice Allow contract creator to set admin and updaters\n    /// @param _admin The admin who can change roles\n    /// @param _feeders The initial updaters\n    /// @param _assets The initial nft assets\n    function initialize(\n        address _admin,\n        address[] memory _feeders,\n        address[] memory _assets\n    ) public initializer {\n        _addAssets(_assets);\n        _addFeeders(_feeders);\n        _setupRole(DEFAULT_ADMIN_ROLE, _admin);\n        //still need to grant update_role to admin for emergency call\n        _setupRole(UPDATER_ROLE, _admin);\n        _setConfig(EXPIRATION_PERIOD, MAX_DEVIATION_RATE);\n    }\n\n    modifier whenNotPaused(address _asset) {\n        if (!hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n            _whenNotPaused(_asset);\n        }\n        _;\n    }\n\n    modifier onlyWhenAssetExisted(address _asset) {\n        require(_isAssetExisted(_asset), \"NFTOracle: asset not existed\");\n        _;\n    }\n\n    modifier onlyWhenAssetNotExisted(address _asset) {\n        require(!_isAssetExisted(_asset), \"NFTOracle: asset existed\");\n        _;\n    }\n\n    modifier onlyWhenFeederExisted(address _feeder) {\n        require(_isFeederExisted(_feeder), \"NFTOracle: feeder not existed\");\n        _;\n    }\n\n    modifier onlyWhenFeederNotExisted(address _feeder) {\n        require(!_isFeederExisted(_feeder), \"NFTOracle: feeder existed\");\n        _;\n    }\n\n    /// @notice Allows owner to add assets.\n    /// @param _assets assets to add\n    function addAssets(address[] calldata _assets)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        _addAssets(_assets);\n    }\n\n    /// @notice Allows owner to remove asset.\n    /// @param _asset asset to remove\n    function removeAsset(address _asset)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyWhenAssetExisted(_asset)\n    {\n        _removeAsset(_asset);\n    }\n\n    /// @notice Allows owner to add feeders.\n    /// @param _feeders feeders to add\n    function addFeeders(address[] calldata _feeders)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        _addFeeders(_feeders);\n    }\n\n    /// @notice Allows owner to remove feeder.\n    /// @param _feeder feeder to remove\n    function removeFeeder(address _feeder)\n        external\n        onlyWhenFeederExisted(_feeder)\n    {\n        _removeFeeder(_feeder);\n    }\n\n    /// @notice Allows owner to update oracle configs\n    function setConfig(uint128 expirationPeriod, uint128 maxPriceDeviation)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        _setConfig(expirationPeriod, maxPriceDeviation);\n    }\n\n    /// @notice Allows owner to pause asset\n    function setPause(address _asset, bool _flag)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        assetFeederMap[_asset].paused = _flag;\n        emit AssetPaused(_asset, _flag);\n    }\n\n    /// @notice Allows updater to set new price on PriceInformation and updates the\n    /// internal Median cumulativePrice.\n    /// @param _asset The nft contract to set a floor price for\n    /// @param _twap The last floor twap\n    function setPrice(address _asset, uint256 _twap)\n        public\n        onlyRole(UPDATER_ROLE)\n        onlyWhenAssetExisted(_asset)\n        whenNotPaused(_asset)\n    {\n        bool dataValidity = false;\n        if (hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n            _finalizePrice(_asset, _twap);\n            return;\n        }\n        dataValidity = _checkValidity(_asset, _twap);\n        require(dataValidity, \"NFTOracle: invalid price data\");\n        // add price to raw feeder storage\n        _addRawValue(_asset, _twap);\n        uint256 medianPrice;\n        // set twap price only when median value is valid\n        (dataValidity, medianPrice) = _combine(_asset, _twap);\n        if (dataValidity) {\n            _finalizePrice(_asset, medianPrice);\n        }\n    }\n\n    /// @notice Allows owner to set new price on PriceInformation and updates the\n    /// internal Median cumulativePrice.\n    /// @param _assets The nft contract to set a floor price for\n    function setMultiplePrices(\n        address[] calldata _assets,\n        uint256[] calldata _twaps\n    ) external onlyRole(UPDATER_ROLE) {\n        require(\n            _assets.length == _twaps.length,\n            \"NFTOracle: Tokens and price length differ\"\n        );\n        for (uint256 i = 0; i < _assets.length; i++) {\n            setPrice(_assets[i], _twaps[i]);\n        }\n    }\n\n    /// @param _asset The nft contract\n    /// @return price The most recent price on chain\n    function getPrice(address _asset)\n        external\n        view\n        override\n        returns (uint256 price)\n    {\n        uint256 updatedAt = assetPriceMap[_asset].updatedAt;\n        require(\n            (block.number - updatedAt) <= config.expirationPeriod,\n            \"NFTOracle: asset price expired\"\n        );\n        return assetPriceMap[_asset].twap;\n    }\n\n    /// @param _asset The nft contract\n    /// @return timestamp The timestamp of the last update for an asset\n    function getLastUpdateTime(address _asset)\n        external\n        view\n        override\n        returns (uint256 timestamp)\n    {\n        return assetPriceMap[_asset].updatedTimestamp;\n    }\n\n    function getFeederSize() public view returns (uint256) {\n        return feeders.length;\n    }\n\n    function _whenNotPaused(address _asset) internal view {\n        bool _paused = assetFeederMap[_asset].paused;\n        require(!_paused, \"NFTOracle: nft price feed paused\");\n    }\n\n    function _isAssetExisted(address _asset) internal view returns (bool) {\n        return assetFeederMap[_asset].registered;\n    }\n\n    function _isFeederExisted(address _feeder) internal view returns (bool) {\n        return feederPositionMap[_feeder].registered;\n    }\n\n    function _addAsset(address _asset)\n        internal\n        onlyWhenAssetNotExisted(_asset)\n    {\n        assetFeederMap[_asset].registered = true;\n        assets.push(_asset);\n        assetFeederMap[_asset].index = uint8(assets.length - 1);\n        emit AssetAdded(_asset);\n    }\n\n    /// @notice add nft assets.\n    /// @param _assets assets to add\n    function _addAssets(address[] memory _assets) internal {\n        for (uint256 i = 0; i < _assets.length; i++) {\n            _addAsset(_assets[i]);\n        }\n    }\n\n    function _removeAsset(address _asset)\n        internal\n        onlyWhenAssetExisted(_asset)\n    {\n        uint8 assetIndex = assetFeederMap[_asset].index;\n        delete assets[assetIndex];\n        delete assetPriceMap[_asset];\n        delete assetFeederMap[_asset];\n        emit AssetRemoved(_asset);\n    }\n\n    function _addFeeder(address _feeder)\n        internal\n        onlyWhenFeederNotExisted(_feeder)\n    {\n        feeders.push(_feeder);\n        feederPositionMap[_feeder].index = uint8(feeders.length - 1);\n        feederPositionMap[_feeder].registered = true;\n        _setupRole(UPDATER_ROLE, _feeder);\n        emit FeederAdded(_feeder);\n    }\n\n    /// @notice set feeders.\n    /// @param _feeders feeders to set\n    function _addFeeders(address[] memory _feeders) internal {\n        for (uint256 i = 0; i < _feeders.length; i++) {\n            _addFeeder(_feeders[i]);\n        }\n    }\n\n    function _removeFeeder(address _feeder)\n        internal\n        onlyWhenFeederExisted(_feeder)\n    {\n        uint8 feederIndex = feederPositionMap[_feeder].index;\n        if (feederIndex >= 0 && feeders[feederIndex] == _feeder) {\n            feeders[feederIndex] = feeders[feeders.length - 1];\n            feeders.pop();\n        }\n        delete feederPositionMap[_feeder];\n        revokeRole(UPDATER_ROLE, _feeder);\n        emit FeederRemoved(_feeder);\n    }\n\n    /// @notice set oracle configs\n    /// @param _expirationPeriod only prices not expired will be aggregated with\n    /// @param _maxPriceDeviation use to reject when price increase/decrease rate more than this value\n    function _setConfig(uint128 _expirationPeriod, uint128 _maxPriceDeviation)\n        internal\n    {\n        config.expirationPeriod = _expirationPeriod;\n        config.maxPriceDeviation = _maxPriceDeviation;\n        emit OracleConfigSet(_expirationPeriod, _maxPriceDeviation);\n    }\n\n    function _checkValidity(address _asset, uint256 _twap)\n        internal\n        view\n        returns (bool)\n    {\n        require(_twap > 0, \"NFTOracle: price should be more than 0\");\n        PriceInformation memory assetPriceMapEntry = assetPriceMap[_asset];\n        uint256 _priorTwap = assetPriceMapEntry.twap;\n        uint256 _updatedAt = assetPriceMapEntry.updatedAt;\n        uint256 priceDeviation;\n        //first price is always valid\n        if (_priorTwap == 0 || _updatedAt == 0) {\n            return true;\n        }\n        priceDeviation = _twap > _priorTwap\n            ? (_twap * 100) / _priorTwap\n            : (_priorTwap * 100) / _twap;\n\n        // config maxPriceDeviation as multiple directly(not percent) for simplicity\n        if (priceDeviation >= config.maxPriceDeviation) {\n            return false;\n        }\n        return true;\n    }\n\n    function _finalizePrice(address _asset, uint256 _twap) internal {\n        PriceInformation storage assetPriceMapEntry = assetPriceMap[_asset];\n        assetPriceMapEntry.twap = _twap;\n        assetPriceMapEntry.updatedAt = block.number;\n        assetPriceMapEntry.updatedTimestamp = block.timestamp;\n        emit AssetDataSet(\n            _asset,\n            assetPriceMapEntry.twap,\n            assetPriceMapEntry.updatedAt\n        );\n    }\n\n    function _addRawValue(address _asset, uint256 _twap) internal {\n        FeederRegistrar storage feederRegistrar = assetFeederMap[_asset];\n        PriceInformation storage priceInfo = feederRegistrar.feederPrice[\n            msg.sender\n        ];\n        priceInfo.twap = _twap;\n        priceInfo.updatedAt = block.number;\n    }\n\n    function _combine(address _asset, uint256 _twap)\n        internal\n        view\n        returns (bool, uint256)\n    {\n        FeederRegistrar storage feederRegistrar = assetFeederMap[_asset];\n        uint256 currentBlock = block.number;\n        //first time just use the feeding value\n        if (assetPriceMap[_asset].twap == 0) {\n            return (true, _twap);\n        }\n        //use memory here so allocate with maximum length\n        uint256 feederSize = feeders.length;\n        uint256[] memory validPriceList = new uint256[](feederSize);\n        uint256 validNum = 0;\n        //aggeregate with price from all feeders\n        for (uint256 i = 0; i < feederSize; i++) {\n            PriceInformation memory priceInfo = feederRegistrar.feederPrice[\n                feeders[i]\n            ];\n            if (priceInfo.updatedAt > 0) {\n                uint256 diffBlock = currentBlock - priceInfo.updatedAt;\n                if (diffBlock <= config.expirationPeriod) {\n                    validPriceList[validNum] = priceInfo.twap;\n                    validNum++;\n                }\n            }\n        }\n        if (validNum < MIN_ORACLES_NUM) {\n            return (false, assetPriceMap[_asset].twap);\n        }\n        _quickSort(validPriceList, 0, int256(validNum - 1));\n        return (true, validPriceList[validNum / 2]);\n    }\n\n    function _quickSort(\n        uint256[] memory arr,\n        int256 left,\n        int256 right\n    ) internal pure {\n        int256 i = left;\n        int256 j = right;\n        if (i == j) return;\n        uint256 pivot = arr[uint256(left + (right - left) / 2)];\n        while (i <= j) {\n            while (arr[uint256(i)] < pivot) i++;\n            while (pivot < arr[uint256(j)]) j--;\n            if (i <= j) {\n                (arr[uint256(i)], arr[uint256(j)]) = (\n                    arr[uint256(j)],\n                    arr[uint256(i)]\n                );\n                i++;\n                j--;\n            }\n        }\n        if (left < j) _quickSort(arr, left, j);\n        if (i < right) _quickSort(arr, i, right);\n    }\n}"
    },
    {
      "filename": "paraspace-core/contracts/misc/NFTFloorOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"../dependencies/openzeppelin/contracts/AccessControl.sol\";\nimport \"../dependencies/openzeppelin/upgradeability/Initializable.sol\";\nimport \"./interfaces/INFTFloorOracle.sol\";\n\n//we need to deploy 3 oracles at least\nuint8 constant MIN_ORACLES_NUM = 3;\n//expirationPeriod at least the interval of client to feed data(currently 6h=21600s/12=1800 in mainnet)\n//we do not accept price lags behind to much\nuint128 constant EXPIRATION_PERIOD = 1800;\n//reject when price increase/decrease 1.5 times more than original value\nuint128 constant MAX_DEVIATION_RATE = 150;\n\nstruct OracleConfig {\n    // Expiration Period for each feed price\n    uint128 expirationPeriod;\n    // Maximum deviation allowed between two consecutive oracle prices\n    uint128 maxPriceDeviation;\n}\n\nstruct PriceInformation {\n    // last reported floor price(offchain twap)\n    uint256 twap;\n    // last updated blocknumber\n    uint256 updatedAt;\n    // last updated timestamp\n    uint256 updatedTimestamp;\n}\n\nstruct FeederRegistrar {\n    // if asset registered or not\n    bool registered;\n    // index in asset list\n    uint8 index;\n    // if asset paused,reject the price\n    bool paused;\n    // feeder -> PriceInformation\n    mapping(address => PriceInformation) feederPrice;\n}\n\nstruct FeederPosition {\n    // if feeder registered or not\n    bool registered;\n    // index in feeder list\n    uint8 index;\n}\n\n/// @title A simple on-chain price oracle mechanism\n/// @author github.com/drbh,github.com/yrong\n/// @notice Offchain clients can update the prices in this contract. The public can read prices\n/// aggeregate prices which are not expired from different feeders, if number of valid/unexpired prices\n/// not enough, we do not aggeregate and just use previous price\ncontract NFTFloorOracle is Initializable, AccessControl, INFTFloorOracle {\n    event AssetAdded(address indexed asset);\n    event AssetRemoved(address indexed asset);\n    event AssetPaused(address indexed asset, bool paused);\n\n    event FeederAdded(address indexed feeder);\n    event FeederRemoved(address indexed feeder);\n\n    event OracleConfigSet(uint128 expirationPeriod, uint128 maxPriceDeviation);\n    event AssetDataSet(\n        address indexed asset,\n        uint256 twap,\n        uint256 lastUpdatedBlock\n    );\n\n    bytes32 public constant UPDATER_ROLE = keccak256(\"UPDATER_ROLE\");\n\n    /// @dev Aggregated price with address\n    // the NFT contract -> latest price information\n    mapping(address => PriceInformation) public assetPriceMap;\n\n    /// @dev All feeders\n    address[] public feeders;\n\n    /// @dev feeder map\n    // feeder address -> index in feeder list\n    mapping(address => FeederPosition) private feederPositionMap;\n\n    /// @dev All asset list\n    address[] public assets;\n\n    /// @dev Original raw value to aggregate with\n    // the NFT contract address -> FeederRegistrar which contains price from each feeder\n    mapping(address => FeederRegistrar) public assetFeederMap;\n\n    /// @dev storage for oracle configurations\n    OracleConfig public config;\n\n    /// @notice Allow contract creator to set admin and updaters\n    /// @param _admin The admin who can change roles\n    /// @param _feeders The initial updaters\n    /// @param _assets The initial nft assets\n    function initialize(\n        address _admin,\n        address[] memory _feeders,\n        address[] memory _assets\n    ) public initializer {\n        _addAssets(_assets);\n        _addFeeders(_feeders);\n        _setupRole(DEFAULT_ADMIN_ROLE, _admin);\n        //still need to grant update_role to admin for emergency call\n        _setupRole(UPDATER_ROLE, _admin);\n        _setConfig(EXPIRATION_PERIOD, MAX_DEVIATION_RATE);\n    }\n\n    modifier whenNotPaused(address _asset) {\n        if (!hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n            _whenNotPaused(_asset);\n        }\n        _;\n    }\n\n    modifier onlyWhenAssetExisted(address _asset) {\n        require(_isAssetExisted(_asset), \"NFTOracle: asset not existed\");\n        _;\n    }\n\n    modifier onlyWhenAssetNotExisted(address _asset) {\n        require(!_isAssetExisted(_asset), \"NFTOracle: asset existed\");\n        _;\n    }\n\n    modifier onlyWhenFeederExisted(address _feeder) {\n        require(_isFeederExisted(_feeder), \"NFTOracle: feeder not existed\");\n        _;\n    }\n\n    modifier onlyWhenFeederNotExisted(address _feeder) {\n        require(!_isFeederExisted(_feeder), \"NFTOracle: feeder existed\");\n        _;\n    }\n\n    /// @notice Allows owner to add assets.\n    /// @param _assets assets to add\n    function addAssets(address[] calldata _assets)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        _addAssets(_assets);\n    }\n\n    /// @notice Allows owner to remove asset.\n    /// @param _asset asset to remove\n    function removeAsset(address _asset)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyWhenAssetExisted(_asset)\n    {\n        _removeAsset(_asset);\n    }\n\n    /// @notice Allows owner to add feeders.\n    /// @param _feeders feeders to add\n    function addFeeders(address[] calldata _feeders)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        _addFeeders(_feeders);\n    }\n\n    /// @notice Allows owner to remove feeder.\n    /// @param _feeder feeder to remove\n    function removeFeeder(address _feeder)\n        external\n        onlyWhenFeederExisted(_feeder)\n    {\n        _removeFeeder(_feeder);\n    }\n\n    /// @notice Allows owner to update oracle configs\n    function setConfig(uint128 expirationPeriod, uint128 maxPriceDeviation)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        _setConfig(expirationPeriod, maxPriceDeviation);\n    }\n\n    /// @notice Allows owner to pause asset\n    function setPause(address _asset, bool _flag)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        assetFeederMap[_asset].paused = _flag;\n        emit AssetPaused(_asset, _flag);\n    }\n\n    /// @notice Allows updater to set new price on PriceInformation and updates the\n    /// internal Median cumulativePrice.\n    /// @param _asset The nft contract to set a floor price for\n    /// @param _twap The last floor twap\n    function setPrice(address _asset, uint256 _twap)\n        public\n        onlyRole(UPDATER_ROLE)\n        onlyWhenAssetExisted(_asset)\n        whenNotPaused(_asset)\n    {\n        bool dataValidity = false;\n        if (hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n            _finalizePrice(_asset, _twap);\n            return;\n        }\n        dataValidity = _checkValidity(_asset, _twap);\n        require(dataValidity, \"NFTOracle: invalid price data\");\n        // add price to raw feeder storage\n        _addRawValue(_asset, _twap);\n        uint256 medianPrice;\n        // set twap price only when median value is valid\n        (dataValidity, medianPrice) = _combine(_asset, _twap);\n        if (dataValidity) {\n            _finalizePrice(_asset, medianPrice);\n        }\n    }\n\n    /// @notice Allows owner to set new price on PriceInformation and updates the\n    /// internal Median cumulativePrice.\n    /// @param _assets The nft contract to set a floor price for\n    function setMultiplePrices(\n        address[] calldata _assets,\n        uint256[] calldata _twaps\n    ) external onlyRole(UPDATER_ROLE) {\n        require(\n            _assets.length == _twaps.length,\n            \"NFTOracle: Tokens and price length differ\"\n        );\n        for (uint256 i = 0; i < _assets.length; i++) {\n            setPrice(_assets[i], _twaps[i]);\n        }\n    }\n\n    /// @param _asset The nft contract\n    /// @return price The most recent price on chain\n    function getPrice(address _asset)\n        external\n        view\n        override\n        returns (uint256 price)\n    {\n        uint256 updatedAt = assetPriceMap[_asset].updatedAt;\n        require(\n            (block.number - updatedAt) <= config.expirationPeriod,\n            \"NFTOracle: asset price expired\"\n        );\n        return assetPriceMap[_asset].twap;\n    }\n\n    /// @param _asset The nft contract\n    /// @return timestamp The timestamp of the last update for an asset\n    function getLastUpdateTime(address _asset)\n        external\n        view\n        override\n        returns (uint256 timestamp)\n    {\n        return assetPriceMap[_asset].updatedTimestamp;\n    }\n\n    function getFeederSize() public view returns (uint256) {\n        return feeders.length;\n    }\n\n    function _whenNotPaused(address _asset) internal view {\n        bool _paused = assetFeederMap[_asset].paused;\n        require(!_paused, \"NFTOracle: nft price feed paused\");\n    }\n\n    function _isAssetExisted(address _asset) internal view returns (bool) {\n        return assetFeederMap[_asset].registered;\n    }\n\n    function _isFeederExisted(address _feeder) internal view returns (bool) {\n        return feederPositionMap[_feeder].registered;\n    }\n\n    function _addAsset(address _asset)\n        internal\n        onlyWhenAssetNotExisted(_asset)\n    {\n        assetFeederMap[_asset].registered = true;\n        assets.push(_asset);\n        assetFeederMap[_asset].index = uint8(assets.length - 1);\n        emit AssetAdded(_asset);\n    }\n\n    /// @notice add nft assets.\n    /// @param _assets assets to add\n    function _addAssets(address[] memory _assets) internal {\n        for (uint256 i = 0; i < _assets.length; i++) {\n            _addAsset(_assets[i]);\n        }\n    }\n\n    function _removeAsset(address _asset)\n        internal\n        onlyWhenAssetExisted(_asset)\n    {\n        uint8 assetIndex = assetFeederMap[_asset].index;\n        delete assets[assetIndex];\n        delete assetPriceMap[_asset];\n        delete assetFeederMap[_asset];\n        emit AssetRemoved(_asset);\n    }\n\n    function _addFeeder(address _feeder)\n        internal\n        onlyWhenFeederNotExisted(_feeder)\n    {\n        feeders.push(_feeder);\n        feederPositionMap[_feeder].index = uint8(feeders.length - 1);\n        feederPositionMap[_feeder].registered = true;\n        _setupRole(UPDATER_ROLE, _feeder);\n        emit FeederAdded(_feeder);\n    }\n\n    /// @notice set feeders.\n    /// @param _feeders feeders to set\n    function _addFeeders(address[] memory _feeders) internal {\n        for (uint256 i = 0; i < _feeders.length; i++) {\n            _addFeeder(_feeders[i]);\n        }\n    }\n\n    function _removeFeeder(address _feeder)\n        internal\n        onlyWhenFeederExisted(_feeder)\n    {\n        uint8 feederIndex = feederPositionMap[_feeder].index;\n        if (feederIndex >= 0 && feeders[feederIndex] == _feeder) {\n            feeders[feederIndex] = feeders[feeders.length - 1];\n            feeders.pop();\n        }\n        delete feederPositionMap[_feeder];\n        revokeRole(UPDATER_ROLE, _feeder);\n        emit FeederRemoved(_feeder);\n    }\n\n    /// @notice set oracle configs\n    /// @param _expirationPeriod only prices not expired will be aggregated with\n    /// @param _maxPriceDeviation use to reject when price increase/decrease rate more than this value\n    function _setConfig(uint128 _expirationPeriod, uint128 _maxPriceDeviation)\n        internal\n    {\n        config.expirationPeriod = _expirationPeriod;\n        config.maxPriceDeviation = _maxPriceDeviation;\n        emit OracleConfigSet(_expirationPeriod, _maxPriceDeviation);\n    }\n\n    function _checkValidity(address _asset, uint256 _twap)\n        internal\n        view\n        returns (bool)\n    {\n        require(_twap > 0, \"NFTOracle: price should be more than 0\");\n        PriceInformation memory assetPriceMapEntry = assetPriceMap[_asset];\n        uint256 _priorTwap = assetPriceMapEntry.twap;\n        uint256 _updatedAt = assetPriceMapEntry.updatedAt;\n        uint256 priceDeviation;\n        //first price is always valid\n        if (_priorTwap == 0 || _updatedAt == 0) {\n            return true;\n        }\n        priceDeviation = _twap > _priorTwap\n            ? (_twap * 100) / _priorTwap\n            : (_priorTwap * 100) / _twap;\n\n        // config maxPriceDeviation as multiple directly(not percent) for simplicity\n        if (priceDeviation >= config.maxPriceDeviation) {\n            return false;\n        }\n        return true;\n    }\n\n    function _finalizePrice(address _asset, uint256 _twap) internal {\n        PriceInformation storage assetPriceMapEntry = assetPriceMap[_asset];\n        assetPriceMapEntry.twap = _twap;\n        assetPriceMapEntry.updatedAt = block.number;\n        assetPriceMapEntry.updatedTimestamp = block.timestamp;\n        emit AssetDataSet(\n            _asset,\n            assetPriceMapEntry.twap,\n            assetPriceMapEntry.updatedAt\n        );\n    }\n\n    function _addRawValue(address _asset, uint256 _twap) internal {\n        FeederRegistrar storage feederRegistrar = assetFeederMap[_asset];\n        PriceInformation storage priceInfo = feederRegistrar.feederPrice[\n            msg.sender\n        ];\n        priceInfo.twap = _twap;\n        priceInfo.updatedAt = block.number;\n    }\n\n    function _combine(address _asset, uint256 _twap)\n        internal\n        view\n        returns (bool, uint256)\n    {\n        FeederRegistrar storage feederRegistrar = assetFeederMap[_asset];\n        uint256 currentBlock = block.number;\n        //first time just use the feeding value\n        if (assetPriceMap[_asset].twap == 0) {\n            return (true, _twap);\n        }\n        //use memory here so allocate with maximum length\n        uint256 feederSize = feeders.length;\n        uint256[] memory validPriceList = new uint256[](feederSize);\n        uint256 validNum = 0;\n        //aggeregate with price from all feeders\n        for (uint256 i = 0; i < feederSize; i++) {\n            PriceInformation memory priceInfo = feederRegistrar.feederPrice[\n                feeders[i]\n            ];\n            if (priceInfo.updatedAt > 0) {\n                uint256 diffBlock = currentBlock - priceInfo.updatedAt;\n                if (diffBlock <= config.expirationPeriod) {\n                    validPriceList[validNum] = priceInfo.twap;\n                    validNum++;\n                }\n            }\n        }\n        if (validNum < MIN_ORACLES_NUM) {\n            return (false, assetPriceMap[_asset].twap);\n        }\n        _quickSort(validPriceList, 0, int256(validNum - 1));\n        return (true, validPriceList[validNum / 2]);\n    }\n\n    function _quickSort(\n        uint256[] memory arr,\n        int256 left,\n        int256 right\n    ) internal pure {\n        int256 i = left;\n        int256 j = right;\n        if (i == j) return;\n        uint256 pivot = arr[uint256(left + (right - left) / 2)];\n        while (i <= j) {\n            while (arr[uint256(i)] < pivot) i++;\n            while (pivot < arr[uint256(j)]) j--;\n            if (i <= j) {\n                (arr[uint256(i)], arr[uint256(j)]) = (\n                    arr[uint256(j)],\n                    arr[uint256(i)]\n                );\n                i++;\n                j--;\n            }\n        }\n        if (left < j) _quickSort(arr, left, j);\n        if (i < right) _quickSort(arr, i, right);\n    }\n}"
    },
    {
      "filename": "paraspace-core/contracts/misc/NFTFloorOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"../dependencies/openzeppelin/contracts/AccessControl.sol\";\nimport \"../dependencies/openzeppelin/upgradeability/Initializable.sol\";\nimport \"./interfaces/INFTFloorOracle.sol\";\n\n//we need to deploy 3 oracles at least\nuint8 constant MIN_ORACLES_NUM = 3;\n//expirationPeriod at least the interval of client to feed data(currently 6h=21600s/12=1800 in mainnet)\n//we do not accept price lags behind to much\nuint128 constant EXPIRATION_PERIOD = 1800;\n//reject when price increase/decrease 1.5 times more than original value\nuint128 constant MAX_DEVIATION_RATE = 150;\n\nstruct OracleConfig {\n    // Expiration Period for each feed price\n    uint128 expirationPeriod;\n    // Maximum deviation allowed between two consecutive oracle prices\n    uint128 maxPriceDeviation;\n}\n\nstruct PriceInformation {\n    // last reported floor price(offchain twap)\n    uint256 twap;\n    // last updated blocknumber\n    uint256 updatedAt;\n    // last updated timestamp\n    uint256 updatedTimestamp;\n}\n\nstruct FeederRegistrar {\n    // if asset registered or not\n    bool registered;\n    // index in asset list\n    uint8 index;\n    // if asset paused,reject the price\n    bool paused;\n    // feeder -> PriceInformation\n    mapping(address => PriceInformation) feederPrice;\n}\n\nstruct FeederPosition {\n    // if feeder registered or not\n    bool registered;\n    // index in feeder list\n    uint8 index;\n}\n\n/// @title A simple on-chain price oracle mechanism\n/// @author github.com/drbh,github.com/yrong\n/// @notice Offchain clients can update the prices in this contract. The public can read prices\n/// aggeregate prices which are not expired from different feeders, if number of valid/unexpired prices\n/// not enough, we do not aggeregate and just use previous price\ncontract NFTFloorOracle is Initializable, AccessControl, INFTFloorOracle {\n    event AssetAdded(address indexed asset);\n    event AssetRemoved(address indexed asset);\n    event AssetPaused(address indexed asset, bool paused);\n\n    event FeederAdded(address indexed feeder);\n    event FeederRemoved(address indexed feeder);\n\n    event OracleConfigSet(uint128 expirationPeriod, uint128 maxPriceDeviation);\n    event AssetDataSet(\n        address indexed asset,\n        uint256 twap,\n        uint256 lastUpdatedBlock\n    );\n\n    bytes32 public constant UPDATER_ROLE = keccak256(\"UPDATER_ROLE\");\n\n    /// @dev Aggregated price with address\n    // the NFT contract -> latest price information\n    mapping(address => PriceInformation) public assetPriceMap;\n\n    /// @dev All feeders\n    address[] public feeders;\n\n    /// @dev feeder map\n    // feeder address -> index in feeder list\n    map"
    }
  ]
}