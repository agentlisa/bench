{
  "Title": "H-11: Lien count per epoch is not updated ultimately locking the collateralized NFT",
  "Content": "# Issue H-11: Lien count per epoch is not updated ultimately locking the collateralized NFT \n\nSource: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/194 \n\n## Found by \n0xRajeev\n\n## Summary\n\nThe lien count per epoch is not updated, causing payments to the lien and liquidation of the lien to revert.\n\n## Vulnerability Detail\n\nThe PublicVault contract keeps track of open liens per epoch to prevent starting a new epoch with open liens. The lien count for a given epoch is decreased whenever a lien is fully paid back (either through a regular payment or a liquidation payment). However, if a lien is bought out, the lien start will be set to the current `block.timestamp` and the duration to the newly provided duration.\n\nIf the borrower now wants to make a payment to this lien, the `LienToken._payment` function will evaluate the lien's current epoch and will use a different epoch as when the lien was initially created. The attempt to then call `IPublicVault(lienOwner).decreaseEpochLienCount` will fail, as the lien count for the new epoch has not been increased yet. The same will happen for liquidations.\n\n## Impact\n\nAfter a lien buyout, payments to the lien and liquidating the lien will revert, which will ultimately lock the collateralized NFT.\n\nThis will certainly prevent the borrower from making payments towards that future-epoch lien in the current epoch because `decreaseEpochLienCount()` will revert. However, even after the epoch progresses to the next one via `processEpoch()`, the `liensOpenForEpoch` for the new epoch still does not account for the previously bought out lien aligned to this new epoch because `liensOpenForEpoch` is only updated in two places:\n    1.  `_increaseOpenLiens()` which is not called by anyone \n    2. `_afterCommitToLien()` <- `commitToLien()` <-- <-- `commitToLiens()` which happens only for new lien commitments\n\nThis will prevent the borrower from making payments towards the previously bought lien that aligns to the current epoch, which will force a liquidation on exceeding lien duration. Depending on when the liquidation can be triggered, if this condition is satisfied `PublicVault(owner).timeToEpochEnd() <= COLLATERAL_TOKEN.auctionWindow()` then `decreaseEpochLienCount()` will revert to prevent auctioning and lock the borrower's collateral in the protocol.\n\n## Code Snippet\n\n1. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/PublicVault.sol#L259-L262\n2. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L634-L636\n3. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L153\n4. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/AstariaRouter.sol#L399\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n`liensOpenForEpoch` should be incremented when a lien is bought with a duration spilling into an epoch higher than the current one.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/8",
  "Code": [
    {
      "filename": "src/PublicVault.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n/**\n *       __  ___       __\n *  /\\  /__'  |   /\\  |__) |  /\\\n * /~~\\ .__/  |  /~~\\ |  \\ | /~~\\\n *\n * Copyright (c) Astaria Labs, Inc\n */\n\npragma solidity ^0.8.17;\n\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC4626} from \"solmate/mixins/ERC4626.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\nimport {IERC721, IERC165} from \"gpl/interfaces/IERC721.sol\";\nimport {\n  IVault,\n  ERC4626Cloned,\n  ITokenBase,\n  ERC4626Base,\n  AstariaVaultBase\n} from \"gpl/ERC4626-Cloned.sol\";\n\nimport {\n  ClonesWithImmutableArgs\n} from \"clones-with-immutable-args/ClonesWithImmutableArgs.sol\";\n\nimport {IAstariaRouter} from \"./interfaces/IAstariaRouter.sol\";\nimport {ILienBase} from \"./interfaces/ILienToken.sol\";\nimport {ILienToken} from \"./interfaces/ILienToken.sol\";\n\nimport {LienToken} from \"./LienToken.sol\";\nimport {LiquidationAccountant} from \"./LiquidationAccountant.sol\";\nimport {VaultImplementation} from \"./VaultImplementation.sol\";\nimport {WithdrawProxy} from \"./WithdrawProxy.sol\";\n\nimport {Math} from \"./utils/Math.sol\";\nimport {Pausable} from \"./utils/Pausable.sol\";\n\ninterface IPublicVault is IERC165 {\n  function beforePayment(uint256 escrowId, uint256 amount) external;\n\n  function decreaseEpochLienCount(uint256 lienId) external;\n\n  function getLienEpoch(uint256 end) external view returns (uint256);\n\n  function afterPayment(uint256 lienId) external;\n}\n\n/**\n * @title Vault\n * @author androolloyd\n */\ncontract Vault is AstariaVaultBase, VaultImplementation, IVault {\n  using SafeTransferLib for ERC20;\n\n  function name() public view override returns (string memory) {\n    return string(abi.encodePacked(\"AST-Vault-\", ERC20(underlying()).symbol()));\n  }\n\n  function symbol() public view override returns (string memory) {\n    return\n      string(\n        abi.encodePacked(\"AST-V\", owner(), \"-\", ERC20(underlying()).symbol())\n      );\n  }\n\n  function _handleStrategistInterestReward(uint256 lienId, uint256 shares)\n    internal\n    virtual\n    override\n  {}\n\n  function deposit(uint256 amount, address)\n    public\n    virtual\n    override\n    returns (uint256)\n  {\n    require(msg.sender == owner(), \"only the appraiser can fund this vault\");\n    ERC20(underlying()).safeTransferFrom(\n      address(msg.sender),\n      address(this),\n      amount\n    );\n    return amount;\n  }\n\n  function withdraw(uint256 amount) external {\n    require(msg.sender == owner(), \"only the appraiser can exit this vault\");\n    ERC20(underlying()).safeTransferFrom(\n      address(this),\n      address(msg.sender),\n      amount\n    );\n  }\n}\n\n/*\n * @title PublicVault\n * @author androolloyd\n * @notice\n */\ncontract PublicVault is Vault, IPublicVault, ERC4626Cloned {\n  using FixedPointMathLib for uint256;\n  using SafeTransferLib for ERC20;\n\n  // epoch seconds when yIntercept was calculated last\n  uint256 public last;\n  // sum of all LienToken amounts\n  uint256 public yIntercept;\n  // sum of all slopes of each LienToken\n  uint256 public slope;\n\n  // block.timestamp of first epoch\n  uint256 public withdrawReserve = 0;\n  uint256 liquidationWithdrawRatio = 0;\n  uint256 strategistUnclaimedShares = 0;\n  uint64 public currentEpoch = 0;\n\n  //mapping of epoch to number of open liens\n  mapping(uint256 => uint256) public liensOpenForEpoch;\n  // WithdrawProxies and LiquidationAccountants for each epoch.\n  // The first possible WithdrawProxy and LiquidationAccountant starts at index 0, i.e. an LP that marks a withdraw in epoch 0 to collect by the end of epoch *1* would use the 0th WithdrawProxy.\n  mapping(uint64 => address) public withdrawProxies;\n  mapping(uint64 => address) public liquidationAccountants;\n  mapping(uint64 => uint256) public liquidationsExpectedAtBoundary;\n\n  event YInterceptChanged(uint256 newYintercept);\n  event WithdrawReserveTransferred(uint256 amount);\n\n  function underlying()\n    public\n    view\n    virtual\n    override(ERC4626Base, AstariaVaultBase)\n    returns (address)\n  {\n    return super.underlying();\n  }\n\n  /**\n   * @notice Signal a withdrawal of funds (redeeming for underlying asset) in the next epoch.\n   * @param shares The number of VaultToken shares to redeem.\n   * @param receiver The receiver of the WithdrawTokens (and eventual underlying asset)\n   * @param owner The owner of the VaultTokens.\n   * @return assets The amount of the underlying asset redeemed.\n   */\n  function redeem(\n    uint256 shares,\n    address receiver,\n    address owner\n  ) public virtual override returns (uint256 assets) {\n    assets = redeemFutureEpoch(shares, receiver, owner, currentEpoch);\n  }\n\n  function withdraw(\n    uint256 assets,\n    address receiver,\n    address owner\n  ) public virtual override returns (uint256 shares) {\n    shares = previewWithdraw(assets);\n    redeemFutureEpoch(shares, receiver, owner, currentEpoch);\n  }\n\n  /**\n   * @notice Signal a withdrawal of funds (redeeming for underlying asset) in an arbitrary future epoch.\n   * @param shares The number of VaultToken shares to redeem.\n   * @param receiver The receiver of the WithdrawTokens (and eventual underlying asset)\n   * @param owner The owner of the VaultTokens.\n   * @param epoch The epoch to withdraw for.\n   * @return assets The amount of the underlying asset redeemed.\n   */\n  function redeemFutureEpoch(\n    uint256 shares,\n    address receiver,\n    address owner,\n    uint64 epoch\n  ) public virtual returns (uint256 assets) {\n    // check to ensure that the requested epoch is not the current epoch or in the past\n    require(epoch >= currentEpoch, \"Exit epoch too low\");\n\n    require(msg.sender == owner, \"Only the owner can redeem\");\n    // check for rounding error since we round down in previewRedeem.\n\n    ERC20(address(this)).safeTransferFrom(owner, address(this), shares);\n\n    // Deploy WithdrawProxy if no WithdrawProxy exists for the specified epoch\n    _deployWithdrawProxyIfNotDeployed(epoch);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n    // WithdrawProxy shares are minted 1:1 with PublicVault shares\n    WithdrawProxy(withdrawProxies[epoch]).mint(receiver, shares); // was withdrawProxies[withdrawEpoch]\n  }\n\n  function _deployWithdrawProxyIfNotDeployed(uint64 epoch) internal {\n    if (withdrawProxies[epoch] == address(0)) {\n      address proxy = ClonesWithImmutableArgs.clone(\n        IAstariaRouter(ROUTER()).WITHDRAW_IMPLEMENTATION(),\n        abi.encodePacked(\n          address(this), //owner\n          underlying() //token\n        )\n      );\n      withdrawProxies[epoch] = proxy;\n    }\n  }\n\n  /**\n   * @notice Deposit funds into the PublicVault.\n   * @param amount The amount of funds to deposit.\n   * @param receiver The receiver of the resulting VaultToken shares.\n   */\n  function deposit(uint256 amount, address receiver)\n    public\n    override(Vault, ERC4626Cloned)\n    whenNotPaused\n    returns (uint256)\n  {\n    return super.deposit(amount, receiver);\n  }\n\n  /**\n   * @notice Retrieve the domain separator.\n   * @return The domain separator.\n   */\n  function computeDomainSeparator() internal view override returns (bytes32) {\n    return super.domainSeparator();\n  }\n\n  /**\n   * @notice Rotate epoch boundary. This must be called before the next epoch can begin.\n   */\n  function processEpoch() external {\n    // check to make sure epoch is over\n    require(getEpochEnd(currentEpoch) < block.timestamp, \"Epoch has not ended\");\n    require(withdrawReserve == 0, \"Withdraw reserve not empty\");\n    if (liquidationAccountants[currentEpoch] != address(0)) {\n      require(\n        LiquidationAccountant(liquidationAccountants[currentEpoch])\n          .getFinalAuctionEnd() < block.timestamp,\n        \"Final auction not ended\"\n      );\n    }\n\n    // split funds from LiquidationAccountant between PublicVault and WithdrawProxy if hasn't been already\n    if (\n      currentEpoch != 0 &&\n      liquidationAccountants[currentEpoch - 1] != address(0)\n    ) {\n      LiquidationAccountant(liquidationAccountants[currentEpoch - 1]).claim();\n    }\n\n    require(\n      liensOpenForEpoch[currentEpoch] == uint256(0),\n      \"loans are still open for this epoch\"\n    );\n\n    // reset liquidationWithdrawRatio to prepare for re calcualtion\n    liquidationWithdrawRatio = 0;\n\n    // check if there are LPs withdrawing this epoch\n    if (withdrawProxies[currentEpoch] != address(0)) {\n      uint256 proxySupply = WithdrawProxy(withdrawProxies[currentEpoch])\n        .totalSupply();\n\n      liquidationWithdrawRatio = proxySupply.mulDivDown(1e18, totalSupply());\n\n      if (liquidationAccountants[currentEpoch] != address(0)) {\n        LiquidationAccountant(liquidationAccountants[currentEpoch])\n          .setWithdrawRatio(liquidationWithdrawRatio);\n      }\n\n      uint256 withdrawAssets = convertToAssets(proxySupply);\n      // compute the withdrawReserve\n      uint256 withdrawLiquidations = liquidationsExpectedAtBoundary[\n        currentEpoch\n      ].mulDivDown(liquidationWithdrawRatio, 1e18);\n      withdrawReserve = withdrawAssets - withdrawLiquidations;\n      // burn the tokens of the LPs withdrawing\n      _burn(address(this), proxySupply);\n\n      _decreaseYIntercept(withdrawAssets);\n    }\n\n    // increment epoch\n    currentEpoch++;\n  }\n\n  /**\n   * @notice Deploys a LiquidationAccountant for the WithdrawProxy for the upcoming epoch boundary.\n   * @return accountant The address of the deployed LiquidationAccountant.\n   */\n  function deployLiquidationAccountant() public returns (address accountant) {\n    require(\n      liquidationAccountants[currentEpoch] == address(0),\n      \"cannot deploy two liquidation accountants for the same epoch\"\n    );\n\n    _deployWithdrawProxyIfNotDeployed(currentEpoch);\n\n    accountant = ClonesWithImmutableArgs.clone(\n      IAstariaRouter(ROUTER()).LIQUIDATION_IMPLEMENTATION(),\n      abi.encodePacked(\n        underlying(),\n        ROUTER(),\n        address(this),\n        address(LIEN_TOKEN()),\n        address(withdrawProxies[currentEpoch])\n      )\n    );\n    liquidationAccountants[currentEpoch] = accountant;\n  }\n\n  function supportsInterface(bytes4 interfaceId)\n    public\n    pure\n    override(IERC165)\n    returns (bool)\n  {\n    return\n      interfaceId == type(IPublicVault).interfaceId ||\n      interfaceId == type(IVault).interfaceId ||\n      interfaceId == type(ERC4626Cloned).interfaceId ||\n      interfaceId == type(ERC4626).interfaceId ||\n      interfaceId == type(ERC20).interfaceId ||\n      interfaceId == type(IERC165).interfaceId;\n  }\n\n  event TransferWithdraw(uint256 a, uint256 b);\n\n  /**\n   * @notice Transfers funds from the PublicVault to the WithdrawProxy.\n   */\n\n  function transferWithdrawReserve() public {\n    // check the available balance to be withdrawn\n    uint256 withdraw = ERC20(underlying()).balanceOf(address(this));\n    emit TransferWithdraw(withdraw, withdrawReserve);\n\n    // prevent transfer of more assets then are available\n    if (withdrawReserve <= withdraw) {\n      withdraw = withdrawReserve;\n      withdrawReserve = 0;\n    } else {\n      withdrawReserve -= withdraw;\n    }\n    emit TransferWithdraw(withdraw, withdrawReserve);\n\n    address currentWithdrawProxy = withdrawProxies[currentEpoch - 1]; //\n    // prevents transfer to a non-existent WithdrawProxy\n    // withdrawProxies are indexed by the epoch where they're deployed\n    if (currentWithdrawProxy != address(0)) {\n      ERC20(underlying()).safeTransfer(currentWithdrawProxy, withdraw);\n      emit WithdrawReserveTransferred(withdraw);\n    }\n  }\n\n  /**\n   * @dev Hook for updating the slope of the PublicVault after a LienToken is issued.\n   * @param lienId The ID of the lien.\n   * @param amount The amount of debt\n   */\n  function _afterCommitToLien(uint256 lienId, uint256 amount)\n    internal\n    virtual\n    override\n  {\n    // increment slope for the new lien\n    unchecked {\n      slope += LIEN_TOKEN().calculateSlope(lienId);\n    }\n\n    ILienToken.Lien memory lien = LIEN_TOKEN().getLien(lienId);\n\n    uint256 epoch = Math.ceilDiv(\n      lien.start + lien.duration - START(),\n      EPOCH_LENGTH()\n    ) - 1;\n\n    liensOpenForEpoch[epoch]++;\n    emit LienOpen(lienId, epoch);\n  }\n\n  event LienOpen(uint256 lienId, uint256 epoch);\n\n  /**\n   * @notice Retrieves the address of the LienToken contract for this PublicVault.\n   * @return The LienToken address.\n   */\n\n  function LIEN_TOKEN() public view returns (ILienToken) {\n    return IAstariaRouter(ROUTER()).LIEN_TOKEN();\n  }\n\n  /**\n   * @notice Computes the implied value of this PublicVault. This includes interest payments that have not yet been made.\n   * @return The implied value for this PublicVault.\n   */\n\n  function totalAssets() public view virtual override returns (uint256) {\n    if (last == 0 || yIntercept == 0) {\n      return ERC20(underlying()).balanceOf(address(this));\n    }\n    uint256 delta_t = block.timestamp - last;\n\n    return slope.mulDivDown(delta_t, 1) + yIntercept;\n  }\n\n  function totalSupply() public view virtual override returns (uint256) {\n    return _totalSupply + strategistUnclaimedShares;\n  }\n\n  /**\n   * @notice Mints earned fees by the strategist to the strategist address.\n   */\n  function claim() external onlyOwner {\n    _mint(owner(), strategistUnclaimedShares);\n    strategistUnclaimedShares = 0;\n  }\n\n  /**\n   * @notice Hook to update the slope and yIntercept of the PublicVault on payment.\n   * The rate for the LienToken is subtracted from the total slope of the PublicVault, and recalculated in afterPayment().\n   * @param lienId The ID of the lien.\n   * @param amount The amount paid off to deduct from the yIntercept of the PublicVault.\n   */\n  function beforePayment(uint256 lienId, uint256 amount) public onlyLienToken {\n    _handleStrategistInterestReward(lienId, amount);\n    uint256 lienSlope = LIEN_TOKEN().calculateSlope(lienId);\n    if (lienSlope > slope) {\n      slope = 0;\n    } else {\n      slope -= lienSlope;\n    }\n    last = block.timestamp;\n  }\n\n  /** @notice\n   * hook to modify the liens open for then given epoch\n   * @param epoch epoch to decrease liens of\n   */\n  function decreaseEpochLienCount(uint256 epoch) external {\n    require(\n      msg.sender == address(ROUTER()) || msg.sender == address(LIEN_TOKEN()),\n      \"only router or lien token\"\n    );\n    liensOpenForEpoch[epoch]--;\n  }\n\n  /** @notice\n   * hook to increase the amount of debt currently liquidated to discount in processEpoch\n   * @param amount the amount of debt liquidated\n   */\n  function increaseLiquidationsExpectedAtBoundary(uint256 amount) external {\n    require(msg.sender == ROUTER(), \"only router\");\n    liquidationsExpectedAtBoundary[currentEpoch] += amount;\n  }\n\n  /** @notice\n   * helper to return the LienEpoch for a given end date\n   * @param end time to compute the end for\n   */\n  function getLienEpoch(uint256 end) external view returns (uint256) {\n    return Math.ceilDiv(end - START(), EPOCH_LENGTH()) - 1;\n  }\n\n  function getEpochEnd(uint256 epoch) public view returns (uint256) {\n    return START() + (epoch + 1) * EPOCH_LENGTH();\n  }\n\n  function _increaseOpenLiens() internal {\n    liensOpenForEpoch[currentEpoch]++;\n  }\n\n  /**\n   * @notice Hook to recalculate the slope of a lien after a payment has been made.\n   * @param lienId The ID of the lien.\n   */\n  function afterPayment(uint256 lienId) public onlyLienToken {\n    slope += LIEN_TOKEN().calculateSlope(lienId);\n  }\n\n  modifier onlyLienToken() {\n    require(msg.sender == address(LIEN_TOKEN()));\n    _;\n  }\n\n  /**\n   * @notice After-deposit hook to update the yIntercept of the PublicVault to reflect a capital contribution.\n   * @param assets The amount of assets deposited to the PublicVault.\n   * @param shares The resulting amount of VaultToken shares that were issued.\n   */\n  function afterDeposit(uint256 assets, uint256 shares)\n    internal\n    virtual\n    override\n  {\n    yIntercept += assets;\n    emit YInterceptChanged(yIntercept);\n  }\n\n  /**\n   * @dev Handles the dilutive fees (on lien repayments) for strategists in VaultTokens.\n   * @param lienId The ID of the lien that received a payment.\n   * @param amount The amount that was paid.\n   */\n  function _handleStrategistInterestReward(uint256 lienId, uint256 amount)\n    internal\n    virtual\n    override\n  {\n    if (VAULT_FEE() != uint256(0)) {\n      uint256 interestOwing = LIEN_TOKEN().getInterest(lienId);\n      uint256 x = (amount > interestOwing) ? interestOwing : amount;\n      uint256 fee = x.mulDivDown(VAULT_FEE(), 1000); //VAULT_FEE is a basis point\n      strategistUnclaimedShares += convertToShares(fee);\n    }\n  }\n\n  function updateVaultAfterLiquidation(uint256 lienSlope) public {\n    require(msg.sender == ROUTER(), \"can only be called by the router\");\n    uint256 delta_t = block.timestamp - last;\n\n    yIntercept = slope.mulDivDown(delta_t, 1) + yIntercept;\n    last = block.timestamp;\n    slope -= lienSlope;\n  }\n\n  function getYIntercept() public view returns (uint256) {\n    return yIntercept;\n  }\n\n  function _decreaseYIntercept(uint256 amount) internal {\n    yIntercept -= amount;\n    emit YInterceptChanged(yIntercept);\n  }\n\n  function decreaseYIntercept(uint256 amount) public {\n    require(\n      msg.sender == AUCTION_HOUSE() ||\n        (currentEpoch != 0 &&\n          msg.sender == liquidationAccountants[currentEpoch - 1]),\n      \"msg sender only from auction house or liquidation accountant\"\n    );\n    _decreaseYIntercept(amount);\n  }\n\n  function getCurrentEpoch() public view returns (uint64) {\n    return currentEpoch;\n  }\n\n  /**\n   * @notice Computes the time until the current epoch is over.\n   * @return Seconds until the current epoch ends.\n   */\n  function timeToEpochEnd() public view returns (uint256) {\n    uint256 epochEnd = START() + ((currentEpoch + 1) * EPOCH_LENGTH());\n\n    if (epochEnd >= block.timestamp) {\n      return uint256(0);\n    }\n\n    return block.timestamp - epochEnd; //\n  }\n\n  function getLiquidationAccountant(uint64 epoch)\n    public\n    view\n    returns (address)\n  {\n    return liquidationAccountants[epoch];\n  }\n}"
    },
    {
      "filename": "src/LienToken.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n/**\n *       __  ___       __\n *  /\\  /__'  |   /\\  |__) |  /\\\n * /~~\\ .__/  |  /~~\\ |  \\ | /~~\\\n *\n * Copyright (c) Astaria Labs, Inc\n */\n\npragma solidity ^0.8.17;\n\npragma experimental ABIEncoderV2;\n\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport {ERC721} from \"gpl/ERC721.sol\";\nimport {IAuctionHouse} from \"gpl/interfaces/IAuctionHouse.sol\";\nimport {IERC721, IERC165} from \"gpl/interfaces/IERC721.sol\";\nimport {ITransferProxy} from \"gpl/interfaces/ITransferProxy.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\nimport {Base64} from \"./libraries/Base64.sol\";\nimport {CollateralLookup} from \"./libraries/CollateralLookup.sol\";\n\nimport {IAstariaRouter} from \"./interfaces/IAstariaRouter.sol\";\nimport {ICollateralToken} from \"./interfaces/ICollateralToken.sol\";\nimport {ILienBase, ILienToken} from \"./interfaces/ILienToken.sol\";\n\nimport {IPublicVault} from \"./PublicVault.sol\";\nimport {VaultImplementation} from \"./VaultImplementation.sol\";\n\ncontract TransferAgent {\n  address public immutable WETH;\n  ITransferProxy public immutable TRANSFER_PROXY;\n\n  constructor(ITransferProxy _TRANSFER_PROXY, address _WETH) {\n    TRANSFER_PROXY = _TRANSFER_PROXY;\n    WETH = _WETH;\n  }\n}\n\n/**\n * @title LienToken\n * @author androolloyd\n * @notice This contract handles the creation, payments, buyouts, and liquidations of tokenized NFT-collateralized debt (liens). Vaults which originate loans against supported collateral are issued a LienToken representing the right to loan repayments and auctioned funds on liquidation.\n */\ncontract LienToken is ERC721, ILienToken, Auth, TransferAgent {\n  using FixedPointMathLib for uint256;\n  using CollateralLookup for address;\n  using SafeCastLib for uint256;\n\n  IAuctionHouse public AUCTION_HOUSE;\n  IAstariaRouter public ASTARIA_ROUTER;\n  ICollateralToken public COLLATERAL_TOKEN;\n\n  uint256 INTEREST_DENOMINATOR = 1e18; //wad per second\n\n  uint256 constant MAX_LIENS = uint256(5);\n\n  mapping(uint256 => Lien) public lienData;\n  mapping(uint256 => uint256[]) public liens;\n\n  /**\n   * @dev Setup transfer authority and initialize the buyoutNumerator and buyoutDenominator for the lien buyout premium.\n   * @param _AUTHORITY The authority manager.\n   * @param _TRANSFER_PROXY The TransferProxy for balance transfers.\n   * @param _WETH The WETH address to use for transfers.\n   */\n  constructor(\n    Authority _AUTHORITY,\n    ITransferProxy _TRANSFER_PROXY,\n    address _WETH\n  )\n    Auth(address(msg.sender), _AUTHORITY)\n    TransferAgent(_TRANSFER_PROXY, _WETH)\n    ERC721(\"Astaria Lien Token\", \"ALT\")\n  {}\n\n  /**\n   * @notice Sets addresses for the AuctionHouse, CollateralToken, and AstariaRouter contracts to use.\n   * @param what The identifier for what is being filed.\n   * @param data The encoded address data to be decoded and filed.\n   */\n  function file(bytes32 what, bytes calldata data) external requiresAuth {\n    if (what == \"setAuctionHouse\") {\n      address addr = abi.decode(data, (address));\n      AUCTION_HOUSE = IAuctionHouse(addr);\n    } else if (what == \"setCollateralToken\") {\n      address addr = abi.decode(data, (address));\n      COLLATERAL_TOKEN = ICollateralToken(addr);\n    } else if (what == \"setAstariaRouter\") {\n      address addr = abi.decode(data, (address));\n      ASTARIA_ROUTER = IAstariaRouter(addr);\n    } else {\n      revert UnsupportedFile();\n    }\n    emit File(what, data);\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC721, IERC165)\n    returns (bool)\n  {\n    return\n      interfaceId == type(ILienToken).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @notice Purchase a LienToken for its buyout price.\n   * @param params The LienActionBuyout data specifying the lien position, receiver address, and underlying CollateralToken information of the lien.\n   */\n\n  function buyoutLien(ILienToken.LienActionBuyout calldata params) external {\n    (bool valid, IAstariaRouter.LienDetails memory ld) = ASTARIA_ROUTER\n      .validateCommitment(params.incoming);\n\n    if (!valid) {\n      revert InvalidTerms();\n    }\n\n    uint256 collateralId = params.incoming.tokenContract.computeId(\n      params.incoming.tokenId\n    );\n    (uint256 owed, uint256 buyout) = getBuyout(collateralId, params.position);\n    uint256 lienId = liens[collateralId][params.position];\n\n    //the borrower shouldn't incur more debt from the buyout than they already owe\n    if (ld.maxAmount < owed) {\n      revert InvalidBuyoutDetails(ld.maxAmount, owed);\n    }\n    if (!ASTARIA_ROUTER.isValidRefinance(lienData[lienId], ld)) {\n      revert InvalidRefinance();\n    }\n\n    TRANSFER_PROXY.tokenTransferFrom(\n      WETH,\n      address(msg.sender),\n      getPayee(lienId),\n      uint256(buyout)\n    );\n\n    lienData[lienId].last = block.timestamp.safeCastTo32();\n    lienData[lienId].start = block.timestamp.safeCastTo32();\n    lienData[lienId].rate = ld.rate.safeCastTo240();\n    lienData[lienId].duration = ld.duration.safeCastTo32();\n\n    _transfer(ownerOf(lienId), address(params.receiver), lienId);\n  }\n\n  /**\n   * @notice Public view function that computes the interest for a LienToken since its last payment.\n   * @param collateralId The ID of the underlying CollateralToken\n   * @param position The position of the lien to calculate interest for.\n   */\n  function getInterest(uint256 collateralId, uint256 position)\n    public\n    view\n    returns (uint256)\n  {\n    uint256 lien = liens[collateralId][position];\n    return _getInterest(lienData[lien], block.timestamp);\n  }\n\n  /**\n   * @dev Computes the interest accrued for a lien since its last payment.\n   * @param lien The Lien for the loan to calculate interest for.\n   * @param timestamp The timestamp at which to compute interest for.\n   */\n  function _getInterest(Lien memory lien, uint256 timestamp)\n    internal\n    view\n    returns (uint256)\n  {\n    if (!lien.active) {\n      return uint256(0);\n    }\n    uint256 delta_t;\n    if (block.timestamp >= lien.start + lien.duration) {\n      delta_t = uint256(lien.start + lien.duration - lien.last);\n    } else {\n      delta_t = uint256(timestamp.safeCastTo32() - lien.last);\n    }\n    return\n      delta_t.mulDivDown(lien.rate, 1).mulDivDown(\n        lien.amount,\n        INTEREST_DENOMINATOR\n      );\n  }\n\n  /**\n   * @notice Stops accruing interest for all liens against a single CollateralToken.\n   * @param collateralId The ID for the  CollateralToken of the NFT used as collateral for the liens.\n   */\n  function stopLiens(uint256 collateralId)\n    external\n    requiresAuth\n    returns (uint256 reserve, uint256[] memory lienIds)\n  {\n    reserve = 0;\n    lienIds = liens[collateralId];\n    for (uint256 i = 0; i < lienIds.length; ++i) {\n      Lien storage lien = lienData[lienIds[i]];\n      unchecked {\n        lien.amount = _getOwed(lien);\n        reserve += lien.amount;\n      }\n      lien.active = false;\n    }\n  }\n\n  /**\n   * @dev See {IERC721Metadata-tokenURI}.\n   */\n  function tokenURI(uint256 tokenId)\n    public\n    pure\n    override\n    returns (string memory)\n  {\n    return \"\";\n  }\n\n  /**\n   * @notice Creates a new lien against a CollateralToken.\n   * @param params LienActionEncumber data containing CollateralToken information and lien parameters (rate, duration, and amount, rate, and debt caps).\n   */\n  function createLien(ILienBase.LienActionEncumber memory params)\n    external\n    requiresAuth\n    returns (uint256 lienId)\n  {\n    // require that the auction is not under way\n\n    uint256 collateralId = params.tokenContract.computeId(params.tokenId);\n\n    if (AUCTION_HOUSE.auctionExists(collateralId)) {\n      revert InvalidCollateralState(InvalidStates.AUCTION);\n    }\n\n    (address tokenContract, ) = COLLATERAL_TOKEN.getUnderlying(collateralId);\n    if (tokenContract == address(0)) {\n      revert InvalidCollateralState(InvalidStates.NO_DEPOSIT);\n    }\n\n    uint256 totalDebt = getTotalDebtForCollateralToken(collateralId);\n    uint256 impliedRate = getImpliedRate(collateralId);\n\n    uint256 potentialDebt = totalDebt *\n      (impliedRate + 1) *\n      params.terms.duration;\n\n    if (potentialDebt > params.terms.maxPotentialDebt) {\n      revert InvalidCollateralState(InvalidStates.DEBT_LIMIT);\n    }\n\n    lienId = uint256(\n      keccak256(\n        abi.encodePacked(\n          abi.encode(\n            bytes32(collateralId),\n            params.vault,\n            WETH,\n            params.terms.maxAmount,\n            params.terms.rate,\n            params.terms.duration,\n            params.terms.maxPotentialDebt\n          ),\n          params.strategyRoot\n        )\n      )\n    );\n\n    //0 - 4 are valid\n    require(\n      uint256(liens[collateralId].length) < MAX_LIENS,\n      \"too many liens active\"\n    );\n\n    uint8 newPosition = uint8(liens[collateralId].length);\n\n    _mint(VaultImplementation(params.vault).recipient(), lienId);\n    lienData[lienId] = Lien({\n      collateralId: collateralId,\n      position: newPosition,\n      amount: params.amount,\n      active: true,\n      rate: params.terms.rate.safeCastTo240(),\n      last: block.timestamp.safeCastTo32(),\n      start: block.timestamp.safeCastTo32(),\n      duration: params.terms.duration.safeCastTo32(),\n      payee: address(0)\n    });\n\n    liens[collateralId].push(lienId);\n    emit NewLien(lienId, lienData[lienId]);\n  }\n\n  /**\n   * @notice Removes all liens for a given CollateralToken.\n   * @param collateralId The ID for the underlying CollateralToken.\n   * @param remainingLiens The IDs for the unpaid liens\n   */\n  function removeLiens(uint256 collateralId, uint256[] memory remainingLiens)\n    external\n    requiresAuth\n  {\n    for (uint256 i = 0; i < remainingLiens.length; i++) {\n      delete lienData[remainingLiens[i]];\n      _burn(remainingLiens[i]);\n    }\n    delete liens[collateralId];\n    emit RemovedLiens(collateralId);\n  }\n\n  /**\n   * @notice Retrieves all liens taken out against the underlying NFT of a CollateralToken.\n   * @param collateralId The ID for the underlying CollateralToken.\n   * @return The IDs of the liens against the CollateralToken.\n   */\n  function getLiens(uint256 collateralId)\n    public\n    view\n    returns (uint256[] memory)\n  {\n    return liens[collateralId];\n  }\n\n  /**\n   * @notice Retrieves a specific Lien by its ID.\n   * @param lienId The ID of the requested Lien.\n   * @return lien The Lien for the lienId.\n   */\n  function getLien(uint256 lienId) public view returns (Lien memory lien) {\n    lien = lienData[lienId];\n    lien.amount = _getOwed(lien);\n    lien.last = block.timestamp.safeCastTo32();\n  }\n\n  /**\n   * @notice Retrives a specific Lien from the ID of the CollateralToken for the underlying NFT and the lien position.\n   * @param collateralId The ID for the underlying CollateralToken.\n   * @param position The requested lien position.\n   *  @ return lien The Lien for the lienId.\n   */\n  function getLien(uint256 collateralId, uint256 position)\n    public\n    view\n    returns (Lien memory)\n  {\n    uint256 lienId = liens[collateralId][position];\n    return getLien(lienId);\n  }\n\n  /**\n   * @notice Computes and returns the buyout amount for a Lien.\n   * @param collateralId The ID for the underlying CollateralToken.\n   * @param position The position of the Lien to compute the buyout amount for.\n   * @return The outstanding debt for the lien and the buyout amount for the Lien.\n   */\n  function getBuyout(uint256 collateralId, uint256 position)\n    public\n    view\n    returns (uint256, uint256)\n  {\n    Lien memory lien = getLien(collateralId, position);\n\n    uint256 remainingInterest = _getRemainingInterest(lien, true);\n    uint256 buyoutTotal = lien.amount +\n      ASTARIA_ROUTER.getBuyoutFee(remainingInterest);\n\n    return (lien.amount, buyoutTotal);\n  }\n\n  /**\n   * @notice Make a payment for the debt against a CollateralToken.\n   * @param collateralId The ID of the underlying CollateralToken.\n   * @param paymentAmount The amount to pay against the debt.\n   */\n  function makePayment(uint256 collateralId, uint256 paymentAmount) public {\n    _makePayment(collateralId, paymentAmount);\n  }\n\n  /**\n   * @notice Make a payment for the debt against a CollateralToken for a specific lien.\n   * @param collateralId The ID of the underlying CollateralToken.\n   * @param paymentAmount The amount to pay against the debt.\n   * @param position The lien position to make a payment to.\n   */\n  function makePayment(\n    uint256 collateralId,\n    uint256 paymentAmount,\n    uint8 position\n  ) external {\n    _payment(collateralId, position, paymentAmount, address(msg.sender));\n  }\n\n  /**\n   * @notice Have a specified paymer make a payment for the debt against a CollateralToken.\n   * @param collateralId The ID of the underlying CollateralToken.\n   * @param totalCapitalAvailable The amount to pay against the debts\n   */\n  function _makePayment(uint256 collateralId, uint256 totalCapitalAvailable)\n    internal\n  {\n    uint256[] memory openLiens = liens[collateralId];\n    uint256 paymentAmount = totalCapitalAvailable;\n    for (uint256 i = 0; i < openLiens.length; ++i) {\n      uint256 capitalSpent = _payment(\n        collateralId,\n        uint8(i),\n        paymentAmount,\n        address(msg.sender)\n      );\n      paymentAmount -= capitalSpent;\n    }\n  }\n\n  function makePayment(\n    uint256 collateralId,\n    uint256 paymentAmount,\n    uint8 position,\n    address payer\n  ) public requiresAuth {\n    _payment(collateralId, position, paymentAmount, payer);\n  }\n\n  /**\n   * @notice Computes the rate for a specified lien.\n   * @param lienId The ID for the lien.\n   * @return The rate for the specified lien, in WETH per second.\n   */\n  function calculateSlope(uint256 lienId) public view returns (uint256) {\n    Lien memory lien = lienData[lienId];\n    uint256 end = (lien.start + lien.duration);\n    uint256 owedAtEnd = _getOwed(lien, end);\n    return (owedAtEnd - lien.amount).mulDivDown(1, end - lien.last);\n  }\n\n  /**\n   * @notice Computes the change in rate for a lien if a specific payment amount was made.\n   * @param lienId The ID for the lien.\n   * @param paymentAmount The hypothetical payment amount that would be made to the lien.\n   * @return slope The difference between the current lien rate and the lien rate if the payment was made.\n   */\n  function changeInSlope(uint256 lienId, uint256 paymentAmount)\n    public\n    view\n    returns (uint256 slope)\n  {\n    Lien memory lien = lienData[lienId];\n    uint256 oldSlope = calculateSlope(lienId);\n    uint256 newAmount = (lien.amount - paymentAmount);\n\n    // slope = (rate*time*amount - amount) / time -> amount(rate*time - 1) / time\n    uint256 newSl"
    }
  ]
}