{
  "Title": "M-2: MerkleReserveMinter minting methodology is incompatible with current governance structure and can lead to migrated DAOs being hijacked immediately",
  "Content": "# Issue M-2: MerkleReserveMinter minting methodology is incompatible with current governance structure and can lead to migrated DAOs being hijacked immediately \n\nSource: https://github.com/sherlock-audit/2023-09-nounsbuilder-judging/issues/249 \n\n## Found by \n0x52, SilentDefendersOfDeFi, jerseyjoewalcott, nirohgo\n## Summary\n\nMerkleReserveMinter allows large number of tokens to be minted instantaneously which is incompatible with the current governance structure which relies on tokens being minted individually and time locked after minting by the auction. By minting and creating a proposal in the same block a user is able to create a proposal with significantly lower quorum than expected. This could easily be used to hijack the migrated DAO.\n\n## Vulnerability Detail\n\n[MerkleReserveMinter.sol#L154-L167](https://github.com/sherlock-audit/2023-09-nounsbuilder/blob/main/nouns-protocol/src/minters/MerkleReserveMinter.sol#L154-L167)\n\n    unchecked {\n        for (uint256 i = 0; i < claimCount; ++i) {\n            // Load claim in memory\n            MerkleClaim memory claim = claims[I];\n\n            // Requires one proof per tokenId to handle cases where users want to partially claim\n            if (!MerkleProof.verify(claim.merkleProof, settings.merkleRoot, keccak256(abi.encode(claim.mintTo, claim.tokenId)))) {\n                revert INVALID_MERKLE_PROOF(claim.mintTo, claim.merkleProof, settings.merkleRoot);\n            }\n\n            // Only allowing reserved tokens to be minted for this strategy\n            IToken(tokenContract).mintFromReserveTo(claim.mintTo, claim.tokenId);\n        }\n    }\n\nWhen minting from the claim merkle tree, a user is able to mint as many tokens as they want in a single transaction. This means in a single transaction, the supply of the token can increase very dramatically. Now we'll take a look at the governor contract as to why this is such an issue.\n\n[Governor.sol#L184-L192](https://github.com/sherlock-audit/2023-09-nounsbuilder/blob/main/nouns-protocol/src/governance/governor/Governor.sol#L184-L192)\n\n        // Store the proposal data\n        proposal.voteStart = SafeCast.toUint32(snapshot);\n        proposal.voteEnd = SafeCast.toUint32(deadline);\n        proposal.proposalThreshold = SafeCast.toUint32(currentProposalThreshold);\n        proposal.quorumVotes = SafeCast.toUint32(quorum());\n        proposal.proposer = msg.sender;\n        proposal.timeCreated = SafeCast.toUint32(block.timestamp);\n\n        emit ProposalCreated(proposalId, _targets, _values, _calldatas, _description, descriptionHash, proposal);\n\n[Governor.sol#L495-L499](https://github.com/sherlock-audit/2023-09-nounsbuilder/blob/main/nouns-protocol/src/governance/governor/Governor.sol#L495-L499)\n\n    function quorum() public view returns (uint256) {\n        unchecked {\n            return (settings.token.totalSupply() * settings.quorumThresholdBps) / BPS_PER_100_PERCENT;\n        }\n    }\n\nWhen creating a proposal, we see that it uses a snapshot of the CURRENT total supply. This is what leads to the issue. The setup is fairly straightforward and occurs all in a single transaction:\n\n1) Create a malicious proposal (which snapshots current supply)\n2) Mint all the tokens\n3) Vote on malicious proposal with all minted tokens\n\nThe reason this works is because the quorum is based on the supply before the mint while votes are considered after the mint, allowing significant manipulation of the quorum.\n\n## Impact\n\nDOA can be completely hijacked\n\n## Code Snippet\n\n[MerkleReserveMinter.sol#L129-L173](https://github.com/sherlock-audit/2023-09-nounsbuilder/blob/main/nouns-protocol/src/minters/MerkleReserveMinter.sol#L129-L173)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nToken should be changed to use a checkpoint based total supply, similar to how balances are handled. Quorum should be based on that instead of the current supply.\n\n\n\n## Discussion\n\n**neokry**\n\nThis is a valid issue but makes a big assumption that a malicious user is included in the merkle tree with a significant share of reserved tokens and the DAO has no veto set. This might be too much of an edge case to make the recommended changes to the token and governor contracts.\n\n**neokry**\n\nFixed here: https://github.com/ourzora/nouns-protocol/pull/124\n\nAs noted in this PR we added a governance delay to fix the more significant issue of a DAO without veto potentially being hijacked. A delay will also help alleviate some of the issues related to claiming and quorum but not outright fix. For quorum issues we will warn DAOs around the risks of setting a high amount of votes for single users. \n\n**Oot2k**\n\nEscalate\n\nI think this issue should be high instead of medium.\nThe attack path can be simply executed by anyone and there is no way to prevent it.\n\nThe only requirement would be that there is no veto, but this is a feature not a requirement, which makes this a high instead of medium.  Also see #155 for reasoning\n\nAs @nevillehuang mentions in the comment on #52 this should be more an High instead. \n\n**sherlock-admin2**\n\n > Escalate\n> \n> I think this issue should be high instead of medium.\n> The attack path can be simply executed by anyone and there is no way to prevent it.\n> \n> The only requirement would be that there is no veto, but this is a feature not a requirement, which makes this a high instead of medium.  Also see #155 for reasoning\n> \n> As @nevillehuang mentions in the comment on #52 this should be more an High instead. \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**neokry**\n\n> Escalate\n> \n> I think this issue should be high instead of medium. The attack path can be simply executed by anyone and there is no way to prevent it.\n> \n> The only requirement would be that there is no veto, but this is a feature not a requirement, which makes this a high instead of medium. Also see #155 for reasoning\n> \n> As @nevillehuang mentions in the comment on #52 this should be more an High instead.\n\nthe attack can only be executed by users in the merkle tree which is controlled by the admin. most DAOs also have veto set. there is no loss of funds if the merkle claim has no price per token and deployer can simply redeploy the DAO and remove the malicious user form the merkle tree.\n\n**nevillehuang**\n\nI see your point @Oot2k but I agree with sponsor, this issue is dependent on a NounsDAO type governance with no veto which I believe is unlikely, so will leave it up to @Czar102 to decide severity.\n\n**Czar102**\n\nIs the new DAO being created holding any funds? Or is it said that it shouldn't hold any until `settings.mintEnd`?\n@neokry @nevillehuang \n\n**neokry**\n\nDAOs are not holding any funds upon creation but it could receive funds if price per token is set and users have claimed tokens\n\n**nevillehuang**\n\n@Czar102 I only assigned this medium severity on the condition that veto are not set for a nounsDAO type governance which is unrealistic, but if you disagree, I could also see why this could be high severity given the impact it has.\n\n**Oot2k**\n\nI wanted to add to sponsor comment that after migration the DAO indeed holds funds, the total layer 1 treasury.\n\nSo for example: DAO with 100 ETH is migrated, all old users get chance to mint tokens for free and no veto set because nouns is designed to delete the veto at some point.\n\nIn this case the 100 ETH can be instantly drained.\n\n**nevillehuang**\n\n@Oot2k Can you outline how the funds can be immediately drained? If true this definitely could be high severity.\n\nFrom my understanding it has something to do with adjusting the parameters to allow instant execution of proposals correct? \n\n**Oot2k**\n\nIn #155 we tried to outline it.\n\nMigration happens like this:\n1. DAO on layer 1 is stoped\n2. Merkeltree with mint config is created \n3. DAO on layer 2 is deployed \n4. Treasury of DAO is transferred from layer1 to layer2\n5. First user to mint quorum tokens can create proposal to drain DAO\n6. Because of the nature of OZ governance only tokens minted at time of proposal can participate in governance.\n-> drain can not be stopped because only the malicious user can vote and there is no way to \"save\" treasury\n\n\n**nevillehuang**\n\n> In #155 we tried to outline it.\n> \n> Migration happens like this:\n> \n> 1. DAO on layer 1 is stoped\n> 2. Merkeltree with mint config is created\n> 3. DAO on layer 2 is deployed\n> 4. Treasury of DAO is transferred from layer1 to layer2\n> 5. First user to mint quorum tokens can create proposal to drain DAO\n> 6. Because of the nature of OZ governance only tokens minted at time of proposal can participate in governance.\n>    -> drain can not be stopped because only the malicious user can vote and there is no way to \"save\" treasury\n\nIs there a proposal delay/duration that can be changed by the malicious users? If so it will be helpful if you point me to the code logic. If not I think the other members of the DAO would have sufficient time to react to proposals.\n\n**neokry**\n\nThe treasury migration step has to go through the full layer 1 DAO governance and the DAO can decide when to submit that proposal. it doesn’t happen immediately after the L2 DAO is deployed. An L1 DAO might also choose to only migrate a portion of their treasury as well to ensure the L2 DAO runs smoothly for a period of time \n\n**Oot2k**\n\n> > In #155 we tried to outline it.\n> > Migration happens like this:\n> > \n> > 1. DAO on layer 1 is stoped\n> > 2. Merkeltree with mint config is created\n> > 3. DAO on layer 2 is deployed\n> > 4. Treasury of DAO is transferred from layer1 to layer2\n> > 5. First user to mint quorum tokens can create proposal to drain DAO\n> > 6. Because of the nature of OZ governance only tokens minted at time of proposal can participate in governance.\n> >    -> drain can not be stopped because only the malicious user can vote and there is no way to \"save\" treasury\n> \n> Is there a proposal delay/duration that can be changed by the malicious users? If so it will be helpful if you point me to the code logic. If not I think the other members of the DAO would have sufficient time to react to proposals.\n\nThey cant react. OZ governance takes the votes from the timestamp. This report includes all important code snippets.\nEven if the proposal has an execution time of 10 weeks it does not matter because every proposal created after gets executed after the drain.\n\nSponsors comments are right, ofc the DAO can migrate only a part of funds, but that does not lower the severity.\nIts still highly realistic that all funds are send at ones.\n\nAnd in reality I think no one will claim tokens in a DAO that has no treasury, so the possibility is quite high.\n\n**neokry**\n\nfor full context on migration we have a bot setup to airdrop DAO tokens for migrated DAOs. Our recommendation to all DAOs will be to execute the migration call wait for tokens to be airdropped and pass a proposal to unpause auctions on L2 before sending the treasury to the L2 DAO. there is a chance this attack could be executed before the bot airdrops the tokens which is why we’ve added the governance delay as a fix. also a malicious user would need to immediately submit this proposal to the DAO making it obvious if a DAO will be captured ie they can easily choose not to send the treasury. \n\n**Czar102**\n\nI think sending any DAO funds to the L2 DAO would be irresponsible if the L2 DAO isn't set up yet. I would be considered an admin error in my opinion. @neokry would you agree?\n\n> DAOs are not holding any funds upon creation but it could receive funds if price per token is set and users have claimed tokens\n\nI think mint fees could be stolen. The attacker could wait for as many tokens as possible would be bought and then mint all their tokens (so that they will have a majority and satisfy quorum) and create a proposal to steal all mint fees. From my understanding, they can also hijack the governance, but it wouldn't hold any other funds at that time.\n\nIs my understanding accurate?\nI would also like to get to know why do you perceive having no veto as likely/unlikely.\n\n**nevillehuang**\n\n@Czar102 I am basing it off of the original NounsDAO governance, where veto is a core role present configured by the admin to prevent malicious proposals. \n\n**neokry**\n\nI agree on your first point @Czar102 . regarding stealing mint fees the attack only works if the attackers vote power is greater than the voting power of active voters. ie if they wait for the majority of users to claim their mint funds they have a higher chance of their proposal to steal funds be voted down. \n\nalso agree with @nevillehuang while veto is optional the veto is used by most DAOs and we strongly encouraged DAOs to set it up to prevent governance attacks like this.\n\n**Czar102**\n\nMy thoughts after some internal discussions:\n- This issue presents a loss of funds scenario, which is limited by the number of tokens an attacker can gather (when there is no frontrunning, frontrunning also has a limited impact). This is quite constrained, so is the loss. The DAO shouldn't hold any funds other than buy-ins at that time.\n- If there is no vetoer and the attacker does the attack right, I believe there is no way to recover funds for addresses who bought in.\n- It is reasonable to assume that there will be no vetoer because of [this fragment of the code](https://github.com/sherlock-audit/2023-09-nounsbuilder/blob/main/nouns-protocol/src/governance/governor/Governor.sol#L99-L100), hence this finding should be at least a medium. It feels like that role is highly advisable to be assigned at least in the very first moments of the DAO when it's being set up (and tokens are being bought, etc.), so I believe a lack of the vetoer is an assumption concerning the state of the DAO.\n\nBased on the above points, I think it is a borderline Med/High. I am leaning towards leaving it a medium.\n\n**Oot2k**\n\nI want to quote the scenario where a DAOs treasury is transferred before the reserve mint ends.\nThe code/docs do not mention in any way that the mint of tokens happens before the treasury is transferred. In this case the impact is detrimental.\nI still think this is a high considering the different ways the issue impacts governance manipulation. \n\n**Czar102**\n\nI think it would be a setup mistake to send funds to an \"uninitialized\" DAO.\n\n**Czar102**\n\nResult:\nMedium\nHas duplicates\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [Oot2k](https://github.com/sherlock-audit/2023-09-nounsbuilder-judging/issues/249/#issuecomment-1855620638): rejected\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/111",
  "Code": [
    {
      "filename": "nouns-protocol/src/minters/MerkleReserveMinter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport { IOwnable } from \"../lib/interfaces/IOwnable.sol\";\nimport { IToken } from \"../token/IToken.sol\";\nimport { Manager } from \"../manager/Manager.sol\";\nimport { IProtocolRewards } from \"../lib/interfaces/IProtocolRewards.sol\";\n\n/// @title MerkleReserveMinter\n/// @notice A mint strategy that mints reserved tokens based on a merkle tree\n/// @author @neokry\ncontract MerkleReserveMinter {\n    ///                                                          ///\n    ///                            EVENTS                        ///\n    ///                                                          ///\n\n    /// @notice Event for mint settings updated\n    event MinterSet(address indexed tokenContract, MerkleMinterSettings merkleSaleSettings);\n\n    ///                                                          ///\n    ///                            ERRORS                        ///\n    ///                                                          ///\n\n    /// @dev Caller is not the owner of the specified token contract\n    error NOT_TOKEN_OWNER();\n\n    /// @dev Transfer failed\n    error TRANSFER_FAILED();\n\n    /// @dev Mint has ended\n    error MINT_ENDED();\n\n    /// @dev Mint has not started\n    error MINT_NOT_STARTED();\n\n    /// @dev Value sent does not match total fee value\n    error INVALID_VALUE();\n\n    /// @dev Invalid amount of tokens to claim\n    error INVALID_CLAIM_COUNT();\n\n    /// @dev Merkle proof for claim is invalid\n    /// @param mintTo Address to mint to\n    /// @param merkleProof Merkle proof for token\n    /// @param merkleRoot Merkle root for collection\n    error INVALID_MERKLE_PROOF(address mintTo, bytes32[] merkleProof, bytes32 merkleRoot);\n\n    ///                                                          ///\n    ///                            STRUCTS                       ///\n    ///                                                          ///\n\n    /// @notice General merkle sale settings\n    struct MerkleMinterSettings {\n        /// @notice Unix timestamp for the mint start\n        uint64 mintStart;\n        /// @notice Unix timestamp for the mint end\n        uint64 mintEnd;\n        /// @notice Price per token\n        uint64 pricePerToken;\n        /// @notice Merkle root for\n        bytes32 merkleRoot;\n    }\n\n    /// @notice Parameters for merkle minting\n    struct MerkleClaim {\n        /// @notice Address to mint to\n        address mintTo;\n        /// @notice Token ID to mint\n        uint256 tokenId;\n        /// @notice Merkle proof for token\n        bytes32[] merkleProof;\n    }\n\n    ///                                                          ///\n    ///                            CONSTANTS                     ///\n    ///                                                          ///\n\n    /// @notice Per token mint fee sent to BuilderDAO\n    uint256 public constant BUILDER_DAO_FEE = 0.000777 ether;\n\n    ///                                                          ///\n    ///                            IMMUTABLES                    ///\n    ///                                                          ///\n\n    /// @notice Manager contract\n    Manager immutable manager;\n\n    /// @notice Protocol rewards contract\n    IProtocolRewards immutable protocolRewards;\n\n    ///                                                          ///\n    ///                            STORAGE                       ///\n    ///                                                          ///\n\n    /// @notice Mapping of DAO token contract to merkle settings\n    mapping(address => MerkleMinterSettings) public allowedMerkles;\n\n    ///                                                          ///\n    ///                            MODIFIERS                     ///\n    ///                                                          ///\n\n    /// @notice Checks if the caller is the token contract or the owner of the token contract\n    /// @param tokenContract Token contract to check\n    modifier onlyContractOwner(address tokenContract) {\n        // Revert if sender is not the token contract owner\n        if (!_isContractOwner(msg.sender, tokenContract)) {\n            revert NOT_TOKEN_OWNER();\n        }\n        _;\n    }\n\n    ///                                                          ///\n    ///                            CONSTRUCTOR                   ///\n    ///                                                          ///\n\n    constructor(address _manager, address _protocolRewards) {\n        manager = Manager(_manager);\n        protocolRewards = IProtocolRewards(_protocolRewards);\n    }\n\n    ///                                                          ///\n    ///                            MINT                          ///\n    ///                                                          ///\n\n    /// @notice Mints tokens from reserve using a merkle proof\n    /// @param tokenContract Address of token contract\n    /// @param claims List of merkle claims\n    function mintFromReserve(address tokenContract, MerkleClaim[] calldata claims) public payable {\n        MerkleMinterSettings memory settings = allowedMerkles[tokenContract];\n        uint256 claimCount = claims.length;\n\n        // Ensure claims are not empty\n        if (claimCount == 0) {\n            revert INVALID_CLAIM_COUNT();\n        }\n\n        // Check sale end\n        if (block.timestamp > settings.mintEnd) {\n            revert MINT_ENDED();\n        }\n\n        // Check sale start\n        if (block.timestamp < settings.mintStart) {\n            revert MINT_NOT_STARTED();\n        }\n\n        // Check value sent\n        if (msg.value < _getTotalFeesForMint(settings.pricePerToken, claimCount)) {\n            revert INVALID_VALUE();\n        }\n\n        // Mint tokens\n        unchecked {\n            for (uint256 i = 0; i < claimCount; ++i) {\n                // Load claim in memory\n                MerkleClaim memory claim = claims[i];\n\n                // Requires one proof per tokenId to handle cases where users want to partially claim\n                if (!MerkleProof.verify(claim.merkleProof, settings.merkleRoot, keccak256(abi.encode(claim.mintTo, claim.tokenId)))) {\n                    revert INVALID_MERKLE_PROOF(claim.mintTo, claim.merkleProof, settings.merkleRoot);\n                }\n\n                // Only allowing reserved tokens to be minted for this strategy\n                IToken(tokenContract).mintFromReserveTo(claim.mintTo, claim.tokenId);\n            }\n        }\n\n        // Distribute fees if minting fees for this collection are set (Builder DAO fee does not apply to free mints)\n        if (settings.pricePerToken > 0) {\n            _distributeFees(tokenContract, claimCount);\n        }\n    }\n\n    ///                                                          ///\n    ///                            FEES                          ///\n    ///                                                          ///\n\n    /// @notice gets the total fees for minting\n    function getTotalFeesForMint(address tokenContract, uint256 quantity) public view returns (uint256) {\n        return _getTotalFeesForMint(allowedMerkles[tokenContract].pricePerToken, quantity);\n    }\n\n    function _getTotalFeesForMint(uint256 pricePerToken, uint256 quantity) internal pure returns (uint256) {\n        // If pricePerToken is 0 the mint has no Builder DAO fee\n        return pricePerToken > 0 ? quantity * (pricePerToken + BUILDER_DAO_FEE) : 0;\n    }\n\n    function _distributeFees(address tokenContract, uint256 quantity) internal {\n        uint256 builderFee = quantity * BUILDER_DAO_FEE;\n        uint256 value = msg.value;\n\n        (, , address treasury, ) = manager.getAddresses(tokenContract);\n        address builderRecipient = manager.builderRewardsRecipient();\n\n        // Pay out fees to the Builder DAO\n        protocolRewards.deposit{ value: builderFee }(builderRecipient, hex\"00\", \"\");\n\n        // Pay out remaining funds to the treasury\n        if (value > builderFee) {\n            (bool treasurySuccess, ) = treasury.call{ value: value - builderFee }(\"\");\n\n            // Revert if treasury cannot accept funds\n            if (!treasurySuccess) {\n                revert TRANSFER_FAILED();\n            }\n        }\n    }\n\n    ///                                                          ///\n    ///                            Settings                      ///\n\n    /// @notice Sets the minter settings for a token\n    /// @param tokenContract Token contract to set settings for\n    /// @param settings Settings to set\n    function setMintSettings(address tokenContract, MerkleMinterSettings memory settings) external onlyContractOwner(tokenContract) {\n        // Set new collection settings\n        _setMintSettings(tokenContract, settings);\n\n        // Emit event for new settings\n        emit MinterSet(tokenContract, settings);\n    }\n\n    /// @notice Resets the minter settings for a token\n    /// @param tokenContract Token contract to reset settings for\n    function resetMintSettings(address tokenContract) external onlyContractOwner(tokenContract) {\n        // Reset collection settings to null\n        delete allowedMerkles[tokenContract];\n\n        // Emit event with null settings\n        emit MinterSet(tokenContract, allowedMerkles[tokenContract]);\n    }\n\n    function _setMintSettings(address tokenContract, MerkleMinterSettings memory settings) internal {\n        allowedMerkles[tokenContract] = settings;\n    }\n\n    ///                                                          ///\n    ///                            Ownership                     ///\n    ///                                                          ///\n\n    function _isContractOwner(address caller, address tokenContract) internal view returns (bool) {\n        return IOwnable(tokenContract).owner() == caller;\n    }\n}"
    },
    {
      "filename": "nouns-protocol/src/governance/governor/Governor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { UUPS } from \"../../lib/proxy/UUPS.sol\";\nimport { Ownable } from \"../../lib/utils/Ownable.sol\";\nimport { EIP712 } from \"../../lib/utils/EIP712.sol\";\nimport { SafeCast } from \"../../lib/utils/SafeCast.sol\";\n\nimport { GovernorStorageV1 } from \"./storage/GovernorStorageV1.sol\";\nimport { Token } from \"../../token/Token.sol\";\nimport { Treasury } from \"../treasury/Treasury.sol\";\nimport { IManager } from \"../../manager/IManager.sol\";\nimport { IGovernor } from \"./IGovernor.sol\";\nimport { ProposalHasher } from \"./ProposalHasher.sol\";\nimport { VersionedContract } from \"../../VersionedContract.sol\";\n\n/// @title Governor\n/// @author Rohan Kulkarni\n/// @notice A DAO's proposal manager and transaction scheduler\n/// @custom:repo github.com/ourzora/nouns-protocol\n/// Modified from:\n/// - OpenZeppelin Contracts v4.7.3 (governance/extensions/GovernorTimelockControl.sol)\n/// - NounsDAOLogicV1.sol commit 2cbe6c7 - licensed under the BSD-3-Clause license.\ncontract Governor is IGovernor, VersionedContract, UUPS, Ownable, EIP712, ProposalHasher, GovernorStorageV1 {\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The EIP-712 typehash to vote with a signature\n    bytes32 public immutable VOTE_TYPEHASH = keccak256(\"Vote(address voter,uint256 proposalId,uint256 support,uint256 nonce,uint256 deadline)\");\n\n    /// @notice The minimum proposal threshold bps setting\n    uint256 public immutable MIN_PROPOSAL_THRESHOLD_BPS = 1;\n\n    /// @notice The maximum proposal threshold bps setting\n    uint256 public immutable MAX_PROPOSAL_THRESHOLD_BPS = 1000;\n\n    /// @notice The minimum quorum threshold bps setting\n    uint256 public immutable MIN_QUORUM_THRESHOLD_BPS = 200;\n\n    /// @notice The maximum quorum threshold bps setting\n    uint256 public immutable MAX_QUORUM_THRESHOLD_BPS = 2000;\n\n    /// @notice The minimum voting delay setting\n    uint256 public immutable MIN_VOTING_DELAY = 1 seconds;\n\n    /// @notice The maximum voting delay setting\n    uint256 public immutable MAX_VOTING_DELAY = 24 weeks;\n\n    /// @notice The minimum voting period setting\n    uint256 public immutable MIN_VOTING_PERIOD = 10 minutes;\n\n    /// @notice The maximum voting period setting\n    uint256 public immutable MAX_VOTING_PERIOD = 24 weeks;\n\n    /// @notice The basis points for 100%\n    uint256 private immutable BPS_PER_100_PERCENT = 10_000;\n\n    /// @notice The contract upgrade manager\n    IManager private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IManager(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /// @notice Initializes a DAO's governor\n    /// @param _treasury The DAO's treasury address\n    /// @param _token The DAO's governance token address\n    /// @param _vetoer The address eligible to veto proposals\n    /// @param _votingDelay The voting delay\n    /// @param _votingPeriod The voting period\n    /// @param _proposalThresholdBps The proposal threshold basis points\n    /// @param _quorumThresholdBps The quorum threshold basis points\n    function initialize(\n        address _treasury,\n        address _token,\n        address _vetoer,\n        uint256 _votingDelay,\n        uint256 _votingPeriod,\n        uint256 _proposalThresholdBps,\n        uint256 _quorumThresholdBps\n    ) external initializer {\n        // Ensure the caller is the contract manager\n        if (msg.sender != address(manager)) revert ONLY_MANAGER();\n\n        // Ensure non-zero addresses are provided\n        if (_treasury == address(0)) revert ADDRESS_ZERO();\n        if (_token == address(0)) revert ADDRESS_ZERO();\n\n        // If a vetoer is specified, store its address\n        if (_vetoer != address(0)) settings.vetoer = _vetoer;\n\n        // Ensure the specified governance settings are valid\n        if (_proposalThresholdBps < MIN_PROPOSAL_THRESHOLD_BPS || _proposalThresholdBps > MAX_PROPOSAL_THRESHOLD_BPS)\n            revert INVALID_PROPOSAL_THRESHOLD_BPS();\n        if (_quorumThresholdBps < MIN_QUORUM_THRESHOLD_BPS || _quorumThresholdBps > MAX_QUORUM_THRESHOLD_BPS) revert INVALID_QUORUM_THRESHOLD_BPS();\n        if (_proposalThresholdBps >= _quorumThresholdBps) revert INVALID_PROPOSAL_THRESHOLD_BPS();\n        if (_votingDelay < MIN_VOTING_DELAY || _votingDelay > MAX_VOTING_DELAY) revert INVALID_VOTING_DELAY();\n        if (_votingPeriod < MIN_VOTING_PERIOD || _votingPeriod > MAX_VOTING_PERIOD) revert INVALID_VOTING_PERIOD();\n\n        // Store the governor settings\n        settings.treasury = Treasury(payable(_treasury));\n        settings.token = Token(_token);\n        settings.votingDelay = SafeCast.toUint48(_votingDelay);\n        settings.votingPeriod = SafeCast.toUint48(_votingPeriod);\n        settings.proposalThresholdBps = SafeCast.toUint16(_proposalThresholdBps);\n        settings.quorumThresholdBps = SafeCast.toUint16(_quorumThresholdBps);\n\n        // Initialize EIP-712 support\n        __EIP712_init(string.concat(settings.token.symbol(), \" GOV\"), \"1\");\n\n        // Grant ownership to the treasury\n        __Ownable_init(_treasury);\n    }\n\n    ///                                                          ///\n    ///                        CREATE PROPOSAL                   ///\n    ///                                                          ///\n\n    /// @notice Creates a proposal\n    /// @param _targets The target addresses to call\n    /// @param _values The ETH values of each call\n    /// @param _calldatas The calldata of each call\n    /// @param _description The proposal description\n    function propose(\n        address[] memory _targets,\n        uint256[] memory _values,\n        bytes[] memory _calldatas,\n        string memory _description\n    ) external returns (bytes32) {\n        // Get the current proposal threshold\n        uint256 currentProposalThreshold = proposalThreshold();\n\n        // Cannot realistically underflow and `getVotes` would revert\n        unchecked {\n            // Ensure the caller's voting weight is greater than or equal to the threshold\n            if (getVotes(msg.sender, block.timestamp - 1) <= proposalThreshold()) {\n                revert BELOW_PROPOSAL_THRESHOLD();\n            }\n        }\n\n        // Cache the number of targets\n        uint256 numTargets = _targets.length;\n\n        // Ensure at least one target exists\n        if (numTargets == 0) revert PROPOSAL_TARGET_MISSING();\n\n        // Ensure the number of targets matches the number of values and calldata\n        if (numTargets != _values.length) revert PROPOSAL_LENGTH_MISMATCH();\n        if (numTargets != _calldatas.length) revert PROPOSAL_LENGTH_MISMATCH();\n\n        // Compute the description hash\n        bytes32 descriptionHash = keccak256(bytes(_description));\n\n        // Compute the proposal id\n        bytes32 proposalId = hashProposal(_targets, _values, _calldatas, descriptionHash, msg.sender);\n\n        // Get the pointer to store the proposal\n        Proposal storage proposal = proposals[proposalId];\n\n        // Ensure the proposal doesn't already exist\n        if (proposal.voteStart != 0) revert PROPOSAL_EXISTS(proposalId);\n\n        // Used to store the snapshot and deadline\n        uint256 snapshot;\n        uint256 deadline;\n\n        // Cannot realistically overflow\n        unchecked {\n            // Compute the snapshot and deadline\n            snapshot = block.timestamp + settings.votingDelay;\n            deadline = snapshot + settings.votingPeriod;\n        }\n\n        // Store the proposal data\n        proposal.voteStart = SafeCast.toUint32(snapshot);\n        proposal.voteEnd = SafeCast.toUint32(deadline);\n        proposal.proposalThreshold = SafeCast.toUint32(currentProposalThreshold);\n        proposal.quorumVotes = SafeCast.toUint32(quorum());\n        proposal.proposer = msg.sender;\n        proposal.timeCreated = SafeCast.toUint32(block.timestamp);\n\n        emit ProposalCreated(proposalId, _targets, _values, _calldatas, _description, descriptionHash, proposal);\n\n        return proposalId;\n    }\n\n    ///                                                          ///\n    ///                          CAST VOTE                       ///\n    ///                                                          ///\n\n    /// @notice Casts a vote\n    /// @param _proposalId The proposal id\n    /// @param _support The support value (0 = Against, 1 = For, 2 = Abstain)\n    function castVote(bytes32 _proposalId, uint256 _support) external returns (uint256) {\n        return _castVote(_proposalId, msg.sender, _support, \"\");\n    }\n\n    /// @notice Casts a vote with a reason\n    /// @param _proposalId The proposal id\n    /// @param _support The support value (0 = Against, 1 = For, 2 = Abstain)\n    /// @param _reason The vote reason\n    function castVoteWithReason(\n        bytes32 _proposalId,\n        uint256 _support,\n        string memory _reason\n    ) external returns (uint256) {\n        return _castVote(_proposalId, msg.sender, _support, _reason);\n    }\n\n    /// @notice Casts a signed vote\n    /// @param _voter The voter address\n    /// @param _proposalId The proposal id\n    /// @param _support The support value (0 = Against, 1 = For, 2 = Abstain)\n    /// @param _deadline The signature deadline\n    /// @param _v The 129th byte and chain id of the signature\n    /// @param _r The first 64 bytes of the signature\n    /// @param _s Bytes 64-128 of the signature\n    function castVoteBySig(\n        address _voter,\n        bytes32 _proposalId,\n        uint256 _support,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (uint256) {\n        // Ensure the deadline has not passed\n        if (block.timestamp > _deadline) revert EXPIRED_SIGNATURE();\n\n        // Used to store the signed digest\n        bytes32 digest;\n\n        // Cannot realistically overflow\n        unchecked {\n            // Compute the message\n            digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(VOTE_TYPEHASH, _voter, _proposalId, _support, nonces[_voter]++, _deadline))\n                )\n            );\n        }\n\n        // Recover the message signer\n        address recoveredAddress = ecrecover(digest, _v, _r, _s);\n\n        // Ensure the recovered signer is the given voter\n        if (recoveredAddress == address(0) || recoveredAddress != _voter) revert INVALID_SIGNATURE();\n\n        return _castVote(_proposalId, _voter, _support, \"\");\n    }\n\n    /// @dev Stores a vote\n    /// @param _proposalId The proposal id\n    /// @param _voter The voter address\n    /// @param _support The vote choice\n    function _castVote(\n        bytes32 _proposalId,\n        address _voter,\n        uint256 _support,\n        string memory _reason\n    ) internal returns (uint256) {\n        // Ensure voting is active\n        if (state(_proposalId) != ProposalState.Active) revert VOTING_NOT_STARTED();\n\n        // Ensure the voter hasn't already voted\n        if (hasVoted[_proposalId][_voter]) revert ALREADY_VOTED();\n\n        // Ensure the vote is valid\n        if (_support > 2) revert INVALID_VOTE();\n\n        // Record the voter as having voted\n        hasVoted[_proposalId][_voter] = true;\n\n        // Get the pointer to the proposal\n        Proposal storage proposal = proposals[_proposalId];\n\n        // Used to store the voter's weight\n        uint256 weight;\n\n        // Cannot realistically underflow and `getVotes` would revert\n        unchecked {\n            // Get the voter's weight at the time the proposal was created\n            weight = getVotes(_voter, proposal.timeCreated);\n\n            // If the vote is against:\n            if (_support == 0) {\n                // Update the total number of votes against\n                proposal.againstVotes += SafeCast.toUint32(weight);\n\n                // Else if the vote is for:\n            } else if (_support == 1) {\n                // Update the total number of votes for\n                proposal.forVotes += SafeCast.toUint32(weight);\n\n                // Else if the vote is to abstain:\n            } else if (_support == 2) {\n                // Update the total number of votes abstaining\n                proposal.abstainVotes += SafeCast.toUint32(weight);\n            }\n        }\n\n        emit VoteCast(_voter, _proposalId, _support, weight, _reason);\n\n        return weight;\n    }\n\n    ///                                                          ///\n    ///                        QUEUE PROPOSAL                    ///\n    ///                                                          ///\n\n    /// @notice Queues a proposal\n    /// @param _proposalId The proposal id\n    function queue(bytes32 _proposalId) external returns (uint256 eta) {\n        // Ensure the proposal has succeeded\n        if (state(_proposalId) != ProposalState.Succeeded) revert PROPOSAL_UNSUCCESSFUL();\n\n        // Schedule the proposal for execution\n        eta = settings.treasury.queue(_proposalId);\n\n        emit ProposalQueued(_proposalId, eta);\n    }\n\n    ///                                                          ///\n    ///                       EXECUTE PROPOSAL                   ///\n    ///                                                          ///\n\n    /// @notice Executes a proposal\n    /// @param _targets The target addresses to call\n    /// @param _values The ETH values of each call\n    /// @param _calldatas The calldata of each call\n    /// @param _descriptionHash The hash of the description\n    /// @param _proposer The proposal creator\n    function execute(\n        address[] calldata _targets,\n        uint256[] calldata _values,\n        bytes[] calldata _calldatas,\n        bytes32 _descriptionHash,\n        address _proposer\n    ) external payable returns (bytes32) {\n        // Get the proposal id\n        bytes32 proposalId = hashProposal(_targets, _values, _calldatas, _descriptionHash, _proposer);\n\n        // Ensure the proposal is queued\n        if (state(proposalId) != ProposalState.Queued) revert PROPOSAL_NOT_QUEUED(proposalId);\n\n        // Mark the proposal as executed\n        proposals[proposalId].executed = true;\n\n        // Execute the proposal\n        settings.treasury.execute{ value: msg.value }(_targets, _values, _calldatas, _descriptionHash, _proposer);\n\n        emit ProposalExecuted(proposalId);\n\n        return proposalId;\n    }\n\n    ///                                                          ///\n    ///                        CANCEL PROPOSAL                   ///\n    ///                                                          ///\n\n    /// @notice Cancels a proposal\n    /// @param _proposalId The proposal id\n    function cancel(bytes32 _proposalId) external {\n        // Ensure the proposal hasn't been executed\n        if (state(_proposalId) == ProposalState.Executed) revert PROPOSAL_ALREADY_EXECUTED();\n\n        // Get a copy of the proposal\n        Proposal memory proposal = proposals[_proposalId];\n\n        // Cannot realistically underflow and `getVotes` would revert\n        unchecked {\n            // Ensure the caller is the proposer or the proposer's voting weight has dropped below the proposal threshold\n            if (msg.sender != proposal.proposer && getVotes(proposal.proposer, block.timestamp - 1) >= proposal.proposalThreshold)\n                revert INVALID_CANCEL();\n        }\n\n        // Update the proposal as canceled\n        proposals[_proposalId].canceled = true;\n\n        // If the proposal was queued:\n        if (settings.treasury.isQueued(_proposalId)) {\n            // Cancel the proposal\n            settings.treasury.cancel(_proposalId);\n        }\n\n        emit ProposalCanceled(_proposalId);\n    }\n\n    ///                                                          ///\n    ///                        VETO PROPOSAL                     ///\n    ///                                                          ///\n\n    /// @notice Vetoes a proposal\n    /// @param _proposalId The proposal id\n    function veto(bytes32 _proposalId) external {\n        // Ensure the caller is the vetoer\n        if (msg.sender != settings.vetoer) revert ONLY_VETOER();\n\n        // Ensure the proposal has not been executed\n        if (state(_proposalId) == ProposalState.Executed) revert PROPOSAL_ALREADY_EXECUTED();\n\n        // Get the pointer to the proposal\n        Proposal storage proposal = proposals[_proposalId];\n\n        // Update the proposal as vetoed\n        proposal.vetoed = true;\n\n        // If the proposal was queued:\n        if (settings.treasury.isQueued(_proposalId)) {\n            // Cancel the proposal\n            settings.treasury.cancel(_proposalId);\n        }\n\n        emit ProposalVetoed(_proposalId);\n    }\n\n    ///                                                          ///\n    ///                        PROPOSAL STATE                    ///\n    ///                                                          ///\n\n    /// @notice The state of a proposal\n    /// @param _proposalId The proposal id\n    function state(bytes32 _proposalId) public view returns (ProposalState) {\n        // Get a copy of the proposal\n        Proposal memory proposal = proposals[_proposalId];\n\n        // Ensure the proposal exists\n        if (proposal.voteStart == 0) revert PROPOSAL_DOES_NOT_EXIST();\n\n        // If the proposal was executed:\n        if (proposal.executed) {\n            return ProposalState.Executed;\n\n            // Else if the proposal was canceled:\n        } else if (proposal.canceled) {\n            return ProposalState.Canceled;\n\n            // Else if the proposal was vetoed:\n        } else if (proposal.vetoed) {\n            return ProposalState.Vetoed;\n\n            // Else if voting has not started:\n        } else if (block.timestamp < proposal.voteStart) {\n            return ProposalState.Pending;\n\n            // Else if voting has not ended:\n        } else if (block.timestamp < proposal.voteEnd) {\n            return ProposalState.Active;\n\n            // Else if the proposal failed (outvoted OR didn't reach quorum):\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) {\n            return ProposalState.Defeated;\n\n            // Else if the proposal has not been queued:\n        } else if (settings.treasury.timestamp(_proposalId) == 0) {\n            return ProposalState.Succeeded;\n\n            // Else if the proposal can no longer be executed:\n        } else if (settings.treasury.isExpired(_proposalId)) {\n            return ProposalState.Expired;\n\n            // Else the proposal is queued\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    /// @notice The voting weight of an account at a timestamp\n    /// @param _account The account address\n    /// @param _timestamp The specific timestamp\n    function getVotes(address _account, uint256 _timestamp) public view returns (uint256) {\n        return settings.token.getPastVotes(_account, _timestamp);\n    }\n\n    /// @notice The current number of votes required to submit a proposal\n    function proposalThreshold() public view returns (uint256) {\n        unchecked {\n            return (settings.token.totalSupply() * settings.proposalThresholdBps) / BPS_PER_100_PERCENT;\n        }\n    }\n\n    /// @notice The current number of votes required to be in favor of a proposal in order to reach quorum\n    function quorum() public view returns (uint256) {\n        unchecked {\n            return (settings.token.totalSupply() * settings.quorumThresholdBps) / BPS_PER_100_PERCENT;\n        }\n    }\n\n    /// @notice The data stored for a given proposal\n    /// @param _proposalId The proposal id\n    function getProposal(bytes32 _proposalId) external view returns (Proposal memory) {\n        return proposals[_proposalId];\n    }\n\n    /// @notice The timestamp when voting starts for a proposal\n    /// @param _proposalId The proposal id\n    function proposalSnapshot(bytes32 _proposalId) external view returns (uint256) {\n        return proposals[_proposalId].voteStart;\n    }\n\n    /// @notice The timestamp when voting ends for a proposal\n    /// @param _proposalId The proposal id\n    function proposalDeadline(bytes32 _proposalId) external view returns (uint256) {\n        return proposals[_proposalId].voteEnd;\n    }\n\n    /// @notice The vote counts for a proposal\n    /// @param _proposalId The proposal id\n    function proposalVotes(bytes32 _proposalId)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        Proposal memory proposal = proposals[_proposalId];\n\n        return (proposal.againstVotes, proposal.forVotes, proposal.abstainVotes);\n    }\n\n    /// @notice The timestamp valid to execute a proposal\n    /// @param _proposalId The proposal id\n    function proposalEta(bytes32 _proposalId) external view returns (uint256) {\n        return settings.treasury.timestamp(_proposalId);\n    }\n\n    ///                                                          ///\n    ///                      GOVERNOR SETTINGS                   ///\n    ///                                                          ///\n\n    /// @notice The basis points of the token supply required to create a proposal\n    function proposalThresholdBps() external view returns (uint256) {\n        return settings.proposalThresholdBps;\n    }\n\n    /// @notice The basis points of the token supply required to reach quorum\n    function quorumThresholdBps() external view returns (uint256) {\n        return settings.quorumThresholdBps;\n    }\n\n    /// @notice The amount of time until voting begins after a proposal is created\n    function votingDelay() external view returns (uint256) {\n        return settings.votingDelay;\n    }\n\n    /// @notice The amount of time to vote on a proposal\n    function votingPeriod() external view returns (uint256) {\n        return settings.votingPeriod;\n    }\n\n    /// @notice The address eligible to veto any proposal (address(0) if burned)\n    function vetoer() external view returns (address) {\n        return settings.vetoer;\n    }\n\n    /// @notice The address of the governance token\n    function token() external view returns (address) {\n        return address(settings.token);\n    }"
    }
  ]
}