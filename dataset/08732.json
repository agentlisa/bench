{
  "Title": "[N-12] Add `namesLength > 0` check in `areOperatorsImported()` method",
  "Content": "\n`areOperatorsImported()` in [OperatorResolver.sol#L32-L49](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/OperatorResolver.sol#L32-L49) returns true when input arrays are empty (ie. `[], []`).\n\n\n```solidity\nfunction areOperatorsImported(bytes32[] calldata names, Operator[] calldata destinations)\n    external\n    view\n    override\n    returns (bool)\n{\n    uint256 namesLength = names.length;\n    require(namesLength == destinations.length, \"OR: INPUTS_LENGTH_MUST_MATCH\");\n    for (uint256 i = 0; i < namesLength; i++) {\n        if (\n            operators[names[i]].implementation != destinations[i].implementation ||\n            operators[names[i]].selector != destinations[i].selector\n        ) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n### Recommendation\n\n`require(namesLength > 0 \"empty names/destinations\");`\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-06-nested",
  "Code": [
    {
      "filename": "contracts/OperatorResolver.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"./interfaces/IOperatorResolver.sol\";\nimport \"./abstracts/MixinOperatorResolver.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title Operator Resolver implementation\n/// @notice Resolve the operators address\ncontract OperatorResolver is IOperatorResolver, Ownable {\n    /// @dev Operators map of the name and address\n    mapping(bytes32 => Operator) public operators;\n\n    /// @inheritdoc IOperatorResolver\n    function getOperator(bytes32 name) external view override returns (Operator memory) {\n        return operators[name];\n    }\n\n    /// @inheritdoc IOperatorResolver\n    function requireAndGetOperator(bytes32 name, string calldata reason)\n        external\n        view\n        override\n        returns (Operator memory)\n    {\n        Operator memory _foundOperator = operators[name];\n        require(_foundOperator.implementation != address(0), reason);\n        return _foundOperator;\n    }\n\n    /// @inheritdoc IOperatorResolver\n    function areOperatorsImported(bytes32[] calldata names, Operator[] calldata destinations)\n        external\n        view\n        override\n        returns (bool)\n    {\n        uint256 namesLength = names.length;\n        require(namesLength == destinations.length, \"OR: INPUTS_LENGTH_MUST_MATCH\");\n        for (uint256 i = 0; i < namesLength; i++) {\n            if (\n                operators[names[i]].implementation != destinations[i].implementation ||\n                operators[names[i]].selector != destinations[i].selector\n            ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @inheritdoc IOperatorResolver\n    function importOperators(\n        bytes32[] calldata names,\n        Operator[] calldata operatorsToImport,\n        MixinOperatorResolver[] calldata destinations\n    ) external override onlyOwner {\n        require(names.length == operatorsToImport.length, \"OR: INPUTS_LENGTH_MUST_MATCH\");\n        bytes32 name;\n        Operator calldata destination;\n        for (uint256 i = 0; i < names.length; i++) {\n            name = names[i];\n            destination = operatorsToImport[i];\n            operators[name] = destination;\n            emit OperatorImported(name, destination);\n        }\n\n        // rebuild caches atomically\n        // see. https://github.com/code-423n4/2021-11-nested-findings/issues/217\n        rebuildCaches(destinations);\n    }\n\n    /// @notice rebuild the caches of mixin smart contracts\n    /// @param destinations The list of mixinOperatorResolver to rebuild\n    function rebuildCaches(MixinOperatorResolver[] calldata destinations) public onlyOwner {\n        for (uint256 i = 0; i < destinations.length; i++) {\n            destinations[i].rebuildCache();\n        }\n    }\n}"
    }
  ]
}