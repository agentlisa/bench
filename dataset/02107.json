{
  "Title": "M-22: PnL is incorrectly counted as collateral when determining whether to close positions automatically",
  "Content": "# Issue M-22: PnL is incorrectly counted as collateral when determining whether to close positions automatically \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/154 \n\n## Found by \nIllIllI\n\n## Summary\n\nGMX uses `MIN_COLLATERAL_USD` to ensure that there is always enough collateral remaining in a position, so that if there are sudden large gaps in prices, there is enough collateral to cover potential losses.\n\n\n## Vulnerability Detail\n\nWhen a position is reduced, the estimate of remaining collateral includes the total P&L as part of the collateral. If a position has a lot of profit, a nefarious owner of the position can reduce the collateral to one wei of the collateral token, and let the position run.\n\n\n## Impact\n\nIf there is a sudden gap down in price, as is common with crypto Bart price chart formations, the user only loses one wei, but the pool incurs losses because there is no collateral to cover price decreases. Once one wei is left in the position, there is no mechanism for a keeper to reduce the position's leverage, so the only chance thereafter to close the position is when it needs to be liquidated.\n\n\n## Code Snippet\n\nPnL is counted as collateral:\n```solidity\n// File: gmx-synthetics/contracts/position/PositionUtils.sol : PositionUtils.willPositionCollateralBeSufficient()   #1\n\n420            int256 remainingCollateralUsd = values.positionCollateralAmount.toInt256() * collateralTokenPrice.min.toInt256();\n421    \n422 @>         remainingCollateralUsd += values.positionPnlUsd;\n423    \n424            if (values.realizedPnlUsd < 0) {\n425                remainingCollateralUsd = remainingCollateralUsd + values.realizedPnlUsd;\n426            }\n427    \n428            if (remainingCollateralUsd < 0) {\n429                return (false, remainingCollateralUsd);\n430            }\n431    \n432:           int256 minCollateralUsdForLeverage = Precision.applyFactor(values.positionSizeInUsd, minCollateralFactor).toInt256();\n```\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/position/PositionUtils.sol#L412-L432\n\nThe position is only closed if that total is below the [minimum collateral](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/position/DecreasePositionUtils.sol#L142-L145) dollar amount.\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nDo not count PnL as part of the collateral, for the purposes of determining the minimum position collateral amount. The combined value may still be useful as a separate check.\n\n\n\n\n## Discussion\n\n**xvi10**\n\nPnL is counted as collateral to allow position increases / decreases if the pnl is sufficient to cover pending fees, the risk of the position having insufficient pnl to cover fees in case of a large change in price is similar to the risk of a position having insufficient collateral to cover fees \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/position/PositionUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"../utils/Precision.sol\";\n\nimport \"./Position.sol\";\n\nimport \"../data/DataStore.sol\";\nimport \"../data/Keys.sol\";\n\nimport \"../pricing/PositionPricingUtils.sol\";\nimport \"../order/BaseOrderUtils.sol\";\nimport \"../referral/ReferralEventUtils.sol\";\n\n// @title PositionUtils\n// @dev Library for position functions\nlibrary PositionUtils {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using Price for Price.Props;\n    using Position for Position.Props;\n    using Order for Order.Props;\n\n    // @dev UpdatePositionParams struct used in increasePosition to avoid\n    // stack too deep errors\n    //\n    // @param market the values of the trading market\n    // @param order the decrease position order\n    // @param position the order's position\n    // @param positionKey the key of the order's position\n    // @param collateral the collateralToken of the position\n    // @param collateralDeltaAmount the amount of collateralToken deposited\n    struct UpdatePositionParams {\n        BaseOrderUtils.ExecuteOrderParamsContracts contracts;\n        Market.Props market;\n        Order.Props order;\n        bytes32 orderKey;\n        Position.Props position;\n        bytes32 positionKey;\n    }\n\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param oracle Oracle\n    // @param referralStorage IReferralStorage\n    struct UpdatePositionParamsContracts {\n        DataStore dataStore;\n        EventEmitter eventEmitter;\n        Oracle oracle;\n        SwapHandler swapHandler;\n        IReferralStorage referralStorage;\n    }\n\n    struct WillPositionCollateralBeSufficientValues {\n        uint256 positionSizeInUsd;\n        uint256 positionCollateralAmount;\n        int256 positionPnlUsd;\n        int256 realizedPnlUsd;\n        int256 openInterestDelta;\n    }\n\n    struct DecreasePositionCollateralValuesOutput {\n        address outputToken;\n        uint256 outputAmount;\n        address secondaryOutputToken;\n        uint256 secondaryOutputAmount;\n    }\n\n    // @dev ProcessCollateralValues struct used to contain the values in processCollateral\n    // @param executionPrice the order execution price\n    // @param remainingCollateralAmount the remaining collateral amount of the position\n    // @param outputAmount the output amount\n    // @param positionPnlUsd the pnl of the position in USD\n    // @param pnlAmountForPool the pnl for the pool in token amount\n    // @param pnlAmountForUser the pnl for the user in token amount\n    // @param sizeDeltaInTokens the change in position size in tokens\n    // @param priceImpactAmount the price impact in tokens\n    struct DecreasePositionCollateralValues {\n        address pnlTokenForPool;\n        uint256 executionPrice;\n        int256 remainingCollateralAmount;\n        int256 positionPnlUsd;\n        int256 pnlAmountForPool;\n        uint256 pnlAmountForUser;\n        uint256 sizeDeltaInTokens;\n        int256 priceImpactAmount;\n        uint256 priceImpactDiffUsd;\n        uint256 priceImpactDiffAmount;\n        DecreasePositionCollateralValuesOutput output;\n    }\n\n    // @dev DecreasePositionCache struct used in decreasePosition to\n    // avoid stack too deep errors\n    // @param prices the prices of the tokens in the market\n    // @param pnlToken the token that the pnl for the user is in, for long positions\n    // this is the market.longToken, for short positions this is the market.shortToken\n    // @param pnlTokenPrice the price of the pnlToken\n    // @param initialCollateralAmount the initial collateral amount\n    // @param nextPositionSizeInUsd the new position size in USD\n    // @param nextPositionBorrowingFactor the new position borrowing factor\n    struct DecreasePositionCache {\n        MarketUtils.MarketPrices prices;\n        int256 estimatedPositionPnlUsd;\n        int256 estimatedRealizedPnlUsd;\n        int256 estimatedRemainingPnlUsd;\n        address pnlToken;\n        Price.Props pnlTokenPrice;\n        uint256 initialCollateralAmount;\n        uint256 nextPositionSizeInUsd;\n        uint256 nextPositionBorrowingFactor;\n    }\n\n\n    struct GetPositionPnlUsdCache {\n        int256 positionValue;\n        int256 totalPositionPnl;\n        address pnlToken;\n        uint256 poolTokenAmount;\n        uint256 poolTokenPrice;\n        uint256 poolTokenUsd;\n        int256 poolPnl;\n        int256 cappedPoolPnl;\n        uint256 sizeDeltaInTokens;\n        int256 positionPnlUsd;\n    }\n\n    // @dev IsPositionLiquidatableCache struct used in isPositionLiquidatable\n    // to avoid stack too deep errors\n    // @param positionPnlUsd the position's pnl in USD\n    // @param minCollateralFactor the min collateral factor\n    // @param collateralUsd the position's collateral in USD\n    // @param priceImpactUsd the price impact of closing the position in USD\n    // @param minCollateralUsd the minimum allowed collateral in USD\n    // @param remainingCollateralUsd the remaining position collateral in USD\n    struct IsPositionLiquidatableCache {\n        int256 positionPnlUsd;\n        uint256 minCollateralFactor;\n        uint256 collateralUsd;\n        int256 priceImpactUsd;\n        int256 minCollateralUsd;\n        int256 minCollateralUsdForLeverage;\n        int256 remainingCollateralUsd;\n    }\n\n    error LiquidatablePosition();\n    error EmptyPosition(uint256 sizeInUsd, uint256 sizeInTokens, uint256 collateralAmount);\n\n    // @dev get the position pnl in USD\n    //\n    // for long positions, pnl is calculated as:\n    // (position.sizeInTokens * indexTokenPrice) - position.sizeInUsd\n    // if position.sizeInTokens is larger for long positions, the position will have\n    // larger profits and smaller losses for the same changes in token price\n    //\n    // for short positions, pnl is calculated as:\n    // position.sizeInUsd -  (position.sizeInTokens * indexTokenPrice)\n    // if position.sizeInTokens is smaller for long positions, the position will have\n    // larger profits and smaller losses for the same changes in token price\n    //\n    // @param position the position values\n    // @param sizeDeltaUsd the change in position size\n    // @param indexTokenPrice the price of the index token\n    //\n    // @return (positionPnlUsd, sizeDeltaInTokens)\n    function getPositionPnlUsd(\n        DataStore dataStore,\n        Market.Props memory market,\n        MarketUtils.MarketPrices memory prices,\n        Position.Props memory position,\n        uint256 indexTokenPrice,\n        uint256 sizeDeltaUsd\n    ) public view returns (int256, uint256) {\n        GetPositionPnlUsdCache memory cache;\n\n        // position.sizeInUsd is the cost of the tokens, positionValue is the current worth of the tokens\n        cache.positionValue = (position.sizeInTokens() * indexTokenPrice).toInt256();\n        cache.totalPositionPnl = position.isLong() ? cache.positionValue - position.sizeInUsd().toInt256() : position.sizeInUsd().toInt256() - cache.positionValue;\n\n        if (cache.totalPositionPnl > 0) {\n            cache.pnlToken = position.isLong() ? market.longToken : market.shortToken;\n            cache.poolTokenAmount = MarketUtils.getPoolAmount(dataStore, market.marketToken, cache.pnlToken);\n            cache.poolTokenPrice = position.isLong() ? prices.longTokenPrice.min : prices.shortTokenPrice.min;\n            cache.poolTokenUsd = cache.poolTokenAmount * cache.poolTokenPrice;\n            cache.poolPnl = MarketUtils.getPnl(\n                dataStore,\n                market.marketToken,\n                market.longToken,\n                market.shortToken,\n                indexTokenPrice,\n                position.isLong(),\n                true\n            );\n\n            cache.cappedPoolPnl = MarketUtils.getCappedPnl(\n                dataStore,\n                market.marketToken,\n                position.isLong(),\n                cache.poolPnl,\n                cache.poolTokenUsd,\n                Keys.MAX_PNL_FACTOR_FOR_TRADERS\n            );\n\n            if (cache.cappedPoolPnl != cache.poolPnl && cache.cappedPoolPnl > 0 && cache.poolPnl > 0) {\n                // divide by WEI_PRECISION to reduce the risk of overflow\n                cache.totalPositionPnl = cache.totalPositionPnl * (cache.cappedPoolPnl / Precision.WEI_PRECISION.toInt256()) / (cache.poolPnl / Precision.WEI_PRECISION.toInt256());\n            }\n        }\n\n        cache.sizeDeltaInTokens;\n\n        if (position.sizeInUsd() == sizeDeltaUsd) {\n            cache.sizeDeltaInTokens = position.sizeInTokens();\n        } else {\n            if (position.isLong()) {\n                cache.sizeDeltaInTokens = Calc.roundUpDivision(position.sizeInTokens() * sizeDeltaUsd, position.sizeInUsd());\n            } else {\n                cache.sizeDeltaInTokens = position.sizeInTokens() * sizeDeltaUsd / position.sizeInUsd();\n            }\n        }\n\n        cache.positionPnlUsd = cache.totalPositionPnl * cache.sizeDeltaInTokens.toInt256() / position.sizeInTokens().toInt256();\n\n        return (cache.positionPnlUsd, cache.sizeDeltaInTokens);\n    }\n\n    // @dev convert sizeDeltaUsd to sizeDeltaInTokens\n    // @param sizeInUsd the position size in USD\n    // @param sizeInTokens the position size in tokens\n    // @param sizeDeltaUsd the position size change in USD\n    // @return the size delta in tokens\n    function getSizeDeltaInTokens(uint256 sizeInUsd, uint256 sizeInTokens, uint256 sizeDeltaUsd) internal pure returns (uint256) {\n        return sizeInTokens * sizeDeltaUsd / sizeInUsd;\n    }\n\n    // @dev get the key for a position\n    // @param account the position's account\n    // @param market the position's market\n    // @param collateralToken the position's collateralToken\n    // @param isLong whether the position is long or short\n    // @return the position key\n    function getPositionKey(address account, address market, address collateralToken, bool isLong) internal pure returns (bytes32) {\n        bytes32 key = keccak256(abi.encode(account, market, collateralToken, isLong));\n        return key;\n    }\n\n    // @dev validate that a position is not empty\n    // @param position the position values\n    function validateNonEmptyPosition(Position.Props memory position) internal pure {\n        if (position.sizeInUsd() == 0 || position.sizeInTokens() == 0 || position.collateralAmount() == 0) {\n            revert EmptyPosition(position.sizeInUsd(), position.sizeInTokens(), position.collateralAmount());\n        }\n    }\n\n    // @dev check if a position is valid\n    // @param dataStore DataStore\n    // @param referralStorage IReferralStorage\n    // @param position the position values\n    // @param market the market values\n    // @param prices the prices of the tokens in the market\n    // @param shouldValidateMinCollateralUsd whether min collateral usd needs to be validated\n    // validation is skipped for decrease position to prevent reverts in case the order size\n    // is just slightly smaller than the position size\n    // in decrease position, the remaining collateral is estimated at the start, and the order\n    // size is updated to match the position size if the remaining collateral will be less than\n    // the min collateral usd\n    // since this is an estimate, there may be edge cases where there is a small remaining position size\n    // and small amount of collateral remaining\n    // validation is skipped for this case as it is preferred for the order to be executed\n    // since the small amount of collateral remaining only impacts the potential payment of liquidation\n    // keepers\n    function validatePosition(\n        DataStore dataStore,\n        IReferralStorage referralStorage,\n        Position.Props memory position,\n        Market.Props memory market,\n        MarketUtils.MarketPrices memory prices,\n        bool shouldValidateMinCollateralUsd\n    ) public view {\n        validateNonEmptyPosition(position);\n\n        if (isPositionLiquidatable(\n            dataStore,\n            referralStorage,\n            position,\n            market,\n            prices,\n            shouldValidateMinCollateralUsd\n        )) {\n            revert LiquidatablePosition();\n        }\n    }\n\n    // @dev check if a position is liquidatable\n    // @param dataStore DataStore\n    // @param referralStorage IReferralStorage\n    // @param position the position values\n    // @param market the market values\n    // @param prices the prices of the tokens in the market\n    function isPositionLiquidatable(\n        DataStore dataStore,\n        IReferralStorage referralStorage,\n        Position.Props memory position,\n        Market.Props memory market,\n        MarketUtils.MarketPrices memory prices,\n        bool shouldValidateMinCollateralUsd\n    ) public view returns (bool) {\n        IsPositionLiquidatableCache memory cache;\n\n        (cache.positionPnlUsd, ) = getPositionPnlUsd(\n            dataStore,\n            market,\n            prices,\n            position,\n            prices.indexTokenPrice.pickPriceForPnl(position.isLong(), false),\n            position.sizeInUsd()\n        );\n\n        cache.minCollateralFactor = MarketUtils.getMinCollateralFactor(dataStore, market.marketToken);\n\n        Price.Props memory collateralTokenPrice = MarketUtils.getCachedTokenPrice(\n            position.collateralToken(),\n            market,\n            prices\n        );\n\n        cache.collateralUsd = position.collateralAmount() * collateralTokenPrice.min;\n\n        cache.priceImpactUsd = PositionPricingUtils.getPriceImpactUsd(\n            PositionPricingUtils.GetPriceImpactUsdParams(\n                dataStore,\n                market.marketToken,\n                market.indexToken,\n                market.longToken,\n                market.shortToken,\n                -position.sizeInUsd().toInt256(),\n                position.isLong()\n            )\n        );\n\n        // even if there is a large positive price impact, positions that would be liquidated\n        // if the positive price impact is reduced should not be allowed to be created\n        // as they would be easily liquidated if the price impact changes\n        // cap the priceImpactUsd to zero to prevent these positions from being created\n        if (cache.priceImpactUsd > 0) {\n            cache.priceImpactUsd = 0;\n        } else {\n            uint256 maxPriceImpactFactor = MarketUtils.getMaxPositionImpactFactorForLiquidations(\n                dataStore,\n                market.marketToken\n            );\n\n            // if there is a large build up of open interest and a sudden large price movement\n            // it may result in a large imbalance between longs and shorts\n            // this could result in very large price impact temporarily\n            // cap the max negative price impact to prevent cascading liquidations\n            int256 maxNegativePriceImpactUsd = -Precision.applyFactor(position.sizeInUsd(), maxPriceImpactFactor).toInt256();\n            if (cache.priceImpactUsd < maxNegativePriceImpactUsd) {\n                cache.priceImpactUsd = maxNegativePriceImpactUsd;\n            }\n        }\n\n        PositionPricingUtils.PositionFees memory fees = PositionPricingUtils.getPositionFees(\n            dataStore,\n            referralStorage,\n            position,\n            collateralTokenPrice,\n            market.longToken,\n            market.shortToken,\n            position.sizeInUsd()\n        );\n\n        cache.remainingCollateralUsd = cache.collateralUsd.toInt256() + cache.positionPnlUsd + cache.priceImpactUsd - fees.totalNetCostUsd.toInt256();\n\n        if (shouldValidateMinCollateralUsd) {\n            cache.minCollateralUsd = dataStore.getUint(Keys.MIN_COLLATERAL_USD).toInt256();\n            if (cache.remainingCollateralUsd < cache.minCollateralUsd) {\n                return true;\n            }\n        }\n\n        if (cache.remainingCollateralUsd <= 0) {\n            return true;\n        }\n\n        // validate if (remaining collateral) / position.size is less than the min collateral factor (max leverage exceeded)\n        cache.minCollateralUsdForLeverage = Precision.applyFactor(position.sizeInUsd(), cache.minCollateralFactor).toInt256();\n        if (cache.remainingCollateralUsd < cache.minCollateralUsdForLeverage) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function willPositionCollateralBeSufficient(\n        DataStore dataStore,\n        Market.Props memory market,\n        MarketUtils.MarketPrices memory prices,\n        address collateralToken,\n        bool isLong,\n        WillPositionCollateralBeSufficientValues memory values\n    ) public view returns (bool, int256) {\n        Price.Props memory collateralTokenPrice = MarketUtils.getCachedTokenPrice(\n            collateralToken,\n            market,\n            prices\n        );\n\n        uint256 minCollateralFactor = MarketUtils.getMinCollateralFactorForOpenInterest(\n            dataStore,\n            market.marketToken,\n            market.longToken,\n            market.shortToken,\n            values.openInterestDelta,\n            isLong\n        );\n\n        int256 remainingCollateralUsd = values.positionCollateralAmount.toInt256() * collateralTokenPrice.min.toInt256();\n\n        remainingCollateralUsd += values.positionPnlUsd;\n\n        if (values.realizedPnlUsd < 0) {\n            remainingCollateralUsd = remainingCollateralUsd + values.realizedPnlUsd;\n        }\n\n        if (remainingCollateralUsd < 0) {\n            return (false, remainingCollateralUsd);\n        }\n\n        int256 minCollateralUsdForLeverage = Precision.applyFactor(values.positionSizeInUsd, minCollateralFactor).toInt256();\n        bool willBeSufficient = remainingCollateralUsd >= minCollateralUsdForLeverage;\n\n        return (willBeSufficient, remainingCollateralUsd);\n    }\n\n    function updateFundingAndBorrowingState(\n        PositionUtils.UpdatePositionParams memory params,\n        MarketUtils.MarketPrices memory prices\n    ) internal {\n        // update the funding amount per size for the market\n        MarketUtils.updateFundingAmountPerSize(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.market,\n            prices\n        );\n\n        // update the cumulative borrowing factor for the market\n        MarketUtils.updateCumulativeBorrowingFactor(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.market,\n            prices,\n            params.order.isLong()\n        );\n    }\n\n    function updateTotalBorrowing(\n        PositionUtils.UpdatePositionParams memory params,\n        uint256 nextPositionSizeInUsd,\n        uint256 nextPositionBorrowingFactor\n    ) internal {\n        MarketUtils.updateTotalBorrowing(\n            params.contracts.dataStore,\n            params.market.marketToken,\n            params.position.isLong(),\n            params.position.borrowingFactor(),\n            params.position.sizeInUsd(),\n            nextPositionSizeInUsd,\n            nextPositionBorrowingFactor\n        );\n    }\n\n    function incrementClaimableFundingAmount(\n        PositionUtils.UpdatePositionParams memory params,\n        PositionPricingUtils.PositionFees memory fees\n    ) internal {\n        // if the position has negative funding fees, distribute it to allow it to be claimable\n        if (fees.funding.claimableLongTokenAmount > 0) {\n            MarketUtils.incrementClaimableFundingAmount(\n                params.contracts.dataStore,\n                params.contracts.eventEmitter,\n                params.market.marketToken,\n                params.market.longToken,\n                params.order.receiver(),\n                fees.funding.claimableLongTokenAmount\n            );\n        }\n\n        if (fees.funding.claimableShortTokenAmount > 0) {\n            MarketUtils.incrementClaimableFundingAmount(\n                params.contracts.dataStore,\n                params.contracts.eventEmitter,\n                params.market.marketToken,\n                params.market.shortToken,\n                params.order.receiver(),\n                fees.funding.claimableShortTokenAmount\n            );\n        }\n    }\n\n    function updateOpenInterest(\n        PositionUtils.UpdatePositionParams memory params,\n        int256 sizeDeltaUsd,\n        int256 sizeDeltaInTokens\n    ) internal {\n        if (sizeDeltaUsd != 0) {\n            MarketUtils.applyDeltaToOpenInterest(\n                params.contracts.dataStore,\n                params.contracts.eventEmitter,\n                params.market.marketToken,\n                params.market.indexToken,\n                params.position.collateralToken(),\n                params.position.isLong(),\n                sizeDeltaUsd\n            );\n\n            MarketUtils.applyDeltaToOpenInterestInTokens(\n                params.contracts.dataStore,\n                params.contracts.eventEmitter,\n                params.position.market(),\n                params.position.collateralToken(),\n                params.position.isLong(),\n                sizeDeltaInTokens\n            );\n        }\n    }\n\n    function handleReferral(\n        PositionUtils.UpdatePositionParams memory params,\n        PositionPricingUtils.PositionFees memory fees\n    ) internal {\n        ReferralUtils.incrementAffiliateReward(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.position.market(),\n            params.position.collateralToken(),\n            fees.referral.affiliate,\n            params.position.account(),\n            fees.referral.affiliateRewardAmount\n        );\n\n        if (fees.referral.traderDiscountAmount > 0) {\n            ReferralEventUtils.emitTraderReferralDiscountApplied(\n                params.contracts.eventEmitter,\n                params.position.market(),\n                params.position.collateralToken(),\n                params.position.account(),\n                fees.referral.traderDiscountAmount\n            );\n        }\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/position/DecreasePositionUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Precision.sol\";\n\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\n\nimport \"../oracle/Oracle.sol\";\nimport \"../pricing/PositionPricingUtils.sol\";\n\nimport \"./Position.sol\";\nimport \"./PositionStoreUtils.sol\";\nimport \"./PositionUtils.sol\";\nimport \"./PositionEventUtils.sol\";\nimport \"../order/BaseOrderUtils.sol\";\nimport \"../order/OrderEventUtils.sol\";\n\nimport \"./DecreasePositionCollateralUtils.sol\";\n\n// @title DecreasePositionUtils\n// @dev Library for functions to help with decreasing a position\nlibrary DecreasePositionUtils {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    using Position for Position.Props;\n    using Order for Order.Props;\n    using Price for Price.Props;\n\n    // @dev DecreasePositionResult struct for the results of decreasePosition\n    // @param outputToken the output token\n    // @param outputAmount the output amount\n    // @param secondaryOutputToken the secondary output token\n    // @param secondaryOutputAmount the secondary output amount\n    struct DecreasePositionResult {\n        address outputToken;\n        uint256 outputAmount;\n        address secondaryOutputToken;\n        uint256 secondaryOutputAmount;\n    }\n\n    error InvalidDecreaseOrderSize(uint256 sizeDeltaUsd, uint256 positionSizeInUsd);\n    error UnableToWithdrawCollateralDueToLeverage(int256 estimatedRemainingCollateralUsd);\n    error InvalidDecreasePositionSwapType(Order.DecreasePositionSwapType decreasePositionSwapType);\n    error PositionShouldNotBeLiquidated();\n\n    // @dev decreases a position\n    // The decreasePosition function decreases the size of an existing position\n    // in a market. It takes a PositionUtils.UpdatePositionParams object as an input, which\n    // includes information about the position to be decreased, the market in\n    // which the position exists, and the order that is being used to decrease the position.\n    //\n    // The function first calculates the prices of the tokens in the market, and then\n    // checks whether the position is liquidatable based on the current market prices.\n    // If the order is a liquidation order and the position is not liquidatable, the function reverts.\n    //\n    // If there is not enough collateral in the position to complete the decrease,\n    // the function reverts. Otherwise, the function updates the position's size and\n    // collateral amount, and increments the claimable funding amount for\n    // the market if necessary.\n    //\n    // Finally, the function returns a DecreasePositionResult object containing\n    // information about the outcome of the decrease operation, including the amount\n    // of collateral removed from the position and any fees that were paid.\n    // @param params PositionUtils.UpdatePositionParams\n    function decreasePosition(\n        PositionUtils.UpdatePositionParams memory params\n    ) external returns (DecreasePositionResult memory) {\n        PositionUtils.DecreasePositionCache memory cache;\n\n        cache.prices = MarketUtils.getMarketPricesForPosition(\n            params.contracts.oracle,\n            params.market\n        );\n\n        // cap the order size to the position size\n        if (params.order.sizeDeltaUsd() > params.position.sizeInUsd()) {\n            if (params.order.orderType() == Order.OrderType.LimitDecrease ||\n                params.order.orderType() == Order.OrderType.StopLossDecrease) {\n\n                OrderEventUtils.emitOrderSizeDeltaAutoUpdated(\n                    params.contracts.eventEmitter,\n                    params.orderKey,\n                    params.order.sizeDeltaUsd(),\n                    params.position.sizeInUsd()\n                );\n\n                params.order.setSizeDeltaUsd(params.position.sizeInUsd());\n            } else {\n                revert InvalidDecreaseOrderSize(params.order.sizeDeltaUsd(), params.position.sizeInUsd());\n            }\n        }\n\n        if (params.order.sizeDeltaUsd() < params.position.sizeInUsd() && params.order.initialCollateralDeltaAmount() > 0) {\n            // estimate pnl based on indexTokenPrice\n            (cache.estimatedPositionPnlUsd, /* uint256 sizeDeltaInTokens */) = PositionUtils.getPositionPnlUsd(\n                params.contracts.dataStore,\n                params.market,\n                cache.prices,\n                params.position,\n                cache.prices.indexTokenPrice.midPrice(),\n                params.position.sizeInUsd()\n            );\n\n            cache.estimatedRealizedPnlUsd = cache.estimatedPositionPnlUsd * params.order.sizeDeltaUsd().toInt256() / params.position.sizeInUsd().toInt256();\n            cache.estimatedRemainingPnlUsd = cache.estimatedPositionPnlUsd - cache.estimatedRealizedPnlUsd;\n\n            PositionUtils.WillPositionCollateralBeSufficientValues memory positionValues = PositionUtils.WillPositionCollateralBeSufficientValues(\n                params.position.sizeInUsd() - params.order.sizeDeltaUsd(), // positionSizeInUsd\n                params.position.collateralAmount() - params.order.initialCollateralDeltaAmount(), // positionCollateralAmount\n                cache.estimatedRemainingPnlUsd, // positionPnlUsd\n                cache.estimatedRealizedPnlUsd,  // realizedPnlUsd\n                -params.order.sizeDeltaUsd().toInt256() // openInterestDelta\n            );\n\n            (bool willBeSufficient, int256 estimatedRemainingCollateralUsd) = PositionUtils.willPositionCollateralBeSufficient(\n                params.contracts.dataStore,\n                params.market,\n                cache.prices,\n                params.position.collateralToken(),\n                params.position.isLong(),\n                positionValues\n            );\n\n            if (!willBeSufficient) {\n                if (params.order.sizeDeltaUsd() == 0) {\n                    revert UnableToWithdrawCollateralDueToLeverage(estimatedRemainingCollateralUsd);\n                }\n\n                OrderEventUtils.emitOrderCollateralDeltaAmountAutoUpdated(\n                    params.contracts.eventEmitter,\n                    params.orderKey,\n                    params.order.initialCollateralDeltaAmount(),\n                    0\n                );\n\n                params.order.setInitialCollateralDeltaAmount(0);\n            }\n\n            // if the remaining collateral will be below the min collateral usd value, then close the position\n            if (estimatedRemainingCollateralUsd < params.contracts.dataStore.getUint(Keys.MIN_COLLATERAL_USD).toInt256()) {\n                params.order.setSizeDeltaUsd(params.position.sizeInUsd());\n            }\n        }\n\n        // if the position will be closed, set the initial collateral delta amount\n        // to zero to help ensure that the order can be executed\n        if (params.order.sizeDeltaUsd() == params.position.sizeInUsd() && params.order.initialCollateralDeltaAmount() > 0) {\n            params.order.setInitialCollateralDeltaAmount(0);\n        }\n\n        cache.pnlToken = params.position.isLong() ? params.market.longToken : params.market.shortToken;\n        cache.pnlTokenPrice = params.position.isLong() ? cache.prices.longTokenPrice : cache.prices.shortTokenPrice;\n\n        if (params.order.decreasePositionSwapType() != Order.DecreasePositionSwapType.NoSwap &&\n            cache.pnlToken == params.position.collateralToken()) {\n            revert InvalidDecreasePositionSwapType(params.order.decreasePositionSwapType());\n        }\n\n        if (BaseOrderUtils.isLiquidationOrder(params.order.orderType()) && !PositionUtils.isPositionLiquidatable(\n            params.contracts.dataStore,\n            params.contracts.referralStorage,\n            params.position,\n            params.market,\n            cache.prices,\n            true\n        )) {\n            revert PositionShouldNotBeLiquidated();\n        }\n\n        PositionUtils.updateFundingAndBorrowingState(params, cache.prices);\n\n        cache.initialCollateralAmount = params.position.collateralAmount();\n        (\n            PositionUtils.DecreasePositionCollateralValues memory values,\n            PositionPricingUtils.PositionFees memory fees\n        ) = DecreasePositionCollateralUtils.processCollateral(\n            params,\n            cache\n        );\n\n        cache.nextPositionSizeInUsd = params.position.sizeInUsd() - params.order.sizeDeltaUsd();\n        cache.nextPositionBorrowingFactor = MarketUtils.getCumulativeBorrowingFactor(params.contracts.dataStore, params.market.marketToken, params.position.isLong());\n\n        PositionUtils.updateTotalBorrowing(\n            params,\n            cache.nextPositionSizeInUsd,\n            cache.nextPositionBorrowingFactor\n        );\n\n        params.position.setSizeInUsd(cache.nextPositionSizeInUsd);\n        params.position.setSizeInTokens(params.position.sizeInTokens() - values.sizeDeltaInTokens);\n        params.position.setCollateralAmount(values.remainingCollateralAmount.toUint256());\n        params.position.setDecreasedAtBlock(Chain.currentBlockNumber());\n\n        PositionUtils.incrementClaimableFundingAmount(params, fees);\n\n        if (params.position.sizeInUsd() == 0 || params.position.sizeInTokens() == 0) {\n            // withdraw all collateral if the position will be closed\n            values.output.outputAmount += params.position.collateralAmount();\n\n            params.position.setSizeInUsd(0);\n            params.position.setSizeInTokens(0);\n            params.position.setCollateralAmount(0);\n\n            PositionStoreUtils.remove(params.contracts.dataStore, params.positionKey, params.order.account());\n        } else {\n            if (!fees.funding.hasPendingLongTokenFundingFee) {\n                params.position.setLongTokenFundingAmountPerSize(fees.funding.latestLongTokenFundingAmountPerSize);\n            }\n            if (!fees.funding.hasPendingShortTokenFundingFee) {\n                params.position.setShortTokenFundingAmountPerSize(fees.funding.latestShortTokenFundingAmountPerSize);\n            }\n            params.position.setBorrowingFactor(cache.nextPositionBorrowingFactor);\n\n            PositionUtils.validatePosition(\n                params.contracts.dataStore,\n                params.contracts.referralStorage,\n                params.position,\n                params.market,\n                cache.prices,\n                false\n            );\n\n            PositionStoreUtils.set(params.contracts.dataStore, params.positionKey, params.position);\n        }\n\n        MarketUtils.applyDeltaToCollateralSum(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.position.market(),\n            params.position.collateralToken(),\n            params.position.isLong(),\n            -(cache.initialCollateralAmount - params.position.collateralAmount()).toInt"
    }
  ]
}