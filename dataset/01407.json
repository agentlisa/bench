{
  "Title": "H-10: Immediately start getting rewards belonging to others after staking",
  "Content": "# Issue H-10: Immediately start getting rewards belonging to others after staking \n\nSource: https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/603 \n\n## Found by \n0x73696d616f, 0xGoodess, 0xJuda, 0xTheC0der, 0xdeadbeef, 0xvj, Ch\\_301, Kalyan-Singh, MrjoryStewartBaxter, VAD37, berndartmueller, bin2chen, caelumimperium, carrotsmuggler, jecikpo, l3r0ux, lemonmon, pengun, saidam017, talfao, wangxx2026, xiaoming90\n\nMalicious users could abuse the accounting error to immediately start getting rewards belonging to others after staking, leading to a loss of reward tokens.\n\n## Vulnerability Detail\n\n> **Note**\n> This issue affects both LMPVault and DV since they use the same underlying reward contract.\n\nAssume a new user called Bob mints 100 LMPVault or DV shares. The ERC20's `_mint` function will be called, which will first increase Bob's balance at Line 267 and then trigger the `_afterTokenTransfer` hook at Line 271.\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/0457042d93d9dfd760dbaa06a4d2f1216fdbe297/contracts/token/ERC20/ERC20.sol#L259\n\n```solidity\nFile: ERC20.sol\n259:     function _mint(address account, uint256 amount) internal virtual {\n..SNIP..\n262:         _beforeTokenTransfer(address(0), account, amount);\n263: \n264:         _totalSupply += amount;\n265:         unchecked {\n266:             // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n267:             _balances[account] += amount;\n268:         }\n..SNIP..\n271:         _afterTokenTransfer(address(0), account, amount);\n272:     }\n```\n\nThe `_afterTokenTransfer` hook will automatically stake the newly minted shares to the rewarder contracts on behalf of Bob.\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/LMPVault.sol#L854\n\n```solidity\nFile: LMPVault.sol\n854:     function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n..SNIP..\n862:         if (to != address(0)) {\n863:             rewarder.stake(to, amount);\n864:         }\n865:     }\n```\n\nWithin the `MainRewarder.stake` function, it will first call the `_updateReward` function at Line 87 to take a snapshot of accumulated rewards. Since Bob is a new user, his accumulated rewards should be zero. However, this turned out to be false due to the bug described in this report.\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/rewarders/MainRewarder.sol#L86\n\n```solidity\nFile: MainRewarder.sol\n86:     function stake(address account, uint256 amount) public onlyStakeTracker {\n87:         _updateReward(account);\n88:         _stake(account, amount);\n89: \n90:         for (uint256 i = 0; i < extraRewards.length; ++i) {\n91:             IExtraRewarder(extraRewards[i]).stake(account, amount);\n92:         }\n93:     }\n```\n\nWhen the `_updateReward` function is executed, it will compute Bob's earned rewards.  It is important to note that at this point, Bob's balance has already been updated to 100 shares in the `stakeTracker` contract, and `userRewardPerTokenPaid[Bob]` is zero.\n\nBob's earned reward will be as follows, where $r$ is the `rewardPerToken()`:\n\n$$\nearned(Bob) = 100\\ {shares \\times (r - 0)} = 100r\n$$\n\nBob immediately accumulated a reward of $100r$ upon staking into the rewarder contract, which is incorrect. Bob could withdraw $100r$ reward tokens that do not belong to him.\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/rewarders/AbstractRewarder.sol#L128\n\n```solidity\nFile: AbstractRewarder.sol\n128:     function _updateReward(address account) internal {\n129:         uint256 earnedRewards = 0;\n130:         rewardPerTokenStored = rewardPerToken();\n131:         lastUpdateBlock = lastBlockRewardApplicable();\n132: \n133:         if (account != address(0)) {\n134:             earnedRewards = earned(account);\n135:             rewards[account] = earnedRewards;\n136:             userRewardPerTokenPaid[account] = rewardPerTokenStored;\n137:         }\n138: \n139:         emit UserRewardUpdated(account, earnedRewards, rewardPerTokenStored, lastUpdateBlock);\n140:     }\n..SNIP..\n155:     function balanceOf(address account) public view returns (uint256) {\n156:         return stakeTracker.balanceOf(account);\n157:     }\n..SNIP..\n204:     function earned(address account) public view returns (uint256) {\n205:         return (balanceOf(account) * (rewardPerToken() - userRewardPerTokenPaid[account]) / 1e18) + rewards[account];\n206:     }\n```\n\n## Impact\n\nLoss of reward tokens for the vault shareholders.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/LMPVault.sol#L854\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/rewarders/MainRewarder.sol#L86\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/rewarders/AbstractRewarder.sol#L128\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nEnsure that the balance of the users in the rewarder contract is only incremented after the `_updateReward` function is executed.\n\nOne option is to track the balance of the staker and total supply internally within the rewarder contract and avoid reading the states in the `stakeTracker` contract, commonly seen in many reward contracts.\n\n```diff\nFile: AbstractRewarder.sol\nfunction balanceOf(address account) public view returns (uint256) {\n-   return stakeTracker.balanceOf(account);\n+\treturn _balances[account];\n}\n```\n\n```diff\nFile: AbstractRewarder.sol\nfunction _stake(address account, uint256 amount) internal {\n    Errors.verifyNotZero(account, \"account\");\n    Errors.verifyNotZero(amount, \"amount\");\n    \n+    _totalSupply += amount\n+    _balances[account] += amount\n\n    emit Staked(account, amount);\n}\n```\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/101",
  "Code": [
    {
      "filename": "contracts/token/ERC20/ERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/src/vault/LMPVault.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\npragma solidity 0.8.17;\n\n// solhint-disable max-states-count\n\nimport { Roles } from \"src/libs/Roles.sol\";\nimport { Errors } from \"src/utils/Errors.sol\";\nimport { LMPDebt } from \"src/vault/libs/LMPDebt.sol\";\nimport { Pausable } from \"src/security/Pausable.sol\";\nimport { VaultTypes } from \"src/vault/VaultTypes.sol\";\nimport { NonReentrant } from \"src/utils/NonReentrant.sol\";\nimport { SystemComponent } from \"src/SystemComponent.sol\";\nimport { LMPStrategy } from \"src/strategy/LMPStrategy.sol\";\nimport { SecurityBase } from \"src/security/SecurityBase.sol\";\nimport { ILMPVault } from \"src/interfaces/vault/ILMPVault.sol\";\nimport { IStrategy } from \"src/interfaces/strategy/IStrategy.sol\";\nimport { Math } from \"openzeppelin-contracts/utils/math/Math.sol\";\nimport { LMPDestinations } from \"src/vault/libs/LMPDestinations.sol\";\nimport { ERC20 } from \"openzeppelin-contracts/token/ERC20/ERC20.sol\";\nimport { IERC4626 } from \"openzeppelin-contracts/interfaces/IERC4626.sol\";\nimport { IMainRewarder } from \"src/interfaces/rewarders/IMainRewarder.sol\";\nimport { IDestinationVault } from \"src/interfaces/vault/IDestinationVault.sol\";\nimport { SafeERC20 } from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Initializable } from \"openzeppelin-contracts/proxy/utils/Initializable.sol\";\nimport { EnumerableSet } from \"openzeppelin-contracts/utils/structs/EnumerableSet.sol\";\nimport { ISystemRegistry, IDestinationVaultRegistry } from \"src/interfaces/ISystemRegistry.sol\";\nimport { ERC20Permit } from \"openzeppelin-contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport { IERC3156FlashBorrower } from \"openzeppelin-contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport { IERC20Metadata as IERC20 } from \"openzeppelin-contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n// Cross functional reentrancy was identified between updateDebtReporting and the\n// destinationInfo. Have nonReentrant and read-only nonReentrant modifier on them both\n// but slither was still complaining\n//slither-disable-start reentrancy-no-eth,reentrancy-benign\n\ncontract LMPVault is\n    SystemComponent,\n    Initializable,\n    ILMPVault,\n    IStrategy,\n    ERC20Permit,\n    SecurityBase,\n    Pausable,\n    NonReentrant\n{\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Math for uint256;\n    using SafeERC20 for ERC20;\n    using SafeERC20 for IERC20;\n\n    /// @dev In memory struct only for managing vars in _withdraw\n    struct WithdrawInfo {\n        uint256 currentIdle;\n        uint256 assetsFromIdle;\n        uint256 totalAssetsToPull;\n        uint256 totalAssetsPulled;\n        uint256 idleIncrease;\n        uint256 debtDecrease;\n    }\n\n    /// @notice Max fee. 100% == 10000\n    uint256 public constant MAX_FEE_BPS = 10_000;\n\n    uint256 public constant NAV_CHANGE_ROUNDING_BUFFER = 100;\n\n    /// @notice Factory contract that created this vault\n    address public factory;\n\n    /// @notice Overarching baseAsset type\n    bytes32 public immutable vaultType = VaultTypes.LST;\n\n    /// @dev The asset that is deposited into the vault\n    IERC20 internal immutable _baseAsset;\n\n    /// @notice Decimals of the base asset. Used as the decimals for the vault itself\n    uint8 internal immutable _baseAssetDecimals;\n\n    /// @dev Full list of possible destinations that could be deployed to\n    EnumerableSet.AddressSet internal destinations;\n\n    /// @dev Destinations that queued for removal\n    EnumerableSet.AddressSet internal removalQueue;\n\n    /// @dev destinationVaultAddress -> Info .. Debt reporting snapshot info\n    mapping(address => LMPDebt.DestinationInfo) internal destinationInfo;\n\n    /// @dev whether or not the vault has been shutdown\n    bool internal _shutdown;\n\n    /// @notice The amount of baseAsset deposited into the contract pending deployment\n    uint256 public totalIdle = 0;\n\n    /// @notice The current (though cached) value of assets we've deployed\n    uint256 public totalDebt = 0;\n\n    /// @notice The destinations, in order, in which withdrawals will be attempted from\n    IDestinationVault[] public withdrawalQueue;\n\n    /// @notice Main rewarder for this contract\n    IMainRewarder public rewarder;\n\n    /// @notice Current performance fee taken on profit. 100% == 10000\n    uint256 public performanceFeeBps;\n\n    /// @notice Where claimed fees are sent\n    address public feeSink;\n\n    /// @notice The last nav/share height we took fees at\n    uint256 public navPerShareHighMark = MAX_FEE_BPS;\n\n    /// @notice The last timestamp we took fees at\n    uint256 public navPerShareHighMarkTimestamp;\n\n    /// @notice The max total supply of shares we'll allow to be minted\n    uint256 public totalSupplyLimit;\n\n    /// @notice The max shares a single wallet is allowed to hold\n    uint256 public perWalletLimit;\n\n    string private _desc;\n    string private _symbol;\n\n    error TooFewAssets(uint256 requested, uint256 actual);\n    error WithdrawShareCalcInvalid(uint256 currentShares, uint256 cachedShares);\n    error InvalidFee(uint256 newFee);\n    error RewarderAlreadySet();\n    error RebalanceDestinationsMatch(address destinationVault);\n    error InvalidDestination(address destination);\n    error NavChanged(uint256 oldNav, uint256 newNav);\n    error NavOpsInProgress();\n    error OverWalletLimit(address to);\n    error VaultShutdown();\n\n    event PerformanceFeeSet(uint256 newFee);\n    event FeeSinkSet(address newFeeSink);\n    event NewNavHighWatermark(uint256 navPerShare, uint256 timestamp);\n    event TotalSupplyLimitSet(uint256 limit);\n    event PerWalletLimitSet(uint256 limit);\n\n    modifier noNavChange() {\n        (uint256 oldNav, uint256 startingTotalSupply) = _snapStartNav();\n        _;\n        _ensureNoNavChange(oldNav, startingTotalSupply);\n    }\n\n    modifier noNavDecrease() {\n        (uint256 oldNav, uint256 startingTotalSupply) = _snapStartNav();\n        _;\n        _ensureNoNavDecrease(oldNav, startingTotalSupply);\n    }\n\n    modifier ensureNoNavOps() {\n        if (systemRegistry.systemSecurity().navOpsInProgress() > 0) {\n            revert NavOpsInProgress();\n        }\n        _;\n    }\n\n    modifier trackNavOps() {\n        systemRegistry.systemSecurity().enterNavOperation();\n        _;\n        systemRegistry.systemSecurity().exitNavOperation();\n    }\n\n    constructor(\n        ISystemRegistry _systemRegistry,\n        address _vaultAsset\n    )\n        SystemComponent(_systemRegistry)\n        ERC20(\n            string(abi.encodePacked(ERC20(_vaultAsset).name(), \" Pool Token\")),\n            string(abi.encodePacked(\"lmp\", ERC20(_vaultAsset).symbol()))\n        )\n        ERC20Permit(string(abi.encodePacked(\"lmp\", ERC20(_vaultAsset).symbol())))\n        SecurityBase(address(_systemRegistry.accessController()))\n        Pausable(_systemRegistry)\n    {\n        _baseAsset = IERC20(_vaultAsset);\n        _baseAssetDecimals = IERC20(_vaultAsset).decimals();\n\n        _symbol = ERC20(_vaultAsset).symbol();\n        _desc = ERC20(_vaultAsset).name();\n\n        _disableInitializers();\n    }\n\n    function initialize(\n        uint256 supplyLimit,\n        uint256 walletLimit,\n        string memory symbolSuffix,\n        string memory descPrefix,\n        bytes memory\n    ) public virtual initializer {\n        Errors.verifyNotEmpty(symbolSuffix, \"symbolSuffix\");\n        Errors.verifyNotEmpty(descPrefix, \"descPrefix\");\n\n        // init withdrawal queue to empty (slither issue)\n        withdrawalQueue = new IDestinationVault[](0);\n\n        navPerShareHighMarkTimestamp = block.timestamp;\n\n        _setTotalSupplyLimit(supplyLimit);\n        _setPerWalletLimit(walletLimit);\n\n        factory = msg.sender;\n\n        _symbol = symbolSuffix;\n        _desc = descPrefix;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override(ERC20, IERC20) returns (string memory) {\n        return string(abi.encodePacked(_desc, \" Pool Token\"));\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override(ERC20, IERC20) returns (string memory) {\n        return string(abi.encodePacked(\"lmp\", _symbol));\n    }\n\n    /// @inheritdoc IERC20\n    function decimals() public view virtual override(ERC20, IERC20) returns (uint8) {\n        return _baseAssetDecimals;\n    }\n\n    /// @notice Set the global share limit\n    /// @dev Zero is allowed here and used as a way to stop deposits but allow withdrawals\n    /// @param newSupplyLimit new total amount of shares allowed to be minted\n    function setTotalSupplyLimit(uint256 newSupplyLimit) external onlyOwner {\n        _setTotalSupplyLimit(newSupplyLimit);\n    }\n\n    /// @notice Set the per-wallet share limit\n    /// @param newWalletLimit new total shares a wallet is allowed to hold\n    function setPerWalletLimit(uint256 newWalletLimit) external onlyOwner {\n        _setPerWalletLimit(newWalletLimit);\n    }\n\n    /// @notice Set the fee that will be taken when profit is realized\n    /// @dev Resets the high water to current value\n    /// @param fee Percent. 100% == 10000\n    function setPerformanceFeeBps(uint256 fee) external nonReentrant hasRole(Roles.LMP_FEE_SETTER_ROLE) {\n        if (fee >= MAX_FEE_BPS) {\n            revert InvalidFee(fee);\n        }\n\n        performanceFeeBps = fee;\n\n        // Set the high mark when we change the fee so we aren't able to go farther back in\n        // time than one debt reporting and claim fee's against past profits\n        uint256 supply = totalSupply();\n        if (supply > 0) {\n            navPerShareHighMark = (totalAssets() * MAX_FEE_BPS) / supply;\n        } else {\n            // The default high mark is 1:1. We don't want to be able to take\n            // fee's before the first debt reporting\n            // Before a rebalance, everything will be in idle and we don't want to take\n            // fee's on pure idle\n            navPerShareHighMark = MAX_FEE_BPS;\n        }\n\n        emit PerformanceFeeSet(fee);\n    }\n\n    /// @notice Set the address that will receive fees\n    /// @param newFeeSink Address that will receive fees\n    function setFeeSink(address newFeeSink) external onlyOwner {\n        emit FeeSinkSet(newFeeSink);\n\n        // Zero is valid. One way to disable taking fees\n        // slither-disable-next-line missing-zero-check\n        feeSink = newFeeSink;\n    }\n\n    /// @notice Set the rewarder contract used by the vault\n    /// @dev Must be set immediately on initialization/creation and only once\n    function setRewarder(address _rewarder) external {\n        if (msg.sender != factory) {\n            revert Errors.AccessDenied();\n        }\n\n        Errors.verifyNotZero(_rewarder, \"rewarder\");\n\n        if (address(rewarder) != address(0)) {\n            revert RewarderAlreadySet();\n        }\n\n        rewarder = IMainRewarder(_rewarder);\n\n        emit RewarderSet(_rewarder);\n    }\n\n    /// @dev See {IERC4626-asset}.\n    function asset() public view virtual override returns (address) {\n        return address(_baseAsset);\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        return totalIdle + totalDebt;\n    }\n\n    /// @dev See {IERC4626-convertToShares}.\n    function convertToShares(uint256 assets) public view virtual returns (uint256 shares) {\n        shares = _convertToShares(assets, Math.Rounding.Down);\n    }\n\n    /// @dev See {IERC4626-convertToAssets}.\n    function convertToAssets(uint256 shares) public view virtual returns (uint256 assets) {\n        assets = _convertToAssets(shares, Math.Rounding.Down);\n    }\n\n    //////////////////////////////////////////////////////////////////////\n    //\t\t\t\t\t\t\t\tDeposit\t\t\t\t\t\t\t\t//\n    //////////////////////////////////////////////////////////////////////\n\n    /// @dev See {IERC4626-maxDeposit}.\n    function maxDeposit(address wallet) public view virtual override returns (uint256 maxAssets) {\n        maxAssets = convertToAssets(_maxMint(wallet));\n    }\n\n    /// @dev See {IERC4626-previewDeposit}.\n    function previewDeposit(uint256 assets) public view virtual returns (uint256 shares) {\n        shares = _convertToShares(assets, Math.Rounding.Down);\n    }\n\n    function deposit(\n        uint256 assets,\n        address receiver\n    ) public virtual override nonReentrant noNavChange ensureNoNavOps returns (uint256 shares) {\n        Errors.verifyNotZero(assets, \"assets\");\n        if (assets > maxDeposit(receiver)) {\n            revert ERC4626DepositExceedsMax(assets, maxDeposit(receiver));\n        }\n\n        shares = previewDeposit(assets);\n\n        _transferAndMint(assets, shares, receiver);\n    }\n\n    /// @dev See {IERC4626-maxMint}.\n    function maxMint(address wallet) public view virtual override returns (uint256 maxShares) {\n        maxShares = _maxMint(wallet);\n    }\n\n    /// @dev See {IERC4626-maxWithdraw}.\n    function maxWithdraw(address owner) public view virtual returns (uint256 maxAssets) {\n        maxAssets = paused() ? 0 : previewRedeem(balanceOf(owner));\n    }\n\n    /// @dev See {IERC4626-maxRedeem}.\n    function maxRedeem(address owner) public view virtual returns (uint256 maxShares) {\n        maxShares = _maxRedeem(owner);\n    }\n\n    /// @dev See {IERC4626-previewMint}.\n    function previewMint(uint256 shares) public view virtual returns (uint256 assets) {\n        assets = _convertToAssets(shares, Math.Rounding.Up);\n    }\n\n    /// @dev See {IERC4626-previewWithdraw}.\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256 shares) {\n        shares = _convertToShares(assets, Math.Rounding.Up);\n    }\n\n    /// @dev See {IERC4626-previewRedeem}.\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Down);\n    }\n\n    /**\n     * @dev See {IERC4626-mint}.\n     *\n     * As opposed to {deposit}, minting is allowed even if the vault is in a state where the price of a share is zero.\n     * In this case, the shares will be minted without requiring any assets to be deposited.\n     */\n    function mint(\n        uint256 shares,\n        address receiver\n    ) public virtual override nonReentrant noNavChange ensureNoNavOps returns (uint256 assets) {\n        if (shares > maxMint(receiver)) {\n            revert ERC4626MintExceedsMax(shares, maxMint(receiver));\n        }\n\n        assets = previewMint(shares);\n\n        _transferAndMint(assets, shares, receiver);\n    }\n\n    //////////////////////////////////////////////////////////////////////\n    //\t\t\t\t\t\t\t\tWithdraw\t\t\t\t\t\t\t//\n    //////////////////////////////////////////////////////////////////////\n\n    /// @dev See {IERC4626-withdraw}.\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual override nonReentrant noNavDecrease ensureNoNavOps returns (uint256 shares) {\n        Errors.verifyNotZero(assets, \"assets\");\n        uint256 maxAssets = maxWithdraw(owner);\n        if (assets > maxAssets) {\n            revert ERC4626ExceededMaxWithdraw(owner, assets, maxAssets);\n        }\n\n        // query number of shares these assets match\n        shares = previewWithdraw(assets);\n\n        uint256 actualAssets = _withdraw(assets, shares, receiver, owner);\n\n        if (actualAssets < assets) {\n            revert TooFewAssets(assets, actualAssets);\n        }\n    }\n\n    /// @dev See {IERC4626-redeem}.\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual override nonReentrant noNavDecrease ensureNoNavOps returns (uint256 assets) {\n        uint256 maxShares = maxRedeem(owner);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxRedeem(owner, shares, maxShares);\n        }\n        uint256 possibleAssets = previewRedeem(shares);\n\n        assets = _withdraw(possibleAssets, shares, receiver, owner);\n    }\n\n    function _calcUserWithdrawSharesToBurn(\n        IDestinationVault destVault,\n        uint256 userShares,\n        uint256 maxAssetsToPull,\n        uint256 totalVaultShares\n    ) internal returns (uint256 sharesToBurn, uint256 totalDebtBurn) {\n        (sharesToBurn, totalDebtBurn) = LMPDebt._calcUserWithdrawSharesToBurn(\n            destinationInfo[address(destVault)], destVault, userShares, maxAssetsToPull, totalVaultShares\n        );\n    }\n\n    // slither-disable-next-line cyclomatic-complexity\n    function _withdraw(\n        uint256 assets,\n        uint256 shares,\n        address receiver,\n        address owner\n    ) internal virtual returns (uint256) {\n        uint256 idle = totalIdle;\n        WithdrawInfo memory info = WithdrawInfo({\n            currentIdle: idle,\n            assetsFromIdle: assets >= idle ? idle : assets,\n            totalAssetsToPull: assets - (assets >= idle ? idle : assets),\n            totalAssetsPulled: 0,\n            idleIncrease: 0,\n            debtDecrease: 0\n        });\n\n        // If not enough funds in idle, then pull what we need from destinations\n        if (info.totalAssetsToPull > 0) {\n            uint256 totalVaultShares = totalSupply();\n\n            // Using pre-set withdrawalQueue for withdrawal order to help minimize user gas\n            uint256 withdrawalQueueLength = withdrawalQueue.length;\n            for (uint256 i = 0; i < withdrawalQueueLength; ++i) {\n                IDestinationVault destVault = IDestinationVault(withdrawalQueue[i]);\n                (uint256 sharesToBurn, uint256 totalDebtBurn) = _calcUserWithdrawSharesToBurn(\n                    destVault,\n                    shares,\n                    info.totalAssetsToPull - Math.max(info.debtDecrease, info.totalAssetsPulled),\n                    totalVaultShares\n                );\n                if (sharesToBurn == 0) {\n                    continue;\n                }\n\n                uint256 assetPreBal = _baseAsset.balanceOf(address(this));\n                uint256 assetPulled = destVault.withdrawBaseAsset(sharesToBurn, address(this));\n\n                // Destination Vault rewards will be transferred to us as part of burning out shares\n                // Back into what that amount is and make sure it gets into idle\n                info.idleIncrease += _baseAsset.balanceOf(address(this)) - assetPreBal - assetPulled;\n                info.totalAssetsPulled += assetPulled;\n                info.debtDecrease += totalDebtBurn;\n\n                // It's possible we'll get back more assets than we anticipate from a swap\n                // so if we do, throw it in idle and stop processing. You don't get more than we've calculated\n                if (info.totalAssetsPulled > info.totalAssetsToPull) {\n                    info.idleIncrease = info.totalAssetsPulled - info.totalAssetsToPull;\n                    info.totalAssetsPulled = info.totalAssetsToPull;\n                    break;\n                }\n\n                // No need to keep going if we have the amount we're looking for\n                // Any overage is accounted for above. Anything lower and we need to keep going\n                // slither-disable-next-line incorrect-equality\n                if (info.totalAssetsPulled == info.totalAssetsToPull) {\n                    break;\n                }\n            }\n        }\n\n        // At this point should have all the funds we need sitting in in the vault\n        uint256 returnedAssets = info.assetsFromIdle + info.totalAssetsPulled;\n\n        // subtract what's taken out of idle from totalIdle\n        // slither-disable-next-line events-maths\n        totalIdle = info.currentIdle + info.idleIncrease - info.assetsFromIdle;\n\n        if (info.debtDecrease > totalDebt) {\n            totalDebt = 0;"
    }
  ]
}