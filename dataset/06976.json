{
  "Title": "[G-02] State variables can be cached instead of re-reading them from storage",
  "Content": "Caching of a state variable replaces each `Gwarmaccess (100 gas)` with a much cheaper stack read. \n\n*Note these are instances that the c4udit tool missed.*\n\nTotal Instances: 16\n\nGas savings: `11 * 100 + 501 (5 benchmarked instances) = 1601`\n\nhttps://github.com/code-423n4/2023-03-aragon/blob/main/packages/contracts/src/framework/plugin/repo/PluginRepo.sol#L128-L153\n\n### Gas Savings for `createVersion()`, obtained via protocol's tests: Avg 107 gas | Cache `latestRelease` as a stack variable to save 1 SLOAD\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  121713  |  178154  |  161829 |    40    |\n| After  |  121606  |  178047  |  161722 |    40    |\n```solidity\nFile: src/framework/plugin/repo/PluginRepo.sol\n128:    function createVersion(\n129:        uint8 _release,\n130:        address _pluginSetup,\n131:        bytes calldata _buildMetadata,\n132:        bytes calldata _releaseMetadata\n133:    ) external auth(MAINTAINER_PERMISSION_ID) {\n134:        if (!_pluginSetup.supportsInterface(type(IPluginSetup).interfaceId)) {\n135:            revert InvalidPluginSetupInterface();\n136:        }\n137:\n138:        if (_release == 0) {\n139:            revert ReleaseZeroNotAllowed();\n140:        }\n141:\n142:        // Check that the release number is not incremented by more than one\n143:        if (_release - latestRelease > 1) { // @audit: 1st sload\n144:            revert InvalidReleaseIncrement({latestRelease: latestRelease, newRelease: _release});\n145:        }\n146:\n147:        if (_release > latestRelease) { // @audit: 2nd sload\n148:            latestRelease = _release;\n149:\n150:            if (_releaseMetadata.length == 0) {\n151:                revert EmptyReleaseMetadata();\n152:            }\n153:        }\n```\n```diff\ndiff --git a/src/framework/plugin/repo/PluginRepo.sol b/src/framework/plugin/repo/PluginRepo.sol\nindex 6dc2c8b..dfde528 100644\n--- a/src/framework/plugin/repo/PluginRepo.sol\n+++ b/src/framework/plugin/repo/PluginRepo.sol\n@@ -140,11 +140,12 @@ contract PluginRepo is\n         }\n\n         // Check that the release number is not incremented by more than one\n-        if (_release - latestRelease > 1) {\n-            revert InvalidReleaseIncrement({latestRelease: latestRelease, newRelease: _release});\n+        uint8 _latestRelease = latestRelease;\n+        if (_release - _latestRelease > 1) {\n+            revert InvalidReleaseIncrement({latestRelease: _latestRelease, newRelease: _release});\n         }\n\n-        if (_release > latestRelease) {\n+        if (_release > _latestRelease) {\n             latestRelease = _release;\n```\n\nhttps://github.com/code-423n4/2023-03-aragon/blob/main/packages/contracts/src/framework/utils/ens/ENSSubdomainRegistrar.sol#L82-L96\n\n### Gas Savings for `createVersion()`, obtained via protocol's tests: Avg 394 gas | Cache `node`, `ens`, and `resolver` to save 4 SLOADs\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  140546  |  142827  |  141691 |    14    |\n| After  |  140152  |  142433  |  141297 |    14    |\n```solidity\nFile: src/framework/utils/ens/ENSSubdomainRegistrar.sol\n82:    function registerSubnode(\n83:        bytes32 _label,\n84:        address _targetAddress\n85:    ) external auth(REGISTER_ENS_SUBDOMAIN_PERMISSION_ID) {\n86:        bytes32 subnode = keccak256(abi.encodePacked(node, _label)); // @audit: 1st sload for `node`\n87:        address currentOwner = ens.owner(subnode); // @audit: 1st sload for `ens`\n88:\n89:        if (currentOwner != address(0)) {\n90:            revert AlreadyRegistered(subnode, currentOwner);\n91:        }\n92:\n93:        ens.setSubnodeOwner(node, _label, address(this)); // @audit: 2nd sload for `ens` and `node`\n94:        ens.setResolver(subnode, resolver); // @audit: 3rd sload for `node` and 1st sload for `resolver`\n95:        Resolver(resolver).setAddr(subnode, _targetAddress); // @audit: 2nd sload for resolver\n96:    }\n```\n```diff\ndiff --git a/src/framework/utils/ens/ENSSubdomainRegistrar.sol b/src/framework/utils/ens/ENSSubdomainRegistrar.sol\nindex 0d5ea5e..3ed14bd 100644\n--- a/src/framework/utils/ens/ENSSubdomainRegistrar.sol\n+++ b/src/framework/utils/ens/ENSSubdomainRegistrar.sol\n@@ -83,16 +83,19 @@ contract ENSSubdomainRegistrar is UUPSUpgradeable, DaoAuthorizableUpgradeable {\n         bytes32 _label,\n         address _targetAddress\n     ) external auth(REGISTER_ENS_SUBDOMAIN_PERMISSION_ID) {\n-        bytes32 subnode = keccak256(abi.encodePacked(node, _label));\n-        address currentOwner = ens.owner(subnode);\n+        bytes32 _node = node;\n+        ENS _ens = ens;\n+        address _resolver = resolver;\n+        bytes32 subnode = keccak256(abi.encodePacked(_node, _label));\n+        address currentOwner = _ens.owner(subnode);\n\n         if (currentOwner != address(0)) {\n             revert AlreadyRegistered(subnode, currentOwner);\n         }\n\n-        ens.setSubnodeOwner(node, _label, address(this));\n-        ens.setResolver(subnode, resolver);\n-        Resolver(resolver).setAddr(subnode, _targetAddress);\n+        _ens.setSubnodeOwner(_node, _label, address(this));\n+        _ens.setResolver(subnode, _resolver);\n+        Resolver(_resolver).setAddr(subnode, _targetAddress);\n     }\n```\n\nhttps://github.com/code-423n4/2023-03-aragon/blob/main/packages/contracts/src/plugins/token/MerkleMinter.sol#L74-L95\n\n### Cache `token` as a stack variable to save 1 SLOAD\n```solidity\nFile: src/plugins/token/MerkleMinter.sol\n74:    function merkleMint(\n75:        bytes32 _merkleRoot,\n76:        uint256 _totalAmount,\n77:        bytes calldata _tree,\n78:        bytes calldata _context\n79:    ) external override auth(MERKLE_MINT_PERMISSION_ID) returns (IMerkleDistributor distributor) {\n80:        address distributorAddr = createERC1967Proxy(\n81:            address(distributorBase),\n82:            abi.encodeWithSelector(\n83:                MerkleDistributor.initialize.selector,\n84:                dao(),\n85:                IERC20Upgradeable(address(token)), // @audit: 1st sload\n86:                _merkleRoot\n87:            )\n88:        );\n89:\n90:        token.mint(distributorAddr, _totalAmount); // @audit: 2nd sload\n91:\n92:        emit MerkleMinted(distributorAddr, _merkleRoot, _totalAmount, _tree, _context);\n93:\n94:        return IMerkleDistributor(distributorAddr);\n95:    }\n```\n```diff\ndiff --git a/src/plugins/token/MerkleMinter.sol b/src/plugins/token/MerkleMinter.sol\nindex fab8959..a372746 100644\n--- a/src/plugins/token/MerkleMinter.sol\n+++ b/src/plugins/token/MerkleMinter.sol\n@@ -77,17 +77,18 @@ contract MerkleMinter is IMerkleMinter, PluginUUPSUpgradeable {\n         bytes calldata _tree,\n         bytes calldata _context\n     ) external override auth(MERKLE_MINT_PERMISSION_ID) returns (IMerkleDistributor distributor) {\n+        IERC20MintableUpgradeable _token = token;\n         address distributorAddr = createERC1967Proxy(\n             address(distributorBase),\n             abi.encodeWithSelector(\n                 MerkleDistributor.initialize.selector,\n                 dao(),\n-                IERC20Upgradeable(address(token)),\n+                IERC20Upgradeable(address(_token)),\n                 _merkleRoot\n             )\n         );\n\n-        token.mint(distributorAddr, _totalAmount);\n+        _token.mint(distributorAddr, _totalAmount);\n\n         emit MerkleMinted(distributorAddr, _merkleRoot, _totalAmount, _tree, _context);\n```\n\nhttps://github.com/code-423n4/2023-03-aragon/blob/main/packages/contracts/src/core/dao/DAO.sol#L248-L258\n\n### Cache `signatureValidator` as a stack variable to save 1 SLOAD\n```solidity\nFile: src/core/dao/DAO.sol\n248:    function isValidSignature(\n249:        bytes32 _hash,\n250:        bytes memory _signature\n251:    ) external view override(IDAO, IERC1271) returns (bytes4) {\n252:        if (address(signatureValidator) == address(0)) { // @audit: 1st sload\n253:            // Return the invalid magic number\n254:            return bytes4(0);\n255:        }\n256:        // Forward the call to the set signature validator contract\n257:        return signatureValidator.isValidSignature(_hash, _signature); // @audit: 2nd sload\n258:    }\n```\n```diff\ndiff --git a/src/core/dao/DAO.sol b/src/core/dao/DAO.sol\nindex d7c912d..9b3379f 100644\n--- a/src/core/dao/DAO.sol\n+++ b/src/core/dao/DAO.sol\n@@ -249,12 +249,13 @@ contract DAO is\n         bytes32 _hash,\n         bytes memory _signature\n     ) external view override(IDAO, IERC1271) returns (bytes4) {\n-        if (address(signatureValidator) == address(0)) {\n+        IERC1271 _signatureValidator = signatureValidator;\n+        if (address(_signatureValidator) == address(0)) {\n             // Return the invalid magic number\n             return bytes4(0);\n         }\n         // Forward the call to the set signature validator contract\n-        return signatureValidator.isValidSignature(_hash, _signature);\n+        return _signatureValidator.isValidSignature(_hash, _signature);\n     }\n```\n\nhttps://github.com/code-423n4/2023-03-aragon/blob/main/packages/contracts/src/framework/plugin/repo/PluginRepo.sol#L155-L163\n\n### Cache `version.tag.release` as a stack variable to save 2 SLOADs\n```solidity\nFile: src/framework/plugin/repo/PluginRepo.sol\n155:        // Make sure the same plugin setup wasn't used in previous releases.\n156:        Version storage version = versions[latestTagHashForPluginSetup[_pluginSetup]];\n157:        if (version.tag.release != 0 && version.tag.release != _release) { // @audit: 1st and 2nd sload \n158:            revert PluginSetupAlreadyInPreviousRelease(\n159:                version.tag.release, // @audit: 3rd sload, unhappy path \n160:                version.tag.build,\n161:                _pluginSetup\n162:            );\n163:        }\n```\n```diff\ndiff --git a/src/framework/plugin/repo/PluginRepo.sol b/src/framework/plugin/repo/PluginRepo.sol\nindex 6dc2c8b..4c18f74 100644\n--- a/src/framework/plugin/repo/PluginRepo.sol\n+++ b/src/framework/plugin/repo/PluginRepo.sol\n@@ -154,9 +154,10 @@ contract PluginRepo is\n\n         // Make sure the same plugin setup wasn't used in previous releases.\n         Version storage version = versions[latestTagHashForPluginSetup[_pluginSetup]];\n-        if (version.tag.release != 0 && version.tag.release != _release) {\n+        uint8 prevRelease = version.tag.release;\n+        if (prevRelease != 0 && prevRelease != _release) {\n             revert PluginSetupAlreadyInPreviousRelease(\n-                version.tag.release,\n+                prevRelease,\n                 version.tag.build,\n                 _pluginSetup\n             );\n```\n\nhttps://github.com/code-423n4/2023-03-aragon/blob/main/packages/contracts/src/plugins/counter-example/v1/CounterV1PluginSetup.sol#L43-L88\n\n### Cache `counterBase` and `multiplyHelperBase` as stack variables to save 2 SLOADs\n```solidity\nFile: src/plugins/counter-example/v1/CounterV1PluginSetup.sol\n43:        if (_multiplyHelper == address(0)) {\n44:            multiplyHelper = createERC1967Proxy(address(multiplyHelperBase), bytes(\"\")); // @audit: 1st sload for `multiplyHelperBase`\n45:        }\n46:\n47:        bytes memory initData = abi.encodeWithSelector(\n48:            bytes4(keccak256(\"initialize(address,address,uint256)\")),\n49:            _dao,\n50:            multiplyHelper,\n51:            _num\n52:        );\n53:\n54:        PermissionLib.MultiTargetPermission[]\n55:            memory permissions = new PermissionLib.MultiTargetPermission[](\n56:                _multiplyHelper == address(0) ? 3 : 2\n57:            );\n58:        address[] memory helpers = new address[](1);\n59:\n60:        // deploy\n61:        plugin = createERC1967Proxy(address(counterBase), initData); // @audit: 1st sload for `counterBase`\n62:\n63:        // set permissions\n64:        permissions[0] = PermissionLib.MultiTargetPermission(\n65:            PermissionLib.Operation.Grant,\n66:            _dao,\n67:            plugin,\n68:            PermissionLib.NO_CONDITION,\n69:            keccak256(\"EXECUTE_PERMISSION\")\n70:        );\n71:\n72:        permissions[1] = PermissionLib.MultiTargetPermission(\n73:            PermissionLib.Operation.Grant,\n74:            plugin,\n75:            _dao,\n76:            PermissionLib.NO_CONDITION,\n77:            counterBase.MULTIPLY_PERMISSION_ID() // @audit: 2nd sload for `counterBase`\n78:        );\n79:\n80:        if (_multiplyHelper == address(0)) {\n81:            permissions[2] = PermissionLib.MultiTargetPermission(\n82:                PermissionLib.Operation.Grant,\n83:                multiplyHelper,\n84:                plugin,\n85:                PermissionLib.NO_CONDITION,\n86:                multiplyHelperBase.MULTIPLY_PERMISSION_ID() // @audit: 2nd sload for `multiplyHelperBase`\n87:            );\n88:        }\n```\n```diff\ndiff --git a/src/plugins/counter-example/v1/CounterV1PluginSetup.sol b/src/plugins/counter-example/v1/CounterV1PluginSetup.sol\nindex 7af94ab..85d2dc6 100644\n--- a/src/plugins/counter-example/v1/CounterV1PluginSetup.sol\n+++ b/src/plugins/counter-example/v1/CounterV1PluginSetup.sol\n@@ -39,9 +39,9 @@ contract CounterV1PluginSetup is PluginSetup {\n         (address _multiplyHelper, uint256 _num) = abi.decode(_data, (address, uint256));\n\n         address multiplyHelper = _multiplyHelper;\n-\n+        MultiplyHelper _multiplyHelperBase = multiplyHelperBase;\n         if (_multiplyHelper == address(0)) {\n-            multiplyHelper = createERC1967Proxy(address(multiplyHelperBase), bytes(\"\"));\n+            multiplyHelper = createERC1967Proxy(address(_multiplyHelperBase), bytes(\"\"));\n         }\n\n         bytes memory initData = abi.encodeWithSelector(\n@@ -58,7 +58,8 @@ contract CounterV1PluginSetup is PluginSetup {\n         address[] memory helpers = new address[](1);\n\n         // deploy\n-        plugin = createERC1967Proxy(address(counterBase), initData);\n+        CounterV1 _counterBase = counterBase;\n+        plugin = createERC1967Proxy(address(_counterBase), initData);\n\n         // set permissions\n         permissions[0] = PermissionLib.MultiTargetPermission(\n@@ -74,7 +75,7 @@ contract CounterV1PluginSetup is PluginSetup {\n             plugin,\n             _dao,\n             PermissionLib.NO_CONDITION,\n-            counterBase.MULTIPLY_PERMISSION_ID()\n+            _counterBase.MULTIPLY_PERMISSION_ID()\n         );\n\n         if (_multiplyHelper == address(0)) {\n@@ -83,7 +84,7 @@ contract CounterV1PluginSetup is PluginSetup {\n                 multiplyHelper,\n                 plugin,\n                 PermissionLib.NO_CONDITION,\n-                multiplyHelperBase.MULTIPLY_PERMISSION_ID()\n+                _multiplyHelperBase.MULTIPLY_PERMISSION_ID()\n             );\n         }\n```\n\nhttps://github.com/code-423n4/2023-03-aragon/blob/main/packages/contracts/src/plugins/counter-example/v2/CounterV2PluginSetup.sol#L44-L89\n\n### Cache `counterBase` and `multiplyHelperBase` as stack variables to save 2 SLOADs (Identical to instance above)\n\nhttps://github.com/code-423n4/2023-03-aragon/blob/main/packages/contracts/src/plugins/governance/majority-voting/MajorityVotingBase.sol#L313-L321\n\n### Cache `proposal_.parameters.supportThreshold` as a stack variable to save 1 SLOAD\n```solidity\nFile: src/plugins/governance/majority-voting/MajorityVotingBase.sol\n313:    function isSupportThresholdReached(uint256 _proposalId) public view virtual returns (bool) {\n314:        Proposal storage proposal_ = proposals[_proposalId];\n315:\n316:        // The code below implements the formula of the support criterion explained in the top of this file.\n317:        // `(1 - supportThreshold) * N_yes > supportThreshold *  N_no`\n318:        return\n319:            (RATIO_BASE - proposal_.parameters.supportThreshold) * proposal_.tally.yes > // @audit: 1st sload\n320:            proposal_.parameters.supportThreshold * proposal_.tally.no; // @audit: 2nd sload\n321:    }\n```\n```diff\ndiff --git a/src/plugins/governance/majority-voting/MajorityVotingBase.sol b/src/plugins/governance/majority-voting/MajorityVotingBase.sol\nindex 58ba2fe..d6ce8b0 100644\n--- a/src/plugins/governance/majority-voting/MajorityVotingBase.sol\n+++ b/src/plugins/governance/majority-voting/MajorityVotingBase.sol\n@@ -315,9 +315,10 @@ abstract contract MajorityVotingBase is\n\n         // The code below implements the formula of the support criterion explained in the top of this file.\n         // `(1 - supportThreshold) * N_yes > supportThreshold *  N_no`\n+        uint32 _supportThreshold = proposal_.parameters.supportThreshold;\n         return\n-            (RATIO_BASE - proposal_.parameters.supportThreshold) * proposal_.tally.yes >\n-            proposal_.parameters.supportThreshold * proposal_.tally.no;\n+            (RATIO_BASE - _supportThreshold) * proposal_.tally.yes >\n+            _supportThreshold * proposal_.tally.no;\n     }\n```\n\nhttps://github.com/code-423n4/2023-03-aragon/blob/main/packages/contracts/src/plugins/governance/majority-voting/MajorityVotingBase.sol#L324-L338\n\n### Cache `proposal_.tally.yes` and `proposal_.parameters.supportThreshold` as stack variables to save 2 SLOADs\n```solidity\nFile: src/plugins/governance/majority-voting/MajorityVotingBase.sol\n324:    function isSupportThresholdReachedEarly(\n325:        uint256 _proposalId\n326:    ) public view virtual returns (bool) {\n327:       Proposal storage proposal_ = proposals[_proposalId];\n328:\n329:        uint256 noVotesWorstCase = totalVotingPower(proposal_.parameters.snapshotBlock) -\n330:            proposal_.tally.yes - // @audit: 1st sload for `proposal_.tally.yes`\n331:            proposal_.tally.abstain;\n332:\n333:        // The code below implements the formula of the early execution support criterion explained in the top of this file.\n334:        // `(1 - supportThreshold) * N_yes > supportThreshold *  N_no,worst-case`\n335:        return\n336:            (RATIO_BASE - proposal_.parameters.supportThreshold) * proposal_.tally.yes > // @audit: 1st sload for `proposal_.parameters.supportThreshold`, 2nd sload for `proposal_.tally.yes`\n337:            proposal_.parameters.supportThreshold * noVotesWorstCase; // @audit: 2nd sload for `proposal_.parameters.supportThreshold`\n338:    }\n```\n```diff\ndiff --git a/src/plugins/governance/majority-voting/MajorityVotingBase.sol b/src/plugins/governance/majority-voting/MajorityVotingBase.sol\nindex 58ba2fe..e6cf684 100644\n--- a/src/plugins/governance/majority-voting/MajorityVotingBase.sol\n+++ b/src/plugins/governance/majority-voting/MajorityVotingBase.sol\n@@ -325,16 +325,18 @@ abstract contract MajorityVotingBase is\n         uint256 _proposalId\n     ) public view virtual returns (bool) {\n         Proposal storage proposal_ = proposals[_proposalId];\n+        uint256 _yes = proposal_.tally.yes;\n+        uint32 _supportThreshold = proposal_.parameters.supportThreshold;\n\n         uint256 noVotesWorstCase = totalVotingPower(proposal_.parameters.snapshotBlock) -\n-            proposal_.tally.yes -\n+            _yes -\n             proposal_.tally.abstain;\n\n         // The code below implements the formula of the early execution support criterion explained in the top of this file.\n         // `(1 - supportThreshold) * N_yes > supportThreshold *  N_no,worst-case`\n         return\n-            (RATIO_BASE - proposal_.parameters.supportThreshold) * proposal_.tally.yes >\n-            proposal_.parameters.supportThreshold * noVotesWorstCase;\n+            (RATIO_BASE - _supportThreshold) * _yes >\n+            _supportThreshold * noVotesWorstCase;\n     }\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-03-aragon",
  "Code": [
    {
      "filename": "packages/contracts/src/framework/plugin/repo/PluginRepo.sol",
      "content": "// SPDX-License-Identifier:    AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {ERC165CheckerUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol\";\n\nimport {PermissionManager} from \"../../../core/permission/PermissionManager.sol\";\nimport {PluginSetup} from \"../setup/PluginSetup.sol\";\nimport {IPluginSetup} from \"../setup/PluginSetup.sol\";\nimport {IPluginRepo} from \"./IPluginRepo.sol\";\n\n/// @title PluginRepo\n/// @author Aragon Association - 2020 - 2023\n/// @notice The plugin repository contract required for managing and publishing different plugin versions within the Aragon DAO framework.\ncontract PluginRepo is\n    Initializable,\n    ERC165Upgradeable,\n    IPluginRepo,\n    UUPSUpgradeable,\n    PermissionManager\n{\n    using AddressUpgradeable for address;\n    using ERC165CheckerUpgradeable for address;\n\n    /// @notice The struct describing the tag of a version obtained by a release and build number as `RELEASE.BUILD`.\n    /// @param release The release number.\n    /// @param build The build number\n    /// @dev Releases can include a storage layout or the addition of new functions. Builds include logic changes or updates of the UI.\n    struct Tag {\n        uint8 release;\n        uint16 build;\n    }\n\n    /// @notice The struct describing a plugin version (release and build).\n    /// @param tag The version tag.\n    /// @param pluginSetup The setup contract associated with this version.\n    /// @param buildMetadata The build metadata URI.\n    struct Version {\n        Tag tag;\n        address pluginSetup;\n        bytes buildMetadata;\n    }\n\n    /// @notice The ID of the permission required to call the `createVersion` function.\n    bytes32 public constant MAINTAINER_PERMISSION_ID = keccak256(\"MAINTAINER_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `createVersion` function.\n    bytes32 public constant UPGRADE_REPO_PERMISSION_ID = keccak256(\"UPGRADE_REPO_PERMISSION\");\n\n    /// @notice The mapping between release and build numbers.\n    mapping(uint8 => uint16) internal buildsPerRelease;\n\n    /// @notice The mapping between the version hash and the corresponding version information.\n    mapping(bytes32 => Version) internal versions;\n\n    /// @notice The mapping between the plugin setup address and its corresponding version hash.\n    mapping(address => bytes32) internal latestTagHashForPluginSetup;\n\n    /// @notice The ID of the latest release.\n    /// @dev The maximum release number is 255.\n    uint8 public latestRelease;\n\n    /// @notice Thrown if a version does not exist.\n    /// @param versionHash The tag hash.\n    error VersionHashDoesNotExist(bytes32 versionHash);\n\n    /// @notice Thrown if a plugin setup contract does not inherit from `PluginSetup`.\n    error InvalidPluginSetupInterface();\n\n    /// @notice Thrown if a release number is zero.\n    error ReleaseZeroNotAllowed();\n\n    /// @notice Thrown if a release number is incremented by more than one.\n    /// @param latestRelease The latest release number.\n    /// @param newRelease The new release number.\n    error InvalidReleaseIncrement(uint8 latestRelease, uint8 newRelease);\n\n    /// @notice Thrown if the same plugin setup contract exists already in a previous releases.\n    /// @param release The release number of the already existing plugin setup.\n    /// @param build The build number of the already existing plugin setup.\n    /// @param pluginSetup The plugin setup contract address.\n    error PluginSetupAlreadyInPreviousRelease(uint8 release, uint16 build, address pluginSetup);\n\n    /// @notice Thrown if the metadata URI is empty.\n    error EmptyReleaseMetadata();\n\n    /// @notice Thrown if release does not exist.\n    error ReleaseDoesNotExist();\n\n    /// @notice Thrown if the same plugin setup exists in previous releases.\n    /// @param release The release number.\n    /// @param build The build number.\n    /// @param pluginSetup The address of the plugin setup contract.\n    /// @param buildMetadata The build metadata URI.\n    event VersionCreated(\n        uint8 release,\n        uint16 build,\n        address indexed pluginSetup,\n        bytes buildMetadata\n    );\n\n    /// @notice Thrown when a release's metadata was updated.\n    /// @param release The release number.\n    /// @param releaseMetadata The release metadata URI.\n    event ReleaseMetadataUpdated(uint8 release, bytes releaseMetadata);\n\n    /// @dev Used to disallow initializing the implementation contract by an attacker for extra safety.\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the contract by\n    /// - initializing the permission manager\n    /// - granting the `MAINTAINER_PERMISSION_ID` permission to the initial owner.\n    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).\n    function initialize(address initialOwner) external initializer {\n        __PermissionManager_init(initialOwner);\n\n        _grant(address(this), initialOwner, MAINTAINER_PERMISSION_ID);\n        _grant(address(this), initialOwner, UPGRADE_REPO_PERMISSION_ID);\n    }\n\n    /// @inheritdoc IPluginRepo\n    function createVersion(\n        uint8 _release,\n        address _pluginSetup,\n        bytes calldata _buildMetadata,\n        bytes calldata _releaseMetadata\n    ) external auth(MAINTAINER_PERMISSION_ID) {\n        if (!_pluginSetup.supportsInterface(type(IPluginSetup).interfaceId)) {\n            revert InvalidPluginSetupInterface();\n        }\n\n        if (_release == 0) {\n            revert ReleaseZeroNotAllowed();\n        }\n\n        // Check that the release number is not incremented by more than one\n        if (_release - latestRelease > 1) {\n            revert InvalidReleaseIncrement({latestRelease: latestRelease, newRelease: _release});\n        }\n\n        if (_release > latestRelease) {\n            latestRelease = _release;\n\n            if (_releaseMetadata.length == 0) {\n                revert EmptyReleaseMetadata();\n            }\n        }\n\n        // Make sure the same plugin setup wasn't used in previous releases.\n        Version storage version = versions[latestTagHashForPluginSetup[_pluginSetup]];\n        if (version.tag.release != 0 && version.tag.release != _release) {\n            revert PluginSetupAlreadyInPreviousRelease(\n                version.tag.release,\n                version.tag.build,\n                _pluginSetup\n            );\n        }\n\n        uint16 build = ++buildsPerRelease[_release];\n\n        Tag memory tag = Tag(_release, build);\n        bytes32 _tagHash = tagHash(tag);\n\n        versions[_tagHash] = Version(tag, _pluginSetup, _buildMetadata);\n\n        latestTagHashForPluginSetup[_pluginSetup] = _tagHash;\n\n        emit VersionCreated({\n            release: _release,\n            build: build,\n            pluginSetup: _pluginSetup,\n            buildMetadata: _buildMetadata\n        });\n\n        if (_releaseMetadata.length > 0) {\n            emit ReleaseMetadataUpdated(_release, _releaseMetadata);\n        }\n    }\n\n    /// @inheritdoc IPluginRepo\n    function updateReleaseMetadata(\n        uint8 _release,\n        bytes calldata _releaseMetadata\n    ) external auth(MAINTAINER_PERMISSION_ID) {\n        if (_release == 0) {\n            revert ReleaseZeroNotAllowed();\n        }\n\n        if (_release > latestRelease) {\n            revert ReleaseDoesNotExist();\n        }\n\n        if (_releaseMetadata.length == 0) {\n            revert EmptyReleaseMetadata();\n        }\n\n        emit ReleaseMetadataUpdated(_release, _releaseMetadata);\n    }\n\n    /// @notice Returns the latest version for a given release number.\n    /// @param _release The release number.\n    /// @return The latest version of this release.\n    function getLatestVersion(uint8 _release) public view returns (Version memory) {\n        uint16 latestBuild = uint16(buildsPerRelease[_release]);\n        return getVersion(tagHash(Tag(_release, latestBuild)));\n    }\n\n    /// @notice Returns the latest version for a given plugin setup.\n    /// @param _pluginSetup The plugin setup address\n    /// @return The latest version associated with the plugin Setup.\n    function getLatestVersion(address _pluginSetup) public view returns (Version memory) {\n        return getVersion(latestTagHashForPluginSetup[_pluginSetup]);\n    }\n\n    /// @notice Returns the version associated with a tag.\n    /// @param _tag The version tag.\n    /// @return The version associated with the tag.\n    function getVersion(Tag calldata _tag) public view returns (Version memory) {\n        return getVersion(tagHash(_tag));\n    }\n\n    /// @notice Returns the version for a tag hash.\n    /// @param _tagHash The tag hash.\n    /// @return The version associated with a tag hash.\n    function getVersion(bytes32 _tagHash) public view returns (Version memory) {\n        Version storage version = versions[_tagHash];\n\n        if (version.tag.release == 0) {\n            revert VersionHashDoesNotExist(_tagHash);\n        }\n\n        return version;\n    }\n\n    /// @notice Gets the total number of builds for a given release number.\n    /// @param _release The release number.\n    /// @return The number of builds of this release.\n    function buildCount(uint8 _release) public view returns (uint256) {\n        return buildsPerRelease[_release];\n    }\n\n    /// @notice The hash of the version tag obtained from the packed, bytes-encoded release and build number.\n    /// @param _tag The version tag.\n    /// @return The version tag hash.\n    function tagHash(Tag memory _tag) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_tag.release, _tag.build));\n    }\n\n    /// @notice Internal method authorizing the upgrade of the contract via the [upgradeabilty mechanism for UUPS proxies](https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable) (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822)).\n    /// @dev The caller must have the `UPGRADE_REPO_PERMISSION_ID` permission.\n    function _authorizeUpgrade(\n        address\n    ) internal virtual override auth(UPGRADE_REPO_PERMISSION_ID) {}\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return\n            _interfaceId == type(IPluginRepo).interfaceId ||\n            _interfaceId == type(UUPSUpgradeable).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n}"
    },
    {
      "filename": "packages/contracts/src/framework/utils/ens/ENSSubdomainRegistrar.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport \"@ensdomains/ens-contracts/contracts/registry/ENS.sol\";\nimport \"@ensdomains/ens-contracts/contracts/resolvers/Resolver.sol\";\n\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\nimport {DaoAuthorizableUpgradeable} from \"../../../core/plugin/dao-authorizable/DaoAuthorizableUpgradeable.sol\";\nimport {IDAO} from \"../../../core/dao/IDAO.sol\";\n\n/// @title ENSSubdomainRegistrar\n/// @author Aragon Association - 2022-2023\n/// @notice This contract registers ENS subdomains under a parent domain specified in the initialization process and maintains ownership of the subdomain since only the resolver address is set. This contract must either be the domain node owner or an approved operator of the node owner. The default resolver being used is the one specified in the parent domain.\ncontract ENSSubdomainRegistrar is UUPSUpgradeable, DaoAuthorizableUpgradeable {\n    /// @notice The ID of the permission required to call the `_authorizeUpgrade` function.\n    bytes32 public constant UPGRADE_REGISTRAR_PERMISSION_ID =\n        keccak256(\"UPGRADE_REGISTRAR_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `registerSubnode` and `setDefaultResolver` function.\n    bytes32 public constant REGISTER_ENS_SUBDOMAIN_PERMISSION_ID =\n        keccak256(\"REGISTER_ENS_SUBDOMAIN_PERMISSION\");\n\n    /// @notice The ENS registry contract\n    ENS public ens;\n\n    /// @notice The namehash of the domain on which subdomains are registered.\n    bytes32 public node;\n\n    /// @notice The address of the ENS resolver resolving the names to an address.\n    address public resolver;\n\n    /// @notice Thrown if the subnode is already registered.\n    /// @param subnode The subnode namehash.\n    /// @param nodeOwner The node owner address.\n    error AlreadyRegistered(bytes32 subnode, address nodeOwner);\n\n    /// @notice Thrown if node's resolver is invalid.\n    /// @param node The node namehash.\n    /// @param resolver The node resolver address.\n    error InvalidResolver(bytes32 node, address resolver);\n\n    /// @dev Used to disallow initializing the implementation contract by an attacker for extra safety.\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the component by\n    /// - checking that the contract is the domain node owner or an approved operator\n    /// - initializing the underlying component\n    /// - registering the [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID\n    /// - setting the ENS contract, the domain node hash, and resolver.\n    /// @param _managingDao The interface of the DAO managing the components permissions.\n    /// @param _ens The interface of the ENS registry to be used.\n    /// @param _node The ENS parent domain node under which the subdomains are to be registered.\n    function initialize(IDAO _managingDao, ENS _ens, bytes32 _node) external initializer {\n        __DaoAuthorizableUpgradeable_init(_managingDao);\n\n        ens = _ens;\n        node = _node;\n\n        address nodeResolver = ens.resolver(_node);\n\n        if (nodeResolver == address(0)) {\n            revert InvalidResolver({node: _node, resolver: nodeResolver});\n        }\n\n        resolver = nodeResolver;\n    }\n\n    /// @notice Internal method authorizing the upgrade of the contract via the [upgradeabilty mechanism for UUPS proxies](https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable) (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822)).\n    /// @dev The caller must have the `UPGRADE_REGISTRAR_PERMISSION_ID` permission.\n    function _authorizeUpgrade(\n        address\n    ) internal virtual override auth(UPGRADE_REGISTRAR_PERMISSION_ID) {}\n\n    /// @notice Registers a new subdomain with this registrar as the owner and set the target address in the resolver.\n    /// @dev It reverts with no message if this contract isn't the owner nor an approved operator for the given node.\n    /// @param _label The labelhash of the subdomain name.\n    /// @param _targetAddress The address to which the subdomain resolves.\n    function registerSubnode(\n        bytes32 _label,\n        address _targetAddress\n    ) external auth(REGISTER_ENS_SUBDOMAIN_PERMISSION_ID) {\n        bytes32 subnode = keccak256(abi.encodePacked(node, _label));\n        address currentOwner = ens.owner(subnode);\n\n        if (currentOwner != address(0)) {\n            revert AlreadyRegistered(subnode, currentOwner);\n        }\n\n        ens.setSubnodeOwner(node, _label, address(this));\n        ens.setResolver(subnode, resolver);\n        Resolver(resolver).setAddr(subnode, _targetAddress);\n    }\n\n    /// @notice Sets the default resolver contract address that the subdomains being registered will use.\n    /// @param _resolver The resolver contract to be used.\n    function setDefaultResolver(\n        address _resolver\n    ) external auth(REGISTER_ENS_SUBDOMAIN_PERMISSION_ID) {\n        if (_resolver == address(0)) {\n            revert InvalidResolver({node: node, resolver: _resolver});\n        }\n\n        resolver = _resolver;\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZepplins guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[47] private __gap;\n}"
    },
    {
      "filename": "packages/contracts/src/plugins/token/MerkleMinter.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport {IDAO} from \"../../core/dao/IDAO.sol\";\nimport {PluginUUPSUpgradeable} from \"../../core/plugin/PluginUUPSUpgradeable.sol\";\nimport {IERC20MintableUpgradeable} from \"../../token/ERC20/IERC20MintableUpgradeable.sol\";\nimport {createERC1967Proxy} from \"../../utils/Proxy.sol\";\nimport {IMerkleDistributor} from \"./IMerkleDistributor.sol\";\nimport {MerkleDistributor} from \"./MerkleDistributor.sol\";\nimport {IMerkleMinter} from \"./IMerkleMinter.sol\";\n\n/// @title MerkleMinter\n/// @author Aragon Association\n/// @notice A component minting [ERC-20](https://eips.ethereum.org/EIPS/eip-20) tokens and distributing them on merkle trees using `MerkleDistributor` clones.\ncontract MerkleMinter is IMerkleMinter, PluginUUPSUpgradeable {\n    using Clones for address;\n\n    /// @notice The ID of the permission required to call the `merkleMint` function.\n    bytes32 public constant MERKLE_MINT_PERMISSION_ID = keccak256(\"MERKLE_MINT_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `changeDistributor` function.\n    bytes32 public constant CHANGE_DISTRIBUTOR_PERMISSION_ID =\n        keccak256(\"CHANGE_DISTRIBUTOR_PERMISSION\");\n\n    /// @inheritdoc IMerkleMinter\n    IERC20MintableUpgradeable public override token;\n\n    /// @inheritdoc IMerkleMinter\n    IMerkleDistributor public override distributorBase;\n\n    /// @notice Initializes the MerkleMinter.\n    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).\n    /// @param _dao The IDAO interface of the associated DAO.\n    /// @param _token A mintable [ERC-20](https://eips.ethereum.org/EIPS/eip-20) token.\n    /// @param _distributorBase A `MerkleDistributor` to be cloned.\n    function initialize(\n        IDAO _dao,\n        IERC20MintableUpgradeable _token,\n        IMerkleDistributor _distributorBase\n    ) external initializer {\n        __PluginUUPSUpgradeable_init(_dao);\n\n        token = _token;\n        distributorBase = _distributorBase;\n    }\n\n    /// @inheritdoc IMerkleMinter\n    function changeDistributorBase(\n        IMerkleDistributor _distributorBase\n    ) external override auth(CHANGE_DISTRIBUTOR_PERMISSION_ID) {\n        distributorBase = _distributorBase;\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return\n            _interfaceId == type(IMerkleMinter).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n\n    /// @notice Mints [ERC-20](https://eips.ethereum.org/EIPS/eip-20) tokens and distributes them using a `MerkleDistributor`.\n    /// @param _merkleRoot The root of the merkle balance tree.\n    /// @param _totalAmount The total amount of tokens to be minted.\n    /// @param _tree The link to the stored merkle tree.\n    /// @param _context Additional info related to the minting process.\n    /// @return distributor The `MerkleDistributor` via which the tokens can be claimed.\n    function merkleMint(\n        bytes32 _merkleRoot,\n        uint256 _totalAmount,\n        bytes calldata _tree,\n        bytes calldata _context\n    ) external override auth(MERKLE_MINT_PERMISSION_ID) returns (IMerkleDistributor distributor) {\n        address distributorAddr = createERC1967Proxy(\n            address(distributorBase),\n            abi.encodeWithSelector(\n                MerkleDistributor.initialize.selector,\n                dao(),\n                IERC20Upgradeable(address(token)),\n                _merkleRoot\n            )\n        );\n\n        token.mint(distributorAddr, _totalAmount);\n\n        emit MerkleMinted(distributorAddr, _merkleRoot, _totalAmount, _tree, _context);\n\n        return IMerkleDistributor(distributorAddr);\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZepplins guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[48] private __gap;\n}"
    },
    {
      "filename": "packages/contracts/src/core/dao/DAO.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165StorageUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\n\nimport {PermissionManager} from \"../permission/PermissionManager.sol\";\nimport {CallbackHandler} from \"../utils/CallbackHandler.sol\";\nimport {hasBit, flipBit} from \"../utils/BitMap.sol\";\nimport {IEIP4824} from \"./IEIP4824.sol\";\nimport {IDAO} from \"./IDAO.sol\";\n\n/// @title DAO\n/// @author Aragon Association - 2021-2023\n/// @notice This contract is the entry point to the Aragon DAO framework and provides our users a simple and easy to use public interface.\n/// @dev Public API of the Aragon DAO framework.\ncontract DAO is\n    IEIP4824,\n    Initializable,\n    IERC1271,\n    ERC165StorageUpgradeable,\n    IDAO,\n    UUPSUpgradeable,\n    PermissionManager,\n    CallbackHandler\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address;\n\n    /// @notice The ID of the permission required to call the `execute` function.\n    bytes32 public constant EXECUTE_PERMISSION_ID = keccak256(\"EXECUTE_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `_authorizeUpgrade` function.\n    bytes32 public constant UPGRADE_DAO_PERMISSION_ID = keccak256(\"UPGRADE_DAO_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `setMetadata` function.\n    bytes32 public constant SET_METADATA_PERMISSION_ID = keccak256(\"SET_METADATA_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `setTrustedForwarder` function.\n    bytes32 public constant SET_TRUSTED_FORWARDER_PERMISSION_ID =\n        keccak256(\"SET_TRUSTED_FORWARDER_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `setSignatureValidator` function.\n    bytes32 public constant SET_SIGNATURE_VALIDATOR_PERMISSION_ID =\n        keccak256(\"SET_SIGNATURE_VALIDATOR_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `registerStandardCallback` function.\n    bytes32 public constant REGISTER_STANDARD_CALLBACK_PERMISSION_ID =\n        keccak256(\"REGISTER_STANDARD_CALLBACK_PERMISSION\");\n\n    /// @notice The internal constant storing the maximal action array length.\n    uint256 internal constant MAX_ACTIONS = 256;\n\n    /// @notice The [ERC-1271](https://eips.ethereum.org/EIPS/eip-1271) signature validator contract.\n    IERC1271 public signatureValidator;\n\n    /// @notice The address of the trusted forwarder verifying meta transactions.\n    address private trustedForwarder;\n\n    /// @notice The [EIP-4824](https://eips.ethereum.org/EIPS/eip-4824) DAO uri.\n    string private _daoURI;\n\n    /// @notice Thrown if the action array length is larger than `MAX_ACTIONS`.\n    error TooManyActions();\n\n    /// @notice Thrown if action execution has failed.\n    /// @param index The index of the action in the action array that failed.\n    error ActionFailed(uint256 index);\n\n    /// @notice Thrown if the deposit amount is zero.\n    error ZeroAmount();\n\n    /// @notice Thrown if there is a mismatch between the expected and actually deposited amount of native tokens.\n    /// @param expected The expected native token amount.\n    /// @param actual The actual native token amount deposited.\n    error NativeTokenDepositAmountMismatch(uint256 expected, uint256 actual);\n\n    /// @notice Emitted when a new DAO uri is set.\n    /// @param daoURI The new uri.\n    event NewURI(string daoURI);\n\n    /// @notice Disables the initializers on the implementation contract to prevent it from being left uninitialized.\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the DAO by\n    /// - registering the [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID\n    /// - setting the trusted forwarder for meta transactions\n    /// - giving the `ROOT_PERMISSION_ID` permission to the initial owner (that should be revoked and transferred to the DAO after setup).\n    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).\n    /// @param _metadata IPFS hash that points to all the metadata (logo, description, tags, etc.) of a DAO.\n    /// @param _initialOwner The initial owner of the DAO having the `ROOT_PERMISSION_ID` permission.\n    /// @param _trustedForwarder The trusted forwarder responsible for verifying meta transactions.\n    function initialize(\n        bytes calldata _metadata,\n        address _initialOwner,\n        address _trustedForwarder,\n        string calldata daoURI_\n    ) external initializer {\n        _registerInterface(type(IDAO).interfaceId);\n        _registerInterface(type(IERC1271).interfaceId);\n        _registerInterface(type(IEIP4824).interfaceId);\n        _registerTokenInterfaces();\n\n        _setMetadata(_metadata);\n        _setTrustedForwarder(_trustedForwarder);\n        _setDaoURI(daoURI_);\n        __PermissionManager_init(_initialOwner);\n    }\n\n    /// @inheritdoc PermissionManager\n    function isPermissionRestrictedForAnyAddr(\n        bytes32 _permissionId\n    ) internal pure override returns (bool) {\n        return\n            _permissionId == EXECUTE_PERMISSION_ID ||\n            _permissionId == UPGRADE_DAO_PERMISSION_ID ||\n            _permissionId == SET_METADATA_PERMISSION_ID ||\n            _permissionId == SET_TRUSTED_FORWARDER_PERMISSION_ID ||\n            _permissionId == SET_SIGNATURE_VALIDATOR_PERMISSION_ID ||\n            _permissionId == REGISTER_STANDARD_CALLBACK_PERMISSION_ID;\n    }\n\n    /// @notice Internal method authorizing the upgrade of the contract via the [upgradeabilty mechanism for UUPS proxies](https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable) (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822)).\n    /// @dev The caller must have the `UPGRADE_DAO_PERMISSION_ID` permission.\n    function _authorizeUpgrade(address) internal virtual override auth(UPGRADE_DAO_PERMISSION_ID) {}\n\n    /// @inheritdoc IDAO\n    function setTrustedForwarder(\n        address _newTrustedForwarder\n    ) external override auth(SET_TRUSTED_FORWARDER_PERMISSION_ID) {\n        _setTrustedForwarder(_newTrustedForwarder);\n    }\n\n    /// @inheritdoc IDAO\n    function getTrustedForwarder() external view virtual override returns (address) {\n        return trustedForwarder;\n    }\n\n    /// @inheritdoc IDAO\n    function hasPermission(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        bytes memory _data\n    ) external view override returns (bool) {\n        return isGranted(_where, _who, _permissionId, _data);\n    }\n\n    /// @inheritdoc IDAO\n    function setMetadata(\n        bytes calldata _metadata\n    ) external override auth(SET_METADATA_PERMISSION_ID) {\n        _setMetadata(_metadata);\n    }\n\n    /// @inheritdoc IDAO\n    function execute(\n        bytes32 _callId,\n        Action[] calldata _actions,\n        uint256 _allowFailureMap\n    )\n        external\n        override\n        auth(EXECUTE_PERMISSION_ID)\n        returns (bytes[] memory execResults, uint256 failureMap)\n    {\n        if (_actions.length > MAX_ACTIONS) {\n            revert TooManyActions();\n        }\n\n        execResults = new bytes[](_actions.length);\n\n        for (uint256 i = 0; i < _actions.length; ) {\n            address to = _actions[i].to;\n            (bool success, bytes memory response) = to.call{value: _actions[i].value}(\n                _actions[i].data\n            );\n\n            if (!success) {\n                // If the call failed and wasn't allowed in allowFailureMap, revert.\n                if (!hasBit(_allowFailureMap, uint8(i))) {\n                    revert ActionFailed(i);\n                }\n\n                // If the call failed, but was allowed in allowFailureMap, store that\n                // this specific action has actually failed.\n                failureMap = flipBit(failureMap, uint8(i));\n            }\n\n            execResults[i] = response;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit Executed({\n            actor: msg.sender,\n            callId: _callId,\n            actions: _actions,\n            failureMap: failureMap,\n            execResults: execResults\n        });\n    }\n\n    /// @inheritdoc IDAO\n    function deposit(\n        address _token,\n        uint256 _amount,\n        string calldata _reference\n    ) external payable override {\n        if (_amount == 0) revert ZeroAmount();\n\n        if (_token == address(0)) {\n            if (msg.value != _amount)\n                revert NativeTokenDepositAmountMismatch({expected: _amount, actual: msg.value});\n        } else {\n            if (msg.value != 0)\n                revert NativeTokenDepositAmountMismatch({expected: 0, actual: msg.value});\n\n            IERC20Upgradeable(_token).safeTransferFrom(msg.sender, address(this), _amount);\n        }\n\n        emit Deposited(msg.sender, _token, _amount, _reference);\n    }\n\n    /// @inheritdoc IDAO\n    function setSignatureValidator(\n        address _signatureValidator\n    ) external override auth(SET_SIGNATURE_VALIDATOR_PERMISSION_ID) {\n        signatureValidator = IERC1271(_signatureValidator);\n\n        emit SignatureValidatorSet({signatureValidator: _signatureValidator});\n    }\n\n    /// @inheritdoc IDAO\n    function isValidSignature(\n        bytes32 _hash,\n        bytes memory _signature\n    ) external view override(IDAO, IERC1271) returns (bytes4) {\n        if (address(signatureValidator) == address(0)) {\n            // Return the invalid magic number\n            return bytes4(0);\n        }\n        // Forward the call to the set signature validator contract\n        return signatureValidator.isValidSignature(_hash, _signature);\n    }\n\n    /// @notice Emits the `NativeTokenDeposited` event to track native token deposits that weren't made via the deposit method.\n    /// @dev This call is bound by the gas limitations for `send`/`transfer` calls introduced by EIP-2929.\n    /// Gas cost increases in future hard forks might break this function. As an alternative, EIP-2930-type transactions using access lists can be employed.\n    receive() external payable {\n        emit NativeTokenDeposited(msg.sender, msg.value);\n    }\n\n    /// @notice Fallback to handle future versions of the [ERC-165](https://eips.ethereum.org/EIPS/eip-165) standard.\n    /// @param _input An alias being equivalent to `msg.data`. This feature of the fallback function was introduced with the [solidity compiler version 0.7.6](https://github.com/ethereum/solidity/releases/tag/v0.7.6)\n    /// @return The magic number registered for the function selector triggering the fallback.\n    fallback(bytes calldata _input) external returns (bytes memory) {\n        bytes4 magicNumber = _handleCallback(msg.sig, _input);\n        return abi.encode(magicNumber);\n    }\n\n    /// @notice Emits the MetadataSet event if new metadata is set."
    }
  ]
}