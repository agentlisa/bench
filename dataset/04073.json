{
  "Title": "[L10] Casting between types without overflow checks",
  "Content": "In our prior audit of the Notional system, we raised an issue about unsafe casting between types. During their initial response to the prior audit, they partially addressed our concerns. The few persistent instances of the issue were to be removed prior to this audit.\n\n\nHowever, the codebase is not yet entirely free of this issue. There are still a few instances of explicit casts that, in scenarios that may well be unlikely to happen, could result in an undesirable truncation leading to unexpected values. *Some examples* are:\n\n\n* Within the functions `_convertToETH` [on line 49 of `ExchangeRate.sol`](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/utils/ExchangeRate.sol#L49) and `_convertETHTo` on [line 80 of `ExchangeRate.sol`](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/utils/ExchangeRate.sol#L80), the `int256` `balance` input is explicitly cast to a `uint128`.\n* Within the `_calculateNotionalToTransfer` function [on line 816 of `Portfolios.sol`](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/Portfolios.sol#L816).\n\n\nConsider using the `SafeCast` library for the casting operations cited in the examples, and wherever else possible, to ensure those type casts cannot corrupt values and lead to undesirable system behavior.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/utils/ExchangeRate.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../lib/SafeInt256.sol\";\nimport \"../lib/SafeMath.sol\";\nimport \"../utils/Common.sol\";\nimport \"../interface/IAggregator.sol\";\n\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\n\n\nlibrary ExchangeRate {\n    using SafeInt256 for int256;\n    using SafeMath for uint256;\n\n    /**\n     * Exchange rates between currencies\n     */\n    struct Rate {\n        // The address of the chainlink price oracle\n        address rateOracle;\n        // The decimals of precision that the rate oracle uses\n        uint128 rateDecimals;\n        // True of the exchange rate must be inverted\n        bool mustInvert;\n        // Amount of buffer to apply to the exchange rate, this defines the collateralization ratio\n        // between the two currencies. This must be stored with 18 decimal precision because it is used\n        // to convert to an ETH balance.\n        uint128 buffer;\n    }\n\n    /**\n     * @notice Converts a balance between token addresses.\n     *\n     * @param er exchange rate object from base to ETH\n     * @param baseDecimals decimals for base currency\n     * @param balance amount to convert\n     * @return the converted balance denominated in ETH with 18 decimal places\n     */\n    function _convertToETH(\n        Rate memory er,\n        uint256 baseDecimals,\n        int256 balance,\n        bool buffer\n    ) internal view returns (int256) {\n        // Fetches the latest answer from the chainlink oracle and buffer it by the apporpriate amount.\n        uint256 rate = _fetchExchangeRate(er, false);\n        uint128 absBalance = uint128(balance.abs());\n\n        // We are converting to ETH here so we know that it has Common.DECIMAL precision. The calculation here is:\n        // baseDecimals * rateDecimals * Common.DECIMAL /  (rateDecimals * baseDecimals)\n        // er.buffer is in Common.DECIMAL precision\n        // We use uint256 to do the calculation and then cast back to int256 to avoid overflows.\n        int256 result = int256(\n            SafeCast.toUint128(rate\n                .mul(absBalance)\n                // Buffer has 18 decimal places of precision\n                .mul(buffer ? er.buffer : Common.DECIMALS)\n                .div(er.rateDecimals)\n                .div(baseDecimals)\n            )\n        );\n\n        return balance > 0 ? result : result.neg();\n    }\n\n    /**\n     * @notice Converts the balance denominated in ETH to the equivalent value in base.\n     * @param er exchange rate object from base to ETH\n     * @param baseDecimals decimals for base currency\n     * @param balance amount (denominated in ETH) to convert\n     */\n    function _convertETHTo(\n        Rate memory er,\n        uint256 baseDecimals,\n        int256 balance\n    ) internal view returns (int256) {\n        uint256 rate = _fetchExchangeRate(er, true);\n        uint128 absBalance = uint128(balance.abs());\n\n        // We are converting from ETH here so we know that it has Common.DECIMAL precision. The calculation here is:\n        // ethDecimals * rateDecimals * baseDecimals / (ethDecimals * rateDecimals)\n        // er.buffer is in Common.DECIMAL precision\n        // We use uint256 to do the calculation and then cast back to int256 to avoid overflows.\n        int256 result = int256(\n            SafeCast.toUint128(rate\n                .mul(absBalance)\n                .mul(baseDecimals)\n                .div(Common.DECIMALS)\n                .div(er.rateDecimals)\n            )\n        );\n\n        return balance > 0 ? result : result.neg();\n    }\n\n    function _fetchExchangeRate(Rate memory er, bool invert) internal view returns (uint256) {\n        int256 rate = IAggregator(er.rateOracle).latestAnswer();\n        require(rate > 0, $$(ErrorCode(INVALID_EXCHANGE_RATE)));\n\n        if (invert || (er.mustInvert && !invert)) {\n            // If the ER is inverted and we're NOT asking to invert then we need to invert the rate here.\n            return uint256(er.rateDecimals).mul(er.rateDecimals).div(uint256(rate));\n        }\n\n        return uint256(rate);\n    }\n\n    /**\n     * @notice Calculates the exchange rate between two currencies via ETH. Returns the rate.\n     */\n    function _exchangeRate(Rate memory baseER, Rate memory quoteER, uint16 quote) internal view returns (uint256) {\n        uint256 rate = _fetchExchangeRate(baseER, false);\n\n        if (quote != 0) {\n            uint256 quoteRate = _fetchExchangeRate(quoteER, false);\n\n            rate = rate.mul(quoteER.rateDecimals).div(quoteRate);\n        }\n\n        return rate;\n    }\n\n}"
    },
    {
      "filename": "contracts/Portfolios.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./utils/Common.sol\";\nimport \"./utils/Governed.sol\";\n\nimport \"./lib/SafeMath.sol\";\nimport \"./lib/SafeInt256.sol\";\nimport \"./lib/SafeUInt128.sol\";\nimport \"./utils/RiskFramework.sol\";\n\nimport \"./interface/IRateOracle.sol\";\nimport \"./interface/IPortfoliosCallable.sol\";\n\nimport \"./storage/PortfoliosStorage.sol\";\nimport \"./CashMarket.sol\";\n\n/**\n * @title Portfolios\n * @notice Manages account portfolios which includes all fCash positions and liquidity tokens.\n */\ncontract Portfolios is PortfoliosStorage, IPortfoliosCallable, Governed {\n    using SafeMath for uint256;\n    using SafeInt256 for int256;\n    using SafeUInt128 for uint128;\n\n    struct TradePortfolioState {\n        uint128 amountRemaining;\n        uint256 indexCount;\n        int256 unlockedCurrentCash;\n        Common.Asset[] portfolioChanges;\n    }\n\n    /**\n     * @notice Emitted when an account has its portfolio settled, only emitted if the portfolio has changed\n     * @param account the account that had its porfolio modified\n     */\n    event SettleAccount(address account);\n\n    /**\n     * @notice Emitted when an account has its portfolio settled, all accounts are emitted in the batch\n     * @param accounts batch of accounts that *may* have been settled\n     */\n    event SettleAccountBatch(address[] accounts);\n\n    /**\n     * @notice Emitted when a new cash group is listed\n     * @param cashGroupId id of the new cash group\n     */\n    event NewCashGroup(uint8 indexed cashGroupId);\n\n    /**\n     * @notice Emitted when a new cash group is updated\n     * @param cashGroupId id of the updated cash group\n     */\n    event UpdateCashGroup(uint8 indexed cashGroupId);\n\n    /**\n     * @notice Emitted when max assets is set\n     * @param maxAssets the max assets a portfolio can hold\n     */\n    event SetMaxAssets(uint256 maxAssets);\n\n    /**\n     * @notice Notice for setting haircut amount for liquidity tokens\n     * @param liquidityHaircut amount of haircut applied to liquidity token claims \n     * @param fCashHaircut amount of negative haircut applied to fcash\n     * @param fCashMaxHaircut max haircut amount applied to fcash\n     */\n    event SetHaircuts(uint128 liquidityHaircut, uint128 fCashHaircut, uint128 fCashMaxHaircut);\n\n    /**\n     * @dev skip\n     * @param directory holds contract addresses for dependencies\n     * @param numCurrencies initializes the number of currencies listed on the escrow contract\n     * @param maxAssets max assets that a portfolio can hold\n     */\n    function initialize(address directory, address owner, uint16 numCurrencies, uint256 maxAssets) external initializer {\n        Governed.initialize(directory, owner);\n\n        // We must initialize this here because it cannot be a constant.\n        NULL_ASSET = Common.Asset(0, 0, 0, 0, 0, 0);\n        G_NUM_CURRENCIES = numCurrencies;\n        G_MAX_ASSETS = maxAssets;\n\n        emit SetMaxAssets(maxAssets);\n    }\n\n    /****** Governance Parameters ******/\n\n    /**\n     * @notice Sets the haircut amount for liquidity token claims, this is set to a percentage\n     * less than 1e18, for example, a 5% haircut will be set to 0.95e18.\n     * @dev governance\n     * @param liquidityHaircut amount of negative haircut applied to token claims\n     * @param fCashHaircut amount of negative haircut applied to fcash\n     * @param fCashMaxHaircut max haircut amount applied to fcash\n     */\n    function setHaircuts(uint128 liquidityHaircut, uint128 fCashHaircut, uint128 fCashMaxHaircut) external onlyOwner {\n        PortfoliosStorageSlot._setLiquidityHaircut(liquidityHaircut);\n        PortfoliosStorageSlot._setfCashHaircut(fCashHaircut);\n        PortfoliosStorageSlot._setfCashMaxHaircut(fCashMaxHaircut);\n        Escrow().setLiquidityHaircut(liquidityHaircut);\n\n        emit SetHaircuts(liquidityHaircut, fCashHaircut, fCashMaxHaircut);\n    }\n\n    /**\n     * @dev skip\n     * @param numCurrencies the total number of currencies set by escrow\n     */\n    function setNumCurrencies(uint16 numCurrencies) external override {\n        require(calledByEscrow(), $$(ErrorCode(UNAUTHORIZED_CALLER)));\n        G_NUM_CURRENCIES = numCurrencies;\n    }\n\n    /**\n     * @notice Set the max assets that a portfolio can hold. The default will be initialized to something\n     * like 10 assets, but this will be increased as new markets are created.\n     * @dev governance\n     * @param maxAssets new max asset number\n     */\n    function setMaxAssets(uint256 maxAssets) external onlyOwner {\n        G_MAX_ASSETS = maxAssets;\n\n        emit SetMaxAssets(maxAssets);\n    }\n\n    /**\n     * @notice An cash group defines a collection of similar fCashs where the risk ladders can be netted\n     * against each other. The identifier is only 1 byte so we can only have 255 cash groups, 0 is unused.\n     * @dev governance\n     * @param numMaturities the total number of maturitys\n     * @param maturityLength the maturity length (in seconds)\n     * @param precision the discount rate precision\n     * @param currency the token address of the currenty this fCash settles in\n     * @param cashMarket the rate oracle that defines the discount rate\n     */\n    function createCashGroup(\n        uint32 numMaturities,\n        uint32 maturityLength,\n        uint32 precision,\n        uint16 currency,\n        address cashMarket\n    ) external onlyOwner {\n        require(currentCashGroupId <= MAX_CASH_GROUPS, $$(ErrorCode(OVER_CASH_GROUP_LIMIT)));\n        require(Escrow().isValidCurrency(currency), $$(ErrorCode(INVALID_CURRENCY)));\n\n        currentCashGroupId++;\n        cashGroups[currentCashGroupId] = Common.CashGroup(\n            numMaturities,\n            maturityLength,\n            precision,\n            cashMarket,\n            currency\n        );\n\n        if (cashMarket == address(0)) {\n            // If cashMarket is set to address 0, then it is an idiosyncratic cash group that does not have\n            // an AMM that will trade it. It can only be traded off chain and created via mintfCashPair\n            require(numMaturities == 1);\n        } else if (cashMarket != address(0)) {\n            // The fCash is set to 0 for discount rate oracles and there is no max rate as well.\n            IRateOracle(cashMarket).setParameters(currentCashGroupId, 0, precision, maturityLength, numMaturities, 0);\n        }\n\n        emit NewCashGroup(currentCashGroupId);\n    }\n\n    /**\n     * @notice Updates cash groups. Be very careful when calling this function! When changing maturities and\n     * maturity sizes the markets must be updated as well.\n     * @dev governance\n     * @param cashGroupId the group id to update\n     * @param numMaturities this is safe to update as long as the discount rate oracle is not shared\n     * @param maturityLength this is only safe to update when there are no assets left\n     * @param precision this is only safe to update when there are no assets left\n     * @param currency this is safe to update if there are no assets or the new currency is equivalent\n     * @param cashMarket this is safe to update once the oracle is established\n     */\n    function updateCashGroup(\n        uint8 cashGroupId,\n        uint32 numMaturities,\n        uint32 maturityLength,\n        uint32 precision,\n        uint16 currency,\n        address cashMarket\n    ) external onlyOwner {\n        require(\n            cashGroupId != 0 && cashGroupId <= currentCashGroupId,\n            $$(ErrorCode(INVALID_CASH_GROUP))\n        );\n        require(Escrow().isValidCurrency(currency), $$(ErrorCode(INVALID_CURRENCY)));\n\n        Common.CashGroup storage i = cashGroups[cashGroupId];\n        if (i.numMaturities != numMaturities) i.numMaturities = numMaturities;\n        if (i.maturityLength != maturityLength) i.maturityLength = maturityLength;\n        if (i.precision != precision) i.precision = precision;\n        if (i.currency != currency) i.currency = currency;\n        if (i.cashMarket != cashMarket) i.cashMarket = cashMarket;\n\n        // The fCash is set to 0 for discount rate oracles and there is no max rate as well.\n        IRateOracle(cashMarket).setParameters(cashGroupId, 0, precision, maturityLength, numMaturities, 0);\n\n        emit UpdateCashGroup(cashGroupId);\n    }\n\n    /****** Governance Parameters ******/\n\n    /***** Public View Methods *****/\n\n    /**\n     * @notice Returns the assets of an account\n     * @param account to retrieve\n     * @return an array representing the account's portfolio\n     */\n    function getAssets(address account) public override view returns (Common.Asset[] memory) {\n        return _accountAssets[account];\n    }\n\n    /**\n     * @notice Returns a particular asset via index\n     * @param account to retrieve\n     * @param index of asset\n     * @return a single asset by index in the portfolio\n     */\n    function getAsset(address account, uint256 index) public view returns (Common.Asset memory) {\n        return _accountAssets[account][index];\n    }\n\n    /**\n     * @notice Returns a particular cash group\n     * @param cashGroupId to retrieve\n     * @return the given cash group\n     */\n    function getCashGroup(uint8 cashGroupId) public override view returns (Common.CashGroup memory) {\n        return cashGroups[cashGroupId];\n    }\n\n    /**\n     * @notice Returns a batch of cash groups\n     * @param groupIds array of cash group ids to retrieve\n     * @return an array of cash group objects\n     */\n    function getCashGroups(uint8[] memory groupIds) public override view returns (Common.CashGroup[] memory) {\n        Common.CashGroup[] memory results = new Common.CashGroup[](groupIds.length);\n\n        for (uint256 i; i < groupIds.length; i++) {\n            results[i] = cashGroups[groupIds[i]];\n        }\n\n        return results;\n    }\n\n    /**\n     * @notice Public method for searching for a asset in an account.\n     * @param account account to search\n     * @param assetType the type of asset to search for\n     * @param cashGroupId the cash group id\n     * @param instrumentId the instrument id\n     * @param maturity the maturity timestamp of the asset\n     * @return (asset, index of asset)\n     */\n    function searchAccountAsset(\n        address account,\n        bytes1 assetType,\n        uint8 cashGroupId,\n        uint16 instrumentId,\n        uint32 maturity\n    ) public override view returns (Common.Asset memory, uint256) {\n        Common.Asset[] storage portfolio = _accountAssets[account];\n        (\n            bool found, uint256 index, /* uint128 */, /* bool */ \n        ) = _searchAsset(portfolio, assetType, cashGroupId, instrumentId, maturity, false);\n\n        if (!found) return (NULL_ASSET, index);\n\n        return (portfolio[index], index);\n    }\n\n    /**\n     * @notice Stateful version of free collateral, first settles all assets in the account before returning\n     * the free collateral parameters. Generally, external developers should not need to call this function. It is used\n     * internally to both check free collateral and ensure that the portfolio does not have any matured assets.\n     * Call `freeCollateralView` if you require a view function.\n     * @param account address of account to get free collateral for\n     * @return (net free collateral position, an array of the net currency available)\n     */\n    function freeCollateral(address account) public override returns (int256, int256[] memory, int256[] memory) {\n        // This will emit an event, which is the correct action here.\n        settleMaturedAssets(account);\n\n        return freeCollateralView(account);\n    }\n\n    function freeCollateralAggregateOnly(address account) public override returns (int256) {\n        // This will emit an event, which is the correct action here.\n        settleMaturedAssets(account);\n        \n        (int256 fc, /* int256[] memory */, /* int256[] memory */) = freeCollateralView(account);\n\n        return fc;\n    }\n\n    /**\n     * @notice Stateful version of free collateral called during settlement and liquidation.\n     * @dev skip\n     * @param account address of account to get free collateral for\n     * @param localCurrency local currency for the liquidation\n     * @param collateralCurrency collateral currency for the liquidation\n     * @return FreeCollateralFactors object\n     */\n    function freeCollateralFactors(\n        address account,\n        uint256 localCurrency,\n        uint256 collateralCurrency\n    ) public override returns (Common.FreeCollateralFactors memory) {\n        require(calledByEscrow(), $$(ErrorCode(UNAUTHORIZED_CALLER)));\n        // This will not emit an event, which is the correct action here.\n        _settleMaturedAssets(account);\n\n        (int256 fc, int256[] memory netCurrencyAvailable, int256[] memory cashClaims) = freeCollateralView(account);\n\n        return Common.FreeCollateralFactors(\n            fc,\n            netCurrencyAvailable[localCurrency],\n            netCurrencyAvailable[collateralCurrency],\n            cashClaims[localCurrency],\n            cashClaims[collateralCurrency]\n        );\n    }\n\n    /**\n     * @notice Returns the free collateral balance for an account as a view functon.\n     * @dev - INVALID_EXCHANGE_RATE: exchange rate returned by the oracle is less than 0\n     * @param account account in question\n     * @return (net free collateral position, an array of the net currency available)\n     */\n    function freeCollateralView(address account) public override view returns (int256, int256[] memory, int256[] memory) {\n        int256[] memory balances = Escrow().getBalances(account);\n        return _freeCollateral(account, balances);\n    }\n\n    function _freeCollateral(address account, int256[] memory balances) internal view returns (int256, int256[] memory, int256[] memory) {\n        Common.Asset[] memory portfolio = _accountAssets[account];\n        int256[] memory cashClaims = new int256[](balances.length);\n\n        if (portfolio.length > 0) {\n            // This returns the net requirement in each currency held by the portfolio.\n            Common.Requirement[] memory requirements = RiskFramework.getRequirement(\n                portfolio,\n                address(this)\n            );\n\n            for (uint256 i; i < requirements.length; i++) {\n                uint256 currency = uint256(requirements[i].currency);\n                cashClaims[currency] = cashClaims[currency].add(requirements[i].cashClaim);\n                balances[currency] = balances[currency].add(requirements[i].cashClaim).add(requirements[i].netfCashValue);\n            }\n        }\n\n        // Collateral requirements are denominated in ETH and positive.\n        int256[] memory ethBalances = Escrow().convertBalancesToETH(balances);\n\n        // Sum up the required balances in ETH\n        int256 fc;\n        for (uint256 i; i < balances.length; i++) {\n            fc = fc.add(ethBalances[i]);\n        }\n\n        return (fc, balances, cashClaims);\n    }\n\n    /***** Public Authenticated Methods *****/\n\n    /**\n     * @notice Updates the portfolio of an account with a asset, merging it into the rest of the\n     * portfolio if necessary.\n     * @dev skip\n     * @param account to insert the asset to\n     * @param asset asset to insert into the account\n     * @param checkFreeCollateral allows free collateral check to be skipped (BE CAREFUL WITH THIS!)\n     */\n    function upsertAccountAsset(\n        address account,\n        Common.Asset calldata asset,\n        bool checkFreeCollateral\n    ) external override {\n        // Only the fCash market can insert assets into a portfolio\n        address cashMarket = cashGroups[asset.cashGroupId].cashMarket;\n        require(msg.sender == cashMarket, $$(ErrorCode(UNAUTHORIZED_CALLER)));\n\n        Common.Asset[] storage portfolio = _accountAssets[account];\n        _upsertAsset(portfolio, asset, false);\n\n        if (checkFreeCollateral) {\n            (\n                int256 fc, /* int256[] memory */, /* int256[] memory */\n            ) = freeCollateral(account);\n            require(fc >= 0, $$(ErrorCode(INSUFFICIENT_FREE_COLLATERAL)));\n        }\n    }\n\n    /**\n     * @notice Updates the portfolio of an account with a batch of assets, merging it into the rest of the\n     * portfolio if necessary.\n     * @dev skip\n     * @param account to insert the assets into\n     * @param assets array of assets to insert into the account\n     * @param checkFreeCollateral allows free collateral check to be skipped (BE CAREFUL WITH THIS!)\n     */\n    function upsertAccountAssetBatch(\n        address account,\n        Common.Asset[] calldata assets,\n        bool checkFreeCollateral\n    ) external override {\n        if (assets.length == 0) {\n            return;\n        }\n\n        // Here we check that all the cash group ids are the same if the liquidation auction\n        // is not calling this function. If this is not the case then we have an issue. Cash markets\n        // should only ever call this function with the same cash group id for all the assets\n        // they submit.\n        uint16 id = assets[0].cashGroupId;\n        for (uint256 i = 1; i < assets.length; i++) {\n            require(assets[i].cashGroupId == id, $$(ErrorCode(INVALID_ASSET_BATCH)));\n        }\n\n        address cashMarket = cashGroups[assets[0].cashGroupId].cashMarket;\n        require(msg.sender == cashMarket, $$(ErrorCode(UNAUTHORIZED_CALLER)));\n\n        Common.Asset[] storage portfolio = _accountAssets[account];\n        for (uint256 i; i < assets.length; i++) {\n            _upsertAsset(portfolio, assets[i], false);\n        }\n\n        if (checkFreeCollateral) {\n            (\n                int256 fc, /* int256[] memory */, /* int256[] memory */\n            ) = freeCollateral(account);\n            require(fc >= 0, $$(ErrorCode(INSUFFICIENT_FREE_COLLATERAL)));\n        }\n    }\n\n    /**\n     * @notice Transfers a asset from one account to another.\n     * @dev skip\n     * @param from account to transfer from\n     * @param to account to transfer to\n     * @param assetType the type of asset to search for\n     * @param cashGroupId the cash group id\n     * @param instrumentId the instrument id\n     * @param maturity the maturity of the asset\n     * @param value the amount of notional transfer between accounts\n     */\n    function transferAccountAsset(\n        address from,\n        address to,\n        bytes1 assetType,\n        uint8 cashGroupId,\n        uint16 instrumentId,\n        uint32 maturity,\n        uint128 value\n    ) external override {\n        // Can only be called by ERC1155 token to transfer assets between accounts.\n        require(calledByERC1155Token(), $$(ErrorCode(UNAUTHORIZED_CALLER)));\n\n        Common.Asset[] storage fromPortfolio = _accountAssets[from];\n        (\n            bool found, uint256 index, /* uint128 */, /* bool */\n        ) = _searchAsset(fromPortfolio, assetType, cashGroupId, instrumentId, maturity, false);\n        require(found, $$(ErrorCode(ASSET_NOT_FOUND)));\n\n        uint32 rate = fromPortfolio[index].rate;\n        _reduceAsset(fromPortfolio, fromPortfolio[index], index, value);\n\n        Common.Asset[] storage toPortfolio = _accountAssets[to];\n        _upsertAsset(\n            toPortfolio,\n            Common.Asset(cashGroupId, instrumentId, maturity, assetType, rate, value),\n            false\n        );\n\n        // All transfers of assets must pass a free collateral check.\n        (\n            int256 fc, /* int256[] memory */, /* int256[] memory */\n        ) = freeCollateral(from);\n        require(fc >= 0, $$(ErrorCode(INSUFFICIENT_FREE_COLLATERAL)));\n\n        // Receivers of transfers do not need to pass a free collateral check because we only allow transfers\n        // of positive value. Their free collateral position will always increase.\n    }\n\n    /**\n     * @notice Used by ERC1155 token contract to create block trades for fCash pairs. Allows idiosyncratic\n     * fCash when cashGroup is set to zero.\n     * @dev skip\n     */\n    function mintfCashPair(\n        address payer,\n        address receiver,\n        uint8 cashGroupId,\n        uint32 maturity,\n        uint128 notional\n    ) external override {\n        require(calledByERC1155Trade(), $$(ErrorCode(UNAUTHORIZED_CALLER)));\n        require(cashGroupId != 0 && cashGroupId <= currentCashGroupId, $$(ErrorCode(INVALID_CASH_GROUP)));\n\n        uint32 blockTime = uint32(block.timestamp);\n        require(blockTime < maturity, $$(ErrorCode(TRADE_MATURITY_ALREADY_PASSED)));\n\n        Common.CashGroup memory fcg = cashGroups[cashGroupId];\n\n        uint32 maxMaturity;\n        if (fcg.cashMarket != address(0)) {\n            // This is a cash group that is traded on an AMM so we ensure that the maturity fits\n            // the cadence.\n            require(maturity % fcg.maturityLength == 0, $$(ErrorCode(INVALID_SWAP)));\n\n            maxMaturity = blockTime - (blockTime % fcg.maturityLength) + (fcg.maturityLength * fcg.numMaturities);\n        } else {\n            // This is an idiosyncratic asset so its max maturity is simply relative to the current time\n            maxMaturity = blockTime + fcg.maturityLength;\n        }\n        require(maturity <= maxMaturity, $$(ErrorCode(PAST_MAX_MATURITY)));\n\n\n        _upsertAsset(\n            _accountAssets[payer],\n            Common.Asset(\n                cashGroupId,\n                0,\n                maturity,\n                Common.getCashPayer(),\n                fcg.precision,\n                notional\n            ),\n            false\n        );\n\n        _upsertAsset(\n            _accountAssets[receiver],\n            Common.Asset(\n                cashGroupId,\n                0,\n                maturity,\n                Common.getCashReceiver(),\n                fcg.precision,\n                notional\n            ),\n            false\n        );\n\n        (int256 fc, /* int256[] memory */, /* int256[] memory */) = freeCollateral(payer);\n        require(fc >= 0, $$(ErrorCode(INSUFFICIENT_FREE_COLLATERAL)));\n\n        // NOTE: we do not check that the receiver has sufficient free collateral because their collateral\n        // position will always increase as a result.\n    }\n\n    /**\n     * @notice Settles all matured cash assets and liquidity tokens in a user's portfolio. This method is\n     * unauthenticated, anyone may settle the assets in any account. This is required for accounts that\n     * have negative cash and counterparties need to settle against them. Generally, external developers\n     * should not need to call this function. We ensure that accounts are settled on every free collateral\n     * check, cash settlement, and liquidation.\n     * @param account the account referenced\n     */\n    function settleMaturedAssets(address account) public override {\n        bool didSettle = _settleMaturedAssets(account);\n\n        if (didSettle) {\n            emit SettleAccount(account);\n        }\n    }\n\n    /**\n     * @notice Settle a batch of accounts. See note for `settleMaturedAssets`, external developers should not need\n     * to call this function.\n     * @param accounts an array of accounts to settle\n     */\n    function settleMaturedAssetsBatch(address[] calldata accounts) external override {\n        for (uint256 i; i < accounts.length; i++) {\n            _settleMaturedAssets(accounts[i]);\n        }\n\n        // We do not want to emit when this is called by escrow during settle cash.\n        if (!calledByEscrow()) {\n            emit SettleAccountBatch(accounts);\n        }\n    }\n\n    /**\n     * @notice Settles all matured cash assets and liquidity tokens in a user's portfolio. This method is\n     * unauthenticated, anyone may settle the assets in any account. This is required for accounts that\n     * have negative cash and counterparties need to settle against them.\n     * @param account the account referenced\n     * @return true if the account had any assets that were settled, used to determine if we emit\n     * an event or not\n     */\n    function _settleMaturedAssets(address account) internal returns (bool) {\n        bool didSettle = false;\n        Common.Asset[] storage portfolio = _accountAssets[account];\n        uint32 blockTime = uint32(block.timestamp);\n\n        // This is only used when merging the account's portfolio for updating cash balances in escrow. We\n        // keep this here so that we can do a single function call to settle all the cash in Escrow.\n        int256[] memory settledCash = new int256[](uint256(G_NUM_CURRENCIES + 1));\n        uint256 length = portfolio.length;\n\n        // Loop through the portfolio and find the assets that have matured.\n        for (uint256 i; i < length; i++) {\n            if (portfolio[i].maturity <= blockTime) {\n                Common.Asset memory asset = portfolio[i];\n                // Here we are dealing with a matured asset. We get the appropriate currency for\n                // the instrument. We may want to cache this somehow, but in all likelihood there\n                // will not be multiple matured assets in the same cash group.\n                Common.CashGroup memory fcg = cashGroups[asset.cashGroupId];\n                uint16 currency = fcg.currency;\n\n                if (Common.isCashPayer(asset.assetType)) {\n                    // If the asset is a payer, we subtract from the cash balance\n                    settledCash[currency] = settledCash[currency].sub(asset.notional);\n                } else if (Common.isCashReceiver(asset.assetType)) {\n                    // If the asset is a receiver, we add to the cash balance\n                    settledCash[currency] = settledCash[currency].add(asset.notional);\n                } else if (Common.isLiquidityToken(asset.assetType)) {\n                    // Settling liquidity tokens is a bit more involved since we need to remove\n                    // money from the collateral pools. This function returns the amount of fCash\n                    // the liquidity token has a claim to.\n                    address cashMarket = fcg.cashMarket;\n                    // This function call will transfer the collateral claim back to the Escrow account.\n                    uint128 fCashAmount = CashMarket(cashMarket).settleLiquidityToken(\n                        account,\n                        asset.notional,\n                        asset.maturity\n                    );\n                    settledCash[currency] = settledCash[currency].add(fCashAmount);\n                } else {\n                    revert($$(ErrorCode(INVALID_SWAP)));\n                }\n\n                // Remove asset from the portfolio\n                _removeAsset(portfolio, i);\n                // The portfolio has gotten smaller, so we need to go back to account for the removed asset.\n                i--;\n                length = length == 0 ? 0 : length - 1;\n                didSettle = true;\n            }\n        }\n\n        // We call the escrow contract to update the account's cash balances.\n        if (didSettle) {\n            Escrow().portfolioSettleCash(account, settledCash);\n        }\n\n        return didSettle;\n    }\n\n    /***** Public Authenticated Methods *****/\n\n    /***** Liquidation Methods *****/\n\n    /**\n     * @notice Looks for ways to take cash from the portfolio and return it to the escrow contract during\n     * cash settlement.\n     * @dev skip\n     * @param account the account to extract cash from\n     * @param currency the currency that the token should be denominated in\n     * @param amount the amount of cash to extract from the portfolio\n     * @return returns the amount of remaining cash value (if any) that the function was unable\n     *  to extract from the portfolio\n     */\n    function raiseCurrentCashViaLiquidityToken(\n        address account,\n        uint16 currency,\n        uint128 amount\n    ) external override returns (uint128) {\n        // Sorting the portfolio ensures that as we iterate through it we see each cash group\n        // in batches. However, this means that we won't be able to track the indexes to remove correctly.\n        Common.Asset[] memory portfolio = Common._sortPortfolio(_accountAssets[account]);\n        TradePortfolioState memory state = _tradePortfolio(account, currency, amount, Common.getLiquidityToken(), portfolio);\n\n        re"
    }
  ]
}