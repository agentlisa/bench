{
  "Title": "Sleep Is Used to Wait for Channel Readiness",
  "Content": "The [sleep is used to wait `0.1 ms`](https://github.com/mantlenetworkio/mantle-v2/blob/bb0ff7002520ee936101c4c263ac02a66e7e3c96/op-node/rollup/driver/state.go#L201-L205) for `sequencerCh` and `stepReqCh` to be ready. While this might mitigate the issue in the testing environment, it might behave differently in the production environment where load might be different and thus the sleep time might not provide the desired effect.\n\n\nConsider refactoring the code to avoid using sleep and instead using more reliable mechanisms to sync the channels.\n\n\n***Update:** Not resolved. The Mantle team stated:*\n\n\n\n> *Not a valid issue.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "op-node/rollup/driver/state.go",
      "content": "package driver\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\tgosync \"sync\"\n\t\"time\"\n\n\t\"github.com/ethereum/go-ethereum/common\"\n\t\"github.com/ethereum/go-ethereum/log\"\n\n\t\"github.com/ethereum-optimism/optimism/op-node/eth\"\n\t\"github.com/ethereum-optimism/optimism/op-node/rollup\"\n\t\"github.com/ethereum-optimism/optimism/op-node/rollup/derive\"\n\t\"github.com/ethereum-optimism/optimism/op-service/backoff\"\n)\n\n// Deprecated: use eth.SyncStatus instead.\ntype SyncStatus = eth.SyncStatus\n\n// sealingDuration defines the expected time it takes to seal the block\nconst sealingDuration = time.Millisecond * 50\n\ntype Driver struct {\n\tl1State L1StateIface\n\n\t// The derivation pipeline is reset whenever we reorg.\n\t// The derivation pipeline determines the new l2Safe.\n\tderivation DerivationPipeline\n\n\t// Requests to block the event loop for synchronous execution to avoid reading an inconsistent state\n\tstateReq chan chan struct{}\n\n\t// Upon receiving a channel in this channel, the derivation pipeline is forced to be reset.\n\t// It tells the caller that the reset occurred by closing the passed in channel.\n\tforceReset chan chan struct{}\n\n\t// Upon receiving a hash in this channel, the sequencer is started at the given hash.\n\t// It tells the caller that the sequencer started by closing the passed in channel (or returning an error).\n\tstartSequencer chan hashAndErrorChannel\n\n\t// Upon receiving a channel in this channel, the sequencer is stopped.\n\t// It tells the caller that the sequencer stopped by returning the latest sequenced L2 block hash.\n\tstopSequencer chan chan hashAndError\n\n\t// Rollup config: rollup chain configuration\n\tconfig *rollup.Config\n\n\t// Driver config: verifier and sequencer settings\n\tdriverConfig *Config\n\n\t// L1 Signals:\n\t//\n\t// Not all L1 blocks, or all changes, have to be signalled:\n\t// the derivation process traverses the chain and handles reorgs as necessary,\n\t// the driver just needs to be aware of the *latest* signals enough so to not\n\t// lag behind actionable data.\n\tl1HeadSig      chan eth.L1BlockRef\n\tl1SafeSig      chan eth.L1BlockRef\n\tl1FinalizedSig chan eth.L1BlockRef\n\n\t// Interface to signal the L2 block range to sync.\n\taltSync AltSync\n\n\t// L2 Signals:\n\n\tunsafeL2Payloads chan *eth.ExecutionPayload\n\n\tl1        L1Chain\n\tl2        L2Chain\n\tsequencer SequencerIface\n\tnetwork   Network // may be nil, network for is optional\n\n\tmetrics     Metrics\n\tlog         log.Logger\n\tsnapshotLog log.Logger\n\tdone        chan struct{}\n\n\twg gosync.WaitGroup\n}\n\n// Start starts up the state loop.\n// The loop will have been started iff err is not nil.\nfunc (s *Driver) Start() error {\n\ts.derivation.Reset()\n\n\ts.wg.Add(1)\n\tgo s.eventLoop()\n\n\treturn nil\n}\n\nfunc (s *Driver) Close() error {\n\ts.done <- struct{}{}\n\ts.wg.Wait()\n\treturn nil\n}\n\n// OnL1Head signals the driver that the L1 chain changed the \"unsafe\" block,\n// also known as head of the chain, or \"latest\".\nfunc (s *Driver) OnL1Head(ctx context.Context, unsafe eth.L1BlockRef) error {\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\tcase s.l1HeadSig <- unsafe:\n\t\treturn nil\n\t}\n}\n\n// OnL1Safe signals the driver that the L1 chain changed the \"safe\",\n// also known as the justified checkpoint (as seen on L1 beacon-chain).\nfunc (s *Driver) OnL1Safe(ctx context.Context, safe eth.L1BlockRef) error {\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\tcase s.l1SafeSig <- safe:\n\t\treturn nil\n\t}\n}\n\nfunc (s *Driver) OnL1Finalized(ctx context.Context, finalized eth.L1BlockRef) error {\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\tcase s.l1FinalizedSig <- finalized:\n\t\treturn nil\n\t}\n}\n\nfunc (s *Driver) OnUnsafeL2Payload(ctx context.Context, payload *eth.ExecutionPayload) error {\n\ts.log.Debug(\"On unsafeL2Payloads channel buffer size\", \"length\", len(s.unsafeL2Payloads))\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\tcase s.unsafeL2Payloads <- payload:\n\t\treturn nil\n\t}\n}\n\n// the eventLoop responds to L1 changes and internal timers to produce L2 blocks.\nfunc (s *Driver) eventLoop() {\n\tdefer s.wg.Done()\n\ts.log.Info(\"State loop started\")\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\t// stepReqCh is used to request that the driver attempts to step forward by one L1 block.\n\tstepReqCh := make(chan struct{}, 1)\n\n\t// channel, nil by default (not firing), but used to schedule re-attempts with delay\n\tvar delayedStepReq <-chan time.Time\n\n\t// keep track of consecutive failed attempts, to adjust the backoff time accordingly\n\tbOffStrategy := backoff.Exponential()\n\tstepAttempts := 0\n\n\t// step requests a derivation step to be taken. Won't deadlock if the channel is full.\n\tstep := func() {\n\t\tselect {\n\t\tcase stepReqCh <- struct{}{}:\n\t\t// Don't deadlock if the channel is already full\n\t\tdefault:\n\t\t}\n\t}\n\n\t// reqStep requests a derivation step nicely, with a delay if this is a reattempt, or not at all if we already scheduled a reattempt.\n\treqStep := func() {\n\t\tif stepAttempts > 0 {\n\t\t\t// if this is not the first attempt, we re-schedule with a backoff, *without blocking other events*\n\t\t\tif delayedStepReq == nil {\n\t\t\t\tdelay := bOffStrategy.Duration(stepAttempts)\n\t\t\t\ts.log.Debug(\"scheduling re-attempt with delay\", \"attempts\", stepAttempts, \"delay\", delay)\n\t\t\t\tdelayedStepReq = time.After(delay)\n\t\t\t} else {\n\t\t\t\ts.log.Debug(\"ignoring step request, already scheduled re-attempt after previous failure\", \"attempts\", stepAttempts)\n\t\t\t}\n\t\t} else {\n\t\t\tstep()\n\t\t}\n\t}\n\n\t// We call reqStep right away to finish syncing to the tip of the chain if we're behind.\n\t// reqStep will also be triggered when the L1 head moves forward or if there was a reorg on the\n\t// L1 chain that we need to handle.\n\treqStep()\n\n\tsequencerTimer := time.NewTimer(0)\n\tvar sequencerCh <-chan time.Time\n\tplanSequencerAction := func() {\n\t\tdelay := s.sequencer.PlanNextSequencerAction()\n\t\tsequencerCh = sequencerTimer.C\n\t\tif len(sequencerCh) > 0 { // empty if not already drained before resetting\n\t\t\t<-sequencerCh\n\t\t}\n\t\tsequencerTimer.Reset(delay)\n\t\t// Without this sleep, even if delay is 0,  sequencerCh will not be ready in the following select judge.\n\t\t// As a result, during deriving a batch blocks, producing new block will be stopped.\n\t\t// After sleep for 0.1 ms, both sequencerCh and stepReqCh might be ready.\n\t\t// And select judge will random choose to proceed derivation or produce new blocks\n\t\ttime.Sleep(100 * time.Microsecond)\n\t}\n\n\t// Create a ticker to check if there is a gap in the engine queue. Whenever\n\t// there is, we send requests to sync source to retrieve the missing payloads.\n\tsyncCheckInterval := time.Duration(s.config.BlockTime) * time.Second * 2\n\taltSyncTicker := time.NewTicker(syncCheckInterval)\n\tdefer altSyncTicker.Stop()\n\tlastUnsafeL2 := s.derivation.UnsafeL2Head()\n\n\tfor {\n\t\t// If we are sequencing, and the L1 state is ready, update the trigger for the next sequencer action.\n\t\t// This may adjust at any time based on fork-choice changes or previous errors.\n\t\t// And avoid sequencing if the derivation pipeline indicates the engine is not ready.\n\t\tif s.driverConfig.SequencerEnabled && !s.driverConfig.SequencerStopped &&\n\t\t\ts.l1State.L1Head() != (eth.L1BlockRef{}) && s.derivation.EngineReady() {\n\t\t\tif s.driverConfig.SequencerMaxSafeLag > 0 && s.derivation.SafeL2Head().Number+s.driverConfig.SequencerMaxSafeLag <= s.derivation.UnsafeL2Head().Number {\n\t\t\t\t// If the safe head has fallen behind by a significant number of blocks, delay creating new blocks\n\t\t\t\t// until the safe lag is below SequencerMaxSafeLag.\n\t\t\t\tif sequencerCh != nil {\n\t\t\t\t\ts.log.Warn(\n\t\t\t\t\t\t\"Delay creating new block since safe lag exceeds limit\",\n\t\t\t\t\t\t\"safe_l2\", s.derivation.SafeL2Head(),\n\t\t\t\t\t\t\"unsafe_l2\", s.derivation.UnsafeL2Head(),\n\t\t\t\t\t)\n\t\t\t\t\tsequencerCh = nil\n\t\t\t\t}\n\t\t\t} else if s.sequencer.BuildingOnto().ID() != s.derivation.UnsafeL2Head().ID() {\n\t\t\t\t// If we are sequencing, and the L1 state is ready, update the trigger for the next sequencer action.\n\t\t\t\t// This may adjust at any time based on fork-choice changes or previous errors.\n\t\t\t\t//\n\t\t\t\t// update sequencer time if the head changed\n\t\t\t\tplanSequencerAction()\n\t\t\t}\n\t\t} else {\n\t\t\tsequencerCh = nil\n\t\t}\n\n\t\t// If the engine is not ready, or if the L2 head is actively changing, then reset the alt-sync:\n\t\t// there is no need to request L2 blocks when we are syncing already.\n\t\tif head := s.derivation.UnsafeL2Head(); head != lastUnsafeL2 || !s.derivation.EngineReady() {\n\t\t\tlastUnsafeL2 = head\n\t\t\taltSyncTicker.Reset(syncCheckInterval)\n\t\t}\n\n\t\tselect {\n\t\tcase <-sequencerCh:\n\t\t\tpayload, err := s.sequencer.RunNextSequencerAction(ctx)\n\t\t\tif err != nil {\n\t\t\t\ts.log.Error(\"Sequencer critical error\", \"err\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif s.network != nil && payload != nil {\n\t\t\t\t// Publishing of unsafe data via p2p is optional.\n\t\t\t\t// Errors are not severe enough to change/halt sequencing but should be logged and metered.\n\t\t\t\tif err := s.network.PublishL2Payload(ctx, payload); err != nil {\n\t\t\t\t\ts.log.Warn(\"failed to publish newly created block\", \"id\", payload.ID(), \"err\", err)\n\t\t\t\t\ts.metrics.RecordPublishingError()\n\t\t\t\t}\n\t\t\t}\n\t\t\tplanSequencerAction() // schedule the next sequencer action to keep the sequencing looping\n\t\tcase <-altSyncTicker.C:\n\t\t\t// Check if there is a gap in the current unsafe payload queue.\n\t\t\tctx, cancel := context.WithTimeout(ctx, time.Second*2)\n\t\t\terr := s.checkForGapInUnsafeQueue(ctx)\n\t\t\tcancel()\n\t\t\tif err != nil {\n\t\t\t\ts.log.Warn(\"failed to check for unsafe L2 blocks to sync\", \"err\", err)\n\t\t\t}\n\t\tcase payload := <-s.unsafeL2Payloads:\n\t\t\ts.snapshot(\"New unsafe payload\")\n\t\t\ts.log.Info(\"Optimistically queueing unsafe L2 execution payload\", \"id\", payload.ID())\n\t\t\ts.derivation.AddUnsafePayload(payload)\n\t\t\ts.metrics.RecordReceivedUnsafePayload(payload)\n\t\t\tfor len(s.unsafeL2Payloads) > 0 {\n\t\t\t\tpayload = <-s.unsafeL2Payloads\n\t\t\t\ts.log.Info(\"Optimistically queueing unsafe L2 execution payload\", \"id\", payload.ID())\n\t\t\t\ts.derivation.AddUnsafePayload(payload)\n\t\t\t\ts.metrics.RecordReceivedUnsafePayload(payload)\n\t\t\t}\n\t\t\treqStep()\n\n\t\tcase newL1Head := <-s.l1HeadSig:\n\t\t\ts.l1State.HandleNewL1HeadBlock(newL1Head)\n\t\t\treqStep() // a new L1 head may mean we have the data to not get an EOF again.\n\t\tcase newL1Safe := <-s.l1SafeSig:\n\t\t\ts.l1State.HandleNewL1SafeBlock(newL1Safe)\n\t\t\t// no step, justified L1 information does not do anything for L2 derivation or status\n\t\tcase newL1Finalized := <-s.l1FinalizedSig:\n\t\t\ts.l1State.HandleNewL1FinalizedBlock(newL1Finalized)\n\t\t\ts.derivation.Finalize(newL1Finalized)\n\t\t\treqStep() // we may be able to mark more L2 data as finalized now\n\t\tcase <-delayedStepReq:\n\t\t\tdelayedStepReq = nil\n\t\t\tstep()\n\t\tcase <-stepReqCh:\n\t\t\ts.metrics.SetDerivationIdle(false)\n\t\t\ts.log.Debug(\"Derivation process step\", \"onto_origin\", s.derivation.Origin(), \"attempts\", stepAttempts)\n\t\t\terr := s.derivation.Step(context.Background())\n\t\t\tstepAttempts += 1 // count as attempt by default. We reset to 0 if we are making healthy progress.\n\n\t\t\tif err == io.EOF {\n\t\t\t\ts.log.Debug(\"Derivation process went idle\", \"progress\", s.derivation.Origin(), \"err\", err)\n\t\t\t\tstepAttempts = 0\n\t\t\t\ts.metrics.SetDerivationIdle(true)\n\t\t\t\tcontinue\n\t\t\t} else if err != nil && errors.Is(err, derive.EngineP2PSyncing) {\n\t\t\t\ts.log.Debug(\"Derivation process went idle because the engine is syncing\", \"progress\", s.derivation.Origin(), \"sync_target\", s.derivation.EngineSyncTarget(), \"err\", err)\n\t\t\t\tstepAttempts = 0\n\t\t\t\ts.metrics.SetDerivationIdle(true)\n\t\t\t\tcontinue\n\t\t\t} else if err != nil && errors.Is(err, derive.ErrReset) {\n\t\t\t\t// If the pipeline corrupts, e.g. due to a reorg, simply reset it\n\t\t\t\ts.log.Warn(\"Derivation pipeline is reset\", \"err\", err)\n\t\t\t\ts.derivation.Reset()\n\t\t\t\ts.metrics.RecordPipelineReset()\n\t\t\t\tcontinue\n\t\t\t} else if err != nil && errors.Is(err, derive.ErrTemporary) {\n\t\t\t\ts.log.Warn(\"Derivation process temporary error\", \"attempts\", stepAttempts, \"err\", err)\n\t\t\t\treqStep()\n\t\t\t\tcontinue\n\t\t\t} else if err != nil && errors.Is(err, derive.ErrCritical) {\n\t\t\t\ts.log.Error(\"Derivation process critical error\", \"err\", err)\n\t\t\t\treturn\n\t\t\t} else if err != nil && errors.Is(err, derive.NotEnoughData) {\n\t\t\t\tstepAttempts = 0 // don't do a backoff for this error\n\t\t\t\treqStep()\n\t\t\t\tcontinue\n\t\t\t} else if err != nil {\n\t\t\t\ts.log.Error(\"Derivation process error\", \"attempts\", stepAttempts, \"err\", err)\n\t\t\t\treqStep()\n\t\t\t\tcontinue\n\t\t\t} else {\n\t\t\t\tstepAttempts = 0\n\t\t\t\treqStep() // continue with the next step if we can\n\t\t\t}\n\t\tcase respCh := <-s.stateReq:\n\t\t\trespCh <- struct{}{}\n\t\tcase respCh := <-s.forceReset:\n\t\t\ts.log.Warn(\"Derivation pipeline is manually reset\")\n\t\t\ts.derivation.Reset()\n\t\t\ts.metrics.RecordPipelineReset()\n\t\t\tclose(respCh)\n\t\tcase resp := <-s.startSequencer:\n\t\t\tunsafeHead := s.derivation.UnsafeL2Head().Hash\n\t\t\tif !s.driverConfig.SequencerStopped {\n\t\t\t\tresp.err <- errors.New(\"sequencer already running\")\n\t\t\t} else if !bytes.Equal(unsafeHead[:], resp.hash[:]) {\n\t\t\t\tresp.err <- fmt.Errorf(\"block hash does not match: head %s, received %s\", unsafeHead.String(), resp.hash.String())\n\t\t\t} else {\n\t\t\t\ts.log.Info(\"Sequencer has been started\")\n\t\t\t\ts.driverConfig.SequencerStopped = false\n\t\t\t\tclose(resp.err)\n\t\t\t\tplanSequencerAction() // resume sequencing\n\t\t\t}\n\t\tcase respCh := <-s.stopSequencer:\n\t\t\tif s.driverConfig.SequencerStopped {\n\t\t\t\trespCh <- hashAndError{err: errors.New(\"sequencer not running\")}\n\t\t\t} else {\n\t\t\t\ts.log.Warn(\"Sequencer has been stopped\")\n\t\t\t\ts.driverConfig.SequencerStopped = true\n\t\t\t\trespCh <- hashAndError{hash: s.derivation.UnsafeL2Head().Hash}\n\t\t\t}\n\t\tcase <-s.done:\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// ResetDerivationPipeline forces a reset of the derivation pipeline.\n// It waits for the reset to occur. It simply unblocks the caller rather\n// than fully cancelling the reset request upon a context cancellation.\nfunc (s *Driver) ResetDerivationPipeline(ctx context.Context) error {\n\trespCh := make(chan struct{}, 1)\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\tcase s.forceReset <- respCh:\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tcase <-respCh:\n\t\t\treturn nil\n\t\t}\n\t}\n}\n\nfunc (s *Driver) StartSequencer(ctx context.Context, blockHash common.Hash) error {\n\tif !s.driverConfig.SequencerEnabled {\n\t\treturn errors.New(\"sequencer is not enabled\")\n\t}\n\th := hashAndErrorChannel{\n\t\thash: blockHash,\n\t\terr:  make(chan error, 1),\n\t}\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\tcase s.startSequencer <- h:\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tcase e := <-h.err:\n\t\t\treturn e\n\t\t}\n\t}\n}\n\nfunc (s *Driver) StopSequencer(ctx context.Context) (common.Hash, error) {\n\tif !s.driverConfig.SequencerEnabled {\n\t\treturn common.Hash{}, errors.New(\"sequencer is not enabled\")\n\t}\n\trespCh := make(chan hashAndError, 1)\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn common.Hash{}, ctx.Err()\n\tcase s.stopSequencer <- respCh:\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn common.Hash{}, ctx.Err()\n\t\tcase he := <-respCh:\n\t\t\treturn he.hash, he.err\n\t\t}\n\t}\n}\n\n// syncStatus returns the current sync status, and should only be called synchronously with\n// the driver event loop to avoid retrieval of an inconsistent status.\nfunc (s *Driver) syncStatus() *eth.SyncStatus {\n\treturn &eth.SyncStatus{\n\t\tCurrentL1:          s.derivation.Origin(),\n\t\tCurrentL1Finalized: s.derivation.FinalizedL1(),\n\t\tHeadL1:             s.l1State.L1Head(),\n\t\tSafeL1:             s.l1State.L1Safe(),\n\t\tFinalizedL1:        s.l1State.L1Finalized(),\n\t\tUnsafeL2:           s.derivation.UnsafeL2Head(),\n\t\tSafeL2:             s.derivation.SafeL2Head(),\n\t\tFinalizedL2:        s.derivation.Finalized(),\n\t\tUnsafeL2SyncTarget: s.derivation.UnsafeL2SyncTarget(),\n\t\tEngineSyncTarget:   s.derivation.EngineSyncTarget(),\n\t}\n}\n\n// SyncStatus blocks the driver event loop and captures the syncing status.\n// If the event loop is too busy and the context expires, a context error is returned.\nfunc (s *Driver) SyncStatus(ctx context.Context) (*eth.SyncStatus, error) {\n\twait := make(chan struct{})\n\tselect {\n\tcase s.stateReq <- wait:\n\t\tresp := s.syncStatus()\n\t\t<-wait\n\t\treturn resp, nil\n\tcase <-ctx.Done():\n\t\treturn nil, ctx.Err()\n\t}\n}\n\n// BlockRefWithStatus blocks the driver event loop and captures the syncing status,\n// along with an L2 block reference by number consistent with that same status.\n// If the event loop is too busy and the context expires, a context error is returned.\nfunc (s *Driver) BlockRefWithStatus(ctx context.Context, num uint64) (eth.L2BlockRef, *eth.SyncStatus, error) {\n\twait := make(chan struct{})\n\tselect {\n\tcase s.stateReq <- wait:\n\t\tresp := s.syncStatus()\n\t\tref, err := s.l2.L2BlockRefByNumber(ctx, num)\n\t\t<-wait\n\t\treturn ref, resp, err\n\tcase <-ctx.Done():\n\t\treturn eth.L2BlockRef{}, nil, ctx.Err()\n\t}\n}\n\n// deferJSONString helps avoid a JSON-encoding performance hit if the snapshot logger does not run\ntype deferJSONString struct {\n\tx any\n}\n\nfunc (v deferJSONString) String() string {\n\tout, _ := json.Marshal(v.x)\n\treturn string(out)\n}\n\nfunc (s *Driver) snapshot(event string) {\n\ts.snapshotLog.Info(\"Rollup State Snapshot\",\n\t\t\"event\", event,\n\t\t\"l1Head\", deferJSONString{s.l1State.L1Head()},\n\t\t\"l1Current\", deferJSONString{s.derivation.Origin()},\n\t\t\"l2Head\", deferJSONString{s.derivation.UnsafeL2Head()},\n\t\t\"l2Safe\", deferJSONString{s.derivation.SafeL2Head()},\n\t\t\"l2FinalizedHead\", deferJSONString{s.derivation.Finalized()})\n}\n\ntype hashAndError struct {\n\thash common.Hash\n\terr  error\n}\n\ntype hashAndErrorChannel struct {\n\thash common.Hash\n\terr  chan error\n}\n\n// checkForGapInUnsafeQueue checks if there is a gap in the unsafe queue and attempts to retrieve the missing payloads from an alt-sync method.\n// WARNING: This is only an outgoing signal, the blocks are not guaranteed to be retrieved.\n// Results are received through OnUnsafeL2Payload.\nfunc (s *Driver) checkForGapInUnsafeQueue(ctx context.Context) error {\n\tstart := s.derivation.UnsafeL2Head()\n\tend := s.derivation.UnsafeL2SyncTarget()\n\t// Check if we have missing blocks between the start and end. Request them if we do.\n\tif end == (eth.L2BlockRef{}) {\n\t\ts.log.Debug(\"requesting sync with open-end range\", \"start\", start)\n\t\treturn s.altSync.RequestL2Range(ctx, start, eth.L2BlockRef{})\n\t} else if end.Number > start.Number+1 {\n\t\ts.log.Debug(\"requesting missing unsafe L2 block range\", \"start\", start, \"end\", end, \"size\", end.Number-start.Number)\n\t\treturn s.altSync.RequestL2Range(ctx, start, end)\n\t}\n\treturn nil\n}"
    }
  ]
}