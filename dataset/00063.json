{
  "Title": "Discrepancy Between Proposal and Implementation",
  "Content": "The accepted [1IP-43](https://snapshot.org/#/1inch.eth/proposal/0xa040c60050147a0f67042ae024673e92e813b5d2c0f748abf70ddfa1ed107cbe) proposal states that \"for blocks with baseFee >104.1 gwei - priorityFee is capped at 65% of the block’s baseFee\". However, the implementation applies the cap if the base fee is [greater than or equal to 104.1](https://github.com/1inch/limit-order-settlement/blob/ff7909c4f32bee8879211607275dc30d788afee8/contracts/SettlementExtension.sol#L200-L204) instead of strictly being greater.\n\n\nConsider adjusting either the proposal or the implementation to eliminate this discrepancy.\n\n\n***Update:** Resolved in [pull request #138](https://github.com/1inch/limit-order-settlement/pull/138) at commit [5e4652a](https://github.com/1inch/limit-order-settlement/commit/5e4652a62989c0b723a6a1a4de2092ba3312fb2f).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/SettlementExtension.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@1inch/limit-order-protocol-contract/contracts/interfaces/IPostInteraction.sol\";\nimport \"@1inch/limit-order-protocol-contract/contracts/interfaces/IAmountGetter.sol\";\nimport \"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\";\nimport \"./FeeBankCharger.sol\";\n\n/**\n * @title Settlement contract\n * @notice Contract to execute limit orders settlement, created by Fusion mode.\n */\ncontract SettlementExtension is IPostInteraction, IAmountGetter, FeeBankCharger {\n    using SafeERC20 for IERC20;\n    using AddressLib for Address;\n\n    error OnlyLimitOrderProtocol();\n    error ResolverIsNotWhitelisted();\n    error InvalidPriorityFee();\n\n    uint256 private constant _TAKING_FEE_BASE = 1e9;\n    uint256 private constant _ORDER_FEE_BASE_POINTS = 1e15;\n    uint256 private constant _BASE_POINTS = 10_000_000; // 100%\n    uint256 private constant _RESOLVER_ADDRESS_MASK = 0xffffffffffffffffffff;\n\n    IOrderMixin private immutable _limitOrderProtocol;\n\n    /// @dev Modifier to check if the caller is the limit order protocol contract.\n    modifier onlyLimitOrderProtocol {\n        if (msg.sender != address(_limitOrderProtocol)) revert OnlyLimitOrderProtocol();\n        _;\n    }\n\n    /**\n     * @notice Initializes the contract.\n     * @param limitOrderProtocol The limit order protocol contract.\n     * @param token The token to charge protocol fees in.\n     */\n    constructor(IOrderMixin limitOrderProtocol, IERC20 token)\n        FeeBankCharger(token)\n    {\n        _limitOrderProtocol = limitOrderProtocol;\n    }\n\n    function getMakingAmount(\n        IOrderMixin.Order calldata order,\n        bytes calldata /* extension */,\n        bytes32 /* orderHash */,\n        address /* taker */,\n        uint256 takingAmount,\n        uint256 /* remainingMakingAmount */,\n        bytes calldata extraData\n    ) external view returns (uint256) {\n        uint256 rateBump = _getRateBump(extraData);\n        return Math.mulDiv(order.makingAmount, takingAmount * _BASE_POINTS, order.takingAmount * (_BASE_POINTS + rateBump));\n    }\n\n    function getTakingAmount(\n        IOrderMixin.Order calldata order,\n        bytes calldata /* extension */,\n        bytes32 /* orderHash */,\n        address /* taker */,\n        uint256 makingAmount,\n        uint256 /* remainingMakingAmount */,\n        bytes calldata extraData\n    ) external view returns (uint256) {\n        uint256 rateBump = _getRateBump(extraData);\n        return Math.mulDiv(order.takingAmount, makingAmount * (_BASE_POINTS + rateBump), order.makingAmount * _BASE_POINTS, Math.Rounding.Up);\n    }\n\n    /// struct AuctionDetails {\n    ///     bytes4 auctionStartTime;\n    ///     bytes3 auctionDuration;\n    ///     bytes3 initialRateBump;\n    ///     (bytes3,bytes2)[N] pointsAndTimeDeltas;\n    /// }\n\n    function _getRateBump(bytes calldata auctionDetails) private view returns (uint256) {\n        unchecked {\n            uint256 auctionStartTime = uint32(bytes4(auctionDetails[0:4]));\n            uint256 auctionFinishTime = auctionStartTime + uint24(bytes3(auctionDetails[4:7]));\n            uint256 initialRateBump = uint24(bytes3(auctionDetails[7:10]));\n\n            if (block.timestamp <= auctionStartTime) {\n                return initialRateBump;\n            } else if (block.timestamp >= auctionFinishTime) {\n                return 0; // Means 0% bump\n            }\n\n            auctionDetails = auctionDetails[10:];\n            uint256 pointsSize = auctionDetails.length / 5;\n            uint256 currentPointTime = auctionStartTime;\n            uint256 currentRateBump = initialRateBump;\n\n            for (uint256 i = 0; i < pointsSize; i++) {\n                uint256 nextRateBump = uint24(bytes3(auctionDetails[:3]));\n                uint256 nextPointTime = currentPointTime + uint16(bytes2(auctionDetails[3:5]));\n                if (block.timestamp <= nextPointTime) {\n                    return ((block.timestamp - currentPointTime) * nextRateBump + (nextPointTime - block.timestamp) * currentRateBump) / (nextPointTime - currentPointTime);\n                }\n                currentRateBump = nextRateBump;\n                currentPointTime = nextPointTime;\n                auctionDetails = auctionDetails[5:];\n            }\n            return (auctionFinishTime - block.timestamp) * currentRateBump / (auctionFinishTime - currentPointTime);\n        }\n    }\n\n    function postInteraction(\n        IOrderMixin.Order calldata order,\n        bytes calldata /* extension */,\n        bytes32 /* orderHash */,\n        address taker,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 /* remainingMakingAmount */,\n        bytes calldata extraData\n    ) external onlyLimitOrderProtocol {\n        (uint256 resolverFee, address integrator, uint256 integrationFee, bytes calldata whitelist) = _parseFeeData(extraData, order.makingAmount, makingAmount, takingAmount);\n\n        if (!_isWhitelisted(whitelist, taker)) revert ResolverIsNotWhitelisted();\n        if (!_isPriorityFeeValid()) revert InvalidPriorityFee();\n\n        _chargeFee(taker, resolverFee);\n        if (integrationFee > 0) {\n            IERC20(order.takerAsset.get()).safeTransferFrom(taker, integrator, integrationFee);\n        }\n    }\n\n    /// struct FeeData {\n    ///     bytes1 feeTypes; 1 = resolverFee, 2 = intergrationFee\n    ///     bytes4 resolverFee; optional\n    ///     bytes20 integrator; optional\n    ///     bytes4 integrationFee; optional\n    ///     bytes whitelist;\n    /// }\n\n    function _parseFeeData(\n        bytes calldata extraData,\n        uint256 orderMakingAmount,\n        uint256 actualMakingAmount,\n        uint256 actualTakingAmount\n    ) private pure returns (uint256 resolverFee, address integrator, uint256 integrationFee, bytes calldata whitelist) {\n        bytes1 feeType = extraData[0];\n        extraData = extraData[1:];\n        if (feeType & 0x01 == 0x01) {\n            // resolverFee enabled\n            resolverFee = uint256(uint32(bytes4(extraData[:4]))) * _ORDER_FEE_BASE_POINTS * actualMakingAmount / orderMakingAmount;\n            extraData = extraData[4:];\n        }\n        if (feeType & 0x02 == 0x02) {\n            // integratorFee enabled\n            integrator = address(bytes20(extraData[:20]));\n            integrationFee = actualTakingAmount * uint256(uint32(bytes4(extraData[20:24]))) / _TAKING_FEE_BASE;\n            extraData = extraData[24:];\n        }\n        whitelist = extraData;\n    }\n\n    /// struct WhitelistDetails {\n    ///     bytes4 auctionStartTime;\n    ///     (bytes10,bytes2)[N] resolversAddressesAndTimeDeltas;\n    /// }\n\n    function _isWhitelisted(bytes calldata whitelist, address resolver) private view returns (bool) {\n        unchecked {\n            uint256 allowedTime = uint32(bytes4(whitelist[0:4])); // initially set to auction start time\n            whitelist = whitelist[4:];\n            uint256 whitelistSize = whitelist.length / 12;\n            uint80 maskedResolverAddress = uint80(uint160(resolver) & _RESOLVER_ADDRESS_MASK);\n            for (uint256 i = 0; i < whitelistSize; i++) {\n                uint80 whitelistedAddress = uint80(bytes10(whitelist[:10]));\n                allowedTime += uint16(bytes2(whitelist[10:12])); // add next time delta\n                if (maskedResolverAddress == whitelistedAddress) {\n                    return allowedTime <= block.timestamp;\n                } else if (allowedTime > block.timestamp) {\n                    return false;\n                }\n                whitelist = whitelist[12:];\n            }\n            return false;\n        }\n    }\n\n    /// @notice Validates priority fee according to the spec\n    /// https://snapshot.org/#/1inch.eth/proposal/0xa040c60050147a0f67042ae024673e92e813b5d2c0f748abf70ddfa1ed107cbe\n    /// For blocks with baseFee <10.6 gwei – the priorityFee is capped at 70% of the baseFee.\n    /// For blocks with baseFee between 10.6 gwei and 104.1 gwei – the priorityFee is capped at 50% of the baseFee.\n    /// For blocks with baseFee >104.1 gwei – priorityFee is capped at 65% of the block’s baseFee.\n    function _isPriorityFeeValid() private view returns(bool) {\n        unchecked {\n            uint256 baseFee = block.basefee;\n            uint256 priorityFee = tx.gasprice - baseFee;\n\n            if (baseFee < 10.6 gwei) {\n                return priorityFee * 100 <= baseFee * 70;\n            } else if (baseFee < 104.1 gwei) {\n                return priorityFee * 2 <= baseFee;\n            } else {\n                return priorityFee * 100 <= baseFee * 65;\n            }\n        }\n    }\n}"
    }
  ]
}