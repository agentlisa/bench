{
  "Title": "[L-03] Function reverts if called a second time",
  "Content": "\n`safeApprove()` reverts if called a second time without fist calling `safeApprove(0)`\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/CrvDepositorWrapper.sol   #1\n\n/// @audit `setApprovals()` is an external function that calls this function. If it's called more than once, the secondary calls will revert\n51       function _setApprovals() internal {\n52           IERC20(WETH).safeApprove(address(BALANCER_VAULT), type(uint256).max);\n53           IERC20(BAL).safeApprove(address(BALANCER_VAULT), type(uint256).max);\n54:      }\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/CrvDepositorWrapper.sol#L51-L54>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-aura",
  "Code": [
    {
      "filename": "contracts/CrvDepositorWrapper.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\nimport { IVault, IPriceOracle, IAsset } from \"./Interfaces.sol\";\nimport { IVault } from \"./Interfaces.sol\";\n\ninterface ICrvDepositor {\n    function depositFor(\n        address to,\n        uint256 _amount,\n        bool _lock,\n        address _stakeAddress\n    ) external;\n}\n\n/**\n * @title   BalInvestor\n * @notice  Deposits $BAL into a BAL/WETH BPT. Hooks into TWAP to determine minOut.\n * @dev     Abstract contract for depositing BAL -> balBPT -> auraBAL via crvDepositor\n */\nabstract contract BalInvestor {\n    using SafeERC20 for IERC20;\n\n    IVault public immutable BALANCER_VAULT;\n    address public immutable BAL;\n    address public immutable WETH;\n    address public immutable BALANCER_POOL_TOKEN;\n    bytes32 public immutable BAL_ETH_POOL_ID;\n\n    constructor(\n        IVault _balancerVault,\n        address _bal,\n        address _weth,\n        bytes32 _balETHPoolId\n    ) {\n        (\n            address poolAddress, /* */\n\n        ) = _balancerVault.getPool(_balETHPoolId);\n        require(poolAddress != address(0), \"!poolAddress\");\n\n        BALANCER_VAULT = _balancerVault;\n        BAL = _bal;\n        WETH = _weth;\n        BALANCER_POOL_TOKEN = poolAddress;\n        BAL_ETH_POOL_ID = _balETHPoolId;\n    }\n\n    function _setApprovals() internal {\n        IERC20(WETH).safeApprove(address(BALANCER_VAULT), type(uint256).max);\n        IERC20(BAL).safeApprove(address(BALANCER_VAULT), type(uint256).max);\n    }\n\n    function _getBptPrice() internal view returns (uint256) {\n        IPriceOracle.OracleAverageQuery[] memory queries = new IPriceOracle.OracleAverageQuery[](1);\n\n        queries[0].variable = IPriceOracle.Variable.BPT_PRICE;\n        queries[0].secs = 3600; // last hour\n        queries[0].ago = 0; // now\n\n        // Gets the balancer time weighted average price denominated in BAL\n        return IPriceOracle(BALANCER_POOL_TOKEN).getTimeWeightedAverage(queries)[0];\n    }\n\n    function _getMinOut(uint256 amount, uint256 minOutBps) internal view returns (uint256) {\n        // Gets the balancer time weighted average price denominated in BAL\n        // e.g.  if 1 BAL == 0.4 BPT, bptOraclePrice == 2.5\n        uint256 bptOraclePrice = _getBptPrice();\n        // e.g. minOut = (((100e18 * 1e18) / 2.5e18) * 9980) / 10000;\n        // e.g. minout = 39.92e18\n        uint256 minOut = (((amount * 1e18) / bptOraclePrice) * minOutBps) / 10000;\n        return minOut;\n    }\n\n    function _investBalToPool(uint256 amount, uint256 minOut) internal {\n        IERC20(BAL).safeTransferFrom(msg.sender, address(this), amount);\n        IAsset[] memory assets = new IAsset[](2);\n        assets[0] = IAsset(BAL);\n        assets[1] = IAsset(WETH);\n        uint256[] memory maxAmountsIn = new uint256[](2);\n        maxAmountsIn[0] = amount;\n        maxAmountsIn[1] = 0;\n\n        BALANCER_VAULT.joinPool(\n            BAL_ETH_POOL_ID,\n            address(this),\n            address(this),\n            IVault.JoinPoolRequest(\n                assets,\n                maxAmountsIn,\n                abi.encode(IVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT, maxAmountsIn, minOut),\n                false // Don't use internal balances\n            )\n        );\n    }\n}\n\n/**\n * @title   CrvDepositorWrapper\n * @notice  Converts BAL -> balBPT and then wraps to auraBAL via the crvDepositor\n */\ncontract CrvDepositorWrapper is BalInvestor {\n    address public immutable crvDeposit;\n\n    constructor(\n        address _crvDeposit,\n        IVault _balancerVault,\n        address _bal,\n        address _weth,\n        bytes32 _balETHPoolId\n    ) BalInvestor(_balancerVault, _bal, _weth, _balETHPoolId) {\n        crvDeposit = _crvDeposit;\n    }\n\n    function setApprovals() external {\n        _setApprovals();\n        require(IERC20(BALANCER_POOL_TOKEN).approve(crvDeposit, type(uint256).max), \"!approval\");\n    }\n\n    /**\n     * @dev Gets minimum output based on BPT oracle price\n     * @param _amount Units of BAL to deposit\n     * @param _outputBps Multiplier where 100% == 10000, 99.5% == 9950 and 98% == 9800\n     * @return minOut Units of BPT to expect as output\n     */\n    function getMinOut(uint256 _amount, uint256 _outputBps) external view returns (uint256) {\n        return _getMinOut(_amount, _outputBps);\n    }\n\n    function deposit(\n        uint256 _amount,\n        uint256 _minOut,\n        bool _lock,\n        address _stakeAddress\n    ) external {\n        _investBalToPool(_amount, _minOut);\n        uint256 bptBalance = IERC20(BALANCER_POOL_TOKEN).balanceOf(address(this));\n        ICrvDepositor(crvDeposit).depositFor(msg.sender, bptBalance, _lock, _stakeAddress);\n    }\n}"
    }
  ]
}