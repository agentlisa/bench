{
  "Title": "[G-07] `x = x + y` is more efficient, than `x += y` (4 instances)",
  "Content": "\n*   Deployment. Gas Saved: **5 007**\n\n*   Minumal Method Call. Gas Saved: **82**\n\n*   Average Method Call. Gas Saved: **87**\n\n*   Maximum Method Call. Gas Saved: **101**\n\n### src/frxETHMinter.sol:[97](https://github.com/code-423n4/2022-09-frax/blob/55ea6b1ef3857a277e2f47d42029bc0f3d6f9173/src/frxETHMinter.sol#L97), [168](https://github.com/code-423n4/2022-09-frax/blob/55ea6b1ef3857a277e2f47d42029bc0f3d6f9173/src/frxETHMinter.sol#L168)\n\n```diff\ndiff --git a/src/frxETHMinter.sol b/src/frxETHMinter.sol\nindex 4565883..a591be9 100644\n--- a/src/frxETHMinter.sol\n+++ b/src/frxETHMinter.sol\n@@ -94,7 +94,7 @@ contract frxETHMinter is OperatorRegistry, ReentrancyGuard {\n   94,  94:         uint256 withheld_amt = 0;\n   95,  95:         if (withholdRatio != 0) {\n   96,  96:             withheld_amt = (msg.value * withholdRatio) / RATIO_PRECISION;\n-  97     :-            currentWithheldETH += withheld_amt;\n+       97:+            currentWithheldETH = currentWithheldETH + withheld_amt;\n   98,  98:         }\n   99,  99:\n  100, 100:         emit ETHSubmitted(msg.sender, recipient, msg.value, withheld_amt);\n@@ -165,7 +165,7 @@ contract frxETHMinter is OperatorRegistry, ReentrancyGuard {\n  165, 165:     /// @notice Give the withheld ETH to the \"to\" address\n  166, 166:     function moveWithheldETH(address payable to, uint256 amount) external onlyByOwnGov {\n  167, 167:         require(amount <= currentWithheldETH, \"Not enough withheld ETH in contract\");\n- 168     :-        currentWithheldETH -= amount;\n+      168:+        currentWithheldETH = currentWithheldETH - amount;\n  169, 169:\n  170, 170:         (bool success,) = payable(to).call{ value: amount }(\"\");\n  171, 171:         require(success, \"Invalid transfer\");\n```\n\n### src/xERC4626.sol:[67](https://github.com/corddry/ERC4626/blob/643cd044fac34bcbf64e1c3790a5126fec0dbec1/src/xERC4626.sol#L67), [72](https://github.com/corddry/ERC4626/blob/643cd044fac34bcbf64e1c3790a5126fec0dbec1/src/xERC4626.sol#L72)\n\n```diff\ndiff --git a/src/xERC4626.sol b/src/xERC4626.sol\nindex a8a4726..dea5982 100644\n--- a/src/xERC4626.sol\n+++ b/src/xERC4626.sol\n@@ -64,12 +64,12 @@ abstract contract xERC4626 is IxERC4626, ERC4626 {\n   64,  64:     // Update storedTotalAssets on withdraw/redeem\n   65,  65:     function beforeWithdraw(uint256 amount, uint256 shares) internal virtual override {\n   66,  66:         super.beforeWithdraw(amount, shares);\n-  67     :-        storedTotalAssets -= amount;\n+       67:+        storedTotalAssets = storedTotalAssets - amount;\n   68,  68:     }\n   69,  69:\n   70,  70:     // Update storedTotalAssets on deposit/mint\n   71,  71:     function afterDeposit(uint256 amount, uint256 shares) internal virtual override {\n-  72     :-        storedTotalAssets += amount;\n+       72:+        storedTotalAssets = storedTotalAssets + amount;\n   73,  73:         super.afterDeposit(amount, shares);\n   74,  74:     }\n   75,  75:\n```\n\n***\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-09-frax",
  "Code": [
    {
      "filename": "src/frxETHMinter.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n// ====================================================================\n// |     ______                   _______                             |\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\n// |                                                                  |\n// ====================================================================\n// ============================ frxETHMinter ==========================\n// ====================================================================\n// Frax Finance: https://github.com/FraxFinance\n\n// Primary Author(s)\n// Jack Corddry: https://github.com/corddry\n// Justin Moore: https://github.com/0xJM\n\n// Reviewer(s) / Contributor(s)\n// Travis Moore: https://github.com/FortisFortuna\n// Dennis: https://github.com/denett\n// Jamie Turley: https://github.com/jyturley\n\nimport { frxETH } from \"./frxETH.sol\";\nimport { IsfrxETH } from \"./IsfrxETH.sol\";\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport { IDepositContract } from \"./DepositContract.sol\";\nimport \"./OperatorRegistry.sol\";\n\n/// @title Authorized minter contract for frxETH\n/// @notice Accepts user-supplied ETH and converts it to frxETH (submit()), and also optionally inline stakes it for sfrxETH (submitAndDeposit())\n/** @dev Has permission to mint frxETH. \n    Once +32 ETH has accumulated, adds it to a validator, which then deposits it for ETH 2.0 staking (depositEther())\n    Withhold ratio refers to what percentage of ETH this contract keeps whenever a user makes a deposit. 0% is kept initially */\ncontract frxETHMinter is OperatorRegistry, ReentrancyGuard {    \n    uint256 public constant DEPOSIT_SIZE = 32 ether; // ETH 2.0 minimum deposit size\n    uint256 public constant RATIO_PRECISION = 1e6; // 1,000,000 \n\n    uint256 public withholdRatio; // What we keep and don't deposit whenever someone submit()'s ETH\n    uint256 public currentWithheldETH; // Needed for internal tracking\n    mapping(bytes => bool) public activeValidators; // Tracks validators (via their pubkeys) that already have 32 ETH in them\n\n    IDepositContract public immutable depositContract; // ETH 2.0 deposit contract\n    frxETH public immutable frxETHToken;\n    IsfrxETH public immutable sfrxETHToken;\n\n    bool public submitPaused;\n    bool public depositEtherPaused;\n\n    constructor(\n        address depositContractAddress, \n        address frxETHAddress, \n        address sfrxETHAddress, \n        address _owner, \n        address _timelock_address,\n        bytes memory _withdrawalCredential\n    ) OperatorRegistry(_owner, _timelock_address, _withdrawalCredential) {\n        depositContract = IDepositContract(depositContractAddress);\n        frxETHToken = frxETH(frxETHAddress);\n        sfrxETHToken = IsfrxETH(sfrxETHAddress);\n        withholdRatio = 0; // No ETH is withheld initially\n        currentWithheldETH = 0;\n    }\n\n    /// @notice Mint frxETH and deposit it to receive sfrxETH in one transaction\n    /** @dev Could try using EIP-712 / EIP-2612 here in the future if you replace this contract,\n        but you might run into msg.sender vs tx.origin issues with the ERC4626 */\n    function submitAndDeposit(address recipient) external payable returns (uint256 shares) {\n        // Give the frxETH to this contract after it is generated\n        _submit(address(this));\n\n        // Approve frxETH to sfrxETH for staking\n        frxETHToken.approve(address(sfrxETHToken), msg.value);\n\n        // Deposit the frxETH and give the generated sfrxETH to the final recipient\n        uint256 sfrxeth_recieved = sfrxETHToken.deposit(msg.value, recipient);\n        require(sfrxeth_recieved > 0, 'No sfrxETH was returned');\n\n        return sfrxeth_recieved;\n    }\n\n    /// @notice Mint frxETH to the recipient using sender's funds. Internal portion\n    function _submit(address recipient) internal nonReentrant {\n        // Initial pause and value checks\n        require(!submitPaused, \"Submit is paused\");\n        require(msg.value != 0, \"Cannot submit 0\");\n\n        // Give the sender frxETH\n        frxETHToken.minter_mint(recipient, msg.value);\n\n        // Track the amount of ETH that we are keeping\n        uint256 withheld_amt = 0;\n        if (withholdRatio != 0) {\n            withheld_amt = (msg.value * withholdRatio) / RATIO_PRECISION;\n            currentWithheldETH += withheld_amt;\n        }\n\n        emit ETHSubmitted(msg.sender, recipient, msg.value, withheld_amt);\n    }\n\n    /// @notice Mint frxETH to the sender depending on the ETH value sent\n    function submit() external payable {\n        _submit(msg.sender);\n    }\n\n    /// @notice Mint frxETH to the recipient using sender's funds\n    function submitAndGive(address recipient) external payable {\n        _submit(recipient);\n    }\n\n    /// @notice Fallback to minting frxETH to the sender\n    receive() external payable {\n        _submit(msg.sender);\n    }\n\n    /// @notice Deposit batches of ETH to the ETH 2.0 deposit contract\n    /// @dev Usually a bot will call this periodically\n    function depositEther() external nonReentrant {\n        // Initial pause check\n        require(!depositEtherPaused, \"Depositing ETH is paused\");\n\n        // See how many deposits can be made. Truncation desired.\n        uint256 numDeposits = (address(this).balance - currentWithheldETH) / DEPOSIT_SIZE;\n        require(numDeposits > 0, \"Not enough ETH in contract\");\n\n        // Give each deposit chunk to an empty validator\n        for (uint256 i = 0; i < numDeposits; ++i) {\n            // Get validator information\n            (\n                bytes memory pubKey,\n                bytes memory withdrawalCredential,\n                bytes memory signature,\n                bytes32 depositDataRoot\n            ) = getNextValidator(); // Will revert if there are not enough free validators\n\n            // Make sure the validator hasn't been deposited into already, to prevent stranding an extra 32 eth\n            // until withdrawals are allowed\n            require(!activeValidators[pubKey], \"Validator already has 32 ETH\");\n\n            // Deposit the ether in the ETH 2.0 deposit contract\n            depositContract.deposit{value: DEPOSIT_SIZE}(\n                pubKey,\n                withdrawalCredential,\n                signature,\n                depositDataRoot\n            );\n\n            // Set the validator as used so it won't get an extra 32 ETH\n            activeValidators[pubKey] = true;\n\n            emit DepositSent(pubKey, withdrawalCredential);\n        }\n    }\n\n    /// @param newRatio of ETH that is sent to deposit contract vs withheld, 1e6 precision\n    /// @notice An input of 1e6 results in 100% of Eth deposited, 0% withheld\n    function setWithholdRatio(uint256 newRatio) external onlyByOwnGov {\n        require (newRatio <= RATIO_PRECISION, \"Ratio cannot surpass 100%\");\n        withholdRatio = newRatio;\n        emit WithholdRatioSet(newRatio);\n    }\n\n    /// @notice Give the withheld ETH to the \"to\" address\n    function moveWithheldETH(address payable to, uint256 amount) external onlyByOwnGov {\n        require(amount <= currentWithheldETH, \"Not enough withheld ETH in contract\");\n        currentWithheldETH -= amount;\n\n        (bool success,) = payable(to).call{ value: amount }(\"\");\n        require(success, \"Invalid transfer\");\n\n        emit WithheldETHMoved(to, amount);\n    }\n\n    /// @notice Toggle allowing submites\n    function togglePauseSubmits() external onlyByOwnGov {\n        submitPaused = !submitPaused;\n\n        emit SubmitPaused(submitPaused);\n    }\n\n    /// @notice Toggle allowing depositing ETH to validators\n    function togglePauseDepositEther() external onlyByOwnGov {\n        depositEtherPaused = !depositEtherPaused;\n\n        emit DepositEtherPaused(depositEtherPaused);\n    }\n\n    /// @notice For emergencies if something gets stuck\n    function recoverEther(uint256 amount) external onlyByOwnGov {\n        (bool success,) = address(owner).call{ value: amount }(\"\");\n        require(success, \"Invalid transfer\");\n\n        emit EmergencyEtherRecovered(amount);\n    }\n\n    /// @notice For emergencies if someone accidentally sent some ERC20 tokens here\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyByOwnGov {\n        require(IERC20(tokenAddress).transfer(owner, tokenAmount), \"recoverERC20: Transfer failed\");\n\n        emit EmergencyERC20Recovered(tokenAddress, tokenAmount);\n    }\n\n    event EmergencyEtherRecovered(uint256 amount);\n    event EmergencyERC20Recovered(address tokenAddress, uint256 tokenAmount);\n    event ETHSubmitted(address indexed sender, address indexed recipient, uint256 sent_amount, uint256 withheld_amt);\n    event DepositEtherPaused(bool new_status);\n    event DepositSent(bytes indexed pubKey, bytes withdrawalCredential);\n    event SubmitPaused(bool new_status);\n    event WithheldETHMoved(address indexed to, uint256 amount);\n    event WithholdRatioSet(uint256 newRatio);\n}"
    },
    {
      "filename": "src/xERC4626.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Rewards logic inspired by xERC20 (https://github.com/ZeframLou/playpen/blob/main/src/xERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"solmate/mixins/ERC4626.sol\";\nimport \"solmate/utils/SafeCastLib.sol\";\n\nimport \"./interfaces/IxERC4626.sol\";\n\n/** \n @title  An xERC4626 Single Staking Contract\n @notice This contract allows users to autocompound rewards denominated in an underlying reward token. \n         It is fully compatible with [ERC4626](https://eips.ethereum.org/EIPS/eip-4626) allowing for DeFi composability.\n         It maintains balances using internal accounting to prevent instantaneous changes in the exchange rate.\n         NOTE: an exception is at contract creation, when a reward cycle begins before the first deposit. After the first deposit, exchange rate updates smoothly.\n\n         Operates on \"cycles\" which distribute the rewards surplus over the internal balance to users linearly over the remainder of the cycle window.\n*/\nabstract contract xERC4626 is IxERC4626, ERC4626 {\n    using SafeCastLib for *;\n\n    /// @notice the maximum length of a rewards cycle\n    uint32 public immutable rewardsCycleLength;\n\n    /// @notice the effective start of the current cycle\n    uint32 public lastSync;\n\n    /// @notice the end of the current cycle. Will always be evenly divisible by `rewardsCycleLength`.\n    uint32 public rewardsCycleEnd;\n\n    /// @notice the amount of rewards distributed in a the most recent cycle.\n    uint192 public lastRewardAmount;\n\n    uint256 internal storedTotalAssets;\n\n    constructor(uint32 _rewardsCycleLength) {\n        rewardsCycleLength = _rewardsCycleLength;\n        // seed initial rewardsCycleEnd\n        rewardsCycleEnd = (block.timestamp.safeCastTo32() / rewardsCycleLength) * rewardsCycleLength;\n    }\n\n    /// @notice Compute the amount of tokens available to share holders.\n    ///         Increases linearly during a reward distribution period from the sync call, not the cycle start.\n    function totalAssets() public view override returns (uint256) {\n        // cache global vars\n        uint256 storedTotalAssets_ = storedTotalAssets;\n        uint192 lastRewardAmount_ = lastRewardAmount;\n        uint32 rewardsCycleEnd_ = rewardsCycleEnd;\n        uint32 lastSync_ = lastSync;\n\n        if (block.timestamp >= rewardsCycleEnd_) {\n            // no rewards or rewards fully unlocked\n            // entire reward amount is available\n            return storedTotalAssets_ + lastRewardAmount_;\n        }\n\n        // rewards not fully unlocked\n        // add unlocked rewards to stored total\n        uint256 unlockedRewards = (lastRewardAmount_ * (block.timestamp - lastSync_)) / (rewardsCycleEnd_ - lastSync_);\n        return storedTotalAssets_ + unlockedRewards;\n    }\n\n    // Update storedTotalAssets on withdraw/redeem\n    function beforeWithdraw(uint256 amount, uint256 shares) internal virtual override {\n        super.beforeWithdraw(amount, shares);\n        storedTotalAssets -= amount;\n    }\n\n    // Update storedTotalAssets on deposit/mint\n    function afterDeposit(uint256 amount, uint256 shares) internal virtual override {\n        storedTotalAssets += amount;\n        super.afterDeposit(amount, shares);\n    }\n\n    /// @notice Distributes rewards to xERC4626 holders.\n    /// All surplus `asset` balance of the contract over the internal balance becomes queued for the next cycle.\n    function syncRewards() public virtual {\n        uint192 lastRewardAmount_ = lastRewardAmount;\n        uint32 timestamp = block.timestamp.safeCastTo32();\n\n        if (timestamp < rewardsCycleEnd) revert SyncError();\n\n        uint256 storedTotalAssets_ = storedTotalAssets;\n        uint256 nextRewards = asset.balanceOf(address(this)) - storedTotalAssets_ - lastRewardAmount_;\n\n        storedTotalAssets = storedTotalAssets_ + lastRewardAmount_; // SSTORE\n\n        uint32 end = ((timestamp + rewardsCycleLength) / rewardsCycleLength) * rewardsCycleLength;\n\n        // Combined single SSTORE\n        lastRewardAmount = nextRewards.safeCastTo192();\n        lastSync = timestamp;\n        rewardsCycleEnd = end;\n\n        emit NewRewardsCycle(end, nextRewards);\n    }\n}"
    }
  ]
}