{
  "Title": "[M-13] Missing `whenNotPaused` modifier",
  "Content": "_Submitted by SmartSek, also found by csanuragjain and hansfriese_\n\n[StableSwapFacet.sol#L279-L286](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/StableSwapFacet.sol#L279-L286)<br>\n\nIn `StableSwapFacet.sol`, two swapping functions contain the `whenNotPaused` modifier while `swapExactOut()` and `addSwapLiquidity()` do not. All functions to swap and add liquidity should contain the same modifiers to stop transactions while paused.\n\n### Proof of Concept\n\n***Example with modifier***\n\n      function swapExact(\n        bytes32 canonicalId,\n        uint256 amountIn,\n        address assetIn,\n        address assetOut,\n        uint256 minAmountOut,\n        uint256 deadline\n      ) external payable nonReentrant deadlineCheck(deadline) whenNotPaused returns (uint256) {\n\n***Examples without modifier***\n\n      function swapExactOut(\n        bytes32 canonicalId,\n        uint256 amountOut,\n        address assetIn,\n        address assetOut,\n        uint256 maxAmountIn,\n        uint256 deadline\n      ) external payable nonReentrant deadlineCheck(deadline) returns (uint256) {\n\nand\n\n      function addSwapLiquidity(\n        bytes32 canonicalId,\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n      ) external nonReentrant deadlineCheck(deadline) returns (uint256) {\n        return s.swapStorages[canonicalId].addLiquidity(amounts, minToMint);\n      }\n\n### Recommended Mitigation Steps\n\nAdd the `whenNotPaused` modifier to all functions that perform swaps or liquidity additions.\n\n**[jakekidd (Connext) confirmed and resolved](https://github.com/code-423n4/2022-06-connext-findings/issues/175#issuecomment-1166751643):**\n > Resolved by: [connext/nxtp@1dd5559](https://github.com/connext/nxtp/commit/1dd55597359bdda56fc7b62d9e5a31c6b0faf9bc)\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-06-connext-findings/issues/175#issuecomment-1214716966):**\n > I think this makes sense to add!\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-06-connext",
  "Code": [
    {
      "filename": "contracts/contracts/core/connext/facets/StableSwapFacet.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\nimport {AmplificationUtils, SwapUtils} from \"../libraries/AmplificationUtils.sol\";\nimport {LPToken} from \"../helpers/LPToken.sol\";\n\n/**\n * @title Swap - A StableSwap implementation in solidity.\n * @notice This contract is responsible for custody of closely pegged assets (eg. group of stablecoins)\n * and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens\n * in desired ratios for an exchange of the pool token that represents their share of the pool.\n * Users can burn pool tokens and withdraw their share of token(s).\n *\n * Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets\n * distributed to the LPs.\n *\n * In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which\n * stops the ratio of the tokens in the pool from changing.\n * Users can always withdraw their tokens via multi-asset withdraws.\n *\n * @dev Most of the logic is stored as a library `SwapUtils` for the sake of reducing contract's\n * deployment size.\n */\n\ncontract StableSwapFacet is BaseConnextFacet {\n  using SwapUtils for SwapUtils.Swap;\n  using AmplificationUtils for SwapUtils.Swap;\n\n  // ========== Custom Errors ===========\n  error StableSwapFacet__deadlineCheck_deadlineNotMet();\n  error StableSwapFacet__initializeSwap_alreadyInitialized();\n  error StableSwapFacet__initializeSwap_invalidPooledTokens();\n  error StableSwapFacet__initializeSwap_decimalsMismatch();\n  error StableSwapFacet__initializeSwap_duplicateTokens();\n  error StableSwapFacet__initializeSwap_zeroTokenAddress();\n  error StableSwapFacet__initializeSwap_tokenDecimalsExceedMax();\n  error StableSwapFacet__initializeSwap_aExceedMax();\n  error StableSwapFacet__initializeSwap_feeExceedMax();\n  error StableSwapFacet__initializeSwap_adminFeeExceedMax();\n  error StableSwapFacet__initializeSwap_failedInitLpTokenClone();\n  error StableSwapFacet__getSwapToken_outOfRange();\n  error StableSwapFacet__getSwapTokenIndex_notExist();\n  error StableSwapFacet__getSwapTokenBalance_indexOutOfRange();\n\n  // ============ Properties ============\n\n  // ============ Modifiers ============\n\n  /**\n   * @notice Modifier to check deadline against current timestamp\n   * @param deadline latest timestamp to accept this transaction\n   */\n  modifier deadlineCheck(uint256 deadline) {\n    if (block.timestamp > deadline) revert StableSwapFacet__deadlineCheck_deadlineNotMet();\n    _;\n  }\n\n  // ============ View Functions ============\n  /**\n   * @notice Return Stable swap storage\n   * @param canonicalId the canonical token id\n   * @return SwapUtils.Swap\n   */\n  function getSwapStorage(bytes32 canonicalId) external view returns (SwapUtils.Swap memory) {\n    return s.swapStorages[canonicalId];\n  }\n\n  /**\n   * @notice Return LP token for canonical Id\n   * @param canonicalId the canonical token id\n   * @return LPToken\n   */\n  function getSwapLPToken(bytes32 canonicalId) external view returns (address) {\n    return address(s.swapStorages[canonicalId].lpToken);\n  }\n\n  /**\n   * @notice Return A, the amplification coefficient * n * (n - 1)\n   * @dev See the StableSwap paper for details\n   * @param canonicalId the canonical token id\n   * @return A parameter\n   */\n  function getSwapA(bytes32 canonicalId) external view returns (uint256) {\n    return s.swapStorages[canonicalId].getA();\n  }\n\n  /**\n   * @notice Return A in its raw precision form\n   * @dev See the StableSwap paper for details\n   * @param canonicalId the canonical token id\n   * @return A parameter in its raw precision form\n   */\n  function getSwapAPrecise(bytes32 canonicalId) external view returns (uint256) {\n    return s.swapStorages[canonicalId].getAPrecise();\n  }\n\n  /**\n   * @notice Return address of the pooled token at given index. Reverts if tokenIndex is out of range.\n   * @param canonicalId the canonical token id\n   * @param index the index of the token\n   * @return address of the token at given index\n   */\n  function getSwapToken(bytes32 canonicalId, uint8 index) public view returns (IERC20) {\n    if (index >= s.swapStorages[canonicalId].pooledTokens.length) revert StableSwapFacet__getSwapToken_outOfRange();\n    return s.swapStorages[canonicalId].pooledTokens[index];\n  }\n\n  /**\n   * @notice Return the index of the given token address. Reverts if no matching\n   * token is found.\n   * @param canonicalId the canonical token id\n   * @param tokenAddress address of the token\n   * @return the index of the given token address\n   */\n  function getSwapTokenIndex(bytes32 canonicalId, address tokenAddress) public view returns (uint8) {\n    uint8 index = s.tokenIndexes[canonicalId][tokenAddress];\n    if (address(getSwapToken(canonicalId, index)) != tokenAddress) revert StableSwapFacet__getSwapTokenIndex_notExist();\n    return index;\n  }\n\n  /**\n   * @notice Return current balance of the pooled token at given index\n   * @param canonicalId the canonical token id\n   * @param index the index of the token\n   * @return current balance of the pooled token at given index with token's native precision\n   */\n  function getSwapTokenBalance(bytes32 canonicalId, uint8 index) external view returns (uint256) {\n    if (index >= s.swapStorages[canonicalId].balances.length)\n      revert StableSwapFacet__getSwapTokenBalance_indexOutOfRange();\n    return s.swapStorages[canonicalId].balances[index];\n  }\n\n  /**\n   * @notice Get the virtual price, to help calculate profit\n   * @param canonicalId the canonical token id\n   * @return the virtual price, scaled to the POOL_PRECISION_DECIMALS\n   */\n  function getSwapVirtualPrice(bytes32 canonicalId) external view returns (uint256) {\n    return s.swapStorages[canonicalId].getVirtualPrice();\n  }\n\n  /**\n   * @notice Calculate amount of tokens you receive on swap\n   * @param canonicalId the canonical token id\n   * @param tokenIndexFrom the token the user wants to sell\n   * @param tokenIndexTo the token the user wants to buy\n   * @param dx the amount of tokens the user wants to sell. If the token charges\n   * a fee on transfers, use the amount that gets transferred after the fee.\n   * @return amount of tokens the user will receive\n   */\n  function calculateSwap(\n    bytes32 canonicalId,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx\n  ) external view returns (uint256) {\n    return s.swapStorages[canonicalId].calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n  }\n\n  /**\n   * @notice A simple method to calculate prices from deposits or\n   * withdrawals, excluding fees but including slippage. This is\n   * helpful as an input into the various \"min\" parameters on calls\n   * to fight front-running\n   *\n   * @dev This shouldn't be used outside frontends for user estimates.\n   *\n   * @param canonicalId the canonical token id\n   * @param amounts an array of token amounts to deposit or withdrawal,\n   * corresponding to pooledTokens. The amount should be in each\n   * pooled token's native precision. If a token charges a fee on transfers,\n   * use the amount that gets transferred after the fee.\n   * @param deposit whether this is a deposit or a withdrawal\n   * @return token amount the user will receive\n   */\n  function calculateSwapTokenAmount(\n    bytes32 canonicalId,\n    uint256[] calldata amounts,\n    bool deposit\n  ) external view returns (uint256) {\n    return s.swapStorages[canonicalId].calculateTokenAmount(amounts, deposit);\n  }\n\n  /**\n   * @notice A simple method to calculate amount of each underlying\n   * tokens that is returned upon burning given amount of LP tokens\n   * @param canonicalId the canonical token id\n   * @param amount the amount of LP tokens that would be burned on withdrawal\n   * @return array of token balances that the user will receive\n   */\n  function calculateRemoveSwapLiquidity(bytes32 canonicalId, uint256 amount) external view returns (uint256[] memory) {\n    return s.swapStorages[canonicalId].calculateRemoveLiquidity(amount);\n  }\n\n  /**\n   * @notice Calculate the amount of underlying token available to withdraw\n   * when withdrawing via only single token\n   * @param canonicalId the canonical token id\n   * @param tokenAmount the amount of LP token to burn\n   * @param tokenIndex index of which token will be withdrawn\n   * @return availableTokenAmount calculated amount of underlying token\n   * available to withdraw\n   */\n  function calculateRemoveSwapLiquidityOneToken(\n    bytes32 canonicalId,\n    uint256 tokenAmount,\n    uint8 tokenIndex\n  ) external view returns (uint256 availableTokenAmount) {\n    return s.swapStorages[canonicalId].calculateWithdrawOneToken(tokenAmount, tokenIndex);\n  }\n\n  /**\n   * @notice This function reads the accumulated amount of admin fees of the token with given index\n   * @param canonicalId the canonical token id\n   * @param index Index of the pooled token\n   * @return admin's token balance in the token's precision\n   */\n  function getSwapAdminBalance(bytes32 canonicalId, uint256 index) external view returns (uint256) {\n    return s.swapStorages[canonicalId].getAdminBalance(index);\n  }\n\n  /*** STATE MODIFYING FUNCTIONS ***/\n\n  /**\n   * @notice Swap two tokens using this pool\n   * @param canonicalId the canonical token id\n   * @param tokenIndexFrom the token the user wants to swap from\n   * @param tokenIndexTo the token the user wants to swap to\n   * @param dx the amount of tokens the user wants to swap from\n   * @param minDy the min amount the user would like to receive, or revert.\n   * @param deadline latest timestamp to accept this transaction\n   */\n  function swap(\n    bytes32 canonicalId,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx,\n    uint256 minDy,\n    uint256 deadline\n  ) external nonReentrant deadlineCheck(deadline) whenNotPaused returns (uint256) {\n    return s.swapStorages[canonicalId].swap(tokenIndexFrom, tokenIndexTo, dx, minDy);\n  }\n\n  /**\n   * @notice Swap two tokens using this pool\n   * @param canonicalId the canonical token id\n   * @param assetIn the token the user wants to swap from\n   * @param assetOut the token the user wants to swap to\n   * @param amountIn the amount of tokens the user wants to swap from\n   */\n  function swapExact(\n    bytes32 canonicalId,\n    uint256 amountIn,\n    address assetIn,\n    address assetOut,\n    uint256 minAmountOut,\n    uint256 deadline\n  ) external payable nonReentrant deadlineCheck(deadline) whenNotPaused returns (uint256) {\n    return\n      s.swapStorages[canonicalId].swap(\n        getSwapTokenIndex(canonicalId, assetIn),\n        getSwapTokenIndex(canonicalId, assetOut),\n        amountIn,\n        minAmountOut\n      );\n  }\n\n  /**\n   * @notice Swap two tokens using this pool\n   * @param canonicalId the canonical token id\n   * @param assetIn the token the user wants to swap from\n   * @param assetOut the token the user wants to swap to\n   * @param amountOut the amount of tokens the user wants to swap to\n   */\n  function swapExactOut(\n    bytes32 canonicalId,\n    uint256 amountOut,\n    address assetIn,\n    address assetOut,\n    uint256 maxAmountIn,\n    uint256 deadline\n  ) external payable nonReentrant deadlineCheck(deadline) returns (uint256) {\n    return\n      s.swapStorages[canonicalId].swapOut(\n        getSwapTokenIndex(canonicalId, assetIn),\n        getSwapTokenIndex(canonicalId, assetOut),\n        amountOut,\n        maxAmountIn\n      );\n  }\n\n  /**\n   * @notice Add liquidity to the pool with the given amounts of tokens\n   * @param canonicalId the canonical token id\n   * @param amounts the amounts of each token to add, in their native precision\n   * @param minToMint the minimum LP tokens adding this amount of liquidity\n   * should mint, otherwise revert. Handy for front-running mitigation\n   * @param deadline latest timestamp to accept this transaction\n   * @return amount of LP token user minted and received\n   */\n  function addSwapLiquidity(\n    bytes32 canonicalId,\n    uint256[] calldata amounts,\n    uint256 minToMint,\n    uint256 deadline\n  ) external nonReentrant deadlineCheck(deadline) returns (uint256) {\n    return s.swapStorages[canonicalId].addLiquidity(amounts, minToMint);\n  }\n\n  /**\n   * @notice Burn LP tokens to remove liquidity from the pool. Withdraw fee that decays linearly\n   * over period of 4 weeks since last deposit will apply.\n   * @dev Liquidity can always be removed, even when the pool is paused.\n   * @param canonicalId the canonical token id\n   * @param amount the amount of LP tokens to burn\n   * @param minAmounts the minimum amounts of each token in the pool\n   *        acceptable for this burn. Useful as a front-running mitigation\n   * @param deadline latest timestamp to accept this transaction\n   * @return amounts of tokens user received\n   */\n  function removeSwapLiquidity(\n    bytes32 canonicalId,\n    uint256 amount,\n    uint256[] calldata minAmounts,\n    uint256 deadline\n  ) external nonReentrant deadlineCheck(deadline) whenNotPaused returns (uint256[] memory) {\n    return s.swapStorages[canonicalId].removeLiquidity(amount, minAmounts);\n  }\n\n  /**\n   * @notice Remove liquidity from the pool all in one token. Withdraw fee that decays linearly\n   * over period of 4 weeks since last deposit will apply.\n   * @param canonicalId the canonical token id\n   * @param tokenAmount the amount of the token you want to receive\n   * @param tokenIndex the index of the token you want to receive\n   * @param minAmount the minimum amount to withdraw, otherwise revert\n   * @param deadline latest timestamp to accept this transaction\n   * @return amount of chosen token user received\n   */\n  function removeSwapLiquidityOneToken(\n    bytes32 canonicalId,\n    uint256 tokenAmount,\n    uint8 tokenIndex,\n    uint256 minAmount,\n    uint256 deadline\n  ) external nonReentrant deadlineCheck(deadline) whenNotPaused returns (uint256) {\n    return s.swapStorages[canonicalId].removeLiquidityOneToken(tokenAmount, tokenIndex, minAmount);\n  }\n\n  /**\n   * @notice Remove liquidity from the pool, weighted differently than the\n   * pool's current balances. Withdraw fee that decays linearly\n   * over period of 4 weeks since last deposit will apply.\n   * @param canonicalId the canonical token id\n   * @param amounts how much of each token to withdraw\n   * @param maxBurnAmount the max LP token provider is willing to pay to\n   * remove liquidity. Useful as a front-running mitigation.\n   * @param deadline latest timestamp to accept this transaction\n   * @return amount of LP tokens burned\n   */\n  function removeSwapLiquidityImbalance(\n    bytes32 canonicalId,\n    uint256[] calldata amounts,\n    uint256 maxBurnAmount,\n    uint256 deadline\n  ) external nonReentrant deadlineCheck(deadline) whenNotPaused returns (uint256) {\n    return s.swapStorages[canonicalId].removeLiquidityImbalance(amounts, maxBurnAmount);\n  }\n\n  /*** ADMIN FUNCTIONS ***/\n  /**\n   * @notice Initializes this Swap contract with the given parameters.\n   * This will also clone a LPToken contract that represents users'\n   * LP positions. The owner of LPToken will be this contract - which means\n   * only this contract is allowed to mint/burn tokens.\n   *\n   * @param _canonicalId the canonical token id\n   * @param _pooledTokens an array of ERC20s this pool will accept\n   * @param decimals the decimals to use for each pooled token,\n   * eg 8 for WBTC. Cannot be larger than POOL_PRECISION_DECIMALS\n   * @param lpTokenName the long-form name of the token to be deployed\n   * @param lpTokenSymbol the short symbol for the token to be deployed\n   * @param _a the amplification coefficient * n * (n - 1). See the\n   * StableSwap paper for details\n   * @param _fee default swap fee to be initialized with\n   * @param _adminFee default adminFee to be initialized with\n   * @param lpTokenTargetAddress the address of an existing LPToken contract to use as a target\n   */\n  function initializeSwap(\n    bytes32 _canonicalId,\n    IERC20[] memory _pooledTokens,\n    uint8[] memory decimals,\n    string memory lpTokenName,\n    string memory lpTokenSymbol,\n    uint256 _a,\n    uint256 _fee,\n    uint256 _adminFee,\n    address lpTokenTargetAddress\n  ) external onlyOwner {\n    if (s.swapStorages[_canonicalId].pooledTokens.length != 0)\n      revert StableSwapFacet__initializeSwap_alreadyInitialized();\n\n    // Check _pooledTokens and precisions parameter\n    if (_pooledTokens.length <= 1 || _pooledTokens.length > 32)\n      revert StableSwapFacet__initializeSwap_invalidPooledTokens();\n\n    if (_pooledTokens.length != decimals.length) revert StableSwapFacet__initializeSwap_decimalsMismatch();\n\n    uint256[] memory precisionMultipliers = new uint256[](decimals.length);\n\n    for (uint8 i = 0; i < _pooledTokens.length; i++) {\n      if (i > 0) {\n        // Check if index is already used. Check if 0th element is a duplicate.\n        if (s.tokenIndexes[_canonicalId][address(_pooledTokens[i])] != 0 || _pooledTokens[0] == _pooledTokens[i])\n          revert StableSwapFacet__initializeSwap_duplicateTokens();\n      }\n      if (address(_pooledTokens[i]) == address(0)) revert StableSwapFacet__initializeSwap_zeroTokenAddress();\n\n      if (decimals[i] > SwapUtils.POOL_PRECISION_DECIMALS)\n        revert StableSwapFacet__initializeSwap_tokenDecimalsExceedMax();\n\n      precisionMultipliers[i] = 10**uint256(SwapUtils.POOL_PRECISION_DECIMALS - decimals[i]);\n      s.tokenIndexes[_canonicalId][address(_pooledTokens[i])] = i;\n    }\n\n    // Check _a, _fee, _adminFee, _withdrawFee parameters\n    if (_a >= AmplificationUtils.MAX_A) revert StableSwapFacet__initializeSwap_aExceedMax();\n    if (_fee >= SwapUtils.MAX_SWAP_FEE) revert StableSwapFacet__initializeSwap_feeExceedMax();\n    if (_adminFee >= SwapUtils.MAX_ADMIN_FEE) revert StableSwapFacet__initializeSwap_adminFeeExceedMax();\n\n    // Initialize a LPToken contract\n    LPToken lpToken = LPToken(Clones.clone(lpTokenTargetAddress));\n    if (!lpToken.initialize(lpTokenName, lpTokenSymbol))\n      revert StableSwapFacet__initializeSwap_failedInitLpTokenClone();\n\n    // Initialize swapStorage struct\n    s.swapStorages[_canonicalId] = SwapUtils.Swap({\n      initialA: _a * AmplificationUtils.A_PRECISION,\n      futureA: _a * AmplificationUtils.A_PRECISION,\n      swapFee: _fee,\n      adminFee: _adminFee,\n      lpToken: lpToken,\n      pooledTokens: _pooledTokens,\n      tokenPrecisionMultipliers: precisionMultipliers,\n      balances: new uint256[](_pooledTokens.length),\n      adminFees: new uint256[](_pooledTokens.length),\n      initialATime: 0,\n      futureATime: 0\n    });\n  }\n\n  /**\n   * @notice Withdraw all admin fees to the contract owner\n   * @param canonicalId the canonical token id\n   */\n  function withdrawSwapAdminFees(bytes32 canonicalId) external onlyOwner {\n    s.swapStorages[canonicalId].withdrawAdminFees(msg.sender);\n  }\n\n  /**\n   * @notice Update the admin fee. Admin fee takes portion of the swap fee.\n   * @param canonicalId the canonical token id\n   * @param newAdminFee new admin fee to be applied on future transactions\n   */\n  function setSwapAdminFee(bytes32 canonicalId, uint256 newAdminFee) external onlyOwner {\n    s.swapStorages[canonicalId].setAdminFee(newAdminFee);\n  }\n\n  /**\n   * @notice Update the swap fee to be applied on swaps\n   * @param canonicalId the canonical token id\n   * @param newSwapFee new swap fee to be applied on future transactions\n   */\n  function setSwapFee(bytes32 canonicalId, uint256 newSwapFee) external onlyOwner {\n    s.swapStorages[canonicalId].setSwapFee(newSwapFee);\n  }\n\n  /**\n   * @notice Start ramping up or down A parameter towards given futureA and futureTime\n   * Checks if the change is too rapid, and commits the new A value only when it falls under\n   * the limit range.\n   * @param canonicalId the canonical token id\n   * @param futureA the new A to ramp towards\n   * @param futureTime timestamp when the new A should be reached\n   */\n  function rampA(\n    bytes32 canonicalId,\n    uint256 futureA,\n    uint256 futureTime\n  ) external onlyOwner {\n    s.swapStorages[canonicalId].rampA(futureA, futureTime);\n  }\n\n  /**\n   * @notice Stop ramping A immediately. Reverts if ramp A is already stopped.\n   * @param canonicalId the canonical token id\n   */\n  function stopRampA(bytes32 canonicalId) external onlyOwner {\n    s.swapStorages[canonicalId].stopRampA();\n  }\n}"
    }
  ]
}