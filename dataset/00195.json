{
  "Title": "M-1: ZivoeYDL::distributeYield() will revert if protocolRecipients recipients length is smaller than residualRecipients",
  "Content": "# Issue M-1: ZivoeYDL::distributeYield() will revert if protocolRecipients recipients length is smaller than residualRecipients \n\nSource: https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/15 \n\n## Found by \nBiasedMerc\n## Summary\n\n`ZivoeYDL::distributeYield` incorrectly accesses `_protocol[i]` instead of `_residual[i]`, and there are no checks anywhere within the code that ensures that both arrays are of the same length. Meaning that it is likely that this will cause `distributeYield()` to revert in the case where `protocolRecipients` length is less than `residualRecipients`.\n\n## Vulnerability Detail\n\n`ZivoeYDL::updateRecipients` allows the timelock contract to update the `protocolRecipients` or `residualRecipients` variables:\n\n[ZivoeYDL::updateRecipients](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeYDL.sol#L392-L416)\n```solidity\n    function updateRecipients(address[] memory recipients, uint256[] memory proportions, bool protocol) external {\n        require(_msgSender() == IZivoeGlobals_YDL(GBL).TLC(), \"ZivoeYDL::updateRecipients() _msgSender() != TLC()\");\n        require(\n            recipients.length == proportions.length && recipients.length > 0, \n            \"ZivoeYDL::updateRecipients() recipients.length != proportions.length || recipients.length == 0\"\n        );\n        require(unlocked, \"ZivoeYDL::updateRecipients() !unlocked\");\n... SKIP!...\n        if (protocol) {\n            emit UpdatedProtocolRecipients(recipients, proportions);\n            protocolRecipients = Recipients(recipients, proportions);\n        }\n        else {\n            emit UpdatedResidualRecipients(recipients, proportions);\n            residualRecipients = Recipients(recipients, proportions);\n        }\n    }\n```\nIt's important to note this function only sets one of those 2 variables at a time, and the length checks on `recipients` and `proportions` is to ensure that the `Recipients()` struct inputs have the same length, NOT to ensure that `protocolRecipients` and `residualRecipients` are the same length. \n\n`ZivoeYDL::distributeYield` calculates protocol earnings and distributes the yield to both the `protocolRecipients` and `residualRecipients`. It does so by looping through the recipients and the earnings:\n\n[ZivoeYDL::distributeYield](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeYDL.sol#L213-L286)\n```solidity\n    function distributeYield() external nonReentrant {\n        require(unlocked, \"ZivoeYDL::distributeYield() !unlocked\"); \n        require(\n            block.timestamp >= lastDistribution + daysBetweenDistributions * 86400, \n            \"ZivoeYDL::distributeYield() block.timestamp < lastDistribution + daysBetweenDistributions * 86400\"\n        );\n\n        // Calculate protocol earnings.\n        uint256 earnings = IERC20(distributedAsset).balanceOf(address(this));\n        uint256 protocolEarnings = protocolEarningsRateBIPS * earnings / BIPS;\n        uint256 postFeeYield = earnings.floorSub(protocolEarnings);\n\n        // Update timeline.\n        distributionCounter += 1;\n        lastDistribution = block.timestamp;\n\n        // Calculate yield distribution (trancheuse = \"slicer\" in French).\n        (\n            uint256[] memory _protocol, uint256 _seniorTranche, uint256 _juniorTranche, uint256[] memory _residual\n        ) = earningsTrancheuse(protocolEarnings, postFeeYield); \n\n... SKIP!...\n\n        // Distribute protocol earnings.\n        for (uint256 i = 0; i < protocolRecipients.recipients.length; i++) {\n            address _recipient = protocolRecipients.recipients[i];\n            if (_recipient == IZivoeGlobals_YDL(GBL).stSTT() ||_recipient == IZivoeGlobals_YDL(GBL).stJTT()) {\n                IERC20(distributedAsset).safeIncreaseAllowance(_recipient, _protocol[i]);\n                IZivoeRewards_YDL(_recipient).depositReward(distributedAsset, _protocol[i]);\n                emit YieldDistributedSingle(distributedAsset, _recipient, _protocol[i]);\n            }\n \n... SKIP!...\n\n        // Distribute residual earnings.\n        for (uint256 i = 0; i < residualRecipients.recipients.length; i++) {\n            if (_residual[i] > 0) {\n                address _recipient = residualRecipients.recipients[i];\n                if (_recipient == IZivoeGlobals_YDL(GBL).stSTT() ||_recipient == IZivoeGlobals_YDL(GBL).stJTT()) {\n                    IERC20(distributedAsset).safeIncreaseAllowance(_recipient, _residual[i]);\n                    IZivoeRewards_YDL(_recipient).depositReward(distributedAsset, _residual[i]);\n                    emit YieldDistributedSingle(distributedAsset, _recipient, _protocol[i]);\n                }\n```\nThe function loops over `protocolRecipients` and `residualRecipients` seperately and within each loop indexed positions are accessed in  `_protocol[]` and ` _residual[]`, these 2 arrays are initated as follows:\n\n[ZivoeYDL::earningsTrancheuse](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeYDL.sol#L447-L451)\n```solidity\n    function earningsTrancheuse(uint256 yP, uint256 yD) public view returns (\n        uint256[] memory protocol, uint256 senior, uint256 junior, uint256[] memory residual\n    ) {\n        protocol = new uint256[](protocolRecipients.recipients.length);\n        residual = new uint256[](residualRecipients.recipients.length);\n```\nTheir lengths will depend on the lengths of `protocolRecipients` and `residualRecipients` respectively, meaning their lengths can differ.\n\nFinally, the 2nd for loop in `distributeYield` itterates over `residualRecipients` and \n incorrectly emits the `YieldDistributedSingle` event by accessing `_protocol[i]`, whilst it should be using `_residual[i]`. This will cause the function to revert due to an out of bound index access if:\n\n`residualRecipients.recipients.length > protocolRecipients.recipients.length`\nAND\natleast one of the recipients in `residualRecipients.recipients` is:\n`IZivoeGlobals_YDL(GBL).stSTT() || IZivoeGlobals_YDL(GBL).stJTT()`\n\nwhich are the reward contracts:\n[ZivoeYDL.sol#L20-L24](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeYDL.sol#L20-L24)\n```solidity\n    /// @notice Returns the address of the ZivoeRewards ($zSTT) contract.\n    function stSTT() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeRewards ($zJTT) contract.\n    function stJTT() external view returns (address);\n```\nmeaning yield will not be able to be successfully distributed and the function will always revert as long as this condition is met.\n\n## Impact\n\nCore functionality of `ZivoeYDL` will be unaccessible due to the function always reverting as long as the above condition is met, and this condition can easily be met through normal protocol use. \n\nThis can be fixed by ensuring that both array are of the same length, however this means that appropriate fees cannot be distributed to the correct parties.\n\n## Code Snippet\n\n[ZivoeYDL.sol#L392-L416](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeYDL.sol#L392-L416)\n[ZivoeYDL.sol#L213-L286](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeYDL.sol#L213-L286)\n[ZivoeYDL.sol#L447-L451](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeYDL.sol#L447-L451)\n[ZivoeYDL.sol#L20-L24](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeYDL.sol#L20-L24)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange the incorrect emit to access from `_residual[i]` rather than `_protocol[i]`:\n[ZivoeYDL.sol#L286](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeYDL.sol#L286)\n```diff\n- emit YieldDistributedSingle(distributedAsset, _recipient, _protocol[i]);\n+ emit YieldDistributedSingle(distributedAsset, _recipient, _residual[i]);\n```\n\n\n\n## Discussion\n\n**pseudonaut**\n\nValid\n\n**sherlock-admin3**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> medium, yield distribution always reverts in some cases if protocols recepients < residual recepients\n\n\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/Zivoe/zivoe-core-foundry/pull/253\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/280",
  "Code": [
    {
      "filename": "zivoe-core-foundry/src/ZivoeYDL.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"./ZivoeMath.sol\";\n\nimport \"./libraries/FloorMath.sol\";\n\nimport \"../lib/openzeppelin-contracts/contracts/utils/Context.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ninterface IZivoeGlobals_YDL {\n    /// @notice Returns the address of the ZivoeDAO contract.\n    function DAO() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeITO contract.\n    function ITO() external view returns (address);\n    \n    /// @notice Returns the address of the ZivoeRewards ($zSTT) contract.\n    function stSTT() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeRewards ($zJTT) contract.\n    function stJTT() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeRewards ($ZVE) contract.\n    function stZVE() external view returns (address);\n\n    /// @notice Returns the address of the Timelock contract.\n    function TLC() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeRewardsVesting ($ZVE) vesting contract.\n    function vestZVE() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeTrancheToken ($zSTT) contract.\n    function zSTT() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeTrancheToken ($zJTT) contract.\n    function zJTT() external view returns (address);\n\n    /// @notice Returns the address of the Zivoe Laboratory.\n    function ZVL() external view returns (address);\n\n    /// @notice Returns total circulating supply of zSTT and zJTT, accounting for defaults via markdowns.\n    /// @return zSTTSupply zSTT.totalSupply() adjusted for defaults.\n    /// @return zJTTSupply zJTT.totalSupply() adjusted for defaults.\n    function adjustedSupplies() external view returns (uint256 zSTTSupply, uint256 zJTTSupply);\n\n    /// @notice Handles WEI standardization of a given asset amount (i.e. 6 decimal precision => 18 decimal precision).\n    /// @param  amount The amount of a given \"asset\".\n    /// @param  asset The asset (ERC-20) from which to standardize the amount to WEI.\n    /// @return standardizedAmount The above amount standardized to 18 decimals.\n    function standardize(uint256 amount, address asset) external view returns (uint256 standardizedAmount);\n\n    /// @notice This function will verify if a given stablecoin has been whitelisted for use throughout system.\n    /// @param  stablecoin address of the stablecoin to verify acceptance for.\n    function stablecoinWhitelist(address stablecoin) external view returns (bool);\n}\n\ninterface IZivoeRewards_YDL {\n    /// @notice Deposits a reward to this contract for distribution.\n    /// @param  _rewardsToken The asset that's being distributed.\n    /// @param  reward The amount of the _rewardsToken to deposit.\n    function depositReward(address _rewardsToken, uint256 reward) external;\n}\n\n\n\n/// @notice  This contract manages the accounting for distributing yield across multiple contracts.\n///          This contract has the following responsibilities:\n///            - Escrows yield in between distribution periods.\n///            - Manages accounting for yield distribution.\n///            - Supports modification of certain state variables for governance purposes.\n///            - Tracks historical values using EMA (exponential moving average) on 30-day basis.\ncontract ZivoeYDL is Context, ReentrancyGuard {\n\n    using SafeERC20 for IERC20;\n    using FloorMath for uint256;\n\n    // ---------------------\n    //    State Variables\n    // ---------------------\n\n    struct Recipients {\n        address[] recipients;\n        uint256[] proportion;\n    }\n\n    Recipients protocolRecipients;          /// @dev Tracks the distributions for protocol earnings.\n    Recipients residualRecipients;          /// @dev Tracks the distributions for residual earnings.\n\n    address public immutable GBL;           /// @dev The ZivoeGlobals contract.\n\n    address public distributedAsset;        /// @dev The \"stablecoin\" that will be distributed via YDL.\n\n    // Weighted moving averages.\n    uint256 public emaSTT;          /// @dev Weighted moving average for senior tranche size, a.k.a. zSTT.totalSupply().\n    uint256 public emaJTT;          /// @dev Weighted moving average for junior tranche size, a.k.a. zJTT.totalSupply().\n\n    // Indexing.\n    uint256 public distributionCounter;     /// @dev Number of calls to distributeYield().\n    uint256 public lastDistribution;        /// @dev Used for timelock constraint to call distributeYield().\n\n    // Accounting vars (governable).\n    uint256 public targetAPYBIPS = 1000;                /// @dev The target annualized yield for senior tranche.\n    uint256 public targetRatioBIPS = 22000;             /// @dev The target ratio of junior to senior tranche.\n    uint256 public protocolEarningsRateBIPS = 2000;     /// @dev The protocol earnings rate.\n\n    // Accounting vars (constant).\n    uint256 public constant daysBetweenDistributions = 30;   /// @dev Number of days between yield distributions.\n    uint256 public constant retrospectiveDistributions = 6;  /// @dev Retrospective moving average period.\n    \n    bool public unlocked;                   /// @dev Prevents contract from supporting functionality until unlocked.\n\n    uint256 private constant BIPS = 10000;\n    uint256 private constant RAY = 10 ** 27;\n\n    ZivoeMath public MATH;\n\n\n\n    // -----------------\n    //    Constructor\n    // -----------------\n\n    /// @notice Initialize the ZivoeYDL contract.\n    /// @param  _GBL The ZivoeGlobals contract.\n    /// @param  _distributedAsset The \"stablecoin\" that will be distributed via YDL.\n    constructor(address _GBL, address _distributedAsset) {\n        GBL = _GBL;\n        distributedAsset = _distributedAsset;\n        MATH = new ZivoeMath();\n    }\n\n\n\n    // ------------\n    //    Events\n    // ------------\n\n    /// @notice Emitted during returnAsset().\n    /// @param  asset The asset returned.\n    /// @param  amount The amount of \"asset\" returned to DAO.\n    event AssetReturned(address indexed asset, uint256 amount);\n\n    /// @notice Emitted during updateDistributedAsset().\n    /// @param  oldAsset The old value of distributedAsset.\n    /// @param  newAsset The new value of distributedAsset.\n    event UpdatedDistributedAsset(address indexed oldAsset, address indexed newAsset);\n\n    /// @notice Emitted during updateProtocolEarningsRateBIPS().\n    /// @param  oldValue The old value of protocolEarningsRateBIPS.\n    /// @param  newValue The new value of protocolEarningsRateBIPS.\n    event UpdatedProtocolEarningsRateBIPS(uint256 oldValue, uint256 newValue);\n\n    /// @notice Emitted during updateRecipients().\n    /// @param  recipients The new recipients to receive protocol earnings.\n    /// @param  proportion The proportion distributed across recipients.\n    event UpdatedProtocolRecipients(address[] recipients, uint256[] proportion);\n\n    /// @notice Emitted during updateRecipients().\n    /// @param  recipients The new recipients to receive residual earnings.\n    /// @param  proportion The proportion distributed across recipients.\n    event UpdatedResidualRecipients(address[] recipients, uint256[] proportion);\n\n    /// @notice Emitted during updateTargetAPYBIPS().\n    /// @param  oldValue The old value of targetAPYBIPS.\n    /// @param  newValue The new value of targetAPYBIPS.\n    event UpdatedTargetAPYBIPS(uint256 oldValue, uint256 newValue);\n\n    /// @notice Emitted during updateTargetRatioBIPS().\n    /// @param  oldValue The old value of targetRatioBIPS.\n    /// @param  newValue The new value of targetRatioBIPS.\n    event UpdatedTargetRatioBIPS(uint256 oldValue, uint256 newValue);\n\n    /// @notice Emitted during distributeYield().\n    /// @param  protocol The amount of earnings distributed to protocol earnings recipients.\n    /// @param  senior The amount of earnings distributed to the senior tranche.\n    /// @param  junior The amount of earnings distributed to the junior tranche.\n    /// @param  residual The amount of earnings distributed to residual earnings recipients.\n    event YieldDistributed(uint256[] protocol, uint256 senior, uint256 junior, uint256[] residual);\n\n    /// @notice Emitted during distributeYield().\n    /// @param  asset The \"asset\" being distributed.\n    /// @param  recipient The recipient of the distribution.\n    /// @param  amount The amount distributed.\n    event YieldDistributedSingle(address indexed asset, address indexed recipient, uint256 amount);\n\n\n\n    // ---------------\n    //    Functions\n    // ---------------\n\n    /// @notice View distribution information for protocol and residual earnings recipients.\n    /// @return protocolEarningsRecipients The destinations for protocol earnings distributions.\n    /// @return protocolEarningsProportion The proportions for protocol earnings distributions.\n    /// @return residualEarningsRecipients The destinations for residual earnings distributions.\n    /// @return residualEarningsProportion The proportions for residual earnings distributions.\n    function viewDistributions() external view returns (\n        address[] memory protocolEarningsRecipients, uint256[] memory protocolEarningsProportion, \n        address[] memory residualEarningsRecipients, uint256[] memory residualEarningsProportion\n    ) {\n        return (\n            protocolRecipients.recipients, \n            protocolRecipients.proportion, \n            residualRecipients.recipients, \n            residualRecipients.proportion\n        );\n    }\n    \n    /// @notice Distributes available yield within this contract to appropriate entities.\n    function distributeYield() external nonReentrant {\n        require(unlocked, \"ZivoeYDL::distributeYield() !unlocked\"); \n        require(\n            block.timestamp >= lastDistribution + daysBetweenDistributions * 86400, \n            \"ZivoeYDL::distributeYield() block.timestamp < lastDistribution + daysBetweenDistributions * 86400\"\n        );\n\n        // Calculate protocol earnings.\n        uint256 earnings = IERC20(distributedAsset).balanceOf(address(this));\n        uint256 protocolEarnings = protocolEarningsRateBIPS * earnings / BIPS;\n        uint256 postFeeYield = earnings.floorSub(protocolEarnings);\n\n        // Update timeline.\n        distributionCounter += 1;\n        lastDistribution = block.timestamp;\n\n        // Calculate yield distribution (trancheuse = \"slicer\" in French).\n        (\n            uint256[] memory _protocol, uint256 _seniorTranche, uint256 _juniorTranche, uint256[] memory _residual\n        ) = earningsTrancheuse(protocolEarnings, postFeeYield); \n\n        emit YieldDistributed(_protocol, _seniorTranche, _juniorTranche, _residual);\n        \n        // Update ema-based supply values.\n        (uint256 aSTT, uint256 aJTT) = IZivoeGlobals_YDL(GBL).adjustedSupplies();\n        emaSTT = MATH.ema(emaSTT, aSTT, retrospectiveDistributions.min(distributionCounter));\n        emaJTT = MATH.ema(emaJTT, aJTT, retrospectiveDistributions.min(distributionCounter));\n\n        // Distribute protocol earnings.\n        for (uint256 i = 0; i < protocolRecipients.recipients.length; i++) {\n            address _recipient = protocolRecipients.recipients[i];\n            if (_recipient == IZivoeGlobals_YDL(GBL).stSTT() ||_recipient == IZivoeGlobals_YDL(GBL).stJTT()) {\n                IERC20(distributedAsset).safeIncreaseAllowance(_recipient, _protocol[i]);\n                IZivoeRewards_YDL(_recipient).depositReward(distributedAsset, _protocol[i]);\n                emit YieldDistributedSingle(distributedAsset, _recipient, _protocol[i]);\n            }\n            else if (_recipient == IZivoeGlobals_YDL(GBL).stZVE()) {\n                uint256 splitBIPS = (\n                    IERC20(IZivoeGlobals_YDL(GBL).stZVE()).totalSupply() * BIPS\n                ) / (\n                    IERC20(IZivoeGlobals_YDL(GBL).stZVE()).totalSupply() + \n                    IERC20(IZivoeGlobals_YDL(GBL).vestZVE()).totalSupply()\n                );\n                uint stZVEAllocation = _protocol[i] * splitBIPS / BIPS;\n                uint vestZVEAllocation = _protocol[i] * (BIPS - splitBIPS) / BIPS;\n                IERC20(distributedAsset).safeIncreaseAllowance(IZivoeGlobals_YDL(GBL).stZVE(), stZVEAllocation);\n                IERC20(distributedAsset).safeIncreaseAllowance(IZivoeGlobals_YDL(GBL).vestZVE(),vestZVEAllocation);\n                IZivoeRewards_YDL(IZivoeGlobals_YDL(GBL).stZVE()).depositReward(distributedAsset, stZVEAllocation);\n                IZivoeRewards_YDL(IZivoeGlobals_YDL(GBL).vestZVE()).depositReward(distributedAsset, vestZVEAllocation);\n                emit YieldDistributedSingle(distributedAsset, IZivoeGlobals_YDL(GBL).stZVE(), stZVEAllocation);\n                emit YieldDistributedSingle(distributedAsset, IZivoeGlobals_YDL(GBL).vestZVE(), vestZVEAllocation);\n            }\n            else {\n                IERC20(distributedAsset).safeTransfer(_recipient, _protocol[i]);\n                emit YieldDistributedSingle(distributedAsset, _recipient, _protocol[i]);\n            }\n        }\n\n        // Distribute senior and junior tranche earnings.\n        IERC20(distributedAsset).safeIncreaseAllowance(IZivoeGlobals_YDL(GBL).stSTT(), _seniorTranche);\n        IERC20(distributedAsset).safeIncreaseAllowance(IZivoeGlobals_YDL(GBL).stJTT(), _juniorTranche);\n        IZivoeRewards_YDL(IZivoeGlobals_YDL(GBL).stSTT()).depositReward(distributedAsset, _seniorTranche);\n        IZivoeRewards_YDL(IZivoeGlobals_YDL(GBL).stJTT()).depositReward(distributedAsset, _juniorTranche);\n        emit YieldDistributedSingle(distributedAsset, IZivoeGlobals_YDL(GBL).stSTT(), _seniorTranche);\n        emit YieldDistributedSingle(distributedAsset, IZivoeGlobals_YDL(GBL).stJTT(), _juniorTranche);\n\n        // Distribute residual earnings.\n        for (uint256 i = 0; i < residualRecipients.recipients.length; i++) {\n            if (_residual[i] > 0) {\n                address _recipient = residualRecipients.recipients[i];\n                if (_recipient == IZivoeGlobals_YDL(GBL).stSTT() ||_recipient == IZivoeGlobals_YDL(GBL).stJTT()) {\n                    IERC20(distributedAsset).safeIncreaseAllowance(_recipient, _residual[i]);\n                    IZivoeRewards_YDL(_recipient).depositReward(distributedAsset, _residual[i]);\n                    emit YieldDistributedSingle(distributedAsset, _recipient, _protocol[i]);\n                }\n                else if (_recipient == IZivoeGlobals_YDL(GBL).stZVE()) {\n                    uint256 splitBIPS = (\n                        IERC20(IZivoeGlobals_YDL(GBL).stZVE()).totalSupply() * BIPS\n                    ) / (\n                        IERC20(IZivoeGlobals_YDL(GBL).stZVE()).totalSupply() + \n                        IERC20(IZivoeGlobals_YDL(GBL).vestZVE()).totalSupply()\n                    );\n                    uint stZVEAllocation = _residual[i] * splitBIPS / BIPS;\n                    uint vestZVEAllocation = _residual[i] * (BIPS - splitBIPS) / BIPS;\n                    IERC20(distributedAsset).safeIncreaseAllowance(IZivoeGlobals_YDL(GBL).stZVE(), stZVEAllocation);\n                    IERC20(distributedAsset).safeIncreaseAllowance(IZivoeGlobals_YDL(GBL).vestZVE(), vestZVEAllocation);\n                    IZivoeRewards_YDL(IZivoeGlobals_YDL(GBL).stZVE()).depositReward(distributedAsset, stZVEAllocation);\n                    IZivoeRewards_YDL(IZivoeGlobals_YDL(GBL).vestZVE()).depositReward(distributedAsset, vestZVEAllocation);\n                    emit YieldDistributedSingle(distributedAsset, IZivoeGlobals_YDL(GBL).stZVE(), stZVEAllocation);\n                    emit YieldDistributedSingle(distributedAsset, IZivoeGlobals_YDL(GBL).vestZVE(), vestZVEAllocation);\n                }\n                else {\n                    IERC20(distributedAsset).safeTransfer(_recipient, _residual[i]);\n                    emit YieldDistributedSingle(distributedAsset, _recipient, _residual[i]);\n                }\n            }\n        }\n    }\n\n    /// @notice Returns an asset to DAO if not distributedAsset().\n    /// @param asset The asset to return.\n    function returnAsset(address asset) external {\n        require(asset != distributedAsset, \"ZivoeYDL::returnAsset() asset == distributedAsset\");\n        emit AssetReturned(asset, IERC20(asset).balanceOf(address(this)));\n        IERC20(asset).safeTransfer(IZivoeGlobals_YDL(GBL).DAO(), IERC20(asset).balanceOf(address(this)));\n    }\n\n    /// @notice Unlocks this contract for distributions, initializes values.\n    function unlock() external {\n        require(\n            _msgSender() == IZivoeGlobals_YDL(GBL).ITO(), \n            \"ZivoeYDL::unlock() _msgSender() != IZivoeGlobals_YDL(GBL).ITO()\"\n        );\n\n        unlocked = true;\n        lastDistribution = block.timestamp + 30 days;\n\n        emaSTT = IERC20(IZivoeGlobals_YDL(GBL).zSTT()).totalSupply();\n        emaJTT = IERC20(IZivoeGlobals_YDL(GBL).zJTT()).totalSupply();\n\n        address[] memory protocolRecipientAcc = new address[](2);\n        uint256[] memory protocolRecipientAmt = new uint256[](2);\n\n        protocolRecipientAcc[0] = address(IZivoeGlobals_YDL(GBL).stZVE());\n        protocolRecipientAmt[0] = 6666;\n        protocolRecipientAcc[1] = address(IZivoeGlobals_YDL(GBL).ZVL());\n        protocolRecipientAmt[1] = 3334;\n\n        protocolRecipients = Recipients(protocolRecipientAcc, protocolRecipientAmt);\n\n        address[] memory residualRecipientAcc = new address[](2);\n        uint256[] memory residualRecipientAmt = new uint256[](2);\n\n        residualRecipientAcc[0] = address(IZivoeGlobals_YDL(GBL).stZVE());\n        residualRecipientAmt[0] = 6666;\n        residualRecipientAcc[1] = address(IZivoeGlobals_YDL(GBL).ZVL());\n        residualRecipientAmt[1] = 3334;\n\n        residualRecipients = Recipients(residualRecipientAcc, residualRecipientAmt);\n    }\n\n    /// @notice Updates the distributed asset for this particular contract.\n    /// @param  _distributedAsset The new value for distributedAsset.\n    function updateDistributedAsset(address _distributedAsset) external nonReentrant {\n        require(\n            _distributedAsset != distributedAsset, \n            \"ZivoeYDL::updateDistributedAsset() _distributedAsset == distributedAsset\"\n        );\n        require(\n            _msgSender() == IZivoeGlobals_YDL(GBL).TLC(), \n            \"ZivoeYDL::updateDistributedAsset() _msgSender() != TLC()\"\n        );\n        require(\n            IZivoeGlobals_YDL(GBL).stablecoinWhitelist(_distributedAsset),\n            \"ZivoeYDL::updateDistributedAsset() !IZivoeGlobals_YDL(GBL).stablecoinWhitelist(_distributedAsset)\"\n        );\n        emit UpdatedDistributedAsset(distributedAsset, _distributedAsset);\n        distributedAsset = _distributedAsset;\n    }\n\n    /// @notice Updates the state variable \"protocolEarningsRateBIPS\".\n    /// @param  _protocolEarningsRateBIPS The new value for protocolEarningsRateBIPS.\n    function updateProtocolEarningsRateBIPS(uint256 _protocolEarningsRateBIPS) external {\n        require(\n            _msgSender() == IZivoeGlobals_YDL(GBL).TLC(), \n            \"ZivoeYDL::updateProtocolEarningsRateBIPS() _msgSender() != TLC()\"\n        );\n        require(\n            _protocolEarningsRateBIPS <= 9000, \n            \"ZivoeYDL::updateProtocolEarningsRateBIPS() _protocolEarningsRateBIPS > 9000\"\n        );\n        emit UpdatedProtocolEarningsRateBIPS(protocolEarningsRateBIPS, _protocolEarningsRateBIPS);\n        protocolEarningsRateBIPS = _protocolEarningsRateBIPS;\n    }\n\n    /// @notice Updates the protocolRecipients or residualRecipients.\n    /// @param  recipients An array of addresses to which protocol earnings will be distributed.\n    /// @param  proportions An array of ratios relative to the recipients - in BIPS. Sum should equal to 10000.\n    /// @param  protocol Specify \"true\" to update protocol earnings, or \"false\" to update residual earnings.\n    function updateRecipients(address[] memory recipients, uint256[] memory proportions, bool protocol) external {\n        require(_msgSender() == IZivoeGlobals_YDL(GBL).TLC(), \"ZivoeYDL::updateRecipients() _msgSender() != TLC()\");\n        require(\n            recipients.length == proportions.length && recipients.length > 0, \n            \"ZivoeYDL::updateRecipients() recipients.length != proportions.length || recipients.length == 0\"\n        );\n        require(unlocked, \"ZivoeYDL::updateRecipients() !unlocked\");\n\n        uint256 proportionTotal;\n        for (uint256 i = 0; i < recipients.length; i++) {\n            proportionTotal += proportions[i];\n            require(proportions[i] > 0, \"ZivoeYDL::updateRecipients() proportions[i] == 0\");\n            require(recipients[i] != address(0), \"ZivoeYDL::updateRecipients() recipients[i] == address(0)\");\n        }\n\n        require(proportionTotal == BIPS, \"ZivoeYDL::updateRecipients() proportionTotal != BIPS (10,000)\");\n        if (protocol) {\n            emit UpdatedProtocolRecipients(recipients, proportions);\n            protocolRecipients = Recipients(recipients, proportions);\n        }\n        else {\n            emit UpdatedResidualRecipients(recipients, proportions);\n            residualRecipients = Recipients(recipients, proportions);\n        }\n    }\n\n    /// @notice Updates the state variable \"targetAPYBIPS\".\n    /// @param  _targetAPYBIPS The new value for targetAPYBIPS.\n    function updateTargetAPYBIPS(uint256 _targetAPYBIPS) external {\n        require(_msgSender() == IZivoeGlobals_YDL(GBL).TLC(), \"ZivoeYDL::updateTargetAPYBIPS() _msgSender() != TLC()\");\n        emit UpdatedTargetAPYBIPS(targetAPYBIPS, _targetAPYBIPS);\n        targetAPYBIPS = _targetAPYBIPS;\n    }\n\n    /// @notice Updates the state variable \"targetRatioBIPS\".\n    /// @param  _targetRatioBIPS The new value for targetRatioBIPS.\n    function updateTargetRatioBIPS(uint256 _targetRatioBIPS) external {\n        require(_msgSender() == IZivoeGlobals_YDL(GBL).TLC(), \"ZivoeYDL::updateTargetRatioBIPS() _msgSender() != TLC()\");\n        emit UpdatedTargetRatioBIPS(targetRatioBIPS, _targetRatioBIPS);\n        targetRatioBIPS = _targetRatioBIPS;\n    }\n\n\n\n    // ----------\n    //    Math\n    // ----------\n\n    /// @notice Calculates the distribution of yield (\"earnings\") for the four primary groups.\n    /// @param  yP Yield for the protocol.\n    /// @param  yD Yield for the remaining three groups.\n    /// @return protocol Protocol earnings.\n    /// @return senior Senior tranche earnings.\n    /// @return junior Junior tranche earnings.\n    /// @return residual Residual earnings.\n    function earningsTrancheuse(uint256 yP, uint256 yD) public view returns (\n        uint256[] memory protocol, uint256 senior, uint256 junior, uint256[] memory residual\n    ) {\n        protocol = new uint256[](protocolRecipients.recipients.length);\n        residual = new uint256[](residualRecipients.recipients.length);\n        \n        // Accounting for protocol earnings.\n        for (uint256 i = 0; i < protocolRecipients.recipients.length; i++) {\n            protocol[i] = protocolRecipients.proportion[i] * yP / BIPS;\n        }\n\n        // Accounting for senior and junior earnings.\n        uint256 _seniorProportion = MATH.seniorProportion(\n            IZivoeGlobals_YDL(GBL).standardize(yD, distributedAsset),\n            MATH.yieldTarget(emaSTT, emaJTT, targetAPYBIPS, targetRatioBIPS, daysBetweenDistributions),\n            emaSTT, emaJTT, targetAPYBIPS, targetRatioBIPS, daysBetweenDistributions\n        );\n        senior = (yD * _seniorProportion) / RAY;\n        junior = (yD * MATH.juniorProportion(emaSTT, emaJTT, _seniorProportion, targetRatioBIPS)) / RAY;\n        \n        // Handle accounting for residual earnings.\n        yD = yD.floorSub(senior + junior);\n        for (uint256 i = 0; i < residualRecipients.recipients.length; i++) {\n            residual[i] = residualRecipients.proportion[i] * yD / BIPS;\n        }\n    }\n\n}"
    },
    {
      "filename": "zivoe-core-foundry/src/ZivoeYDL.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"./ZivoeMath.sol\";\n\nimport \"./libraries/FloorMath.sol\";\n\nimport \"../lib/openzeppelin-contracts/contracts/utils/Context.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ninterface IZivoeGlobals_YDL {\n    /// @notice Returns the address of the ZivoeDAO contract.\n    function DAO() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeITO contract.\n    function ITO() external view returns (address);\n    \n    /// @notice Returns the address of the ZivoeRewards ($zSTT) contract.\n    function stSTT() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeRewards ($zJTT) contract.\n    function stJTT() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeRewards ($ZVE) contract.\n    function stZVE() external view returns (address);\n\n    /// @notice Returns the address of the Timelock contract.\n    function TLC() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeRewardsVesting ($ZVE) vesting contract.\n    function vestZVE() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeTrancheToken ($zSTT) contract.\n    function zSTT() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeTrancheToken ($zJTT) contract.\n    function zJTT() external view returns (address);\n\n    /// @notice Returns the address of the Zivoe Laboratory.\n    function ZVL() external view returns (address);\n\n    /// @notice Returns total circulating supply of zSTT and zJTT, accounting for defaults via markdowns.\n    /// @return zSTTSupply zSTT.totalSupply() adjusted for defaults.\n    /// @return zJTTSupply zJTT.totalSupply() adjusted for defaults.\n    function adjustedSupplies() external view returns (uint256 zSTTSupply, uint256 zJTTSupply);\n\n    /// @notice Handles WEI standardization of a given asset amount (i.e. 6 decimal precision => 18 decimal precision).\n    /// @param  amount The amount of a given \"asset\".\n    /// @param  asset The asset (ERC-20) from which to standardize the amount to WEI.\n    /// @return standardizedAmount The above amount standardized to 18 decimals.\n    function standardize(uint256 amount, address asset) external view returns (uint256 standardizedAmount);\n\n    /// @notice This function will verify if a given stablecoin has been whitelisted for use throughout system.\n    /// @param  stablecoin address of the stablecoin to verify acceptance for.\n    function stablecoinWhitelist(address stablecoin) external view returns (bool);\n}\n\ninterface IZivoeRewards_YDL {\n    /// @notice Deposits a reward to this contract for distribution.\n    /// @param  _rewardsToken The asset that's being distributed.\n    /// @param  reward The amount of the _rewardsToken to deposit.\n    function depositReward(address _rewardsToken, uint256 reward) external;\n}\n\n\n\n/// @notice  This contract manages the accounting for distributing yield across multiple contracts.\n///          This contract has the following responsibilities:\n///            - Escrows yield in between distribution periods.\n///            - Manages accounting for yield distribution.\n///            - Supports modification of certain state variables for governance purposes.\n///            - Tracks historical values using EMA (exponential moving average) on 30-day basis.\ncontract ZivoeYDL is Context, ReentrancyGuard {\n\n    using SafeERC20 for IERC20;\n    using FloorMath for uint256;\n\n    // ---------------------\n    //    State Variables\n    // ---------------------\n\n    struct Recipients {\n        address[] recipients;\n        uint256[] proportion;\n    }\n\n    Recipients protocolRecipients;          /// @dev Tracks the distributions for protocol earnings.\n    Recipients residualRecipients;          /// @dev Tracks the distributions for residual earnings.\n\n    address public immutable GBL;           /// @dev The ZivoeGlobals contract.\n\n    address public distributedAsset;        /// @dev The \"stablecoin\" that will be distributed via YDL.\n\n    // Weighted moving averages.\n    uint256 public emaSTT;          /// @dev Weighted moving average for senior tranche size, a.k.a. zSTT.totalSupply().\n    uint256 public emaJTT;          /// @dev Weighted moving average for junior tranche size, a.k.a. zJTT.totalSupply().\n\n    // Indexing.\n    uint256 public distributionCounter;     /// @dev Number of calls to distributeYield().\n    uint256 public lastDistribution;        /// @dev Used for timelock constraint to call distributeYield().\n\n    // Accounting vars (governable).\n    uint256 public targetAPYBIPS = 1000;                /// @dev The target annualized yield for senior tranche.\n    uint256 public targetRatioBIPS = 22000;             /// @dev The target ratio of junior to senior tranche.\n    uint256 public protocolEarningsRateBIPS = 2000;     /// @dev The protocol earnings rate.\n\n    // Accounting vars (constant).\n    uint256 public constant daysBetweenDistributions = 30;   /// @dev Number of days between yield distributions.\n    uint256 public constant retrospectiveDistributions = 6;  /// @dev Retrospective moving average period.\n    \n    bool public unlocked;                   /// @dev Prevents contract from supporting functionality until unlocked.\n\n    uint256 private constant BIPS = 10000;\n    uint256 private constant RAY = 10 ** 27;\n\n    ZivoeMath public MATH;\n\n\n\n    // -----------------\n    //    Constructor\n    // -----------------\n\n    /// @notice Initialize the ZivoeYDL contract.\n    /// @param  _GBL The ZivoeGlobals contract.\n    /// @param  _distributedAsset The \"stablecoin\" that will be distributed via YDL.\n    constructor(address _GBL, address _distributedAsset) {\n        GBL = _GBL;\n        distributedAsset = _distributedAsset;\n        MATH = new ZivoeMath();\n    }\n\n\n\n    // ------------\n    //    Events\n    // ------------\n\n    /// @notice Emitted during returnAsset().\n    /// @param  asset The asset returned.\n    /// @param  amount The amount of \"asset\" returned to DAO.\n    event AssetReturned(address indexed asset, uint256 amount);\n\n    /// @notice Emitted during updateDistributedAsset().\n    /// @param  oldAsset The old value of distributedAsset.\n    /// @param  newAsset The new value of distributedAsset.\n    event UpdatedDistributedAsset(address indexed oldAsset, address indexed newAsset);\n\n    /// @notice Emitted during updateProtocolEarningsRateBIPS().\n    /// @param  oldValue The old value of protocolEarningsRateBIPS.\n    /// @param  newValue The new value of protocolEarningsRateBIPS.\n    event UpdatedProtocolEarningsRateBIPS(uint256 oldValue, uint256 newValue);\n\n    /// @notice Emitted during updateRecipients().\n    /// @param  recipients The new recipients to receive protocol earnings.\n    /// @param  proportion The proportion distributed across recipients.\n    event UpdatedProtocolRecipients(address[] recipients, uint256[] proportion);\n\n    /// @notice Emitted during updateRecipients().\n    /// @param  recipients The new recipients to receive residual earnings.\n    /// @param  proportion The proportion distributed across recipients.\n    event UpdatedResidualRecipients(address[] recipients, uint256[] proportion);\n\n    /// @notice Emitted during updateTargetAPYBIPS().\n    /// @param  oldValue The old value of targetAPYBIPS.\n    /// @param  newValue The new value of targetAPYBIPS.\n    event UpdatedTargetAPYBIPS(uint256 oldValue, uint256 newValue);\n\n    /// @notice Emitted during updateTargetRatioBIPS().\n    /// @param  oldValue The old value of targetRatioBIPS.\n    /// @param  newValue The new value of targetRatioBIPS.\n    event UpdatedTargetRatioBIPS(uint256 oldValue, uint256 newValue);\n\n    /// @notice Emitted during distributeYield().\n    /// @param  protocol The amount of earnings distributed to protocol earnings recipients.\n    /// @param  senior The amount of earnings distributed to the senior tranche.\n    /// @param  junior The amount of earnings distributed to the junior tranche.\n    /// @param  residual The amount of earnings distributed to residual earnings recipients.\n    event YieldDistributed(uint256[] protocol, uint256 senior, uint256 junior, uint256[] residual);\n\n    /// @notice Emitted during distributeYield().\n    /// @param  asset The \"asset\" being distributed.\n    /// @param  recipient The recipient of the distribution.\n    /// @param  amount The amount distributed.\n    event YieldDistributedSingle(address indexed asset, address indexed recipient, uint25"
    }
  ]
}