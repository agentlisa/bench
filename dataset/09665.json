{
  "Title": "L-01] `PaladinRewardReserve`'s approvals break if the same contract is in charge of two tokens (e.g. a [PalPool",
  "Content": "\nThe `approvedSpenders` mapping only takes in a spender, rather than both a spender and a token. Approval for one token means approval for all tokens the account controls. Removal for one means removal for all.\n\n1.  File: contracts/PaladinRewardReserve.sol (lines [28-31](https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol#L28-L31))\n\n```solidity\n    function setNewSpender(address token, address spender, uint256 amount) external onlyOwner {\n        require(!approvedSpenders[spender], \"Already Spender\");\n        approvedSpenders[spender] = true;\n        IERC20(token).safeApprove(spender, amount);\n```\n\n2.  File: contracts/PaladinRewardReserve.sol (lines [36-37](https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol#L36-L37))\n\n```solidity\n    function updateSpenderAllowance(address token, address spender, uint256 amount) external onlyOwner {\n        require(approvedSpenders[spender], \"Not approved Spender\");\n```\n\n3.  File: contracts/PaladinRewardReserve.sol (lines [44-46](https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol#L44-L46))\n\n```solidity\n    function removeSpender(address token, address spender) external onlyOwner {\n        require(approvedSpenders[spender], \"Not approved Spender\");\n        approvedSpenders[spender] = false;\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-03-paladin",
  "Code": [
    {
      "filename": "contracts/PaladinRewardReserve.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./open-zeppelin/utils/Ownable.sol\";\nimport \"./open-zeppelin/utils/ReentrancyGuard.sol\";\nimport \"./open-zeppelin/interfaces/IERC20.sol\";\nimport \"./open-zeppelin/libraries/SafeERC20.sol\";\n\n/** @title Paladin Reward Reserve contract  */\n/// @author Paladin\ncontract PaladinRewardReserve is Ownable, ReentrancyGuard{\n    using SafeERC20 for IERC20;\n\n    /** @notice Addresses allowed to transfer tokens from this contract */\n    mapping(address => bool) public approvedSpenders;\n\n    /** @notice Emitted when a new spender is approved*/\n    event NewSpender(address indexed token, address indexed spender, uint256 amount);\n    /** @notice Emitted when the allowance of a spander is updated */\n    event UpdateSpender(address indexed token, address indexed spender, uint256 amount);\n    /** @notice Emitted when a spender allowance is removed */\n    event RemovedSpender(address indexed token, address indexed spender);\n\n    constructor(address _admin) {\n        transferOwnership(_admin);\n    }\n\n    function setNewSpender(address token, address spender, uint256 amount) external onlyOwner {\n        require(!approvedSpenders[spender], \"Already Spender\");\n        approvedSpenders[spender] = true;\n        IERC20(token).safeApprove(spender, amount);\n\n        emit NewSpender(token, spender, amount);\n    }\n\n    function updateSpenderAllowance(address token, address spender, uint256 amount) external onlyOwner {\n        require(approvedSpenders[spender], \"Not approved Spender\");\n        IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, amount);\n\n        emit UpdateSpender(token, spender, amount);\n    }\n\n    function removeSpender(address token, address spender) external onlyOwner {\n        require(approvedSpenders[spender], \"Not approved Spender\");\n        approvedSpenders[spender] = false;\n        IERC20(token).safeApprove(spender, 0);\n\n        emit RemovedSpender(token, spender);\n    }\n\n    function transferToken(address token, address receiver, uint256 amount) external onlyOwner nonReentrant {\n        IERC20(token).safeTransfer(receiver, amount);\n    }\n\n}"
    },
    {
      "filename": "contracts/PaladinRewardReserve.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./open-zeppelin/utils/Ownable.sol\";\nimport \"./open-zeppelin/utils/ReentrancyGuard.sol\";\nimport \"./open-zeppelin/interfaces/IERC20.sol\";\nimport \"./open-zeppelin/libraries/SafeERC20.sol\";\n\n/** @title Paladin Reward Reserve contract  */\n/// @author Paladin\ncontract PaladinRewardReserve is Ownable, ReentrancyGuard{\n    using SafeERC20 for IERC20;\n\n    /** @notice Addresses allowed to transfer tokens from this contract */\n    mapping(address => bool) public approvedSpenders;\n\n    /** @notice Emitted when a new spender is approved*/\n    event NewSpender(address indexed token, address indexed spender, uint256 amount);\n    /** @notice Emitted when the allowance of a spander is updated */\n    event UpdateSpender(address indexed token, address indexed spender, uint256 amount);\n    /** @notice Emitted when a spender allowance is removed */\n    event RemovedSpender(address indexed token, address indexed spender);\n\n    constructor(address _admin) {\n        transferOwnership(_admin);\n    }\n\n    function setNewSpender(address token, address spender, uint256 amount) external onlyOwner {\n        require(!approvedSpenders[spender], \"Already Spender\");\n        approvedSpenders[spender] = true;\n        IERC20(token).safeApprove(spender, amount);\n\n        emit NewSpender(token, spender, amount);\n    }\n\n    function updateSpenderAllowance(address token, address spender, uint256 amount) external onlyOwner {\n        require(approvedSpenders[spender], \"Not approved Spender\");\n        IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, amount);\n\n        emit UpdateSpender(token, spender, amount);\n    }\n\n    function removeSpender(address token, address spender) external onlyOwner {\n        require(approvedSpenders[spender], \"Not approved Spender\");\n        approvedSpenders[spender] = false;\n        IERC20(token).safeApprove(spender, 0);\n\n        emit RemovedSpender(token, spender);\n    }\n\n    function transferToken(address token, address receiver, uint256 amount) external onlyOwner nonReentrant {\n        IERC20(token).safeTransfer(receiver, amount);\n    }\n\n}"
    },
    {
      "filename": "contracts/PaladinRewardReserve.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./open-zeppelin/utils/Ownable.sol\";\nimport \"./open-zeppelin/utils/ReentrancyGuard.sol\";\nimport \"./open-zeppelin/interfaces/IERC20.sol\";\nimport \"./open-zeppelin/libraries/SafeERC20.sol\";\n\n/** @title Paladin Reward Reserve contract  */\n/// @author Paladin\ncontract PaladinRewardReserve is Ownable, ReentrancyGuard{\n    using SafeERC20 for IERC20;\n\n    /** @notice Addresses allowed to transfer tokens from this contract */\n    mapping(address => bool) public approvedSpenders;\n\n    /** @notice Emitted when a new spender is approved*/\n    event NewSpender(address indexed token, address indexed spender, uint256 amount);\n    /** @notice Emitted when the allowance of a spander is updated */\n    event UpdateSpender(address indexed token, address indexed spender, uint256 amount);\n    /** @notice Emitted when a spender allowance is removed */\n    event RemovedSpender(address indexed token, address indexed spender);\n\n    constructor(address _admin) {\n        transferOwnership(_admin);\n    }\n\n    function setNewSpender(address token, address spender, uint256 amount) external onlyOwner {\n        require(!approvedSpenders[spender], \"Already Spender\");\n        approvedSpenders[spender] = true;\n        IERC20(token).safeApprove(spender, amount);\n\n        emit NewSpender(token, spender, amount);\n    }\n\n    function updateSpenderAllowance(address token, address spender, uint256 amount) external onlyOwner {\n        require(approvedSpenders[spender], \"Not approved Spender\");\n        IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, amount);\n\n        emit UpdateSpender(token, spender, amount);\n    }\n\n    function removeSpender(address token, address spender) external onlyOwner {\n        require(approvedSpenders[spender], \"Not approved Spender\");\n        approvedSpenders[spender] = false;\n        IERC20(token).safeApprove(spender, 0);\n\n        emit RemovedSpender(token, spender);\n    }\n\n    function transferToken(address token, address receiver, uint256 amount) external onlyOwner nonReentrant {\n        IERC20(token).safeTransfer(receiver, amount);\n    }\n\n}"
    }
  ]
}