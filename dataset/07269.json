{
  "Title": "[M-04] `LienToken.transferFrom` There is a possibility of malicious attack",
  "Content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L366-L368>\n\nCorrupt multiple key properties of public vault, causing vault not to function properly.\n\n### Proof of Concept\n\nWhen LienToken.makePayment()/buyoutLien()/payDebtViaClearingHouse()<br>\nIf it corresponds to PublicVault, it will make multiple changes to the vault, such as: yIntercept, slope, last, epochData, etc.\n\nIf LienToken corresponds to PublicVault, then ownerOf(lienId) = PublicVault address\n\nWhen the LienToken is a private vault, it is possible to transfer the owner of the LienToken.\n\nAs the above seems, if the private vault is transferred to the PublicVault address will result in the wrong modification of the yIntercept, slope, last, epochData, etc.\n\nSo we restrict the to in transferFrom to not be a PublicVault address\n\n```solidity\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 id\n  ) public override(ERC721, IERC721) {\n\n    if (_isPublicVault(s, to)) {  //***@audit when to == PublicVault address , will revert\n      revert InvalidState(InvalidStates.PUBLIC_VAULT_RECIPIENT);  \n    }  \n```\n\nHowever, such a restriction does not prevent an attacker from transferring PrivateVault's LienToken to PublicVault.<br>\nBecause the address is predictable when the vault contract is created, a malicious user can predict the vault address, front-run, and transfer PrivateVault's LienToken to the predicted PublicVault address before the public vault is created, thus bypassing this restriction\n\nAssumptions:\n\n1.  alice creates PrivateVault, and creates multiple PrivateVault's LienToken\n2.  alice monitors bob's creation of the PublicVault transaction, i.e., AstariaRouter.newPublicVault(), and then predicts the address of the newly generated treasure chest\n\nNote: newPublicVAult() although the use of create(), but still can predict the address\n\nsee：<https://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed>\n\n> The address for an Ethereum contract is deterministically computed from the address of its creator (sender) and how many transactions the creator has sent (nonce). The sender and nonce are RLP encoded and then hashed with Keccak-256.\n\n3. front-run , and transfer LienToken to public vault predict address\n4. bob's public vault created success and do some loan\n5. alice do makePayment() to Corrupt bob's public vault\n\n### Recommended Mitigation Steps\n\nThe corresponding vault address is stored in s.lienMeta\\[id].orginOwner when the LienToken is created, this is not modified. Get the vault address from this variable, not from ownerOf(id).\n\n**[androolloyd (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/571)**\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-01-astaria",
  "Code": [
    {
      "filename": "src/LienToken.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**                                                     \n*  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗ \n* ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n* ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n* ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n* ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n* ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n*\n* Astaria Labs, Inc\n*/\n\npragma solidity =0.8.17;\n\npragma experimental ABIEncoderV2;\n\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport {ERC721} from \"gpl/ERC721.sol\";\nimport {IERC721} from \"core/interfaces/IERC721.sol\";\nimport {IERC165} from \"core/interfaces/IERC165.sol\";\nimport {ITransferProxy} from \"core/interfaces/ITransferProxy.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\nimport {CollateralLookup} from \"core/libraries/CollateralLookup.sol\";\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {ICollateralToken} from \"core/interfaces/ICollateralToken.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\n\nimport {IPublicVault} from \"core/interfaces/IPublicVault.sol\";\nimport {VaultImplementation} from \"./VaultImplementation.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {AuthInitializable} from \"core/AuthInitializable.sol\";\nimport {Initializable} from \"./utils/Initializable.sol\";\n\n/**\n * @title LienToken\n * @notice This contract handles the creation, payments, buyouts, and liquidations of tokenized NFT-collateralized debt (liens). Vaults which originate loans against supported collateral are issued a LienToken representing the right to loan repayments and auctioned funds on liquidation.\n */\ncontract LienToken is ERC721, ILienToken, AuthInitializable {\n  using FixedPointMathLib for uint256;\n  using CollateralLookup for address;\n  using SafeCastLib for uint256;\n  using SafeTransferLib for ERC20;\n\n  uint256 private constant LIEN_SLOT =\n    uint256(keccak256(\"xyz.astaria.LienToken.storage.location\")) - 1;\n\n  bytes32 constant ACTIVE_AUCTION = bytes32(\"ACTIVE_AUCTION\");\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize(Authority _AUTHORITY, ITransferProxy _TRANSFER_PROXY)\n    public\n    initializer\n  {\n    __initAuth(msg.sender, address(_AUTHORITY));\n    __initERC721(\"Astaria Lien Token\", \"ALT\");\n    LienStorage storage s = _loadLienStorageSlot();\n    s.TRANSFER_PROXY = _TRANSFER_PROXY;\n    s.maxLiens = uint8(5);\n  }\n\n  function _loadLienStorageSlot()\n    internal\n    pure\n    returns (LienStorage storage s)\n  {\n    uint256 slot = LIEN_SLOT;\n\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  function file(File calldata incoming) external requiresAuth {\n    FileType what = incoming.what;\n    bytes memory data = incoming.data;\n    LienStorage storage s = _loadLienStorageSlot();\n    if (what == FileType.CollateralToken) {\n      s.COLLATERAL_TOKEN = ICollateralToken(abi.decode(data, (address)));\n    } else if (what == FileType.AstariaRouter) {\n      s.ASTARIA_ROUTER = IAstariaRouter(abi.decode(data, (address)));\n    } else {\n      revert UnsupportedFile();\n    }\n    emit FileUpdated(what, data);\n  }\n\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC721, IERC165)\n    returns (bool)\n  {\n    return\n      interfaceId == type(ILienToken).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  function buyoutLien(ILienToken.LienActionBuyout calldata params)\n    external\n    validateStack(params.encumber.lien.collateralId, params.encumber.stack)\n    returns (Stack[] memory, Stack memory newStack)\n  {\n    if (block.timestamp >= params.encumber.stack[params.position].point.end) {\n      revert InvalidState(InvalidStates.EXPIRED_LIEN);\n    }\n    LienStorage storage s = _loadLienStorageSlot();\n    if (!s.ASTARIA_ROUTER.isValidVault(msg.sender)) {\n      revert InvalidSender();\n    }\n    return _buyoutLien(s, params);\n  }\n\n  function _buyoutLien(\n    LienStorage storage s,\n    ILienToken.LienActionBuyout calldata params\n  ) internal returns (Stack[] memory newStack, Stack memory newLien) {\n    //the borrower shouldn't incur more debt from the buyout than they already owe\n    (, newLien) = _createLien(s, params.encumber);\n    if (\n      !s.ASTARIA_ROUTER.isValidRefinance({\n        newLien: params.encumber.lien,\n        position: params.position,\n        stack: params.encumber.stack\n      })\n    ) {\n      revert InvalidRefinance();\n    }\n\n    if (\n      s.collateralStateHash[params.encumber.lien.collateralId] == ACTIVE_AUCTION\n    ) {\n      revert InvalidState(InvalidStates.COLLATERAL_AUCTION);\n    }\n    (uint256 owed, uint256 buyout) = _getBuyout(\n      s,\n      params.encumber.stack[params.position]\n    );\n\n    if (params.encumber.lien.details.maxAmount < owed) {\n      revert InvalidBuyoutDetails(params.encumber.lien.details.maxAmount, owed);\n    }\n\n    uint256 potentialDebt = 0;\n    for (uint256 i = params.encumber.stack.length; i > 0; ) {\n      uint256 j = i - 1;\n      // should not be able to purchase lien if any lien in the stack is expired (and will be liquidated)\n      if (block.timestamp >= params.encumber.stack[j].point.end) {\n        revert InvalidState(InvalidStates.EXPIRED_LIEN);\n      }\n\n      potentialDebt += _getOwed(\n        params.encumber.stack[j],\n        params.encumber.stack[j].point.end\n      );\n\n      if (\n        potentialDebt >\n        params.encumber.stack[j].lien.details.liquidationInitialAsk\n      ) {\n        revert InvalidState(InvalidStates.INITIAL_ASK_EXCEEDED);\n      }\n\n      unchecked {\n        --i;\n      }\n    }\n\n    address payee = _getPayee(\n      s,\n      params.encumber.stack[params.position].point.lienId\n    );\n    s.TRANSFER_PROXY.tokenTransferFrom(\n      params.encumber.stack[params.position].lien.token,\n      msg.sender,\n      payee,\n      buyout\n    );\n\n    if (_isPublicVault(s, payee)) {\n      IPublicVault(payee).handleBuyoutLien(\n        IPublicVault.BuyoutLienParams({\n          lienSlope: calculateSlope(params.encumber.stack[params.position]),\n          lienEnd: params.encumber.stack[params.position].point.end,\n          increaseYIntercept: buyout -\n            params.encumber.stack[params.position].point.amount\n        })\n      );\n    }\n\n    newStack = _replaceStackAtPositionWithNewLien(\n      s,\n      params.encumber.stack,\n      params.position,\n      newLien,\n      params.encumber.stack[params.position].point.lienId\n    );\n    uint256 maxPotentialDebt;\n    uint256 n = newStack.length;\n    uint256 i;\n    for (i; i < n; ) {\n      maxPotentialDebt += _getOwed(newStack[i], newStack[i].point.end);\n      //no need to check validity before the position we're buying\n      if (i == params.position) {\n        if (maxPotentialDebt > params.encumber.lien.details.maxPotentialDebt) {\n          revert InvalidState(InvalidStates.DEBT_LIMIT);\n        }\n      }\n      if (\n        i > params.position &&\n        (maxPotentialDebt > newStack[i].lien.details.maxPotentialDebt)\n      ) {\n        revert InvalidState(InvalidStates.DEBT_LIMIT);\n      }\n      unchecked {\n        ++i;\n      }\n    }\n\n    s.collateralStateHash[params.encumber.lien.collateralId] = keccak256(\n      abi.encode(newStack)\n    );\n  }\n\n  function _replaceStackAtPositionWithNewLien(\n    LienStorage storage s,\n    ILienToken.Stack[] calldata stack,\n    uint256 position,\n    Stack memory newLien,\n    uint256 oldLienId\n  ) internal returns (ILienToken.Stack[] memory newStack) {\n    newStack = stack;\n    newStack[position] = newLien;\n    _burn(oldLienId);\n    delete s.lienMeta[oldLienId];\n  }\n\n  function getInterest(Stack calldata stack) public view returns (uint256) {\n    return _getInterest(stack, block.timestamp);\n  }\n\n  /**\n   * @dev Computes the interest accrued for a lien since its last payment.\n   * @param stack The Lien for the loan to calculate interest for.\n   * @param timestamp The timestamp at which to compute interest for.\n   */\n  function _getInterest(Stack memory stack, uint256 timestamp)\n    internal\n    pure\n    returns (uint256)\n  {\n    uint256 delta_t = timestamp - stack.point.last;\n\n    return (delta_t * stack.lien.details.rate).mulWadDown(stack.point.amount);\n  }\n\n  modifier validateStack(uint256 collateralId, Stack[] memory stack) {\n    LienStorage storage s = _loadLienStorageSlot();\n    bytes32 stateHash = s.collateralStateHash[collateralId];\n    if (stateHash == bytes32(0) && stack.length != 0) {\n      revert InvalidState(InvalidStates.EMPTY_STATE);\n    }\n    if (stateHash != bytes32(0) && keccak256(abi.encode(stack)) != stateHash) {\n      revert InvalidState(InvalidStates.INVALID_HASH);\n    }\n    _;\n  }\n\n  function stopLiens(\n    uint256 collateralId,\n    uint256 auctionWindow,\n    Stack[] calldata stack,\n    address liquidator\n  ) external validateStack(collateralId, stack) requiresAuth {\n    _stopLiens(\n      _loadLienStorageSlot(),\n      collateralId,\n      auctionWindow,\n      stack,\n      liquidator\n    );\n  }\n\n  function _stopLiens(\n    LienStorage storage s,\n    uint256 collateralId,\n    uint256 auctionWindow,\n    Stack[] calldata stack,\n    address liquidator\n  ) internal {\n    AuctionData memory auctionData;\n    auctionData.liquidator = liquidator;\n    auctionData.stack = new AuctionStack[](stack.length);\n    s.auctionData[collateralId].liquidator = liquidator;\n    uint256 i;\n    for (; i < stack.length; ) {\n      AuctionStack memory auctionStack;\n\n      auctionStack.lienId = stack[i].point.lienId;\n      auctionStack.end = stack[i].point.end;\n      uint88 owed = _getOwed(stack[i], block.timestamp);\n      auctionStack.amountOwed = owed;\n      s.lienMeta[auctionStack.lienId].atLiquidation = true;\n      auctionData.stack[i] = auctionStack;\n      address payee = _getPayee(s, auctionStack.lienId);\n      if (_isPublicVault(s, payee)) {\n        // update the public vault state and get the liquidation accountant back if any\n        address withdrawProxyIfNearBoundary = IPublicVault(payee)\n          .updateVaultAfterLiquidation(\n            auctionWindow,\n            IPublicVault.AfterLiquidationParams({\n              lienSlope: calculateSlope(stack[i]),\n              newAmount: owed,\n              lienEnd: stack[i].point.end\n            })\n          );\n\n        if (withdrawProxyIfNearBoundary != address(0)) {\n          _setPayee(s, auctionStack.lienId, withdrawProxyIfNearBoundary);\n        }\n      }\n      unchecked {\n        ++i;\n      }\n    }\n    s.collateralStateHash[collateralId] = ACTIVE_AUCTION;\n    auctionData.startTime = block.timestamp.safeCastTo48();\n    auctionData.endTime = (block.timestamp + auctionWindow).safeCastTo48();\n    auctionData.startAmount = stack[0]\n      .lien\n      .details\n      .liquidationInitialAsk\n      .safeCastTo88();\n    auctionData.endAmount = uint88(1000 wei);\n    s.COLLATERAL_TOKEN.getClearingHouse(collateralId).setAuctionData(\n      auctionData\n    );\n  }\n\n  function tokenURI(uint256 tokenId)\n    public\n    view\n    override(ERC721, IERC721)\n    returns (string memory)\n  {\n    if (!_exists(tokenId)) {\n      revert InvalidTokenId(tokenId);\n    }\n    return \"\";\n  }\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 id\n  ) public override(ERC721, IERC721) {\n    LienStorage storage s = _loadLienStorageSlot();\n    if (_isPublicVault(s, to)) {\n      revert InvalidState(InvalidStates.PUBLIC_VAULT_RECIPIENT);\n    }\n    if (s.lienMeta[id].atLiquidation) {\n      revert InvalidState(InvalidStates.COLLATERAL_AUCTION);\n    }\n    delete s.lienMeta[id].payee;\n    emit PayeeChanged(id, address(0));\n    super.transferFrom(from, to, id);\n  }\n\n  function ASTARIA_ROUTER() public view returns (IAstariaRouter) {\n    return _loadLienStorageSlot().ASTARIA_ROUTER;\n  }\n\n  function COLLATERAL_TOKEN() public view returns (ICollateralToken) {\n    return _loadLienStorageSlot().COLLATERAL_TOKEN;\n  }\n\n  function _exists(uint256 tokenId) internal view returns (bool) {\n    return _loadERC721Slot()._ownerOf[tokenId] != address(0);\n  }\n\n  function createLien(ILienToken.LienActionEncumber memory params)\n    external\n    requiresAuth\n    validateStack(params.lien.collateralId, params.stack)\n    returns (\n      uint256 lienId,\n      Stack[] memory newStack,\n      uint256 lienSlope\n    )\n  {\n    LienStorage storage s = _loadLienStorageSlot();\n    //0 - 4 are valid\n    Stack memory newStackSlot;\n    (lienId, newStackSlot) = _createLien(s, params);\n\n    newStack = _appendStack(s, params.stack, newStackSlot);\n    s.collateralStateHash[params.lien.collateralId] = keccak256(\n      abi.encode(newStack)\n    );\n\n    lienSlope = calculateSlope(newStackSlot);\n    emit AddLien(\n      params.lien.collateralId,\n      uint8(params.stack.length),\n      lienId,\n      newStackSlot\n    );\n    emit LienStackUpdated(\n      params.lien.collateralId,\n      uint8(params.stack.length),\n      StackAction.ADD,\n      uint8(newStack.length)\n    );\n  }\n\n  function _createLien(\n    LienStorage storage s,\n    ILienToken.LienActionEncumber memory params\n  ) internal returns (uint256 newLienId, ILienToken.Stack memory newSlot) {\n    if (s.collateralStateHash[params.lien.collateralId] == ACTIVE_AUCTION) {\n      revert InvalidState(InvalidStates.COLLATERAL_AUCTION);\n    }\n    if (\n      params.lien.details.liquidationInitialAsk < params.amount ||\n      params.lien.details.liquidationInitialAsk == 0\n    ) {\n      revert InvalidState(InvalidStates.INVALID_LIQUIDATION_INITIAL_ASK);\n    }\n\n    if (params.stack.length > 0) {\n      if (params.lien.collateralId != params.stack[0].lien.collateralId) {\n        revert InvalidState(InvalidStates.COLLATERAL_MISMATCH);\n      }\n\n      if (params.lien.token != params.stack[0].lien.token) {\n        revert InvalidState(InvalidStates.ASSET_MISMATCH);\n      }\n    }\n\n    newLienId = uint256(keccak256(abi.encode(params.lien)));\n    Point memory point = Point({\n      lienId: newLienId,\n      amount: params.amount.safeCastTo88(),\n      last: block.timestamp.safeCastTo40(),\n      end: (block.timestamp + params.lien.details.duration).safeCastTo40()\n    });\n    _mint(params.receiver, newLienId);\n    return (newLienId, Stack({lien: params.lien, point: point}));\n  }\n\n  function _appendStack(\n    LienStorage storage s,\n    Stack[] memory stack,\n    Stack memory newSlot\n  ) internal returns (Stack[] memory newStack) {\n    if (stack.length >= s.maxLiens) {\n      revert InvalidState(InvalidStates.MAX_LIENS);\n    }\n\n    newStack = new Stack[](stack.length + 1);\n    newStack[stack.length] = newSlot;\n\n    uint256 potentialDebt = _getOwed(newSlot, newSlot.point.end);\n    for (uint256 i = stack.length; i > 0; ) {\n      uint256 j = i - 1;\n      newStack[j] = stack[j];\n      if (block.timestamp >= newStack[j].point.end) {\n        revert InvalidState(InvalidStates.EXPIRED_LIEN);\n      }\n\n      unchecked {\n        potentialDebt += _getOwed(newStack[j], newStack[j].point.end);\n      }\n      if (potentialDebt > newStack[j].lien.details.liquidationInitialAsk) {\n        revert InvalidState(InvalidStates.INITIAL_ASK_EXCEEDED);\n      }\n\n      unchecked {\n        --i;\n      }\n    }\n    if (\n      stack.length > 0 && potentialDebt > newSlot.lien.details.maxPotentialDebt\n    ) {\n      revert InvalidState(InvalidStates.DEBT_LIMIT);\n    }\n  }\n\n  function payDebtViaClearingHouse(\n    address token,\n    uint256 collateralId,\n    uint256 payment,\n    AuctionStack[] memory auctionStack\n  ) external {\n    LienStorage storage s = _loadLienStorageSlot();\n    require(\n      msg.sender == address(s.COLLATERAL_TOKEN.getClearingHouse(collateralId))\n    );\n\n    _payDebt(s, token, payment, msg.sender, auctionStack);\n    delete s.collateralStateHash[collateralId];\n  }\n\n  function _payDebt(\n    LienStorage storage s,\n    address token,\n    uint256 payment,\n    address payer,\n    AuctionStack[] memory stack\n  ) internal returns (uint256 totalSpent) {\n    uint256 i;\n    for (; i < stack.length;) {\n      uint256 spent;\n      unchecked {\n        spent = _paymentAH(s, token, stack, i, payment, payer);\n        totalSpent += spent;\n        payment -= spent;\n        ++i;\n      }\n    }\n  }\n\n  function getAuctionData(uint256 collateralId)\n    external\n    view\n    returns (AuctionData memory)\n  {\n    return _loadLienStorageSlot().auctionData[collateralId];\n  }\n\n  function getAuctionLiquidator(uint256 collateralId)\n    external\n    view\n    returns (address liquidator)\n  {\n    liquidator = _loadLienStorageSlot().auctionData[collateralId].liquidator;\n    if (liquidator == address(0)) {\n      revert InvalidState(InvalidStates.COLLATERAL_NOT_LIQUIDATED);\n    }\n  }\n\n  function getAmountOwingAtLiquidation(ILienToken.Stack calldata stack)\n    public\n    view\n    returns (uint256)\n  {\n    return\n      _loadLienStorageSlot()\n        .auctionData[stack.lien.collateralId]\n        .stack[stack.point.lienId]\n        .amountOwed;\n  }\n\n  function validateLien(Lien memory lien) public view returns (uint256 lienId) {\n    lienId = uint256(keccak256(abi.encode(lien)));\n    if (!_exists(lienId)) {\n      revert InvalidState(InvalidStates.INVALID_LIEN_ID);\n    }\n  }\n\n  function getCollateralState(uint256 collateralId)\n    external\n    view\n    returns (bytes32)\n  {\n    return _loadLienStorageSlot().collateralStateHash[collateralId];\n  }\n\n  function getBuyout(Stack calldata stack)\n    public\n    view\n    returns (uint256 owed, uint256 buyout)\n  {\n    return _getBuyout(_loadLienStorageSlot(), stack);\n  }\n\n  function _getBuyout(LienStorage storage s, Stack calldata stack)\n    internal\n    view\n    returns (uint256 owed, uint256 buyout)\n  {\n    owed = _getOwed(stack, block.timestamp);\n    buyout =\n      owed +\n      s.ASTARIA_ROUTER.getBuyoutFee(_getRemainingInterest(s, stack));\n  }\n\n  function makePayment(\n    uint256 collateralId,\n    Stack[] calldata stack,\n    uint256 amount\n  )\n    public\n    validateStack(collateralId, stack)\n    returns (Stack[] memory newStack)\n  {\n    return _makePayment(_loadLienStorageSlot(), stack, amount);\n  }\n\n  function makePayment(\n    uint256 collateralId,\n    Stack[] calldata stack,\n    uint8 position,\n    uint256 amount\n  )\n    external\n    validateStack(collateralId, stack)\n    returns (Stack[] memory newStack)\n  {\n    LienStorage storage s = _loadLienStorageSlot();\n    (newStack, ) = _payment(s, stack, position, amount, msg.sender);\n    _updateCollateralStateHash(s, collateralId, newStack);\n  }\n\n  function _paymentAH(\n    LienStorage storage s,\n    address token,\n    AuctionStack[] memory stack,\n    uint256 position,\n    uint256 payment,\n    address payer\n  ) internal returns (uint256) {\n    uint256 lienId = stack[position].lienId;\n    uint256 end = stack[position].end;\n    uint256 owing = stack[position].amountOwed;\n    //checks the lien exists\n    address payee = _getPayee(s, lienId);\n    uint256 remaining = 0;\n    if (owing > payment.safeCastTo88()) {\n      remaining = owing - payment;\n    } else {\n      payment = owing;\n    }\n    if (payment > 0)\n      s.TRANSFER_PROXY.tokenTransferFrom(token, payer, payee, payment);\n\n    delete s.lienMeta[lienId]; //full delete\n    delete stack[position];\n    _burn(lienId);\n\n    if (_isPublicVault(s, payee)) {\n      IPublicVault(payee).updateAfterLiquidationPayment(\n        IPublicVault.LiquidationPaymentParams({remaining: remaining})\n      );\n    }\n    emit Payment(lienId, payment);\n    return payment;\n  }\n\n  /**\n   * @dev Have a specified payer make a payment for the debt against a CollateralToken.\n   * @param stack the stack for the payment\n   * @param totalCapitalAvailable The amount to pay against the debts\n   */\n  function _makePayment(\n    LienStorage storage s,\n    Stack[] calldata stack,\n    uint256 totalCapitalAvailable\n  ) internal returns (Stack[] memory newStack) {\n    newStack = stack;\n    for (uint256 i; i < newStack.length; ) {\n      uint256 oldLength = newStack.length;\n      uint256 spent;\n      (newStack, spent) = _payment(\n        s,\n        newStack,\n        uint8(i),\n        totalCapitalAvailable,\n        msg.sender\n      );\n      totalCapitalAvailable -= spent;\n      if (totalCapitalAvailable == 0) break;\n      if (newStack.length == oldLength) {\n        unchecked {\n          ++i;\n        }\n      }\n    }\n    _updateCollateralStateHash(s, stack[0].lien.collateralId, newStack);\n  }\n\n  function _updateCollateralStateHash(\n    LienStorage storage s,\n    uint256 collateralId,\n    Stack[] memory stack\n  ) internal {\n    if (stack.length == 0) {\n      delete s.collateralStateHash[collateralId];\n    } else {\n      s.collateralStateHash[collateralId] = keccak256(abi.encode(stack));\n    }\n  }\n\n  function calculateSlope(Stack memory stack) public pure returns (uint256) {\n    return stack.lien.details.rate.mulWadDown(stack.point.amount);\n  }\n\n  function getMaxPotentialDebtForCollateral(Stack[] memory stack)\n    public\n    view\n    validateStack(stack[0].lien.collateralId, stack)\n    returns (uint256 maxPotentialDebt)\n  {\n    return _getMaxPotentialDebtForCollateralUpToNPositions(stack, stack.length);\n  }\n\n  function _getMaxPotentialDebtForCollateralUpToNPositions(\n    Stack[] memory stack,\n    uint256 n\n  ) internal pure returns (uint256 maxPotentialDebt) {\n    for (uint256 i; i < n; ) {\n      maxPotentialDebt += _getOwed(stack[i], stack[i].point.end);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function getMaxPotentialDebtForCollateral(Stack[] memory stack, uint256 end)\n    public\n    view\n    validateStack(stack[0].lien.collateralId, stack)\n    returns (uint256 maxPotentialDebt)\n  {\n    uint256 i;\n    for (; i < stack.length; ) {\n      maxPotentialDebt += _getOwed(stack[i], end);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function getOwed(Stack memory stack) external view returns (uint88) {\n    validateLien(stack.lien);\n    return _getOwed(stack, block.timestamp);\n  }\n\n  function getOwed(Stack memory stack, uint256 timestamp)\n    external\n    view\n    returns (uint88)\n  {\n    validateLien(stack.lien);\n    return _getOwed(stack, timestamp);\n  }\n\n  /**\n   * @dev Computes the debt owed to a Lien at a specified timestamp.\n   * @param stack The specified Lien.\n   * @return The amount owed to the Lien at the specified timestamp.\n   */\n  function _getOwed(Stack memory stack, uint256 timestamp)\n    internal\n    pure\n    returns (uint88)\n  {\n    return stack.point.amount + _getInterest(stack, timestamp).safeCastTo88();\n  }\n\n  /**\n   * @dev Computes the interest still owed to a Lien.\n   * @param s active storage slot\n   * @param stack the lien\n   * @return The WETH still owed in interest to the Lien.\n   */\n  function _getRemainingInterest(LienStorage storage s, Stack memory stack)\n    internal\n    view\n    returns (uint256)\n  {\n    uint256 delta_t = stack.point.end - block.timestamp;\n    return (delta_t * stack.lien.details.rate).mulWadDown(stack.point.amount);\n  }\n\n  /**\n   * @dev Make a payment from a payer to a specific lien against a CollateralToken.\n   * @param activeStack The stack\n   * @param amount The amount to pay against the debt.\n   * @param payer The address to make the payment.\n   */\n  function _payment(\n    LienStorage storage s,\n    Stack[] memory activeStack,\n    uint8 position,\n    uint256 amount,\n    address payer\n  ) internal returns (Stack[] memory, uint256) {\n    Stack memory stack = activeStack[position];\n    uint256 lienId = stack.point.lienId;\n\n    if (s.lienMeta[lienId].atLiquidation) {\n      revert InvalidState(InvalidStates.COLLATERAL_AUCTION);\n    }\n    uint64 end = stack.point.end;\n    // Blocking off payments for a lien that has exceeded the lien.end to prevent repayment unless the msg.sender() is the AuctionHouse\n    if (block.timestamp >= end) {\n      revert InvalidLoanState();\n    }\n    uint256 owed = _getOwed(stack, block.timestamp);\n    address lienOwner = ownerOf(lienId);\n    bool isPublicVault = _isPublicVault(s, lienOwner);\n\n    address payee = _getPayee(s, lienId);\n\n    if (amount > owed) amount = owed;\n    if (isPublicVault) {\n      IPublicVault(lienOwner).beforePayment(\n        IPublicVault.BeforePaymentParams({\n          interestOwed: owed - stack.point.amount,\n          amount: stack.point.amount,\n          lienSlope: calculateSlope(stack)\n        })\n      );\n    }\n\n    //bring the point up to block.timestamp, compute the owed\n    stack.point.amount = owed.safeCastTo88();\n    stack.point.last = block.timestamp.safeCastTo40();\n\n    if (stack.point.amount > amount) {\n      stack.point.amount -= amount.safeCastTo88();\n      //      // slope does not need to be updated if paying off the rest, since we neutralize slope in beforePayment()\n      if (isPublicVault) {\n        IPublicVault(lienOwner).afterPayment(calculateSlope(stack));\n      }\n    } else {\n      amount = stack.point.amount;\n      if (isPublicVault) {\n        // since the openLiens count is only positive when there are liens that haven't been paid off\n        // that should be liquidated, this lien should not be counted anymore\n        IPublicVault(lienOwner).decreaseEpochLienCount(\n          IPublicVault(lienOwner).getLienEpoch(end)\n        );\n      }\n      delete s.lienMeta[lienId]; //full delete of point data for the lien\n      _burn(lienId);\n      activeStack = _removeStackPosition(activeStack, position);\n    }\n\n    s.TRANSFER_PROXY.tokenTransferFrom(stack.lien.token, payer, payee, amount);\n\n    emit Payment(lienId, amount);\n    return (activeStack, amount);\n  }\n\n  function _removeStackPosition(Stack[] memory stack, uint8 position)\n    internal\n    returns (Stack[] memory newStack)\n  {\n    uint256 length = stack.length;\n    require(position < length);\n    newStack = new ILienToken.Stack[](length - 1);\n    uint256 i;\n    for (; i < position; ) {\n      newStack[i] = stack[i];\n      unchecked {\n        ++i;\n      }\n    }\n    for (; i < length - 1; ) {\n      unchecked {\n        newStack[i] = stack[i + 1];\n        ++i;\n      }\n    }\n    emit LienStackUpdated(\n      stack[position].lien.collateralId,\n      position,\n      StackAction.REMOVE,\n      uint8(newStack.length)\n    );\n  }\n\n  function _isPublicVault(LienStorage storage s, address account)\n    internal\n    view\n    returns (bool)\n  {\n    return\n      s.ASTARIA_ROUTER.isValidVault(account) &&\n      IPublicVault(account).supportsInterface(type(IPublicVault).interfaceId);\n  }\n\n  function getPayee(uint256 lienId) public view returns (address) {\n    if (!_exists(lienId)) {\n      revert InvalidState(InvalidStates.INVALID_LIEN_ID);\n    }\n    return _getPayee(_loadLienStorageSlot(), lienId);\n  }\n\n  function _getPayee(LienStorage storage s, uint256 lienId)\n    internal\n    view\n    returns (address)\n  {\n    return\n      s.lienMeta[lienId].payee != address(0)\n        ? s.lienMeta[lienId].payee\n        : ownerOf(lienId);\n  }\n\n  function _setPayee(\n    LienStorage storage s,\n    uint256 lienId,\n    address newPayee\n  ) internal {\n    s.lienMeta[lienId].payee = newPayee;\n    emit PayeeChanged(lienId, newPayee);\n  }\n}"
    }
  ]
}