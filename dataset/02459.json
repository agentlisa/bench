{
  "Title": "M-6: Resizing the payout schedule with less items might revert",
  "Content": "# Issue M-6: Resizing the payout schedule with less items might revert \n\nSource: https://github.com/sherlock-audit/2023-02-openq-judging/issues/244 \n\n## Found by \nrvierdiiev, Jeiwan, HonorLt, 0x52, ak1, GimelSec, usmannk, TrungOre, bin2chen, caventa, StErMi, clems4ever, ck, unforgiven, ArcAnya, XKET\n\n## Summary\n\nAccording to some comments in `setPayoutScheduleFixed`, reducing the number of items in the schedule is a supported use case. However in that case, the function will revert because we are iterating over as many items as there was in the previous version of the three arrays making the function revert since the new arrays have less items.\n\n## Vulnerability Detail\n\nLet say they were 4 items in the arrays `tierWinners`, `invoiceComplete` and `supportingDocumentsComplete` and we are resizing the schedule to 3 items. Then the following function would revert because we use the length of the previous arrays instead of the new ones in the for loops.\n\n```solidity\nfunction setPayoutScheduleFixed(\n        uint256[] calldata _payoutSchedule,\n        address _payoutTokenAddress\n    ) external onlyOpenQ {\n        require(\n            bountyType == OpenQDefinitions.TIERED_FIXED,\n            Errors.NOT_A_FIXED_TIERED_BOUNTY\n        );\n        payoutSchedule = _payoutSchedule;\n        payoutTokenAddress = _payoutTokenAddress;\n\n        // Resize metadata arrays and copy current members to new array\n        // NOTE: If resizing to fewer tiers than previously, the final indexes will be removed\n        string[] memory newTierWinners = new string[](payoutSchedule.length);\n        bool[] memory newInvoiceComplete = new bool[](payoutSchedule.length);\n        bool[] memory newSupportingDocumentsCompleted = new bool[](\n            payoutSchedule.length\n        );\n\n        for (uint256 i = 0; i < tierWinners.length; i++) { <=====================================================\n            newTierWinners[i] = tierWinners[i];\n        }\n        tierWinners = newTierWinners;\n\n        for (uint256 i = 0; i < invoiceComplete.length; i++) { <=====================================================\n            newInvoiceComplete[i] = invoiceComplete[i];\n        }\n        invoiceComplete = newInvoiceComplete;\n\n        for (uint256 i = 0; i < supportingDocumentsComplete.length; i++) { <=====================================================\n            newSupportingDocumentsCompleted[i] = supportingDocumentsComplete[i];\n        }\n        supportingDocumentsComplete = newSupportingDocumentsCompleted;\n    }\n```\n\nThe same issue exists on TieredPercentageBounty too.\n\n## Impact\n\nUnable to resize the payout schedule to less items than the previous state.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-openq/blob/main/contracts/Bounty/Implementations/TieredFixedBountyV1.sol#L157\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n```solidity\n        for (uint256 i = 0; i < newTierWinners.length; i++) {\n            newTierWinners[i] = tierWinners[i];\n        }\n        tierWinners = newTierWinners;\n\n        for (uint256 i = 0; i < newInvoiceComplete.length; i++) {\n            newInvoiceComplete[i] = invoiceComplete[i];\n        }\n        invoiceComplete = newInvoiceComplete;\n\n        for (uint256 i = 0; i < newSupportingDocumentsCompleted.length; i++) {\n            newSupportingDocumentsCompleted[i] = supportingDocumentsComplete[i];\n        }\n        supportingDocumentsComplete = newSupportingDocumentsCompleted;\n```\nNote this won't work if increasing the number of items compared to previous state must also be supported. In that case you must use the length of the smallest of the two arrays in each for loop.\n\n## Discussion\n\n**FlacoJones**\n\nA valid issue but an invalid approach. Because if one is INCREASING the size of the array, you will still get an array out of bounds exception.\n\nThis suggestion, combined with adding a `i >= previousArray.length` will do the trick\n\nhttps://github.com/OpenQDev/OpenQ-Contracts/pull/126\n\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/39",
  "Code": [
    {
      "filename": "contracts/Bounty/Implementations/TieredFixedBountyV1.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport '../Storage/TieredFixedBountyStorage.sol';\n\n/// @title TieredFixedBountyV1\n/// @author FlacoJones\n/// @notice Bounty implementation for tiered bounties with fixed amount for each tier\n/// @dev TieredFixedBountyV1 -> TieredFixedBountyStorageV1 -> TieredBountyCore -> TieredBountyStorageCore -> BountyCore -> BountyStorageCore -> (Third Party Deps + Custom )\n/// @dev Do not add any new storage variables here. Put them in a TieredPercentageBountyStorageV# and release new implementation\ncontract TieredFixedBountyV1 is TieredFixedBountyStorageV1 {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address payable;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    constructor() {}\n\n    /// @notice Initializes a bounty proxy with initial state\n    /// @param _bountyId The unique bounty identifier\n    /// @param _issuer The sender of the mint bounty transaction\n    /// @param _organization The organization associated with the bounty\n    /// @param _openQ The OpenQProxy address\n    /// @param _claimManager The Claim Manager proxy address\n    /// @param _depositManager The Deposit Manager proxy address\n    /// @param _operation The ABI encoded data determining the type of bounty being initialized and associated data\n\t\t/// @dev see IBountyCore.initialize.(_operation) for _operation ABI encoding schema for TIERED FIXED\n    function initialize(\n        string memory _bountyId,\n        address _issuer,\n        string memory _organization,\n        address _openQ,\n        address _claimManager,\n        address _depositManager,\n        OpenQDefinitions.InitOperation memory _operation\n    ) external initializer {\n        require(bytes(_bountyId).length != 0, Errors.NO_EMPTY_BOUNTY_ID);\n        require(bytes(_organization).length != 0, Errors.NO_EMPTY_ORGANIZATION);\n\n        __ReentrancyGuard_init();\n\n        __OnlyOpenQ_init(_openQ);\n        __ClaimManagerOwnable_init(_claimManager);\n        __DepositManagerOwnable_init(_depositManager);\n\n        bountyId = _bountyId;\n        issuer = _issuer;\n        organization = _organization;\n        bountyCreatedTime = block.timestamp;\n        nftDepositLimit = 5;\n\n        (\n            uint256[] memory _payoutSchedule,\n            address _payoutTokenAddress,\n            bool _invoiceRequired,\n            bool _kycRequired,\n            bool _supportingDocumentsRequired,\n            string memory _issuerExternalUserId,\n            ,\n\n        ) = abi.decode(\n                _operation.data,\n                (\n                    uint256[],\n                    address,\n                    bool,\n                    bool,\n                    bool,\n                    string,\n                    string,\n                    string\n                )\n            );\n\n        bountyType = OpenQDefinitions.TIERED_FIXED;\n        payoutSchedule = _payoutSchedule;\n\t\t\t\tpayoutTokenAddress = _payoutTokenAddress;\n        invoiceRequired = _invoiceRequired;\n        kycRequired = _kycRequired;\n        supportingDocumentsRequired = _supportingDocumentsRequired;\n        issuerExternalUserId = _issuerExternalUserId;\n\n        // Initialize metadata arrays to same number of tiers\n        tierWinners = new string[](_payoutSchedule.length);\n        invoiceComplete = new bool[](_payoutSchedule.length);\n        supportingDocumentsComplete = new bool[](_payoutSchedule.length);\n    }\n\n    /// @notice Transfers the fixed amount of balance associated with the tier\n    /// @param _payoutAddress The destination address for the fund\n    /// @param _tier The ordinal of the claimant (e.g. 1st place, 2nd place)\n    function claimTieredFixed(address _payoutAddress, uint256 _tier)\n        external\n        onlyClaimManager\n        nonReentrant\n        returns (uint256)\n    {\n        require(\n            bountyType == OpenQDefinitions.TIERED_FIXED,\n            Errors.NOT_A_TIERED_FIXED_BOUNTY\n        );\n        require(!tierClaimed[_tier], Errors.TIER_ALREADY_CLAIMED);\n\n        uint256 claimedBalance = payoutSchedule[_tier];\n\n        _transferToken(payoutTokenAddress, claimedBalance, _payoutAddress);\n        return claimedBalance;\n    }\n\n    /// @notice Similar to close() for single priced bounties. closeCompetition() freezes the current funds for the competition.\n    function closeCompetition() external onlyClaimManager {\n        require(\n            status == OpenQDefinitions.OPEN,\n            Errors.CONTRACT_ALREADY_CLOSED\n        );\n\n        status = OpenQDefinitions.CLOSED;\n        bountyClosedTime = block.timestamp;\n    }\n\n    /// @notice Sets fundingGoal for bounty with id _bountyId\n    /// @param _fundingToken The token address to be used for the funding goal\n    /// @param _fundingGoal The volume of token to be used for the funding goal\n    function setFundingGoal(address _fundingToken, uint256 _fundingGoal)\n        external\n        override\n        onlyOpenQ\n    {\n        fundingGoal = _fundingGoal;\n        fundingToken = _fundingToken;\n        hasFundingGoal = true;\n\n        payoutTokenAddress = _fundingToken;\n    }\n\n    /// @notice Sets the payout schedule\n    /// @param _payoutSchedule An array of payout volumes for each tier\n    /// @param _payoutTokenAddress The address of the token to be used for the payout\n    function setPayoutScheduleFixed(\n        uint256[] calldata _payoutSchedule,\n        address _payoutTokenAddress\n    ) external onlyOpenQ {\n        require(\n            bountyType == OpenQDefinitions.TIERED_FIXED,\n            Errors.NOT_A_FIXED_TIERED_BOUNTY\n        );\n        payoutSchedule = _payoutSchedule;\n        payoutTokenAddress = _payoutTokenAddress;\n\n        // Resize metadata arrays and copy current members to new array\n        // NOTE: If resizing to fewer tiers than previously, the final indexes will be removed\n        string[] memory newTierWinners = new string[](payoutSchedule.length);\n        bool[] memory newInvoiceComplete = new bool[](payoutSchedule.length);\n        bool[] memory newSupportingDocumentsCompleted = new bool[](\n            payoutSchedule.length\n        );\n\n        for (uint256 i = 0; i < tierWinners.length; i++) {\n            newTierWinners[i] = tierWinners[i];\n        }\n        tierWinners = newTierWinners;\n\n        for (uint256 i = 0; i < invoiceComplete.length; i++) {\n            newInvoiceComplete[i] = invoiceComplete[i];\n        }\n        invoiceComplete = newInvoiceComplete;\n\n        for (uint256 i = 0; i < supportingDocumentsComplete.length; i++) {\n            newSupportingDocumentsCompleted[i] = supportingDocumentsComplete[i];\n        }\n        supportingDocumentsComplete = newSupportingDocumentsCompleted;\n    }\n\n    /// @notice receive() method to accept protocol tokens\n    receive() external payable {\n        revert(\n            'Cannot send Ether directly to boutny contract. Please use the BountyV1.receiveFunds() method.'\n        );\n    }\n}"
    }
  ]
}