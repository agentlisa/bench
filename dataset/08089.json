{
  "Title": "[M-15] Malicious pausing the contract",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L204\nhttps://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L206\nhttps://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L235\n\n\n# Vulnerability details\n\n# Vulnerability details\n\n## Description\n\nThere is a function `_createAuction` in `Auction` contract.\n\nIt consist the following logic:\n\n```\n/// @dev Creates an auction for the next token\nfunction _createAuction() private {\n    // Get the next token available for bidding\n    try token.mint() returns (uint256 tokenId) {\n        **creating of the auction for token with id equal to tokenId**\n\n        // Pause the contract if token minting failed\n    } catch Error(string memory) {\n        _pause();\n    }\n}\n```\n\nAccording to the [EIP-150](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-150.md) `call` opcode can consume as most `63/64` of parrent calls' gas. That means `token.mint()` can fail since there will be no gas. \n\nAll in all, if `token.mint()` fail on gas and the rest gas is enough for pausing the contract by calling `_pause` in `catch` statement the contract will be paused.\n\nPlease note, that a bug can be exploitable if the token.mint() consume more than 1.500.000 of gas, because 1.500.000 / 64 > 20.000 that need to pause the contract. Also, the logic of `token.mint()` includes traversing the array up to 100 times, that's heavy enough to reach 1.500.000 gas limit. \n\n## Impact\n\nContract can be paused by any user by passing special amount of gas for the call of `settleCurrentAndCreateNewAuction` (which consists of two internal calls of `_settleAuction` and `_createAuction` functions).\n\n## Recommended Mitigation Steps\n\nAdd a special check for upper bound of `gasLeft` at start of `_createAuction` function.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-09-nouns-builder-contest",
  "Code": [
    {
      "filename": "src/auction/Auction.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { UUPS } from \"../lib/proxy/UUPS.sol\";\nimport { Ownable } from \"../lib/utils/Ownable.sol\";\nimport { ReentrancyGuard } from \"../lib/utils/ReentrancyGuard.sol\";\nimport { Pausable } from \"../lib/utils/Pausable.sol\";\nimport { SafeCast } from \"../lib/utils/SafeCast.sol\";\n\nimport { AuctionStorageV1 } from \"./storage/AuctionStorageV1.sol\";\nimport { Token } from \"../token/Token.sol\";\nimport { IManager } from \"../manager/IManager.sol\";\nimport { IAuction } from \"./IAuction.sol\";\nimport { IWETH } from \"../lib/interfaces/IWETH.sol\";\n\n/// @title Auction\n/// @author Rohan Kulkarni\n/// @notice A DAO's auction house\n/// Modified from:\n/// - NounsAuctionHouse.sol commit 2cbe6c7 - licensed under the BSD-3-Clause license.\n/// - Zora V3 ReserveAuctionCoreEth module commit 795aeca - licensed under the GPL-3.0 license.\ncontract Auction is IAuction, UUPS, Ownable, ReentrancyGuard, Pausable, AuctionStorageV1 {\n    ///                                                          ///\n    ///                          IMMUTABLES                      ///\n    ///                                                          ///\n\n    /// @notice The address of WETH\n    address private immutable WETH;\n\n    /// @notice The contract upgrade manager\n    IManager private immutable manager;\n\n    ///                                                          ///\n    ///                          CONSTRUCTOR                     ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    /// @param _weth The address of WETH\n    constructor(address _manager, address _weth) payable initializer {\n        manager = IManager(_manager);\n        WETH = _weth;\n    }\n\n    ///                                                          ///\n    ///                          INITIALIZER                     ///\n    ///                                                          ///\n\n    /// @notice Initializes a DAO's auction contract\n    /// @param _token The ERC-721 token address\n    /// @param _founder The founder responsible for starting the first auction\n    /// @param _treasury The treasury address where ETH will be sent\n    /// @param _duration The duration of each auction\n    /// @param _reservePrice The reserve price of each auction\n    function initialize(\n        address _token,\n        address _founder,\n        address _treasury,\n        uint256 _duration,\n        uint256 _reservePrice\n    ) external initializer {\n        // Ensure the caller is the contract manager\n        if (msg.sender != address(manager)) revert ONLY_MANAGER();\n\n        // Initialize the reentrancy guard\n        __ReentrancyGuard_init();\n\n        // Grant initial ownership to a founder\n        __Ownable_init(_founder);\n\n        // Pause the contract until the first auction\n        __Pausable_init(true);\n\n        // Store DAO's ERC-721 token\n        token = Token(_token);\n\n        // Store the auction house settings\n        settings.duration = SafeCast.toUint40(_duration);\n        settings.reservePrice = _reservePrice;\n        settings.treasury = _treasury;\n        settings.timeBuffer = 5 minutes;\n        settings.minBidIncrement = 10;\n    }\n\n    ///                                                          ///\n    ///                          CREATE BID                      ///\n    ///                                                          ///\n\n    /// @notice Creates a bid for the current token\n    /// @param _tokenId The ERC-721 token id\n    function createBid(uint256 _tokenId) external payable nonReentrant {\n        // Get a copy of the current auction\n        Auction memory _auction = auction;\n\n        // Ensure the bid is for the current token\n        if (_auction.tokenId != _tokenId) revert INVALID_TOKEN_ID();\n\n        // Ensure the auction is still active\n        if (block.timestamp >= _auction.endTime) revert AUCTION_OVER();\n\n        // Cache the address of the highest bidder\n        address highestBidder = _auction.highestBidder;\n\n        // If this is the first bid:\n        if (highestBidder == address(0)) {\n            // Ensure the bid meets the reserve price\n            if (msg.value < settings.reservePrice) revert RESERVE_PRICE_NOT_MET();\n\n            // Else this is a subsequent bid:\n        } else {\n            // Cache the highest bid\n            uint256 highestBid = _auction.highestBid;\n\n            // Used to store the minimum bid required\n            uint256 minBid;\n\n            // Cannot realistically overflow\n            unchecked {\n                // Compute the minimum bid\n                minBid = highestBid + ((highestBid * settings.minBidIncrement) / 100);\n            }\n\n            // Ensure the incoming bid meets the minimum\n            if (msg.value < minBid) revert MINIMUM_BID_NOT_MET();\n\n            // Refund the previous bidder\n            _handleOutgoingTransfer(highestBidder, highestBid);\n        }\n\n        // Store the new highest bid\n        auction.highestBid = msg.value;\n\n        // Store the new highest bidder\n        auction.highestBidder = msg.sender;\n\n        // Used to store if the auction will be extended\n        bool extend;\n\n        // Cannot underflow as `_auction.endTime` is ensured to be greater than the current time above\n        unchecked {\n            // Compute whether the time remaining is less than the buffer\n            extend = (_auction.endTime - block.timestamp) < settings.timeBuffer;\n        }\n\n        // If the time remaining is within the buffer:\n        if (extend) {\n            // Cannot realistically overflow\n            unchecked {\n                // Extend the auction by the time buffer\n                auction.endTime = uint40(block.timestamp + settings.timeBuffer);\n            }\n        }\n\n        emit AuctionBid(_tokenId, msg.sender, msg.value, extend, auction.endTime);\n    }\n\n    ///                                                          ///\n    ///                    SETTLE & CREATE AUCTION               ///\n    ///                                                          ///\n\n    /// @notice Settles the current auction and creates the next one\n    function settleCurrentAndCreateNewAuction() external nonReentrant whenNotPaused {\n        _settleAuction();\n        _createAuction();\n    }\n\n    /// @dev Settles the current auction\n    function _settleAuction() private {\n        // Get a copy of the current auction\n        Auction memory _auction = auction;\n\n        // Ensure the auction wasn't already settled\n        if (auction.settled) revert AUCTION_SETTLED();\n\n        // Ensure the auction had started\n        if (_auction.startTime == 0) revert AUCTION_NOT_STARTED();\n\n        // Ensure the auction is over\n        if (block.timestamp < _auction.endTime) revert AUCTION_ACTIVE();\n\n        // Mark the auction as settled\n        auction.settled = true;\n\n        // If a bid was placed:\n        if (_auction.highestBidder != address(0)) {\n            // Cache the amount of the highest bid\n            uint256 highestBid = _auction.highestBid;\n\n            // If the highest bid included ETH: Transfer it to the DAO treasury\n            if (highestBid != 0) _handleOutgoingTransfer(settings.treasury, highestBid);\n\n            // Transfer the token to the highest bidder\n            token.transferFrom(address(this), _auction.highestBidder, _auction.tokenId);\n\n            // Else no bid was placed:\n        } else {\n            // Burn the token\n            token.burn(_auction.tokenId);\n        }\n\n        emit AuctionSettled(_auction.tokenId, _auction.highestBidder, _auction.highestBid);\n    }\n\n    /// @dev Creates an auction for the next token\n    function _createAuction() private {\n        // Get the next token available for bidding\n        try token.mint() returns (uint256 tokenId) {\n            // Store the token id\n            auction.tokenId = tokenId;\n\n            // Cache the current timestamp\n            uint256 startTime = block.timestamp;\n\n            // Used to store the auction end time\n            uint256 endTime;\n\n            // Cannot realistically overflow\n            unchecked {\n                // Compute the auction end time\n                endTime = startTime + settings.duration;\n            }\n\n            // Store the auction start and end time\n            auction.startTime = uint40(startTime);\n            auction.endTime = uint40(endTime);\n\n            // Reset data from the previous auction\n            auction.highestBid = 0;\n            auction.highestBidder = address(0);\n            auction.settled = false;\n\n            emit AuctionCreated(tokenId, startTime, endTime);\n\n            // Pause the contract if token minting failed\n        } catch Error(string memory) {\n            _pause();\n        }\n    }\n\n    ///                                                          ///\n    ///                             PAUSE                        ///\n    ///                                                          ///\n\n    /// @notice Unpauses the auction house\n    function unpause() external onlyOwner {\n        _unpause();\n\n        // If this is the first auction:\n        if (auction.tokenId == 0) {\n            // Transfer ownership of the contract to the DAO\n            transferOwnership(settings.treasury);\n\n            // Start the first auction\n            _createAuction();\n        }\n        // Else if the contract was paused and the previous auction was settled:\n        else if (auction.settled) {\n            // Start the next auction\n            _createAuction();\n        }\n    }\n\n    /// @notice Pauses the auction house\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /// @notice Settles the latest auction when the contract is paused\n    function settleAuction() external nonReentrant whenPaused {\n        _settleAuction();\n    }\n\n    ///                                                          ///\n    ///                       AUCTION SETTINGS                   ///\n    ///                                                          ///\n\n    /// @notice The DAO treasury\n    function treasury() external view returns (address) {\n        return settings.treasury;\n    }\n\n    /// @notice The time duration of each auction\n    function duration() external view returns (uint256) {\n        return settings.duration;\n    }\n\n    /// @notice The reserve price of each auction\n    function reservePrice() external view returns (uint256) {\n        return settings.reservePrice;\n    }\n\n    /// @notice The minimum amount of time to place a bid during an active auction\n    function timeBuffer() external view returns (uint256) {\n        return settings.timeBuffer;\n    }\n\n    /// @notice The minimum percentage an incoming bid must raise the highest bid\n    function minBidIncrement() external view returns (uint256) {\n        return settings.minBidIncrement;\n    }\n\n    ///                                                          ///\n    ///                       UPDATE SETTINGS                    ///\n    ///                                                          ///\n\n    /// @notice Updates the time duration of each auction\n    /// @param _duration The new time duration\n    function setDuration(uint256 _duration) external onlyOwner {\n        settings.duration = SafeCast.toUint40(_duration);\n\n        emit DurationUpdated(_duration);\n    }\n\n    /// @notice Updates the reserve price of each auction\n    /// @param _reservePrice The new reserve price\n    function setReservePrice(uint256 _reservePrice) external onlyOwner {\n        settings.reservePrice = _reservePrice;\n\n        emit ReservePriceUpdated(_reservePrice);\n    }\n\n    /// @notice Updates the time buffer of each auction\n    /// @param _timeBuffer The new time buffer\n    function setTimeBuffer(uint256 _timeBuffer) external onlyOwner {\n        settings.timeBuffer = SafeCast.toUint40(_timeBuffer);\n\n        emit TimeBufferUpdated(_timeBuffer);\n    }\n\n    /// @notice Updates the minimum bid increment of each subsequent bid\n    /// @param _percentage The new percentage\n    function setMinimumBidIncrement(uint256 _percentage) external onlyOwner {\n        settings.minBidIncrement = SafeCast.toUint8(_percentage);\n\n        emit MinBidIncrementPercentageUpdated(_percentage);\n    }\n\n    ///                                                          ///\n    ///                        TRANSFER UTIL                     ///\n    ///                                                          ///\n\n    /// @notice Transfer ETH/WETH from the contract\n    /// @param _to The recipient address\n    /// @param _amount The amount transferring\n    function _handleOutgoingTransfer(address _to, uint256 _amount) private {\n        // Ensure the contract has enough ETH to transfer\n        if (address(this).balance < _amount) revert INSOLVENT();\n\n        // Used to store if the transfer succeeded\n        bool success;\n\n        assembly {\n            // Transfer ETH to the recipient\n            // Limit the call to 50,000 gas\n            success := call(50000, _to, _amount, 0, 0, 0, 0)\n        }\n\n        // If the transfer failed:\n        if (!success) {\n            // Wrap as WETH\n            IWETH(WETH).deposit{ value: _amount }();\n\n            // Transfer WETH instead\n            IWETH(WETH).transfer(_to, _amount);\n        }\n    }\n\n    ///                                                          ///\n    ///                        AUCTION UPGRADE                   ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override onlyOwner {\n        // Ensure the new implementation is registered by the Builder DAO\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}"
    },
    {
      "filename": "src/auction/Auction.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { UUPS } from \"../lib/proxy/UUPS.sol\";\nimport { Ownable } from \"../lib/utils/Ownable.sol\";\nimport { ReentrancyGuard } from \"../lib/utils/ReentrancyGuard.sol\";\nimport { Pausable } from \"../lib/utils/Pausable.sol\";\nimport { SafeCast } from \"../lib/utils/SafeCast.sol\";\n\nimport { AuctionStorageV1 } from \"./storage/AuctionStorageV1.sol\";\nimport { Token } from \"../token/Token.sol\";\nimport { IManager } from \"../manager/IManager.sol\";\nimport { IAuction } from \"./IAuction.sol\";\nimport { IWETH } from \"../lib/interfaces/IWETH.sol\";\n\n/// @title Auction\n/// @author Rohan Kulkarni\n/// @notice A DAO's auction house\n/// Modified from:\n/// - NounsAuctionHouse.sol commit 2cbe6c7 - licensed under the BSD-3-Clause license.\n/// - Zora V3 ReserveAuctionCoreEth module commit 795aeca - licensed under the GPL-3.0 license.\ncontract Auction is IAuction, UUPS, Ownable, ReentrancyGuard, Pausable, AuctionStorageV1 {\n    ///                                                          ///\n    ///                          IMMUTABLES                      ///\n    ///                                                          ///\n\n    /// @notice The address of WETH\n    address private immutable WETH;\n\n    /// @notice The contract upgrade manager\n    IManager private immutable manager;\n\n    ///                                                          ///\n    ///                          CONSTRUCTOR                     ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    /// @param _weth The address of WETH\n    constructor(address _manager, address _weth) payable initializer {\n        manager = IManager(_manager);\n        WETH = _weth;\n    }\n\n    ///                                                          ///\n    ///                          INITIALIZER                     ///\n    ///                                                          ///\n\n    /// @notice Initializes a DAO's auction contract\n    /// @param _token The ERC-721 token address\n    /// @param _founder The founder responsible for starting the first auction\n    /// @param _treasury The treasury address where ETH will be sent\n    /// @param _duration The duration of each auction\n    /// @param _reservePrice The reserve price of each auction\n    function initialize(\n        address _token,\n        address _founder,\n        address _treasury,\n        uint256 _duration,\n        uint256 _reservePrice\n    ) external initializer {\n        // Ensure the caller is the contract manager\n        if (msg.sender != address(manager)) revert ONLY_MANAGER();\n\n        // Initialize the reentrancy guard\n        __ReentrancyGuard_init();\n\n        // Grant initial ownership to a founder\n        __Ownable_init(_founder);\n\n        // Pause the contract until the first auction\n        __Pausable_init(true);\n\n        // Store DAO's ERC-721 token\n        token = Token(_token);\n\n        // Store the auction house settings\n        settings.duration = SafeCast.toUint40(_duration);\n        settings.reservePrice = _reservePrice;\n        settings.treasury = _treasury;\n        settings.timeBuffer = 5 minutes;\n        settings.minBidIncrement = 10;\n    }\n\n    ///                                                          ///\n    ///                          CREATE BID                      ///\n    ///                                                          ///\n\n    /// @notice Creates a bid for the current token\n    /// @param _tokenId The ERC-721 token id\n    function createBid(uint256 _tokenId) external payable nonReentrant {\n        // Get a copy of the current auction\n        Auction memory _auction = auction;\n\n        // Ensure the bid is for the current token\n        if (_auction.tokenId != _tokenId) revert INVALID_TOKEN_ID();\n\n        // Ensure the auction is still active\n        if (block.timestamp >= _auction.endTime) revert AUCTION_OVER();\n\n        // Cache the address of the highest bidder\n        address highestBidder = _auction.highestBidder;\n\n        // If this is the first bid:\n        if (highestBidder == address(0)) {\n            // Ensure the bid meets the reserve price\n            if (msg.value < settings.reservePrice) revert RESERVE_PRICE_NOT_MET();\n\n            // Else this is a subsequent bid:\n        } else {\n            // Cache the highest bid\n            uint256 highestBid = _auction.highestBid;\n\n            // Used to store the minimum bid required\n            uint256 minBid;\n\n            // Cannot realistically overflow\n            unchecked {\n                // Compute the minimum bid\n                minBid = highestBid + ((highestBid * settings.minBidIncrement) / 100);\n            }\n\n            // Ensure the incoming bid meets the minimum\n            if (msg.value < minBid) revert MINIMUM_BID_NOT_MET();\n\n            // Refund the previous bidder\n            _handleOutgoingTransfer(highestBidder, highestBid);\n        }\n\n        // Store the new highest bid\n        auction.highestBid = msg.value;\n\n        // Store the new highest bidder\n        auction.highestBidder = msg.sender;\n\n        // Used to store if the auction will be extended\n        bool extend;\n\n        // Cannot underflow as `_auction.endTime` is ensured to be greater than the current time above\n        unchecked {\n            // Compute whether the time remaining is less than the buffer\n            extend = (_auction.endTime - block.timestamp) < settings.timeBuffer;\n        }\n\n        // If the time remaining is within the buffer:\n        if (extend) {\n            // Cannot realistically overflow\n            unchecked {\n                // Extend the auction by the time buffer\n                auction.endTime = uint40(block.timestamp + settings.timeBuffer);\n            }\n        }\n\n        emit AuctionBid(_tokenId, msg.sender, msg.value, extend, auction.endTime);\n    }\n\n    ///                                                          ///\n    ///                    SETTLE & CREATE AUCTION               ///\n    ///                                                          ///\n\n    /// @notice Settles the current auction and creates the next one\n    function settleCurrentAndCreateNewAuction() external nonReentrant whenNotPaused {\n        _settleAuction();\n        _createAuction();\n    }\n\n    /// @dev Settles the current auction\n    function _settleAuction() private {\n        // Get a copy of the current auction\n        Auction memory _auction = auction;\n\n        // Ensure the auction wasn't already settled\n        if (auction.settled) revert AUCTION_SETTLED();\n\n        // Ensure the auction had started\n        if (_auction.startTime == 0) revert AUCTION_NOT_STARTED();\n\n        // Ensure the auction is over\n        if (block.timestamp < _auction.endTime) revert AUCTION_ACTIVE();\n\n        // Mark the auction as settled\n        auction.settled = true;\n\n        // If a bid was placed:\n        if (_auction.highestBidder != address(0)) {\n            // Cache the amount of the highest bid\n            uint256 highestBid = _auction.highestBid;\n\n            // If the highest bid included ETH: Transfer it to the DAO treasury\n            if (highestBid != 0) _handleOutgoingTransfer(settings.treasury, highestBid);\n\n            // Transfer the token to the highest bidder\n            token.transferFrom(address(this), _auction.highestBidder, _auction.tokenId);\n\n            // Else no bid was placed:\n        } else {\n            // Burn the token\n            token.burn(_auction.tokenId);\n        }\n\n        emit AuctionSettled(_auction.tokenId, _auction.highestBidder, _auction.highestBid);\n    }\n\n    /// @dev Creates an auction for the next token\n    function _createAuction() private {\n        // Get the next token available for bidding\n        try token.mint() returns (uint256 tokenId) {\n            // Store the token id\n            auction.tokenId = tokenId;\n\n            // Cache the current timestamp\n            uint256 startTime = block.timestamp;\n\n            // Used to store the auction end time\n            uint256 endTime;\n\n            // Cannot realistically overflow\n            unchecked {\n                // Compute the auction end time\n                endTime = startTime + settings.duration;\n            }\n\n            // Store the auction start and end time\n            auction.startTime = uint40(startTime);\n            auction.endTime = uint40(endTime);\n\n            // Reset data from the previous auction\n            auction.highestBid = 0;\n            auction.highestBidder = address(0);\n            auction.settled = false;\n\n            emit AuctionCreated(tokenId, startTime, endTime);\n\n            // Pause the contract if token minting failed\n        } catch Error(string memory) {\n            _pause();\n        }\n    }\n\n    ///                                                          ///\n    ///                             PAUSE                        ///\n    ///                                                          ///\n\n    /// @notice Unpauses the auction house\n    function unpause() external onlyOwner {\n        _unpause();\n\n        // If this is the first auction:\n        if (auction.tokenId == 0) {\n            // Transfer ownership of the contract to the DAO\n            transferOwnership(settings.treasury);\n\n            // Start the first auction\n            _createAuction();\n        }\n        // Else if the contract was paused and the previous auction was settled:\n        else if (auction.settled) {\n            // Start the next auction\n            _createAuction();\n        }\n    }\n\n    /// @notice Pauses the auction house\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /// @notice Settles the latest auction when the contract is paused\n    function settleAuction() external nonReentrant whenPaused {\n        _settleAuction();\n    }\n\n    ///                                                          ///\n    ///                       AUCTION SETTINGS                   ///\n    ///                                                          ///\n\n    /// @notice The DAO treasury\n    function treasury() external view returns (address) {\n        return settings.treasury;\n    }\n\n    /// @notice The time duration of each auction\n    function duration() external view returns (uint256) {\n        return settings.duration;\n    }\n\n    /// @notice The reserve price of each auction\n    function reservePrice() external view returns (uint256) {\n        return settings.reservePrice;\n    }\n\n    /// @notice The minimum amount of time to place a bid during an active auction\n    function timeBuffer() external view returns (uint256) {\n        return settings.timeBuffer;\n    }\n\n    /// @notice The minimum percentage an incoming bid must raise the highest bid\n    function minBidIncrement() external view returns (uint256) {\n        return settings.minBidIncrement;\n    }\n\n    ///                                                          ///\n    ///                       UPDATE SETTINGS                    ///\n    ///                                                          ///\n\n    /// @notice Updates the time duration of each auction\n    /// @param _duration The new time duration\n    function setDuration(uint256 _duration) external onlyOwner {\n        settings.duration = SafeCast.toUint40(_duration);\n\n        emit DurationUpdated(_duration);\n    }\n\n    /// @notice Updates the reserve price of each auction\n    /// @param _reservePrice The new reserve price\n    function setReservePrice(uint256 _reservePrice) external onlyOwner {\n        settings.reservePrice = _reservePrice;\n\n        emit ReservePriceUpdated(_reservePrice);\n    }\n\n    /// @notice Updates the time buffer of each auction\n    /// @param _timeBuffer The new time buffer\n    function setTimeBuffer(uint256 _timeBuffer) external onlyOwner {\n        settings.timeBuffer = SafeCast.toUint40(_timeBuffer);\n\n        emit TimeBufferUpdated(_timeBuffer);\n    }\n\n    /// @notice Updates the minimum bid increment of each subsequent bid\n    /// @param _percentage The new percentage\n    function setMinimumBidIncrement(uint256 _percentage) external onlyOwner {\n        settings.minBidIncrement = SafeCast.toUint8(_percentage);\n\n        emit MinBidIncrementPercentageUpdated(_percentage);\n    }\n\n    ///                                                          ///\n    ///                        TRANSFER UTIL                     ///\n    ///                                                          ///\n\n    /// @notice Transfer ETH/WETH from the contract\n    /// @param _to The recipient address\n    /// @param _amount The amount transferring\n    function _handleOutgoingTransfer(address _to, uint256 _amount) private {\n        // Ensure the contract has enough ETH to transfer\n        if (address(this).balance < _amount) revert INSOLVENT();\n\n        // Used to store if the transfer succeeded\n        bool success;\n\n        assembly {\n            // Transfer ETH to the recipient\n            // Limit the call to 50,000 gas\n            success := call(50000, _to, _amount, 0, 0, 0, 0)\n        }\n\n        // If the transfer failed:\n        if (!success) {\n            // Wrap as WETH\n            IWETH(WETH).deposit{ value: _amount }();\n\n            // Transfer WETH instead\n            IWETH(WETH).transfer(_to, _amount);\n        }\n    }\n\n    ///                                                          ///\n    ///                        AUCTION UPGRADE                   ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override onlyOwner {\n        // Ensure the new implementation is registered by the Builder DAO\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}"
    },
    {
      "filename": "src/auction/Auction.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { UUPS } from \"../lib/proxy/UUPS.sol\";\nimport { Ownable } from \"../lib/utils/Ownable.sol\";\nimport { ReentrancyGuard } from \"../lib/utils/ReentrancyGuard.sol\";\nimport { Pausable } from \"../lib/utils/Pausable.sol\";\nimport { SafeCast } from \"../lib/utils/SafeCast.sol\";\n\nimport { AuctionStorageV1 } from \"./storage/AuctionStorageV1.sol\";\nimport { Token } from \"../token/Token.sol\";\nimport { IManager } from \"../manager/IManager.sol\";\nimport { IAuction } from \"./IAuction.sol\";\nimport { IWETH } from \"../lib/interfaces/IWETH.sol\";\n\n/// @title Auction\n/// @author Rohan Kulkarni\n/// @notice A DAO's auction house\n/// Modified from:\n/// - NounsAuctionHouse.sol commit 2cbe6c7 - licensed under the BSD-3-Clause license.\n/// - Zora V3 ReserveAuctionCoreEth module commit 795aeca - licensed under the GPL-3.0 license.\ncontract Auction is IAuction, UUPS, Ownable, ReentrancyGuard, Pausable, AuctionStorageV1 {\n    ///                                                          ///\n    ///                          IMMUTABLES                      ///\n    ///                                                          ///\n\n    /// @notice The address of WETH\n    address private immutable WETH;\n\n    /// @notice The contract upgrade manager\n    IManager private immutable manager;\n\n    ///                                                          ///\n    ///                          CONSTRUCTOR                     ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    /// @param _weth The address of WETH\n    constructor(address _manager, address _weth) payable initializer {\n        manager = IManager(_manager);\n        WETH = _weth;\n    }\n\n    ///                                                          ///\n    ///                          INITIALIZER                     ///\n    ///                                                          ///\n\n    /// @notice Initializes a DAO's auction contract\n    /// @param _token The ERC-721 token address\n    /// @param _founder The founder responsible for starting the first auction\n    /// @param _treasury The treasury address where ETH will be sent\n    /// @param _duration The duration of each auction\n    /// @param _reservePrice The reserve price of each auction\n    function initialize(\n        address _token,\n        address _founder,\n        address _treasury,\n        uint256 _duration,\n        uint256 _reservePrice\n    ) external initializer {\n        // Ensure the caller is the contract manager\n        if (msg.sender != address(manager)) revert ONLY_MANAGER();\n\n        // Initialize the reentrancy guard\n        __ReentrancyGuard_init();\n\n        // Grant initial ownership to a founder\n        __Ownable_init(_founder);\n\n        // Pause the contract until the first auction\n        __Pausable_init(true);\n\n        // Store DAO's ERC-721 token\n        token = Token(_token);\n\n        // Store the auction house settings\n        settings.duration = SafeCast.toUint40(_duration);\n        settings.reservePrice = _reservePrice;\n        settings.treasury = _treasury;\n        settings.timeBuffer = 5 minutes;\n        settings.minBidIncrement = 10;\n    }\n\n    ///                                                          ///\n    ///                          CREATE BID                      ///\n    ///                                                          ///\n\n    /// @notice Creates a bid for the current token\n    /// @param _tokenId The ERC-721 token id\n    function createBid(uint256 _tokenId) external payable nonReentrant {\n        // Get a copy of the current auction\n        Auction memory _auction = auction;\n\n        // Ensure the bid is for the current token\n        if (_auction.tokenId != _tokenId) revert INVALID_TOKEN_ID();\n\n        // Ensure the auction is still active\n        if (block.timestamp >= _auction.endTime) revert AUCTION_OVER();\n\n        // Cache the address of the highest bidder\n        address highestBidder = _auction.highestBidder;\n\n        // If this is the first bid:\n        if (highestBidder == address(0)) {\n            // Ensure the bid meets the reserve price\n            if (msg.value < settings.reservePrice) revert RESERVE_PRICE_NOT_MET();\n\n            // Else this is a subsequent bid:\n        } else {\n            // Cache the highest bid\n            uint256 highestBid = _auction.highestBid;\n\n            // Used to store the minimum bid required\n            uint256 minBid;\n\n            // Cannot realistically overflow"
    }
  ]
}