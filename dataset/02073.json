{
  "Title": "H-7: Limit orders are broken when there are price gaps",
  "Content": "# Issue H-7: Limit orders are broken when there are price gaps \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/140 \n\n## Found by \nIllIllI\n\n## Summary\n\nLimit orders fail to execute when the price becomes worse for the order in the block after the order is submitted.\n\n\n## Vulnerability Detail\n\nLimit orders require that all oracle-provided prices come from blocks [_after_](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/order/DecreaseOrderUtils.sol#L134-L156) the order has been submitted. In addition, limit orders's primary and secondary prices are required to straddle the trigger price.\n\n## Impact\n\nIf the primary/secondary prices go well past the trigger price (e.g. due to a price gap), then the order execution will revert, leaving the user exposed to their position, even if they had a valid stoploss set.\n\n\n## Code Snippet\n\nLimit orders require prices to straddle the trigger price, and revert if they don't:\n```solidity\n// File: gmx-synthetics/contracts/order/BaseOrderUtils.sol : BaseOrderUtils.setExactOrderPrice()   #1\n\n238            if (orderType == Order.OrderType.LimitIncrease ||\n239                orderType == Order.OrderType.LimitDecrease ||\n240                orderType == Order.OrderType.StopLossDecrease\n241            ) {\n242                uint256 primaryPrice = oracle.getPrimaryPrice(indexToken).pickPrice(shouldUseMaxPrice);\n243                uint256 secondaryPrice = oracle.getSecondaryPrice(indexToken).pickPrice(shouldUseMaxPrice);\n244    \n...\n258                if (shouldValidateAscendingPrice) {\n259                    // check that the earlier price (primaryPrice) is smaller than the triggerPrice\n260                    // and that the later price (secondaryPrice) is larger than the triggerPrice\n261 @>                 bool ok = primaryPrice <= triggerPrice && triggerPrice <= secondaryPrice;\n262                    if (!ok) {\n263                        revert InvalidOrderPrices(primaryPrice, secondaryPrice, triggerPrice, shouldValidateAscendingPrice);\n264                    }\n...\n270                } else {\n271                    // check that the earlier price (primaryPrice) is larger than the triggerPrice\n272                    // and that the later price (secondaryPrice) is smaller than the triggerPrice\n273 @>                 bool ok = primaryPrice >= triggerPrice && triggerPrice >= secondaryPrice;\n274                    if (!ok) {\n275                        revert InvalidOrderPrices(primaryPrice, secondaryPrice, triggerPrice, shouldValidateAscendingPrice);\n276                    }\n...\n282:               }\n```\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/order/BaseOrderUtils.sol#L228-L288\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nDon't [revert](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/exchange/OrderHandler.sol#L253) if both the primary and secondary prices are worse than the trigger price. Use the trigger price as the execution price.\n\n\n\n\n## Discussion\n\n**xvi10**\n\nFix in https://github.com/gmx-io/gmx-synthetics/commit/ec586b87cd677d6e0426000fb746613537027160#diff-d3ac89c96efb4157bb20ef7f24459de430ab4f29ffa8b39d92db13843e92c5a5\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/order/DecreaseOrderUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./BaseOrderUtils.sol\";\nimport \"../swap/SwapUtils.sol\";\nimport \"../position/DecreasePositionUtils.sol\";\nimport \"../order/OrderStoreUtils.sol\";\nimport \"../utils/ErrorUtils.sol\";\n\n// @title DecreaseOrderUtils\n// @dev Library for functions to help with processing a decrease order\nlibrary DecreaseOrderUtils {\n    using Position for Position.Props;\n    using Order for Order.Props;\n    using Array for uint256[];\n\n    // @dev process a decrease order\n    // @param params BaseOrderUtils.ExecuteOrderParams\n    function processOrder(BaseOrderUtils.ExecuteOrderParams memory params) external {\n        Order.Props memory order = params.order;\n        MarketUtils.validateEnabledMarket(params.contracts.dataStore, params.market);\n        MarketUtils.validatePositionMarket(params.market);\n\n        bytes32 positionKey = PositionUtils.getPositionKey(order.account(), order.market(), order.initialCollateralToken(), order.isLong());\n        Position.Props memory position = PositionStoreUtils.get(params.contracts.dataStore, positionKey);\n        PositionUtils.validateNonEmptyPosition(position);\n\n        validateOracleBlockNumbers(\n            params.minOracleBlockNumbers,\n            params.maxOracleBlockNumbers,\n            order.orderType(),\n            order.updatedAtBlock(),\n            position.increasedAtBlock(),\n            position.decreasedAtBlock()\n        );\n\n        DecreasePositionUtils.DecreasePositionResult memory result = DecreasePositionUtils.decreasePosition(\n            PositionUtils.UpdatePositionParams(\n                params.contracts,\n                params.market,\n                order,\n                params.key,\n                position,\n                positionKey\n            )\n        );\n\n        OrderStoreUtils.remove(params.contracts.dataStore, params.key, order.account());\n\n        // if the pnlToken and the collateralToken are different\n        // and if a swap fails or no swap was requested\n        // then it is possible to receive two separate tokens from decreasing\n        // the position\n        // transfer the two tokens to the user in this case and skip processing\n        // the swapPath\n        if (result.secondaryOutputAmount > 0) {\n            MarketToken(payable(order.market())).transferOut(\n                result.outputToken,\n                order.receiver(),\n                result.outputAmount,\n                order.shouldUnwrapNativeToken()\n            );\n\n            MarketToken(payable(order.market())).transferOut(\n                result.secondaryOutputToken,\n                order.receiver(),\n                result.secondaryOutputAmount,\n                order.shouldUnwrapNativeToken()\n            );\n\n            return;\n        }\n\n        if (order.swapPath().length == 0) {\n            MarketToken(payable(order.market())).transferOut(\n                result.outputToken,\n                order.receiver(),\n                result.outputAmount,\n                order.shouldUnwrapNativeToken()\n            );\n        } else {\n            try params.contracts.swapHandler.swap(\n                SwapUtils.SwapParams(\n                    params.contracts.dataStore,\n                    params.contracts.eventEmitter,\n                    params.contracts.oracle,\n                    Bank(payable(order.market())),\n                    result.outputToken,\n                    result.outputAmount,\n                    params.swapPathMarkets,\n                    order.minOutputAmount(),\n                    order.receiver(),\n                    order.shouldUnwrapNativeToken()\n                )\n            ) returns (address /* tokenOut */, uint256 /* swapOutputAmount */) {\n            } catch Error(string memory reason) {\n                _handleSwapError(\n                    order,\n                    result,\n                    reason,\n                    \"\"\n                );\n            } catch (bytes memory reasonBytes) {\n                (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n                _handleSwapError(\n                    order,\n                    result,\n                    reason,\n                    reasonBytes\n                );\n            }\n        }\n    }\n\n    // @dev validate the oracle block numbers used for the prices in the oracle\n    // @param oracleBlockNumbers the oracle block numbers\n    // @param orderType the order type\n    // @param orderUpdatedAtBlock the block at which the order was last updated\n    // @param positionIncreasedAtBlock the block at which the position was last increased\n    // @param positionDecreasedAtBlock the block at which the position was last decreased\n    function validateOracleBlockNumbers(\n        uint256[] memory minOracleBlockNumbers,\n        uint256[] memory maxOracleBlockNumbers,\n        Order.OrderType orderType,\n        uint256 orderUpdatedAtBlock,\n        uint256 positionIncreasedAtBlock,\n        uint256 positionDecreasedAtBlock\n    ) internal pure {\n        if (orderType == Order.OrderType.MarketDecrease) {\n            OracleUtils.validateBlockNumberWithinRange(\n                minOracleBlockNumbers,\n                maxOracleBlockNumbers,\n                orderUpdatedAtBlock\n            );\n            return;\n        }\n\n        if (\n            orderType == Order.OrderType.LimitDecrease ||\n            orderType == Order.OrderType.StopLossDecrease\n        ) {\n            uint256 latestUpdatedAtBlock = orderUpdatedAtBlock > positionIncreasedAtBlock ? orderUpdatedAtBlock : positionIncreasedAtBlock;\n            if (!minOracleBlockNumbers.areGreaterThan(latestUpdatedAtBlock)) {\n                OracleUtils.revertOracleBlockNumbersAreSmallerThanRequired(minOracleBlockNumbers, latestUpdatedAtBlock);\n            }\n            return;\n        }\n\n        if (orderType == Order.OrderType.Liquidation) {\n            uint256 latestUpdatedAtBlock = positionIncreasedAtBlock > positionDecreasedAtBlock ? positionIncreasedAtBlock : positionDecreasedAtBlock;\n\n            if (!minOracleBlockNumbers.areGreaterThan(latestUpdatedAtBlock)) {\n                OracleUtils.revertOracleBlockNumbersAreSmallerThanRequired(minOracleBlockNumbers, latestUpdatedAtBlock);\n            }\n            return;\n        }\n\n        BaseOrderUtils.revertUnsupportedOrderType();\n    }\n\n    function _handleSwapError(\n        Order.Props memory order,\n        DecreasePositionUtils.DecreasePositionResult memory result,\n        string memory reason,\n        bytes memory reasonBytes\n    ) internal {\n        emit SwapUtils.SwapReverted(reason, reasonBytes);\n\n        MarketToken(payable(order.market())).transferOut(\n            result.outputToken,\n            order.receiver(),\n            result.outputAmount,\n            order.shouldUnwrapNativeToken()\n        );\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/order/BaseOrderUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./Order.sol\";\nimport \"../market/Market.sol\";\n\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\n\nimport \"../order/OrderVault.sol\";\n\nimport \"../oracle/Oracle.sol\";\nimport \"../swap/SwapHandler.sol\";\n\n// @title Order\n// @dev Library for common order functions used in OrderUtils, IncreaseOrderUtils\n// DecreaseOrderUtils, SwapOrderUtils\nlibrary BaseOrderUtils {\n    using SafeCast for int256;\n    using SafeCast for uint256;\n\n    using Order for Order.Props;\n    using Price for Price.Props;\n\n    // @dev CreateOrderParams struct used in createOrder to avoid stack\n    // too deep errors\n    //\n    // @param addresses address values\n    // @param numbers number values\n    // @param orderType for order.orderType\n    // @param isLong for order.isLong\n    // @param shouldUnwrapNativeToken for order.shouldUnwrapNativeToken\n    struct CreateOrderParams {\n        CreateOrderParamsAddresses addresses;\n        CreateOrderParamsNumbers numbers;\n        Order.OrderType orderType;\n        Order.DecreasePositionSwapType decreasePositionSwapType;\n        bool isLong;\n        bool shouldUnwrapNativeToken;\n        bytes32 referralCode;\n    }\n\n    // @param receiver for order.receiver\n    // @param callbackContract for order.callbackContract\n    // @param market for order.market\n    // @param initialCollateralToken for order.initialCollateralToken\n    // @param swapPath for order.swapPath\n    struct CreateOrderParamsAddresses {\n        address receiver;\n        address callbackContract;\n        address market;\n        address initialCollateralToken;\n        address[] swapPath;\n    }\n\n    // @param sizeDeltaUsd for order.sizeDeltaUsd\n    // @param triggerPrice for order.triggerPrice\n    // @param acceptablePrice for order.acceptablePrice\n    // @param executionFee for order.executionFee\n    // @param callbackGasLimit for order.callbackGasLimit\n    // @param minOutputAmount for order.minOutputAmount\n    struct CreateOrderParamsNumbers {\n        uint256 sizeDeltaUsd;\n        uint256 initialCollateralDeltaAmount;\n        uint256 triggerPrice;\n        uint256 acceptablePrice;\n        uint256 executionFee;\n        uint256 callbackGasLimit;\n        uint256 minOutputAmount;\n    }\n\n    // @dev ExecuteOrderParams struct used in executeOrder to avoid stack\n    // too deep errors\n    //\n    // @param key the key of the order to execute\n    // @param order the order to execute\n    // @param swapPathMarkets the market values of the markets in the swapPath\n    // @param oracleBlockNumbers the oracle block numbers for the prices in the oracle\n    // @param market market values of the trading market\n    // @param keeper the keeper sending the transaction\n    // @param startingGas the starting gas\n    // @param positionKey the key of the order's position\n    struct ExecuteOrderParams {\n        ExecuteOrderParamsContracts contracts;\n        bytes32 key;\n        Order.Props order;\n        Market.Props[] swapPathMarkets;\n        uint256[] minOracleBlockNumbers;\n        uint256[] maxOracleBlockNumbers;\n        Market.Props market;\n        address keeper;\n        uint256 startingGas;\n        bytes32 positionKey;\n    }\n\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param orderVault OrderVault\n    // @param oracle Oracle\n    // @param swapHandler SwapHandler\n    // @param referralStorage IReferralStorage\n    struct ExecuteOrderParamsContracts {\n        DataStore dataStore;\n        EventEmitter eventEmitter;\n        OrderVault orderVault;\n        Oracle oracle;\n        SwapHandler swapHandler;\n        IReferralStorage referralStorage;\n    }\n\n    error EmptyOrder();\n    error UnsupportedOrderType();\n    error InvalidOrderPrices(\n        uint256 primaryPrice,\n        uint256 secondaryPrice,\n        uint256 triggerPrice,\n        bool shouldValidateAscendingPrice\n    );\n    error PriceImpactLargerThanOrderSize(int256 priceImpactUsdForPriceAdjustment, uint256 sizeDeltaUsd);\n    error OrderNotFulfillableDueToPriceImpact(uint256 price, uint256 acceptablePrice);\n\n    // @dev check if an orderType is a market order\n    // @param orderType the order type\n    // @return whether an orderType is a market order\n    function isMarketOrder(Order.OrderType orderType) internal pure returns (bool) {\n        return orderType == Order.OrderType.MarketSwap ||\n               orderType == Order.OrderType.MarketIncrease ||\n               orderType == Order.OrderType.MarketDecrease ||\n               orderType == Order.OrderType.Liquidation;\n    }\n\n    // @dev check if an orderType is a limit order\n    // @param orderType the order type\n    // @return whether an orderType is a limit order\n    function isLimitOrder(Order.OrderType orderType) internal pure returns (bool) {\n        return orderType == Order.OrderType.LimitSwap ||\n               orderType == Order.OrderType.LimitIncrease ||\n               orderType == Order.OrderType.LimitDecrease;\n    }\n\n    // @dev check if an orderType is a swap order\n    // @param orderType the order type\n    // @return whether an orderType is a swap order\n    function isSwapOrder(Order.OrderType orderType) internal pure returns (bool) {\n        return orderType == Order.OrderType.MarketSwap ||\n               orderType == Order.OrderType.LimitSwap;\n    }\n\n    // @dev check if an orderType is a position order\n    // @param orderType the order type\n    // @return whether an orderType is a position order\n    function isPositionOrder(Order.OrderType orderType) internal pure returns (bool) {\n        return isIncreaseOrder(orderType) || isDecreaseOrder(orderType);\n    }\n\n    // @dev check if an orderType is an increase order\n    // @param orderType the order type\n    // @return whether an orderType is an increase order\n    function isIncreaseOrder(Order.OrderType orderType) internal pure returns (bool) {\n        return orderType == Order.OrderType.MarketIncrease ||\n               orderType == Order.OrderType.LimitIncrease;\n    }\n\n    // @dev check if an orderType is a decrease order\n    // @param orderType the order type\n    // @return whether an orderType is a decrease order\n    function isDecreaseOrder(Order.OrderType orderType) internal pure returns (bool) {\n        return orderType == Order.OrderType.MarketDecrease ||\n               orderType == Order.OrderType.LimitDecrease ||\n               orderType == Order.OrderType.StopLossDecrease ||\n               orderType == Order.OrderType.Liquidation;\n    }\n\n    // @dev check if an orderType is a liquidation order\n    // @param orderType the order type\n    // @return whether an orderType is a liquidation order\n    function isLiquidationOrder(Order.OrderType orderType) internal pure returns (bool) {\n        return orderType == Order.OrderType.Liquidation;\n    }\n\n    // @dev set the price for increase / decrease position orders\n    //\n    // for market orders, set the min and max values of the customPrice for the indexToken\n    // to either secondaryPrice.min or secondaryPrice.max depending on whether the order\n    // is an increase or decrease and whether it is for a long or short\n    //\n    // customPrice.min and customPrice.max will be equal in this case\n    // this is because in getExecutionPrice the function will try to use the closest price which can fulfill\n    // the order, if customPrice.min is set to secondaryPrice.min and customPrice.max is set to secondaryPrice.max\n    // getExecutionPrice will pick a better price than what should be possible\n    //\n    // for limit / stop-loss orders, the min and max value will be set to the triggerPrice\n    // and latest secondaryPrice value, this represents the price that the user desired the order\n    // to be fulfilled at and the best oracle price that the order could be fulfilled at\n    //\n    // getExecutionPrice handles the logic for selecting the execution price to use\n    //\n    // @param oracle Oracle\n    // @param indexToken the index token\n    // @param orderType the order type\n    // @param triggerPrice the order's triggerPrice\n    // @param isLong whether the order is for a long or short\n    function setExactOrderPrice(\n        Oracle oracle,\n        address indexToken,\n        Order.OrderType orderType,\n        uint256 triggerPrice,\n        bool isLong\n    ) internal {\n        if (isSwapOrder(orderType)) {\n            return;\n        }\n\n        bool isIncrease = isIncreaseOrder(orderType);\n        // increase order:\n        //     - long: use the larger price\n        //     - short: use the smaller price\n        // decrease order:\n        //     - long: use the smaller price\n        //     - short: use the larger price\n        bool shouldUseMaxPrice = isIncrease ? isLong : !isLong;\n\n        if (orderType == Order.OrderType.MarketIncrease ||\n            orderType == Order.OrderType.MarketDecrease ||\n            orderType == Order.OrderType.Liquidation) {\n\n            Price.Props memory price = oracle.getPrimaryPrice(indexToken);\n\n            oracle.setCustomPrice(indexToken, Price.Props(\n                price.pickPrice(shouldUseMaxPrice),\n                price.pickPrice(shouldUseMaxPrice)\n            ));\n\n            return;\n        }\n\n        if (orderType == Order.OrderType.LimitIncrease ||\n            orderType == Order.OrderType.LimitDecrease ||\n            orderType == Order.OrderType.StopLossDecrease\n        ) {\n            uint256 primaryPrice = oracle.getPrimaryPrice(indexToken).pickPrice(shouldUseMaxPrice);\n            uint256 secondaryPrice = oracle.getSecondaryPrice(indexToken).pickPrice(shouldUseMaxPrice);\n\n            bool shouldValidateAscendingPrice;\n            if (orderType == Order.OrderType.LimitIncrease || orderType == Order.OrderType.StopLossDecrease) {\n                // for limit increase / stop-loss decrease order:\n                //     - long: validate descending price\n                //     - short: validate ascending price\n                shouldValidateAscendingPrice = !isLong;\n            } else {\n                // for limit decrease order:\n                //     - long: validate ascending price\n                //     - short: validate descending price\n                shouldValidateAscendingPrice = isLong;\n            }\n\n            if (shouldValidateAscendingPrice) {\n                // check that the earlier price (primaryPrice) is smaller than the triggerPrice\n                // and that the later price (secondaryPrice) is larger than the triggerPrice\n                bool ok = primaryPrice <= triggerPrice && triggerPrice <= secondaryPrice;\n                if (!ok) {\n                    revert InvalidOrderPrices(primaryPrice, secondaryPrice, triggerPrice, shouldValidateAscendingPrice);\n                }\n\n                oracle.setCustomPrice(indexToken, Price.Props(\n                    triggerPrice, // min price that order can be executed with\n                    secondaryPrice // max price that order can be executed with\n                ));\n            } else {\n                // check that the earlier price (primaryPrice) is larger than the triggerPrice\n                // and that the later price (secondaryPrice) is smaller than the triggerPrice\n                bool ok = primaryPrice >= triggerPrice && triggerPrice >= secondaryPrice;\n                if (!ok) {\n                    revert InvalidOrderPrices(primaryPrice, secondaryPrice, triggerPrice, shouldValidateAscendingPrice);\n                }\n\n                oracle.setCustomPrice(indexToken, Price.Props(\n                    secondaryPrice, // min price that order can be executed with\n                    triggerPrice // max price that order can be executed with\n                ));\n            }\n\n            return;\n        }\n\n        revertUnsupportedOrderType();\n    }\n\n    // @dev get the execution price for an order\n    //\n    // see setExactOrderPrice for information on the customPrice values\n    //\n    // for limit / stop-loss orders, the triggerPrice is returned here if it can\n    // fulfill the acceptablePrice after factoring in price impact\n    //\n    // if the triggerPrice cannot fulfill the acceptablePrice, check if the acceptablePrice\n    // can be fulfilled using the best oracle price after factoring in price impact\n    // if it can be fulfilled, fulfill the order at the acceptablePrice\n    //\n    // @param customIndexTokenPrice the custom price of the index token\n    // @param sizeDeltaUsd the order.sizeDeltaUsd\n    // @param priceImpactUsd the price impact of the order\n    // @param acceptablePrice the order.acceptablePrice\n    // @param isLong whether this is for a long or short order\n    // @param isIncrease whether this is for an increase or decrease order\n    // @return the execution price\n    function getExecutionPrice(\n        Price.Props memory customIndexTokenPrice,\n        uint256 sizeDeltaUsd,\n        int256 priceImpactUsd,\n        uint256 acceptablePrice,\n        bool isLong,\n        bool isIncrease\n    ) internal pure returns (uint256) {\n        // increase order:\n        //     - long: use the larger price\n        //     - short: use the smaller price\n        // decrease order:\n        //     - long: use the smaller price\n        //     - short: use the larger price\n        bool shouldUseMaxPrice = isIncrease ? isLong : !isLong;\n\n        // should price be smaller than acceptablePrice\n        // increase order:\n        //     - long: price should be smaller than acceptablePrice\n        //     - short: price should be larger than acceptablePrice\n        // decrease order:\n        //     - long: price should be larger than acceptablePrice\n        //     - short: price should be smaller than acceptablePrice\n        bool shouldPriceBeSmaller = isIncrease ? isLong : !isLong;\n\n        // for market orders, customIndexTokenPrice.min and customIndexTokenPrice.max should\n        // be equal, see setExactOrderPrice for more info\n        // for limit orders, customIndexTokenPrice contains the triggerPrice and the best oracle\n        // price, we first attempt to fulfill the order using the triggerPrice\n        uint256 price = customIndexTokenPrice.pickPrice(shouldUseMaxPrice);\n\n        // increase order:\n        //     - long: lower price for positive impact, higher price for negative impact\n        //     - short: higher price for positive impact, lower price for negative impact\n        // decrease order:\n        //     - long: higher price for positive impact, lower price for negative impact\n        //     - short: lower price for positive impact, higher price for negative impact\n        bool shouldFlipPriceImpactUsd = isIncrease ? isLong : !isLong;\n        int256 priceImpactUsdForPriceAdjustment = shouldFlipPriceImpactUsd ? -priceImpactUsd : priceImpactUsd;\n\n        if (priceImpactUsdForPriceAdjustment < 0 && (-priceImpactUsdForPriceAdjustment).toUint256() > sizeDeltaUsd) {\n            revert PriceImpactLargerThanOrderSize(priceImpactUsdForPriceAdjustment, sizeDeltaUsd);\n        }\n\n        // adjust price by price impact\n        if (sizeDeltaUsd > 0) {\n            price = price * Calc.sumReturnUint256(sizeDeltaUsd, priceImpactUsdForPriceAdjustment) / sizeDeltaUsd;\n        }\n\n        if (shouldPriceBeSmaller && price <= acceptablePrice) {\n            return price;\n        }\n\n        if (!shouldPriceBeSmaller && price >= acceptablePrice) {\n            return price;\n        }\n\n        // if the order could not be fulfilled using the triggerPrice\n        // check if the best oracle price can fulfill the order\n        price = customIndexTokenPrice.pickPrice(!shouldUseMaxPrice);\n\n        // adjust price by price impact\n        if (sizeDeltaUsd > 0) {\n            price = price * Calc.sumReturnUint256(sizeDeltaUsd, priceImpactUsdForPriceAdjustment) / sizeDeltaUsd;\n        }\n\n        if (shouldPriceBeSmaller && price <= acceptablePrice) {\n            return acceptablePrice;\n        }\n\n        if (!shouldPriceBeSmaller && price >= acceptablePrice) {\n            return acceptablePrice;\n        }\n\n        // the setExactOrderPrice function should have validated if the price fulfills\n        // the order's trigger price\n        //\n        // for decrease orders, the price impact should already be capped, so if the user\n        // had set an acceptable price within the range of the capped price impact, then\n        // the order should be fulfillable at the acceptable price\n        //\n        // for increase orders, the negative price impact is not capped\n        //\n        // for both increase and decrease orders, if it is due to price impact that the\n        // order cannot be fulfilled then the order should be frozen\n        //\n        // this is to prevent gaming by manipulation of the price impact value\n        //\n        // usually it should be costly to game the price impact value\n        // however, for certain cases, e.g. a user already has a large position opened\n        // the user may create limit orders that would only trigger after they close\n        // their position, this gives the user the option to cancel the pending order if\n        // prices do not move in their favour or to close their position and let the order\n        // execute if prices move in their favour\n        revert OrderNotFulfillableDueToPriceImpact(price, acceptablePrice);\n    }\n\n    // @dev validate that an order exists\n    // @param order the order to check\n    function validateNonEmptyOrder(Order.Props memory order) internal pure {\n        if (order.account() == address(0)) {\n            revert EmptyOrder();\n        }\n    }\n\n    // @dev throw an unsupported order type error\n    function revertUnsupportedOrderType() internal pure {\n        revert UnsupportedOrderType();\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/exchange/OrderHandler.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./BaseOrderHandler.sol\";\nimport \"../utils/ErrorUtils.sol\";\n\n// @title OrderHandler\n// @dev Contract to handle creation, execution and cancellation of orders\ncontract OrderHandler is BaseOrderHandler {\n    using SafeCast for uint256;\n    using Order for Order.Props;\n    using Array for uint256[];\n\n    error OrderNotUpdatable(Order.OrderType orderType);\n    error InvalidKeeperForFrozenOrder(address keeper);\n\n    constructor(\n        RoleStore _roleStore,\n        DataStore _dataStore,\n        EventEmitter _eventEmitter,\n        OrderVault _orderVault,\n        Oracle _oracle,\n        SwapHandler _swapHandler,\n        IReferralStorage _referralStorage\n    ) BaseOrderHandler(\n        _roleStore,\n        _dataStore,\n        _eventEmitter,\n        _orderVault,\n        _oracle,\n        _swapHandler,\n        _referralStorage\n    ) {}\n\n    // @dev creates an order in the order store\n    // @param account the order's account\n    // @param params BaseOrderUtils.CreateOrderParams\n    function createOrder(\n        address account,\n        BaseOrderUtils.CreateOrderParams calldata params\n    ) external globalNonReentrant onlyController returns (bytes32) {\n        FeatureUtils.validateFeature(dataStore, Keys.createOrderFeatureDisabledKey(address(this), uint256(params.orderType)));\n\n        return OrderUtils.createOrder(\n            dataStore,\n            eventEmitter,\n            orderVault,\n            referralStorage,\n            account,\n            params\n        );\n    }\n\n    /**\n     * @dev Updates the given order with the specified size delta, acceptable price, and trigger price.\n     * The `updateOrder()` feature must be enabled for the given order type. The caller must be the owner\n     * of the order, and the order must not be a market order. The size delta, trigger price, and\n     * acceptable price are updated on the order, and the order is unfrozen. Any additional WNT that is\n     * transferred to the contract is added to the order's execution fee. The updated order is then saved\n     * in the order store, and an `OrderUpdated` event is emitted.\n     *\n     * @param key The unique ID of the order to be updated\n     * @param sizeDeltaUsd The new size delta for the order\n     * @param acceptablePrice The new acceptable price for the order\n     * @param triggerPrice The new trigger price for the order\n     */\n    function updateOrder(\n        bytes32 key,\n        uint256 sizeDeltaUsd,\n        uint256 acceptablePrice,\n        uint256 triggerPrice,\n        uint256 minOutputAmount,\n        Order.Props memory order\n    ) external payable globalNonReentrant onlyController {\n        FeatureUtils.validateFeature(dataStore, Keys.updateOrderFeatureDisabledKey(address(this), uint256(order.orderType())));\n\n        if (BaseOrderUtils.isMarketOrder(order.orderType())) {\n            revert OrderNotUpdatable(order.orderType());\n        }\n\n        order.setSizeDeltaUsd(sizeDeltaUsd);\n        order.setTriggerPrice(triggerPrice);\n        order.setAcceptablePrice(acceptablePrice);\n        order.setMinOutputAmount(minOutputAmount);\n        order.setIsFrozen(false);\n\n        // allow topping up of executionFee as partially filled or frozen orders\n        // will have their executionFee reduced\n        address wnt = TokenUtils.wnt(dataStore);\n        uint256 receivedWnt = orderVault.recordTransferIn(wnt);\n        order.setExecutionFee(order.executionFee() + receivedWnt);\n\n        uint256 estimatedGasLimit = GasUtils.estimateExecuteOrderGasLimit(dataStore, order);\n        GasUtils.validateExecutionFee(dataStore, estimatedGasLimit, order.executionFee());\n\n        order.touch();\n        OrderStoreUtils.set(dataStore, key, order);\n\n        OrderEventUtils.emitOrderUpdated(eventEmitter, key, sizeDeltaUsd, triggerPrice, acceptablePrice);\n    }\n\n    /**\n     * @dev Cancels the given order. The `cancelOrder()` feature must be enabled for the given order\n     * type. The caller must be the owner of the order, and the order must not be a market order. The\n     * order is cancelled by calling the `cancelOrder()` function in the `OrderUtils` contract. This\n     * function also records the starting gas amount and the reason for cancellation, which is passed to\n     * the `cancelOrder()` function.\n     *\n     * @param key The unique ID of the order to be cancelled\n     */\n    function cancelOrder(bytes32 key) external globalNonReentrant onlyController {\n        uint256 startingGas = gasleft();\n\n        DataStore _dataStore = dataStore;\n        Order.Props memory order = OrderStoreUtils.get(_dataStore, key);\n\n        FeatureUtils.validateFeature(_dataStore, Keys.cancelOrderFeatureDisabledKey(address(this), uint256(order.orderType())));\n\n        if (BaseOrderUtils.isMarketOrder(order.orderType())) {\n            ExchangeUtils.validateRequestCancellation(\n                _dataStore,\n                order.updatedAtBlock(),\n                \"Order\"\n            );\n        }\n\n        OrderUtils.cancelOrder(\n            dataStore,\n            eventEmitter,\n            orderVault,\n            key,\n            order.account(),\n            startingGas,\n            Keys.USER_INITIATED_CANCEL,\n            \"\"\n        );\n    }\n\n    // @dev simulate execution of an order to check for any errors\n    // @param key the order key\n    // @param params OracleUtils.SimulatePricesParams\n    function simulateExecuteOrder(\n        bytes32 key,\n        OracleUtils.SimulatePricesParams memory params\n    ) external\n        onlyController\n        withSimulatedOraclePrices(oracle, params)\n        globalNonReentrant\n    {\n        uint256 startingGas = gasleft();\n\n        OracleUtils.SetPricesParams memory oracleParams;\n\n        this._executeOrder(\n            key,\n            oracleParams,\n            msg.sender,\n            startingGas\n        );\n    }\n\n    // @dev executes an order\n    // @param key the key of the order to execute\n    // @param oracleParams OracleUtils.SetPricesParams\n    function executeOrder(\n        bytes32 key,\n        OracleUtils.SetPricesParams calldata oracleParams\n    ) external\n        globalNonReentrant\n        onlyOrderKeeper\n        withOraclePrices(oracle, dataStore, eventEmitter, oracleParams)\n    {\n        uint256 startingGas = gasleft();\n\n        try this._executeOrder(\n            key,\n            oracleParams,\n            msg.sender,\n            startingGas\n        ) {\n        } catch (bytes memory reasonBytes) {\n            _handleOrderError(key, startingGas, reasonBytes);\n        }\n    }\n\n    // @dev executes an order\n    // @param key the key of the order to execute\n    // @param oracleParams OracleUtils.SetPricesParams\n    // @param keeper the keeper executing the order\n    // @param startingGas the starting gas\n    function _executeOrder(\n        bytes32 key,\n        OracleUtils.SetPricesParams memory oracleParams,\n        address keeper,\n        uint256 startingGas\n    ) external onlySelf {\n        BaseOrderUtils.ExecuteOrderParams memory params = _getExecuteOrderParams(key, oracleParams, keeper, startingGas);\n        // limit swaps require frozen order keeper for execution since on creation it can fail due to output amount\n        // which would automatically cause the order to be frozen\n        // limit increase and limit / trigger decrease orders may fail due to output amount as well and become frozen\n        // but only if their acceptablePrice is reached\n        if (params.order.isFrozen() || params.order.orderType() == Order.OrderType.LimitSwap) {\n            _validateFrozenOrderKeeper(keeper);\n        }\n\n        FeatureUtils.validateFeature(params.contracts.dataStore, Keys.executeOrderFeatureDisabledKey(address(this), uint256(params.order.orderType())));\n\n        OrderUtils.executeOrder(params);\n    }\n\n    // @dev handle a caught order error\n    // @param key the order's key\n    // @param startingGas the starting gas\n    // @param reason the error reason\n    // @param reasonKey the hash or the error reason\n    function _handleOrderError(\n        bytes32 key,\n        uint256 startingGas,"
    }
  ]
}