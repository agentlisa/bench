{
  "Title": "[14] Missing getter functions for key internal `ZkSyncStateTransitionStorage` variables should be introduced",
  "Content": "\n### Proof of Concept\n\nTake a look at the getter facet here: https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Getters.sol\n\nNow, consider the `ZkSyncStateTransitionStorage` struct here: https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/chain-deps/ZkSyncStateTransitionStorage.sol#L66-L153\n\nGoing through both code snippets, one can see that where as there are multiple getter functions a few are missing, to list them:\n\n1. `__DEPRECATED_diamondCutStorage`\n2. `__DEPRECATED_governor`\n3. `__DEPRECATED_pendingGovernor`\n4. `__DEPRECATED_allowList`\n5. `UpgradeStorage __DEPRECATED_upgrades`\n6. `__DEPRECATED_lastWithdrawalLimitReset`\n7. `__DEPRECATED_withdrawnAmountInWindow`\n8. `mapping(address => uint256) __DEPRECATED_totalDepositedAmountPerUser`\n9. `bool zkPorterIsAvailable`\n10. `address blobVersionedHashRetriever`\n11. `uint256 chainId`\n\nNow where as one can say it's arguable not to attache getters for the deprecated variables, we can't say that for the non-deprecated ones.\n\n### Impact\n\nUsers can't directly query important state data.\n\n### Recommended Mitigation Steps\n\nConsider adding corresponding getter functions in `Getters.sol` for the nondeprecated storage data.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/state-transition/chain-deps/ZkSyncStateTransitionStorage.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {IVerifier, VerifierParams} from \"../chain-interfaces/IVerifier.sol\";\nimport {PriorityQueue} from \"../../state-transition/libraries/PriorityQueue.sol\";\n\n/// @notice Indicates whether an upgrade is initiated and if yes what type\n/// @param None Upgrade is NOT initiated\n/// @param Transparent Fully transparent upgrade is initiated, upgrade data is publicly known\n/// @param Shadow Shadow upgrade is initiated, upgrade data is hidden\nenum UpgradeState {\n    None,\n    Transparent,\n    Shadow\n}\n\n/// @dev Logically separated part of the storage structure, which is responsible for everything related to proxy\n/// upgrades and diamond cuts\n/// @param proposedUpgradeHash The hash of the current upgrade proposal, zero if there is no active proposal\n/// @param state Indicates whether an upgrade is initiated and if yes what type\n/// @param securityCouncil Address which has the permission to approve instant upgrades (expected to be a Gnosis\n/// multisig)\n/// @param approvedBySecurityCouncil Indicates whether the security council has approved the upgrade\n/// @param proposedUpgradeTimestamp The timestamp when the upgrade was proposed, zero if there are no active proposals\n/// @param currentProposalId The serial number of proposed upgrades, increments when proposing a new one\nstruct UpgradeStorage {\n    bytes32 proposedUpgradeHash;\n    UpgradeState state;\n    address securityCouncil;\n    bool approvedBySecurityCouncil;\n    uint40 proposedUpgradeTimestamp;\n    uint40 currentProposalId;\n}\n\n/// @notice The struct that describes whether users will be charged for pubdata for L1->L2 transactions.\n/// @param Rollup The users are charged for pubdata & it is priced based on the gas price on Ethereum.\n/// @param Validium The pubdata is considered free with regard to the L1 gas price.\nenum PubdataPricingMode {\n    Rollup,\n    Validium\n}\n\n/// @notice The fee params for L1->L2 transactions for the network.\n/// @param pubdataPricingMode How the users will charged for pubdata in L1->L2 transactions.\n/// @param batchOverheadL1Gas The amount of L1 gas required to process the batch (except for the calldata).\n/// @param maxPubdataPerBatch The maximal number of pubdata that can be emitted per batch.\n/// @param priorityTxMaxPubdata The maximal amount of pubdata a priority transaction is allowed to publish.\n/// It can be slightly less than maxPubdataPerBatch in order to have some margin for the bootloader execution.\n/// @param minimalL2GasPrice The minimal L2 gas price to be used by L1->L2 transactions. It should represent\n/// the price that a single unit of compute costs.\nstruct FeeParams {\n    PubdataPricingMode pubdataPricingMode;\n    uint32 batchOverheadL1Gas;\n    uint32 maxPubdataPerBatch;\n    uint32 maxL2GasPerBatch;\n    uint32 priorityTxMaxPubdata;\n    uint64 minimalL2GasPrice;\n}\n\n/// @dev storing all storage variables for hyperchain diamond facets\n/// NOTE: It is used in a proxy, so it is possible to add new variables to the end\n/// but NOT to modify already existing variables or change their order.\n/// NOTE: variables prefixed with '__DEPRECATED_' are deprecated and shouldn't be used.\n/// Their presence is maintained for compatibility and to prevent storage collision.\nstruct ZkSyncStateTransitionStorage {\n    /// @dev Storage of variables needed for deprecated diamond cut facet\n    uint256[7] __DEPRECATED_diamondCutStorage;\n    /// @notice Address which will exercise critical changes to the Diamond Proxy (upgrades, freezing & unfreezing). Replaced by STM\n    address __DEPRECATED_governor;\n    /// @notice Address that the governor proposed as one that will replace it\n    address __DEPRECATED_pendingGovernor;\n    /// @notice List of permitted validators\n    mapping(address validatorAddress => bool isValidator) validators;\n    /// @dev Verifier contract. Used to verify aggregated proof for batches\n    IVerifier verifier;\n    /// @notice Total number of executed batches i.e. batches[totalBatchesExecuted] points at the latest executed batch\n    /// (batch 0 is genesis)\n    uint256 totalBatchesExecuted;\n    /// @notice Total number of proved batches i.e. batches[totalBatchesProved] points at the latest proved batch\n    uint256 totalBatchesVerified;\n    /// @notice Total number of committed batches i.e. batches[totalBatchesCommitted] points at the latest committed\n    /// batch\n    uint256 totalBatchesCommitted;\n    /// @dev Stored hashed StoredBatch for batch number\n    mapping(uint256 batchNumber => bytes32 batchHash) storedBatchHashes;\n    /// @dev Stored root hashes of L2 -> L1 logs\n    mapping(uint256 batchNumber => bytes32 l2LogsRootHash) l2LogsRootHashes;\n    /// @dev Container that stores transactions requested from L1\n    PriorityQueue.Queue priorityQueue;\n    /// @dev The smart contract that manages the list with permission to call contract functions\n    address __DEPRECATED_allowList;\n    /// @notice Part of the configuration parameters of ZKP circuits. Used as an input for the verifier smart contract\n    VerifierParams verifierParams;\n    /// @notice Bytecode hash of bootloader program.\n    /// @dev Used as an input to zkp-circuit.\n    bytes32 l2BootloaderBytecodeHash;\n    /// @notice Bytecode hash of default account (bytecode for EOA).\n    /// @dev Used as an input to zkp-circuit.\n    bytes32 l2DefaultAccountBytecodeHash;\n    /// @dev Indicates that the porter may be touched on L2 transactions.\n    /// @dev Used as an input to zkp-circuit.\n    bool zkPorterIsAvailable;\n    /// @dev The maximum number of the L2 gas that a user can request for L1 -> L2 transactions\n    /// @dev This is the maximum number of L2 gas that is available for the \"body\" of the transaction, i.e.\n    /// without overhead for proving the batch.\n    uint256 priorityTxMaxGasLimit;\n    /// @dev Storage of variables needed for upgrade facet\n    UpgradeStorage __DEPRECATED_upgrades;\n    /// @dev A mapping L2 batch number => message number => flag.\n    /// @dev The L2 -> L1 log is sent for every withdrawal, so this mapping is serving as\n    /// a flag to indicate that the message was already processed.\n    /// @dev Used to indicate that eth withdrawal was already processed\n    mapping(uint256 l2BatchNumber => mapping(uint256 l2ToL1MessageNumber => bool isFinalized)) isEthWithdrawalFinalized;\n    /// @dev The most recent withdrawal time and amount reset\n    uint256 __DEPRECATED_lastWithdrawalLimitReset;\n    /// @dev The accumulated withdrawn amount during the withdrawal limit window\n    uint256 __DEPRECATED_withdrawnAmountInWindow;\n    /// @dev A mapping user address => the total deposited amount by the user\n    mapping(address => uint256) __DEPRECATED_totalDepositedAmountPerUser;\n    /// @dev Stores the protocol version. Note, that the protocol version may not only encompass changes to the\n    /// smart contracts, but also to the node behavior.\n    uint256 protocolVersion;\n    /// @dev Hash of the system contract upgrade transaction. If 0, then no upgrade transaction needs to be done.\n    bytes32 l2SystemContractsUpgradeTxHash;\n    /// @dev Batch number where the upgrade transaction has happened. If 0, then no upgrade transaction has happened\n    /// yet.\n    uint256 l2SystemContractsUpgradeBatchNumber;\n    /// @dev Address which will exercise non-critical changes to the Diamond Proxy (changing validator set & unfreezing)\n    address admin;\n    /// @notice Address that the admin proposed as one that will replace admin role\n    address pendingAdmin;\n    /// @dev Fee params used to derive gasPrice for the L1->L2 transactions. For L2 transactions,\n    /// the bootloader gives enough freedom to the operator.\n    FeeParams feeParams;\n    /// @dev Address of the blob versioned hash getter smart contract used for EIP-4844 versioned hashes.\n    address blobVersionedHashRetriever;\n    /// new fields\n    /// @dev The chainId of the chain\n    uint256 chainId;\n    /// @dev The address of the bridgehub\n    address bridgehub;\n    /// @dev The address of the StateTransitionManager\n    address stateTransitionManager;\n    /// @dev The address of the baseToken contract. Eth is address(1)\n    address baseToken;\n    /// @dev The address of the baseTokenbridge. Eth also uses the shared bridge\n    address baseTokenBridge;\n    /// @notice gasPriceMultiplier for each baseToken, so that each L1->L2 transaction pays for its transaction on the destination\n    /// we multiply by the nominator, and divide by the denominator\n    uint128 baseTokenGasPriceMultiplierNominator;\n    uint128 baseTokenGasPriceMultiplierDenominator;\n}"
    }
  ]
}