{
  "Title": "[M-04] Undercollateralized loans possible",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/compound_rari_fork/Comptroller.sol#L1491\n\n\n# Vulnerability details\n\n## Impact\nThe `_setPoolCollateralFactors` function does not check that the collateral factor is < 100%.\nIt's possible that it's set to 200% and then borrows more than the collateral is worth, stealing from the pool.\n\n## Recommended Mitigation Steps\nDisable the possibility of ever having a collateral factor > 100% by checking:\n\n```diff\nfor (uint256 i = 0; i < pools.length; i++) {\n+   require(collateralFactorsMantissa[i] <= 1e18, \"CF > 100%\");\n    poolCollateralFactors[pools[i]] = collateralFactorsMantissa[i];\n}\n```\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-04-duality-focus-contest",
  "Code": [
    {
      "filename": "contracts/compound_rari_fork/Comptroller.sol",
      "content": "pragma solidity ^0.5.16;\n\nimport \"./CToken.sol\";\nimport \"./CErc20.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./Exponential.sol\";\nimport \"./PriceOracle.sol\";\nimport \"./ComptrollerInterface.sol\";\nimport \"./ComptrollerStorage.sol\";\nimport \"./Unitroller.sol\";\nimport \"./external/IUniV3LpVault.sol\";\n\n/**\n * @title Compound's Comptroller Contract\n * @author Compound\n * @dev This contract should not to be deployed alone; instead, deploy `Unitroller` (proxy contract) on top of this `Comptroller` (logic/implementation contract).\n */\ncontract Comptroller is ComptrollerV3Storage, ComptrollerInterface, ComptrollerErrorReporter, Exponential {\n    /// @notice Emitted when an admin supports a market\n    event MarketListed(CToken cToken);\n\n    /// @notice Emitted when an admin unsupports a market\n    event MarketUnlisted(CToken cToken);\n\n    /// @notice Emitted when an account enters a market\n    event MarketEntered(CToken cToken, address account);\n\n    /// @notice Emitted when an account exits a market\n    event MarketExited(CToken cToken, address account);\n\n    /// @notice Emitted when close factor is changed by admin\n    event NewCloseFactor(uint256 oldCloseFactorMantissa, uint256 newCloseFactorMantissa);\n\n    /// @notice Emitted when a collateral factor is changed by admin\n    event NewCollateralFactor(CToken cToken, uint256 oldCollateralFactorMantissa, uint256 newCollateralFactorMantissa);\n\n    /// @notice Emitted when liquidation incentive is changed by admin\n    event NewLiquidationIncentive(uint256 oldLiquidationIncentiveMantissa, uint256 newLiquidationIncentiveMantissa);\n\n    /// @notice Emitted when price oracle is changed\n    event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\n\n    /// @notice Emitted when tick oracle is changed\n    event NewTickOracle(TickOracle oldTickOracle, TickOracle newTickOracle);\n\n    /// @notice Emitted when UniV3LpVault is changed\n    event NewUniV3LpVault(IUniV3LpVault oldVault, IUniV3LpVault newVault);\n\n    /// @notice Emitted when pause guardian is changed\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n\n    /// @notice Emitted when an action is paused globally\n    event ActionPaused(string action, bool pauseState);\n\n    /// @notice Emitted when an action is paused on a market\n    event ActionPausedMarket(CToken cToken, string action, bool pauseState);\n\n    /// @notice Emitted when supply cap for a cToken is changed\n    event NewSupplyCap(CToken indexed cToken, uint256 newSupplyCap);\n\n    /// @notice Emitted when borrow cap for a cToken is changed\n    event NewBorrowCap(CToken indexed cToken, uint256 newBorrowCap);\n\n    /// @notice Emitted when borrow cap guardian is changed\n    event NewBorrowCapGuardian(address oldBorrowCapGuardian, address newBorrowCapGuardian);\n     // closeFactorMantissa must be strictly greater than this value\n    uint256 internal constant closeFactorMinMantissa = 0.05e18; // 0.05\n\n    // closeFactorMantissa must not exceed this value\n    uint256 internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\n\n    // No collateralFactorMantissa may exceed this value\n    uint256 internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\n\n    // liquidationIncentiveMantissa must be no less than this value\n    uint256 internal constant liquidationIncentiveMinMantissa = 1.0e18; // 1.0\n\n    // liquidationIncentiveMantissa must be no greater than this value\n    uint256 internal constant liquidationIncentiveMaxMantissa = 1.5e18; // 1.5\n\n    constructor (address _admin) public {\n        admin = _admin;\n        _notEntered = true;\n        _notEnteredInitialized = true;    \n    }\n\n    /*** Assets You Are In ***/\n\n    /**\n     * @notice Returns the assets an account has entered\n     * @param account The address of the account to pull assets for\n     * @return A dynamic list with the assets the account has entered\n     */\n    function getAssetsIn(address account) external view returns (CToken[] memory) {\n        CToken[] memory assetsIn = accountAssets[account];\n\n        return assetsIn;\n    }\n\n    /**\n     * @notice Returns whether the given account is entered in the given asset\n     * @param account The address of the account to check\n     * @param cToken The cToken to check\n     * @return True if the account is in the asset, otherwise false.\n     */\n    function checkMembership(address account, CToken cToken) external view returns (bool) {\n        return markets[address(cToken)].accountMembership[account];\n    }\n\n    /**\n     * @notice Add assets to be included in account liquidity calculation\n     * @param cTokens The list of addresses of the cToken markets to be enabled\n     * @return Success indicator for whether each corresponding market was entered\n     */\n    function enterMarkets(address[] memory cTokens) public returns (uint256[] memory) {\n        uint256 len = cTokens.length;\n\n        uint256[] memory results = new uint256[](len);\n        for (uint256 i = 0; i < len; i++) {\n            CToken cToken = CToken(cTokens[i]);\n\n            results[i] = uint256(addToMarketInternal(cToken, msg.sender));\n        }\n\n        return results;\n    }\n\n    /**\n     * @notice Add the market to the borrower's \"assets in\" for liquidity calculations\n     * @param cToken The market to enter\n     * @param borrower The address of the account to modify\n     * @return Success indicator for whether the market was entered\n     */\n    function addToMarketInternal(CToken cToken, address borrower) internal returns (Error) {\n        Market storage marketToJoin = markets[address(cToken)];\n\n        if (!marketToJoin.isListed) {\n            // market is not listed, cannot join\n            return Error.MARKET_NOT_LISTED;\n        }\n\n        if (marketToJoin.accountMembership[borrower] == true) {\n            // already joined\n            return Error.NO_ERROR;\n        }\n\n        // survived the gauntlet, add to list\n        // NOTE: we store these somewhat redundantly as a significant optimization\n        //  this avoids having to iterate through the list for the most common use cases\n        //  that is, only when we need to perform liquidity checks\n        //  and not whenever we want to check if an account is in a particular market\n        marketToJoin.accountMembership[borrower] = true;\n        accountAssets[borrower].push(cToken);\n\n        // Add to allBorrowers\n        if (!borrowers[borrower]) {\n            allBorrowers.push(borrower);\n            borrowers[borrower] = true;\n            borrowerIndexes[borrower] = allBorrowers.length - 1;\n        }\n\n        emit MarketEntered(cToken, borrower);\n\n        return Error.NO_ERROR;\n    }\n\n    /**\n     * @notice Removes asset from sender's account liquidity calculation\n     * @dev Sender must not have an outstanding borrow balance in the asset,\n     *  or be providing neccessary collateral for an outstanding borrow.\n     * @param cTokenAddress The address of the asset to be removed\n     * @return Whether or not the account successfully exited the market\n     */\n    function exitMarket(address cTokenAddress) external returns (uint256) {\n        CToken cToken = CToken(cTokenAddress);\n        /* Get sender tokensHeld and amountOwed underlying from the cToken */\n        (uint256 oErr, uint256 tokensHeld, uint256 amountOwed, ) = cToken.getAccountSnapshot(msg.sender);\n        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n\n        /* Fail if the sender has a borrow balance */\n        if (amountOwed != 0) {\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n        }\n\n        /* Fail if the sender is not permitted to redeem all of their tokens */\n        uint256 allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);\n        if (allowed != 0) {\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n        }\n\n        Market storage marketToExit = markets[address(cToken)];\n\n        /* Return true if the sender is not already ‘in’ the market */\n        if (!marketToExit.accountMembership[msg.sender]) {\n            return uint256(Error.NO_ERROR);\n        }\n\n        /* Set cToken account membership to false */\n        delete marketToExit.accountMembership[msg.sender];\n\n        /* Delete cToken from the account’s list of assets */\n        // load into memory for faster iteration\n        CToken[] memory userAssetList = accountAssets[msg.sender];\n        uint256 len = userAssetList.length;\n        uint256 assetIndex = len;\n        for (uint256 i = 0; i < len; i++) {\n            if (userAssetList[i] == cToken) {\n                assetIndex = i;\n                break;\n            }\n        }\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n        assert(assetIndex < len);\n\n        // copy last item in list to location of item to be removed, reduce length by 1\n        CToken[] storage storedList = accountAssets[msg.sender];\n        storedList[assetIndex] = storedList[storedList.length - 1];\n        storedList.length--;\n\n        // If the user has exited all markets, remove them from the `allBorrowers` array\n        if (storedList.length == 0) {\n            allBorrowers[borrowerIndexes[msg.sender]] = allBorrowers[allBorrowers.length - 1]; // Copy last item in list to location of item to be removed\n            allBorrowers.length--; // Reduce length by 1\n            borrowerIndexes[allBorrowers[borrowerIndexes[msg.sender]]] = borrowerIndexes[msg.sender]; // Set borrower index of moved item to correct index\n            borrowerIndexes[msg.sender] = 0; // Reset sender borrower index to 0 for a gas refund\n            borrowers[msg.sender] = false; // Tell the contract that the sender is no longer a borrower (so it knows to add the borrower back if they enter a market in the future)\n        }\n\n        emit MarketExited(cToken, msg.sender);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /*** Policy Hooks ***/\n\n    /**\n     * @notice Checks if the account should be allowed to mint tokens in the given market\n     * @param cToken The market to verify the mint against\n     * @param minter The account which would get the minted tokens\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function mintAllowed(\n        address cToken,\n        address minter,\n        uint256 mintAmount\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!mintGuardianPaused[cToken], \"mint is paused\");\n\n        // Shh - currently unused\n        minter;\n        mintAmount;\n\n        // Make sure market is listed\n        if (!markets[cToken].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        // deposits are automatically treated as collateral\n        if (!markets[cToken].accountMembership[minter]) {\n            // only cTokens may call mintAllowed if minter not in market\n            require(msg.sender == cToken, \"sender must be cToken\");\n\n            // attempt to add minter to the market\n            Error err = addToMarketInternal(CToken(msg.sender), minter);\n            if (err != Error.NO_ERROR) {\n                return uint256(err);\n            }\n\n            // it should be impossible to break the important invariant\n            assert(markets[cToken].accountMembership[minter]);\n        }\n\n        // Check supply cap\n        uint256 supplyCap = supplyCaps[cToken];\n        // Supply cap of 0 corresponds to unlimited supplying\n        if (supplyCap != 0) {\n            uint256 totalCash = CToken(cToken).getCash();\n            uint256 totalBorrows = CToken(cToken).totalBorrows();\n            uint256 totalReserves = CToken(cToken).totalReserves();\n\n            // totalUnderlyingSupply = totalCash + totalBorrows - (totalReserves)\n            (MathError mathErr, uint256 totalUnderlyingSupply) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) return uint256(Error.MATH_ERROR);\n\n            uint256 nextTotalUnderlyingSupply;\n            (mathErr, nextTotalUnderlyingSupply) = addUInt(totalUnderlyingSupply, mintAmount);\n            if (mathErr != MathError.NO_ERROR) return uint256(Error.MATH_ERROR);\n\n            require(nextTotalUnderlyingSupply < supplyCap, \"market supply cap reached\");\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\n     * @param cToken The market to verify the redeem against\n     * @param redeemer The account which would redeem the tokens\n     * @param redeemTokens The number of cTokens to exchange for the underlying asset in the market\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function redeemAllowed(\n        address cToken,\n        address redeemer,\n        uint256 redeemTokens\n    ) external returns (uint256) {\n        uint256 allowed = redeemAllowedInternal(cToken, redeemer, redeemTokens);\n        if (allowed != uint256(Error.NO_ERROR)) {\n            return allowed;\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function redeemAllowedInternal(\n        address cToken,\n        address redeemer,\n        uint256 redeemTokens\n    ) internal view returns (uint256) {\n        if (!markets[cToken].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\n        if (!markets[cToken].accountMembership[redeemer]) {\n            return uint256(Error.NO_ERROR);\n        }\n\n        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\n        (Error err, , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            redeemer,\n            CToken(cToken),\n            redeemTokens,\n            0\n        );\n        if (err != Error.NO_ERROR) {\n            return uint256(err);\n        }\n        if (shortfall > 0) {\n            return uint256(Error.INSUFFICIENT_LIQUIDITY);\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates redeem and reverts on rejection. May emit logs.\n     * @param cToken Asset being redeemed\n     * @param redeemer The address redeeming the tokens\n     * @param redeemAmount The amount of the underlying asset being redeemed\n     * @param redeemTokens The number of tokens being redeemed\n     */\n    function redeemVerify(\n        address cToken,\n        address redeemer,\n        uint256 redeemAmount,\n        uint256 redeemTokens\n    ) external {\n        // Shh - currently unused\n        cToken;\n        redeemer;\n\n        // Require tokens is zero or amount is also zero\n        if (redeemTokens == 0 && redeemAmount > 0) {\n            revert(\"redeemTokens zero\");\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n     * @param cToken The market to verify the borrow against\n     * @param borrower The account which would borrow the asset\n     * @param borrowAmount The amount of underlying the account would borrow\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function borrowAllowed(\n        address cToken,\n        address borrower,\n        uint256 borrowAmount\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!borrowGuardianPaused[cToken], \"borrow is paused\");\n\n        // Make sure market is listed\n        if (!markets[cToken].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        if (!markets[cToken].accountMembership[borrower]) {\n            // only cTokens may call borrowAllowed if borrower not in market\n            require(msg.sender == cToken, \"sender must be cToken\");\n\n            // attempt to add borrower to the market\n            Error err = addToMarketInternal(CToken(msg.sender), borrower);\n            if (err != Error.NO_ERROR) {\n                return uint256(err);\n            }\n\n            // it should be impossible to break the important invariant\n            assert(markets[cToken].accountMembership[borrower]);\n        }\n\n        // Make sure oracle price is available\n        if (oracle.getUnderlyingPrice(CToken(cToken)) == 0) {\n            return uint256(Error.PRICE_ERROR);\n        }\n\n        // Check borrow cap\n        uint256 borrowCap = borrowCaps[cToken];\n        // Borrow cap of 0 corresponds to unlimited borrowing\n        if (borrowCap != 0) {\n            uint256 totalBorrows = CToken(cToken).totalBorrows();\n            (MathError mathErr, uint256 nextTotalBorrows) = addUInt(totalBorrows, borrowAmount);\n            if (mathErr != MathError.NO_ERROR) return uint256(Error.MATH_ERROR);\n            require(nextTotalBorrows < borrowCap, \"market borrow cap reached\");\n        }\n\n        // Perform a hypothetical liquidity check to guard against shortfall\n        (Error err, , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            borrower,\n            CToken(cToken),\n            0,\n            borrowAmount\n        );\n        if (err != Error.NO_ERROR) {\n            return uint256(err);\n        }\n        if (shortfall > 0) {\n            return uint256(Error.INSUFFICIENT_LIQUIDITY);\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\n     * @param cToken The market to verify the repay against\n     * @param payer The account which would repay the asset\n     * @param borrower The account which would borrowed the asset\n     * @param repayAmount The amount of the underlying asset the account would repay\n     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function repayBorrowAllowed(\n        address cToken,\n        address payer,\n        address borrower,\n        uint256 repayAmount\n    ) external returns (uint256) {\n        // Shh - currently unused\n        payer;\n        borrower;\n        repayAmount;\n\n        // Make sure market is listed\n        if (!markets[cToken].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the liquidation should be allowed to occur\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param repayAmount The amount of underlying being repaid\n     */\n    function liquidateBorrowAllowed(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount\n    ) external returns (uint256) {\n        // Shh - currently unused\n        liquidator;\n\n        // Make sure markets are listed\n        if (!markets[cTokenBorrowed].isListed || !markets[cTokenCollateral].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        // Get borrowers's underlying borrow balance\n        uint256 borrowBalance = CToken(cTokenBorrowed).borrowBalanceStored(borrower);\n\n        /* allow accounts to be liquidated if the market is deprecated */\n        if (isDeprecated(CToken(cTokenBorrowed))) {\n            require(borrowBalance >= repayAmount, \"Can not repay more than the total borrow\");\n        } else {\n            /* The borrower must have shortfall in order to be liquidatable */\n            (Error err, , uint256 shortfall) = getAccountLiquidityInternal(borrower);\n            if (err != Error.NO_ERROR) {\n                return uint256(err);\n            }\n\n            if (shortfall == 0) {\n                return uint256(Error.INSUFFICIENT_SHORTFALL);\n            }\n\n            /* The liquidator may not repay more than what is allowed by the closeFactor */\n            uint256 maxClose = mul_ScalarTruncate(Exp({ mantissa: closeFactorMantissa }), borrowBalance);\n            if (repayAmount > maxClose) {\n                return uint256(Error.TOO_MUCH_REPAY);\n            }\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the liquidation should be allowed to occur\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param collateralTokenId the tokenId of the Uni V3 NFT being used as collateral\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param repayAmount The amount of underlying being repaid\n     */\n    function liquidateBorrowUniV3Allowed(\n        address cTokenBorrowed,\n        uint256 collateralTokenId,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount\n    ) external returns (uint256) {\n        // Shh - currently unused\n        collateralTokenId;\n        liquidator;\n\n        if (!markets[cTokenBorrowed].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        if (uniV3LpVault.ownerOf(collateralTokenId) != borrower) {\n            return uint256(Error.TOKEN_ID_BORROWER_MISMATCH);\n        }\n\n        uint256 borrowBalance = CToken(cTokenBorrowed).borrowBalanceStored(borrower);\n\n        /* allow accounts to be liquidated if the market is deprecated */\n        if (isDeprecated(CToken(cTokenBorrowed))) {\n            require(borrowBalance >= repayAmount, \"Can not repay more than the total borrow\");\n        } else {\n            /* The borrower must have shortfall in order to be liquidatable */\n            (Error err, , uint256 shortfall) = getAccountLiquidityInternal(borrower);\n            if (err != Error.NO_ERROR) {\n                return uint256(err);\n            }\n\n            if (shortfall == 0) {\n                return uint256(Error.INSUFFICIENT_SHORTFALL);\n            }\n\n            /* The liquidator may not repay more than what is allowed by the closeFactor */\n            uint256 maxClose = mul_ScalarTruncate(Exp({ mantissa: closeFactorMantissa }), borrowBalance);\n            if (repayAmount > maxClose) {\n                return uint256(Error.TOO_MUCH_REPAY);\n            }\n        }\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the seizing of assets should be allowed to occur\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n    function seizeAllowed(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!seizeGuardianPaused, \"seize is paused\");\n\n        // Shh - currently unused\n        liquidator;\n        borrower;\n        seizeTokens;\n\n        // Make sure markets are listed\n        if (!markets[cTokenCollateral].isListed || !markets[cTokenBorrowed].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        // Make sure cToken Comptrollers are identical\n        if (CToken(cTokenCollateral).comptroller() != CToken(cTokenBorrowed).comptroller()) {\n            return uint256(Error.COMPTROLLER_MISMATCH);\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * new seize function for Uni V3 vault\n     */\n    function seizeAllowedUniV3(\n        address lpVault,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 tokenId,\n        uint256 seizeFeesToken0,\n        uint256 seizeFeesToken1,\n        uint256 seizeLiquidity\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!seizeGuardianPaused, \"seize is paused\");\n\n        // Shh - currently unused\n        tokenId;\n        seizeFeesToken0;\n        seizeFeesToken1;\n        seizeLiquidity;\n\n        // check that the borrow token is listed in comptroller market\n        if (!markets[cTokenBorrowed].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        // check that lpVault matches our LPVault\n        if (lpVault != address(uniV3LpVault)) {\n            return uint256(Error.LP_VAULT_MISMATCH);\n        }\n\n        // check that lpVault comptroller matches this comptroller\n        if (uniV3LpVault.comptroller() != CToken(cTokenBorrowed).comptroller()) {\n            return uint256(Error.COMPTROLLER_MISMATCH);\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\n     * @param cToken The market to verify the transfer against\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of cTokens to transfer\n     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function transferAllowed(\n        address cToken,\n        address src,\n        address dst,\n        uint256 transferTokens\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!transferGuardianPaused, \"transfer is paused\");\n\n        // Currently the only consideration is whether or not\n        //  the src is allowed to redeem this many tokens\n        uint256 allowed = redeemAllowedInternal(cToken, src, transferTokens);\n        if (allowed != uint256(Error.NO_ERROR)) {\n            return allowed;\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /*** Liquidity/Liquidation Calculations ***/\n\n    /**\n     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\n     *  Note that `cTokenBalance` is the number of cTokens the account owns in the market,\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\n     */\n    struct AccountLiquidityLocalVars {\n        uint256 sumCollateral;\n        uint256 sumBorrowPlusEffects;\n        uint256 cTokenBalance;\n        uint256 borrowBalance;\n        uint256 exchangeRateMantissa;\n        uint256 oraclePriceMantissa;\n        Exp collateralFactor;\n        Exp exchangeRate;\n        Exp oraclePrice;\n        Exp tokensToDenom;\n    }\n\n    /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code (semi-opaque),\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n    function getAccountLiquidity(address account)\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        (Error err, uint256 liquidity, uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            account,\n            CToken(0),\n            0,\n            0\n        );\n\n        return (uint256(err), liquidity, shortfall);\n    }\n\n    /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code,\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n    function getAccountLiquidityInternal(address account)\n        internal\n        view\n        returns (\n            Error,\n            uint256,\n            uint256\n        )\n    {\n        return getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);\n    }\n\n    /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @return (possible error code (semi-opaque),\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n    function getHypotheticalAccountLiquidity(\n        address account,\n        address cTokenModify,\n        uint256 redeemTokens,\n        uint256 borrowAmount\n    )\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        (Error err, uint256 liquidity, uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            account,\n            CToken(cTokenModify),\n            redeemTokens,\n            borrowAmount\n        );\n        return (uint256(err), liquidity, shortfall);\n    }\n\n    function addNFTCollateral(address account, AccountLiquidityLocalVars memory vars) internal view {\n        uint256 userTokensLength = uniV3LpVault.getUserTokensLength(account);\n        for (uint256 i = 0; i < userTokensLength; i++) {\n            uint256 tokenId = uniV3LpVault.userTokens(account, i);\n            (\n                address token0,\n                address token1,\n                uint256 amountToken0Fees,\n                uint256 amountToken1Fees,\n                uint256 amountToken0Liquidity,\n                uint256 amountToken1Liquidity,\n\n            ) = tickOracle.getTokenBreakdownTWAP(tokenId);\n            CToken asset0 = cTokensByUnderlying[token0];\n            CToken asset1 = cTokensByUnderlying[token1];\n\n            {\n                // avoid stack too deep\n                address poolAddress = uniV3LpVault.getPoolAddress(tokenId);\n                uint256 collateralFactorMantissa = poolCollateralFactors[poolAddress];\n\n                vars.collateralFactor = Exp({ mantissa: collateralFactorMantissa });\n            }\n\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset0);\n            vars.oraclePrice = Exp({ mantissa: vars.oraclePriceMantissa });\n            vars.tokensToDenom = mul_(vars.collateralFactor, vars.oraclePrice);\n\n            vars.sumCollateral = mul_ScalarTruncateAddUInt(\n                vars.tokensToDenom,\n                add_(amountToken0Fees, amountToken0Liquidity),\n                vars.sumCollateral\n            );\n\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset1);\n            vars.oraclePrice = Exp({ mantissa: vars.oraclePriceMantissa });\n            vars.tokensToDenom = mul_(vars.collateralFactor, vars.oraclePrice);\n\n            vars.sumCollateral = mul_ScalarTruncateAddUInt(\n                vars.tokensToDenom,\n                add_(amountToken1Fees, amountToken1Liquidity),\n                vars.sumCollateral\n            );\n        }\n    }\n\n    /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @dev Note that we calculate the exchangeRateStored for each collateral cToken using stored data,\n     *  without calculating accumulated interest.\n     * @return (possible error code,\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n    function getHypotheticalAccountLiquidityInternal(\n        address account,\n        CToken cTokenModify,\n        uint256 redeemTokens,\n        uint256 borrowAmount\n    )\n        internal\n        view\n        returns (\n            Error,\n            uint256,\n            uint256\n        )\n    {\n        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\n        uint256 oErr;\n\n        // add all Uni V3 LP Collateral value\n        addNFTCollateral(account, vars);\n\n        // For each asset the account is in\n        CToken[] memory assets = accountAs"
    }
  ]
}