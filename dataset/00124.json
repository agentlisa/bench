{
  "Title": "Miscellaneous NatSpec and inline comment errors",
  "Content": "The following NatSpec errors were identified:\n- [`UnripeFacet::balanceOfPenalizedUnderlying`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/beanstalk/barn/UnripeFacet.sol#L208-L214) NatSpec is incorrectly copied from [`UnripeFacet::balanceOfUnderlying`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/beanstalk/barn/UnripeFacet.sol#L194-L201) and should be modified for this particular function.\n- The NatSpec of [`LibWell::getTwaReservesForWell`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/libraries/Well/LibWell.sol#L189) is incorrect. It states that this function returns the `USD / TKN` price stored in `{AppStorage.usdTokenPrice}`; however, this is actually the `TKN / USD` price and should be updated accordingly.\n- A [comment](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/beanstalk/sun/SeasonFacet/Weather.sol#L90) explaining the implementation of`Weather::updateTemperature` incorrectly references `uint32(-change)` where it should instead be `uint256(-change)`.\n- A [comment](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/libraries/LibCases.sol#L55) in `LibCases` explaining the behavior of the constants incorrectly states `Bean2maxLpGpPerBdv set to 10% of current value` when it should be 50% of the current value.\n- A [comment](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/beanstalk/init/InitBipNewSilo.sol#L77) in `InitBipNewSilo` has been changed to state the `stemStartSeason` is stored as a `uint32` when it is actually `uint16`.\n- The NatSpec for the [`int8[32] cases`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/beanstalk/AppStorage.sol#L456) member of `AppStorage` is outdated and along with the [member itself](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/beanstalk/AppStorage.sol#L507) should be marked as deprecated in favor of `bytes32[144] casesV2`.\n- There is a slight error in the case of [`TwaReserves`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/beanstalk/AppStorage.sol#L499) in the NatSpec of `AppStorage` which should instead be `twaReserves`.\n- [`deprecated_beanEthPrice`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/beanstalk/AppStorage.sol#L564) does not currently exist in the NatSpec of `AppStorage`. It should be added along with an explanation of why this member is deprecated.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/beanstalk/barn/UnripeFacet.sol",
      "content": "/*\n * SPDX-License-Identifier: MIT\n */\n\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {MerkleProof} from \"@openzeppelin/contracts/cryptography/MerkleProof.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IBean} from \"contracts/interfaces/IBean.sol\";\nimport {LibDiamond} from \"contracts/libraries/LibDiamond.sol\";\nimport {LibUnripe} from \"contracts/libraries/LibUnripe.sol\";\nimport {LibTransfer} from \"contracts/libraries/Token/LibTransfer.sol\";\nimport {LibWell} from \"contracts/libraries/Well/LibWell.sol\";\nimport {C} from \"contracts/C.sol\";\nimport {ReentrancyGuard} from \"contracts/beanstalk/ReentrancyGuard.sol\";\nimport {LibLockedUnderlying} from \"contracts/libraries/LibLockedUnderlying.sol\";\nimport {LibChop} from \"contracts/libraries/LibChop.sol\";\n\n/**\n * @title UnripeFacet\n * @author ZrowGz, Publius, deadmanwalking\n * @notice Handles functionality related to Unripe Tokens including Chopping, Picking,\n * managing Unripe Tokens. Also, contains view functions to fetch Unripe Token data.\n */\n\ncontract UnripeFacet is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using LibTransfer for IERC20;\n    using SafeMath for uint256;\n\n    /**\n     * @notice Emitted when a new unripe token is added to Beanstalk.\n     */\n    event AddUnripeToken(\n        address indexed unripeToken,\n        address indexed underlyingToken,\n        bytes32 merkleRoot\n    );\n\n    /**\n     * @notice Emitted when the Ripe Token of an Unripe Token increases or decreases.\n     * @param token The token of which the Underlying changes.\n     * @param underlying `amount` that has changed.\n     */\n    event ChangeUnderlying(address indexed token, int256 underlying);\n\n    /**\n     * @notice Emitted when the Ripe Token of an unripe asset changes.\n     * @param token The Unripe Token to change the Ripe Token of.\n     * @param underlyingToken The new Ripe Token.\n     */\n    event SwitchUnderlyingToken(address indexed token, address indexed underlyingToken);\n\n    /**\n     * @notice emitted when a Farmer Chops.\n     */\n    event Chop(address indexed account, address indexed token, uint256 amount, uint256 underlying);\n\n    /**\n     * @notice emitted when a user `picks`.\n     * @dev `picking` is claiming non-Deposited Unripe Tokens.\n     */\n    event Pick(address indexed account, address indexed token, uint256 amount);\n\n    /**\n     * @notice Chops an unripe asset into its ripe counterpart according to the recapitalization %\n     * @param unripeToken The address of the unripe token to be chopped into its ripe counterpart\n     * @param amount The amount of the of the unripe token to be chopped into its ripe counterpart\n     * @param fromMode Enum value to distinguish the type of account used to charge the funds before chopping.\n     * @param toMode Enum value to distinguish the type of account used to credit the funds after chopping.\n     * fromMode can be EXTERNAL,INTERNAL, EXTERNAL_INTERNAL,INTERNAL_TOLERANT.\n     * toMode can be EXTERNAL or INTERNAL.\n     * @return underlyingAmount the amount of ripe tokens received after the chop\n     */\n    function chop(\n        address unripeToken,\n        uint256 amount,\n        LibTransfer.From fromMode,\n        LibTransfer.To toMode\n    ) external payable nonReentrant returns (uint256) {\n        // burn the token from the msg.sender address\n        uint256 supply = IBean(unripeToken).totalSupply();\n        amount = LibTransfer.burnToken(IBean(unripeToken), amount, msg.sender, fromMode);\n        // get ripe address and ripe amount\n        (address underlyingToken, uint256 underlyingAmount) = LibChop.chop(\n            unripeToken,\n            amount,\n            supply\n        );\n        // send the corresponding amount of ripe token to the user address\n        require(underlyingAmount > 0, \"Chop: no underlying\");\n        IERC20(underlyingToken).sendToken(underlyingAmount, msg.sender, toMode);\n        // emit the event\n        emit Chop(msg.sender, unripeToken, amount, underlyingAmount);\n        return underlyingAmount;\n    }\n\n    /**\n     * @notice Picks a Farmer's Pickable Unripe Tokens.\n     * @dev Pickable Unripe Tokens were distributed to all non-Deposited pre-exploit Bean and Bean LP Tokens.\n     * @param token The Unripe Token address to Pick.\n     * @param amount The amount of Unripe Tokens to Pick.\n     * @param proof The merkle proof used to validate that the Pick is valid.\n     * @param mode The destination balance that the Unripe Tokens are sent to.\n     */\n    function pick(\n        address token,\n        uint256 amount,\n        bytes32[] memory proof,\n        LibTransfer.To mode\n    ) external payable nonReentrant {\n        bytes32 root = s.u[token].merkleRoot;\n        require(root != bytes32(0), \"UnripeClaim: invalid token\");\n        require(!picked(msg.sender, token), \"UnripeClaim: already picked\");\n\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, amount));\n        require(MerkleProof.verify(proof, root, leaf), \"UnripeClaim: invalid proof\");\n        s.unripeClaimed[token][msg.sender] = true;\n\n        LibTransfer.sendToken(IERC20(token), amount, msg.sender, mode);\n\n        emit Pick(msg.sender, token, amount);\n    }\n\n    /**\n     * @notice Returns whether a given `account` has picked a given `token`.\n     * @param account The address of the account to check.\n     * @param token The address of the Unripe Token to check.\n     */\n    function picked(address account, address token) public view returns (bool) {\n        return s.unripeClaimed[token][account];\n    }\n\n    /**\n     * @notice Returns the amount of Ripe Tokens that underly a given amount of Unripe Tokens.\n     * @dev Does NOT include the penalty associated with the percent of Sprouts that are Rinsable\n     * or Rinsed.\n     * @param unripeToken The address of the Unripe Token.\n     * @param amount The amount of the Unripe Token.\n     * @return underlyingAmount The amount of Ripe Tokens that underly the given amount of\n     * Unripe Tokens.\n     */\n    function getUnderlying(\n        address unripeToken,\n        uint256 amount\n    ) public view returns (uint256 underlyingAmount) {\n        return LibUnripe.unripeToUnderlying(unripeToken, amount, IBean(unripeToken).totalSupply());\n    }\n\n    /**\n     * @notice Getter function to get the corresponding penalty associated with an unripe asset.\n     * @param unripeToken The address of the unripe token.\n     * @return penalty The current penalty for converting unripe --> ripe\n     */\n    function getPenalty(address unripeToken) external view returns (uint256 penalty) {\n        return getPenalizedUnderlying(unripeToken, LibUnripe.DECIMALS);\n    }\n\n    /**\n     * @notice Getter function to get the corresponding amount\n     * of ripe tokens from a set amount of unripe tokens according to current state.\n     * @param unripeToken The address of the unripe token.\n     * @param amount The amount of the unripe token.\n     * @return redeem The amount of the corresponding ripe tokens\n     */\n    function getPenalizedUnderlying(\n        address unripeToken,\n        uint256 amount\n    ) public view returns (uint256 redeem) {\n        return\n            LibChop._getPenalizedUnderlying(unripeToken, amount, IBean(unripeToken).totalSupply());\n    }\n\n    function _getPenalizedUnderlying(\n        address unripeToken,\n        uint256 amount,\n        uint256 supply\n    ) public view returns (uint256 redeem) {\n        return LibUnripe._getPenalizedUnderlying(unripeToken, amount, supply);\n    }\n\n    /**\n     * @notice Returns whether a token is an Unripe Token.\n     * @param unripeToken The token address to check.\n     * @return unripe Whether the token is Unripe or not.\n     */\n    function isUnripe(address unripeToken) external view returns (bool unripe) {\n        unripe = LibChop.isUnripe(unripeToken);\n    }\n\n    /**\n     * @notice Returns the amount of Ripe Tokens that underly a Farmer's balance of Unripe\n     * Tokens.\n     * @param unripeToken The address of the Unripe Token.\n     * @param account The address of the Farmer to check.\n     * @return underlying The amount of Ripe Tokens that underly the Farmer's balance.\n     */\n    function balanceOfUnderlying(\n        address unripeToken,\n        address account\n    ) external view returns (uint256 underlying) {\n        return getUnderlying(unripeToken, IERC20(unripeToken).balanceOf(account));\n    }\n\n    /**\n     * @notice Returns the amount of Ripe Tokens that underly a Farmer's balance of Unripe\n     * @param unripeToken The address of the unripe token.\n     * @param account The address of the account to check.\n     * @return underlying The theoretical amount of the ripe asset in the account.\n     */\n    function balanceOfPenalizedUnderlying(\n        address unripeToken,\n        address account\n    ) external view returns (uint256 underlying) {\n        return getPenalizedUnderlying(unripeToken, IERC20(unripeToken).balanceOf(account));\n    }\n\n    /**\n     * @notice Returns the % of Ripe Tokens that have been recapiatlized for a given Unripe Token.\n     * @param unripeToken The address of the Unripe Token.\n     * @return percent The recap % of the token.\n     */\n    function getRecapFundedPercent(address unripeToken) public view returns (uint256 percent) {\n        if (unripeToken == C.UNRIPE_BEAN) {\n            return LibUnripe.percentBeansRecapped();\n        } else if (unripeToken == C.UNRIPE_LP) {\n            return LibUnripe.percentLPRecapped();\n        }\n        revert(\"not vesting\");\n    }\n\n    /**\n     * @notice Returns the % penalty of Chopping an Unripe Token into its Ripe Token.\n     * @param unripeToken The address of the Unripe Token.\n     * @return penalty The penalty % of Chopping.\n     */\n    function getPercentPenalty(address unripeToken) external view returns (uint256 penalty) {\n        return LibUnripe.getRecapPaidPercentAmount(getRecapFundedPercent(unripeToken));\n    }\n\n    /**\n     * @notice Returns % of Sprouts that are Rinsable or Rinsed.\n     * @return percent The % stemming from the recap.\n     */\n    function getRecapPaidPercent() external view returns (uint256 percent) {\n        percent = LibUnripe.getRecapPaidPercentAmount(LibUnripe.DECIMALS);\n    }\n\n    /**\n     * @notice Returns the amount of Ripe Tokens that underly a single Unripe Token.\n     * @dev has 6 decimals of precision.\n     * @param unripeToken The address of the unripe token.\n     * @return underlyingPerToken The underlying ripe token per unripe token. \n     */\n    function getUnderlyingPerUnripeToken(address unripeToken)\n        external\n        view\n        returns (uint256 underlyingPerToken)\n    {\n        underlyingPerToken = s\n            .u[unripeToken]\n            .balanceOfUnderlying\n            .mul(LibUnripe.DECIMALS)\n            .div(IERC20(unripeToken).totalSupply());\n    }\n\n    /**\n     * @notice Returns the total amount of Ripe Tokens for a given Unripe Token.\n     * @param unripeToken The address of the unripe token.\n     * @return underlying The total balance of the token. \n     */\n    function getTotalUnderlying(address unripeToken)\n        external\n        view\n        returns (uint256 underlying)\n    {\n        return s.u[unripeToken].balanceOfUnderlying;\n    }\n\n\n    /**\n     * @notice Adds an Unripe Token to Beanstalk.\n     * @param unripeToken The address of the Unripe Token to be added.\n     * @param underlyingToken The address of the Ripe Token.\n     * @param root The merkle root, which is used to verify claims.\n     */\n    function addUnripeToken(\n        address unripeToken,\n        address underlyingToken,\n        bytes32 root\n    ) external payable nonReentrant {\n        LibDiamond.enforceIsOwnerOrContract();\n        s.u[unripeToken].underlyingToken = underlyingToken;\n        s.u[unripeToken].merkleRoot = root;\n        emit AddUnripeToken(unripeToken, underlyingToken, root);\n    }\n\n    /**\n     * @notice Returns the Ripe Token of an Unripe Token.\n     * @param unripeToken The address of the Unripe Token.\n     * @return underlyingToken The address of the Ripe Token.\n     */\n    function getUnderlyingToken(address unripeToken)\n        external\n        view\n        returns (address underlyingToken)\n    {\n        return s.u[unripeToken].underlyingToken;\n    }\n\n    /////////////// UNDERLYING TOKEN MIGRATION //////////////////\n\n    /**\n     * @notice Adds Ripe Tokens to an Unripe Token. Used when changing the Ripe Token.\n     * @param unripeToken The Unripe Token to add Underlying tokens to.\n     * @param amount The amount of Ripe Tokens to add.\n     * @dev Used to migrate the Ripe Token of an Unripe Token to a new token.\n     * Only callable by the contract owner.\n     */\n    function addMigratedUnderlying(\n        address unripeToken,\n        uint256 amount\n    ) external payable nonReentrant {\n        LibDiamond.enforceIsContractOwner();\n        IERC20(s.u[unripeToken].underlyingToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n        LibUnripe.incrementUnderlying(unripeToken, amount);\n    }\n\n    /**\n     * @notice Switches the Ripe Token of an Unripe Token.\n     * @param unripeToken The Unripe Token to switch the Ripe Token of.\n     * @param newUnderlyingToken The new Ripe Token to switch to.\n     * @dev `s.u[unripeToken].balanceOfUnderlying` must be 0.\n     */\n    function switchUnderlyingToken(\n        address unripeToken,\n        address newUnderlyingToken\n    ) external payable {\n        LibDiamond.enforceIsContractOwner();\n        require(s.u[unripeToken].balanceOfUnderlying == 0, \"Unripe: Underlying balance > 0\");\n        LibUnripe.switchUnderlyingToken(unripeToken, newUnderlyingToken);\n    }\n\n    /**\n     * @notice Returns the number of Beans that are locked (not in circulation) using the TWA reserves in\n     * the Bean:Eth Well including the Unchoppable Beans underlying the Unripe Bean and Unripe LP\n     * Tokens.\n     */\n    function getLockedBeans() external view returns (uint256) {\n        uint256[] memory twaReserves = LibWell.getTwaReservesFromBeanstalkPump(C.BEAN_ETH_WELL);\n        return LibUnripe.getLockedBeans(twaReserves);\n    }\n\n    /**\n     * @notice Returns the number of Beans that are locked underneath the Unripe Bean token.\n     */\n    function getLockedBeansUnderlyingUnripeBean() external view returns (uint256) {\n        return LibLockedUnderlying.getLockedUnderlying(\n            C.UNRIPE_BEAN,\n            LibUnripe.getRecapPaidPercentAmount(1e6)\n        );\n    }\n\n    /**\n     * @notice Returns the number of Beans that are locked underneath the Unripe LP Token.\n     */\n    function getLockedBeansUnderlyingUnripeBeanEth() external view returns (uint256) {\n        uint256[] memory twaReserves = LibWell.getTwaReservesFromBeanstalkPump(C.BEAN_ETH_WELL);\n        return LibUnripe.getLockedBeansFromLP(twaReserves);\n    }\n}"
    },
    {
      "filename": "protocol/contracts/libraries/Well/LibWell.sol",
      "content": "/*\n SPDX-License-Identifier: MIT\n*/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {ICumulativePump} from \"contracts/interfaces/basin/pumps/ICumulativePump.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IWell} from \"contracts/interfaces/basin/IWell.sol\";\nimport {C} from \"contracts/C.sol\";\nimport {AppStorage, LibAppStorage, Storage} from \"../LibAppStorage.sol\";\nimport {LibUsdOracle} from \"contracts/libraries/Oracle/LibUsdOracle.sol\";\nimport {LibSafeMath128} from \"contracts/libraries/LibSafeMath128.sol\";\n\n/**\n * @title Well Library\n * Contains helper functions for common Well related functionality.\n **/\nlibrary LibWell {\n    using SafeMath for uint256;\n    using LibSafeMath128 for uint128;\n\n    // The BDV Selector that all Wells should be whitelisted with.\n    bytes4 internal constant WELL_BDV_SELECTOR = 0xc84c7727;\n\n    /**\n     * @dev Returns the price ratios between `tokens` and the index of Bean in `tokens`.\n     * These actions are combined into a single function for gas efficiency.\n     */\n    function getRatiosAndBeanIndex(\n        IERC20[] memory tokens\n    ) internal view returns (uint[] memory ratios, uint beanIndex, bool success) {\n        success = true;\n        ratios = new uint[](tokens.length);\n        beanIndex = type(uint256).max;\n        for (uint i; i < tokens.length; ++i) {\n            if (C.BEAN == address(tokens[i])) {\n                beanIndex = i;\n                ratios[i] = 1e6;\n            } else {\n                ratios[i] = LibUsdOracle.getUsdPrice(address(tokens[i]));\n                if (ratios[i] == 0) {\n                    success = false;\n                }\n            }\n        }\n        require(beanIndex != type(uint256).max, \"Bean not in Well.\");\n    }\n\n    /**\n     * @dev Returns the index of Bean in a list of tokens.\n     */\n    function getBeanIndex(IERC20[] memory tokens) internal pure returns (uint beanIndex) {\n        for (beanIndex; beanIndex < tokens.length; ++beanIndex) {\n            if (C.BEAN == address(tokens[beanIndex])) {\n                return beanIndex;\n            }\n        }\n        revert(\"Bean not in Well.\");\n    }\n\n    /**\n     * @dev Returns the index of Bean given a Well.\n     */\n    function getBeanIndexFromWell(address well) internal view returns (uint beanIndex) {\n        IERC20[] memory tokens = IWell(well).tokens();\n        beanIndex = getBeanIndex(tokens);\n    }\n\n    /**\n     * @dev Returns the non-Bean token within a Well.\n     * Assumes a well with 2 tokens only.\n     * Cannot fail (and thus revert), as wells cannot have 2 of the same tokens as the pairing.\n     */\n    function getNonBeanTokenAndIndexFromWell(\n        address well\n    ) internal view returns (address, uint256) {\n        IERC20[] memory tokens = IWell(well).tokens();\n        for (uint256 i; i < tokens.length; i++) {\n            if (address(tokens[i]) != C.BEAN) {\n                return (address(tokens[i]), i);\n            }\n        }\n    }\n\n    /**\n     * @dev Returns whether an address is a whitelisted Well by checking\n     * if the BDV function selector is the `wellBdv` function.\n     */\n    function isWell(address well) internal view returns (bool _isWell) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.ss[well].selector == WELL_BDV_SELECTOR;\n    }\n\n    /**\n     * @notice gets the non-bean usd liquidity of a well,\n     * using the twa reserves and price in storage.\n     *\n     * @dev this is done for gas efficency purposes, rather than calling the pump multiple times.\n     * This function should be called after the reserves for the well have been set.\n     * Currently this is only done in {seasonFacet.sunrise}.\n     *\n     * if LibWell.getUsdTokenPriceForWell() returns 1, then this function is called without the reserves being set.\n     * if s.usdTokenPrice[well] or s.twaReserves[well] returns 0, then the oracle failed to compute\n     * a valid price this Season, and thus beanstalk cannot calculate the usd liquidity.\n     */\n    function getWellTwaUsdLiquidityFromReserves(\n        address well,\n        uint256[] memory twaReserves\n    ) internal view returns (uint256 usdLiquidity) {\n        uint256 tokenUsd = getUsdTokenPriceForWell(well);\n        (address token, uint256 j) = getNonBeanTokenAndIndexFromWell(well);\n        if (tokenUsd > 1) {\n            return twaReserves[j].mul(1e18).div(tokenUsd);\n        }\n\n        // if tokenUsd == 0, then the beanstalk could not compute a valid eth price,\n        // and should return 0. if s.twaReserves[C.BEAN_ETH_WELL].reserve1 is 0, the previous if block will return 0.\n        if (tokenUsd == 0) {\n            return 0;\n        }\n\n        // if the function reaches here, then this is called outside the sunrise function\n        // (i.e, seasonGetterFacet.getLiquidityToSupplyRatio()).We use LibUsdOracle\n        // to get the price. This should never be reached during sunrise and thus\n        // should not impact gas.\n        return LibUsdOracle.getTokenPrice(token).mul(twaReserves[j]).div(1e6);\n    }\n\n    /**\n     * @dev Sets the price in {AppStorage.usdTokenPrice} given a set of ratios.\n     * It assumes that the ratios correspond to the Constant Product Well indexes.\n     */\n    function setUsdTokenPriceForWell(address well, uint256[] memory ratios) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        // If the reserves length is 0, then {LibWellMinting} failed to compute\n        // valid manipulation resistant reserves and thus the price is set to 0\n        // indicating that the oracle failed to compute a valid price this Season.\n        if (ratios.length == 0) {\n            s.usdTokenPrice[well] = 0;\n        } else {\n            (, uint256 j) = getNonBeanTokenAndIndexFromWell(well);\n            s.usdTokenPrice[well] = ratios[j];\n        }\n    }\n\n    /**\n     * @notice Returns the USD / TKN price stored in {AppStorage.usdTokenPrice}.\n     * @dev assumes TKN has 18 decimals.\n     */\n    function getUsdTokenPriceForWell(address well) internal view returns (uint tokenUsd) {\n        tokenUsd = LibAppStorage.diamondStorage().usdTokenPrice[well];\n    }\n\n    /**\n     * @notice resets token price for a well to 1.\n     * @dev must be called at the end of sunrise() once the\n     * price is not needed anymore to save gas.\n     */\n    function resetUsdTokenPriceForWell(address well) internal {\n        LibAppStorage.diamondStorage().usdTokenPrice[well] = 1;\n    }\n\n    /**\n     * @dev Sets the twaReserves in {AppStorage.usdTokenPrice}.\n     * assumes the twaReserve indexes correspond to the Constant Product Well indexes.\n     * if the length of the twaReserves is 0, then the minting oracle is off.\n     *\n     */\n    function setTwaReservesForWell(address well, uint256[] memory twaReserves) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        // if the length of twaReserves is 0, then return 0.\n        // the length of twaReserves should never be 1, but\n        // is added for safety.\n        if (twaReserves.length < 1) {\n            delete s.twaReserves[well].reserve0;\n            delete s.twaReserves[well].reserve1;\n        } else {\n            // safeCast not needed as the reserves are uint128 in the wells.\n            s.twaReserves[well].reserve0 = uint128(twaReserves[0]);\n            s.twaReserves[well].reserve1 = uint128(twaReserves[1]);\n        }\n    }\n\n    /**\n     * @notice Returns the USD / TKN price stored in {AppStorage.usdTokenPrice}.\n     * @dev assumes TKN has 18 decimals.\n     */\n    function getTwaReservesForWell(\n        address well\n    ) internal view returns (uint256[] memory twaReserves) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        twaReserves = new uint256[](2);\n        twaReserves[0] = s.twaReserves[well].reserve0;\n        twaReserves[1] = s.twaReserves[well].reserve1;\n    }\n\n    /**\n     * @notice resets token price for a well to 1.\n     * @dev must be called at the end of sunrise() once the\n     * price is not needed anymore to save gas.\n     */\n    function resetTwaReservesForWell(address well) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.twaReserves[well].reserve0 = 1;\n        s.twaReserves[well].reserve1 = 1;\n    }\n\n    function getWellPriceFromTwaReserves(address well) internal view returns (uint256 price) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        // s.twaReserve[well] should be set prior to this function being called.\n        // 'price' is in terms of reserve0:reserve1.\n        if (s.twaReserves[well].reserve0 == 0) {\n            price = 0;\n        } else {\n            price = s.twaReserves[well].reserve0.mul(1e18).div(s.twaReserves[well].reserve1);\n        }\n    }\n\n    function getTwaReservesFromStorageOrBeanstalkPump(\n        address well\n    ) internal view returns (uint256[] memory twaReserves) {\n        twaReserves = getTwaReservesForWell(well);\n        if (twaReserves[0] == 1) {\n            twaReserves = getTwaReservesFromBeanstalkPump(well);\n        }\n    }\n\n    /**\n     * @notice gets the TwaReserves of a given well.\n     * @dev only supports wells that are whitelisted in beanstalk.\n     * the inital timestamp and reserves is the timestamp of the start\n     * of the last season.\n     */\n    function getTwaReservesFromBeanstalkPump(\n        address well\n    ) internal view returns (uint256[] memory twaReserves) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        (twaReserves, ) = ICumulativePump(C.BEANSTALK_PUMP).readTwaReserves(\n            well,\n            s.wellOracleSnapshots[well],\n            s.season.timestamp,\n            C.BYTES_ZERO\n        );\n    }\n\n    /**\n     * @notice gets the TwaLiquidity of a given well.\n     * @dev only supports wells that are whitelisted in beanstalk.\n     * the inital timestamp and reserves is the timestamp of the start\n     * of the last season.\n     */\n    function getTwaLiquidityFromBeanstalkPump(\n        address well,\n        uint256 tokenUsdPrice\n    ) internal view returns (uint256 usdLiquidity) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        (, uint256 j) = getNonBeanTokenAndIndexFromWell(well);\n        (uint256[] memory twaReserves, ) = ICumulativePump(C.BEANSTALK_PUMP).readTwaReserves(\n            well,\n            s.wellOracleSnapshots[well],\n            s.season.timestamp,\n            C.BYTES_ZERO\n        );\n        usdLiquidity = tokenUsdPrice.mul(twaReserves[j]).div(1e6);\n    }\n}"
    },
    {
      "filename": "protocol/contracts/beanstalk/sun/SeasonFacet/Weather.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {LibBeanMetaCurve} from \"contracts/libraries/Curve/LibBeanMetaCurve.sol\";\nimport {LibEvaluate} from \"contracts/libraries/LibEvaluate.sol\";\nimport {LibSafeMath128} from \"contracts/libraries/LibSafeMath128.sol\";\nimport {LibCases} from \"contracts/libraries/LibCases.sol\";\nimport {Sun, SafeMath, C} from \"./Sun.sol\";\n\n/**\n * @title Weather\n * @author Publius\n * @notice Weather controls the Temperature and Grown Stalk to LP on the Farm.\n */\ncontract Weather is Sun {\n    using SafeMath for uint256;\n    using LibSafeMath128 for uint128;\n\n    uint128 internal constant MAX_BEAN_LP_GP_PER_BDV_RATIO = 100e18;\n\n    /**\n     * @notice Emitted when the Temperature (fka \"Weather\") changes.\n     * @param season The current Season\n     * @param caseId The Weather case, which determines how much the Temperature is adjusted.\n     * @param absChange The absolute change in Temperature.\n     * @dev formula: T_n = T_n-1 +/- bT\n     */\n    event TemperatureChange(uint256 indexed season, uint256 caseId, int8 absChange);\n\n    /**\n     * @notice Emitted when the grownStalkToLP changes.\n     * @param season The current Season\n     * @param caseId The Weather case, which determines how the BeanToMaxLPGpPerBDVRatio is adjusted.\n     * @param absChange The absolute change in the BeanToMaxLPGpPerBDVRatio.\n     * @dev formula: L_n = L_n-1 +/- bL\n     */\n    event BeanToMaxLpGpPerBdvRatioChange(uint256 indexed season, uint256 caseId, int80 absChange);\n\n    /**\n     * @notice Emitted when Beans are minted during the Season of Plenty.\n     * @param season The Season in which Beans were minted for distribution.\n     * @param amount The amount of 3CRV which was received for swapping Beans.\n     * @param toField The amount of Beans which were distributed to remaining Pods in the Field.\n     */\n    event SeasonOfPlenty(uint256 indexed season, uint256 amount, uint256 toField);\n\n    //////////////////// WEATHER INTERNAL ////////////////////\n\n    /**\n     * @notice from deltaB, podRate, change in soil demand, and liquidity to supply ratio,\n     * calculate the caseId, and update the temperature and grownStalkPerBdvToLp.\n     * @param deltaB Pre-calculated deltaB from {Oracle.stepOracle}.\n     * @dev A detailed explanation of the temperature and grownStalkPerBdvToLp\n     * mechanism can be found in the Beanstalk whitepaper.\n     * An explanation of state variables can be found in {AppStorage}.\n     */\n    function calcCaseIdandUpdate(int256 deltaB) internal returns (uint256 caseId) {\n        uint256 beanSupply = C.bean().totalSupply();\n        // prevents infinite L2SR and podrate\n        if (beanSupply == 0) {\n            s.w.t = 1;\n            return 9; // Reasonably low\n        }\n        // Calculate Case Id\n        caseId = LibEvaluate.evaluateBeanstalk(deltaB, beanSupply);\n        updateTemperatureAndBeanToMaxLpGpPerBdvRatio(caseId);\n        handleRain(caseId);\n    }\n\n    /**\n     * @notice updates the temperature and BeanToMaxLpGpPerBdvRatio, based on the caseId.\n     * @param caseId the state beanstalk is in, based on the current season.\n     */\n    function updateTemperatureAndBeanToMaxLpGpPerBdvRatio(uint256 caseId) internal {\n        LibCases.CaseData memory cd = LibCases.decodeCaseData(caseId);\n        updateTemperature(cd.bT, caseId);\n        updateBeanToMaxLPRatio(cd.bL, caseId);\n    }\n\n    /**\n     * @notice Changes the current Temperature `s.w.t` based on the Case Id.\n     * @dev bT are set during edge cases such that the event emitted is valid.\n     */\n    function updateTemperature(int8 bT, uint256 caseId) private {\n        uint256 t = s.w.t;\n        if (bT < 0) {\n            if (t <= uint256(-bT)) {\n                // if (change < 0 && t <= uint32(-change)),\n                // then 0 <= t <= type(int8).max because change is an int8.\n                // Thus, downcasting t to an int8 will not cause overflow.\n                bT = 1 - int8(t);\n                s.w.t = 1;\n            } else {\n                s.w.t = uint32(t - uint256(-bT));\n            }\n        } else {\n            s.w.t = uint32(t + uint256(bT));\n        }\n\n        emit TemperatureChange(s.season.current, caseId, bT);\n    }\n\n    /**\n     * @notice Changes the grownStalkPerBDVPerSeason based on the CaseId.\n     * @dev bL are set during edge cases such that the event emitted is valid.\n     */\n    function updateBeanToMaxLPRatio(int80 bL, uint256 caseId) private {\n        uint128 beanToMaxLpGpPerBdvRatio = s.seedGauge.beanToMaxLpGpPerBdvRatio;\n        if (bL < 0) {\n            if (beanToMaxLpGpPerBdvRatio <= uint128(-bL)) {\n                bL = -int80(beanToMaxLpGpPerBdvRatio);\n                s.seedGauge.beanToMaxLpGpPerBdvRatio = 0;\n            } else {\n                s.seedGauge.beanToMaxLpGpPerBdvRatio = beanToMaxLpGpPerBdvRatio.sub(uint128(-bL));\n            }\n        } else {\n            if (beanToMaxLpGpPerBdvRatio.add(uint128(bL)) >= MAX_BEAN_LP_GP_PER_BDV_RATIO) {\n                // if (change > 0 && 100e18 - beanToMaxLpGpPerBdvRatio <= bL),\n                // then bL cannot overflow.\n                bL = int80(MAX_BEAN_LP_GP_PER_BDV_RATIO.sub(beanToMaxLpGpPerBdvRatio));\n                s.seedGauge.beanToMaxLpGpPerBdvRatio = MAX_BEAN_LP_GP_PER_BDV_RATIO;\n            } else {\n                s.seedGauge.beanToMaxLpGpPerBdvRatio = beanToMaxLpGpPerBdvRatio.add(uint128(bL));\n            }\n        }\n\n        emit BeanToMaxLpGpPerBdvRatioChange(s.season.current, caseId, bL);\n    }\n\n    /**\n     * @dev Oversaturated was previously referred to as Raining and thus code\n     * references mentioning Rain really refer to Oversaturation. If P > 1 and the\n     * Pod Rate is less than 5%, the Farm is Oversaturated. If it is Oversaturated\n     * for a Season, each Season in which it continues to be Oversaturated, it Floods.\n     */\n    function handleRain(uint256 caseId) internal {\n        // cases 3-8 represent the case where the pod rate is less than 5% and P > 1.\n        if (caseId.mod(36) < 3 || caseId.mod(36) > 8) {\n            if (s.season.raining) {\n                s.season.raining = false;\n            }\n            return;\n        } else if (!s.season.raining) {\n            s.season.raining = true;\n            // Set the plenty per root equal to previous rain start.\n            s.sops[s.season.current] = s.sops[s.season.rainStart];\n            s.season.rainStart = s.season.current;\n            s.r.pods = s.f.pods;\n            s.r.roots = s.s.roots;\n        } else {\n            if (s.r.roots > 0) {\n                sop();\n            }\n        }\n    }\n\n    /**\n     * @dev Flood was previously called a \"Season of Plenty\" (SOP for short).\n     * When Beanstalk has been Oversaturated for a Season, Beanstalk returns the\n     * Bean price to its peg by minting additional Beans and selling them directly\n     * on Curve. Proceeds  from the sale in the form of 3CRV are distributed to\n     * Stalkholders at the beginning of a Season in proportion to their Stalk\n     * ownership when the Farm became Oversatur"
    }
  ]
}