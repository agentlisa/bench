{
  "Title": "[M-01] Due to loss of precision, targetVotes may not reach",
  "Content": "\nIn the `\\_pledge` function, require delegationBoost.adjusted_balance_of(pledgeParams.receiver) + amount <= pledgeParams.targetVotes.\n\nIn reality, when the user pledges the amount of votes, the actual votes received by the receiver are the bias in the following calculation. And the bias will be less than amount due to the loss of precision.\n\n            uint256 slope = amount / boostDuration;\n            uint256 bias = slope * boostDuration;\n\nThis means that the balance of receiver may not reach targetVotes\n\n        point = self._checkpoint_read(_user, False)\n        amount += (point.bias - point.slope * (block.timestamp - point.ts))\n        return amount\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L245-L246>\n\n<https://github.com/curvefi/curve-veBoost/blob/master/contracts/BoostV2.vy#L192-L209>\n\n<https://github.com/curvefi/curve-veBoost/blob/master/contracts/BoostV2.vy#L175>\n\n### Recommended Mitigation Steps\n\nUse bias instead of amount in the check below:\n\n            uint256 slope = amount / boostDuration;\n            uint256 bias = slope * boostDuration;\n            if(delegationBoost.adjusted_balance_of(pledgeParams.receiver) + bias > pledgeParams.targetVotes) revert Errors.TargetVotesOverflow();\n            delegationBoost.boost(\n                pledgeParams.receiver,\n                amount,\n                endTimestamp,\n                user\n            );\n\n**[Kogaroshi (Paladin) acknowledged and commented](https://github.com/code-423n4/2022-10-paladin-findings/issues/59#issuecomment-1296374082):**\n > The current check is made that way to prevent any unnecessary call to the BoostV2 contract (and save gas by not creating the Boost) in the case of a `targetVotes` overflow.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-10-paladin",
  "Code": [
    {
      "filename": "contracts/WardenPledge.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./oz/interfaces/IERC20.sol\";\nimport \"./oz/libraries/SafeERC20.sol\";\nimport \"./utils/Owner.sol\";\nimport \"./oz/utils/Pausable.sol\";\nimport \"./oz/utils/ReentrancyGuard.sol\";\nimport \"./interfaces/IVotingEscrow.sol\";\nimport \"./interfaces/IBoostV2.sol\";\nimport \"./utils/Errors.sol\";\n\n/** @title Warden Pledge contract */\n/// @author Paladin\n/*\n    Delegation market (Pledge version) based on Curve Boost V2 contract\n*/\ncontract WardenPledge is Ownable, Pausable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // Constants :\n    uint256 public constant UNIT = 1e18;\n    uint256 public constant MAX_PCT = 10000;\n    uint256 public constant WEEK = 7 * 86400;\n\n    // Storage :\n\n    struct Pledge{\n        // Target amount of veCRV (balance scaled by Boost v2, fetched as adjusted_balance)\n        uint256 targetVotes;\n        // Difference of votes between the target and the receiver balance at the start of the Pledge\n        // (used for later extend/increase of some parameters the Pledge)\n        uint256 votesDifference;\n        // Price per vote per second, set by the owner\n        uint256 rewardPerVote;\n        // Address to receive the Boosts\n        address receiver;\n        // Address of the token given as rewards to Boosters\n        address rewardToken;\n        // Timestamp of end of the Pledge\n        uint64 endTimestamp;\n        // Set to true if the Pledge is canceled, or when closed after the endTimestamp\n        bool closed;\n    }\n\n    /** @notice List of all Pledges */\n    Pledge[] public pledges;\n\n    /** @notice Owner of each Pledge (ordered by index in the pledges list) */\n    mapping(uint256 => address) public pledgeOwner;\n    /** @notice List of all Pledges for each owner */\n    mapping(address => uint256[]) public ownerPledges;\n\n    /** @notice Amount of rewards available for each Pledge */\n    // sorted by Pledge index\n    mapping(uint256 => uint256) public pledgeAvailableRewardAmounts;\n\n\n    /** @notice Address of the votingToken to delegate */\n    IVotingEscrow public votingEscrow;\n    /** @notice Address of the Delegation Boost contract */\n    IBoostV2 public delegationBoost;\n\n\n    /** @notice Minimum amount of reward per vote for each reward token */\n    // Also used to whitelist the tokens for rewards\n    mapping(address => uint256) public minAmountRewardToken;\n\n\n    /** @notice ratio of fees to pay the protocol (in BPS) */\n    uint256 public protocalFeeRatio = 250; //bps\n    /** @notice Address to receive protocol fees */\n    address public chestAddress;\n\n    /** @notice Minimum target of votes for a Pledge */\n    uint256 public minTargetVotes;\n\n    /** @notice Minimum delegation time, taken from veBoost contract */\n    uint256 public minDelegationTime = 1 weeks;\n\n\n    // Events\n\n    /** @notice Event emitted when xx */\n    event NewPledge(\n        address creator,\n        address receiver,\n        address rewardToken,\n        uint256 targetVotes,\n        uint256 rewardPerVote,\n        uint256 endTimestamp\n    );\n    /** @notice Event emitted when xx */\n    event ExtendPledgeDuration(uint256 indexed pledgeId, uint256 oldEndTimestamp, uint256 newEndTimestamp);\n    /** @notice Event emitted when xx */\n    event IncreasePledgeTargetVotes(uint256 indexed pledgeId, uint256 oldTargetVotes, uint256 newTargetVotes);\n    /** @notice Event emitted when xx */\n    event IncreasePledgeRewardPerVote(uint256 indexed pledgeId, uint256 oldRewardPerVote, uint256 newRewardPerVote);\n    /** @notice Event emitted when xx */\n    event ClosePledge(uint256 indexed pledgeId);\n    /** @notice Event emitted when xx */\n    event RetrievedPledgeRewards(uint256 indexed pledgeId, address receiver, uint256 amount);\n\n    /** @notice Event emitted when xx */\n    event Pledged(uint256 indexed pledgeId, address indexed user, uint256 amount, uint256 endTimestamp);\n\n    /** @notice Event emitted when xx */\n    event NewRewardToken(address indexed token, uint256 minRewardPerSecond);\n    /** @notice Event emitted when xx */\n    event UpdateRewardToken(address indexed token, uint256 minRewardPerSecond);\n    /** @notice Event emitted when xx */\n    event RemoveRewardToken(address indexed token);\n\n    /** @notice Event emitted when xx */\n    event ChestUpdated(address oldChest, address newChest);\n    /** @notice Event emitted when xx */\n    event PlatformFeeUpdated(uint256 oldfee, uint256 newFee);\n    /** @notice Event emitted when xx */\n    event MinTargetUpdated(uint256 oldMinTarget, uint256 newMinTargetVotes);\n\n\n\n    // Constructor\n\n    /**\n    * @dev Creates the contract, set the given base parameters\n    * @param _votingEscrow address of the voting token to delegate\n    * @param _delegationBoost address of the contract handling delegation\n    * @param _minTargetVotes min amount of veToken to target in a Pledge\n    */\n    constructor(\n        address _votingEscrow,\n        address _delegationBoost,\n        address _chestAddress,\n        uint256 _minTargetVotes\n    ) {\n        votingEscrow = IVotingEscrow(_votingEscrow);\n        delegationBoost = IBoostV2(_delegationBoost);\n\n        chestAddress = _chestAddress;\n\n        minTargetVotes = _minTargetVotes;\n    }\n\n    \n    // View Methods\n\n    /**\n    * @notice Amount of Pledges listed in this contract\n    * @dev Amount of Pledges listed in this contract\n    * @return uint256: Amount of Pledges listed in this contract\n    */\n    function pledgesIndex() public view returns(uint256){\n        return pledges.length;\n    }\n\n    /**\n    * @notice Get all Pledges created by the user\n    * @dev Get all Pledges created by the user\n    * @param user Address of the user\n    * @return uint256[]: List of Pledges IDs\n    */\n    function getUserPledges(address user) external view returns(uint256[] memory){\n        return ownerPledges[user];\n    }\n\n    /**\n    * @notice Get all the Pledges\n    * @dev Get all the Pledges\n    * @return Pledge[]: List of Pledge structs\n    */\n    function getAllPledges() external view returns(Pledge[] memory){\n        return pledges;\n    }\n\n    /**\n    * @dev Rounds down given timestamp to weekly periods\n    * @param timestamp timestamp to round down\n    * @return uint256: rounded down timestamp\n    */\n    function _getRoundedTimestamp(uint256 timestamp) internal pure returns(uint256) {\n        return (timestamp / WEEK) * WEEK;\n    }\n\n\n    // Pledgers Methods\n\n    /**\n    * @notice Delegates boost to a given Pledge & receive rewards\n    * @dev Delegates boost to a given Pledge & receive rewards\n    * @param pledgeId Pledge to delegate to\n    * @param amount Amount to delegate\n    * @param endTimestamp End of delegation\n    */\n    function pledge(uint256 pledgeId, uint256 amount, uint256 endTimestamp) external whenNotPaused nonReentrant {\n        _pledge(pledgeId, msg.sender, amount, endTimestamp);\n    }\n\n    /**\n    * @notice Delegates boost (using a percentage of the balance) to a given Pledge & receive rewards\n    * @dev Delegates boost (using a percentage of the balance) to a given Pledge & receive rewards\n    * @param pledgeId Pledge to delegate to\n    * @param percent Percent of balance to delegate\n    * @param endTimestamp End of delegation\n    */\n    function pledgePercent(uint256 pledgeId, uint256 percent, uint256 endTimestamp) external whenNotPaused nonReentrant {\n        if(percent > MAX_PCT) revert Errors.PercentOverMax();\n\n        uint256 amount = (votingEscrow.balanceOf(msg.sender) * percent) / MAX_PCT;\n\n        _pledge(pledgeId, msg.sender, amount, endTimestamp);\n        \n    }\n\n    /**\n    * @dev Delegates the boost to the Pledge receiver & sends rewards to the delegator\n    * @param pledgeId Pledge to delegate to\n    * @param user Address of the delegator\n    * @param amount Amount to delegate\n    * @param endTimestamp End of delegation\n    */\n    function _pledge(uint256 pledgeId, address user, uint256 amount, uint256 endTimestamp) internal {\n        if(pledgeId >= pledgesIndex()) revert Errors.InvalidPledgeID();\n        if(amount == 0) revert Errors.NullValue();\n\n        // Load Pledge parameters & check the Pledge is still active\n        Pledge memory pledgeParams = pledges[pledgeId];\n        if(pledgeParams.closed) revert Errors.PledgeClosed();\n        if(pledgeParams.endTimestamp <= block.timestamp) revert Errors.ExpiredPledge();\n\n        // To join until the end of the pledge, user can input 0 as endTimestamp\n        // so it's override by the Pledge's endTimestamp\n        if(endTimestamp == 0) endTimestamp = pledgeParams.endTimestamp;\n        if(endTimestamp > pledgeParams.endTimestamp || endTimestamp != _getRoundedTimestamp(endTimestamp)) revert Errors.InvalidEndTimestamp();\n\n        // Calculated the effective Pledge duration\n        uint256 boostDuration = endTimestamp - block.timestamp;\n\n        // Check that the user has enough boost delegation available & set the correct allowance to this contract\n        delegationBoost.checkpoint_user(user);\n        if(delegationBoost.allowance(user, address(this)) < amount) revert Errors.InsufficientAllowance();\n        if(delegationBoost.delegable_balance(user) < amount) revert Errors.CannotDelegate();\n\n        // Check that this will not go over the Pledge target of votes\n        if(delegationBoost.adjusted_balance_of(pledgeParams.receiver) + amount > pledgeParams.targetVotes) revert Errors.TargetVotesOverflow();\n\n        // Creates the DelegationBoost\n        delegationBoost.boost(\n            pledgeParams.receiver,\n            amount,\n            endTimestamp,\n            user\n        );\n\n        // Re-calculate the new Boost bias & slope (using Boostv2 logic)\n        uint256 slope = amount / boostDuration;\n        uint256 bias = slope * boostDuration;\n\n        // Rewards are set in the Pledge as reward/veToken/sec\n        // To find the total amount of veToken delegated through the whole Boost duration\n        // based on the Boost bias & the Boost duration, to take in account that the delegated amount decreases\n        // each second of the Boost duration\n        uint256 totalDelegatedAmount = ((bias * boostDuration) + bias) / 2;\n        // Then we can calculate the total amount of rewards for this Boost\n        uint256 rewardAmount = (totalDelegatedAmount * pledgeParams.rewardPerVote) / UNIT;\n\n        if(rewardAmount > pledgeAvailableRewardAmounts[pledgeId]) revert Errors.RewardsBalanceTooLow();\n        pledgeAvailableRewardAmounts[pledgeId] -= rewardAmount;\n\n        // Send the rewards to the user\n        IERC20(pledgeParams.rewardToken).safeTransfer(user, rewardAmount);\n\n        emit Pledged(pledgeId, user, amount, endTimestamp);\n    }\n\n\n    // Pledge Creators Methods\n\n    struct CreatePledgeVars {\n        uint256 duration;\n        uint256 votesDifference;\n        uint256 totalRewardAmount;\n        uint256 feeAmount;\n        uint256 newPledgeID;\n    }\n\n    /**\n    * @notice Creates a new Pledge\n    * @dev Creates a new Pledge\n    * @param receiver Address to receive the boost delegation\n    * @param rewardToken Address of the token distributed as reward\n    * @param targetVotes Maximum taget of votes to have (own balacne + delegation) for the receiver\n    * @param rewardPerVote Amount of reward given for each vote delegation (per second)\n    * @param endTimestamp End of the Pledge\n    * @param maxTotalRewardAmount Maximum total reward amount allowed ot be pulled by this contract\n    * @param maxFeeAmount Maximum feeamount allowed ot be pulled by this contract\n    * @return uint256: Newly created Pledge ID\n    */\n    function createPledge(\n        address receiver,\n        address rewardToken,\n        uint256 targetVotes,\n        uint256 rewardPerVote, // reward/veToken/second\n        uint256 endTimestamp,\n        uint256 maxTotalRewardAmount,\n        uint256 maxFeeAmount\n    ) external whenNotPaused nonReentrant returns(uint256){\n        address creator = msg.sender;\n\n        if(receiver == address(0) || rewardToken == address(0)) revert Errors.ZeroAddress();\n        if(targetVotes < minTargetVotes) revert Errors.TargetVoteUnderMin();\n        if(minAmountRewardToken[rewardToken] == 0) revert Errors.TokenNotWhitelisted();\n        if(rewardPerVote < minAmountRewardToken[rewardToken]) revert Errors.RewardPerVoteTooLow();\n\n        if(endTimestamp == 0) revert Errors.NullEndTimestamp();\n        if(endTimestamp != _getRoundedTimestamp(endTimestamp)) revert Errors.InvalidEndTimestamp();\n\n        CreatePledgeVars memory vars;\n        vars.duration = endTimestamp - block.timestamp;\n        if(vars.duration < minDelegationTime) revert Errors.DurationTooShort();\n\n        // Get the missing votes for the given receiver to reach the target votes\n        // We ignore any delegated boost here because they might expire during the Pledge duration\n        // (we can have a future version of this contract using adjusted_balance)\n        vars.votesDifference = targetVotes - votingEscrow.balanceOf(receiver);\n\n        vars.totalRewardAmount = (rewardPerVote * vars.votesDifference * vars.duration) / UNIT;\n        vars.feeAmount = (vars.totalRewardAmount * protocalFeeRatio) / MAX_PCT ;\n        if(vars.totalRewardAmount > maxTotalRewardAmount) revert Errors.IncorrectMaxTotalRewardAmount();\n        if(vars.feeAmount > maxFeeAmount) revert Errors.IncorrectMaxFeeAmount();\n\n        // Pull all the rewards in this contract\n        IERC20(rewardToken).safeTransferFrom(creator, address(this), vars.totalRewardAmount);\n        // And transfer the fees from the Pledge creator to the Chest contract\n        IERC20(rewardToken).safeTransferFrom(creator, chestAddress, vars.feeAmount);\n\n        vars.newPledgeID = pledgesIndex();\n\n        // Add the total reards as available for the Pledge & write Pledge parameters in storage\n        pledgeAvailableRewardAmounts[vars.newPledgeID] += vars.totalRewardAmount;\n\n        pledges.push(Pledge(\n            targetVotes,\n            vars.votesDifference,\n            rewardPerVote,\n            receiver,\n            rewardToken,\n            safe64(endTimestamp),\n            false\n        ));\n\n        pledgeOwner[vars.newPledgeID] = creator;\n        ownerPledges[creator].push(vars.newPledgeID);\n\n        emit NewPledge(creator, receiver, rewardToken, targetVotes, rewardPerVote, endTimestamp);\n\n        return vars.newPledgeID;\n    }\n\n    /**\n    * @notice Extends the Pledge duration\n    * @dev Extends the Pledge duration & add rewards for that new duration\n    * @param pledgeId ID of the Pledge\n    * @param newEndTimestamp New end of the Pledge\n    * @param maxTotalRewardAmount Maximum added total reward amount allowed ot be pulled by this contract\n    * @param maxFeeAmount Maximum fee amount allowed ot be pulled by this contract\n    */\n    function extendPledge(\n        uint256 pledgeId,\n        uint256 newEndTimestamp,\n        uint256 maxTotalRewardAmount,\n        uint256 maxFeeAmount\n    ) external whenNotPaused nonReentrant {\n        if(pledgeId >= pledgesIndex()) revert Errors.InvalidPledgeID();\n        address creator = pledgeOwner[pledgeId];\n        if(msg.sender != creator) revert Errors.NotPledgeCreator();\n\n        Pledge storage pledgeParams = pledges[pledgeId];\n        if(pledgeParams.closed) revert Errors.PledgeClosed();\n        if(pledgeParams.endTimestamp <= block.timestamp) revert Errors.ExpiredPledge();\n        if(newEndTimestamp == 0) revert Errors.NullEndTimestamp();\n        uint256 oldEndTimestamp = pledgeParams.endTimestamp;\n        if(newEndTimestamp != _getRoundedTimestamp(newEndTimestamp) || newEndTimestamp < oldEndTimestamp) revert Errors.InvalidEndTimestamp();\n\n        uint256 addedDuration = newEndTimestamp - oldEndTimestamp;\n        if(addedDuration < minDelegationTime) revert Errors.DurationTooShort();\n        uint256 totalRewardAmount = (pledgeParams.rewardPerVote * pledgeParams.votesDifference * addedDuration) / UNIT;\n        uint256 feeAmount = (totalRewardAmount * protocalFeeRatio) / MAX_PCT ;\n        if(totalRewardAmount > maxTotalRewardAmount) revert Errors.IncorrectMaxTotalRewardAmount();\n        if(feeAmount > maxFeeAmount) revert Errors.IncorrectMaxFeeAmount();\n\n\n        // Pull all the rewards in this contract\n        IERC20(pledgeParams.rewardToken).safeTransferFrom(creator, address(this), totalRewardAmount);\n        // And transfer the fees from the Pledge creator to the Chest contract\n        IERC20(pledgeParams.rewardToken).safeTransferFrom(creator, chestAddress, feeAmount);\n\n        // Update the Pledge parameters in storage\n        pledgeParams.endTimestamp = safe64(newEndTimestamp);\n\n        pledgeAvailableRewardAmounts[pledgeId] += totalRewardAmount;\n\n        emit ExtendPledgeDuration(pledgeId, oldEndTimestamp, newEndTimestamp);\n    }\n\n    /**\n    * @notice Increases the Pledge reward per vote delegated\n    * @dev Increases the Pledge reward per vote delegated & add rewards for that new duration\n    * @param pledgeId ID of the Pledge\n    * @param newRewardPerVote New amount of reward given for each vote delegation (per second)\n    * @param maxTotalRewardAmount Maximum added total reward amount allowed ot be pulled by this contract\n    * @param maxFeeAmount Maximum fee amount allowed ot be pulled by this contract\n    */\n    function increasePledgeRewardPerVote(\n        uint256 pledgeId,\n        uint256 newRewardPerVote,\n        uint256 maxTotalRewardAmount,\n        uint256 maxFeeAmount\n    ) external whenNotPaused nonReentrant {\n        if(pledgeId >= pledgesIndex()) revert Errors.InvalidPledgeID();\n        address creator = pledgeOwner[pledgeId];\n        if(msg.sender != creator) revert Errors.NotPledgeCreator();\n\n        Pledge storage pledgeParams = pledges[pledgeId];\n        if(pledgeParams.closed) revert Errors.PledgeClosed();\n        if(pledgeParams.endTimestamp <= block.timestamp) revert Errors.ExpiredPledge();\n\n        uint256 oldRewardPerVote = pledgeParams.rewardPerVote;\n        if(newRewardPerVote <= oldRewardPerVote) revert Errors.RewardsPerVotesTooLow();\n        uint256 remainingDuration = pledgeParams.endTimestamp - block.timestamp;\n        uint256 rewardPerVoteDiff = newRewardPerVote - oldRewardPerVote;\n        uint256 totalRewardAmount = (rewardPerVoteDiff * pledgeParams.votesDifference * remainingDuration) / UNIT;\n        uint256 feeAmount = (totalRewardAmount * protocalFeeRatio) / MAX_PCT ;\n        if(totalRewardAmount > maxTotalRewardAmount) revert Errors.IncorrectMaxTotalRewardAmount();\n        if(feeAmount > maxFeeAmount) revert Errors.IncorrectMaxFeeAmount();\n\n        // Pull all the rewards in this contract\n        IERC20(pledgeParams.rewardToken).safeTransferFrom(creator, address(this), totalRewardAmount);\n        // And transfer the fees from the Pledge creator to the Chest contract\n        IERC20(pledgeParams.rewardToken).safeTransferFrom(creator, chestAddress, feeAmount);\n\n        // Update the Pledge parameters in storage\n        pledgeParams.rewardPerVote = newRewardPerVote;\n\n        pledgeAvailableRewardAmounts[pledgeId] += totalRewardAmount;\n\n        emit IncreasePledgeRewardPerVote(pledgeId, oldRewardPerVote, newRewardPerVote);\n    }\n\n    /**\n    * @notice Retrieves all non distributed rewards from a closed Pledge\n    * @dev Retrieves all non distributed rewards from a closed Pledge & send them to the given receiver\n    * @param pledgeId ID fo the Pledge\n    * @param receiver Address to receive the remaining rewards\n    */\n    function retrievePledgeRewards(uint256 pledgeId, address receiver) external whenNotPaused nonReentrant {\n        if(pledgeId >= pledgesIndex()) revert Errors.InvalidPledgeID();\n        address creator = pledgeOwner[pledgeId];\n        if(msg.sender != creator) revert Errors.NotPledgeCreator();\n        if(receiver == address(0)) revert Errors.ZeroAddress();\n\n        Pledge storage pledgeParams = pledges[pledgeId];\n        if(pledgeParams.endTimestamp > block.timestamp) revert Errors.PledgeNotExpired();\n\n        // Get the current remaining amount of rewards not distributed for the Pledge\n        uint256 remainingAmount = pledgeAvailableRewardAmounts[pledgeId];\n\n        // Set the Pledge as Closed\n        if(!pledgeParams.closed) pledgeParams.closed = true;\n\n        if(remainingAmount > 0) {\n            // Transfer the non used rewards and reset storage\n            pledgeAvailableRewardAmounts[pledgeId] = 0;\n\n            IERC20(pledgeParams.rewardToken).safeTransfer(receiver, remainingAmount);\n\n            emit RetrievedPledgeRewards(pledgeId, receiver, remainingAmount);\n\n        }\n    }\n\n    /**\n    * @notice Closes a Pledge and retrieves all non distributed rewards from a Pledge\n    * @dev Closes a Pledge and retrieves all non distributed rewards from a Pledge & send them to the given receiver\n    * @param pledgeId ID fo the Pledge to close\n    * @param receiver Address to receive the remaining rewards\n    */\n    function closePledge(uint256 pledgeId, address receiver) external whenNotPaused nonReentrant {\n        if(pledgeId >= pledgesIndex()) revert Errors.InvalidPledgeID();\n        address creator = pledgeOwner[pledgeId];\n        if(msg.sender != creator) revert Errors.NotPledgeCreator();\n        if(receiver == address(0)) revert Errors.ZeroAddress();\n\n        Pledge storage pledgeParams = pledges[pledgeId];\n        if(pledgeParams.closed) revert Errors.PledgeAlreadyClosed();\n        if(pledgeParams.endTimestamp <= block.timestamp) revert Errors.ExpiredPledge();\n\n        // Set the Pledge as Closed\n        pledgeParams.closed = true;\n\n        // Get the current remaining amount of rewards not distributed for the Pledge\n        uint256 remainingAmount = pledgeAvailableRewardAmounts[pledgeId];\n\n        if(remainingAmount > 0) {\n            // Transfer the non used rewards and reset storage\n            pledgeAvailableRewardAmounts[pledgeId] = 0;\n\n            IERC20(pledgeParams.rewardToken).safeTransfer(receiver, remainingAmount);\n\n            emit RetrievedPledgeRewards(pledgeId, receiver, remainingAmount);\n\n        }\n\n        emit ClosePledge(pledgeId);\n    }\n\n\n    // Admin Methods\n\n    /**\n    * @dev Adds a given reward token to the whitelist\n    * @param token Address of the token\n    * @param minRewardPerSecond Minmum amount of reward per vote per second for the token\n    */\n    function _addRewardToken(address token, uint256 minRewardPerSecond) internal {\n        if(minAmountRewardToken[token] != 0) revert Errors.AlreadyAllowedToken();\n        if(token == address(0)) revert Errors.ZeroAddress();\n        if(minRewardPerSecond == 0) revert Errors.NullValue();\n        \n        minAmountRewardToken[token] = minRewardPerSecond;\n\n        emit NewRewardToken(token, minRewardPerSecond);\n    }\n\n    /**\n    * @notice Adds a given reward token to the whitelist\n    * @dev Adds a given reward token to the whitelist\n    * @param tokens List of token addresses to add\n    * @param minRewardsPerSecond Minmum amount of reward per vote per second for each token in the list\n    */\n    function addMultipleRewardToken(address[] calldata tokens, uint256[] calldata minRewardsPerSecond) external onlyOwner {\n        uint256 length = tokens.length;\n\n        if(length == 0) revert Errors.EmptyArray();\n        if(length != minRewardsPerSecond.length) revert Errors.InequalArraySizes();\n\n        for(uint256 i = 0; i < length;){\n            _addRewardToken(tokens[i], minRewardsPerSecond[i]);\n\n            unchecked{ ++i; }\n        }\n    }\n\n    /**\n    * @notice Adds a given reward token to the whitelist\n    * @dev Adds a given reward token to the whitelist\n    * @param token Address of the token\n    * @param minRewardPerSecond Minmum amount of reward per vote per second for the token\n    */\n    function addRewardToken(address token, uint256 minRewardPerSecond) external onlyOwner {\n        _addRewardToken(token, minRewardPerSecond);\n    }\n\n    /**\n    * @notice Updates a reward token\n    * @dev Updates a reward token\n    * @param token Address of the token\n    * @param minRewardPerSecond Minmum amount of reward per vote per second for the token\n    */\n    function updateRewardToken(address token, uint256 minRewardPerSecond) external onlyOwner {\n        if(token == address(0)) revert Errors.ZeroAddress();\n        if(minAmountRewardToken[token] == 0) revert Errors.NotAllowedToken();\n        if(minRewardPerSecond == 0) revert Errors.InvalidValue();\n\n        minAmountRewardToken[token] = minRewardPerSecond;\n\n        emit UpdateRewardToken(token, minRewardPerSecond);\n    }\n\n    /**\n    * @notice Removes a reward token from the whitelist\n    * @dev Removes a reward token from the whitelist\n    * @param token Address of the token\n    */\n    function removeRewardToken(address token) external onlyOwner {\n        if(token == address(0)) revert Errors.ZeroAddress();\n        if(minAmountRewardToken[token] == 0) revert Errors.NotAllowedToken();\n        \n        minAmountRewardToken[token] = 0;\n        \n        emit RemoveRewardToken(token);\n    }\n    \n    /**\n    * @notice Updates the Chest address\n    * @dev Updates the Chest address\n    * @param chest Address of the new Chest\n    */\n    function updateChest(address chest) external onlyOwner {\n        if(chest == address(0)) revert Errors.ZeroAddress();\n        address oldChest = chestAddress;\n        chestAddress = chest;\n\n        emit ChestUpdated(oldChest, chest);\n    }\n\n    /**\n    * @notice Updates the new min target of votes for Pledges\n    * @dev Updates the new min target of votes for Pledges\n    * @param newMinTargetVotes New minimum target of votes\n    */\n    function updateMinTargetVotes(uint256 newMinTargetVotes) external onlyOwner {\n        if(newMinTargetVotes == 0) revert Errors.InvalidValue();\n        uint256 oldMinTarget = minTargetVotes;\n        minTargetVotes = newMinTargetVotes;\n\n        emit MinTargetUpdated(oldMinTarget, newMinTargetVotes);\n    }\n\n    /**\n    * @notice Updates the Platfrom fees BPS ratio\n    * @dev Updates the Platfrom fees BPS ratio\n    * @param newFee New fee ratio\n    */\n    function updatePlatformFee(uint256 newFee) external onlyOwner {\n        if(newFee > 500) revert Errors.InvalidValue();\n        uint256 oldfee = protocalFeeRatio;\n        protocalFeeRatio = newFee;\n\n        emit PlatformFeeUpdated(oldfee, newFee);\n    }\n\n    /**\n     * @notice Pauses the contract\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Unpauses the contract\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /**\n    * @notice Recovers ERC2O tokens sent by mistake to the contract\n    * @dev Recovers ERC2O tokens sent by mistake to the contract\n    * @param token Address tof the EC2O token\n    * @return bool: success\n    */\n    function recoverERC20(address token) external onlyOwner returns(bool) {\n        if(minAmountRewardToken[token] != 0) revert Errors.CannotRecoverToken();\n\n        uint256 amount = IERC20(token).balanceOf(address(this));\n        if(amount == 0) revert Errors.NullValue();\n        IERC20(token).safeTransfer(owner(), amount);\n\n        return true;\n    }\n\n    // Utils \n\n    function safe64(uint256 n) internal pure returns (uint64) {\n        if(n > type(uint64).max) revert Errors.NumberExceed64Bits();\n        return uint64(n);\n    }\n\n\n}"
    },
    {
      "filename": "contracts/BoostV2.vy",
      "content": "# @version 0.3.3\n\"\"\"\n@title Boost Delegation V2\n@author CurveFi\n\"\"\"\n\n\nevent Approval:\n    _owner: indexed(address)\n    _spender: indexed(address)\n    _value: uint256\n\nevent Transfer:\n    _from: indexed(address)\n    _to: indexed(address)\n    _value: uint256\n\nevent Boost:\n    _from: indexed(address)\n    _to: indexed(address)\n    _bias: uint256\n    _slope: uint256\n    _start: uint256\n\nevent Migrate:\n    _token_id: indexed(uint256)\n\n\ninterface BoostV1:\n    def ownerOf(_token_id: uint256) -> address: view\n    def token_boost(_token_id: uint256) -> int256: view\n    def token_expiry(_token_id: uint256) -> uint256: view\n\ninterface VotingEscrow:\n    def balanceOf(_user: address) -> uint256: view\n    def totalSupply() -> uint256: view\n    def locked__end(_user: address) -> uint256: view\n\n\nstruct Point:\n    bias: uint256\n    slope: uint256\n    ts: uint256\n\n\nNAME: constant(String[32]) = \"Vote-Escrowed Boost\"\nSYMBOL: constant(String[8]) = \"veBoost\"\nVERSION: constant(String[8]) = \"v2.0.0\"\n\nEIP712_TYPEHASH: constant(bytes32) = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)\")\nPERMIT_TYPEHASH: constant(bytes32) = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\n\nWEEK: constant(uint256) = 86400 * 7\n\n\nBOOST_V1: immutable(address)\nDOMAIN_SEPARATOR: immutable(bytes32)\nVE: immutable(address)\n\n\nallowance: public(HashMap[address, HashMap[address, uint256]])\nnonces: public(HashMap[address, uint256])\n\ndelegated: public(HashMap[address, Point])\ndelegated_slope_changes: public(HashMap[address, HashMap[uint256, uint256]])\n\nreceived: public(HashMap[address, Point])\nreceived_slope_changes: public(HashMap[address, HashMap[uint256, uint256]])\n\nmigrated: public(HashMap[uint256, bool])\n\n\n@external\ndef __init__(_boost_v1: address, _ve: address):\n    BOOST_V1 = _boost_v1\n    DOMAIN_SEPARATOR = keccak256(_abi_encode(EIP712_TYPEHASH, keccak256(NAME), keccak256(VERSION), chain.id, self, block.prevhash))\n    VE = _ve\n\n    log Transfer(ZERO_ADDRESS, msg.sender, 0)\n\n\n@view\n@internal\ndef _checkpoint_read(_user: address, _delegated: bool) -> Point:\n    point: Point = empty(Point)\n\n    if _delegated:\n        point = self.delegated[_user]\n    else:\n        point = self.received[_user]\n\n    if point.ts == 0:\n        point.ts = block.timestamp\n\n    if point.ts == block.timestamp:\n        return point\n\n    ts: uint256 = (point.ts / WEEK) * WEEK\n    for _ in range(255):\n        ts += WEEK\n\n        dslope: uint256 = 0\n        if block.timestamp < ts:\n            ts = block.timestamp\n        else:\n            if _delegated:\n                dslope = self.delegated_slope_changes[_user][ts]\n            else:\n                dslope = self.received_slope_changes[_user][ts]\n\n        point.bias -= point.slope * (ts - point.ts)\n        point.slope -= dslope\n        point.ts = ts\n\n        if ts == block.timestamp:\n            break\n\n    return point\n\n\n@internal\ndef _checkpoint_write(_user: address, _delegated: bool) -> Point:\n    point: Point = empty(Point)\n\n    if _delegated:\n        point = self.delegated[_user]\n    else:\n        point = self.received[_user]\n\n    if point.ts == 0:\n        point.ts = block.timestamp\n\n    if point.ts == block.timestamp:\n        return point\n\n    dbias: uint256 = 0\n    ts: uint256 = (point.ts / WEEK) * WEEK\n    for _ in range(255):\n        ts += WEEK\n\n        dslope: uint256 = 0\n        if block.timestamp < ts:\n            ts = block.timestamp\n        else:\n            if _delegated:\n                dslope = self.delegated_slope_changes[_user][ts]\n            else:\n                dslope = self.received_slope_changes[_user][ts]\n\n        amount: uint256 = point.slope * (ts - point.ts)\n\n        dbias += amount\n        point.bias -= amount\n        point.slope -= dslope\n        point.ts = ts\n\n        if ts == block.timestamp:\n            break\n\n    if _delegated == False and dbias != 0:  # received boost\n        log Transfer(_user, ZERO_ADDRESS, dbias)\n\n    return point\n\n\n@view\n@internal\ndef _balance_of(_user: address) -> uint256:\n    amount: uint256 = VotingEscrow(VE).balanceOf(_user)\n\n    point: Point = self._checkpoint_read(_user, True)\n    amount -= (point.bias - point.slope * (block.timestamp - point.ts))\n\n    point = self._checkpoint_read(_user, False)\n    amount += (point.bias - point.slope * (block.timestamp - point.ts))\n    return amount\n\n\n@internal\ndef _boost(_from: address, _to: address, _amount: uint256, _endtime: uint256):\n    assert _to not in [_from, ZERO_ADDRESS]\n    assert _amount != 0\n    assert _endtime > block.timestamp\n    assert _endtime % WEEK == 0\n    assert _endtime <= VotingEscrow(VE).locked__end(_from)\n\n    # checkpoint delegated point\n    point: Point = self._checkpoint_write(_from, True)\n    assert _amount <= VotingEscrow(VE).balanceOf(_from) - (point.bias - point.slope * (block.timestamp - point.ts))\n\n    # calculate slope and bias being added\n    slope: uint256 = _amount / (_endtime - block.timestamp)\n    bias: uint256 = slope * (_endtime - block.timestamp)\n\n    # update delegated point\n    point.bias += bias\n    point.slope += slope\n\n    # store updated values\n    self.delegated[_from] = point\n    self.delegated_slope_changes[_from][_endtime] += slope\n\n    # update received amount\n    point = self._checkpoint_write(_to, False)\n    point.bias += bias\n    point.slope += slope\n\n    # store updated values\n    self.received[_to] = point\n    self.received_slope_changes[_to][_endtime] += slope\n\n    log Transfer(_from, _to, _amount)\n    log Boost(_fr"
    }
  ]
}