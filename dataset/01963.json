{
  "Title": "H-4: Potential flash loan attack vulnerability in `getPrice` function of CurveOracle",
  "Content": "# Issue H-4: Potential flash loan attack vulnerability in `getPrice` function of CurveOracle \n\nSource: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/123 \n\n## Found by \nBauer, helpMePlease\n## Summary\nDuring a security review of the `getPrice` function in the CurveOracle, a potential flash loan attack vulnerability was identified.\n\n## Vulnerability Detail\nThe `getPrice` function retrieves the spot price of each token in a Curve LP pool, calculates the minimum price among them, and multiplies it by the virtual price of the LP token to determine the USD value of the LP token. If the price of one or more tokens in the pool is manipulated, this can cause the minimum price calculation to be skewed, leading to an incorrect USD value for the LP token. This can be exploited by attackers to make a profit at the expense of other users.\n\n## Impact\nThis vulnerability could potentially allow attackers to manipulate the price of tokens in Curve LP pools and profit at the expense of other users. If exploited, this vulnerability could result in significant financial losses for affected users.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/96eb1829571dc46e1a387985bd56989702c5e1dc/blueberry-core/contracts/oracle/CurveOracle.sol#L122\n\n## Tool used\n\nManual Review\n\n## Recommendation\nuse TWAP to determine the prices of the underlying assets in the pool. \n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/69",
  "Code": [
    {
      "filename": "blueberry-core/contracts/oracle/CurveOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../utils/BlueBerryErrors.sol\" as Errors;\nimport \"./UsingBaseOracle.sol\";\nimport \"../interfaces/ICurveOracle.sol\";\nimport \"../interfaces/curve/ICurveRegistry.sol\";\nimport \"../interfaces/curve/ICurveCryptoSwapRegistry.sol\";\nimport \"../interfaces/curve/ICurveAddressProvider.sol\";\n\n/**\n * @author BlueberryProtocol\n * @title Curve Oracle\n * @notice Oracle contract which privides price feeds of Curve Lp tokens\n */\ncontract CurveOracle is UsingBaseOracle, ICurveOracle, Ownable {\n    ICurveAddressProvider public immutable addressProvider;\n\n    event CurveLpRegistered(\n        address crvLp,\n        address pool,\n        address[] underlyingTokens\n    );\n\n    constructor(\n        IBaseOracle base_,\n        ICurveAddressProvider addressProvider_\n    ) UsingBaseOracle(base_) {\n        addressProvider = addressProvider_;\n    }\n\n    /**\n     * @dev Get Curve pool info of given curve lp\n     * @param crvLp Curve LP token address to get the pool info of\n     * @return pool The address of curve pool\n     * @return ulTokens Underlying tokens of curve pool\n     * @return virtualPrice Virtual price of curve pool\n     */\n    function _getPoolInfo(\n        address crvLp\n    )\n        internal\n        view\n        returns (address pool, address[] memory ulTokens, uint256 virtualPrice)\n    {\n        // 1. Try from main registry\n        address registry = addressProvider.get_registry();\n        pool = ICurveRegistry(registry).get_pool_from_lp_token(crvLp);\n        if (pool != address(0)) {\n            (uint256 n, ) = ICurveRegistry(registry).get_n_coins(pool);\n            address[8] memory coins = ICurveRegistry(registry).get_coins(pool);\n            ulTokens = new address[](n);\n            for (uint256 i = 0; i < n; i++) {\n                ulTokens[i] = coins[i];\n            }\n            virtualPrice = ICurveRegistry(registry)\n                .get_virtual_price_from_lp_token(crvLp);\n            return (pool, ulTokens, virtualPrice);\n        }\n\n        // 2. Try from CryptoSwap Registry\n        registry = addressProvider.get_address(5);\n        pool = ICurveCryptoSwapRegistry(registry).get_pool_from_lp_token(crvLp);\n        if (pool != address(0)) {\n            uint256 n = ICurveCryptoSwapRegistry(registry).get_n_coins(pool);\n            address[8] memory coins = ICurveCryptoSwapRegistry(registry)\n                .get_coins(pool);\n            ulTokens = new address[](n);\n            for (uint256 i = 0; i < n; i++) {\n                ulTokens[i] = coins[i];\n            }\n            virtualPrice = ICurveCryptoSwapRegistry(registry)\n                .get_virtual_price_from_lp_token(crvLp);\n            return (pool, ulTokens, virtualPrice);\n        }\n\n        // 3. Try from Metaregistry\n        registry = addressProvider.get_address(7);\n        pool = ICurveCryptoSwapRegistry(registry).get_pool_from_lp_token(crvLp);\n        if (pool != address(0)) {\n            uint256 n = ICurveCryptoSwapRegistry(registry).get_n_coins(pool);\n            address[8] memory coins = ICurveCryptoSwapRegistry(registry)\n                .get_coins(pool);\n            ulTokens = new address[](n);\n            for (uint256 i = 0; i < n; i++) {\n                ulTokens[i] = coins[i];\n            }\n            virtualPrice = ICurveCryptoSwapRegistry(registry)\n                .get_virtual_price_from_lp_token(crvLp);\n            return (pool, ulTokens, virtualPrice);\n        }\n\n        revert Errors.ORACLE_NOT_SUPPORT_LP(crvLp);\n    }\n\n    function getPoolInfo(\n        address crvLp\n    )\n        external\n        view\n        returns (address pool, address[] memory coins, uint256 virtualPrice)\n    {\n        return _getPoolInfo(crvLp);\n    }\n\n    /**\n     * @notice Return the USD value of given Curve Lp, with 18 decimals of precision.\n     * @param crvLp The ERC-20 Curve LP token to check the value.\n     */\n    function getPrice(address crvLp) external view override returns (uint256) {\n        (, address[] memory tokens, uint256 virtualPrice) = _getPoolInfo(crvLp);\n\n        uint256 minPrice = type(uint256).max;\n        for (uint256 idx = 0; idx < tokens.length; idx++) {\n            uint256 tokenPrice = base.getPrice(tokens[idx]);\n            if (tokenPrice < minPrice) minPrice = tokenPrice;\n        }\n        if (minPrice == type(uint256).max)\n            revert Errors.ORACLE_NOT_SUPPORT_LP(crvLp);\n        // Use min underlying token prices\n        return (minPrice * virtualPrice) / 1e18;\n    }\n}"
    }
  ]
}