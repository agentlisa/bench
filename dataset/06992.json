{
  "Title": "[M-08] If the strategy incurs a loss the Active Pool will stop working until the shortfall is paid out entirely",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Core/contracts/ActivePool.sol#L251-L252\n\n\n# Vulnerability details\n\n- Vaults are built with the idea that a [loss could happen](https://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Vault/contracts/ReaperVaultV2.sol#L385-L386)\n\n- The scope mentions that a [Loss scenario is in scope](https://docs.reaper.farm/ethos-reserve-bounty-hunter-documentation/#community-usdoath-issuance:~:text=stays%20fully%20capitalized.-,The%20vault%20will%20be%20farming%20the%20lowest%2Drisk%20yield%20possible%2C%20so%20you%20can%20assume%20that%20the%20principal%20will%20be%20protected%20from%20loss.%20We%20encourage%20you%20nonetheless%20to%20analyze%20the%20impact%20of%20losses%20on%20the%20system.,-Balancer%20Pool%20Staking)\n\nThis line, is written with the assumption that `sharesToAssets` will always be greater than or equal to `currentAllocated`\n\nhttps://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Core/contracts/ActivePool.sol#L251-L252\n\n```solidity\n        vars.profit = vars.sharesToAssets.sub(vars.currentAllocated);\n\n```\n\nThis is not the case as the Strategy MAY incur a loss.\n\nIn such cases, `_rebalance` on the ActivePool will not work until the subtraction stops underflowing `vars.sharesToAssets.sub(vars.currentAllocated);` will revert if any loss (even 1 wei) has happened.\n\n\n### POC\n\nWhen a loss happens, the `sharesToAssets` will decrease.\n\nBecause [`vars.currentAllocated`](https://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Core/contracts/ActivePool.sol#L243) tracks the amount deposited in the vault, this value will necessarily be greater than the `sharesToAsset` if any loss happened.\n\n\nIn that case this line will revert:\n        ```vars.profit = vars.sharesToAssets.sub(vars.currentAllocated);```\n\nIn the code shown, a loss could happen if the LendingPool has accounting errors\n\nFor the in-scope codebase a loss could happen as a consequence of slashing or restructuring due to bad debt incurred by borrowers\n\n### Coded POC\n\nThe following POC was built with brownie\n\nMocked contract retain the core logic, but are rid of access control and other functions to keep the logic the same but reduce complexity of setup\n\nSetup brownie via `brownie console` (local environment is fine as I set-up mocks to make it easy)\n\n```python\n## Setup tokens\ntoken = MockToken.deploy({\"from\": a[0]})\n\n## Deploy Vault\nvault = ReaperVaultV2.deploy(token, {\"from\": a[0]})\n\n##Â Deploy ActivePool\npool = MockActivePool.deploy(token, 2000, vault, 1, {\"from\": a[0]})\n\n## Add to Active\ntoken.approve(pool, 1e18, {\"from\": a[0]})\npool.depositColl(1e18, {\"from\": a[0]})\n\n## Rebalance to invest\npool.manualRebalance(token, 0, {\"from\": a[0]})\n\n## 20% of tokens are in the vault\nprint(token.balanceOf(vault))\n200000000000000000\n\n## Trigger loss to vault\nvault.triggerLoss(1e17, {\"from\": a[0]})\n## Confirm the loss has happened\nprint(vault.balance())\n100000000000000000\n\n## Now that a loss happened, any rebalance will revert\npool.manualRebalance(token, 1, {\"from\": a[0]})\nTransaction sent: 0x798e759783ab59dda9c294178859fec5519179a2c31b89abbfea56bd7284b0bc\n  Gas price: 0.0 gwei   Gas limit: 12000000   Nonce: 8\n  MockActivePool.manualRebalance confirmed (Integer overflow)   Block: 9   Gas used: 32821 (0.27%)\n\n<Transaction '0x798e759783ab59dda9c294178859fec5519179a2c31b89abbfea56bd7284b0bc'>\npool.manualRebalance(token, 100, {\"from\": a[0]})\nTransaction sent: 0x0c41ec1b74a05df6c7101522931cda6ba30139358ec239f014777d7e7e992563\n  Gas price: 0.0 gwei   Gas limit: 12000000   Nonce: 9\n  MockActivePool.manualRebalance confirmed (Integer overflow)   Block: 10   Gas used: 32821 (0.27%)\n\n<Transaction '0x0c41ec1b74a05df6c7101522931cda6ba30139358ec239f014777d7e7e992563'>\n\n## That's because the loss has been registered by the Vault\nprint(vault.convertToAssets(1e17))\n50000000000000000\n\n## But not by the Pool, triggering a revert at this line\n> vars.profit = vars.sharesToAssets.sub(vars.currentAllocated);\n```\n\n\n#### Mocks Used\n\n#### ActivePool.sol\n\n```solidity\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport {ReaperVaultV2} from \"./ReaperVaultV2.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n\ncontract MockActivePool {\n    using SafeMath for uint256;\n\n\n    address immutable collateral;\n\n    mapping(address => uint256) public collAmount;\n    mapping(address => uint256) public yieldingPercentage; // collateral => % to use for yield farming (in BPS, <= 10k)\n    mapping(address => uint256) public yieldingAmount; // collateral => actual wei amount being used for yield farming\n    mapping(address => address) public yieldGenerator; // collateral => corresponding ERC4626 vault\n    mapping(address => uint256) public yieldClaimThreshold; // collateral => minimum wei amount of yield to claim and redistribute\n\n    uint256 public yieldingPercentageDrift = 100; // rebalance iff % is off by more than 100 BPS\n\n    // Yield distribution params, must add up to 10k\n    uint256 public yieldSplitTreasury = 20_00; // amount of yield to direct to treasury in BPS\n    uint256 public yieldSplitSP = 40_00; // amount of yield to direct to stability pool in BPS\n    uint256 public yieldSplitStaking = 40_00; // amount of yield to direct to OATH Stakers in BPS\n\n    // Mock addresses, unused\n    address public treasuryAddress = address(1);\n    address public stabilityPoolAddress = address(2);\n    address public lqtyStakingAddress = address(3);\n\n    constructor(\n        address _collateral,\n        uint256 _yieldingPercentage,\n        address _yieldGenerator,\n        uint256 _yieldClaimThreshold\n    ) {\n        collateral = _collateral;\n        yieldingPercentage[_collateral] = _yieldingPercentage;\n        yieldGenerator[_collateral] = _yieldGenerator;\n        yieldClaimThreshold[_collateral] = _yieldClaimThreshold;\n    }\n\n    function depositColl(uint256 amount) external {\n      ERC20(collateral).transferFrom(msg.sender, address(this), amount);\n      collAmount[collateral] += amount;\n    }\n\n    function manualRebalance(address _collateral, uint256 _simulatedAmountLeavingPool) external {\n        _rebalance(_collateral, _simulatedAmountLeavingPool);\n    }\n\n    struct LocalVariables_rebalance {\n        uint256 currentAllocated;\n        ReaperVaultV2 yieldGenerator;\n        uint256 ownedShares;\n        uint256 sharesToAssets;\n        uint256 profit;\n        uint256 finalBalance;\n        uint256 percentOfFinalBal;\n        uint256 yieldingPercentage;\n        uint256 toDeposit;\n        uint256 toWithdraw;\n        uint256 yieldingAmount;\n        uint256 finalYieldingAmount;\n        int256 netAssetMovement;\n        uint256 treasurySplit;\n        uint256 stakingSplit;\n        uint256 stabilityPoolSplit;\n    }\n\n    function _rebalance(address _collateral, uint256 _amountLeavingPool) internal {\n        LocalVariables_rebalance memory vars;\n\n        // how much has been allocated as per our internal records?\n        vars.currentAllocated = yieldingAmount[_collateral];\n\n        // what is the present value of our shares?\n        vars.yieldGenerator = ReaperVaultV2(yieldGenerator[_collateral]);\n        vars.ownedShares = vars.yieldGenerator.balanceOf(address(this));\n        vars.sharesToAssets = vars.yieldGenerator.convertToAssets(vars.ownedShares);\n\n        // if we have profit that's more than the threshold, record it for withdrawal and redistribution\n        vars.profit = vars.sharesToAssets.sub(vars.currentAllocated);\n        if (vars.profit < yieldClaimThreshold[_collateral]) {\n            vars.profit = 0;\n        }\n\n        // what % of the final pool balance would the current allocation be?\n        vars.finalBalance = collAmount[_collateral].sub(_amountLeavingPool);\n        vars.percentOfFinalBal =\n            vars.finalBalance == 0 ? type(uint256).max : vars.currentAllocated.mul(10_000).div(vars.finalBalance);\n\n        // if abs(percentOfFinalBal - yieldingPercentage) > drift, we will need to deposit more or withdraw some\n        vars.yieldingPercentage = yieldingPercentage[_collateral];\n        vars.finalYieldingAmount = vars.finalBalance.mul(vars.yieldingPercentage).div(10_000);\n        vars.yieldingAmount = yieldingAmount[_collateral];\n        if (\n            vars.percentOfFinalBal > vars.yieldingPercentage\n                && vars.percentOfFinalBal.sub(vars.yieldingPercentage) > yieldingPercentageDrift\n        ) {\n            // we will end up overallocated, withdraw some\n            vars.toWithdraw = vars.currentAllocated.sub(vars.finalYieldingAmount);\n            vars.yieldingAmount = vars.yieldingAmount.sub(vars.toWithdraw);\n            yieldingAmount[_collateral] = vars.yieldingAmount;\n        } else if (\n            vars.percentOfFinalBal < vars.yieldingPercentage\n                && vars.yieldingPercentage.sub(vars.percentOfFinalBal) > yieldingPercentageDrift\n        ) {\n            // we will end up underallocated, deposit more\n            vars.toDeposit = vars.finalYieldingAmount.sub(vars.currentAllocated);\n            vars.yieldingAmount = vars.yieldingAmount.add(vars.toDeposit);\n            yieldingAmount[_collateral] = vars.yieldingAmount;\n        }\n\n        // + means deposit, - means withdraw\n        vars.netAssetMovement = int256(vars.toDeposit) - int256(vars.toWithdraw) - int256(vars.profit);\n        if (vars.netAssetMovement > 0) {\n            ERC20(_collateral).approve(yieldGenerator[_collateral], uint256(vars.netAssetMovement));\n            ReaperVaultV2(yieldGenerator[_collateral]).deposit(uint256(vars.netAssetMovement), address(this));\n        } else if (vars.netAssetMovement < 0) {\n            ReaperVaultV2(yieldGenerator[_collateral]).withdraw(\n                uint256(-vars.netAssetMovement), address(this), address(this)\n            );\n        }\n\n        // if we recorded profit, recalculate it for precision and distribute\n        if (vars.profit != 0) {\n            // profit is ultimately (coll at hand) + (coll allocated to yield generator) - (recorded total coll Amount in pool)\n            vars.profit =\n                ERC20(_collateral).balanceOf(address(this)).add(vars.yieldingAmount).sub(collAmount[_collateral]);\n            if (vars.profit != 0) {\n                // distribute to treasury, staking pool, and stability pool\n                vars.treasurySplit = vars.profit.mul(yieldSplitTreasury).div(10_000);\n                if (vars.treasurySplit != 0) {\n                    ERC20(_collateral).transfer(treasuryAddress, vars.treasurySplit);\n                }\n\n                vars.stakingSplit = vars.profit.mul(yieldSplitStaking).div(10_000);\n                if (vars.stakingSplit != 0) {\n                    ERC20(_collateral).transfer(lqtyStakingAddress, vars.stakingSplit);\n                }\n\n                vars.stabilityPoolSplit = vars.profit.sub(vars.treasurySplit.add(vars.stakingSplit));\n                if (vars.stabilityPoolSplit != 0) {\n                    ERC20(_collateral).transfer(stabilityPoolAddress, vars.stabilityPoolSplit);\n                }\n            }\n        }\n    }\n}\n\n```\n\n#### ReaperVaultV2.sol\n\n```solidity\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\ncontract ReaperVaultV2 is ERC20, AccessControlEnumerable {\n    uint256 totalAllocated = 0;\n\n    IERC20Metadata public immutable token;\n\n    constructor(address _token) ERC20(\"test\", \"TEST\") {\n        token = IERC20Metadata(_token);\n    }\n\n    function triggerLoss(uint256 amt) external {\n        token.transfer(address(1337), amt);\n    }\n\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares) {\n        shares = _deposit(assets, receiver);\n    }\n\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares) {\n        revert(\"No op\");\n    }\n\n    function convertToAssets(uint256 shares) public view returns (uint256 assets) {\n        if (totalSupply() == 0) return shares;\n        return (shares * _freeFunds()) / totalSupply();\n    }\n\n    function _deposit(uint256 _amount, address _receiver) internal returns (uint256 shares) {\n        require(_amount != 0, \"Invalid amount\");\n        uint256 pool = balance();\n\n        uint256 freeFunds = _freeFunds();\n        uint256 balBefore = token.balanceOf(address(this));\n        token.transferFrom(msg.sender, address(this), _amount);\n        uint256 balAfter = token.balanceOf(address(this));\n        _amount = balAfter - balBefore;\n        if (totalSupply() == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount * totalSupply()) / freeFunds; // use \"freeFunds\" instead of \"pool\"\n        }\n        _mint(_receiver, shares);\n    }\n\n    function balance() public view returns (uint256) {\n        return token.balanceOf(address(this)) + totalAllocated;\n    }\n\n    // No harvest, so it's not going to make a difference\n    function _freeFunds() public view returns (uint256) {\n        return balance();\n    }\n}\n\n```\n\n#### MockToken.sol\n\n```solidity\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockToken is ERC20 {\n  constructor() ERC20(\"Mock\", \"Mock\"){\n    _mint(msg.sender, 1000e18);\n  }\n}\n```\n\n\n### Remediation Steps\n\nA slashing mechanism would need to be added to account for a loss.\n\nThis should be fairly involved as to not create gotchas.\n\nIntuitively, I believe, that the funds in the activePool would need to be mapped against the funds invested in Vaults as to reconcile the \"deposited value\" with the \"slashed value\".\n\nAlternatively, for the time being, a \"ShortFall\" fund could be instituted, fully knowing that if something goes wrong, the fund will have to cover the loss",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-02-ethos-reserve-contest",
  "Code": [
    {
      "filename": "Ethos-Core/contracts/ActivePool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.6.11;\n\nimport './Interfaces/IActivePool.sol';\nimport \"./Interfaces/ICollateralConfig.sol\";\nimport './Interfaces/IDefaultPool.sol';\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/ILQTYStaking.sol\";\nimport \"./Interfaces/IStabilityPool.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/CheckContract.sol\";\nimport \"./Dependencies/console.sol\";\nimport \"./Dependencies/SafeERC20.sol\";\nimport \"./Dependencies/IERC4626.sol\";\n\n/*\n * The Active Pool holds the collateral and LUSD debt for each collateral (but not LUSD tokens) for all active troves.\n *\n * When a trove is liquidated, it's collateral and LUSD debt are transferred from the Active Pool, to either the\n * Stability Pool, the Default Pool, or both, depending on the liquidation conditions.\n *\n */\ncontract ActivePool is Ownable, CheckContract, IActivePool {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    string constant public NAME = \"ActivePool\";\n\n    bool public addressesSet = false;\n    address public collateralConfigAddress;\n    address public borrowerOperationsAddress;\n    address public troveManagerAddress;\n    address public stabilityPoolAddress;\n    address public defaultPoolAddress;\n    address public collSurplusPoolAddress;\n    address public treasuryAddress;\n    address public lqtyStakingAddress;\n    mapping (address => uint256) internal collAmount;  // collateral => amount tracker\n    mapping (address => uint256) internal LUSDDebt;  // collateral => corresponding debt tracker\n\n    mapping (address => uint256) public yieldingPercentage; // collateral => % to use for yield farming (in BPS, <= 10k)\n    mapping (address => uint256) public yieldingAmount; // collateral => actual wei amount being used for yield farming\n    mapping (address => address) public yieldGenerator; // collateral => corresponding ERC4626 vault\n    mapping (address => uint256) public yieldClaimThreshold; // collateral => minimum wei amount of yield to claim and redistribute\n    \n    uint256 public yieldingPercentageDrift = 100; // rebalance iff % is off by more than 100 BPS\n\n    // Yield distribution params, must add up to 10k\n    uint256 public yieldSplitTreasury = 20_00; // amount of yield to direct to treasury in BPS\n    uint256 public yieldSplitSP = 40_00; // amount of yield to direct to stability pool in BPS\n    uint256 public yieldSplitStaking = 40_00; // amount of yield to direct to OATH Stakers in BPS\n\n    // --- Events ---\n\n    event CollateralConfigAddressChanged(address _newCollateralConfigAddress);\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event ActivePoolLUSDDebtUpdated(address _collateral, uint _LUSDDebt);\n    event ActivePoolCollateralBalanceUpdated(address _collateral, uint _amount);\n    event YieldingPercentageUpdated(address _collateral, uint256 _bps);\n    event YieldingPercentageDriftUpdated(uint256 _driftBps);\n    event YieldClaimThresholdUpdated(address _collateral, uint256 _threshold);\n    event YieldDistributionParamsUpdated(uint256 _treasurySplit, uint256 _SPSplit, uint256 _stakingSplit);\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _collateralConfigAddress,\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _stabilityPoolAddress,\n        address _defaultPoolAddress,\n        address _collSurplusPoolAddress,\n        address _treasuryAddress,\n        address _lqtyStakingAddress,\n        address[] calldata _erc4626vaults\n    )\n        external\n        onlyOwner\n    {\n        require(!addressesSet, \"Can call setAddresses only once\");\n\n        checkContract(_collateralConfigAddress);\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        require(_treasuryAddress != address(0), \"Treasury cannot be 0 address\");\n        checkContract(_lqtyStakingAddress);\n\n        collateralConfigAddress = _collateralConfigAddress;\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        troveManagerAddress = _troveManagerAddress;\n        stabilityPoolAddress = _stabilityPoolAddress;\n        defaultPoolAddress = _defaultPoolAddress;\n        collSurplusPoolAddress = _collSurplusPoolAddress;\n        treasuryAddress = _treasuryAddress;\n        lqtyStakingAddress = _lqtyStakingAddress;\n\n        address[] memory collaterals = ICollateralConfig(collateralConfigAddress).getAllowedCollaterals();\n        uint256 numCollaterals = collaterals.length;\n        require(numCollaterals == _erc4626vaults.length, \"Vaults array length must match number of collaterals\");\n        for(uint256 i = 0; i < numCollaterals; i++) {\n            address collateral = collaterals[i];\n            address vault = _erc4626vaults[i];\n            require(IERC4626(vault).asset() == collateral, \"Vault asset must be collateral\");\n            yieldGenerator[collateral] = vault;\n        }\n\n        emit CollateralConfigAddressChanged(_collateralConfigAddress);\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n\n        addressesSet = true;\n    }\n\n    function setYieldingPercentage(address _collateral, uint256 _bps) external onlyOwner {\n        _requireValidCollateralAddress(_collateral);\n        require(_bps <= 10_000, \"Invalid BPS value\");\n        yieldingPercentage[_collateral] = _bps;\n        emit YieldingPercentageUpdated(_collateral, _bps);\n    }\n\n    function setYieldingPercentageDrift(uint256 _driftBps) external onlyOwner {\n        require(_driftBps <= 500, \"Exceeds max allowed value of 500 BPS\");\n        yieldingPercentageDrift = _driftBps;\n        emit YieldingPercentageDriftUpdated(_driftBps);\n    }\n\n    function setYieldClaimThreshold(address _collateral, uint256 _threshold) external onlyOwner {\n        _requireValidCollateralAddress(_collateral);\n        yieldClaimThreshold[_collateral] = _threshold;\n        emit YieldClaimThresholdUpdated(_collateral, _threshold);\n    }\n\n    function setYieldDistributionParams(uint256 _treasurySplit, uint256 _SPSplit, uint256 _stakingSplit) external onlyOwner {\n        require(_treasurySplit + _SPSplit + _stakingSplit == 10_000, \"Splits must add up to 10000 BPS\");\n        yieldSplitTreasury = _treasurySplit;\n        yieldSplitSP = _SPSplit;\n        yieldSplitStaking = _stakingSplit;\n        emit YieldDistributionParamsUpdated(_treasurySplit, _SPSplit, _stakingSplit);\n    }\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    /*\n    * Returns the collAmount state variable.\n    *\n    *Not necessarily equal to the the contract's raw collateral balance - collateral can be forcibly sent to contracts.\n    */\n    function getCollateral(address _collateral) external view override returns (uint) {\n        _requireValidCollateralAddress(_collateral);\n        return collAmount[_collateral];\n    }\n\n    function getLUSDDebt(address _collateral) external view override returns (uint) {\n        _requireValidCollateralAddress(_collateral);\n        return LUSDDebt[_collateral];\n    }\n\n    // --- Pool functionality ---\n\n    function sendCollateral(address _collateral, address _account, uint _amount) external override {\n        _requireValidCollateralAddress(_collateral);\n        _requireCallerIsBOorTroveMorSP();\n        _rebalance(_collateral, _amount);\n        collAmount[_collateral] = collAmount[_collateral].sub(_amount);\n        emit ActivePoolCollateralBalanceUpdated(_collateral, collAmount[_collateral]);\n        emit CollateralSent(_collateral, _account, _amount);\n\n        if (_account == defaultPoolAddress) {\n            IERC20(_collateral).safeIncreaseAllowance(defaultPoolAddress, _amount);\n            IDefaultPool(defaultPoolAddress).pullCollateralFromActivePool(_collateral, _amount);\n        } else if (_account == collSurplusPoolAddress) {\n            IERC20(_collateral).safeIncreaseAllowance(collSurplusPoolAddress, _amount);\n            ICollSurplusPool(collSurplusPoolAddress).pullCollateralFromActivePool(_collateral, _amount);\n        } else {\n            IERC20(_collateral).safeTransfer(_account, _amount);\n        }\n    }\n\n    function increaseLUSDDebt(address _collateral, uint _amount) external override {\n        _requireValidCollateralAddress(_collateral);\n        _requireCallerIsBOorTroveM();\n        LUSDDebt[_collateral] = LUSDDebt[_collateral].add(_amount);\n        ActivePoolLUSDDebtUpdated(_collateral, LUSDDebt[_collateral]);\n    }\n\n    function decreaseLUSDDebt(address _collateral, uint _amount) external override {\n        _requireValidCollateralAddress(_collateral);\n        _requireCallerIsBOorTroveMorSP();\n        LUSDDebt[_collateral] = LUSDDebt[_collateral].sub(_amount);\n        ActivePoolLUSDDebtUpdated(_collateral, LUSDDebt[_collateral]);\n    }\n\n    function pullCollateralFromBorrowerOperationsOrDefaultPool(address _collateral, uint _amount) external override {\n        _requireValidCollateralAddress(_collateral);\n        _requireCallerIsBorrowerOperationsOrDefaultPool();\n        collAmount[_collateral] = collAmount[_collateral].add(_amount);\n        emit ActivePoolCollateralBalanceUpdated(_collateral, collAmount[_collateral]);\n\n        IERC20(_collateral).safeTransferFrom(msg.sender, address(this), _amount);\n        _rebalance(_collateral, 0);\n    }\n\n    function manualRebalance(address _collateral, uint256 _simulatedAmountLeavingPool) external onlyOwner {\n        _requireValidCollateralAddress(_collateral);\n        _rebalance(_collateral, _simulatedAmountLeavingPool);\n    }\n\n    // Due to \"stack too deep\" error\n    struct LocalVariables_rebalance {\n        uint256 currentAllocated;\n        IERC4626 yieldGenerator;\n        uint256 ownedShares;\n        uint256 sharesToAssets;\n        uint256 profit;\n        uint256 finalBalance;\n        uint256 percentOfFinalBal;\n        uint256 yieldingPercentage;\n        uint256 toDeposit;\n        uint256 toWithdraw;\n        uint256 yieldingAmount;\n        uint256 finalYieldingAmount;\n        int256 netAssetMovement;\n        uint256 treasurySplit;\n        uint256 stakingSplit;\n        uint256 stabilityPoolSplit;\n    }\n\n    function _rebalance(address _collateral, uint256 _amountLeavingPool) internal {\n        LocalVariables_rebalance memory vars;\n\n        // how much has been allocated as per our internal records?\n        vars.currentAllocated = yieldingAmount[_collateral];\n        \n        // what is the present value of our shares?\n        vars.yieldGenerator = IERC4626(yieldGenerator[_collateral]);\n        vars.ownedShares = vars.yieldGenerator.balanceOf(address(this));\n        vars.sharesToAssets = vars.yieldGenerator.convertToAssets(vars.ownedShares);\n\n        // if we have profit that's more than the threshold, record it for withdrawal and redistribution\n        vars.profit = vars.sharesToAssets.sub(vars.currentAllocated);\n        if (vars.profit < yieldClaimThreshold[_collateral]) {\n            vars.profit = 0;\n        }\n        \n        // what % of the final pool balance would the current allocation be?\n        vars.finalBalance = collAmount[_collateral].sub(_amountLeavingPool);\n        vars.percentOfFinalBal = vars.finalBalance == 0 ? uint256(-1) : vars.currentAllocated.mul(10_000).div(vars.finalBalance);\n\n        // if abs(percentOfFinalBal - yieldingPercentage) > drift, we will need to deposit more or withdraw some\n        vars.yieldingPercentage = yieldingPercentage[_collateral];\n        vars.finalYieldingAmount = vars.finalBalance.mul(vars.yieldingPercentage).div(10_000);\n        vars.yieldingAmount = yieldingAmount[_collateral];\n        if (vars.percentOfFinalBal > vars.yieldingPercentage && vars.percentOfFinalBal.sub(vars.yieldingPercentage) > yieldingPercentageDrift) {\n            // we will end up overallocated, withdraw some\n            vars.toWithdraw = vars.currentAllocated.sub(vars.finalYieldingAmount);\n            vars.yieldingAmount = vars.yieldingAmount.sub(vars.toWithdraw);\n            yieldingAmount[_collateral] = vars.yieldingAmount;\n        } else if(vars.percentOfFinalBal < vars.yieldingPercentage && vars.yieldingPercentage.sub(vars.percentOfFinalBal) > yieldingPercentageDrift) {\n            // we will end up underallocated, deposit more\n            vars.toDeposit = vars.finalYieldingAmount.sub(vars.currentAllocated);\n            vars.yieldingAmount = vars.yieldingAmount.add(vars.toDeposit);\n            yieldingAmount[_collateral] = vars.yieldingAmount;\n        }\n\n        // + means deposit, - means withdraw\n        vars.netAssetMovement = int256(vars.toDeposit) - int256(vars.toWithdraw) - int256(vars.profit);\n        if (vars.netAssetMovement > 0) {\n            IERC20(_collateral).safeIncreaseAllowance(yieldGenerator[_collateral], uint256(vars.netAssetMovement));\n            IERC4626(yieldGenerator[_collateral]).deposit(uint256(vars.netAssetMovement), address(this));\n        } else if (vars.netAssetMovement < 0) {\n            IERC4626(yieldGenerator[_collateral]).withdraw(uint256(-vars.netAssetMovement), address(this), address(this));\n        }\n\n        // if we recorded profit, recalculate it for precision and distribute\n        if (vars.profit != 0) {\n            // profit is ultimately (coll at hand) + (coll allocated to yield generator) - (recorded total coll Amount in pool)\n            vars.profit = IERC20(_collateral).balanceOf(address(this)).add(vars.yieldingAmount).sub(collAmount[_collateral]);\n            if (vars.profit != 0) {\n                // distribute to treasury, staking pool, and stability pool\n                vars.treasurySplit = vars.profit.mul(yieldSplitTreasury).div(10_000);\n                if (vars.treasurySplit != 0) {\n                    IERC20(_collateral).safeTransfer(treasuryAddress, vars.treasurySplit);\n                }\n\n                vars.stakingSplit = vars.profit.mul(yieldSplitStaking).div(10_000);\n                if (vars.stakingSplit != 0) {\n                    IERC20(_collateral).safeTransfer(lqtyStakingAddress, vars.stakingSplit);\n                    ILQTYStaking(lqtyStakingAddress).increaseF_Collateral(_collateral, vars.stakingSplit);\n                }\n\n                vars.stabilityPoolSplit = vars.profit.sub(vars.treasurySplit.add(vars.stakingSplit));\n                if (vars.stabilityPoolSplit != 0) {\n                    IERC20(_collateral).safeTransfer(stabilityPoolAddress, vars.stabilityPoolSplit);\n                    IStabilityPool(stabilityPoolAddress).updateRewardSum(_collateral, vars.stabilityPoolSplit);   \n                }\n            }\n        }\n    }\n\n    // --- 'require' functions ---\n\n    function _requireValidCollateralAddress(address _collateral) internal view {\n        require(\n            ICollateralConfig(collateralConfigAddress).isCollateralAllowed(_collateral),\n            \"Invalid collateral address\"\n        );\n    }\n\n    function _requireCallerIsBorrowerOperationsOrDefaultPool() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress ||\n            msg.sender == defaultPoolAddress,\n            \"ActivePool: Caller is neither BO nor Default Pool\");\n    }\n\n    function _requireCallerIsBOorTroveMorSP() internal view {\n        address redemptionHelper = address(ITroveManager(troveManagerAddress).redemptionHelper());\n        require(\n            msg.sender == borrowerOperationsAddress ||\n            msg.sender == troveManagerAddress ||\n            msg.sender == redemptionHelper ||\n            msg.sender == stabilityPoolAddress,\n            \"ActivePool: Caller is neither BorrowerOperations nor TroveManager nor StabilityPool\");\n    }\n\n    function _requireCallerIsBOorTroveM() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress ||\n            msg.sender == troveManagerAddress,\n            \"ActivePool: Caller is neither BorrowerOperations nor TroveManager\");\n    }\n}"
    }
  ]
}