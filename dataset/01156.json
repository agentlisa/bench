{
  "Title": "Code Redundancy",
  "Content": "Throughout the codebase, there are multiple instances of code redundancy, which is error-prone and hinders the codebase's readability:\n\n\n* The [`L1ScrollMessenger`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/L1ScrollMessenger.sol#L56-L68) and [`ScrollGatewayBase`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/libraries/gateway/ScrollGatewayBase.sol#L38-L50) contracts implement a `nonReentrant` modifier. Instead, consider utilizing the [`ReentrancyGuardUpgradeable` contract](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/release-v4.9/contracts/security/ReentrancyGuardUpgradeable.sol) of the OpenZeppelin library which is a dependency in use. The same holds for the [`OwnableBase` contract](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/libraries/common/OwnableBase.sol) and OpenZeppelin's [`Ownable` contract](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/merge/release-v4.9/contracts/access/Ownable.sol). The reimplementation of such safety mechanisms is generally discouraged. In both cases, make sure to initialize the contracts properly if they are used for upgradeable contracts.\n* The [`IERC20Metadata` interface](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/interfaces/IERC20Metadata.sol#L5) could also be used from the [OpenZeppelin library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.9/contracts/token/ERC20/extensions/IERC20Metadata.sol).\n* The [`IScrollERC20`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/libraries/token/IScrollERC20.sol#L11) and [`IScrollERC20Upgradeable`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/libraries/token/IScrollERC20Upgradeable.sol#L11) interfaces are the same interface - consider removing one of them.\n* The [`isContract` function](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/libraries/token/ScrollStandardERC20.sol#L74) of the `ScrollStandardERC20` contract could also be realized with `address.code.length > 0`. For better gas efficiency, it is recommended to use this with a Solidity version higher than 0.8.1.\n* The [`L1ScrollMessenger`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/L1ScrollMessenger.sol#L221) and [`L2ScrollMessenger`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/L2ScrollMessenger.sol#L259) both implement the `setPause` function but inherit from [`ScrollMessengerBase`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/libraries/gateway/ScrollGatewayBase.sol). Consider moving the `setPause` function to the base contract.\n* The [`onlyMessenger` modifier](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/libraries/gateway/ScrollGatewayBase.sol#L52) of the `ScrollGatewayBase` contract is unused. Consider removing it.\n\n\nConsider applying these code changes to improve the quality of the codebase. Make sure to have all of these changes tested with an extensive test suite.\n\n\n***Update:** Acknowledged, not resolved. The Scroll team stated:*\n\n\n\n> *This will be fixed later if we have more bandwidth.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/L1/L1ScrollMessenger.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport {IScrollChain} from \"./rollup/IScrollChain.sol\";\nimport {IL1MessageQueue} from \"./rollup/IL1MessageQueue.sol\";\nimport {IL1ScrollMessenger} from \"./IL1ScrollMessenger.sol\";\nimport {ScrollConstants} from \"../libraries/constants/ScrollConstants.sol\";\nimport {IScrollMessenger} from \"../libraries/IScrollMessenger.sol\";\nimport {ScrollMessengerBase} from \"../libraries/ScrollMessengerBase.sol\";\nimport {AddressAliasHelper} from \"../libraries/common/AddressAliasHelper.sol\";\nimport {WithdrawTrieVerifier} from \"../libraries/verifier/WithdrawTrieVerifier.sol\";\n\n// solhint-disable avoid-low-level-calls\n\n/// @title L1ScrollMessenger\n/// @notice The `L1ScrollMessenger` contract can:\n///\n/// 1. send messages from layer 1 to layer 2;\n/// 2. relay messages from layer 2 layer 1;\n/// 3. replay failed message by replacing the gas limit;\n/// 4. drop expired message due to sequencer problems.\n///\n/// @dev All deposited Ether (including `WETH` deposited throng `L1WETHGateway`) will locked in\n/// this contract.\ncontract L1ScrollMessenger is PausableUpgradeable, ScrollMessengerBase, IL1ScrollMessenger {\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from relay id to relay status.\n    mapping(bytes32 => bool) public isL1MessageRelayed;\n\n    /// @notice Mapping from L1 message hash to sent status.\n    mapping(bytes32 => bool) public isL1MessageSent;\n\n    /// @notice Mapping from L2 message hash to a boolean value indicating if the message has been successfully executed.\n    mapping(bytes32 => bool) public isL2MessageExecuted;\n\n    /// @notice The address of Rollup contract.\n    address public rollup;\n\n    /// @notice The address of L1MessageQueue contract.\n    address public messageQueue;\n\n    // @note move to ScrollMessengerBase in next big refactor\n    /// @dev The status of for non-reentrant check.\n    uint256 private _lock_status;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_lock_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _lock_status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _lock_status = _NOT_ENTERED;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @notice Initialize the storage of L1ScrollMessenger.\n    /// @param _counterpart The address of L2ScrollMessenger contract in L2.\n    /// @param _feeVault The address of fee vault, which will be used to collect relayer fee.\n    /// @param _rollup The address of ScrollChain contract.\n    /// @param _messageQueue The address of L1MessageQueue contract.\n    function initialize(\n        address _counterpart,\n        address _feeVault,\n        address _rollup,\n        address _messageQueue\n    ) public initializer {\n        PausableUpgradeable.__Pausable_init();\n        ScrollMessengerBase._initialize(_counterpart, _feeVault);\n\n        rollup = _rollup;\n        messageQueue = _messageQueue;\n\n        // initialize to a nonzero value\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, tx.origin);\n    }\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes calldata _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, _refundAddress);\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function relayMessageWithProof(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _nonce,\n        bytes memory _message,\n        L2MessageProof memory _proof\n    ) external override whenNotPaused {\n        require(\n            xDomainMessageSender == ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER,\n            \"Message is already in execution\"\n        );\n\n        bytes32 _xDomainCalldataHash = keccak256(_encodeXDomainCalldata(_from, _to, _value, _nonce, _message));\n        require(!isL2MessageExecuted[_xDomainCalldataHash], \"Message was already successfully executed\");\n\n        {\n            address _rollup = rollup;\n            require(IScrollChain(_rollup).isBatchFinalized(_proof.batchIndex), \"Batch is not finalized\");\n            bytes32 _messageRoot = IScrollChain(_rollup).withdrawRoots(_proof.batchIndex);\n            require(\n                WithdrawTrieVerifier.verifyMerkleProof(_messageRoot, _xDomainCalldataHash, _nonce, _proof.merkleProof),\n                \"Invalid proof\"\n            );\n        }\n\n        // @note check more `_to` address to avoid attack in the future when we add more gateways.\n        require(_to != messageQueue, \"Forbid to call message queue\");\n        require(_to != address(this), \"Forbid to call self\");\n\n        // @note This usually will never happen, just in case.\n        require(_from != xDomainMessageSender, \"Invalid message sender\");\n\n        xDomainMessageSender = _from;\n        (bool success, ) = _to.call{value: _value}(_message);\n        // reset value to refund gas.\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n\n        if (success) {\n            isL2MessageExecuted[_xDomainCalldataHash] = true;\n            emit RelayedMessage(_xDomainCalldataHash);\n        } else {\n            emit FailedRelayedMessage(_xDomainCalldataHash);\n        }\n\n        bytes32 _relayId = keccak256(abi.encodePacked(_xDomainCalldataHash, msg.sender, block.number));\n        isL1MessageRelayed[_relayId] = true;\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function replayMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _queueIndex,\n        bytes memory _message,\n        uint32 _newGasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused {\n        // We will use a different `queueIndex` for the replaced message. However, the original `queueIndex` or `nonce`\n        // is encoded in the `_message`. We will check the `xDomainCalldata` in layer 2 to avoid duplicated execution.\n        // So, only one message will succeed in layer 2. If one of the message is executed successfully, the other one\n        // will revert with \"Message was already successfully executed\".\n        address _messageQueue = messageQueue;\n        address _counterpart = counterpart;\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_from, _to, _value, _queueIndex, _message);\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        require(isL1MessageSent[_xDomainCalldataHash], \"Provided message has not been enqueued\");\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(_messageQueue).estimateCrossDomainMessageFee(_newGasLimit);\n\n        // charge relayer fee\n        require(msg.value >= _fee, \"Insufficient msg.value for fee\");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}(\"\");\n            require(_success, \"Failed to deduct the fee\");\n        }\n\n        // enqueue the new transaction\n        IL1MessageQueue(_messageQueue).appendCrossDomainMessage(_counterpart, _newGasLimit, _xDomainCalldata);\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}(\"\");\n                require(_success, \"Failed to refund the fee\");\n            }\n        }\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Pause the contract\n    /// @dev This function can only called by contract owner.\n    /// @param _status The pause status to update.\n    function setPause(bool _status) external onlyOwner {\n        if (_status) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function _sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) internal nonReentrant {\n        address _messageQueue = messageQueue; // gas saving\n        address _counterpart = counterpart; // gas saving\n\n        // compute the actual cross domain message calldata.\n        uint256 _messageNonce = IL1MessageQueue(_messageQueue).nextCrossDomainMessageIndex();\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(msg.sender, _to, _value, _messageNonce, _message);\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(_messageQueue).estimateCrossDomainMessageFee(_gasLimit);\n        require(msg.value >= _fee + _value, \"Insufficient msg.value\");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}(\"\");\n            require(_success, \"Failed to deduct the fee\");\n        }\n\n        // append message to L1MessageQueue\n        IL1MessageQueue(_messageQueue).appendCrossDomainMessage(_counterpart, _gasLimit, _xDomainCalldata);\n\n        // record the message hash for future use.\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        // normally this won't happen, since each message has different nonce, but just in case.\n        require(!isL1MessageSent[_xDomainCalldataHash], \"Duplicated message\");\n        isL1MessageSent[_xDomainCalldataHash] = true;\n\n        emit SentMessage(msg.sender, _to, _value, _messageNonce, _gasLimit, _message);\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee - _value;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}(\"\");\n                require(_success, \"Failed to refund the fee\");\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/src/interfaces/IERC20Metadata.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IERC20Metadata {\n    function symbol() external view returns (string memory);\n\n    function name() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}"
    },
    {
      "filename": "contracts/src/libraries/token/IScrollERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\n\n// The recommended ERC20 implementation for bridge token.\n// deployed in L2 when original token is on L1\n// deployed in L1 when original token is on L2\ninterface IScrollERC20 is IERC20, IERC20Permit {\n    /// @notice Return the address of Gateway the token belongs to.\n    function gateway() external view returns (address);\n\n    /// @notice Return the address of counterpart token.\n    function counterpart() external view returns (address);\n\n    /// @dev ERC677 Standard, see https://github.com/ethereum/EIPs/issues/677\n    /// Defi can use this method to transfer L1/L2 token to L2/L1,\n    /// and deposit to L2/L1 contract in one transaction\n    function transferAndCall(\n        address receiver,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool success);\n\n    /// @notice Mint some token to recipient's account.\n    /// @dev Gateway Utilities, only gateway contract can call\n    /// @param _to The address of recipient.\n    /// @param _amount The amount of token to mint.\n    function mint(address _to, uint256 _amount) external;\n\n    /// @notice Mint some token from account.\n    /// @dev Gateway Utilities, only gateway contract can call\n    /// @param _from The address of account to burn token.\n    /// @param _amount The amount of token to mint.\n    function burn(address _from, uint256 _amount) external;\n}"
    },
    {
      "filename": "contracts/src/libraries/token/ScrollStandardERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {ERC20PermitUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\nimport {IScrollERC20Upgradeable} from \"./IScrollERC20Upgradeable.sol\";\nimport {IERC677Receiver} from \"../callbacks/IERC677Receiver.sol\";\n\n/// @notice The `ScrollStandardERC20` is the ERC20 token contract created by\n/// `L2StandardERC20Gateway` when the first time the L1 ERC20 is bridged via\n/// `L1StandardERC20Gateway`.\n/// @dev The reason that `ScrollStandardERC20` inherits `IScrollERC20Upgradeable` is because we need\n/// to use the `initialize` function from the `ERC20PermitUpgradeable` to initialize the ERC20\n/// token. However, the token contract is NOT upgradable afterwards because\n/// `ScrollStandardERC20Factory` uses `Clones` to deploy the `ScrollStandardERC20` contract.\ncontract ScrollStandardERC20 is ERC20PermitUpgradeable, IScrollERC20Upgradeable {\n    /// @inheritdoc IScrollERC20Upgradeable\n    address public override gateway;\n\n    /// @inheritdoc IScrollERC20Upgradeable\n    address public override counterpart;\n\n    uint8 private decimals_;\n\n    modifier onlyGateway() {\n        require(gateway == msg.sender, \"Only Gateway\");\n        _;\n    }\n\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        address _gateway,\n        address _counterpart\n    ) external initializer {\n        __ERC20Permit_init(_name);\n        __ERC20_init(_name, _symbol);\n\n        decimals_ = _decimals;\n        gateway = _gateway;\n        counterpart = _counterpart;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return decimals_;\n    }\n\n    /// @dev ERC677 Standard, see https://github.com/ethereum/EIPs/issues/677\n    /// Defi can use this method to transfer L1/L2 token to L2/L1,\n    /// and deposit to L2/L1 contract in one transaction\n    function transferAndCall(\n        address receiver,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool success) {\n        ERC20Upgradeable.transfer(receiver, amount);\n        if (isContract(receiver)) {\n            contractFallback(receiver, amount, data);\n        }\n        return true;\n    }\n\n    function contractFallback(\n        address to,\n        uint256 value,\n        bytes memory data\n    ) private {\n        IERC677Receiver receiver = IERC677Receiver(to);\n        receiver.onTokenTransfer(msg.sender, value, data);\n    }\n\n    function isContract(address _addr) private view returns (bool hasCode) {\n        uint256 length;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            length := extcodesize(_addr)\n        }\n        return length > 0;\n    }\n\n    /// @inheritdoc IScrollERC20Upgradeable\n    function mint(address _to, uint256 _amount) external onlyGateway {\n        _mint(_to, _amount);\n    }\n\n    /// @inheritdoc IScrollERC20Upgradeable\n    function burn(address _from, uint256 _amount) external onlyGateway {\n        _burn(_from, _amount);\n    }\n}"
    },
    {
      "filename": "contracts/src/L1/L1ScrollMessenger.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport {IScrollChain} from \"./rollup/IScrollChain.sol\";\nimport {IL1MessageQueue} from \"./rollup/IL1MessageQueue.sol\";\nimport {IL1ScrollMessenger} from \"./IL1ScrollMessenger.sol\";\nimport {ScrollConstants} from \"../libraries/constants/ScrollConstants.sol\";\nimport {IScrollMessenger} from \"../libraries/IScrollMessenger.sol\";\nimport {ScrollMessengerBase} from \"../libraries/ScrollMessengerBase.sol\";\nimport {AddressAliasHelper} from \"../libraries/common/AddressAliasHelper.sol\";\nimport {WithdrawTrieVerifier} from \"../libraries/verifier/WithdrawTrieVerifier.sol\";\n\n// solhint-disable avoid-low-level-calls\n\n/// @title L1ScrollMessenger\n/// @notice The `L1ScrollMessenger` contract can:\n///\n/// 1. send messages from layer 1 to layer 2;\n/// 2. relay messages from layer 2 layer 1;\n/// 3. replay failed message by replacing the gas limit;\n/// 4. drop expired message due to sequencer problems.\n///\n/// @dev All deposited Ether (including `WETH` deposited throng `L1WETHGateway`) will locked in\n/// this contract.\ncontract L1ScrollMessenger is PausableUpgradeable, ScrollMessengerBase, IL1ScrollMessenger {\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from relay id to relay status.\n    mapping(bytes32 => bool) public isL1MessageRelayed;\n\n    /// @notice Mapping from L1 message hash to sent status.\n    mapping(bytes32 => bool) public isL1MessageSent;\n\n    /// @notice Mapping from L2 message hash to a boolean value indicating if the message has been successfully executed.\n    mapping(bytes32 => bool) public isL2MessageExecuted;\n\n    /// @notice The address of Rollup contract.\n    address public rollup;\n\n    /// @notice The address of L1MessageQueue contract.\n    address public messageQueue;\n\n    // @note move to ScrollMessengerBase in next big refactor\n    /// @dev The status of for non-reentrant check.\n    uint256 private _lock_status;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_lock_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _lock_status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _lock_status = _NOT_ENTERED;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @notice Initialize the storage of L1ScrollMessenger.\n    /// @param _counterpart The address of L2ScrollMessenger contract in L2.\n    /// @param _feeVault The address of fee vault, which will be used to collect relayer fee.\n    /// @param _rollup The address of ScrollChain contract.\n    /// @param _messageQueue The address of L1MessageQueue contract.\n    function initialize(\n        address _counterpart,\n        address _feeVault,\n        address _rollup,\n        address _messageQueue\n    ) public initializer {\n        PausableUpgradeable.__Pausable_init();\n        ScrollMessengerBase._initialize(_counterpart, _feeVault);\n\n        rollup = _rollup;\n        messageQueue = _messageQueue;\n\n        // initialize to a nonzero value\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, tx.origin);\n    }\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes calldata _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, _refundAddress);\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function relayMessageWithProof(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _nonce,\n        bytes memory _message,\n        L2MessageProof memory _proof\n    ) external override whenNotPaused {\n        require(\n            xDomainMessageSender == ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER,\n            \"Message is already in execution\"\n        );\n\n        bytes32 _xDomainCalldataHash = keccak256(_encodeXDomainCalldata(_from, _to, _value, _nonce, _message));\n        require(!isL2MessageExecuted[_xDomainCalldataHash], \"Message was already successfully executed\");\n\n        {\n            address _rollup = rollup;\n            require(IScrollChain(_rollup).isBatchFinalized(_proof.batchIndex), \"Batch is not finalized\");\n            bytes32 _messageRoot = IScrollChain(_rollup).withdrawRoots(_proof.batchIndex);\n            require(\n                WithdrawTrieVerifier.verifyMerkleProof(_messageRoot, _xDomainCalldataHash, _nonce, _proof.merkleProof),\n                \"Invalid proof\"\n            );\n        }\n\n        // @note check more `_to` address to avoid attack in the future when we add more gateways.\n        require(_to != messageQueue, \"Forbid to call message queue\");\n        require(_to != address(this), \"Forbid to call self\");\n\n        // @note This usually will never happen, just in case.\n        require(_from != xDomainMessageSender, \"Invalid message sender\");\n\n        xDomainMessageSender = _from;\n        (bool success, ) = _to.call{value: _value}(_message);\n        // reset value to refund gas.\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n\n        if (success) {\n            isL2MessageExecuted[_xDomainCalldataHash] = true;\n            emit RelayedMessage(_xDomainCalldataHash);\n        } else {\n            emit FailedRelayedMessage(_xDomainCalldataHash);\n        }\n\n        bytes32 _relayId = keccak256(abi.encodePacked(_xDomainCalldataHash, msg.sender, block.number));\n        isL1MessageRelayed[_relayId] = true;\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function replayMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _queueIndex,\n        bytes memory _message,\n        uint32 _newGasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused {\n        // We will use a different `queueIndex` for the replaced message. However, the original `queueIndex` or `nonce`\n        // is encoded in the `_message`. We will check the `xDomainCalldata` in layer 2 to avoid duplicated execution.\n        // So, only one message will succeed in layer 2. If one of the message is executed successfully, the other one\n        // will revert with \"Message was already successfully executed\".\n        address _messageQueue = messageQueue;\n        address _counterpart = counterpart;\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_from, _to, _value, _queueIndex, _message);\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        require(isL1MessageSent[_xDomainCalldataHash], \"Provided message has not been enqueued\");\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(_messageQueue).estimateCrossDomainMessageFee(_newGasLimit);\n\n        // charge relayer fee\n        require(msg.value >= _fee, \"Insufficient msg.value for fee\");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}(\"\");\n            require(_success, \"Failed to deduct the fee\");\n        }\n\n        // enqueue the new transaction\n        IL1MessageQueue(_messageQueue).appendCrossDomainMessage(_counterpart, _newGasLimit, _xDomainCalldata);\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}(\"\");\n                require(_success, \"Failed to refund the fee\");\n            }\n        }\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Pause the contract\n    /// @dev This function can only called by contract owner.\n    /// @param _status The pause status to update.\n    function setPause(bool _status) external onlyOwner {\n        if (_status) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function _sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) internal nonReentrant {\n        address _messageQueue = messageQueue; // gas saving\n        address _counterpart = counterpart; // gas saving\n\n        // compute the actual cross domain message calldata.\n        uint256 _messageNonce = IL1MessageQueue(_messageQueue).nextCrossDomainMessageIndex();\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(msg.sender, _to, _value, _messageNonce, _message);\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(_messageQueue).estimateCrossDomainMessageFee(_gasLimit);\n        require(msg.value >= _fee + _value, \"Insufficient msg.value\");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}(\"\");\n            require(_success, \"Failed to deduct the fee\");\n        }\n\n        // append message to L1MessageQueue\n        IL1MessageQueue(_messageQueue).appendCrossDomainMessage(_counterpart, _gasLimit, _xDomainCalldata);\n\n        // record the message hash for future use.\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        // normally this won't happen, since each message has different nonce, but just in case.\n        require(!isL1MessageSent[_xDomainCalldataHash], \"Duplicated message\");\n        isL1MessageSent[_xDomainCalldataHash] = true;\n\n        emit SentMessage(msg.sender, _to, _value, _messageNonce, _gasLimit, _message);\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee - _value;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}(\"\");\n                require(_success, \"Failed to refund the fee\");\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/src/libraries/gateway/ScrollGatewayBase.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {IScrollGateway} from \"./IScrollGateway.sol\";\nimport {IScrollMessenger} from \"../IScrollMessenger.sol\";\nimport {IScrollGatewayCallback} from \"../callbacks/IScrollGatewayCallback.sol\";\n\nabstract contract ScrollGatewayBase is IScrollGateway {\n    /*************\n     * Constants *\n     *************/\n\n    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/security/ReentrancyGuard.sol\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @inheritdoc IScrollGateway\n    address public override counterpart;\n\n    /// @inheritdoc IScrollGateway\n    address public override router;\n\n    /// @inheritdoc IScrollGateway\n    address public override messenger;\n\n    /// @dev The status of for non-reentrant check.\n    uint256 private _status;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    modifier onlyMessenger() {\n        require(msg.sender == messenger, \"only messenger can call\");\n        _;\n    }\n\n    modifier onlyCallByCounterpart() {\n        address _messenger = messenger; // gas saving\n        require(msg.sender == _messenger, \"only messenger can call\");\n        require(counterpart == IScrollMessenger(_messenger).xDomainMessageSender(), \"only call by counterpart\");\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    function _initialize(\n        address _counterpart,\n        address _router,\n        address _messenger\n    ) internal {\n        require(_counterpart != address(0), \"zero counterpart address\");\n        require(_messenger != address(0), \"zero messenger address\");\n\n        counterpart = _counterpart;\n        messenger = _messenger;\n\n        // @note: the address of router could be zero, if this contract is GatewayRouter.\n        if (_router != address(0)) {\n            router = _router;\n        }\n\n        // for reentrancy guard\n        _status = _NOT_ENTERED;\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to forward calldata to target contract.\n    /// @param _to The address of contract to call.\n    /// @param _data The calldata passed to the contract.\n    function _doCallback(address _to, bytes memory _data) internal {\n        if (_data.length > 0 && _to.code.length > 0) {\n            IScrollGatewayCallback(_to).onScrollGatewayCallback(_data);\n        }\n    }\n}"
    }
  ]
}