{
  "Title": "[M-05] When calling LeverageMacroBase.doOperation to open a CDP, the POST CALL CHECK may use the wrong cdpId",
  "Content": "\nAfter [LeverageMacroBase.doOperation](https://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/LeverageMacroBase.sol#L118-L124) is used to open a new CDP, there will be a [POST CALL CHECK](https://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/LeverageMacroBase.sol#L169-L183), which is used to check the new CDP. However, the current implementation incorrectly assumes that [the index of the new CDP is the last one](https://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/LeverageMacroBase.sol#L173). In this case, there may be two impacts:\n\n1.  The check that should be passed cannot be passed, causing tx revert and waste of gas.\n2.  The check that should not have been passed was passed, which may result in funds losses from `this` contract or caller.\n\n### Proof of Concept\n\n`doOperation` is used to open a new CDP, and there are roughly three steps: setup for POST CALL CHECK, openCdp, POST CALL CHECK for the created CDP.\n\n```solidity\nFile: packages\\contracts\\contracts\\LeverageMacroBase.sol\n118:     function doOperation(\n119:         FlashLoanType flType,\n120:         uint256 borrowAmount,\n121:         LeverageMacroOperation calldata operation,\n122:         PostOperationCheck postCheckType,\n123:         PostCheckParams calldata checkParams\n124:     ) external {\n......\n139:         uint256 initialCdpIndex;\n140:         if (postCheckType == PostOperationCheck.openCdp) {\n141:             // How to get owner\n142:             // sortedCdps.existCdpOwners(_cdpId);\n143:->           initialCdpIndex = sortedCdps.cdpCountOf(address(this));\n144:         }\n\n......//do the operation\n\n169:         if (postCheckType == PostOperationCheck.openCdp) {\n170:             // How to get owner\n171:             // sortedCdps.existCdpOwners(_cdpId);\n172:             // initialCdpIndex is initialCdpIndex + 1\n173:->           bytes32 cdpId = sortedCdps.cdpOfOwnerByIndex(address(this), initialCdpIndex);.\n174: \n175:             // Check for param details\n176:             ICdpManagerData.Cdp memory cdpInfo = cdpManager.Cdps(cdpId);\n177:->           _doCheckValueType(checkParams.expectedDebt, cdpInfo.debt);\n178:->           _doCheckValueType(checkParams.expectedCollateral, cdpInfo.coll);\n179:             require(\n180:                 cdpInfo.status == checkParams.expectedStatus,\n181:                 \"!LeverageMacroReference: openCDP status check\"\n182:             );\n183:         }\n......\n211:     }\n```\n\nL143, `initialCdpIndex = sortedCdps.cdpCountOf(address(this))`, which [is used to count the number of CDPs](https://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/SortedCdps.sol#L216-L219) already owned by `this`.\n\nL145-168, Creats a CDP, the code here is not helpful in describing the issue and is therefore omitted.\n\nL173, `sortedCdps.cdpOfOwnerByIndex(address(this), initialCdpIndex)` is used to get the id of the initialCdpIndex-th CDP owned by `this`. That's the problem. Because `initialCdpIndex` is the number of CDPs owned before the new CDP was created (from L143), that is to say, the index of the created CDP is considered to be the last one.\n\nLet's look at the code of `cdpOfOwnerByIndex`:\n\n```solidity\nFile: packages\\contracts\\contracts\\SortedCdps.sol\n140:     function cdpOfOwnerByIndex(\n141:         address owner,\n142:         uint256 index\n143:     ) external view override returns (bytes32) {\n144:->       (bytes32 _cdpId, ) = _cdpOfOwnerByIndex(owner, index, dummyId, 0);\n145:         return _cdpId;\n146:     }\n......\n173:     function _cdpOfOwnerByIndex(\n174:         address owner,\n175:         uint256 index,\n176:         bytes32 startNodeId,\n177:         uint maxNodes\n178:     ) internal view returns (bytes32, bool) {\n179:         // walk the list, until we get to the indexed CDP\n180:         // start at the given node or from the tail of list\n181:->       bytes32 _currentCdpId = (startNodeId == dummyId ? data.tail : startNodeId);\n182:->       uint _currentIndex = 0;\n183:         uint i;\n184: \n185:         while (_currentCdpId != dummyId) {\n186:             // if the current CDP is owned by specified owner\n187:             if (getOwnerAddress(_currentCdpId) == owner) {\n188:                 // if the current index of the owner CDP matches specified index\n189:->               if (_currentIndex == index) {\n190:->                   return (_currentCdpId, true);\n191:                 } else {\n192:                     // if not, increment the owner index as we've seen a CDP owned by them\n193:->                   _currentIndex = _currentIndex + 1;\n194:                 }\n195:             }\n196:             ++i;\n197: \n198:             // move to the next CDP in the list\n199:             _currentCdpId = data.nodes[_currentCdpId].prevId;\n200: \n201:             // cut the run if we exceed expected iterations through the loop\n202:             if (maxNodes > 0 && i >= maxNodes) {\n203:                 break;\n204:             }\n205:         }\n206:         // if we reach maximum iteration or end of list\n207:         // without seeing the specified index for the owner\n208:         // then maybe a new pagination is needed\n209:         return (_currentCdpId, false);\n210:     }\n```\n\nL144, `_cdpOfOwnerByIndex(owner, index, dummyId, 0)` is called.\n\nL181, \\_currentCdpId = data.tail due to `startNodeId = dummyId`.\n\nL189-194, If `_currentIndex == index`, the target `cdpId` is found and the loop exits. Otherwise, `_currentIndex` is increased by 1.\n\nTo better describe the problem, consider the following scenario:\n\n`this` already has 1 CDP: A, and the entire linked list currently has 10 CDPs. Its topology is as follows:\n\n```flow\nhead                      tail  \ncdp1->A->cdp2->...->cdp8->cdp9\n```\n\nNew CDP is created via `doOperation`:\n\n1.  `initialCdpIndex = 1`, which is from `sortedCdps.cdpCountOf(address(this))`.\n\n2.  open a new Cdp: B.\n\n3.  The current linked list has 11 CDPs, and its topology is as follows:\n\n    ```flow\n    head                         tail  \n    cdp1->A->cdp2->cdp3->B->...->cdp9\n    ```\n\n4.  `cdpId = sortedCdps.cdpOfOwnerByIndex(address(this), 1)`. **`cdpId` was expected to be B's id, but A's id was returned**.\n\nThe root cause of this case is that the linked list is in descending order of NICR, and **the NICR of the newly created CDP may be lower than the NICR of the already created CDP**. In this case, the wrong `cdpId` will be returned.\n\n### Recommended Mitigation Steps\n\nIn [\\_openCdpCallback](https://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/LeverageMacroBase.sol#L465), `borrowerOperations.openCdp` returns the created `cdpId`, and we should specify a slot to store this value. Afterwards, read this slot directly in POST CALL CHECK and reset it to `byte32(0)`. The slot can be obtained by using a method similar to `keccak256(\"Badger.LeverageMacroBase.OpenCdpId\")`.\n\n**[Alex the Entreprenerd (Badger) confirmed and commented](https://github.com/code-423n4/2023-10-badger-findings/issues/152#issuecomment-1818569092):**\n > Would have liked a coded POC of 2 cdps and the last one not being last.\n> \n> Team says that to find the specific CdpID we would need to use something like this:\n>  \n> `cdpID = sorted.Cdps.toCdpID(msg.sender, block.number, sortedCdps.nextCdpNonce());`\n> \n> The finding seems valid, but I believe it would result in reverts on usage (no loss of funds).<br>\n> And I believe it was missed because the check always works for the first Cdp, it will cause issue for the 2nd cdp onwards.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-badger",
  "Code": [
    {
      "filename": "packages/contracts/contracts/LeverageMacroBase.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport \"./Interfaces/IERC3156FlashLender.sol\";\nimport \"./Interfaces/IEBTCToken.sol\";\nimport \"./Interfaces/ICdpManager.sol\";\nimport \"./Interfaces/ISortedCdps.sol\";\nimport \"./Interfaces/IPriceFeed.sol\";\nimport \"./Dependencies/ICollateralToken.sol\";\nimport {ICdpManagerData} from \"./Interfaces/ICdpManagerData.sol\";\nimport \"./Dependencies/SafeERC20.sol\";\n\ninterface ICdpCdps {\n    function Cdps(bytes32) external view returns (ICdpManagerData.Cdp memory);\n}\n\n/// @title Base implementation of the LeverageMacro\n/// @notice Do not use this contract as a end users\n/// @dev You must extend this contract and override `owner()` to allow this to work:\n/// - As a Clone / Proxy (Not done, prob you'd read `owner` from calldata when using clones-with-immutable-args)\n/// - As a deployed copy (LeverageMacroReference)\n/// - Via delegate call (LeverageMacroDelegateTarget)\n/// @custom:known-issue Due to slippage some dust amounts for all intermediary tokens can be left, since there's no way to ask to sell all available\n\ncontract LeverageMacroBase {\n    using SafeERC20 for IERC20;\n\n    IBorrowerOperations public immutable borrowerOperations;\n    IActivePool public immutable activePool;\n    ICdpCdps public immutable cdpManager;\n    IEBTCToken public immutable ebtcToken;\n    ISortedCdps public immutable sortedCdps;\n    ICollateralToken public immutable stETH;\n    bool internal immutable willSweep;\n\n    bytes32 constant FLASH_LOAN_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    function owner() public virtual returns (address) {\n        revert(\"Must be overridden\");\n    }\n\n    function _assertOwner() internal {\n        // Reference will compare to variable,\n        require(owner() == msg.sender, \"Must be owner\");\n    }\n\n    // Leverage Macro should receive a request and set that data\n    // Then perform the request\n\n    constructor(\n        address _borrowerOperationsAddress,\n        address _activePool,\n        address _cdpManager,\n        address _ebtc,\n        address _coll,\n        address _sortedCdps,\n        bool _sweepToCaller\n    ) {\n        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);\n        activePool = IActivePool(_activePool);\n        cdpManager = ICdpCdps(_cdpManager);\n        ebtcToken = IEBTCToken(_ebtc);\n        stETH = ICollateralToken(_coll);\n        sortedCdps = ISortedCdps(_sortedCdps);\n\n        willSweep = _sweepToCaller;\n    }\n\n    enum FlashLoanType {\n        stETH,\n        eBTC,\n        noFlashloan // Use this to not perform a FL and just `doOperation`\n    }\n\n    enum PostOperationCheck {\n        openCdp,\n        cdpStats,\n        isClosed\n    }\n\n    enum Operator {\n        skip,\n        equal,\n        gte,\n        lte\n    }\n\n    struct CheckValueAndType {\n        uint256 value;\n        Operator operator;\n    }\n\n    struct PostCheckParams {\n        CheckValueAndType expectedDebt;\n        CheckValueAndType expectedCollateral;\n        // Used only if cdpStats || isClosed\n        bytes32 cdpId;\n        // Used only to check status\n        ICdpManagerData.Status expectedStatus; // NOTE: THIS IS SUPERFLUOUS\n    }\n\n    /**\n     * FL Setup\n     *         - Validate Caller\n     *\n     *         FL\n     *         - SwapsBefore\n     *         - Operation\n     *         - SwapsAfter\n     *         - Repay\n     *\n     *         - Post Operation Checks\n     *\n     *         - Sweep\n     */\n    /// @notice Entry point for the Macro\n    function doOperation(\n        FlashLoanType flType,\n        uint256 borrowAmount,\n        LeverageMacroOperation calldata operation,\n        PostOperationCheck postCheckType,\n        PostCheckParams calldata checkParams\n    ) external {\n        _assertOwner();\n\n        // Call FL Here, then the stuff below needs to happen inside the FL\n        if (operation.amountToTransferIn > 0) {\n            IERC20(operation.tokenToTransferIn).safeTransferFrom(\n                msg.sender,\n                address(this),\n                operation.amountToTransferIn\n            );\n        }\n\n        /**\n         * SETUP FOR POST CALL CHECK\n         */\n        uint256 initialCdpIndex;\n        if (postCheckType == PostOperationCheck.openCdp) {\n            // How to get owner\n            // sortedCdps.existCdpOwners(_cdpId);\n            initialCdpIndex = sortedCdps.cdpCountOf(address(this));\n        }\n\n        // Take eBTC or stETH FlashLoan\n        if (flType == FlashLoanType.eBTC) {\n            IERC3156FlashLender(address(borrowerOperations)).flashLoan(\n                IERC3156FlashBorrower(address(this)),\n                address(ebtcToken),\n                borrowAmount,\n                abi.encode(operation)\n            );\n        } else if (flType == FlashLoanType.stETH) {\n            IERC3156FlashLender(address(activePool)).flashLoan(\n                IERC3156FlashBorrower(address(this)),\n                address(stETH),\n                borrowAmount,\n                abi.encode(operation)\n            );\n        } else {\n            // No leverage, just do the operation\n            _handleOperation(operation);\n        }\n\n        /**\n         * POST CALL CHECK FOR CREATION\n         */\n        if (postCheckType == PostOperationCheck.openCdp) {\n            // How to get owner\n            // sortedCdps.existCdpOwners(_cdpId);\n            // initialCdpIndex is initialCdpIndex + 1\n            bytes32 cdpId = sortedCdps.cdpOfOwnerByIndex(address(this), initialCdpIndex);\n\n            // Check for param details\n            ICdpManagerData.Cdp memory cdpInfo = cdpManager.Cdps(cdpId);\n            _doCheckValueType(checkParams.expectedDebt, cdpInfo.debt);\n            _doCheckValueType(checkParams.expectedCollateral, cdpInfo.coll);\n            require(\n                cdpInfo.status == checkParams.expectedStatus,\n                \"!LeverageMacroReference: openCDP status check\"\n            );\n        }\n\n        // Update CDP, Ensure the stats are as intended\n        if (postCheckType == PostOperationCheck.cdpStats) {\n            ICdpManagerData.Cdp memory cdpInfo = cdpManager.Cdps(checkParams.cdpId);\n\n            _doCheckValueType(checkParams.expectedDebt, cdpInfo.debt);\n            _doCheckValueType(checkParams.expectedCollateral, cdpInfo.coll);\n            require(\n                cdpInfo.status == checkParams.expectedStatus,\n                \"!LeverageMacroReference: adjustCDP status check\"\n            );\n        }\n\n        // Post check type: Close, ensure it has the status we want\n        if (postCheckType == PostOperationCheck.isClosed) {\n            ICdpManagerData.Cdp memory cdpInfo = cdpManager.Cdps(checkParams.cdpId);\n\n            require(\n                cdpInfo.status == checkParams.expectedStatus,\n                \"!LeverageMacroReference: closeCDP status check\"\n            );\n        }\n\n        // Sweep here if it's Reference, do not if it's delegate\n        if (willSweep) {\n            sweepToCaller();\n        }\n    }\n\n    /// @notice Sweep away tokens if they are stuck here\n    function sweepToCaller() public {\n        _assertOwner();\n        /**\n         * SWEEP TO CALLER *\n         */\n        // Safe unchecked because known tokens\n        uint256 ebtcBal = ebtcToken.balanceOf(address(this));\n        uint256 collateralBal = stETH.sharesOf(address(this));\n\n        if (ebtcBal > 0) {\n            ebtcToken.transfer(msg.sender, ebtcBal);\n        }\n\n        if (collateralBal > 0) {\n            stETH.transferShares(msg.sender, collateralBal);\n        }\n    }\n\n    /// @notice Transfer an arbitrary token back to you\n    /// @dev If you delegatecall into this, this will transfer the tokens to the caller of the DiamondLike (and not the contract)\n    function sweepToken(address token, uint256 amount) public {\n        _assertOwner();\n\n        IERC20(token).safeTransfer(msg.sender, amount);\n    }\n\n    /// @dev Assumes that\n    ///     >= you prob use this one\n    ///     <= if you don't need >= you go for lte\n    ///     And if you really need eq, it's third\n    function _doCheckValueType(CheckValueAndType memory check, uint256 valueToCheck) internal {\n        if (check.operator == Operator.skip) {\n            // Early return\n            return;\n        } else if (check.operator == Operator.gte) {\n            require(check.value >= valueToCheck, \"!LeverageMacroReference: gte post check\");\n        } else if (check.operator == Operator.lte) {\n            require(check.value <= valueToCheck, \"!LeverageMacroReference: let post check\");\n        } else if (check.operator == Operator.equal) {\n            require(check.value == valueToCheck, \"!LeverageMacroReference: equal post check\");\n        } else {\n            revert(\"Operator not found\");\n        }\n    }\n\n    struct LeverageMacroOperation {\n        address tokenToTransferIn;\n        uint256 amountToTransferIn;\n        SwapOperation[] swapsBefore; // Empty to skip\n        SwapOperation[] swapsAfter; // Empty to skip\n        OperationType operationType; // Open, Close, etc..\n        bytes OperationData; // Generic Operation Data, which we'll decode to use\n    }\n\n    struct SwapOperation {\n        // Swap Data\n        address tokenForSwap;\n        address addressForApprove;\n        uint256 exactApproveAmount;\n        address addressForSwap;\n        bytes calldataForSwap;\n        SwapCheck[] swapChecks; // Empty to skip\n    }\n\n    struct SwapCheck {\n        // Swap Slippage Check\n        address tokenToCheck;\n        uint256 expectedMinOut;\n    }\n\n    enum OperationType {\n        OpenCdpOperation,\n        AdjustCdpOperation,\n        CloseCdpOperation\n    }\n\n    /// @dev Must be memory since we had to decode it\n    function _handleOperation(LeverageMacroOperation memory operation) internal {\n        uint256 beforeSwapsLength = operation.swapsBefore.length;\n        if (beforeSwapsLength > 0) {\n            _doSwaps(operation.swapsBefore);\n        }\n\n        // Based on the type we do stuff\n        if (operation.operationType == OperationType.OpenCdpOperation) {\n            _openCdpCallback(operation.OperationData);\n        } else if (operation.operationType == OperationType.CloseCdpOperation) {\n            _closeCdpCallback(operation.OperationData);\n        } else if (operation.operationType == OperationType.AdjustCdpOperation) {\n            _adjustCdpCallback(operation.OperationData);\n        }\n\n        uint256 afterSwapsLength = operation.swapsAfter.length;\n        if (afterSwapsLength > 0) {\n            _doSwaps(operation.swapsAfter);\n        }\n    }\n\n    // Open\n    struct OpenCdpOperation {\n        // Open CDP For Data\n        uint256 eBTCToMint;\n        bytes32 _upperHint;\n        bytes32 _lowerHint;\n        uint256 stETHToDeposit;\n    }\n\n    // Change leverage or something\n    struct AdjustCdpOperation {\n        bytes32 _cdpId;\n        uint256 _stEthBalanceDecrease;\n        uint256 _EBTCChange;\n        bool _isDebtIncrease;\n        bytes32 _upperHint;\n        bytes32 _lowerHint;\n        uint256 _stEthBalanceIncrease;\n    }\n\n    // Repay and Close\n    struct CloseCdpOperation {\n        bytes32 _cdpId;\n    }\n\n    /// @notice Convenience function to parse bytes into LeverageMacroOperation data\n    function decodeFLData(bytes calldata data) public view returns (LeverageMacroOperation memory) {\n        LeverageMacroOperation memory leverageMacroData = abi.decode(data, (LeverageMacroOperation));\n        return leverageMacroData;\n    }\n\n    /// @notice Proper Flashloan Callback handler\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32) {\n        // Verify we started the FL\n        require(initiator == address(this), \"LeverageMacroReference: wrong initiator for flashloan\");\n\n        // Ensure the caller is the intended contract\n        if (token == address(ebtcToken)) {\n            require(\n                msg.sender == address(borrowerOperations),\n                \"LeverageMacroReference: wrong lender for eBTC flashloan\"\n            );\n        } else {\n            // Enforce that this is either eBTC or stETH\n            require(\n                msg.sender == address(activePool),\n                \"LeverageMacroReference: wrong lender for stETH flashloan\"\n            );\n        }\n\n        // Else a malicious contract, that changes the data would be able to inject a forwarded caller\n\n        // Get the data\n        // We will get the first byte of data for enum an type\n        // The rest of the data we can decode based on the operation type from calldata\n        // Then we can do multiple hooks and stuff\n        LeverageMacroOperation memory operation = decodeFLData(data);\n\n        _handleOperation(operation);\n\n        return FLASH_LOAN_SUCCESS;\n    }\n\n    /// @dev Must be memory since we had to decode it\n    function _doSwaps(SwapOperation[] memory swapData) internal {\n        uint256 swapLength = swapData.length;\n\n        for (uint256 i; i < swapLength; ) {\n            _doSwap(swapData[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Given a SwapOperation\n    ///     Approves the `addressForApprove` for the exact amount\n    ///     Calls `addressForSwap`\n    ///     Resets the approval of `addressForApprove`\n    ///     Performs validation via `_doSwapChecks`\n    function _doSwap(SwapOperation memory swapData) internal {\n        // Ensure call is safe\n        // Block all system contracts\n        _ensureNotSystem(swapData.addressForSwap);\n\n        // Exact approve\n        // Approve can be given anywhere because this is a router, and after call we will delete all approvals\n        IERC20(swapData.tokenForSwap).safeApprove(\n            swapData.addressForApprove,\n            swapData.exactApproveAmount\n        );\n\n        // Call and perform swap\n        // NOTE: Technically approval may be different from target, something to keep in mind\n        // Call target are limited\n        // But technically you could approve w/e you want here, this is fine because the contract is a router and will not hold user funds\n        (bool success, ) = excessivelySafeCall(\n            swapData.addressForSwap,\n            gasleft(),\n            0,\n            0,\n            swapData.calldataForSwap\n        );\n        require(success, \"Call has failed\");\n\n        // Approve back to 0\n        // Enforce exact approval\n        // Can use max because the tokens are OZ\n        // val -> 0 -> 0 -> val means this is safe to repeat since even if full approve is unused, we always go back to 0 after\n        IERC20(swapData.tokenForSwap).safeApprove(swapData.addressForApprove, 0);\n\n        // Do the balance checks after the call to the aggregator\n        _doSwapChecks(swapData.swapChecks);\n    }\n\n    /// @dev Given `SwapCheck` performs validation on the state of this contract\n    ///     A minOut Check\n    function _doSwapChecks(SwapCheck[] memory swapChecks) internal {\n        uint256 length = swapChecks.length;\n        unchecked {\n            for (uint256 i; i < length; ++i) {\n                // > because if you don't want to check for 0, just don't have the check\n                require(\n                    IERC20(swapChecks[i].tokenToCheck).balanceOf(address(this)) >\n                        swapChecks[i].expectedMinOut,\n                    \"LeverageMacroReference: swap check failure!\"\n                );\n            }\n        }\n    }\n\n    /// @dev Prevents doing arbitrary calls to protected targets\n    function _ensureNotSystem(address addy) internal {\n        /// @audit Check and add more if you think it's better\n        require(addy != address(borrowerOperations));\n        require(addy != address(sortedCdps));\n        require(addy != address(activePool));\n        require(addy != address(cdpManager));\n        require(addy != address(this)); // If it could call this it could fake the forwarded caller\n    }\n\n    /// @dev Must be memory since we had to decode it\n    function _openCdpCallback(bytes memory data) internal {\n        OpenCdpOperation memory flData = abi.decode(data, (OpenCdpOperation));\n        /**\n         * Open CDP and Emit event\n         */\n        bytes32 _cdpId = borrowerOperations.openCdp(\n            flData.eBTCToMint,\n            flData._upperHint,\n            flData._lowerHint,\n            flData.stETHToDeposit\n        );\n    }\n\n    /// @dev Must be memory since we had to decode it\n    function _closeCdpCallback(bytes memory data) internal {\n        CloseCdpOperation memory flData = abi.decode(data, (CloseCdpOperation));\n\n        // Initiator must be added by this contract, else it's not trusted\n        borrowerOperations.closeCdp(flData._cdpId);\n    }\n\n    /// @dev Must be memory since we had to decode it\n    function _adjustCdpCallback(bytes memory data) internal {\n        AdjustCdpOperation memory flData = abi.decode(data, (AdjustCdpOperation));\n\n        borrowerOperations.adjustCdpWithColl(\n            flData._cdpId,\n            flData._stEthBalanceDecrease,\n            flData._EBTCChange,\n            flData._isDebtIncrease,\n            flData._upperHint,\n            flData._lowerHint,\n            flData._stEthBalanceIncrease\n        );\n    }\n\n    /// @dev excessivelySafeCall to perform generic calls without getting gas bombed | useful if you don't care about return value\n    /// @notice Credits to: https://github.com/nomad-xyz/ExcessivelySafeCall/blob/main/src/ExcessivelySafeCall.sol\n    function excessivelySafeCall(\n        address _target,\n        uint256 _gas,\n        uint256 _value,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := call(\n                _gas, // gas\n                _target, // recipient\n                _value, // ether value\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n            // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n}"
    },
    {
      "filename": "packages/contracts/contracts/SortedCdps.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./Interfaces/ISortedCdps.sol\";\nimport \"./Interfaces/ICdpManager.sol\";\nimport \"./Interfaces/IBorrowerOperations.sol\";\n\n/*\n * A sorted doubly linked list with nodes sorted in descending order.\n *\n * Nodes map to active Cdps in the system by Id.\n * Nodes are ordered according to their current nominal individual collateral ratio (NICR),\n * which is like the ICR but without the price, i.e., just collateral / debt.\n *\n * The list optionally accepts insert position hints.\n *\n * NICRs are computed dynamically at runtime, and not stored on the Node. This is because NICRs of active Cdps\n * change dynamically as liquidation events occur.\n *\n * The list relies on the fact that liquidation events preserve ordering: a liquidation decreases the NICRs of all active Cdps,\n * but maintains their order. A node inserted based on current NICR will maintain the correct position,\n * relative to it's peers, as rewards accumulate, as long as it's raw collateral and debt have not changed.\n * Thus, Nodes remain sorted by current NICR.\n *\n * Nodes need only be re-inserted upon a CDP operation - when the owner adds or removes collateral or debt\n * to their position.\n *\n * The list is a modification of the following audited SortedDoublyLinkedList:\n * https://github.com/livepeer/protocol/blob/master/contracts/libraries/SortedDoublyLL.sol\n *\n *\n * Changes made in the Liquity implementation:\n *\n * - Keys have been removed from nodes\n *\n * - Ordering checks for insertion are performed by comparing an NICR argument to the current NICR, calculated at runtime.\n *   The list relies on the property that ordering by ICR is maintained as the stETH:BTC price varies.\n *\n * - Public functions with parameters have been made internal to save gas, and given an external wrapper function for external access\n *\n *\n * Changes made in the Ebtc implementation:\n *\n * - Positions are now indexed by Ids, not addresses. Functions to generate Ids are provided.\n *\n * - Added batchRemove functions to optimize redemptions.\n *\n * - Added more O(n) getter functions and pagination-flavor variants, intended for off-chain use.\n */\ncontract SortedCdps is ISortedCdps {\n    string public constant NAME = \"SortedCdps\";\n\n    address public immutable borrowerOperationsAddress;\n\n    ICdpManager public immutable cdpManager;\n\n    uint256 public immutable maxSize;\n\n    uint256 constant ADDRESS_SHIFT = 96; // 8 * 12; Puts the address at leftmost bytes32 position\n    uint256 constant BLOCK_SHIFT = 64; // 8 * 8; Puts the block value after the address\n\n    // Information for a node in the list\n    struct Node {\n        bytes32 nextId; // Id of next node (smaller NICR) in the list\n        bytes32 prevId; // Id of previous node (larger NICR) in the list\n    }\n\n    // Information for the list\n    struct Data {\n        bytes32 head; // Head of the list. Also the node in the list with the largest NICR\n        bytes32 tail; // Tail of the list. Also the node in the list with the smallest NICR\n        uint256 size; // Current size of the list\n        mapping(bytes32 => Node) nodes; // Track the corresponding ids for each node in the list\n    }\n\n    Data public data;\n\n    uint256 public nextCdpNonce;\n    bytes32 public constant dummyId =\n        0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    /// @notice Constructor\n    /// @dev Sets max list size\n    /// @param _size Max number of nodes allowed in the list\n    /// @param _cdpManagerAddress Address of CdpManager contract\n    /// @param _borrowerOperationsAddress Address of BorrowerOperations contract\n    constructor(uint256 _size, address _cdpManagerAddress, address _borrowerOperationsAddress) {\n        if (_size == 0) {\n            _size = type(uint256).max;\n        }\n\n        maxSize = _size;\n\n        cdpManager = ICdpManager(_cdpManagerAddress);\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n    }\n\n    /// @notice Encodes a unique CDP Id from owner, block and nonce\n    /// @dev Inspired https://github.com/balancer-labs/balancer-v2-monorepo/blob/18bd5fb5d87b451cc27fbd30b276d1fb2987b529/pkg/vault/contracts/PoolRegistry.sol\n    /// @param owner Owner address of the CDP\n    /// @param blockHeight Block number when CDP opened\n    /// @param nonce Unique nonce for CDP\n    /// @return Unique bytes32 CDP Id\n    function toCdpId(\n        address owner,\n        uint256 blockHeight,\n        uint256 nonce\n    ) public pure returns (bytes32) {\n        bytes32 serialized;\n\n        serialized |= bytes32(nonce);\n        serialized |= bytes32(blockHeight) << BLOCK_SHIFT; // to accommendate more than 4.2 billion blocks\n        serialized |= bytes32(uint256(uint160(owner))) << ADDRESS_SHIFT;\n\n        return serialized;\n    }\n\n    /// @notice Get owner address of a given CDP, given CdpId.\n    /// @dev The owner address is stored in the first 20 bytes of the CdpId\n    /// @param cdpId cdpId of CDP to get owner of\n    /// @return owner address of the CDP\n    function getOwnerAddress(bytes32 cdpId) public pure override returns (address) {\n        uint256 _tmp = uint256(cdpId) >> ADDRESS_SHIFT;\n        return address(uint160(_tmp));\n    }\n\n    /// @notice Get dummy non-existent CDP Id\n    /// @return Dummy non-existent CDP Id\n    function nonExistId() public pure override returns (bytes32) {\n        return dummyId;\n    }\n\n    /// @notice Find a specific CDP for a given owner, indexed by it's place in the linked list relative to other Cdps owned by the same address\n    /// @notice Reverts if the index exceeds the number of active Cdps owned by the given owner\n    /// @dev Intended for off-chain use, O(n) operation on size of SortedCdps linked list\n    /// @param owner address of CDP owner\n    /// @param index index of CDP, ordered by position in linked list relative to Cdps of the same owner\n    /// @return CDP Id if found\n    function cdpOfOwnerByIndex(\n        address owner,\n        uint256 index\n    ) external view override returns (bytes32) {\n        (bytes32 _cdpId, ) = _cdpOfOwnerByIndex(owner, index, dummyId, 0);\n        return _cdpId;\n    }\n\n    /// @dev a pagination-flavor search (from least ICR to biggest ICR) for CDP owned by given owner and specified index (starting at given CDP)\n    /// @param owner address of CDP owner\n    /// @param index index of CDP, ordered by position in linked list relative to Cdps of the same owner\n    /// @param startNodeId the seach traversal will start at this given CDP instead of the tail of the list\n    /// @param maxNodes the traversal will go through the list by this given maximum limit of number of Cdps\n    /// @return CDP Id if found, else return last seen CDP\n    /// @return True if CDP found, false otherwise\n    function cdpOfOwnerByIdx(\n        address owner,\n        uint256 index,\n        bytes32 startNodeId,\n        uint maxNodes\n    ) external view override returns (bytes32, bool) {\n        return _cdpOfOwnerByIndex(owner, index, startNodeId, maxNodes);\n    }\n\n    /// @notice Get a user CDP by index using pagination\n    /// @dev return EITHER the found CDP owned by given owner & index with a true indicator OR\n    /// @dev current lastly-visited CDP as the startNode for next pagination with a false indicator\n    /// @param owner Owner address to get CDP for\n    /// @param index Index of CDP amongst user's Cdps\n    /// @param startNodeId Start position CDP Id\n    /// @param maxNodes Max number of Cdps to traverse\n    /// @return cdpId The CDP Id if found, otherwise return current lastly-visited CDP as the startNode for next pagination\n    /// @return found True if the CDP was found, false otherwise\n    function _cdpOfOwnerByIndex(\n        address owner,\n        uint256 index,\n        bytes32 startNodeId,\n        uint maxNodes\n    ) internal view returns (bytes32, bool) {\n        // walk the list, until we get to the indexed CDP\n        // start at the given node or from the tail of list\n        bytes32 _currentCdpId = (startNodeId == dummyId ? data.tail : startNodeId);\n        uint _currentIndex = 0;\n        uint i;\n\n        while (_currentCdpId != dummyId) {\n            // if the current CDP is owned by specified owner\n            if (getOwnerAddress(_currentCdpId) == owner) {\n                // if the current index of the owner CDP matches specified index\n                if (_currentIndex == index) {\n                    return (_currentCdpId, true);\n                } else {\n                    // if not, increment the owner index as we've seen a CDP owned by them\n                    _currentIndex = _currentIndex + 1;\n                }\n            }\n            ++i;\n\n            // move to the next CDP in the list\n            _currentCdpId = data.nodes[_currentCdpId].prevId;\n\n            // cut the run if we exceed expected iterations through the loop\n            if (maxNodes > 0 && i >= maxNodes) {\n                break;\n            }\n        }\n        // if we reach maximum iteration or end of list\n        // without seeing the specified index for the owner\n        // then maybe a new pagination is needed\n        return (_currentCdpId, false);\n    }\n\n    /// @notice Get active CDP count for an owner address\n    /// @dev Intended for off-chain use, O(n) operation on size of linked list\n    /// @param owner Owner address to count Cdps for\n    /// @return count Number of active Cdps owned by the address\n    function cdpCountOf(address owner) external view override returns (uint256) {\n        (uint256 _cnt, ) = _cdpCountOf(owner, dummyId, 0);\n        return _cnt;\n    }\n\n    /// @notice a Pagination-flavor search for the count of Cdps owned by given owner\n    /// @notice Starts from a given CdpId in the sorted list, and moves from lowest ICR to highest ICR\n    /// @param startNodeId the count traversal will start at this given CDP instead of the tail of the list\n    /// @param maxNodes the traversal will go through the list by this given maximum limit of number of Cdps\n    /// @return count Number of active Cdps owned by the address in the segment of the list traversed\n    /// @return last seen CDP for the startNode for next pagination\n    function getCdpCountOf(\n        address owner,\n        bytes32 startNodeId,\n        uint maxNodes\n    ) external view override returns (uint256, bytes32) {\n        return _cdpCountOf(owner, startNodeId, maxNodes);\n    }\n\n    /// @dev return the found CDP count owned by given owner with\n    /// @dev current lastly-visited CDP as the startNode for next pagination\n    function _cdpCountOf(\n        address owner,\n        bytes32 startNodeId,\n        uint maxNodes\n    ) internal view returns (uint256, bytes32) {\n        // walk the list, until we get to the count\n        // start at the given node or from the tail of list\n        bytes32 _currentCdpId = (startNodeId == dummyId ? data.tail : startNodeId);\n        uint _ownedCount = 0;\n        uint i = 0;\n\n        while (_currentCdpId != dummyId) {\n            // if the current CDP is owned by specified owner\n            if (getOwnerAddress(_currentCdpId) == owner) {\n                _ownedCount = _ownedCount + 1;\n            }\n            ++i;\n\n            // move to the next CDP in the list\n            _currentCdpId = data.nodes[_currentCdpId].prevId;\n\n            // cut the run if we exceed expected iterations through the loop\n            if (maxNodes > 0 && i >= maxNodes) {\n                break;\n            }\n        }\n        return (_ownedCount, _currentCdpId);\n    }\n\n    /// @notice Get all active Cdps for a given address\n    /// @dev Intended for off-chain use, O(n) operation on size of linked list\n    /// @param owner address of CDP owner\n    /// @return cdps all CdpIds of the specified owner\n    function getCdpsOf(address owner) external view override returns (bytes32[] memory cdps) {\n        // Naive method uses two-pass strategy to determine exactly how many Cdps are owned by owner\n        // This roughly halves the amount of Cdps we can process before relying on pagination or off-chain methods\n        (uint _ownedCount, ) = _cdpCountOf(owner, dummyId, 0);\n        if (_ownedCount > 0) {\n            (bytes32[] memory _allCdps, , ) = _getCdpsOf(owner, dummyId, 0, _ownedCount);\n            cdps = _allCdps;\n        }\n    }\n\n    /// @dev a pagination-flavor search retrieval of (from least ICR to biggest ICR) Cdps owned by given owner (starting at given CDP)\n    /// @param startNodeId the traversal will start at this given CDP instead of the tail of the list\n    /// @param maxNodes the traversal will go through the list by this given maximum limit of number of Cdps\n    /// @return all CdpIds of the specified owner found by search starting at the specified startNodeId for the specified maximum iteration count\n    /// @return found number of Cdp for the owner\n    /// @return starting CdpId for next pagination within current SortedCdps\n    function getAllCdpsOf(\n        address owner,\n        bytes32 startNodeId,\n        uint maxNodes\n    ) external view override returns (bytes32[] memory, uint256, bytes32) {\n        // Naive method uses two-pass strategy to determine exactly how many Cdps are owned by owner\n        // This roughly halves the amount of Cdps we can process before relying on pagination or off-chain methods\n        (uint _ownedCount, ) = _cdpCountOf(owner, startNodeId, maxNodes);\n        return _getCdpsOf(owner, startNodeId, maxNodes, _ownedCount);\n    }\n\n    /// @dev return EITHER the found Cdps (also the count) owned by given owner OR empty array with\n    /// @dev current lastly-visited CDP as the startNode for next pagination\n    function _getCdpsOf(\n        address owner,\n        bytes32 startNodeId,\n        uint maxNodes,\n        uint maxArraySize\n    ) internal view returns (bytes32[] memory, uint256, bytes32) {\n        if (maxArraySize == 0) {\n            return (new bytes32[](0), 0, dummyId);\n        }\n\n        // Two-pa"
    }
  ]
}