{
  "Title": "M-2: Cross-chain replay attacks are possible with `changeRecipientAddress()`",
  "Content": "# Issue M-2: Cross-chain replay attacks are possible with `changeRecipientAddress()` \n\nSource: https://github.com/sherlock-audit/2022-09-harpie-judging/tree/main/004-M \n\n## Found by \nminhquanym, JohnSmith, IllIllI\n\n## Summary\nMistakes made on one chain can be re-applied to a new chain\n\n## Vulnerability Detail\nThere is no `chain.id` in the signed data\n\n## Impact\nIf a user does a `changeRecipientAddress()` using the wrong network, an attacker can replay the action on the correct chain, and steal the funds a-la the wintermute gnosis safe attack, where the attacker can create the same address that the user tried to, and steal the funds from there\n\n## Code Snippet\nhttps://github.com/Harpieio/contracts/blob/97083d7ce8ae9d85e29a139b1e981464ff92b89e/contracts/Vault.sol#L60-L73\n\n## Tool used\n\nManual Review\n\n## Recommendation\nInclude the `chain.id` in what's hashed\n\n## Harpie Team\nAdded chainId to signature and signature validation. Fix [here](https://github.com/Harpieio/contracts/pull/4/commits/de24a50349ec014163180ba60b5305098f42eb14).\n\n## Lead Senior Watson\nThis is true assuming the contract address is the same across other chains. Confirmed fix. \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/3",
  "Code": [
    {
      "filename": "contracts/Vault.sol",
      "content": "// contracts/delegator.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n/// @notice This contract is designed to hold ERC20s and ERC721s from user wallets and allow only them to withdraw.\n/// Users will have to pay a designated fee in order to withdraw their ERC20s and ERC721s.\n/// In case we need to reduce fees for each user, we have reduceFee functions we can call. \ncontract Vault {\n    using ECDSA for bytes32;\n\n    /// @dev We use safeERC20 for noncompliant ERC20s\n    using SafeERC20 for IERC20;\n\n    /// @dev This struct defines the amount of an ERC20 stored, and the fee required to withdraw\n    struct erc20Struct {\n        uint128 amountStored;\n        uint128 fee;\n    }\n\n    /// @dev This struct defines if an ERC721 id is stored, and the fee required to withdraw\n    struct erc721Struct {\n        bool isStored;\n        uint128 fee;\n    }\n\n    /// @dev The address of the Transfer contract linked to this contract\n    address private immutable transferer;\n    /// @notice The serverSigner is an EOA responsible for providing the signature of changeRecipientAddress\n    address private immutable serverSigner;\n    /// @notice The feeController is an EOA that's able to only reduce the fees of users and withdraw our fees\n    address payable private feeController;\n\n    /// @dev This mapping is a one-to-one that defines who can withdraw a user's transfered funds\n    mapping(address => address) private _recipientAddress;\n    \n    /// @dev These mappings define the tokens a user can withdraw from the Vault and the fees to withdraw\n    mapping(address => mapping(address => erc20Struct)) private _erc20WithdrawalAllowances;\n    mapping(address => mapping(address => mapping (uint256 => erc721Struct))) private _erc721WithdrawalAllowances;\n\n    /// @dev This mapping prevents the reuse of a signature to changeRecipientAddress\n    mapping(bytes32 => bool) private _isChangeRecipientMessageConsumed;\n\n    /// @dev Immutables like transferer and serverSigner are set during construction for safety\n    constructor(address _transferer, address _serverSigner, address payable _feeController) {\n        transferer = _transferer;\n        serverSigner = _serverSigner;\n        feeController = _feeController;\n    }\n\n    /// @notice Allow users to set up a recipient address for collecting stored assets\n    function setupRecipientAddress(address _recipient) external {\n        require(_recipientAddress[msg.sender] == address(0), \"You already have registered a recipient address\");\n        _recipientAddress[msg.sender] = _recipient;\n    }   \n\n    /// @notice Allow users to change their recipient address. Requires a signature from our serverSigner\n    /// to allow this transaction to fire\n    function changeRecipientAddress(bytes memory _signature, address _newRecipientAddress, uint256 expiry) external {\n        /// @dev Have server sign a message in the format [protectedWalletAddress, newRecipientAddress, exp, vaultAddress]\n        /// msg.sender == protectedWalletAddress (meaning that the protected wallet will submit this transaction)\n        /// @notice We require the extra signature in case we add 2fa in some way in future\n\n        bytes32 data = keccak256(abi.encodePacked(msg.sender, _newRecipientAddress, expiry, address(this)));\n        require(data.toEthSignedMessageHash().recover(_signature) == serverSigner, \"Invalid signature. Signature source may be incorrect, or a provided parameter is invalid\");\n        require(block.timestamp <= expiry, \"Signature expired\");\n        require(_isChangeRecipientMessageConsumed[data] == false, \"Already used this signature\");\n        _isChangeRecipientMessageConsumed[data] = true;\n        _recipientAddress[msg.sender] = _newRecipientAddress;\n    }\n\n    /// @notice View which address is authorized to withdraw assets\n    function viewRecipientAddress(address _originalAddress) public view returns (address) {\n        return _recipientAddress[_originalAddress];\n    }\n\n\n    /// @notice Log functions fire when the vault receives an ERC20 or ER721 from Transfer.sol\n    function logIncomingERC20(address _originalAddress, address _erc20Address, uint256 _amount, uint128 _fee) external{\n        require(msg.sender == transferer, \"Only the transferer contract can log funds.\");\n        _erc20WithdrawalAllowances[_originalAddress][_erc20Address].fee += _fee;\n        _erc20WithdrawalAllowances[_originalAddress][_erc20Address].amountStored += uint128(_amount);\n    }\n\n    function logIncomingERC721(address _originalAddress, address _erc721Address, uint256 _id, uint128 _fee) external {\n        require(msg.sender == transferer, \"Only the transferer contract can log funds.\");\n        _erc721WithdrawalAllowances[_originalAddress][_erc721Address][_id].fee += _fee;\n        _erc721WithdrawalAllowances[_originalAddress][_erc721Address][_id].isStored = true;\n    }\n\n\n    /// @notice These functions can be called to view an addresses' stored balances and the fees to withdraw them\n    function canWithdrawERC20(address _originalAddress, address _erc20Address) public view returns (uint256) {\n        return _erc20WithdrawalAllowances[_originalAddress][_erc20Address].amountStored;\n    }\n\n    function canWithdrawERC721(address _originalAddress, address _erc721Address, uint256 _id) public view returns (bool) {\n        return _erc721WithdrawalAllowances[_originalAddress][_erc721Address][_id].isStored;\n    }\n\n    function erc20Fee(address _originalAddress, address _erc20Address) public view returns (uint128) {\n        return _erc20WithdrawalAllowances[_originalAddress][_erc20Address].fee;\n    }\n\n    function erc721Fee(address _originalAddress, address _erc721Address, uint256 _id) public view returns (uint128) {\n        return _erc721WithdrawalAllowances[_originalAddress][_erc721Address][_id].fee;\n    }\n\n    /// @notice Withdrawal functions allow users to withdraw their assets after paying the ETH withdrawal fee\n    /// @dev A few guards are placed to avoid erroneous withdrawals.\n    /// - caller must be a recipient address of the assets of _originalAddress\n    /// - there must be an allowance in the _originalAddress's withdrawal allowance\n    /// - the _erc20Address must not be address(this)\n    /// - the msg.value must be >= the withdrawal fee\n    function withdrawERC20(address _originalAddress, address _erc20Address) payable external {\n        require(_recipientAddress[_originalAddress] == msg.sender, \"Function caller is not an authorized recipientAddress.\");\n        require(_erc20Address != address(this), \"The vault is not a token address\");\n        require(canWithdrawERC20(_originalAddress, _erc20Address) > 0, \"No withdrawal allowance.\");\n        require(msg.value >= _erc20WithdrawalAllowances[_originalAddress][_erc20Address].fee, \"Insufficient payment.\");\n\n        uint256 amount = canWithdrawERC20(_originalAddress, _erc20Address);\n        _erc20WithdrawalAllowances[_originalAddress][_erc20Address].amountStored = 0;\n        _erc20WithdrawalAllowances[_originalAddress][_erc20Address].fee = 0;\n        IERC20(_erc20Address).safeTransfer(msg.sender, amount);\n    }\n    function withdrawERC721(address _originalAddress, address _erc721Address, uint256 _id) payable external {\n        require(_recipientAddress[_originalAddress] == msg.sender, \"Function caller is not an authorized recipientAddress.\");\n        require(_erc721Address != address(this), \"The vault is not a token address\");\n        require(canWithdrawERC721(_originalAddress, _erc721Address, _id), \"Insufficient withdrawal allowance.\");\n        require(msg.value >= _erc721WithdrawalAllowances[_originalAddress][_erc721Address][_id].fee, \"Insufficient payment.\");\n\n        _erc721WithdrawalAllowances[_originalAddress][_erc721Address][_id].isStored = false;\n        _erc721WithdrawalAllowances[_originalAddress][_erc721Address][_id].fee = 0;\n        IERC721(_erc721Address).transferFrom(address(this), msg.sender, _id);\n    }\n\n    /// @notice These functions allow Harpie to reduce (but never increase) the fee upon a user\n    function reduceERC20Fee(address _originalAddress, address _erc20Address, uint128 _reduceBy) external returns (uint128) {\n        require(msg.sender == feeController, \"msg.sender must be feeController.\");\n        require(_erc20WithdrawalAllowances[_originalAddress][_erc20Address].fee >= _reduceBy, \"You cannot reduce more than the current fee.\");\n        _erc20WithdrawalAllowances[_originalAddress][_erc20Address].fee -= _reduceBy;\n        return _erc20WithdrawalAllowances[_originalAddress][_erc20Address].fee;\n    }\n\n    function reduceERC721Fee(address _originalAddress, address _erc721Address, uint128 _id, uint128 _reduceBy) external returns (uint128) {\n        require(msg.sender == feeController, \"msg.sender must be feeController.\");\n        require(_erc721WithdrawalAllowances[_originalAddress][_erc721Address][_id].fee >= _reduceBy, \"You cannot reduce more than the current fee.\");\n        _erc721WithdrawalAllowances[_originalAddress][_erc721Address][_id].fee -= _reduceBy;\n        return _erc721WithdrawalAllowances[_originalAddress][_erc721Address][_id].fee;\n    }\n\n    /// @notice This function allows us to withdraw the fees we collect in this contract\n    function withdrawPayments(uint256 _amount) external {\n        require(msg.sender == feeController, \"msg.sender must be feeController.\");\n        require(address(this).balance >= _amount, \"Cannot withdraw more than the amount in the contract.\");\n        feeController.transfer(_amount);\n    }\n\n    /// @notice This function allows us to change the signer that we use to reduce and withdraw fees\n    function changeFeeController(address payable _newFeeController) external {\n        require(msg.sender == feeController, \"msg.sender must be feeController.\");\n        feeController = _newFeeController;\n    }\n}"
    }
  ]
}