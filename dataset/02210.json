{
  "Title": "M-45: withdrawal request override",
  "Content": "# Issue M-45: withdrawal request override \n\nSource: https://github.com/sherlock-audit/2023-01-derby-judging/issues/392 \n\n## Found by \nHonorLt, gogo, XKET, nobody2018, saidam017, bin2chen, immeas, oot2k\n\n## Summary\n\nIt is possible that a withdrawal request is overridden during the initial phase.\n\n## Vulnerability Detail\n\nUsers have two options to withdraw: directly or request a withdrawal if not enough funds are available at the moment.\n\nWhen making a `withdrawalRequest` it is required that the user has `withdrawalRequestPeriod` not set:\n```solidity\n  function withdrawalRequest(\n    uint256 _amount\n  ) external nonReentrant onlyWhenVaultIsOn returns (uint256 value) {\n    UserInfo storage user = userInfo[msg.sender];\n    require(user.withdrawalRequestPeriod == 0, \"Already a request\");\n\n    value = (_amount * exchangeRate) / (10 ** decimals());\n\n    _burn(msg.sender, _amount);\n\n    user.withdrawalAllowance = value;\n    user.withdrawalRequestPeriod = rebalancingPeriod;\n    totalWithdrawalRequests += value;\n  }\n```\n\nThis will misbehave during the initial period when `rebalancingPeriod` is 0. The check will pass, so if invoked multiple times, it will burn users' shares and overwrite the value.\n\n## Impact\n\nWhile not very likely to happen, the impact would be huge, because the users who invoke this function several times before the first rebalance, would burn their shares and lose previous `withdrawalAllowance`. The protocol should prevent such mistakes.\n\n## Code Snippet\n\nI have extended one of your test cases to showcase this vulnerability:\n\n```ts\n  it('Should not be able to lose previous withdrawal request :(', async function () {\n    const { vault, user } = await setupVault();\n    await vault.connect(user).deposit(parseUSDC(10_000), user.address); // 10k\n    expect(await vault.totalSupply()).to.be.equal(parseUSDC(10_000)); // 10k\n\n    // mocking exchangerate to 0.9\n    await vault.setExchangeRateTEST(parseUSDC(0.9));\n\n    // withdrawal request for 2x 5k LP tokens\n    await expect(() =>\n      vault.connect(user).withdrawalRequest(parseUSDC(5_000)),\n    ).to.changeTokenBalance(vault, user, -parseUSDC(5_000));\n\n    await expect(() =>\n      vault.connect(user).withdrawalRequest(parseUSDC(5_000)),\n    ).to.changeTokenBalance(vault, user, -parseUSDC(5_000));\n\n    // check withdrawalAllowance user and totalsupply\n    expect(await vault.connect(user).getWithdrawalAllowance()).to.be.equal(parseUSDC(4_500));\n    expect(await vault.totalSupply()).to.be.equal(parseUSDC(0));\n\n    // trying to withdraw allowance before the vault reserved the funds\n    await expect(vault.connect(user).withdrawAllowance()).to.be.revertedWith('');\n\n    // mocking vault settings\n    await vault.upRebalancingPeriodTEST();\n    await vault.setReservedFundsTEST(parseUSDC(10_000));\n\n    // withdraw allowance should give 4.5k USDC\n    await expect(() => vault.connect(user).withdrawAllowance()).to.changeTokenBalance(\n      IUSDc,\n      user,\n      parseUSDC(4_500),\n    );\n\n    // trying to withdraw allowance again\n    await expect(vault.connect(user).withdrawAllowance()).to.be.revertedWith('!Allowance');\n  });\n```\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/MainVault.sol#L153\n\n## Tool used\n\nManual Review\n\n## Recommendation\nRequire `rebalancingPeriod` != 0 in `withdrawalRequest`, otherwise, force users to directly withdraw.\n\n\n\n## Discussion\n\n**Theezr**\n\nFix:\nhttps://github.com/derbyfinance/derby-yield-optimiser/pull/193\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/13",
  "Code": [
    {
      "filename": "derby-yield-optimiser/contracts/MainVault.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"./Vault.sol\";\n\nimport \"./Interfaces/IXProvider.sol\";\n\ncontract MainVault is Vault, VaultToken {\n  using SafeERC20 for IERC20;\n\n  struct UserInfo {\n    // amount in vaultCurrency the vault owes to the user\n    uint256 withdrawalAllowance;\n    // rebalancing period the withdrawal request is made\n    uint256 withdrawalRequestPeriod;\n    // amount in vaultCurrency the vault owes to the user\n    uint256 rewardAllowance;\n    // rebalancing period the reward request is made\n    uint256 rewardRequestPeriod;\n  }\n\n  address public derbyToken;\n  address public game;\n  address public xProvider;\n\n  bool public vaultOff;\n  // True when rewards should be swapped to derby tokens\n  bool public swapRewards;\n\n  // total amount of withdrawal requests for the vault to pull extra during a cross-chain rebalance, will be upped when a user makes a withdrawalRequest\n  // during a cross-chain rebalance the vault will pull extra funds by the amount of totalWithdrawalRequests and the totalWithdrawalRequests will turn into actual reservedFunds\n  uint256 internal totalWithdrawalRequests;\n  uint256 public exchangeRate;\n  uint32 public homeChain;\n  uint256 public amountToSendXChain;\n  uint256 public governanceFee; // Basis points\n  uint256 public maxDivergenceWithdraws;\n\n  string internal allowanceError = \"!Allowance\";\n\n  // (userAddress => userInfo struct)\n  mapping(address => UserInfo) internal userInfo;\n\n  // training\n  bool private training;\n  uint256 private maxTrainingDeposit;\n  mapping(address => bool) private whitelist;\n\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    uint8 _decimals,\n    uint256 _vaultNumber,\n    address _dao,\n    address _game,\n    address _controller,\n    address _vaultCurrency,\n    uint256 _uScale\n  )\n    VaultToken(_name, _symbol, _decimals)\n    Vault(_vaultNumber, _dao, _controller, _vaultCurrency, _uScale)\n  {\n    exchangeRate = _uScale;\n    game = _game;\n    governanceFee = 0;\n    maxDivergenceWithdraws = 1_000_000;\n  }\n\n  modifier onlyXProvider() {\n    require(msg.sender == xProvider, \"only xProvider\");\n    _;\n  }\n\n  modifier onlyWhenVaultIsOn() {\n    require(state == State.Idle, \"Rebalancing\");\n    require(!vaultOff, \"Vault is off\");\n    _;\n  }\n\n  modifier onlyWhenIdle() {\n    require(state == State.Idle, \"Rebalancing\");\n    _;\n  }\n\n  modifier onlyGame() {\n    require(msg.sender == game, \"only game\");\n    _;\n  }\n\n  event PushTotalUnderlying(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    uint256 _underlying,\n    uint256 _totalSupply,\n    uint256 _withdrawalRequests\n  );\n  event RebalanceXChain(uint256 _vaultNumber, uint256 _amount, address _asset);\n  event PushedRewardsToGame(uint256 _vaultNumber, uint32 _chain, int256[] _rewards);\n\n  /// @notice Deposit in Vault\n  /// @dev Deposit VaultCurrency to Vault and mint LP tokens\n  /// @param _amount Amount to deposit\n  /// @param _receiver Receiving adress for the tokens\n  /// @return shares Tokens received by buyer\n  function deposit(\n    uint256 _amount,\n    address _receiver\n  ) external nonReentrant onlyWhenVaultIsOn returns (uint256 shares) {\n    if (training) {\n      require(whitelist[msg.sender]);\n      uint256 balanceSender = (balanceOf(msg.sender) * exchangeRate) / (10 ** decimals());\n      require(_amount + balanceSender <= maxTrainingDeposit);\n    }\n\n    uint256 balanceBefore = getVaultBalance() - reservedFunds;\n    vaultCurrency.safeTransferFrom(msg.sender, address(this), _amount);\n    uint256 balanceAfter = getVaultBalance() - reservedFunds;\n\n    uint256 amount = balanceAfter - balanceBefore;\n    shares = (amount * (10 ** decimals())) / exchangeRate;\n\n    _mint(_receiver, shares);\n  }\n\n  /// @notice Withdraw from Vault\n  /// @dev Withdraw VaultCurrency from Vault and burn LP tokens\n  /// @param _amount Amount to withdraw in LP tokens\n  /// @param _receiver Receiving adress for the vaultcurrency\n  /// @return value Amount received by seller in vaultCurrency\n  function withdraw(\n    uint256 _amount,\n    address _receiver,\n    address _owner\n  ) external nonReentrant onlyWhenVaultIsOn returns (uint256 value) {\n    value = (_amount * exchangeRate) / (10 ** decimals());\n\n    require(value > 0, \"!value\");\n\n    require(getVaultBalance() - reservedFunds >= value, \"!funds\");\n\n    _burn(msg.sender, _amount);\n    transferFunds(_receiver, value);\n  }\n\n  /// @notice Withdrawal request for when the vault doesnt have enough funds available\n  /// @dev Will give the user allowance for his funds and pulls the extra funds at the next rebalance\n  /// @param _amount Amount to withdraw in LP token\n  function withdrawalRequest(\n    uint256 _amount\n  ) external nonReentrant onlyWhenVaultIsOn returns (uint256 value) {\n    UserInfo storage user = userInfo[msg.sender];\n    require(user.withdrawalRequestPeriod == 0, \"Already a request\");\n\n    value = (_amount * exchangeRate) / (10 ** decimals());\n\n    _burn(msg.sender, _amount);\n\n    user.withdrawalAllowance = value;\n    user.withdrawalRequestPeriod = rebalancingPeriod;\n    totalWithdrawalRequests += value;\n  }\n\n  /// @notice Withdraw the allowance the user requested on the last rebalancing period\n  /// @dev Will send the user funds and reset the allowance\n  function withdrawAllowance() external nonReentrant onlyWhenIdle returns (uint256 value) {\n    UserInfo storage user = userInfo[msg.sender];\n    require(user.withdrawalAllowance > 0, allowanceError);\n    require(rebalancingPeriod > user.withdrawalRequestPeriod, \"Funds not arrived\");\n\n    value = user.withdrawalAllowance;\n    value = checkForBalance(value);\n\n    reservedFunds -= value;\n    delete user.withdrawalAllowance;\n    delete user.withdrawalRequestPeriod;\n\n    transferFunds(msg.sender, value);\n  }\n\n  /// @notice Substract governance fee from value\n  /// @param _receiver Receiving adress for the vaultcurrency\n  /// @param _value Amount received by seller in vaultCurrency\n  function transferFunds(address _receiver, uint256 _value) internal {\n    uint256 govFee = (_value * governanceFee) / 10_000;\n\n    vaultCurrency.safeTransfer(getDao(), govFee);\n    vaultCurrency.safeTransfer(_receiver, _value - govFee);\n  }\n\n  /// @notice Function for the game to set a withdrawalRequest for the rewards of the game user\n  /// @param _value Amount to set a request in vaultCurrency\n  /// @param _user Address of the user\n  function redeemRewardsGame(\n    uint256 _value,\n    address _user\n  ) external onlyGame nonReentrant onlyWhenVaultIsOn {\n    UserInfo storage user = userInfo[_user];\n    require(user.rewardAllowance == 0, allowanceError);\n\n    user.rewardAllowance = _value;\n    user.rewardRequestPeriod = rebalancingPeriod;\n    totalWithdrawalRequests += _value;\n  }\n\n  /// @notice Withdraw the reward allowance set by the game with redeemRewardsGame\n  /// @dev Will swap vaultCurrency to Derby tokens, send the user funds and reset the allowance\n  function withdrawRewards() external nonReentrant onlyWhenIdle returns (uint256 value) {\n    UserInfo storage user = userInfo[msg.sender];\n    require(user.rewardAllowance > 0, allowanceError);\n    require(rebalancingPeriod > user.rewardRequestPeriod, \"!Funds\");\n\n    value = user.rewardAllowance;\n    value = checkForBalance(value);\n\n    reservedFunds -= value;\n    delete user.rewardAllowance;\n    delete user.rewardRequestPeriod;\n\n    if (swapRewards) {\n      uint256 tokensReceived = Swap.swapTokensMulti(\n        Swap.SwapInOut(value, address(vaultCurrency), derbyToken),\n        controller.getUniswapParams(),\n        true\n      );\n      IERC20(derbyToken).safeTransfer(msg.sender, tokensReceived);\n    } else {\n      vaultCurrency.safeTransfer(msg.sender, value);\n    }\n  }\n\n  /// @notice Sometimes when swapping stable coins the vault will get a fraction of a coin less then expected\n  /// @notice This is to make sure the vault doesnt get stuck\n  /// @notice Value will be set to the vaultBalance\n  /// @notice When divergence is greater then maxDivergenceWithdraws it will revert\n  /// @param _value Value the user wants to withdraw\n  /// @return value Value - divergence\n  function checkForBalance(uint256 _value) internal view returns (uint256) {\n    if (_value > getVaultBalance()) {\n      uint256 oldValue = _value;\n      _value = getVaultBalance();\n      require(oldValue - _value <= maxDivergenceWithdraws, \"Max divergence\");\n    }\n    return _value;\n  }\n\n  /// @notice Step 2 trigger; Vaults push totalUnderlying, totalSupply and totalWithdrawalRequests to xChainController\n  /// @notice Pushes totalUnderlying, totalSupply and totalWithdrawalRequests of the vault for this chainId to xController\n  function pushTotalUnderlyingToController() external payable onlyWhenIdle {\n    require(rebalanceNeeded(), \"!rebalance needed\");\n\n    setTotalUnderlying();\n    uint256 underlying = savedTotalUnderlying + getVaultBalance() - reservedFunds;\n\n    IXProvider(xProvider).pushTotalUnderlying{value: msg.value}(\n      vaultNumber,\n      homeChain,\n      underlying,\n      totalSupply(),\n      totalWithdrawalRequests\n    );\n\n    state = State.PushedUnderlying;\n    lastTimeStamp = block.timestamp;\n\n    emit PushTotalUnderlying(\n      vaultNumber,\n      homeChain,\n      underlying,\n      totalSupply(),\n      totalWithdrawalRequests\n    );\n  }\n\n  /// @notice See setXChainAllocationInt below\n  function setXChainAllocation(\n    uint256 _amountToSend,\n    uint256 _exchangeRate,\n    bool _receivingFunds\n  ) external onlyXProvider {\n    require(state == State.PushedUnderlying, stateError);\n    setXChainAllocationInt(_amountToSend, _exchangeRate, _receivingFunds);\n  }\n\n  /// @notice Step 3 end; xChainController pushes exchangeRate and amount the vaults have to send back to all vaults\n  /// @notice Will set the amount to send back to the xController by the xController\n  /// @dev Sets the amount and state so the dao can trigger the rebalanceXChain function\n  /// @dev When amount == 0 the vault doesnt need to send anything and will wait for funds from the xController\n  /// @param _amountToSend amount to send in vaultCurrency\n  function setXChainAllocationInt(\n    uint256 _amountToSend,\n    uint256 _exchangeRate,\n    bool _receivingFunds\n  ) internal {\n    amountToSendXChain = _amountToSend;\n    exchangeRate = _exchangeRate;\n\n    if (_amountToSend == 0 && !_receivingFunds) settleReservedFunds();\n    else if (_amountToSend == 0 && _receivingFunds) state = State.WaitingForFunds;\n    else state = State.SendingFundsXChain;\n  }\n\n  /// @notice Step 4 trigger; Push funds from vaults to xChainController\n  /// @notice Send vaultcurrency to the xController for xChain rebalance\n  /// @param _slippage Slippage tollerance for xChain swap, in BPS (i.e. 30 = 0.3%)\n  /// @param _relayerFee The fee offered to the relayers\n  function rebalanceXChain(uint256 _slippage, uint256 _relayerFee) external payable {\n    require(state == State.SendingFundsXChain, stateError);\n\n    if (amountToSendXChain > getVaultBalance()) pullFunds(amountToSendXChain);\n    if (amountToSendXChain > getVaultBalance()) amountToSendXChain = getVaultBalance();\n\n    vaultCurrency.safeIncreaseAllowance(xProvider, amountToSendXChain);\n    IXProvider(xProvider).xTransferToController{value: msg.value}(\n      vaultNumber,\n      amountToSendXChain,\n      address(vaultCurrency),\n      _slippage,\n      _relayerFee\n    );\n\n    emit RebalanceXChain(vaultNumber, amountToSendXChain, address(vaultCurrency));\n\n    amountToSendXChain = 0;\n    settleReservedFunds();\n  }\n\n  /// @notice Step 5 end; Push funds from xChainController to vaults\n  /// @notice Receiving feedback from xController when funds are received, so the vault can rebalance\n  function receiveFunds() external onlyXProvider {\n    if (state != State.WaitingForFunds) return;\n    settleReservedFunds();\n  }\n\n  /// @notice Helper to settle reserved funds when funds arrived and up to the next State\n  function settleReservedFunds() internal {\n    reservedFunds += totalWithdrawalRequests;\n    totalWithdrawalRequests = 0;\n    state = State.RebalanceVault;\n  }\n\n  /// @notice See receiveProtocolAllocations below\n  function receiveProtocolAllocations(int256[] memory _deltas) external onlyXProvider {\n    receiveProtocolAllocationsInt(_deltas);\n  }\n\n  /// @notice Step 6 end; Game pushes deltaAllocations to vaults\n  /// @notice Receives protocol allocation array from the game and settles the allocations\n  /// @param _deltas Array with delta allocations where the index matches the protocolId\n  function receiveProtocolAllocationsInt(int256[] memory _deltas) internal {\n    for (uint i = 0; i < _deltas.length; i++) {\n      int256 allocation = _deltas[i];\n      if (allocation == 0) continue;\n      setDeltaAllocationsInt(i, allocation);\n    }\n\n    deltaAllocationsReceived = true;\n  }\n\n  /// @notice Step 8 trigger; Vaults push rewardsPerLockedToken to game\n  function sendRewardsToGame() external payable {\n    require(state == State.SendRewardsPerToken, stateError);\n\n    int256[] memory rewards = rewardsToArray();\n    IXProvider(xProvider).pushRewardsToGame{value: msg.value}(vaultNumber, homeChain, rewards);\n\n    state = State.Idle;\n\n    emit PushedRewardsToGame(vaultNumber, homeChain, rewards);\n  }\n\n  /// @notice Receive feedback for the vault if the vault is set to on or off\n  /// @param _state bool for chainId on or off\n  function toggleVaultOnOff(bool _state) external onlyXProvider {\n    vaultOff = _state;\n  }\n\n  /// @notice Returns the amount in vaultCurrency the user is able to withdraw\n  function getWithdrawalAllowance() external view returns (uint256) {\n    return userInfo[msg.sender].withdrawalAllowance;\n  }\n\n  /// @notice Returns the rewards the user is able to withdraw\n  function getRewardAllowance() external view returns (uint256) {\n    return userInfo[msg.sender].rewardAllowance;\n  }\n\n  /*\n  Only Dao functions\n  */\n\n  /// @notice Setter for xProvider address\n  /// @param _xProvider new address of xProvider on this chain\n  function setHomeXProvider(address _xProvider) external onlyDao {\n    xProvider = _xProvider;\n  }\n\n  /// @notice Setter for derby token address\n  /// @param _token New address of the derby token\n  function setDaoToken(address _token) external onlyDao {\n    derbyToken = _token;\n  }\n\n  /// @notice Setter for new game address\n  /// @param _game New address of the game\n  function setGame(address _game) external onlyDao {\n    game = _game;\n  }\n\n  /// @notice Setter for swapping rewards to derby tokens\n  /// @param _state True when rewards should be swapped to derby tokens\n  function setSwapRewards(bool _state) external onlyDao {\n    swapRewards = _state;\n  }\n\n  /// @notice Setter for maximum divergence a user can get during a withdraw\n  /// @param _maxDivergence New maximum divergence in vaultCurrency\n  function setMaxDivergence(uint256 _maxDivergence) external onlyDao {\n    maxDivergenceWithdraws = _maxDivergence;\n  }\n\n  /*\n  Only Guardian functions\n  */\n\n  /// @notice Step 3: Guardian function\n  function setXChainAllocationGuard(\n    uint256 _amountToSend,\n    uint256 _exchangeRate,\n    bool _receivingFunds\n  ) external onlyGuardian {\n    setXChainAllocationInt(_amountToSend, _exchangeRate, _receivingFunds);\n  }\n\n  /// @notice Step 5: Guardian function\n  function receiveFundsGuard() external onlyGuardian {\n    settleReservedFunds();\n  }\n\n  /// @notice Step 6: Guardian function\n  function receiveProtocolAllocationsGuard(int256[] memory _deltas) external onlyGuardian {\n    receiveProtocolAllocationsInt(_deltas);\n  }\n\n  /// @notice Guardian function to set state when vault gets stuck for whatever reason\n  function setVaultStateGuard(State _state) external onlyGuardian {\n    state = _state;\n  }\n\n  /// @notice Setter for new homeChain Id\n  function setHomeChain(uint32 _homeChain) external onlyGuardian {\n    homeChain = _homeChain;\n  }\n\n  /// @notice Setter for governance fee\n  /// @param _fee Fee in basis points\n  function setGovernanceFee(uint16 _fee) external onlyGuardian {\n    governanceFee = _fee;\n  }\n\n  /// @notice Setter to control the training state in de deposit function\n  function setTraining(bool _state) external onlyGuardian {\n    training = _state;\n  }\n\n  /// @notice Setter for maximum amount to be able to deposit in training state\n  function setTrainingDeposit(uint256 _maxDeposit) external onlyGuardian {\n    maxTrainingDeposit = _maxDeposit;\n  }\n\n  /// @notice Setter to add an address to the whitelist\n  function addToWhitelist(address _address) external onlyGuardian {\n    whitelist[_address] = true;\n  }\n}"
    }
  ]
}