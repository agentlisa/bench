{
  "Title": "Incomplete Docstrings [core and samples]",
  "Content": "Throughout the [codebase](https://github.com/eth-infinitism/account-abstraction/tree/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/), there are several parts that have incomplete docstrings:\n\n\n* In the [updateCachedPrice](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/samples/utils/OracleHelper.sol#L80-L117) function in [`OracleHelper.sol`](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/samples/utils/OracleHelper.sol):\n\n\n\t+ The `force` parameter is not documented.\n\t+ The return value is not documented.\n* In the [`_postOp`](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/core/BasePaymaster.sol#L84-L93) function in [`BasePaymaster.sol`](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/core/BasePaymaster.sol), the `actualGasCost` parameter is not documented.\n* In the [getUserOpPublicKey](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/samples/bls/BLSSignatureAggregator.sol#L34-L41) function in [`BLSSignatureAggregator.sol`](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/samples/bls/BLSSignatureAggregator.sol), the `userOp` parameter is not documented.\n* In the [addStake](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/samples/bls/BLSSignatureAggregator.sol#L166-L168) function in [`BLSSignatureAggregator.sol`](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/samples/bls/BLSSignatureAggregator.sol), the `delay` parameter is not documented.\n* In the [validateUserOp](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/core/BaseAccount.sol#L50-L59) function in [`BaseAccount.sol`](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/core/BaseAccount.sol), the return value is not documented.\n* In the [innerHandleOp](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/core/EntryPoint.sol#L290-L337) function in [`EntryPoint.sol`](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/core/EntryPoint.sol), the return value is not documented.\n* In the [\\_getValidationData](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/core/EntryPoint.sol#L567-L577) function in [`EntryPoint.sol`](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/core/EntryPoint.sol), the return values are not documented.\n* In the [getUserOpHash](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/interfaces/IEntryPoint.sol#L162-L164) function in [`IEntryPoint.sol`](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/interfaces/IEntryPoint.sol), the return value is not documented.\n* In the [delegateAndRevert](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/interfaces/IEntryPoint.sol#L209) function in [`IEntryPoint.sol`](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/interfaces/IEntryPoint.sol), the `target` and `data` parameters are not documented.\n* In the [simulateValidation](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/interfaces/IEntryPointSimulations.sol#L43-L49) function in [`IEntryPointSimulations.sol`](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/interfaces/IEntryPointSimulations.sol), the return value is not documented.\n* In the [simulateHandleOp](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/interfaces/IEntryPointSimulations.sol#L64-L72) function in [`IEntryPointSimulations.sol`](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/interfaces/IEntryPointSimulations.sol), the return value is not documented.\n* In the [executeBatch](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/samples/SimpleAccount.sol#L63-L75) function in [`SimpleAccount.sol`](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/samples/SimpleAccount.sol), the `dest`, `value`, and `func` parameters are not documented.\n* In the [initialize](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/samples/SimpleAccount.sol#L82-L84) function in [`SimpleAccount.sol`](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/samples/SimpleAccount.sol), the `anOwner` parameter is not documented.\n* In the [balanceOf](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/core/StakeManager.sol#L41-L43) function in [`StakeManager.sol`](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/core/StakeManager.sol), the return value is not documented.\n\n\nConsider thoroughly documenting all functions/events (and their parameters or return values) that are part of any contract's public API. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/latest/natspec-format.html) (NatSpec).\n\n\n***Update:** Resolved in [pull request #414](https://github.com/eth-infinitism/account-abstraction/pull/414).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/samples/utils/OracleHelper.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable not-rely-on-time */\n\nimport \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\n\nimport \"./IOracle.sol\";\n\n/// @title Helper functions for dealing with various forms of price feed oracles.\n/// @notice Maintains a price cache and updates the current price if needed.\n/// In the best case scenario we have a direct oracle from the token to the native asset.\n/// Also support tokens that have no direct price oracle to the native asset.\n/// Sometimes oracles provide the price in the opposite direction of what we need in the moment.\nabstract contract OracleHelper {\n\n    event TokenPriceUpdated(uint256 currentPrice, uint256 previousPrice, uint256 cachedPriceTimestamp);\n\n    uint256 private constant PRICE_DENOMINATOR = 1e26;\n\n    struct OracleHelperConfig {\n\n        /// @notice The price cache will be returned without even fetching the oracles for this number of seconds\n        uint48 cacheTimeToLive;\n\n        /// @notice The Oracle contract used to fetch the latest token prices\n        IOracle tokenOracle;\n\n        /// @notice The Oracle contract used to fetch the latest ETH prices\n        IOracle nativeOracle;\n\n        /// @notice If 'true' we will fetch price directly from tokenOracle\n        /// @notice If 'false' we will use nativeOracle to establish a token price through a shared third currency\n        bool tokenToNativeOracle;\n\n        /// @notice 'false' if price is dollars-per-token (or ether-per-token), 'true' if price is tokens-per-dollar\n        bool tokenOracleReverse;\n\n        /// @notice 'false' if price is dollars-per-ether, 'true' if price is ether-per-dollar\n        bool nativeOracleReverse;\n\n        /// @notice The price update threshold percentage that triggers a price update (1e6 = 100%)\n        uint48 priceUpdateThreshold;\n\n    }\n\n    /// @notice The cached token price from the Oracle, always in (ether-per-token) * PRICE_DENOMINATOR format\n    uint256 public cachedPrice;\n\n    /// @notice The timestamp of a block when the cached price was updated\n    uint48 public cachedPriceTimestamp;\n\n    OracleHelperConfig private oracleHelperConfig;\n\n    /// @notice The \"10^(tokenOracle.decimals)\" value used for the price calculation\n    uint128 private tokenOracleDecimalPower;\n\n    /// @notice The \"10^(nativeOracle.decimals)\" value used for the price calculation\n    uint128 private nativeOracleDecimalPower;\n\n    constructor (\n        OracleHelperConfig memory _oracleHelperConfig\n    ) {\n        cachedPrice = type(uint256).max; // initialize the storage slot to invalid value\n        _setOracleConfiguration(\n            _oracleHelperConfig\n        );\n    }\n\n    function _setOracleConfiguration(\n        OracleHelperConfig memory _oracleHelperConfig\n    ) private {\n        oracleHelperConfig = _oracleHelperConfig;\n        require(_oracleHelperConfig.priceUpdateThreshold <= 1e6, \"TPM: update threshold too high\");\n        tokenOracleDecimalPower = uint128(10 ** oracleHelperConfig.tokenOracle.decimals());\n        nativeOracleDecimalPower = uint128(10 ** oracleHelperConfig.nativeOracle.decimals());\n    }\n\n    /// @notice Updates the token price by fetching the latest price from the Oracle.\n    function updateCachedPrice(bool force) public returns (uint256 newPrice) {\n        uint256 cacheTimeToLive = oracleHelperConfig.cacheTimeToLive;\n        uint256 cacheAge = block.timestamp - cachedPriceTimestamp;\n        if (!force && cacheAge <= cacheTimeToLive) {\n            return cachedPrice;\n        }\n        uint256 priceUpdateThreshold = oracleHelperConfig.priceUpdateThreshold;\n        IOracle tokenOracle = oracleHelperConfig.tokenOracle;\n        IOracle nativeOracle = oracleHelperConfig.nativeOracle;\n\n        uint256 _cachedPrice = cachedPrice;\n        uint256 tokenPrice = fetchPrice(tokenOracle);\n        uint256 nativeAssetPrice = 1;\n        // If the 'TokenOracle' returns the price in the native asset units there is no need to fetch native asset price\n        if (!oracleHelperConfig.tokenToNativeOracle) {\n            nativeAssetPrice = fetchPrice(nativeOracle);\n        }\n        uint256 price = calculatePrice(\n            tokenPrice,\n            nativeAssetPrice,\n            oracleHelperConfig.tokenOracleReverse,\n            oracleHelperConfig.nativeOracleReverse\n        );\n        uint256 priceNewByOld = price * PRICE_DENOMINATOR / _cachedPrice;\n\n        bool updateRequired = force ||\n            priceNewByOld > PRICE_DENOMINATOR + priceUpdateThreshold ||\n            priceNewByOld < PRICE_DENOMINATOR - priceUpdateThreshold;\n        if (!updateRequired) {\n            return _cachedPrice;\n        }\n        uint256 previousPrice = _cachedPrice;\n        _cachedPrice = price;\n        cachedPrice = _cachedPrice;\n        cachedPriceTimestamp = uint48(block.timestamp);\n        emit TokenPriceUpdated(_cachedPrice, previousPrice, cachedPriceTimestamp);\n        return _cachedPrice;\n    }\n\n    /**\n     * Calculate the effective price of the selected token denominated in native asset.\n     *\n     * @param tokenPrice - the price of the token relative to a native asset or a bridging asset like the U.S. dollar.\n     * @param nativeAssetPrice - the price of the native asset relative to a bridging asset or 1 if no bridging needed.\n     * @param tokenOracleReverse - flag indicating direction of the \"tokenPrice\".\n     * @param nativeOracleReverse - flag indicating direction of the \"nativeAssetPrice\".\n     * @return the ether-per-token price multiplied by the PRICE_DENOMINATOR constant.\n     */\n    function calculatePrice(\n        uint256 tokenPrice,\n        uint256 nativeAssetPrice,\n        bool tokenOracleReverse,\n        bool nativeOracleReverse\n    ) private view returns (uint256){\n        // tokenPrice is normalized as dollars-per-token\n        if (tokenOracleReverse) {\n            // inverting tokenPrice that was tokens-per-dollar (or tokens-per-ether)\n            tokenPrice = PRICE_DENOMINATOR * tokenOracleDecimalPower / tokenPrice;\n        } else {\n            // tokenPrice already dollars-per-token (or ethers-per-token)\n            tokenPrice = PRICE_DENOMINATOR * tokenPrice / tokenOracleDecimalPower;\n        }\n\n        if (nativeOracleReverse) {\n            // multiplying by nativeAssetPrice that is  ethers-per-dollar\n            // => result = (dollar / token) * (ether / dollar) = ether / token\n            return nativeAssetPrice * tokenPrice / nativeOracleDecimalPower;\n        } else {\n            // dividing by nativeAssetPrice that is dollars-per-ether\n            // => result = (dollar / token) / (dollar / ether) = ether / token\n            return tokenPrice * nativeOracleDecimalPower / nativeAssetPrice;\n        }\n    }\n\n    /// @notice Fetches the latest price from the given Oracle.\n    /// @dev This function is used to get the latest price from the tokenOracle or nativeOracle.\n    /// @param _oracle The Oracle contract to fetch the price from.\n    /// @return price The latest price fetched from the Oracle.\n    function fetchPrice(IOracle _oracle) internal view returns (uint256 price) {\n        (uint80 roundId, int256 answer,, uint256 updatedAt, uint80 answeredInRound) = _oracle.latestRoundData();\n        require(answer > 0, \"TPM: Chainlink price <= 0\");\n        // 2 days old price is considered stale since the price is updated every 24 hours\n        require(updatedAt >= block.timestamp - 60 * 60 * 24 * 2, \"TPM: Incomplete round\");\n        require(answeredInRound >= roundId, \"TPM: Stale price\");\n        price = uint256(answer);\n    }\n}"
    },
    {
      "filename": "contracts/core/BasePaymaster.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable reason-string */\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"../interfaces/IPaymaster.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\nimport \"./Helpers.sol\";\nimport \"./UserOperationLib.sol\";\n/**\n * Helper class for creating a paymaster.\n * provides helper methods for staking.\n * Validates that the postOp is called only by the entryPoint.\n */\nabstract contract BasePaymaster is IPaymaster, Ownable {\n    IEntryPoint public immutable entryPoint;\n\n    uint256 internal constant PAYMASTER_VALIDATION_GAS_OFFSET = UserOperationLib.PAYMASTER_VALIDATION_GAS_OFFSET;\n    uint256 internal constant PAYMASTER_POSTOP_GAS_OFFSET = UserOperationLib.PAYMASTER_POSTOP_GAS_OFFSET;\n    uint256 internal constant PAYMASTER_DATA_OFFSET = UserOperationLib.PAYMASTER_DATA_OFFSET;\n\n    constructor(IEntryPoint _entryPoint) Ownable(msg.sender) {\n        _validateEntryPointInterface(_entryPoint);\n        entryPoint = _entryPoint;\n    }\n\n    //sanity check: make sure this EntryPoint was compiled against the same\n    // IEntryPoint of this paymaster\n    function _validateEntryPointInterface(IEntryPoint _entryPoint) internal virtual {\n        require(IERC165(address(_entryPoint)).supportsInterface(type(IEntryPoint).interfaceId), \"IEntryPoint interface mismatch\");\n    }\n\n    /// @inheritdoc IPaymaster\n    function validatePaymasterUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 maxCost\n    ) external override returns (bytes memory context, uint256 validationData) {\n        _requireFromEntryPoint();\n        return _validatePaymasterUserOp(userOp, userOpHash, maxCost);\n    }\n\n    /**\n     * Validate a user operation.\n     * @param userOp     - The user operation.\n     * @param userOpHash - The hash of the user operation.\n     * @param maxCost    - The maximum cost of the user operation.\n     */\n    function _validatePaymasterUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 maxCost\n    ) internal virtual returns (bytes memory context, uint256 validationData);\n\n    /// @inheritdoc IPaymaster\n    function postOp(\n        PostOpMode mode,\n        bytes calldata context,\n        uint256 actualGasCost,\n        uint256 actualUserOpFeePerGas\n    ) external override {\n        _requireFromEntryPoint();\n        _postOp(mode, context, actualGasCost, actualUserOpFeePerGas);\n    }\n\n    /**\n     * Post-operation handler.\n     * (verified to be called only through the entryPoint)\n     * @dev If subclass returns a non-empty context from validatePaymasterUserOp,\n     *      it must also implement this method.\n     * @param mode          - Enum with the following options:\n     *                        opSucceeded - User operation succeeded.\n     *                        opReverted  - User op reverted. still has to pay for gas.\n     *                        postOpReverted - User op succeeded, but caused postOp (in mode=opSucceeded) to revert.\n     *                                         Now this is the 2nd call, after user's op was deliberately reverted.\n     * @param context       - The context value returned by validatePaymasterUserOp\n     * @param actualUserOpFeePerGas - the gas price this UserOp pays. This value is based on the UserOp's maxFeePerGas\n     *                        and maxPriorityFee (and basefee)\n     *                        It is not the same as tx.gasprice, which is what the bundler pays.\n\n     */\n    function _postOp(\n        PostOpMode mode,\n        bytes calldata context,\n        uint256 actualGasCost,\n        uint256 actualUserOpFeePerGas\n    ) internal virtual {\n        (mode, context, actualGasCost, actualUserOpFeePerGas); // unused params\n        // subclass must override this method if validatePaymasterUserOp returns a context\n        revert(\"must override\");\n    }\n\n    /**\n     * Add a deposit for this paymaster, used for paying for transaction fees.\n     */\n    function deposit() public payable {\n        entryPoint.depositTo{value: msg.value}(address(this));\n    }\n\n    /**\n     * Withdraw value from the deposit.\n     * @param withdrawAddress - Target to send to.\n     * @param amount          - Amount to withdraw.\n     */\n    function withdrawTo(\n        address payable withdrawAddress,\n        uint256 amount\n    ) public onlyOwner {\n        entryPoint.withdrawTo(withdrawAddress, amount);\n    }\n\n    /**\n     * Add stake for this paymaster.\n     * This method can also carry eth value to add to the current stake.\n     * @param unstakeDelaySec - The unstake delay for this paymaster. Can only be increased.\n     */\n    function addStake(uint32 unstakeDelaySec) external payable onlyOwner {\n        entryPoint.addStake{value: msg.value}(unstakeDelaySec);\n    }\n\n    /**\n     * Return current paymaster's deposit on the entryPoint.\n     */\n    function getDeposit() public view returns (uint256) {\n        return entryPoint.balanceOf(address(this));\n    }\n\n    /**\n     * Unlock the stake, in order to withdraw it.\n     * The paymaster can't serve requests once unlocked, until it calls addStake again\n     */\n    function unlockStake() external onlyOwner {\n        entryPoint.unlockStake();\n    }\n\n    /**\n     * Withdraw the entire paymaster's stake.\n     * stake must be unlocked first (and then wait for the unstakeDelay to be over)\n     * @param withdrawAddress - The address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external onlyOwner {\n        entryPoint.withdrawStake(withdrawAddress);\n    }\n\n    /**\n     * Validate the call is made from a valid entrypoint\n     */\n    function _requireFromEntryPoint() internal virtual {\n        require(msg.sender == address(entryPoint), \"Sender not EntryPoint\");\n    }\n}"
    },
    {
      "filename": "contracts/samples/bls/BLSSignatureAggregator.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4 <0.9.0;\npragma abicoder v2;\n\nimport \"../../interfaces/IAggregator.sol\";\nimport \"../../interfaces/IEntryPoint.sol\";\nimport \"../../core/UserOperationLib.sol\";\nimport {BLSOpen} from  \"./lib/BLSOpen.sol\";\nimport \"./IBLSAccount.sol\";\nimport \"./BLSHelper.sol\";\n\n/**\n * A BLS-based signature aggregator, to validate aggregated signature of multiple UserOps if BLSAccount\n */\ncontract BLSSignatureAggregator is IAggregator {\n    using UserOperationLib for PackedUserOperation;\n\n    bytes32 public constant BLS_DOMAIN = keccak256(\"eip4337.bls.domain\");\n\n     //copied from BLS.sol\n    uint256 public  constant N = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    address public immutable entryPoint;\n\n    constructor(address _entryPoint) {\n        entryPoint = _entryPoint;\n    }\n\n    /**\n     * @return publicKey - the public key from a BLS keypair the Aggregator will use to verify this UserOp;\n     *         normally public key will be queried from the deployed BLSAccount itself;\n     *         the public key will be read from the 'initCode' if the account is not deployed yet;\n     */\n    function getUserOpPublicKey(PackedUserOperation memory userOp) public view returns (uint256[4] memory publicKey) {\n        bytes memory initCode = userOp.initCode;\n        if (initCode.length > 0) {\n            publicKey = getTrailingPublicKey(initCode);\n        } else {\n            return IBLSAccount(userOp.sender).getBlsPublicKey{gas : 50000}();\n        }\n    }\n\n    /**\n     * return the trailing 4 words of input data\n     */\n    function getTrailingPublicKey(bytes memory data) public pure returns (uint256[4] memory publicKey) {\n        uint len = data.length;\n        require(len > 32 * 4, \"data too short for sig\");\n\n        /* solhint-disable-next-line no-inline-assembly */\n        assembly {\n        // actual buffer starts at data+32, so last 128 bytes start at data+32+len-128 = data+len-96\n            let ofs := sub(add(data, len), 96)\n            mstore(publicKey, mload(ofs))\n            mstore(add(publicKey, 32), mload(add(ofs, 32)))\n            mstore(add(publicKey, 64), mload(add(ofs, 64)))\n            mstore(add(publicKey, 96), mload(add(ofs, 96)))\n        }\n    }\n\n    /// @inheritdoc IAggregator\n    function validateSignatures(PackedUserOperation[] calldata userOps, bytes calldata signature)\n    external view override {\n        require(signature.length == 64, \"BLS: invalid signature\");\n        (uint256[2] memory blsSignature) = abi.decode(signature, (uint256[2]));\n\n        uint userOpsLen = userOps.length;\n        uint256[4][] memory blsPublicKeys = new uint256[4][](userOpsLen);\n        uint256[2][] memory messages = new uint256[2][](userOpsLen);\n        for (uint256 i = 0; i < userOpsLen; i++) {\n\n            PackedUserOperation memory userOp = userOps[i];\n            blsPublicKeys[i] = getUserOpPublicKey(userOp);\n\n            messages[i] = _userOpToMessage(userOp, _getPublicKeyHash(blsPublicKeys[i]));\n        }\n        require(BLSOpen.verifyMultiple(blsSignature, blsPublicKeys, messages), \"BLS: validateSignatures failed\");\n    }\n\n    /**\n     * get a hash of userOp\n     * NOTE: this hash is not the same as UserOperation.hash()\n     *  (slightly less efficient, since it uses memory userOp)\n     */\n    function internalUserOpHash(PackedUserOperation memory userOp) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n                userOp.sender,\n                userOp.nonce,\n                keccak256(userOp.initCode),\n                keccak256(userOp.callData),\n                userOp.accountGasLimits,\n                userOp.preVerificationGas,\n                userOp.maxFeePerGas,\n                userOp.maxPriorityFeePerGas,\n                keccak256(userOp.paymasterAndData)\n            ));\n    }\n\n    /**\n     * return the BLS \"message\" for the given UserOp.\n     * the account checks the signature over this value using its public key\n     */\n    function userOpToMessage(PackedUserOperation memory userOp) public view returns (uint256[2] memory) {\n        bytes32 publicKeyHash = _getPublicKeyHash(getUserOpPublicKey(userOp));\n        return _userOpToMessage(userOp, publicKeyHash);\n    }\n\n    function _userOpToMessage(PackedUserOperation memory userOp, bytes32 publicKeyHash) internal view returns (uint256[2] memory) {\n        bytes32 userOpHash = _getUserOpHash(userOp, publicKeyHash);\n        return BLSOpen.hashToPoint(BLS_DOMAIN, abi.encodePacked(userOpHash));\n    }\n\n    function getUserOpHash(PackedUserOperation memory userOp) public view returns (bytes32) {\n        bytes32 publicKeyHash = _getPublicKeyHash(getUserOpPublicKey(userOp));\n        return _getUserOpHash(userOp, publicKeyHash);\n    }\n\n    function _getUserOpHash(PackedUserOperation memory userOp, bytes32 publicKeyHash) internal view returns (bytes32) {\n        return keccak256(abi.encode(internalUserOpHash(userOp), publicKeyHash, address(this), block.chainid, entryPoint));\n    }\n\n    function _getPublicKeyHash(uint256[4] memory publicKey) internal pure returns(bytes32) {\n        return keccak256(abi.encode(publicKey));\n    }\n    /**\n     * validate signature of a single userOp\n     * This method is called after EntryPoint.simulateValidation() returns an aggregator.\n     * First it validates the signature over the userOp. then it return data to be used when creating the handleOps:\n     * @param userOp the userOperation received from the user.\n     * @return sigForUserOp the value to put into the signature field of the userOp when calling handleOps.\n     *    (usually empty, unless account and aggregator support some kind of \"multisig\"\n     */\n    function validateUserOpSignature(PackedUserOperation calldata userOp)\n    external view returns (bytes memory sigForUserOp) {\n        uint256[2] memory signature = abi.decode(userOp.signature, (uint256[2]));\n        uint256[4] memory pubkey = getUserOpPublicKey(userOp);\n        uint256[2] memory message = _userOpToMessage(userOp, _getPublicKeyHash(pubkey));\n\n        require(BLSOpen.verifySingle(signature, pubkey, message), \"BLS: wrong sig\");\n        return \"\";\n    }\n\n\n    /**\n     * aggregate multiple signatures into a single value.\n     * This method is called off-chain to calculate the signature to pass with handleOps()\n     * bundler MAY use optimized custom code perform this aggregation\n     * @param userOps array of UserOperations to collect the signatures from.\n     * @return aggregatedSignature the aggregated signature\n     */\n    function aggregateSignatures(PackedUserOperation[] calldata userOps) external pure returns (bytes memory aggregatedSignature) {\n        BLSHelper.XY[] memory points = new BLSHelper.XY[](userOps.length);\n        for (uint i = 0; i < points.length; i++) {\n            (uint256 x, uint256 y) = abi.decode(userOps[i].signature, (uint256, uint256));\n            points[i] = BLSHelper.XY(x, y);\n        }\n        BLSHelper.XY memory sum = BLSHelper.sum(points, N);\n        return abi.encode(sum.x, sum.y);\n    }\n\n    /**\n     * allow staking for this aggregator\n     * there is no limit on stake or delay, but it is not a problem, since it is a permissionless\n     * signature aggregator, which doesn't support unstaking.\n     */\n    function addStake(uint32 delay) external payable {\n        IEntryPoint(entryPoint).addStake{value : msg.value}(delay);\n    }\n}"
    },
    {
      "filename": "contracts/samples/bls/BLSSignatureAggregator.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4 <0.9.0;\npragma abicoder v2;\n\nimport \"../../interfaces/IAggregator.sol\";\nimport \"../../interfaces/IEntryPoint.sol\";\nimport \"../../core/UserOperationLib.sol\";\nimport {BLSOpen} from  \"./lib/BLSOpen.sol\";\nimport \"./IBLSAccount.sol\";\nimport \"./BLSHelper.sol\";\n\n/**\n * A BLS-based signature aggregator, to validate aggregated signature of multiple UserOps if BLSAccount\n */\ncontract BLSSignatureAggregator is IAggregator {\n    using UserOperationLib for PackedUserOperation;\n\n    bytes32 public constant BLS_DOMAIN = keccak256(\"eip4337.bls.domain\");\n\n     //copied from BLS.sol\n    uint256 public  constant N = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    address public immutable entryPoint;\n\n    constructor(address _entryPoint) {\n        entryPoint = _entryPoint;\n    }\n\n    /**\n     * @return publicKey - the public key from a BLS keypair the Aggregator will use to verify this UserOp;\n     *         normally public key will be queried from the deployed BLSAccount itself;\n     *         the public key will be read from the 'initCode' if the account is not deployed yet;\n     */\n    function getUserOpPublicKey(PackedUserOperation memory userOp) public view returns (uint256[4] memory publicKey) {\n        bytes memory initCode = userOp.initCode;\n        if (initCode.length > 0) {\n            publicKey = getTrailingPublicKey(initCode);\n        } else {\n            return IBLSAccount(userOp.sender).getBlsPublicKey{gas : 50000}();\n        }\n    }\n\n    /**\n     * return the trailing 4 words of input data\n     */\n    function getTrailingPublicKey(bytes memory data) public pure returns (uint256[4] memory publicKey) {\n        uint len = data.length;\n        require(len > 32 * 4, \"data too short for sig\");\n\n        /* solhint-disable-next-line no-inline-assembly */\n        assembly {\n        // actual buffer starts at data+32, so last 128 bytes start at data+32+len-128 = data+len-96\n            let ofs := sub(add(data, len), 96)\n            mstore(publicKey, mload(ofs))\n            mstore(add(publicKey, 32), mload(add(ofs, 32)))\n            mstore(add(publicKey, 64), mload(add(ofs, 64)))\n            mstore(add(publicKey, 96), mload(add(ofs, 96)))\n        }\n    }\n\n    /// @inheritdoc IAggregator\n    function validateSignatures(PackedUserOperation[] calldata userOps, bytes calldata signature)\n    external view override {\n        require(signature.length == 64, \"BLS: invalid signature\");\n        (uint256[2] memory blsSignature) = abi.decode(signature, (uint256[2]));\n\n        uint userOpsLen = userOps.length;\n        uint256[4][] memory blsPublicKeys = new uint256[4][](userOpsLen);\n        uint256[2][] memory messages = new uint256[2][](userOpsLen);\n        for (uint256 i = 0; i < userOpsLen; i++) {\n\n            PackedUserOperation memory userOp = userOps[i];\n            blsPublicKeys[i] = getUserOpPublicKey(userOp);\n\n            messages[i] = _userOpToMessage(userOp, _getPublicKeyHash(blsPublicKeys[i]));\n        }\n        require(BLSOpen.verifyMultiple(blsSignature, blsPublicKeys, messages), \"BLS: validateSignatures failed\");\n    }\n\n    /**\n     * get a hash of userOp\n     * NOTE: this hash is not the same as UserOperation.hash()\n     *  (slightly less efficient, since it uses memory userOp)\n     */\n    function internalUserOpHash(PackedUserOperation memory userOp) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n                userOp.sender,\n                userOp.nonce,\n                keccak256(userOp.initCode),\n                keccak256(userOp.callData),\n                userOp.accountGasLimits,\n                userOp.preVerificationGas,\n                userOp.maxFeePerGas,\n                userOp.maxPriorityFeePerGas,\n                keccak256(userOp.paymasterAndData)\n            ));\n    }\n\n    /**\n     * return the BLS \"message\" for the given UserOp.\n     * the account checks the signature over this value using its public key\n     */\n    function userOpToMessage(PackedUserOperation memory userOp) public view returns (uint256[2] memory) {\n        bytes32 publicKeyHash = _getPublicKeyHash(getUserOpPublicKey(userOp));\n        return _userOpToMessage(userOp, publicKeyHash);\n    }\n\n    function _userOpToMessage(PackedUserOperation memory userOp, bytes32 publicKeyHash) internal view returns (uint256[2] memory) {\n        bytes32 userOpHash = _getUserOpHash(userOp, publicKeyHash);\n        return BLSOpen.hashToPoint(BLS_DOMAIN, abi.encodePacked(userOpHash));\n    }\n\n    function getUserOpHash(PackedUserOperation memory userOp) public view returns (bytes32) {\n        bytes32 publicKeyHash = _getPublicKeyHash(getUserOpPublicKey(userOp));\n        return _getUserOpHash(userOp, publicKeyHash);\n    }\n\n    function _getUserOpHash(PackedUserOperation memory userOp, bytes32 publicKeyHash) internal view returns (bytes32) {\n        return keccak256(abi.encode(internalUserOpHash(userOp), publicKeyHash, address(this), block.chainid, entryPoint));\n    }\n\n    function _getPublicKeyHash(uint256[4] memory publicKey) internal pure returns(bytes32) {\n        return keccak256(abi.encode(publicKey));\n    }\n    /**\n     * validate signature of a single userOp\n     * This method is called after EntryPoint.simulateValidation() returns an aggregator.\n     * First it validates the signature over the userOp. then it return data to be used when creating the handleOps:\n     * @param userOp the userOperation received from the user.\n     * @return sigForUserOp the value to put into the signature field of the userOp when calling handleOps.\n     *    (usually empty, unless account and aggregator support some kind of \"multisig\"\n     */\n    function validateUserOpSignature(PackedUserOperation calldata userOp)\n    external view returns (bytes memory sigForUserOp) {\n        uint256[2] memory signature = abi.decode(userOp.signature, (uint256[2]));\n        uint256[4] memory pubkey = getUserOpPublicKey(userOp);\n        uint256[2] memory message = _userOpToMessage(userOp, _getPublicKeyHash(pubkey));\n\n        require(BLSOpen.verifySingle(signature, pubkey, message), \"BLS: wrong sig\");\n        return \"\";\n    }\n\n\n    /**\n     * aggregate multiple signatures into a single value.\n     * This method is called off-chain to calculate the signature to pass with handleOps()\n     * bundler MAY use optimized custom code perform this aggregation\n     * @param userOps array of UserOperations to collect the signatures from.\n     * @return aggregatedSignature the aggregated signature\n     */\n    function aggregateSignatures(PackedUserOperation[] calldata userOps) external pure returns (bytes memory aggregatedSignature) {\n        BLSHelper.XY[] memory points = new BLSHelper.XY[](userOps.length);\n        for (uint i = 0; i < points.length; i++) {\n            (uint256 x, uint256 y) = abi.decode(userOps[i].signature, (uint256, uint256));\n            points[i] = BLSHelper.XY(x, y);\n        }\n        BLSHelper.XY memory sum = BLSHelper.sum(points, N);\n        return abi.encode(sum.x, sum.y);\n    }\n\n    /**\n     * allow staking for this aggregator\n     * there is no limit on stake or delay, but it is not a problem, since it is a permissionless\n     * signature aggregator, which doesn't support unstaking.\n     */\n    function addStake(uint32 delay) external payable {\n        IEntryPoint(entryPoint).addStake{value : msg.value}(delay);\n    }\n}"
    },
    {
      "filename": "contracts/core/BaseAccount.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-empty-blocks */\n\nimport \"../interfaces/IAccount.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\nimport \"./Helpers.sol\";\nimport \"./UserOperationLib.sol\";\n\n/**\n * Basic account implementation.\n * This contract provides the basic logic for implementing the IAccount interface - validateUserOp\n * Specific account implementation should inherit it and provide the account-specific logic.\n */\nabstract contract BaseAccount is IAccount {\n    using UserOperationLib for PackedUserOperation;\n\n    /**\n     * Return value in case of signature failure, with no time-range.\n     * Equivalent to _packValidationData(true,0,0).\n     */\n    uint256 internal constant SIG_VALIDATION_FAILED = 1;\n\n    /**\n     * Return the account nonce.\n     * This method returns the next sequential nonce.\n     * For a nonce of a specific key, use `entrypoint.getNonce(account, key)`\n     */\n    function getNonce() public view virtual returns (uint256) {\n        return entryPoint().getNonce(address(this), 0);\n    }\n\n    /**\n     * Return the entryPoint used by this account.\n     * Subclass should return the current entryPoint used by this account.\n     */\n    function entryPoint() public view virtual returns (IEntryPoint);\n\n    /**\n     * Validate user's signature and nonce.\n     * Subclass doesn't need to override this method. Instead,\n     * it should override the specific internal validation methods.\n     * @param userOp              - The user operation to validate.\n     * @param userOpHash          - The hash of the user operation.\n     * @param missingAccountFunds - The amount of funds missing from the account\n     *                              to pay for the user operation.\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    ) external virtual override returns (uint256 validationData) {\n        _requireFromEntryPoint();\n        validationData = _validateSignature(userOp, userOpHash);\n        _validateNonce(userOp.nonce);\n        _payPrefund(missingAccountFunds);\n    }\n\n    /**\n     * Ensure the request comes from the known entrypoint.\n     */\n    function _requireFromEntryPoint() internal view virtual {\n        require(\n            msg.sender == address(entryPoint()),\n            \"account: not from EntryPoint\"\n        );\n    }\n\n    /**\n     * Validate the signature is valid for this message.\n     * @param userOp          - Validate the userOp.signature field.\n     * @param userOpHash      - Convenient field: the hash of the request, to check the signature against.\n     *                          (also hashes the entrypoint and chain id)\n     * @return validationData - Signature and time-range of this operation.\n     *                          <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\n     *                              otherwise, an address of an \"authorizer\" contract.\n     *                          <6-byte> validUntil - last timestamp this operation is valid. 0 for \"indefinite\"\n     *                          <6-byte> validAfter - first timestamp this operation is valid\n     *                          If the account doesn't use time-range, it is enough to return\n     *                          SIG_VALIDATION_FAILED value (1) for signature failure.\n     *                          Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function _validateSignature(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash\n    ) internal virtual returns (uint256 validationData);\n\n    /**\n     * Validate the nonce of the UserOperation.\n     * This method may validate the nonce requirement of this account.\n     * e.g.\n     * To limit the nonce to use sequenced UserOps only (no \"out of order\" UserOps):\n     *      `require(nonce < type(uint64).max)`\n     * For a hypothetical account that *requires* the nonce to be out-of-order:\n     *      `require(nonce & type(uint64).max == 0)`\n     *\n     * The actual nonce uniqueness is managed by the EntryPoint, and thus no other\n     * action is needed by the account itself.\n     *\n     * @param"
    }
  ]
}