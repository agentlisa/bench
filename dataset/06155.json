{
  "Title": "[M-05] Gas fees are refunded to a wrong address when transferring tokens via `InterchainToken.interchainTransferFrom`",
  "Content": "\nIn a case when gas fees are refunded for a token transfer made via the `InterchainToken.interchainTransferFrom` function, the fees will be refunded to the owner of the tokens, not the address that actually paid the fees. As a result, the sender will lose the fees paid for the cross-chain transaction and will not receive tokens on the other chain; the owner of the token will have their tokens and will receive the fees.\n\n### Proof of Concept\n\nThe [InterchainToken.interchainTransferFrom](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/interchain-token/InterchainToken.sol#L79) function is used to transfer tokens cross-chain. The function is identical to the `ERC20.transferFrom` function: an approved address can send someone else's tokens to another chain. Since this is a cross-chain transaction, the sender also has to pay the additional gas fee for executing the transaction:\n\n1. The function calls [tokenManager.transmitInterchainTransfer](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/interchain-token/InterchainToken.sol#L104);\n2. `tokenManager.transmitInterchainTransfer` calls [interchainTokenService.transmitSendToken](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/token-manager/TokenManager.sol#L145);\n3. `interchainTokenService.transmitSendToken` calls [\\_callContract](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/interchain-token-service/InterchainTokenService.sol#L513);\n4. `_callContract` uses the `msg.value` to [pay the extra gas fees](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/interchain-token-service/InterchainTokenService.sol#L716).\n\nNotice that the `gasService.payNativeGasForContractCall` call in `_callContract` takes the `refundTo` address, i.e. the address that will receive refunded gas fee. If we return up on the call stack, we'll see that the refund address is the sender address that's [passed to the `tokenManager.transmitInterchainTransfer` call](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/interchain-token/InterchainToken.sol#L104). Thus, the gas fees will be refunded to the token owner, not the caller; however, it's the caller who pays them.\n\n### Recommended Mitigation Steps\n\nThe `TokenManager.transmitInterchainTransfer` and the `InterchainTokenService.transmitSendToken` functions, besides taking the `sender`/`sourceAddress` argument, need to also take the \"refund to\" address. In the `InterchainToken.interchainTransferFrom` function, the two arguments will be set to different addresses: the `sender`/`sourceAddress` argument will be set to the token owner address; the new \"refund to\" argument will be set to `msg.sender`. Thus, while tokens will be taken from their owner, the cross-chain gas fees will be refunded to the actual transaction sender.\n\n### Assessed type\n\nETH-Transfer\n\n**[deanamiel (Axelar) disagreed with severity and commented](https://github.com/code-423n4/2023-07-axelar-findings/issues/316#issuecomment-1693752370):**\n> Corrected Severity: QA\n>\n> In most cases, it will have been called by the sender anyway, so having the sender be refunded is the desired effect. Sometimes this will not be the case though, depending on the use case. Therefore, we have added a parameter to keep track of where the funds need to be refunded.\n> \n> Link to public PR: https://github.com/axelarnetwork/interchain-token-service/pull/96\n\n**[berndartmueller (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-07-axelar-findings/issues/316#issuecomment-1702538812):**\n > Considering this medium severity as per:\n >> \"...In most cases it will have been called by the sender anyway\" (sponsors statement above).\n >\n > Nevertheless, in the cases where an approved address transfers the tokens, the gas is incorrectly refunded.\n\n**[milapsheth (Axelar) commented](https://github.com/code-423n4/2023-07-axelar-findings/issues/316#issuecomment-1801781480):**\n> We acknowledge the severity.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-axelar",
  "Code": [
    {
      "filename": "contracts/its/interchain-token/InterchainToken.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IInterchainToken } from '../interfaces/IInterchainToken.sol';\nimport { ITokenManager } from '../interfaces/ITokenManager.sol';\nimport { ERC20 } from '../token-implementations/ERC20.sol';\n\n/**\n * @title An example implementation of the IInterchainToken.\n * @notice The implementation ERC20 can be done in any way, however this example assumes that an _approve internal function exists\n * that can be used to create approvals, and that `allowance` is a mapping.\n * @dev You can skip the `tokenManagerRequiresApproval()` function altogether if you know what it should return for your token.\n */\nabstract contract InterchainToken is IInterchainToken, ERC20 {\n    /**\n     * @notice Getter for the tokenManager used for this token.\n     * @dev Needs to be overwitten.\n     * @return tokenManager the TokenManager called to facilitate cross chain transfers.\n     */\n    function getTokenManager() public view virtual returns (ITokenManager tokenManager);\n\n    /**\n     * @notice Getter function specifiying if the tokenManager requires approval to facilitate cross-chain transfers.\n     * Usually, only mint/burn tokenManagers do not need approval.\n     * @dev The return value depends on the implementation of ERC20.\n     * In case of lock/unlock and liquidity pool TokenManagers it is possible to implement transferFrom to allow the\n     * TokenManager specifically to do it permissionlesly.\n     * On the other hand you can implement burn in a way that requires approval for a mint/burn TokenManager\n     * @return tokenManager the TokenManager called to facilitate cross chain transfers.\n     */\n    function tokenManagerRequiresApproval() public view virtual returns (bool);\n\n    /**\n     * @notice Implementation of the interchainTransfer method\n     * @dev We chose to either pass `metadata` as raw data on a remote contract call, or, if no data is passed, just do a transfer.\n     * A different implementation could have `metadata` that tells this function which function to use or that it is used for anything else as well.\n     * @param destinationChain The destination chain identifier.\n     * @param recipient The bytes representation of the address of the recipient.\n     * @param amount The amount of token to be transfered.\n     * @param metadata Either empty, to just facilitate an interchain transfer, or the data can be passed for an interchain contract call with transfer as per semantics defined by the token service.\n     */\n    function interchainTransfer(\n        string calldata destinationChain,\n        bytes calldata recipient,\n        uint256 amount,\n        bytes calldata metadata\n    ) external payable {\n        address sender = msg.sender;\n        ITokenManager tokenManager = getTokenManager();\n        /**\n         * @dev if you know the value of `tokenManagerRequiresApproval()` you can just skip the if statement and just do nothing or _approve.\n         */\n        if (tokenManagerRequiresApproval()) {\n            uint256 allowance_ = allowance[sender][address(tokenManager)];\n            if (allowance_ != type(uint256).max) {\n                if (allowance_ > type(uint256).max - amount) {\n                    allowance_ = type(uint256).max - amount;\n                }\n\n                _approve(sender, address(tokenManager), allowance_ + amount);\n            }\n        }\n\n        // Metadata semantics are defined by the token service and thus should be passed as-is.\n        tokenManager.transmitInterchainTransfer{ value: msg.value }(sender, destinationChain, recipient, amount, metadata);\n    }\n\n    /**\n     * @notice Implementation of the interchainTransferFrom method\n     * @dev We chose to either pass `metadata` as raw data on a remote contract call, or, if no data is passed, just do a transfer.\n     * A different implementation could have `metadata` that tells this function which function to use or that it is used for anything else as well.\n     * @param sender the sender of the tokens. They need to have approved `msg.sender` before this is called.\n     * @param destinationChain the string representation of the destination chain.\n     * @param recipient the bytes representation of the address of the recipient.\n     * @param amount the amount of token to be transfered.\n     * @param metadata either empty, to just facilitate a cross-chain transfer, or the data to be passed to a cross-chain contract call and transfer.\n     */\n    function interchainTransferFrom(\n        address sender,\n        string calldata destinationChain,\n        bytes calldata recipient,\n        uint256 amount,\n        bytes calldata metadata\n    ) external payable {\n        uint256 _allowance = allowance[sender][msg.sender];\n\n        if (_allowance != type(uint256).max) {\n            _approve(sender, msg.sender, _allowance - amount);\n        }\n\n        ITokenManager tokenManager = getTokenManager();\n        if (tokenManagerRequiresApproval()) {\n            uint256 allowance_ = allowance[sender][address(tokenManager)];\n            if (allowance_ != type(uint256).max) {\n                if (allowance_ > type(uint256).max - amount) {\n                    allowance_ = type(uint256).max - amount;\n                }\n\n                _approve(sender, address(tokenManager), allowance_ + amount);\n            }\n        }\n\n        tokenManager.transmitInterchainTransfer{ value: msg.value }(sender, destinationChain, recipient, amount, metadata);\n    }\n}"
    },
    {
      "filename": "contracts/its/interchain-token/InterchainToken.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IInterchainToken } from '../interfaces/IInterchainToken.sol';\nimport { ITokenManager } from '../interfaces/ITokenManager.sol';\nimport { ERC20 } from '../token-implementations/ERC20.sol';\n\n/**\n * @title An example implementation of the IInterchainToken.\n * @notice The implementation ERC20 can be done in any way, however this example assumes that an _approve internal function exists\n * that can be used to create approvals, and that `allowance` is a mapping.\n * @dev You can skip the `tokenManagerRequiresApproval()` function altogether if you know what it should return for your token.\n */\nabstract contract InterchainToken is IInterchainToken, ERC20 {\n    /**\n     * @notice Getter for the tokenManager used for this token.\n     * @dev Needs to be overwitten.\n     * @return tokenManager the TokenManager called to facilitate cross chain transfers.\n     */\n    function getTokenManager() public view virtual returns (ITokenManager tokenManager);\n\n    /**\n     * @notice Getter function specifiying if the tokenManager requires approval to facilitate cross-chain transfers.\n     * Usually, only mint/burn tokenManagers do not need approval.\n     * @dev The return value depends on the implementation of ERC20.\n     * In case of lock/unlock and liquidity pool TokenManagers it is possible to implement transferFrom to allow the\n     * TokenManager specifically to do it permissionlesly.\n     * On the other hand you can implement burn in a way that requires approval for a mint/burn TokenManager\n     * @return tokenManager the TokenManager called to facilitate cross chain transfers.\n     */\n    function tokenManagerRequiresApproval() public view virtual returns (bool);\n\n    /**\n     * @notice Implementation of the interchainTransfer method\n     * @dev We chose to either pass `metadata` as raw data on a remote contract call, or, if no data is passed, just do a transfer.\n     * A different implementation could have `metadata` that tells this function which function to use or that it is used for anything else as well.\n     * @param destinationChain The destination chain identifier.\n     * @param recipient The bytes representation of the address of the recipient.\n     * @param amount The amount of token to be transfered.\n     * @param metadata Either empty, to just facilitate an interchain transfer, or the data can be passed for an interchain contract call with transfer as per semantics defined by the token service.\n     */\n    function interchainTransfer(\n        string calldata destinationChain,\n        bytes calldata recipient,\n        uint256 amount,\n        bytes calldata metadata\n    ) external payable {\n        address sender = msg.sender;\n        ITokenManager tokenManager = getTokenManager();\n        /**\n         * @dev if you know the value of `tokenManagerRequiresApproval()` you can just skip the if statement and just do nothing or _approve.\n         */\n        if (tokenManagerRequiresApproval()) {\n            uint256 allowance_ = allowance[sender][address(tokenManager)];\n            if (allowance_ != type(uint256).max) {\n                if (allowance_ > type(uint256).max - amount) {\n                    allowance_ = type(uint256).max - amount;\n                }\n\n                _approve(sender, address(tokenManager), allowance_ + amount);\n            }\n        }\n\n        // Metadata semantics are defined by the token service and thus should be passed as-is.\n        tokenManager.transmitInterchainTransfer{ value: msg.value }(sender, destinationChain, recipient, amount, metadata);\n    }\n\n    /**\n     * @notice Implementation of the interchainTransferFrom method\n     * @dev We chose to either pass `metadata` as raw data on a remote contract call, or, if no data is passed, just do a transfer.\n     * A different implementation could have `metadata` that tells this function which function to use or that it is used for anything else as well.\n     * @param sender the sender of the tokens. They need to have approved `msg.sender` before this is called.\n     * @param destinationChain the string representation of the destination chain.\n     * @param recipient the bytes representation of the address of the recipient.\n     * @param amount the amount of token to be transfered.\n     * @param metadata either empty, to just facilitate a cross-chain transfer, or the data to be passed to a cross-chain contract call and transfer.\n     */\n    function interchainTransferFrom(\n        address sender,\n        string calldata destinationChain,\n        bytes calldata recipient,\n        uint256 amount,\n        bytes calldata metadata\n    ) external payable {\n        uint256 _allowance = allowance[sender][msg.sender];\n\n        if (_allowance != type(uint256).max) {\n            _approve(sender, msg.sender, _allowance - amount);\n        }\n\n        ITokenManager tokenManager = getTokenManager();\n        if (tokenManagerRequiresApproval()) {\n            uint256 allowance_ = allowance[sender][address(tokenManager)];\n            if (allowance_ != type(uint256).max) {\n                if (allowance_ > type(uint256).max - amount) {\n                    allowance_ = type(uint256).max - amount;\n                }\n\n                _approve(sender, address(tokenManager), allowance_ + amount);\n            }\n        }\n\n        tokenManager.transmitInterchainTransfer{ value: msg.value }(sender, destinationChain, recipient, amount, metadata);\n    }\n}"
    },
    {
      "filename": "contracts/its/token-manager/TokenManager.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ITokenManager } from '../interfaces/ITokenManager.sol';\nimport { IInterchainTokenService } from '../interfaces/IInterchainTokenService.sol';\nimport { ITokenManagerProxy } from '../interfaces/ITokenManagerProxy.sol';\n\nimport { Operatable } from '../utils/Operatable.sol';\nimport { FlowLimit } from '../utils/FlowLimit.sol';\nimport { AddressBytesUtils } from '../libraries/AddressBytesUtils.sol';\nimport { Implementation } from '../utils/Implementation.sol';\n\n/**\n * @title The main functionality of TokenManagers.\n * @notice This contract is responsible for handling tokens before initiating a cross chain token transfer, or after receiving one.\n */\nabstract contract TokenManager is ITokenManager, Operatable, FlowLimit, Implementation {\n    using AddressBytesUtils for bytes;\n\n    IInterchainTokenService public immutable interchainTokenService;\n\n    /**\n     * @notice Constructs the TokenManager contract.\n     * @param interchainTokenService_ The address of the interchain token service\n     */\n    constructor(address interchainTokenService_) {\n        if (interchainTokenService_ == address(0)) revert TokenLinkerZeroAddress();\n        interchainTokenService = IInterchainTokenService(interchainTokenService_);\n    }\n\n    /**\n     * @dev A modifier that allows only the interchain token service to execute the function.\n     */\n    modifier onlyService() {\n        if (msg.sender != address(interchainTokenService)) revert NotService();\n        _;\n    }\n\n    /**\n     * @dev A modifier that allows only the token to execute the function.\n     */\n    modifier onlyToken() {\n        if (msg.sender != tokenAddress()) revert NotToken();\n        _;\n    }\n\n    /**\n     * @notice A function that should return the address of the token.\n     * Must be overridden in the inheriting contract.\n     * @return address address of the token.\n     */\n    function tokenAddress() public view virtual returns (address);\n\n    /**\n     * @dev This function should only be called by the proxy, and only once from the proxy constructor\n     * @param params the parameters to be used to initialize the TokenManager. The exact format depends\n     * on the type of TokenManager used but the first 32 bytes are reserved for the address of the operator,\n     * stored as bytes (to be compatible with non-EVM chains)\n     */\n    function setup(bytes calldata params) external override onlyProxy {\n        bytes memory operatorBytes = abi.decode(params, (bytes));\n        address operator_;\n        /**\n         * @dev Specifying an empty operator will default to the service being the operator. This makes it easy to deploy\n         * remote standardized tokens without knowing anything about the service address at the destination.\n         */\n        if (operatorBytes.length == 0) {\n            operator_ = address(interchainTokenService);\n        } else {\n            operator_ = operatorBytes.toAddress();\n        }\n        _setOperator(operator_);\n        _setup(params);\n    }\n\n    /**\n     * @notice Calls the service to initiate the a cross-chain transfer after taking the appropriate amount of tokens from the user.\n     * @param destinationChain the name of the chain to send tokens to.\n     * @param destinationAddress the address of the user to send tokens to.\n     * @param amount the amount of tokens to take from msg.sender.\n     */\n    function sendToken(\n        string calldata destinationChain,\n        bytes calldata destinationAddress,\n        uint256 amount,\n        bytes calldata metadata\n    ) external payable virtual {\n        address sender = msg.sender;\n        amount = _takeToken(sender, amount);\n        _addFlowOut(amount);\n        interchainTokenService.transmitSendToken{ value: msg.value }(\n            _getTokenId(),\n            sender,\n            destinationChain,\n            destinationAddress,\n            amount,\n            metadata\n        );\n    }\n\n    /**\n     * @notice Calls the service to initiate the a cross-chain transfer with data after taking the appropriate amount of tokens from the user.\n     * @param destinationChain the name of the chain to send tokens to.\n     * @param destinationAddress the address of the user to send tokens to.\n     * @param amount the amount of tokens to take from msg.sender.\n     * @param data the data to pass to the destination contract.\n     */\n    function callContractWithInterchainToken(\n        string calldata destinationChain,\n        bytes calldata destinationAddress,\n        uint256 amount,\n        bytes calldata data\n    ) external payable virtual {\n        address sender = msg.sender;\n        amount = _takeToken(sender, amount);\n        _addFlowOut(amount);\n        uint32 version = 0;\n        interchainTokenService.transmitSendToken{ value: msg.value }(\n            _getTokenId(),\n            sender,\n            destinationChain,\n            destinationAddress,\n            amount,\n            abi.encodePacked(version, data)\n        );\n    }\n\n    /**\n     * @notice Calls the service to initiate the a cross-chain transfer after taking the appropriate amount of tokens from the user. This can only be called by the token itself.\n     * @param sender the address of the user paying for the cross chain transfer.\n     * @param destinationChain the name of the chain to send tokens to.\n     * @param destinationAddress the address of the user to send tokens to.\n     * @param amount the amount of tokens to take from msg.sender.\n     */\n    function transmitInterchainTransfer(\n        address sender,\n        string calldata destinationChain,\n        bytes calldata destinationAddress,\n        uint256 amount,\n        bytes calldata metadata\n    ) external payable virtual onlyToken {\n        amount = _takeToken(sender, amount);\n        _addFlowOut(amount);\n        interchainTokenService.transmitSendToken{ value: msg.value }(\n            _getTokenId(),\n            sender,\n            destinationChain,\n            destinationAddress,\n            amount,\n            metadata\n        );\n    }\n\n    /**\n     * @notice This function gives token to a specified address. Can only be called by the service.\n     * @param destinationAddress the address to give tokens to.\n     * @param amount the amount of token to give.\n     * @return the amount of token actually given, which will onle be differen than `amount` in cases where the token takes some on-transfer fee.\n     */\n    function giveToken(address destinationAddress, uint256 amount) external onlyService returns (uint256) {\n        amount = _giveToken(destinationAddress, amount);\n        _addFlowIn(amount);\n        return amount;\n    }\n\n    /**\n     * @notice This function sets the flow limit for this TokenManager. Can only be called by the operator.\n     * @param flowLimit the maximum difference between the tokens flowing in and/or out at any given interval of time (6h)\n     */\n    function setFlowLimit(uint256 flowLimit) external onlyOperator {\n        _setFlowLimit(flowLimit);\n    }\n\n    /**\n     * @notice Transfers tokens from a specific address to this contract.\n     * Must be overridden in the inheriting contract.\n     * @param from The address from which the tokens will be sent\n     * @param amount The amount of tokens to receive\n     * @return uint amount of tokens received\n     */\n    function _takeToken(address from, uint256 amount) internal virtual returns (uint256);\n\n    /**\n     * @notice Transfers tokens from this contract to a specific address.\n     * Must be overridden in the inheriting contract.\n     * @param from The address to which the tokens will be sent\n     * @param amount The amount of tokens to send\n     * @return uint amount of tokens sent\n     */\n    function _giveToken(address from, uint256 amount) internal virtual returns (uint256);\n\n    /**\n     * @dev Additional setup logic to perform\n     * Must be overridden in the inheriting contract.\n     * @param params The setup parameters\n     */\n    function _setup(bytes calldata params) internal virtual;\n\n    /**\n     * @notice Gets the token ID from the token manager proxy.\n     * @return tokenId The ID of the token\n     */\n    function _getTokenId() internal view returns (bytes32 tokenId) {\n        tokenId = ITokenManagerProxy(address(this)).tokenId();\n    }\n}"
    },
    {
      "filename": "contracts/its/interchain-token-service/InterchainTokenService.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IAxelarGateway } from '../../gmp-sdk/interfaces/IAxelarGateway.sol';\nimport { IAxelarGasService } from '../../gmp-sdk/interfaces/IAxelarGasService.sol';\nimport { AxelarExecutable } from '../../gmp-sdk/executable/AxelarExecutable.sol';\nimport { SafeTokenTransferFrom } from '../../gmp-sdk/util/SafeTransfer.sol';\nimport { IERC20 } from '../../gmp-sdk/interfaces/IERC20.sol';\n\nimport { IInterchainTokenService } from '../interfaces/IInterchainTokenService.sol';\nimport { ITokenManagerDeployer } from '../interfaces/ITokenManagerDeployer.sol';\nimport { IStandardizedTokenDeployer } from '../interfaces/IStandardizedTokenDeployer.sol';\nimport { IRemoteAddressValidator } from '../interfaces/IRemoteAddressValidator.sol';\nimport { IInterchainTokenExpressExecutable } from '../interfaces/IInterchainTokenExpressExecutable.sol';\nimport { ITokenManager } from '../interfaces/ITokenManager.sol';\nimport { ITokenManagerProxy } from '../interfaces/ITokenManagerProxy.sol';\nimport { IERC20Named } from '../interfaces/IERC20Named.sol';\n\nimport { AddressBytesUtils } from '../libraries/AddressBytesUtils.sol';\nimport { StringToBytes32, Bytes32ToString } from '../../gmp-sdk/util/Bytes32String.sol';\n\nimport { Upgradable } from '../../gmp-sdk/upgradable/Upgradable.sol';\nimport { Create3Deployer } from '../../gmp-sdk/deploy/Create3Deployer.sol';\n\nimport { ExpressCallHandler } from '../utils/ExpressCallHandler.sol';\nimport { Pausable } from '../utils/Pausable.sol';\nimport { Operatable } from '../utils/Operatable.sol';\nimport { Multicall } from '../utils/Multicall.sol';\n\n/**\n * @title The Interchain Token Service\n * @notice This contract is responsible for facilitating cross chain token transfers.\n * It (mostly) does not handle tokens, but is responsible for the messaging that needs to occur for cross chain transfers to happen.\n * @dev The only storage used here is for ExpressCalls\n */\ncontract InterchainTokenService is\n    IInterchainTokenService,\n    AxelarExecutable,\n    Upgradable,\n    Operatable,\n    ExpressCallHandler,\n    Pausable,\n    Multicall\n{\n    using StringToBytes32 for string;\n    using Bytes32ToString for bytes32;\n    using AddressBytesUtils for bytes;\n    using AddressBytesUtils for address;\n\n    address internal immutable implementationLockUnlock;\n    address internal immutable implementationMintBurn;\n    address internal immutable implementationLiquidityPool;\n    IAxelarGasService public immutable gasService;\n    IRemoteAddressValidator public immutable remoteAddressValidator;\n    address public immutable tokenManagerDeployer;\n    address public immutable standardizedTokenDeployer;\n    Create3Deployer internal immutable deployer;\n    bytes32 internal immutable chainNameHash;\n    bytes32 internal immutable chainName;\n\n    bytes32 internal constant PREFIX_CUSTOM_TOKEN_ID = keccak256('its-custom-token-id');\n    bytes32 internal constant PREFIX_STANDARDIZED_TOKEN_ID = keccak256('its-standardized-token-id');\n    bytes32 internal constant PREFIX_STANDARDIZED_TOKEN_SALT = keccak256('its-standardized-token-salt');\n\n    uint256 private constant SELECTOR_SEND_TOKEN = 1;\n    uint256 private constant SELECTOR_SEND_TOKEN_WITH_DATA = 2;\n    uint256 private constant SELECTOR_DEPLOY_TOKEN_MANAGER = 3;\n    uint256 private constant SELECTOR_DEPLOY_AND_REGISTER_STANDARDIZED_TOKEN = 4;\n\n    bytes32 private constant CONTRACT_ID = keccak256('interchain-token-service');\n\n    /**\n     * @dev All of the varaibles passed here are stored as immutable variables.\n     * @param tokenManagerDeployer_ the address of the TokenManagerDeployer.\n     * @param standardizedTokenDeployer_ the address of the StandardizedTokenDeployer.\n     * @param gateway_ the address of the AxelarGateway.\n     * @param gasService_ the address of the AxelarGasService.\n     * @param remoteAddressValidator_ the address of the RemoteAddressValidator.\n     * @param tokenManagerImplementations this need to have exactly 3 implementations in the following order: Lock/Unlock, mint/burn and then liquidity pool.\n     * @param chainName_ the name of the current chain.\n     */\n    constructor(\n        address tokenManagerDeployer_,\n        address standardizedTokenDeployer_,\n        address gateway_,\n        address gasService_,\n        address remoteAddressValidator_,\n        address[] memory tokenManagerImplementations,\n        string memory chainName_\n    ) AxelarExecutable(gateway_) {\n        if (\n            remoteAddressValidator_ == address(0) ||\n            gasService_ == address(0) ||\n            tokenManagerDeployer_ == address(0) ||\n            standardizedTokenDeployer_ == address(0)\n        ) revert ZeroAddress();\n        remoteAddressValidator = IRemoteAddressValidator(remoteAddressValidator_);\n        gasService = IAxelarGasService(gasService_);\n        tokenManagerDeployer = tokenManagerDeployer_;\n        standardizedTokenDeployer = standardizedTokenDeployer_;\n        deployer = ITokenManagerDeployer(tokenManagerDeployer_).deployer();\n\n        if (tokenManagerImplementations.length != uint256(type(TokenManagerType).max) + 1) revert LengthMismatch();\n\n        implementationLockUnlock = _sanitizeTokenManagerImplementation(tokenManagerImplementations, TokenManagerType.LOCK_UNLOCK);\n        implementationMintBurn = _sanitizeTokenManagerImplementation(tokenManagerImplementations, TokenManagerType.MINT_BURN);\n        implementationLiquidityPool = _sanitizeTokenManagerImplementation(tokenManagerImplementations, TokenManagerType.LIQUIDITY_POOL);\n\n        chainName = chainName_.toBytes32();\n        chainNameHash = keccak256(bytes(chainName_));\n    }\n\n    /*******\\\n    MODIFIERS\n    \\*******/\n\n    /**\n     * @notice This modifier is used to ensure that only a remote InterchainTokenService can _execute this one.\n     * @param sourceChain the source of the contract call.\n     * @param sourceAddress the address that the call came from.\n     */\n    modifier onlyRemoteService(string calldata sourceChain, string calldata sourceAddress) {\n        if (!remoteAddressValidator.validateSender(sourceChain, sourceAddress)) revert NotRemoteService();\n        _;\n    }\n\n    /**\n     * @notice This modifier is used to ensure certain functions can only be called by TokenManagers.\n     * @param tokenId the `tokenId` of the TokenManager trying to perform the call.\n     */\n    modifier onlyTokenManager(bytes32 tokenId) {\n        if (msg.sender != getTokenManagerAddress(tokenId)) revert NotTokenManager();\n        _;\n    }\n\n    /*****\\\n    GETTERS\n    \\*****/\n\n    /**\n     * @notice Getter for the contract id.\n     */\n    function contractId() external pure returns (bytes32) {\n        return CONTRACT_ID;\n    }\n\n    /**\n     * @notice Getter for the chain name.\n     * @return name the name of the chain\n     */\n    function getChainName() public view returns (string memory name) {\n        name = chainName.toTrimmedString();\n    }\n\n    /**\n     * @notice Calculates the address of a TokenManager from a specific tokenId. The TokenManager does not need to exist already.\n     * @param tokenId the tokenId.\n     * @return tokenManagerAddress deployement address of the TokenManager.\n     */\n    function getTokenManagerAddress(bytes32 tokenId) public view returns (address tokenManagerAddress) {\n        tokenManagerAddress = deployer.deployedAddress(address(this), tokenId);\n    }\n\n    /**\n     * @notice Returns the address of a TokenManager from a specific tokenId. The TokenManager needs to exist already.\n     * @param tokenId the tokenId.\n     * @return tokenManagerAddress deployment address of the TokenManager.\n     */\n    function getValidTokenManagerAddress(bytes32 tokenId) public view returns (address tokenManagerAddress) {\n        tokenManagerAddress = getTokenManagerAddress(tokenId);\n        if (ITokenManagerProxy(tokenManagerAddress).tokenId() != tokenId) revert TokenManagerDoesNotExist(tokenId);\n    }\n\n    /**\n     * @notice Returns the address of the token that an existing tokenManager points to.\n     * @param tokenId the tokenId.\n     * @return tokenAddress the address of the token.\n     */\n    function getTokenAddress(bytes32 tokenId) external view returns (address tokenAddress) {\n        address tokenManagerAddress = getValidTokenManagerAddress(tokenId);\n        tokenAddress = ITokenManager(tokenManagerAddress).tokenAddress();\n    }\n\n    /**\n     * @notice Returns the address of the standardized token that would be deployed with a given tokenId.\n     * The token does not need to exist.\n     * @param tokenId the tokenId.\n     * @return tokenAddress the address of the standardized token.\n     */\n    function getStandardizedTokenAddress(bytes32 tokenId) public view returns (address tokenAddress) {\n        tokenId = _getStandardizedTokenSalt(tokenId);\n        tokenAddress = deployer.deployedAddress(address(this), tokenId);\n    }\n\n    /**\n     * @notice Calculates the tokenId that would correspond to a canonical link for a given token.\n     * This will depend on what chain it is called from, unlike custom tokenIds.\n     * @param tokenAddress the address of the token.\n     * @return tokenId the tokenId that the canonical TokenManager would get (or has gotten) for the token.\n     */\n    function getCanonicalTokenId(address tokenAddress) public view returns (bytes32 tokenId) {\n        tokenId = keccak256(abi.encode(PREFIX_STANDARDIZED_TOKEN_ID, chainNameHash, tokenAddress));\n    }\n\n    /**\n     * @notice Calculates the tokenId that would correspond to a custom link for a given deployer with a specified salt.\n     * This will not depend on what chain it is called from, unlike canonical tokenIds.\n     * @param sender the address of the TokenManager deployer.\n     * @param salt the salt that the deployer uses for the deployment.\n     * @return tokenId the tokenId that the custom TokenManager would get (or has gotten).\n     */\n    function getCustomTokenId(address sender, bytes32 salt) public pure returns (bytes32 tokenId) {\n        tokenId = keccak256(abi.encode(PREFIX_CUSTOM_TOKEN_ID, sender, salt));\n    }\n\n    /**\n     * @notice Getter function for TokenManager implementations. This will mainly be called by TokenManagerProxies\n     * to figure out their implementations\n     * @param tokenManagerType the type of the TokenManager.\n     * @return tokenManagerAddress the address of the TokenManagerImplementation.\n     */\n    function getImplementation(uint256 tokenManagerType) external view returns (address tokenManagerAddress) {\n        // There could be a way to rewrite the following using assembly switch statements, which would be more gas efficient,\n        // but accessing immutable variables and/or enum values seems to be tricky, and would reduce code readability.\n        if (TokenManagerType(tokenManagerType) == TokenManagerType.LOCK_UNLOCK) {\n            return implementationLockUnlock;\n        } else if (TokenManagerType(tokenManagerType) == TokenManagerType.MINT_BURN) {\n            return implementationMintBurn;\n        } else if (TokenManagerType(tokenManagerType) == TokenManagerType.LIQUIDITY_POOL) {\n            return implementationLiquidityPool;\n        }\n    }\n\n    /**\n     * @notice Getter function for the parameters of a lock/unlock TokenManager. Mainly to be used by frontends.\n     * @param operator the operator of the TokenManager.\n     * @param tokenAddress the token to be managed.\n     * @return params the resulting params to be passed to custom TokenManager deployments.\n     */\n    function getParamsLockUnlock(bytes memory operator, address tokenAddress) public pure returns (bytes memory params) {\n        params = abi.encode(operator, tokenAddress);\n    }\n\n    /**\n     * @notice Getter function for the parameters of a mint/burn TokenManager. Mainly to be used by frontends.\n     * @param operator the operator of the TokenManager.\n     * @param tokenAddress the token to be managed.\n     * @return params the resulting params to be passed to custom TokenManager deployments.\n     */\n    function getParamsMintBurn(bytes memory operator, address tokenAddress) public pure returns (bytes memory params) {\n        params = abi.encode(operator, tokenAddress);\n    }\n\n    /**\n     * @notice Getter function for the parameters of a liquidity pool TokenManager. Mainly to be used by frontends.\n     * @param operator the operator of the TokenManager.\n     * @param tokenAddress the token to be managed.\n     * @param liquidityPoolAddress the liquidity pool to be used to store the bridged tokens.\n     * @return params the resulting params to be passed to custom TokenManager deployments.\n     */\n    function getParamsLiquidityPool(\n        bytes memory operator,\n        address tokenAddress,\n        address liquidityPoolAddress\n    ) public pure returns (bytes memory params) {\n        params = abi.encode(operator, tokenAddress, liquidityPoolAddress);\n    }\n\n    /**\n     * @notice Getter function for the flow limit of an existing token manager with a give token ID.\n     * @param tokenId the token ID of the TokenManager.\n     * @return flowLimit the flow limit.\n     */\n    function getFlowLimit(bytes32 tokenId) external view returns (uint256 flowLimit) {\n        ITokenManager tokenManager = ITokenManager(getValidTokenManagerAddress(tokenId));\n        flowLimit = tokenManager.getFlowLimit();\n    }\n\n    /**\n     * @notice Gett"
    }
  ]
}