{
  "Title": "[L-05] Reentrancy vulnerabilities",
  "Content": "- Severity: Low\n- Confidence: Medium\n\n### Description\n\nDetection of the [reentrancy bug](https://github.com/trailofbits/not-so-smart-contracts/tree/master/reentrancy).<br>\nOnly report reentrancy that acts as a double call (see `reentrancy-eth`, `reentrancy-no-eth`).\n\n<details>\n\n<summary>\nThere are 14 instances of this issue:\n\n</summary>\n\n###\n- Reentrancy in File: solidity/contracts/core/USDA.sol\n```\n \nLine: 101          function _deposit(uint256 _susdAmount, address _target) internal paysInterest whenNotPaused \n```\n\nExternal calls:<br>\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 103          sUSD.transferFrom(_msgSender(), address(this), _susdAmount)\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 101          paysInterest\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 49          IVaultController(_vaultControllers.at(_i)).calculateInterest()\n```\n\nState variables written after the call(s):<br>\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 104          _mint(_target, _susdAmount)\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 170          _gonBalances[_target] += _amount * __gonsPerFragment\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 104          _mint(_target, _susdAmount)\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 174          _totalGons += _amount * __gonsPerFragment\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 104          _mint(_target, _susdAmount)\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 172          _totalSupply += _amount\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 106          reserveAmount += _susdAmount\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/USDA.sol#L101-L109](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/USDA.sol#L101-L109)\n\n- Reentrancy in File: solidity/contracts/core/USDA.sol\n```\n \nLine: 147          function _withdraw(uint256 _susdAmount, address _target) internal paysInterest whenNotPaused \n```\n\nExternal calls:<br>\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 147          paysInterest\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 49          IVaultController(_vaultControllers.at(_i)).calculateInterest()\n```\n\nState variables written after the call(s):<br>\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 152          reserveAmount -= _susdAmount\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/USDA.sol#L147-L157](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/USDA.sol#L147-L157)\n\n- Reentrancy in File: solidity/contracts/core/USDA.sol\n```\n \nLine: 147          function _withdraw(uint256 _susdAmount, address _target) internal paysInterest whenNotPaused \n```\n\nExternal calls:<br>\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 153          sUSD.transfer(_target, _susdAmount)\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 147          paysInterest\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 49          IVaultController(_vaultControllers.at(_i)).calculateInterest()\n```\n\nState variables written after the call(s):<br>\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 154          _burn(_msgSender(), _susdAmount)\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 191          _gonBalances[_target] -= (_amount * __gonsPerFragment)\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 154          _burn(_msgSender(), _susdAmount)\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 194          _totalGons -= (_amount * __gonsPerFragment)\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 154          _burn(_msgSender(), _susdAmount)\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 193          _totalSupply -= _amount\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/USDA.sol#L147-L157](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/USDA.sol#L147-L157)\n\n- Reentrancy in File: solidity/contracts/core/USDA.sol\n```\n \nLine: 182          function burn(uint256 _susdAmount) external override paysInterest onlyOwner \n```\n\nExternal calls:<br>\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 182          paysInterest\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 49          IVaultController(_vaultControllers.at(_i)).calculateInterest()\n```\n\nState variables written after the call(s):<br>\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 184          _burn(_msgSender(), _susdAmount)\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 191          _gonBalances[_target] -= (_amount * __gonsPerFragment)\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 184          _burn(_msgSender(), _susdAmount)\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 194          _totalGons -= (_amount * __gonsPerFragment)\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 184          _burn(_msgSender(), _susdAmount)\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 193          _totalSupply -= _amount\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/USDA.sol#L182-L185](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/USDA.sol#L182-L185)\n\n- Reentrancy in File: solidity/contracts/core/USDA.sol\n```\n \nLine: 202          function donate(uint256 _susdAmount) external override paysInterest whenNotPaused \n```\n\nExternal calls:<br>\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 202          paysInterest\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 49          IVaultController(_vaultControllers.at(_i)).calculateInterest()\n```\n\nState variables written after the call(s):<br>\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 205          reserveAmount += _susdAmount\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/USDA.sol#L202-L208](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/USDA.sol#L202-L208)\n\n- Reentrancy in File: solidity/contracts/core/USDA.sol\n```\n \nLine: 202          function donate(uint256 _susdAmount) external override paysInterest whenNotPaused \n```\n\nExternal calls:<br>\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 206          sUSD.transferFrom(_msgSender(), address(this), _susdAmount)\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 202          paysInterest\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 49          IVaultController(_vaultControllers.at(_i)).calculateInterest()\n```\n\nState variables written after the call(s):<br>\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 207          _donation(_susdAmount)\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 262          _gonsPerFragment = _totalGons / _totalSupply\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 207          _donation(_susdAmount)\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 260          _totalSupply += _amount\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 261          _totalSupply = MAX_SUPPLY\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/USDA.sol#L202-L208](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/USDA.sol#L202-L208)\n\n- Reentrancy in File: solidity/contracts/core/USDA.sol\n```\n \nLine: 161          function mint(uint256 _susdAmount) external override paysInterest onlyOwner \n```\n\nExternal calls:<br>\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 161          paysInterest\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 49          IVaultController(_vaultControllers.at(_i)).calculateInterest()\n```\n\nState variables written after the call(s):\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 163          _mint(_msgSender(), _susdAmount)\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 170          _gonBalances[_target] += _amount * __gonsPerFragment\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 163          _mint(_msgSender(), _susdAmount)\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 174          _totalGons += _amount * __gonsPerFragment\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 163          _mint(_msgSender(), _susdAmount)\n```\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 172          _totalSupply += _amount\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/USDA.sol#L161-L164](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/USDA.sol#L161-L164)\n\n- Reentrancy in File: solidity/contracts/core/Vault.sol\n```\n \nLine: 284          function controllerTransfer(address _token, address _to, uint256 _amount) external override onlyVaultController \n```\n\nExternal calls:<br>\n- File: solidity/contracts/core/Vault.sol\n```\n \nLine: 285          SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(_token), _to, _amount)\n```\n\nState variables written after the call(s):<br>\n- File: solidity/contracts/core/Vault.sol\n```\n \nLine: 286          balances[_token] -= _amount\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/Vault.sol#L284-L287](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/Vault.sol#L284-L287)\n\n- Reentrancy in File: solidity/contracts/core/Vault.sol\n```\n \nLine: 89          function depositERC20(address _token, uint256 _amount) external override onlyMinter \n```\n\nExternal calls:<br>\n- File: solidity/contracts/core/Vault.sol\n```\n \nLine: 92          SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(_token), _msgSender(), address(this), _amount)\n```\n\nState variables written after the call(s):<br>\n- File: solidity/contracts/core/Vault.sol\n```\n \nLine: 102          isTokenStaked[_token] = true\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/Vault.sol#L89-L109](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/Vault.sol#L89-L109)\n\n- Reentrancy in File: solidity/contracts/core/Vault.sol\n```\n \nLine: 117          function withdrawERC20(address _tokenAddress, uint256 _amount) external override onlyMinter \n```\n\nExternal calls:<br>\n- File: solidity/contracts/core/Vault.sol\n```\n \nLine: 120          !CONTROLLER.tokenCrvRewardsContract(_tokenAddress).withdrawAndUnwrap(_amount, false)\n```\n\nState variables written after the call(s):<br>\n- File: solidity/contracts/core/Vault.sol\n```\n \nLine: 125          balances[_tokenAddress] -= _amount\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/Vault.sol#L117-L133](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/Vault.sol#L117-L133)\n\n- Reentrancy in File: solidity/contracts/core/VaultController.sol\n```\n \nLine: 278          function mintVault() public override whenNotPaused returns (address _vaultAddress) \n```\n\nExternal calls:<br>\n- File: solidity/contracts/core/VaultController.sol\n```\n \nLine: 282          _vaultAddress = _createVault(vaultsMinted, _msgSender())\n```\n\n- File: solidity/contracts/core/VaultController.sol\n```\n \nLine: 980          _vault = address(VAULT_DEPLOYER.deployVault(_id, _minter))\n```\n\nState variables written after the call(s):<br>\n- File: solidity/contracts/core/VaultController.sol\n```\n \nLine: 284          vaultIdVaultAddress[vaultsMinted] = _vaultAddress\n```\n\n- File: solidity/contracts/core/VaultController.sol\n```\n \nLine: 287          walletVaultIDs[_msgSender()].push(vaultsMinted)\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/VaultController.sol#L278-L291](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/VaultController.sol#L278-L291)\n\n- Reentrancy in File: solidity/contracts/periphery/CurveMaster.sol\n```\n \nLine: 41          function setCurve(address _tokenAddress, address _curveAddress) external override onlyOwner \n```\n\nExternal calls:<br>\n- File: solidity/contracts/periphery/CurveMaster.sol\n```\n \nLine: 42          IVaultController(vaultControllerAddress).calculateInterest()\n```\n\nState variables written after the call(s):<br>\n- File: solidity/contracts/periphery/CurveMaster.sol\n```\n \nLine: 44          curves[_tokenAddress] = _curveAddress\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/periphery/CurveMaster.sol#L41-L47](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/periphery/CurveMaster.sol#L41-L47)\n\n- Reentrancy in File: solidity/contracts/periphery/oracles/CbEthEthOracle.sol\n```\n \nLine: 70          function _updateVirtualPrice() internal \n```\n\nExternal calls:<br>\n- File: solidity/contracts/periphery/oracles/CbEthEthOracle.sol\n```\n \nLine: 74          CB_ETH_POOL.claim_admin_fees()\n```\n\nState variables written after the call(s):<br>\n- File: solidity/contracts/periphery/oracles/CbEthEthOracle.sol\n```\n \nLine: 76          virtualPrice = _virtualPrice\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/periphery/oracles/CbEthEthOracle.sol#L70-L77](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/periphery/oracles/CbEthEthOracle.sol#L70-L77)\n\n- Reentrancy in File: solidity/contracts/periphery/oracles/EthSafeStableCurveOracle.sol\n```\n \nLine: 36          function _updateVirtualPrice() internal \n```\n\nExternal calls:<br>\n- File: solidity/contracts/periphery/oracles/EthSafeStableCurveOracle.sol\n```\n \nLine: 41          CRV_POOL.remove_liquidity(0, _amounts)\n```\n\nState variables written after the call(s):<br>\n- File: solidity/contracts/periphery/oracles/EthSafeStableCurveOracle.sol\n```\n \nLine: 43          virtualPrice = _virtualPrice\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/periphery/oracles/EthSafeStableCurveOracle.sol#L36-L44](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/periphery/oracles/EthSafeStableCurveOracle.sol#L36-L44)\n\n</details>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-07-amphora",
  "Code": [
    {
      "filename": "core/solidity/contracts/core/USDA.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {ExponentialNoError} from '@contracts/utils/ExponentialNoError.sol';\nimport {Roles} from '@contracts/utils/Roles.sol';\nimport {UFragments} from '@contracts/utils/UFragments.sol';\n\nimport {IUSDA} from '@interfaces/core/IUSDA.sol';\nimport {IVaultController} from '@interfaces/core/IVaultController.sol';\n\nimport {IERC20Metadata, IERC20} from '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\nimport {Pausable} from '@openzeppelin/contracts/security/Pausable.sol';\nimport {Context} from '@openzeppelin/contracts/utils/Context.sol';\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\n\n/// @notice USDA token contract, handles all minting/burning of usda\n/// @dev extends UFragments\ncontract USDA is Pausable, UFragments, IUSDA, ExponentialNoError, Roles {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  bytes32 public constant VAULT_CONTROLLER_ROLE = keccak256('VAULT_CONTROLLER');\n\n  EnumerableSet.AddressSet internal _vaultControllers;\n\n  /// @dev The reserve token\n  IERC20 public sUSD;\n\n  /// @dev The address of the pauser\n  address public pauser;\n\n  /// @dev The reserve amount\n  uint256 public reserveAmount;\n\n  /// @notice Checks if _msgSender() is a valid VaultController\n  modifier onlyVaultController() {\n    _checkRole(VAULT_CONTROLLER_ROLE, _msgSender());\n    _;\n  }\n\n  /// @notice Checks if _msgSender() is pauser\n  modifier onlyPauser() {\n    if (_msgSender() != address(pauser)) revert USDA_OnlyPauser();\n    _;\n  }\n\n  /// @notice Any function with this modifier will call the pay_interest() function before any function logic is called\n  modifier paysInterest() {\n    for (uint256 _i; _i < _vaultControllers.length();) {\n      IVaultController(_vaultControllers.at(_i)).calculateInterest();\n      unchecked {\n        _i++;\n      }\n    }\n    _;\n  }\n\n  constructor(IERC20 _sUSDAddr) UFragments('USDA Token', 'USDA') {\n    sUSD = _sUSDAddr;\n  }\n\n  /// @notice Sets the pauser for both USDA and VaultController\n  /// @dev The pauser is a separate role from the owner\n  function setPauser(address _pauser) external override onlyOwner {\n    pauser = _pauser;\n\n    emit PauserSet(_pauser);\n  }\n\n  /// @notice Pause contract\n  /// @dev Can only be called by the pauser\n  function pause() external override onlyPauser {\n    _pause();\n  }\n\n  /// @notice Unpause contract, pauser only\n  /// @dev Can only be called by the pauser\n  function unpause() external override onlyPauser {\n    _unpause();\n  }\n\n  /// @notice Deposit sUSD to mint USDA\n  /// @dev Caller should obtain 1 USDA for each sUSD\n  /// the calculations for deposit mimic the calculations done by mint in the ampleforth contract, simply with the susd transfer\n  /// 'fragments' are the units that we see, so 1000 fragments == 1000 USDA\n  /// 'gons' are the internal accounting unit, used to keep scale.\n  /// We use the variable _gonsPerFragment in order to convert between the two\n  /// try dimensional analysis when doing the math in order to verify units are correct\n  /// @param _susdAmount The amount of sUSD to deposit\n  function deposit(uint256 _susdAmount) external override {\n    _deposit(_susdAmount, _msgSender());\n  }\n\n  /// @notice Deposits sUSD to mint USDA and transfer to a different address\n  /// @param _susdAmount The amount of sUSD to deposit\n  /// @param _target The address to receive the USDA tokens\n  function depositTo(uint256 _susdAmount, address _target) external override {\n    _deposit(_susdAmount, _target);\n  }\n\n  /// @notice Business logic to deposit sUSD and mint USDA for the caller\n  function _deposit(uint256 _susdAmount, address _target) internal paysInterest whenNotPaused {\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    sUSD.transferFrom(_msgSender(), address(this), _susdAmount);\n    _mint(_target, _susdAmount);\n    // Account for the susd received\n    reserveAmount += _susdAmount;\n\n    emit Deposit(_target, _susdAmount);\n  }\n\n  /// @notice Withdraw sUSD by burning USDA\n  /// @dev The caller should obtain 1 sUSD for every 1 USDA\n  /// @param _susdAmount The amount of sUSD to withdraw\n  function withdraw(uint256 _susdAmount) external override {\n    _withdraw(_susdAmount, _msgSender());\n  }\n\n  /// @notice Withdraw sUSD to a specific address by burning USDA from the caller\n  /// @dev The _target address should obtain 1 sUSD for every 1 USDA burned from the caller\n  /// @param _susdAmount amount of sUSD to withdraw\n  /// @param _target address to receive the sUSD\n  function withdrawTo(uint256 _susdAmount, address _target) external override {\n    _withdraw(_susdAmount, _target);\n  }\n\n  /// @notice Withdraw sUSD by burning USDA\n  /// @dev The caller should obtain 1 sUSD for every 1 USDA\n  /// @dev This function is effectively just withdraw, but we calculate the amount for the sender\n  /// @param _susdWithdrawn The amount os sUSD withdrawn\n  function withdrawAll() external override returns (uint256 _susdWithdrawn) {\n    uint256 _balance = this.balanceOf(_msgSender());\n    _susdWithdrawn = _balance > reserveAmount ? reserveAmount : _balance;\n    _withdraw(_susdWithdrawn, _msgSender());\n  }\n\n  /// @notice Withdraw sUSD by burning USDA\n  /// @dev This function is effectively just withdraw, but we calculate the amount for the _target\n  /// @param _target should obtain 1 sUSD for every 1 USDA burned from caller\n  /// @param _susdWithdrawn The amount os sUSD withdrawn\n  function withdrawAllTo(address _target) external override returns (uint256 _susdWithdrawn) {\n    uint256 _balance = this.balanceOf(_msgSender());\n    _susdWithdrawn = _balance > reserveAmount ? reserveAmount : _balance;\n    _withdraw(_susdWithdrawn, _target);\n  }\n\n  /// @notice business logic to withdraw sUSD and burn USDA from the caller\n  function _withdraw(uint256 _susdAmount, address _target) internal paysInterest whenNotPaused {\n    if (reserveAmount == 0) revert USDA_EmptyReserve();\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    if (_susdAmount > this.balanceOf(_msgSender())) revert USDA_InsufficientFunds();\n    // Account for the susd withdrawn\n    reserveAmount -= _susdAmount;\n    sUSD.transfer(_target, _susdAmount);\n    _burn(_msgSender(), _susdAmount);\n\n    emit Withdraw(_target, _susdAmount);\n  }\n\n  /// @notice Admin function to mint USDA\n  /// @param _susdAmount The amount of USDA to mint, denominated in sUSD\n  function mint(uint256 _susdAmount) external override paysInterest onlyOwner {\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    _mint(_msgSender(), _susdAmount);\n  }\n\n  /// @dev mint a specific `amount` of tokens to the `target`\n  function _mint(address _target, uint256 _amount) internal {\n    uint256 __gonsPerFragment = _gonsPerFragment;\n    // the gonbalances of the sender is in gons, therefore we must multiply the deposit amount, which is in fragments, by gonsperfragment\n    _gonBalances[_target] += _amount * __gonsPerFragment;\n    // total supply is in fragments, and so we add amount\n    _totalSupply += _amount;\n    // and totalgons of course is in gons, and so we multiply amount by gonsperfragment to get the amount of gons we must add to totalGons\n    _totalGons += _amount * __gonsPerFragment;\n    // emit both a mint and transfer event\n    emit Transfer(address(0), _target, _amount);\n    emit Mint(_target, _amount);\n  }\n\n  /// @notice Admin function to burn USDA\n  /// @param _susdAmount The amount of USDA to burn, denominated in sUSD\n  function burn(uint256 _susdAmount) external override paysInterest onlyOwner {\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    _burn(_msgSender(), _susdAmount);\n  }\n\n  /// @dev burn a specific `amount` of tokens from the `target`\n  function _burn(address _target, uint256 _amount) internal {\n    uint256 __gonsPerFragment = _gonsPerFragment;\n    // modify the gonbalances of the sender, subtracting the amount of gons, therefore amount * gonsperfragment\n    _gonBalances[_target] -= (_amount * __gonsPerFragment);\n    // modify totalSupply and totalGons\n    _totalSupply -= _amount;\n    _totalGons -= (_amount * __gonsPerFragment);\n    // emit both a burn and transfer event\n    emit Transfer(_target, address(0), _amount);\n    emit Burn(_target, _amount);\n  }\n\n  /// @notice Donates susd to the protocol reserve\n  /// @param _susdAmount The amount of sUSD to donate\n  function donate(uint256 _susdAmount) external override paysInterest whenNotPaused {\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    // Account for the susd received\n    reserveAmount += _susdAmount;\n    sUSD.transferFrom(_msgSender(), address(this), _susdAmount);\n    _donation(_susdAmount);\n  }\n\n  /// @notice Recovers accidentally sent sUSD to this contract\n  /// @param _to The receiver of the dust\n  function recoverDust(address _to) external onlyOwner {\n    // All sUSD sent directly to the contract is not accounted into the reserveAmount\n    // This function allows governance to recover it\n    uint256 _amount = sUSD.balanceOf(address(this)) - reserveAmount;\n    sUSD.transfer(_to, _amount);\n\n    emit RecoveredDust(owner(), _amount);\n  }\n\n  /// @notice Function for the vaultController to mint\n  /// @param _target The address to mint the USDA to\n  /// @param _amount The amount of USDA to mint\n  function vaultControllerMint(address _target, uint256 _amount) external override onlyVaultController whenNotPaused {\n    _mint(_target, _amount);\n  }\n\n  /// @notice Function for the vaultController to burn\n  /// @param _target The address to burn the USDA from\n  /// @param _amount The amount of USDA to burn\n  function vaultControllerBurn(address _target, uint256 _amount) external override onlyVaultController {\n    if (_gonBalances[_target] < (_amount * _gonsPerFragment)) revert USDA_NotEnoughBalance();\n    _burn(_target, _amount);\n  }\n\n  /// @notice Allows VaultController to send sUSD from the reserve\n  /// @param _target The address to receive the sUSD from reserve\n  /// @param _susdAmount The amount of sUSD to send\n  function vaultControllerTransfer(\n    address _target,\n    uint256 _susdAmount\n  ) external override onlyVaultController whenNotPaused {\n    // Account for the susd withdrawn\n    reserveAmount -= _susdAmount;\n    // ensure transfer success\n    sUSD.transfer(_target, _susdAmount);\n\n    emit VaultControllerTransfer(_target, _susdAmount);\n  }\n\n  /// @notice Function for the vaultController to scale all USDA balances\n  /// @param _amount The amount of USDA (e18) to donate\n  function vaultControllerDonate(uint256 _amount) external override onlyVaultController {\n    _donation(_amount);\n  }\n\n  /// @notice Function for distributing the donation to all USDA holders\n  /// @param _amount The amount of USDA to donate\n  function _donation(uint256 _amount) internal {\n    _totalSupply += _amount;\n    if (_totalSupply > MAX_SUPPLY) _totalSupply = MAX_SUPPLY;\n    _gonsPerFragment = _totalGons / _totalSupply;\n    emit Donation(_msgSender(), _amount, _totalSupply);\n  }\n\n  /// @notice Returns the reserve ratio\n  /// @return _e18reserveRatio The USDA reserve ratio\n  function reserveRatio() external view override returns (uint192 _e18reserveRatio) {\n    _e18reserveRatio = _safeu192((reserveAmount * EXP_SCALE) / _totalSupply);\n  }\n\n  /*///////////////////////////////////////////////////////////////\n                                ROLES\n    //////////////////////////////////////////////////////////////*/\n\n  /// @notice Adds a new vault controller\n  /// @param _vaultController The new vault controller to add\n  function addVaultController(address _vaultController) external onlyOwner {\n    _vaultControllers.add(_vaultController);\n    _grantRole(VAULT_CONTROLLER_ROLE, _vaultController);\n\n    emit VaultControllerAdded(_vaultController);\n  }\n\n  /// @notice Removes a vault controller\n  /// @param _vaultController The vault controller to remove\n  function removeVaultController(address _vaultController) external onlyOwner {\n    _vaultControllers.remove(_vaultController);\n    _revokeRole(VAULT_CONTROLLER_ROLE, _vaultController);\n\n    emit VaultControllerRemoved(_vaultController);\n  }\n\n  /// @notice Removes a vault controller from the list\n  /// @param _vaultController The vault controller to remove\n  /// @dev The vault controller is removed from the list but keeps the role as to not brick it\n  function removeVaultControllerFromList(address _vaultController) external onlyOwner {\n    _vaultControllers.remove(_vaultController);\n\n    emit VaultControllerRemovedFromList(_vaultController);\n  }\n}"
    },
    {
      "filename": "core/solidity/contracts/core/USDA.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {ExponentialNoError} from '@contracts/utils/ExponentialNoError.sol';\nimport {Roles} from '@contracts/utils/Roles.sol';\nimport {UFragments} from '@contracts/utils/UFragments.sol';\n\nimport {IUSDA} from '@interfaces/core/IUSDA.sol';\nimport {IVaultController} from '@interfaces/core/IVaultController.sol';\n\nimport {IERC20Metadata, IERC20} from '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\nimport {Pausable} from '@openzeppelin/contracts/security/Pausable.sol';\nimport {Context} from '@openzeppelin/contracts/utils/Context.sol';\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\n\n/// @notice USDA token contract, handles all minting/burning of usda\n/// @dev extends UFragments\ncontract USDA is Pausable, UFragments, IUSDA, ExponentialNoError, Roles {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  bytes32 public constant VAULT_CONTROLLER_ROLE = keccak256('VAULT_CONTROLLER');\n\n  EnumerableSet.AddressSet internal _vaultControllers;\n\n  /// @dev The reserve token\n  IERC20 public sUSD;\n\n  /// @dev The address of the pauser\n  address public pauser;\n\n  /// @dev The reserve amount\n  uint256 public reserveAmount;\n\n  /// @notice Checks if _msgSender() is a valid VaultController\n  modifier onlyVaultController() {\n    _checkRole(VAULT_CONTROLLER_ROLE, _msgSender());\n    _;\n  }\n\n  /// @notice Checks if _msgSender() is pauser\n  modifier onlyPauser() {\n    if (_msgSender() != address(pauser)) revert USDA_OnlyPauser();\n    _;\n  }\n\n  /// @notice Any function with this modifier will call the pay_interest() function before any function logic is called\n  modifier paysInterest() {\n    for (uint256 _i; _i < _vaultControllers.length();) {\n      IVaultController(_vaultControllers.at(_i)).calculateInterest();\n      unchecked {\n        _i++;\n      }\n    }\n    _;\n  }\n\n  constructor(IERC20 _sUSDAddr) UFragments('USDA Token', 'USDA') {\n    sUSD = _sUSDAddr;\n  }\n\n  /// @notice Sets the pauser for both USDA and VaultController\n  /// @dev The pauser is a separate role from the owner\n  function setPauser(address _pauser) external override onlyOwner {\n    pauser = _pauser;\n\n    emit PauserSet(_pauser);\n  }\n\n  /// @notice Pause contract\n  /// @dev Can only be called by the pauser\n  function pause() external override onlyPauser {\n    _pause();\n  }\n\n  /// @notice Unpause contract, pauser only\n  /// @dev Can only be called by the pauser\n  function unpause() external override onlyPauser {\n    _unpause();\n  }\n\n  /// @notice Deposit sUSD to mint USDA\n  /// @dev Caller should obtain 1 USDA for each sUSD\n  /// the calculations for deposit mimic the calculations done by mint in the ampleforth contract, simply with the susd transfer\n  /// 'fragments' are the units that we see, so 1000 fragments == 1000 USDA\n  /// 'gons' are the internal accounting unit, used to keep scale.\n  /// We use the variable _gonsPerFragment in order to convert between the two\n  /// try dimensional analysis when doing the math in order to verify units are correct\n  /// @param _susdAmount The amount of sUSD to deposit\n  function deposit(uint256 _susdAmount) external override {\n    _deposit(_susdAmount, _msgSender());\n  }\n\n  /// @notice Deposits sUSD to mint USDA and transfer to a different address\n  /// @param _susdAmount The amount of sUSD to deposit\n  /// @param _target The address to receive the USDA tokens\n  function depositTo(uint256 _susdAmount, address _target) external override {\n    _deposit(_susdAmount, _target);\n  }\n\n  /// @notice Business logic to deposit sUSD and mint USDA for the caller\n  function _deposit(uint256 _susdAmount, address _target) internal paysInterest whenNotPaused {\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    sUSD.transferFrom(_msgSender(), address(this), _susdAmount);\n    _mint(_target, _susdAmount);\n    // Account for the susd received\n    reserveAmount += _susdAmount;\n\n    emit Deposit(_target, _susdAmount);\n  }\n\n  /// @notice Withdraw sUSD by burning USDA\n  /// @dev The caller should obtain 1 sUSD for every 1 USDA\n  /// @param _susdAmount The amount of sUSD to withdraw\n  function withdraw(uint256 _susdAmount) external override {\n    _withdraw(_susdAmount, _msgSender());\n  }\n\n  /// @notice Withdraw sUSD to a specific address by burning USDA from the caller\n  /// @dev The _target address should obtain 1 sUSD for every 1 USDA burned from the caller\n  /// @param _susdAmount amount of sUSD to withdraw\n  /// @param _target address to receive the sUSD\n  function withdrawTo(uint256 _susdAmount, address _target) external override {\n    _withdraw(_susdAmount, _target);\n  }\n\n  /// @notice Withdraw sUSD by burning USDA\n  /// @dev The caller should obtain 1 sUSD for every 1 USDA\n  /// @dev This function is effectively just withdraw, but we calculate the amount for the sender\n  /// @param _susdWithdrawn The amount os sUSD withdrawn\n  function withdrawAll() external override returns (uint256 _susdWithdrawn) {\n    uint256 _balance = this.balanceOf(_msgSender());\n    _susdWithdrawn = _balance > reserveAmount ? reserveAmount : _balance;\n    _withdraw(_susdWithdrawn, _msgSender());\n  }\n\n  /// @notice Withdraw sUSD by burning USDA\n  /// @dev This function is effectively just withdraw, but we calculate the amount for the _target\n  /// @param _target should obtain 1 sUSD for every 1 USDA burned from caller\n  /// @param _susdWithdrawn The amount os sUSD withdrawn\n  function withdrawAllTo(address _target) external override returns (uint256 _susdWithdrawn) {\n    uint256 _balance = this.balanceOf(_msgSender());\n    _susdWithdrawn = _balance > reserveAmount ? reserveAmount : _balance;\n    _withdraw(_susdWithdrawn, _target);\n  }\n\n  /// @notice business logic to withdraw sUSD and burn USDA from the caller\n  function _withdraw(uint256 _susdAmount, address _target) internal paysInterest whenNotPaused {\n    if (reserveAmount == 0) revert USDA_EmptyReserve();\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    if (_susdAmount > this.balanceOf(_msgSender())) revert USDA_InsufficientFunds();\n    // Account for the susd withdrawn\n    reserveAmount -= _susdAmount;\n    sUSD.transfer(_target, _susdAmount);\n    _burn(_msgSender(), _susdAmount);\n\n    emit Withdraw(_target, _susdAmount);\n  }\n\n  /// @notice Admin function to mint USDA\n  /// @param _susdAmount The amount of USDA to mint, denominated in sUSD\n  function mint(uint256 _susdAmount) external override paysInterest onlyOwner {\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    _mint(_msgSender(), _susdAmount);\n  }\n\n  /// @dev mint a specific `amount` of tokens to the `target`\n  function _mint(address _target, uint256 _amount) internal {\n    uint256 __gonsPerFragment = _gonsPerFragment;\n    // the gonbalances of the sender is in gons, therefore we must multiply the deposit amount, which is in fragments, by gonsperfragment\n    _gonBalances[_target] += _amount * __gonsPerFragment;\n    // total supply is in fragments, and so we add amount\n    _totalSupply += _amount;\n    // and totalgons of course is in gons, and so we multiply amount by gonsperfragment to get the amount of gons we must add to totalGons\n    _totalGons += _amount * __gonsPerFragment;\n    // emit both a mint and transfer event\n    emit Transfer(address(0), _target, _amount);\n    emit Mint(_target, _amount);\n  }\n\n  /// @notice Admin function to burn USDA\n  /// @param _susdAmount The amount of USDA to burn, denominated in sUSD\n  function burn(uint256 _susdAmount) external override paysInterest onlyOwner {\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    _burn(_msgSender(), _susdAmount);\n  }\n\n  /// @dev burn a specific `amount` of tokens from the `target`\n  function _burn(address _target, uint256 _amount) internal {\n    uint256 __gonsPerFragment = _gonsPerFragment;\n    // modify the gonbalances of the sender, subtracting the amount of gons, therefore amount * gonsperfragment\n    _gonBalances[_target] -= (_amount * __gonsPerFragment);\n    // modify totalSupply and totalGons\n    _totalSupply -= _amount;\n    _totalGons -= (_amount * __gonsPerFragment);\n    // emit both a burn and transfer event\n    emit Transfer(_target, address(0), _amount);\n    emit Burn(_target, _amount);\n  }\n\n  /// @notice Donates susd to the protocol reserve\n  /// @param _susdAmount The amount of sUSD to donate\n  function donate(uint256 _susdAmount) external override paysInterest whenNotPaused {\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    // Account for the susd received\n    reserveAmount += _susdAmount;\n    sUSD.transferFrom(_msgSender(), address(this), _susdAmount);\n    _donation(_susdAmount);\n  }\n\n  /// @notice Recovers accidentally sent sUSD to this contract\n  /// @param _to The receiver of the dust\n  function recoverDust(address _to) external onlyOwner {\n    // All sUSD sent directly to the contract is not accounted into the reserveAmount\n    // This function allows governance to recover it\n    uint256 _amount = sUSD.balanceOf(address(this)) - reserveAmount;\n    sUSD.transfer(_to, _amount);\n\n    emit RecoveredDust(owner(), _amount);\n  }\n\n  /// @notice Function for the vaultController to mint\n  /// @param _target The address to mint the USDA to\n  /// @param _amount The amount of USDA to mint\n  function vaultControllerMint(address _target, uint256 _amount) external override onlyVaultController whenNotPaused {\n    _mint(_target, _amount);\n  }\n\n  /// @notice Function for the vaultController to burn\n  /// @param _target The address to burn the USDA from\n  /// @param _amount The amount of USDA to burn\n  function vaultControllerBurn(address _target, uint256 _amount) external override onlyVaultController {\n    if (_gonBalances[_target] < (_amount * _gonsPerFragment)) revert USDA_NotEnoughBalance();\n    _burn(_target, _amount);\n  }\n\n  /// @notice Allows VaultController to send sUSD from the reserve\n  /// @param _target The address to receive the sUSD from reserve\n  /// @param _susdAmount The amount of sUSD to send\n  function vaultControllerTransfer(\n    address _target,\n    uint256 _susdAmount\n  ) external override onlyVaultController whenNotPaused {\n    // Account for the susd withdrawn\n    reserveAmount -= _susdAmount;\n    // ensure transfer success\n    sUSD.transfer(_target, _susdAmount);\n\n    emit VaultControllerTransfer(_target, _susdAmount);\n  }\n\n  /// @notice Function for the vaultController to scale all USDA balances\n  /// @param _amount The amount of USDA (e18) to donate\n  function vaultControllerDonate(uint256 _amount) external override onlyVaultController {\n    _donation(_amount);\n  }\n\n  /// @notice Function for distributing the donation to all USDA holders\n  /// @param _amount The amount of USDA to donate\n  function _donation(uint256 _amount) internal {\n    _totalSupply += _amount;\n    if (_totalSupply > MAX_SUPPLY) _totalSupply = MAX_SUPPLY;\n    _gonsPerFragment = _totalGons / _totalSupply;\n    emit Donation(_msgSender(), _amount, _totalSupply);\n  }\n\n  /// @notice Returns the reserve ratio\n  /// @return _e18reserveRatio The USDA reserve ratio\n  function reserveRatio() external view override returns (uint192 _e18reserveRatio) {\n    _e18reserveRatio = _safeu192((reserveAmount * EXP_SCALE) / _totalSupply);\n  }\n\n  /*///////////////////////////////////////////////////////////////\n                                ROLES\n    //////////////////////////////////////////////////////////////*/\n\n  /// @notice Adds a new vault controller\n  /// @param _vaultController The new vault controller to add\n  function addVaultController(address _vaultController) external onlyOwner {\n    _vaultControllers.add(_vaultController);\n    _grantRole(VAULT_CONTROLLER_ROLE, _vaultController);\n\n    emit VaultControllerAdded(_vaultController);\n  }\n\n  /// @notice Removes a vault controller\n  /// @param _vaultController The vault controller to remove\n  function removeVaultController(address _vaultController) external onlyOwner {\n    _vaultControllers.remove(_vaultController);\n    _revokeRole(VAULT_CONTROLLER_ROLE, _vaultController);\n\n    emit VaultControllerRemoved(_vaultController);\n  }\n\n  /// @notice Removes a vault controller from the list\n  /// @param _vaultController The vault controller to remove\n  /// @dev The vault controller is removed from the list but keeps the role as to not brick it\n  function removeVaultControllerFromList(address _vaultController) external onlyOwner {\n    _vaultControllers.remove(_vaultController);\n\n    emit VaultControllerRemovedFromList(_vaultController);\n  }\n}"
    },
    {
      "filename": "core/solidity/contracts/core/USDA.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {ExponentialNoError} from '@contracts/utils/ExponentialNoError.sol';\nimport {Roles} from '@contracts/utils/Roles.sol';\nimport {UFragments} from '@contracts/utils/UFragments.sol';\n\nimport {IUSDA} from '@interfaces/core/IUSDA.sol';\nimport {IVaultController} from '@interfaces/core/IVaultController.sol';\n\nimport {IERC20Metadata, IERC20} from '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\nimport {Pausable} from '@openzeppelin/contracts/security/Pausable.sol';\nimport {Context} from '@openzeppelin/contracts/utils/Context.sol';\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\n\n/// @notice USDA token contract, handles all minting/burning of usda\n/// @dev extends UFragments\ncontract USDA is Pausable, UFragments, IUSDA, ExponentialNoError, Roles {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  bytes32 public constant VAULT_CONTROLLER_ROLE = keccak256('VAULT_CONTROLLER');\n\n  EnumerableSet.AddressSet internal _vaultControllers;\n\n  /// @dev The reserve token\n  IERC20 public sUSD;\n\n  /// @dev The address of the pauser\n  address public pauser;\n\n  /// @dev The reserve amount\n  uint256 public reserveAmount;\n\n  /// @notice Checks if _msgSender() is a valid VaultController\n  modifier onlyVaultController() {\n    _checkRole(VAULT_CONTROLLER_ROLE, _msgSender());\n    _;\n  }\n\n  /// @notice Checks if _msgSender() is pauser\n  modifier onlyPauser() {\n    if (_msgSender() != address(pauser)) revert USDA_OnlyPauser();\n    _;\n  }\n\n  /// @notice Any function with this modifier will call the pay_interest() function before any function logic is called\n  modifier paysInterest() {\n    for (uint256 _i; _i < _vaultControllers.length();) {\n      IVaultController(_vaultControllers.at(_i)).calculateInterest();\n      unchecked {\n        _i++;\n      }\n    }\n    _;\n  }\n\n  constructor(IERC20 _sUSDAddr) UFragments('USDA Token', 'USDA') {\n    sUSD = _sUSDAddr;\n  }\n\n  /// @notice Sets the pauser for both USDA and VaultController\n  /// @dev The pauser is a separate role from the owner\n  function setPauser(address _pauser) external override onlyOwner {\n    pauser = _pauser;\n\n    emit PauserSet(_pauser);\n  }\n\n  /// @notice Pause contract\n  /// @dev Can only be called by the pauser\n  function pause() external override onlyPauser {\n    _pause();\n  }\n\n  /// @notice Unpause contract, pauser only\n  /// @dev Can only be called by the pauser\n  function unpause() external override onlyPauser {\n    _unpause();\n  }\n\n  /// @notice Deposit sUSD to mint USDA\n  /// @dev Caller should obtain 1 USDA for each sUSD\n  /// the calculations for deposit mimic the calculations done by mint in the ampleforth contract, simply with the susd transfer\n  /// 'fragments' are the units that we see, so 1000 fragments == 1000 USDA\n  /// 'gons' are the internal accounting unit, used to keep scale.\n  /// We use the variable _gonsPerFragment in order to convert between the two\n  /// try dimensional analysis when doing the math in order to verify units are correct\n  /// @param _susdAmount The amount of sUSD to deposit\n  function deposit(uint256 _susdAmount) external override {\n    _deposit(_susdAmount, _msgSender());\n  }\n\n  /// @notice Deposits sUSD to mint USDA and transfer to a different address\n  /// @param _susdAmount The amount of sUSD to deposit\n  /// @param _target The address to receive the USDA tokens\n  function depositTo(uint256 _susdAmount, address _target) external override {\n    _deposit(_susdAmount, _target);\n  }\n\n  /// @notice Business logic to deposit sUSD and mint USDA for the caller\n  function _deposit(uint256 _susdAmount, address _target) internal paysInterest whenNotPaused {\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    sUSD.transferFrom(_msgSender(), address(this), _susdAmount);\n    _mint(_target, _susdAmount);\n    // Account for the susd received\n    reserveAmount += _susdAmount;\n\n    emit Deposit(_target, _susdAmount);\n  }\n\n  /// @notice Withdraw sUSD by burning USDA\n  /// @dev The caller should obtain 1 sUSD for every 1 USDA\n  /// @param _susdAmount The amount of sUSD to withdraw\n  function withdraw(uint256 _susdAmount) external override {\n    _withdraw(_susdAmount, _msgSender());\n  }\n\n  /// @notice Withdraw sUSD to a specific address by burning USDA from the caller\n  /// @dev The _target address should obtain 1 sUSD for every 1 USDA burned from the caller\n  /// @param _susdAmount amount of sUSD to withdraw\n  /// @param _target address to receive the sUSD\n  function withdrawTo(uint256 _susdAmount, address _target) external override {\n    _withdraw(_susdAmount, _target);\n  }\n\n  /// @notice Withdraw sUSD by burning USDA\n  /// @dev The caller should obtain 1 sUSD for every 1 USDA\n  /// @dev This function is effectively just withdraw, but we calculate the amount for the sender\n  /// @param _susdWithdrawn The amount os sUSD withdrawn\n  function withdrawAll() external override returns (uint256 _susdWithdrawn) {\n    uint256 _balance = this.balanceOf(_msgSender());\n    _susdWithdrawn = _balance > reserveAmount ? reserveAmount : _balance;\n    _withdraw(_susdWithdrawn, _msgSender());\n  }\n\n  /// @notice Withdraw sUSD by burning USDA\n  /// @dev This function is effectively just withdraw, but we calculate the amount for the _target\n  /// @param _target should obtain 1 sUSD for every 1 USDA burned from caller\n  /// @param _susdWithdrawn The amount os sUSD withdrawn\n  function withdrawAllTo(address _target) external override returns (uint256 _susdWithdrawn) {\n    uint256 _balance = this.balanceOf(_msgSender());\n    _susdWithdrawn = _balance > reserveAmount ? reserveAmount : _balance;\n    _withdraw(_susdWithdrawn, _target);\n  }\n\n  /// @notice business logic to withdraw sUSD and burn USDA from the caller\n  function _withdraw(uint256 _susdAmount, address _target) internal paysInterest whenNotPaused {\n    if (reserveAmount == 0) revert USDA_EmptyReserve();\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    if (_susdAmount > this.balanceOf(_msgSender())) revert USDA_InsufficientFunds();\n    // Account for the susd withdrawn\n    reserveAmount -= _susdAmount;\n    sUSD.transfer(_target, _susdAmount);\n    _burn(_msgSender(), _susdAmount);\n\n    emit Withdraw(_target, _susdAmount);\n  }\n\n  /// @notice Admin function to mint USDA\n  /// @param _susdAmount The amount of USDA to mint, denominated in sUSD\n  function mint(uint256 _susdAmount) external override paysInterest onlyOwner {\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    _mint(_msgSender(), _susdAmount);\n  }\n\n  /// @dev mint a specific `amount` of tokens to the `target`\n  function _mint(address _target, uint256 _amount) internal {\n    uint256 __gonsPerFragment = _gonsPerFragment;\n    // the gonbalances of the sender is in gons, therefore we must multiply the deposit amount, which is in fragments, by gonsperfragment\n    _gonBalances[_target] += _amount * __gonsPerFragment;\n    // total supply is in fragments, and so we add amount\n    _totalSupply += _amount;\n    // and totalgons of course is in gons, and so we multiply amount by gonsperfragment to get the amount of gons we must add to totalGons\n    _totalGons += _amount * __gonsPerFragment;\n    // emit both a mint and transfer event\n    emit Transfer(address(0), _target, _amount);\n    emit Mint(_target, _amount);\n  }\n\n  /// @notice Admin function to burn USDA\n  /// @param _susdAmount The amount of USDA to burn, denominated in sUSD\n  function burn(uint256 _susdAmount) external override paysInterest onlyOwner {\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    _burn(_msgSender(), _susdAmount);\n  }\n\n  /// @dev burn a specific `amount` of tokens from the `target`\n  function _burn(address _ta"
    }
  ]
}