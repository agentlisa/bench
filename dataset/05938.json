{
  "Title": "[G-06] Use uint256 instead of the counter library",
  "Content": "\nThe counters version runs 6 more instructions than the uint version  due to the counters code needing to jump into the Counters library.\nThe 6 added instructions are: 2 JUMPs, 2 JUMPDESTs, and 2 PUSH1s. These are used to jump from the current executing code to the library function that actually handles the increment logic. The total gas costs of these operations is 24 units\nIn addition to using more gas, using the Counters library also results in a larger deployment size\nSee [More Info](https://twitter.com/0xCygaar/status/1608562486508417025)\n\n\n**Note:The counters library is also being deprecated**https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4289\n\nhttps://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/core/RdpxV2Bond.sol#L9\n\n### RdpxV2Bond.sol.mint(): get rid of counters (Save 109 Gas)\n\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 105847    | 113510   | 115747 | 117747 |\n| After  | 105738    | 113401   | 115638 | 117638 |\n\n```solidity\nFile: /contracts/core/RdpxV2Bond.sol\n9:import { Counters } from \"@openzeppelin/contracts/utils/Counters.sol\";\n\n18:  using Counters for Counters.Counter;\n\n\n20:  Counters.Counter private _tokenIdCounter;\n```\nhttps://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/core/RdpxV2Bond.sol#L37-L43\n```solidity\nFile: /contracts/core/RdpxV2Bond.sol\n37:  function mint(\n38:    address to\n39:  ) public onlyRole(MINTER_ROLE) returns (uint256 tokenId) {\n40:    tokenId = _tokenIdCounter.current();\n41:    _tokenIdCounter.increment();\n42:    _mint(to, tokenId);\n43:  }\n```\n\n\n```diff\n-import { Counters } from \"@openzeppelin/contracts/utils/Counters.sol\";\n\n contract RdpxV2Bond is\n   ERC721,\n@@ -15,9 +14,8 @@ contract RdpxV2Bond is\n   AccessControl,\n   ERC721Burnable\n {\n-  using Counters for Counters.Counter;\n\n-  Counters.Counter private _tokenIdCounter;\n+  uint256 private _tokenIdCounter;\n\n   bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n@@ -37,8 +35,10 @@ contract RdpxV2Bond is\n   function mint(\n     address to\n   ) public onlyRole(MINTER_ROLE) returns (uint256 tokenId) {\n-    tokenId = _tokenIdCounter.current();\n-    _tokenIdCounter.increment();\n+    tokenId = _tokenIdCounter;\n+    unchecked{\n+      ++_tokenIdCounter;\n+    }\n     _mint(to, tokenId);\n   }\n\n```\n\n\n**Similar Instance**\n\nhttps://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/decaying-bonds/RdpxDecayingBonds.sol#L13\n\n### RdpxDecayingBonds.sol.mintToken() : save 162 Gas\n\n**Benchmarks based on function `mint()` which calls the function `mintToken()`\n\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 184661    | 192194   | 195461 | 197461 |\n| After  | 184529    | 192062   | 195329 | 197329 |\n```solidity\nFile: /contracts/decaying-bonds/RdpxDecayingBonds.sol\n13:import { Counters } from \"@openzeppelin/contracts/utils/Counters.sol\";\n\n26:  using Counters for Counters.Counter;\n\n28:  Counters.Counter private _tokenIdCounter;\n\n56:  constructor(\n\n59:  ) ERC721(_name, _symbol) {\n\n63:    _tokenIdCounter.increment();\n64:  }\n```\n\nhttps://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/decaying-bonds/RdpxDecayingBonds.sol#L129-L133\n```solidity\nFile: /contracts/decaying-bonds/RdpxDecayingBonds.sol\n129:  function _mintToken(address to) private returns (uint256 tokenId) {\n130:    tokenId = _tokenIdCounter.current();\n131:    _tokenIdCounter.increment();\n132:    _mint(to, tokenId);\n133:  }\n```\n\n```diff\n-import { Counters } from \"@openzeppelin/contracts/utils/Counters.sol\";\n\n // Interfaces\n import { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\n@@ -23,9 +22,8 @@ contract RdpxDecayingBonds is\n   AccessControl\n {\n   using SafeERC20 for IERC20WithBurn;\n-  using Counters for Counters.Counter;\n\n-  Counters.Counter private _tokenIdCounter;\n+  uint256 private _tokenIdCounter;\n\n   // Create a new role identifier for the minter role\n   bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n@@ -60,7 +58,9 @@ contract RdpxDecayingBonds is\n     // Grant the minter role and admin role to deployer\n     _setupRole(MINTER_ROLE, msg.sender);\n     _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n-    _tokenIdCounter.increment();\n+    unchecked {\n+      ++_tokenIdCounter;\n+    }\n   }\n\n   /*============ ADMIN FUNCTIONS ============*/\n@@ -127,8 +127,10 @@ contract RdpxDecayingBonds is\n   /// @dev Internal function to mint a bond position token\n   /// @param to the address to mint the position to\n   function _mintToken(address to) private returns (uint256 tokenId) {\n-    tokenId = _tokenIdCounter.current();\n-    _tokenIdCounter.increment();\n+    tokenId = _tokenIdCounter;\n+    unchecked{\n+      ++_tokenIdCounter;\n+    }\n     _mint(to, tokenId);\n   }\n\n```\n\n**Another instance**\nhttps://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVault.sol#L14\n\n### PerpetualAtlanticVault.sol.\\_mintOptionToken(): (Save ~132 Gas on average)\n\n*Benchmarks based on function purchase which calls the private function `_mintOptionToken()`*\n\n*`Test: Purchase(uint256,address)(uint256)`*\n\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 312368    | 333657   | 333657 | 354946 |\n| After  | 312236    | 333525   | 333525 | 354814 |\n\n*`Test: Purchase(uint256,address)(uint256,uint256)`*\n\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 17877    | 256930   | 221256 | 359646 |\n| After  | 17877    | 256809   | 221124 | 359515 |\n\n```solidity\nFile: /contracts/perp-vault/PerpetualAtlanticVault.sol\n14:import { Counters } from \"@openzeppelin/contracts/utils/Counters.sol\";\n\n39:  using Counters for Counters.Counter;\n\n41:  /// @dev Token ID counter for write positions\n42:  Counters.Counter private _tokenIdCounter;\n```\nhttps://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVault.sol#L588-L592\n```solidity\n588:  function _mintOptionToken() private returns (uint256 tokenId) {\n589:    tokenId = _tokenIdCounter.current();\n590:    _tokenIdCounter.increment();\n591:    _mint(addresses.rdpxV2Core, tokenId);\n592:  }\n```\n\n```diff\n-import { Counters } from \"@openzeppelin/contracts/utils/Counters.sol\";\n import { IPerpetualAtlanticVaultLP } from \"./IPerpetualAtlanticVaultLP.sol\";\n import { ContractWhitelist } from \"../helper/ContractWhitelist.sol\";\n import { Pausable } from \"../helper/Pausable.sol\";\n@@ -36,10 +35,9 @@ contract PerpetualAtlanticVault is\n   ContractWhitelist\n {\n   using SafeERC20 for IERC20WithBurn;\n-  using Counters for Counters.Counter;\n\n   /// @dev Token ID counter for write positions\n-  Counters.Counter private _tokenIdCounter;\n+  uint256 private _tokenIdCounter;\n\n   /// @dev Manager role which handles bootstrapping\n   bytes32 public constant MANAGER_ROLE = keccak256(\"MANAGER_ROLE\");\n@@ -352,7 +350,7 @@ contract PerpetualAtlanticVault is\n     // Transfer rdpx from rdpx rdpxV2Core to perpetual vault\n     IERC20WithBurn(addresses.rdpx).safeTransferFrom(\n       addresses.rdpxV2Core,\n-      addresses.perpetualAtlanticVaultLP,\n+      addresses.perpetualAtlanticVaultLP,//@audit Cache this call?\n       rdpxAmount\n     );\n\n@@ -586,8 +584,10 @@ contract PerpetualAtlanticVault is\n\n   /// @dev Internal function to mint a option token\n   function _mintOptionToken() private returns (uint256 tokenId) {\n-    tokenId = _tokenIdCounter.current();\n-    _tokenIdCounter.increment();\n+    tokenId = _tokenIdCounter;\n+    unchecked {\n+      ++_tokenIdCounter;\n+    }\n     _mint(addresses.rdpxV2Core, tokenId);\n   }\n\n```\n\nhttps://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/reLP/ReLPContract.sol#L138-L164\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-08-dopex",
  "Code": [
    {
      "filename": "contracts/core/RdpxV2Bond.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { ERC721Enumerable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport { Pausable } from \"../helper/Pausable.sol\";\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { ERC721Burnable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport { Counters } from \"@openzeppelin/contracts/utils/Counters.sol\";\n\ncontract RdpxV2Bond is\n  ERC721,\n  ERC721Enumerable,\n  Pausable,\n  AccessControl,\n  ERC721Burnable\n{\n  using Counters for Counters.Counter;\n\n  Counters.Counter private _tokenIdCounter;\n\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n  constructor() ERC721(\"rDPX V2 Bond\", \"rDPXV2Bond\") {\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    _setupRole(MINTER_ROLE, msg.sender);\n  }\n\n  function pause() public onlyRole(DEFAULT_ADMIN_ROLE) {\n    _pause();\n  }\n\n  function unpause() public onlyRole(DEFAULT_ADMIN_ROLE) {\n    _unpause();\n  }\n\n  function mint(\n    address to\n  ) public onlyRole(MINTER_ROLE) returns (uint256 tokenId) {\n    tokenId = _tokenIdCounter.current();\n    _tokenIdCounter.increment();\n    _mint(to, tokenId);\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 tokenId,\n    uint256 batchSize\n  ) internal override(ERC721, ERC721Enumerable) {\n    _whenNotPaused();\n    super._beforeTokenTransfer(from, to, tokenId, batchSize);\n  }\n\n  // The following functions are overrides required by Solidity.\n\n  function supportsInterface(\n    bytes4 interfaceId\n  )\n    public\n    view\n    override(ERC721, ERC721Enumerable, AccessControl)\n    returns (bool)\n  {\n    return super.supportsInterface(interfaceId);\n  }\n}"
    },
    {
      "filename": "contracts/core/RdpxV2Bond.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { ERC721Enumerable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport { Pausable } from \"../helper/Pausable.sol\";\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { ERC721Burnable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport { Counters } from \"@openzeppelin/contracts/utils/Counters.sol\";\n\ncontract RdpxV2Bond is\n  ERC721,\n  ERC721Enumerable,\n  Pausable,\n  AccessControl,\n  ERC721Burnable\n{\n  using Counters for Counters.Counter;\n\n  Counters.Counter private _tokenIdCounter;\n\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n  constructor() ERC721(\"rDPX V2 Bond\", \"rDPXV2Bond\") {\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    _setupRole(MINTER_ROLE, msg.sender);\n  }\n\n  function pause() public onlyRole(DEFAULT_ADMIN_ROLE) {\n    _pause();\n  }\n\n  function unpause() public onlyRole(DEFAULT_ADMIN_ROLE) {\n    _unpause();\n  }\n\n  function mint(\n    address to\n  ) public onlyRole(MINTER_ROLE) returns (uint256 tokenId) {\n    tokenId = _tokenIdCounter.current();\n    _tokenIdCounter.increment();\n    _mint(to, tokenId);\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 tokenId,\n    uint256 batchSize\n  ) internal override(ERC721, ERC721Enumerable) {\n    _whenNotPaused();\n    super._beforeTokenTransfer(from, to, tokenId, batchSize);\n  }\n\n  // The following functions are overrides required by Solidity.\n\n  function supportsInterface(\n    bytes4 interfaceId\n  )\n    public\n    view\n    override(ERC721, ERC721Enumerable, AccessControl)\n    returns (bool)\n  {\n    return super.supportsInterface(interfaceId);\n  }\n}"
    },
    {
      "filename": "contracts/decaying-bonds/RdpxDecayingBonds.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// Libraries\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Contracts\nimport { Pausable } from \"../helper/Pausable.sol\";\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { ERC721Enumerable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport { ERC721Burnable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { Counters } from \"@openzeppelin/contracts/utils/Counters.sol\";\n\n// Interfaces\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\n\ncontract RdpxDecayingBonds is\n  ERC721,\n  ERC721Enumerable,\n  ERC721Burnable,\n  Pausable,\n  AccessControl\n{\n  using SafeERC20 for IERC20WithBurn;\n  using Counters for Counters.Counter;\n\n  Counters.Counter private _tokenIdCounter;\n\n  // Create a new role identifier for the minter role\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n  // Create a new role identifier for the Rdpx v2 core role\n  bytes32 public constant RDPXV2CORE_ROLE = keccak256(\"RDPXV2CORE_ROLE\");\n\n  // Array of bonds\n  mapping(uint256 => Bond) public bonds;\n\n  // Structure to store the bond information\n  struct Bond {\n    address owner;\n    uint256 expiry;\n    uint256 rdpxAmount;\n  }\n\n  event BondMinted(\n    address to,\n    uint256 bondId,\n    uint256 expiry,\n    uint256 rdpxAmount\n  );\n\n  event EmergencyWithdraw(address sender);\n\n  /*==== CONSTRUCTOR ====*/\n  constructor(\n    string memory _name,\n    string memory _symbol\n  ) ERC721(_name, _symbol) {\n    // Grant the minter role and admin role to deployer\n    _setupRole(MINTER_ROLE, msg.sender);\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    _tokenIdCounter.increment();\n  }\n\n  /*============ ADMIN FUNCTIONS ============*/\n\n  /// @notice Pauses the vault for emergency cases\n  /// @dev Can only be called by the owner\n  function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _pause();\n  }\n\n  /// @notice Unpauses the vault\n  /// @dev Can only be called by the owner\n  function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _unpause();\n  }\n\n  /**\n   * @notice Transfers all funds to msg.sender\n   * @dev    Can only be called by the owner\n   * @param  tokens The list of erc20 tokens to withdraw\n   * @param  transferNative Whether should transfer the native currency\n   * @param  to The address to transfer the funds to\n   * @param  amount The amount to transfer\n   * @param  gas The gas to use for the transfer\n   **/\n  function emergencyWithdraw(\n    address[] calldata tokens,\n    bool transferNative,\n    address payable to,\n    uint256 amount,\n    uint256 gas\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _whenPaused();\n    if (transferNative) {\n      (bool success, ) = to.call{ value: amount, gas: gas }(\"\");\n      require(success, \"RdpxReserve: transfer failed\");\n    }\n    IERC20WithBurn token;\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      token = IERC20WithBurn(tokens[i]);\n      token.safeTransfer(msg.sender, token.balanceOf(address(this)));\n    }\n  }\n\n  /// @notice Mints decaying rdpx bonds\n  /// @dev Can only be called by the minter\n  /// @param to address of the user to mint the bonds for\n  /// @param expiry timestamp of the bond expiry\n  /// @param rdpxAmount amount of rdpx to bond\n  function mint(\n    address to,\n    uint256 expiry,\n    uint256 rdpxAmount\n  ) external onlyRole(MINTER_ROLE) {\n    _whenNotPaused();\n    require(hasRole(MINTER_ROLE, msg.sender), \"Caller is not a minter\");\n    uint256 bondId = _mintToken(to);\n    bonds[bondId] = Bond(to, expiry, rdpxAmount);\n\n    emit BondMinted(to, bondId, expiry, rdpxAmount);\n  }\n\n  /// @dev Internal function to mint a bond position token\n  /// @param to the address to mint the position to\n  function _mintToken(address to) private returns (uint256 tokenId) {\n    tokenId = _tokenIdCounter.current();\n    _tokenIdCounter.increment();\n    _mint(to, tokenId);\n  }\n\n  /// @notice Decreases the bond amount\n  /// @dev Can only be called by the rdpxV2Core\n  /// @param bondId id of the bond to decrease\n  /// @param amount amount to decrease\n  function decreaseAmount(\n    uint256 bondId,\n    uint256 amount\n  ) public onlyRole(RDPXV2CORE_ROLE) {\n    _whenNotPaused();\n    bonds[bondId].rdpxAmount = amount;\n  }\n\n  /*============ VIEW FUNCTIONS ============*/\n\n  /// @notice returns the bonds owned by an address\n  /// @param _address address of the user\n  function getBondsOwned(\n    address _address\n  ) external view returns (uint256[] memory) {\n    uint256 ownerTokenCount = balanceOf(_address);\n    uint256[] memory tokenIds = new uint256[](ownerTokenCount);\n    for (uint256 i; i < ownerTokenCount; i++) {\n      tokenIds[i] = tokenOfOwnerByIndex(_address, i);\n    }\n    return tokenIds;\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 tokenId,\n    uint256 batchSize\n  ) internal override(ERC721, ERC721Enumerable) {\n    _whenNotPaused();\n    super._beforeTokenTransfer(from, to, tokenId, batchSize);\n  }\n\n  // The following functions are overrides required by Solidity.\n\n  function supportsInterface(\n    bytes4 interfaceId\n  )\n    public\n    view\n    override(ERC721, ERC721Enumerable, AccessControl)\n    returns (bool)\n  {\n    return super.supportsInterface(interfaceId);\n  }\n}"
    },
    {
      "filename": "contracts/decaying-bonds/RdpxDecayingBonds.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// Libraries\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Contracts\nimport { Pausable } from \"../helper/Pausable.sol\";\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { ERC721Enumerable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport { ERC721Burnable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { Counters } from \"@openzeppelin/contracts/utils/Counters.sol\";\n\n// Interfaces\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\n\ncontract RdpxDecayingBonds is\n  ERC721,\n  ERC721Enumerable,\n  ERC721Burnable,\n  Pausable,\n  AccessControl\n{\n  using SafeERC20 for IERC20WithBurn;\n  using Counters for Counters.Counter;\n\n  Counters.Counter private _tokenIdCounter;\n\n  // Create a new role identifier for the minter role\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n  // Create a new role identifier for the Rdpx v2 core role\n  bytes32 public constant RDPXV2CORE_ROLE = keccak256(\"RDPXV2CORE_ROLE\");\n\n  // Array of bonds\n  mapping(uint256 => Bond) public bonds;\n\n  // Structure to store the bond information\n  struct Bond {\n    address owner;\n    uint256 expiry;\n    uint256 rdpxAmount;\n  }\n\n  event BondMinted(\n    address to,\n    uint256 bondId,\n    uint256 expiry,\n    uint256 rdpxAmount\n  );\n\n  event EmergencyWithdraw(address sender);\n\n  /*==== CONSTRUCTOR ====*/\n  constructor(\n    string memory _name,\n    string memory _symbol\n  ) ERC721(_name, _symbol) {\n    // Grant the minter role and admin role to deployer\n    _setupRole(MINTER_ROLE, msg.sender);\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    _tokenIdCounter.increment();\n  }\n\n  /*============ ADMIN FUNCTIONS ============*/\n\n  /// @notice Pauses the vault for emergency cases\n  /// @dev Can only be called by the owner\n  function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _pause();\n  }\n\n  /// @notice Unpauses the vault\n  /// @dev Can only be called by the owner\n  function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _unpause();\n  }\n\n  /**\n   * @notice Transfers all funds to msg.sender\n   * @dev    Can only be called by the owner\n   * @param  tokens The list of erc20 tokens to withdraw\n   * @param  transferNative Whether should transfer the native currency\n   * @param  to The address to transfer the funds to\n   * @param  amount The amount to transfer\n   * @param  gas The gas to use for the transfer\n   **/\n  function emergencyWithdraw(\n    address[] calldata tokens,\n    bool transferNative,\n    address payable to,\n    uint256 amount,\n    uint256 gas\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _whenPaused();\n    if (transferNative) {\n      (bool success, ) = to.call{ value: amount, gas: gas }(\"\");\n      require(success, \"RdpxReserve: transfer failed\");\n    }\n    IERC20WithBurn token;\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      token = IERC20WithBurn(tokens[i]);\n      token.safeTransfer(msg.sender, token.balanceOf(address(this)));\n    }\n  }\n\n  /// @notice Mints decaying rdpx bonds\n  /// @dev Can only be called by the minter\n  /// @param to address of the user to mint the bonds for\n  /// @param expiry timestamp of the bond expiry\n  /// @param rdpxAmount amount of rdpx to bond\n  function mint(\n    address to,\n    uint256 expiry,\n    uint256 rdpxAmount\n  ) external onlyRole(MINTER_ROLE) {\n    _whenNotPaused();\n    require(hasRole(MINTER_ROLE, msg.sender), \"Caller is not a minter\");\n    uint256 bondId = _mintToken(to);\n    bonds[bondId] = Bond(to, expiry, rdpxAmount);\n\n    emit BondMinted(to, bondId, expiry, rdpxAmount);\n  }\n\n  /// @dev Internal function to mint a bond position token\n  /// @param to the address to mint the position to\n  function _mintToken(address to) private returns (uint256 tokenId) {\n    tokenId = _tokenIdCounter.current();\n    _tokenIdCounter.increment();\n    _mint(to, tokenId);\n  }\n\n  /// @notice Decreases the bond amount\n  /// @dev Can only be called by the rdpxV2Core\n  /// @param bondId id of the bond to decrease\n  /// @param amount amount to decrease\n  function decreaseAmount(\n    uint256 bondId,\n    uint256 amount\n  ) public onlyRole(RDPXV2CORE_ROLE) {\n    _whenNotPaused();\n    bonds[bondId].rdpxAmount = amount;\n  }\n\n  /*============ VIEW FUNCTIONS ============*/\n\n  /// @notice returns the bonds owned by an address\n  /// @param _address address of the user\n  function getBondsOwned(\n    address _address\n  ) external view returns (uint256[] memory) {\n    uint256 ownerTokenCount = balanceOf(_address);\n    uint256[] memory tokenIds = new uint256[](ownerTokenCount);\n    for (uint256 i; i < ownerTokenCount; i++) {\n      tokenIds[i] = tokenOfOwnerByIndex(_address, i);\n    }\n    return tokenIds;\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 tokenId,\n    uint256 batchSize\n  ) internal override(ERC721, ERC721Enumerable) {\n    _whenNotPaused();\n    super._beforeTokenTransfer(from, to, tokenId, batchSize);\n  }\n\n  // The following functions are overrides required by Solidity.\n\n  function supportsInterface(\n    bytes4 interfaceId\n  )\n    public\n    view\n    override(ERC721, ERC721Enumerable, AccessControl)\n    returns (bool)\n  {\n    return super.supportsInterface(interfaceId);\n  }\n}"
    },
    {
      "filename": "contracts/perp-vault/PerpetualAtlanticVault.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// Libraries\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Contracts\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { ERC721Enumerable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport { ERC721Burnable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport { ERC4626 } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { Counters } from \"@openzeppelin/contracts/utils/Counters.sol\";\nimport { IPerpetualAtlanticVaultLP } from \"./IPerpetualAtlanticVaultLP.sol\";\nimport { ContractWhitelist } from \"../helper/ContractWhitelist.sol\";\nimport { Pausable } from \"../helper/Pausable.sol\";\n\n// Interfaces\nimport { IPerpetualAtlanticVault } from \"./IPerpetualAtlanticVault.sol\";\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\nimport { IOptionPricing } from \"../interfaces/IOptionPricing.sol\";\nimport { IRdpxEthOracle } from \"../interfaces/IRdpxEthOracle.sol\";\nimport { IVolatilityOracle } from \"../interfaces/IVolatilityOracle.sol\";\n\n/// @title Contract to offer perpetual atlantic rDPX PUT options to the rdpxV2Core contract\n/// @dev Option tokens are in erc20 18 decimals & Strikes are in 1e8 precision\ncontract PerpetualAtlanticVault is\n  IPerpetualAtlanticVault,\n  ReentrancyGuard,\n  Pausable,\n  ERC721,\n  ERC721Enumerable,\n  ERC721Burnable,\n  AccessControl,\n  ContractWhitelist\n{\n  using SafeERC20 for IERC20WithBurn;\n  using Counters for Counters.Counter;\n\n  /// @dev Token ID counter for write positions\n  Counters.Counter private _tokenIdCounter;\n\n  /// @dev Manager role which handles bootstrapping\n  bytes32 public constant MANAGER_ROLE = keccak256(\"MANAGER_ROLE\");\n\n  /// @dev Rdpx v2 core role which can purchase and settle options\n  bytes32 public constant RDPXV2CORE_ROLE = keccak256(\"RDPXV2CORE_ROLE\");\n\n  /// @dev Underlying assets symbol\n  string public underlyingSymbol;\n\n  /// @dev Contract addresses\n  Addresses public addresses;\n\n  /// @dev Collateral Token\n  IERC20WithBurn public collateralToken;\n\n  /// @dev The precision of the collateral token\n  uint256 public collateralPrecision;\n\n  /// @dev tokenId => OptionPosition\n  mapping(uint256 => OptionPosition) public optionPositions;\n\n  /// @dev number of options funding has been accounted for the epoch\n  mapping(uint256 => uint256) public fundingPaymentsAccountedFor;\n\n  /// @dev the funding accounted for the epoch and strike\n  mapping(uint256 => mapping(uint256 => uint256))\n    public fundingPaymentsAccountedForPerStrike;\n\n  /// @dev the total funding for the epoch\n  mapping(uint256 => uint256) public totalFundingForEpoch;\n\n  /// @dev amount of options per strike\n  mapping(uint256 => uint256) public optionsPerStrike;\n\n  /// @dev latest funding update per strike\n  mapping(uint256 => uint256) public latestFundingPerStrike;\n\n  // @dev Funding rate for the epoch\n  mapping(uint256 => uint256) public fundingRates;\n\n  /// @dev the pointer to the lattest funding payment timestamp\n  /// @notice Explain to an end user what this does\n  /// @dev Explain to a developer any extra details\n  /// @return Documents the return variables of a contractâ€™s function state variable\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  uint256 public latestFundingPaymentPointer = 0;\n\n  /// @dev the total number of active options\n  uint256 public totalActiveOptions;\n\n  /// @dev genesis timestamp\n  uint256 public genesis;\n\n  /// @dev the timestamp of the last update where funding was paid for\n  uint256 public lastUpdateTime;\n\n  /// @dev the duration between funding payments\n  uint256 public fundingDuration = 7 days;\n\n  /// @dev the precision to round up to\n  uint256 public roundingPrecision = 1e6;\n\n  // ================================ CONSTRUCTOR ================================ //\n\n  /// @notice Contract constructor\n  /// @param _name ERC721 name\n  /// @param _symbol ERC721 symbol\n  /// @param _collateralToken Collateral token of the perpetual atlantic vault\n  /// @param _gensis Gensis time for funding calculation\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    address _collateralToken,\n    uint256 _gensis\n  ) ERC721(_name, _symbol) {\n    _validate(_collateralToken != address(0), 1);\n\n    collateralToken = IERC20WithBurn(_collateralToken);\n    underlyingSymbol = collateralToken.symbol();\n    collateralPrecision = 10 ** collateralToken.decimals();\n    genesis = _gensis;\n\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    _setupRole(MANAGER_ROLE, msg.sender);\n  }\n\n  // ================================ ADMIN FUNCTIONS ================================ //\n\n  /**\n   * @notice Pauses the vault for emergency cases\n   * @dev    Can only be called by the owner\n   **/\n  function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _pause();\n  }\n\n  /**\n   * @notice Unpauses the vault\n   * @dev    Can only be called by the owner\n   **/\n  function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _unpause();\n  }\n\n  /**\n   * @notice Add a contract to the whitelist\n   * @dev    Can only be called by the owner\n   * @param  _contract Address of the contract that needs to be added to the whitelist\n   **/\n  function addToContractWhitelist(\n    address _contract\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _addToContractWhitelist(_contract);\n  }\n\n  /**\n   * @notice Remove a contract to the whitelist\n   * @dev    Can only be called by the owner\n   * @param  _contract Address of the contract that needs to be removed from the whitelist\n   **/\n  function removeFromContractWhitelist(\n    address _contract\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _removeFromContractWhitelist(_contract);\n  }\n\n  /**\n   * @notice Sets (adds) a list of addresses to the address list\n   * @dev    Can only be called by the owner\n   * @param  _optionPricing Address of the option pricing contract\n   * @param  _assetPriceOracle Address of the asset price oracle contract\n   * @param  _volatilityOracle Address of the volatility oracle contract\n   * @param  _feeDistributor Address of the fee distributor contract\n   * @param  _rdpx Address of the rdpx contract\n   * @param  _perpetualAtlanticVaultLP Address of the perpetual atlantic vault lp contract\n   * @param  _rdpxV2Core Address of the rdpx v2 rdpxV2Core contract\n   **/\n  function setAddresses(\n    address _optionPricing,\n    address _assetPriceOracle,\n    address _volatilityOracle,\n    address _feeDistributor,\n    address _rdpx,\n    address _perpetualAtlanticVaultLP,\n    address _rdpxV2Core\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_optionPricing != address(0), 1);\n    _validate(_assetPriceOracle != address(0), 1);\n    _validate(_volatilityOracle != address(0), 1);\n    _validate(_feeDistributor != address(0), 1);\n    _validate(_rdpx != address(0), 1);\n    _validate(_perpetualAtlanticVaultLP != address(0), 1);\n    _validate(_rdpxV2Core != address(0), 1);\n\n    addresses = Addresses({\n      optionPricing: _optionPricing,\n      assetPriceOracle: _assetPriceOracle,\n      volatilityOracle: _volatilityOracle,\n      feeDistributor: _feeDistributor,\n      rdpx: _rdpx,\n      perpetualAtlanticVaultLP: _perpetualAtlanticVaultLP,\n      rdpxV2Core: _rdpxV2Core\n    });\n    collateralToken.safeApprove(\n      addresses.perpetualAtlanticVaultLP,\n      type(uint256).max\n    );\n    emit AddressesSet(addresses);\n  }\n\n  /**\n   * @notice Transfers all funds to msg.sender\n   * @dev    Can only be called by the owner\n   * @param  tokens The list of erc20 tokens to withdraw\n   **/\n  function emergencyWithdraw(\n    address[] calldata tokens\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _whenPaused();\n    IERC20WithBurn token;\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      token = IERC20WithBurn(tokens[i]);\n      token.safeTransfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    emit EmergencyWithdraw(msg.sender, tokens);\n  }\n\n  /**\n   * @notice Updates the funding duration\n   * @dev    Can only be called by the owner\n   **/\n  function updateFundingDuration(\n    uint256 _fundingDuration\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    fundingDuration = _fundingDuration;\n  }\n\n  function setLpAllowance(bool increase) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    increase\n      ? collateralToken.approve(\n        addresses.perpetualAtlanticVaultLP,\n        type(uint256).max\n      )\n      : collateralToken.approve(addresses.perpetualAtlanticVaultLP, 0);\n  }\n\n  // ================================ TREASURY FUNCTIONS ================================ //\n\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  function purchase(\n    uint256 amount,\n    address to\n  )\n    external\n    nonReentrant\n    onlyRole(RDPXV2CORE_ROLE)\n    returns (uint256 premium, uint256 tokenId)\n  {\n    _whenNotPaused();\n    _validate(amount > 0, 2);\n\n    updateFunding();\n\n    uint256 currentPrice = getUnderlyingPrice(); // price of underlying wrt collateralToken\n    uint256 strike = roundUp(currentPrice - (currentPrice / 4)); // 25% below the current price\n    IPerpetualAtlanticVaultLP perpetualAtlanticVaultLp = IPerpetualAtlanticVaultLP(\n        addresses.perpetualAtlanticVaultLP\n      );\n\n    // Check if vault has enough collateral to write the options\n    uint256 requiredCollateral = (amount * strike) / 1e8;\n\n    _validate(\n      requiredCollateral <= perpetualAtlanticVaultLp.totalAvailableCollateral(),\n      3\n    );\n\n    uint256 timeToExpiry = nextFundingPaymentTimestamp() - block.timestamp;\n\n    // Get total premium for all options being purchased\n    premium = calculatePremium(strike, amount, timeToExpiry, 0);\n\n    // Transfer premium from msg.sender to PerpetualAtlantics vault\n    collateralToken.safeTransferFrom(msg.sender, address(this), premium);\n\n    perpetualAtlanticVaultLp.lockCollateral(requiredCollateral);\n    _updateFundingRate(premium);\n\n    // Mint the option tokens\n    tokenId = _mintOptionToken();\n    optionPositions[tokenId] = OptionPosition({\n      strike: strike,\n      amount: amount,\n      positionId: tokenId\n    });\n\n    totalActiveOptions += amount;\n    fundingPaymentsAccountedFor[latestFundingPaymentPointer] += amount;\n    optionsPerStrike[strike] += amount;\n\n    // record the number of options funding has been accounted for the epoch and strike\n    fundingPaymentsAccountedForPerStrike[latestFundingPaymentPointer][\n      strike\n    ] += amount;\n\n    emit Purchase(strike, amount, premium, to, msg.sender);\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  function settle(\n    uint256[] memory optionIds\n  )\n    external\n    nonReentrant\n    onlyRole(RDPXV2CORE_ROLE)\n    returns (uint256 ethAmount, uint256 rdpxAmount)\n  {\n    _whenNotPaused();\n    _isEligibleSender();\n\n    updateFunding();\n\n    for (uint256 i = 0; i < optionIds.length; i++) {\n      uint256 strike = optionPositions[optionIds[i]].strike;\n      uint256 amount = optionPositions[optionIds[i]].amount;\n\n      // check if strike is ITM\n      _validate(strike >= getUnderlyingPrice(), 7);\n\n      ethAmount += (amount * strike) / 1e8;\n      rdpxAmount += amount;\n      optionsPerStrike[strike] -= amount;\n      totalActiveOptions -= amount;\n\n      // Burn option tokens from user\n      _burn(optionIds[i]);\n\n      optionPositions[optionIds[i]].strike = 0;\n    }\n\n    // Transfer collateral token from perpetual vault to rdpx rdpxV2Core\n    collateralToken.safeTransferFrom(\n      addresses.perpetualAtlanticVaultLP,\n      addresses.rdpxV2Core,\n      ethAmount\n    );\n    // Transfer rdpx from rdpx rdpxV2Core to perpetual vault\n    IERC20WithBurn(addresses.rdpx).safeTransferFrom(\n      addresses.rdpxV2Core,\n      addresses.perpetualAtlanticVaultLP,\n      rdpxAmount\n    );\n\n    IPerpetualAtlanticVaultLP(addresses.perpetualAtlanticVaultLP).subtractLoss(\n      ethAmount\n    );\n    IPerpetualAtlanticVaultLP(addresses.perpetualAtlanticVaultLP)\n      .unlockLiquidity(ethAmount);\n    IPerpetualAtlanticVaultLP(addresses.perpetualAtlanticVaultLP).addRdpx(\n      rdpxAmount\n    );\n\n    emit Settle(ethAmount, rdpxAmount, optionIds);\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  function payFunding() external onlyRole(RDPXV2CORE_ROLE) returns (uint256) {\n    _whenNotPaused();\n    _isEligibleSender();\n\n    _validate(\n      totalActiveOptions ==\n        fundingPaymentsAccountedFor[latestFundingPaymentPointer],\n      6\n    );\n\n    collateralToken.safeTransferFrom(\n      addresses.rdpxV2Core,\n      address(this),\n      totalFundingForEpoch[latestFundingPaymentPointer]\n    );\n    _updateFundingRate(totalFundingForEpoch[latestFundingPaymentPointer]);\n\n    emit PayFunding(\n      msg.sender,\n      totalFundingForEpoch[latestFundingPaymentPointer],\n      latestFundingPaymentPointer\n    );\n\n    return (totalFundingForEpoch[latestFundingPaymentPointer]);\n  }\n\n  // ================================ PUBLIC/EXTERNAL FUNCTIONS ================================ //\n\n  /**\n   * @notice Function to calculate the funding of options for the next epoch\n   * @param  strikes array of strikes to calculate the funding for\n   * @return fundingAmount the funding of options\n   **/\n  function calculateFunding(\n    uint256[] memory strikes\n  ) external nonReentrant returns (uint256 fundingAmount) {\n    _whenNotPaused();\n    _isEligibleSender();\n\n    updateFundingPaymentPointer();\n\n    for (uint256 i = 0; i < strikes.length; i++) {\n      _validate(optionsPerStrike[strikes[i]] > 0, 4);\n      _validate(\n        latestFundingPerStrike[strikes[i]] != latestFundingPaymentPointer,\n        5\n      );\n      uint256 strike = strikes[i];\n\n      uint256 amount = optionsPerStrike[strike] -\n        fundingPaymentsAccountedForPerStrike[latestFundingPaymentPointer][\n          strike\n        ];\n\n      uint256 timeToExpiry = nextFundingPaymentTimestamp() -\n        (genesis + ((latestFundingPaymentPointer - 1) * fundingDuration));\n\n      uint256 premium = calculatePremium(\n        strike,\n        amount,\n        timeToExpiry,\n        getUnderlyingPrice()\n      );\n\n      latestFundingPerStrike[strike] = latestFundingPaymentPointer;\n      fundingAmount += premium;\n\n      // Record number of options that funding payments were accounted for, for this epoch\n      fundingPaymentsAccountedFor[latestFundingPaymentPointer] += amount;\n\n      // record the number of options funding has been accounted for the epoch and strike\n      fundingPaymentsAccountedForPerStrike[latestFundingPaymentPointer][\n        strike\n      ] += amount;\n\n      // Record total funding for this epoch\n      // This does not need to be done in purchase() since it's already accounted for using `addProceeds()`\n      totalFundingForEpoch[latestFundingPaymentPointer] += premium;\n\n      emit CalculateFunding(\n        msg.sender,\n        amount,\n        strike,\n        premium,\n        latestFundingPaymentPointer\n      );\n    }\n  }\n\n  /// @dev Helper function that updates the latest funding payment pointer based on current timestamp\n  function updateFundingPaymentPointer() public {\n    while (block.timestamp >= nextFundingPaymentTimestamp()) {\n      if (lastUpdateTime < nextFundingPaymentTimestamp()) {\n        uint256 currentFundingRate = fundingRates[latestFundingPaymentPointer];\n\n        uint256 startTime = lastUpdateTime == 0\n          ? (nextFundingPaymentTimestamp() - fundingDuration)\n          : lastUpdateTime;\n\n        lastUpdateTime = nextFundingPaymentTimestamp();\n\n        collateralToken.safeTransfer(\n          addresses.perpetualAtlanticVaultLP,\n          (currentFundingRate * (nextFundingPaymentTimestamp() - startTime)) /\n            1e18\n        );\n\n        IPerpetualAtlanticVaultLP(addresses.perpetualAtlanticVaultLP)\n          .addProceeds(\n            (currentFundingRate * (nextFundingPaymentTimestamp() - startTime)) /\n              1e18\n          );\n\n        emit FundingPaid(\n          msg.sender,\n          ((currentFundingRate * (nextFundingPaymentTimestamp() - startTime)) /\n            1e18),\n          latestFundingPaymentPointer\n        );\n      }\n\n      latestFundingPaymentPointer += 1;\n      emit FundingPaymentPointerUpdated(latestFundingPaymentPointer);\n    }\n  }\n\n  /**\n   * @notice function to transfer funding into the LP in a drip-vested manner\n   * @dev    addProceeds() is invoked to update totalCollateral in LP\n   **/\n  function updateFunding() public {\n    updateFundingPaymentPointer();\n    uint256 currentFundingRate = fundingRates[latestFundingPaymentPointer];\n    uint256 startTime = lastUpdateTime == 0\n      ? (nextFundingPaymentTimestamp() - fundingDuration)\n      : lastUpdateTime;\n    lastUpdateTime = block.timestamp;\n\n    collateralToken.safeTransfer(\n      addresses.perpetualAtlanticVaultLP,\n      (currentFundingRate * (block.timestamp - startTime)) / 1e18\n    );\n\n    IPerpetualAtlanticVaultLP(addresses.perpetualAtlanticVaultLP).addProceeds(\n      (currentFundingRate * (block.timestamp - startTime)) / 1e18\n    );\n\n    emit FundingPaid(\n      msg.sender,\n      ((currentFundingRate * (block.timestamp - startTime)) / 1e18),\n      latestFundingPaymentPointer\n    );\n  }\n\n  // ================================ VIEWS ================================ //\n\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  function getUnderlyingPrice() public view returns (uint256) {\n    return IRdpxEthOracle(addresses.assetPriceOracle).getRdpxPriceInEth();\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  function getVolatility(uint256 _strike) public view returns (uint256) {\n    return IVolatilityOracle(addresses.volatilityOracle).getVolatility(_strike);\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  function calculatePremium(\n    uint256 _strike,\n    uint256 _amount,\n    uint256 timeToExpiry,\n    uint256 _price\n  ) public view returns (uint256 premium) {\n    premium = ((IOptionPricing(addresses.optionPricing).getOptionPrice(\n      _strike,\n      _price > 0 ? _price : getUnderlyingPrice(),\n      getVolatility(_s"
    }
  ]
}