{
  "Title": "M-7: Losses of some long traders can eat into the margins of others",
  "Content": "# Issue M-7: Losses of some long traders can eat into the margins of others \n\nSource: https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/198 \n\n## Found by \nxiaoming90\n## Summary\n\nThe losses of some long traders can eat into the margins of others, resulting in those affected long traders being unable to withdraw their margin and profits, leading to a loss of assets for the long traders.\n\n## Vulnerability Detail\n\nAt $T0$, the current price of ETH is \\$1000 and assume the following state:\n\n| Alice's Long Position 1                                     | Bob's Long Position 2                                       | Charles (LP)     |\n| ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------- |\n| Position Size = 6 ETH<br />Margin = 3 ETH<br />Last Price (entry price) = \\$1000 | Position Size = 6 ETH<br />Margin = 5 ETH<br />Last Price (entry price) = \\$1000 | Deposited 12 ETH |\n\n- The `stableCollateralTotal` will be 12 ETH\n- The `GlobalPositions.marginDepositedTotal` will be 8 ETH (3 + 5)\n- The `globalPosition.sizeOpenedTotal` will be 12 ETH (6 + 6)\n- The total balance of ETH in the vault is 20 ETH. \n\n\nAs this is a perfectly hedged market, the accrued fee will be zero, and ignored in this report for simplicity's sake.\n\nAt $T1$, the price of the ETH drops from \\$1000 to \\$600. At this point, the settle margin of both long positions will be as follows:\n\n| Alice's Long Position 1                                     | Bob's Long Position 2                                       |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| priceShift = Current Price - Last Price = \\$600 - \\$1000 = -\\$400<br />PnL = (Position Size * priceShift) / Current Price = (6 ETH * -\\$400) / \\$400 = -4 ETH<br />settleMargin = marginDeposited + PnL = 3 ETH + (-4 ETH) = -1 ETH | PnL = -4 ETH (Same calculation)<br />settleMargin = marginDeposited + PnL = 5 ETH + (-4 ETH) = 1 ETH |\n\nAlice's long position is underwater (settleMargin < 0), so it can be liquidated. When the liquidation is triggered, it will internally call the `updateGlobalPositionData` function. Even if the liquidation does not occur, any of the following actions will also trigger the `updateGlobalPositionData` function internally:\n\n- executeOpen\n- executeAdjust\n- executeClose\n\nThe purpose of the `updateGlobalPositionData` function is to update the global position data. This includes getting the total profit loss of all long traders (Alice & Bob), and updating the margin deposited total + stable collateral total accordingly.\n\nAssume that the `updateGlobalPositionData` function is triggered by one of the above-mentioned functions. Line 179 below will compute the total PnL of all the opened long positions.\n\n```solidity\npriceShift = current price - last price\npriceShift = $600 - $1000 = -$400\n\nprofitLossTotal = (globalPosition.sizeOpenedTotal * priceShift) / current price\nprofitLossTotal = (12 ETH * -$400) / $600\nprofitLossTotal = -8 ETH\n```\n\nThe `profitLossTotal` is -8 ETH. This is aligned with what we have calculated earlier, where Alice's PnL is -4 ETH and Bob's PnL is -4 ETH (total = -8 ETH loss). \n\nAt Line 184 below, the `newMarginDepositedTotal` will be set to as follows (ignoring the `_marginDelta` for simplicity's sake)\n\n```solidity\nnewMarginDepositedTotal = _globalPositions.marginDepositedTotal + _marginDelta + profitLossTotal\nnewMarginDepositedTotal = 8 ETH + 0 + (-8 ETH) = 0 ETH\n```\n\nWhat happened above is that 8 ETH collateral is deducted from the long traders and transferred to LP. When `newMarginDepositedTotal` is zero, this means that the long trader no longer owns any collateral. This is incorrect, as Bob's position should still contribute 1 ETH remaining margin to the long trader's pool.\n\nLet's review Alice's Long Position 1: Her position's settled margin is -1 ETH. When the settled margin is -ve then the LPs have to bear the cost of loss per the comment [here](https://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/LiquidationModule.sol#L139). However, in this case, we can see that it is Bob (long trader) instead of LPs who are bearing the cost of Alice's loss, which is incorrect.\n\nLet's review Bob's Long Position 2: His position's settled margin is 1 ETH. If his position's liquidation margin is $LM$, Bob should be able to withdraw $1\\  ETH - LM$ of his position's margin. However, in this case, the `marginDepositedTotal` is already zero, so there is no more collateral left on the long trader pool for Bob to withdraw, which is incorrect.\n\nWith the current implementation, the losses of some long traders can eat into the margins of others, resulting in those affected long traders being unable to withdraw their margin and profits.\n\nhttps://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/FlatcoinVault.sol#L173\n\n```solidity\nbeing File: FlatcoinVault.sol\n173:     function updateGlobalPositionData(\n174:         uint256 _price,\n175:         int256 _marginDelta,\n176:         int256 _additionalSizeDelta\n177:     ) external onlyAuthorizedModule {\n178:         // Get the total profit loss and update the margin deposited total.\n179:         int256 profitLossTotal = PerpMath._profitLossTotal({globalPosition: _globalPositions, price: _price});\n180: \n181:         // Note that technically, even the funding fees should be accounted for when computing the margin deposited total.\n182:         // However, since the funding fees are settled at the same time as the global position data is updated,\n183:         // we can ignore the funding fees here.\n184:         int256 newMarginDepositedTotal = int256(_globalPositions.marginDepositedTotal) + _marginDelta + profitLossTotal;\n185: \n186:         // Check that the sum of margin of all the leverage traders is not negative.\n187:         // Rounding errors shouldn't result in a negative margin deposited total given that\n188:         // we are rounding down the profit loss of the position.\n189:         // If anything, after closing the last position in the system, the `marginDepositedTotal` should can be positive.\n190:         // The margin may be negative if liquidations are not happening in a timely manner.\n191:         if (newMarginDepositedTotal < 0) {\n192:             revert FlatcoinErrors.InsufficientGlobalMargin();\n193:         }\n194: \n195:         _globalPositions = FlatcoinStructs.GlobalPositions({\n196:             marginDepositedTotal: uint256(newMarginDepositedTotal),\n197:             sizeOpenedTotal: (int256(_globalPositions.sizeOpenedTotal) + _additionalSizeDelta).toUint256(),\n198:             lastPrice: _price\n199:         });\n200: \n201:         // Profit loss of leverage traders has to be accounted for by adjusting the stable collateral total.\n202:         // Note that technically, even the funding fees should be accounted for when computing the stable collateral total.\n203:         // However, since the funding fees are settled at the same time as the global position data is updated,\n204:         // we can ignore the funding fees here\n205:         _updateStableCollateralTotal(-profitLossTotal);\n206:     }\n```\n\n## Impact\n\nLoss of assets for the long traders as the losses of some long traders can eat into the margins of others, resulting in those affected long traders being unable to withdraw their margin and profits.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/FlatcoinVault.sol#L173\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe following are the two issues identified earlier and the recommended fixes:\n\n**Issue 1**\n\n> Let's review Alice's Long Position 1: Her position's settled margin is -1 ETH. When the settled margin is -ve then the LPs have to bear the cost of loss per the comment [here](https://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/LiquidationModule.sol#L139). However, in this case, we can see that it is Bob (long trader) instead of LPs who are bearing the cost of Alice's loss, which is incorrect.\n\nFix: Alice -1 ETH loss should be borne by the LP, not the long traders. The stable collateral total of LP should be deducted by 1 ETH to bear the cost of the loss.\n\n**Issue 2**\n\n> Let's review Bob's Long Position 2: His position's settled margin is 1 ETH. If his position's liquidation margin is $LM$, Bob should be able to withdraw $1\\  ETH - LM$ of his position's margin. However, in this case, the `marginDepositedTotal` is already zero, so there is no more collateral left on the long trader pool for Bob to withdraw, which is incorrect.\n\nFix: Bob should be able to withdraw $1\\  ETH - LM$ of his position's margin regardless of the PnL of other long traders. Bob's margin should be isolated from Alice's loss.\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid: high(7)\n\n\n\n**0xLogos**\n\nEscalate \n\nInvalid (maybe medium if I'm missing something, clearly not high)\n\nIsn't described scenario is just a speculation? Why Alice's long position was not liquidated earlier? Even if price dropped that significant in ~1 minute there is still enough time to liquidate.\n\n**sherlock-admin2**\n\n> Escalate \n> \n> Invalid (maybe medium if I'm missing something, clearly not high)\n> \n> Isn't described scenario is just a speculation? Why Alice's long position was not liquidated earlier? Even if price dropped that significant in ~1 minute there is still enough time to liquidate.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**securitygrid**\n\nThe judge should consider whether the scenario or the assumed system state (the value of some variables) described in a report will actually occur or not. This is important.\n\nThe scenario described in this report is unlikely to occur. Because Alice's position should have been liquidated before T1, why did it have to wait until bad debts occurred before it was liquidated?\nIf the protocol has only one keeper, then such a scenario may occur when the keeper goes down. However, the protocol has multiple keepers: from third parties and from the protocol itself. It is impossible for all keepers going down.\n\n**xiaoming9090**\n\nThe issue stands valid and remains high as it leads to a loss of assets for the long traders, as described in the \"impact\" section of the report. \n\nThe scenario is a valid example to demonstrate the issue on hand. The points related to the timing of the liquidation in the escalation are irrelevant, as the bugs will be triggered when liquidation is executed.\n\nAlso, we cannot expect the liquidator keeper always to liquidate the accounts before the settled margin falls below zero (bad debt) under all circumstances due to many reasons (e.g., the price dropped too fast, delay due to too many TX queues at sequencer, time delay between the oracle and market price)\n\nThe scenario where the settled margin falls below zero (bad debt) is absolutely something that will happen in the real world. In the code of the liquidation function [here](https://github.com/sherlock-audit/2023-12-flatmoney/blob/bba4f077a64f43fbd565f8983388d0e985cb85db/flatcoin-v1/src/LiquidationModule.sol#L139), even the protocol expected that the settled margin could fall below zero (bad debt) under some conditions and implement logic to handle this scenario.\n\n```solidity\n// If the settled margin is -ve then the LPs have to bear the cost.\n// Adjust the stable collateral total to account for user's profit/loss and the negative margin.\n// Note: We are adding `settledMargin` and `profitLoss` instead of subtracting because of their sign (which will be -ve).\nvault.updateStableCollateralTotal(settledMargin - positionSummary.profitLoss);\n```\n\n#\n\n**Czar102**\n\nWould like sponsors to comment on this issue @D-Ig @itsermin @rashtrakoff â€“ is it unintended?\n@nevillehuang any thoughts?\n\nGiven that this occurs on accrual of bad debt, I think it should be classified at most as a Medium severity issue.\n\n**rashtrakoff**\n\nThe old math (that is math being used in the audit version of contracts) had this side effect. The new math fixes this along with other issues.\n\n**Czar102**\n\nThank you @rashtrakoff.\n\nPlanning to accept the escalation and consider this a Medium severity issue.\n\n**nevillehuang**\n\n> Thank you @rashtrakoff.\n> \n> Planning to accept the escalation and consider this a Medium severity issue.\n\nAgree to downgrade to medium severity\n\n**Czar102**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0xLogos](https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/198/#issuecomment-1956807320): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/132",
  "Code": [
    {
      "filename": "flatcoin-v1/src/LiquidationModule.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\nimport {Initializable} from \"openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\n\nimport {ModuleUpgradeable} from \"./abstracts/ModuleUpgradeable.sol\";\nimport {OracleModifiers} from \"./abstracts/OracleModifiers.sol\";\nimport {FlatcoinErrors} from \"./libraries/FlatcoinErrors.sol\";\nimport {FlatcoinStructs} from \"./libraries/FlatcoinStructs.sol\";\nimport {FlatcoinModuleKeys} from \"./libraries/FlatcoinModuleKeys.sol\";\nimport {FlatcoinEvents} from \"./libraries/FlatcoinEvents.sol\";\nimport {PerpMath} from \"./libraries/PerpMath.sol\";\nimport {InvariantChecks} from \"./misc/InvariantChecks.sol\";\n\nimport {IFlatcoinVault} from \"./interfaces/IFlatcoinVault.sol\";\nimport {ILeverageModule} from \"./interfaces/ILeverageModule.sol\";\nimport {IOracleModule} from \"./interfaces/IOracleModule.sol\";\nimport {ILiquidationModule} from \"./interfaces/ILiquidationModule.sol\";\nimport {ILimitOrder} from \"./interfaces/ILimitOrder.sol\";\n\n/// @title LiquidationModule\n/// @author dHEDGE\n/// @notice Module for liquidating leveraged positions.\ncontract LiquidationModule is\n    ILiquidationModule,\n    Initializable,\n    ModuleUpgradeable,\n    OracleModifiers,\n    ReentrancyGuardUpgradeable,\n    InvariantChecks\n{\n    /// @notice Liquidation fee basis points paid to liquidator.\n    /// @dev Note that this needs to be used together with keeper fee bounds.\n    /// @dev Should include 18 decimals i.e, 0.2% => 0.002e18 => 2e15\n    uint128 public liquidationFeeRatio;\n\n    /// @notice Liquidation price buffer in basis points to prevent negative margin on liquidation.\n    /// @dev Should include 18 decimals i.e, 0.75% => 0.0075e18 => 75e14\n    uint128 public liquidationBufferRatio;\n\n    /// @notice Upper bound for the liquidation fee.\n    /// @dev Denominated in USD.\n    uint256 public liquidationFeeUpperBound;\n\n    /// @notice Lower bound for the liquidation fee.\n    /// @dev Denominated in USD.\n    uint256 public liquidationFeeLowerBound;\n\n    /// @dev To prevent the implementation contract from being used, we invoke the _disableInitializers\n    /// function in the constructor to automatically lock it when it is deployed.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        IFlatcoinVault _vault,\n        uint128 _liquidationFeeRatio,\n        uint128 _liquidationBufferRatio,\n        uint256 _liquidationFeeLowerBound,\n        uint256 _liquidationFeeUpperBound\n    ) external initializer {\n        __Module_init(FlatcoinModuleKeys._LIQUIDATION_MODULE_KEY, _vault);\n\n        setLiquidationFeeRatio(_liquidationFeeRatio);\n        setLiquidationBufferRatio(_liquidationBufferRatio);\n        setLiquidationFeeBounds(_liquidationFeeLowerBound, _liquidationFeeUpperBound);\n    }\n\n    /////////////////////////////////////////////\n    //         Public Write Functions          //\n    /////////////////////////////////////////////\n\n    function liquidate(\n        uint256 tokenID,\n        bytes[] calldata priceUpdateData\n    ) external payable whenNotPaused updatePythPrice(vault, msg.sender, priceUpdateData) {\n        liquidate(tokenID);\n    }\n\n    /// @notice Function to liquidate a position.\n    /// @dev One could directly call this method instead of `liquidate(uint256, bytes[])` if they don't want to update the Pyth price.\n    /// @param tokenId The token ID of the leverage position.\n    function liquidate(uint256 tokenId) public nonReentrant whenNotPaused liquidationInvariantChecks(vault, tokenId) {\n        FlatcoinStructs.Position memory position = vault.getPosition(tokenId);\n\n        (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n\n        // Settle funding fees accrued till now.\n        vault.settleFundingFees();\n\n        // Check if the position can indeed be liquidated.\n        if (!canLiquidate(tokenId)) revert FlatcoinErrors.CannotLiquidate(tokenId);\n\n        FlatcoinStructs.PositionSummary memory positionSummary = PerpMath._getPositionSummary(\n            position,\n            vault.cumulativeFundingRate(),\n            currentPrice\n        );\n\n        // Check that the total margin deposited by the long traders is not -ve.\n        // To get this amount, we will have to account for the PnL and funding fees accrued.\n        int256 settledMargin = positionSummary.marginAfterSettlement;\n\n        uint256 liquidatorFee;\n\n        // If the settled margin is greater than 0, send a portion (or all) of the margin to the liquidator and LPs.\n        if (settledMargin > 0) {\n            // Calculate the liquidation fees to be sent to the caller.\n            uint256 expectedLiquidationFee = PerpMath._liquidationFee(\n                position.additionalSize,\n                liquidationFeeRatio,\n                liquidationFeeLowerBound,\n                liquidationFeeUpperBound,\n                currentPrice\n            );\n\n            uint256 remainingMargin;\n\n            // Calculate the remaining margin after accounting for liquidation fees.\n            // If the settled margin is less than the liquidation fee, then the liquidator fee is the settled margin.\n            if (uint256(settledMargin) > expectedLiquidationFee) {\n                liquidatorFee = expectedLiquidationFee;\n                remainingMargin = uint256(settledMargin) - expectedLiquidationFee;\n            } else {\n                liquidatorFee = uint256(settledMargin);\n            }\n\n            // Adjust the stable collateral total to account for user's remaining margin.\n            // If the remaining margin is greater than 0, this goes to the LPs.\n            // Note that {`remainingMargin` - `profitLoss`} is the same as {`marginDeposited` + `accruedFunding`}.\n            vault.updateStableCollateralTotal(int256(remainingMargin) - positionSummary.profitLoss);\n\n            // Send the liquidator fee to the caller of the function.\n            // If the liquidation fee is greater than the remaining margin, then send the remaining margin.\n            vault.sendCollateral(msg.sender, liquidatorFee);\n        } else {\n            // If the settled margin is -ve then the LPs have to bear the cost.\n            // Adjust the stable collateral total to account for user's profit/loss and the negative margin.\n            // Note: We are adding `settledMargin` and `profitLoss` instead of subtracting because of their sign (which will be -ve).\n            vault.updateStableCollateralTotal(settledMargin - positionSummary.profitLoss);\n        }\n\n        // Update the global position data.\n        // Note that we are only accounting for `globalMarginDelta`, `marginDeposited` and `userAccruedFunding`.\n        // and not the PnL of the user when altering `marginDepositedTotal`.\n        // This is because the PnL is already accounted for in the `stableCollateralTotal`.\n        // So when the PnL is +ve (the trader made profits), the trader takes the profit along with the margin deposited.\n        // When the PnL is -ve, the trader loses a portion of the margin deposited to the LPs and the rest is again taken along.\n        // In neither case, the PnL is added/subtracted to/from the `marginDepositedTotal`.\n        // Now we are subtracting `userAccruedFunding` in the below function call because:\n        //      `globalMarginDelta` = `userAccruedFunding` + Funding accrued by the rest of the long traders.\n        // And this accrued funding is being taken away from the system (if +ve) or given to LPs (if -ve).\n        // When the `userAccruedFunding` is +ve, the user takes away the funding fees earned.\n        // When it's negative, the user pays the funding fees to the LPs and their margin is reduced.\n        // So the `marginDepositedTotal` is added with `userAccruedFunding` in the below function call as the user has paid for their share\n        // of funding fees.\n        vault.updateGlobalPositionData({\n            price: position.lastPrice,\n            marginDelta: -(int256(position.marginDeposited) + positionSummary.accruedFunding),\n            additionalSizeDelta: -int256(position.additionalSize) // Since position is being closed, additionalSizeDelta should be negative.\n        });\n\n        // Delete position storage\n        vault.deletePosition(tokenId);\n\n        // Cancel any limit orders associated with the position\n        ILimitOrder(vault.moduleAddress(FlatcoinModuleKeys._LIMIT_ORDER_KEY)).cancelExistingLimitOrder(tokenId);\n\n        // If the position token is locked because of an announced order, it should still be liquidatable\n        ILeverageModule leverageModule = ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY));\n        leverageModule.unlock(tokenId);\n        leverageModule.burn(tokenId);\n\n        emit FlatcoinEvents.PositionLiquidated(tokenId, msg.sender, liquidatorFee);\n    }\n\n    /////////////////////////////////////////////\n    //             View Functions              //\n    /////////////////////////////////////////////\n\n    /// @notice Function to calculate liquidation price for a given position.\n    /// @dev Note that liquidation price is influenced by the funding rates and also the current price.\n    /// @param tokenId The token ID of the leverage position.\n    /// @return liqPrice The liquidation price in $ terms.\n    function liquidationPrice(uint256 tokenId) public view returns (uint256 liqPrice) {\n        (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n\n        return liquidationPrice(tokenId, currentPrice);\n    }\n\n    /// @notice Function to calculate liquidation price for a given position at a given price.\n    /// @dev Note that liquidation price is influenced by the funding rates and also the current price.\n    /// @param tokenId The token ID of the leverage position.\n    /// @param price The price at which the liquidation price is to be calculated.\n    /// @return liqPrice The liquidation price in $ terms.\n    function liquidationPrice(uint256 tokenId, uint256 price) public view returns (uint256 liqPrice) {\n        FlatcoinStructs.Position memory position = vault.getPosition(tokenId);\n\n        int256 nextFundingEntry = _accountFundingFees();\n\n        return\n            PerpMath._approxLiquidationPrice({\n                position: position,\n                nextFundingEntry: nextFundingEntry,\n                liquidationFeeRatio: liquidationFeeRatio,\n                liquidationBufferRatio: liquidationBufferRatio,\n                liquidationFeeLowerBound: liquidationFeeLowerBound,\n                liquidationFeeUpperBound: liquidationFeeUpperBound,\n                currentPrice: price\n            });\n    }\n\n    /// @notice Function which determines if a leverage position can be liquidated or not.\n    /// @param tokenId The token ID of the leverage position.\n    /// @return liquidatable True if the position can be liquidated, false otherwise.\n    function canLiquidate(uint256 tokenId) public view returns (bool liquidatable) {\n        // Get the current price from the oracle module.\n        (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n\n        return canLiquidate(tokenId, currentPrice);\n    }\n\n    function canLiquidate(uint256 tokenId, uint256 price) public view returns (bool liquidatable) {\n        FlatcoinStructs.Position memory position = vault.getPosition(tokenId);\n\n        int256 nextFundingEntry = _accountFundingFees();\n\n        return\n            PerpMath._canLiquidate({\n                position: position,\n                liquidationFeeRatio: liquidationFeeRatio,\n                liquidationBufferRatio: liquidationBufferRatio,\n                liquidationFeeLowerBound: liquidationFeeLowerBound,\n                liquidationFeeUpperBound: liquidationFeeUpperBound,\n                nextFundingEntry: nextFundingEntry,\n                currentPrice: price\n            });\n    }\n\n    /// @notice Function to calculate the liquidation fee awarded for a liquidating a given position.\n    /// @param tokenId The token ID of the leverage position.\n    /// @return liquidationFee The liquidation fee in collateral units.\n    function getLiquidationFee(uint256 tokenId) public view returns (uint256 liquidationFee) {\n        // Get the latest price from the oracle module.\n        (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n\n        return\n            PerpMath._liquidationFee(\n                vault.getPosition(tokenId).additionalSize,\n                liquidationFeeRatio,\n                liquidationFeeLowerBound,\n                liquidationFeeUpperBound,\n                currentPrice\n            );\n    }\n\n    /// @notice Function to calculate the liquidation margin for a given additional size amount.\n    /// @param additionalSize The additional size amount for which the liquidation margin is to be calculated.\n    /// @return liquidationMargin The liquidation margin in collateral units.\n    function getLiquidationMargin(uint256 additionalSize) public view returns (uint256 liquidationMargin) {\n        // Get the latest price from the oracle module.\n        (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n\n        return getLiquidationMargin(additionalSize, currentPrice);\n    }\n\n    /// @notice Function to calculate the liquidation margin for a given additional size amount and price.\n    /// @param additionalSize The additional size amount for which the liquidation margin is to be calculated.\n    /// @param price The price at which the liquidation margin is to be calculated.\n    /// @return liquidationMargin The liquidation margin in collateral units.\n    function getLiquidationMargin(\n        uint256 additionalSize,\n        uint256 price\n    ) public view returns (uint256 liquidationMargin) {\n        return\n            PerpMath._liquidationMargin(\n                additionalSize,\n                liquidationFeeRatio,\n                liquidationBufferRatio,\n                liquidationFeeLowerBound,\n                liquidationFeeUpperBound,\n                price\n            );\n    }\n\n    /////////////////////////////////////////////\n    //            Owner Functions              //\n    /////////////////////////////////////////////\n\n    function setLiquidationFeeRatio(uint128 _newLiquidationFeeRatio) public onlyOwner {\n        if (_newLiquidationFeeRatio == 0) revert FlatcoinErrors.ZeroValue(\"newLiquidationFeeRatio\");\n\n        emit FlatcoinEvents.LiquidationFeeRatioModified(liquidationFeeRatio, _newLiquidationFeeRatio);\n\n        liquidationFeeRatio = _newLiquidationFeeRatio;\n    }\n\n    function setLiquidationBufferRatio(uint128 _newLiquidationBufferRatio) public onlyOwner {\n        if (_newLiquidationBufferRatio == 0) revert FlatcoinErrors.ZeroValue(\"newLiquidationBufferRatio\");\n\n        emit FlatcoinEvents.LiquidationBufferRatioModified(liquidationBufferRatio, _newLiquidationBufferRatio);\n\n        liquidationBufferRatio = _newLiquidationBufferRatio;\n    }\n\n    function setLiquidationFeeBounds(\n        uint256 _newLiquidationFeeLowerBound,\n        uint256 _newLiquidationFeeUpperBound\n    ) public onlyOwner {\n        if (_newLiquidationFeeUpperBound == 0 || _newLiquidationFeeLowerBound == 0)\n            revert FlatcoinErrors.ZeroValue(\"newLiquidationFee\");\n        if (_newLiquidationFeeUpperBound < _newLiquidationFeeLowerBound)\n            revert FlatcoinErrors.InvalidBounds(_newLiquidationFeeLowerBound, _newLiquidationFeeUpperBound);\n\n        emit FlatcoinEvents.LiquidationFeeBoundsModified(\n            liquidationFeeLowerBound,\n            liquidationFeeUpperBound,\n            _newLiquidationFeeLowerBound,\n            _newLiquidationFeeUpperBound\n        );\n\n        liquidationFeeLowerBound = _newLiquidationFeeLowerBound;\n        liquidationFeeUpperBound = _newLiquidationFeeUpperBound;\n    }\n\n    /////////////////////////////////////////////\n    //           Internal Functions            //\n    /////////////////////////////////////////////\n\n    /// @dev Accounts for the funding fees based on the market state.\n    /// @return nextFundingEntry The cumulative funding rate based on the latest market state.\n    function _accountFundingFees() internal view returns (int256 nextFundingEntry) {\n        uint256 stableCollateralTotal = vault.stableCollateralTotal();\n        int256 currMarketSkew = int256(vault.getGlobalPositions().sizeOpenedTotal) - int256(stableCollateralTotal);\n\n        int256 currentFundingRate = PerpMath._currentFundingRate({\n            proportionalSkew: PerpMath._proportionalSkew({\n                skew: currMarketSkew,\n                stableCollateralTotal: stableCollateralTotal\n            }),\n            lastRecomputedFundingRate: vault.lastRecomputedFundingRate(),\n            lastRecomputedFundingTimestamp: vault.lastRecomputedFundingTimestamp(),\n            maxFundingVelocity: vault.maxFundingVelocity(),\n            maxVelocitySkew: vault.maxVelocitySkew()\n        });\n\n        int256 unrecordedFunding = PerpMath._unrecordedFunding(\n            currentFundingRate,\n            vault.lastRecomputedFundingRate(),\n            vault.lastRecomputedFundingTimestamp()\n        );\n\n        return PerpMath._nextFundingEntry(unrecordedFunding, vault.cumulativeFundingRate());\n    }\n}"
    },
    {
      "filename": "flatcoin-v1/src/FlatcoinVault.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\nimport {OwnableUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/utils/math/SafeCastUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\nimport {FlatcoinErrors} from \"./libraries/FlatcoinErrors.sol\";\nimport {FlatcoinStructs} from \"./libraries/FlatcoinStructs.sol\";\nimport {PerpMath} from \"./libraries/PerpMath.sol\";\n\nimport {IFlatcoinVault} from \"./interfaces/IFlatcoinVault.sol\";\n\n/// @title FlatcoinVault\n/// @author dHEDGE\n/// @notice Contains state to be reused by different modules of the system.\n/// @dev Holds the stable LP deposits and leverage traders' collateral amounts.\n///      Also stores other related contract address pointers.\ncontract FlatcoinVault is IFlatcoinVault, OwnableUpgradeable {\n    using SafeCastUpgradeable for *;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @notice The collateral token address.\n    IERC20Upgradeable public collateral;\n\n    /// @notice The last market skew recomputation timestamp.\n    uint64 public lastRecomputedFundingTimestamp;\n\n    /// @notice The minimum time that needs to expire between trade announcement and execution.\n    uint64 public minExecutabilityAge;\n\n    /// @notice The maximum amount of time that can expire between trade announcement and execution.\n    uint64 public maxExecutabilityAge;\n\n    /// @notice The last recomputed funding rate.\n    int256 public lastRecomputedFundingRate;\n\n    /// @notice Sum of funding rate over the entire lifetime of the market.\n    int256 public cumulativeFundingRate;\n\n    /// @notice Total collateral deposited by users minting the flatcoin.\n    /// @dev This value is adjusted due to funding fee payments.\n    uint256 public stableCollateralTotal;\n\n    /// @notice The maximum funding velocity used to limit the funding rate fluctuations.\n    /// @dev Funding velocity is used for calculating the current funding rate and acts as\n    ///      a limit on how much the funding rate can change between funding re-computations.\n    ///      The units are %/day (1e18 = 100% / day at max or min skew).\n    uint256 public maxFundingVelocity;\n\n    /// @notice The skew percentage at which the funding rate velocity is at its maximum.\n    /// @dev When absolute pSkew > maxVelocitySkew, then funding velocity = maxFundingVelocity.\n    ///      The units are in % (0.1e18 = 10% skew)\n    uint256 public maxVelocitySkew;\n\n    /// @notice Maximum cap on the total stable LP deposits.\n    uint256 public stableCollateralCap;\n\n    /// @notice The maximum limit of total leverage long size vs stable LP.\n    /// @dev This prevents excessive short skew of stable LPs by capping long trader total open interest.\n    ///      Care needs to be taken when increasing this value as it can lead to the stable LPs being excessively short.\n    uint256 public skewFractionMax;\n\n    /// @notice Holds mapping between module keys and module addresses.\n    ///         A module key is a keccak256 hash of the module name.\n    /// @dev Make sure that a module key is created using the following format:\n    ///      moduleKey = bytes32(<MODULE_NAME>)\n    ///      All the module keys should reside in a single file (see FlatcoinModuleKeys.sol).\n    mapping(bytes32 moduleKey => address moduleAddress) public moduleAddress;\n\n    /// @notice Holds mapping between module addresses and their authorization status.\n    mapping(address moduleAddress => bool authorized) public isAuthorizedModule;\n\n    /// @notice Holds mapping between module keys and their pause status.\n    mapping(bytes32 moduleKey => bool paused) public isModulePaused;\n\n    /// @dev Tracks global totals of leverage trade positions to be able to:\n    ///      - price stable LP value.\n    ///      - calculate the funding rate.\n    ///      - calculate the skew.\n    ///      - calculate funding fees payments.\n    FlatcoinStructs.GlobalPositions internal _globalPositions;\n\n    /// @dev Holds mapping between user addresses and their leverage positions.\n    mapping(uint256 tokenId => FlatcoinStructs.Position userPosition) internal _positions;\n\n    modifier onlyAuthorizedModule() {\n        if (isAuthorizedModule[msg.sender] == false) revert FlatcoinErrors.OnlyAuthorizedModule(msg.sender);\n        _;\n    }\n\n    /// @dev To prevent the implementation contract from being used, we invoke the _disableInitializers\n    /// function in the constructor to automatically lock it when it is deployed.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Function to initialize this contract.\n    /// @param _owner The owner of this contract.\n    /// @param _collateral The collateral token address.\n    /// @param _maxFundingVelocity The maximum funding velocity used to limit the funding rate fluctuations.\n    /// @param _maxVelocitySkew The skew percentage at which the funding rate velocity is at its maximum.\n    /// @param _skewFractionMax The maximum limit of total leverage long size vs stable LP.\n    /// @param _stableCollateralCap The maximum cap on the total stable LP deposits.\n    /// @param _minExecutabilityAge The minimum time that needs to expire between trade announcement and execution.\n    /// @param _maxExecutabilityAge The maximum amount of time that can expire between trade announcement and execution.\n    function initialize(\n        address _owner,\n        IERC20Upgradeable _collateral,\n        uint256 _maxFundingVelocity,\n        uint256 _maxVelocitySkew,\n        uint256 _skewFractionMax,\n        uint256 _stableCollateralCap,\n        uint64 _minExecutabilityAge,\n        uint64 _maxExecutabilityAge\n    ) external initializer {\n        if (address(_collateral) == address(0)) revert FlatcoinErrors.ZeroAddress(\"collateral\");\n\n        __Ownable_init();\n        _transferOwnership(_owner);\n\n        collateral = _collateral;\n\n        setMaxFundingVelocity(_maxFundingVelocity);\n        setMaxVelocitySkew(_maxVelocitySkew);\n        setStableCollateralCap(_stableCollateralCap);\n        setSkewFractionMax(_skewFractionMax);\n        setExecutabilityAge(_minExecutabilityAge, _maxExecutabilityAge);\n    }\n\n    /////////////////////////////////////////////\n    //            Module Functions             //\n    /////////////////////////////////////////////\n\n    /// @notice Collateral can only be withdrawn by the flatcoin contracts (Delayed Orders, Stable or Leverage module).\n    function sendCollateral(address to, uint256 amount) external onlyAuthorizedModule {\n        collateral.safeTransfer(to, amount);\n    }\n\n    /// @notice Function to set the position of a leverage trader.\n    /// @dev This function is only callable by the authorized modules.\n    /// @param _newPosition The new struct encoded position of the leverage trader.\n    /// @param _tokenId The token ID of the leverage trader.\n    function setPosition(\n        FlatcoinStructs.Position calldata _newPosition,\n        uint256 _tokenId\n    ) external onlyAuthorizedModule {\n        _positions[_tokenId] = _newPosition;\n    }\n\n    /// @notice Function to delete the position of a leverage trader.\n    /// @dev This function is only callable by the authorized modules.\n    /// @param _tokenId The token ID of the leverage trader.\n    function deletePosition(uint256 _tokenId) external onlyAuthorizedModule {\n        delete _positions[_tokenId];\n    }\n\n    /// @notice Function to update the stable collateral total.\n    /// @dev This function is only callable by the authorized modules.\n    ///      When `_stableCollateralAdjustment` is negative, it means that the stable collateral total is decreasing.\n    /// @param _stableCollateralAdjustment The adjustment to the stable collateral total.\n    function updateStableCollateralTotal(int256 _stableCollateralAdjustment) external onlyAuthorizedModule {\n        _updateStableCollateralTotal(_stableCollateralAdjustment);\n    }\n\n    /// @notice Function to update the global position data.\n    /// @dev This function is only callable by the authorized modules.\n    /// @param _price The current price of the underlying asset.\n    /// @param _marginDelta The change in the margin deposited total.\n    /// @param _additionalSizeDelta The change in the size opened total.\n    function updateGlobalPositionData(\n        uint256 _price,\n        int256 _marginDelta,\n        int256 _additionalSizeDelta\n    ) external onlyAuthorizedModule {\n        // Get the total profit loss and update the margin deposited total.\n        int256 profitLossTotal = PerpMath._profitLossTotal({globalPosition: _globalPositions, price: _price});\n\n        // Note that technically, even the funding fees should be accounted for when computing the margin deposited total.\n        // However, since the funding fees are settled at the same time as the global position data is updated,\n        // we can ignore the funding fees here.\n        int256 newMarginDepositedTotal = int256(_globalPositions.marginDepositedTotal) + _marginDelta + profitLossTotal;\n\n        // Check that the sum of margin of all the leverage traders is not negative.\n        // Rounding errors shouldn't result in a negative margin deposited total given that\n        // we are rounding down the profit loss of the position.\n        // If anything, after closing the last position in the system, the `marginDepositedTotal` should can be positive.\n        // The margin may be negative if liquidations are not happening in a timely manner.\n        if (newMarginDepositedTotal < 0) {\n            revert FlatcoinErrors.InsufficientGlobalMargin();\n        }\n\n        _globalPositions = FlatcoinStructs.GlobalPositions({\n            marginDepositedTotal: uint256(newMarginDepositedTotal),\n            sizeOpenedTotal: (int256(_globalPositions.sizeOpenedTotal) + _additionalSizeDelta).toUint256(),\n            lastPrice: _price\n        });\n\n        // Profit loss of leverage traders has to be accounted for by adjusting the stable collateral total.\n        // Note that technically, even the funding fees should be accounted for when computing the stable collateral total.\n        // However, since the funding fees are settled at the same time as the global position data is updated,\n        // we can ignore the funding fees here\n        _updateStableCollateralTotal(-profitLossTotal);\n    }\n\n    /////////////////////////////////////////////\n    //            Public Functions             //\n    /////////////////////////////////////////////\n\n    /// @notice Function to settle the funding fees between longs and LPs.\n    /// @dev Anyone can call this function to settle the funding fees.\n    /// @return _fundingFees The funding fees paid to longs.\n    ///         If it's negative, longs pay shorts and vice versa.\n    function settleFundingFees() public returns (int256 _fundingFees) {\n        (int256 fundingChangeSinceRecomputed, int256 unrecordedFunding) = _getUnrecordedFunding();\n\n        // Record the funding rate change and update the cumulative funding rate.\n        cumulativeFundingRate = PerpMath._nextFundingEntry(unrecordedFunding, cumulativeFundingRate);\n\n        // Update the latest funding rate and the latest funding recomputation timestamp.\n        lastRecomputedFundingRate += fundingChangeSinceRecomputed;\n        lastRecomputedFundingTimestamp = (block.timestamp).toUint64();\n\n        // Calculate the funding fees accrued to the longs.\n        // This will be used to adjust the global margin and collateral amounts.\n        _fundingFees = PerpMath._accruedFundingTotalByLongs(_globalPositions, unrecordedFunding);\n\n        // In the worst case scenario that the last position which remained open is underwater,\n        // we set the margin deposited total to 0. We don't want to have a negative margin deposited total.\n        _globalPositions.marginDepositedTotal = (int256(_globalPositions.marginDepositedTotal) > _fundingFees)\n            ? uint256(int256(_globalPositions.marginDepositedTotal) + _fundingFees)\n            : 0;\n\n        _updateStableCollateralTotal(-_fundingFees);\n    }\n\n    /////////////////////////////////////////////\n    //             View Functions              //\n    /////////////////////////////////////////////\n\n    /// @notice Function to get a summary of the vault.\n    /// @dev This can be used by modules to get the current state of the vault.\n    /// @return _vaultSummary The vault summary struct.\n    function getVaultSummary() external view returns (FlatcoinStructs.VaultSummary memory _vaultSummary) {\n        return\n            FlatcoinStructs.VaultSummary({\n                marketSkew: int256(_globalPositions.sizeOpenedTotal) - int256(stableCollateralTotal),\n                cumulativeFundingRate: cumulativeFundingRate,\n                lastRecomputedFundingRate: lastRecomputedFundingRate,\n                lastRecomputedFundingTimestamp: lastRecomputedFundingTimestamp,\n                stableCollateralTotal: stableCollateralTotal,\n                globalPositions: _globalPositions\n            });\n    }\n\n    /// @notice Function to get the current funding rate.\n    /// @dev This can be used by modules to get the current funding rate.\n    /// @return currentFundingRate_ The current funding rate.\n    function getCurrentFundingRate() external view returns (int256 currentFundingRate_) {\n        return\n            PerpMath._currentFundingRate({\n                proportionalSkew: PerpMath._proportionalSkew({\n                    skew: int256(_globalPositions.sizeOpenedTotal) - int256(stableCollateralTotal),\n                    stableCollateralTotal: stableCollateralTotal\n                }),\n                lastRecomputedFundingRate: lastRecomputedFundingRate,\n                lastRecomputedFundingTimestamp: lastRecomputedFundingTimestamp,\n                maxFundingVelocity: maxFundingVelocity,\n                maxVelocitySkew: maxVelocitySkew\n            });\n    }\n\n    /// @notice Function to get the position details of associated with a `_tokenId`.\n    /// @dev This can be used by modules to get the position details of a leverage trader.\n    /// @param _tokenId The token ID of the leverage trader.\n    /// @return _positionDetails The position struct with details.\n    function getPosition(uint256 _tokenId) external view returns (FlatcoinStructs.Position memory _positionDetails) {\n        return _positions[_tokenId];\n    }\n\n    /// @notice Function to get the global position details.\n    /// @dev This can be used by modules to get the global position details.\n    /// @return _globalPositionsDetails The global position struct with details.\n    function getGlobalPositions()\n        external\n        view\n        returns (FlatcoinStructs.GlobalPositions memory _globalPositionsDetails)\n    {\n        return _globalPositions;\n    }\n\n    /// @notice Asserts that the system will not be too skew"
    }
  ]
}