{
  "Title": "M-12: Composing approval with other messages is subject to DoS",
  "Content": "# Issue M-12: Composing approval with other messages is subject to DoS \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/67 \n\n## Found by \nGiuseppeDeLaZara\n## Summary\n\n`TOFT::sendPacket` function allows the caller to specify multiple messages that are executed on the destination chain. \nOn the receiving side the `lzCompose` function in `TOFT` contract can be DoS-ed by front-running the approval message and causing the `lzCompose` to revert. \nAs `lzCompose` is supposed to process several messages, this results in lost fee paid on the sending chain for executing the subsequent messages and any value or gas airdropped to the contract.\n\n## Vulnerability Detail\n[`TOFT::sendPacket`](https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/TapiocaZ/contracts/tOFT/TOFT.sol#L182) allows the caller to specify arbitrary `_composeMsg`.  It can be a single message or multiple composed messages. \n\n```solidity\n>>>>    function sendPacket(LZSendParam calldata _lzSendParam, bytes calldata _composeMsg)\n        public\n        payable\n        whenNotPaused // @audit Pausing is not implemented yet.\n        returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt)\n    {\n        (msgReceipt, oftReceipt) = abi.decode(\n            _executeModule(\n                uint8(ITOFT.Module.TOFTSender),\n>>>>               abi.encodeCall(TapiocaOmnichainSender.sendPacket, (_lzSendParam, _composeMsg)),\n                false\n            ),\n            (MessagingReceipt, OFTReceipt)\n        );\n    }\n\n```\nIf we observe the logic inside the `lzCompose`:\n\n```solidity\n    function _lzCompose(address srcChainSender_, bytes32 _guid, bytes memory oftComposeMsg_) internal {\n        // Decode OFT compose message.\n>>>>        (uint16 msgType_,,, bytes memory tapComposeMsg_, bytes memory nextMsg_) =\n>>>>            TapiocaOmnichainEngineCodec.decodeToeComposeMsg(oftComposeMsg_);\n\n        // Call Permits/approvals if the msg type is a permit/approval.\n        // If the msg type is not a permit/approval, it will call the other receivers.\n        if (msgType_ == MSG_REMOTE_TRANSFER) {\n            _remoteTransferReceiver(srcChainSender_, tapComposeMsg_);\n        } else if (!_extExec(msgType_, tapComposeMsg_)) {\n            // Check if the TOE extender is set and the msg type is valid. If so, call the TOE extender to handle msg.\n            if (\n                address(tapiocaOmnichainReceiveExtender) != address(0)\n                    && tapiocaOmnichainReceiveExtender.isMsgTypeValid(msgType_)\n            ) {\n                bytes memory callData = abi.encodeWithSelector(\n                    ITapiocaOmnichainReceiveExtender.toeComposeReceiver.selector,\n                    msgType_,\n                    srcChainSender_,\n                    tapComposeMsg_\n                );\n                (bool success, bytes memory returnData) =\n                    address(tapiocaOmnichainReceiveExtender).delegatecall(callData);\n                if (!success) {\n                    revert(_getTOEExtenderRevertMsg(returnData));\n                }\n            } else {\n                // If no TOE extender is set or msg type doesn't match extender, try to call the internal receiver.\n                if (!_toeComposeReceiver(msgType_, srcChainSender_, tapComposeMsg_)) {\n                    revert InvalidMsgType(msgType_);\n                }\n            }\n        }\n\n        emit ComposeReceived(msgType_, _guid, tapComposeMsg_);\n>>>>        if (nextMsg_.length > 0) {\n>>>>            _lzCompose(address(this), _guid, nextMsg_);\n        }\n    }\n```\n\nAt the beginning of the function bytes memory `tapComposeMsg_` is the message being processed, while `bytes memory nextMsg_` are all the other messages. `lzCompose` will process all the messages until `nextMsg_` is empty.\n\nA user might want to have his first message to grant approval, e.g. `_extExec` function call, while his second message might execute `BaseTOFTReceiver::_toeComposeReceiver` with `_msgType == MSG_YB_SEND_SGL_BORROW`. \n\nThis is a problem as there is a clear DoS attack vector on granting any approvals. A griever can observe the permit message from the user and front-run the `lzCompose` call and submit the approval on the user's behalf. \n\nAs permits use nonce it can't be replayed, which means if anyone front-runs the permit, the original permit will revert.\nThis means that `lzCompose` always reverts and all the gas and value to process the `BaseTOFTReceiver::_toeComposeReceiver` with `_msgType == MSG_YB_SEND_SGL_BORROW` is lost for the user. \n\nPermit based DoS attack is described in detail in the following article by Trust-Security: https://www.trust-security.xyz/post/permission-denied.\n\n## Impact\nWhen user is granting approvals and wants to execute any other message in the same `lzCompose` call, the attacker can deny the user from executing the other message by front-running the approval message and causing the `lzCompose` to revert.\nThe impact is lost fee paid on the sending chain for executing the subsequent messages and any value or gas airdropped to the contract. This is especially severe when the user wants to withdraw funds to another chain, as he needs to pay for that fee on the sending chain. \n\n## Code Snippet\n- https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/TapiocaZ/contracts/tOFT/TOFT.sol#L182\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n`TOFT::sendPacket` should do extra checks to ensure if the message contains approvals, it should not allow packing several messages.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "TapiocaZ/contracts/tOFT/TOFT.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n//LZ\nimport {IMessagingChannel} from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingChannel.sol\";\nimport {MessagingReceipt, OFTReceipt} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\nimport {OAppReceiver} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppReceiver.sol\";\nimport {Origin} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol\";\n\n// External\nimport {ERC20Permit, ERC20} from \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\n\n// Tapioca\nimport {\n    ITOFT,\n    TOFTInitStruct,\n    TOFTModulesInitStruct,\n    LZSendParam,\n    ERC20PermitStruct,\n    IToftVault\n} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {BaseTapiocaOmnichainEngine} from \"tapioca-periph/tapiocaOmnichainEngine/BaseTapiocaOmnichainEngine.sol\";\nimport {TapiocaOmnichainSender} from \"tapioca-periph/tapiocaOmnichainEngine/TapiocaOmnichainSender.sol\";\nimport {TOFTReceiver} from \"./modules/TOFTReceiver.sol\";\nimport {TOFTSender} from \"./modules/TOFTSender.sol\";\nimport {BaseTOFT} from \"./BaseTOFT.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title TOFT\n * @author TapiocaDAO\n * @notice Tapioca OFT wrapper contract\n * @dev It can be wrapped and unwrapped only on host chain\n */\ncontract TOFT is BaseTOFT, Pausable, ReentrancyGuard, ERC20Permit {\n    error TOFT_OnlyHostChain();\n    error TOFT_NotNative();\n    error TOFT_Failed();\n\n    modifier onlyHostChain() {\n        if (_getChainId() != hostEid) revert TOFT_OnlyHostChain();\n        _;\n    }\n\n    constructor(TOFTInitStruct memory _tOFTData, TOFTModulesInitStruct memory _modulesData)\n        BaseTOFT(_tOFTData)\n        ERC20Permit(_tOFTData.name)\n    {\n        // Set TOFT execution modules\n        if (_modulesData.tOFTSenderModule == address(0)) revert TOFT_NotValid();\n        if (_modulesData.tOFTReceiverModule == address(0)) {\n            revert TOFT_NotValid();\n        }\n        if (_modulesData.marketReceiverModule == address(0)) {\n            revert TOFT_NotValid();\n        }\n        if (_modulesData.optionsReceiverModule == address(0)) {\n            revert TOFT_NotValid();\n        }\n        if (_modulesData.genericReceiverModule == address(0)) {\n            revert TOFT_NotValid();\n        }\n\n        _setModule(uint8(ITOFT.Module.TOFTSender), _modulesData.tOFTSenderModule);\n        _setModule(uint8(ITOFT.Module.TOFTReceiver), _modulesData.tOFTReceiverModule);\n        _setModule(uint8(ITOFT.Module.TOFTMarketReceiver), _modulesData.marketReceiverModule);\n        _setModule(uint8(ITOFT.Module.TOFTOptionsReceiver), _modulesData.optionsReceiverModule);\n        _setModule(uint8(ITOFT.Module.TOFTGenericReceiver), _modulesData.genericReceiverModule);\n\n        vault = IToftVault(_tOFTData.vault);\n        vault.claimOwnership();\n\n        if (address(vault._token()) != erc20) revert TOFT_VaultWrongERC20();\n    }\n\n    /**\n     * @dev Fallback function should handle calls made by endpoint, which should go to the receiver module.\n     */\n    fallback() external payable {\n        /// @dev Call the receiver module on fallback, assume it's gonna be called by endpoint.\n        _executeModule(uint8(ITOFT.Module.TOFTReceiver), msg.data, false);\n    }\n\n    receive() external payable {}\n\n    function transferFrom(address from, address to, uint256 value)\n        public\n        override(BaseTapiocaOmnichainEngine, ERC20)\n        returns (bool)\n    {\n        return BaseTapiocaOmnichainEngine.transferFrom(from, to, value);\n    }\n\n    /**\n     * @dev Slightly modified version of the OFT _lzReceive() operation.\n     * The composed message is sent to `address(this)` instead of `toAddress`.\n     * @dev Internal function to handle the receive on the LayerZero endpoint.\n     * @param _origin The origin information.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address from the src chain.\n     *  - nonce: The nonce of the LayerZero message.\n     * @param _guid The unique identifier for the received LayerZero message.\n     * @param _message The encoded message.\n     * @dev _executor The address of the executor.\n     * @dev _extraData Additional data.\n     */\n    function lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor, // @dev unused in the default implementation.\n        bytes calldata _extraData // @dev unused in the default implementation.\n    ) public payable override {\n        // Call the internal OApp implementation of lzReceive.\n        _executeModule(\n            uint8(ITOFT.Module.TOFTReceiver),\n            abi.encodeWithSelector(OAppReceiver.lzReceive.selector, _origin, _guid, _message, _executor, _extraData),\n            false\n        );\n    }\n\n    /**\n     * @notice Execute a call to a module.\n     * @dev Example on how `_data` should be encoded:\n     *      - abi.encodeCall(IERC20.transfer, (to, amount));\n     * @dev Use abi.encodeCall to encode the function call and its parameters with type safety.\n     *\n     * @param _module The module to execute.\n     * @param _data The data to execute. Should be ABI encoded with the selector.\n     * @param _forwardRevert If true, forward the revert message from the module.\n     *\n     * @return returnData The return data from the module execution, if any.\n     */\n    function executeModule(ITOFT.Module _module, bytes memory _data, bool _forwardRevert)\n        external\n        payable\n        whenNotPaused\n        returns (bytes memory returnData)\n    {\n        return _executeModule(uint8(_module), _data, _forwardRevert);\n    }\n\n    /**\n     * @dev Slightly modified version of the OFT send() operation. Includes a `_msgType` parameter.\n     * The `_buildMsgAndOptionsByType()` appends the packet type to the message.\n     * @dev Executes the send operation.\n     * @param _lzSendParam The parameters for the send operation.\n     *      - _sendParam: The parameters for the send operation.\n     *          - dstEid::uint32: Destination endpoint ID.\n     *          - to::bytes32: Recipient address.\n     *          - amountToSendLD::uint256: Amount to send in local decimals.\n     *          - minAmountToCreditLD::uint256: Minimum amount to credit in local decimals.\n     *      - _fee: The calculated fee for the send() operation.\n     *          - nativeFee::uint256: The native fee.\n     *          - lzTokenFee::uint256: The lzToken fee.\n     *      - _extraOptions::bytes: Additional options for the send() operation.\n     *      - refundAddress::address: The address to refund the native fee to.\n     * @param _composeMsg The composed message for the send() operation. Is a combination of 1 or more TAP specific messages.\n     *\n     * @return msgReceipt The receipt for the send operation.\n     *      - guid::bytes32: The unique identifier for the sent message.\n     *      - nonce::uint64: The nonce of the sent message.\n     *      - fee: The LayerZero fee incurred for the message.\n     *          - nativeFee::uint256: The native fee.\n     *          - lzTokenFee::uint256: The lzToken fee.\n     * @return oftReceipt The OFT receipt information.\n     *      - amountDebitLD::uint256: Amount of tokens ACTUALLY debited in local decimals.\n     *      - amountCreditLD::uint256: Amount of tokens to be credited on the remote side.\n     */\n    function sendPacket(LZSendParam calldata _lzSendParam, bytes calldata _composeMsg)\n        public\n        payable\n        whenNotPaused\n        returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt)\n    {\n        (msgReceipt, oftReceipt) = abi.decode(\n            _executeModule(\n                uint8(ITOFT.Module.TOFTSender),\n                abi.encodeCall(TapiocaOmnichainSender.sendPacket, (_lzSendParam, _composeMsg)),\n                false\n            ),\n            (MessagingReceipt, OFTReceipt)\n        );\n    }\n\n    /// =====================\n    /// View\n    /// =====================\n\n    /**\n     * @notice returns token's decimals\n     */\n    function decimals() public pure override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev Returns the hash of the struct used by the permit function.\n     * @param _permitData Struct containing permit data.\n     */\n    function getTypedDataHash(ERC20PermitStruct calldata _permitData) public view returns (bytes32) {\n        bytes32 permitTypeHash_ =\n            keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n        bytes32 structHash_ = keccak256(\n            abi.encode(\n                permitTypeHash_,\n                _permitData.owner,\n                _permitData.spender,\n                _permitData.value,\n                _permitData.nonce,\n                _permitData.deadline\n            )\n        );\n        return _hashTypedDataV4(structHash_);\n    }\n\n    /// =====================\n    /// External\n    /// =====================\n    /**\n     * @notice Wrap an ERC20.\n     * @dev Minted amount is 1:1 with `_amount`\n     * @param _fromAddress The address to wrap from.\n     * @param _toAddress The address to wrap the ERC20 to.\n     * @param _amount The amount of ERC20 to wrap.\n     *\n     * @return minted The tOFT minted amount.\n     */\n    function wrap(address _fromAddress, address _toAddress, uint256 _amount)\n        external\n        payable\n        whenNotPaused\n        nonReentrant\n        onlyHostChain\n        returns (uint256 minted)\n    {\n        if (erc20 == address(0)) {\n            _wrapNative(_toAddress, _amount, 0);\n        } else {\n            if (msg.value > 0) revert TOFT_NotNative();\n            _wrap(_fromAddress, _toAddress, _amount, 0);\n        }\n\n        return _amount; //no fee for TOFT\n    }\n\n    /// =====================\n    /// Owner\n    /// =====================\n    /**\n     * @notice rescues unused ETH from the contract\n     * @param amount the amount to rescue\n     * @param to the recipient\n     */\n    function rescueEth(uint256 amount, address to) external onlyOwner {\n        (bool success,) = to.call{value: amount}(\"\");\n        if (!success) revert TOFT_Failed();\n    }\n\n    /// =====================\n    /// Private\n    /// =====================\n\n    /**\n     * @notice Unwrap an ERC20/Native with a 1:1 ratio. Called only on host chain.\n     * @param _toAddress The address to wrap the ERC20 to.\n     * @param _amount The amount of tokens to unwrap.\n     */\n    function unwrap(address _toAddress, uint256 _amount) external onlyHostChain nonReentrant {\n        _unwrap(_toAddress, _amount);\n    }\n\n    /**\n     * @notice Return the current chain EID.\n     */\n    function _getChainId() internal view override returns (uint32) {\n        return IMessagingChannel(endpoint).eid();\n    }\n}"
    },
    {
      "filename": "TapiocaZ/contracts/tOFT/TOFT.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n//LZ\nimport {IMessagingChannel} from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingChannel.sol\";\nimport {MessagingReceipt, OFTReceipt} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\nimport {OAppReceiver} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppReceiver.sol\";\nimport {Origin} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol\";\n\n// External\nimport {ERC20Permit, ERC20} from \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\n\n// Tapioca\nimport {\n    ITOFT,\n    TOFTInitStruct,\n    TOFTModulesInitStruct,\n    LZSendParam,\n    ERC20PermitStruct,\n    IToftVault\n} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {BaseTapiocaOmnichainEngine} from \"tapioca-periph/tapiocaOmnichainEngine/BaseTapiocaOmnichainEngine.sol\";\nimport {TapiocaOmnichainSender} from \"tapioca-periph/tapiocaOmnichainEngine/TapiocaOmnichainSender.sol\";\nimport {TOFTReceiver} from \"./modules/TOFTReceiver.sol\";\nimport {TOFTSender} from \"./modules/TOFTSender.sol\";\nimport {BaseTOFT} from \"./BaseTOFT.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title TOFT\n * @author TapiocaDAO\n * @notice Tapioca OFT wrapper contract\n * @dev It can be wrapped and unwrapped only on host chain\n */\ncontract TOFT is BaseTOFT, Pausable, ReentrancyGuard, ERC20Permit {\n    error TOFT_OnlyHostChain();\n    error TOFT_NotNative();\n    error TOFT_Failed();\n\n    modifier onlyHostChain() {\n        if (_getChainId() != hostEid) revert TOFT_OnlyHostChain();\n        _;\n    }\n\n    constructor(TOFTInitStruct memory _tOFTData, TOFTModulesInitStruct memory _modulesData)\n        BaseTOFT(_tOFTData)\n        ERC20Permit(_tOFTData.name)\n    {\n        // Set TOFT execution modules\n        if (_modulesData.tOFTSenderModule == address(0)) revert TOFT_NotValid();\n        if (_modulesData.tOFTReceiverModule == address(0)) {\n            revert TOFT_NotValid();\n        }\n        if (_modulesData.marketReceiverModule == address(0)) {\n            revert TOFT_NotValid();\n        }\n        if (_modulesData.optionsReceiverModule == address(0)) {\n            revert TOFT_NotValid();\n        }\n        if (_modulesData.genericReceiverModule == address(0)) {\n            revert TOFT_NotValid();\n        }\n\n        _setModule(uint8(ITOFT.Module.TOFTSender), _modulesData.tOFTSenderModule);\n        _setModule(uint8(ITOFT.Module.TOFTReceiver), _modulesData.tOFTReceiverModule);\n        _setModule(uint8(ITOFT.Module.TOFTMarketReceiver), _modulesData.marketReceiverModule);\n        _setModule(uint8(ITOFT.Module.TOFTOptionsReceiver), _modulesData.optionsReceiverModule);\n        _setModule(uint8(ITOFT.Module.TOFTGenericReceiver), _modulesData.genericReceiverModule);\n\n        vault = IToftVault(_tOFTData.vault);\n        vault.claimOwnership();\n\n        if (address(vault._token()) != erc20) revert TOFT_VaultWrongERC20();\n    }\n\n    /**\n     * @dev Fallback function should handle calls made by endpoint, which should go to the receiver module.\n     */\n    fallback() external payable {\n        /// @dev Call the receiver module on fallback, assume it's gonna be called by endpoint.\n        _executeModule(uint8(ITOFT.Module.TOFTReceiver), msg.data, false);\n    }\n\n    receive() external payable {}\n\n    function transferFrom(address from, address to, uint256 value)\n        public\n        override(BaseTapiocaOmnichainEngine, ERC20)\n        returns (bool)\n    {\n        return BaseTapiocaOmnichainEngine.transferFrom(from, to, value);\n    }\n\n    /**\n     * @dev Slightly modified version of the OFT _lzReceive() operation.\n     * The composed message is sent to `address(this)` instead of `toAddress`.\n     * @dev Internal function to handle the receive on the LayerZero endpoint.\n     * @param _origin The origin information.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address from the src chain.\n     *  - nonce: The nonce of the LayerZero message.\n     * @param _guid The unique identifier for the received LayerZero message.\n     * @param _message The encoded message.\n     * @dev _executor The address of the executor.\n     * @dev _extraData Additional data.\n     */\n    function lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor, // @dev unused in the default implementation.\n        bytes calldata _extraData // @dev unused in the default implementation.\n    ) public payable override {\n        // Call the internal OApp implementation of lzReceive.\n        _executeModule(\n            uint8(ITOFT.Module.TOFTReceiver),\n            abi.encodeWithSelector(OAppReceiver.lzReceive.selector, _origin, _guid, _message, _executor, _extraData),\n            false\n        );\n    }\n\n    /**\n     * @notice Execute a call to a module.\n     * @dev Example on how `_data` should be encoded:\n     *      - abi.encodeCall(IERC20.transfer, (to, amount));\n     * @dev Use abi.encodeCall to encode the function call and its parameters with type safety.\n     *\n     * @param _module The module to execute.\n     * @param _data The data to execute. Should be ABI encoded with the selector.\n     * @param _forwardRevert If true, forward the revert message from the module.\n     *\n     * @return returnData The return data from the module execution, if any.\n     */\n    function executeModule(ITOFT.Module _module, bytes memory _data, bool _forwardRevert)\n        external\n        payable\n        whenNotPaused\n        returns (bytes memory returnData)\n    {\n        return _executeModule(uint8(_module), _data, _forwardRevert);\n    }\n\n    /**\n     * @dev Slightly modified version of the OFT send() operation. Includes a `_msgType` parameter.\n     * The `_buildMsgAndOptionsByType()` appends the packet type to the message.\n     * @dev Executes the send operation.\n     * @param _lzSendParam The parameters for the send operation.\n     *      - _sendParam: The parameters for the send operation.\n     *          - dstEid::uint32: Destination endpoint ID.\n     *          - to::bytes32: Recipient address.\n     *          - amountToSendLD::uint256: Amount to send in local decimals.\n     *          - minAmountToCreditLD::uint256: Minimum amount to credit in local decimals.\n     *      - _fee: The calculated fee for the send() operation.\n     *          - nativeFee::uint256: The native fee.\n     *          - lzTokenFee::uint256: The lzToken fee.\n     *      - _extraOptions::bytes: Additional options for the send() operation.\n     *      - refundAddress::address: The address to refund the native fee to.\n     * @param _composeMsg The composed message for the send() operation. Is a combination of 1 or more TAP specific messages.\n     *\n     * @return msgReceipt The receipt for the send operation.\n     *      - guid::bytes32: The unique identifier for the sent message.\n     *      - nonce::uint64: The nonce of the sent message.\n     *      - fee: The LayerZero fee incurred for the message.\n     *          - nativeFee::uint256: The native fee.\n     *          - lzTokenFee::uint256: The lzToken fee.\n     * @return oftReceipt The OFT receipt information.\n     *      - amountDebitLD::uint256: Amount of tokens ACTUALLY debited in local decimals.\n     *      - amountCreditLD::uint256: Amount of tokens to be credited on the remote side.\n     */\n    function sendPacket(LZSendParam calldata _lzSendParam, bytes calldata _composeMsg)\n        public\n        payable\n        whenNotPaused\n        returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt)\n    {\n        (msgReceipt, oftReceipt) = abi.decode(\n            _executeModule(\n                uint8(ITOFT.Module.TOFTSender),\n                abi.encodeCall(TapiocaOmnichainSender.sendPacket, (_lzSendParam, _composeMsg)),\n                false\n            ),\n            (MessagingReceipt, OFTReceipt)\n        );\n    }\n\n    /// =====================\n    /// View\n    /// =====================\n\n    /**\n     * @notice returns token's decimals\n     */\n    function decimals() public pure override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev Returns the hash of the struct used by the permit function.\n     * @param _permitData Struct containing permit data.\n     */\n    function getTypedDataHash(ERC20PermitStruct calldata _permitData) public view returns (bytes32) {\n        bytes32 permitTypeHash_ =\n            keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n        bytes32 structHash_ = keccak256(\n            abi.encode(\n                permitTypeHash_,\n                _permitData.owner,\n                _permitData.spender,\n                _permitData.value,\n                _permitData.nonce,\n                _permitData.deadline\n            )\n        );\n        return _hashTypedDataV4(structHash_);\n    }\n\n    /// =====================\n    /// External\n    /// =====================\n    /**\n     * @notice Wrap an ERC20.\n     * @dev Minted amount is 1:1 with `_amount`\n     * @param _fromAddress The address to wrap from.\n     * @param _toAddress The address to wrap the ERC20 to.\n     * @param _amount The amount of ERC20 to wrap.\n     *\n     * @return minted The tOFT minted amount.\n     */\n    function wrap(address _fromAddress, address _toAddress, uint256 _amount)\n        external\n        payable\n        whenNotPaused\n        nonReentrant\n        onlyHostChain\n        returns (uint256 minted)\n    {\n        if (erc20 == address(0)) {\n            _wrapNative(_toAddress, _amount, 0);\n        } else {\n            if (msg.value > 0) revert TOFT_NotNative();\n            _wrap(_fromAddress, _toAddress, _amount, 0);\n        }\n\n        return _amount; //no fee for TOFT\n    }\n\n    /// =====================\n    /// Owner\n    /// =====================\n    /**\n     * @notice rescues unused ETH from the contract\n     * @param amount the amount to rescue\n     * @param to the recipient\n     */\n    function rescueEth(uint256 amount, address to) external onlyOwner {\n        (bool success,) = to.call{value: amount}(\"\");\n        if (!success) revert TOFT_Failed();\n    }\n\n    /// =====================\n    /// Private\n    /// =====================\n\n    /**\n     * @notice Unwrap an ERC20/Native with a 1:1 ratio. Called only on host chain.\n     * @param _toAddress The address to wrap the ERC20 to.\n     * @param _amount The amount of tokens to unwrap.\n     */\n    function unwrap(address _toAddress, uint256 _amount) external onlyHostChain nonReentrant {\n        _unwrap(_toAddress, _amount);\n    }\n\n    /**\n     * @notice Return the current chain EID.\n     */\n    function _getChainId() internal view override returns (uint32) {\n        return IMessagingChannel(endpoint).eid();\n    }\n}"
    }
  ]
}