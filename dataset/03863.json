{
  "Title": "Potential collateralization imbalance",
  "Content": "##### Description\nIn function `balance` defined at https://github.com/bondappetit/bondappetit-protocol/blob/88680691fe8d872c5fc26e9500d19cf7caaa9861/contracts/depositary/StableTokenDepositaryBalanceView.sol#L81 contract aggregates balances through different tokens, so function return sum of collateral assets. However, as we known price of some stable coins can be changed(especially algorithmic stable coins), so we can't simply calculate sum of tokens to get real assets value.\n\n##### Recommendation\nWe recommend to use oracles to fetch real assets price\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/depositary/StableTokenDepositaryBalanceView.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"./IDepositaryBalanceView.sol\";\n\ncontract StableTokenDepositaryBalanceView is Ownable, IDepositaryBalanceView {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice Balance decimals.\n    uint256 public override decimals = 18;\n\n    /// @dev Allowed tokens.\n    EnumerableSet.AddressSet private tokens;\n\n    /// @notice An event emitted when token allowed.\n    event TokenAllowed(address token);\n\n    /// @notice An event emitted when token denied.\n    event TokenDenied(address token);\n\n    /**\n     * @notice Allow token.\n     * @param token Allowed token.\n     */\n    function allowToken(address token) external onlyOwner {\n        require(!tokens.contains(token), \"TokenDepositary::allowToken: token already allowed\");\n\n        uint256 tokenDecimals = ERC20(token).decimals();\n        require(tokenDecimals <= decimals, \"TokenDepositary::allowToken: invalid token decimals\");\n\n        tokens.add(token);\n        emit TokenAllowed(token);\n    }\n\n    /**\n     * @notice Deny token.\n     * @param token Denied token.\n     */\n    function denyToken(address token) external onlyOwner {\n        require(tokens.contains(token), \"TokenDepositary::denyToken: token already denied\");\n\n        tokens.remove(token);\n        emit TokenDenied(token);\n    }\n\n    /**\n     * @notice Transfer target token to recipient.\n     * @param token Target token.\n     * @param recipient Recipient.\n     * @param amount Transfer amount.\n     */\n    function transfer(\n        address token,\n        address recipient,\n        uint256 amount\n    ) external onlyOwner {\n        ERC20(token).safeTransfer(recipient, amount);\n    }\n\n    /**\n     * @return Allowed tokens list.\n     */\n    function allowedTokens() external view returns (address[] memory) {\n        address[] memory result = new address[](tokens.length());\n\n        for(uint256 i = 0; i < tokens.length(); i++) {\n            result[i] = tokens.at(i);\n        }\n\n        return result;\n    }\n\n    function balance() external override view returns (uint256) {\n        uint256 result;\n\n        for(uint256 i = 0; i < tokens.length(); i++) {\n            ERC20 token = ERC20(tokens.at(i));\n            uint256 tokenBalance = token.balanceOf(address(this));\n            uint256 tokenDecimals = token.decimals();\n\n            result = result.add(tokenBalance.mul(10**(decimals.sub(tokenDecimals))));\n        }\n\n        return result;\n    }\n}"
    }
  ]
}