{
  "Title": "A user can lose funds in `sdlPoolSecondary` if tries to add more sdl tokens to a lock that has been queued to be completely withdrawn",
  "Content": "# A user can lose funds in `sdlPoolSecondary` if tries to add more sdl tokens to a lock that has been queued to be completely withdrawn\n\n### Severity\nHigh Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/sdlPool/SDLPoolSecondary.sol#L144\">https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/sdlPool/SDLPoolSecondary.sol#L144</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/sdlPool/SDLPoolSecondary.sol#L214-L239\">https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/sdlPool/SDLPoolSecondary.sol#L214-L239</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/sdlPool/SDLPoolSecondary.sol#L451-L510\">https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/sdlPool/SDLPoolSecondary.sol#L451-L510</a>\n\n\n## Summary\nIn a secondary chain, if a user adds more sdl amount into a lock that he has queued to withdraw all the amount in the same index batch, he will lose the extra amount he deposited\n\n## Vulnerability Details\nThe process to withdraw all the funds from a lock in a primary chain is just by calling withdraw with all the base amount of the lock. At this point the user will get immediately his funds back and the lock will be deleted, hence the owner will be zero address.\n\nHowever, in a secondary chain, a user has to queue a withdraw of all the funds and wait for the keeper to send the update to the primary chain to execute the updates and then receive his sdl token back. In this period of time when the keeper does not send the update to the primary chain, if a user queues a withdraw of all the lock base amount, he will still own the lock because the withdraw has not been executed, just queued. So the user can still do whatever modification in his lock, for example, increase his lock base amount by calling `transferAndCall()` in the `sdlToken` passing the address of the `sdlSecondaryPool` as argument.\n\nIf this happens, when the keeper send the update to the primary chain and the user executes the updates for his lockId, he will lose this extra amount he deposited because it will execute the updates in order, and it will start with the withdraw of all the funds, will delete the ownership (make the zero address as the owner), and then increase the base amount of the lock that now owns the zero address.\n\nAnd basically the lockId will be owned by the zero address with base amount as the extra sdl tokens that the user sent.\n\n#### Proof of Concept\nIt is written inside `sdl-pool-secondary.test.ts` because it uses its setup\n\n```\n  it('PoC user will lose extra deposited tokens', async () => {\n\n    let user = accounts[1]\n    let initialUserSDLBalance = await sdlToken.balanceOf(user);\n\n    // User creates a lock depositing some amount\n    await sdlToken\n      .connect(signers[1])\n      .transferAndCall(\n        sdlPool.address,\n        toEther(100),\n        ethers.utils.defaultAbiCoder.encode(['uint256', 'uint64'], [0, 0])\n      )\n\n    await sdlPool.handleOutgoingUpdate()\n    await sdlPool.handleIncomingUpdate(1)\n    await sdlPool.connect(signers[1]).executeQueuedOperations([])\n\n    assert.equal(await sdlPool.ownerOf(1), user)\n    \n    // User queues a withdraw of all the amount from the lock\n    await sdlPool.connect(signers[1]).withdraw(1, toEther(100))\n\n    // User wants to deposit more tokens to the lock without the withdraw being updated and still being in the queue\n    await sdlToken\n      .connect(signers[1])\n      .transferAndCall(\n        sdlPool.address,\n        toEther(1000),\n        ethers.utils.defaultAbiCoder.encode(['uint256', 'uint64'], [1, 0])\n      )\n\n    await sdlPool.handleOutgoingUpdate()\n    await sdlPool.handleIncomingUpdate(2)\n    // When executing the updates, zero address will be the owner of his lock\n    // and the amount he diposited the last time will be lost\n    await sdlPool.connect(signers[1]).executeQueuedOperations([1])\n\n    let finalUserSDLBalance = await sdlToken.balanceOf(user);\n    let sdlLost = initialUserSDLBalance.sub(finalUserSDLBalance)\n\n    console.log(\"The user has lost\", sdlLost.toString(), \"sdl tokens\")\n\n    // This staticall should revert because now the lock owner is the zero address\n    await expect(sdlPool.ownerOf(1)).to.be.revertedWith('InvalidLockId()')\n  })\n```\n\nOutput:\n```\n  SDLPoolSecondary\nThe user has lost 1000000000000000000000 sdl tokens\n    âœ” PoC user is not able to execute his lock updates (159ms)\n\n\n  1 passing (3s)\n```\n\n## Impact\nHigh, user will lose funds\n\n## Tools Used\nManual review\n\n## Recommendations\nWhen trying to do any action on a lock in a secondary pool, check if the last update queued has not 0 as the base amount. Because if it is the case, that would mean that the user queued a withdraw of all funds and he will lose ownership of the lock at the next keeper update.\n\n```diff\n     function _queueLockUpdate(\n         address _owner,\n         uint256 _lockId,\n         uint256 _amount,\n         uint64 _lockingDuration\n     ) internal onlyLockOwner(_lockId, _owner) {\n         Lock memory lock = _getQueuedLockState(_lockId);\n+        if(lock.amount == 0) revert();\n         LockUpdate memory lockUpdate = LockUpdate(updateBatchIndex, _updateLock(lock, _amount, _lockingDuration));\n         queuedLockUpdates[_lockId].push(lockUpdate);\n         queuedRESDLSupplyChange +=\n             int256(lockUpdate.lock.amount + lockUpdate.lock.boostAmount) -\n             int256(lock.amount + lock.boostAmount);\n         if (updateNeeded == 0) updateNeeded = 1;\n\n         emit QueueUpdateLock(_owner, _lockId, lockUpdate.lock.amount, lockUpdate.lock.boostAmount, lockUpdate.lock.duration);\n     }\n```",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clqf7mgla0001yeyfah59c674",
  "Code": [
    {
      "filename": "contracts/core/sdlPool/SDLPoolSecondary.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\n\nimport \"./base/SDLPool.sol\";\n\n/**\n * @title SDL Pool Secondary\n * @notice Allows users to stake/lock SDL tokens and receive a percentage of the protocol's earned rewards\n * @dev deployed on all supported chains besides the primary chain\n */\ncontract SDLPoolSecondary is SDLPool {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct NewLockPointer {\n        uint128 updateBatchIndex;\n        uint128 index;\n    }\n    struct LockUpdate {\n        uint128 updateBatchIndex;\n        Lock lock;\n    }\n\n    mapping(uint256 => LockUpdate[]) internal queuedLockUpdates;\n\n    uint256 public queuedNewLockLimit;\n    uint256[] internal currentMintLockIdByBatch;\n    Lock[][] internal queuedNewLocks;\n    mapping(address => NewLockPointer[]) internal newLocksByOwner;\n\n    uint128 public updateBatchIndex;\n    uint64 public updateInProgress;\n    uint64 internal updateNeeded;\n    int256 public queuedRESDLSupplyChange;\n\n    event QueueInitiateUnlock(address indexed owner, uint256 indexed lockId, uint64 expiry);\n    event QueueWithdraw(address indexed owner, uint256 indexed lockId, uint256 amount);\n    event QueueCreateLock(address indexed owner, uint256 amount, uint256 boostAmount, uint64 lockingDuration);\n    event QueueUpdateLock(\n        address indexed owner,\n        uint256 indexed lockId,\n        uint256 amount,\n        uint256 boostAmount,\n        uint64 lockingDuration\n    );\n    event OutgoingUpdate(uint128 indexed batchIndex, uint256 numNewQueuedLocks, int256 reSDLSupplyChange);\n    event IncomingUpdate(uint128 indexed batchIndex, uint256 mintStartIndex);\n\n    error CannotTransferWithQueuedUpdates();\n    error UpdateInProgress();\n    error NoUpdateInProgress();\n    error TooManyQueuedLocks();\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice initializes contract\n     * @param _name name of the staking derivative token\n     * @param _symbol symbol of the staking derivative token\n     * @param _sdlToken address of the SDL token\n     * @param _boostController address of the boost controller\n     * @param _queuedNewLockLimit max amount of queued new locks an account can have\n     **/\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        address _sdlToken,\n        address _boostController,\n        uint256 _queuedNewLockLimit\n    ) public initializer {\n        __SDLPoolBase_init(_name, _symbol, _sdlToken, _boostController);\n        updateBatchIndex = 1;\n        currentMintLockIdByBatch.push(0);\n        queuedNewLocks.push();\n        queuedNewLocks.push();\n        queuedNewLockLimit = _queuedNewLockLimit;\n    }\n\n    /**\n     * @notice returns a list of queued new locks for an owner\n     * @param _owner owner of locks\n     * @return list of queued locks and corresponding batch indexes\n     **/\n    function getQueuedNewLocksByOwner(address _owner) external view returns (Lock[] memory, uint256[] memory) {\n        uint256 numNewLocks = newLocksByOwner[_owner].length;\n        Lock[] memory newLocks = new Lock[](numNewLocks);\n        uint256[] memory batchIndexes = new uint256[](numNewLocks);\n\n        for (uint256 i = 0; i < numNewLocks; ++i) {\n            NewLockPointer memory pointer = newLocksByOwner[_owner][i];\n            newLocks[i] = queuedNewLocks[pointer.updateBatchIndex][pointer.index];\n            batchIndexes[i] = pointer.updateBatchIndex;\n        }\n\n        return (newLocks, batchIndexes);\n    }\n\n    /**\n     * @notice returns queued lock updates for a list of lock ids\n     * @param _lockIds list of lock ids\n     * @return list of queued lock updates corresponding to each lock id\n     **/\n    function getQueuedLockUpdates(uint256[] calldata _lockIds) external view returns (LockUpdate[][] memory) {\n        LockUpdate[][] memory updates = new LockUpdate[][](_lockIds.length);\n\n        for (uint256 i = 0; i < _lockIds.length; ++i) {\n            updates[i] = queuedLockUpdates[_lockIds[i]];\n        }\n\n        return updates;\n    }\n\n    /**\n     * @notice ERC677 implementation to stake/lock SDL tokens or distribute rewards\n     * @dev operations will be queued until the next update at which point the user can execute (excludes reward distribution)\n     * @dev\n     * - will update/create a lock if the token transferred is SDL or will distribute rewards otherwise\n     *\n     * For Non-SDL:\n     * - reverts if token is unsupported\n     *\n     * For SDL:\n     * - set lockId to 0 to create a new lock or set lockId to > 0 to stake more into an existing lock\n     * - set lockingDuration to 0 to stake without locking or set lockingDuration to > 0 to lock for an amount\n     *   time in seconds\n     * @param _sender of the stake\n     * @param _value of the token transfer\n     * @param _calldata encoded lockId (uint256) and lockingDuration (uint64)\n     **/\n    function onTokenTransfer(\n        address _sender,\n        uint256 _value,\n        bytes calldata _calldata\n    ) external override {\n        if (msg.sender != address(sdlToken) && !isTokenSupported(msg.sender)) revert UnauthorizedToken();\n\n        if (_value == 0) revert InvalidValue();\n\n        if (msg.sender == address(sdlToken)) {\n            (uint256 lockId, uint64 lockingDuration) = abi.decode(_calldata, (uint256, uint64));\n            if (lockId != 0) {\n                _queueLockUpdate(_sender, lockId, _value, lockingDuration);\n            } else {\n                _queueNewLock(_sender, _value, lockingDuration);\n            }\n        } else {\n            distributeToken(msg.sender);\n        }\n    }\n\n    /**\n     * @notice extends the locking duration of a lock\n     * @dev operation will be queued until the next update at which point the user can execute\n     * @dev\n     * - reverts if `_lockId` is invalid or sender is not owner of lock\n     * - reverts if `_lockingDuration` is less than current locking duration of lock\n     * - reverts if `_lockingDuration` is 0 or exceeds the maximum\n     * @param _lockId id of lock\n     * @param _lockingDuration new locking duration to set\n     **/\n    function extendLockDuration(uint256 _lockId, uint64 _lockingDuration) external {\n        if (_lockingDuration == 0) revert InvalidLockingDuration();\n        _queueLockUpdate(msg.sender, _lockId, 0, _lockingDuration);\n    }\n\n    /**\n     * @notice initiates the unlock period for a lock\n     * @dev operation will be queued until the next update at which point the user can execute\n     * @dev\n     * - at least half of the locking duration must have elapsed to initiate the unlock period\n     * - the unlock period consists of half of the locking duration\n     * - boost will be set to 0 upon initiation of the unlock period\n     *\n     * - reverts if `_lockId` is invalid or sender is not owner of lock\n     * - reverts if a minimum of half the locking duration has not elapsed\n     * @param _lockId id of lock\n     **/\n    function initiateUnlock(uint256 _lockId) external onlyLockOwner(_lockId, msg.sender) updateRewards(msg.sender) {\n        Lock memory lock = _getQueuedLockState(_lockId);\n\n        if (lock.expiry != 0) revert UnlockAlreadyInitiated();\n        uint64 halfDuration = lock.duration / 2;\n        if (lock.startTime + halfDuration > block.timestamp) revert HalfDurationNotElapsed();\n\n        uint64 expiry = uint64(block.timestamp) + halfDuration;\n        lock.expiry = expiry;\n\n        uint256 boostAmount = lock.boostAmount;\n        lock.boostAmount = 0;\n        effectiveBalances[msg.sender] -= boostAmount;\n        totalEffectiveBalance -= boostAmount;\n\n        queuedLockUpdates[_lockId].push(LockUpdate(updateBatchIndex, lock));\n        queuedRESDLSupplyChange -= int256(boostAmount);\n        if (updateNeeded == 0) updateNeeded = 1;\n\n        emit QueueInitiateUnlock(msg.sender, _lockId, expiry);\n    }\n\n    /**\n     * @notice withdraws unlocked SDL\n     * @dev operation will be queued until the next update at which point the user can execute\n     * @dev\n     * - SDL can only be withdrawn if unlocked (once the unlock period has elapsed or if it was never\n     *   locked in the first place)\n     * - reverts if `_lockId` is invalid or sender is not owner of lock\n     * - reverts if not unlocked\n     * - reverts if `_amount` exceeds the amount staked in the lock\n     * @param _lockId id of the lock\n     * @param _amount amount to withdraw from the lock\n     **/\n    function withdraw(uint256 _lockId, uint256 _amount)\n        external\n        onlyLockOwner(_lockId, msg.sender)\n        updateRewards(msg.sender)\n    {\n        Lock memory lock = _getQueuedLockState(_lockId);\n\n        if (lock.startTime != 0) {\n            uint64 expiry = lock.expiry;\n            if (expiry == 0) revert UnlockNotInitiated();\n            if (expiry > block.timestamp) revert TotalDurationNotElapsed();\n        }\n\n        uint256 baseAmount = lock.amount;\n        if (_amount > baseAmount) revert InsufficientBalance();\n\n        lock.amount = baseAmount - _amount;\n        effectiveBalances[msg.sender] -= _amount;\n        totalEffectiveBalance -= _amount;\n\n        queuedLockUpdates[_lockId].push(LockUpdate(updateBatchIndex, lock));\n        queuedRESDLSupplyChange -= int256(_amount);\n        if (updateNeeded == 0) updateNeeded = 1;\n\n        emit QueueWithdraw(msg.sender, _lockId, _amount);\n    }\n\n    /**\n     * @notice executes queued operations for the sender\n     * @dev will mint new locks and update existing locks\n     * @dev an operation can only be executed once its encompassing batch is finalized\n     * @param _lockIds ids of locks to update\n     **/\n    function executeQueuedOperations(uint256[] memory _lockIds) external {\n        _executeQueuedLockUpdates(msg.sender, _lockIds);\n        _mintQueuedNewLocks(msg.sender);\n    }\n\n    /**\n     * @notice handles the outgoing transfer of an reSDL lock to another chain\n     * @param _sender sender of the transfer\n     * @param _lockId id of lock\n     * @param _sdlReceiver address to receive underlying SDL on this chain\n     * @return lock the lock being transferred\n     **/\n    function handleOutgoingRESDL(\n        address _sender,\n        uint256 _lockId,\n        address _sdlReceiver\n    ) external onlyCCIPController onlyLockOwner(_lockId, _sender) updateRewards(_sender) returns (Lock memory) {\n        if (queuedLockUpdates[_lockId].length != 0) revert CannotTransferWithQueuedUpdates();\n\n        Lock memory lock = locks[_lockId];\n\n        delete locks[_lockId].amount;\n        delete lockOwners[_lockId];\n        balances[_sender] -= 1;\n\n        uint256 totalAmount = lock.amount + lock.boostAmount;\n        effectiveBalances[_sender] -= totalAmount;\n        totalEffectiveBalance -= totalAmount;\n\n        sdlToken.safeTransfer(_sdlReceiver, lock.amount);\n\n        emit OutgoingRESDL(_sender, _lockId);\n\n        return lock;\n    }\n\n    /**\n     * @notice handles the incoming transfer of an reSDL lock from another chain\n     * @param _receiver receiver of the transfer\n     * @param _lockId id of lock\n     * @param _lock lock\n     **/\n    function handleIncomingRESDL(\n        address _receiver,\n        uint256 _lockId,\n        Lock calldata _lock\n    ) external onlyCCIPController updateRewards(_receiver) {\n        if (lockOwners[_lockId] != address(0)) revert InvalidLockId();\n\n        locks[_lockId] = Lock(_lock.amount, _lock.boostAmount, _lock.startTime, _lock.duration, _lock.expiry);\n        lockOwners[_lockId] = _receiver;\n        balances[_receiver] += 1;\n\n        uint256 totalAmount = _lock.amount + _lock.boostAmount;\n        effectiveBalances[_receiver] += totalAmount;\n        totalEffectiveBalance += totalAmount;\n\n        if (_lockId > lastLockId) lastLockId = _lockId;\n\n        emit IncomingRESDL(_receiver, _lockId);\n    }\n\n    /**\n     * @notice handles an outgoing update to the primary chain\n     * @return the number of new locks to mint and the reSDL supply change since the last update\n     **/\n    function handleOutgoingUpdate() external onlyCCIPController returns (uint256, int256) {\n        if (updateInProgress == 1) revert UpdateInProgress();\n\n        uint256 numNewQueuedLocks = queuedNewLocks[updateBatchIndex].length;\n        int256 reSDLSupplyChange = queuedRESDLSupplyChange;\n\n        queuedRESDLSupplyChange = 0;\n        updateBatchIndex++;\n        updateInProgress = 1;\n        updateNeeded = 0;\n        queuedNewLocks.push();\n\n        emit OutgoingUpdate(updateBatchIndex - 1, numNewQueuedLocks, reSDLSupplyChange);\n\n        return (numNewQueuedLocks, reSDLSupplyChange);\n    }\n\n    /**\n     * @notice handles an incoming update from the primary chain\n     * @dev an outgoing update must be sent prior to receiving an incoming update\n     * @dev finalizes the most recent batch of operations\n     * @param _mintStartIndex start index to use for minting new locks in the lastest batch\n     **/\n    function handleIncomingUpdate(uint256 _mintStartIndex) external onlyCCIPController {\n        if (updateInProgress == 0) revert NoUpdateInProgress();\n\n        if (_mintStartIndex != 0) {\n            uint256 newLastLockId = _mintStartIndex + queuedNewLocks[updateBatchIndex - 1].length - 1;\n            if (newLastLockId > lastLockId) lastLockId = newLastLockId;\n        }\n\n        currentMintLockIdByBatch.push(_mintStartIndex);\n        updateInProgress = 0;\n        emit IncomingUpdate(updateBatchIndex - 1, _mintStartIndex);\n    }\n\n    /**\n     * @notice returns whether an update should be sent to the primary chain\n     * @return whether update should be sent\n     **/\n    function shouldUpdate() external view returns (bool) {\n        return updateNeeded == 1 && updateInProgress == 0;\n    }\n\n    /**\n     * @notice queues a new lock to be minted\n     * @param _owner owner of lock\n     * @param _amount amount of underlying SDL\n     * @param _lockingDuration locking duration\n     **/\n    function _queueNewLock(\n        address _owner,\n        uint256 _amount,\n        uint64 _lockingDuration\n    ) internal {\n        if (newLocksByOwner[_owner].length >= queuedNewLockLimit) revert TooManyQueuedLocks();\n\n        Lock memory lock = _createLock(_amount, _lockingDuration);\n        queuedNewLocks[updateBatchIndex].push(lock);\n        newLocksByOwner[_owner].push(NewLockPointer(updateBatchIndex, uint128(queuedNewLocks[updateBatchIndex].length - 1)));\n        queuedRESDLSupplyChange += int256(lock.amount + lock.boostAmount);\n        if (updateNeeded == 0) updateNeeded = 1;\n\n        emit QueueCreateLock(_owner, _amount, lock.boostAmount, _lockingDuration);\n    }\n\n    /**\n     * @notice mints queued new locks for an owner\n     * @dev will only mint locks that are part of finalized batches\n     * @param _owner owner address\n     **/\n    function _mintQueuedNewLocks(address _owner) internal updateRewards(_owner) {\n        uint256 finalizedBatchIndex = _getFinalizedUpdateBatchIndex();\n        uint256 numNewLocks = newLocksByOwner[_owner].length;\n        uint256 i = 0;\n        while (i < numNewLocks) {\n            NewLockPointer memory newLockPointer = newLocksByOwner[_owner][i];\n            if (newLockPointer.updateBatchIndex > finalizedBatchIndex) break;\n\n            uint256 lockId = currentMintLockIdByBatch[newLockPointer.updateBatchIndex];\n            Lock memory lock = queuedNewLocks[newLockPointer.updateBatchIndex][newLockPointer.index];\n\n            currentMintLockIdByBatch[newLockPointer.updateBatchIndex] += 1;\n\n            locks[lockId] = lock;\n            lockOwners[lockId] = _owner;\n            balances[_owner] += 1;\n\n            uint256 totalAmount = lock.amount + lock.boostAmount;\n            effectiveBalances[_owner] += totalAmount;\n            totalEffectiveBalance += totalAmount;\n\n            emit CreateLock(_owner, lockId, lock.amount, lock.boostAmount, lock.duration);\n            emit Transfer(address(0), _owner, lockId);\n\n            ++i;\n        }\n\n        for (uint256 j = 0; j < numNewLocks; ++j) {\n            if (i == numNewLocks) {\n                newLocksByOwner[_owner].pop();\n            } else {\n                newLocksByOwner[_owner][j] = newLocksByOwner[_owner][i];\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice queued an update for a lock\n     * @param _owner owner of lock\n     * @param _lockId id of lock\n     * @param _amount new amount of underlying SDL\n     * @param _lockingDuration new locking duration\n     **/\n    function _queueLockUpdate(\n        address _owner,\n        uint256 _lockId,\n        uint256 _amount,\n        uint64 _lockingDuration\n    ) internal onlyLockOwner(_lockId, _owner) {\n        Lock memory lock = _getQueuedLockState(_lockId);\n        LockUpdate memory lockUpdate = LockUpdate(updateBatchIndex, _updateLock(lock, _amount, _lockingDuration));\n        queuedLockUpdates[_lockId].push(lockUpdate);\n        queuedRESDLSupplyChange +=\n            int256(lockUpdate.lock.amount + lockUpdate.lock.boostAmount) -\n            int256(lock.amount + lock.boostAmount);\n        if (updateNeeded == 0) updateNeeded = 1;\n\n        emit QueueUpdateLock(_owner, _lockId, lockUpdate.lock.amount, lockUpdate.lock.boostAmount, lockUpdate.lock.duration);\n    }\n\n    /**\n     * @notice executes a series of lock updates\n     * @dev will only update locks that are part of finalized batches\n     * @param _owner owner of locks\n     * @param _lockIds list of ids for locks to update\n     **/\n    function _executeQueuedLockUpdates(address _owner, uint256[] memory _lockIds) internal updateRewards(_owner) {\n        uint256 finalizedBatchIndex = _getFinalizedUpdateBatchIndex();\n\n        for (uint256 i = 0; i < _lockIds.length; ++i) {\n            uint256 lockId = _lockIds[i];\n            _onlyLockOwner(lockId, _owner);\n            uint256 numUpdates = queuedLockUpdates[lockId].length;\n\n            Lock memory curLockState = locks[lockId];\n            uint256 j = 0;\n            while (j < numUpdates) {\n                if (queuedLockUpdates[lockId][j].updateBatchIndex > finalizedBatchIndex) break;\n\n                Lock memory updateLockState = queuedLockUpdates[lockId][j].lock;\n                int256 baseAmountDiff = int256(updateLockState.amount) - int256(curLockState.amount);\n                int256 boostAmountDiff = int256(updateLockState.boostAmount) - int256(curLockState.boostAmount);\n\n                if (baseAmountDiff < 0) {\n                    emit Withdraw(_owner, lockId, uint256(-1 * baseAmountDiff));\n                    if (updateLockState.amount == 0) {\n                        delete locks[lockId];\n                        delete lockOwners[lockId];\n                        balances[_owner] -= 1;\n                        if (tokenApprovals[lockId] != address(0)) delete tokenApprovals[lockId];\n                        emit Transfer(_owner, address(0), lockId);\n                    } else {\n                        locks[lockId].amount = updateLockState.amount;\n                    }\n                    sdlToken.safeTransfer(_owner, uint256(-1 * baseAmountDiff));\n                } else if (boostAmountDiff < 0) {\n                    locks[lockId].expiry = updateLockState.expiry;\n                    locks[lockId].boostAmount = 0;\n                    emit InitiateUnlock(_owner, lockId, updateLockState.expiry);\n                } else {\n                    locks[lockId] = updateLockState;\n                    uint256 totalDiff = uint256(baseAmountDiff + boostAmountDiff);\n                    effectiveBalances[_owner] += totalDiff;\n                    totalEffectiveBalance += totalDiff;\n                    emit UpdateLock(\n                        _owner,\n                        lockId,\n                        updateLockState.amount,\n                        updateLockState.boostAmount,\n                        updateLockState.duration\n                    );\n                }\n                curLockState = updateLockState;\n                ++j;\n            }\n\n            for (uint256 k = 0; k < numUpdates; ++k) {\n                if (j == numUpdates) {\n                    queuedLockUpdates[lockId].pop();\n                } else {\n                    queuedLockUpdates[lockId][k] = queuedLockUpdates[lockId][j];\n                    ++j;\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice returns the current state of a lock\n     * @dev will return the most recent queued update for a lock or the finalized state if there are no queued updates\n     * @param _lockId id of lock\n     * @return the current state of a lock\n     **/\n    function _getQueuedLockState(uint256 _lockId) internal view returns (Lock memory) {\n        uint256 updatesLength = queuedLockUpdates[_lockId].length;\n\n        if (updatesLength != 0) {\n            return queuedLockUpdates[_lockId][updatesLength - 1].lock;\n        } else {\n            return locks[_lockId];\n        }\n    }\n\n    /**\n     * @notice returns the index of the latest finalized batch\n     * @return latest finalized batch index\n     **/\n    function _getFinalizedUpdateBatchIndex() internal view returns (uint256) {\n        return currentMintLockIdByBatch.length - 1;\n    }\n\n    /**\n     * @notice transfers a lock between accounts\n     * @param _from account to transfer from\n     * @param _to account to transfer to\n     * @param _lockId id of lock to tansfer\n     **/\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _lockId\n    ) internal override {\n        if (queuedLockUpdates[_lockId].length != 0) revert CannotTransferWithQueuedUpdates();\n        super._transfer(_from, _to, _lockId);\n    }\n}"
    },
    {
      "filename": "contracts/core/sdlPool/SDLPoolSecondary.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\n\nimport \"./base/SDLPool.sol\";\n\n/**\n * @title SDL Pool Secondary\n * @notice Allows users to stake/lock SDL tokens and receive a percentage of the protocol's earned rewards\n * @dev deployed on all supported chains besides the primary chain\n */\ncontract SDLPoolSecondary is SDLPool {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct NewLockPointer {\n        uint128 updateBatchIndex;\n        uint128 index;\n    }\n    struct LockUpdate {\n        uint128 updateBatchIndex;\n        Lock lock;\n    }\n\n    mapping(uint256 => LockUpdate[]) internal queuedLockUpdates;\n\n    uint256 public queuedNewLockLimit;\n    uint256[] internal currentMintLockIdByBatch;\n    Lock[][] internal queuedNewLocks;\n    mapping(address => NewLockPointer[]) internal newLocksByOwner;\n\n    uint128 public updateBatchIndex;\n    uint64 public updateInProgress;\n    uint64 internal updateNeeded;\n    int256 public queuedRESDLSupplyChange;\n\n    event QueueInitiateUnlock(address indexed owner, uint256 indexed lockId, uint64 expiry);\n    event QueueWithdraw(address indexed owner, uint256 indexed lockId, uint256 amount);\n    event QueueCreateLock(address indexed owner, uint256 amount, uint256 boostAmount, uint64 lockingDuration);\n    event QueueUpdateLock(\n        address indexed owner,\n        uint256 indexed lockId,\n        uint256 amount,\n        uint256 boostAmount,\n        uint64 lockingDuration\n    );\n    event OutgoingUpdate(uint128 indexed batchIndex, uint256 numNewQueuedLocks, int256 reSDLSupplyChange);\n    event IncomingUpdate(uint128 indexed batchIndex, uint256 mintStartIndex);\n\n    error CannotTransferWithQueuedUpdates();\n    error UpdateInProgress();\n    error NoUpdateInProgress();\n    error TooManyQueuedLocks();\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice initializes contract\n     * @param _name name of the staking derivative token\n     * @param _symbol symbol of the staking derivative token\n     * @param _sdlToken address of the SDL token\n     * @param _boostController address of the boost controller\n     * @param _queuedNewLockLimit max amount of queued new locks an account can have\n     **/\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        address _sdlToken,\n        address _boostController,\n        uint256 _queuedNewLockLimit\n    ) public initializer {\n        __SDLPoolBase_init(_name, _symbol, _sdlToken, _boostController);\n        updateBatchIndex = 1;\n        currentMintLockIdByBatch.push(0);\n        queuedNewLocks.push();\n        queuedNewLocks.push();\n        queuedNewLockLimit = _queuedNewLockLimit;\n    }\n\n    /**\n     * @notice returns a list of queued new locks for an owner\n     * @param _owner owner of locks\n     * @return list of queued locks and corresponding batch indexes\n     **/\n    function getQueuedNewLocksByOwner(address _owner) external view returns (Lock[] memory, uint256[] memory) {\n        uint256 numNewLocks = newLocksByOwner[_owner].length;\n        Lock[] memory newLocks = new Lock[](numNewLocks);\n        uint256[] memory batchIndexes = new uint256[](numNewLocks);\n\n        for (uint256 i = 0; i < numNewLocks; ++i) {\n            NewLockPointer memory pointer = newLocksByOwner[_owner][i];\n            newLocks[i] = queuedNewLocks[pointer.updateBatchIndex][pointer.index];\n            batchIndexes[i] = pointer.updateBatchIndex;\n        }\n\n        return (newLocks, batchIndexes);\n    }\n\n    /**\n     * @notice returns queued lock updates for a list of lock ids\n     * @param _lockIds list of lock ids\n     * @return list of queued lock updates corresponding to each lock id\n     **/\n    function getQueuedLockUpdates(uint256[] calldata _lockIds) external view returns (LockUpdate[][] memory) {\n        LockUpdate[][] memory updates = new LockUpdate[][](_lockIds.length);\n\n        for (uint256 i = 0; i < _lockIds.length; ++i) {\n            updates[i] = queuedLockUpdates[_lockIds[i]];\n        }\n\n        return updates;\n    }\n\n    /**\n     * @notice ERC677 implementation to stake/lock SDL tokens or distribute rewards\n     * @dev operations will be queued until the next update at which point the user can execute (excludes reward distribution)\n     * @dev\n     * - will update/create a lock if the token transferred is SDL or will distribute rewards otherwise\n     *\n     * For Non-SDL:\n     * - reverts if token is unsupported\n     *\n     * For SDL:\n     * - set lockId to 0 to create a new lock or set lockId to > 0 to stake more into an existing lock\n     * - set lockingDuration to 0 to stake without locking or set lockingDuration to > 0 to lock for an amount\n     *   time in seconds\n     * @param _sender of the stake\n     * @param _value of the token transfer\n     * @param _calldata encoded lockId (uint256) and lockingDuration (uint64)\n     **/\n    function onTokenTransfer(\n        address _sender,\n        uint256 _value,\n        bytes calldata _calldata\n    ) external override {\n        if (msg.sender != address(sdlToken) && !isTokenSupported(msg.sender)) revert UnauthorizedToken();\n\n        if (_value == 0) revert InvalidValue();\n\n        if (msg.sender == address(sdlToken)) {\n            (uint256 lockId, uint64 lockingDuration) = abi.decode(_calldata, (uint256, uint64));\n            if (lockId != 0) {\n                _queueLockUpdate(_sender, lockId, _value, lockingDuration);\n            } else {\n                _queueNewLock(_sender, _value, lockingDuration);\n            }\n        } else {\n            distributeToken(msg.sender);\n        }\n    }\n\n    /**\n     * @notice extends the locking duration of a lock\n     * @dev operation will be queued until the next update at which point the user can execute\n     * @dev\n     * - reverts if `_lockId` is invalid or sender is not owner of lock\n     * - reverts if `_lockingDuration` is less than current locking duration of lock\n     * - reverts if `_lockingDuration` is 0 or exceeds the maximum\n     * @param _lockId id of lock\n     * @param _lockingDuration new locking duration to set\n     **/\n    function extendLockDuration(uint256 _lockId, uint64 _lockingDuration) external {\n        if (_lockingDuration == 0) revert InvalidLockingDuration();\n        _queueLockUpdate(msg.sender, _lockId, 0, _lockingDuration);\n    }\n\n    /**\n     * @notice initiates the unlock period for a lock\n     * @dev operation will be queued until the next update at which point the user can execute\n     * @dev\n     * - at least half of the locking duration must have elapsed to initiate the unlock period\n     * - the unlock period consists of half of the locking duration\n     * - boost will be set to 0 upon initiation of the unlock period\n     *\n     * - reverts if `_lockId` is invalid or sender is not owner of lock\n     * - reverts if a minimum of half the locking duration has not elapsed\n     * @param _lockId id of lock\n     **/\n    function initiateUnlock(uint256 _lockId) external onlyLockOwner(_lockId, msg.sender) updateRewards(msg.sender) {\n        Lock memory lock = _getQueuedLockState(_lockId);\n\n        if (lock.expiry != 0) revert UnlockAlreadyInitiated();\n        uint64 halfDuration = lock.duration / 2;\n        if (lock.startTime + halfDuration > block.timestamp) revert HalfDurationNotElapsed();\n\n        uint64 expiry = uint64(block.timestamp) + halfDuration;\n        lock.expiry = expiry;\n\n        uint256 boostAmount = lock.boostAmount;\n        lock.boostAmount = 0;\n        effectiveBalances[msg.sender] -= boostAmount;\n        totalEffectiveBalance -= boostAmount;\n\n        queuedLockUpdates[_lockId].push(LockUpdate(updateBatchIndex, lock));\n        queuedRESDLSupplyChange -= int256(boostAmount);\n        if (updateNeeded == 0) updateNeeded = 1;\n\n        emit QueueInitiateUnlock(msg.sender, _lockId, expiry);\n    }\n\n    /**\n     * @notice withdraws unlocked SDL\n     * @dev operation will be queued until the next update at which point the user can execute\n     * @dev\n     * - SDL can only be withdrawn if unlocked (once the unlock period has elapsed or if it was never\n     *   locked in the first place)\n     * - reverts if `_lockId` is invalid or sender is not owner of lock\n     * - reverts if not unlocked\n     * - reverts if `_amount` exceeds the amount staked in the lock\n     * @param _lockId id of the lock\n     * @param _amount amount to withdraw from the lock\n     **/\n    function withdraw(uint256 _lockId, uint256 _amount)\n        external\n        onlyLockOwner(_lockId, msg.sender)\n        updateRewards(msg.sender)\n    {\n        Lock memory lock = _getQueuedLockState(_lockId);\n\n        if (lock.startTime != 0) {\n            uint64 expiry = lock.expiry;\n            if (expiry == 0) revert UnlockNotInitiated();\n            if (expiry > block.timestamp) revert TotalDurationNotElapsed();\n        }\n\n        uint256 baseAmount = lock.amount;\n        if (_amount > baseAmount) revert InsufficientBalance();\n\n        lock.amount = baseAmount - _amount;\n        effectiveBalances[msg.sender] -= _amount;\n        totalEffectiveBalance -= _amount;\n\n        queuedLockUpdates[_lockId].push(LockUpdate(updateBatchIndex, lock));\n        queuedRESDLSupplyChange -= int256(_amount);\n        if (updateNeeded == 0) updateNeeded = 1;\n\n        emit QueueWithdraw(msg.sender, _lockId, _amount);\n    }\n\n    /**\n     * @notice executes queued operations for the sender\n     * @dev will mint new locks and update existing locks\n     * @dev an operation can only be executed once its encompassing batch is finalized\n     * @param _lockIds ids of locks to update\n     **/\n    function executeQueuedOperations(uint256[] memory _lockIds) external {\n        _executeQueuedLockUpdates(msg.sender, _lockIds);\n        _mintQueuedNewLocks(msg.sender);\n    }\n\n    /**\n     * @notice handles the outgoing transfer of an reSDL lock to another chain\n     * @param _sender sender of the transfer\n     * @param _lockId id of lock\n     * @param _sdlReceiver address to receive underlying SDL on this chain\n     * @return lock the lock being transferred\n     **/\n    function handleOutgoingRESDL(\n        address _sender,\n        uint256 _lockId,\n        address _sdlReceiver\n    ) external onlyCCIPController onlyLockOwner(_lockId, _sender) updateRewards(_sender) returns (Lock memory) {\n        if (queuedLockUpdates[_lockId].length != 0) revert CannotTransferWithQueuedUpdates();\n\n        Lock memory lock = locks[_lockId];\n\n        delete locks[_lockId].amount;\n        delete lockOwners[_lockId];\n        balances[_sender] -= 1;\n\n        uint256 totalAmount = lock.amount + lock.boostAmount;\n        effectiveBalances[_sender] -= totalAmount;\n        totalEffectiveBalance -= totalAmount;\n\n        sdlToken.safeTransfer(_sdlReceiver, lock.amount);\n\n        emit OutgoingRESDL(_sender, _lockId);\n\n        return lock;\n    }\n\n    /**\n     * @notice handles the incoming transfer of an reSDL lock from another chain\n     * @param _receiver receiver of the transfer\n     * @param _lockId id of lock\n     * @param _lock lock\n     **/\n    function handleIncomingRESDL(\n        address _receiver,\n        uint256 _lockId,\n        Lock callda"
    }
  ]
}