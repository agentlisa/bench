{
  "Title": "[M-01] Potential risk of using `swappedAmount` in case of swap error",
  "Content": "\n<https://github.com/code-423n4/2023-06-canto/blob/main/Canto/x/onboarding/keeper/ibc_callbacks.go#L93-L96> <br><https://github.com/code-423n4/2023-06-canto/blob/a4ff2fd2e67e77e36528fad99f9d88149a5e8532/Canto/x/onboarding/keeper/ibc_callbacks.go#L124>\n\n### Impact\n\nIn case the swap operation failed, the module should continue as is with the erc20 conversion and finish the IBC transfer. This is the relevant part of the code that swallows the error:\n\n    swappedAmount, err = k.coinswapKeeper.TradeInputForExactOutput(ctx, coinswaptypes.Input{Coin: transferredCoin, Address: recipient.String()}, coinswaptypes.Output{Coin: swapCoins, Address: recipient.String()})\n    if err != nil {\n        logger.Error(\"failed to swap coins\", \"error\", err)\n    } \n\nNotice that in case of an error, `swappedAmount` will still be written to.\n\nLater on in the code, it is used to calculate the conversion amount:\n\n    convertCoin := sdk.NewCoin(transferredCoin.Denom, transferredCoin.Amount.Sub(swappedAmount))\n\nThe `swappedAmount` is trusted to have a zero value in this case. While this is currently true in the existing code, variables returned in error states should not be trusted and should be overwritten.\n\nCurrently all error states return `sdk.ZeroInt()` unless the swap was executed correctly, but it might change in  a future PR.\n\n### Proof of Concept\n\n1.  Run this patch, it will cause TradeInputForExactOutput to always error with a swappedAmount > 0 .\n\n```\n    diff --git a/Canto/x/coinswap/keeper/swap.go b/Canto/x/coinswap/keeper/swap.go\n    index 67e04ef..a331bcf 100644\n    --- a/Canto/x/coinswap/keeper/swap.go\n    +++ b/Canto/x/coinswap/keeper/swap.go\n    @@ -2,6 +2,7 @@ package keeper\n     \n     import (\n            \"fmt\"\n    +\n            sdk \"github.com/cosmos/cosmos-sdk/types\"\n            sdkerrors \"github.com/cosmos/cosmos-sdk/types/errors\"\n     \n    @@ -160,51 +161,8 @@ Buy exact amount of a token by specifying the max amount of another token, one o\n     @param receipt : address of the receiver\n     @return : actual amount of the token to be paid\n     */\n    -func (k Keeper) TradeInputForExactOutput(ctx sdk.Context, input types.Input, output types.Output) (sdk.Int, error) {\n    -       soldTokenAmt, err := k.calculateWithExactOutput(ctx, output.Coin, input.Coin.Denom)\n    -       if err != nil {\n    -               return sdk.ZeroInt(), err\n    -       }\n    -\n    -       // assert that the calculated amount is less than the\n    -       // max amount the buyer is willing to pay.\n    -       if soldTokenAmt.GT(input.Coin.Amount) {\n    -               return sdk.ZeroInt(), sdkerrors.Wrap(types.ErrConstraintNotMet, fmt.Sprintf(\"insufficient amount of %s, user expected: %s, actual: %s\", input.Coin.Denom, input.Coin.Amount.String(), soldTokenAmt.String()))\n    -       }\n    -       soldToken := sdk.NewCoin(input.Coin.Denom, soldTokenAmt)\n    -\n    -       inputAddress, err := sdk.AccAddressFromBech32(input.Address)\n    -       if err != nil {\n    -               return sdk.ZeroInt(), err\n    -       }\n    -       outputAddress, err := sdk.AccAddressFromBech32(output.Address)\n    -       if err != nil {\n    -               return sdk.ZeroInt(), err\n    -       }\n    -\n    -       standardDenom := k.GetStandardDenom(ctx)\n    -       var quoteCoinToSwap sdk.Coin\n    -\n    -       if soldToken.Denom != standardDenom {\n    -               quoteCoinToSwap = soldToken\n    -       } else {\n    -               quoteCoinToSwap = output.Coin\n    -       }\n    -\n    -       maxSwapAmount, err := k.GetMaximumSwapAmount(ctx, quoteCoinToSwap.Denom)\n    -       if err != nil {\n    -               return sdk.ZeroInt(), err\n    -       }\n    -\n    -       if quoteCoinToSwap.Amount.GT(maxSwapAmount.Amount) {\n    -               return sdk.ZeroInt(), sdkerrors.Wrap(types.ErrConstraintNotMet, fmt.Sprintf(\"expected swap amount %s%s exceeding swap amount limit %s%s\", quoteCoinToSwap.Amount.String(), quoteCoinToSwap.Denom, maxSwapAmount.Amount.String(), maxSwapAmount.Denom))\n    -       }\n    -\n    -       if err := k.swapCoins(ctx, inputAddress, outputAddress, soldToken, output.Coin); err != nil {\n    -               return sdk.ZeroInt(), err\n    -       }\n    -\n    -       return soldTokenAmt, nil\n    +func (k Keeper) TradeInputForExactOutput(_ sdk.Context, _ types.Input, _ types.Output) (sdk.Int, error) {\n    +       return sdk.NewIntFromUint64(10000), fmt.Errorf(\"swap error\")\n     }\n```\n\n2.  Add this test to `x/onboarding/keeper/ibc_callbacks_test.go` :\n\n```\n    {\n        \"swap fails with swappedAmount / convert remaining ibc token - some vouchers are not converted\",\n        func() {\n            transferAmount = sdk.NewIntWithDecimal(25, 6)\n            transfer := transfertypes.NewFungibleTokenPacketData(denom, transferAmount.String(), secpAddrCosmos, ethsecpAddrcanto)\n            bz := transfertypes.ModuleCdc.MustMarshalJSON(&transfer)\n            packet = channeltypes.NewPacket(bz, 100, transfertypes.PortID, sourceChannel, transfertypes.PortID, cantoChannel, timeoutHeight, 0)\n        },\n        true,\n        sdk.NewCoins(sdk.NewCoin(\"acanto\", sdk.NewIntWithDecimal(3, 18))),\n        sdk.NewCoin(\"acanto\", sdk.NewIntWithDecimal(3, 18)),\n        sdk.NewCoin(uusdcIbcdenom, sdk.NewIntFromUint64(10000)),\n        sdk.NewInt(24990000),\n    },\n```\n\nThe test will still fail because of another unimportant check, but the important check will pass - the address will have `sent-swappedAmount` vouchers converted, and the rest will be kept.\n\nIt means swappedAmount was used even though the swap function failed.\n\n### Tools Used\n\nIDE.\n\n### Recommended Mitigation Steps\n\nZero the `swappedAmount` variable in the error case:\n\n    swappedAmount = sdk.ZeroInt()\n\n### Assessed type\n\nOther\n\n**[tkkwon1998 (Canto) confirmed and commented on duplicate issue 80](https://github.com/code-423n4/2023-06-canto-findings/issues/80#issuecomment-1612272077):**\n> The warden is correct in that a swap could go only half-completed if the function is used incorrectly, but all of the checks should occur before it ever gets to the swap function to ensure it succeeds fully. In our case, all of the checks are done in `TradeInputForExactOutput`. If the warden believes we are missing any checks which may cause the swap to only half-complete, then that would be great.\n> \n> I will mark this as valid because, as the warden mentioned, if any future upgrades use the swap function, there may be a potential that they do not do the necessary checks.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-06-canto",
  "Code": [
    {
      "filename": "Canto/x/onboarding/keeper/ibc_callbacks.go",
      "content": "package keeper\n\nimport (\n\t\"strconv\"\n\n\terrorsmod \"cosmossdk.io/errors\"\n\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n\tauthtypes \"github.com/cosmos/cosmos-sdk/x/auth/types\"\n\n\ttransfertypes \"github.com/cosmos/ibc-go/v3/modules/apps/transfer/types\"\n\tchanneltypes \"github.com/cosmos/ibc-go/v3/modules/core/04-channel/types\"\n\t\"github.com/cosmos/ibc-go/v3/modules/core/exported\"\n\n\t\"github.com/ethereum/go-ethereum/common\"\n\n\t\"github.com/Canto-Network/Canto/v6/ibc\"\n\tcoinswaptypes \"github.com/Canto-Network/Canto/v6/x/coinswap/types\"\n\terc20types \"github.com/Canto-Network/Canto/v6/x/erc20/types\"\n\t\"github.com/Canto-Network/Canto/v6/x/onboarding/types\"\n)\n\n// OnRecvPacket performs an IBC receive callback.\n// It swaps the transferred IBC denom to acanto and\n// convert the remaining balance to ERC20 tokens.\n// If the balance of acanto is greater than the predefined value,\n// the swap is omitted and the entire transferred amount is converted to ERC20.\nfunc (k Keeper) OnRecvPacket(\n\tctx sdk.Context,\n\tpacket channeltypes.Packet,\n\tack exported.Acknowledgement,\n) exported.Acknowledgement {\n\tlogger := k.Logger(ctx)\n\n\t// It always returns original ACK\n\t// meaning that even if the swap or conversion fails, it does not revert IBC transfer\n\t// and the asset transferred to the Canto network will still remain in the Canto network\n\n\tparams := k.GetParams(ctx)\n\tif !params.EnableOnboarding {\n\t\treturn ack\n\t}\n\n\t// check source channel is in the whitelist channels\n\tvar found bool\n\tfor _, s := range params.WhitelistedChannels {\n\t\tif s == packet.DestinationChannel {\n\t\t\tfound = true\n\t\t}\n\t}\n\n\tif !found {\n\t\treturn ack\n\t}\n\n\t// Get recipient addresses in `canto1` and the original bech32 format\n\t_, recipient, senderBech32, recipientBech32, err := ibc.GetTransferSenderRecipient(packet)\n\tif err != nil {\n\t\treturn channeltypes.NewErrorAcknowledgement(err.Error())\n\t}\n\n\t//get the recipient account\n\taccount := k.accountKeeper.GetAccount(ctx, recipient)\n\n\t// onboarding is not supported for module accounts\n\tif _, isModuleAccount := account.(authtypes.ModuleAccountI); isModuleAccount {\n\t\treturn ack\n\t}\n\n\tstandardDenom := k.coinswapKeeper.GetStandardDenom(ctx)\n\n\tvar data transfertypes.FungibleTokenPacketData\n\tif err = transfertypes.ModuleCdc.UnmarshalJSON(packet.GetData(), &data); err != nil {\n\t\t// NOTE: shouldn't happen as the packet has already\n\t\t// been decoded on ICS20 transfer logic\n\t\terr = errorsmod.Wrapf(types.ErrInvalidType, \"cannot unmarshal ICS-20 transfer packet data\")\n\t\treturn channeltypes.NewErrorAcknowledgement(err.Error())\n\t}\n\n\t// parse the transferred denom\n\ttransferredCoin := ibc.GetReceivedCoin(\n\t\tpacket.SourcePort, packet.SourceChannel,\n\t\tpacket.DestinationPort, packet.DestinationChannel,\n\t\tdata.Denom, data.Amount,\n\t)\n\n\tautoSwapThreshold := k.GetParams(ctx).AutoSwapThreshold\n\tswapCoins := sdk.NewCoin(standardDenom, autoSwapThreshold)\n\tstandardCoinBalance := k.bankKeeper.SpendableCoins(ctx, recipient).AmountOf(standardDenom)\n\tswappedAmount := sdk.ZeroInt()\n\n\tif standardCoinBalance.LT(autoSwapThreshold) {\n\t\tswappedAmount, err = k.coinswapKeeper.TradeInputForExactOutput(ctx, coinswaptypes.Input{Coin: transferredCoin, Address: recipient.String()}, coinswaptypes.Output{Coin: swapCoins, Address: recipient.String()})\n\t\tif err != nil {\n\t\t\tlogger.Error(\"failed to swap coins\", \"error\", err)\n\t\t} else {\n\t\t\tctx.EventManager().EmitEvent(\n\t\t\t\tsdk.NewEvent(\n\t\t\t\t\tcoinswaptypes.EventTypeSwap,\n\t\t\t\t\tsdk.NewAttribute(coinswaptypes.AttributeValueAmount, swappedAmount.String()),\n\t\t\t\t\tsdk.NewAttribute(coinswaptypes.AttributeValueSender, recipient.String()),\n\t\t\t\t\tsdk.NewAttribute(coinswaptypes.AttributeValueRecipient, recipient.String()),\n\t\t\t\t\tsdk.NewAttribute(coinswaptypes.AttributeValueIsBuyOrder, strconv.FormatBool(true)),\n\t\t\t\t\tsdk.NewAttribute(coinswaptypes.AttributeValueTokenPair, coinswaptypes.GetTokenPairByDenom(transferredCoin.Denom, swapCoins.Denom)),\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\t}\n\n\t//convert coins to ERC20 token\n\tpairID := k.erc20Keeper.GetTokenPairID(ctx, transferredCoin.Denom)\n\tif len(pairID) == 0 {\n\t\t// short-circuit: if the denom is not registered, conversion will fail\n\t\t// so we can continue with the rest of the stack\n\t\treturn ack\n\t}\n\n\tpair, _ := k.erc20Keeper.GetTokenPair(ctx, pairID)\n\tif !pair.Enabled {\n\t\t// no-op: continue with the rest of the stack without conversion\n\t\treturn ack\n\t}\n\n\tconvertCoin := sdk.NewCoin(transferredCoin.Denom, transferredCoin.Amount.Sub(swappedAmount))\n\n\t// Build MsgConvertCoin, from recipient to recipient since IBC transfer already occurred\n\tconvertMsg := erc20types.NewMsgConvertCoin(convertCoin, common.BytesToAddress(recipient.Bytes()), recipient)\n\n\t// NOTE: we don't use ValidateBasic the msg since we've already validated\n\t// the ICS20 packet data\n\n\t// Use MsgConvertCoin to convert the Cosmos Coin to an ERC20\n\tif _, err = k.erc20Keeper.ConvertCoin(sdk.WrapSDKContext(ctx), convertMsg); err != nil {\n\t\tlogger.Error(\"failed to convert coins\", \"error\", err)\n\t\treturn ack\n\t}\n\n\tlogger.Info(\n\t\t\"coinswap and erc20 conversion completed\",\n\t\t\"sender\", senderBech32,\n\t\t\"receiver\", recipientBech32,\n\t\t\"source-port\", packet.SourcePort,\n\t\t\"source-channel\", packet.SourceChannel,\n\t\t\"dest-port\", packet.DestinationPort,\n\t\t\"dest-channel\", packet.DestinationChannel,\n\t\t\"swap amount\", swappedAmount,\n\t\t\"convert amount\", convertCoin.Amount,\n\t)\n\n\tctx.EventManager().EmitEvent(\n\t\tsdk.NewEvent(\n\t\t\ttypes.EventTypeOnboarding,\n\t\t\tsdk.NewAttribute(sdk.AttributeKeySender, senderBech32),\n\t\t\tsdk.NewAttribute(transfertypes.AttributeKeyReceiver, recipientBech32),\n\t\t\tsdk.NewAttribute(channeltypes.AttributeKeySrcChannel, packet.SourceChannel),\n\t\t\tsdk.NewAttribute(channeltypes.AttributeKeySrcPort, packet.SourcePort),\n\t\t\tsdk.NewAttribute(channeltypes.AttributeKeyDstPort, packet.DestinationPort),\n\t\t\tsdk.NewAttribute(channeltypes.AttributeKeyDstChannel, packet.DestinationChannel),\n\t\t\tsdk.NewAttribute(types.AttributeKeySwapAmount, swappedAmount.String()),\n\t\t\tsdk.NewAttribute(types.AttributeKeyConvertAmount, convertCoin.Amount.String()),\n\t\t),\n\t)\n\n\t// return original acknowledgement\n\treturn ack\n}"
    }
  ]
}