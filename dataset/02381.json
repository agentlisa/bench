{
  "Title": "H-6: Protection seller will lose unlocked capital if it fails to claim during more than one period",
  "Content": "# Issue H-6: Protection seller will lose unlocked capital if it fails to claim during more than one period \n\nSource: https://github.com/sherlock-audit/2023-02-carapace-judging/issues/142 \n\n## Found by \nXKET, Tricko, jkoppel, MalfurionWhitehat, Koolex, immeas, dec3ntraliz3d, bin2chen, VAD37\n\n## Summary\n\nThe protection seller will lose unlocked capital if it fails to claim during more than one period.\n\n## Vulnerability Detail\n\nThe function `DefaultStateManager._calculateClaimableAmount`, used by `DefaultStateManager.calculateAndClaimUnlockedCapital`, which in turn is used by `ProtectionPool.claimUnlockedCapital`, [overrides the claimable unlocked capital](https://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/core/DefaultStateManager.sol#L500-L505) on every loop iteration on the [`lockedCapitals` array](https://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/core/DefaultStateManager.sol#L476-L478). \n\nAs a result, [only the last snapshot is returned](https://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/core/DefaultStateManager.sol#L479) by this function, regardless if the protection seller has claimed the unlocked capital or not. The purpose of this code was to prevent sellers from [claiming the same snapshot twice](https://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/core/DefaultStateManager.sol#L487), but since the `_claimableUnlockedCapital` variable is being overwritten instead of incremented, on each loop iteration, it will also make sellers lose unlocked capital if they fail to claim at each snapshot.\n\nProof of concept:\n\n1. Pool goes to locked state with snapshotId 1\n2. Pool goes to active state\n3. Pool goes to locked state with snapshotId 2\n4. Pool goes to active state\n5. Protection seller calls `ProtectionPool.claimUnlockedCapital`, but they will only receive what's due from snapshotId 2, not from snapshotId 1\n\n## Impact\n\nThe protection seller will lose unlocked capital if it fails to claim during more than one period.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/core/DefaultStateManager.sol#L500-L505\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIncrement `_claimableUnlockedCapital` [for all](https://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/core/DefaultStateManager.sol#L502-L505) locked capital instances.\n\n## Discussion\n\n**vnadoda**\n\n@clems4ev3r PR for the fix is: https://github.com/carapace-finance/credit-default-swaps-contracts/pull/62\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/40",
  "Code": [
    {
      "filename": "contracts/core/DefaultStateManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ERC20SnapshotUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol\";\n\nimport {UUPSUpgradeableBase} from \"../UUPSUpgradeableBase.sol\";\nimport {IReferenceLendingPools, LendingPoolStatus} from \"../interfaces/IReferenceLendingPools.sol\";\nimport {ILendingProtocolAdapter} from \"../interfaces/ILendingProtocolAdapter.sol\";\nimport {IProtectionPool} from \"../interfaces/IProtectionPool.sol\";\nimport {IDefaultStateManager, ProtectionPoolState, LockedCapital, LendingPoolStatusDetail} from \"../interfaces/IDefaultStateManager.sol\";\nimport \"../libraries/Constants.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * @title DefaultStateManager\n * @author Carapace Finance\n * @notice Contract to assess status updates and the resultant state transitions of all lending pools of all protection pools\n * @dev This contract is upgradeable using the UUPS pattern.\n */\ncontract DefaultStateManager is UUPSUpgradeableBase, IDefaultStateManager {\n  /////////////////////////////////////////////////////\n  ///             STORAGE - START                   ///\n  /////////////////////////////////////////////////////\n  /**\n   * @dev DO NOT CHANGE THE ORDER OF THESE VARIABLES ONCE DEPLOYED\n   */\n\n  /// @notice address of the contract factory which is the only contract allowed to register protection pools.\n  address public contractFactoryAddress;\n\n  /// @dev stores the current state of all protection pools in the system.\n  /// @dev Array is used for enumerating all pools during state assessment.\n  ProtectionPoolState[] private protectionPoolStates;\n\n  /// @notice tracks an index of ProtectionPoolState for each pool in protectionPoolStates array.\n  mapping(address => uint256) private protectionPoolStateIndexes;\n\n  //////////////////////////////////////////////////////\n  ///             STORAGE - END                     ///\n  /////////////////////////////////////////////////////\n\n  /*** modifiers ***/\n\n  /// @dev modifier to restrict access to the contract factory address.\n  modifier onlyContractFactory() {\n    if (msg.sender != contractFactoryAddress) {\n      revert NotContractFactory(msg.sender);\n    }\n    _;\n  }\n\n  /*** initializer ***/\n\n  /**\n   * @notice Initializes the contract.\n   */\n  function initialize() external initializer {\n    __UUPSUpgradeableBase_init();\n\n    /// create a dummy pool state to reserve index 0.\n    /// this is to ensure that protectionPoolStateIndexes[pool] is always greater than 0,\n    /// which is used to check if a pool is registered or not.\n    protectionPoolStates.push();\n  }\n\n  /*** state-changing functions ***/\n\n  /// @inheritdoc IDefaultStateManager\n  /// @dev This function is marked as payable for gas optimization.\n  function setContractFactory(address _contractFactoryAddress)\n    external\n    payable\n    override\n    onlyOwner\n  {\n    if (_contractFactoryAddress == Constants.ZERO_ADDRESS) {\n      revert ZeroContractFactoryAddress();\n    }\n\n    contractFactoryAddress = _contractFactoryAddress;\n    emit ContractFactoryUpdated(_contractFactoryAddress);\n  }\n\n  /// @inheritdoc IDefaultStateManager\n  function registerProtectionPool(address _protectionPoolAddress)\n    external\n    payable\n    override\n    onlyContractFactory\n  {\n    /// if the protection pool is already registered, revert\n    if (\n      protectionPoolStates[protectionPoolStateIndexes[_protectionPoolAddress]]\n        .updatedTimestamp > 0\n    ) {\n      revert ProtectionPoolAlreadyRegistered(_protectionPoolAddress);\n    }\n\n    /// Protection pool will be inserted at the end of the array\n    uint256 newIndex = protectionPoolStates.length;\n\n    /// Insert new empty pool state at the end of the array\n    /// and update the state\n    protectionPoolStates.push();\n    ProtectionPoolState storage poolState = protectionPoolStates[newIndex];\n    poolState.protectionPool = IProtectionPool(_protectionPoolAddress);\n\n    /// Store the index of the pool state in the array\n    protectionPoolStateIndexes[_protectionPoolAddress] = newIndex;\n\n    /// Assess the state of the newly registered protection pool\n    _assessState(poolState);\n\n    emit ProtectionPoolRegistered(_protectionPoolAddress);\n  }\n\n  /// @inheritdoc IDefaultStateManager\n  function assessStates() external override {\n    /// gas optimizations:\n    /// 1. capture length in memory & don't read from storage for each iteration\n    /// 2. uncheck incrementing pool index\n    uint256 _length = protectionPoolStates.length;\n\n    /// assess the state of all registered protection pools except the dummy pool at index 0\n    for (uint256 _poolIndex = 1; _poolIndex < _length; ) {\n      _assessState(protectionPoolStates[_poolIndex]);\n      unchecked {\n        ++_poolIndex;\n      }\n    }\n\n    emit ProtectionPoolStatesAssessed();\n  }\n\n  /// @inheritdoc IDefaultStateManager\n  function assessStateBatch(address[] calldata _pools) external override {\n    uint256 _length = _pools.length;\n    for (uint256 _poolIndex; _poolIndex < _length; ) {\n      /// Get the state of the pool by looking up the index in the mapping from the given pool address\n      ProtectionPoolState storage poolState = protectionPoolStates[\n        protectionPoolStateIndexes[_pools[_poolIndex]]\n      ];\n\n      /// Only assess the state if the protection pool is registered\n      if (poolState.updatedTimestamp > 0) {\n        _assessState(poolState);\n      }\n\n      unchecked {\n        ++_poolIndex;\n      }\n    }\n  }\n\n  /// @inheritdoc IDefaultStateManager\n  /// @dev This method is only callable by a protection pool\n  function calculateAndClaimUnlockedCapital(address _seller)\n    external\n    override\n    returns (uint256 _claimedUnlockedCapital)\n  {\n    /// Get the state of the pool by looking up the index in the mapping from sender address\n    ProtectionPoolState storage poolState = protectionPoolStates[\n      protectionPoolStateIndexes[msg.sender]\n    ];\n\n    /// Only assess the state if the protection pool is registered\n    if (poolState.updatedTimestamp == 0) {\n      revert ProtectionPoolNotRegistered(msg.sender);\n    }\n\n    /// Get the list of all lending pools for the protection pool\n    address[] memory _lendingPools = poolState\n      .protectionPool\n      .getPoolInfo()\n      .referenceLendingPools\n      .getLendingPools();\n\n    /// Iterate through all lending pools for a given protection pool\n    /// and calculate the total claimable amount for the seller\n    uint256 _length = _lendingPools.length;\n    for (uint256 _lendingPoolIndex; _lendingPoolIndex < _length; ) {\n      address _lendingPool = _lendingPools[_lendingPoolIndex];\n\n      /// Calculate the claimable amount across all the locked capital instances for a given protection pool\n      (\n        uint256 _unlockedCapitalPerLendingPool,\n        uint256 _snapshotId\n      ) = _calculateClaimableAmount(poolState, _lendingPool, _seller);\n      _claimedUnlockedCapital += _unlockedCapitalPerLendingPool;\n\n      /// update the last claimed snapshot id for the seller for the given lending pool,\n      /// so that the next time the seller claims, the calculation starts from the last claimed snapshot id\n      poolState.lastClaimedSnapshotIds[_lendingPool][_seller] = _snapshotId;\n\n      unchecked {\n        ++_lendingPoolIndex;\n      }\n    }\n  }\n\n  /** view functions */\n\n  /**\n   * @notice Returns the timestamp of the protection pool state update.\n   */\n  function getPoolStateUpdateTimestamp(address _pool)\n    external\n    view\n    returns (uint256)\n  {\n    return\n      protectionPoolStates[protectionPoolStateIndexes[_pool]].updatedTimestamp;\n  }\n\n  /**\n   * @notice Returns the list of locked capital instances for a given protection pool and lending pool.\n   */\n  function getLockedCapitals(address _protectionPool, address _lendingPool)\n    external\n    view\n    returns (LockedCapital[] memory _lockedCapitals)\n  {\n    ProtectionPoolState storage poolState = protectionPoolStates[\n      protectionPoolStateIndexes[_protectionPool]\n    ];\n    _lockedCapitals = poolState.lockedCapitals[_lendingPool];\n  }\n\n  /// @inheritdoc IDefaultStateManager\n  function calculateClaimableUnlockedAmount(\n    address _protectionPool,\n    address _seller\n  ) external view override returns (uint256 _claimableUnlockedCapital) {\n    ProtectionPoolState storage poolState = protectionPoolStates[\n      protectionPoolStateIndexes[_protectionPool]\n    ];\n\n    /// Calculate the claimable amount only if the protection pool is registered\n    if (poolState.updatedTimestamp > 0) {\n      /// Get the list of all lending pools for the protection pool\n      address[] memory _lendingPools = poolState\n        .protectionPool\n        .getPoolInfo()\n        .referenceLendingPools\n        .getLendingPools();\n\n      /// Iterate through all lending pools for a given protection pool\n      /// and calculate the total claimable amount for the seller\n      uint256 _length = _lendingPools.length;\n      for (uint256 _lendingPoolIndex; _lendingPoolIndex < _length; ) {\n        address _lendingPool = _lendingPools[_lendingPoolIndex];\n\n        /// Calculate the claimable amount across all the locked capital instances for a given protection pool\n        (uint256 _unlockedCapitalPerLendingPool, ) = _calculateClaimableAmount(\n          poolState,\n          _lendingPool,\n          _seller\n        );\n\n        /// add the unlocked/claimable amount for the given lending pool to the total claimable amount\n        _claimableUnlockedCapital += _unlockedCapitalPerLendingPool;\n\n        unchecked {\n          ++_lendingPoolIndex;\n        }\n      }\n    }\n  }\n\n  /// @inheritdoc IDefaultStateManager\n  function getLendingPoolStatus(\n    address _protectionPoolAddress,\n    address _lendingPoolAddress\n  ) external view override returns (LendingPoolStatus) {\n    return\n      protectionPoolStates[protectionPoolStateIndexes[_protectionPoolAddress]]\n        .lendingPoolStateDetails[_lendingPoolAddress]\n        .currentStatus;\n  }\n\n  /** internal functions */\n\n  /**\n   * @dev assess the state of a given protection pool and\n   * update state changes & initiate related actions as needed.\n   */\n  function _assessState(ProtectionPoolState storage poolState) internal {\n    poolState.updatedTimestamp = block.timestamp;\n\n    /// assess the state of all reference lending pools of this protection pool\n    (\n      address[] memory _lendingPools,\n      LendingPoolStatus[] memory _currentStatuses\n    ) = poolState\n        .protectionPool\n        .getPoolInfo()\n        .referenceLendingPools\n        .assessState();\n\n    /// Compare previous and current status of each lending pool and perform the required state transition\n    uint256 _length = _lendingPools.length;\n    for (uint256 _lendingPoolIndex; _lendingPoolIndex < _length; ) {\n      /// Get the lending pool state details\n      address _lendingPool = _lendingPools[_lendingPoolIndex];\n      LendingPoolStatusDetail storage lendingPoolStateDetail = poolState\n        .lendingPoolStateDetails[_lendingPool];\n\n      /// Get the previous and current status of the lending pool\n      LendingPoolStatus _previousStatus = lendingPoolStateDetail.currentStatus;\n      LendingPoolStatus _currentStatus = _currentStatuses[_lendingPoolIndex];\n\n      if (_previousStatus != _currentStatus) {\n        console.log(\n          \"DefaultStateManager: Lending pool %s status is changed from %s to  %s\",\n          _lendingPool,\n          uint256(_previousStatus),\n          uint256(_currentStatus)\n        );\n      }\n\n      /// State transition 1: Active or LateWithinGracePeriod -> Late\n      if (\n        (_previousStatus == LendingPoolStatus.Active ||\n          _previousStatus == LendingPoolStatus.LateWithinGracePeriod) &&\n        _currentStatus == LendingPoolStatus.Late\n      ) {\n        /// Update the current status of the lending pool to Late\n        /// and move the lending pool to the locked state\n        lendingPoolStateDetail.currentStatus = LendingPoolStatus.Late;\n        _moveFromActiveToLockedState(poolState, _lendingPool);\n\n        /// Capture the timestamp when the lending pool became late\n        lendingPoolStateDetail.lateTimestamp = block.timestamp;\n      } else if (_previousStatus == LendingPoolStatus.Late) {\n        /// Once there is a late payment, we wait for 2 payment periods.\n        /// After 2 payment periods are elapsed, either full payment is going to be made or not.\n        /// If all missed payments(full payment) are made, then a pool goes back to active.\n        /// If full payment is not made, then this lending pool is in the default state.\n        if (\n          block.timestamp >\n          (lendingPoolStateDetail.lateTimestamp +\n            _getTwoPaymentPeriodsInSeconds(poolState, _lendingPool))\n        ) {\n          /// State transition 2: Late -> Active\n          if (_currentStatus == LendingPoolStatus.Active) {\n            /// Update the current status of the lending pool to Active\n            /// and move the lending pool to the active state\n            lendingPoolStateDetail.currentStatus = LendingPoolStatus.Active;\n            _moveFromLockedToActiveState(poolState, _lendingPool);\n\n            /// Clear the late timestamp\n            lendingPoolStateDetail.lateTimestamp = 0;\n          }\n          /// State transition 3: Late -> Defaulted\n          else if (_currentStatus == LendingPoolStatus.Late) {\n            /// Update the current status of the lending pool to Active\n            lendingPoolStateDetail.currentStatus = LendingPoolStatus.Defaulted;\n\n            // Default state transition will be implemented in the next version of the protocol\n            // _moveFromLockedToDefaultedState(poolState, _lendingPool);\n          }\n        }\n      } else if (\n        _previousStatus == LendingPoolStatus.Defaulted ||\n        _previousStatus == LendingPoolStatus.Expired\n      ) {\n        /// no state transition for Defaulted or Expired state\n      } else {\n        /// Only update the status in storage if it is changed\n        if (_previousStatus != _currentStatus) {\n          lendingPoolStateDetail.currentStatus = _currentStatus;\n          /// No action required for any other state transition\n        }\n      }\n\n      unchecked {\n        ++_lendingPoolIndex;\n      }\n    }\n  }\n\n  /**\n   * @dev Moves the lending pool from active state to locked state.\n   * Meaning that the capital is locked in the protection pool.\n   * @param poolState The stored state of the protection pool\n   * @param _lendingPool The address of the lending pool\n   */\n  function _moveFromActiveToLockedState(\n    ProtectionPoolState storage poolState,\n    address _lendingPool\n  ) internal {\n    IProtectionPool _protectionPool = poolState.protectionPool;\n\n    /// step 1: calculate & lock the capital amount in the protection pool\n    (uint256 _lockedCapital, uint256 _snapshotId) = _protectionPool.lockCapital(\n      _lendingPool\n    );\n\n    /// step 2: create and store an instance of locked capital for the lending pool\n    poolState.lockedCapitals[_lendingPool].push(\n      LockedCapital({\n        snapshotId: _snapshotId,\n        amount: _lockedCapital,\n        locked: true\n      })\n    );\n\n    emit LendingPoolLocked(\n      _lendingPool,\n      address(_protectionPool),\n      _snapshotId,\n      _lockedCapital\n    );\n  }\n\n  /**\n   * @dev Releases the locked capital, so investors can claim their share of the unlocked capital\n   * The capital is released/unlocked from last locked capital instance.\n   * Because new lock capital instance can not be created until the latest one is active again.\n   * @param poolState The stored state of the protection pool\n   * @param _lendingPool The address of the lending pool\n   */\n  function _moveFromLockedToActiveState(\n    ProtectionPoolState storage poolState,\n    address _lendingPool\n  ) internal {\n    /// For each lending pool, every active -> late state change creates a new instance of the locked capital.\n    /// So last item in the array represents the latest state change.\n    LockedCapital storage lockedCapital = _getLatestLockedCapital(\n      poolState,\n      _lendingPool\n    );\n    lockedCapital.locked = false;\n\n    emit LendingPoolUnlocked(\n      _lendingPool,\n      address(poolState.protectionPool),\n      lockedCapital.amount\n    );\n  }\n\n  /**\n   * @dev Calculates the claimable amount across all locked capital instances for the given seller address for a given lending pool.\n   * locked capital can be only claimed when it is released and has not been claimed before.\n   * @param poolState The stored state of the protection pool\n   * @param _lendingPool The address of the lending pool\n   * @param _seller The address of the seller\n   * @return _claimableUnlockedCapital The claimable amount across all locked capital instances in underlying tokens\n   * @return _latestClaimedSnapshotId The snapshot id of the latest locked capital instance from which the claimable amount is calculated\n   */\n  function _calculateClaimableAmount(\n    ProtectionPoolState storage poolState,\n    address _lendingPool,\n    address _seller\n  )\n    internal\n    view\n    returns (\n      uint256 _claimableUnlockedCapital,\n      uint256 _latestClaimedSnapshotId\n    )\n  {\n    /// Retrieve the last claimed snapshot id for the seller from storage\n    uint256 _lastClaimedSnapshotId = poolState.lastClaimedSnapshotIds[\n      _lendingPool\n    ][_seller];\n\n    /// Retrieve the locked capital instances for the given lending pool\n    LockedCapital[] storage lockedCapitals = poolState.lockedCapitals[\n      _lendingPool\n    ];\n\n    /// Iterate over the locked capital instances and calculate the claimable amount\n    uint256 _length = lockedCapitals.length;\n    for (uint256 _index = 0; _index < _length; ) {\n      LockedCapital storage lockedCapital = lockedCapitals[_index];\n      uint256 _snapshotId = lockedCapital.snapshotId;\n\n      console.log(\n        \"lockedCapital.locked: %s, amt: %s\",\n        lockedCapital.locked,\n        lockedCapital.amount\n      );\n\n      /// Verify that the seller does not claim the same snapshot twice\n      if (!lockedCapital.locked && _snapshotId > _lastClaimedSnapshotId) {\n        ERC20SnapshotUpgradeable _poolSToken = ERC20SnapshotUpgradeable(\n          address(poolState.protectionPool)\n        );\n\n        console.log(\n          \"balance of seller: %s, total supply: %s at snapshot: %s\",\n          _poolSToken.balanceOfAt(_seller, _snapshotId),\n          _poolSToken.totalSupplyAt(_snapshotId),\n          _snapshotId\n        );\n\n        /// The claimable amount for the given seller is proportional to the seller's share of the total supply at the snapshot\n        /// claimable amount = (seller's snapshot balance / total supply at snapshot) * locked capital amount\n        _claimableUnlockedCapital =\n          (_poolSToken.balanceOfAt(_seller, _snapshotId) *\n            lockedCapital.amount) /\n          _poolSToken.totalSupplyAt(_snapshotId);\n\n        /// Update the last claimed snapshot id for the seller\n        _latestClaimedSnapshotId = _snapshotId;\n\n        console.log(\n          \"Claimable amount for seller %s is %s\",\n          _seller,\n          _claimableUnlockedCapital\n        );\n      }\n\n      unchecked {\n        ++_index;\n      }\n    }\n  }\n\n  /**\n   * @dev Returns the latest locked capital instance for a given lending pool.\n   * @param poolState The stored state of the protection pool\n   * @param _lendingPool The address of the lending pool\n   */\n  function _getLatestLockedCapital(\n    ProtectionPoolState storage poolState,\n    address _lendingPool\n  ) internal view returns (LockedCapital storage _lockedCapital) {\n    /// Return the last locked capital instance in the array\n    LockedCapital[] storage lockedCapitals = poolState.lockedCapitals[\n      _lendingPool\n    ];\n    _lockedCapital = lockedCapitals[lockedCapitals.length - 1];\n  }\n\n  /**\n   * @dev Returns the two payment periods in seconds for a given lending pool.\n   * @param poolState The stored state of the protection pool\n   * @param _lendingPool The address of the lending pool\n   * @return The two payment periods in seconds for a given lending pool\n   */\n  function _getTwoPaymentPeriodsInSeconds(\n    ProtectionPoolState storage poolState,\n    address _lendingPool\n  ) internal view returns (uint256) {\n    /// Retrieve the payment period in days for the given lending pool and convert it to seconds\n    return\n      (poolState\n        .protectionPool\n        .getPoolInfo()\n        .referenceLendingPools\n        .getPaymentPeriodInDays(_lendingPool) * 2) *\n      Constants.SECONDS_IN_DAY_UINT;\n  }\n}"
    },
    {
      "filename": "contracts/core/DefaultStateManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ERC20SnapshotUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol\";\n\nimport {UUPSUpgradeableBase} from \"../UUPSUpgradeableBase.sol\";\nimport {IReferenceLendingPools, LendingPoolStatus} from \"../interfaces/IReferenceLendingPools.sol\";\nimport {ILendingProtocolAdapter} from \"../interfaces/ILendingProtocolAdapter.sol\";\nimport {IProtectionPool} from \"../interfaces/IProtectionPool.sol\";\nimport {IDefaultStateManager, ProtectionPoolState, LockedCapital, LendingPoolStatusDetail} from \"../interfaces/IDefaultStateManager.sol\";\nimport \"../libraries/Constants.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * @title DefaultStateManager\n * @author Carapace Finance\n * @notice Contract to assess status updates and the resultant state transitions of all lending pools of all protection pools\n * @dev This contract is upgradeable using the UUPS pattern.\n */\ncontract DefaultStateManager is UUPSUpgradeableBase, IDefaultStateManager {\n  /////////////////////////////////////////////////////\n  ///             STORAGE - START                   ///\n  /////////////////////////////////////////////////////\n  /**\n   * @dev DO NOT CHANGE THE ORDER OF THESE VARIABLES ONCE DEPLOYED\n   */\n\n  /// @notice address of the contract factory which is the only contract allowed to register protection pools.\n  address public contractFactoryAddress;\n\n  /// @dev stores the current state of all protection pools in the system.\n  /// @dev Array is used for enumerating all pools during state assessment.\n  ProtectionPoolState[] private protectionPoolStates;\n\n  /// @notice tracks an index of ProtectionPoolState for each pool in protectionPoolStates array.\n  mapping(address => uint256) private protectionPoolStateIndexes;\n\n  //////////////////////////////////////////////////////\n  ///             STORAGE - END                     ///\n  /////////////////////////////////////////////////////\n\n  /*** modifiers ***/\n\n  /// @dev modifier to restrict access to the contract factory address.\n  modifier onlyContractFactory() {\n    if (msg.sender != contractFactoryAddress) {\n      revert NotContractFactory(msg.sender);\n    }\n    _;\n  }\n\n  /*** initializer ***/\n\n  /**\n   * @notice Initializes the contract.\n   */\n  function initialize() external initializer {\n    __UUPSUpgradeableBase_init();\n\n    /// create a dummy pool state to reserve index 0.\n    /// this is to ensure that protectionPoolStateIndexes[pool] is always greater than 0,\n    /// which is used to check if a pool is registered or not.\n    protectionPoolStates.push();\n  }\n\n  /*** state-changing functions ***/\n\n  /// @inheritdoc IDefaultStateManager\n  /// @dev This function is marked as payable for gas optimization.\n  function setContractFactory(address _contractFactoryAddress)\n    external\n    payable\n    override\n    onlyOwner\n  {\n    if (_contractFactoryAddress == Constants.ZERO_ADDRESS) {\n      revert ZeroContractFactoryAddress();\n    }\n\n    contractFactoryAddress = _contractFactoryAddress;\n    emit ContractFactoryUpdated(_contractFactoryAddress);\n  }\n\n  /// @inheritdoc IDefaultStateManager\n  function registerProtectionPool(address _protectionPoolAddress)\n    external\n    payable\n    override\n    onlyContractFactory\n  {\n    /// if the protection pool is already registered, revert\n    if (\n      protectionPoolStates[protectionPoolStateIndexes[_protectionPoolAddress]]\n        .updatedTimestamp > 0\n    ) {\n      revert ProtectionPoolAlreadyRegistered(_protectionPoolAddress);\n    }\n\n    /// Protection pool will be inserted at the end of the array\n    uint256 newIndex = protectionPoolStates.length;\n\n    /// Insert new empty pool state at the end of the array\n    /// and update the state\n    protectionPoolStates.push();\n    ProtectionPoolState storage poolState = protectionPoolStates[newIndex];\n    poolState.protectionPool = IProtectionPool(_protectionPoolAddress);\n\n    /// Store the index of the pool state in the array\n    protectionPoolStateIndexes[_protectionPoolAddress] = newIndex;\n\n    /// Assess the state of the newly registered protection pool\n    _assessState(poolState);\n\n    emit ProtectionPoolRegistered(_protectionPoolAddress);\n  }\n\n  /// @inheritdoc IDefaultStateManager\n  function assessStates() external override {\n    /// gas optimizations:\n    /// 1. capture length in memory & don't read from storage for each iteration\n    /// 2. uncheck incrementing pool index\n    uint256 _length = protectionPoolStates.length;\n\n    /// assess the state of all registered protection pools except the dummy pool at index 0\n    for (uint256 _poolIndex = 1; _poolIndex < _length; ) {\n      _assessState(protectionPoolStates[_poolIndex]);\n      unchecked {\n        ++_poolIndex;\n      }\n    }\n\n    emit ProtectionPoolStatesAssessed();\n  }\n\n  /// @inheritdoc IDefaultStateManager\n  function assessStateBatch(address[] calldata _pools) external override {\n    uint256 _length = _pools.length;\n    for (uint256 _poolIndex; _poolIndex < _length; ) {\n      /// Get the state of the pool by looking up the index in the mapping from the given pool address\n      ProtectionPoolState storage poolState = protectionPoolStates[\n        protectionPoolStateIndexes[_pools[_poolIndex]]\n      ];\n\n      /// Only assess the state if the protection pool is registered\n      if (poolState.updatedTimestamp > 0) {\n        _assessState(poolState);\n      }\n\n      unchecked {\n        ++_poolIndex;\n      }\n    }\n  }\n\n  /// @inheritdoc IDefaultStateManager\n  /// @dev This method is only callable by a protection pool\n  function calculateAndClaimUnlockedCapital(address _seller)\n    external\n    override\n    returns (uint256 _claimedUnlockedCapital)\n  {\n    /// Get the state of the pool by looking up the index in the mapping from sender address\n    ProtectionPoolState storage poolState = protectionPoolStates[\n      protectionPoolStateIndexes[msg.sender]\n    ];\n\n    /// Only assess the state if the protection pool is registered\n    if (poolState.updatedTimestamp == 0) {\n      revert ProtectionPoolNotRegistered(msg.sender);\n    }\n\n    /// Get the list of all lending pools for the protection pool\n    address[] memory _lendingPools = poolState\n      .protectionPool\n      .getPoolInfo()\n      .referenceLendingPools\n      .getLendingPools();\n\n    /// Iterate through all lending pools for a given protection pool\n    /// and calculate the total claimable amount for the seller\n    uint256 _length = _lendingPools.length;\n    for (uint256 _lendingPoolIndex; _lendingPoolIndex < _length; ) {\n      address _lendingPool = _lendingPools[_lendingPoolIndex];\n\n      /// Calculate the claimable amount across all the locked capital instances for a given protection pool\n      (\n        uint256 _unlockedCapitalPerLendingPool,\n        uint256 _snapshotId\n      ) = _calculateClaimableAmount(poolState, _lendingPool, _seller);\n      _claimedUnlockedCapital += _unlockedCapitalPerLendingPool;\n\n      /// update the last claimed snapshot id for the seller for the given lending pool,\n      /// so that the next time the seller claims, the calculation starts from the last claimed snapshot id\n      poolState.lastClaimedSnapshotIds[_lendingPool][_seller] = _snapshotId;\n\n      unchecked {\n        ++_lendingPoolIndex;\n      }\n    }\n  }\n\n  /** view functions */\n\n  /**\n   * @notice Returns the timestamp of the protection pool state update.\n   */\n  function getPoolStateUpdateTimestamp(address _pool)\n    external\n    view\n    returns (uint256)\n  {\n    return\n      protectionPoolStates[protectionPoolStateIndexes[_pool]].updatedTimestamp;\n  }\n\n  /**\n   * @notice Returns the list of locked capital instances for a given protection pool and lending pool.\n   */\n  function getLockedCapitals(address _protectionPool, address _lendingPool)\n    external\n    view\n    returns (LockedCapital[] memory _lockedCapitals)\n  {\n    ProtectionPoolState storage poolState = protectionPoolStates[\n      protectionPoolStateIndexes[_protectionPool]\n    ];\n    _lockedCapitals = poolState.lockedCapitals[_lendingPool];\n  }\n\n  /// @inheritdoc IDefaultStateManager\n  function calculateClaimableUnlockedAmount(\n    address _protectionPool,\n    address _seller\n  ) external view override returns (uint256 _claimableUnlockedCapital) {\n    ProtectionPoolState storage poolState = protectionPoolStates[\n      protectionPoolStateIndexes[_protectionPool]\n    ];\n\n    /// Calculate the claimable amount only if the protection pool is registered\n    if (poolState.updatedTimestamp > 0) {\n      /// Get the list of all lending pools for the protection pool\n      address[] memory _lendingPools = poolState\n        .protectionPool\n        .getPoolInfo()\n        .referenceLendingPools\n        .getLendingPools();\n\n      /// Iterate through all lending pools for a given protection pool\n      /// and calculate the total claimable amount for the seller\n      uint256 _length = _lendingPools.length;\n      for (uint256 _lendingPoolIndex; _lendingPoolIndex < _length; ) {\n        address _lendingPool = _lendingPools[_lendingPoolIndex];\n\n        /// Calculate the claimable amount across all the locked capital instances for a given protection pool\n        (uint256 _unlockedCapitalPerLendingPool, ) = _calculateClaimableAmount(\n          poolState,\n          _lendingPool,\n          _seller\n        );\n\n        /// add the unlocked/claimable amount for the given lending pool to the total claimable amount\n        _claimableUnlockedCapital += _unlockedCapitalPerLendingPool;\n\n        unchecked {\n          ++_lendingPoolIndex;\n        }\n      }\n    }\n  }\n\n  /// @inheritdoc IDefaultStateManager\n  function getLendingPoolStatus(\n    address _protectionPoolAddress,\n    address _lendingPoolAddress\n  ) external view override returns (LendingPoolStatus) {\n    return\n      protectionPoolStates[protectionPoolStateIndexes[_protectionPoolAddress]]\n        .lendingPoolStateDetails[_lendingPoolAddress]\n        .currentStatus;\n  }\n\n  /** internal functions */\n\n  /**\n   * @dev assess the state of a given protection pool and\n   * update state changes & initiate related actions as needed.\n   */\n  function _assessState(ProtectionPoolState storage poolState) internal {\n    poolState.updatedTimestamp = block.timestamp;\n\n    /// assess the state of all reference lending pools of this protection pool\n    (\n      address[] memory _lendingPools,\n      LendingPoolStatus[] memory _currentStatuses\n    ) = poolState\n        .protectionPool\n        .getPoolInfo()\n        .referenceLendingPools\n        .assessState();\n\n    /// Compare previous and current status of each lending pool and perform the required state transition\n    uint256 _length = _lendingPools.length;\n    for (uint256 _lendingPoolIndex; _lendingPoolIndex < _length; ) {\n      /// Get the lending pool state details\n      address _lendingPool = _lendingPools[_lendingPoolIndex];\n      LendingPoolStatusDetail storage lendingPoolStateDetail = poolState\n        .lendingPoolStateDetails[_lendingPool];\n\n      /// Get the previous and current status of the lending pool\n      LendingPoolStatus _previousStatus = lendingPoolStateDetail.currentStatus;\n      LendingPoolStatus _currentStatus = _currentStatuses[_lendingPoolIndex];\n\n      if (_previousStatus != _currentStatus) {\n        console.log(\n          \"DefaultStateManager: Lending pool %s status is changed from %s to  %s\",\n          _lendingPool,\n          uint256(_previousStatus),\n          uint256(_currentStatus)\n        );\n      }\n\n      /// State transition 1: Active or LateWithinGracePeriod -> Late\n      if (\n        (_previousStatus == LendingPoolStatus.Active ||\n          _previousStatus == LendingPoolStatus.LateWithinGracePeriod) &&\n        _currentStatus == LendingPoolStatus.Late\n      ) {\n        /// Update the current status of the lending pool to Late\n        /// and move the lending pool to the locked state\n        lendingPoolStateDetail.currentStatus = LendingPoolStatus.Late;\n        _moveFromActiveToLockedState(poolState, _lendingPool);\n\n        /// Capture the timestamp when the lending pool became late\n        lendingPoolStateDetail.lateTimestamp = block.timestamp;\n      } else if (_previousStatus == LendingPoolStatus.L"
    }
  ]
}