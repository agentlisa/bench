{
  "Title": "[H-31] Collateral can be locked in BigBang contract when `debtStartPoint` is nonzero",
  "Content": "\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/Penrose.sol#L395-L397> \n\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/bigBang/BigBang.sol#L242-L255> \n\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/bigBang/BigBang.sol#L180-L201> \n\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/bigBang/BigBang.sol#L512-L520> \n\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/bigBang/BigBang.sol#L309-L317> \n\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/bigBang/BigBang.sol#L263-L271>\n\nFollowing conditions have to be met for this issue to happen:\n\n*   This issue occurs when the BigBang market is not an ETH market.\n*   `Penrose.registerBigBang()` being called with `data` param where `data.debtStartPoint` is nonzero.\n*   The first borrower borrows using `BigBang.borrow()`, with function param `amount` (borrow amount) has to be less than `debtStartPoint`.\n\nNow `BigBang.getDebtRate()` will always revert and the collateral from the first borrower is locked, because `BigBang.getDebtRate()` is used in `BigBang._accrue()`, and `BigBang._accrue()` is used in every function that involves totalBorrow like in `BigBang.liquidate()`, `BigBang.repay()`.\n\nThe reason for the revert is that in `BigBang.getDebtRate()`, `totalBorrow.elastic` which gets assigned to the variable `_currentDebt` (line 186 BigBang.sol) will not be 0, and then on line 192 in the BigBang contract, the `_currentDebt` is smaller than `debtStartPoint` which causes the revert.\n\nAs a consequence the collateral is trapped as repay or liquidate requires to call accrue before hand.\n\n### Proof of Concept\n\nThe following gist contains a proof of concept to demonstrate this issue.\nA non-ETH bigbang market (wbtc market) is deployed with `Penrose::registerBigBang`. Note that the `debtStartPoint` parameter in the init data is non-zero (set to be 1e18).\n\nFirst we set up the primary eth market:\nSome weth is minted and deposited to the ETH market. Then some assets were borrowed against the collateral. This is necessary condition for this bug to happen, which is the ETH market to have some borrowed asset. However, this condition is very likely to be fulfilled, as the primary ETH market would be deployed before any non-eth market.\n\nNow, an innocent user is adding collateral and borrows in the non-eth market (the wbtc market). The issue occurs when the user borrows less than the `debtStartPoint`. If the user should borrow less than the `debtStartPoint`, the `BigBang::accrue` will revert and the collateral is trapped in this Market.\n\n<https://gist.github.com/zzzitron/a6d6377b73130819f15f1e5a2e2a2ba9>\n\nThe bug happens here in the line 192 in the `BigBang`.\n\n```solidity\n179     /// @notice returns the current debt rate\n180     function getDebtRate() public view returns (uint256) {                                                                        \n181         if (_isEthMarket) return penrose.bigBangEthDebtRate(); // default 0.5%                                                    \n182         if (totalBorrow.elastic == 0) return minDebtRate;                                                                         \n183         \n184         uint256 _ethMarketTotalDebt = BigBang(penrose.bigBangEthMarket())                                                         \n185             .getTotalDebt();                                                                                                      \n186         uint256 _currentDebt = totalBorrow.elastic;\n187         uint256 _maxDebtPoint = (_ethMarketTotalDebt *                                                                            \n188             debtRateAgainstEthMarket) / 1e18;                                                                                     \n189 \n190         if (_currentDebt >= _maxDebtPoint) return maxDebtRate;\n191 \n192         uint256 debtPercentage = ((_currentDebt - debtStartPoint) *\n193             DEBT_PRECISION) / (_maxDebtPoint - debtStartPoint);\n194         uint256 debt = ((maxDebtRate - minDebtRate) * debtPercentage) /\n195             DEBT_PRECISION +\n196             minDebtRate;\n197 \n```\n\n### Recommended Mitigation Steps\n\nConsider adding a require statement to `BigBang.borrow()` to make sure that the borrow amount has to be >= `debtStartPoint`.\n\n```solidity\n// BigBang\n// borrow\n247        require(amount >= debtStartPoint);\n```\n\n**[0xRektora (Tapioca) confirmed](https://github.com/code-423n4/2023-07-tapioca-findings/issues/1046#issuecomment-1701699307)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-tapioca",
  "Code": [
    {
      "filename": "contracts/Penrose.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/BoringFactory.sol\";\n\nimport \"tapioca-sdk/dist/contracts/YieldBox/contracts/YieldBox.sol\";\nimport \"tapioca-sdk/dist/contracts/YieldBox/contracts/interfaces/IYieldBox.sol\";\nimport \"tapioca-sdk/dist/contracts/YieldBox/contracts/strategies/ERC20WithoutStrategy.sol\";\nimport \"tapioca-periph/contracts/interfaces/ISingularity.sol\";\nimport \"tapioca-periph/contracts/interfaces/IPenrose.sol\";\n\n/*\n\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\n\n*/\n\n/// @title Global market registry\n/// @notice Singularity & BigBang management\n/// @dev owner of all Singularity & BigBang markets\n///     - can execute actions on the registered markets\n///     - also holds information about the common properties that are used by those markets\ncontract Penrose is BoringOwnable, BoringFactory {\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    /// @notice returns the Conservator address\n    address public conservator;\n    /// @notice returns the pause state of the contract\n    bool public paused;\n    /// @notice returns the YieldBox contract\n    YieldBox public immutable yieldBox;\n    /// @notice returns the TAP contract\n    IERC20 public immutable tapToken;\n    /// @notice returns TAP asset id registered in the YieldBox contract\n    uint256 public immutable tapAssetId;\n    /// @notice returns USDO contract\n    IERC20 public usdoToken;\n    /// @notice returns USDO asset id registered in the YieldBox contract\n    uint256 public usdoAssetId;\n    /// @notice returns the WETH contract\n    IERC20 public immutable wethToken;\n    /// @notice returns WETH asset id registered in the YieldBox contract\n    uint256 public immutable wethAssetId;\n\n    /// @notice Singularity master contracts\n    IPenrose.MasterContract[] public singularityMasterContracts;\n    /// @notice BigBang master contracts\n    IPenrose.MasterContract[] public bigbangMasterContracts;\n\n    // Used to check if a Singularity master contract is registered\n    mapping(address => bool) public isSingularityMasterContractRegistered;\n    // Used to check if a BigBang master contract is registered\n    mapping(address => bool) public isBigBangMasterContractRegistered;\n    // Used to check if a SGL/BB is a real market\n    mapping(address => bool) public isMarketRegistered;\n\n    /// @notice protocol fees\n    address public feeTo;\n\n    /// @notice whitelisted swappers\n    mapping(ISwapper => bool) public swappers;\n\n    /// @notice BigBang ETH market address\n    address public bigBangEthMarket;\n    /// @notice BigBang ETH market debt rate\n    uint256 public bigBangEthDebtRate;\n\n    /// @notice registered empty strategies\n    mapping(address => IStrategy) public emptyStrategies;\n\n    /// @notice creates a Penrose contract\n    /// @param _yieldBox YieldBox contract address\n    /// @param tapToken_ TapOFT contract address\n    /// @param wethToken_ WETH contract address\n    /// @param _owner owner address\n    constructor(\n        YieldBox _yieldBox,\n        IERC20 tapToken_,\n        IERC20 wethToken_,\n        address _owner\n    ) {\n        yieldBox = _yieldBox;\n        tapToken = tapToken_;\n        owner = _owner;\n\n        emptyStrategies[address(tapToken_)] = IStrategy(\n            address(\n                new ERC20WithoutStrategy(\n                    IYieldBox(address(_yieldBox)),\n                    tapToken_\n                )\n            )\n        );\n        tapAssetId = uint96(\n            _yieldBox.registerAsset(\n                TokenType.ERC20,\n                address(tapToken_),\n                emptyStrategies[address(tapToken_)],\n                0\n            )\n        );\n\n        wethToken = wethToken_;\n        emptyStrategies[address(wethToken_)] = IStrategy(\n            address(\n                new ERC20WithoutStrategy(\n                    IYieldBox(address(_yieldBox)),\n                    wethToken_\n                )\n            )\n        );\n        wethAssetId = uint96(\n            _yieldBox.registerAsset(\n                TokenType.ERC20,\n                address(wethToken_),\n                emptyStrategies[address(wethToken_)],\n                0\n            )\n        );\n\n        bigBangEthDebtRate = 5e15;\n    }\n\n    // **************//\n    // *** EVENTS *** //\n    // ************** //\n    /// @notice event emitted when fees are extracted\n    event ProtocolWithdrawal(IMarket[] markets, uint256 timestamp);\n    /// @notice event emitted when Singularity master contract is registered\n    event RegisterSingularityMasterContract(\n        address location,\n        IPenrose.ContractType risk\n    );\n    /// @notice event emitted when BigBang master contract is registered\n    event RegisterBigBangMasterContract(\n        address location,\n        IPenrose.ContractType risk\n    );\n    /// @notice event emitted when Singularity is registered\n    event RegisterSingularity(address location, address masterContract);\n    /// @notice event emitted when BigBang is registered\n    event RegisterBigBang(address location, address masterContract);\n    /// @notice event emitted when feeTo address is updated\n    event FeeToUpdate(address newFeeTo);\n    /// @notice event emitted when ISwapper address is updated\n    event SwapperUpdate(address swapper, bool isRegistered);\n    /// @notice event emitted when USDO address is updated\n    event UsdoTokenUpdated(address indexed usdoToken, uint256 assetId);\n    /// @notice event emitted when conservator is updated\n    event ConservatorUpdated(address indexed old, address indexed _new);\n    /// @notice event emitted when pause state is updated\n    event PausedUpdated(bool oldState, bool newState);\n    /// @notice event emitted when BigBang ETH market address is updated\n    event BigBangEthMarketSet(address indexed _newAddress);\n    /// @notice event emitted when BigBang ETH market debt rate is updated\n    event BigBangEthMarketDebtRate(uint256 _rate);\n    /// @notice event emitted when fees are deposited to YieldBox\n    event LogYieldBoxFeesDeposit(uint256 feeShares, uint256 ethAmount);\n\n    // ******************//\n    // *** MODIFIERS *** //\n    // ***************** //\n    modifier registeredSingularityMasterContract(address mc) {\n        require(\n            isSingularityMasterContractRegistered[mc] == true,\n            \"Penrose: MC not registered\"\n        );\n        _;\n    }\n\n    modifier registeredBigBangMasterContract(address mc) {\n        require(\n            isBigBangMasterContractRegistered[mc] == true,\n            \"Penrose: MC not registered\"\n        );\n        _;\n    }\n\n    modifier notPaused() {\n        require(!paused, \"Penrose: paused\");\n        _;\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice Get all the Singularity contract addresses\n    /// @return markets list of available markets\n    function singularityMarkets()\n        public\n        view\n        returns (address[] memory markets)\n    {\n        markets = _getMasterContractLength(singularityMasterContracts);\n    }\n\n    /// @notice Get all the BigBang contract addresses\n    /// @return markets list of available markets\n    function bigBangMarkets() public view returns (address[] memory markets) {\n        markets = _getMasterContractLength(bigbangMasterContracts);\n    }\n\n    /// @notice Get the length of `singularityMasterContracts`\n    function singularityMasterContractLength() public view returns (uint256) {\n        return singularityMasterContracts.length;\n    }\n\n    /// @notice Get the length of `bigbangMasterContracts`\n    function bigBangMasterContractLength() public view returns (uint256) {\n        return bigbangMasterContracts.length;\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice Loop through the master contracts and call `_depositFeesToYieldBox()` to each one of their clones.\n    /// @dev `swappers_` can have one element that'll be used for all clones. Or one swapper per MasterContract.\n    /// @dev Fees are withdrawn in TAP and sent to the FeeDistributor contract\n    /// @param markets_ Singularity &/ BigBang markets array\n    /// @param swappers_ one or more swappers to convert the asset to TAP.\n    /// @param swapData_ swap data for each swapper\n    function withdrawAllMarketFees(\n        IMarket[] calldata markets_,\n        ISwapper[] calldata swappers_,\n        IPenrose.SwapData[] calldata swapData_\n    ) public notPaused {\n        require(\n            markets_.length == swappers_.length &&\n                swappers_.length == swapData_.length,\n            \"Penrose: length mismatch\"\n        );\n        require(address(swappers_[0]) != address(0), \"Penrose: zero address\");\n        require(address(markets_[0]) != address(0), \"Penrose: zero address\");\n\n        _withdrawAllProtocolFees(swappers_, swapData_, markets_);\n\n        emit ProtocolWithdrawal(markets_, block.timestamp);\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    /// @notice sets the main BigBang market debt rate\n    /// @dev can only be called by the owner\n    /// @param _rate the new rate\n    function setBigBangEthMarketDebtRate(uint256 _rate) external onlyOwner {\n        bigBangEthDebtRate = _rate;\n        emit BigBangEthMarketDebtRate(_rate);\n    }\n\n    /// @notice sets the main BigBang market\n    /// @dev needed for the variable debt computation\n    function setBigBangEthMarket(address _market) external onlyOwner {\n        bigBangEthMarket = _market;\n        emit BigBangEthMarketSet(_market);\n    }\n\n    /// @notice updates the pause state of the contract\n    /// @dev can only be called by the conservator\n    /// @param val the new value\n    function updatePause(bool val) external {\n        require(msg.sender == conservator, \"Penrose: unauthorized\");\n        require(val != paused, \"Penrose: same state\");\n        emit PausedUpdated(paused, val);\n        paused = val;\n    }\n\n    /// @notice Set the Conservator address\n    /// @dev Conservator can pause the contract\n    /// @param _conservator The new address\n    function setConservator(address _conservator) external onlyOwner {\n        require(_conservator != address(0), \"Penrose: address not valid\");\n        emit ConservatorUpdated(conservator, _conservator);\n        conservator = _conservator;\n    }\n\n    /// @notice Set the USDO token\n    /// @dev sets usdoToken and usdoAssetId\n    ///      can only by called by the owner\n    /// @param _usdoToken the USDO token address\n    function setUsdoToken(address _usdoToken) external onlyOwner {\n        usdoToken = IERC20(_usdoToken);\n\n        emptyStrategies[_usdoToken] = IStrategy(\n            address(\n                new ERC20WithoutStrategy(\n                    IYieldBox(address(yieldBox)),\n                    IERC20(_usdoToken)\n                )\n            )\n        );\n        usdoAssetId = uint96(\n            yieldBox.registerAsset(\n                TokenType.ERC20,\n                _usdoToken,\n                emptyStrategies[_usdoToken],\n                0\n            )\n        );\n        emit UsdoTokenUpdated(_usdoToken, usdoAssetId);\n    }\n\n    /// @notice Register a Singularity master contract\n    /// @dev can only be called by the owner\n    /// @param mcAddress The address of the contract\n    /// @param contractType_ The risk type of the contract\n    function registerSingularityMasterContract(\n        address mcAddress,\n        IPenrose.ContractType contractType_\n    ) external onlyOwner {\n        require(\n            isSingularityMasterContractRegistered[mcAddress] == false,\n            \"Penrose: MC registered\"\n        );\n\n        IPenrose.MasterContract memory mc;\n        mc.location = mcAddress;\n        mc.risk = contractType_;\n        singularityMasterContracts.push(mc);\n        isSingularityMasterContractRegistered[mcAddress] = true;\n\n        emit RegisterSingularityMasterContract(mcAddress, contractType_);\n    }\n\n    /// @notice Register a BigBang master contract\n    /// @dev can only be called by the owner\n    /// @param mcAddress The address of the contract\n    /// @param contractType_ The risk type of the contract\n    function registerBigBangMasterContract(\n        address mcAddress,\n        IPenrose.ContractType contractType_\n    ) external onlyOwner {\n        require(\n            isBigBangMasterContractRegistered[mcAddress] == false,\n            \"Penrose: MC registered\"\n        );\n\n        IPenrose.MasterContract memory mc;\n        mc.location = mcAddress;\n        mc.risk = contractType_;\n        bigbangMasterContracts.push(mc);\n        isBigBangMasterContractRegistered[mcAddress] = true;\n\n        emit RegisterBigBangMasterContract(mcAddress, contractType_);\n    }\n\n    /// @notice Registers a Singularity market\n    /// @dev can only be called by the owner\n    /// @param mc The address of the master contract which must be already registered\n    /// @param data The init data of the Singularity\n    /// @param useCreate2 Whether to use create2 or not\n    function registerSingularity(\n        address mc,\n        bytes calldata data,\n        bool useCreate2\n    )\n        external\n        payable\n        onlyOwner\n        registeredSingularityMasterContract(mc)\n        returns (address _contract)\n    {\n        _contract = deploy(mc, data, useCreate2);\n        isMarketRegistered[_contract] = true;\n        emit RegisterSingularity(_contract, mc);\n    }\n\n    /// @notice Registers an existing Singularity market (without deployment)\n    /// @dev can only be called by the owner\n    /// @param mc The address of the master contract which must be already registered\n    function addSingularity(\n        address mc,\n        address _contract\n    ) external onlyOwner registeredSingularityMasterContract(mc) {\n        isMarketRegistered[_contract] = true;\n        clonesOf[mc].push(_contract);\n        emit RegisterSingularity(_contract, mc);\n    }\n\n    /// @notice Registers a BigBang market\n    /// @dev can only be called by the owner\n    /// @param mc The address of the master contract which must be already registered\n    /// @param data The init data of the BigBang contract\n    /// @param useCreate2 Whether to use create2 or not\n    function registerBigBang(\n        address mc,\n        bytes calldata data,\n        bool useCreate2\n    )\n        external\n        payable\n        onlyOwner\n        registeredBigBangMasterContract(mc)\n        returns (address _contract)\n    {\n        _contract = deploy(mc, data, useCreate2);\n        isMarketRegistered[_contract] = true;\n        emit RegisterBigBang(_contract, mc);\n    }\n\n    /// @notice Registers an existing BigBang market (without deployment)\n    /// @dev can only be called by the owner\n    /// @param mc The address of the master contract which must be already registered\n    function addBigBang(\n        address mc,\n        address _contract\n    ) external onlyOwner registeredBigBangMasterContract(mc) {\n        isMarketRegistered[_contract] = true;\n        clonesOf[mc].push(_contract);\n        emit RegisterBigBang(_contract, mc);\n    }\n\n    /// @notice Execute an only owner function inside of a Singularity or a BigBang market\n    function executeMarketFn(\n        address[] calldata mc,\n        bytes[] memory data,\n        bool forceSuccess\n    )\n        external\n        onlyOwner\n        notPaused\n        returns (bool[] memory success, bytes[] memory result)\n    {\n        uint256 len = mc.length;\n        success = new bool[](len);\n        result = new bytes[](len);\n        for (uint256 i = 0; i < len; ) {\n            require(\n                isSingularityMasterContractRegistered[\n                    masterContractOf[mc[i]]\n                ] || isBigBangMasterContractRegistered[masterContractOf[mc[i]]],\n                \"Penrose: MC not registered\"\n            );\n            (success[i], result[i]) = mc[i].call(data[i]);\n            if (forceSuccess) {\n                require(success[i], _getRevertMsg(result[i]));\n            }\n            ++i;\n        }\n    }\n\n    /// @notice Set protocol fees address\n    /// @dev can only be called by the owner\n    /// @param feeTo_ the new feeTo address\n    function setFeeTo(address feeTo_) external onlyOwner {\n        feeTo = feeTo_;\n        emit FeeToUpdate(feeTo_);\n    }\n\n    /// @notice Used to register and enable or disable swapper contracts used in closed liquidations.\n    /// @dev can only be called by the owner\n    /// @param swapper The address of the swapper contract that conforms to `ISwapper`.\n    /// @param enable True to enable the swapper. To disable use False.\n    function setSwapper(ISwapper swapper, bool enable) external onlyOwner {\n        swappers[swapper] = enable;\n        emit SwapperUpdate(address(swapper), enable);\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _getRevertMsg(\n        bytes memory _returnData\n    ) private pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"SGL: no return data\";\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n\n    function _withdrawAllProtocolFees(\n        ISwapper[] calldata swappers_,\n        IPenrose.SwapData[] calldata swapData_,\n        IMarket[] memory markets_\n    ) private {\n        uint256 length = markets_.length;\n        unchecked {\n            for (uint256 i = 0; i < length; ) {\n                _depositFeesToYieldBox(markets_[i], swappers_[i], swapData_[i]);\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Withdraw the balance of `feeTo`, swap asset into TAP and deposit it to yieldBox of `feeTo`\n    function _depositFeesToYieldBox(\n        IMarket market,\n        ISwapper swapper,\n        IPenrose.SwapData calldata dexData\n    ) private {\n        require(swappers[swapper], \"Penrose: Invalid swapper\");\n        require(isMarketRegistered[address(market)], \"Penrose: Invalid market\");\n\n        uint256 feeShares = market.refreshPenroseFees(feeTo);\n        if (feeShares == 0) return;\n\n        uint256 assetId = market.assetId();\n        uint256 amount = 0;\n        if (assetId != wethAssetId) {\n            yieldBox.transfer(\n                address(this),\n                address(swapper),\n                assetId,\n                feeShares\n            );\n\n            ISwapper.SwapData memory swapData = swapper.buildSwapData(\n                assetId,\n                wethAssetId,\n                0,\n                feeShares,\n                true,\n                true\n            );\n            (amount, ) = swapper.swap(\n                swapData,\n                dexData.minAssetAmount,\n                feeTo,\n                \"\"\n            );\n        } else {\n            yieldBox.transfer(address(this), feeTo, assetId, feeShares);\n        }\n\n        emit LogYieldBoxFeesDeposit(feeShares, amount);\n    }\n\n    function _getMasterContractLength(\n        IPenrose.MasterContract[] memory array\n    ) public view returns (address[] memory markets) {\n        uint256 _masterContractLength = array.length;\n        uint256 marketsLength = 0;\n\n        unchecked {\n            // We first compute the length of the markets array\n            for (uint256 i = 0; i < _masterContractLength; ) {\n                marketsLength += clonesOfCount(array[i].location);\n\n                ++i;\n            }\n        }\n\n        markets = new address[](marketsLength);\n\n        uint256 marketIndex;\n        uint256 clonesOfLength;\n\n        unchecked {\n            // We populate the array\n            for (uint256 i = 0; i < _masterContractLength; ) {\n                address mcLocation = array[i].location;\n                clonesOfLength = clonesOfCount(mcLocation);\n\n                // Loop through clones of the current MC.\n                for (uint256 j = 0; j < clonesOfLength; ) {\n                    markets[marketIndex] = clonesOf[mcLocation][j];\n                    ++marketIndex;\n                    ++j;\n                }\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/markets/bigBang/BigBang.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\n\nimport \"tapioca-periph/contracts/interfaces/IBigBang.sol\";\nimport \"tapioca-periph/contracts/interfaces/ISendFrom.sol\";\nimport \"tapioca-periph/contracts/interfaces/ISwapper.sol\";\nimport {IUSDOBase} from \"tapioca-periph/contracts/interfaces/IUSDO.sol\";\n\nimport \"../Market.sol\";\n\n// solhint-disable max-line-length\n/*\n\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\n\n*/\n\n/// @title BigBang market\n/// @notice Adaptation of the Singularity contract\n/// @dev owner of the contract is Penrose\n///     - the borrow action performs a mint on USDO\n///     - the repay action performs a burn on USDO\n///     - interest rate is not fixed, but dynamic based on the main BigBang market, minDebtRate, maxDebtRate and debtRateAgainstEthMarket\n///         - BigBang markets can either be main or secondary markets; the main market is set on Penrose and has a fixed rate\n///         - BigBang secondary markets has a dynamic interest rate which is starts from `minDebtRate` to `maxDebtRate`\n///             - if current debt is over _maxDebtPoint = (_ethMarketTotalDebt * debtRateAgainstEthMarket) / 1e18, the interest rate is automatically `maxDebtRate`\n///         - simulation: https://dotnetfiddle.net/cuKVpf\ncontract BigBang is BoringOwnable, Market {\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    mapping(address => mapping(address => bool)) public operators;\n\n    IBigBang.AccrueInfo public accrueInfo;\n\n    uint256 public totalFees;\n\n    bool private _isEthMarket;\n    uint256 public maxDebtRate;\n    uint256 public minDebtRate;\n    uint256 public debtRateAgainstEthMarket;\n    uint256 public debtStartPoint;\n    uint256 private constant DEBT_PRECISION = 1e18;\n\n    // ************** //\n    // *** EVENTS *** //\n    // ************** //\n    /// @notice event emitted when accrue is called\n    event LogAccrue(uint256 accruedAmount, uint64 rate);\n    /// @notice event emitted when collateral is added\n    event LogAddCollateral(\n        address indexed from,\n        address indexed to,\n        uint256 share\n    );\n    /// @notice event emitted when collateral is removed\n    event LogRemoveCollateral(\n        address indexed from,\n        address indexed to,\n        uint256 share\n    );\n    /// @notice event emitted when borrow is performed\n    event LogBorrow(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        uint256 feeAmount,\n        uint256 part\n    );\n    /// @notice event emitted when a repay operation is performed\n    event LogRepay(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        uint256 part\n    );\n    /// @notice event emitted when the minimum debt rate is updated\n    event MinDebtRateUpdated(uint256 oldVal, uint256 newVal);\n    /// @notice event emitted when the maximum debt rate is updated\n    event MaxDebtRateUpdated(uint256 oldVal, uint256 newVal);\n    /// @notice event emitted when the debt rate against the main market is updated\n    event DebtRateAgainstEthUpdated(uint256 oldVal, uint256 newVal);\n\n    constructor() MarketERC20(\"Tapioca BigBang\") {}\n\n    /// @notice The init function that acts as a constructor\n    function init(bytes calldata data) external onlyOnce {\n        (\n            IPenrose tapiocaBar_,\n            IERC20 _collateral,\n            uint256 _collateralId,\n            IOracle _oracle,\n            uint256 _exchangeRatePrecision,\n            uint256 _debtRateAgainstEth,\n            uint256 _debtRateMin,\n            uint256 _debtRateMax,\n            uint256 _debtStartPoint\n        ) = abi.decode(\n                data,\n                (\n                    IPenrose,\n                    IERC20,\n                    uint256,\n                    IOracle,\n                    uint256,\n                    uint256,\n                    uint256,\n                    uint256,\n                    uint256\n                )\n            );\n\n        penrose = tapiocaBar_;\n        yieldBox = YieldBox(tapiocaBar_.yieldBox());\n        owner = address(penrose);\n\n        address _asset = penrose.usdoToken();\n\n        require(\n            address(_collateral) != address(0) &&\n                address(_asset) != address(0) &&\n                address(_oracle) != address(0),\n            \"BigBang: bad pair\"\n        );\n\n        asset = IERC20(_asset);\n        assetId = penrose.usdoAssetId();\n        collateral = _collateral;\n        collateralId = _collateralId;\n        oracle = _oracle;\n\n        updateExchangeRate();\n\n        callerFee = 90000; // 90%\n        protocolFee = 10000; // 10%\n        collateralizationRate = 75000; // 75%\n\n        EXCHANGE_RATE_PRECISION = _exchangeRatePrecision > 0\n            ? _exchangeRatePrecision\n            : 1e18;\n\n        _isEthMarket = collateralId == penrose.wethAssetId();\n        if (!_isEthMarket) {\n            debtRateAgainstEthMarket = _debtRateAgainstEth;\n            maxDebtRate = _debtRateMax;\n            minDebtRate = _debtRateMin;\n            debtStartPoint = _debtStartPoint;\n        }\n\n        minLiquidatorReward = 1e3;\n        maxLiquidatorReward = 1e4;\n        liquidationBonusAmount = 1e4;\n        borrowOpeningFee = 50; // 0.05%\n        liquidationMultiplier = 12000; //12%\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice returns total market debt\n    function getTotalDebt() external view returns (uint256) {\n        return totalBorrow.elastic;\n    }\n\n    /// @notice returns the current debt rate\n    function getDebtRate() public view returns (uint256) {\n        if (_isEthMarket) return penrose.bigBangEthDebtRate(); // default 0.5%\n        if (totalBorrow.elastic == 0) return minDebtRate;\n\n        uint256 _ethMarketTotalDebt = BigBang(penrose.bigBangEthMarket())\n            .getTotalDebt();\n        uint256 _currentDebt = totalBorrow.elastic;\n        uint256 _maxDebtPoint = (_ethMarketTotalDebt *\n            debtRateAgainstEthMarket) / 1e18;\n\n        if (_currentDebt >= _maxDebtPoint) return maxDebtRate;\n\n        uint256 debtPercentage = ((_currentDebt - debtStartPoint) *\n            DEBT_PRECISION) / (_maxDebtPoint - debtStartPoint);\n        uint256 debt = ((maxDebtRate - minDebtRate) * debtPercentage) /\n            DEBT_PRECISION +\n            minDebtRate;\n\n        if (debt > maxDebtRate) return maxDebtRate;\n\n        return debt;\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice Allows batched call to BingBang.\n    /// @param calls An array encoded call data.\n    /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.\n    function execute(\n        bytes[] calldata calls,\n        bool revertOnFail\n    ) external returns (bool[] memory successes, string[] memory results) {\n        successes = new bool[](calls.length);\n        results = new string[](calls.length);\n        for (uint256 i = 0; i < calls.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(\n                calls[i]\n            );\n            require(success || !revertOnFail, _getRevertMsg(result));\n            successes[i] = success;\n            results[i] = _getRevertMsg(result);\n        }\n    }\n\n    /// @notice allows 'operator' to act on behalf of the sender\n    /// @param status true/false\n    function updateOperator(address operator, bool status) external {\n        operators[msg.sender][operator] = status;\n    }\n\n    /// @notice Accrues the interest on the borrowed tokens and handles the accumulation of fees.\n    function accrue() public {\n        _accrue();\n    }\n\n    /// @notice Sender borrows `amount` and transfers it to `to`.\n    /// @param from Account to borrow for.\n    /// @param to The receiver of borrowed tokens.\n    /// @param amount Amount to borrow.\n    /// @return part Total part of the debt held by borrowers.\n    /// @return share Total amount in shares borrowed.\n    function borrow(\n        address from,\n        address to,\n        uint256 amount\n    ) public notPaused solvent(from) returns (uint256 part, uint256 share) {\n        uint256 allowanceShare = _computeAllowanceAmountInAsset(\n            from,\n            exchangeRate,\n            amount,\n            asset.safeDecimals()\n        );\n        _allowedBorrow(from, allowanceShare);\n        (part, share) = _borrow(from, to, amount);\n    }\n\n    /// @notice Repays a loan.\n    /// @dev The bool param is not used but we added it to respect the ISingularity interface for MarketsHelper compatibility\n    /// @param from Address to repay from.\n    /// @param to Address of the user this payment should go.\n    /// @param part The amount to repay. See `userBorrowPart`.\n    /// @return amount The total amount repayed.\n    function repay(\n        address from,\n        address to,\n        bool,\n        uint256 part\n    ) public notPaused allowedBorrow(from, part) returns (uint256 amount) {\n        updateExchangeRate();\n\n        accrue();\n\n        amount = _repay(from, to, part);\n    }\n\n    /// @notice Adds `collateral` from msg.sender to the account `to`.\n    /// @param from Account to transfer shares from.\n    /// @param to The receiver of the tokens.\n    /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\n    /// @param share The amount of shares to add for `to`.\n    function addCollateral(\n        address from,\n        address to,\n        bool skim,\n        uint256 amount,\n        uint256 share\n    ) public allowedBorrow(from, share) notPaused {\n        _addCollateral(from, to, skim, amount, share);\n    }\n\n    /// @notice Removes `share` amount of collateral and transfers it to `to`."
    }
  ]
}