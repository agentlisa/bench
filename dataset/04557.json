{
  "Title": "Validate MigrationAgent setting",
  "Content": "The [`setMigrationAgent`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L100) function from [`QiibeeToken`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol) does not check if the `agent.qbxSourceToken` matches the address of the contract from which the function is executed. Linking to a `MigrationAgent` that was configured to work with a different token may corrupt the migration process.\n\n\nWe recommend checking the precondition `require(_agent.qbxSourceToken == address(this))` in [line 102](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L102) to avoid being in an inconsistent state.\n\n\n***Update:** Fixed in [this](https://github.com/qiibee/qb-contracts/commit/25efdbf5bc29de12a724450c540218f6c8e59129) commit.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/QiibeeToken.sol",
      "content": "pragma solidity ^0.4.11;\n\nimport \"zeppelin-solidity/contracts/token/PausableToken.sol\";\nimport \"zeppelin-solidity/contracts/token/MintableToken.sol\";\nimport \"zeppelin-solidity/contracts/token/BurnableToken.sol\";\nimport \"zeppelin-solidity/contracts/token/VestedToken.sol\";\n\n// @dev Migration Agent interface\ncontract MigrationAgentInterface {\n  function migrateFrom(address _from, uint256 _value);\n  function setSourceToken(address _qbxSourceToken);\n}\n\n/**\n   @title QBX, the qiibee token\n\n   Implementation of QBX, an ERC20 token for the qiibee ecosystem. The smallest unit of a qbx is\n   the atto. The token call be migrated to a new token by calling the `migrate()` function.\n */\ncontract QiibeeToken is BurnableToken, PausableToken, VestedToken, MintableToken {\n\n    string public constant SYMBOL = \"QBX\";\n\n    string public constant NAME = \"qiibeeCoin\";\n\n    uint8 public constant DECIMALS = 18;\n\n    // migration vars\n    uint256 public totalMigrated;\n    address public migrationAgent;\n    address public migrationMaster;\n\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n\n    modifier onlyMigrationMaster {\n        require(msg.sender == migrationMaster);\n        _;\n    }\n\n    /*\n     * Constructor.\n     */\n    function QiibeeToken(address _migrationMaster) {\n      require(_migrationMaster != address(0));\n      migrationMaster = _migrationMaster;\n    }\n\n    /**\n      @dev Similar to grantVestedTokens but minting tokens instead of transferring.\n    */\n    function mintVestedTokens (\n      address _to,\n      uint256 _value,\n      uint64 _start,\n      uint64 _cliff,\n      uint64 _vesting,\n      bool _revokable,\n      bool _burnsOnRevoke,\n      address _wallet\n    ) onlyOwner public returns (bool) {\n      // Check for date inconsistencies that may cause unexpected behavior\n      require(_cliff >= _start && _vesting >= _cliff);\n\n      require(tokenGrantsCount(_to) < MAX_GRANTS_PER_ADDRESS);   // To prevent a user being spammed and have his balance locked (out of gas attack when calculating vesting).\n\n      uint256 count = grants[_to].push(\n                  TokenGrant(\n                    _revokable ? _wallet : 0, // avoid storing an extra 20 bytes when it is non-revokable\n                    _value,\n                    _cliff,\n                    _vesting,\n                    _start,\n                    _revokable,\n                    _burnsOnRevoke\n                  )\n                );\n\n      return mint(_to, _value); //mint tokens\n    }\n\n    /**\n      @dev Overrides VestedToken#grantVestedTokens(). Only owner can call it.\n    */\n    function grantVestedTokens (\n      address _to,\n      uint256 _value,\n      uint64 _start,\n      uint64 _cliff,\n      uint64 _vesting,\n      bool _revokable,\n      bool _burnsOnRevoke\n    ) onlyOwner public {\n      super.grantVestedTokens(_to, _value, _start, _cliff, _vesting, _revokable, _burnsOnRevoke);\n    }\n\n    /**\n      @dev Set address of migration agent contract and enable migration process.\n      @param _agent The address of the MigrationAgent contract\n     */\n    function setMigrationAgent(address _agent) public onlyMigrationMaster {\n      require(migrationAgent == address(0));\n      migrationAgent = _agent;\n    }\n\n    /**\n      @dev Migrates the tokens to the target token through the MigrationAgent.\n      @param _value The amount of tokens (in atto) to be migrated.\n     */\n    function migrate(uint256 _value) public whenNotPaused {\n      require(migrationAgent != address(0));\n      require(_value != 0);\n      require(_value <= balances[msg.sender]);\n\n      balances[msg.sender] -= _value;\n      totalSupply -= _value;\n      totalMigrated += _value;\n      MigrationAgentInterface(migrationAgent).migrateFrom(msg.sender, _value);\n      Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    /*\n     * @dev Changes the migration master.\n     * @param _master The address of the migration master.\n     */\n    function setMigrationMaster(address _master) public onlyMigrationMaster {\n      require(_master != address(0));\n      migrationMaster = _master;\n    }\n\n    /*\n     * @dev Burns a specific amount of tokens.\n     * @param _value The amount of tokens to be burnt.\n     */\n    function burn(uint256 _value) whenNotPaused public {\n        super.burn(_value);\n    }\n}"
    },
    {
      "filename": "contracts/QiibeeToken.sol",
      "content": "pragma solidity ^0.4.11;\n\nimport \"zeppelin-solidity/contracts/token/PausableToken.sol\";\nimport \"zeppelin-solidity/contracts/token/MintableToken.sol\";\nimport \"zeppelin-solidity/contracts/token/BurnableToken.sol\";\nimport \"zeppelin-solidity/contracts/token/VestedToken.sol\";\n\n// @dev Migration Agent interface\ncontract MigrationAgentInterface {\n  function migrateFrom(address _from, uint256 _value);\n  function setSourceToken(address _qbxSourceToken);\n}\n\n/**\n   @title QBX, the qiibee token\n\n   Implementation of QBX, an ERC20 token for the qiibee ecosystem. The smallest unit of a qbx is\n   the atto. The token call be migrated to a new token by calling the `migrate()` function.\n */\ncontract QiibeeToken is BurnableToken, PausableToken, VestedToken, MintableToken {\n\n    string public constant SYMBOL = \"QBX\";\n\n    string public constant NAME = \"qiibeeCoin\";\n\n    uint8 public constant DECIMALS = 18;\n\n    // migration vars\n    uint256 public totalMigrated;\n    address public migrationAgent;\n    address public migrationMaster;\n\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n\n    modifier onlyMigrationMaster {\n        require(msg.sender == migrationMaster);\n        _;\n    }\n\n    /*\n     * Constructor.\n     */\n    function QiibeeToken(address _migrationMaster) {\n      require(_migrationMaster != address(0));\n      migrationMaster = _migrationMaster;\n    }\n\n    /**\n      @dev Similar to grantVestedTokens but minting tokens instead of transferring.\n    */\n    function mintVestedTokens (\n      address _to,\n      uint256 _value,\n      uint64 _start,\n      uint64 _cliff,\n      uint64 _vesting,\n      bool _revokable,\n      bool _burnsOnRevoke,\n      address _wallet\n    ) onlyOwner public returns (bool) {\n      // Check for date inconsistencies that may cause unexpected behavior\n      require(_cliff >= _start && _vesting >= _cliff);\n\n      require(tokenGrantsCount(_to) < MAX_GRANTS_PER_ADDRESS);   // To prevent a user being spammed and have his balance locked (out of gas attack when calculating vesting).\n\n      uint256 count = grants[_to].push(\n                  TokenGrant(\n                    _revokable ? _wallet : 0, // avoid storing an extra 20 bytes when it is non-revokable\n                    _value,\n                    _cliff,\n                    _vesting,\n                    _start,\n                    _revokable,\n                    _burnsOnRevoke\n                  )\n                );\n\n      return mint(_to, _value); //mint tokens\n    }\n\n    /**\n      @dev Overrides VestedToken#grantVestedTokens(). Only owner can call it.\n    */\n    function grantVestedTokens (\n      address _to,\n      uint256 _value,\n      uint64 _start,\n      uint64 _cliff,\n      uint64 _vesting,\n      bool _revokable,\n      bool _burnsOnRevoke\n    ) onlyOwner public {\n      super.grantVestedTokens(_to, _value, _start, _cliff, _vesting, _revokable, _burnsOnRevoke);\n    }\n\n    /**\n      @dev Set address of migration agent contract and enable migration process.\n      @param _agent The address of the MigrationAgent contract\n     */\n    function setMigrationAgent(address _agent) public onlyMigrationMaster {\n      require(migrationAgent == address(0));\n      migrationAgent = _agent;\n    }\n\n    /**\n      @dev Migrates the tokens to the target token through the MigrationAgent.\n      @param _value The amount of tokens (in atto) to be migrated.\n     */\n    function migrate(uint256 _value) public whenNotPaused {\n      require(migrationAgent != address(0));\n      require(_value != 0);\n      require(_value <= balances[msg.sender]);\n\n      balances[msg.sender] -= _value;\n      totalSupply -= _value;\n      totalMigrated += _value;\n      MigrationAgentInterface(migrationAgent).migrateFrom(msg.sender, _value);\n      Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    /*\n     * @dev Changes the migration master.\n     * @param _master The address of the migration master.\n     */\n    function setMigrationMaster(address _master) public onlyMigrationMaster {\n      require(_master != address(0));\n      migrationMaster = _master;\n    }\n\n    /*\n     * @dev Burns a specific amount of tokens.\n     * @param _value The amount of tokens to be burnt.\n     */\n    function burn(uint256 _value) whenNotPaused public {\n        super.burn(_value);\n    }\n}"
    }
  ]
}