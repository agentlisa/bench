{
  "Title": "[M-03] Innocent borrower could incur losses caused by a malicious lender",
  "Content": "\nThe protocol allows the lender to change the interest rate anytime. However, since the new interest rate is stored on trading pool level, the lender could front-run a borrowing transaction that's yet to be processed, updating the interest rate too high (up to 99). This is harmful to the borrower even if the borrower repays the SOL immediately.\nThat's because the minimum elapsed days on repay is set to be one\n\n```rust\n  let days_elapsed = ((current_timestamp - timestamp) as u64 / 86400) + 1; // +1 to ensure interest is charged from day 0\n```\n\n`src/processor/swapback.rs#L145`\n\n### Proof of Concept\n\nUpdate interest rate on pool level:\n\n`src/processor/lending.rs#L38-L51`\n\nMinimum elapsed days is 1:\n\n    ```rust\n      let days_elapsed = ((current_timestamp - timestamp) as u64 / 86400) + 1; // +1 to ensure interest is charged from day 0\n    ```\n\n`src/processor/swapback.rs#L145`\n\n### Recommended Mitigation Steps\n\nAllow the borrower to pass maximum interest rate, this protects the borrower from any change of the interest rate that occur after they send their TX.\n\nAnother suggestion: store the interest rate on position level instead.\n\n**[piske-alex (Lavarage) confirmed and commented](https://github.com/code-423n4/2024-04-lavarage-findings/issues/17#issuecomment-2087769388):**\n > > Another suggestion: store the interest rate on position level instead.\n> \n> Will implement max interest rate param. How do I store the interest rate on position before the position is created?\n\n\n**[Koolex (warden) commented](https://github.com/code-423n4/2024-04-lavarage-findings/issues/17#issuecomment-2088199727):**\n > @piske-alex - That's a very good point, as it can still be front-run.\n> \n> However, if you still would like to avoid passing the interest rate as a param, interest rate should be stored in trading pool with `updated_time`, then on borrowing, check if there is not enough timespan between current timestamp and `updated_time`, revert accordingly. Otherwise, proceed and store the interest rate (for records only).\n> \n> This should be a sufficient protection without requiring the user to pass max interest rate as a param due to the fact that, a Solana TX has an expiration time. So, if it is not processed within a certain time, it will never be.\n> \n> > During transaction processing, Solana Validators will check if each transaction's recent blockhash is recorded within the most recent 151 stored hashes (aka \"max processing age\"). If the transaction's recent blockhash is [older than this](https://github.com/anza-xyz/agave/blob/cb2fd2b632f16a43eff0c27af7458e4e97512e31/runtime/src/bank.rs#L3570-L3571) max processing age, the transaction is not processed.\n> \n> Check [this](https://solana.com/docs/advanced/confirmation#how-does-transaction-expiration-work) for more info.\n\n**[alcueca (judge) commented](https://github.com/code-423n4/2024-04-lavarage-findings/issues/17#issuecomment-2105119034):**\n > Front-running by validators is possible in Solana, and after a brief analysis of the current situation, concerning to some users. This issue can cause mild losses to users. Nothing major, but a headache for the protocol that will have to deal with the complaints and possibly refunds. Affected users would have to close their positions immediately if they notice the issue. All in all, a medium is a fair severity rating.\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2024-04-lavarage-findings/issues/17).*\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-04-lavarage",
  "Code": [
    {
      "filename": "runtime/src/bank.rs",
      "content": "//! The `bank` module tracks client accounts and the progress of on-chain\n//! programs.\n//!\n//! A single bank relates to a block produced by a single leader and each bank\n//! except for the genesis bank points back to a parent bank.\n//!\n//! The bank is the main entrypoint for processing verified transactions with the function\n//! `Bank::process_transactions`\n//!\n//! It does this by loading the accounts using the reference it holds on the account store,\n//! and then passing those to an InvokeContext which handles loading the programs specified\n//! by the Transaction and executing it.\n//!\n//! The bank then stores the results to the accounts store.\n//!\n//! It then has APIs for retrieving if a transaction has been processed and it's status.\n//! See `get_signature_status` et al.\n//!\n//! Bank lifecycle:\n//!\n//! A bank is newly created and open to transactions. Transactions are applied\n//! until either the bank reached the tick count when the node is the leader for that slot, or the\n//! node has applied all transactions present in all `Entry`s in the slot.\n//!\n//! Once it is complete, the bank can then be frozen. After frozen, no more transactions can\n//! be applied or state changes made. At the frozen step, rent will be applied and various\n//! sysvar special accounts update to the new state of the system.\n//!\n//! After frozen, and the bank has had the appropriate number of votes on it, then it can become\n//! rooted. At this point, it will not be able to be removed from the chain and the\n//! state is finalized.\n//!\n//! It offers a high-level API that signs transactions\n//! on behalf of the caller, and a low-level API for when they have\n//! already been signed and verified.\n#[allow(deprecated)]\nuse solana_sdk::recent_blockhashes_account;\npub use solana_sdk::reward_type::RewardType;\nuse {\n    crate::{\n        bank::{\n            builtins::{BuiltinPrototype, BUILTINS},\n            metrics::*,\n            partitioned_epoch_rewards::{\n                EpochRewardCalculateParamInfo, EpochRewardStatus, StakeRewards, VoteRewardsAccounts,\n            },\n        },\n        bank_forks::BankForks,\n        epoch_stakes::{EpochStakes, NodeVoteAccounts},\n        installed_scheduler_pool::{BankWithScheduler, InstalledSchedulerRwLock},\n        runtime_config::RuntimeConfig,\n        serde_snapshot::BankIncrementalSnapshotPersistence,\n        snapshot_hash::SnapshotHash,\n        stake_account::StakeAccount,\n        stake_history::StakeHistory,\n        stake_weighted_timestamp::{\n            calculate_stake_weighted_timestamp, MaxAllowableDrift,\n            MAX_ALLOWABLE_DRIFT_PERCENTAGE_FAST, MAX_ALLOWABLE_DRIFT_PERCENTAGE_SLOW_V2,\n        },\n        stakes::{InvalidCacheEntryReason, Stakes, StakesCache, StakesEnum},\n        status_cache::{SlotDelta, StatusCache},\n        transaction_batch::TransactionBatch,\n    },\n    byteorder::{ByteOrder, LittleEndian},\n    dashmap::{DashMap, DashSet},\n    itertools::izip,\n    log::*,\n    rayon::{\n        iter::{IntoParallelIterator, IntoParallelRefIterator, ParallelIterator},\n        slice::ParallelSlice,\n        ThreadPool, ThreadPoolBuilder,\n    },\n    serde::Serialize,\n    solana_accounts_db::{\n        accounts::{AccountAddressFilter, Accounts, PubkeyAccountSlot},\n        accounts_db::{\n            AccountShrinkThreshold, AccountStorageEntry, AccountsDb, AccountsDbConfig,\n            CalcAccountsHashDataSource, VerifyAccountsHashAndLamportsConfig,\n        },\n        accounts_hash::{\n            AccountHash, AccountsHash, CalcAccountsHashConfig, HashStats, IncrementalAccountsHash,\n        },\n        accounts_index::{AccountSecondaryIndexes, IndexKey, ScanConfig, ScanResult, ZeroLamport},\n        accounts_partition::{self, Partition, PartitionIndex},\n        accounts_update_notifier_interface::AccountsUpdateNotifier,\n        ancestors::{Ancestors, AncestorsForSerialization},\n        blockhash_queue::BlockhashQueue,\n        epoch_accounts_hash::EpochAccountsHash,\n        sorted_storages::SortedStorages,\n        stake_rewards::StakeReward,\n        storable_accounts::{AccountForStorage, StorableAccounts},\n    },\n    solana_bpf_loader_program::syscalls::create_program_runtime_environment_v1,\n    solana_cost_model::cost_tracker::CostTracker,\n    solana_loader_v4_program::create_program_runtime_environment_v2,\n    solana_measure::{measure, measure::Measure, measure_us},\n    solana_perf::perf_libs,\n    solana_program_runtime::{\n        compute_budget_processor::process_compute_budget_instructions,\n        invoke_context::BuiltinFunctionWithContext,\n        loaded_programs::{\n            LoadedProgram, LoadedProgramMatchCriteria, LoadedProgramType, ProgramCache,\n        },\n        timings::{ExecuteTimingType, ExecuteTimings},\n    },\n    solana_sdk::{\n        account::{\n            create_account_shared_data_with_fields as create_account, from_account, Account,\n            AccountSharedData, InheritableAccountFields, ReadableAccount, WritableAccount,\n        },\n        clock::{\n            BankId, Epoch, Slot, SlotCount, SlotIndex, UnixTimestamp, DEFAULT_HASHES_PER_TICK,\n            DEFAULT_TICKS_PER_SECOND, INITIAL_RENT_EPOCH, MAX_PROCESSING_AGE,\n            MAX_TRANSACTION_FORWARDING_DELAY, MAX_TRANSACTION_FORWARDING_DELAY_GPU,\n            SECONDS_PER_DAY, UPDATED_HASHES_PER_TICK2, UPDATED_HASHES_PER_TICK3,\n            UPDATED_HASHES_PER_TICK4, UPDATED_HASHES_PER_TICK5, UPDATED_HASHES_PER_TICK6,\n        },\n        epoch_info::EpochInfo,\n        epoch_schedule::EpochSchedule,\n        feature,\n        feature_set::{\n            self, include_loaded_accounts_data_size_in_fee_calculation,\n            remove_rounding_in_fee_calculation, FeatureSet,\n        },\n        fee::{FeeDetails, FeeStructure},\n        fee_calculator::{FeeCalculator, FeeRateGovernor},\n        genesis_config::{ClusterType, GenesisConfig},\n        hard_forks::HardForks,\n        hash::{extend_and_hash, hashv, Hash},\n        incinerator,\n        inflation::Inflation,\n        inner_instruction::InnerInstructions,\n        message::{AccountKeys, SanitizedMessage},\n        native_loader,\n        native_token::LAMPORTS_PER_SOL,\n        nonce::{self, state::DurableNonce, NONCED_TX_MARKER_IX_INDEX},\n        nonce_account,\n        nonce_info::{NonceInfo, NoncePartial},\n        packet::PACKET_DATA_SIZE,\n        precompiles::get_precompiles,\n        pubkey::Pubkey,\n        rent::RentDue,\n        rent_collector::{CollectedInfo, RentCollector, RENT_EXEMPT_RENT_EPOCH},\n        rent_debits::RentDebits,\n        reserved_account_keys::ReservedAccountKeys,\n        reward_info::RewardInfo,\n        saturating_add_assign,\n        signature::{Keypair, Signature},\n        slot_hashes::SlotHashes,\n        slot_history::{Check, SlotHistory},\n        stake::state::Delegation,\n        system_transaction,\n        sysvar::{self, last_restart_slot::LastRestartSlot, Sysvar, SysvarId},\n        timing::years_as_slots,\n        transaction::{\n            self, MessageHash, Result, SanitizedTransaction, Transaction, TransactionError,\n            TransactionVerificationMode, VersionedTransaction, MAX_TX_ACCOUNT_LOCKS,\n        },\n        transaction_context::{TransactionAccount, TransactionReturnData},\n    },\n    solana_stake_program::{\n        points::{InflationPointCalculationEvent, PointValue},\n        stake_state::StakeStateV2,\n    },\n    solana_svm::{\n        account_loader::{TransactionCheckResult, TransactionLoadResult},\n        account_overrides::AccountOverrides,\n        transaction_error_metrics::TransactionErrorMetrics,\n        transaction_processor::{\n            ExecutionRecordingConfig, TransactionBatchProcessor, TransactionLogMessages,\n            TransactionProcessingCallback,\n        },\n        transaction_results::{\n            TransactionExecutionDetails, TransactionExecutionResult, TransactionResults,\n        },\n    },\n    solana_system_program::{get_system_account_kind, SystemAccountKind},\n    solana_vote::vote_account::{VoteAccount, VoteAccountsHashMap},\n    solana_vote_program::vote_state::VoteState,\n    std::{\n        borrow::Cow,\n        collections::{HashMap, HashSet},\n        convert::TryFrom,\n        fmt, mem,\n        ops::{AddAssign, RangeInclusive},\n        path::PathBuf,\n        slice,\n        sync::{\n            atomic::{\n                AtomicBool, AtomicI64, AtomicU64, AtomicUsize,\n                Ordering::{AcqRel, Acquire, Relaxed},\n            },\n            Arc, LockResult, Mutex, RwLock, RwLockReadGuard, RwLockWriteGuard,\n        },\n        thread::Builder,\n        time::{Duration, Instant},\n    },\n};\n#[cfg(feature = \"dev-context-only-utils\")]\nuse {\n    solana_accounts_db::accounts_db::{\n        ACCOUNTS_DB_CONFIG_FOR_BENCHMARKS, ACCOUNTS_DB_CONFIG_FOR_TESTING,\n    },\n    solana_program_runtime::{\n        loaded_programs::LoadedProgramsForTxBatch, sysvar_cache::SysvarCache,\n    },\n};\n\n/// params to `verify_accounts_hash`\nstruct VerifyAccountsHashConfig {\n    test_hash_calculation: bool,\n    ignore_mismatch: bool,\n    require_rooted_bank: bool,\n    run_in_background: bool,\n    store_hash_raw_data_for_debug: bool,\n}\n\nmod address_lookup_table;\npub mod bank_hash_details;\nmod builtin_programs;\npub mod builtins;\npub mod epoch_accounts_hash_utils;\nmod fee_distribution;\nmod metrics;\npub(crate) mod partitioned_epoch_rewards;\nmod serde_snapshot;\nmod sysvar_cache;\n#[cfg(test)]\npub(crate) mod tests;\n\npub const SECONDS_PER_YEAR: f64 = 365.25 * 24.0 * 60.0 * 60.0;\n\npub const MAX_LEADER_SCHEDULE_STAKES: Epoch = 5;\n\n#[derive(Default)]\nstruct RentMetrics {\n    hold_range_us: AtomicU64,\n    load_us: AtomicU64,\n    collect_us: AtomicU64,\n    hash_us: AtomicU64,\n    store_us: AtomicU64,\n    count: AtomicUsize,\n}\n\npub type BankStatusCache = StatusCache<Result<()>>;\n#[frozen_abi(digest = \"EzAXfE2xG3ZqdAj8KMC8CeqoSxjo5hxrEaP7fta8LT9u\")]\npub type BankSlotDelta = SlotDelta<Result<()>>;\n\n#[derive(Default, Copy, Clone, Debug, PartialEq, Eq)]\npub struct SquashTiming {\n    pub squash_accounts_ms: u64,\n    pub squash_accounts_cache_ms: u64,\n    pub squash_accounts_index_ms: u64,\n    pub squash_accounts_store_ms: u64,\n\n    pub squash_cache_ms: u64,\n}\n\nimpl AddAssign for SquashTiming {\n    fn add_assign(&mut self, rhs: Self) {\n        self.squash_accounts_ms += rhs.squash_accounts_ms;\n        self.squash_accounts_cache_ms += rhs.squash_accounts_cache_ms;\n        self.squash_accounts_index_ms += rhs.squash_accounts_index_ms;\n        self.squash_accounts_store_ms += rhs.squash_accounts_store_ms;\n        self.squash_cache_ms += rhs.squash_cache_ms;\n    }\n}\n\n#[derive(AbiExample, Debug, Default, PartialEq)]\npub(crate) struct CollectorFeeDetails {\n    transaction_fee: u64,\n    priority_fee: u64,\n}\n\nimpl CollectorFeeDetails {\n    pub(crate) fn accumulate(&mut self, fee_details: &FeeDetails) {\n        self.transaction_fee = self\n            .transaction_fee\n            .saturating_add(fee_details.transaction_fee());\n        self.priority_fee = self\n            .priority_fee\n            .saturating_add(fee_details.prioritization_fee());\n    }\n}\n\n#[derive(Debug)]\npub struct BankRc {\n    /// where all the Accounts are stored\n    pub accounts: Arc<Accounts>,\n\n    /// Previous checkpoint of this bank\n    pub(crate) parent: RwLock<Option<Arc<Bank>>>,\n\n    /// Current slot\n    pub(crate) slot: Slot,\n\n    pub(crate) bank_id_generator: Arc<AtomicU64>,\n}\n\n#[cfg(RUSTC_WITH_SPECIALIZATION)]\nuse solana_frozen_abi::abi_example::AbiExample;\n\n#[cfg(RUSTC_WITH_SPECIALIZATION)]\nimpl AbiExample for BankRc {\n    fn example() -> Self {\n        BankRc {\n            // Set parent to None to cut the recursion into another Bank\n            parent: RwLock::new(None),\n            // AbiExample for Accounts is specially implemented to contain a storage example\n            accounts: AbiExample::example(),\n            slot: AbiExample::example(),\n            bank_id_generator: Arc::new(AtomicU64::new(0)),\n        }\n    }\n}\n\nimpl BankRc {\n    pub(crate) fn new(accounts: Accounts, slot: Slot) -> Self {\n        Self {\n            accounts: Arc::new(accounts),\n            parent: RwLock::new(None),\n            slot,\n            bank_id_generator: Arc::new(AtomicU64::new(0)),\n        }\n    }\n}\n\npub struct LoadAndExecuteTransactionsOutput {\n    pub loaded_transactions: Vec<TransactionLoadResult>,\n    // Vector of results indicating whether a transaction was executed or could not\n    // be executed. Note executed transactions can still have failed!\n    pub execution_results: Vec<TransactionExecutionResult>,\n    pub retryable_transaction_indexes: Vec<usize>,\n    // Total number of transactions that were executed\n    pub executed_transactions_count: usize,\n    // Number of non-vote transactions that were executed\n    pub executed_non_vote_transactions_count: usize,\n    // Total number of the executed transactions that returned success/not\n    // an error.\n    pub executed_with_successful_result_count: usize,\n    pub signature_count: u64,\n    pub error_counters: TransactionErrorMetrics,\n}\n\npub struct TransactionSimulationResult {\n    pub result: Result<()>,\n    pub logs: TransactionLogMessages,\n    pub post_simulation_accounts: Vec<TransactionAccount>,\n    pub units_consumed: u64,\n    pub return_data: Option<TransactionReturnData>,\n    pub inner_instructions: Option<Vec<InnerInstructions>>,\n}\npub struct TransactionBalancesSet {\n    pub pre_balances: TransactionBalances,\n    pub post_balances: TransactionBalances,\n}\n\nimpl TransactionBalancesSet {\n    pub fn new(pre_balances: TransactionBalances, post_balances: TransactionBalances) -> Self {\n        assert_eq!(pre_balances.len(), post_balances.len());\n        Self {\n            pre_balances,\n            post_balances,\n        }\n    }\n}\npub type TransactionBalances = Vec<Vec<u64>>;\n\n#[derive(Serialize, Deserialize, AbiExample, AbiEnumVisitor, Debug, PartialEq, Eq)]\npub enum TransactionLogCollectorFilter {\n    All,\n    AllWithVotes,\n    None,\n    OnlyMentionedAddresses,\n}\n\nimpl Default for TransactionLogCollectorFilter {\n    fn default() -> Self {\n        Self::None\n    }\n}\n\n#[derive(AbiExample, Debug, Default)]\npub struct TransactionLogCollectorConfig {\n    pub mentioned_addresses: HashSet<Pubkey>,\n    pub filter: TransactionLogCollectorFilter,\n}\n\n#[derive(AbiExample, Clone, Debug, PartialEq, Eq)]\npub struct TransactionLogInfo {\n    pub signature: Signature,\n    pub result: Result<()>,\n    pub is_vote: bool,\n    pub log_messages: TransactionLogMessages,\n}\n\n#[derive(AbiExample, Default, Debug)]\npub struct TransactionLogCollector {\n    // All the logs collected for from this Bank.  Exact contents depend on the\n    // active `TransactionLogCollectorFilter`\n    pub logs: Vec<TransactionLogInfo>,\n\n    // For each `mentioned_addresses`, maintain a list of indices into `logs` to easily\n    // locate the logs from transactions that included the mentioned addresses.\n    pub mentioned_address_map: HashMap<Pubkey, Vec<usize>>,\n}\n\nimpl TransactionLogCollector {\n    pub fn get_logs_for_address(\n        &self,\n        address: Option<&Pubkey>,\n    ) -> Option<Vec<TransactionLogInfo>> {\n        match address {\n            None => Some(self.logs.clone()),\n            Some(address) => self.mentioned_address_map.get(address).map(|log_indices| {\n                log_indices\n                    .iter()\n                    .filter_map(|i| self.logs.get(*i).cloned())\n                    .collect()\n            }),\n        }\n    }\n}\n\n/// Bank's common fields shared by all supported snapshot versions for deserialization.\n/// Sync fields with BankFieldsToSerialize! This is paired with it.\n/// All members are made public to remain Bank's members private and to make versioned deserializer workable on this\n/// Note that some fields are missing from the serializer struct. This is because of fields added later.\n/// Since it is difficult to insert fields to serialize/deserialize against existing code already deployed,\n/// new fields can be optionally serialized and optionally deserialized. At some point, the serialization and\n/// deserialization will use a new mechanism or otherwise be in sync more clearly.\n#[derive(Clone, Debug, Default, PartialEq)]\npub struct BankFieldsToDeserialize {\n    pub(crate) blockhash_queue: BlockhashQueue,\n    pub(crate) ancestors: AncestorsForSerialization,\n    pub(crate) hash: Hash,\n    pub(crate) parent_hash: Hash,\n    pub(crate) parent_slot: Slot,\n    pub(crate) hard_forks: HardForks,\n    pub(crate) transaction_count: u64,\n    pub(crate) tick_height: u64,\n    pub(crate) signature_count: u64,\n    pub(crate) capitalization: u64,\n    pub(crate) max_tick_height: u64,\n    pub(crate) hashes_per_tick: Option<u64>,\n    pub(crate) ticks_per_slot: u64,\n    pub(crate) ns_per_slot: u128,\n    pub(crate) genesis_creation_time: UnixTimestamp,\n    pub(crate) slots_per_year: f64,\n    pub(crate) slot: Slot,\n    pub(crate) epoch: Epoch,\n    pub(crate) block_height: u64,\n    pub(crate) collector_id: Pubkey,\n    pub(crate) collector_fees: u64,\n    pub(crate) fee_calculator: FeeCalculator,\n    pub(crate) fee_rate_governor: FeeRateGovernor,\n    pub(crate) collected_rent: u64,\n    pub(crate) rent_collector: RentCollector,\n    pub(crate) epoch_schedule: EpochSchedule,\n    pub(crate) inflation: Inflation,\n    pub(crate) stakes: Stakes<Delegation>,\n    pub(crate) epoch_stakes: HashMap<Epoch, EpochStakes>,\n    pub(crate) is_delta: bool,\n    pub(crate) accounts_data_len: u64,\n    pub(crate) incremental_snapshot_persistence: Option<BankIncrementalSnapshotPersistence>,\n    pub(crate) epoch_accounts_hash: Option<Hash>,\n    pub(crate) epoch_reward_status: EpochRewardStatus,\n}\n\n/// Bank's common fields shared by all supported snapshot versions for serialization.\n/// This is separated from BankFieldsToDeserialize to avoid cloning by using refs.\n/// So, sync fields with BankFieldsToDeserialize!\n/// all members are made public to keep Bank private and to make versioned serializer workable on this.\n/// Note that some fields are missing from the serializer struct. This is because of fields added later.\n/// Since it is difficult to insert fields to serialize/deserialize against existing code already deployed,\n/// new fields can be optionally serialized and optionally deserialized. At some point, the serialization and\n/// deserialization will use a new mechanism or otherwise be in sync more clearly.\n#[derive(Debug)]\npub(crate) struct BankFieldsToSerialize<'a> {\n    pub(crate) blockhash_queue: &'a RwLock<BlockhashQueue>,\n    pub(crate) ancestors: &'a AncestorsForSerialization,\n    pub(crate) hash: Hash,\n    pub(crate) parent_hash: Hash,\n    pub(crate) parent_slot: Slot,\n    pub(crate) hard_forks: &'a RwLock<HardForks>,\n    pub(crate) transaction_count: u64,\n    pub(crate) tick_height: u64,\n    pub(crate) signature_count: u64,\n    pub(crate) capitalization: u64,\n    pub(crate) max_tick_height: u64,\n    pub(crate) hashes_per_tick: Option<u64>,\n    pub(crate) ticks_per_slot: u64,\n    pub(crate) ns_per_slot: u128,\n    pub(crate) genesis_creation_time: UnixTimestamp,\n    pub(crate) slots_per_year: f64,\n    pub(crate) slot: Slot,\n    pub(crate) epoch: Epoch,\n    pub(crate) block_height: u64,\n    pub(crate) collector_id: Pubkey,\n    pub(crate) collector_fees: u64,\n    pub(crate) fee_calculator: FeeCalculator,\n    pub(crate) fee_rate_governor: FeeRateGovernor,\n    pub(crate) collected_rent: u64,\n    pub(crate) rent_collector: RentCollector,\n    pub(crate) epoch_schedule: EpochSchedule,\n    pub(crate) inflation: Inflation,\n    pub(crate) stakes: &'a StakesCache,\n    pub(crate) epoch_stakes: &'a HashMap<Epoch, EpochStakes>,\n    pub(crate) is_delta: bool,\n    pub(crate) accounts_data_len: u64,\n}\n\n// Can't derive PartialEq because RwLock doesn't implement PartialEq\nimpl PartialEq for Bank {\n    fn eq(&self, other: &Self) -> bool {\n        if std::ptr::eq(self, other) {\n            return true;\n        }\n        let Self {\n            skipped_rewrites: _,\n            rc: _,\n            status_cache: _,\n            blockhash_queue,\n            ancestors,\n            hash,\n            parent_hash,\n            parent_slot,\n            hard_forks,\n            transaction_count,\n            non_vote_transaction_count_since_restart: _,\n            transaction_error_count: _,\n            transaction_entries_count: _,\n            transactions_per_entry_max: _,\n            tick_height,\n            signature_count,\n            capitalization,\n            max_tick_height,\n            hashes_per_tick,\n            ticks_per_slot,\n            ns_per_slot,\n            genesis_creation_time,\n            slots_per_year,\n            slot,\n            bank_id: _,\n            epoch,\n            block_height,\n            collector_id,\n            collector_fees,\n            fee_rate_governor,\n            collected_rent,\n            rent_collector,\n            epoch_schedule,\n            inflation,\n            stakes_cache,\n            epoch_stakes,\n            is_delta,\n            // TODO: Confirm if all these fields are intentionally ignored!\n            runtime_config: _,\n            rewards: _,\n            cluster_type: _,\n            lazy_rent_collection: _,\n            rewards_pool_pubkeys: _,\n            transaction_debug_keys: _,\n            transaction_log_collector_config: _,\n            transaction_log_collector: _,\n            feature_set: _,\n            reserved_account_keys: _,\n            drop_callback: _,\n            freeze_started: _,\n            vote_only_bank: _,\n            cost_tracker: _,\n            accounts_data_size_initial: _,\n            accounts_data_size_delta_on_chain: _,\n            accounts_data_size_delta_off_chain: _,\n            fee_structure: _,\n            incremental_snapshot_persistence: _,\n            epoch_reward_status: _,\n            transaction_processor: _,\n            check_program_modification_slot: _,\n            collector_fee_details: _,\n            // Ignore new fields explicitly if they do not impact PartialEq.\n            // Adding \"..\" will remove compile-time checks that if a new field\n            // is added to the struct, this PartialEq is accordingly updated.\n        } = self;\n        *blockhash_queue.read().unwrap() == *other.blockhash_queue.read().unwrap()\n            && ancestors == &other.ancestors\n            && *hash.read().unwrap() == *other.hash.read().unwrap()\n            && parent_hash == &other.parent_hash\n            && parent_slot == &other.parent_slot\n            && *hard_forks.read().unwrap() == *other.hard_forks.read().unwrap()\n            && transaction_count.load(Relaxed) == other.transaction_count.load(Relaxed)\n            && tick_height.load(Relaxed) == other.tick_height.load(Relaxed)\n            && signature_count.load(Relaxed) == other.signature_count.load(Relaxed)\n            && capitalization.load(Relaxed) == other.capitalization.load(Relaxed)\n            && max_tick_height == &other.max_tick_height\n            && hashes_per_tick == &other.hashes_per_tick\n            && ticks_per_slot == &other.ticks_per_slot\n            && ns_per_slot == &other.ns_per_slot\n            && genesis_creation_time == &other.genesis_creation_time\n            && slots_per_year == &other.slots_per_year\n            && slot == &other.slot\n            && epoch == &other.epoch\n            && block_height == &other.block_height\n            && collector_id == &other.collector_id\n            && collector_fees.load(Relaxed) == other.collector_fees.load(Relaxed)\n            && fee_rate_governor == &other.fee_rate_governor\n            && collected_rent.load(Relaxed) == other.collected_rent.load(Relaxed)\n            && rent_collector == &other.rent_collector\n            && epoch_schedule == &other.epoch_schedule\n            && *inflation.read().unwrap() == *other.inflation.read().unwrap()\n            && *stakes_cache.stakes() == *other.stakes_cache.stakes()\n            && epoch_stakes == &other.epoch_stakes\n            && is_delta.load(Relaxed) == other.is_delta.load(Relaxed)\n    }\n}\n\n#[derive(Debug)]\npub enum RewardCalculationEvent<'a, 'b> {\n    Staking(&'a Pubkey, &'b InflationPointCalculationEvent),\n}\n\n/// type alias is not supported for trait in rust yet. As a workaround, we define the\n/// `RewardCalcTracer` trait explicitly and implement it on any type that implement\n/// `Fn(&RewardCalculationEvent) + Send + Sync`.\npub trait RewardCalcTracer: Fn(&RewardCalculationEvent) + Send + Sync {}\n\nimpl<T: Fn(&RewardCalculationEvent) + Send + Sync> RewardCalcTracer for T {}\n\nfn null_tracer() -> Option<impl RewardCalcTracer> {\n    None::<fn(&RewardCalculationEvent)>\n}\n\npub trait DropCallback: fmt::Debug {\n    fn callback(&self, b: &Bank);\n    fn clone_box(&self) -> Box<dyn DropCallback + Send + Sync>;\n}\n\n#[derive(Debug, Default)]\npub struct OptionalDropCallback(Option<Box<dyn DropCallback + Send + Sync>>);\n\n#[cfg(RUSTC_WITH_SPECIALIZATION)]\nimpl AbiExample for OptionalDropCallback {\n    fn example() -> Self {\n        Self(None)\n    }\n}\n\n/// Manager for the state of all accounts and programs after processing its entries.\n/// AbiExample is needed even without Serialize/Deserialize; actual (de-)serialization\n/// are implemented elsewhere for versioning\n#[derive(AbiExample, Debug)]\npub struct Bank {\n    /// References to accounts, parent and signature status\n    pub rc: BankRc,\n\n    /// A cache of signature statuses\n    pub status_cache: Arc<RwLock<BankStatusCache>>,\n\n    /// FIFO queue of `recent_blockhash` items\n    blockhash_queue: RwLock<BlockhashQueue>,\n\n    /// The set of parents including this bank\n    pub ancestors: Ancestors,\n\n    /// Hash of this Bank's state. Only meaningful after freezing.\n    hash: RwLock<Hash>,\n\n    /// Hash of this Bank's parent's state\n    parent_hash: Hash,\n\n    /// parent's slot\n    parent_slot: Slot,\n\n    /// slots to hard fork at\n    hard_forks: Arc<RwLock<HardForks>>,\n\n    /// The number of transactions processed without error\n    transaction_count: AtomicU64,\n\n    /// The number of non-vote transactions processed without error since the most recent boot from\n    /// snapshot or genesis. This value is not shared though the network, nor retained within\n    /// snapshots, but is preserved in `Bank::new_from_parent`.\n    non_vote_transaction_count_since_restart: AtomicU64,\n\n    /// The number of transaction errors in this slot\n    transaction_error_count: AtomicU64,\n\n    /// The number of transaction entries in this slot\n    transaction_entries_count: AtomicU64,\n\n    /// The max number of transaction in an entry in this slot\n    transactions_per_entry_max: AtomicU64,\n\n    /// Bank tick height\n    tick_height: AtomicU64,\n\n    /// The number of signatures from valid transactions in this slot\n    signature_count: AtomicU64,\n\n    /// Total capitalization, used to calculate inflation\n    capitalization: AtomicU64,\n\n    // Bank max_tick_height\n    max_tick_height: u64,\n\n    /// The number of hashes in each tick. None value means hashing is disabled.\n    hashes_per_tick: Option<u64>,\n\n    /// The number of ticks in each slot.\n    ticks_per_slot: u64,\n\n    /// length of a slot in ns\n    pub ns_per_slot: u128,\n\n    /// genesis time, used for computed clock\n    genesis_creation_time: UnixTimestamp,\n\n    /// The number of slots per year, used for inflation\n    slots_per_year: f64,\n\n    /// Bank slot (i.e. block)\n    slot: Slot,\n\n    bank_id: BankId,\n\n    /// Bank epoch\n    epoch: Epoch,\n\n    /// Bank block_height\n    block_height: u64,\n\n    /// The pubkey to send transactions fees to.\n    collector_id: Pubkey,\n\n    /// Fees that have been collected\n    collector_fees: AtomicU64,\n\n    /// Track cluster signature throughput and adjust fee rate\n    pub(crate) fee_rate_governor: FeeRateGovernor,\n\n    /// Rent that has been collected\n    collected_rent: AtomicU64,\n\n    /// latest rent collector, knows the epoch\n    rent_collector: RentCollector,\n\n    /// initialized from genesis\n    pub(crate) epoch_schedule: EpochSchedule,\n\n    /// inflation specs\n    inflation: Arc<RwLock<Inflation>>,\n\n    /// cache of vote_account and stake_account state for this fork\n    stakes_cache: StakesCache,\n\n    /// staked nodes on epoch boundaries, saved off when a bank.slot() is at\n    ///   a leader schedule calculation boundary\n    epoch_stakes: HashMap<Epoch, EpochStakes>,\n\n    /// A boolean reflecting whether any entries were recorded into the PoH\n    /// stream for the slot == self.slot\n    is_delta: AtomicBool,\n\n    /// Optional config parameters that can override runtime behavior\n    pub(crate) runtime_config: Arc<RuntimeConfig>,\n\n    /// Protocol-level rewards that were distributed by this bank\n    pub rewards: RwLock<Vec<(Pubkey, RewardInfo)>>,\n\n    pub cluster_type: Option<ClusterType>,\n\n    pub lazy_rent_collection: AtomicBool,\n\n    // this is temporary field only to remove rewards_pool entirely\n    pub rewards_pool_pubkeys: Arc<HashSet<Pubkey>>,\n\n    transaction_debug_keys: Option<Arc<HashSet<Pubkey>>>,\n\n    // Global configuration for how transaction logs should be collected across all banks\n    pub transaction_log_collector_config: Arc<RwLock<TransactionLogCollectorConfig>>,\n\n    // Logs from transactions that this Bank executed collected according to the criteria in\n    // `transaction_log_collector_config`\n    pub transaction_log_collector: Arc<RwLock<TransactionLogCollector>>,\n\n    pub feature_set: Arc<FeatureSet>,\n\n    /// Set of reserved account keys that cannot be write locked\n    reserved_account_keys: Arc<ReservedAccountKeys>,\n\n    /// callback function only to be called when dropping and should only be called once\n    pub drop_callback: RwLock<OptionalDropCallback>,\n\n    pub freeze_started: AtomicBool,\n\n    vote_only_bank: bool,\n\n    cost_tracker: RwLock<CostTracker>,\n\n    /// The initial accounts data size at the start of this Bank, before processing any transactions/etc\n    accounts_data_size_initial: u64,\n    /// The change to accounts data size in this Bank, due on-chain events (i.e. transactions)\n    accounts_data_size_delta_on_chain: AtomicI64,\n    /// The change to accounts data size in this Bank, due to off-chain events (i.e. rent collection)\n    accounts_data_size_delta_off_chain: AtomicI64,\n\n    /// until the skipped rewrites feature is activated, it is possible to skip rewrites and still include\n    /// the account hash of the accounts that would have been rewritten as bank hash expects.\n    skipped_rewrites: Mutex<HashMap<Pubkey, AccountHash>>,\n\n    /// Transaction fee structure\n    pub fee_structure: FeeStructure,\n\n    pub incremental_snapshot_persistence: Option<BankIncrementalSnapshotPersistence>,\n\n    epoch_reward_status: EpochRewardStatus,\n\n    transaction_processor: TransactionBatchProcessor<BankForks>,\n\n    check_program_modification_slot: bool,\n\n    /// Collected fee details\n    collector_fee_details: RwLock<CollectorFeeDetails>,\n}\n\nstruct VoteWithStakeDelegations {\n    vote_state: Arc<VoteState>,\n    vote_account: AccountSharedData,\n    delegations: Vec<(Pubkey, StakeAccount<Delegation>)>,\n}\n\ntype VoteWithStakeDelegationsMap = DashMap<Pubkey, VoteWithStakeDelegations>;\n\ntype InvalidCacheKeyMap = DashMap<Pubkey, InvalidCacheEntryReason>;\n\nstruct LoadVoteAndStakeAccountsResult {\n    vote_with_stake_delegations_map: VoteWithStakeDelegationsMap,\n    invalid_vote_keys: InvalidCacheKeyMap,\n    vote_accounts_cache_miss_count: usize,\n}\n\n#[derive(Debug)]\nstruct VoteReward {\n    vote_account: AccountSharedData,\n    commission: u8,\n    vote_rewards: u64,\n    vote_needs_store: bool,\n}\n\ntype VoteRewards = DashMap<Pubkey, VoteReward>;\n\n#[derive(Debug, Default)]\npub struct NewBankOptions {\n    pub vote_only_bank: bool,\n}\n\n#[derive(Debug, Default)]\npub struct BankTestConfig {\n    pub secondary_indexes: AccountSecondaryIndexes,\n}\n\n#[derive(Debug)]\nstruct PrevEpochInflationRewards {\n    validator_rewards: u64,\n    prev_epoch_duration_in_years: f64,\n    validator_rate: f64,\n    foundation_rate: f64,\n}\n\npub struct CommitTransactionCounts {\n    pub committed_transactions_count: u64,\n    pub committed_non_vote_transactions_count: u64,\n    pub committed_with_failure_result_count: u64,\n    pub signature_count: u64,\n}\n\nimpl Bank {\n    fn default_with_accounts(accounts: Accounts) -> Self {\n        let mut bank = Self {\n            skipped_rewrites: Mutex::default(),\n            incremental_snapshot_persistence: None,\n            rc: BankRc::new(accounts, Slot::default()),\n            status_cache: Arc::<RwLock<BankStatusCache>>::default(),\n            blockhash_queue: RwLock::<BlockhashQueue>::default(),\n            ancestors: Ancestors::default(),\n            hash: RwLock::<Hash>::default(),\n            parent_hash: Hash::default(),\n            parent_slot: Slot::default(),\n            hard_forks: Arc::<RwLock<HardForks>>::default(),\n            transaction_count: AtomicU64::default(),\n            non_vote_transaction_count_since_restart: AtomicU64::default(),\n            transaction_error"
    }
  ]
}