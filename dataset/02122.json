{
  "Title": "M-38: boundedSub() might fail to return the result that is bounded to prevent overflows",
  "Content": "# Issue M-38: boundedSub() might fail to return the result that is bounded to prevent overflows \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/16 \n\n## Found by \nchaduke\n\n## Summary\nThe goal of boundedSub() is to bound the result regardless what the inputs are to prevent overflows/underflows. However, the goal is not achieved for some cases. As a result, ``boundedSub()`` still might underflow and still might revert. The goal of the function is not achieved. \n\nAs a result, the protocol might not be fault-tolerant as it is supposed to be - when ``boundedSub()`` is designed to not revert in any case, it still might revert. For example, function ``MarketUtils.getNextFundingAmountPerSize()`` will be affected. \n \n\n## Vulnerability Detail\n``boundedSub()`` is designed to always bound its result between ``type(int256).min`` and ``type(int256).max`` so that it will never overflow/underflow:\n\n[https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/utils/Calc.sol#L116-L135](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/utils/Calc.sol#L116-L135)\n\nIt achieves its goal in three cases: \n1) Case 1: ``if either a or b is zero or the signs are the same there should not be any overflow``.\n\n2) Case 2: ``a > 0``, and ``b < 0``,  and ``a-b > type(int256).max``, then we need to return  ``type(int256).max``.\n\n3) Case 3: ``a < 0``, and ``b > 0``, and ``a - b <  type(int256).min``, then we need to return \n``type(int256).min``\n\nUnfortunately, the third case is implemented wrongly as follows:\n\n```javascipt\n // if subtracting `b` from `a` would result in a value less than the min int256 value\n        // then return the min int256 value\n        if (a < 0 && b <= type(int256).min - a) {\n            return type(int256).min;\n        }\n```\n\nwhich essentially is checking ``a < 0 && b + a <= type(int256).min``, a wrong condition to check.  Because of using this wrong condition, underflow cases will not be detected and the function will revert instead of returning `` type(int256).min`` in this case.\n\nTo verify, suppose a = ``type(int256).min`` and b = 1, ``a-b`` needs to be bounded to prevent underflow and the function should have returned  ``type(int256).min``. However, the function will fail the condition, as a result, it will not execute the if part, and the following final line will be executed instead: \n\n```javascript\nreturn a - b;\n```\nAs a result, instead of returning the minimum, the function will revert in the last line due to underflow. This violates the property of the function: it should have returned  the bounded result ``type(int256).min`` and should not have reverted in any case. \n\nThe following POC in Remix can show that the following function will revert: \n\n```javascript\nfunction testBoundedSub() public pure returns (int256){\n              return boundedSub(type(int256).min+3, 4);\n}\n```\n\n## Impact\n ``boundedSub()`` does not guarantee  underflow/overflow free  as it is designed to be. As a result, the protocol might break at points when it is not supposed to break. \n For example, function ``MarketUtils.getNextFundingAmountPerSize()`` will be affected. \n\n## Code Snippet\n\n## Tool used\nVsCode\n\nManual Review\n\n## Recommendation\nThe correction is as follows:\n```diff\n function boundedSub(int256 a, int256 b) internal pure returns (int256) {\n        // if either a or b is zero or the signs are the same there should not be any overflow\n        if (a == 0 || b == 0 || (a > 0 && b > 0) || (a < 0 && b < 0)) {\n            return a - b;\n        }\n\n        // if adding `-b` to `a` would result in a value greater than the max int256 value\n        // then return the max int256 value\n        if (a > 0 && -b >= type(int256).max - a) {\n            return type(int256).max;\n        }\n\n        // if subtracting `b` from `a` would result in a value less than the min int256 value\n        // then return the min int256 value\n-        if (a < 0 && b <= type(int256).min - a) {\n+        if (a < 0 && a <= type(int256).min + b) {\n            return type(int256).min;\n        }\n\n        return a - b;\n    }\n\n```\n\n\n\n\n## Discussion\n\n**xvi10**\n\nFix in https://github.com/gmx-io/gmx-synthetics/pull/110\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/utils/Calc.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n/**\n * @title Calc\n * @dev Library for math functions\n */\nlibrary Calc {\n    using SignedMath for int256;\n    using SafeCast for uint256;\n\n    /**\n     * @dev Calculates the result of dividing the first number by the second number,\n     * rounded up to the nearest integer.\n     *\n     * @param a the dividend\n     * @param b the divisor\n     * @return the result of dividing the first number by the second number, rounded up to the nearest integer\n     */\n    function roundUpDivision(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    /**\n     * Calculates the result of dividing the first number by the second number,\n     * rounded up to the nearest integer.\n     *\n     * @param a the dividend\n     * @param b the divisor\n     * @return the result of dividing the first number by the second number, rounded up to the nearest integer\n     */\n    function roundUpDivision(int256 a, uint256 b) internal pure returns (int256) {\n        if (a < 0) {\n            return (a - b.toInt256() + 1) / b.toInt256();\n        }\n\n        return (a + b.toInt256() - 1) / b.toInt256();\n    }\n\n    /**\n     * Adds two numbers together and return a uint256 value, treating the second number as a signed integer.\n     *\n     * @param a the first number\n     * @param b the second number\n     * @return the result of adding the two numbers together\n     */\n    function sumReturnUint256(uint256 a, int256 b) internal pure returns (uint256) {\n        if (b > 0) {\n            return a + b.abs();\n        }\n\n        return a - b.abs();\n    }\n\n    /**\n     * Adds two numbers together and return an int256 value, treating the second number as a signed integer.\n     *\n     * @param a the first number\n     * @param b the second number\n     * @return the result of adding the two numbers together\n     */\n    function sumReturnInt256(uint256 a, int256 b) internal pure returns (int256) {\n        return a.toInt256() + b;\n    }\n\n    /**\n     * @dev Calculates the absolute difference between two numbers.\n     *\n     * @param a the first number\n     * @param b the second number\n     * @return the absolute difference between the two numbers\n     */\n    function diff(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : b - a;\n    }\n\n    /**\n     * Adds two numbers together, the result is bounded to prevent overflows.\n     *\n     * @param a the first number\n     * @param b the second number\n     * @return the result of adding the two numbers together\n     */\n    function boundedAdd(int256 a, int256 b) internal pure returns (int256) {\n        // if either a or b is zero or if the signs are different there should not be any overflows\n        if (a == 0 || b == 0 || (a < 0 && b > 0) || (a > 0 && b < 0)) {\n            return a + b;\n        }\n\n        // if adding `b` to `a` would result in a value less than the min int256 value\n        // then return the min int256 value\n        if (a < 0 && b <= type(int256).min - a) {\n            return type(int256).min;\n        }\n\n        // if adding `b` to `a` would result in a value more than the max int256 value\n        // then return the max int256 value\n        if (a > 0 && b >= type(int256).max - a) {\n            return type(int256).max;\n        }\n\n        return a + b;\n    }\n\n    /**\n     * Returns a - b, the result is bounded to prevent overflows.\n     *\n     * @param a the first number\n     * @param b the second number\n     * @return the bounded result of a - b\n     */\n    function boundedSub(int256 a, int256 b) internal pure returns (int256) {\n        // if either a or b is zero or the signs are the same there should not be any overflow\n        if (a == 0 || b == 0 || (a > 0 && b > 0) || (a < 0 && b < 0)) {\n            return a - b;\n        }\n\n        // if adding `-b` to `a` would result in a value greater than the max int256 value\n        // then return the max int256 value\n        if (a > 0 && -b >= type(int256).max - a) {\n            return type(int256).max;\n        }\n\n        // if subtracting `b` from `a` would result in a value less than the min int256 value\n        // then return the min int256 value\n        if (a < 0 && b <= type(int256).min - a) {\n            return type(int256).min;\n        }\n\n        return a - b;\n    }\n\n\n    /**\n     * Converts the given unsigned integer to a signed integer, using the given\n     * flag to determine whether the result should be positive or negative.\n     *\n     * @param a the unsigned integer to convert\n     * @param isPositive whether the result should be positive (if true) or negative (if false)\n     * @return the signed integer representation of the given unsigned integer\n     */\n    function toSigned(uint256 a, bool isPositive) internal pure returns (int256) {\n        if (isPositive) {\n            return a.toInt256();\n        } else {\n            return -a.toInt256();\n        }\n    }\n}"
    }
  ]
}