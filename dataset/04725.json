{
  "Title": "[NC-04] Erroneous math in documentation",
  "Content": "\nIn the documentation for `rOUSG` it says [`rOUSG#L36-L45`](https://github.com/code-423n4/2024-03-ondo-finance/blob/main/contracts/ousg/rOUSG.sol#L36-L45):\n\n```solidity\nFile: contracts/ousg/rOUSG.sol\n\n36: * For example, assume that we have:\n37: *\n38: *   ousgPrice = 100.505\n39: *   sharesOf(user1) -> 100\n40: *   sharesOf(user2) -> 400\n41: *\n42: * Therefore:\n43: *\n44: *   balanceOf(user1) -> 105 tokens which corresponds 105 rOUSG\n45: *   balanceOf(user2) -> 420 tokens which corresponds 420 rOUSG\n```\n\nThis is confusing. As first, one share is one ten-thousandth of a `OUSG`; it is unclear what a \"share\" means here. Second, the math is wrong, `100 * 100.505 / 100 = 100.505` and `400 * 100.505 / 100 = 402.02`.\n\nConsider updating the documentation.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-ondo-finance",
  "Code": [
    {
      "filename": "contracts/ousg/rOUSG.sol",
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/external/openzeppelin/contracts/token/IERC20.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/IERC20MetadataUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"contracts/kyc/KYCRegistryClientUpgradeable.sol\";\nimport \"contracts/rwaOracles/IRWAOracle.sol\";\n\n/**\n * @title Interest-bearing ERC20-like token for OUSG.\n *\n * rOUSG balances are dynamic and represent the holder's share of the underlying OUSG\n * controlled by the protocol. To calculate each account's balance, we do\n *\n *   shares[account] * ousgPrice\n *\n * For example, assume that we have:\n *\n *   ousgPrice = 100.505\n *   sharesOf(user1) -> 100\n *   sharesOf(user2) -> 400\n *\n * Therefore:\n *\n *   balanceOf(user1) -> 105 tokens which corresponds 105 rOUSG\n *   balanceOf(user2) -> 420 tokens which corresponds 420 rOUSG\n *\n * Since balances of all token holders change when the price of OUSG changes, this\n * token cannot fully implement ERC20 standard: it only emits `Transfer` events\n * upon explicit transfer between holders. In contrast, when total amount of pooled\n * Cash increases, no `Transfer` events are generated: doing so would require emitting\n * an event for each token holder and thus running an unbounded loop.\n *\n */\n\ncontract ROUSG is\n  Initializable,\n  ContextUpgradeable,\n  PausableUpgradeable,\n  AccessControlEnumerableUpgradeable,\n  KYCRegistryClientUpgradeable,\n  IERC20Upgradeable,\n  IERC20MetadataUpgradeable\n{\n  /**\n   * @dev rOUSG balances are dynamic and are calculated based on the accounts' shares (OUSG)\n   * and the the price of OUSG. Account shares aren't\n   * normalized, so the contract also stores the sum of all shares to calculate\n   * each account's token balance which equals to:\n   *\n   *   shares[account] * ousgPrice\n   */\n  mapping(address => uint256) private shares;\n\n  /// @dev Allowances are nominated in tokens, not token shares.\n  mapping(address => mapping(address => uint256)) private allowances;\n\n  // Total shares in existence\n  uint256 private totalShares;\n\n  // Address of the oracle that provides the `ousgPrice`\n  IRWAOracle public oracle;\n\n  // Address of the OUSG token\n  IERC20 public ousg;\n\n  // Used to scale up ousg amount -> shares\n  uint256 public constant OUSG_TO_ROUSG_SHARES_MULTIPLIER = 10_000;\n\n  // Error when redeeming shares < `OUSG_TO_ROUSG_SHARES_MULTIPLIER`\n  error UnwrapTooSmall();\n\n  /// @dev Role based access control roles\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n  bytes32 public constant BURNER_ROLE = keccak256(\"BURN_ROLE\");\n  bytes32 public constant CONFIGURER_ROLE = keccak256(\"CONFIGURER_ROLE\");\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize(\n    address _kycRegistry,\n    uint256 requirementGroup,\n    address _ousg,\n    address guardian,\n    address _oracle\n  ) public virtual initializer {\n    __rOUSG_init(_kycRegistry, requirementGroup, _ousg, guardian, _oracle);\n  }\n\n  function __rOUSG_init(\n    address _kycRegistry,\n    uint256 requirementGroup,\n    address _ousg,\n    address guardian,\n    address _oracle\n  ) internal onlyInitializing {\n    __rOUSG_init_unchained(\n      _kycRegistry,\n      requirementGroup,\n      _ousg,\n      guardian,\n      _oracle\n    );\n  }\n\n  function __rOUSG_init_unchained(\n    address _kycRegistry,\n    uint256 _requirementGroup,\n    address _ousg,\n    address guardian,\n    address _oracle\n  ) internal onlyInitializing {\n    __KYCRegistryClientInitializable_init(_kycRegistry, _requirementGroup);\n    ousg = IERC20(_ousg);\n    oracle = IRWAOracle(_oracle);\n    _grantRole(DEFAULT_ADMIN_ROLE, guardian);\n    _grantRole(PAUSER_ROLE, guardian);\n    _grantRole(BURNER_ROLE, guardian);\n    _grantRole(CONFIGURER_ROLE, guardian);\n  }\n\n  /**\n   * @notice An executed shares transfer from `sender` to `recipient`.\n   *\n   * @dev emitted in pair with an ERC20-defined `Transfer` event.\n   */\n  event TransferShares(\n    address indexed from,\n    address indexed to,\n    uint256 sharesValue\n  );\n\n  /**\n   * @notice Emitted when the oracle address is set\n   *\n   * @param oldOracle The address of the old oracle\n   * @param newOracle The address of the new oracle\n   */\n  event OracleSet(address indexed oldOracle, address indexed newOracle);\n\n  /**\n   * @return the name of the token.\n   */\n  function name() public pure returns (string memory) {\n    return \"Rebasing OUSG\";\n  }\n\n  /**\n   * @return the symbol of the token, usually a shorter version of the\n   * name.\n   */\n  function symbol() public pure returns (string memory) {\n    return \"rOUSG\";\n  }\n\n  /**\n   * @return the number of decimals for getting user representation of a token amount.\n   */\n  function decimals() public pure returns (uint8) {\n    return 18;\n  }\n\n  /**\n   * @return the amount of tokens in existence.\n   */\n  function totalSupply() public view returns (uint256) {\n    return\n      (totalShares * getOUSGPrice()) / (1e18 * OUSG_TO_ROUSG_SHARES_MULTIPLIER);\n  }\n\n  /**\n   * @return the amount of tokens owned by the `_account`.\n   *\n   * @dev Balances are dynamic and equal the `_account`'s OUSG shares multiplied\n   *      by the price of OUSG\n   */\n  function balanceOf(address _account) public view returns (uint256) {\n    return\n      (_sharesOf(_account) * getOUSGPrice()) /\n      (1e18 * OUSG_TO_ROUSG_SHARES_MULTIPLIER);\n  }\n\n  /**\n   * @notice Moves `_amount` tokens from the caller's account to the `_recipient` account.\n   *\n   * @return a boolean value indicating whether the operation succeeded.\n   * Emits a `Transfer` event.\n   * Emits a `TransferShares` event.\n   *\n   * Requirements:\n   *\n   * - `_recipient` cannot be the zero address.\n   * - the caller must have a balance of at least `_amount`.\n   * - the contract must not be paused.\n   *\n   * @dev The `_amount` argument is the amount of tokens, not shares.\n   */\n  function transfer(address _recipient, uint256 _amount) public returns (bool) {\n    _transfer(msg.sender, _recipient, _amount);\n    return true;\n  }\n\n  /**\n   * @return the remaining number of tokens that `_spender` is allowed to spend\n   * on behalf of `_owner` through `transferFrom`. This is zero by default.\n   *\n   * @dev This value changes when `approve` or `transferFrom` is called.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n  ) public view returns (uint256) {\n    return allowances[_owner][_spender];\n  }\n\n  /**\n   * @notice Sets `_amount` as the allowance of `_spender` over the caller's tokens.\n   *\n   * @return a boolean value indicating whether the operation succeeded.\n   * Emits an `Approval` event.\n   *\n   * Requirements:\n   *\n   * - `_spender` cannot be the zero address.\n   * - the contract must not be paused.\n   *\n   * @dev The `_amount` argument is the amount of tokens, not shares.\n   */\n  function approve(address _spender, uint256 _amount) public returns (bool) {\n    _approve(msg.sender, _spender, _amount);\n    return true;\n  }\n\n  /**\n   * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n   * allowance mechanism. `_amount` is then deducted from the caller's\n   * allowance.\n   *\n   * @return a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a `Transfer` event.\n   * Emits a `TransferShares` event.\n   * Emits an `Approval` event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `_sender` and `_recipient` cannot be the zero addresses.\n   * - `_sender` must have a balance of at least `_amount`.\n   * - the caller must have allowance for `_sender`'s tokens of at least `_amount`.\n   * - the contract must not be paused.\n   *\n   * @dev The `_amount` argument is the amount of tokens, not shares.\n   */\n  function transferFrom(\n    address _sender,\n    address _recipient,\n    uint256 _amount\n  ) public returns (bool) {\n    uint256 currentAllowance = allowances[_sender][msg.sender];\n    require(currentAllowance >= _amount, \"TRANSFER_AMOUNT_EXCEEDS_ALLOWANCE\");\n\n    _transfer(_sender, _recipient, _amount);\n    _approve(_sender, msg.sender, currentAllowance - _amount);\n    return true;\n  }\n\n  /**\n   * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n   *\n   * This is an alternative to `approve` that can be used as a mitigation for\n   * problems described in:\n   * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol#L42\n   * Emits an `Approval` event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `_spender` cannot be the the zero address.\n   * - the contract must not be paused.\n   */\n  function increaseAllowance(\n    address _spender,\n    uint256 _addedValue\n  ) public returns (bool) {\n    _approve(\n      msg.sender,\n      _spender,\n      allowances[msg.sender][_spender] + _addedValue\n    );\n    return true;\n  }\n\n  /**\n   * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n   *\n   * This is an alternative to `approve` that can be used as a mitigation for\n   * problems described in:\n   * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol#L42\n   * Emits an `Approval` event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `_spender` cannot be the zero address.\n   * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n   * - the contract must not be paused.\n   */\n  function decreaseAllowance(\n    address _spender,\n    uint256 _subtractedValue\n  ) public returns (bool) {\n    uint256 currentAllowance = allowances[msg.sender][_spender];\n    require(\n      currentAllowance >= _subtractedValue,\n      \"DECREASED_ALLOWANCE_BELOW_ZERO\"\n    );\n    _approve(msg.sender, _spender, currentAllowance - _subtractedValue);\n    return true;\n  }\n\n  /**\n   * @return the total amount of shares in existence.\n   *\n   * @dev The sum of all accounts' shares can be an arbitrary number, therefore\n   * it is necessary to store it in order to calculate each account's relative share.\n   */\n  function getTotalShares() public view returns (uint256) {\n    return totalShares;\n  }\n\n  /**\n   * @return the amount of shares owned by `_account`.\n   *\n   * @dev This is the equivalent to the amount of OUSG wrapped by `_account`.\n   */\n  function sharesOf(address _account) public view returns (uint256) {\n    return _sharesOf(_account);\n  }\n\n  /**\n   * @return the amount of shares that corresponds to `_rOUSGAmount` of rOUSG\n   */\n  function getSharesByROUSG(\n    uint256 _rOUSGAmount\n  ) public view returns (uint256) {\n    return\n      (_rOUSGAmount * 1e18 * OUSG_TO_ROUSG_SHARES_MULTIPLIER) / getOUSGPrice();\n  }\n\n  /**\n   * @return the amount of rOUSG that corresponds to `_shares` of OUSG.\n   */\n  function getROUSGByShares(uint256 _shares) public view returns (uint256) {\n    return\n      (_shares * getOUSGPrice()) / (1e18 * OUSG_TO_ROUSG_SHARES_MULTIPLIER);\n  }\n\n  function getOUSGPrice() public view returns (uint256 price) {\n    (price, ) = oracle.getPriceData();\n  }\n\n  /**\n   * @notice Moves `_sharesAmount` token shares from the caller's account to the `_recipient` account.\n   *\n   * @return amount of transferred tokens.\n   * Emits a `TransferShares` event.\n   * Emits a `Transfer` event.\n   *\n   * Requirements:\n   *\n   * - `_recipient` cannot be the zero address.\n   * - the caller must have at least `_sharesAmount` shares.\n   * - the contract must not be paused.\n   *\n   * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n   */\n  function transferShares(\n    address _recipient,\n    uint256 _sharesAmount\n  ) public returns (uint256) {\n    _transferShares(msg.sender, _recipient, _sharesAmount);\n    emit TransferShares(msg.sender, _recipient, _sharesAmount);\n    uint256 tokensAmount = getROUSGByShares(_sharesAmount);\n    emit Transfer(msg.sender, _recipient, tokensAmount);\n    return tokensAmount;\n  }\n\n  /**\n   * @notice Function called by users to wrap their OUSG tokens\n   *\n   * @param _OUSGAmount The amount of OUSG Tokens to wrap\n   *\n   * @dev KYC checks implicit in OUSG Transfer\n   */\n  function wrap(uint256 _OUSGAmount) external whenNotPaused {\n    require(_OUSGAmount > 0, \"rOUSG: can't wrap zero OUSG tokens\");\n    uint256 ousgSharesAmount = _OUSGAmount * OUSG_TO_ROUSG_SHARES_MULTIPLIER;\n    _mintShares(msg.sender, ousgSharesAmount);\n    ousg.transferFrom(msg.sender, address(this), _OUSGAmount);\n    emit Transfer(address(0), msg.sender, getROUSGByShares(ousgSharesAmount));\n    emit TransferShares(address(0), msg.sender, ousgSharesAmount);\n  }\n\n  /**\n   * @notice Function called by users to unwrap their rOUSG tokens\n   *\n   * @param _rOUSGAmount The amount of rOUSG to unwrap\n   *\n   * @dev KYC checks implicit in OUSG Transfer\n   */\n  function unwrap(uint256 _rOUSGAmount) external whenNotPaused {\n    require(_rOUSGAmount > 0, \"rOUSG: can't unwrap zero rOUSG tokens\");\n    uint256 ousgSharesAmount = getSharesByROUSG(_rOUSGAmount);\n    if (ousgSharesAmount < OUSG_TO_ROUSG_SHARES_MULTIPLIER)\n      revert UnwrapTooSmall();\n    _burnShares(msg.sender, ousgSharesAmount);\n    ousg.transfer(\n      msg.sender,\n      ousgSharesAmount / OUSG_TO_ROUSG_SHARES_MULTIPLIER\n    );\n    emit Transfer(msg.sender, address(0), _rOUSGAmount);\n    emit TransferShares(msg.sender, address(0), ousgSharesAmount);\n  }\n\n  /**\n   * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n   * Emits a `Transfer` event.\n   * Emits a `TransferShares` event.\n   */\n  function _transfer(\n    address _sender,\n    address _recipient,\n    uint256 _amount\n  ) internal {\n    uint256 _sharesToTransfer = getSharesByROUSG(_amount);\n    _transferShares(_sender, _recipient, _sharesToTransfer);\n    emit Transfer(_sender, _recipient, _amount);\n    emit TransferShares(_sender, _recipient, _sharesToTransfer);\n  }\n\n  /**\n   * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n   *\n   * Emits an `Approval` event.\n   *\n   * Requirements:\n   *\n   * - `_owner` cannot be the zero address.\n   * - `_spender` cannot be the zero address.\n   * - the contract must not be paused.\n   */\n  function _approve(\n    address _owner,\n    address _spender,\n    uint256 _amount\n  ) internal whenNotPaused {\n    require(_owner != address(0), \"APPROVE_FROM_ZERO_ADDRESS\");\n    require(_spender != address(0), \"APPROVE_TO_ZERO_ADDRESS\");\n\n    allowances[_owner][_spender] = _amount;\n    emit Approval(_owner, _spender, _amount);\n  }\n\n  /**\n   * @return the amount of shares owned by `_account`.\n   */\n  function _sharesOf(address _account) internal view returns (uint256) {\n    return shares[_account];\n  }\n\n  /**\n   * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n   *\n   * Requirements:\n   *\n   * - `_sender` cannot be the zero address.\n   * - `_recipient` cannot be the zero address.\n   * - `_sender` must hold at least `_sharesAmount` shares.\n   * - the contract must not be paused.\n   */\n  function _transferShares(\n    address _sender,\n    address _recipient,\n    uint256 _sharesAmount\n  ) internal whenNotPaused {\n    require(_sender != address(0), \"TRANSFER_FROM_THE_ZERO_ADDRESS\");\n    require(_recipient != address(0), \"TRANSFER_TO_THE_ZERO_ADDRESS\");\n\n    _beforeTokenTransfer(_sender, _recipient, _sharesAmount);\n\n    uint256 currentSenderShares = shares[_sender];\n    require(\n      _sharesAmount <= currentSenderShares,\n      \"TRANSFER_AMOUNT_EXCEEDS_BALANCE\"\n    );\n\n    shares[_sender] = currentSenderShares - _sharesAmount;\n    shares[_recipient] = shares[_recipient] + _sharesAmount;\n  }\n\n  /**\n   * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n   *\n   * Requirements:\n   *\n   * - `_recipient` cannot be the zero address.\n   * - the contract must not be paused.\n   */\n  function _mintShares(\n    address _recipient,\n    uint256 _sharesAmount\n  ) internal whenNotPaused returns (uint256) {\n    require(_recipient != address(0), \"MINT_TO_THE_ZERO_ADDRESS\");\n\n    _beforeTokenTransfer(address(0), _recipient, _sharesAmount);\n\n    totalShares += _sharesAmount;\n\n    shares[_recipient] = shares[_recipient] + _sharesAmount;\n\n    return totalShares;\n  }\n\n  /**\n   * @notice Destroys `_sharesAmount` shares from `_account`'s holdings, decreasing the total amount of shares.\n   * @dev This doesn't decrease the token total supply.\n   *\n   * Requirements:\n   *\n   * - `_account` cannot be the zero address.\n   * - `_account` must hold at least `_sharesAmount` shares.\n   * - the contract must not be paused.\n   */\n  function _burnShares(\n    address _account,\n    uint256 _sharesAmount\n  ) internal whenNotPaused returns (uint256) {\n    require(_account != address(0), \"BURN_FROM_THE_ZERO_ADDRESS\");\n\n    _beforeTokenTransfer(_account, address(0), _sharesAmount);\n\n    uint256 accountShares = shares[_account];\n    require(_sharesAmount <= accountShares, \"BURN_AMOUNT_EXCEEDS_BALANCE\");\n\n    totalShares -= _sharesAmount;\n\n    shares[_account] = accountShares - _sharesAmount;\n\n    return totalShares;\n  }\n\n  /**\n   * @dev Hook that is called before any transfer of tokens. This includes\n   * minting and burning.\n   *\n   * Calling conditions:\n   *\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n   * will be transferred to `to`.\n   * - when `from` is zero, `amount` tokens will be minted for `to`.\n   * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n   * - `from` and `to` are never both zero.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256\n  ) internal view {\n    // Check constraints when `transferFrom` is called to facliitate\n    // a transfer between two parties that are not `from` or `to`.\n    if (from != msg.sender && to != msg.sender) {\n      require(_getKYCStatus(msg.sender), \"rOUSG: 'sender' address not KYC'd\");\n    }\n\n    if (from != address(0)) {\n      // If not minting\n      require(_getKYCStatus(from), \"rOUSG: 'from' address not KYC'd\");\n    }\n\n    if (to != address(0)) {\n      // If not burning\n      require(_getKYCStatus(to), \"rOUSG: 'to' address not KYC'd\");\n    }\n  }\n\n  /**\n   * @notice Sets the Oracle address\n   * @dev The new oracle must comply with the IRWAOracle interface\n   * @param _oracle Address of the new oracle\n   */\n  function setOracle(address _oracle) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    emit OracleSet(address(oracle), _oracle);\n    oracle = IRWAOracle(_oracle);\n  }\n\n  /**\n   * @notice Admin burn function to burn rOUSG tokens from any account\n   * @param _account The account to burn tokens from\n   * @param _amount  The amount of rOUSG tokens to burn\n   * @dev Transfers burned shares (OUSG) to `msg.sender`\n   */\n  function burn(\n    address _account,\n    uint256 _amount\n  ) external onlyRole(BURNER_ROLE) {\n    uint256 ousgSharesAmount = getSharesByROUSG(_amount);\n    if (ousgSharesAmount < OUSG_TO_ROUSG_SHARES_MULTIPLIER)\n      revert UnwrapTooSmall();\n\n    _burnShares(_account, ousgSharesAmount);\n\n    ousg.transfer(\n      msg.sender,\n      ousgSharesAmount / OUSG_TO_ROUSG_SHARES_MULTIPLIER\n    );\n    emit Transfer(address(0), msg.sender, getROUSGByShares(ousgSharesAmount));\n    emit TransferShares(_account, address(0), ousgSharesAmount);\n  }\n\n  function pause() external onlyRole(PAUSER_ROLE) {\n    _pause();\n  }\n\n  function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _unpause();\n  }\n\n  function setKYCRegistry(\n    address registry\n  ) external override onlyRole(CONFIGURER_ROLE) {\n    _setKYCRegistry(registry);\n  }\n\n  function setKYCRequirementGroup(\n    uint256 group\n  ) external override onlyRole(CONFIGURER_ROLE) {\n    _setKYCRequirementGroup(group);\n  }\n}"
    }
  ]
}