{
  "Title": "The approval value obtained in the constructor may not be enough for the long term of the smart contract",
  "Content": "##### Description\nSmart contracts call `safeApprove()` functions for different tokens. But in the process of work, the obtained value will only decrease. If this value decreases to zero, then the tokens will remain locked in the contract forever.\nIt is at the following lines:\n- https://github.com/orbxball/stablecoins-3pool/blob/adeb776933c6cb3b8306239cc3357d4c6239a88d/contracts/StrategyDAI.sol#L39-L41\n- https://github.com/orbxball/stablecoins-3pool/blob/adeb776933c6cb3b8306239cc3357d4c6239a88d/contracts/StrategyUSDC.sol#L39-L41\n- https://github.com/orbxball/stablecoins-3pool/blob/adeb776933c6cb3b8306239cc3357d4c6239a88d/contracts/StrategyUSDT.sol#L39-L41\n  \n##### Recommendation\nIt is recommended to add a function to increase the value of approvals.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/StrategyDAI.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {\n    BaseStrategy,\n    StrategyParams\n} from \"@yearnvaults/contracts/BaseStrategy.sol\";\nimport \"@openzeppelinV3/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelinV3/contracts/math/SafeMath.sol\";\nimport \"@openzeppelinV3/contracts/utils/Address.sol\";\nimport \"@openzeppelinV3/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../interfaces/yearn/yvERC20.sol\";\nimport \"../interfaces/curve/ICurveFI.sol\";\n\n\ncontract StrategyDAI3pool is BaseStrategy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address constant public _3pool = address(0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7);\n    address constant public _3crv = address(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);\n    address constant public y3crv = address(0x9cA85572E6A3EbF24dEDd195623F188735A5179f);\n\n    uint256 constant public DENOMINATOR = 10000;\n    uint256 public threshold;\n    uint256 public slip;\n    uint256 public tank;\n    uint256 public p;\n\n    constructor(address _vault) public BaseStrategy(_vault) {\n        // minReportDelay = 6300;\n        // profitFactor = 100;\n        // debtThreshold = 0;\n        threshold = 8000;\n        slip = 100;\n        want.safeApprove(_3pool, uint256(-1));\n        IERC20(_3crv).safeApprove(y3crv, uint256(-1));\n        IERC20(_3crv).safeApprove(_3pool, uint256(-1));\n    }\n\n    function setThreshold(uint256 _threshold) external onlyAuthorized {\n        threshold = _threshold;\n    }\n\n    function setSlip(uint256 _slip) external onlyAuthorized {\n        slip = _slip;\n    }\n\n    function name() external override pure returns (string memory) {\n        return \"StrategyCurve3poolDAI\";\n    }\n\n    function estimatedTotalAssets() public override view returns (uint256) {\n        return balanceOfWant().add(balanceOfy3CRVinWant());\n    }\n\n    function balanceOfWant() public view returns (uint256) {\n        return want.balanceOf(address(this));\n    }\n\n    function balanceOfy3CRV() public view returns (uint256) {\n        return IERC20(y3crv).balanceOf(address(this));\n    }\n\n    function balanceOfy3CRVinWant() public view returns (uint256) {\n        return balanceOfy3CRV()\n                .mul(yvERC20(y3crv).getPricePerFullShare()).div(1e18)\n                .mul(ICurveFi(_3pool).get_virtual_price()).div(1e18);\n    }\n\n    function prepareReturn(uint256 _debtOutstanding)\n        internal\n        override\n        returns (\n            uint256 _profit,\n            uint256 _loss,\n            uint256 _debtPayment\n        )\n    {\n        _profit = want.balanceOf(address(this));\n        uint256 _p = yvERC20(y3crv).getPricePerFullShare();\n        _p = _p.mul(ICurveFi(_3pool).get_virtual_price()).div(1e18);\n        if (_p >= p) {\n            _profit = _profit.add((_p.sub(p)).mul(balanceOfy3CRV()).div(1e18));\n        }\n        else {\n            _loss = (p.sub(_p)).mul(balanceOfy3CRV()).div(1e18);\n        }\n        p = _p;\n\n        if (_debtOutstanding > 0) {\n            _debtPayment = liquidatePosition(_debtOutstanding);\n        }\n    }\n\n    function adjustPosition(uint256 _debtOutstanding) internal override {\n        rebalance();\n        _deposit();\n    }\n\n    function _deposit() internal {\n        uint256 _want = (want.balanceOf(address(this))).sub(tank);\n        if (_want > 0) {\n            uint256 v = _want.mul(1e18).div(ICurveFi(_3pool).get_virtual_price());\n            ICurveFi(_3pool).add_liquidity([_want, 0, 0], v.mul(DENOMINATOR.sub(slip)).div(DENOMINATOR));\n        }\n        uint256 _bal = IERC20(_3crv).balanceOf(address(this));\n        if (_bal > 0) {\n            yvERC20(y3crv).deposit(_bal);\n        }\n    }\n\n    function exitPosition(uint256 _debtOutstanding)\n        internal\n        override\n        returns (uint256 _profit, uint256 _loss, uint256 _debtPayment)\n    {\n        (_profit, _loss, _debtPayment) = prepareReturn(_debtOutstanding);\n        _withdrawAll();\n        _debtPayment = want.balanceOf(address(this));\n    }\n\n    function _withdrawAll() internal {\n        uint256 _y3crv = IERC20(y3crv).balanceOf(address(this));\n        if (_y3crv > 0) {\n            yvERC20(y3crv).withdraw(_y3crv);\n            _withdrawOne(IERC20(_3crv).balanceOf(address(this)));\n        }\n    }\n\n    function _withdrawOne(uint256 _amnt) internal returns (uint256) {\n        uint256 _before = want.balanceOf(address(this));\n        ICurveFi(_3pool).remove_liquidity_one_coin(_amnt, 0, _amnt.mul(DENOMINATOR.sub(slip)).div(DENOMINATOR));\n        uint256 _after = want.balanceOf(address(this));\n        \n        return _after.sub(_before);\n    }\n\n    function liquidatePosition(uint256 _amountNeeded)\n        internal\n        override\n        returns (uint256 _amountFreed)\n    {\n        uint256 _balance = want.balanceOf(address(this));\n        if (_balance < _amountNeeded) {\n            _amountFreed = _withdrawSome(_amountNeeded.sub(_balance));\n            _amountFreed = _amountFreed.add(_balance);\n            tank = 0;\n        }\n        else {\n            _amountFreed = _amountNeeded;\n            if (tank >= _amountNeeded) tank = tank.sub(_amountNeeded);\n            else tank = 0;\n        }\n    }\n\n    function _withdrawSome(uint256 _amount) internal returns (uint256) {\n        uint256 _amnt = _amount.mul(1e18).div(ICurveFi(_3pool).get_virtual_price());\n        uint256 _amt = _amnt.mul(1e18).div(yvERC20(y3crv).getPricePerFullShare());\n        uint256 _before = IERC20(_3crv).balanceOf(address(this));\n        yvERC20(y3crv).withdraw(_amt);\n        uint256 _after = IERC20(_3crv).balanceOf(address(this));\n        return _withdrawOne(_after.sub(_before));\n    }\n\n    // NOTE: Can override `tendTrigger` and `harvestTrigger` if necessary\n    function tendTrigger(uint256 callCost) public override view returns (bool) {\n        (uint256 _t, uint256 _c) = tick();\n        return (_c > _t);\n    }\n\n    function prepareMigration(address _newStrategy) internal override {\n        IERC20(y3crv).safeTransfer(_newStrategy, IERC20(y3crv).balanceOf(address(this)));\n        IERC20(_3crv).safeTransfer(_newStrategy, IERC20(_3crv).balanceOf(address(this)));\n    }\n\n    function protectedTokens()\n        internal\n        override\n        view\n        returns (address[] memory)\n    {\n        address[] memory protected = new address[](2);\n        protected[0] = _3crv;\n        protected[1] = y3crv;\n        return protected;\n    }\n\n    function tick() public view returns (uint256 _t, uint256 _c) {\n        _t = ICurveFi(_3pool).balances(0).mul(threshold).div(DENOMINATOR);\n        _c = balanceOfy3CRVinWant();\n    }\n\n    function rebalance() public {\n        (uint256 _t, uint256 _c) = tick();\n        if (_c > _t) {\n            _withdrawSome(_c.sub(_t));\n            tank = want.balanceOf(address(this));\n        }\n    }\n\n    function forceD(uint256 _amount) external onlyAuthorized {\n        uint256 v = _amount.mul(1e18).div(ICurveFi(_3pool).get_virtual_price());\n        ICurveFi(_3pool).add_liquidity([_amount, 0, 0], v.mul(DENOMINATOR.sub(slip)).div(DENOMINATOR));\n        if (_amount < tank) tank = tank.sub(_amount);\n        else tank = 0;\n\n        uint256 _bal = IERC20(_3crv).balanceOf(address(this));\n        yvERC20(y3crv).deposit(_bal);\n    }\n\n    function forceW(uint256 _amt) external onlyAuthorized {\n        uint256 _before = IERC20(_3crv).balanceOf(address(this));\n        yvERC20(y3crv).withdraw(_amt);\n        uint256 _after = IERC20(_3crv).balanceOf(address(this));\n        _amt = _after.sub(_before);\n        \n        _before = want.balanceOf(address(this));\n        ICurveFi(_3pool).remove_liquidity_one_coin(_amt, 0, _amt.mul(DENOMINATOR.sub(slip)).div(DENOMINATOR));\n        _after = want.balanceOf(address(this));\n        tank = tank.add(_after.sub(_before));\n    }\n}"
    },
    {
      "filename": "contracts/StrategyUSDC.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {\n    BaseStrategy,\n    StrategyParams\n} from \"@yearnvaults/contracts/BaseStrategy.sol\";\nimport \"@openzeppelinV3/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelinV3/contracts/math/SafeMath.sol\";\nimport \"@openzeppelinV3/contracts/utils/Address.sol\";\nimport \"@openzeppelinV3/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../interfaces/yearn/yvERC20.sol\";\nimport \"../interfaces/curve/ICurveFI.sol\";\n\n\ncontract StrategyUSDC3pool is BaseStrategy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address constant public _3pool = address(0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7);\n    address constant public _3crv = address(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);\n    address constant public y3crv = address(0x9cA85572E6A3EbF24dEDd195623F188735A5179f);\n\n    uint256 constant public DENOMINATOR = 10000;\n    uint256 public threshold;\n    uint256 public slip;\n    uint256 public tank;\n    uint256 public p;\n\n    constructor(address _vault) public BaseStrategy(_vault) {\n        // minReportDelay = 6300;\n        // profitFactor = 100;\n        // debtThreshold = 0;\n        threshold = 8000;\n        slip = 100;\n        want.safeApprove(_3pool, uint256(-1));\n        IERC20(_3crv).safeApprove(y3crv, uint256(-1));\n        IERC20(_3crv).safeApprove(_3pool, uint256(-1));\n    }\n\n    function setThreshold(uint256 _threshold) external onlyAuthorized {\n        threshold = _threshold;\n    }\n\n    function setSlip(uint256 _slip) external onlyAuthorized {\n        slip = _slip;\n    }\n\n    function name() external override pure returns (string memory) {\n        return \"StrategyCurve3poolUSDC\";\n    }\n\n    function estimatedTotalAssets() public override view returns (uint256) {\n        return balanceOfWant().add(balanceOfy3CRVinWant());\n    }\n\n    function balanceOfWant() public view returns (uint256) {\n        return want.balanceOf(address(this));\n    }\n\n    function balanceOfy3CRV() public view returns (uint256) {\n        return IERC20(y3crv).balanceOf(address(this));\n    }\n\n    function balanceOfy3CRVinWant() public view returns (uint256) {\n        return balanceOfy3CRV()\n                .mul(yvERC20(y3crv).getPricePerFullShare()).div(1e18)\n                .mul(ICurveFi(_3pool).get_virtual_price()).div(1e30);\n    }\n\n    function prepareReturn(uint256 _debtOutstanding)\n        internal\n        override\n        returns (\n            uint256 _profit,\n            uint256 _loss,\n            uint256 _debtPayment\n        )\n    {\n        _profit = want.balanceOf(address(this));\n        uint256 _p = yvERC20(y3crv).getPricePerFullShare();\n        _p = _p.mul(ICurveFi(_3pool).get_virtual_price()).div(1e18);\n        if (_p >= p) {\n            _profit = _profit.add((_p.sub(p)).mul(balanceOfy3CRV()).div(1e30));\n        }\n        else {\n            _loss = (p.sub(_p)).mul(balanceOfy3CRV()).div(1e30);\n        }\n        p = _p;\n\n        if (_debtOutstanding > 0) {\n            _debtPayment = liquidatePosition(_debtOutstanding);\n        }\n    }\n\n    function adjustPosition(uint256 _debtOutstanding) internal override {\n        rebalance();\n        _deposit();\n    }\n\n    function _deposit() internal {\n        uint256 _want = (want.balanceOf(address(this))).sub(tank);\n        if (_want > 0) {\n            uint256 v = _want.mul(1e30).div(ICurveFi(_3pool).get_virtual_price());\n            ICurveFi(_3pool).add_liquidity([0, _want, 0], v.mul(DENOMINATOR.sub(slip)).div(DENOMINATOR));\n        }\n        uint256 _bal = IERC20(_3crv).balanceOf(address(this));\n        if (_bal > 0) {\n            yvERC20(y3crv).deposit(_bal);\n        }\n    }\n\n    function exitPosition(uint256 _debtOutstanding)\n        internal\n        override\n        returns (uint256 _profit, uint256 _loss, uint256 _debtPayment)\n    {\n        (_profit, _loss, _debtPayment) = prepareReturn(_debtOutstanding);\n        _withdrawAll();\n        _debtPayment = want.balanceOf(address(this));\n    }\n\n    function _withdrawAll() internal {\n        uint256 _y3crv = IERC20(y3crv).balanceOf(address(this));\n        if (_y3crv > 0) {\n            yvERC20(y3crv).withdraw(_y3crv);\n            _withdrawOne(IERC20(_3crv).balanceOf(address(this)));\n        }\n    }\n\n    function _withdrawOne(uint256 _amnt) internal returns (uint256) {\n        uint256 _before = want.balanceOf(address(this));\n        ICurveFi(_3pool).remove_liquidity_one_coin(_amnt, 1, _amnt.mul(DENOMINATOR.sub(slip)).div(DENOMINATOR).div(1e12));\n        uint256 _after = want.balanceOf(address(this));\n        \n        return _after.sub(_before);\n    }\n\n    function liquidatePosition(uint256 _amountNeeded)\n        internal\n        override\n        returns (uint256 _amountFreed)\n    {\n        uint256 _balance = want.balanceOf(address(this));\n        if (_balance < _amountNeeded) {\n            _amountFreed = _withdrawSome(_amountNeeded.sub(_balance));\n            _amountFreed = _amountFreed.add(_balance);\n            tank = 0;\n        }\n        else {\n            _amountFreed = _amountNeeded;\n            if (tank >= _amountNeeded) tank = tank.sub(_amountNeeded);\n            else tank = 0;\n        }\n    }\n\n    function _withdrawSome(uint256 _amount) internal returns (uint256) {\n        uint256 _amnt = _amount.mul(1e30).div(ICurveFi(_3pool).get_virtual_price());\n        uint256 _amt = _amnt.mul(1e18).div(yvERC20(y3crv).getPricePerFullShare());\n        uint256 _before = IERC20(_3crv).balanceOf(address(this));\n        yvERC20(y3crv).withdraw(_amt);\n        uint256 _after = IERC20(_3crv).balanceOf(address(this));\n        return _withdrawOne(_after.sub(_before));\n    }\n\n    // NOTE: Can override `tendTrigger` and `harvestTrigger` if necessary\n    function tendTrigger(uint256 callCost) public override view returns (bool) {\n        (uint256 _t, uint256 _c) = tick();\n        return (_c > _t);\n    }\n\n    function prepareMigration(address _newStrategy) internal override {\n        IERC20(y3crv).safeTransfer(_newStrategy, IERC20(y3crv).balanceOf(address(this)));\n        IERC20(_3crv).safeTransfer(_newStrategy, IERC20(_3crv).balanceOf(address(this)));\n    }\n\n    function protectedTokens()\n        internal\n        override\n        view\n        returns (address[] memory)\n    {\n        address[] memory protected = new address[](2);\n        protected[0] = _3crv;\n        protected[1] = y3crv;\n        return protected;\n    }\n\n    function tick() public view returns (uint256 _t, uint256 _c) {\n        _t = ICurveFi(_3pool).balances(1).mul(threshold).div(DENOMINATOR);\n        _c = balanceOfy3CRVinWant();\n    }\n\n    function rebalance() public {\n        (uint256 _t, uint256 _c) = tick();\n        if (_c > _t) {\n            _withdrawSome(_c.sub(_t));\n            tank = want.balanceOf(address(this));\n        }\n    }\n\n    function forceD(uint256 _amount) external onlyAuthorized {\n        uint256 v = _amount.mul(1e30).div(ICurveFi(_3pool).get_virtual_price());\n        ICurveFi(_3pool).add_liquidity([0, _amount, 0], v.mul(DENOMINATOR.sub(slip)).div(DENOMINATOR));\n        if (_amount < tank) tank = tank.sub(_amount);\n        else tank = 0;\n\n        uint256 _bal = IERC20(_3crv).balanceOf(address(this));\n        yvERC20(y3crv).deposit(_bal);\n    }\n\n    function forceW(uint256 _amt) external onlyAuthorized {\n        uint256 _before = IERC20(_3crv).balanceOf(address(this));\n        yvERC20(y3crv).withdraw(_amt);\n        uint256 _after = IERC20(_3crv).balanceOf(address(this));\n        _amt = _after.sub(_before);\n\n        _before = want.balanceOf(address(this));\n        ICurveFi(_3pool).remove_liquidity_one_coin(_amt, 1, _amt.mul(DENOMINATOR.sub(slip)).div(DENOMINATOR).div(1e12));\n        _after = want.balanceOf(address(this));\n        tank = tank.add(_after.sub(_before));\n    }\n}"
    },
    {
      "filename": "contracts/StrategyUSDT.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {\n    BaseStrategy,\n    StrategyParams\n} from \"@yearnvaults/contracts/BaseStrategy.sol\";\nimport \"@openzeppelinV3/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelinV3/contracts/math/SafeMath.sol\";\nimport \"@openzeppelinV3/contracts/utils/Address.sol\";\nimport \"@openzeppelinV3/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../interfaces/yearn/yvERC20.sol\";\nimport \"../interfaces/curve/ICurveFI.sol\";\n\n\ncontract StrategyUSDT3pool is BaseStrategy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address constant public _3pool = address(0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7);\n    address constant public _3crv = address(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);\n    address constant public y3crv = address(0x9cA85572E6A3EbF24dEDd195623F188735A5179f);\n\n    uint256 constant public DENOMINATOR = 10000;\n    uint256 public threshold;\n    uint256 public slip;\n    uint256 public tank;\n    uint256 public p;\n\n    constructor(address _vault) public BaseStrategy(_vault) {\n        // minReportDelay = 6300;\n        // profitFactor = 100;\n        // debtThreshold = 0;\n        threshold = 8000;\n        slip = 100;\n        want.safeApprove(_3pool, uint256(-1));\n        IERC20(_3crv).safeApprove(y3crv, uint256(-1));\n        IERC20(_3crv).safeApprove(_3pool, uint256(-1));\n    }\n\n    function setThreshold(uint256 _threshold) external onlyAuthorized {\n        threshold = _threshold;\n    }\n\n    function setSlip(uint256 _slip) external onlyAuthorized {\n        slip = _slip;\n    }\n\n    function name() external override pure returns (string memory) {\n        return \"StrategyCurve3poolUSDT\";\n    }\n\n    function estimatedTotalAssets() public override view returns (uint256) {\n        return balanceOfWant().add(balanceOfy3CRVinWant());\n    }\n\n    function balanceOfWant() public view returns (uint256) {\n        return want.balanceOf(address(this));\n    }\n\n    function balanceOfy3CRV() public view returns (uint256) {\n        return IERC20(y3crv).balanceOf(address(this));\n    }\n\n    function balanceOfy3CRVinWant() public view returns (uint256) {\n        return balanceOfy3CRV()\n                .mul(yvERC20(y3crv).getPricePerFullShare()).div(1e18)\n                .mul(ICurveFi(_3pool).get_virtual_price()).div(1e30);\n    }\n\n    function prepareReturn(uint256 _debtOutstanding)\n        internal\n        override\n        returns (\n            uint256 _profit,\n            uint256 _loss,\n            uint256 _debtPayment\n        )\n    {\n        _profit = want.balanceOf(address(this));\n        uint256 _p = yvERC20(y3crv).getPricePerFullShare();\n        _p = _p.mul(ICurveFi(_3pool).get_virtual_price()).div(1e18);\n        if (_p >= p) {\n            _profit = _profit.add((_p.sub(p)).mul(balanceOfy3CRV()).div(1e30));\n        }\n        else {\n            _loss = (p.sub(_p)).mul(balanceOfy3CRV()).div(1e30);\n        }\n        p = _p;\n\n        if (_debtOutstanding > 0) {\n            _debtPayment = liquidatePosition(_debtOutstanding);\n        }\n    }\n\n    function adjustPosition(uint256 _debtOutstanding) internal override {\n        rebalance();\n        _deposit();\n    }\n\n    function _deposit() internal {\n        uint256 _want = (want.balanceOf(address(this))).sub(tank);\n        if (_want > 0) {\n            uint256 v = _want.mul(1e30).div(ICurveFi(_3pool).get_virtual_price());\n            ICurveFi(_3pool).add_liquidity([0, 0, _want], v.mul(DENOMINATOR.sub(slip)).div(DENOMINATOR));\n        }\n        uint256 _bal = IERC20(_3crv).balanceOf(address(this));\n        if (_bal > 0) {\n            yvERC20(y3crv).deposit(_bal);\n        }\n    }\n\n    function exitPosition(uint256 _debtOutstanding)\n        internal\n        override\n        returns (uint256 _profit, uint256 _loss, uint256 _debtPayment)\n    {\n        (_profit, _loss, _debtPayment) = prepareReturn(_debtOutstanding);\n        _withdrawAll();\n        _debtPayment = want.balanceOf(address(this));\n    }\n\n    function _withdrawAll() internal {\n        uint256 _y3crv = IERC20(y3crv).balanceOf(address(this));\n        if (_y3crv > 0) {\n            yvERC20(y3crv).withdraw(_y3crv);\n            _withdrawOne(IERC20(_3crv).balanceOf(address(this)));\n        }\n    }\n\n    function _withdrawOne(uint256 _amnt) internal returns (uint256) {\n        uint256 _before = want.balanceOf(address(this));\n        ICurveFi(_3pool).remove_liquidity_one_coin(_amnt, 2, _amnt.mul(DENOMINATOR.sub(slip)).div(DENOMINATOR).div(1e12));\n        uint256 _after = want.balanceOf(address(this));\n        \n        return _after.sub(_before);\n    }\n\n    function liquidatePosition(uint256 _amountNeeded)\n        internal\n        override\n        returns (uint256 _amountFreed)\n    {\n        uint256 _balance = want.balanceOf(address(this));\n        if (_balance < _amountNeeded) {\n            _amountFreed = _withdrawSome(_amountNeeded.sub(_balance));\n            _amountFreed = _amountFreed.add(_balance);\n            tank = 0;\n        }\n        else {\n            _amountFreed = _amountNeeded;\n            if (tank >= _amountNeeded) tank = tank.sub(_amountNeeded);\n            else tank = 0;\n        }\n    }\n\n    function _withdrawSome(uint256 _amount) internal returns (uint256) {\n        uint256 _amnt = _amount.mul(1e30).div(ICurveFi(_3pool).get_virtual_price());\n        uint256 _amt = _amnt.mul(1e18).div(yvERC20(y3crv).getPricePerFullShare());\n        uint256 _bal = IERC20(y3crv).balanceOf(address(this));\n        if (_amt > _bal) _amt = _bal;\n        uint256 _before = IERC20(_3crv).balanceOf(address(this));\n        yvERC20(y3crv).withdraw(_amt);\n        uint256 _after = IERC20(_3crv).balanceOf(address(this));\n        return _withdrawOne(_after.sub(_before));\n    }\n\n    // NOTE: Can override `tendTrigger` and `harvestTrigger` if necessary\n    function tendTrigger(uint256 callCost) public override view returns (bool) {\n        (uint256 _t, uint256 _c) = tick();\n        return (_c > _t);\n    }\n\n    function prepareMigration(address _newStrategy) internal override {\n        IERC20(y3crv).safeTransfer(_newStrategy, IERC20(y3crv).balanceOf(address(this)));\n        IERC20(_3crv).safeTransfer(_newStrategy, IERC20(_3crv).balanceOf(address(this)));\n    }\n\n    function protectedTokens()\n        internal\n        override\n        view\n        returns (address[] memory)\n    {\n        address[] memory protected = new address[](2);\n        protected[0] = _3crv;\n        protected[1] = y3crv;\n        return protected;\n    }\n\n    function tick() public view returns (uint256 _t, uint256 _c) {\n        _t = ICurveFi(_3pool).balances(2).mul(threshold).div(DENOMINATOR);\n        _c = balanceOfy3CRVinWant();\n    }\n\n    function rebalance() public {\n        (uint256 _t, uint256 _c) = tick();\n        if (_c > _t) {\n            _withdrawSome(_c.sub(_t));\n            tank = want.balanceOf(address(this));\n        }\n    }\n\n    function forceD(uint256 _amount) external onlyAuthorized {\n        uint256 v = _amount.mul(1e30).div(ICurveFi(_3pool).get_virtual_price());\n        ICurveFi(_3pool).add_liquidity([0, 0, _amount], v.mul(DENOMINATOR.sub(slip)).div(DENOMINATOR));\n        if (_amount < tank) tank = tank.sub(_amount);\n        else tank = 0;\n\n        uint256 _bal = IERC20(_3crv).balanceOf(address(this));\n        yvERC20(y3crv).deposit(_bal);\n    }\n\n    function forceW(uint256 _amt) external onlyAuthorized {\n        uint256 _before = IERC20(_3crv).balanceOf(address(this));\n        yvERC20(y3crv).withdraw(_amt);\n        uint256 _after = IERC20(_3crv).balanceOf(address(this));\n        _amt = _after.sub(_before);\n\n        _before = want.balanceOf(address(this));\n        ICurveFi(_3pool).remove_liquidity_one_coin(_amt, 2, _amt.mul(DENOMINATOR.sub(slip)).div(DENOMINATOR).div(1e12));\n        _after = want.balanceOf(address(this));\n        tank = tank.add(_after.sub(_before));\n    }\n}"
    }
  ]
}