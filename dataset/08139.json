{
  "Title": "[L-02] BondCallback: incorrect accounting if quoteToken is rebase token",
  "Content": "\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/BondCallback.sol#L114>\n\nIf the quoteToken is rebase token, the priorBalances may change due to rebasing or airdrop. It may result to an incorrect accounting. However, whether it is exploitable depends on the Bond market's logic.<br>\nWith the current logic, it just checks whether the balance is increased more than the `inputAmount_`, so it is harder to exploit, compare to the alternative logic of using the difference in balances as the input amount. However, it also introduces the possibility of paying the users less than they deserve.\n\n```solidity\n// Callback::callback\n113         // Check that quoteTokens were transferred prior to the call\n114         if (quoteToken.balanceOf(address(this)) < priorBalances[quoteToken] + inputAmount_)\n115             revert Callback_TokensNotReceived();\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-08-olympus-dao-contest",
  "Code": [
    {
      "filename": "src/policies/BondCallback.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\nimport {IBondCallback} from \"interfaces/IBondCallback.sol\";\nimport {IBondAggregator} from \"interfaces/IBondAggregator.sol\";\nimport {OlympusTreasury} from \"modules/TRSRY.sol\";\nimport {OlympusMinter} from \"modules/MINTR.sol\";\nimport {Operator} from \"policies/Operator.sol\";\nimport \"src/Kernel.sol\";\n\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\n\n/// @title Olympus Bond Callback\ncontract BondCallback is Policy, ReentrancyGuard, IBondCallback {\n    using TransferHelper for ERC20;\n\n    error Callback_MarketNotSupported(uint256 id);\n    error Callback_TokensNotReceived();\n    error Callback_InvalidParams();\n\n    mapping(address => mapping(uint256 => bool)) public approvedMarkets;\n    mapping(uint256 => uint256[2]) internal _amountsPerMarket;\n    mapping(ERC20 => uint256) public priorBalances;\n\n    IBondAggregator public aggregator;\n    OlympusTreasury public TRSRY;\n    OlympusMinter public MINTR;\n    Operator public operator;\n    ERC20 public ohm;\n\n    /*//////////////////////////////////////////////////////////////\n                            POLICY INTERFACE\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        Kernel kernel_,\n        IBondAggregator aggregator_,\n        ERC20 ohm_\n    ) Policy(kernel_) {\n        aggregator = aggregator_;\n        ohm = ohm_;\n    }\n\n    /// @inheritdoc Policy\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](2);\n        dependencies[0] = toKeycode(\"TRSRY\");\n        dependencies[1] = toKeycode(\"MINTR\");\n\n        TRSRY = OlympusTreasury(getModuleAddress(dependencies[0]));\n        MINTR = OlympusMinter(getModuleAddress(dependencies[1]));\n\n        // Approve MINTR for burning OHM (called here so that it is re-approved on updates)\n        ohm.safeApprove(address(MINTR), type(uint256).max);\n    }\n\n    /// @inheritdoc Policy\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        Keycode TRSRY_KEYCODE = TRSRY.KEYCODE();\n        Keycode MINTR_KEYCODE = MINTR.KEYCODE();\n\n        requests = new Permissions[](4);\n        requests[0] = Permissions(TRSRY_KEYCODE, TRSRY.setApprovalFor.selector);\n        requests[1] = Permissions(TRSRY_KEYCODE, TRSRY.withdrawReserves.selector);\n        requests[2] = Permissions(MINTR_KEYCODE, MINTR.mintOhm.selector);\n        requests[3] = Permissions(MINTR_KEYCODE, MINTR.burnOhm.selector);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CORE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBondCallback\n    function whitelist(address teller_, uint256 id_)\n        external\n        override\n        onlyRole(\"callback_whitelist\")\n    {\n        approvedMarkets[teller_][id_] = true;\n\n        // Get payout tokens for market\n        (, , ERC20 payoutToken, , , ) = aggregator.getAuctioneer(id_).getMarketInfoForPurchase(id_);\n\n        /// If payout token is not OHM, request approval from TRSRY for withdrawals\n        if (address(payoutToken) != address(ohm)) {\n            TRSRY.setApprovalFor(address(this), payoutToken, type(uint256).max);\n        }\n    }\n\n    /// @inheritdoc IBondCallback\n    function callback(\n        uint256 id_,\n        uint256 inputAmount_,\n        uint256 outputAmount_\n    ) external override nonReentrant {\n        /// Confirm that the teller and market id are whitelisted\n        if (!approvedMarkets[msg.sender][id_]) revert Callback_MarketNotSupported(id_);\n\n        // Get tokens for market\n        (, , ERC20 payoutToken, ERC20 quoteToken, , ) = aggregator\n            .getAuctioneer(id_)\n            .getMarketInfoForPurchase(id_);\n\n        // Check that quoteTokens were transferred prior to the call\n        if (quoteToken.balanceOf(address(this)) < priorBalances[quoteToken] + inputAmount_)\n            revert Callback_TokensNotReceived();\n\n        // Handle payout\n        if (quoteToken == payoutToken && quoteToken == ohm) {\n            // If OHM-OHM bond, only mint the difference and transfer back to teller\n            uint256 toMint = outputAmount_ - inputAmount_;\n            MINTR.mintOhm(address(this), toMint);\n\n            // Transfer payoutTokens to sender\n            payoutToken.safeTransfer(msg.sender, outputAmount_);\n        } else if (quoteToken == ohm) {\n            // If inverse bond (buying ohm), transfer payout tokens to sender\n            TRSRY.withdrawReserves(msg.sender, payoutToken, outputAmount_);\n\n            // Burn OHM received from sender\n            MINTR.burnOhm(address(this), inputAmount_);\n        } else if (payoutToken == ohm) {\n            // Else (selling ohm), mint OHM to sender\n            MINTR.mintOhm(msg.sender, outputAmount_);\n        } else {\n            // Revert since this callback only handles OHM bonds\n            revert Callback_MarketNotSupported(id_);\n        }\n\n        // Store amounts in/out.\n        // Updated after internal call so previous balances are available to check against\n        priorBalances[quoteToken] = quoteToken.balanceOf(address(this));\n        priorBalances[payoutToken] = payoutToken.balanceOf(address(this));\n        _amountsPerMarket[id_][0] += inputAmount_;\n        _amountsPerMarket[id_][1] += outputAmount_;\n\n        // Check if the market is deployed by range operator and update capacity if so\n        operator.bondPurchase(id_, outputAmount_);\n    }\n\n    /// @notice Send tokens to the TRSRY in a batch\n    /// @param  tokens_ - Array of tokens to send\n    function batchToTreasury(ERC20[] memory tokens_) external onlyRole(\"callback_admin\") {\n        ERC20 token;\n        uint256 balance;\n        uint256 len = tokens_.length;\n        for (uint256 i; i < len; ) {\n            token = tokens_[i];\n            balance = token.balanceOf(address(this));\n            token.safeTransfer(address(TRSRY), balance);\n            priorBalances[token] = token.balanceOf(address(this));\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBondCallback\n    function amountsForMarket(uint256 id_)\n        external\n        view\n        override\n        returns (uint256 in_, uint256 out_)\n    {\n        uint256[2] memory marketAmounts = _amountsPerMarket[id_];\n        return (marketAmounts[0], marketAmounts[1]);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Sets the operator contract for the callback to use to report bond purchases\n    /// @notice Must be set before the callback is used\n    /// @param  operator_ - Address of the Operator contract\n    function setOperator(Operator operator_) external onlyRole(\"callback_admin\") {\n        if (address(operator_) == address(0)) revert Callback_InvalidParams();\n        operator = operator_;\n    }\n}"
    }
  ]
}