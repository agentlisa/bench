{
  "Title": "Collateral With No Value Can Be Claimed Through Liquidation",
  "Content": "The [`liquidate`](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/modules/Liquidation.sol#L47-L58) function allows for the [claiming of collateral](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/modules/Liquidation.sol#L139-L143) that, according to the configured price oracle, holds no value. Liquidation plays a crucial role in maintaining the stability and solvency of DeFi lending protocols by ensuring that lenders are compensated in the event of borrower default and that the system remains collateralized. However, the liquidator's ability to claim the violator's collateral even when it holds no value does not align with the logic of the liquidation process.\n\n\nConsider removing the ability to claim the violator's collateral when the price oracle returns zero as its value.\n\n\n***Update:** Acknowledged, not resolved. The Euler team stated:*\n\n\n\n> *We acknowledge the issue. We agree that removing the collateral without a value without reducing debt does not, on its own, align with the basic liquidation logic, which is to reward the collateral to the liquidator in order to reduce debt.*\n> \n> \n> *However, when debt socialization is taken into account, removing worthless collateral from the violatorâ€™s account frees up the bad debt to be removed from the system. In that sense, the behavior does align with the liquidation logic, which is to remove collateral in order to remove debt.*\n> \n> \n> *Note that the collateral may be worthless not only because the asset is literally worth nothing according to the oracles, which would be a very unlikely edge-case, but also because the oracle may respond with a zero `amountOut` when the collateral amount is so small that it is not representable in the reference asset. In the latter case, which is much more likely to occur, removing the dust collateral would be the only way to socialize the bad debt.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/EVault/modules/Liquidation.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {ILiquidation} from \"../IEVault.sol\";\nimport {Base} from \"../shared/Base.sol\";\nimport {BalanceUtils} from \"../shared/BalanceUtils.sol\";\nimport {LiquidityUtils} from \"../shared/LiquidityUtils.sol\";\n\nimport \"../shared/types/Types.sol\";\n\n/// @title LiquidationModule\n/// @author Euler Labs (https://www.eulerlabs.com/)\n/// @notice An EVault module handling liquidations of unhealthy accounts\nabstract contract LiquidationModule is ILiquidation, Base, BalanceUtils, LiquidityUtils {\n    using TypesLib for uint256;\n\n    // Maximum liquidation discount that can be awarded under any conditions.\n    uint256 constant MAXIMUM_LIQUIDATION_DISCOUNT = 0.2 * 1e18;\n\n    struct LiquidationCache {\n        address liquidator;\n        address violator;\n        address collateral;\n        address[] collaterals;\n        Assets liability;\n        Assets repay;\n        uint256 yieldBalance;\n    }\n\n    /// @inheritdoc ILiquidation\n    function checkLiquidation(address liquidator, address violator, address collateral)\n        public\n        view\n        virtual\n        nonReentrantView\n        returns (uint256 maxRepay, uint256 maxYield)\n    {\n        LiquidationCache memory liqCache =\n            calculateLiquidation(loadVault(), liquidator, violator, collateral, type(uint256).max);\n\n        maxRepay = liqCache.repay.toUint();\n        maxYield = liqCache.yieldBalance;\n    }\n\n    /// @inheritdoc ILiquidation\n    function liquidate(address violator, address collateral, uint256 repayAssets, uint256 minYieldBalance)\n        public\n        virtual\n        nonReentrant\n    {\n        (VaultCache memory vaultCache, address liquidator) = initOperation(OP_LIQUIDATE, CHECKACCOUNT_CALLER);\n\n        LiquidationCache memory liqCache =\n            calculateLiquidation(vaultCache, liquidator, violator, collateral, repayAssets);\n\n        executeLiquidation(vaultCache, liqCache, minYieldBalance);\n    }\n\n    function calculateLiquidation(\n        VaultCache memory vaultCache,\n        address liquidator,\n        address violator,\n        address collateral,\n        uint256 desiredRepay\n    ) private view returns (LiquidationCache memory liqCache) {\n        // Init cache\n\n        liqCache.liquidator = liquidator;\n        liqCache.violator = violator;\n        liqCache.collateral = collateral;\n\n        liqCache.repay = Assets.wrap(0);\n        liqCache.yieldBalance = 0;\n        liqCache.liability = getCurrentOwed(vaultCache, violator).toAssetsUp();\n        liqCache.collaterals = getCollaterals(violator);\n\n        // Checks\n\n        // Self liquidation is not allowed\n        if (liqCache.violator == liqCache.liquidator) revert E_SelfLiquidation();\n        // Only liquidate trusted collaterals to make sure yield transfer has no side effects.\n        if (!isRecognizedCollateral(liqCache.collateral)) revert E_BadCollateral();\n        // Verify this vault is the controller for the violator\n        validateController(liqCache.violator);\n        // Violator must have enabled the collateral to be transferred to the liquidator\n        if (!isCollateralEnabled(liqCache.violator, liqCache.collateral)) revert E_CollateralDisabled();\n        // Violator's health check must not be deferred, meaning no prior operations on violator's account\n        // would possibly be forgiven after the enforced collateral transfer to the liquidator\n        if (isAccountStatusCheckDeferred(violator)) revert E_ViolatorLiquidityDeferred();\n\n        // Violator has no liabilities, liquidation is a no-op\n        if (liqCache.liability.isZero()) return liqCache;\n\n        // Calculate max yield and repay\n\n        liqCache = calculateMaxLiquidation(liqCache, vaultCache);\n\n        // Adjust for desired repay\n\n        if (desiredRepay != type(uint256).max) {\n            uint256 maxRepay = liqCache.repay.toUint();\n            if (desiredRepay > maxRepay) revert E_ExcessiveRepayAmount();\n\n            if (maxRepay > 0) {\n                liqCache.yieldBalance = desiredRepay * liqCache.yieldBalance / maxRepay;\n                liqCache.repay = desiredRepay.toAssets();\n            }\n        }\n    }\n\n    function calculateMaxLiquidation(LiquidationCache memory liqCache, VaultCache memory vaultCache)\n        private\n        view\n        returns (LiquidationCache memory)\n    {\n        // Check account health\n\n        (uint256 liquidityCollateralValue, uint256 liquidityLiabilityValue) =\n            calculateLiquidity(vaultCache, liqCache.violator, liqCache.collaterals, LTVType.LIQUIDATION);\n\n        // no violation\n        if (liquidityCollateralValue > liquidityLiabilityValue) return liqCache;\n\n        // Compute discount\n\n        uint256 discountFactor = liquidityCollateralValue * 1e18 / liquidityLiabilityValue; // discountFactor = health score = 1 - discount\n\n        if (discountFactor < 1e18 - MAXIMUM_LIQUIDATION_DISCOUNT) {\n            discountFactor = 1e18 - MAXIMUM_LIQUIDATION_DISCOUNT;\n        }\n\n        // Compute maximum yield\n\n        uint256 collateralBalance = IERC20(liqCache.collateral).balanceOf(liqCache.violator);\n        uint256 collateralValue =\n            vaultCache.oracle.getQuote(collateralBalance, liqCache.collateral, vaultCache.unitOfAccount);\n\n        if (collateralValue == 0) {\n            // worthless collateral can be claimed with no repay\n            liqCache.yieldBalance = collateralBalance;\n            return liqCache;\n        }\n\n        uint256 liabilityValue = liqCache.liability.toUint();\n        if (address(vaultCache.asset) != vaultCache.unitOfAccount) {\n            // liquidation, in contrast to liquidity calculation, uses mid-point pricing instead of bid/ask\n            liabilityValue =\n                vaultCache.oracle.getQuote(liabilityValue, address(vaultCache.asset), vaultCache.unitOfAccount);\n        }\n\n        uint256 maxRepayValue = liabilityValue;\n        uint256 maxYieldValue = maxRepayValue * 1e18 / discountFactor;\n\n        // Limit yield to borrower's available collateral, and reduce repay if necessary\n        // This can happen when borrower has multiple collaterals and seizing all of this one won't bring the violator back to solvency\n\n        if (collateralValue < maxYieldValue) {\n            maxRepayValue = collateralValue * discountFactor / 1e18;\n            maxYieldValue = collateralValue;\n        }\n\n        liqCache.repay = (maxRepayValue * liqCache.liability.toUint() / liabilityValue).toAssets();\n        liqCache.yieldBalance = maxYieldValue * collateralBalance / collateralValue;\n\n        return liqCache;\n    }\n\n    function executeLiquidation(VaultCache memory vaultCache, LiquidationCache memory liqCache, uint256 minYieldBalance)\n        private\n    {\n        // Check minimum yield.\n\n        if (minYieldBalance > liqCache.yieldBalance) revert E_MinYield();\n\n        // Handle repay: liquidator takes on violator's debt:\n\n        transferBorrow(vaultCache, liqCache.violator, liqCache.liquidator, liqCache.repay);\n\n        // Handle yield: liquidator receives violator's collateral\n\n        // Impersonate violator on the EVC to seize collateral. The yield transfer will trigger a health check on the violator's\n        // account, which should be forgiven, because the violator's account is not guaranteed to be healthy after liquidation.\n        // This operation is safe, because:\n        // 1. `liquidate` function is enforcing that the violator is not in deferred checks state,\n        //    therefore there were no prior batch operations that could have registered a health check,\n        //    and if the check is present now, it must have been triggered by the enforced transfer.\n        // 2. Only collaterals with initialized LTV settings can be liquidated and they are assumed to be audited\n        //    to have safe transfer methods, which make no external calls. In other words, yield transfer will not\n        //    have any side effects, which would be wrongly forgiven.\n        // 3. Any additional operations on violator's account in a batch will register the health check again, and it\n        //    will be executed normally at the end of the batch.\n\n        if (liqCache.yieldBalance > 0) {\n            enforceCollateralTransfer(\n                liqCache.collateral, liqCache.yieldBalance, liqCache.violator, liqCache.liquidator\n            );\n\n            forgiveAccountStatusCheck(liqCache.violator);\n        }\n\n        // Handle debt socialization\n\n        if (\n            vaultCache.configFlags.isNotSet(CFG_DONT_SOCIALIZE_DEBT) && liqCache.liability > liqCache.repay\n                && checkNoCollateral(liqCache.violator, liqCache.collaterals)\n        ) {\n            Assets owedRemaining = liqCache.liability - liqCache.repay;\n            decreaseBorrow(vaultCache, liqCache.violator, owedRemaining);\n\n            // decreaseBorrow emits Repay without any assets entering the vault. Emit Withdraw from and to zero address to cover the missing amount for offchain trackers.\n            emit Withdraw(liqCache.liquidator, address(0), address(0), owedRemaining.toUint(), 0);\n            emit DebtSocialized(liqCache.violator, owedRemaining.toUint());\n        }\n\n        emit Liquidate(\n            liqCache.liquidator, liqCache.violator, liqCache.collateral, liqCache.repay.toUint(), liqCache.yieldBalance\n        );\n    }\n}\n\n/// @dev Deployable module contract\ncontract Liquidation is LiquidationModule {\n    constructor(Integrations memory integrations) Base(integrations) {}\n}"
    }
  ]
}