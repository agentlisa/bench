{
  "Title": "[L-02] BribeVault: Use `safeTransfer` for tokens",
  "Content": "\n### Line References\n\n[BribeVault.sol#L296-L297](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L296-L297)<br>\n[BribeVault.sol#L337](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L337)\n\n### Description\n\nSome ERC20 tokens like ZRX donâ€™t revert if the transfer fails. Since the `SafeERC20` has already been imported and the `safeTransferFrom` method used, the same should be done for token transfers.\n\n### Recommended Mitigation Steps\n\nReplace `transfer` with `safeTransfer`.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-02-redacted-cartel-contest",
  "Code": [
    {
      "filename": "contracts/BribeVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Common} from \"./libraries/Common.sol\";\n\ninterface IRewardDistributor {\n    function updateRewardsMetadata(\n        Common.Distribution[] calldata _distributions\n    ) external;\n}\n\ncontract BribeVault is AccessControl {\n    using SafeERC20 for IERC20;\n\n    struct Bribe {\n        address token;\n        uint256 amount;\n    }\n\n    uint256 public fee; // 5000 = 0.5%\n    address public feeRecipient; // Protocol treasury\n    address public distributor; // RewardDistributor contract\n    uint256 public constant feeDivisor = 1000000;\n    bytes32 public constant DEPOSITOR_ROLE = keccak256(\"DEPOSITOR_ROLE\");\n\n    // Bribe identifiers mapped to Bribe structs\n    // A bribe identifier is composed of different info (e.g. protocol, voting round, etc.)\n    mapping(bytes32 => Bribe) public bribes;\n\n    // Protocol-specific reward identifiers mapped to bribe identifiers\n    // Allows us to group bribes by reward tokens (one token may be used across many bribes)\n    mapping(bytes32 => bytes32[]) public rewardToBribes;\n\n    event GrantDepositorRole(address depositor);\n    event RevokeDepositorRole(address depositor);\n    event SetFee(uint256 _fee);\n    event SetFeeRecipient(address _feeRecipient);\n    event SetDistributor(address _distributor);\n    event DepositBribe(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address token,\n        uint256 amount,\n        uint256 totalAmount,\n        address briber\n    );\n    event TransferBribe(\n        bytes32 rewardIdentifier,\n        address token,\n        bytes32 proof,\n        uint256 feeAmount,\n        uint256 distributorAmount\n    );\n    event EmergencyWithdrawal(address token, uint256 amount, address admin);\n\n    constructor(\n        uint256 _fee,\n        address _feeRecipient,\n        address _distributor\n    ) {\n        require(_fee <= feeDivisor, \"Invalid fee\");\n        fee = _fee;\n\n        require(_feeRecipient != address(0), \"Invalid feeRecipient\");\n        feeRecipient = _feeRecipient;\n\n        require(_distributor != address(0), \"Invalid distributor\");\n        distributor = _distributor;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /**\n        @notice Grant the depositor role to an address\n        @param  depositor  address  Address to grant the depositor role\n     */\n    function grantDepositorRole(address depositor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(depositor != address(0), \"Invalid depositor\");\n        _grantRole(DEPOSITOR_ROLE, depositor);\n\n        emit GrantDepositorRole(depositor);\n    }\n\n    /**\n        @notice Revoke the depositor role from an address\n        @param  depositor  address  Address to revoke the depositor role\n     */\n    function revokeDepositorRole(address depositor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(hasRole(DEPOSITOR_ROLE, depositor), \"Invalid depositor\");\n        _revokeRole(DEPOSITOR_ROLE, depositor);\n\n        emit RevokeDepositorRole(depositor);\n    }\n\n    /**\n        @notice Set the fee collected by the protocol\n        @param  _fee  uint256  Fee\n     */\n    function setFee(uint256 _fee) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_fee <= feeDivisor, \"Invalid _fee\");\n        fee = _fee;\n\n        emit SetFee(_fee);\n    }\n\n    /**\n        @notice Set the protocol address where fees will be transferred\n        @param  _feeRecipient  address  Fee recipient\n     */\n    function setFeeRecipient(address _feeRecipient)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_feeRecipient != address(0), \"Invalid feeRecipient\");\n        feeRecipient = _feeRecipient;\n\n        emit SetFeeRecipient(_feeRecipient);\n    }\n\n    /**\n        @notice Set the RewardDistributor contract address\n        @param  _distributor  address  Distributor\n     */\n    function setDistributor(address _distributor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_distributor != address(0), \"Invalid distributor\");\n        distributor = _distributor;\n\n        emit SetDistributor(_distributor);\n    }\n\n    /**\n        @notice Get bribe information based on the specified identifier\n        @param  bribeIdentifier  bytes32  The specified bribe identifier\n     */\n    function getBribe(bytes32 bribeIdentifier)\n        external\n        view\n        returns (address token, uint256 amount)\n    {\n        Bribe memory b = bribes[bribeIdentifier];\n        return (b.token, b.amount);\n    }\n\n    /**\n        @notice Deposit bribe (ERC20 only)\n        @param  bribeIdentifier   bytes32  Unique identifier related to bribe\n        @param  rewardIdentifier  bytes32  Unique identifier related to reward\n        @param  token             address  Bribe token\n        @param  amount            uint256  Bribe token amount\n        @param  briber            address  Address that originally called the depositor contract\n     */\n    function depositBribeERC20(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address token,\n        uint256 amount,\n        address briber\n    ) external onlyRole(DEPOSITOR_ROLE) {\n        require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");\n        require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");\n        require(token != address(0), \"Invalid token\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(briber != address(0), \"Invalid briber\");\n\n        Bribe storage b = bribes[bribeIdentifier];\n        address currentToken = b.token;\n        require(\n            // If bribers want to bribe with a different token they need a new identifier\n            currentToken == address(0) || currentToken == token,\n            \"Cannot change token\"\n        );\n\n        // Since this method is called by a depositor contract, we must transfer from the account\n        // that called the depositor contract - amount must be approved beforehand\n        IERC20(token).safeTransferFrom(briber, address(this), amount);\n\n        b.amount += amount; // Allow bribers to increase bribe\n\n        // Only set the token address and update the reward-to-bribe mapping if not yet set\n        if (currentToken == address(0)) {\n            b.token = token;\n            rewardToBribes[rewardIdentifier].push(bribeIdentifier);\n        }\n\n        emit DepositBribe(\n            bribeIdentifier,\n            rewardIdentifier,\n            token,\n            amount,\n            b.amount,\n            briber\n        );\n    }\n\n    /**\n        @notice Deposit bribe (native token only)\n        @param  bribeIdentifier   bytes32 Unique identifier related to bribe\n        @param  rewardIdentifier  bytes32 Unique identifier related to reward\n        @param  briber            address  Address that originally called the depositor contract\n     */\n    function depositBribe(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address briber\n    ) external payable onlyRole(DEPOSITOR_ROLE) {\n        require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");\n        require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");\n        require(briber != address(0), \"Invalid briber\");\n        require(msg.value > 0, \"Value must be greater than 0\");\n\n        Bribe storage b = bribes[bribeIdentifier];\n        address currentToken = b.token;\n        require(\n            // For native tokens, the token address is set to this contract to prevent\n            // overwriting storage - the address can be anything but address(this) safer\n            currentToken == address(0) || currentToken == address(this),\n            \"Cannot change token\"\n        );\n\n        b.amount += msg.value; // Allow bribers to increase bribe\n\n        // Only set the token address and update the reward-to-bribe mapping if not yet set\n        if (currentToken == address(0)) {\n            b.token = address(this);\n            rewardToBribes[rewardIdentifier].push(bribeIdentifier);\n        }\n\n        emit DepositBribe(\n            bribeIdentifier,\n            rewardIdentifier,\n            b.token,\n            msg.value,\n            b.amount,\n            briber\n        );\n    }\n\n    /**\n        @notice Transfer fees to fee recipient and bribes to distributor and update rewards metadata\n        @param  distributions    Distribution[] List of distribution details\n        @param  amounts          uint256[] List of amounts for distributor\n        @param  fees             uint256[] List of fee amounts for fee recipient\n     */\n    function transferBribes(\n        Common.Distribution[] calldata distributions,\n        uint256[] calldata amounts,\n        uint256[] calldata fees\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(distributions.length > 0, \"Invalid distributions\");\n        require(\n            distributions.length == amounts.length &&\n                distributions.length == fees.length,\n            \"Distributions, amounts, and fees must contain the same # of elements\"\n        );\n\n        // Transfer the bribe funds to fee recipient and reward distributor\n        for (uint256 i = 0; i < distributions.length; i++) {\n            bytes32 rewardIdentifier = distributions[i].rewardIdentifier;\n            uint256 distributorAmount = amounts[i];\n            uint256 feeAmount = fees[i];\n            address token = distributions[i].token;\n            require(\n                rewardToBribes[rewardIdentifier].length > 0,\n                \"Invalid reward identifier\"\n            );\n            require(token != address(0), \"Invalid token address\");\n            require(distributorAmount > 0, \"Invalid pending reward amount\");\n\n            // Check whether it's a native token reward\n            if (token == address(this)) {\n                (bool sentFeeRecipient, ) = feeRecipient.call{value: feeAmount}(\n                    \"\"\n                );\n                require(\n                    sentFeeRecipient,\n                    \"Failed to transfer to fee recipient\"\n                );\n\n                (bool sentDistributor, ) = distributor.call{\n                    value: distributorAmount\n                }(\"\");\n                require(sentDistributor, \"Failed to transfer to distributor\");\n            } else {\n                IERC20(token).transfer(feeRecipient, feeAmount);\n                IERC20(token).transfer(distributor, distributorAmount);\n            }\n\n            emit TransferBribe(\n                rewardIdentifier,\n                token,\n                distributions[i].proof,\n                feeAmount,\n                distributorAmount\n            );\n        }\n\n        // Update the rewards' metadata\n        IRewardDistributor(distributor).updateRewardsMetadata(distributions);\n    }\n\n    /**\n        @notice Update the rewards metadata of the specified identifiers (only if absolutely needed)\n        @param  distributions    Distribution[] List of distribution details\n     */\n    function updateRewardsMetadata(Common.Distribution[] calldata distributions)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(distributions.length > 0, \"Invalid distributions\");\n        IRewardDistributor(distributor).updateRewardsMetadata(distributions);\n    }\n\n    /**\n        @notice Withdraw ERC20 tokens to the admin address\n        @param  token   address  Token address\n        @param  amount  uint256  Token amount\n     */\n    function emergencyWithdrawERC20(address token, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(token != address(0), \"Invalid token\");\n        require(amount > 0, \"Invalid amount\");\n\n        IERC20(token).transfer(msg.sender, amount);\n\n        emit EmergencyWithdrawal(token, amount, msg.sender);\n    }\n\n    /**\n        @notice Withdraw native tokens to the admin address\n        @param  amount  uint256  Token amount\n     */\n    function emergencyWithdraw(uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(amount > 0, \"Invalid amount\");\n\n        (bool sentAdmin, ) = msg.sender.call{value: amount}(\"\");\n        require(sentAdmin, \"Failed to withdraw\");\n\n        emit EmergencyWithdrawal(address(this), amount, msg.sender);\n    }\n}"
    },
    {
      "filename": "contracts/BribeVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Common} from \"./libraries/Common.sol\";\n\ninterface IRewardDistributor {\n    function updateRewardsMetadata(\n        Common.Distribution[] calldata _distributions\n    ) external;\n}\n\ncontract BribeVault is AccessControl {\n    using SafeERC20 for IERC20;\n\n    struct Bribe {\n        address token;\n        uint256 amount;\n    }\n\n    uint256 public fee; // 5000 = 0.5%\n    address public feeRecipient; // Protocol treasury\n    address public distributor; // RewardDistributor contract\n    uint256 public constant feeDivisor = 1000000;\n    bytes32 public constant DEPOSITOR_ROLE = keccak256(\"DEPOSITOR_ROLE\");\n\n    // Bribe identifiers mapped to Bribe structs\n    // A bribe identifier is composed of different info (e.g. protocol, voting round, etc.)\n    mapping(bytes32 => Bribe) public bribes;\n\n    // Protocol-specific reward identifiers mapped to bribe identifiers\n    // Allows us to group bribes by reward tokens (one token may be used across many bribes)\n    mapping(bytes32 => bytes32[]) public rewardToBribes;\n\n    event GrantDepositorRole(address depositor);\n    event RevokeDepositorRole(address depositor);\n    event SetFee(uint256 _fee);\n    event SetFeeRecipient(address _feeRecipient);\n    event SetDistributor(address _distributor);\n    event DepositBribe(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address token,\n        uint256 amount,\n        uint256 totalAmount,\n        address briber\n    );\n    event TransferBribe(\n        bytes32 rewardIdentifier,\n        address token,\n        bytes32 proof,\n        uint256 feeAmount,\n        uint256 distributorAmount\n    );\n    event EmergencyWithdrawal(address token, uint256 amount, address admin);\n\n    constructor(\n        uint256 _fee,\n        address _feeRecipient,\n        address _distributor\n    ) {\n        require(_fee <= feeDivisor, \"Invalid fee\");\n        fee = _fee;\n\n        require(_feeRecipient != address(0), \"Invalid feeRecipient\");\n        feeRecipient = _feeRecipient;\n\n        require(_distributor != address(0), \"Invalid distributor\");\n        distributor = _distributor;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /**\n        @notice Grant the depositor role to an address\n        @param  depositor  address  Address to grant the depositor role\n     */\n    function grantDepositorRole(address depositor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(depositor != address(0), \"Invalid depositor\");\n        _grantRole(DEPOSITOR_ROLE, depositor);\n\n        emit GrantDepositorRole(depositor);\n    }\n\n    /**\n        @notice Revoke the depositor role from an address\n        @param  depositor  address  Address to revoke the depositor role\n     */\n    function revokeDepositorRole(address depositor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(hasRole(DEPOSITOR_ROLE, depositor), \"Invalid depositor\");\n        _revokeRole(DEPOSITOR_ROLE, depositor);\n\n        emit RevokeDepositorRole(depositor);\n    }\n\n    /**\n        @notice Set the fee collected by the protocol\n        @param  _fee  uint256  Fee\n     */\n    function setFee(uint256 _fee) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_fee <= feeDivisor, \"Invalid _fee\");\n        fee = _fee;\n\n        emit SetFee(_fee);\n    }\n\n    /**\n        @notice Set the protocol address where fees will be transferred\n        @param  _feeRecipient  address  Fee recipient\n     */\n    function setFeeRecipient(address _feeRecipient)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_feeRecipient != address(0), \"Invalid feeRecipient\");\n        feeRecipient = _feeRecipient;\n\n        emit SetFeeRecipient(_feeRecipient);\n    }\n\n    /**\n        @notice Set the RewardDistributor contract address\n        @param  _distributor  address  Distributor\n     */\n    function setDistributor(address _distributor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_distributor != address(0), \"Invalid distributor\");\n        distributor = _distributor;\n\n        emit SetDistributor(_distributor);\n    }\n\n    /**\n        @notice Get bribe information based on the specified identifier\n        @param  bribeIdentifier  bytes32  The specified bribe identifier\n     */\n    function getBribe(bytes32 bribeIdentifier)\n        external\n        view\n        returns (address token, uint256 amount)\n    {\n        Bribe memory b = bribes[bribeIdentifier];\n        return (b.token, b.amount);\n    }\n\n    /**\n        @notice Deposit bribe (ERC20 only)\n        @param  bribeIdentifier   bytes32  Unique identifier related to bribe\n        @param  rewardIdentifier  bytes32  Unique identifier related to reward\n        @param  token             address  Bribe token\n        @param  amount            uint256  Bribe token amount\n        @param  briber            address  Address that originally called the depositor contract\n     */\n    function depositBribeERC20(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address token,\n        uint256 amount,\n        address briber\n    ) external onlyRole(DEPOSITOR_ROLE) {\n        require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");\n        require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");\n        require(token != address(0), \"Invalid token\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(briber != address(0), \"Invalid briber\");\n\n        Bribe storage b = bribes[bribeIdentifier];\n        address currentToken = b.token;\n        require(\n            // If bribers want to bribe with a different token they need a new identifier\n            currentToken == address(0) || currentToken == token,\n            \"Cannot change token\"\n        );\n\n        // Since this method is called by a depositor contract, we must transfer from the account\n        // that called the depositor contract - amount must be approved beforehand\n        IERC20(token).safeTransferFrom(briber, address(this), amount);\n\n        b.amount += amount; // Allow bribers to increase bribe\n\n        // Only set the token address and update the reward-to-bribe mapping if not yet set\n        if (currentToken == address(0)) {\n            b.token = token;\n            rewardToBribes[rewardIdentifier].push(bribeIdentifier);\n        }\n\n        emit DepositBribe(\n            bribeIdentifier,\n            rewardIdentifier,\n            token,\n            amount,\n            b.amount,\n            briber\n        );\n    }\n\n    /**\n        @notice Deposit bribe (native token only)\n        @param  bribeIdentifier   bytes32 Unique identifier related to bribe\n        @param  rewardIdentifier  bytes32 Unique identifier related to reward\n        @param  briber            address  Address that originally called the depositor contract\n     */\n    function depositBribe(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address briber\n    ) external payable onlyRole(DEPOSITOR_ROLE) {\n        require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");\n        require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");\n        require(briber != address(0), \"Invalid briber\");\n        require(msg.value > 0, \"Value must be greater than 0\");\n\n        Bribe storage b = bribes[bribeIdentifier];\n        address currentToken = b.token;\n        require(\n            // For native tokens, the token address is set to this contract to prevent\n            // overwriting storage - the address can be anything but address(this) safer\n            currentToken == address(0) || currentToken == address(this),\n            \"Cannot change token\"\n        );\n\n        b.amount += msg.value; // Allow bribers to increase bribe\n\n        // Only set the token address and update the reward-to-bribe mapping if not yet set\n        if (currentToken == address(0)) {\n            b.token = address(this);\n            rewardToBribes[rewardIdentifier].push(bribeIdentifier);\n        }\n\n        emit DepositBribe(\n            bribeIdentifier,\n            rewardIdentifier,\n            b.token,\n            msg.value,\n            b.amount,\n            briber\n        );\n    }\n\n    /**\n        @notice Transfer fees to fee recipient and bribes to distributor and update rewards metadata\n        @param  distributions    Distribution[] List of distribution details\n        @param  amounts          uint256[] List of amounts for distributor\n        @param  fees             uint256[] List of fee amounts for fee recipient\n     */\n    function transferBribes(\n        Common.Distribution[] calldata distributions,\n        uint256[] calldata amounts,\n        uint256[] calldata fees\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(distributions.length > 0, \"Invalid distributions\");\n        require(\n            distributions.length == amounts.length &&\n                distributions.length == fees.length,\n            \"Distributions, amounts, and fees must contain the same # of elements\"\n        );\n\n        // Transfer the bribe funds to fee recipient and reward distributor\n        for (uint256 i = 0; i < distributions.length; i++) {\n            bytes32 rewardIdentifier = distributions[i].rewardIdentifier;\n            uint256 distributorAmount = amounts[i];\n            uint256 feeAmount = fees[i];\n            address token = distributions[i].token;\n            require(\n                rewardToBribes[rewardIdentifier].length > 0,\n                \"Invalid reward identifier\"\n            );\n            require(token != address(0), \"Invalid token address\");\n            require(distributorAmount > 0, \"Invalid pending reward amount\");\n\n            // Check whether it's a native token reward\n            if (token == address(this)) {\n                (bool sentFeeRecipient, ) = feeRecipient.call{value: feeAmount}(\n                    \"\"\n                );\n                require(\n                    sentFeeRecipient,\n                    \"Failed to transfer to fee recipient\"\n                );\n\n                (bool sentDistributor, ) = distributor.call{\n                    value: distributorAmount\n                }(\"\");\n                require(sentDistributor, \"Failed to transfer to distributor\");\n            } else {\n                IERC20(token).transfer(feeRecipient, feeAmount);\n                IERC20(token).transfer(distributor, distributorAmount);\n            }\n\n            emit TransferBribe(\n                rewardIdentifier,\n                token,\n                distributions[i].proof,\n                feeAmount,\n                distributorAmount\n            );\n        }\n\n        // Update the rewards' metadata\n        IRewardDistributor(distributor).updateRewardsMetadata(distributions);\n    }\n\n    /**\n        @notice Update the rewards metadata of the specified identifiers (only if absolutely needed)\n        @param  distributions    Distribution[] List of distribution details\n     */\n    function updateRewardsMetadata(Common.Distribution[] calldata distributions)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(distributions.length > 0, \"Invalid distributions\");\n        IRewardDistributor(distributor).updateRewardsMetadata(distributions);\n    }\n\n    /**\n        @notice Withdraw ERC20 tokens to the admin address\n        @param  token   address  Token address\n        @param  amount  uint256  Token amount\n     */\n    function emergencyWithdrawERC20(address token, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(token != address(0), \"Invalid token\");\n        require(amount > 0, \"Invalid amount\");\n\n        IERC20(token).transfer(msg.sender, amount);\n\n        emit EmergencyWithdrawal(token, amount, msg.sender);\n    }\n\n    /**\n        @notice Withdraw native tokens to the admin address\n        @param  amount  uint256  Token amount\n     */\n    function emergencyWithdraw(uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(amount > 0, \"Invalid amount\");\n\n        (bool sentAdmin, ) = msg.sender.call{value: amount}(\"\");\n        require(sentAdmin, \"Failed to withdraw\");\n\n        emit EmergencyWithdrawal(address(this), amount, msg.sender);\n    }\n}"
    }
  ]
}