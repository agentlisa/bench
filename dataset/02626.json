{
  "Title": "Governor contract can create emergency proposals",
  "Content": "The [`EmergencyProposal` contract](https://github.com/UMAprotocol/protocol/blob/5682c65a9226f63610a6eb391c34d06799eb587d/packages/core/contracts/oracle/implementation/EmergencyProposer.sol#L24) is used to construct an emergency recovery transaction that bypasses the standard voting process. The intention is to provide an alternate execution path that can be utilized to fix an incorrectly configured `VotingV2` contract.\n\n\nAny user can propose an emergency transaction via the [`emergencyPropose`](https://github.com/UMAprotocol/protocol/blob/5682c65a9226f63610a6eb391c34d06799eb587d/packages/core/contracts/oracle/implementation/EmergencyProposer.sol#L110) function, but the size of the required bond is expected to be large enough that it is unlikely that an individual or the UMA team would be able to sufficiently fund the bond amount on their own. Proposals are executed using the [`emergencyExecute`](https://github.com/UMAprotocol/protocol/blob/5682c65a9226f63610a6eb391c34d06799eb587d/packages/core/contracts/oracle/implementation/GovernorV2.sol#L160) function in the `GovernorV2` contract. The [`executor`](https://github.com/UMAprotocol/protocol/blob/5682c65a9226f63610a6eb391c34d06799eb587d/packages/core/contracts/oracle/implementation/EmergencyProposer.sol#L41) address has the sole ability to call this function, giving it veto power over any proposal. The UMA team controls the `executor` address.\n\n\nThere is currently no restriction that would prevent using the standard voting process to create a transaction that results in the `GovernorV2` contract calling the `emergencyPropose` function to create a proposal. While this is highly unlikely as this transaction would need to pass a standard voting process, this could potentially introduce undesired effects and deviate from the expected functioning of the contract.\n\n\nAn example of an unexpected interaction is that a `GovernorV2` emergency proposal can not be slashed by using the [`slashProposal`](https://github.com/UMAprotocol/protocol/blob/5682c65a9226f63610a6eb391c34d06799eb587d/packages/core/contracts/oracle/implementation/EmergencyProposer.sol#L156) function, as the slash mechanism [transfers the slashed amount to the `GovernorV2` address](https://github.com/UMAprotocol/protocol/blob/5682c65a9226f63610a6eb391c34d06799eb587d/packages/core/contracts/oracle/implementation/EmergencyProposer.sol#L159).\n\n\nTo avoid unexpected or undesirable behavior, consider preventing the `GovernorV2` contract from being able to execute the `emergencyPropose` function.\n\n\n**Update:** *Fixed as of commit [`41a03995087d2e63d047075582ef49783074ba48`](https://github.com/UMAprotocol/protocol/pull/4151/commits/41a03995087d2e63d047075582ef49783074ba48) in [PR #4151](https://github.com/UMAprotocol/protocol/pull/4151).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/core/contracts/oracle/implementation/EmergencyProposer.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.16;\n\nimport \"./Finder.sol\";\nimport \"./GovernorV2.sol\";\nimport \"./Constants.sol\";\nimport \"../interfaces/OracleAncillaryInterface.sol\";\nimport \"./AdminIdentifierLib.sol\";\nimport \"../../common/implementation/Lockable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title Emergency Proposer contract\n * @dev This is a contract that allows anyone to construct an emergency recovery transaction to bypass the\n * standard voting process by submitting a very large bond, which is considered a quorum in this case. This bond is\n * expected to be about as large as the GAT in the VotingV2 contract. If a proposal is considered invalid, UMA token\n * holders can vote to slash and remove this proposal through the standard governance flow. If valid, a proposal must\n * wait minimumWaitTime before it can be executed and it can only be executed by a privileged account, executor. This\n * includes three tiers of protection to ensure that abuse is extremely risky both from creating market volatility in\n * the underlying token and the threat of the locked tokens being slashed.\n */\ncontract EmergencyProposer is Ownable, Lockable {\n    using SafeERC20 for IERC20;\n    IERC20 public immutable token;\n    uint256 public quorum;\n    uint64 public minimumWaitTime;\n\n    GovernorV2 public immutable governor;\n    Finder public immutable finder;\n\n    struct EmergencyProposal {\n        address sender;\n        uint64 expiryTime;\n        uint256 lockedTokens;\n        GovernorV2.Transaction[] transactions;\n    }\n    EmergencyProposal[] public emergencyProposals;\n    uint256 public currentId;\n    address public executor;\n\n    event QuorumSet(uint256 quorum);\n    event ExecutorSet(address executor);\n    event MinimumWaitTimeSet(uint256 minimumWaitTime);\n    event EmergencyTransactionsProposed(\n        uint256 indexed id,\n        address indexed sender,\n        address indexed caller,\n        uint64 expiryTime,\n        uint256 lockedTokens,\n        GovernorV2.Transaction[] transactions\n    );\n    event EmergencyProposalRemoved(\n        uint256 indexed id,\n        address indexed sender,\n        address indexed caller,\n        uint64 expiryTime,\n        uint256 lockedTokens,\n        GovernorV2.Transaction[] transactions\n    );\n    event EmergencyProposalSlashed(\n        uint256 indexed id,\n        address indexed sender,\n        address indexed caller,\n        uint64 expiryTime,\n        uint256 lockedTokens,\n        GovernorV2.Transaction[] transactions\n    );\n    event EmergencyProposalExecuted(\n        uint256 indexed id,\n        address indexed sender,\n        address indexed caller,\n        uint64 expiryTime,\n        uint256 lockedTokens,\n        GovernorV2.Transaction[] transactions\n    );\n\n    /**\n     * @notice Construct the EmergencyProposer contract.\n     * @param _token the ERC20 token that the quorum is in.\n     * @param _quorum the tokens needed to propose an emergency action..\n     * @param _governor the governor contract that this contract makes proposals to.\n     * @param _finder the finder contract used to look up addresses.\n     */\n    constructor(\n        IERC20 _token,\n        uint256 _quorum,\n        GovernorV2 _governor,\n        Finder _finder,\n        address _executor\n    ) {\n        token = _token;\n        governor = _governor;\n        finder = _finder;\n        setExecutor(_executor);\n        setQuorum(_quorum);\n\n        // Start with a hardcoded value of 1 week.\n        setMinimumWaitTime(1 weeks);\n        transferOwnership(address(_governor));\n    }\n\n    /**\n     * @notice Propose an emergency admin action to execute on the DVM as a set of proposed transactions.\n     * @dev Caller of this method must approve (and have) quorum amount of token to be pulled from their wallet.\n     * @param transactions array of transactions to be executed in the emergency action. When executed, will be sent\n     * via the governor contract.\n     */\n    function emergencyPropose(GovernorV2.Transaction[] memory transactions) external nonReentrant() returns (uint256) {\n        token.safeTransferFrom(msg.sender, address(this), quorum);\n        uint256 id = emergencyProposals.length;\n        EmergencyProposal storage proposal = emergencyProposals.push();\n        proposal.sender = msg.sender;\n        proposal.lockedTokens = quorum;\n        proposal.expiryTime = uint64(getCurrentTime()) + minimumWaitTime;\n\n        for (uint256 i = 0; i < transactions.length; i++) proposal.transactions.push(transactions[i]);\n\n        emit EmergencyTransactionsProposed(id, msg.sender, msg.sender, proposal.expiryTime, quorum, transactions);\n        return id;\n    }\n\n    /**\n     * @notice After the proposal is executable, the executor or proposer can use this function to remove the proposal\n     * without slashing.\n     * @dev This means that the DVM didn't explicitly reject the proposal. Allowing the executor to slash the quorum\n     * would give the executor too much power. So the only control either party has is to remove the proposal,\n     * releasing the bond. The proposal should not be removable before its liveness/expiry to ensure the regular Voting\n     * system's slash cannot be frontrun.\n     * @param id id of the proposal.\n     */\n    function removeProposal(uint256 id) external nonReentrant() {\n        EmergencyProposal storage proposal = emergencyProposals[id];\n        require(proposal.expiryTime <= getCurrentTime(), \"must be expired to remove\");\n        require(msg.sender == proposal.sender || msg.sender == executor, \"proposer or executor\");\n        require(proposal.lockedTokens != 0, \"invalid proposal\");\n        token.safeTransfer(proposal.sender, proposal.lockedTokens);\n        emit EmergencyProposalRemoved(\n            id,\n            proposal.sender,\n            msg.sender,\n            proposal.expiryTime,\n            proposal.lockedTokens,\n            proposal.transactions\n        );\n        delete emergencyProposals[id];\n    }\n\n    /**\n     * @notice Before a proposal expires (or after), this method can be used by the owner, which should generally be\n     * the GovernorV2 contract, to slash the proposer.\n     * @dev The slash results in the proposer's tokens being sent to the Governor contract.\n     * @param id id of the proposal.\n     */\n    function slashProposal(uint256 id) external nonReentrant() onlyOwner() {\n        EmergencyProposal storage proposal = emergencyProposals[id];\n        require(proposal.lockedTokens != 0, \"invalid proposal\");\n        token.safeTransfer(address(governor), proposal.lockedTokens);\n        emit EmergencyProposalSlashed(\n            id,\n            proposal.sender,\n            msg.sender,\n            proposal.expiryTime,\n            proposal.lockedTokens,\n            proposal.transactions\n        );\n        delete emergencyProposals[id];\n    }\n\n    /**\n     * @notice After a proposal expires, this method can be used by the executor to execute the proposal.\n     * @dev This method effectively gives the executor veto power over any proposal.\n     * @param id id of the proposal.\n     */\n    function executeEmergencyProposal(uint256 id) public payable nonReentrant() {\n        require(msg.sender == executor, \"must be called by executor\");\n\n        EmergencyProposal storage proposal = emergencyProposals[id];\n        require(proposal.lockedTokens != 0, \"invalid proposal\");\n        require(proposal.expiryTime <= getCurrentTime(), \"must be expired to execute\");\n\n        for (uint256 i = 0; i < proposal.transactions.length; i++)\n            governor.emergencyExecute{ value: address(this).balance }(proposal.transactions[i]);\n\n        token.safeTransfer(proposal.sender, proposal.lockedTokens);\n        emit EmergencyProposalExecuted(\n            id,\n            proposal.sender,\n            msg.sender,\n            proposal.expiryTime,\n            proposal.lockedTokens,\n            proposal.transactions\n        );\n        delete emergencyProposals[id];\n    }\n\n    /**\n     * @notice Admin method to set the quorum (bond) size.\n     * @dev Admin is intended to be the governance system.\n     * @param newQuorum the new quorum.\n     */\n    function setQuorum(uint256 newQuorum) public nonReentrant() onlyOwner() {\n        require(newQuorum != 0, \"quorum must be > 0\");\n        quorum = newQuorum;\n        emit QuorumSet(newQuorum);\n    }\n\n    /**\n     * @notice Admin method to set the executor address.\n     * @dev Admin is intended to be the governance system.\n     * @param newExecutor the new executor address.\n     */\n    function setExecutor(address newExecutor) public nonReentrant() onlyOwner() {\n        executor = newExecutor;\n        emit ExecutorSet(newExecutor);\n    }\n\n    /**\n     * @notice Admin method to set the minimum wait time for a proposal to be executed.\n     * @dev Admin is intended to be the governance system. The minumum wait time is added to the current time at the\n     * time of the proposal to determine when the proposal will be executable. Any changes to this value after that\n     * point will have no impact on the proposal.\n     * @param newMinimumWaitTime the new minimum wait time.\n     */\n    function setMinimumWaitTime(uint64 newMinimumWaitTime) public nonReentrant() onlyOwner() {\n        require(newMinimumWaitTime != 0, \"minimumWaitTime == 0\");\n        minimumWaitTime = newMinimumWaitTime;\n        emit MinimumWaitTimeSet(newMinimumWaitTime);\n    }\n\n    /**\n     * @notice Returns the current block timestamp.\n     * @dev Can be overridden to control contract time.\n     */\n    function getCurrentTime() public view virtual returns (uint256) {\n        return block.timestamp;\n    }\n}"
    },
    {
      "filename": "packages/core/contracts/oracle/implementation/EmergencyProposer.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.16;\n\nimport \"./Finder.sol\";\nimport \"./GovernorV2.sol\";\nimport \"./Constants.sol\";\nimport \"../interfaces/OracleAncillaryInterface.sol\";\nimport \"./AdminIdentifierLib.sol\";\nimport \"../../common/implementation/Lockable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title Emergency Proposer contract\n * @dev This is a contract that allows anyone to construct an emergency recovery transaction to bypass the\n * standard voting process by submitting a very large bond, which is considered a quorum in this case. This bond is\n * expected to be about as large as the GAT in the VotingV2 contract. If a proposal is considered invalid, UMA token\n * holders can vote to slash and remove this proposal through the standard governance flow. If valid, a proposal must\n * wait minimumWaitTime before it can be executed and it can only be executed by a privileged account, executor. This\n * includes three tiers of protection to ensure that abuse is extremely risky both from creating market volatility in\n * the underlying token and the threat of the locked tokens being slashed.\n */\ncontract EmergencyProposer is Ownable, Lockable {\n    using SafeERC20 for IERC20;\n    IERC20 public immutable token;\n    uint256 public quorum;\n    uint64 public minimumWaitTime;\n\n    GovernorV2 public immutable governor;\n    Finder public immutable finder;\n\n    struct EmergencyProposal {\n        address sender;\n        uint64 expiryTime;\n        uint256 lockedTokens;\n        GovernorV2.Transaction[] transactions;\n    }\n    EmergencyProposal[] public emergencyProposals;\n    uint256 public currentId;\n    address public executor;\n\n    event QuorumSet(uint256 quorum);\n    event ExecutorSet(address executor);\n    event MinimumWaitTimeSet(uint256 minimumWaitTime);\n    event EmergencyTransactionsProposed(\n        uint256 indexed id,\n        address indexed sender,\n        address indexed caller,\n        uint64 expiryTime,\n        uint256 lockedTokens,\n        GovernorV2.Transaction[] transactions\n    );\n    event EmergencyProposalRemoved(\n        uint256 indexed id,\n        address indexed sender,\n        address indexed caller,\n        uint64 expiryTime,\n        uint256 lockedTokens,\n        GovernorV2.Transaction[] transactions\n    );\n    event EmergencyProposalSlashed(\n        uint256 indexed id,\n        address indexed sender,\n        address indexed caller,\n        uint64 expiryTime,\n        uint256 lockedTokens,\n        GovernorV2.Transaction[] transactions\n    );\n    event EmergencyProposalExecuted(\n        uint256 indexed id,\n        address indexed sender,\n        address indexed caller,\n        uint64 expiryTime,\n        uint256 lockedTokens,\n        GovernorV2.Transaction[] transactions\n    );\n\n    /**\n     * @notice Construct the EmergencyProposer contract.\n     * @param _token the ERC20 token that the quorum is in.\n     * @param _quorum the tokens needed to propose an emergency action..\n     * @param _governor the governor contract that this contract makes proposals to.\n     * @param _finder the finder contract used to look up addresses.\n     */\n    constructor(\n        IERC20 _token,\n        uint256 _quorum,\n        GovernorV2 _governor,\n        Finder _finder,\n        address _executor\n    ) {\n        token = _token;\n        governor = _governor;\n        finder = _finder;\n        setExecutor(_executor);\n        setQuorum(_quorum);\n\n        // Start with a hardcoded value of 1 week.\n        setMinimumWaitTime(1 weeks);\n        transferOwnership(address(_governor));\n    }\n\n    /**\n     * @notice Propose an emergency admin action to execute on the DVM as a set of proposed transactions.\n     * @dev Caller of this method must approve (and have) quorum amount of token to be pulled from their wallet.\n     * @param transactions array of transactions to be executed in the emergency action. When executed, will be sent\n     * via the governor contract.\n     */\n    function emergencyPropose(GovernorV2.Transaction[] memory transactions) external nonReentrant() returns (uint256) {\n        token.safeTransferFrom(msg.sender, address(this), quorum);\n        uint256 id = emergencyProposals.length;\n        EmergencyProposal storage proposal = emergencyProposals.push();\n        proposal.sender = msg.sender;\n        proposal.lockedTokens = quorum;\n        proposal.expiryTime = uint64(getCurrentTime()) + minimumWaitTime;\n\n        for (uint256 i = 0; i < transactions.length; i++) proposal.transactions.push(transactions[i]);\n\n        emit EmergencyTransactionsProposed(id, msg.sender, msg.sender, proposal.expiryTime, quorum, transactions);\n        return id;\n    }\n\n    /**\n     * @notice After the proposal is executable, the executor or proposer can use this function to remove the proposal\n     * without slashing.\n     * @dev This means that the DVM didn't explicitly reject the proposal. Allowing the executor to slash the quorum\n     * would give the executor too much power. So the only control either party has is to remove the proposal,\n     * releasing the bond. The proposal should not be removable before its liveness/expiry to ensure the regular Voting\n     * system's slash cannot be frontrun.\n     * @param id id of the proposal.\n     */\n    function removeProposal(uint256 id) external nonReentrant() {\n        EmergencyProposal storage proposal = emergencyProposals[id];\n        require(proposal.expiryTime <= getCurrentTime(), \"must be expired to remove\");\n        require(msg.sender == proposal.sender || msg.sender == executor, \"proposer or executor\");\n        require(proposal.lockedTokens != 0, \"invalid proposal\");\n        token.safeTransfer(proposal.sender, proposal.lockedTokens);\n        emit EmergencyProposalRemoved(\n            id,\n            proposal.sender,\n            msg.sender,\n            proposal.expiryTime,\n            proposal.lockedTokens,\n            proposal.transactions\n        );\n        delete emergencyProposals[id];\n    }\n\n    /**\n     * @notice Before a proposal expires (or after), this method can be used by the owner, which should generally be\n     * the GovernorV2 contract, to slash the proposer.\n     * @dev The slash results in the proposer's tokens being sent to the Governor contract.\n     * @param id id of the proposal.\n     */\n    function slashProposal(uint256 id) external nonReentrant() onlyOwner() {\n        EmergencyProposal storage proposal = emergencyProposals[id];\n        require(proposal.lockedTokens != 0, \"invalid proposal\");\n        token.safeTransfer(address(governor), proposal.lockedTokens);\n        emit EmergencyProposalSlashed(\n            id,\n            proposal.sender,\n            msg.sender,\n            proposal.expiryTime,\n            proposal.lockedTokens,\n            proposal.transactions\n        );\n        delete emergencyProposals[id];\n    }\n\n    /**\n     * @notice After a proposal expires, this method can be used by the executor to execute the proposal.\n     * @dev This method effectively gives the executor veto power over any proposal.\n     * @param id id of the proposal.\n     */\n    function executeEmergencyProposal(uint256 id) public payable nonReentrant() {\n        require(msg.sender == executor, \"must be called by executor\");\n\n        EmergencyProposal storage proposal = emergencyProposals[id];\n        require(proposal.lockedTokens != 0, \"invalid proposal\");\n        require(proposal.expiryTime <= getCurrentTime(), \"must be expired to execute\");\n\n        for (uint256 i = 0; i < proposal.transactions.length; i++)\n            governor.emergencyExecute{ value: address(this).balance }(proposal.transactions[i]);\n\n        token.safeTransfer(proposal.sender, proposal.lockedTokens);\n        emit EmergencyProposalExecuted(\n            id,\n            proposal.sender,\n            msg.sender,\n            proposal.expiryTime,\n            proposal.lockedTokens,\n            proposal.transactions\n        );\n        delete emergencyProposals[id];\n    }\n\n    /**\n     * @notice Admin method to set the quorum (bond) size.\n     * @dev Admin is intended to be the governance system.\n     * @param newQuorum the new quorum.\n     */\n    function setQuorum(uint256 newQuorum) public nonReentrant() onlyOwner() {\n        require(newQuorum != 0, \"quorum must be > 0\");\n        quorum = newQuorum;\n        emit QuorumSet(newQuorum);\n    }\n\n    /**\n     * @notice Admin method to set the executor address.\n     * @dev Admin is intended to be the governance system.\n     * @param newExecutor the new executor address.\n     */\n    function setExecutor(address newExecutor) public nonReentrant() onlyOwner() {\n        executor = newExecutor;\n        emit ExecutorSet(newExecutor);\n    }\n\n    /**\n     * @notice Admin method to set the minimum wait time for a proposal to be executed.\n     * @dev Admin is intended to be the governance system. The minumum wait time is added to the current time at the\n     * time of the proposal to determine when the proposal will be executable. Any changes to this value after that\n     * point will have no impact on the proposal.\n     * @param newMinimumWaitTime the new minimum wait time.\n     */\n    function setMinimumWaitTime(uint64 newMinimumWaitTime) public nonReentrant() onlyOwner() {\n        require(newMinimumWaitTime != 0, \"minimumWaitTime == 0\");\n        minimumWaitTime = newMinimumWaitTime;\n        emit MinimumWaitTimeSet(newMinimumWaitTime);\n    }\n\n    /**\n     * @notice Returns the current block timestamp.\n     * @dev Can be overridden to control contract time.\n     */\n    function getCurrentTime() public view virtual returns (uint256) {\n        return block.timestamp;\n    }\n}"
    },
    {
      "filename": "packages/core/contracts/oracle/implementation/EmergencyProposer.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.16;\n\nimport \"./Finder.sol\";\nimport \"./GovernorV2.sol\";\nimport \"./Constants.sol\";\nimport \"../interfaces/OracleAncillaryInterface.sol\";\nimport \"./AdminIdentifierLib.sol\";\nimport \"../../common/implementation/Lockable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title Emergency Proposer contract\n * @dev This is a contract that allows anyone to construct an emergency recovery transaction to bypass the\n * standard voting process by submitting a very large bond, which is considered a quorum in this case. This bond is\n * expected to be about as large as the GAT in the VotingV2 contract. If a proposal is considered invalid, UMA token\n * holders can vote to slash and remove this proposal through the standard governance flow. If valid, a proposal must\n * wait minimumWaitTime before it can be executed and it can only be executed by a privileged account, executor. This\n * includes three tiers of protection to ensure that abuse is extremely risky both from creating market volatility in\n * the underlying token and the threat of the locked tokens being slashed.\n */\ncontract EmergencyProposer is Ownable, Lockable {\n    using SafeERC20 for IERC20;\n    IERC20 public immutable token;\n    uint256 public quorum;\n    uint64 public minimumWaitTime;\n\n    GovernorV2 public immutable governor;\n    Finder public immutable finder;\n\n    struct EmergencyProposal {\n        address sender;\n        uint64 expiryTime;\n        uint256 lockedTokens;\n        GovernorV2.Transaction[] transactions;\n    }\n    EmergencyProposal[] public emergencyProposals;\n    uint256 public currentId;\n    address public executor;\n\n    event QuorumSet(uint256 quorum);\n    event ExecutorSet(address executor);\n    event MinimumWaitTimeSet(uint256 minimumWaitTime);\n    event EmergencyTransactionsProposed(\n        uint256 indexed id,\n        address indexed sender,\n        address indexed caller,\n        uint64 expiryTime,\n        uint256 lockedTokens,\n        GovernorV2.Transaction[] transactions\n    );\n    event EmergencyProposalRemoved(\n        uint256 indexed id,\n        address indexed sender,\n        address indexed caller,\n        uint64 expiryTime,\n        uint256 lockedTokens,\n        GovernorV2.Transaction[] transactions\n    );\n    event EmergencyProposalSlashed(\n        uint256 indexed id,\n        address indexed sender,\n        address indexed caller,\n        uint64 expiryTime,\n        uint256 lockedTokens,\n        GovernorV2.Transaction[] transactions\n    );\n    event EmergencyProposalExecuted(\n        uint256 indexed id,\n        address indexed sender,\n        address indexed caller,\n        uint64 expiryTime,\n        uint256 lockedTokens,\n        GovernorV2.Transaction[] transactions\n    );\n\n    /**\n     * @notice Construct the EmergencyProposer contract.\n     * @param _token the ERC20 token that the quorum is in.\n     * @param _quorum the tokens needed to propose an emergency action..\n     * @param _governor the governor contract that this contract makes proposals to.\n     * @param _finder the finder contract used to look up addresses.\n     */\n    constructor(\n        IERC20 _token,\n        uint256 _quorum,\n        GovernorV2 _governor,\n        Finder _finder,\n        address _executor\n    ) {\n        token = _token;\n        governor = _governor;\n        finder = _finder;\n        setExecutor(_executor);\n        setQuorum(_quorum);\n\n        // Start with a hardcoded value of 1 week.\n        setMinimumWaitTime(1 weeks);\n        transferOwnership(address(_governor));\n    }\n\n    /**\n     * @notice Propose an emergency admin action to execute on the DVM as a set of proposed transactions.\n     * @dev Caller of this method must approve (and have) quorum amount of token to be pulled from their wallet.\n     * @param transactions array of transactions to be executed in the emergency action. When executed, will be sent\n     * via the governor contract.\n     */\n    function emergencyPropose(GovernorV2.Transaction[] memory transactions) external nonReentrant() returns (uint256) {\n        token.safeTransferFrom(msg.sender, address(this), quorum);\n        uint256 id = emergencyProposals.length;\n        EmergencyProposal storage proposal = emergencyProposals.push();\n        proposal.sender = msg.sender;\n        proposal.lockedTokens = quorum;\n        proposal.expiryTime = uint64(getCurrentTime()) + minimumWaitTime;\n\n        for (uint256 i = 0; i < transactions.length; i++) proposal.transactions.push(transactions[i]);\n\n        emit EmergencyTransactionsProposed(id, msg.sender, msg.sender, proposal.expiryTime, quorum, transactions);\n        return id;\n    }\n\n    /**\n     * @notice After the proposal is executable, the executor or proposer can use this function to remove the proposal\n     * without slashing.\n     * @dev This means that the DVM didn't explicitly reject the proposal. Allowing the executor to slash the quorum\n     * would give the executor too much power. So the only control either party has is to remove the proposal,\n     * releasing the bond. The proposal should not be removable before its liveness/expiry to ensure the regular Voting\n     * system's slash cannot be frontrun.\n     * @param id id of the proposal.\n     */\n    function removeProposal(uint256 id) external nonReentrant() {\n        EmergencyProposal storage proposal = emergencyProposals[id];\n        require(proposal.expiryTime <= getCurrentTime(), \"must be expired to remove\");\n        require(msg.sender == proposal.sender || msg.sender == executor, \"proposer or executor\");\n        require(proposal.lockedTokens != 0, \"invalid proposal\");\n        token.safeTransfer(proposal.sender, proposal.lockedTokens);\n        emit EmergencyProposalRemoved(\n            id,\n            proposal.sender,\n            msg.sender,\n            proposal.expiryTime,\n            proposal.lockedTokens,\n            proposal.transactions\n        );\n        delete emergencyProposals[id];\n    }\n\n    /**\n     * @notice Before a proposal expires (or after), this method can be used by the owner, which should generally be\n     * the GovernorV2 contract, to slash the proposer.\n     * @dev The slash results in the proposer's tokens being sent to the Governor contract.\n     * @param id id of the proposal.\n     */\n    function slashProposal(uint256 id) external nonReentrant() onlyOwner() {\n        EmergencyProposal storage proposal = emergencyProposals[id];\n        require(proposal.lockedTokens != 0, \"invalid proposal\");\n        token.safeTransfer(address(governor), proposal.lockedTokens);\n        emit EmergencyProposalSlashed(\n            id,\n            proposal.sender,\n            msg.sender,\n            proposal.expiryTime,\n            proposal.lockedTokens,\n            proposal.transactions\n        );\n        delete emergencyProposals[id];\n    }\n\n    /**\n     * @notice After a proposal expires, this method can be used by the executor to execute the proposal.\n     * @dev This method effectively gives the executor veto power over any proposal.\n     * @param id id of the proposal.\n     */\n    function executeEmergencyProposal(uint256 id) public payable nonReentrant() {\n        require(msg.sender == executor, \"must be called by executor\");\n\n        EmergencyProposal storage proposal = emergencyProposals[id];\n        require(proposal.lockedTokens != 0, \"invalid proposal\");\n        require(proposal.expiryTime <= getCurrentTime(), \"must be expired to execute\");\n\n        for (uint256 i = 0; i < proposal.transactions.length; i++)\n            governor.emergencyExecute{ value: address(this).balance }(proposal.transactions[i]);\n\n        token.safeTransfer(proposal.sender, proposal.lockedTokens);\n        emit EmergencyProposalExecuted(\n            id,\n            proposal.sender,\n            msg.sender,\n            proposal.expiryTime,\n            proposal.lockedTokens,\n            proposal.transactions\n        );\n        delete emergencyProposals[id];\n    }\n\n    /**\n     * @notice Admin method to set the quorum (bond) size.\n     * @dev Admin is intended to be the governance system.\n     * @param newQuorum the new quorum.\n     */\n    function setQuorum(uint256 newQuorum) public nonReentrant() onlyOwner() {\n        require(newQuorum != 0, \"quorum must be > 0\");\n        quorum = newQuorum;\n        emit QuorumSet(newQuorum);\n    }\n\n    /**\n     * @notice Admin method to set the executor address.\n     * @dev Admin is intended to be the governance system.\n     * @param newExecutor the new executor address.\n     */\n    function setExecutor(address newExecutor) public nonReentrant() onlyOwner() {\n        executor = newExecutor;\n        emit ExecutorSet(newExecutor);\n    }\n\n    /**\n     * @notice Admin method to set the minimum wait time for a proposal to be executed.\n     * @dev Admin is intended to be the governance system. The minumum wait time is added to the current time at the\n     * time of the proposal to determine when the proposal will be executable. Any changes to this value after that\n     * point will have no impact on the proposal.\n     * @param newMinimumWaitTime the new minimum wait time.\n     */\n    function setMinimumWaitTime(uint64 newMinimumWaitTime) public nonReentrant() onlyOwner() {\n        require(newMinimumWaitTime != 0, \"minimumWaitTime == 0\");\n        minimumWaitTime = newMinimumWaitTime;\n        emit MinimumWaitTimeSet(newMinimumWaitTime);\n    }\n\n    /**\n     * @notice Returns the current block timestamp.\n     * @dev Can be overridden to control contract time.\n     */\n    function getCurrentTime() public view virtual returns (uint256) {\n        return block.timestamp;\n    }\n}"
    }
  ]
}