{
  "Title": "[M-02] Rotating LPTokens to banned BLS public key",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/ETHPoolLPFactory.sol#L76\n\n\n# Vulnerability details\n\n## Impact\n\nIt is possible to rotate `LPTokens` to a banned BLS public key. This is not a safe action, because it can result in insolvency of the project (specially if the banned BLS public key was malicious).\n\n## Proof of Concept\n\nWhen a user deposits ETH for staking by calling `depositETHForStaking`, the manager checks whether the provided BLS public key is banned or not.\n`require(liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key is banned or not a part of LSD network\");`\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L113\n\nIf it is not banned the `LPToken` related to that BLS public key will be minted to the caller, so the number of `LPToken` related to that BLS public key will be increased. \nhttps://github.com/code-423n4/2022-11-stakehouse/blob/39a3a84615725b7b2ce296861352117793e4c853/contracts/liquid-staking/ETHPoolLPFactory.sol#L125\n\nIf it is banned, it will not be possible to stake to this BLS public key, so the number of `LPToken` will not be increased. But the issue is that it is still possible to increase the `LPToken` of this BLS public key through rotating `LPToken`. \n\nIn other words, a malicious user can call `rotateLPTokens`, so that the `_oldLPToken` will be migrated to `_newLPToken` which is equal to the `LPToken` related to the banned BLS public key.\n\nIn summary, the vulnerability is that during rorating `LPTokens`, it is not checked that the `_newLPToken` is related to a banned BLS public key or not.\n\n## Tools Used\n\n## Recommended Mitigation Steps\nThe following line should be added to function `rotateLPTokens(...)`:\n`require(liquidStakingNetworkManager.isBLSPublicKeyBanned(blsPublicKeyOfNewKnot ) == false, \"BLS public key is banned or not a part of LSD network\");`\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/ETHPoolLPFactory.sol#L76",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-lsd-network-stakehouse-contest",
  "Code": [
    {
      "filename": "contracts/liquid-staking/ETHPoolLPFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { IDataStructures } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol\";\n\nimport { LPTokenFactory } from \"./LPTokenFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\n\n/// @dev For pools accepting ETH for validator staking, this contract will manage issuing LPs for deposits\nabstract contract ETHPoolLPFactory is StakehouseAPI {\n\n    /// @notice signalize withdrawing of ETH by depositor\n    event ETHWithdrawnByDepositor(address depositor, uint256 amount);\n\n    /// @notice signalize burning of LP token\n    event LPTokenBurnt(bytes blsPublicKeyOfKnot, address token, address depositor, uint256 amount);\n\n    /// @notice signalize issuance of new LP token\n    event NewLPTokenIssued(bytes blsPublicKeyOfKnot, address token, address firstDepositor, uint256 amount);\n\n    /// @notice signalize issuance of existing LP token\n    event LPTokenMinted(bytes blsPublicKeyOfKnot, address token, address depositor, uint256 amount);\n\n    /// @dev Base name and symbol used for deploying new LP tokens per KNOT\n    string internal baseLPTokenName;\n    string internal baseLPTokenSymbol;\n\n    /// @notice count of unique LP tokens issued for ETH deposits\n    uint256 public numberOfLPTokensIssued;\n\n    /// @notice Maximum amount that can be staked per validator in WEI\n    uint256 public maxStakingAmountPerValidator;\n\n    /// @notice Minimum amount that can be staked per validator in WEI\n    uint256 public constant MIN_STAKING_AMOUNT = 0.001 ether;\n\n    /// @notice Factory for the deployment of KNOT<>LP Tokens that can be used to redeem dETH\n    LPTokenFactory public lpTokenFactory;\n\n    /// @notice LP token address deployed for a KNOT's BLS public key\n    mapping(bytes => LPToken) public lpTokenForKnot;\n\n    /// @notice KNOT BLS public key associated with the LP token\n    mapping(LPToken => bytes) public KnotAssociatedWithLPToken;\n\n    /// @notice Allow users to rotate the ETH from many LP to another in the event that a BLS key is never staked\n    /// @param _oldLPTokens Array of old LP tokens to be burnt\n    /// @param _newLPTokens Array of new LP tokens to be minted in exchange of old LP tokens\n    /// @param _amounts Array of amount of tokens to be exchanged\n    function batchRotateLPTokens(\n        LPToken[] calldata _oldLPTokens,\n        LPToken[] calldata _newLPTokens,\n        uint256[] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _oldLPTokens.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n\n        for (uint256 i; i < numOfRotations; ++i) {\n            rotateLPTokens(\n                _oldLPTokens[i],\n                _newLPTokens[i],\n                _amounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow users to rotate the ETH from one LP token to another in the event that the BLS key is never staked\n    /// @param _oldLPToken Instance of the old LP token (to be burnt)\n    /// @param _newLPToken Instane of the new LP token (to be minted)\n    /// @param _amount Amount of LP tokens to be rotated/converted from old to new\n    function rotateLPTokens(LPToken _oldLPToken, LPToken _newLPToken, uint256 _amount) public {\n        require(address(_oldLPToken) != address(0), \"Zero address\");\n        require(address(_newLPToken) != address(0), \"Zero address\");\n        require(_oldLPToken != _newLPToken, \"Incorrect rotation to same token\");\n        require(_amount >= MIN_STAKING_AMOUNT, \"Amount cannot be zero\");\n        require(_amount <= _oldLPToken.balanceOf(msg.sender), \"Not enough balance\");\n        require(_oldLPToken.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, \"Liquidity is still fresh\");\n        require(_amount + _newLPToken.totalSupply() <= 24 ether, \"Not enough mintable tokens\");\n\n        bytes memory blsPublicKeyOfPreviousKnot = KnotAssociatedWithLPToken[_oldLPToken];\n        bytes memory blsPublicKeyOfNewKnot = KnotAssociatedWithLPToken[_newLPToken];\n\n        require(blsPublicKeyOfPreviousKnot.length == 48, \"Incorrect BLS public key\");\n        require(blsPublicKeyOfNewKnot.length == 48, \"Incorrect BLS public key\");\n\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfPreviousKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Lifecycle status must be one\"\n        );\n\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfNewKnot) ==IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Lifecycle status must be one\"\n        );\n\n        // burn old tokens and mint new ones\n        _oldLPToken.burn(msg.sender, _amount);\n        emit LPTokenBurnt(blsPublicKeyOfPreviousKnot, address(_oldLPToken), msg.sender, _amount);\n\n        _newLPToken.mint(msg.sender, _amount);\n        emit LPTokenMinted(KnotAssociatedWithLPToken[_newLPToken], address(_newLPToken), msg.sender, _amount);\n    }\n\n    /// @dev Internal business logic for processing staking deposits for single or batch deposits\n    function _depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount, bool _enableTransferHook) internal {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Min amount not reached\");\n        require(_blsPublicKeyOfKnot.length == 48, \"Invalid BLS public key\");\n\n        // LP token issued for the KNOT\n        // will be zero for a new KNOT because the mapping doesn't exist\n        LPToken lpToken = lpTokenForKnot[_blsPublicKeyOfKnot];\n        if(address(lpToken) != address(0)) {\n            // KNOT and it's LP token is already registered\n            // mint the respective LP tokens for the user\n\n            // total supply after minting the LP token must not exceed maximum staking amount per validator\n            require(lpToken.totalSupply() + _amount <= maxStakingAmountPerValidator, \"Amount exceeds the staking limit for the validator\");\n\n            // mint LP tokens for the depoistor with 1:1 ratio of LP tokens and ETH supplied\n            lpToken.mint(msg.sender, _amount);\n            emit LPTokenMinted(_blsPublicKeyOfKnot, address(lpToken), msg.sender, _amount);\n        }\n        else {\n            // check that amount doesn't exceed max staking amount per validator\n            require(_amount <= maxStakingAmountPerValidator, \"Amount exceeds the staking limit for the validator\");\n            \n            // mint new LP tokens for the new KNOT\n            // add the KNOT in the mapping\n            string memory tokenNumber = Strings.toString(numberOfLPTokensIssued);\n            string memory tokenName = string(abi.encodePacked(baseLPTokenName, tokenNumber));\n            string memory tokenSymbol = string(abi.encodePacked(baseLPTokenSymbol, tokenNumber));\n\n            // deploy new LP token and optionally enable transfer notifications\n            LPToken newLPToken = _enableTransferHook ?\n                             LPToken(lpTokenFactory.deployLPToken(address(this), address(this), tokenSymbol, tokenName)) :\n                             LPToken(lpTokenFactory.deployLPToken(address(this), address(0), tokenSymbol, tokenName));\n\n            // increase the count of LP tokens\n            numberOfLPTokensIssued++;\n\n            // register the BLS Public Key with the LP token\n            lpTokenForKnot[_blsPublicKeyOfKnot] = newLPToken;\n            KnotAssociatedWithLPToken[newLPToken] = _blsPublicKeyOfKnot;\n\n            // mint LP tokens for the depoistor with 1:1 ratio of LP tokens and ETH supplied\n            newLPToken.mint(msg.sender, _amount);\n            emit NewLPTokenIssued(_blsPublicKeyOfKnot, address(newLPToken), msg.sender, _amount);\n        }\n    }\n}"
    }
  ]
}