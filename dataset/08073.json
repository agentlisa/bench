{
  "Title": "[H-04] ERC721Votes: Token owners can double voting power through self delegation",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L131-L135\nhttps://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L176-L190\nhttps://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L192-L235\n\n\n# Vulnerability details\n\nThe owner of one or many `ERC721Votes` tokens can double their voting power once (and only once) by delegating to their own address as their first delegation.\n\n### Scenario\nThis exploit relies on the initial default value of the `delegation` mapping in `ERC721Votes`, which is why it will only work once per address.\n\nFirst, the token owner must call `delegate` or `delegateBySig`, passing their own address as the delegate:\n\n[`ERC721Votes#delegate`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L131-L135)\n\n```solidity\n    /// @notice Delegates votes to an account\n    /// @param _to The address delegating votes to\n    function delegate(address _to) external {\n        _delegate(msg.sender, _to);\n    }\n```\n\nThis calls into the internal `_delegate` function, with `_from` and `_to` both set to the token owner's address:\n\n[`ERC721Votes#_delegate`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L176-L190)\n\n```solidity\n    /// @dev Updates delegate addresses\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    function _delegate(address _from, address _to) internal {\n        // Get the previous delegate\n        address prevDelegate = delegation[_from];\n\n        // Store the new delegate\n        delegation[_from] = _to;\n\n        emit DelegateChanged(_from, prevDelegate, _to);\n\n        // Transfer voting weight from the previous delegate to the new delegate\n        _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));\n    }\n```\n\nSince this is the token owner's first delegation, the `delegation` mapping does not contain a value for the `_from` address, and `prevDelegate` on L#181 will be set to `address(0)`:\n\n[`ERC721Votes.sol#L180-L181`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L180-L181)\n\n```solidity\n        // Get the previous delegate\n        address prevDelegate = delegation[_from];\n```\n\nThis function then calls into `_moveDelegateVotes` to transfer voting power. This time, `_from` is `prevDelegate`, equal to `address(0)`; `_to` is the token owner's address; and `_amount` is `balanceOf(_from)`, the token owner's current balance:\n\n[`ERC721Votes#_moveDelegateVotes`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L192-L235)\n\n```solidity\n /// @dev Transfers voting weight\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    /// @param _amount The number of votes delegating\n    function _moveDelegateVotes(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        unchecked {\n            // If voting weight is being transferred:\n            if (_from != _to && _amount > 0) {\n                // If this isn't a token mint:\n                if (_from != address(0)) {\n                    // Get the sender's number of checkpoints\n                    uint256 nCheckpoints = numCheckpoints[_from]++;\n\n                    // Used to store the sender's previous voting weight\n                    uint256 prevTotalVotes;\n\n                    // If this isn't the sender's first checkpoint: Get their previous voting weight\n                    if (nCheckpoints != 0) prevTotalVotes = checkpoints[_from][nCheckpoints - 1].votes;\n\n                    // Update their voting weight\n                    _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes - _amount);\n                }\n\n                // If this isn't a token burn:\n                if (_to != address(0)) {\n                    // Get the recipients's number of checkpoints\n                    uint256 nCheckpoints = numCheckpoints[_to]++;\n\n                    // Used to store the recipient's previous voting weight\n                    uint256 prevTotalVotes;\n\n                    // If this isn't the recipient's first checkpoint: Get their previous voting weight\n                    if (nCheckpoints != 0) prevTotalVotes = checkpoints[_to][nCheckpoints - 1].votes;\n\n                    // Update their voting weight\n                    _writeCheckpoint(_to, nCheckpoints, prevTotalVotes, prevTotalVotes + _amount);\n                }\n            }\n        }\n    }\n```\n\nThe `if` condition on L#203 is `true`, since `_from` is `address(0)`, `_to` is the owner address, and `_amount` is nonzero:\n\n[`ERC721Votes.sol#L202-L203`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L202-L203)\n\n```solidity\n            // If voting weight is being transferred:\n            if (_from != _to && _amount > 0) {\n```\n\nExecution skips the `if` block on L#205-217, since `_from` is `address(0)`:\n\n[`ERC721Votes.sol#L205-L217`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L204-L217)\n\n```solidity\n                // If this isn't a token mint:\n                if (_from != address(0)) {\n                    // Get the sender's number of checkpoints\n                    uint256 nCheckpoints = numCheckpoints[_from]++;\n\n                    // Used to store the sender's previous voting weight\n                    uint256 prevTotalVotes;\n\n                    // If this isn't the sender's first checkpoint: Get their previous voting weight\n                    if (nCheckpoints != 0) prevTotalVotes = checkpoints[_from][nCheckpoints - 1].votes;\n\n                    // Update their voting weight\n                    _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes - _amount);\n                }\n```\n\nHowever, the `if` block on L#220-232 will execute and increase the voting power allocated to `_to`:\n\n[`ERC721Votes.sol#L220-L232`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L219-L232)\n\n```solidity\n                // If this isn't a token burn:\n                if (_to != address(0)) {\n                    // Get the recipients's number of checkpoints\n                    uint256 nCheckpoints = numCheckpoints[_to]++;\n\n                    // Used to store the recipient's previous voting weight\n                    uint256 prevTotalVotes;\n\n                    // If this isn't the recipient's first checkpoint: Get their previous voting weight\n                    if (nCheckpoints != 0) prevTotalVotes = checkpoints[_to][nCheckpoints - 1].votes;\n\n                    // Update their voting weight\n                    _writeCheckpoint(_to, nCheckpoints, prevTotalVotes, prevTotalVotes + _amount);\n                }\n```\n\nThe token owner's voting power has now been increased by an amount equal to their total number of tokens, without an offsetting decrease.\n\nThis exploit only works once: if a token owner subsequently delegates to themselves after their initial self delegation, `prevDelegate` will be set to a non-default value in `_delegate`, and the delegation logic will work as intended.\n\n### Impact\nMalicious `ERC21Votes` owners can accrue more voting power than they deserve. Especially malicious owners may quietly acquire multiple tokens before doubling their voting power. In an early DAO with a small supply of tokens, the impact of this exploit could be significant.\n\n### Recommendation\nMake the `delegates` function `public` rather than `external`:\n\n```solidity\n    /// @notice The delegate for an account\n    /// @param _account The account address\n    function delegates(address _account) public view returns (address) {\n        address current = delegation[_account];\n        return current == address(0) ? _account : current;\n    }\n```\n\nThen, call this function rather than accessing the `delegation` mapping directly:\n\n```solidity\n    /// @dev Updates delegate addresses\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    function _delegate(address _from, address _to) internal {\n        // Get the previous delegate\n        address prevDelegate = delegates(_from);\n\n        // Store the new delegate\n        delegation[_from] = _to;\n\n        emit DelegateChanged(_from, prevDelegate, _to);\n\n        // Transfer voting weight from the previous delegate to the new delegate\n        _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));\n    }\n```\n\nNote that the original NounsDAO contracts follow this pattern. (See [here](https://github.com/nounsDAO/nouns-monorepo/blob/master/packages/nouns-contracts/contracts/base/ERC721Checkpointable.sol#L83-L91) and [here](https://github.com/nounsDAO/nouns-monorepo/blob/master/packages/nouns-contracts/contracts/base/ERC721Checkpointable.sol#L83-L91)).\n\n\n### Test cases\n(Put the following test cases in `Gov.t.sol`)\n\n```solidity\n    function test_delegate_to_self_doubles_voting_power() public {\n        mintVoter1();\n\n        assertEq(token.getVotes(address(voter1)), 1);\n\n        vm.startPrank(voter1);\n        token.delegate(address(voter1));\n\n        assertEq(token.getVotes(address(voter1)), 2);\n    }\n\n    function mintToken(uint256 tokenId) internal {\n        vm.prank(voter1);\n        auction.createBid{ value: 0.420 ether }(tokenId);\n\n        vm.warp(block.timestamp + auctionParams.duration + 1 seconds);\n        auction.settleCurrentAndCreateNewAuction();\n    }\n\n    function test_delegate_to_self_multiple_tokens_doubles_voting_power() public {\n        // An especially malicious user may acquire multiple tokens\n        // before doubling their voting power through this exploit.\n        mintVoter1();\n        mintToken(3);\n        mintToken(4);\n        mintToken(5);\n        mintToken(6);\n\n        assertEq(token.getVotes(address(voter1)), 5);\n\n        vm.prank(voter1);\n        token.delegate(address(voter1));\n\n        assertEq(token.getVotes(address(voter1)), 10);\n    }\n```",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-09-nouns-builder-contest",
  "Code": [
    {
      "filename": "src/lib/token/ERC721Votes.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { IERC721Votes } from \"../interfaces/IERC721Votes.sol\";\nimport { ERC721 } from \"../token/ERC721.sol\";\nimport { EIP712 } from \"../utils/EIP712.sol\";\n\n/// @title ERC721Votes\n/// @author Rohan Kulkarni\n/// @notice Modified from OpenZeppelin Contracts v4.7.3 (token/ERC721/extensions/draft-ERC721Votes.sol) & Nouns DAO ERC721Checkpointable.sol commit 2cbe6c7 - licensed under the BSD-3-Clause license.\n/// - Uses custom errors defined in IERC721Votes\n/// - Checkpoints are based on timestamps instead of block numbers\n/// - Tokens are self-delegated by default\n/// - The total number of votes is the token supply itself\nabstract contract ERC721Votes is IERC721Votes, EIP712, ERC721 {\n    ///                                                          ///\n    ///                          CONSTANTS                       ///\n    ///                                                          ///\n\n    /// @dev The EIP-712 typehash to delegate with a signature\n    bytes32 internal constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address from,address to,uint256 nonce,uint256 deadline)\");\n\n    ///                                                          ///\n    ///                           STORAGE                        ///\n    ///                                                          ///\n\n    /// @notice The delegate for an account\n    /// @notice Account => Delegate\n    mapping(address => address) internal delegation;\n\n    /// @notice The number of checkpoints for an account\n    /// @dev Account => Num Checkpoints\n    mapping(address => uint256) internal numCheckpoints;\n\n    /// @notice The checkpoint for an account\n    /// @dev Account => Checkpoint Id => Checkpoint\n    mapping(address => mapping(uint256 => Checkpoint)) internal checkpoints;\n\n    ///                                                          ///\n    ///                        VOTING WEIGHT                     ///\n    ///                                                          ///\n\n    /// @notice The current number of votes for an account\n    /// @param _account The account address\n    function getVotes(address _account) public view returns (uint256) {\n        // Get the account's number of checkpoints\n        uint256 nCheckpoints = numCheckpoints[_account];\n\n        // Cannot underflow as `nCheckpoints` is ensured to be greater than 0 if reached\n        unchecked {\n            // Return the number of votes at the latest checkpoint if applicable\n            return nCheckpoints != 0 ? checkpoints[_account][nCheckpoints - 1].votes : 0;\n        }\n    }\n\n    /// @notice The number of votes for an account at a past timestamp\n    /// @param _account The account address\n    /// @param _timestamp The past timestamp\n    function getPastVotes(address _account, uint256 _timestamp) public view returns (uint256) {\n        // Ensure the given timestamp is in the past\n        if (_timestamp >= block.timestamp) revert INVALID_TIMESTAMP();\n\n        // Get the account's number of checkpoints\n        uint256 nCheckpoints = numCheckpoints[_account];\n\n        // If there are none return 0\n        if (nCheckpoints == 0) return 0;\n\n        // Get the account's checkpoints\n        mapping(uint256 => Checkpoint) storage accountCheckpoints = checkpoints[_account];\n\n        unchecked {\n            // Get the latest checkpoint id\n            // Cannot underflow as `nCheckpoints` is ensured to be greater than 0\n            uint256 lastCheckpoint = nCheckpoints - 1;\n\n            // If the latest checkpoint has a valid timestamp, return its number of votes\n            if (accountCheckpoints[lastCheckpoint].timestamp <= _timestamp) return accountCheckpoints[lastCheckpoint].votes;\n\n            // If the first checkpoint doesn't have a valid timestamp, return 0\n            if (accountCheckpoints[0].timestamp > _timestamp) return 0;\n\n            // Otherwise, find a checkpoint with a valid timestamp\n            // Use the latest id as the initial upper bound\n            uint256 high = lastCheckpoint;\n            uint256 low;\n            uint256 middle;\n\n            // Used to temporarily hold a checkpoint\n            Checkpoint memory cp;\n\n            // While a valid checkpoint is to be found:\n            while (high > low) {\n                // Find the id of the middle checkpoint\n                middle = high - (high - low) / 2;\n\n                // Get the middle checkpoint\n                cp = accountCheckpoints[middle];\n\n                // If the timestamp is a match:\n                if (cp.timestamp == _timestamp) {\n                    // Return the voting weight\n                    return cp.votes;\n\n                    // Else if the timestamp is before the one looking for:\n                } else if (cp.timestamp < _timestamp) {\n                    // Update the lower bound\n                    low = middle;\n\n                    // Else update the upper bound\n                } else {\n                    high = middle - 1;\n                }\n            }\n\n            return accountCheckpoints[low].votes;\n        }\n    }\n\n    ///                                                          ///\n    ///                          DELEGATION                      ///\n    ///                                                          ///\n\n    /// @notice The delegate for an account\n    /// @param _account The account address\n    function delegates(address _account) external view returns (address) {\n        address current = delegation[_account];\n        return current == address(0) ? _account : current;\n    }\n\n    /// @notice Delegates votes to an account\n    /// @param _to The address delegating votes to\n    function delegate(address _to) external {\n        _delegate(msg.sender, _to);\n    }\n\n    /// @notice Delegates votes from a signer to an account\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    /// @param _deadline The signature deadline\n    /// @param _v The 129th byte and chain id of the signature\n    /// @param _r The first 64 bytes of the signature\n    /// @param _s Bytes 64-128 of the signature\n    function delegateBySig(\n        address _from,\n        address _to,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        // Ensure the signature has not expired\n        if (block.timestamp > _deadline) revert EXPIRED_SIGNATURE();\n\n        // Used to store the digest\n        bytes32 digest;\n\n        // Cannot realistically overflow\n        unchecked {\n            // Compute the hash of the domain seperator with the typed delegation data\n            digest = keccak256(\n                abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR(), keccak256(abi.encode(DELEGATION_TYPEHASH, _from, _to, nonces[_from]++, _deadline)))\n            );\n        }\n\n        // Recover the message signer\n        address recoveredAddress = ecrecover(digest, _v, _r, _s);\n\n        // Ensure the recovered signer is the voter\n        if (recoveredAddress == address(0) || recoveredAddress != _from) revert INVALID_SIGNATURE();\n\n        // Update the delegate\n        _delegate(_from, _to);\n    }\n\n    /// @dev Updates delegate addresses\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    function _delegate(address _from, address _to) internal {\n        // Get the previous delegate\n        address prevDelegate = delegation[_from];\n\n        // Store the new delegate\n        delegation[_from] = _to;\n\n        emit DelegateChanged(_from, prevDelegate, _to);\n\n        // Transfer voting weight from the previous delegate to the new delegate\n        _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));\n    }\n\n    /// @dev Transfers voting weight\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    /// @param _amount The number of votes delegating\n    function _moveDelegateVotes(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        unchecked {\n            // If voting weight is being transferred:\n            if (_from != _to && _amount > 0) {\n                // If this isn't a token mint:\n                if (_from != address(0)) {\n                    // Get the sender's number of checkpoints\n                    uint256 nCheckpoints = numCheckpoints[_from]++;\n\n                    // Used to store the sender's previous voting weight\n                    uint256 prevTotalVotes;\n\n                    // If this isn't the sender's first checkpoint: Get their previous voting weight\n                    if (nCheckpoints != 0) prevTotalVotes = checkpoints[_from][nCheckpoints - 1].votes;\n\n                    // Update their voting weight\n                    _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes - _amount);\n                }\n\n                // If this isn't a token burn:\n                if (_to != address(0)) {\n                    // Get the recipients's number of checkpoints\n                    uint256 nCheckpoints = numCheckpoints[_to]++;\n\n                    // Used to store the recipient's previous voting weight\n                    uint256 prevTotalVotes;\n\n                    // If this isn't the recipient's first checkpoint: Get their previous voting weight\n                    if (nCheckpoints != 0) prevTotalVotes = checkpoints[_to][nCheckpoints - 1].votes;\n\n                    // Update their voting weight\n                    _writeCheckpoint(_to, nCheckpoints, prevTotalVotes, prevTotalVotes + _amount);\n                }\n            }\n        }\n    }\n\n    /// @dev Records a checkpoint\n    /// @param _account The account address\n    /// @param _id The checkpoint id\n    /// @param _prevTotalVotes The account's previous voting weight\n    /// @param _newTotalVotes The account's new voting weight\n    function _writeCheckpoint(\n        address _account,\n        uint256 _id,\n        uint256 _prevTotalVotes,\n        uint256 _newTotalVotes\n    ) private {\n        // Get the pointer to store the checkpoint\n        Checkpoint storage checkpoint = checkpoints[_account][_id];\n\n        // Record the updated voting weight and current time\n        checkpoint.votes = uint192(_newTotalVotes);\n        checkpoint.timestamp = uint64(block.timestamp);\n\n        emit DelegateVotesChanged(_account, _prevTotalVotes, _newTotalVotes);\n    }\n\n    /// @dev Enables each NFT to equal 1 vote\n    /// @param _from The token sender\n    /// @param _to The token recipient\n    /// @param _tokenId The ERC-721 token id\n    function _afterTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal override {\n        // Transfer 1 vote from the sender to the recipient\n        _moveDelegateVotes(_from, _to, 1);\n\n        super._afterTokenTransfer(_from, _to, _tokenId);\n    }\n}"
    },
    {
      "filename": "src/lib/token/ERC721Votes.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { IERC721Votes } from \"../interfaces/IERC721Votes.sol\";\nimport { ERC721 } from \"../token/ERC721.sol\";\nimport { EIP712 } from \"../utils/EIP712.sol\";\n\n/// @title ERC721Votes\n/// @author Rohan Kulkarni\n/// @notice Modified from OpenZeppelin Contracts v4.7.3 (token/ERC721/extensions/draft-ERC721Votes.sol) & Nouns DAO ERC721Checkpointable.sol commit 2cbe6c7 - licensed under the BSD-3-Clause license.\n/// - Uses custom errors defined in IERC721Votes\n/// - Checkpoints are based on timestamps instead of block numbers\n/// - Tokens are self-delegated by default\n/// - The total number of votes is the token supply itself\nabstract contract ERC721Votes is IERC721Votes, EIP712, ERC721 {\n    ///                                                          ///\n    ///                          CONSTANTS                       ///\n    ///                                                          ///\n\n    /// @dev The EIP-712 typehash to delegate with a signature\n    bytes32 internal constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address from,address to,uint256 nonce,uint256 deadline)\");\n\n    ///                                                          ///\n    ///                           STORAGE                        ///\n    ///                                                          ///\n\n    /// @notice The delegate for an account\n    /// @notice Account => Delegate\n    mapping(address => address) internal delegation;\n\n    /// @notice The number of checkpoints for an account\n    /// @dev Account => Num Checkpoints\n    mapping(address => uint256) internal numCheckpoints;\n\n    /// @notice The checkpoint for an account\n    /// @dev Account => Checkpoint Id => Checkpoint\n    mapping(address => mapping(uint256 => Checkpoint)) internal checkpoints;\n\n    ///                                                          ///\n    ///                        VOTING WEIGHT                     ///\n    ///                                                          ///\n\n    /// @notice The current number of votes for an account\n    /// @param _account The account address\n    function getVotes(address _account) public view returns (uint256) {\n        // Get the account's number of checkpoints\n        uint256 nCheckpoints = numCheckpoints[_account];\n\n        // Cannot underflow as `nCheckpoints` is ensured to be greater than 0 if reached\n        unchecked {\n            // Return the number of votes at the latest checkpoint if applicable\n            return nCheckpoints != 0 ? checkpoints[_account][nCheckpoints - 1].votes : 0;\n        }\n    }\n\n    /// @notice The number of votes for an account at a past timestamp\n    /// @param _account The account address\n    /// @param _timestamp The past timestamp\n    function getPastVotes(address _account, uint256 _timestamp) public view returns (uint256) {\n        // Ensure the given timestamp is in the past\n        if (_timestamp >= block.timestamp) revert INVALID_TIMESTAMP();\n\n        // Get the account's number of checkpoints\n        uint256 nCheckpoints = numCheckpoints[_account];\n\n        // If there are none return 0\n        if (nCheckpoints == 0) return 0;\n\n        // Get the account's checkpoints\n        mapping(uint256 => Checkpoint) storage accountCheckpoints = checkpoints[_account];\n\n        unchecked {\n            // Get the latest checkpoint id\n            // Cannot underflow as `nCheckpoints` is ensured to be greater than 0\n            uint256 lastCheckpoint = nCheckpoints - 1;\n\n            // If the latest checkpoint has a valid timestamp, return its number of votes\n            if (accountCheckpoints[lastCheckpoint].timestamp <= _timestamp) return accountCheckpoints[lastCheckpoint].votes;\n\n            // If the first checkpoint doesn't have a valid timestamp, return 0\n            if (accountCheckpoints[0].timestamp > _timestamp) return 0;\n\n            // Otherwise, find a checkpoint with a valid timestamp\n            // Use the latest id as the initial upper bound\n            uint256 high = lastCheckpoint;\n            uint256 low;\n            uint256 middle;\n\n            // Used to temporarily hold a checkpoint\n            Checkpoint memory cp;\n\n            // While a valid checkpoint is to be found:\n            while (high > low) {\n                // Find the id of the middle checkpoint\n                middle = high - (high - low) / 2;\n\n                // Get the middle checkpoint\n                cp = accountCheckpoints[middle];\n\n                // If the timestamp is a match:\n                if (cp.timestamp == _timestamp) {\n                    // Return the voting weight\n                    return cp.votes;\n\n                    // Else if the timestamp is before the one looking for:\n                } else if (cp.timestamp < _timestamp) {\n                    // Update the lower bound\n                    low = middle;\n\n                    // Else update the upper bound\n                } else {\n                    high = middle - 1;\n                }\n            }\n\n            return accountCheckpoints[low].votes;\n        }\n    }\n\n    ///                                                          ///\n    ///                          DELEGATION                      ///\n    ///                                                          ///\n\n    /// @notice The delegate for an account\n    /// @param _account The account address\n    function delegates(address _account) external view returns (address) {\n        address current = delegation[_account];\n        return current == address(0) ? _account : current;\n    }\n\n    /// @notice Delegates votes to an account\n    /// @param _to The address delegating votes to\n    function delegate(address _to) external {\n        _delegate(msg.sender, _to);\n    }\n\n    /// @notice Delegates votes from a signer to an account\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    /// @param _deadline The signature deadline\n    /// @param _v The 129th byte and chain id of the signature\n    /// @param _r The first 64 bytes of the signature\n    /// @param _s Bytes 64-128 of the signature\n    function delegateBySig(\n        address _from,\n        address _to,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        // Ensure the signature has not expired\n        if (block.timestamp > _deadline) revert EXPIRED_SIGNATURE();\n\n        // Used to store the digest\n        bytes32 digest;\n\n        // Cannot realistically overflow\n        unchecked {\n            // Compute the hash of the domain seperator with the typed delegation data\n            digest = keccak256(\n                abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR(), keccak256(abi.encode(DELEGATION_TYPEHASH, _from, _to, nonces[_from]++, _deadline)))\n            );\n        }\n\n        // Recover the message signer\n        address recoveredAddress = ecrecover(digest, _v, _r, _s);\n\n        // Ensure the recovered signer is the voter\n        if (recoveredAddress == address(0) || recoveredAddress != _from) revert INVALID_SIGNATURE();\n\n        // Update the delegate\n        _delegate(_from, _to);\n    }\n\n    /// @dev Updates delegate addresses\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    function _delegate(address _from, address _to) internal {\n        // Get the previous delegate\n        address prevDelegate = delegation[_from];\n\n        // Store the new delegate\n        delegation[_from] = _to;\n\n        emit DelegateChanged(_from, prevDelegate, _to);\n\n        // Transfer voting weight from the previous delegate to the new delegate\n        _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));\n    }\n\n    /// @dev Transfers voting weight\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    /// @param _amount The number of votes delegating\n    function _moveDelegateVotes(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        unchecked {\n            // If voting weight is being transferred:\n            if (_from != _to && _amount > 0) {\n                // If this isn't a token mint:\n                if (_from != address(0)) {\n                    // Get the sender's number of checkpoints\n                    uint256 nCheckpoints = numCheckpoints[_from]++;\n\n                    // Used to store the sender's previous voting weight\n                    uint256 prevTotalVotes;\n\n                    // If this isn't the sender's first checkpoint: Get their previous voting weight\n                    if (nCheckpoints != 0) prevTotalVotes = checkpoints[_from][nCheckpoints - 1].votes;\n\n                    // Update their voting weight\n                    _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes - _amount);\n                }\n\n                // If this isn't a token burn:\n                if (_to != address(0)) {\n                    // Get the recipients's number of checkpoints\n                    uint256 nCheckpoints = numCheckpoints[_to]++;\n\n                    // Used to store the recipient's previous voting weight\n                    uint256 prevTotalVotes;\n\n                    // If this isn't the recipient's first checkpoint: Get their previous voting weight\n                    if (nCheckpoints != 0) prevTotalVotes = checkpoints[_to][nCheckpoints - 1].votes;\n\n                    // Update their voting weight\n                    _writeCheckpoint(_to, nCheckpoints, prevTotalVotes, prevTotalVotes + _amount);\n                }\n            }\n        }\n    }\n\n    /// @dev Records a checkpoint\n    /// @param _account The account address\n    /// @param _id The checkpoint id\n    /// @param _prevTotalVotes The account's previous voting weight\n    /// @param _newTotalVotes The account's new voting weight\n    function _writeCheckpoint(\n        address _account,\n        uint256 _id,\n        uint256 _prevTotalVotes,\n        uint256 _newTotalVotes\n    ) private {\n        // Get the pointer to store the checkpoint\n        Checkpoint storage checkpoint = checkpoints[_account][_id];\n\n        // Record the updated voting weight and current time\n        checkpoint.votes = uint192(_newTotalVotes);\n        checkpoint.timestamp = uint64(block.timestamp);\n\n        emit DelegateVotesChanged(_account, _prevTotalVotes, _newTotalVotes);\n    }\n\n    /// @dev Enables each NFT to equal 1 vote\n    /// @param _from The token sender\n    /// @param _to The token recipient\n    /// @param _tokenId The ERC-721 token id\n    function _afterTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal override {\n        // Transfer 1 vote from the sender to the recipient\n        _moveDelegateVotes(_from, _to, 1);\n\n        super._afterTokenTransfer(_from, _to, _tokenId);\n    }\n}"
    },
    {
      "filename": "src/lib/token/ERC721Votes.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { IERC721Votes } from \"../interfaces/IERC721Votes.sol\";\nimport { ERC721 } from \"../token/ERC721.sol\";\nimport { EIP712 } from \"../utils/EIP712.sol\";\n\n/// @title ERC721Votes\n/// @author Rohan Kulkarni\n/// @notice Modified from OpenZeppelin Contracts v4.7.3 (token/ERC721/extensions/draft-ERC721Votes.sol) & Nouns DAO ERC721Checkpointable.sol commit 2cbe6c7 - licensed under the BSD-3-Clause license.\n/// - Uses custom errors defined in IERC721Votes\n/// - Checkpoints are based on timestamps instead of block numbers\n/// - Tokens are self-delegated by default\n/// - The total number of votes is the token supply itself\nabstract contract ERC721Votes is IERC721Votes, EIP712, ERC721 {\n    ///                                                          ///\n    ///                          CONSTANTS                       ///\n    ///                                                          ///\n\n    /// @dev The EIP-712 typehash to delegate with a signature\n    bytes32 internal constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address from,address to,uint256 nonce,uint256 deadline)\");\n\n    ///                                                          ///\n    ///                           STORAGE                        ///\n    ///                                                          ///\n\n    /// @notice The delegate for an account\n    /// @notice Account => Delegate\n    mapping(address => address) internal delegation;\n\n    /// @notice The number of checkpoints for an account\n    /// @dev Account => Num Checkpoints\n    mapping(address => uint256) internal numCheckpoints;\n\n    /// @notice The checkpoint for an account\n    /// @dev Account => Checkpoint Id => Checkpoint\n    mapping(address => mapping(uint256 => Checkpoint)) internal checkpoints;\n\n    ///                                                          ///\n    ///                        VOTING WEIGHT                     ///\n    ///                                                          ///\n\n    /// @notice The current number of votes for an account\n    /// @param _account The account address\n    function getVotes(address _account) public view returns (uint256) {\n        // Get the account's number of checkpoints\n        uint256 nCheckpoints = numCheckpoints[_account];\n\n        // Cannot underflow as `nCheckpoints` is ensured to be greater than 0 if reached\n        unchecked {\n            // Return the number of votes at the latest checkpoint if applicable\n            return nCheckpoints != 0 ? checkpoints[_account][nCheckpoints - 1].votes : 0;\n        }\n    }\n\n    /// @notice The number of votes for an account at a past timestamp\n    /// @param _account The account address\n    /// @param _timestamp The past timestamp\n    function getPastVotes(address _account, uint256 _timestamp) public view returns (uint256) {\n        // Ensure the given timestamp is in the past\n        if (_timestamp >= block.timestamp) revert INVALID_TIMESTAMP();\n\n        // Get the account's number of checkpoints\n        uint256 nCheckpoints = numCheckpoints[_account];\n\n        // If there are none return 0\n        if (nCheckpoints == 0) return 0;\n\n        // Get the account's checkpoints\n        mapping(uint256 => Checkpoint) storage accountCheckpoints = checkpoints[_account];\n\n        unchecked {\n            // Get the latest checkpoint id\n            // Cannot underflow as `nCheckpoints` is ensured to be greater than 0\n            uint256 lastCheckpoint = nCheckpoints - 1;\n\n            // If the latest checkpoint has a valid timestamp, return its number of votes\n            if (accountCheckpoints[lastCheckpoint].timestamp <= _timestamp) return accountCheckpoints[lastCheckpoint].votes;\n\n            // If the first checkpoint doesn't have a valid timestamp, return 0\n            if (accountCheckpoints[0].timestamp > _timestamp) return 0;\n\n            // Otherwise, find a checkpoint with a valid timestamp\n            // Use the latest id as the initial upper bound\n            uint256 high = lastCheckpoint;\n            uint256 low;\n            uint256 middle;\n\n            // Used to temporarily hold a checkpoint\n            Checkpoint memory cp;\n\n            // While a valid checkpoint is to be found:\n            while (high > low) {\n                // Find the id of the middle checkpoint\n                middle = high - (high - low) / 2;\n\n                // Get the middle checkpoint\n                cp = accountCheckpoints[middle];\n\n                // If the timestamp is a match:\n                if (cp.timestamp == _timestamp) {\n                    // Return the voting weight\n                    return cp.votes;\n\n                    // Else if the timestamp is before the one looking for:\n                } else if (cp.timestamp < _timestamp) {\n                    // Update the lower bound\n                    low = middle;\n\n                    // Else update the upper bound\n                } else {\n                    high = middle - 1;\n                }\n            }\n\n            return accountCheckpoints[low].votes;\n        }\n    }\n\n    ///                                                          ///\n    ///                          DELEGATION                      ///\n    ///                                                          ///\n\n    /// @notice The delegate for an account\n    /// @param _account The account address\n    function delegates(address _account) external view returns (address) {\n        address current = delegation[_account];\n        return current == address(0) ? _account : current;\n    }\n\n    /// @notice Delegates votes to an account\n    /// @param _to The address delegating votes to\n    function delegate(address _to) external {\n        _delegate(msg.sender, _to);\n    }\n\n    /// @notice Delegates votes from a signer to an account\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    /// @param _deadline The signature deadline\n    /// @param _v The 129th byte and chain id of the signature\n    /// @param _r The first 64 bytes of the signature\n    /// @param _s Bytes 64-128 of the signature\n    function delegateBySig(\n        address _from,\n        address _to,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        // Ensure the signature has not expired\n        if (block.timestamp > _deadline) revert EXPIRED_SIGNATURE();\n\n        // Used to store the digest\n        bytes32 digest;\n\n        // Cannot realistically overflow\n        unchecked {\n            // Compute the hash of the domain seperator with the typed delegation data\n            digest = keccak256(\n                abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR(), keccak256(abi.encode(DELEGATION_TYPEHASH, _from, _to, nonces[_from]++, _deadline)))\n            );\n        }\n\n        // Recover the message signer\n        address recoveredAddress = ecrecover(digest, _v, _r, _s);\n\n        // Ensure the recovered signer is the voter\n        if (recoveredAddress == address(0) || recoveredAddress != _from) revert INVALID_SIGNATURE();\n\n        // Update the delegate\n        _delegate(_from, _to);\n    }\n\n    /// @dev Updates delegate addresses\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    function _delegate(address _from, address _to) internal {\n        // Get the previous delegate\n        address prevDelegate = delegation[_from];\n\n        // Store the new delegate\n        delegation[_from] = _to;\n\n        emit DelegateChanged(_from, prevDelegate, _to);\n\n        // Transfer voting weight from the previous delegate to the new delegate\n        _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));\n    }\n\n    /// @dev Transfers voting weight\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    /// @param _amount The number of votes delegating\n    function _moveDelegateVotes(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        unchecked {\n            // If voting weight is being transferred:\n            if (_from != _to && _amount > 0) {\n                // If this isn't a token mint:\n                if (_from != address(0)) {\n                    // Get the sender's number of checkpoints\n                    uint256 nCheckpoints = numCheckpoints[_from]++;\n\n                    // Used to store the sender's previous voting weight\n                    uint256 prevTotalVotes;\n\n                    // If this isn't the sender's first checkpoint: Get their previous voting weight\n                    if (nCheckpoints != 0) prevTotalVotes = checkpoints[_from][nCheckpoints - 1].votes;\n\n                    // Update their voting weight\n                    _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes - _amount);\n                }\n\n                // If this isn't a token burn:\n                if (_to != address(0)) {\n                    // Get the recipients's number of checkpoints\n                    uint256 nCheckpoints = numCheckpoints[_to]++;\n\n                    // Used to store the recipient's previous voting weight\n                    uint256 prevTotalVotes;\n\n                    // If this isn't the recipient's first checkpoint: Get their previous voting weight\n                    if (nCheckpoints != 0) prevTotalVotes = checkpoints[_to][nCheckpoints - 1].votes;\n\n                    // Update their voting weight\n                    _writeCheckpoint(_to, nCheckpoints, prevTotalVotes, prevTotalVotes + _amount);\n                }\n            }\n        }\n    }\n\n    /// @dev Records a checkpoint\n    /// @param _account The account address\n    /// @param _id The checkpoint id\n    /// @param _prevTotalVotes The account's previous voting weight\n    /// @param _newTotalVotes The account's new voting weight\n    function _writeCheckpoint(\n        address _account,\n        uint256 _id,\n        uint256 _prevTotalVotes,\n        uint256 _newTotalVotes\n    ) private {\n        // Get the pointer to store the checkpoint\n        Checkpoint storage checkpoint = checkpoints[_account][_id];\n\n        // Record the updated voting weight and current time\n        checkpoint.votes = uint192(_newTotalVotes);\n        checkpoint.timestamp = uint64(block.timestamp);\n\n        emit DelegateVotesChanged(_account, _prevTotalVotes, _newTotalVotes);\n    }\n\n    /// @dev Enables each NFT to equal 1 vote\n    /// @param _from The token sender\n    /// @param _to The token recipient\n    /// @param _tokenId The ERC-721 token id\n    function _afterTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal override {\n        // Transfer 1 vote from the sender to the recipient\n        _moveDelegateVotes(_from, _to, 1);\n\n        super."
    }
  ]
}