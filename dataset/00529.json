{
  "Title": "M-2: A borrower eligible for liquidation can pay an improperly large amount of fees, and may be unfairly liquidated",
  "Content": "# Issue M-2: A borrower eligible for liquidation can pay an improperly large amount of fees, and may be unfairly liquidated \n\nSource: https://github.com/sherlock-audit/2024-02-leverage-contracts-judging/issues/40 \n\n## Found by \n0xDetermination\n## Summary\nIf a borrower is partially liquidated and then increases the collateral balance to avoid further liquidation, they will pay an improperly large amount of fees and can be unfairly liquidated.\n## Vulnerability Detail\nThe root cause is that partial emergency liquidation doesn't update `accLoanRatePerSeconds` (https://github.com/sherlock-audit/2024-02-leverage-contracts/blob/main/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L660-L666).\n\nIf a borrower is partially liquidated, fees will be increased by the entire collateral amount (https://github.com/sherlock-audit/2024-02-leverage-contracts/blob/main/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L604-L633):\n```solidity\n            (collateralBalance, currentFees) = _calculateCollateralBalance(\n                borrowing.borrowedAmount,\n                borrowing.accLoanRatePerSeconds,\n                borrowing.dailyRateCollateralBalance,\n                accLoanRatePerSeconds\n            );\n            ...\n            if (collateralBalance > 0) {\n                ...\n            } else {\n                currentFees = borrowing.dailyRateCollateralBalance; //entire collateral amount\n            }\n            ...\n            borrowing.feesOwed += _pickUpPlatformFees(borrowing.holdToken, currentFees);\n```\nWhen liquidation occurs right after becoming liquidatable, the `collateralBalance` calculation in `repay()` above will be a small value like `-1`; and essentially all the fees owed will be collected.\n\nIf the borrower notices the partial liquidation and wishes to avoid further liquidation, `increaseCollateralBalance()` can be called to become solvent again. But since the `accLoanRatePerSeconds` wasn't updated, the borrower will have to doubly pay all the fees that were just collected. This will happen if a lender calls `harvest()` or the loan is liquidated again. The loan can also be liquidated unfairly, because the `collateralBalance` calculated above will be much lower than it should be.\n## Impact\nThe borrower may pay too many fees, and it's also possible to unfairly liquidate the position.\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-02-leverage-contracts/blob/main/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L660-L666\nhttps://github.com/sherlock-audit/2024-02-leverage-contracts/blob/main/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L604-L633\n## Tool used\n\nManual Review\n\n## Recommendation\nUpdate `accLoanRatePerSeconds` for incomplete emergency liquidations.\n\n\n\n## Discussion\n\n**fann95**\n\naccLoanRatePerSeconds should not be updated since borrowedAmount are reduced, accordingly, a position debt also redused\nThis issue was already discussed in the previous audit.\nHarvest cannot be called on a position that is under liquidation\n\n**nevillehuang**\n\nInvalid, agree with sponsors comments. This was previously discussed [here](https://github.com/sherlock-audit/2023-10-real-wagmi-judging/issues/119#issuecomment-1793233316)\n\n**0xDetermination**\n\nHi @nevillehuang @fann95 , posting commented PoC with console.logs below (modified test).\n\nThe flow is like so:\n1. Borrower's position is emergency liquidated by one lender\n2. Borrower doesn't want to get liquidated more so `increaseCollateralBalance()` is called\n3. Borrower will pay too many fees since `dailyRateCollateralBalance` was set to zero and `accLoanRatePerSeconds` wasn't updated\n\n```\n    it(\"emergency repay will be successful for PosManNFT owner if the collateral is depleted\", async () => {\n        let debt: ILiquidityBorrowingManager.BorrowingInfoExtStructOutput[] =\n            await borrowingManager.getBorrowerDebtsInfo(bob.address);\n        console.log('collateralBalance', debt[0].collateralBalance);\n        console.log('current collateral amount', debt[0].info.dailyRateCollateralBalance);\n        console.log('estimated life time', debt[0].estimatedLifeTime);\n        await time.increase(debt[0].estimatedLifeTime.toNumber() + 1);\n\n        debt = await borrowingManager.getBorrowerDebtsInfo(bob.address);\n        console.log('collateralBalance after advancing time', debt[0].collateralBalance);\n\n        let borrowingKey = (await borrowingManager.getBorrowingKeysForBorrower(bob.address))[0];\n        let deadline = (await time.latest()) + 60;\n\n        let params: ILiquidityBorrowingManager.RepayParamsStruct = {\n            returnOnlyHoldToken: true,\n            isEmergency: true, //emergency\n            internalSwapPoolfee: 0,\n            externalSwap: [],\n            borrowingKey: borrowingKey,\n            minHoldTokenOut: BigNumber.from(0),\n            minSaleTokenOut: BigNumber.from(0)\n        };\n\n        await expect(borrowingManager.connect(alice).repay(params, deadline))\n            .to.emit(borrowingManager, \"EmergencyLoanClosure\")\n            .withArgs(bob.address, alice.address, borrowingKey);\n\n        debt = await borrowingManager.getBorrowerDebtsInfo(bob.address);\n        \n        console.log('collateralBalance after first liquidation (this is wrong, should be close to zero)', debt[0].collateralBalance); //this amount is wrong, way too large due to the borrower's collateral set to zero and accLoanRatePerSeconds not updated. We can see that the amount actually increased instead of decreasing as it should\n        \n        //borrower increases collateral by a large amount such that liquidation shouldn't be possible anymore, 18000000000000000000000 (this is currently scaled by collateral precision, 1e18)\n        //This amount is about 75% of the orignal collateral amount of 24948000000000000000000\n        await borrowingManager.connect(bob).increaseCollateralBalance(borrowingKey, 18000n, deadline); //adjust amount for collateral balance precision\n        //below should revert since collateral balance was increased by a large amount, but the borrower gets liquidated\n        await expect(borrowingManager.connect(bob).repay(params, deadline))\n            .to.emit(borrowingManager, \"EmergencyLoanClosure\")\n            .withArgs(bob.address, bob.address, borrowingKey);\n        \n        await expect(borrowingManager.connect(owner).repay(params, deadline))\n            .to.emit(borrowingManager, \"EmergencyLoanClosure\")\n            .withArgs(bob.address, owner.address, borrowingKey);\n    });\n```\n\n**fann95**\n\nI see in the tests that the amount of debt has decreased by part of the closed Lp-share, but the rest of the debt has been maintained, as expected.\ncollateralBalance after advancing time BigNumber { value: \"-363497523148146947\" }\ncollateralBalance after first liquidation (this is wrong, should be close to zero) BigNumber { value: \"-263884816316264683\" }\ndebt(263884816316264683) < debt(363497523148146947)\n\n**0xDetermination**\n\n@fann95 That's weird, when I run in the contest repo the output is:\ncollateralBalance BigNumber { value: \"6236502752476851853053\" }\ncurrent collateral amount BigNumber { value: \"24948000000000000000000\" }\nestimated life time BigNumber { value: \"21598\" }\ncollateralBalance after advancing time BigNumber { value: \"-181748761574072227\" }\ncollateralBalance after first liquidation (this is wrong, should be close to zero) BigNumber { value: \"-18111392620173611109770\" }\n\nAlso, not sure if the test is passing on your end, but if it's passing I think the bug is there since the collateral is increased and emergency liq shouldn't happen\n\n**fann95**\n\nIt looks like this is a valid issue..I got different results since I ran your test in the updated version. The PR which corrected the problems with the distribution of commissions also corrected this problem.\n\n**sherlock-admin**\n\nThe protocol team fixed this issue in PR/commit https://github.com/RealWagmi/wagmi-leverage/commit/84416fcedfcc7eb062917bdc69f919bba9d3c0b7.\n\n**nevillehuang**\n\n@fann95 Is the root cause stemming from similar issues in #41 or only possible because of another issue, given fix PR is the same?\n\n**0xDetermination**\n\n@fann95 @nevillehuang Fix [code](https://github.com/RealWagmi/wagmi-leverage/commit/84416fcedfcc7eb062917bdc69f919bba9d3c0b7#diff-19eb89909078be53347656861a11ad5cc119624558cf955fc423c728d80821bdL663-R604) looks good to me, PoC doesn't pass in the main repo. \n\nIn case my input is helpful- I think this issue is different than #41 since that issue describes a root cause/fix in `borrow()`, whereas the cause/fix for this issue is around not setting `dailyRateCollateralBalance` to zero in `repay()`. Additionally the PR is quite large and changes a lot of things.\n\n**nevillehuang**\n\n@fann95 @0xDetermination I am trying to figure out how the original fix could have fixed this issue without first considering it, which leads me to believe they share the same root causes revolving around distribution of fees. I would have to take a closer look at the fix PR.\n\n**fann95**\n\n> @fann95 @0xDetermination I am trying to figure out how the original fix could have fixed this issue without first considering it, which leads me to believe they share the same root causes revolving around distribution of fees. I would have to take a closer look at the fix PR.\n\nThis problem is indirectly related to the distribution of commissions. I got rid of the mechanism for accumulating a fee, therefore the current error was fixed.\n\n**nevillehuang**\n\n@Czar102 @0xDetermination What are your thoughts here based on duplication [rules here](https://docs.sherlock.xyz/audits/judging/judging#ix.-duplication-rules)? The core vulnerability seem to stem from erroneous distribution of fees which allowed for this issue to be possible in the first place. I am inclined to think this should be duplicated with #41\n\n> There is a root cause/error/vulnerability A in the code. This vulnerability A -> leads to two attack paths:\n> - B -> high severity path\n> - C -> medium severity attack path/just identifying the vulnerability.\n> Both B & C would not have been possible if error A did not exist in the first place. In this case, both B & C should be put together as duplicates.\n\n**0xDetermination**\n\n@nevillehuang @Czar102 The root cause and fix for this issue are both distinct from #41- the erroneous distribution of fees in #41 is caused by not harvesting fees when a new loan is taken with the `borrow()` function, and the fix is the new internal `_harvest()` function that runs in `borrow()`. ([link](https://github.com/RealWagmi/wagmi-leverage/commit/84416fcedfcc7eb062917bdc69f919bba9d3c0b7#diff-19eb89909078be53347656861a11ad5cc119624558cf955fc423c728d80821bdR976))\n\nThis issue #40 is caused by the fee distribution mechanism in emergency liquidation mode in `repay()`, which is separate from `borrow()` and `harvest()`. The root cause and fix can both be seen [here](https://github.com/RealWagmi/wagmi-leverage/commit/84416fcedfcc7eb062917bdc69f919bba9d3c0b7#diff-19eb89909078be53347656861a11ad5cc119624558cf955fc423c728d80821bdL663-R604) in `repay()`. The fix for #41 won't fix this issue.\n\n**nevillehuang**\n\nSince #39 and #41 talks about different types of fees, I agree they are not duplicates and they are both high severity findings. Given this erroneous fee calculation affects a large portion of the protocol, I agree with sponsor comments [here](https://github.com/sherlock-audit/2024-02-leverage-contracts-judging/issues/41#issuecomment-1970143929) and believe high severity is appropriate.\n\nHowever, I believe that #40 is a medium severity issue only possible because of the root cause of wrong computation of fees for borrowed positions within #41. This is evident from the fix employed without considering this issue in the first place. Hence, I am going to duplicate it with #41 and assign it as high severity based on sherlock rules despite it having only a medium severity impact. \n\n**0xDetermination**\n\nEscalate\n\nI understand @nevillehuang's point here, but I still think this shouldn't be a dup for the reasons I gave in my above [comment](https://github.com/sherlock-audit/2024-02-leverage-contracts-judging/issues/40#issuecomment-1976611101). The fix PR changed a lot of things unrelated to validated issues, such as removal of the min fee [mechanism](https://github.com/RealWagmi/wagmi-leverage/commit/84416fcedfcc7eb062917bdc69f919bba9d3c0b7#diff-19eb89909078be53347656861a11ad5cc119624558cf955fc423c728d80821bdL618-L624).\n\nWill appreciate @Czar102's decision.\n\nAdditionally, if validated as not a dup, not sure if this should be H or M based on the 'external conditions' criteria.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> I understand @nevillehuang's point here, but I still think this shouldn't be a dup for the reasons I gave in my above [comment](https://github.com/sherlock-audit/2024-02-leverage-contracts-judging/issues/40#issuecomment-1976611101). The fix PR changed a lot of things unrelated to validated issues, such as removal of the min fee [mechanism](https://github.com/RealWagmi/wagmi-leverage/commit/84416fcedfcc7eb062917bdc69f919bba9d3c0b7#diff-19eb89909078be53347656861a11ad5cc119624558cf955fc423c728d80821bdL618-L624).\n> \n> Will appreciate @Czar102's decision.\n> \n> Additionally, if validated as not a dup, not sure if this should be H or M based on the 'external conditions' criteria.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Czar102**\n\n@nevillehuang can you elaborate on how does a fix to #40 follows from #41?\n\n**nevillehuang**\n\n@Czar102 I believe @fann95 answered it [here](https://github.com/sherlock-audit/2024-02-leverage-contracts-judging/issues/40#issuecomment-1976134206) and [here](https://github.com/sherlock-audit/2024-02-leverage-contracts-judging/issues/40#issuecomment-1974030831)\n\nBased on sponsor description and comments above, The PR fix was performed without consideration of this issue, which led me to believe this issue only stems from the root cause of incorrect distribution.\n\n**Czar102**\n\n@nevillehuang what is the single logical error (maybe an assumption, maybe approach) that led to both of these issues?\n\nHaving issue A which makes the sponsor want to restructure code and it accidentally removing issue B doesn't make them duplicates.\n\n**fann95**\n\nI propose to confirm this issue and not consider it a duplicate.\n\n**nevillehuang**\n\n@Czar102 It stems from the logic for fee distribution. Although I disagree, seems like sponsor agrees to deduplicate so we can proceed with deduplication.\n\n**Czar102**\n\n@nevillehuang regarding this:\n> It stems from the logic for fee distribution.\n\nI believe it doesn't answer my question:\n> what is the single logical error (maybe an assumption, maybe approach) that led to both of these issues?\n\nI wanted to have a one-sentence description of the common ground of these issues, and the fact that the issues \"stem from the logic for fee distribution\" (are in the same part of the code logic) doesn't make them duplicates.\n\nI'm planning to make this issue a unique issue, unless a justification (as mentioned above) is provided.\n\nWhat are the considerations regarding the severity? @nevillehuang\n@0xDetermination what did you mean by the following fragment of your escalation?\n> not sure if this should be H or M based on the 'external conditions' criteria\n\n**0xDetermination**\n\n@Czar102 I'm not 100% sure whether this is better suited for H or M, as I don't have a ton of experience with Sherlock judging rules. Basically, the issue can cause serious loss of funds (borrower's entire collateral), but it is conditional on a partial emergency liquidation followed by the borrower increasing collateral. It looks more like M to me but I don't want to speak too soon, will leave it up to you and @nevillehuang. Happy to provide more info if needed.\n\n**nevillehuang**\n\nYup @Czar102 I agree with your decision, I cannot pinpoint an exact singular approach/code logic given this is an update contest and would take up too much time. The reason I duplicated them was on the side of caution, given the sponsor quite literally fix this issue without even considering it. But since sponsor also agree with deduplication, lets move ahead\n\n**Czar102**\n\nIn that case, planning to make this issue a unique Medium severity one.\n\n**Czar102**\n\nResult:\nMedium\nUnique\n\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0xDetermination](https://github.com/sherlock-audit/2024-02-leverage-contracts-judging/issues/40/#issuecomment-1986871881): accepted\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/234",
  "Code": [
    {
      "filename": "wagmi-leverage/contracts/LiquidityBorrowingManager.sol",
      "content": "// SPDX-License-Identifier: SAL-1.0\n\n/**\n * WAGMI Leverage Protocol v1.2\n * wagmi.com\n */\n\npragma solidity 0.8.21;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./abstract/LiquidityManager.sol\";\nimport \"./abstract/OwnerSettings.sol\";\nimport \"./abstract/DailyRateAndCollateral.sol\";\nimport \"./libraries/ErrLib.sol\";\nimport \"./interfaces/ILiquidityBorrowingManager.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n/**\n * @title LiquidityBorrowingManager\n * @dev This contract manages the borrowing liquidity functionality for WAGMI Leverage protocol.\n * It inherits from LiquidityManager, OwnerSettings, DailyRateAndCollateral, and ReentrancyGuard contracts.\n */\ncontract LiquidityBorrowingManager is\n    ILiquidityBorrowingManager,\n    LiquidityManager,\n    OwnerSettings,\n    DailyRateAndCollateral,\n    ReentrancyGuard\n{\n    using { ErrLib.revertError } for bool;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    /// borrowingKey=>LoanInfo\n    mapping(bytes32 => LoanInfo[]) private loansInfo;\n    /// borrowingKey=>BorrowingInfo\n    mapping(bytes32 => BorrowingInfo) public borrowingsInfo;\n    /// NonfungiblePositionManager tokenId => EnumerableSet.Bytes32Set\n    mapping(uint256 => EnumerableSet.Bytes32Set) private tokenIdToBorrowingKeys;\n    /// borrower => EnumerableSet.Bytes32Set\n    mapping(address => EnumerableSet.Bytes32Set) private userBorrowingKeys;\n    ///  token => FeesAmt\n    mapping(address => uint256) private platformsFeesInfo;\n\n    /// @dev Modifier to check if the current block timestamp is before or equal to the deadline.\n    modifier checkDeadline(uint256 deadline) {\n        (_blockTimestamp() > deadline).revertError(ErrLib.ErrorCode.TOO_OLD_TRANSACTION);\n        _;\n    }\n\n    modifier onlyOperator() {\n        (msg.sender != operator).revertError(ErrLib.ErrorCode.INVALID_CALLER);\n        _;\n    }\n\n    function _blockTimestamp() internal view returns (uint256) {\n        return block.timestamp;\n    }\n\n    constructor(\n        address _underlyingPositionManagerAddress,\n        address _lightQuoterV3,\n        address _underlyingV3Factory,\n        bytes32 _underlyingV3PoolInitCodeHash\n    )\n        LiquidityManager(\n            _underlyingPositionManagerAddress,\n            _lightQuoterV3,\n            _underlyingV3Factory,\n            _underlyingV3PoolInitCodeHash\n        )\n    {}\n\n    /**\n     * @dev Adds or removes a swap call params to the whitelist.\n     * @param swapTarget The address of the target contract for the swap call.\n     * @param funcSelector The function selector of the swap call.\n     * @param isAllowed A boolean indicating whether the swap call is allowed or not.\n     */\n    function setSwapCallToWhitelist(\n        address swapTarget,\n        bytes4 funcSelector,\n        bool isAllowed\n    ) external onlyOwner {\n        (swapTarget == VAULT_ADDRESS ||\n            swapTarget == address(this) ||\n            swapTarget == address(underlyingPositionManager) ||\n            funcSelector == IERC20.transferFrom.selector).revertError(ErrLib.ErrorCode.FORBIDDEN);\n        whitelistedCall[swapTarget][funcSelector] = isAllowed;\n    }\n\n    /**\n     * @notice This function allows the owner to collect protocol fees for multiple tokens\n     * and transfer them to a specified recipient.\n     * @dev Only the contract owner can call this function.\n     * @param recipient The address of the recipient who will receive the collected fees.\n     * @param tokens An array of addresses representing the tokens for which fees will be collected.\n     */\n    function collectProtocol(address recipient, address[] calldata tokens) external onlyOwner {\n        uint256[] memory amounts = _collect(platformsFeesInfo, recipient, tokens);\n\n        emit CollectProtocol(recipient, tokens, amounts);\n    }\n\n    /**\n     * @notice This function allows the caller to collect their own loan fees for multiple tokens\n     * and transfer them to themselves.\n     * @param tokens An array of addresses representing the tokens for which fees will be collected.\n     */\n    function collectLoansFees(address[] calldata tokens) external {\n        mapping(address => uint256) storage collection = loansFeesInfo[msg.sender];\n        uint256[] memory amounts = _collect(collection, msg.sender, tokens);\n\n        emit CollectLoansFees(msg.sender, tokens, amounts);\n    }\n\n    /**\n     * @notice This function is used to update the daily rate for holding token for specific pair.\n     * @dev Only the daily rate operator can call this function.\n     * @param saleToken The address of the sale token.\n     * @param holdToken The address of the hold token.\n     * @param value The new value of the daily rate for the hold token will be calculated based\n     * on the volatility of the pair and the popularity of loans in it\n     * @dev The value must be within the range of MIN_DAILY_RATE and MAX_DAILY_RATE.\n     */\n    function updateHoldTokenDailyRate(\n        address saleToken,\n        address holdToken,\n        uint256 value\n    ) external onlyOperator {\n        if (value > Constants.MAX_DAILY_RATE || value < Constants.MIN_DAILY_RATE) {\n            revert InvalidSettingsValue(value);\n        }\n        // If the value is within the acceptable range, the function updates the currentDailyRate property\n        // of the holdTokenRateInfo structure associated with the token pair.\n        (, TokenInfo storage holdTokenRateInfo) = _updateHoldTokenRateInfo(saleToken, holdToken);\n        holdTokenRateInfo.currentDailyRate = value;\n        emit UpdateHoldTokenDailyRate(saleToken, holdToken, value);\n    }\n\n    function updateHoldTokenEntranceFee(\n        address saleToken,\n        address holdToken,\n        uint256 value\n    ) external onlyOperator {\n        if (value > Constants.MAX_ENTRANCE_FEE_BPS) {\n            revert InvalidSettingsValue(value);\n        }\n        // If the value is within the acceptable range, the function updates the currentDailyRate property\n        // of the holdTokenRateInfo structure associated with the token pair.\n        (, TokenInfo storage holdTokenEntranceFeeInfo) = _updateHoldTokenRateInfo(\n            saleToken,\n            holdToken\n        );\n        holdTokenEntranceFeeInfo.entranceFeeBP = value;\n        emit UpdateHoldTokeEntranceFee(saleToken, holdToken, value);\n    }\n\n    /**\n     * @notice This function is used to check the daily rate collateral for a specific borrowing.\n     * @param borrowingKey The key of the borrowing.\n     * @return balance The balance of the daily rate collateral.\n     * @return estimatedLifeTime The estimated lifetime of the collateral in seconds.\n     */\n    function checkDailyRateCollateral(\n        bytes32 borrowingKey\n    ) external view returns (int256 balance, uint256 estimatedLifeTime) {\n        (, balance, estimatedLifeTime) = _getDebtInfo(borrowingKey);\n        balance /= int256(Constants.COLLATERAL_BALANCE_PRECISION);\n    }\n\n    /**\n     * @notice Get information about loans associated with a borrowing key\n     * @dev This function retrieves an array of loan information for a given borrowing key.\n     * The loans are stored in the loansInfo mapping, which is a mapping of borrowing keys to LoanInfo arrays.\n     * @param borrowingKey The unique key associated with the borrowing\n     * @return loans An array containing LoanInfo structs representing the loans associated with the borrowing key\n     */\n    function getLoansInfo(bytes32 borrowingKey) external view returns (LoanInfo[] memory loans) {\n        loans = loansInfo[borrowingKey];\n    }\n\n    /**\n     * @notice Retrieves the borrowing information for a specific NonfungiblePositionManager tokenId.\n     * @param tokenId The unique identifier of the PositionManager token.\n     * @return extinfo An array of BorrowingInfoExt structs representing the borrowing information.\n     */\n    function getLenderCreditsInfo(\n        uint256 tokenId\n    ) external view returns (BorrowingInfoExt[] memory extinfo) {\n        bytes32[] memory borrowingKeys = getBorrowingKeysForTokenId(tokenId);\n        extinfo = _getDebtsInfo(borrowingKeys);\n    }\n\n    /**\n     * @dev Retrieves the borrowing keys associated with a token ID.\n     * @param tokenId The identifier of the token.\n     * @return borrowingKeys An array of borrowing keys.\n     */\n    function getBorrowingKeysForTokenId(\n        uint256 tokenId\n    ) public view returns (bytes32[] memory borrowingKeys) {\n        borrowingKeys = tokenIdToBorrowingKeys[tokenId].values();\n    }\n\n    /**\n     * @dev Retrieves the borrowing keys for a specific borrower.\n     * @param borrower The address of the borrower.\n     * @return borrowingKeys An array of borrowing keys.\n     */\n    function getBorrowingKeysForBorrower(\n        address borrower\n    ) public view returns (bytes32[] memory borrowingKeys) {\n        borrowingKeys = userBorrowingKeys[borrower].values();\n    }\n\n    /**\n     * @notice Retrieves the debts information for a specific borrower.\n     * @param borrower The address of the borrower.\n     * @return extinfo An array of BorrowingInfoExt structs representing the borrowing information.\n     */\n    function getBorrowerDebtsInfo(\n        address borrower\n    ) external view returns (BorrowingInfoExt[] memory extinfo) {\n        bytes32[] memory borrowingKeys = userBorrowingKeys[borrower].values();\n        extinfo = _getDebtsInfo(borrowingKeys);\n    }\n\n    /**\n     * @dev Returns the number of loans associated with a given NonfungiblePositionManager tokenId.\n     * @param tokenId The ID of the token.\n     * @return count The total number of loans associated with the tokenId.\n     */\n    function getLenderCreditsCount(uint256 tokenId) external view returns (uint256 count) {\n        count = tokenIdToBorrowingKeys[tokenId].length();\n    }\n\n    /**\n     * @dev Returns the number of borrowings for a given borrower.\n     * @param borrower The address of the borrower.\n     * @return count The total number of borrowings for the borrower.\n     */\n    function getBorrowerDebtsCount(address borrower) external view returns (uint256 count) {\n        count = userBorrowingKeys[borrower].length();\n    }\n\n    /**\n     * @dev Returns the current daily rate for holding token.\n     * @param saleToken The address of the token being sold.\n     * @param holdToken The address of the token being held.\n     * @return  holdTokenRateInfo The structured data containing detailed information for the hold token.\n     */\n    function getHoldTokenInfo(\n        address saleToken,\n        address holdToken\n    ) external view returns (TokenInfo memory holdTokenRateInfo) {\n        holdTokenRateInfo = _getHoldTokenInfo(saleToken, holdToken);\n    }\n\n    /**\n     * @dev Returns the fees information for multiple tokens in an array.\n     * @param feesOwner The address of the owner of the fees.\n     * @param tokens An array of token addresses for which the fees are to be retrieved.\n     * @return fees An array containing the fees for each token.\n     */\n    function getFeesInfo(\n        address feesOwner,\n        address[] calldata tokens\n    ) external view returns (uint256[] memory fees) {\n        mapping(address => uint256) storage collection = loansFeesInfo[feesOwner];\n        fees = _getFees(collection, tokens);\n    }\n\n    /**\n     * @dev Get the platform fees information for a list of tokens.\n     *\n     * This function returns an array of fees corresponding to the list of input tokens provided.\n     * Each fee is retrieved from the `platformsFeesInfo` mapping which stores the fee for each token address.\n     *\n     * @param tokens An array of token addresses for which to retrieve the fees information.\n     * @return fees Returns an array of fees, one per each token given as input in the same order.\n     */\n    function getPlatformFeesInfo(\n        address[] calldata tokens\n    ) external view returns (uint256[] memory fees) {\n        mapping(address => uint256) storage collection = platformsFeesInfo;\n        fees = _getFees(collection, tokens);\n    }\n\n    /**\n     * @dev Calculates the liquidation bonus for a given token, borrowed amount, and times factor.\n     * @param token The address of the token.\n     * @param borrowedAmount The amount of tokens borrowed.\n     * @param times The times factor to apply to the liquidation bonus calculation.\n     * @return liquidationBonus The calculated liquidation bonus.\n     */\n    function getLiquidationBonus(\n        address token,\n        uint256 borrowedAmount,\n        uint256 times\n    ) public view returns (uint256 liquidationBonus) {\n        // Retrieve liquidation bonus for the given token\n        Liquidation memory liq = liquidationBonusForToken[token];\n\n        if (liq.bonusBP == 0) {\n            // If there is no specific bonus for the token\n            // Use default bonus\n            liq.minBonusAmount = Constants.MINIMUM_AMOUNT;\n            liq.bonusBP = dafaultLiquidationBonusBP;\n        }\n        liquidationBonus = (borrowedAmount * liq.bonusBP) / Constants.BP;\n\n        if (liquidationBonus < liq.minBonusAmount) {\n            liquidationBonus = liq.minBonusAmount;\n        }\n        liquidationBonus *= (times > 0 ? times : 1);\n    }\n\n    /**\n     * @dev Calculates the collateral amount required for a lifetime in seconds.\n     *\n     * @param borrowingKey The unique identifier of the borrowing.\n     * @param lifetimeInSeconds The duration of the borrowing in seconds.\n     * @return collateralAmt The calculated collateral amount that is needed.\n     */\n    function calculateCollateralAmtForLifetime(\n        bytes32 borrowingKey,\n        uint256 lifetimeInSeconds\n    ) external view returns (uint256 collateralAmt) {\n        // Retrieve the BorrowingInfo struct associated with the borrowing key\n        BorrowingInfo memory borrowing = borrowingsInfo[borrowingKey];\n        // Check if the borrowed position is existing\n        if (borrowing.borrowedAmount > 0) {\n            // Get the current daily rate for the hold token\n            uint256 currentDailyRate = _getHoldTokenInfo(borrowing.saleToken, borrowing.holdToken)\n                .currentDailyRate;\n            // Calculate the collateral amount per second\n            uint256 everySecond = (\n                FullMath.mulDivRoundingUp(\n                    borrowing.borrowedAmount,\n                    currentDailyRate * Constants.COLLATERAL_BALANCE_PRECISION,\n                    1 days * Constants.BP\n                )\n            );\n            // Calculate the total collateral amount for the borrowing lifetime\n            collateralAmt = FullMath.mulDivRoundingUp(\n                everySecond,\n                lifetimeInSeconds,\n                Constants.COLLATERAL_BALANCE_PRECISION\n            );\n            // Ensure that the collateral amount is at least 1\n            if (collateralAmt == 0) collateralAmt = 1;\n        }\n    }\n\n    /**\n     * @notice This function is used to increase the daily rate collateral for a specific borrowing.\n     * @param borrowingKey The unique identifier of the borrowing.\n     * @param collateralAmt The amount of collateral to be added.\n     * @param deadline The deadline timestamp after which the transaction is considered invalid.\n     */\n    function increaseCollateralBalance(\n        bytes32 borrowingKey,\n        uint256 collateralAmt,\n        uint256 deadline\n    ) external checkDeadline(deadline) {\n        BorrowingInfo storage borrowing = borrowingsInfo[borrowingKey];\n        // Ensure that the borrowed position exists and the borrower is the message sender\n        (borrowing.borrowedAmount == 0 || borrowing.borrower != address(msg.sender)).revertError(\n            ErrLib.ErrorCode.INVALID_BORROWING_KEY\n        );\n        // Increase the daily rate collateral balance by the specified collateral amount\n        borrowing.dailyRateCollateralBalance +=\n            collateralAmt *\n            Constants.COLLATERAL_BALANCE_PRECISION;\n        _pay(borrowing.holdToken, msg.sender, VAULT_ADDRESS, collateralAmt);\n        emit IncreaseCollateralBalance(msg.sender, borrowingKey, collateralAmt);\n    }\n\n    /**\n     * @notice Borrow function allows a user to borrow tokens by providing collateral and taking out loans.\n     * The trader opens a long position by borrowing the liquidity of Uniswap V3 and extracting it into a pair of tokens,\n     * one of which will be swapped into a desired(holdToken).The tokens will be kept in storage until the position is closed.\n     * The margin is calculated on the basis that liquidity must be restored with any price movement.\n     * The time the position is held is paid by the trader.\n     * @dev Emits a Borrow event upon successful borrowing.\n     * @param params The BorrowParams struct containing the necessary parameters for borrowing.\n     * @param deadline The deadline timestamp after which the transaction is considered invalid.\n     *\n     * @return borrowedAmount The total amount of `params.holdToken` borrowed.\n     * @return marginDeposit The required collateral deposit amount for initiating the loan.\n     * @return liquidationBonus An additional amount added to the debt as a bonus in case of liquidation.\n     * @return dailyRateCollateral The collateral deposit to hold the transaction for a day.\n     */\n    function borrow(\n        BorrowParams calldata params,\n        uint256 deadline\n    )\n        external\n        nonReentrant\n        checkDeadline(deadline)\n        returns (uint256, uint256, uint256, uint256, uint256)\n    {\n        // Precalculating borrowing details and storing them in cache\n        BorrowCache memory cache = _precalculateBorrowing(params);\n        // Initializing borrowing variables and obtaining borrowing key\n        (\n            uint256 feesDebt,\n            bytes32 borrowingKey,\n            BorrowingInfo storage borrowing\n        ) = _initOrUpdateBorrowing(\n                params.saleToken,\n                params.holdToken,\n                cache.accLoanRatePerSeconds,\n                cache.holdTokenEntraceFee\n            );\n        uint256 liquidationBonus;\n        {\n            // Adding borrowing key and loans information to storage\n            uint256 pushCounter = _addKeysAndLoansInfo(borrowingKey, params.loans);\n            // Calculating liquidation bonus based on hold token, borrowed amount, and number of used loans\n            liquidationBonus = getLiquidationBonus(\n                params.holdToken,\n                cache.borrowedAmount,\n                pushCounter\n            );\n        }\n        uint256 marginDeposit;\n        // positive slippage\n        if (cache.holdTokenBalance > cache.borrowedAmount) {\n            // Thus, we stimulate the platform to look for the best conditions for swapping on external aggregators.\n            platformsFeesInfo[params.holdToken] +=\n                (cache.holdTokenBalance - cache.borrowedAmount) *\n                Constants.COLLATERAL_BALANCE_PRECISION;\n        } else {\n            marginDeposit = cache.borrowedAmount - cache.holdTokenBalance;\n            (marginDeposit > params.maxMarginDeposit).revertError(\n                ErrLib.ErrorCode.TOO_BIG_MARGIN_DEPOSIT\n            );\n        }\n\n        // Updating borrowing details\n        borrowing.borrowedAmount += cache.borrowedAmount;\n        borrowing.liquidationBonus += liquidationBonus;\n        borrowing.dailyRateCollateralBalance +=\n            cache.dailyRateCollateral *\n            Constants.COLLATERAL_BALANCE_PRECISION;\n        //\n        cache.holdTokenEntraceFee =\n            cache.holdTokenEntraceFee /\n            Constants.COLLATERAL_BALANCE_PRECISION +\n            1;\n\n        // Transfer the required tokens to the VAULT_ADDRESS for collateral and holdTokenBalance\n        _pay(\n            params.holdToken,\n            msg.sender,\n            VAULT_ADDRESS,\n            marginDeposit +\n                liquidationBonus +\n                cache.dailyRateCollateral +\n                feesDebt +\n                cache.holdTokenEntraceFee\n        );\n        // Transferring holdTokenBalance to VAULT_ADDRESS\n        _pay(params.holdToken, address(this), VAULT_ADDRESS, cache.holdTokenBalance);\n        // Emit the Borrow event with the borrower, borrowing key, and borrowed amount\n        emit Borrow(\n            msg.sender,\n            borrowingKey,\n            cache.borrowedAmount,\n            marginDeposit,\n            liquidationBonus,\n            cache.dailyRateCollateral,\n            feesDebt,\n            cache.holdTokenEntraceFee\n        );\n        return (\n            cache.borrowedAmount,\n            marginDeposit,\n            liquidationBonus,\n            cache.dailyRateCollateral,\n            cache.holdTokenEntraceFee\n        );\n    }\n\n    /**\n     * @notice Allows lenders to harvest the fees accumulated from their loans.\n     * @dev Retrieves and updates fee amounts for all loans associated with a borrowing position.\n     * The function iterates through each loan, calculating and updating the amount of fees due.\n     *\n     * Requirements:\n     * - The borrowingKey must correspond to an active and valid borrowing position.\n     * - The collateral balance must be above zero or the current fees must be above the minimum required amount.\n     *\n     * @param borrowingKey The unique identifier for the specific borrowing position.\n     *\n     * @return harvestedAmt The total amount of fees harvested by the borrower.\n     */\n    function harvest(bytes32 borrowingKey) external nonReentrant returns (uint256 harvestedAmt) {\n        BorrowingInfo storage borrowing = borrowingsInfo[borrowingKey];\n        // Check if the borrowing key is valid\n        _existenceCheck(borrowing.borrowedAmount);\n\n        // Update token rate information and get holdTokenRateInfo storage reference\n        (, TokenInfo storage holdTokenRateInfo) = _updateHoldTokenRateInfo(\n            borrowing.saleToken,\n            borrowing.holdToken\n        );\n\n        // Calculate collateral balance and validate caller\n        (int256 collateralBalance, uint256 currentFees) = _calculateCollateralBalance(\n            borrowing.borrowedAmount,\n            borrowing.accLoanRatePerSeconds,\n            borrowing.dailyRateCollateralBalance,\n            holdTokenRateInfo.accLoanRatePerSeconds\n        );\n\n        (collateralBalance < 0 ||\n            currentFees < Constants.MINIMUM_AMOUNT * Constants.COLLATERAL_BALANCE_PRECISION)\n            .revertError(ErrLib.ErrorCode.FORBIDDEN);\n\n        // Calculate platform fees and adjust fees owed\n        borrowing.dailyRateCollateralBalance -= currentFees;\n        borrowing.feesOwed += _pickUpPlatformFees(borrowing.holdToken, currentFees);\n        // Set the accumulated loan rate per second for the borrowing position\n        borrowing.accLoanRatePerSeconds = holdTokenRateInfo.accLoanRatePerSeconds;\n\n        uint256 feesOwed = borrowing.feesOwed;\n        uint256 borrowedAmount = borrowing.borrowedAmount;\n\n        bool zeroForSaleToken = borrowing.saleToken < borrowing.holdToken;\n\n        // Create a memory struct to store liquidity cache information.\n        NftPositionCache memory cache;\n        // Get the array of LoanInfo structs associated with the given borrowing key.\n        LoanInfo[] memory loans = loansInfo[borrowingKey];\n        // Iterate through each loan in the loans array.\n        for (uint256 i; i < loans.length; ) {\n            LoanInfo memory loan = loans[i];\n            // Get the owner address of the loan's token ID using the underlyingPositionManager contract.\n            address creditor = _getOwnerOf(loan.tokenId);\n            // Check if the owner of the loan's token ID is equal to the `msg.sender`.\n            if (creditor != address(0)) {\n                // Update the liquidity cache based on the loan information.\n                _upNftPositionCache(zeroForSaleToken, loan, cache);\n                uint256 feesAmt = FullMath.mulDiv(feesOwed, cache.holdTokenDebt, borrowedAmount);\n                // Calculate the fees amount based on the total fees owed and holdTokenDebt.\n                loansFeesInfo[creditor][cache.holdToken] += feesAmt;\n                harvestedAmt += feesAmt;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        borrowing.feesOwed -= harvestedAmt;\n\n        emit Harvest(borrowingKey, harvestedAmt);\n    }\n\n    /**\n     * @notice Used for repaying loans, optionally with liquidation or emergency liquidity withdrawal.\n     * The position is closed either by the trader or by the liquidator if the trader has not paid for holding the position\n     * and the moment of liquidation has arrived.The positions borrowed from liquidation providers are restored from the held\n     * token and the remainder is sent to the caller.In the event of liquidation, the liquidity provider\n     * whose liquidity is present in the traderâ€™s position can use the emergency mode and withdraw their liquidity.In this case,\n     * he will receive hold tokens and liquidity will not be restored in the uniswap pool.\n     * @param params The repayment parameters including\n     *  activation of the emergency liquidity restoration mode (available only to the lender)\n     *  internal swap pool fee,\n     *  external swap parameters,\n     *  borrowing key,\n     *  swap slippage allowance.\n     * @param deadline The deadline by which the repayment must be made.\n     *\n     * @return saleTokenOut The amount of saleToken returned back to the user after repayment.\n     * @return holdTokenOut The amount of holdToken returned back to the user after repayment or emergency withdrawal.\n     */\n    function repay(\n        RepayParams calldata params,\n        uint256 deadline\n    )\n        external\n        nonReentrant\n        checkDeadline(deadline)\n        returns (uint256 saleTokenOut, uint256 holdTokenOut)\n    {\n        BorrowingInfo memory borrowing = borrowingsInfo[params.borrowingKey];\n        // Check if the borrowing key is valid\n        _existenceCheck(borrowing.borrowedAmount);\n\n        bool zeroForSaleToken = borrowing.saleToken < borrowing.holdToken;\n        uint256 liquidationBonus = borrowing.liquidationBonus;\n        int256 collateralBalance;\n        // Update token rate information and get holdTokenRateInfo storage reference\n        (, TokenInfo storage holdTokenRateInfo) = _updateHoldTokenRateInfo(\n            borrowing.saleToken,\n            borrowing.holdToken\n        );\n        {\n            // Calculate collateral balance and validate caller\n            uint256 accLoanRatePerSeconds = holdTokenRateInfo.accLoanRatePerSeconds;\n            uint256 currentFees;\n            (collateralBalance, currentFees) = _calculateCollateralBalance(\n                borrowing.borrowedAmount,\n                borrowing.accLoanRatePerSeconds,\n                borrowing.dailyRateCollateralBalance,\n                accLoanRatePerSeconds\n            );\n\n            (msg.sender != borrowing.borrower && collateralBalance >= 0).revertError(\n                ErrLib.ErrorCode.INVALID_CALLER\n            );\n\n            // Calculate liquidation bonus and adjust fees owed\n\n            if (collateralBalance > 0) {\n                uint256 compensation = _calcFeeCompensationUpToMin(\n                    collateralBalance,\n                    currentFees,\n                    borrowing.feesOwed\n                );\n                currentFees += compensation;\n                collateralBalance -= int256(compensation);\n                liquidationBonus +=\n                    uint256(collateralBalance) /\n                    Constants.COLLATERAL_BALANCE_PRECISION;\n            } else {\n                currentFees = borrowing.dailyRateCollateralBalance;\n            }\n\n            // Calculate platform fees and adjust fees owed\n            borrowing.feesOwed += _pickUpPlatformFees(borrowing.holdToken, currentFees);\n        }\n        // Check if it's an emergency repayment\n        if (params.isEmergency) {\n            (collateralBalance >= 0).revertError(ErrLib.ErrorCode.FORBIDDEN);\n            (\n                uint256 removedAmt,\n                uint256 feesAmt,\n                bool completeRepayment\n            ) = _calculateEmergencyLoanClosure(\n                    zeroForSaleToken,\n                    params.borrowingKey,\n                    borrowing.feesOwed,\n                    borrowing.borrowedAmount\n                );\n            (removedAmt == 0).revertError(ErrLib.ErrorCode.LIQUIDITY_IS_ZERO);\n            // Subtract the removed amount and fees from borrowedAmount and feesOwed\n            borrowing.borrowedAmount -= removedAmt;\n            borrowing.feesOwed -= feesAmt;\n            feesAmt /= Constants.COLLATERAL_BALANCE_PRECISION;\n            // Deduct the removed amount from totalBorrowed\n            holdTokenRateInfo.totalBorrowed -= removedAmt;\n            // If loansInfoLength is 0, remove the borrowing key from storage and get the liquidation bonus\n            if (completeRepayment) {\n                LoanInfo[] memory empty;\n                _removeKeysAndClearStorage(borrowing.borrower, params.borrowingKey, empty);\n                feesAmt += liquidationBonus;\n            } else {\n                // make changes to the storage\n                BorrowingInfo storage borrowingStorage = borrowingsInfo[params.borrowingKey];\n                borrowingStorage.dailyRateCollateralBalance = 0;\n                borrowingStorage.feesOwed = borrowing.feesOwed;\n                borrowingStorage.borrowedAmount = borrowing.borrowedAmount;\n            }\n            holdTokenOut = removedAmt + feesAmt;\n            // Transfer removedAmt + feesAmt to msg.sender and emit EmergencyLoanClosure event\n            Vault(VAULT_ADDRESS).transferToken(borrowing.holdToken, msg.sender, holdTokenOut);\n            emit EmergencyLoanClosure(borrowing.borrower, msg.sender, params.borrowingKey);\n        } else {\n            // Deduct borrowedAmount from totalBorrowed\n            holdTokenRateInfo.totalBorrowed -= borrowing.borrowedAmount;\n\n            // Transfer the borrowed amount and liquidation bonus from the VAULT to this contract\n            Vault(VAULT_ADDRESS).transferToken(\n                borrowing.holdToken,\n                address(this),\n                borrowing.borrowedAmount + liquidationBonus\n            );\n\n            if (params.externalSwap.length != 0) {\n                _callExternalSwap(borrowing.holdToken, params.externalSwap);\n            }\n\n            // Restore liquidity using the borrowed amount and pay a daily rate fee\n            LoanInfo[] memory loans = loansInfo[params.borrowingKey];\n            _maxApproveIfNecessary(\n                borrowing.holdToken,\n                address(underlyingPositionManager),\n                type(uint128).max\n            );\n            _maxApproveIfNecessary(\n                borrowing.saleToken,\n                address(underlyingPositionManager),\n                type(uint128).max\n            );\n\n            _restoreLiquidity(\n                RestoreLiquidityParams({\n                    zeroForSaleToken: zeroForSaleToken,\n                    swapPoolfeeTier: params.internalSwapPoolfee,\n                    totalfeesOwed: borrowing.feesOwed,\n                    totalBorrowedAmount: borrowing.borrowedAmount\n                }),\n                loans\n            );\n\n            // Remove borrowing key from related data structures\n            _removeKeysAndClearStorage(borrowing.borrower, params.borrowingKey, loans);\n\n            // Get the remaining balance of saleToken and holdToken\n            (saleTokenOut, holdTokenOut) = _getPairBalance(\n                borrowing.saleToken,\n                borrowing.holdToken\n            );\n\n            if (saleTokenOut > 0 && params.returnOnlyHoldToken) {\n                (, uint256 holdTokenAmountOut) = _simulateSwap(\n                    zeroForSaleToken,\n                    params.internalSwapPoolfee,\n                    borrowing.saleToken, // saleToken is tokenIn\n                    borrowing.holdToken,\n                    saleTokenOut\n                );\n                if (holdTokenAmountOut > 0) {\n                    // Call the internal v3SwapExactInput function\n                    holdTokenOut += _v3SwapExactInput(\n                        v3SwapExactInputParams({\n                            fee: params.internalSwapPoolfee,\n                            tokenIn: borrowing.saleToken,\n                            tokenOut: borrowing.holdToken,\n                            amountIn: saleTokenOut\n                        })\n                    );\n                    saleTokenOut = 0;\n                }\n            }\n\n            (holdTokenOut < params.minHoldTokenOut || saleTokenOut < params.minSaleTokenOut)\n                .revertError(ErrLib.ErrorCode.PRICE_SLIPPAGE_CHECK);\n\n            // Pay a"
    }
  ]
}