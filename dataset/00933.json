{
  "Title": "`TokenSaleProposal::buy` implicitly assumes that buy token has 18 decimals resulting in a potential total loss scenario for Dao Pool",
  "Content": "**Description:** `TokenSaleProposalBuy::buy` is called by users looking to buy the DAO token using a pre-approved token. The exchange rate for this sale is pre-assigned for the specific tier. This function internally calls `TokenSaleProposalBuy::_purchaseWithCommission` to transfer funds from the buyer to the gov pool. Part of the transferred funds are used to pay the DexeDAO commission and balance funds are transferred to the `GovPool` address. To do this, `TokenSaleProposalBuy::_sendFunds` is called.\n\n```solidity\n    function _sendFunds(address token, address to, uint256 amount) internal {\n        if (token == ETHEREUM_ADDRESS) {\n            (bool success, ) = to.call{value: amount}(\"\");\n            require(success, \"TSP: failed to transfer ether\");\n        } else {\n  >>          IERC20(token).safeTransferFrom(msg.sender, to, amount.from18(token.decimals())); //@audit -> amount is assumed to be 18 decimals\n        }\n    }\n```\n\nNote that this function assumes that the `amount` of ERC20 token is always 18 decimals. The `DecimalsConverter::from18` function converts from a base decimal (18) to token decimals. Note that the amount is directly passed by the buyer and there is no prior normalisation done to ensure the token decimals are converted to 18 decimals before the `_sendFunds` is called.\n\n\n**Impact:** It is easy to see that for tokens with smaller decimals, eg. USDC with 6 decimals, will cause a total loss to the DAO. In such cases amount is presumed to be 18 decimals & on converting to token decimals(6), this number can round down to 0.\n\n**Proof of Concept:**\n- Tier 1 allows users to buy DAO token at exchange rate, 1 DAO token = 1 USDC.\n-  User intends to buy 1000 Dao Tokens and calls `TokenSaleProposal::buy` with `buy(1, USDC, 1000*10**6)\n- Dexe DAO Comission is assumed 0% for simplicity- > `sendFunds` is called with `sendFunds(USDC, govPool, 1000* 10**6)`\n- `DecimalConverter::from18` function is called on amount with base decimals 18, destination decimals 6:  `from18(1000*10**6, 18, 6)`\n- this gives `1000*10**6/10*(18-6) = 1000/ 10**6` which rounds to 0\n\nBuyer can claim 1000 DAO tokens for free. This is a total loss to the DAO.\n\nAdd PoC to `TokenSaleProposal.test.js`:\n\nFirst add a new line around [L76](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/test/gov/proposals/TokenSaleProposal.test.js#L76) to add new `purchaseToken3`:\n```javascript\n      let purchaseToken3;\n```\n\nThen add a new line around [L528](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/test/gov/proposals/TokenSaleProposal.test.js#L528):\n```javascript\n      purchaseToken3 = await ERC20Mock.new(\"PurchaseMockedToken3\", \"PMT3\", 6);\n```\n\nThen add a new tier around [L712](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/test/gov/proposals/TokenSaleProposal.test.js#L712):\n```javascript\n        {\n          metadata: {\n            name: \"tier 9\",\n            description: \"the ninth tier\",\n          },\n          totalTokenProvided: wei(1000),\n          saleStartTime: timeNow.toString(),\n          saleEndTime: (timeNow + 10000).toString(),\n          claimLockDuration: \"0\",\n          saleTokenAddress: saleToken.address,\n          purchaseTokenAddresses: [purchaseToken3.address],\n          exchangeRates: [PRECISION.times(1).toFixed()],\n          minAllocationPerUser: 0,\n          maxAllocationPerUser: 0,\n          vestingSettings: {\n            vestingPercentage: \"0\",\n            vestingDuration: \"0\",\n            cliffPeriod: \"0\",\n            unlockStep: \"0\",\n          },\n          participationDetails: [],\n        },\n```\n\nThen add the test itself under the section `describe(\"if added to whitelist\", () => {`:\n```javascript\n          it(\"audit buy implicitly assumes that buy token has 18 decimals resulting in loss to DAO\", async () => {\n            await purchaseToken3.approve(tsp.address, wei(1000));\n\n            // tier9 has the following parameters:\n            // totalTokenProvided   : wei(1000)\n            // minAllocationPerUser : 0 (no min)\n            // maxAllocationPerUser : 0 (no max)\n            // exchangeRate         : 1 sale token for every 1 purchaseToken\n            //\n            // purchaseToken3 has 6 decimal places\n            //\n            // mint purchase tokens to owner 1000 in 6 decimal places\n            //                        1000 000000\n            let buyerInitTokens6Dec = 1000000000;\n\n            await purchaseToken3.mint(OWNER, buyerInitTokens6Dec);\n            await purchaseToken3.approve(tsp.address, buyerInitTokens6Dec, { from: OWNER });\n\n            //\n            // start: buyer has bought no tokens\n            let TIER9 = 9;\n            let purchaseView = userViewsToObjects(await tsp.getUserViews(OWNER, [TIER9]))[0].purchaseView;\n            assert.equal(purchaseView.claimTotalAmount, wei(0));\n\n            // buyer attempts to purchase using 100 purchaseToken3 tokens\n            // purchaseToken3 has 6 decimals but all inputs to Dexe should be in\n            // 18 decimals, so buyer formats input amount to 18 decimals\n            // doing this first to verify it works correctly\n            let buyInput18Dec = wei(\"100\");\n            await tsp.buy(TIER9, purchaseToken3.address, buyInput18Dec);\n\n            // buyer has bought wei(100) sale tokens\n            purchaseView = userViewsToObjects(await tsp.getUserViews(OWNER, [TIER9]))[0].purchaseView;\n            assert.equal(purchaseView.claimTotalAmount, buyInput18Dec);\n\n            // buyer has 900 000000 remaining purchaseToken3 tokens\n            assert.equal((await purchaseToken3.balanceOf(OWNER)).toFixed(), \"900000000\");\n\n            // next buyer attempts to purchase using 100 purchaseToken3 tokens\n            // but sends input formatted into native 6 decimals\n            // sends 6 decimal input: 100 000000\n            let buyInput6Dec = 100000000;\n            await tsp.buy(TIER9, purchaseToken3.address, buyInput6Dec);\n\n            // buyer has bought an additional 100000000 sale tokens\n            purchaseView = userViewsToObjects(await tsp.getUserViews(OWNER, [TIER9]))[0].purchaseView;\n            assert.equal(purchaseView.claimTotalAmount, \"100000000000100000000\");\n\n            // but the buyer still has 900 000000 remaining purchasetoken3 tokens\n            assert.equal((await purchaseToken3.balanceOf(OWNER)).toFixed(), \"900000000\");\n\n            // by sending the input amount formatted to 6 decimal places,\n            // the buyer was able to buy small amounts of the token being sold\n            // for free!\n          });\n```\n\nFinally run the test with: `npx hardhat test --grep \"audit buy implicitly assumes that buy token has 18 decimals resulting in loss to DAO\"`\n\n**Recommended Mitigation:** There are at least 2 options for mitigating this issue:\n\nOption 1 - revise the design decision that all token amounts must be sent in 18 decimals even if the underlying token decimals are not 18, to instead that all token amounts should be sent in their native decimals and Dexe will convert everything.\n\nOption 2 - keep current design but revert if `amount.from18(token.decimals()) == 0` in [L90](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/libs/gov/token-sale-proposal/TokenSaleProposalBuy.sol#L90) or alternatively use the [`from18Safe()`](https://github.com/dl-solarity/solidity-lib/blob/master/contracts/libs/utils/DecimalsConverter.sol#L124) function which uses [`_convertSafe()`](https://github.com/dl-solarity/solidity-lib/blob/master/contracts/libs/utils/DecimalsConverter.sol#L248) that reverts if the conversion is 0.\n\nThe project team should also examine other areas where the same pattern occurs which may have the same vulnerability and where it may be required to revert if the conversion returns 0:\n\n* `GovUserKeeper` [L92](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L92), [L116](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L116), [L183](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L183)\n* `GovPool` [L248](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/GovPool.sol#L248)\n* `TokenSaleProposalWhitelist` [L50](https://github.com/dexe-network/DeXe-Protocol/blob/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/libs/gov/token-sale-proposal/TokenSaleProposalWhitelist.sol#L50)\n* `ERC721Power` [L113](https://github.com/dexe-network/DeXe-Protocol/blob/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/ERC721/ERC721Power.sol#L113), [L139](https://github.com/dexe-network/DeXe-Protocol/blob/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/ERC721/ERC721Power.sol#L139)\n* `TokenBalance` [L35](https://github.com/dexe-network/DeXe-Protocol/blob/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/libs/utils/TokenBalance.sol#L35), [L62](https://github.com/dexe-network/DeXe-Protocol/blob/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/libs/utils/TokenBalance.sol#L62)\n\n**Dexe:**\nFixed in commit [c700d9f](https://github.com/dexe-network/DeXe-Protocol/commit/c700d9f9f328d1df853891b52fd3527b56a6f1df).\n\n**Cyfrin:** Verified. While other places have been changed, `TokenBalance::sendFunds()` still uses `from18()` instead of `from18Safe()` & other parts of the codebase which allow user input when calling `TokenBalance::sendFunds()` directly could be impacted by a similar issue.\n\nFor example `TokenSaleProposalWhitelist::unlockParticipationTokens()` - if users try to unlock a small enough amount of locked tokens which are in 6 decimal precision, state will be updated as if the unlock was successful but the resulting conversion in `TokenBalance::sendFunds()` will round down to 0. Execution will continue & zero tokens will be transferred to the user but since storage has been updated those tokens will remain forever locked.\n\nDexe should carefully consider if there exists any valid situations where the `from18()` conversion in `TokenBalance::sendFunds()` should round an input > 0 to 0, and the transaction should not revert but continue executing transferring 0 tokens? Cyfrin recommends that the \"default\" conversion to use is `from18Safe()` and that `from18()` should only be used where conversions to 0 are explicitly allowed.",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/libs/gov/token-sale-proposal/TokenSaleProposalWhitelist.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"@solarity/solidity-lib/libs/decimals/DecimalsConverter.sol\";\nimport \"@solarity/solidity-lib/libs/arrays/SetHelper.sol\";\n\nimport \"../../../gov/proposals/TokenSaleProposal.sol\";\n\nimport \"../../../libs/utils/TokenBalance.sol\";\nimport \"./TokenSaleProposalBuy.sol\";\n\nlibrary TokenSaleProposalWhitelist {\n    using TokenSaleProposalBuy for ITokenSaleProposal.Tier;\n    using TokenBalance for address;\n    using DecimalsConverter for *;\n    using SetHelper for EnumerableSet.UintSet;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for *;\n    using EnumerableMap for EnumerableMap.AddressToUintMap;\n\n    function lockParticipationTokens(\n        ITokenSaleProposal.Tier storage tier,\n        address tokenToLock,\n        uint256 amountToLock\n    ) external {\n        ITokenSaleProposal.ParticipationInfo storage participationInfo = tier.participationInfo;\n        EnumerableMap.AddressToUintMap storage lockedTokens = tier\n            .users[msg.sender]\n            .purchaseInfo\n            .lockedTokens;\n\n        require(amountToLock > 0, \"TSP: zero amount to lock\");\n\n        (, uint256 lockedAmount) = lockedTokens.tryGet(tokenToLock);\n        (, uint256 requiredAmount) = participationInfo.requiredTokenLock.tryGet(tokenToLock);\n\n        uint256 newLockedAmount = lockedAmount + amountToLock;\n\n        require(newLockedAmount <= requiredAmount, \"TSP: token overlock\");\n\n        lockedTokens.set(tokenToLock, newLockedAmount);\n\n        if (tokenToLock != ETHEREUM_ADDRESS) {\n            IERC20(tokenToLock).safeTransferFrom(\n                msg.sender,\n                address(this),\n                amountToLock.from18(tokenToLock.decimals())\n            );\n        } else {\n            require(msg.value == amountToLock, \"TSP: wrong lock amount\");\n        }\n    }\n\n    function lockParticipationNft(\n        ITokenSaleProposal.Tier storage tier,\n        address nftToLock,\n        uint256[] calldata nftIdsToLock\n    ) external {\n        ITokenSaleProposal.PurchaseInfo storage purchaseInfo = tier.users[msg.sender].purchaseInfo;\n        EnumerableSet.UintSet storage lockedNfts = purchaseInfo.lockedNfts[nftToLock];\n\n        require(nftIdsToLock.length > 0, \"TSP: zero nft ids to lock\");\n\n        purchaseInfo.lockedNftAddresses.add(nftToLock);\n\n        for (uint256 i = 0; i < nftIdsToLock.length; i++) {\n            require(lockedNfts.add(nftIdsToLock[i]), \"TSP: lock nfts are duplicated\");\n        }\n\n        (, uint256 requiredAmount) = tier.participationInfo.requiredNftLock.tryGet(nftToLock);\n\n        require(lockedNfts.length() <= requiredAmount, \"TSP: nft overlock\");\n\n        for (uint256 i = 0; i < nftIdsToLock.length; i++) {\n            IERC721(nftToLock).safeTransferFrom(msg.sender, address(this), nftIdsToLock[i]);\n        }\n    }\n\n    function unlockParticipationTokens(\n        ITokenSaleProposal.Tier storage tier,\n        address tokenToUnlock,\n        uint256 amountToUnlock\n    ) external {\n        EnumerableMap.AddressToUintMap storage lockedTokens = tier\n            .users[msg.sender]\n            .purchaseInfo\n            .lockedTokens;\n\n        require(\n            block.timestamp >= tier.tierInitParams.saleEndTime ||\n                !tier._checkUserLockedTokens(msg.sender),\n            \"TSP: unlock unavailable\"\n        );\n\n        require(amountToUnlock > 0, \"TSP: zero amount to unlock\");\n\n        (, uint256 lockedAmount) = lockedTokens.tryGet(tokenToUnlock);\n\n        require(amountToUnlock <= lockedAmount, \"TSP: unlock exceeds lock\");\n\n        if (amountToUnlock == lockedAmount) {\n            lockedTokens.remove(tokenToUnlock);\n        } else {\n            lockedTokens.set(tokenToUnlock, lockedAmount - amountToUnlock);\n        }\n\n        tokenToUnlock.sendFunds(msg.sender, amountToUnlock);\n    }\n\n    function unlockParticipationNft(\n        ITokenSaleProposal.Tier storage tier,\n        address nftToUnlock,\n        uint256[] calldata nftIdsToUnlock\n    ) external {\n        ITokenSaleProposal.PurchaseInfo storage purchaseInfo = tier.users[msg.sender].purchaseInfo;\n        EnumerableSet.UintSet storage lockedNfts = purchaseInfo.lockedNfts[nftToUnlock];\n\n        require(\n            block.timestamp >= tier.tierInitParams.saleEndTime ||\n                !tier._checkUserLockedNfts(msg.sender),\n            \"TSP: unlock unavailable\"\n        );\n\n        require(nftIdsToUnlock.length > 0, \"TSP: zero nft ids to unlock\");\n\n        for (uint256 i = 0; i < nftIdsToUnlock.length; i++) {\n            require(lockedNfts.remove(nftIdsToUnlock[i]), \"TSP: nft is not locked\");\n        }\n\n        if (lockedNfts.length() == 0) {\n            purchaseInfo.lockedNftAddresses.remove(nftToUnlock);\n        }\n\n        for (uint256 i = 0; i < nftIdsToUnlock.length; i++) {\n            IERC721(nftToUnlock).safeTransferFrom(address(this), msg.sender, nftIdsToUnlock[i]);\n        }\n    }\n\n    function addToWhitelist(\n        ITokenSaleProposal.Tier storage tier,\n        ITokenSaleProposal.WhitelistingRequest calldata request\n    ) external {\n        require(tier.participationInfo.isWhitelisted, \"TSP: tier is not whitelisted\");\n\n        tier.tierInfo.uri = request.uri;\n\n        for (uint256 i = 0; i < request.users.length; i++) {\n            TokenSaleProposal(address(this)).mint(request.users[i], request.tierId);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/gov/ERC721/ERC721Power.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"@solarity/solidity-lib/libs/decimals/DecimalsConverter.sol\";\n\nimport \"../../interfaces/gov/ERC721/IERC721Power.sol\";\n\nimport \"../../libs/math/MathHelper.sol\";\nimport \"../../libs/utils/TokenBalance.sol\";\n\nimport \"../../core/Globals.sol\";\n\ncontract ERC721Power is IERC721Power, ERC721EnumerableUpgradeable, OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n    using MathHelper for uint256;\n    using DecimalsConverter for *;\n    using TokenBalance for address;\n\n    uint64 public powerCalcStartTimestamp;\n    string public baseURI;\n\n    mapping(uint256 => NftInfo) public nftInfos; // tokenId => info\n\n    uint256 public reductionPercent;\n\n    address public collateralToken;\n    uint256 public totalCollateral;\n\n    uint256 public maxPower;\n    uint256 public requiredCollateral;\n\n    uint256 public totalPower;\n\n    modifier onlyBeforePowerCalc() {\n        _onlyBeforePowerCalc();\n        _;\n    }\n\n    function __ERC721Power_init(\n        string calldata name,\n        string calldata symbol,\n        uint64 startTimestamp,\n        address _collateralToken,\n        uint256 _maxPower,\n        uint256 _reductionPercent,\n        uint256 _requiredCollateral\n    ) external initializer {\n        __Ownable_init();\n        __ERC721Enumerable_init();\n        __ERC721_init(name, symbol);\n\n        require(_collateralToken != address(0), \"ERC721Power: zero address\");\n        require(_maxPower > 0, \"ERC721Power: max power can't be zero\");\n        require(_reductionPercent > 0, \"ERC721Power: reduction percent can't be zero\");\n        require(_reductionPercent < PERCENTAGE_100, \"ERC721Power: reduction can't be 100%\");\n        require(_requiredCollateral > 0, \"ERC721Power: required collateral amount can't be zero\");\n\n        powerCalcStartTimestamp = startTimestamp;\n\n        collateralToken = _collateralToken;\n        maxPower = _maxPower;\n        reductionPercent = _reductionPercent;\n        requiredCollateral = _requiredCollateral;\n    }\n\n    function setNftMaxPower(\n        uint256 _maxPower,\n        uint256 tokenId\n    ) external onlyOwner onlyBeforePowerCalc {\n        require(_maxPower > 0, \"ERC721Power: max power can't be zero\");\n\n        if (_exists(tokenId)) {\n            totalPower -= getMaxPowerForNft(tokenId);\n            totalPower += _maxPower;\n        }\n\n        nftInfos[tokenId].maxPower = _maxPower;\n    }\n\n    function setNftRequiredCollateral(\n        uint256 amount,\n        uint256 tokenId\n    ) external onlyOwner onlyBeforePowerCalc {\n        require(amount > 0, \"ERC721Power: required collateral amount can't be zero\");\n\n        nftInfos[tokenId].requiredCollateral = amount;\n    }\n\n    function safeMint(address to, uint256 tokenId) external onlyOwner onlyBeforePowerCalc {\n        _safeMint(to, tokenId, \"\");\n\n        totalPower += getMaxPowerForNft(tokenId);\n    }\n\n    function setBaseUri(string calldata uri) external onlyOwner {\n        baseURI = uri;\n    }\n\n    function addCollateral(uint256 amount, uint256 tokenId) external override {\n        require(ownerOf(tokenId) == msg.sender, \"ERC721Power: sender isn't an nft owner\");\n        require(amount > 0, \"ERC721Power: wrong collateral amount\");\n\n        IERC20(collateralToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount.from18(collateralToken.decimals())\n        );\n\n        recalculateNftPower(tokenId);\n\n        nftInfos[tokenId].currentCollateral += amount;\n        totalCollateral += amount;\n    }\n\n    function removeCollateral(uint256 amount, uint256 tokenId) external override {\n        require(ownerOf(tokenId) == msg.sender, \"ERC721Power: sender isn't an nft owner\");\n\n        NftInfo storage nftInfo = nftInfos[tokenId];\n\n        require(\n            amount > 0 && amount <= nftInfo.currentCollateral,\n            \"ERC721Power: wrong collateral amount\"\n        );\n\n        recalculateNftPower(tokenId);\n\n        nftInfo.currentCollateral -= amount;\n        totalCollateral -= amount;\n\n        IERC20(collateralToken).safeTransfer(\n            msg.sender,\n            amount.from18(collateralToken.decimals())\n        );\n    }\n\n    function recalculateNftPower(uint256 tokenId) public override returns (uint256 newPower) {\n        if (block.timestamp < powerCalcStartTimestamp) {\n            return 0;\n        }\n\n        newPower = getNftPower(tokenId);\n\n        NftInfo storage nftInfo = nftInfos[tokenId];\n\n        totalPower -= nftInfo.lastUpdate != 0 ? nftInfo.currentPower : getMaxPowerForNft(tokenId);\n        totalPower += newPower;\n\n        nftInfo.lastUpdate = uint64(block.timestamp);\n        nftInfo.currentPower = newPower;\n    }\n\n    function getMaxPowerForNft(uint256 tokenId) public view override returns (uint256) {\n        uint256 maxPowerForNft = nftInfos[tokenId].maxPower;\n\n        return maxPowerForNft == 0 ? maxPower : maxPowerForNft;\n    }\n\n    function getRequiredCollateralForNft(uint256 tokenId) public view override returns (uint256) {\n        uint256 requiredCollateralForNft = nftInfos[tokenId].requiredCollateral;\n\n        return requiredCollateralForNft == 0 ? requiredCollateral : requiredCollateralForNft;\n    }\n\n    function getNftPower(uint256 tokenId) public view override returns (uint256) {\n        if (block.timestamp <= powerCalcStartTimestamp) {\n            return 0;\n        }\n\n        uint256 collateral = nftInfos[tokenId].currentCollateral;\n\n        // Calculate the minimum possible power based on the collateral of the nft\n        uint256 maxNftPower = getMaxPowerForNft(tokenId);\n        uint256 minNftPower = maxNftPower.ratio(collateral, getRequiredCollateralForNft(tokenId));\n        minNftPower = maxNftPower.min(minNftPower);\n\n        // Get last update and current power. Or set them to default if it is first iteration\n        uint64 lastUpdate = nftInfos[tokenId].lastUpdate;\n        uint256 currentPower = nftInfos[tokenId].currentPower;\n\n        if (lastUpdate == 0) {\n            lastUpdate = powerCalcStartTimestamp;\n            currentPower = maxNftPower;\n        }\n\n        // Calculate reduction amount\n        uint256 powerReductionPercent = reductionPercent * (block.timestamp - lastUpdate);\n        uint256 powerReduction = currentPower.min(maxNftPower.percentage(powerReductionPercent));\n        uint256 newPotentialPower = currentPower - powerReduction;\n\n        if (minNftPower <= newPotentialPower) {\n            return newPotentialPower;\n        }\n\n        if (minNftPower <= currentPower) {\n            return minNftPower;\n        }\n\n        return currentPower;\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        virtual\n        override(IERC165Upgradeable, ERC721EnumerableUpgradeable)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC721Power).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return baseURI;\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 batchSize\n    ) internal override {\n        super._beforeTokenTransfer(from, to, tokenId, batchSize);\n\n        recalculateNftPower(tokenId);\n    }\n\n    function _onlyBeforePowerCalc() internal view {\n        require(\n            block.timestamp < powerCalcStartTimestamp,\n            \"ERC721Power: power calculation already begun\"\n        );\n    }\n}"
    },
    {
      "filename": "contracts/libs/utils/TokenBalance.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"@solarity/solidity-lib/libs/decimals/DecimalsConverter.sol\";\n\nimport \"../../core/Globals.sol\";\n\nimport \"../../interfaces/gov/ERC20/IERC20Gov.sol\";\n\nlibrary TokenBalance {\n    using DecimalsConverter for *;\n    using SafeERC20 for IERC20;\n\n    enum TransferType {\n        Revert,\n        Mint,\n        TryMint\n    }\n\n    function sendFunds(\n        address token,\n        address receiver,\n        uint256 amount,\n        TransferType transferType\n    ) internal {\n        if (token == ETHEREUM_ADDRESS) {\n            (bool status, ) = payable(receiver).call{value: amount}(\"\");\n\n            require(status, \"Gov: failed to send eth\");\n        } else {\n            amount = amount.from18(ERC20(token).decimals());\n\n            uint256 balance = IERC20(token).balanceOf(address(this));\n\n            if (balance < amount) {\n                if (transferType == TransferType.Revert) {\n                    revert(\"Gov: insufficient funds\");\n                }\n\n                try IERC20Gov(token).mint(address(this), amount - balance) {} catch {\n                    if (transferType == TransferType.Mint) {\n                        revert(\"Gov: cannot mint\");\n                    }\n\n                    amount = balance;\n                }\n            }\n\n            IERC20(token).safeTransfer(receiver, amount);\n        }\n    }\n\n    function sendFunds(address token, address receiver, uint256 amount) internal {\n        sendFunds(token, receiver, amount, TransferType.Revert);\n    }\n\n    function sendFunds(IERC20 token, address receiver, uint256 amount) internal {\n        token.safeTransfer(receiver, amount.from18(address(token).decimals()));\n    }\n\n    function thisBalance(address token) internal view returns (uint256) {\n        return\n            token == ETHEREUM_ADDRESS\n                ? address(this).balance\n                : IERC20(token).balanceOf(address(this));\n    }\n\n    function normThisBalance(address token) internal view returns (uint256) {\n        return\n            token == ETHEREUM_ADDRESS\n                ? thisBalance(token)\n                : thisBalance(token).to18(token.decimals());\n    }\n}"
    }
  ]
}