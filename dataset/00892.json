{
  "Title": "H-8: Native ETH not received when removing liquidity from Curve V2 pools",
  "Content": "# Issue H-8: Native ETH not received when removing liquidity from Curve V2 pools \n\nSource: https://github.com/sherlock-audit/2023-10-notional-judging/issues/86 \n\n## Found by \nxiaoming90\n## Summary\n\nNative ETH was not received when removing liquidity from Curve V2 pools due to the mishandling of Native ETH and WETH, leading to a loss of assets.\n\n## Vulnerability Detail\n\nCurve V2 pool will always wrap to WETH and send to leverage vault unless the `use_eth` is explicitly set to `True`. Otherwise, it will default to `False`. The following implementation of the `remove_liquidity_one_coin` function taken from one of the Curve V2 pools shows that unless the `use_eth` is set to `True`, the `WETH.deposit()` will be triggered to wrap the ETH, and WETH will be transferred back to the caller. The same is true for the `remove_liquidity` function, but it is omitted for brevity.\n\nhttps://etherscan.io/address/0x0f3159811670c117c372428d4e69ac32325e4d0f#code\n\n```python\n@external\n@nonreentrant('lock')\ndef remove_liquidity_one_coin(token_amount: uint256, i: uint256, min_amount: uint256,\n                              use_eth: bool = False, receiver: address = msg.sender) -> uint256:\n    A_gamma: uint256[2] = self._A_gamma()\n\n    dy: uint256 = 0\n    D: uint256 = 0\n    p: uint256 = 0\n    xp: uint256[N_COINS] = empty(uint256[N_COINS])\n    future_A_gamma_time: uint256 = self.future_A_gamma_time\n    dy, p, D, xp = self._calc_withdraw_one_coin(A_gamma, token_amount, i, (future_A_gamma_time > 0), True)\n    assert dy >= min_amount, \"Slippage\"\n\n    if block.timestamp >= future_A_gamma_time:\n        self.future_A_gamma_time = 1\n\n    self.balances[i] -= dy\n    CurveToken(self.token).burnFrom(msg.sender, token_amount)\n\n    coin: address = self.coins[i]\n    if use_eth and coin == WETH20:\n        raw_call(receiver, b\"\", value=dy)\n    else:\n        if coin == WETH20:\n            WETH(WETH20).deposit(value=dy)\n        response: Bytes[32] = raw_call(\n            coin,\n            _abi_encode(receiver, dy, method_id=method_id(\"transfer(address,uint256)\")),\n            max_outsize=32,\n        )\n        if len(response) != 0:\n            assert convert(response, bool)\n```\n\nNotional's Leverage Vault only works with Native ETH. It was found that the `remove_liquidity_one_coin` and `remove_liquidity` functions are executed without explicitly setting the `use_eth` parameter to `True`. Thus, WETH instead of Native ETH will be returned during remove liquidity. As a result, these WETH will not be accounted for in the vault and result in a loss of assets.\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/Curve2TokenConvexVault.sol#L83C17-L83C77\n\n```solidity\nFile: Curve2TokenConvexVault.sol\n66:     function _unstakeAndExitPool(\n..SNIP..\n78:         ICurve2TokenPool pool = ICurve2TokenPool(CURVE_POOL);\n79:         exitBalances = new uint256[](2);\n80:         if (isSingleSided) {\n81:             // Redeem single-sided\n82:             exitBalances[_PRIMARY_INDEX] = pool.remove_liquidity_one_coin(\n83:                 poolClaim, int8(_PRIMARY_INDEX), _minAmounts[_PRIMARY_INDEX]\n84:             );\n85:         } else {\n86:             // Redeem proportionally, min amounts are rewritten to a fixed length array\n87:             uint256[2] memory minAmounts;\n88:             minAmounts[0] = _minAmounts[0];\n89:             minAmounts[1] = _minAmounts[1];\n90: \n91:             uint256[2] memory _exitBalances = pool.remove_liquidity(poolClaim, minAmounts);\n92:             exitBalances[0] = _exitBalances[0];\n93:             exitBalances[1] = _exitBalances[1];\n94:         }\n```\n\n## Impact\n\nFollowing are some of the impacts due to the mishandling of Native ETH and WETH during liquidity removal in Curve pools, leading to loss of assets:\n\n1. Within the `redeemFromNotional`, if the vaults consist of ETH, the `_UNDERLYING_IS_ETH` will be set to true. In this case, the code will attempt to call `transfer` to transfer Native ETH, which will fail as Native ETH is not received and users/Notional are unable to redeem.\n\n   ```solidity\n   File: BaseStrategyVault.sol\n   175:     function redeemFromNotional(\n   ..SNIP..\n   199:         if (_UNDERLYING_IS_ETH) {\n   200:             if (transferToReceiver > 0) payable(receiver).transfer(transferToReceiver);\n   201:             if (transferToNotional > 0) payable(address(NOTIONAL)).transfer(transferToNotional);\n   202:         } else {\n   ..SNIP..\n   ```\n\n2. WETH will be received instead of Native ETH during the emergency exit. During vault restoration, WETH is not re-entered into the pool as only Native ETH residing in the vault will be transferred to the pool. Leverage vault only works with Native ETH, and if one of the pool tokens is WETH, it will be converted to Native ETH (0x0 or 0xEeeee) during deployment/initialization. Thus, the WETH is stuck in the vault. This causes the value per share to drop significantly. ([Reference](https://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/common/SingleSidedLPVaultBase.sol#L514))\n\n   ```solidity\n   File: SingleSidedLPVaultBase.sol\n   480:     function emergencyExit(\n   481:         uint256 claimToExit, bytes calldata /* data */\n   482:     ) external override onlyRole(EMERGENCY_EXIT_ROLE) {\n   483:         StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n   484:         if (claimToExit == 0) claimToExit = state.totalPoolClaim;\n   485: \n   486:         // By setting min amounts to zero, we will accept whatever tokens come from the pool\n   487:         // in a proportional exit. Front running will not have an effect since no trading will\n   488:         // occur during a proportional exit.\n   489:         _unstakeAndExitPool(claimToExit, new uint256[](NUM_TOKENS()), true);\n   490: \n   491:         state.totalPoolClaim = state.totalPoolClaim - claimToExit;\n   492:         state.setStrategyVaultState();\n   ```\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/Curve2TokenConvexVault.sol#L83C17-L83C77\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIf one of the pool tokens is ETH, consider setting `is_eth` to true when calling `remove_liquidity_one_coin` and `remove_liquidity` functions to ensure that Native ETH is sent back to the vault.\n\n\n\n## Discussion\n\n**jeffywu**\n\nAs I recall, this flag only exists on CurveV2 pools?\n\n**jeffywu**\n\nhttps://github.com/notional-finance/leveraged-vaults/pull/71\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/119",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/Curve2TokenConvexVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {Deployments} from \"../global/Deployments.sol\";\nimport {Constants} from \"../global/Constants.sol\";\nimport {IERC20} from \"../utils/TokenUtils.sol\";\nimport {ConvexStakingMixin, ConvexVaultDeploymentParams} from \"./curve/ConvexStakingMixin.sol\";\nimport {NotionalProxy} from \"../../interfaces/notional/NotionalProxy.sol\";\nimport {IConvexBooster, IConvexBoosterArbitrum} from \"../../interfaces/convex/IConvexBooster.sol\";\nimport {IConvexRewardPool, IConvexRewardPoolArbitrum} from \"../../interfaces/convex/IConvexRewardPool.sol\";\nimport {\n    ICurvePool,\n    ICurve2TokenPool,\n    ICurve2TokenPoolV1,\n    ICurve2TokenPoolV2\n} from \"../../interfaces/curve/ICurvePool.sol\";\n\ncontract Curve2TokenConvexVault is ConvexStakingMixin {\n    constructor(NotionalProxy notional_, ConvexVaultDeploymentParams memory params) \n        ConvexStakingMixin(notional_, params) {}\n\n    function strategy() external override pure returns (bytes4) {\n        return bytes4(keccak256(\"Curve2TokenConvexVault\"));\n    }\n\n    function _joinPoolAndStake(\n        uint256[] memory _amounts, uint256 minPoolClaim\n    ) internal override returns (uint256 lpTokens) {\n        // Only two tokens are ever allowed in this strategy, remaps the array\n        // into a fixed length array here.\n        uint256[2] memory amounts;\n        amounts[0] = _amounts[0];\n        amounts[1] = _amounts[1];\n\n        // Although Curve uses ALT_ETH to represent native ETH, it is rewritten in the Curve2TokenPoolMixin\n        // to the Deployments.ETH_ADDRESS which we use internally.\n        (IERC20[] memory tokens, /* */) = TOKENS();\n        uint256 msgValue;\n        if (address(tokens[0]) == Deployments.ETH_ADDRESS) {\n            msgValue = amounts[0];\n        } else if (address(tokens[1]) == Deployments.ETH_ADDRESS) {\n            msgValue = amounts[1];\n        }\n\n        // Slightly different method signatures in v1 and v2\n        if (IS_CURVE_V2) {\n            lpTokens = ICurve2TokenPoolV2(CURVE_POOL).add_liquidity{value: msgValue}(\n                amounts, minPoolClaim, 0 < msgValue // use_eth = true if msgValue > 0\n            );\n        } else {\n            lpTokens = ICurve2TokenPoolV1(CURVE_POOL).add_liquidity{value: msgValue}(\n                amounts, minPoolClaim\n            );\n        }\n\n        // Method signatures are slightly different on mainnet and arbitrum\n        bool success;\n        if (Deployments.CHAIN_ID == Constants.CHAIN_ID_MAINNET) {\n            success = IConvexBooster(CONVEX_BOOSTER).deposit(CONVEX_POOL_ID, lpTokens, true);\n        } else if (Deployments.CHAIN_ID == Constants.CHAIN_ID_ARBITRUM) {\n            success = IConvexBoosterArbitrum(CONVEX_BOOSTER).deposit(CONVEX_POOL_ID, lpTokens);\n        }\n        require(success);\n    }\n\n    function _unstakeAndExitPool(\n        uint256 poolClaim, uint256[] memory _minAmounts, bool isSingleSided\n    ) internal override returns (uint256[] memory exitBalances) {\n        bool success;\n        // Do not claim rewards when unstaking\n        if (Deployments.CHAIN_ID == Constants.CHAIN_ID_MAINNET) {\n            success = IConvexRewardPool(CONVEX_REWARD_POOL).withdrawAndUnwrap(poolClaim, false);\n        } else if (Deployments.CHAIN_ID == Constants.CHAIN_ID_ARBITRUM) {\n            success = IConvexRewardPoolArbitrum(CONVEX_REWARD_POOL).withdraw(poolClaim, false);\n        }\n        require(success);\n\n        ICurve2TokenPool pool = ICurve2TokenPool(CURVE_POOL);\n        exitBalances = new uint256[](2);\n        if (isSingleSided) {\n            // Redeem single-sided\n            exitBalances[_PRIMARY_INDEX] = pool.remove_liquidity_one_coin(\n                poolClaim, int8(_PRIMARY_INDEX), _minAmounts[_PRIMARY_INDEX]\n            );\n        } else {\n            // Redeem proportionally, min amounts are rewritten to a fixed length array\n            uint256[2] memory minAmounts;\n            minAmounts[0] = _minAmounts[0];\n            minAmounts[1] = _minAmounts[1];\n\n            uint256[2] memory _exitBalances = pool.remove_liquidity(poolClaim, minAmounts);\n            exitBalances[0] = _exitBalances[0];\n            exitBalances[1] = _exitBalances[1];\n        }\n    }\n\n    function _checkPriceAndCalculateValue() internal view override returns (uint256 oneLPValueInPrimary) {\n        uint256[] memory balances = new uint256[](2);\n        balances[0] = ICurvePool(CURVE_POOL).balances(0);\n        balances[1] = ICurvePool(CURVE_POOL).balances(1);\n\n        // The primary index spot price is left as zero.\n        uint256[] memory spotPrices = new uint256[](2);\n        uint256 primaryPrecision = 10 ** PRIMARY_DECIMALS;\n        uint256 secondaryPrecision = 10 ** SECONDARY_DECIMALS;\n\n        // `get_dy` returns the price of one unit of the primary token\n        // converted to the secondary token. The spot price is in secondary\n        // precision and then we convert it to POOL_PRECISION.\n        spotPrices[SECONDARY_INDEX] = ICurvePool(CURVE_POOL).get_dy(\n            int8(_PRIMARY_INDEX), int8(SECONDARY_INDEX), primaryPrecision\n        ) * POOL_PRECISION() / secondaryPrecision;\n\n        return _calculateLPTokenValue(balances, spotPrices);\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/common/SingleSidedLPVaultBase.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\n\nimport {BaseStrategyVault} from \"./BaseStrategyVault.sol\";\nimport {Errors} from \"../../global/Errors.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {TypeConvert} from \"../../global/TypeConvert.sol\";\nimport {TokenUtils} from \"../../utils/TokenUtils.sol\";\nimport {StrategyUtils} from \"./StrategyUtils.sol\";\nimport {VaultStorage} from \"./VaultStorage.sol\";\n\nimport {IERC20} from \"../../../interfaces/IERC20.sol\";\nimport {\n    ISingleSidedLPStrategyVault,\n    StrategyVaultSettings,\n    InitParams,\n    StrategyVaultState,\n    SingleSidedRewardTradeParams,\n    DepositParams,\n    DepositTradeParams,\n    RedeemParams,\n    TradeParams\n} from \"../../../interfaces/notional/ISingleSidedLPStrategyVault.sol\";\nimport {NotionalProxy} from \"../../../interfaces/notional/NotionalProxy.sol\";\nimport {ITradingModule, DexId} from \"../../../interfaces/trading/ITradingModule.sol\";\n\n/**\n * @notice Base contract for the SingleSidedLP strategy. This strategy deposits into an LP\n * pool given a single borrowed currency. Allows for users to trade via external exchanges\n * during entry and exit, but the general expected behavior is single sided entries and\n * exits. Inheriting contracts will fill in the implementation details for integration with\n * the external DEX pool.\n */\nabstract contract SingleSidedLPVaultBase is BaseStrategyVault, UUPSUpgradeable, ISingleSidedLPStrategyVault {\n    using TypeConvert for uint256;\n    using VaultStorage for StrategyVaultState;\n\n    uint256 internal constant MAX_TOKENS = 5;\n    uint8 internal constant NOT_FOUND = type(uint8).max;\n    /// @notice Bit mask for the 'LOCKED\" flag big\n    uint32 internal constant FLAG_LOCKED = 1 << 0;\n\n    /************************************************************************\n     * VIRTUAL FUNCTIONS                                                    *\n     * These virtual functions are used to isolate implementation specific  *\n     * behavior.                                                            *\n     ************************************************************************/\n\n    /// @notice Total number of tokens held by the LP token\n    function NUM_TOKENS() internal view virtual returns (uint256);\n\n    /// @notice Addresses of tokens held and decimal places of each token. ETH will always be\n    /// recorded in this array as Deployments.ETH_Address\n    function TOKENS() internal view virtual returns (IERC20[] memory, uint8[] memory decimals);\n\n    /// @notice Address of the LP token\n    function POOL_TOKEN() internal view virtual returns (IERC20);\n\n    /// @notice Index of the TOKENS() array that refers to the primary borrowed currency by the\n    /// leveraged vault. All valuations are done in terms of this currency.\n    function PRIMARY_INDEX() internal view virtual returns (uint256);\n\n    /// @notice Precision (i.e. 10 ** decimals) of the LP token.\n    function POOL_PRECISION() internal view virtual returns (uint256);\n\n    /// @notice Returns the value of one LP token in terms of the primary borrowed currency by this\n    /// strategy. Will revert if the spot price on the pool is not within some deviation tolerance of\n    /// the implied oracle price. This is intended to prevent any pool manipulation.\n    /// The value of the LP token is calculated as the value of the token if all the balance claims are\n    /// withdrawn proportionally and then converted to the primary currency at the oracle price. Slippage\n    /// from selling the tokens is not considered, any slippage effects will be captured by the maximum\n    /// leverage ratio allowed before liquidation.\n    function _checkPriceAndCalculateValue() internal view virtual returns (uint256 oneLPValueInPrimary);\n\n    /// @notice Called once during initialization to set the initial token approvals.\n    function _initialApproveTokens() internal virtual;\n\n    /// @notice Called to claim reward tokens\n    function _claimRewardTokens() internal virtual;\n\n    /// @notice Called during reward reinvestment to validate that the token being sold is not one\n    /// of the tokens that is required for the vault to function properly (i.e. one of the pool tokens\n    /// or any of the reward booster tokens).\n    function _isInvalidRewardToken(address token) internal view virtual returns (bool);\n\n    /// @notice Implementation specific wrapper for joining a pool with the given amounts. Will also\n    /// stake on the relevant booster protocol.\n    function _joinPoolAndStake(\n        uint256[] memory amounts, uint256 minPoolClaim\n    ) internal virtual returns (uint256 lpTokens);\n\n    /// @notice Implementation specific wrapper for unstaking from the booster protocol and withdrawing\n    /// funds from the LP pool\n    function _unstakeAndExitPool(\n        uint256 poolClaim, uint256[] memory minAmounts, bool isSingleSided\n    ) internal virtual returns (uint256[] memory exitBalances);\n\n    /// @notice Returns the total supply of the pool token. Is a virtual function because\n    /// ComposableStablePools use a \"virtual supply\" and a different method must be called\n    /// to get the actual total supply.\n    function _totalPoolSupply() internal view virtual returns (uint256) {\n        return POOL_TOKEN().totalSupply();\n    }\n\n    /************************************************************************\n     * CLASS FUNCTIONS                                                      *\n     * Below are class functions that represent the base implementation     *\n     * of the Single Sided LP strategy.                                     *\n     ************************************************************************/\n\n    constructor(NotionalProxy notional_, ITradingModule tradingModule_)\n        BaseStrategyVault(notional_, tradingModule_) {}\n\n    /************************************************************************\n     * EXTERNAL VIEW FUNCTIONS                                              *\n     ************************************************************************/\n\n    /// @notice Returns basic information about the vault for use in the user interface.\n    function getStrategyVaultInfo() external view override returns (SingleSidedLPStrategyVaultInfo memory) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        return SingleSidedLPStrategyVaultInfo({\n            pool: address(POOL_TOKEN()),\n            singleSidedTokenIndex: uint8(PRIMARY_INDEX()),\n            totalLPTokens: state.totalPoolClaim,\n            totalVaultShares: state.totalVaultSharesGlobal\n        });\n    }\n\n    /// @notice Returns the current locked status of the vault\n    function isLocked() public view returns (bool) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        return _hasFlag(state.flags, FLAG_LOCKED);\n    }\n\n    /// @notice Returns the current price of a vault share, even when there are no vault shares\n    /// in the strategy. Used by the user interface to collect historical valuation information.\n    function getExchangeRate(uint256 /* maturity */) external view override returns (int256) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        uint256 oneLPValueInPrimary = _checkPriceAndCalculateValue();\n        // If inside an emergency exit, just report the one LP value in primary since the total\n        // pool claim will be 0\n        if (state.totalVaultSharesGlobal == 0 || isLocked()) {\n            return oneLPValueInPrimary.toInt();\n        } else {\n            uint256 lpTokensPerVaultShare = (uint256(Constants.INTERNAL_TOKEN_PRECISION) * state.totalPoolClaim)\n                / state.totalVaultSharesGlobal;\n            return (oneLPValueInPrimary * lpTokensPerVaultShare / POOL_PRECISION()).toInt();\n        }\n    }\n\n    /************************************************************************\n     * ADMIN FUNCTIONS                                                      *\n     * Administrative functions to set settings and initialize the vault.   *\n     * These methods are only callable by the Notional owner.               *\n     ************************************************************************/\n\n    /// @notice Allow Notional owner to upgrade the contract\n    function _authorizeUpgrade(\n        address /* newImplementation */\n    ) internal override onlyNotionalOwner {}\n\n    /// @notice Updates the vault settings include the maximum oracle deviation limit and the\n    /// maximum percent of the LP pool that the vault can hold.\n    function setStrategyVaultSettings(StrategyVaultSettings calldata settings) external onlyNotionalOwner {\n        // Validation occurs inside this method\n        VaultStorage.setStrategyVaultSettings(settings);\n    }\n\n    /// @notice Called to initialize the vault and set the initial approvals. All of the other vault\n    /// parameters are set via immutable parameters already.\n    function initialize(InitParams calldata params) external override initializer onlyNotionalOwner {\n        // Initialize the base vault\n        __INIT_VAULT(params.name, params.borrowCurrencyId);\n\n        // Settings are validated in setStrategyVaultSettings\n        VaultStorage.setStrategyVaultSettings(params.settings);\n\n        _initialApproveTokens();\n    }\n\n    /************************************************************************\n     * USER FUNCTIONS                                                       *\n     * These functions are called during normal usage of the vault.         *\n     * They allow for deposits and redemptions from the vault as well as a  *\n     * valuation check that is used by Notional to determine if the user is *\n     * properly collateralized.                                             *\n     ************************************************************************/\n\n    /// @notice This is a virtual function called by BaseStrategyVault which ensures that\n    /// this method is only called by Notional after an initial borrow has been made and\n    /// the deposit amount has been transferred to this vault. Will join the LP pool with\n    /// the funds given and then return the total vault shares minted.\n    function _depositFromNotional(\n        address /* account */, uint256 deposit, uint256 /* maturity */, bytes calldata data\n    ) internal override whenNotLocked returns (uint256 vaultSharesMinted) {\n        // Short circuit any zero deposit amounts\n        if (deposit == 0) return 0;\n\n        DepositParams memory params = abi.decode(data, (DepositParams));\n        uint256[] memory amounts = new uint256[](NUM_TOKENS());\n        amounts[PRIMARY_INDEX()] = deposit;\n\n        // If depositTrades are specified, then parts of the initial deposit are traded\n        // for corresponding amounts of the other pool tokens via external exchanges. If\n        // these amounts are not specified then the pool will just be joined single sided.\n        // Deposit trades are not automatically enabled on vaults since the trading module\n        // requires explicit permission for every token that can be sold by an address.\n        if (params.depositTrades.length > 0) {\n            (IERC20[] memory tokens, /* */) = TOKENS();\n            // This is an external library call so the memory location of amounts is\n            // different before and after the call.\n            amounts = StrategyUtils.executeDepositTrades(\n                tokens,\n                amounts,\n                params.depositTrades,\n                PRIMARY_INDEX()\n            );\n        }\n\n        uint256 lpTokens = _joinPoolAndStake(amounts, params.minPoolClaim);\n        return _mintVaultShares(lpTokens);\n    }\n\n    /// @notice Given a number of LP tokens minted, issues vault shares back to the holder. Vault\n    /// shares are claim on the LP tokens held by the vault. As rewards are reinvested, one vault\n    /// share is a claim on an increasing amount of LP tokens.\n    function _mintVaultShares(uint256 lpTokens) internal returns (uint256 vaultShares) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        if (state.totalPoolClaim == 0) {\n            // Vault Shares are in 8 decimal precision\n            vaultShares = (lpTokens * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / POOL_PRECISION();\n        } else {\n            vaultShares = (lpTokens * state.totalVaultSharesGlobal) / state.totalPoolClaim;\n        }\n\n        // Updates internal storage here\n        state.totalPoolClaim += lpTokens;\n        state.totalVaultSharesGlobal += vaultShares.toUint80();\n        state.setStrategyVaultState();\n\n        // Checks that the vault does not own too large of a portion of the pool. If this is the case,\n        // single sided exits may have a detrimental effect on the liquidity.\n        uint256 maxPoolShare = VaultStorage.getStrategyVaultSettings().maxPoolShare;\n        uint256 maxSupplyThreshold = (_totalPoolSupply() * maxPoolShare) / Constants.VAULT_PERCENT_BASIS;\n        if (maxSupplyThreshold < state.totalPoolClaim)\n            revert Errors.PoolShareTooHigh(state.totalPoolClaim, maxSupplyThreshold);\n    }\n\n    /// @notice This is a virtual function called by BaseStrategyVault which ensures that\n    /// this method is only called by Notional after an initial position has been made. Will\n    /// withdraw the LP tokens from the pool, either single sided or proportionally. On a\n    /// proportional exit, will trade all the tokens back to the primary in order to exit the pool.\n    /// @return finalPrimaryBalance which is the amount of funds that the vault will transfer back\n    /// to Notional and the account to repay debts and withdraw profits.\n    function _redeemFromNotional(\n        address /* account */, uint256 vaultShares, uint256 /* maturity */, bytes calldata data\n    ) internal override whenNotLocked returns (uint256 finalPrimaryBalance) {\n        // Short circuit any zero redemption amounts, this can occur during rolling positions\n        // or withdraw cash balances post liquidation.\n        if (vaultShares == 0) return 0;\n\n        // Updates internal account to deduct the vault shares.\n        uint256 poolClaim = _redeemVaultShares(vaultShares);\n        RedeemParams memory params = abi.decode(data, (RedeemParams));\n\n        bool isSingleSided = params.redemptionTrades.length == 0;\n        // Returns the amount of each token that has been withdrawn from the pool.\n        uint256[] memory exitBalances = _unstakeAndExitPool(poolClaim, params.minAmounts, isSingleSided);\n        if (!isSingleSided) {\n            // If not a single sided trade, will execute trades back to the primary token on\n            // external exchanges. This method will execute EXACT_IN trades to ensure that\n            // all of the balance in the other tokens is sold for primary.\n            (IERC20[] memory tokens, /* */) = TOKENS();\n            // Redemption trades are not automatically enabled on vaults since the trading module\n            // requires explicit permission for every token that can be sold by an address.\n            return StrategyUtils.executeRedemptionTrades(\n                tokens,\n                exitBalances,\n                params.redemptionTrades,\n                PRIMARY_INDEX()\n            );\n        } else {\n            // No explicit check is done here to ensure that the other balances are zero, assumed\n            // that the `_unstakeAndExitPool` method on the implementation is correct and will only\n            // ever withdraw to a single balance.\n            return exitBalances[PRIMARY_INDEX()];\n        }\n    }\n\n    /// @notice Updates internal account for vault share redemption.\n    function _redeemVaultShares(uint256 vaultShares) internal returns (uint256 poolClaim) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        // Will revert on divide by zero, which is the correct behavior\n        poolClaim = (vaultShares * state.totalPoolClaim) / state.totalVaultSharesGlobal;\n\n        state.totalPoolClaim -= poolClaim;\n        // Will revert on underflow if vault shares is greater than total shares global\n        state.totalVaultSharesGlobal -= vaultShares.toUint80();\n        state.setStrategyVaultState();\n    }\n\n    /// @notice Converts the vault shares to an oracle value in underlying tokens. Used by Notional\n    /// to determine the collateral position of a vault user. If the vault is locked due to an\n    /// emergency exit, this function will revert which will prevent users from entering, exiting,\n    /// and being liquidated. During emergency exit, the vault will not be holding any LP tokens and\n    /// therefore this calculation will not be correct.\n    function convertStrategyToUnderlying(\n        address /* */, uint256 vaultShares, uint256 /* */\n    ) public view override whenNotLocked returns (int256 underlyingValue) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        // Will revert on divide by zero, which is the correct behavior\n        uint256 lpTokens = (vaultShares * state.totalPoolClaim) / state.totalVaultSharesGlobal;\n        uint256 oneLPValueInPrimary = _checkPriceAndCalculateValue();\n\n        return (oneLPValueInPrimary * lpTokens / POOL_PRECISION()).toInt();\n    }\n\n    /// @notice Returns the pair price of two tokens via the TRADING_MODULE which holds a registry\n    /// of oracles. Will revert of the oracle pair is not listed.\n    function _getOraclePairPrice(address base, address quote) internal view returns (uint256) {\n        (int256 rate, int256 precision) = TRADING_MODULE.getOraclePrice(base, quote);\n        require(rate > 0);\n        require(precision > 0);\n        return uint256(rate) * POOL_PRECISION() / uint256(precision);\n    }\n\n    /// @notice Helper method called by _checkPriceAndCalculateValue which will supply the relevant\n    /// pool balances and spot prices. Calculates the claim of one LP token on relevant pool balances\n    /// and compares the oracle price to the spot price, reverting if the deviation is too high.\n    /// @return oneLPValueInPrimary the value of one LP token in terms of the primary borrowed currency\n    function _calculateLPTokenValue(\n        uint256[] memory balances,\n        uint256[] memory spotPrices\n    ) internal view returns (uint256 oneLPValueInPrimary) {\n        (IERC20[] memory tokens, uint8[] memory decimals) = TOKENS();\n        address primaryToken = address(tokens[PRIMARY_INDEX()]);\n        uint256 primaryDecimals = 10 ** decimals[PRIMARY_INDEX()];\n        uint256 totalSupply = _totalPoolSupply();\n        uint256 limit = VaultStorage.getStrategyVaultSettings().oraclePriceDeviationLimitPercent;\n\n        for (uint256 i; i < tokens.length; i++) {\n            // Skip the pool token if it is in the token list (i.e. ComposablePools)\n            if (address(tokens[i]) == address(POOL_TOKEN())) continue;\n            // This is the claim on the pool balance of 1 LP token.\n            uint256 tokenClaim = balances[i] * POOL_PRECISION() / totalSupply;\n            if (i == PRIMARY_INDEX()) {\n                oneLPValueInPrimary += tokenClaim;\n            } else {\n                uint256 price = _getOraclePairPrice(primaryToken, address(tokens[i]));\n\n                // Check that the spot price and the oracle price are near each other. If this is\n                // not true then we assume that the LP pool is being manipulated.\n                uint256 lowerLimit = price * (Constants.VAULT_PERCENT_BASIS - limit) / Constants.VAULT_PERCENT_BASIS;\n                uint256 upperLimit = price * (Constants.VAULT_PERCENT_BASIS + limit) / Constants.VAULT_PERCENT_BASIS;\n                if (spotPrices[i] < lowerLimit || upperLimit < spotPrices[i]) {\n                    revert Errors.InvalidPrice(price, spotPrices[i]);\n                }\n\n                // Convert the token claim to primary using the oracle pair price.\n                uint256 secondaryDecimals = 10 ** decimals[i];\n                oneLPValueInPrimary += (tokenClaim * POOL_PRECISION() * primaryDecimals) / \n                    (price * secondaryDecimals);\n            }\n        }\n    }\n\n    /************************************************************************\n     * REWARD REINVESTMENT                                                  *\n     * Methods used by bots to claim reward tokens and reinvest them as LP  *\n     * tokens which are donated to all vault users.                         *\n     ************************************************************************/\n\n    /// @notice Ensures that only whitelisted bots can claim reward tokens.\n    function claimRewardTokens() external override onlyRole(REWARD_REINVESTMENT_ROLE) {\n        _claimRewardTokens();\n    }\n\n    /// @notice Ensures that only whitelisted bots can reinvest rewards. Since rewards\n    /// are typically less liquid than pool tokens and lack oracles, reward reinvestment\n    /// is done using explicitly set slippage limits by the reinvestment bots. Reinvestment\n    /// will fail if the spot prices are not close to the oracle prices to ensure that\n    /// there is no front running the reinvestment.\n    function reinvestReward(\n        SingleSidedRewardTradeParams[] calldata trades,\n        uint256 minPoolClaim\n    ) external whenNotLocked onlyRole(REWARD_REINVESTMENT_ROLE) returns (\n        address rewardToken,\n        uint256 amountSold,\n        uint256 poolClaimAmount\n    ) {\n        // Will revert if spot prices are not in line with the oracle values\n        _checkPriceAndCalculateValue();\n\n        // Require one trade per token, if we do not want to buy any tokens at a\n        // given index then the amount should be set to zero. This applies to pool\n        // tokens like in the ComposableStablePool.\n        require(trades.length == NUM_TOKENS());\n        uint256[] memory amounts;\n        (rewardToken, amountSold, amounts) = _executeRewardTrades(trades);\n\n        poolClaimAmount = _joinPoolAndStake(amounts, minPoolClaim);\n\n        // Increase LP token amount without minting additional vault shares\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        state.totalPoolClaim += poolClaimAmount;\n        state.setStrategyVaultState();\n\n        emit RewardReinvested(rewardToken, amountSold, poolClaimAmount);\n    }\n\n    function _executeRewardTrades(SingleSidedRewardTradeParams[] calldata trades) internal returns (\n        address rewardToken,\n        uint256 amountSold,\n        uint256[] memory amounts\n    ) {\n        // The sell token on all trades must be the same (checked inside executeRewardTrades) so\n        // just validate here that the sellToken is a valid reward token (i.e. none of the tokens\n        // used in the regular functioning of the vault).\n        rewardToken = trades[0].sellToken;\n        if (_isInvalidRewardToken(rewardToken)) revert Errors.InvalidRewardToken(rewardToken);\n        (IERC20[] memory tokens, /* */) = TOKENS();\n        (amounts, amountSold) = StrategyUtils.executeRewardTrades(\n            tokens, trades, rewardToken, address(POOL_TOKEN())\n        );\n    }\n\n    /************************************************************************\n     * EMERGENCY EXIT                                                       *\n     * In case of an emergency, will allow a whitelisted guardian to exit   *\n     * funds on the vault and locks the vault from further usage. The owner *\n     * can restore funds to the LP pool and reinstante vault usage. If the  *\n     * vault cannot be fully restored after an exit, the vault will need to *\n     * be upgraded and unwound manually to ensure that debts are repaid and *\n     * users can withdraw their funds.                                      *\n     ************************************************************************/\n\n    /// @notice Allows the function to execute only when the vault is not locked\n    modifier whenNotLocked() {\n        if (isLocked()) revert Errors.VaultLocked();\n        _;\n    }\n\n    /// @notice Allows the function to execute only when the vault is locked\n    modifier whenLocked() {\n        if (!isLocked()) revert Errors.VaultNotLocked();\n        _;\n    }\n\n    /// @notice Checks if a flag bit is set\n    function _hasFlag(uint32 flags, uint32 flagID) private pure returns (bool) {\n        return (flags & flagID) == flagID;\n    }\n\n    /// @notice Locks the vault, preventing deposits and redemptions. Used during\n    /// emergency exit\n    function _lockVault() internal {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        // Set locked flag\n        state.flags = state.flags | FLAG_LOCKED;\n        VaultStorage.setStrategyVaultState(state);\n        emit VaultLocked();\n    }\n\n    /// @notice Unlocks the vault, called during restore vault.\n    function _unlockVault() internal {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        // Remove locked flag\n        state.flags = state.flags & ~FLAG_LOCKED;\n        VaultStorage.setStrategyVaultState(state);\n        emit VaultUnlocked();\n    }\n\n    /// @notice Allows the emergency exit role to trigger an emergency exit on the vault.\n    /// In this situation, the `claimToExit` is withdrawn proportionally to the underlying\n    /// tokens and held on the vault. The vault is locked so that no entries, exits or\n    /// valuations of vaultShares can be performed.\n    /// @param claimToExit if this is set to zero, the entire pool claim is withdrawn\n    function emergencyExit(\n        uint256 claimToExit, bytes calldata /* data */\n    ) external override onlyRole(EMERGENCY_EXIT_ROLE) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        if (claimToExit == 0) claimToExit = state.totalPoolClaim;\n\n        // By setting min amounts to zero, we will accept whatever tokens come from the pool\n        // in a proportional exit. Front running will not have an effect since no trading will\n        // occur during a proportional exit.\n        _unstakeAndExitPool(claimToExit, new uint256[](NUM_TOKENS()), true);\n\n        state.totalPoolClaim = state.totalPoolClaim - claimToExit;\n        state.setStrategyVaultState();\n\n        emit EmergencyExit(claimToExit);\n        _lockVault();\n    }\n\n    /// @notice Restores withdrawn tokens from emergencyExit back into the vault proportionally.\n    /// Unlocks the vault after restoration so that normal functionality is restored.\n    /// @param minPoolClaim slippage limit to prevent front running\n    function restoreVault(\n        uint256 minPoolClaim, bytes calldata /* data */\n    ) external override whenLocked onlyNotionalOwner {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n\n        (IERC20[] memory tokens, /* */) = TOKENS();\n        uint256[] memory amounts = new uint256[](tokens.length);\n\n        // All balances held by the vault are assumed to be used to re-enter\n        // the pool. Since the vault has been locked no other users should have\n        // been able to enter the pool.\n        for (uint256 i; i < tokens.length; i++) {\n            if (address(tokens[i]) == address(POOL_TOKEN())) continue;\n            amounts[i] = TokenUtils.tokenBalance(address(tokens[i]));\n        }\n\n        // No trades are specified so this joins proportionally using the\n        // amounts specified.\n        uint256 poolTok"
    }
  ]
}