{
  "Title": "H-5: Incorrect invariant used for Balancer's composable pools",
  "Content": "# Issue H-5: Incorrect invariant used for Balancer's composable pools \n\nSource: https://github.com/sherlock-audit/2023-10-notional-judging/issues/83 \n\n## Found by \nxiaoming90\n## Summary\n\nOnly two balances instead of all balances were used when computing the invariant for Balancer's composable pools, which is incorrect. As a result, pool manipulation might not be detected. This could lead to the transaction being executed on the manipulated pool, resulting in a loss of assets.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/BalancerSpotPrice.sol#L90\n\n```solidity\nFile: BalancerSpotPrice.sol\n78:     function _calculateStableMathSpotPrice(\n..SNIP..\n86:         // Apply scale factors\n87:         uint256 secondary = balances[index2] * scalingFactors[index2] / BALANCER_PRECISION;\n88: \n89:         uint256 invariant = StableMath._calculateInvariant(\n90:             ampParam, StableMath._balances(scaledPrimary, secondary), true // round up\n91:         );\n92: \n93:         spotPrice = StableMath._calcSpotPrice(ampParam, invariant, scaledPrimary, secondary);\n..SNIP..\n```\n\nA composable pool can support up to 5 tokens (excluding the BPT). When computing the invariant for a composable pool, one needs to pass in the balances of all the tokens within the pool except for BPT. However, the existing code always only passes in the balance of two tokens, which will return an incorrect invariant if the composable pool supports more than two tokens.\n\nFollowing is the formula for computing the invariant of a composable pool taken from Balancer's Composable Pool. The `balances` passed into this function consist of all balances except for BPT ([Reference](https://github.com/balancer/balancer-v2-monorepo/blob/6da0b87fa7bd10cbba7f084d45336fc743944fea/pkg/pool-stable/contracts/ComposableStablePool.sol#L700))\n\nhttps://github.com/balancer/balancer-v2-monorepo/blob/c7d4abbea39834e7778f9ff7999aaceb4e8aa048/pkg/pool-stable/contracts/StableMath.sol#L57\n\n```solidity\nfunction _calculateInvariant(uint256 amplificationParameter, uint256[] memory balances)\n    internal\n    pure\n    returns (uint256)\n{\n    /**********************************************************************************************\n    // invariant                                                                                 //\n    // D = invariant                                                  D^(n+1)                    //\n    // A = amplification coefficient      A  n^n S + D = A D n^n + -----------                   //\n    // S = sum of balances                                             n^n P                     //\n    // P = product of balances                                                                   //\n    // n = number of tokens                                                                      //\n    **********************************************************************************************/\n```\n\nThe Balancer SDK's provide a feature to compute the spot price of any two tokens within a pool (https://github.com/balancer/balancer-sdk/blob/develop/balancer-js/src/modules/pools/pool-types/concerns/stablePhantom/spotPrice.spec.ts). By tracing the functions, it eventually triggers the following `_poolDerivatives` function.\n\nWithin the `_poolDerivatives` function, the `balances` used to compute the invariant consist of the balance of all tokens in the pool, except for BPT, which is aligned with the earlier understanding.\n\nhttps://github.com/balancer/balancer-sor/blob/73d6b435c1429bbfc199b39b38a36e581838d2c3/src/pools/phantomStablePool/phantomStableMath.ts#L516\n\n```solidity\nexport function _poolDerivatives(\n    A: BigNumber,\n    balances: OldBigNumber[],\n    tokenIndexIn: number,\n    tokenIndexOut: number,\n    is_first_derivative: boolean,\n    wrt_out: boolean\n): OldBigNumber {\n    const totalCoins = balances.length;\n    const D = _invariant(A, balances);\n```\n\nNote: Composable Pool used to be called Phantom Pool in the past (https://medium.com/balancer-protocol/rate-manipulation-in-balancer-boosted-pools-technical-postmortem-53db4b642492)\n\n## Impact\n\nAn incorrect invariant will lead to an incorrect spot price being computed. The spot price is used within the `_checkPriceAndCalculateValue` function that is intended to revert if the spot price on the pool is not within some deviation tolerance of the implied oracle price to prevent any pool manipulation. As a result, incorrect spot price leads to false positives or false negatives, where, in the worst-case scenario, pool manipulation was not caught by this function, and the transaction proceeded to be executed. \n\nThe `_checkPriceAndCalculateValue` function was found to be used within the following functions:\n\n- `reinvestReward` - If the `_checkPriceAndCalculateValue` function is malfunctioning, it will cause the vault to add liquidity into a pool that has been manipulated, leading to a loss of assets.\n\n- `convertStrategyToUnderlying` - This function is used by Notional V3 for the purpose of computing the collateral values and the account's health factor. If the `_checkPriceAndCalculateValue` function reverts unexpectedly due to an incorrect invariant/spot price, many of Notional's core functions will break. In addition, the collateral values and the account's health factor might be inflated if it fails to detect a manipulated pool due to incorrect invariant/spot price, potentially allowing the malicious actors to drain the main protocol.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/BalancerSpotPrice.sol#L90\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nReview if there is any specific reason for passing in only the balance of two tokens when computing the invariant. Otherwise, the balance of all tokens (except BPT) should be used to compute the invariant. \n\nIn addition, it is recommended to include additional tests to ensure that the computed spot price is aligned with the market price.\n\n\n\n## Discussion\n\n**jeffywu**\n\nThis looks to be valid and we can re-align our implementation to match the balancer implementation.\n\n**jeffywu**\n\nhttps://github.com/notional-finance/leveraged-vaults/pull/63\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/119",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/BalancerSpotPrice.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport \"forge-std/console.sol\";\nimport {Deployments} from \"../../global/Deployments.sol\";\nimport {StableMath} from \"./math/StableMath.sol\";\nimport {IComposablePool, IWeightedPool} from \"../../../interfaces/balancer/IBalancerPool.sol\";\nimport {IBalancerVault} from \"../../../interfaces/balancer/IBalancerVault.sol\";\n\n/**\n * @notice External, singleton helper contract deployed to calculate spot prices for Balancer pools.\n * Currently supports Composable pools with any number of tokens and Weighted2Token pools.\n */\ncontract BalancerSpotPrice {\n    uint256 internal constant BALANCER_PRECISION = 1e18;\n\n    /// @notice Returns the weighted pool spot price and balances. Only the spot price on the\n    /// secondary token is returned.\n    function getWeightedSpotPrices(\n        bytes32 poolId,\n        address poolAddress,\n        uint256 primaryIndex,\n        uint8 primaryDecimals\n    ) external view returns (uint256[] memory balances, uint256[] memory spotPrices) {\n        (/* */, balances, /* */) = Deployments.BALANCER_VAULT.getPoolTokens(poolId);\n        // Only two token pools are supported\n        require(balances.length == 2);\n        spotPrices = new uint256[](2);\n\n        uint256[] memory weights = IWeightedPool(poolAddress).getNormalizedWeights();\n\n        // Spot price calculation is specified at the link below. Do not account for swap fees\n        // because we're using this price to compare to the oracle price and adding swap fees\n        // would unnecessarily increase the price deviation.\n        // https://docs.balancer.fi/reference/math/weighted-math.html#typescript\n        // secondaryBalance * primaryWeight * primaryDecimals \n        // --------------------------------------------------- \n        //          primaryBalance * secondaryWeight\n        uint256 secondaryIndex = 1 - primaryIndex;\n\n        // There is a chance of a uint256 overflow if the balances[secondaryIndex] > 10**36\n        uint256 numerator = balances[secondaryIndex] * weights[primaryIndex] * (10 ** primaryDecimals);\n        uint256 denominator = balances[primaryIndex] * weights[secondaryIndex];\n        spotPrices[secondaryIndex] = numerator / denominator;\n    }\n\n    /// @notice Returns the composable pool spot price and balances. Pool token spot\n    /// prices are not returned, pool token balance is returned.\n    function getComposableSpotPrices(\n        bytes32 poolId,\n        address poolAddress,\n        uint256 primaryIndex\n    ) external view returns (uint256[] memory balances, uint256[] memory spotPrices) {\n        address[] memory tokens;\n        (tokens, balances, /* */) = Deployments.BALANCER_VAULT.getPoolTokens(poolId);\n        uint256[] memory scalingFactors = IComposablePool(poolAddress).getScalingFactors();\n\n        (\n            uint256 ampParam,\n            /* bool isUpdating */,\n            uint256 precision\n        ) = IComposablePool(poolAddress).getAmplificationParameter();\n        require(precision == StableMath._AMP_PRECISION);\n\n        // The primary index spot price is left as zero.\n        spotPrices = new uint256[](tokens.length);\n        uint256 scaledPrimary = balances[primaryIndex] * scalingFactors[primaryIndex] / BALANCER_PRECISION;\n        for (uint256 i; i < tokens.length; i++) {\n            if (i == primaryIndex) continue;\n            if (tokens[i] == poolAddress) continue;\n\n            spotPrices[i] = _calculateStableMathSpotPrice(\n                ampParam, scalingFactors, balances, scaledPrimary, primaryIndex, i\n            );\n        }\n    }\n\n    function _calculateStableMathSpotPrice(\n        uint256 ampParam,\n        uint256[] memory scalingFactors,\n        uint256[] memory balances,\n        uint256 scaledPrimary,\n        uint256 primaryIndex,\n        uint256 index2\n    ) internal pure returns (uint256 spotPrice) {\n        // Apply scale factors\n        uint256 secondary = balances[index2] * scalingFactors[index2] / BALANCER_PRECISION;\n\n        uint256 invariant = StableMath._calculateInvariant(\n            ampParam, StableMath._balances(scaledPrimary, secondary), true // round up\n        );\n\n        spotPrice = StableMath._calcSpotPrice(ampParam, invariant, scaledPrimary, secondary);\n\n        // Remove scaling factors from spot price\n        spotPrice = spotPrice * scalingFactors[primaryIndex] / scalingFactors[index2];\n    }\n}"
    },
    {
      "filename": "pkg/pool-stable/contracts/ComposableStablePool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@balancer-labs/v2-interfaces/contracts/pool-stable/StablePoolUserData.sol\";\nimport \"@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol\";\nimport \"@balancer-labs/v2-interfaces/contracts/standalone-utils/IProtocolFeePercentagesProvider.sol\";\nimport \"@balancer-labs/v2-interfaces/contracts/pool-utils/IRateProvider.sol\";\n\nimport \"@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol\";\nimport \"@balancer-labs/v2-solidity-utils/contracts/math/Math.sol\";\nimport \"@balancer-labs/v2-solidity-utils/contracts/helpers/ERC20Helpers.sol\";\nimport \"@balancer-labs/v2-solidity-utils/contracts/helpers/InputHelpers.sol\";\n\nimport \"@balancer-labs/v2-pool-utils/contracts/BaseGeneralPool.sol\";\nimport \"@balancer-labs/v2-pool-utils/contracts/rates/PriceRateCache.sol\";\n\nimport \"./ComposableStablePoolStorage.sol\";\nimport \"./ComposableStablePoolRates.sol\";\nimport \"./ComposableStablePoolStorage.sol\";\nimport \"./ComposableStablePoolRates.sol\";\nimport \"./ComposableStablePoolProtocolFees.sol\";\nimport \"./StablePoolAmplification.sol\";\nimport \"./StableMath.sol\";\n\n/**\n * @dev StablePool with preminted BPT and rate providers for each token, allowing for e.g. wrapped tokens with a known\n * price ratio, such as Compound's cTokens.\n *\n * BPT is preminted on Pool initialization and registered as one of the Pool's tokens, allowing for swaps to behave as\n * single-token joins or exits (by swapping a token for BPT). We also support regular joins and exits, which can mint\n * and burn BPT.\n *\n * Preminted BPT is deposited in the Vault as the initial balance of the Pool, and doesn't belong to any entity until\n * transferred out of the Pool. The Pool's arithmetic behaves as if it didn't exist, and the BPT total supply is not\n * a useful value: we rely on the 'virtual supply' (how much BPT is actually owned outside the Vault) instead.\n */\ncontract ComposableStablePool is\n    IRateProvider,\n    BaseGeneralPool,\n    StablePoolAmplification,\n    ComposableStablePoolRates,\n    ComposableStablePoolProtocolFees\n{\n    using FixedPoint for uint256;\n    using PriceRateCache for bytes32;\n    using StablePoolUserData for bytes;\n    using BasePoolUserData for bytes;\n\n    // The maximum imposed by the Vault, which stores balances in a packed format, is 2**(112) - 1.\n    // We are preminting half of that value (rounded up).\n    uint256 private constant _PREMINTED_TOKEN_BALANCE = 2**(111);\n\n    // The constructor arguments are received in a struct to work around stack-too-deep issues\n    struct NewPoolParams {\n        IVault vault;\n        IProtocolFeePercentagesProvider protocolFeeProvider;\n        string name;\n        string symbol;\n        IERC20[] tokens;\n        IRateProvider[] rateProviders;\n        uint256[] tokenRateCacheDurations;\n        bool[] exemptFromYieldProtocolFeeFlags;\n        uint256 amplificationParameter;\n        uint256 swapFeePercentage;\n        uint256 pauseWindowDuration;\n        uint256 bufferPeriodDuration;\n        address owner;\n    }\n\n    constructor(NewPoolParams memory params)\n        BasePool(\n            params.vault,\n            IVault.PoolSpecialization.GENERAL,\n            params.name,\n            params.symbol,\n            _insertSorted(params.tokens, IERC20(this)),\n            new address[](params.tokens.length + 1),\n            params.swapFeePercentage,\n            params.pauseWindowDuration,\n            params.bufferPeriodDuration,\n            params.owner\n        )\n        StablePoolAmplification(params.amplificationParameter)\n        ComposableStablePoolStorage(_extractStorageParams(params))\n        ComposableStablePoolRates(_extractRatesParams(params))\n        ProtocolFeeCache(params.protocolFeeProvider, ProtocolFeeCache.DELEGATE_PROTOCOL_SWAP_FEES_SENTINEL)\n    {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    // Translate parameters to avoid stack-too-deep issues in the constructor\n    function _extractRatesParams(NewPoolParams memory params)\n        private\n        pure\n        returns (ComposableStablePoolRates.RatesParams memory)\n    {\n        return\n            ComposableStablePoolRates.RatesParams({\n                tokens: params.tokens,\n                rateProviders: params.rateProviders,\n                tokenRateCacheDurations: params.tokenRateCacheDurations\n            });\n    }\n\n    // Translate parameters to avoid stack-too-deep issues in the constructor\n    function _extractStorageParams(NewPoolParams memory params)\n        private\n        view\n        returns (ComposableStablePoolStorage.StorageParams memory)\n    {\n        return\n            ComposableStablePoolStorage.StorageParams({\n                registeredTokens: _insertSorted(params.tokens, IERC20(this)),\n                tokenRateProviders: params.rateProviders,\n                exemptFromYieldProtocolFeeFlags: params.exemptFromYieldProtocolFeeFlags\n            });\n    }\n\n    /**\n     * @notice Return the minimum BPT balance, required to avoid minimum token balances.\n     * @dev This amount is minted and immediately burned on pool initialization, so that the total supply\n     * (and therefore post-exit token balances), can never be zero. This keeps the math well-behaved when\n     * liquidity is low. (It also provides an easy way to check whether a pool has been initialized, to\n     * ensure this is only done once.)\n     */\n    function getMinimumBpt() external pure returns (uint256) {\n        return _getMinimumBpt();\n    }\n\n    // BasePool hook\n\n    /**\n     * @dev Override base pool hook invoked before any swap, join, or exit to ensure rates are updated before\n     * the operation.\n     */\n    function _beforeSwapJoinExit() internal override {\n        super._beforeSwapJoinExit();\n\n        // Before the scaling factors are read, we must update the cached rates, as those will be used to compute the\n        // scaling factors.\n        // Note that this is not done in a recovery mode exit (since _beforeSwapjoinExit() is not called under those\n        // conditions), but this is fine as recovery mode exits are unaffected by scaling factors anyway.\n        _cacheTokenRatesIfNecessary();\n    }\n\n    // Swap Hooks\n\n    /**\n     * @dev Override this hook called by the base class `onSwap`, to check whether we are doing a regular swap,\n     * or a swap involving BPT, which is equivalent to a single token join or exit. Since one of the Pool's\n     * tokens is the preminted BPT, we need to handle swaps where BPT is involved separately.\n     *\n     * At this point, the balances are unscaled. The indices are coming from the Vault, so they are indices into\n     * the array of registered tokens (including BPT).\n     *\n     * If this is a swap involving BPT, call `_swapWithBpt`, which computes the amountOut using the swapFeePercentage\n     * and charges protocol fees, in the same manner as single token join/exits. Otherwise, perform the default\n     * processing for a regular swap.\n     */\n    function _swapGivenIn(\n        SwapRequest memory swapRequest,\n        uint256[] memory registeredBalances,\n        uint256 registeredIndexIn,\n        uint256 registeredIndexOut,\n        uint256[] memory scalingFactors\n    ) internal virtual override returns (uint256) {\n        return\n            (swapRequest.tokenIn == IERC20(this) || swapRequest.tokenOut == IERC20(this))\n                ? _swapWithBpt(swapRequest, registeredBalances, registeredIndexIn, registeredIndexOut, scalingFactors)\n                : super._swapGivenIn(\n                    swapRequest,\n                    registeredBalances,\n                    registeredIndexIn,\n                    registeredIndexOut,\n                    scalingFactors\n                );\n    }\n\n    /**\n     * @dev Override this hook called by the base class `onSwap`, to check whether we are doing a regular swap,\n     * or a swap involving BPT, which is equivalent to a single token join or exit. Since one of the Pool's\n     * tokens is the preminted BPT, we need to handle swaps where BPT is involved separately.\n     *\n     * At this point, the balances are unscaled. The indices and balances are coming from the Vault, so they\n     * refer to the full set of registered tokens (including BPT).\n     *\n     * If this is a swap involving BPT, call `_swapWithBpt`, which computes the amountOut using the swapFeePercentage\n     * and charges protocol fees, in the same manner as single token join/exits. Otherwise, perform the default\n     * processing for a regular swap.\n     */\n    function _swapGivenOut(\n        SwapRequest memory swapRequest,\n        uint256[] memory registeredBalances,\n        uint256 registeredIndexIn,\n        uint256 registeredIndexOut,\n        uint256[] memory scalingFactors\n    ) internal virtual override returns (uint256) {\n        return\n            (swapRequest.tokenIn == IERC20(this) || swapRequest.tokenOut == IERC20(this))\n                ? _swapWithBpt(swapRequest, registeredBalances, registeredIndexIn, registeredIndexOut, scalingFactors)\n                : super._swapGivenOut(\n                    swapRequest,\n                    registeredBalances,\n                    registeredIndexIn,\n                    registeredIndexOut,\n                    scalingFactors\n                );\n    }\n\n    /**\n     * @dev This is called from the base class `_swapGivenIn`, so at this point the amount has been adjusted\n     * for swap fees, and balances have had scaling applied. This will only be called for regular (non-BPT) swaps,\n     * so forward to `onRegularSwap`.\n     */\n    function _onSwapGivenIn(\n        SwapRequest memory request,\n        uint256[] memory registeredBalances,\n        uint256 registeredIndexIn,\n        uint256 registeredIndexOut\n    ) internal virtual override returns (uint256) {\n        return\n            _onRegularSwap(\n                true, // given in\n                request.amount,\n                registeredBalances,\n                registeredIndexIn,\n                registeredIndexOut\n            );\n    }\n\n    /**\n     * @dev This is called from the base class `_swapGivenOut`, so at this point the amount has been adjusted\n     * for swap fees, and balances have had scaling applied. This will only be called for regular (non-BPT) swaps,\n     * so forward to `onRegularSwap`.\n     */\n    function _onSwapGivenOut(\n        SwapRequest memory request,\n        uint256[] memory registeredBalances,\n        uint256 registeredIndexIn,\n        uint256 registeredIndexOut\n    ) internal virtual override returns (uint256) {\n        return\n            _onRegularSwap(\n                false, // given out\n                request.amount,\n                registeredBalances,\n                registeredIndexIn,\n                registeredIndexOut\n            );\n    }\n\n    /**\n     * @dev Perform a swap between non-BPT tokens. Scaling and fee adjustments have been performed upstream, so\n     * all we need to do here is calculate the price quote, depending on the direction of the swap.\n     */\n    function _onRegularSwap(\n        bool isGivenIn,\n        uint256 amountGiven,\n        uint256[] memory registeredBalances,\n        uint256 registeredIndexIn,\n        uint256 registeredIndexOut\n    ) private view returns (uint256) {\n        // Adjust indices and balances for BPT token\n        uint256[] memory balances = _dropBptItem(registeredBalances);\n        uint256 indexIn = _skipBptIndex(registeredIndexIn);\n        uint256 indexOut = _skipBptIndex(registeredIndexOut);\n\n        (uint256 currentAmp, ) = _getAmplificationParameter();\n        uint256 invariant = StableMath._calculateInvariant(currentAmp, balances);\n\n        if (isGivenIn) {\n            return StableMath._calcOutGivenIn(currentAmp, balances, indexIn, indexOut, amountGiven, invariant);\n        } else {\n            return StableMath._calcInGivenOut(currentAmp, balances, indexIn, indexOut, amountGiven, invariant);\n        }\n    }\n\n    /**\n     * @dev Perform a swap involving the BPT token, equivalent to a single-token join or exit. As with the standard\n     * joins and swaps, we first pay any protocol fees pending from swaps that occurred since the previous join or\n     * exit, then perform the operation (joinSwap or exitSwap), and finally store the \"post operation\" invariant and\n     * amp, which establishes the new basis for protocol fees.\n     *\n     * At this point, the scaling factors (including rates) have been computed by the base class, but not yet applied\n     * to the balances.\n     */\n    function _swapWithBpt(\n        SwapRequest memory swapRequest,\n        uint256[] memory registeredBalances,\n        uint256 registeredIndexIn,\n        uint256 registeredIndexOut,\n        uint256[] memory scalingFactors\n    ) private returns (uint256) {\n        bool isGivenIn = swapRequest.kind == IVault.SwapKind.GIVEN_IN;\n\n        _upscaleArray(registeredBalances, scalingFactors);\n        swapRequest.amount = _upscale(\n            swapRequest.amount,\n            scalingFactors[isGivenIn ? registeredIndexIn : registeredIndexOut]\n        );\n\n        (\n            uint256 preJoinExitSupply,\n            uint256[] memory balances,\n            uint256 currentAmp,\n            uint256 preJoinExitInvariant\n        ) = _beforeJoinExit(registeredBalances);\n\n        // These calls mutate `balances` so that it holds the post join-exit balances.\n        (uint256 amountCalculated, uint256 postJoinExitSupply) = registeredIndexOut == getBptIndex()\n            ? _doJoinSwap(\n                isGivenIn,\n                swapRequest.amount,\n                balances,\n                _skipBptIndex(registeredIndexIn),\n                currentAmp,\n                preJoinExitSupply,\n                preJoinExitInvariant\n            )\n            : _doExitSwap(\n                isGivenIn,\n                swapRequest.amount,\n                balances,\n                _skipBptIndex(registeredIndexOut),\n                currentAmp,\n                preJoinExitSupply,\n                preJoinExitInvariant\n            );\n\n        _updateInvariantAfterJoinExit(\n            currentAmp,\n            balances,\n            preJoinExitInvariant,\n            preJoinExitSupply,\n            postJoinExitSupply\n        );\n\n        return\n            isGivenIn\n                ? _downscaleDown(amountCalculated, scalingFactors[registeredIndexOut]) // Amount out, round down\n                : _downscaleUp(amountCalculated, scalingFactors[registeredIndexIn]); // Amount in, round up\n    }\n\n    /**\n     * @dev This mutates `balances` so that they become the post-joinswap balances. The StableMath interfaces\n     * are different depending on the swap direction, so we forward to the appropriate low-level join function.\n     */\n    function _doJoinSwap(\n        bool isGivenIn,\n        uint256 amount,\n        uint256[] memory balances,\n        uint256 indexIn,\n        uint256 currentAmp,\n        uint256 virtualSupply,\n        uint256 preJoinExitInvariant\n    ) internal view returns (uint256, uint256) {\n        return\n            isGivenIn\n                ? _joinSwapExactTokenInForBptOut(\n                    amount,\n                    balances,\n                    indexIn,\n                    currentAmp,\n                    virtualSupply,\n                    preJoinExitInvariant\n                )\n                : _joinSwapExactBptOutForTokenIn(\n                    amount,\n                    balances,\n                    indexIn,\n                    currentAmp,\n                    virtualSupply,\n                    preJoinExitInvariant\n                );\n    }\n\n    /**\n     * @dev Since this is a join, we know the tokenOut is BPT. Since it is GivenIn, we know the tokenIn amount,\n     * and must calculate the BPT amount out.\n     * We are moving preminted BPT out of the Vault, which increases the virtual supply.\n     */\n    function _joinSwapExactTokenInForBptOut(\n        uint256 amountIn,\n        uint256[] memory balances,\n        uint256 indexIn,\n        uint256 currentAmp,\n        uint256 virtualSupply,\n        uint256 preJoinExitInvariant\n    ) internal view returns (uint256, uint256) {\n        // The StableMath function was created with joins in mind, so it expects a full amounts array. We create an\n        // empty one and only set the amount for the token involved.\n        uint256[] memory amountsIn = new uint256[](balances.length);\n        amountsIn[indexIn] = amountIn;\n\n        uint256 bptOut = StableMath._calcBptOutGivenExactTokensIn(\n            currentAmp,\n            balances,\n            amountsIn,\n            virtualSupply,\n            preJoinExitInvariant,\n            getSwapFeePercentage()\n        );\n\n        balances[indexIn] = balances[indexIn].add(amountIn);\n        uint256 postJoinExitSupply = virtualSupply.add(bptOut);\n\n        return (bptOut, postJoinExitSupply);\n    }\n\n    /**\n     * @dev Since this is a join, we know the tokenOut is BPT. Since it is GivenOut, we know the BPT amount,\n     * and must calculate the token amount in.\n     * We are moving preminted BPT out of the Vault, which increases the virtual supply.\n     */\n    function _joinSwapExactBptOutForTokenIn(\n        uint256 bptOut,\n        uint256[] memory balances,\n        uint256 indexIn,\n        uint256 currentAmp,\n        uint256 virtualSupply,\n        uint256 preJoinExitInvariant\n    ) internal view returns (uint256, uint256) {\n        uint256 amountIn = StableMath._calcTokenInGivenExactBptOut(\n            currentAmp,\n            balances,\n            indexIn,\n            bptOut,\n            virtualSupply,\n            preJoinExitInvariant,\n            getSwapFeePercentage()\n        );\n\n        balances[indexIn] = balances[indexIn].add(amountIn);\n        uint256 postJoinExitSupply = virtualSupply.add(bptOut);\n\n        return (amountIn, postJoinExitSupply);\n    }\n\n    /**\n     * @dev This mutates balances so that they become the post-exitswap balances. The StableMath interfaces are\n     * different depending on the swap direction, so we forward to the appropriate low-level exit function.\n     */\n    function _doExitSwap(\n        bool isGivenIn,\n        uint256 amount,\n        uint256[] memory balances,\n        uint256 indexOut,\n        uint256 currentAmp,\n        uint256 virtualSupply,\n        uint256 preJoinExitInvariant\n    ) internal view returns (uint256, uint256) {\n        return\n            isGivenIn\n                ? _exitSwapExactBptInForTokenOut(\n                    amount,\n                    balances,\n                    indexOut,\n                    currentAmp,\n                    virtualSupply,\n                    preJoinExitInvariant\n                )\n                : _exitSwapExactTokenOutForBptIn(\n                    amount,\n                    balances,\n                    indexOut,\n                    currentAmp,\n                    virtualSupply,\n                    preJoinExitInvariant\n                );\n    }\n\n    /**\n     * @dev Since this is an exit, we know the tokenIn is BPT. Since it is GivenIn, we know the BPT amount,\n     * and must calculate the token amount out.\n     * We are moving BPT out of circulation and into the Vault, which decreases the virtual supply.\n     */\n    function _exitSwapExactBptInForTokenOut(\n        uint256 bptAmount,\n        uint256[] memory balances,\n        uint256 indexOut,\n        uint256 currentAmp,\n        uint256 virtualSupply,\n        uint256 preJoinExitInvariant\n    ) internal view returns (uint256, uint256) {\n        uint256 amountOut = StableMath._calcTokenOutGivenExactBptIn(\n            currentAmp,\n            balances,\n            indexOut,\n            bptAmount,\n            virtualSupply,\n            preJoinExitInvariant,\n            getSwapFeePercentage()\n        );\n\n        balances[indexOut] = balances[indexOut].sub(amountOut);\n        uint256 postJoinExitSupply = virtualSupply.sub(bptAmount);\n\n        return (amountOut, postJoinExitSupply);\n    }\n\n    /**\n     * @dev Since this is an exit, we know the tokenIn is BPT. Since it is GivenOut, we know the token amount out,\n     * and must calculate the BPT amount in.\n     * We are moving BPT out of circulation and into the Vault, which decreases the virtual supply.\n     */\n    function _exitSwapExactTokenOutForBptIn(\n        uint256 amountOut,\n        uint256[] memory balances,\n        uint256 indexOut,\n        uint256 currentAmp,\n        uint256 virtualSupply,\n        uint256 preJoinExitInvariant\n    ) internal view returns (uint256, uint256) {\n        // The StableMath function was created with exits in mind, so it expects a full amounts array. We create an\n        // empty one and only set the amount for the token involved.\n        uint256[] memory amountsOut = new uint256[](balances.length);\n        amountsOut[indexOut] = amountOut;\n\n        uint256 bptAmount = StableMath._calcBptInGivenExactTokensOut(\n            currentAmp,\n            balances,\n            amountsOut,\n            virtualSupply,\n            preJoinExitInvariant,\n            getSwapFeePercentage()\n        );\n\n        balances[indexOut] = balances[indexOut].sub(amountOut);\n        uint256 postJoinExitSupply = virtualSupply.sub(bptAmount);\n\n        return (bptAmount, postJoinExitSupply);\n    }\n\n    // Join Hooks\n\n    /**\n     * Since this Pool has preminted BPT which is stored in the Vault, it cannot simply be minted at construction.\n     *\n     * We take advantage of the fact that StablePools have an initialization step where BPT is minted to the first\n     * account joining them, and perform both actions at once. By minting the entire BPT supply for the initial joiner\n     * and then pulling all tokens except those due the joiner, we arrive at the desired state of the Pool holding all\n     * BPT except the joiner's.\n     */\n    function _onInitializePool(\n        bytes32,\n        address sender,\n        address,\n        uint256[] memory scalingFactors,\n        bytes memory userData\n    ) internal override returns (uint256, uint256[] memory) {\n        StablePoolUserData.JoinKind kind = userData.joinKind();\n        _require(kind == StablePoolUserData.JoinKind.INIT, Errors.UNINITIALIZED);\n\n        // AmountsIn usually does not include the BPT token; initialization is the one time it has to.\n        uint256[] memory amountsInIncludingBpt = userData.initialAmountsIn();\n        InputHelpers.ensureInputLengthMatch(amountsInIncludingBpt.length, scalingFactors.length);\n        _upscaleArray(amountsInIncludingBpt, scalingFactors);\n\n        (uint256 amp, ) = _getAmplificationParameter();\n        uint256[] memory amountsIn = _dropBptItem(amountsInIncludingBpt);\n        uint256 invariantAfterJoin = StableMath._calculateInvariant(amp, amountsIn);\n\n        // Set the initial BPT to the value of the invariant\n        uint256 bptAmountOut = invariantAfterJoin;\n\n        // BasePool will mint bptAmountOut for the sender: we then also mint the remaining BPT to make up the total\n        // supply, and have the Vault pull those tokens from the sender as part of the join.\n        // We are only minting half of the maximum value - already an amount many orders of magnitude greater than any\n        // conceivable real liquidity - to allow for minting new BPT as a result of regular joins.\n        //\n        // Note that the sender need not approve BPT for the Vault as the Vault already has infinite BPT allowance for\n        // all accounts.\n        uint256 initialBpt = _PREMINTED_TOKEN_BALANCE.sub(bptAmountOut);\n\n        _mintPoolTokens(sender, initialBpt);\n        amountsInIncludingBpt[getBptIndex()] = initialBpt;\n\n        // Initialization is still a join, so we need to do post-join work.\n        _updatePostJoinExit(amp, invariantAfterJoin);\n\n        return (bptAmountOut, amountsInIncludingBpt);\n    }\n\n    /**\n     * @dev Base pool hook called from `onJoinPool`. Forward to `onJoinExitPool` with `isJoin` set to true.\n     */\n    function _onJoinPool(\n        bytes32,\n        address,\n        address,\n        uint256[] memory registeredBalances,\n        uint256,\n        uint256,\n        uint256[] memory scalingFactors,\n        bytes memory userData\n    ) internal override returns (uint256, uint256[] memory) {\n        return _onJoinExitPool(true, registeredBalances, scalingFactors, userData);\n    }\n\n    /**\n     * @dev Base pool hook called from `onExitPool`. Forward to `onJoinExitPool` with `isJoin` set to false.\n     * Note that recovery mode exits do not call `_onExitPool`.\n     */\n    function _onExitPool(\n        bytes32,\n        address,\n        address,\n        uint256[] memory registeredBalances,\n        uint256,\n        uint256,\n        uint256[] memory scalingFactors,\n        bytes memory userData\n    ) internal override returns (uint256, uint256[] memory) {\n        return _onJoinExitPool(false, registeredBalances, scalingFactors, userData);\n    }\n\n    /**\n     * @dev Pay protocol fees before the operation, and call `_updateInvariantAfterJoinExit` afterward, to establish\n     * the new basis for protocol fees.\n     */\n    function _onJoinExitPool(\n        bool isJoin,\n        uint256[] memory registeredBalances,\n        uint256[] memory scalingFactors,\n        bytes memory userData\n    ) internal returns (uint256, uint256[] memory) {\n        (\n            uint256 preJoinExitSupply,\n            uint256[] memory balances,\n            uint256 currentAmp,\n            uint256 preJoinExitInvariant\n        ) = _beforeJoinExit(registeredBalances);\n\n\n            function(uint256[] memory, uint256, uint256, uint256, uint256[] memory, bytes memory)\n                internal\n                view\n                returns (uint256, uint256[] memory) _doJoinOrExit\n         = (isJoin ? _doJoin : _doExit);\n\n        (uint256 bptAmount, uint256[] memory amountsDelta) = _doJoinOrExit(\n            balances,\n            currentAmp,\n            preJoinExitSupply,\n            preJoinExitInvariant,\n            scalingFactors,\n            userData\n        );\n\n        // Unlike joinswaps, explicit joins do not mutate balances into the post join-exit balances so we must perform\n        // this mutation here.\n        function(uint256, uint256) internal pure returns (uint256) _addOrSub = isJoin ? FixedPoint.add : FixedPoint.sub;\n        _mutateAmounts(balances, amountsDelta, _addOrSub);\n        uint256 postJoinExitSupply = _addOrSub(preJoinExitSupply, bptAmount);\n\n        // Pass in the post-join balances to reset the protocol fee basis.\n        // We are minting bptAmount, increasing the total (and virtual) supply post-join\n        _updateInvariantAfterJoinExit(\n            currentAmp,\n            balances,\n            preJoinExitInvariant,\n            preJoinExitSupply,\n            postJoinExitSupply\n        );\n\n        // For clarity and simplicity, arrays used and computed in lower level functions do not include BPT.\n        // But the amountsIn array passed back to the Vault must include BPT, so we add it back in here.\n        return (bptAmount, _addBptItem(amountsDelta, 0));\n    }\n\n    /**\n     * @dev Pay any due protocol fees and calculate values necessary for performing the join/exit.\n     */\n    function _beforeJoinExit(uint256[] memory registeredBalances)\n        internal\n        returns (\n            uint256,\n            uint256[] memory,\n            uint256,\n            uint256\n        )\n    {\n        (uint256 lastJoinExitAmp, uint256 lastPostJoinExitInvariant) = getLastJoinExitData();\n        (\n            uint256 preJoinExitSupply,\n            uint256[] memory balances,\n            uint256 oldAmpPreJoinExitInvariant\n        ) = _payProtocolFeesBeforeJoinExit(registeredBalances, lastJoinExitAmp, lastPostJoinExitInvariant)"
    }
  ]
}