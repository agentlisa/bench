{
  "Title": "Possible arithmetic overflow",
  "Content": "##### Description\nAt the line https://github.com/1inch/farming/blob/7a007ec7784cca2899889e99e46cf06d5788a7d9/contracts/accounting/UserAccounting.sol#L29 the number with the type `int256` is converted to the number with the type `uint256`. The number is taken with a minus sign.\nBut before that, there is no check that the number is less than 0.\nIf we take a small positive value and apply the transformation `uint256(-amount)` to it, we get a very large value due to arithmetic overflow.\nFor example, if you take number `1000`, then after conversion you get value` 115792089237316195423570985008687907853269984665640564039457584007913129638936`.\n\n##### Recommendation\nBefore line 29 you need to check if the value of the variable is not less than 0.\n If the value of the variable is positive, then do not do the conversion.\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/accounting/UserAccounting.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary UserAccounting {\n    struct Info {\n        uint40 checkpoint;\n        uint216 farmedPerTokenStored;\n        mapping(address => int256) corrections;\n    }\n\n    function farmedPerToken(\n        Info storage info,\n        address context,\n        function(address) internal view returns(uint256) lazyGetSupply,\n        function(address, uint256) internal view returns(uint256) lazyGetFarmed\n    ) internal view returns(uint256) {\n        (uint256 checkpoint, uint256 fpt) = (info.checkpoint, info.farmedPerTokenStored);\n        if (block.timestamp != checkpoint) {\n            uint256 supply = lazyGetSupply(context);\n            if (supply > 0) {\n                fpt += lazyGetFarmed(context, checkpoint) / supply;\n            }\n        }\n        return fpt;\n    }\n\n    function farmed(Info storage info, address account, uint256 balance, uint256 fpt) internal view returns(uint256) {\n        return uint256(int256(balance * fpt) - info.corrections[account]) / 1e18;\n    }\n\n    function eraseFarmed(Info storage info, address account, uint256 balance, uint256 fpt) internal {\n        info.corrections[account] = int256(balance * fpt);\n    }\n\n    function updateCheckpoint(Info storage info, uint256 fpt) internal {\n        (info.checkpoint, info.farmedPerTokenStored) = (uint40(block.timestamp), uint216(fpt));\n    }\n\n    function updateBalances(Info storage info, uint256 fpt, address from, address to, uint256 amount, bool inFrom, bool inTo) internal {\n        if (amount > 0 && (inFrom || inTo)) {\n            if (inFrom != inTo) {\n                updateCheckpoint(info, fpt);\n            }\n            if (inFrom) {\n                info.corrections[from] -= int256(amount * fpt);\n            }\n            if (inTo) {\n                info.corrections[to] += int256(amount * fpt);\n            }\n        }\n    }\n}"
    }
  ]
}