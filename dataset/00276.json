{
  "Title": "Disabled Transceivers cannot be re-enabled by calling `TransceiverRegistry::_setTransceiver` after 64 have been registered",
  "Content": "**Description:** [`TransceiverRegistry::_setTransceiver`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/NttManager/TransceiverRegistry.sol#L112-L153) handles the registering of Transceivers, but note that they cannot be re-registered as this has other downstream effects, so this function is also responsible for the re-enabling of previously registered but currently disabled Transceivers.\n```solidity\nfunction _setTransceiver(address transceiver) internal returns (uint8 index) {\n    /* snip */\n    if (transceiver == address(0)) {\n        revert InvalidTransceiverZeroAddress();\n    }\n\n    if (_numTransceivers.registered >= MAX_TRANSCEIVERS) {\n        revert TooManyTransceivers();\n    }\n\n    if (transceiverInfos[transceiver].registered) {\n        transceiverInfos[transceiver].enabled = true;\n    } else {\n    /* snip */\n}\n```\n\nThis function reverts if the passed transceiver address is `address(0)` or the number of registered transceivers is already at its defined maximum of 64. Assuming a total of 64 registered Transceivers, with some of these Transceivers having been previously disabled, the placement of this latter validation will prevent a disabled Transceiver from being re-enabled since the subsequent block in which the storage indicating its enabled state is set to `true` is not reachable. Consequently, it will not be possible to re-enable any disabled transceivers after having registered the maximum number of Transceivers, meaning that this function will never be callable without redeployment.\n\n**Impact:** Under normal circumstances, this maximum number of registered Transceivers should never be reached, especially since the underlying Transceivers are upgradeable. However, while unlikely based on operational assumptions, this undefined behavior could have a high impact, and so this is classified as a **MEDIUM** severity finding.\n\n**Recommended Mitigation:** Move the placement of the maximum Transceivers validation to within the `else` block that is responsible for handling the registration of new Transceivers.\n\n**Wormhole Foundation:** Fixed in [PR \\#253](https://github.com/wormhole-foundation/example-native-token-transfers/pull/253).\n\n**Cyfrin:** Verified. The validation is now skipped for previously registered (but currently disabled) Transceivers.",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "evm/src/NttManager/TransceiverRegistry.sol",
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity >=0.8.8 <0.9.0;\n\n/// @dev This contract is responsible for handling the registration of Transceivers.\nabstract contract TransceiverRegistry {\n    constructor() {\n        _checkTransceiversInvariants();\n    }\n\n    /// @dev Information about registered transceivers.\n    struct TransceiverInfo {\n        // whether this transceiver is registered\n        bool registered;\n        // whether this transceiver is enabled\n        bool enabled;\n        uint8 index;\n    }\n\n    /// @dev Bitmap encoding the enabled transceivers.\n    /// invariant: forall (i: uint8), enabledTransceiverBitmap & i == 1 <=> transceiverInfos[i].enabled\n    struct _EnabledTransceiverBitmap {\n        uint64 bitmap;\n    }\n\n    /// @dev Total number of registered transceivers. This number can only increase.\n    /// invariant: numRegisteredTransceivers <= MAX_TRANSCEIVERS\n    /// invariant: forall (i: uint8),\n    ///   i < numRegisteredTransceivers <=> exists (a: address), transceiverInfos[a].index == i\n    struct _NumTransceivers {\n        uint8 registered;\n        uint8 enabled;\n    }\n\n    uint8 constant MAX_TRANSCEIVERS = 64;\n\n    error CallerNotTransceiver(address caller);\n    error InvalidTransceiverZeroAddress();\n    error DisabledTransceiver(address transceiver);\n    error TooManyTransceivers();\n    error NonRegisteredTransceiver(address transceiver);\n    error TransceiverAlreadyEnabled(address transceiver);\n\n    modifier onlyTransceiver() {\n        if (!_getTransceiverInfosStorage()[msg.sender].enabled) {\n            revert CallerNotTransceiver(msg.sender);\n        }\n        _;\n    }\n\n    // =============== Storage ===============================================\n\n    bytes32 private constant TRANSCEIVER_INFOS_SLOT =\n        bytes32(uint256(keccak256(\"ntt.transceiverInfos\")) - 1);\n\n    bytes32 private constant TRANSCEIVER_BITMAP_SLOT =\n        bytes32(uint256(keccak256(\"ntt.transceiverBitmap\")) - 1);\n\n    bytes32 private constant ENABLED_TRANSCEIVERS_SLOT =\n        bytes32(uint256(keccak256(\"ntt.enabledTransceivers\")) - 1);\n\n    bytes32 private constant REGISTERED_TRANSCEIVERS_SLOT =\n        bytes32(uint256(keccak256(\"ntt.registeredTransceivers\")) - 1);\n\n    bytes32 private constant NUM_REGISTERED_TRANSCEIVERS_SLOT =\n        bytes32(uint256(keccak256(\"ntt.numRegisteredTransceivers\")) - 1);\n\n    function _getTransceiverInfosStorage()\n        internal\n        pure\n        returns (mapping(address => TransceiverInfo) storage $)\n    {\n        uint256 slot = uint256(TRANSCEIVER_INFOS_SLOT);\n        assembly (\"memory-safe\") {\n            $.slot := slot\n        }\n    }\n\n    function _getEnabledTransceiversStorage() internal pure returns (address[] storage $) {\n        uint256 slot = uint256(ENABLED_TRANSCEIVERS_SLOT);\n        assembly (\"memory-safe\") {\n            $.slot := slot\n        }\n    }\n\n    function _getTransceiverBitmapStorage()\n        private\n        pure\n        returns (_EnabledTransceiverBitmap storage $)\n    {\n        uint256 slot = uint256(TRANSCEIVER_BITMAP_SLOT);\n        assembly (\"memory-safe\") {\n            $.slot := slot\n        }\n    }\n\n    function _getRegisteredTransceiversStorage() internal pure returns (address[] storage $) {\n        uint256 slot = uint256(REGISTERED_TRANSCEIVERS_SLOT);\n        assembly (\"memory-safe\") {\n            $.slot := slot\n        }\n    }\n\n    function _getNumTransceiversStorage() internal pure returns (_NumTransceivers storage $) {\n        uint256 slot = uint256(NUM_REGISTERED_TRANSCEIVERS_SLOT);\n        assembly (\"memory-safe\") {\n            $.slot := slot\n        }\n    }\n\n    // =============== Storage Getters/Setters ========================================\n\n    function _setTransceiver(address transceiver) internal returns (uint8 index) {\n        mapping(address => TransceiverInfo) storage transceiverInfos = _getTransceiverInfosStorage();\n        _EnabledTransceiverBitmap storage _enabledTransceiverBitmap = _getTransceiverBitmapStorage();\n        address[] storage _enabledTransceivers = _getEnabledTransceiversStorage();\n\n        _NumTransceivers storage _numTransceivers = _getNumTransceiversStorage();\n\n        if (transceiver == address(0)) {\n            revert InvalidTransceiverZeroAddress();\n        }\n\n        if (_numTransceivers.registered >= MAX_TRANSCEIVERS) {\n            revert TooManyTransceivers();\n        }\n\n        if (transceiverInfos[transceiver].registered) {\n            transceiverInfos[transceiver].enabled = true;\n        } else {\n            transceiverInfos[transceiver] = TransceiverInfo({\n                registered: true,\n                enabled: true,\n                index: _numTransceivers.registered\n            });\n            _numTransceivers.registered++;\n            _getRegisteredTransceiversStorage().push(transceiver);\n        }\n\n        _enabledTransceivers.push(transceiver);\n        _numTransceivers.enabled++;\n\n        uint64 updatedEnabledTransceiverBitmap =\n            _enabledTransceiverBitmap.bitmap | uint64(1 << transceiverInfos[transceiver].index);\n        // ensure that this actually changed the bitmap\n        if (updatedEnabledTransceiverBitmap == _enabledTransceiverBitmap.bitmap) {\n            revert TransceiverAlreadyEnabled(transceiver);\n        }\n        _enabledTransceiverBitmap.bitmap = updatedEnabledTransceiverBitmap;\n\n        _checkTransceiversInvariants();\n\n        return transceiverInfos[transceiver].index;\n    }\n\n    function _removeTransceiver(address transceiver) internal {\n        mapping(address => TransceiverInfo) storage transceiverInfos = _getTransceiverInfosStorage();\n        _EnabledTransceiverBitmap storage _enabledTransceiverBitmap = _getTransceiverBitmapStorage();\n        address[] storage _enabledTransceivers = _getEnabledTransceiversStorage();\n\n        if (transceiver == address(0)) {\n            revert InvalidTransceiverZeroAddress();\n        }\n\n        if (!transceiverInfos[transceiver].registered) {\n            revert NonRegisteredTransceiver(transceiver);\n        }\n\n        if (!transceiverInfos[transceiver].enabled) {\n            revert DisabledTransceiver(transceiver);\n        }\n\n        transceiverInfos[transceiver].enabled = false;\n        _getNumTransceiversStorage().enabled--;\n\n        uint64 updatedEnabledTransceiverBitmap =\n            _enabledTransceiverBitmap.bitmap & uint64(~(1 << transceiverInfos[transceiver].index));\n        // ensure that this actually changed the bitmap\n        assert(updatedEnabledTransceiverBitmap < _enabledTransceiverBitmap.bitmap);\n        _enabledTransceiverBitmap.bitmap = updatedEnabledTransceiverBitmap;\n\n        bool removed = false;\n\n        uint256 numEnabledTransceivers = _enabledTransceivers.length;\n        for (uint256 i = 0; i < numEnabledTransceivers; i++) {\n            if (_enabledTransceivers[i] == transceiver) {\n                _enabledTransceivers[i] = _enabledTransceivers[numEnabledTransceivers - 1];\n                _enabledTransceivers.pop();\n                removed = true;\n                break;\n            }\n        }\n        assert(removed);\n\n        _checkTransceiversInvariants();\n        // we call the invariant check on the transceiver here as well, since\n        // the above check only iterates through the enabled transceivers.\n        _checkTransceiverInvariants(transceiver);\n    }\n\n    function _getEnabledTransceiversBitmap() internal view virtual returns (uint64 bitmap) {\n        return _getTransceiverBitmapStorage().bitmap;\n    }\n\n    /// @notice Returns the Transceiver contracts that have been registered via governance.\n    function getTransceivers() external pure returns (address[] memory result) {\n        result = _getEnabledTransceiversStorage();\n    }\n\n    // ============== Invariants =============================================\n\n    /// @dev Check that the transceiver nttManager is in a valid state.\n    /// Checking these invariants is somewhat costly, but we only need to do it\n    /// when modifying the transceivers, which happens infrequently.\n    function _checkTransceiversInvariants() internal view {\n        _NumTransceivers storage _numTransceivers = _getNumTransceiversStorage();\n        address[] storage _enabledTransceivers = _getEnabledTransceiversStorage();\n\n        uint256 numTransceiversEnabled = _numTransceivers.enabled;\n        assert(numTransceiversEnabled == _enabledTransceivers.length);\n\n        for (uint256 i = 0; i < numTransceiversEnabled; i++) {\n            _checkTransceiverInvariants(_enabledTransceivers[i]);\n        }\n\n        // invariant: each transceiver is only enabled once\n        for (uint256 i = 0; i < numTransceiversEnabled; i++) {\n            for (uint256 j = i + 1; j < numTransceiversEnabled; j++) {\n                assert(_enabledTransceivers[i] != _enabledTransceivers[j]);\n            }\n        }\n\n        // invariant: numRegisteredTransceivers <= MAX_TRANSCEIVERS\n        assert(_numTransceivers.registered <= MAX_TRANSCEIVERS);\n    }\n\n    // @dev Check that the transceiver is in a valid state.\n    function _checkTransceiverInvariants(address transceiver) private view {\n        mapping(address => TransceiverInfo) storage transceiverInfos = _getTransceiverInfosStorage();\n        _EnabledTransceiverBitmap storage _enabledTransceiverBitmap = _getTransceiverBitmapStorage();\n        _NumTransceivers storage _numTransceivers = _getNumTransceiversStorage();\n        address[] storage _enabledTransceivers = _getEnabledTransceiversStorage();\n\n        TransceiverInfo memory transceiverInfo = transceiverInfos[transceiver];\n\n        // if an transceiver is not registered, it should not be enabled\n        assert(\n            transceiverInfo.registered || (!transceiverInfo.enabled && transceiverInfo.index == 0)\n        );\n\n        bool transceiverInEnabledBitmap =\n            (_enabledTransceiverBitmap.bitmap & uint64(1 << transceiverInfo.index)) != 0;\n        bool transceiverEnabled = transceiverInfo.enabled;\n\n        bool transceiverInEnabledTransceivers = false;\n\n        for (uint256 i = 0; i < _numTransceivers.enabled; i++) {\n            if (_enabledTransceivers[i] == transceiver) {\n                transceiverInEnabledTransceivers = true;\n                break;\n            }\n        }\n\n        // invariant: transceiverInfos[transceiver].enabled\n        //            <=> enabledTransceiverBitmap & (1 << transceiverInfos[transceiver].index) != 0\n        assert(transceiverInEnabledBitmap == transceiverEnabled);\n\n        // invariant: transceiverInfos[transceiver].enabled <=> transceiver in _enabledTransceivers\n        assert(transceiverInEnabledTransceivers == transceiverEnabled);\n\n        assert(transceiverInfo.index < _numTransceivers.registered);\n    }\n}"
    }
  ]
}