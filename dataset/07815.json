{
  "Title": "[M-11] viewPrice doesnâ€™t always report dampened price",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Oracle.sol#L91\n\n\n# Vulnerability details\n\n## Impact\nOracle's `viewPrice` function doesn't report a dampened price until `getPrice` is called and today's price is updated. This will impact the public read-only functions that call it:\n- [getCollateralValue](https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L312);\n- [getCreditLimit](https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L334) (calls `getCollateralValue`);\n- [getLiquidatableDebt](https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L578) (calls `getCreditLimit`);\n- [getWithdrawalLimit](https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L370).\n\nThese functions are used to get on-chain state and prepare values for write calls (e.g. calculate withdrawal amount before withdrawing or calculate a user's debt that can be liquidated before liquidating it). Thus, wrong values returned by these functions can cause withdrawal of a wrong amount or liquidation of a wrong debt or cause reverts.\n## Proof of Concept\n```solidity\n// src/test/Oracle.t.sol\nfunction test_viewPriceNoDampenedPrice_AUDIT() public {\n    uint collateralFactor = market.collateralFactorBps();\n    uint day = block.timestamp / 1 days;\n    uint feedPrice = ethFeed.latestAnswer();\n\n    //1600e18 price saved as daily low\n    oracle.getPrice(address(WETH), collateralFactor);\n    assertEq(oracle.dailyLows(address(WETH), day), feedPrice);\n\n    vm.warp(block.timestamp + 1 days);\n    uint newPrice = 1200e18;\n    ethFeed.changeAnswer(newPrice);\n    //1200e18 price saved as daily low\n    oracle.getPrice(address(WETH), collateralFactor);\n    assertEq(oracle.dailyLows(address(WETH), ++day), newPrice);\n\n    vm.warp(block.timestamp + 1 days);\n    newPrice = 3000e18;\n    ethFeed.changeAnswer(newPrice);\n\n    //1200e18 should be twoDayLow, 3000e18 is current price. We should receive dampened price here.\n    // Notice that viewPrice is called before getPrice.\n    uint viewPrice = oracle.viewPrice(address(WETH), collateralFactor);\n    uint price = oracle.getPrice(address(WETH), collateralFactor);\n    assertEq(oracle.dailyLows(address(WETH), ++day), newPrice);\n\n    assertEq(price, 1200e18 * 10_000 / collateralFactor);\n\n    // View price wasn't dampened.\n    assertEq(viewPrice, 3000e18);\n}\n```\n## Tools Used\nManual review\n## Recommended Mitigation Steps\nConsider this change:\n```diff\n--- a/src/Oracle.sol\n+++ b/src/Oracle.sol\n@@ -89,6 +89,9 @@ contract Oracle {\n             uint day = block.timestamp / 1 days;\n             // get today's low\n             uint todaysLow = dailyLows[token][day];\n+            if(todaysLow == 0 || normalizedPrice < todaysLow) {\n+                todaysLow = normalizedPrice;\n+            }\n             // get yesterday's low\n             uint yesterdaysLow = dailyLows[token][day - 1];\n             // calculate new borrowing power based on collateral factor\n```",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-10-inverse-finance-contest",
  "Code": [
    {
      "filename": "src/Oracle.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\ninterface IChainlinkFeed {\n    function decimals() external view returns (uint8);\n    function latestAnswer() external view returns (uint);\n}\n\n/**\n@title Oracle\n@notice Oracle used by markets. Can use both fixed price feeds and Chainlink-style feeds for prices.\nThe Pessimistic Oracle introduces collateral factor into the pricing formula. It ensures that any given oracle price is dampened to prevent borrowers from borrowing more than the lowest recorded value of their collateral over the past 2 days.\nThis has the advantage of making price manipulation attacks more difficult, as an attacker needs to log artificially high lows.\nIt has the disadvantage of reducing borrow power of borrowers to a 2-day minimum value of their collateral, where the value must have been seen by the oracle.\n*/\ncontract Oracle {\n\n    struct FeedData {\n        IChainlinkFeed feed;\n        uint8 tokenDecimals;\n    }\n\n    address public operator;\n    address public pendingOperator;\n    mapping (address => FeedData) public feeds;\n    mapping (address => uint) public fixedPrices;\n    mapping (address => mapping(uint => uint)) public dailyLows; // token => day => price\n\n    constructor(\n        address _operator\n    ) {\n        operator = _operator;\n    }\n\n    modifier onlyOperator {\n        require(msg.sender == operator, \"ONLY OPERATOR\");\n        _;\n    }\n    \n    /**\n    @notice Sets the pending operator of the oracle. Only callable by operator.\n    @param newOperator_ The address of the pending operator.\n    */\n    function setPendingOperator(address newOperator_) public onlyOperator { pendingOperator = newOperator_; }\n\n    /**\n    @notice Sets the price feed of a specific token address.\n    @dev Even though the price feeds implement the chainlink interface, it's possible to use other price oracle.\n    @param token Address of the ERC20 token to set a feed for\n    @param feed The chainlink feed of the ERC20 token.\n    @param tokenDecimals uint8 representing the decimal precision of the token\n    */\n    function setFeed(address token, IChainlinkFeed feed, uint8 tokenDecimals) public onlyOperator { feeds[token] = FeedData(feed, tokenDecimals); }\n\n    /**\n    @notice Sets a fixed price for a token\n    @dev Be careful when setting this. Assuming a fixed price where one doesn't exist can have disastrous consequences.\n    @param token The address of the fixed price token\n    @param price The fixed price of the token. Remember to account for decimal precision when setting this.\n    */\n    function setFixedPrice(address token, uint price) public onlyOperator { fixedPrices[token] = price; }\n\n    /**\n    @notice Claims the operator role. Only successfully callable by the pending operator.\n    */\n    function claimOperator() public {\n        require(msg.sender == pendingOperator, \"ONLY PENDING OPERATOR\");\n        operator = pendingOperator;\n        pendingOperator = address(0);\n        emit ChangeOperator(operator);\n    }\n\n    /**\n    @notice Gets the price of a specific token in DOLA\n    @param token The address of the token to get price of\n    @return The price of the token in DOLA, adjusted for token and feed decimals\n    */\n    function viewPrice(address token, uint collateralFactorBps) external view returns (uint) {\n        if(fixedPrices[token] > 0) return fixedPrices[token];\n        if(feeds[token].feed != IChainlinkFeed(address(0))) {\n            // get price from feed\n            uint price = feeds[token].feed.latestAnswer();\n            require(price > 0, \"Invalid feed price\");\n            // normalize price\n            uint8 feedDecimals = feeds[token].feed.decimals();\n            uint8 tokenDecimals = feeds[token].tokenDecimals;\n            uint8 decimals = 36 - feedDecimals - tokenDecimals;\n            uint normalizedPrice = price * (10 ** decimals);\n            uint day = block.timestamp / 1 days;\n            // get today's low\n            uint todaysLow = dailyLows[token][day];\n            // get yesterday's low\n            uint yesterdaysLow = dailyLows[token][day - 1];\n            // calculate new borrowing power based on collateral factor\n            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;\n            uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;\n            if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {\n                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;\n                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;\n            }\n            return normalizedPrice;\n\n        }\n        revert(\"Price not found\");\n    }\n\n    /**\n    @notice Gets the price of a specific token in DOLA while also saving the price if it is the day's lowest.\n    @param token The address of the token to get price of\n    @return The price of the token in DOLA, adjusted for token and feed decimals\n    */\n    function getPrice(address token, uint collateralFactorBps) external returns (uint) {\n        if(fixedPrices[token] > 0) return fixedPrices[token];\n        if(feeds[token].feed != IChainlinkFeed(address(0))) {\n            // get price from feed\n            uint price = feeds[token].feed.latestAnswer();\n            require(price > 0, \"Invalid feed price\");\n            // normalize price\n            uint8 feedDecimals = feeds[token].feed.decimals();\n            uint8 tokenDecimals = feeds[token].tokenDecimals;\n            uint8 decimals = 36 - feedDecimals - tokenDecimals;\n            uint normalizedPrice = price * (10 ** decimals);\n            // potentially store price as today's low\n            uint day = block.timestamp / 1 days;\n            uint todaysLow = dailyLows[token][day];\n            if(todaysLow == 0 || normalizedPrice < todaysLow) {\n                dailyLows[token][day] = normalizedPrice;\n                todaysLow = normalizedPrice;\n                emit RecordDailyLow(token, normalizedPrice);\n            }\n            // get yesterday's low\n            uint yesterdaysLow = dailyLows[token][day - 1];\n            // calculate new borrowing power based on collateral factor\n            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;\n            uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;\n            if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {\n                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;\n                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;\n            }\n            return normalizedPrice;\n\n        }\n        revert(\"Price not found\");\n    }\n\n    event ChangeOperator(address indexed newOperator);\n    event RecordDailyLow(address indexed token, uint price);\n\n}"
    }
  ]
}