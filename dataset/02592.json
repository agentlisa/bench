{
  "Title": "Funds held in ETHAdapter can be drained by anyone",
  "Content": "The [`ETHAdapter`](https://github.com/pods-finance/yield-contracts/blob/c4b401ce674c24798de5f9d02c82e466ee0a2600/contracts/proxy/ETHAdapter.sol) contract is used as a proxy to allow users to interact with the vault through sending and receiving ETH instead of stETH. In the course of a normal [withdrawal](https://github.com/pods-finance/yield-contracts/blob/c4b401ce674c24798de5f9d02c82e466ee0a2600/contracts/proxy/ETHAdapter.sol#L72) or [redemption](https://github.com/pods-finance/yield-contracts/blob/c4b401ce674c24798de5f9d02c82e466ee0a2600/contracts/proxy/ETHAdapter.sol#L47) transaction, the `ETHAdapter` will pull the funds out of the vault before passing them onto the designated receiver. During the moment the `ETHAdapter` is holding the funds, it first [converts](https://github.com/pods-finance/yield-contracts/blob/c4b401ce674c24798de5f9d02c82e466ee0a2600/contracts/proxy/ETHAdapter.sol#L111-L113) all of its stETH to ETH, and then sends its entire ETH balance to the receiving address.\n\n\nConsequently, the `ETHAdapter` sends its full balance to the receiver each time, meaning any ETH or stETH that is mistakenly sent to it can be drained by any user who performs a withdrawal or redemption on the `ETHAdapter`. This is exacerbated by the fact that the vault is passed in as a [parameter](https://github.com/pods-finance/yield-contracts/blob/c4b401ce674c24798de5f9d02c82e466ee0a2600/contracts/proxy/ETHAdapter.sol#L73), potentially allowing a user to perform withdrawals and redemptions without interacting with the actual stETH vault.\n\n\nConsider transferring the exchanged balance from the Curve pool to the receiver instead of the entire balance of the `ETHAdapter`. Also consider implementing a rescue or sweep function to allow the recovery of funds that are accidentally sent to the `ETHAdapter`.\n\n\n***Update:** Acknowledged, not resolved. Pods Finance team stated:*\n\n\n\n> *For now, we do not want to take action in case of funds sent by mistake to our contract. We will prioritize this issue in a future version.*\n> \n> \n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/proxy/ETHAdapter.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { ICurvePool } from \"../interfaces/ICurvePool.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\ncontract ETHAdapter {\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n\n    ICurvePool public immutable pool;\n\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant STETH_ADDRESS = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;\n\n    error ETHAdapter__IncompatibleVault();\n    error ETHAdapter__IncompatiblePool();\n\n    constructor(ICurvePool _pool) {\n        if (_pool.coins(0) != ETH_ADDRESS || _pool.coins(1) != STETH_ADDRESS) revert ETHAdapter__IncompatiblePool();\n        pool = _pool;\n    }\n\n    function convertToSTETH(uint256 ethAmount) external view returns (uint256) {\n        return pool.get_dy(0, 1, ethAmount);\n    }\n\n    function convertToETH(uint256 stETHAmount) external view returns (uint256) {\n        return pool.get_dy(1, 0, stETHAmount);\n    }\n\n    function deposit(\n        IVault vault,\n        address receiver,\n        uint256 minOutput\n    ) external payable returns (uint256 shares) {\n        if (vault.asset() != STETH_ADDRESS) revert ETHAdapter__IncompatibleVault();\n        uint256 assets = pool.exchange{ value: msg.value }(0, 1, msg.value, minOutput);\n        IERC20(vault.asset()).safeApprove(address(vault), assets);\n        return vault.deposit(assets, receiver);\n    }\n\n    function redeem(\n        IVault vault,\n        uint256 shares,\n        address receiver,\n        uint256 minOutput\n    ) external returns (uint256 assets) {\n        assets = vault.redeem(shares, address(this), msg.sender);\n        _returnETH(vault, receiver, minOutput);\n    }\n\n    function redeemWithPermit(\n        IVault vault,\n        uint256 shares,\n        address receiver,\n        uint256 minOutput,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 assets) {\n        vault.permit(msg.sender, address(this), shares, deadline, v, r, s);\n        assets = vault.redeem(shares, address(this), msg.sender);\n        _returnETH(vault, receiver, minOutput);\n    }\n\n    function withdraw(\n        IVault vault,\n        uint256 assets,\n        address receiver,\n        uint256 minOutput\n    ) external returns (uint256 shares) {\n        shares = vault.withdraw(assets, address(this), msg.sender);\n        _returnETH(vault, receiver, minOutput);\n    }\n\n    function withdrawWithPermit(\n        IVault vault,\n        uint256 assets,\n        address receiver,\n        uint256 minOutput,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 shares) {\n        shares = vault.convertToShares(assets);\n        vault.permit(msg.sender, address(this), shares, deadline, v, r, s);\n        shares = vault.withdraw(assets, address(this), msg.sender);\n        _returnETH(vault, receiver, minOutput);\n    }\n\n    /* We need this default function because this contract will\n        receive ETH from the Curve pool\n    */\n    receive() external payable {}\n\n    function _returnETH(\n        IVault vault,\n        address receiver,\n        uint256 minOutput\n    ) internal {\n        if (vault.asset() != STETH_ADDRESS) revert ETHAdapter__IncompatibleVault();\n        IERC20 asset = IERC20(vault.asset());\n\n        uint256 balance = asset.balanceOf(address(this));\n        asset.safeApprove(address(pool), balance);\n        pool.exchange(1, 0, balance, minOutput);\n\n        payable(receiver).sendValue(address(this).balance);\n    }\n}"
    }
  ]
}