{
  "Title": "[M-02] Marketplace calls unimplemented function",
  "Content": "_Submitted by 0x52_\n\n<https://github.com/code-423n4/2022-06-illuminate/blob/3ca41a9f529980b17fdc67baf8cbee5a8035afab/marketplace/MarketPlace.sol#L203-L204>\n\n<https://github.com/code-423n4/2022-06-illuminate/blob/3ca41a9f529980b17fdc67baf8cbee5a8035afab/marketplace/MarketPlace.sol#L220>\n\n### Vulnerability details\n\nWhile safe.sol isn't explicitly listed in scope it is listed as a library for all in scope contracts so I believe it should be in scope\n\n### Impact\n\nmint and mintWithUnderlying won't function.\n\n### Proof of Concept\n\n`safe.sol` never implements a transferFrom function meaning it will revert whenever a user calls either function.\n\n### Recommended Mitigation Steps\n\nCreate an implementation for transferFrom.\n\n**[JTraversa (Illuminate) disagreed with severity and commented](https://github.com/code-423n4/2022-06-illuminate-findings/issues/22#issuecomment-1176455560):**\n > I don't believe this should be considered high risk (an incorrectly copy/pasted safeTransfer lib) based on principal hah, but beyond that I don't think it should be high risk because without the expected safeTransfer lib, the contracts would not properly compile / no value would be at risk.\n\n**[gzeoneth (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-illuminate-findings/issues/22#issuecomment-1186212424):**\n > Judging as Med Risk as no value at risk and function of the protocol would be impacted.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-06-illuminate",
  "Code": [
    {
      "filename": "marketplace/MarketPlace.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Interfaces.sol';\nimport './ERC5095.sol';\nimport './Safe.sol';\n\n/// @title MarketPlace\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice This contract is in charge of managing the avaialable principals for each loan market.\n/// @notice In addition, this contract routes swap orders between metaprincipal tokens and their respective underlying to YieldSpace pools.\ncontract MarketPlace {\n    /// @notice the available principals\n    /// @dev the order of this enum is used to select principals from the markets\n    /// mapping (e.g. Illuminate => 0, Swivel => 1, and so on)\n    enum Principals {\n        Illuminate,\n        Swivel,\n        Yield,\n        Element,\n        Pendle,\n        Tempus,\n        Sense,\n        Apwine,\n        Notional\n    }\n\n    error Exists(string);\n    error Unauthorized();\n    error Invalid(string);\n\n    /// @notice markets are defined by a market pair which point to a fixed length array of principal token addresses. \n    /// @notice The principal tokens those addresses represent correspond to their Principals enum value, thus the array should be ordered in that way\n    mapping(address => mapping(uint256 => address[9])) public markets;\n\n    /// @notice pools map markets to their respective YieldSpace pools for the MetaPrincipal token\n    mapping(address => mapping(uint256 => address)) public pools;\n\n    /// @notice address that is allowed to create markets, set fees, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the deployed redeemer contract\n    address public immutable redeemer;\n    /// @notice address of the deployed lender contract\n    address public immutable lender;\n\n    /// @notice emitted upon the creation of a new market\n    event CreateMarket(address indexed underlying, uint256 indexed maturity);\n\n    /// @notice intializes the MarketPlace contract\n    /// @param r address of the deployed redeemer contract\n    /// @param l address of the deployed lender contract\n    constructor(address r, address l) {\n        admin = msg.sender;\n        redeemer = r;\n        lender = l;\n    }\n\n    /// @notice creates a new market for the given underlying token and maturity\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param t principal token addresses for this market minus the illuminate principal (which is added here)\n    /// @param n name for the illuminate token\n    /// @param s symbol for the illuminate token\n    /// @param d decimals for the illuminate token\n    /// @return bool true if successful\n    function createMarket(\n        address u,\n        uint256 m,\n        address[8] memory t,\n        string calldata n,\n        string calldata s,\n        uint8 d\n    ) external authorized(admin) returns (bool) {\n        if (markets[u][m][uint256(Principals.Illuminate)] != address(0)) {\n            revert Exists('market already exists');\n        }\n\n        // deploy an illuminate token with this new market\n        address iToken = address(new ERC5095(u, m, redeemer, lender, n, s, d));\n\n        // the market will have the illuminate principal as its zeroth item, thus t should have Principals[1] as [0]\n        address[9] memory market = [iToken, t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7]];\n\n        // set the market\n        markets[u][m] = market;\n\n        emit CreateMarket(u, m);\n        return true;\n    }\n\n    /// @notice allows the admin to set an individual market\n    /// @param p enum value of the principal token\n    /// @param u underlying token address\n    /// @param m maturity timestamp for the market\n    /// @param a address of the new market\n    /// @return bool true if successful\n    function setPrincipal(uint8 p, address u, uint256 m, address a) external authorized(admin) returns (bool) {\n        if (markets[u][m][p] != address(0)) {\n            revert Exists('Market already exists');\n        }\n        markets[u][m][p] = a;\n        return true;\n    }\n\n    /// @notice sets the admin address\n    /// @param a Address of a new admin\n    /// @return bool true if successful\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        return true;\n    }\n\n    /// @notice sets the address for a pool\n    /// @param u address of the underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a address of the pool\n    /// @return bool true if successful\n    function setPool(\n        address u,\n        uint256 m,\n        address a\n    ) external authorized(admin) returns (bool) {\n        if (pools[u][m] != address(0)) {\n            revert Exists('pool already exists');\n        }\n        pools[u][m] = a;\n        return true;\n    }\n\n    /// @notice sells the PT for the PT via the pool\n    /// @param u address of the underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of PT to swap\n    /// @return uint128 amount of PT bought\n    function sellPrincipalToken(\n        address u,\n        uint256 m,\n        uint128 a\n    ) external returns (uint128) {\n        IPool pool = IPool(pools[u][m]);\n        Safe.transfer(IERC20(address(pool.fyToken())), address(pool), a);\n        return pool.sellFYToken(msg.sender, pool.sellFYTokenPreview(a));\n    }\n\n    /// @notice buys the underlying for the PT via the pool\n    /// @param u address of the underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to sell\n    /// @return uint128 amount of PT received\n    function buyPrincipalToken(\n        address u,\n        uint256 m,\n        uint128 a\n    ) external returns (uint128) {\n        IPool pool = IPool(pools[u][m]);\n        Safe.transfer(IERC20(address(pool.base())), address(pool), a);\n        return pool.buyFYToken(msg.sender, pool.buyFYTokenPreview(a), a);\n    }\n\n    /// @notice sells the underlying for the PT via the pool\n    /// @param u address of the underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying to swap\n    /// @return uint128 amount of underlying sold\n    function sellUnderlying(\n        address u,\n        uint256 m,\n        uint128 a\n    ) external returns (uint128) {\n        IPool pool = IPool(pools[u][m]);\n        Safe.transfer(IERC20(address(pool.base())), address(pool), a);\n        return pool.sellBase(msg.sender, pool.sellBasePreview(a));\n    }\n\n    /// @notice buys the underlying for the PT via the pool\n    /// @param u address of the underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of PT to swap\n    /// @return uint128 amount of underlying bought\n    function buyUnderlying(\n        address u,\n        uint256 m,\n        uint128 a\n    ) external returns (uint128) {\n        IPool pool = IPool(pools[u][m]);\n        Safe.transfer(IERC20(address(pool.fyToken())), address(pool), a);\n        return pool.buyBase(msg.sender, pool.buyBasePreview(a), a);\n    }\n\n    /// @notice mint liquidity tokens in exchange for adding underlying and PT\n    /// @dev amount of liquidity tokens to mint is calculated from the amount of unaccounted for PT in this contract.\n    /// @dev A proportional amount of underlying tokens need to be present in this contract, also unaccounted for.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param uA the underlying amount being sent\n    /// @param ptA the principal token amount being sent\n    /// @param minRatio minimum ratio of underlying to PT in the pool.\n    /// @param maxRatio maximum ratio of underlying to PT in the pool.\n    /// @return uint256 the amount of liquidity tokens minted.\n    function mint(address u, uint256 m, uint256 uA, uint256 ptA, uint256 minRatio, uint256 maxRatio) external returns (uint256, uint256, uint256) {\n        IPool pool = IPool(pools[u][m]);\n        Safe.transferFrom(ERC20(address(pool.base())), msg.sender, address(pool), uA);  \n        Safe.transferFrom(ERC20(address(pool.fyToken())), msg.sender, address(pool), ptA);\n        return pool.mint(msg.sender, msg.sender, minRatio, maxRatio);\n    }\n\n    /// @notice Mint liquidity tokens in exchange for adding only underlying\n    /// @dev amount of liquidity tokens is calculated from the amount of PT to buy from the pool,\n    /// plus the amount of unaccounted for PT in this contract.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param a the underlying amount being sent\n    /// @param ptBought amount of `PT` being bought in the Pool, from this we calculate how much underlying it will be taken in.\n    /// @param minRatio minimum ratio of underlying to PT in the pool.\n    /// @param maxRatio maximum ratio of underlying to PT in the pool.\n    /// @return uint256 the amount of liquidity tokens minted\n    function mintWithUnderlying(address u, uint256 m, uint256 a, uint256 ptBought, uint256 minRatio, uint256 maxRatio) external returns (uint256, uint256, uint256) {\n        IPool pool = IPool(pools[u][m]);\n        Safe.transferFrom(ERC20(address(pool.base())), msg.sender, address(pool), a);\n        return pool.mintWithBase(msg.sender, msg.sender, ptBought, minRatio, maxRatio);\n    }\n\n    /// @notice burn liquidity tokens in exchange for underlying and PT.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param minRatio minimum ratio of underlying to PT in the pool.\n    /// @param maxRatio maximum ratio of underlying to PT in the pool.\n    /// @return uint256 amount of tokens burned and returned (tokensBurned, underlyings, PTs).\n    function burn(address u, uint256 m, uint256 minRatio, uint256 maxRatio) external returns (uint256, uint256, uint256) {\n        return IPool(pools[u][m]).burn(msg.sender, msg.sender, minRatio, maxRatio);\n    }\n\n    /// @notice burn liquidity tokens in exchange for underlying.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param minRatio minimum ratio of underlying to PT in the pool.\n    /// @param maxRatio minimum ratio of underlying to PT in the pool.\n    /// @return uint256 amount of underlying tokens returned\n    /// @return uint256 amount of PT tokens sent to the pool\n    function burnForUnderlying(address u, uint256 m, uint256 minRatio, uint256 maxRatio) external returns (uint256, uint256) {\n        return IPool(pools[u][m]).burnForBase(msg.sender, minRatio, maxRatio);\n    }\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Unauthorized();\n        }\n        _;\n    }\n}"
    },
    {
      "filename": "marketplace/MarketPlace.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Interfaces.sol';\nimport './ERC5095.sol';\nimport './Safe.sol';\n\n/// @title MarketPlace\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice This contract is in charge of managing the avaialable principals for each loan market.\n/// @notice In addition, this contract routes swap orders between metaprincipal tokens and their respective underlying to YieldSpace pools.\ncontract MarketPlace {\n    /// @notice the available principals\n    /// @dev the order of this enum is used to select principals from the markets\n    /// mapping (e.g. Illuminate => 0, Swivel => 1, and so on)\n    enum Principals {\n        Illuminate,\n        Swivel,\n        Yield,\n        Element,\n        Pendle,\n        Tempus,\n        Sense,\n        Apwine,\n        Notional\n    }\n\n    error Exists(string);\n    error Unauthorized();\n    error Invalid(string);\n\n    /// @notice markets are defined by a market pair which point to a fixed length array of principal token addresses. \n    /// @notice The principal tokens those addresses represent correspond to their Principals enum value, thus the array should be ordered in that way\n    mapping(address => mapping(uint256 => address[9])) public markets;\n\n    /// @notice pools map markets to their respective YieldSpace pools for the MetaPrincipal token\n    mapping(address => mapping(uint256 => address)) public pools;\n\n    /// @notice address that is allowed to create markets, set fees, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the deployed redeemer contract\n    address public immutable redeemer;\n    /// @notice address of the deployed lender contract\n    address public immutable lender;\n\n    /// @notice emitted upon the creation of a new market\n    event CreateMarket(address indexed underlying, uint256 indexed maturity);\n\n    /// @notice intializes the MarketPlace contract\n    /// @param r address of the deployed redeemer contract\n    /// @param l address of the deployed lender contract\n    constructor(address r, address l) {\n        admin = msg.sender;\n        redeemer = r;\n        lender = l;\n    }\n\n    /// @notice creates a new market for the given underlying token and maturity\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param t principal token addresses for this market minus the illuminate principal (which is added here)\n    /// @param n name for the illuminate token\n    /// @param s symbol for the illuminate token\n    /// @param d decimals for the illuminate token\n    /// @return bool true if successful\n    function createMarket(\n        address u,\n        uint256 m,\n        address[8] memory t,\n        string calldata n,\n        string calldata s,\n        uint8 d\n    ) external authorized(admin) returns (bool) {\n        if (markets[u][m][uint256(Principals.Illuminate)] != address(0)) {\n            revert Exists('market already exists');\n        }\n\n        // deploy an illuminate token with this new market\n        address iToken = address(new ERC5095(u, m, redeemer, lender, n, s, d));\n\n        // the market will have the illuminate principal as its zeroth item, thus t should have Principals[1] as [0]\n        address[9] memory market = [iToken, t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7]];\n\n        // set the market\n        markets[u][m] = market;\n\n        emit CreateMarket(u, m);\n        return true;\n    }\n\n    /// @notice allows the admin to set an individual market\n    /// @param p enum value of the principal token\n    /// @param u underlying token address\n    /// @param m maturity timestamp for the market\n    /// @param a address of the new market\n    /// @return bool true if successful\n    function setPrincipal(uint8 p, address u, uint256 m, address a) external authorized(admin) returns (bool) {\n        if (markets[u][m][p] != address(0)) {\n            revert Exists('Market already exists');\n        }\n        markets[u][m][p] = a;\n        return true;\n    }\n\n    /// @notice sets the admin address\n    /// @param a Address of a new admin\n    /// @return bool true if successful\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        return true;\n    }\n\n    /// @notice sets the address for a pool\n    /// @param u address of the underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a address of the pool\n    /// @return bool true if successful\n    function setPool(\n        address u,\n        uint256 m,\n        address a\n    ) external authorized(admin) returns (bool) {\n        if (pools[u][m] != address(0)) {\n            revert Exists('pool already exists');\n        }\n        pools[u][m] = a;\n        return true;\n    }\n\n    /// @notice sells the PT for the PT via the pool\n    /// @param u address of the underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of PT to swap\n    /// @return uint128 amount of PT bought\n    function sellPrincipalToken(\n        address u,\n        uint256 m,\n        uint128 a\n    ) external returns (uint128) {\n        IPool pool = IPool(pools[u][m]);\n        Safe.transfer(IERC20(address(pool.fyToken())), address(pool), a);\n        return pool.sellFYToken(msg.sender, pool.sellFYTokenPreview(a));\n    }\n\n    /// @notice buys the underlying for the PT via the pool\n    /// @param u address of the underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to sell\n    /// @return uint128 amount of PT received\n    function buyPrincipalToken(\n        address u,\n        uint256 m,\n        uint128 a\n    ) external returns (uint128) {\n        IPool pool = IPool(pools[u][m]);\n        Safe.transfer(IERC20(address(pool.base())), address(pool), a);\n        return pool.buyFYToken(msg.sender, pool.buyFYTokenPreview(a), a);\n    }\n\n    /// @notice sells the underlying for the PT via the pool\n    /// @param u address of the underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying to swap\n    /// @return uint128 amount of underlying sold\n    function sellUnderlying(\n        address u,\n        uint256 m,\n        uint128 a\n    ) external returns (uint128) {\n        IPool pool = IPool(pools[u][m]);\n        Safe.transfer(IERC20(address(pool.base())), address(pool), a);\n        return pool.sellBase(msg.sender, pool.sellBasePreview(a));\n    }\n\n    /// @notice buys the underlying for the PT via the pool\n    /// @param u address of the underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of PT to swap\n    /// @return uint128 amount of underlying bought\n    function buyUnderlying(\n        address u,\n        uint256 m,\n        uint128 a\n    ) external returns (uint128) {\n        IPool pool = IPool(pools[u][m]);\n        Safe.transfer(IERC20(address(pool.fyToken())), address(pool), a);\n        return pool.buyBase(msg.sender, pool.buyBasePreview(a), a);\n    }\n\n    /// @notice mint liquidity tokens in exchange for adding underlying and PT\n    /// @dev amount of liquidity tokens to mint is calculated from the amount of unaccounted for PT in this contract.\n    /// @dev A proportional amount of underlying tokens need to be present in this contract, also unaccounted for.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param uA the underlying amount being sent\n    /// @param ptA the principal token amount being sent\n    /// @param minRatio minimum ratio of underlying to PT in the pool.\n    /// @param maxRatio maximum ratio of underlying to PT in the pool.\n    /// @return uint256 the amount of liquidity tokens minted.\n    function mint(address u, uint256 m, uint256 uA, uint256 ptA, uint256 minRatio, uint256 maxRatio) external returns (uint256, uint256, uint256) {\n        IPool pool = IPool(pools[u][m]);\n        Safe.transferFrom(ERC20(address(pool.base())), msg.sender, address(pool), uA);  \n        Safe.transferFrom(ERC20(address(pool.fyToken())), msg.sender, address(pool), ptA);\n        return pool.mint(msg.sender, msg.sender, minRatio, maxRatio);\n    }\n\n    /// @notice Mint liquidity tokens in exchange for adding only underlying\n    /// @dev amount of liquidity tokens is calculated from the amount of PT to buy from the pool,\n    /// plus the amount of unaccounted for PT in this contract.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param a the underlying amount being sent\n    /// @param ptBought amount of `PT` being bought in the Pool, from this we calculate how much underlying it will be taken in.\n    /// @param minRatio minimum ratio of underlying to PT in the pool.\n    /// @param maxRatio maximum ratio of underlying to PT in the pool.\n    /// @return uint256 the amount of liquidity tokens minted\n    function mintWithUnderlying(address u, uint256 m, uint256 a, uint256 ptBought, uint256 minRatio, uint256 maxRatio) external returns (uint256, uint256, uint256) {\n        IPool pool = IPool(pools[u][m]);\n        Safe.transferFrom(ERC20(address(pool.base())), msg.sender, address(pool), a);\n        return pool.mintWithBase(msg.sender, msg.sender, ptBought, minRatio, maxRatio);\n    }\n\n    /// @notice burn liquidity tokens in exchange for underlying and PT.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param minRatio minimum ratio of underlying to PT in the pool.\n    /// @param maxRatio maximum ratio of underlying to PT in the pool.\n    /// @return uint256 amount of tokens burned and returned (tokensBurned, underlyings, PTs).\n    function burn(address u, uint256 m, uint256 minRatio, uint256 maxRatio) external returns (uint256, uint256, uint256) {\n        return IPool(pools[u][m]).burn(msg.sender, msg.sender, minRatio, maxRatio);\n    }\n\n    /// @notice burn liquidity tokens in exchange for underlying.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param minRatio minimum ratio of underlying to PT in the pool.\n    /// @param maxRatio minimum ratio of underlying to PT in the pool.\n    /// @return uint256 amount of underlying tokens returned\n    /// @return uint256 amount of PT tokens sent to the pool\n    function burnForUnderlying(address u, uint256 m, uint256 minRatio, uint256 maxRatio) external returns (uint256, uint256) {\n        return IPool(pools[u][m]).burnForBase(msg.sender, minRatio, maxRatio);\n    }\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Unauthorized();\n        }\n        _;\n    }\n}"
    }
  ]
}