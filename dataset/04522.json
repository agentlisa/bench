{
  "Title": "Missing checks for null addresses in RenderToken and Airdrop contracts",
  "Content": "In `RenderToken`, the [`setEscrowContractAddress`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/RenderToken.sol#L58) function allows the token’s owner to change the escrow’s address (*i.e.* the contract variable [`escrowContractAddress`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/RenderToken.sol#L20) ). However, the function does not implement a check to prevent the null address from being set.\n\n\nSimilarly in `Airdrop`, the contract’s constructor receives as a parameter an address that is assigned to the contract variable [`renderTokenAddress`](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L19) with no checks preventing the null address from being used.\n\n\nConsider implementing no-null address validations before setting these variables to avoid potential problems downstream.\n\n\n***Update:** null checks are now [in(<https://github.com/jeualvarez/Token-Audit/blob/master/contracts/RenderToken.sol#L88>) [place](https://github.com/jeualvarez/Token-Airdrop/blob/master/contracts/AirDrop.sol#L36) for address changes.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/RenderToken.sol",
      "content": "pragma solidity ^0.4.14;\n\n// Escrow constract\nimport \"./Escrow.sol\";\nimport \"./MigratableERC20.sol\";\n\n/**\n * @title RenderToken\n * @dev ERC20 mintable token\n * The token will be minted by the crowdsale contract only\n */\ncontract RenderToken is Migratable, MigratableERC20, MintableToken {\n\n  string public constant name = \"Render Token\";\n  string public constant symbol = \"RNDR\";\n  uint8 public constant decimals = 18;\n\n  // The address of the contract that manages job balances. Address is used for forwarding tokens\n  // that come in to fund jobs\n  address public escrowContractAddress;\n\n  /**\n   * @dev Constructor\n   * @param _owner because this contract uses proxies, owner must be passed in as a param\n   */\n  function initialize(address _owner, address _legacyToken) public isInitializer(\"RenderToken\", \"0\") {\n    MintableToken.initialize(_owner);\n    MigratableERC20.initialize(_legacyToken);\n  }\n\n  /**\n   * @dev Take tokens prior to beginning a job\n   *\n   * This function is called by the artist, and it will transfer tokens\n   * to a separate escrow contract to be held until the job is completed\n   * @param _jobID is the ID of the job used within the ORC backend\n   * @param _amount is the number of RNDR tokens being held in escrow\n   */\n  function holdInEscrow(string _jobID, uint256 _amount) public {\n    require(transfer(escrowContractAddress, _amount));\n    Escrow(escrowContractAddress).fundJob(_jobID, _amount);\n  }\n\n  function _mint(address _to, uint256 _amount) internal {\n    require(_to != address(0));\n    totalSupply_ = totalSupply_.add(_amount);\n    balances[_to] = balances[_to].add(_amount);\n    emit Transfer(address(0), _to, _amount);\n  }\n\n  /**\n   * @dev Set the address of the escrow contract\n   *\n   * This will dictate the contract that will hold tokens in escrow and keep\n   * a ledger of funds available for jobs\n   * @param _escrowAddress see escrowContractAddress\n  */\n  function setEscrowContractAddress(address _escrowAddress) public onlyOwner {\n    escrowContractAddress = _escrowAddress;\n  }\n\n}"
    },
    {
      "filename": "contracts/Airdrop.sol",
      "content": "pragma solidity ^0.4.0;\npragma experimental \"v0.5.0\";\n\nimport \"../node_modules/openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\nimport \"../node_modules/openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\ncontract AirDrop is Ownable {\n    address public renderTokenAddress;\n    bool public listFinalized = false;\n    uint256 public totalBonus;\n    uint256 public nextUserToBePaid = 0;\n\n    mapping (address => uint256) public bonusAmounts;\n    address[] public bonusAddresses;\n\n    event AddedUser(address userAddress, uint256 userIndex, uint256 bonusAmount);\n    event PaidUser(address userAddress, uint256 userIndex, uint256 amountPaid);\n\n    constructor(address _renderTokenAddress) public {\n        renderTokenAddress = _renderTokenAddress;\n    }\n    \n    function getUserCount() public view returns (uint256) {\n        return bonusAddresses.length;\n    }\n    \n    function addUser(address _userAddress, uint256 _amount) internal {\n        require (bonusAmounts[_userAddress] == 0, \"User bonus shouldn't exist before adding\");\n        bonusAmounts[_userAddress] = _amount;\n        totalBonus += _amount;\n        emit AddedUser(_userAddress, bonusAddresses.push(_userAddress) - 1, _amount);\n    }\n\n    function payUser(uint256 _id) internal returns(uint256 amount) {\n        amount = bonusAmounts[bonusAddresses[_id]];\n\n        if (amount > 0) { // If bonus hasn't been paid yet\n            bonusAmounts[bonusAddresses[_id]] = 0;\n            totalBonus -= amount;\n            ERC20(renderTokenAddress).transfer(bonusAddresses[_id], amount);\n            emit PaidUser(bonusAddresses[_id], _id, amount);\n        }\n    }\n\n    function addManyUsers(address[] _recipients, uint256[] _amounts) public onlyOwner {\n        require(!listFinalized, \"Adding users allowed only when list isn't finalized\");\n        for (uint i = 0; i < _recipients.length; i++) {\n            addUser(_recipients[i], _amounts[i]);\n        }\n    }\n    \n    function payUserRange(uint256 _idFrom, uint256 _idTo) internal returns(uint256 totalPaid) {\n        require(_idTo < bonusAddresses.length, \"idTo should be less than user count\");\n        require(_idFrom <= _idTo, \"idFrom shouldn't be greater than idTo\");\n        for (uint i = _idFrom; i <= _idTo; i++) { // idTo included\n            totalPaid += payUser(i);\n        }\n        nextUserToBePaid = _idTo + 1;\n    }\n    \n    function payManyUsers(uint256 batchSize) public onlyOwner returns(uint256 totalPaid) {\n        require(listFinalized, \"Payment can be called only after list is finalized\");\n        uint256 idFrom = nextUserToBePaid;\n        uint256 idTo = idFrom + batchSize - 1;\n        if (idTo >= bonusAddresses.length) idTo = bonusAddresses.length - 1;\n        return payUserRange(idFrom, idTo);\n    }\n\n    function finalizeList() public onlyOwner {\n        require(!listFinalized, \"Can be called only if list isn't finalized\");\n        listFinalized = true;\n    }\n    \n    function returnTokens() public onlyOwner {\n        uint256 amount = ERC20(renderTokenAddress).balanceOf(address(this));\n        ERC20(renderTokenAddress).transfer(owner, amount);\n    }\n}"
    },
    {
      "filename": "contracts/RenderToken.sol",
      "content": "pragma solidity ^0.4.24;\n\n// Escrow constract\nimport { Escrow } from \"./Escrow.sol\";\nimport { Migratable } from \"../node_modules/zos-lib/contracts/migrations/Migratable.sol\";\nimport { MigratableERC20 } from \"./MigratableERC20.sol\";\nimport { Ownable } from \"../node_modules/openzeppelin-zos/contracts/ownership/Ownable.sol\";\nimport { StandardToken } from \"../node_modules/openzeppelin-zos/contracts/token/ERC20/StandardToken.sol\";\n\n/**\n * @title RenderToken\n * @dev ERC20 mintable token\n * The token will be minted by the crowdsale contract only\n */\ncontract RenderToken is Migratable, MigratableERC20, Ownable, StandardToken {\n\n  string public constant name = \"Render Token\";\n  string public constant symbol = \"RNDR\";\n  uint8 public constant decimals = 18;\n\n  // The address of the contract that manages job balances. Address is used for forwarding tokens\n  // that come in to fund jobs\n  address public escrowContractAddress;\n\n  // Emit new contract address when escrowContractAddress has been changed\n  event EscrowContractAddressUpdate(address escrowContractAddress);\n  // Emit information related to tokens being escrowed\n  event TokensEscrowed(address indexed sender, string jobId, uint256 amount);\n  // Emit information related to legacy tokens being migrated\n  event TokenMigration(address indexed receiver, uint256 amount);\n\n  /**\n   * @dev Initailization\n   * @param _owner because this contract uses proxies, owner must be passed in as a param\n   */\n  function initialize(address _owner, address _legacyToken) public isInitializer(\"RenderToken\", \"0\") {\n    require(_owner != address(0), \"_owner must not be null\");\n    require(_legacyToken != address(0), \"_legacyToken must not be null\");\n    Ownable.initialize(_owner);\n    MigratableERC20.initialize(_legacyToken);\n  }\n\n  /**\n   * @dev Take tokens prior to beginning a job\n   *\n   * This function is called by the artist, and it will transfer tokens\n   * to a separate escrow contract to be held until the job is completed\n   * @param _jobID is the ID of the job used within the ORC backend\n   * @param _amount is the number of RNDR tokens being held in escrow\n   */\n  function holdInEscrow(string _jobID, uint256 _amount) public {\n    require(transfer(escrowContractAddress, _amount), \"token transfer to escrow address failed\");\n    Escrow(escrowContractAddress).fundJob(_jobID, _amount);\n\n    emit TokensEscrowed(msg.sender, _jobID, _amount);\n  }\n\n  /**\n   * @dev Mints new tokens equal to the amount of legacy tokens burned\n   *\n   * This function is called internally, but triggered by a user choosing to\n   * migrate their balance.\n   * @param _to is the address tokens will be sent to\n   * @param _amount is the number of RNDR tokens being sent to the address\n   */\n  function _mintMigratedTokens(address _to, uint256 _amount) internal {\n    require(_to != address(0), \"_to address must not be null\");\n    totalSupply_ = totalSupply_.add(_amount);\n    balances[_to] = balances[_to].add(_amount);\n\n    emit TokenMigration(_to, _amount);\n    emit Transfer(address(0), _to, _amount);\n  }\n\n  /**\n   * @dev Set the address of the escrow contract\n   *\n   * This will dictate the contract that will hold tokens in escrow and keep\n   * a ledger of funds available for jobs.\n   * RNDR is still in its infancy, and changes may need to be made to this\n   * contract and / or the escrow contract. Including methods to update the\n   * addresses allows the contracts to update independently.\n   * If the escrow contract is ever migrated to another address for\n   * either added security or functionality, this will need to be called.\n   * @param _escrowAddress see escrowContractAddress\n   */\n  function setEscrowContractAddress(address _escrowAddress) public onlyOwner {\n    require(_escrowAddress != address(0), \"_escrowAddress must not be null\");\n    escrowContractAddress = _escrowAddress;\n\n    emit EscrowContractAddressUpdate(escrowContractAddress);\n  }\n\n}"
    }
  ]
}