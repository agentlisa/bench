{
  "Title": "Silo is not compatible with Fee-on-transfer or rebasing tokens",
  "Content": "# Silo is not compatible with Fee-on-transfer or rebasing tokens\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-02-Beanstalk-1/blob/a3658861af8f5126224718af494d02352fbb3ea5/protocol/contracts/libraries/Silo/LibTokenSilo.sol#L266-L292\">https://github.com/Cyfrin/2024-02-Beanstalk-1/blob/a3658861af8f5126224718af494d02352fbb3ea5/protocol/contracts/libraries/Silo/LibTokenSilo.sol#L266-L292</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-02-Beanstalk-1/blob/a3658861af8f5126224718af494d02352fbb3ea5/protocol/contracts/libraries/Silo/LibTokenSilo.sol#L310-L351\">https://github.com/Cyfrin/2024-02-Beanstalk-1/blob/a3658861af8f5126224718af494d02352fbb3ea5/protocol/contracts/libraries/Silo/LibTokenSilo.sol#L310-L351</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-02-Beanstalk-1/blob/a3658861af8f5126224718af494d02352fbb3ea5/protocol/contracts/libraries/Silo/LibTokenSilo.sol#L373-L427\">https://github.com/Cyfrin/2024-02-Beanstalk-1/blob/a3658861af8f5126224718af494d02352fbb3ea5/protocol/contracts/libraries/Silo/LibTokenSilo.sol#L373-L427</a>\n\n\n## Summary\n\nAccording to the documentation there are certain conditions that need to be met for a token to be whitelisted:\n\n```\nAdditional tokens may be added to the Deposit Whitelist via Beanstalk governance. In order for a token to be added to the Deposit Whitelist, Beanstalk requires:\n1. The token address;\n2. A function to calculate the Bean Denominated Value (BDV) of the token (see Section 14.2 of the whitepaper for complete formulas); and\n3. The number of Stalk and Seeds per BDV received upon Deposit.\n```\n\nThus if the community proposes any kind of Fee-on-Transfer or rebasing tokens like (`PAXG` or `stETH`) and the Beanstalk governance approves it, then the protocol needs to integrate them into the system. But as it is now the system is definitely not compatible with such tokens.\n\n## Vulnerability Details\n\n`deposit`, `depositWithBDV`, `addDepositToAccount`, `removeDepositFromAccount` and any other `silo` accounting related functions perform operations using inputed/recorded amounts. They don't query the existing balance of tokens before or after receiving/sending in order to properly account for tokens that shift balance when received (FoT) or shift balance over time (rebasing).\n\n## Impact\n\nLikelyhood - low/medium - At the moment of writing lido has over [31% of the ETH staked](https://dune.com/hildobby/eth2-staking) which makes `stETH` a very popular token. There's a strong chance that stakeholder would want to have stETH inside the silo.\n\nImpact - High - It simply won't work.\n\nOverall severity is medium.\n\n## Tools Used\n\nManual review\n\n## Recommendations\n\nClearly state in the docs that weird tokens won't be implemented via Governance Vote or adjust the code to check the `token.balanceOf()` before and after doing any operation related to the `silo`.",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clsxlpte900074r5et7x6kh96",
  "Code": [
    {
      "filename": "protocol/contracts/libraries/Silo/LibTokenSilo.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport {LibAppStorage, Storage, AppStorage, Account} from \"../LibAppStorage.sol\";\nimport {C} from \"../../C.sol\";\nimport {LibSafeMath32} from \"contracts/libraries/LibSafeMath32.sol\";\nimport {LibSafeMath128} from \"contracts/libraries/LibSafeMath128.sol\";\nimport {LibSafeMathSigned128} from \"contracts/libraries/LibSafeMathSigned128.sol\";\nimport {LibSafeMathSigned96} from \"contracts/libraries/LibSafeMathSigned96.sol\";\nimport {LibBytes} from \"contracts/libraries/LibBytes.sol\";\nimport {LibGerminate} from \"contracts/libraries/Silo/LibGerminate.sol\";\nimport {LibWhitelistedTokens} from \"contracts/libraries/Silo/LibWhitelistedTokens.sol\";\n\n/**\n * @title LibTokenSilo\n * @author Publius, Pizzaman1337\n * @notice Contains functions for depositing, withdrawing and claiming\n * whitelisted Silo tokens.\n *\n * For functionality related to Stalk, and Roots, see {LibSilo}.\n */\nlibrary LibTokenSilo {\n    using SafeMath for uint256;\n    using LibSafeMath128 for uint128;\n    using LibSafeMath32 for uint32;\n    using LibSafeMathSigned128 for int128;\n    using SafeCast for int128;\n    using SafeCast for uint256;\n    using LibSafeMathSigned96 for int96;\n\n    uint256 constant PRECISION = 1e6; // increased precision from to silo v3.1.\n\n\n    //////////////////////// ENUM ////////////////////////\n    /**\n     * @dev when a user deposits or withdraws a deposit, the\n     * {TrasferSingle} event is emitted. However, in the case\n     * of a transfer, this emission is ommited. This enum is\n     * used to determine if the event should be emitted.\n     */\n    enum Transfer {\n        emitTransferSingle,\n        noEmitTransferSingle\n    }\n\n    //////////////////////// EVENTS ////////////////////////\n\n    /**\n     * @dev IMPORTANT: copy of {TokenSilo-AddDeposit}, check there for details.\n     */\n    event AddDeposit(\n        address indexed account,\n        address indexed token,\n        int96 stem,\n        uint256 amount,\n        uint256 bdv\n    );\n\n    /**\n     * @dev IMPORTANT: copy of {TokenSilo-RemoveDeposit}, check there for details.\n     */\n    event RemoveDeposit(\n        address indexed account,\n        address indexed token,\n        int96 stem,\n        uint256 amount,\n        uint256 bdv\n    );\n\n    // added as the ERC1155 deposit upgrade\n    event TransferSingle(\n        address indexed operator,\n        address indexed sender,\n        address indexed recipient,\n        uint256 depositId,\n        uint256 amount\n    );\n\n    //////////////////////// ACCOUNTING: TOTALS GERMINATING ////////////////////////\n\n    /**\n     * @notice Increment the total amount and bdv of `token` germinating in the Silo.\n     * @dev when an asset is `deposited` in the silo, it is not immediately eliable for\n     * bean mints. It must `germinate` (stay deposited the silo) for a certain\n     * amount of seasons (the remainer of the current season + 1). This function\n     * increments the total amount and bdv germinating in the silo. The {sunrise}\n     * function ends the germination process for even or odd germinating deposits.\n     *\n     * This protects beanstalk from flashloan attacks, and makes `totalDeposited` and\n     * `totalDepositedBdv` significantly more MEV resistant.\n     */\n    function incrementTotalGerminating(\n        address token,\n        uint256 amount,\n        uint256 bdv,\n        LibGerminate.Germinate germ\n    ) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        Storage.TotalGerminating storage germinate;\n\n        // verify germ is valid\n        if (germ == LibGerminate.Germinate.ODD) {\n            germinate = s.oddGerminating;\n        } else if (germ == LibGerminate.Germinate.EVEN) {\n            germinate = s.evenGerminating;\n        } else {\n            revert(\"invalid germinationMode\"); // should not ever get here\n        }\n\n        // increment germinating amount and bdv.\n        germinate.deposited[token].amount = germinate.deposited[token].amount.add(\n            amount.toUint128()\n        );\n        germinate.deposited[token].bdv = germinate.deposited[token].bdv.add(bdv.toUint128());\n\n        // emit event.\n        emit LibGerminate.TotalGerminatingBalanceChanged(\n            s.season.current,\n            token,\n            int256(amount),\n            int256(bdv)\n        );\n    }\n\n    /**\n     * @notice Decrement the total amount and bdv of `token` germinating in the Silo.\n     * @dev `decrementTotalGerminating` should be used when removing deposits\n     * that are < 2 seasons old.\n     */\n    function decrementTotalGerminating(\n        address token,\n        uint256 amount,\n        uint256 bdv,\n        LibGerminate.Germinate germ\n    ) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        Storage.TotalGerminating storage germinate;\n\n        // verify germ is valid\n        if (germ == LibGerminate.Germinate.ODD) {\n            germinate = s.oddGerminating;\n        } else if (germ == LibGerminate.Germinate.EVEN) {\n            germinate = s.evenGerminating;\n        } else {\n            revert(\"invalid germinationMode\"); // should not ever get here\n        }\n\n        // decrement germinating amount and bdv.\n        germinate.deposited[token].amount = germinate.deposited[token].amount.sub(\n            amount.toUint128()\n        );\n        germinate.deposited[token].bdv = germinate.deposited[token].bdv.sub(bdv.toUint128());\n\n        emit LibGerminate.TotalGerminatingBalanceChanged(\n            LibGerminate.getSeasonGerminationState() == germ ? \n                s.season.current : \n                s.season.current - 1,\n            token,\n            -int256(amount),\n            -int256(bdv)\n        );\n    }\n\n    /**\n     * @notice Increment the total bdv of `token` germinating in the Silo. Used in Enroot.\n     */\n    function incrementTotalGerminatingBdv(\n        address token,\n        uint256 bdv,\n        LibGerminate.Germinate germ\n    ) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        if (germ == LibGerminate.Germinate.ODD) {\n            // increment odd germinating\n            s.oddGerminating.deposited[token].bdv = s.oddGerminating.deposited[token].bdv.add(\n                bdv.toUint128()\n            );\n        } else if (germ == LibGerminate.Germinate.EVEN) {\n            // increment even germinating\n            s.evenGerminating.deposited[token].bdv = s.evenGerminating.deposited[token].bdv.add(\n                bdv.toUint128()\n            );\n        } else {\n            revert(\"invalid germinationMode\"); // should not ever get here\n        }\n\n        emit LibGerminate.TotalGerminatingBalanceChanged(\n            LibGerminate.getSeasonGerminationState() == germ ? \n                s.season.current : \n                s.season.current - 1,\n            token,\n            0,\n            int256(bdv)\n        );\n    }\n\n    //////////////////////// ACCOUNTING: TOTALS ////////////////////////\n\n    /**\n     * @dev Increment the total amount and bdv of `token` deposited in the Silo.\n     * @dev `IncrementTotalDeposited` should be used when removing deposits that are\n     * >= 2 seasons old (ex. when a user converts).\n     */\n    function incrementTotalDeposited(address token, uint256 amount, uint256 bdv) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.siloBalances[token].deposited = s.siloBalances[token].deposited.add(amount.toUint128());\n        s.siloBalances[token].depositedBdv = s.siloBalances[token].depositedBdv.add(\n            bdv.toUint128()\n        );\n    }\n\n    /**\n     * @notice Decrement the total amount and bdv of `token` deposited in the Silo.\n     * @dev `decrementTotalDeposited` should be used when removing deposits that are\n     * >= 2 seasons old.\n     */\n    function decrementTotalDeposited(address token, uint256 amount, uint256 bdv) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.siloBalances[token].deposited = s.siloBalances[token].deposited.sub(amount.toUint128());\n        s.siloBalances[token].depositedBdv = s.siloBalances[token].depositedBdv.sub(\n            bdv.toUint128()\n        );\n    }\n\n    /**\n     * @notice Increment the total bdv of `token` deposited in the Silo. Used in Enroot.\n     */\n    function incrementTotalDepositedBdv(address token, uint256 bdv) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.siloBalances[token].depositedBdv = s.siloBalances[token].depositedBdv.add(\n            bdv.toUint128()\n        );\n    }\n\n    //////////////////////// ADD DEPOSIT ////////////////////////\n\n    /**\n     * @return stalk The amount of Stalk received for this Deposit.\n     *\n     * @dev Calculate the current BDV for `amount` of `token`, then perform\n     * Deposit accounting.\n     */\n    function deposit(\n        address account,\n        address token,\n        int96 stem,\n        uint256 amount\n    ) internal returns (uint256, LibGerminate.Germinate) {\n        uint256 bdv = beanDenominatedValue(token, amount);\n        return depositWithBDV(account, token, stem, amount, bdv);\n    }\n\n    /**\n     * @dev Once the BDV received for Depositing `amount` of `token` is known,\n     * add a Deposit for `account` and update the total amount Deposited.\n     *\n     * `s.ss[token].stalkIssuedPerBdv` stores the number of Stalk per BDV for `token`.\n     */\n    function depositWithBDV(\n        address account,\n        address token,\n        int96 stem,\n        uint256 amount,\n        uint256 bdv\n    ) internal returns (uint256 stalk, LibGerminate.Germinate germ) {\n        require(bdv > 0, \"Silo: No Beans under Token.\");\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        // determine whether the deposit is odd or even germinating\n        germ = LibGerminate.getSeasonGerminationState();\n\n        // all new deposits will increment total germination.\n        incrementTotalGerminating(token, amount, bdv, germ);\n        \n        addDepositToAccount(\n            account,\n            token,\n            stem,\n            amount,\n            bdv,\n            Transfer.emitTransferSingle\n        );\n\n        stalk = bdv.mul(s.ss[token].stalkIssuedPerBdv);\n    }\n\n    /**\n     * @dev Add `amount` of `token` to a user's Deposit in `stemTipForToken`. Requires a\n     * precalculated `bdv`.\n     *\n     * If a Deposit doesn't yet exist, one is created. Otherwise, the existing\n     * Deposit is updated.\n     *\n     * `amount` & `bdv` are downcasted uint256 -> uint128 to optimize storage cost,\n     * since both values can be packed into one slot.\n     *\n     * Unlike {removeDepositFromAccount}, this function DOES EMIT an\n     * {AddDeposit} event. See {removeDepositFromAccount} for more details.\n     *\n     * If a deposit is 'germinating', increment the germinating bdv for a user.\n     * Otherwise, increment the mow status bdv for a user.\n     */\n    function addDepositToAccount(\n        address account,\n        address token,\n        int96 stem,\n        uint256 amount,\n        uint256 bdv,\n        Transfer transferType\n    ) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 depositId = LibBytes.packAddressAndStem(token, stem);\n\n        // add amount and bdv to the deposits.\n        s.a[account].deposits[depositId].amount = s.a[account].deposits[depositId].amount.add(\n            amount.toUint128()\n        );\n        s.a[account].deposits[depositId].bdv = s.a[account].deposits[depositId].bdv.add(\n            bdv.toUint128()\n        );\n\n        // SafeMath unnecessary b/c crateBDV <= type(uint128).max\n        s.a[account].mowStatuses[token].bdv = s.a[account].mowStatuses[token].bdv.add(\n            bdv.toUint128()\n        );\n\n        /**\n         *  {addDepositToAccount} is used for both depositing and transferring deposits.\n         *  In the case of a deposit, only the {TransferSingle} Event needs to be emitted.\n         *  In the case of a transfer, a different {TransferSingle}/{TransferBatch}\n         *  Event is emitted in {TokenSilo._transferDeposit(s)},\n         *  and thus, this event is ommited.\n         */\n        if (transferType == Transfer.emitTransferSingle) {\n            emit TransferSingle(\n                msg.sender, // operator\n                address(0), // from\n                account, // to\n                depositId, // depositID\n                amount // token amount\n            );\n        }\n        emit AddDeposit(account, token, stem, amount, bdv);\n    }\n\n    //////////////////////// REMOVE DEPOSIT ////////////////////////\n\n    /**\n     * @dev Remove `amount` of `token` from a user's Deposit in `stem`.\n     *\n     * A \"Crate\" refers to the existing Deposit in storage at:\n     *  `s.a[account].deposits[token][stem]`\n     *\n     * Partially removing a Deposit should scale its BDV proportionally. For ex.\n     * removing 80% of the tokens from a Deposit should reduce its BDV by 80%.\n     *\n     * During an update, `amount` & `bdv` are cast uint256 -> uint128 to\n     * optimize storage cost, since both values can be packed into one slot.\n     *\n     * This function DOES **NOT** EMIT a {RemoveDeposit} event. This\n     * asymmetry occurs because {removeDepositFromAccount} is called in a loop\n     * in places where multiple deposits are removed simultaneously, including\n     * {TokenSilo-removeDepositsFromAccount} and {TokenSilo-_transferDeposits}.\n     */\n\n    function removeDepositFromAccount(\n        address account,\n        address token,\n        int96 stem,\n        uint256 amount\n    ) internal returns (uint256 crateBDV) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 depositId = LibBytes.packAddressAndStem(token, stem);\n\n        uint256 crateAmount = s.a[account].deposits[depositId].amount;\n        crateBDV = s.a[account].deposits[depositId].bdv;\n        // if amount is > crateAmount, check if user has a legacy deposit:\n        if (amount > crateAmount) { \n            // get the absolute stem value.\n            uint256 absStem = stem > 0 ? uint256(stem) : uint256(-stem);\n            // only stems with modulo 1e6 can have a legacy deposit.\n            if (absStem.mod(1e6) == 0) {\n                (crateAmount, crateBDV) = migrateLegacyStemDeposit(\n                    account,\n                    token,\n                    stem,\n                    crateAmount,\n                    crateBDV\n                );\n            }\n        }\n        require(amount <= crateAmount, \"Silo: Crate balance too low.\");\n\n        // Partial remove\n        if (amount < crateAmount) {\n            // round up removal of BDV. (x - 1)/y + 1\n            // https://stackoverflow.com/questions/17944\n            uint256 removedBDV = amount.sub(1).mul(crateBDV).div(crateAmount).add(1);\n            uint256 updatedBDV = crateBDV.sub(removedBDV);\n            uint256 updatedAmount = crateAmount.sub(amount);\n\n            // SafeCast unnecessary b/c updatedAmount <= crateAmount and updatedBDV <= crateBDV, \n            // which are both <= type(uint128).max\n            s.a[account].deposits[depositId].amount = uint128(updatedAmount);\n            s.a[account].deposits[depositId].bdv = uint128(updatedBDV);\n            \n            s.a[account].mowStatuses[token].bdv = s.a[account].mowStatuses[token].bdv.sub(\n                uint128(removedBDV)\n            );\n\n            return removedBDV;\n        }\n        // Full remove\n        if (crateAmount > 0) delete s.a[account].deposits[depositId];\n\n        // SafeMath unnecessary b/c crateBDV <= type(uint128).max\n        s.a[account].mowStatuses[token].bdv = s.a[account].mowStatuses[token].bdv.sub(\n            uint128(crateBDV)\n        );\n    }\n\n    //////////////////////// GETTERS ////////////////////////\n\n    /**\n     * @dev Calculate the BDV (\"Bean Denominated Value\") for `amount` of `token`.\n     *\n     * Makes a call to a BDV function defined in the SiloSettings for this\n     * `token`. See {AppStorage.sol:Storage-SiloSettings} for more information.\n     */\n    function beanDenominatedValue(\n        address token,\n        uint256 amount\n    ) internal view returns (uint256 bdv) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        require(s.ss[token].selector != bytes4(0), \"Silo: Token not whitelisted\");\n\n        (bool success, bytes memory data) = address(this).staticcall(\n            encodeBdvFunction(token, s.ss[token].encodeType, s.ss[token].selector, amount)\n        );\n\n        if (!success) {\n            if (data.length == 0) revert();\n            assembly {\n                revert(add(32, data), mload(data))\n            }\n        }\n\n        assembly {\n            bdv := mload(add(data, add(0x20, 0)))\n        }\n    }\n\n    function encodeBdvFunction(\n        address token,\n        bytes1 encodeType,\n        bytes4 selector,\n        uint256 amount\n    ) internal pure returns (bytes memory callData) {\n        if (encodeType == 0x00) {\n            callData = abi.encodeWithSelector(selector, amount);\n        } else if (encodeType == 0x01) {\n            callData = abi.encodeWithSelector(selector, token, amount);\n        } else {\n            revert(\"Silo: Invalid encodeType\");\n        }\n    }\n\n    /**\n     * @dev Locate the `amount` and `bdv` for a user's Deposit in storage.\n     *\n     * Silo V3 Deposits are stored within each {Account} as a mapping of:\n     *  `uint256 DepositID => { uint128 amount, uint128 bdv }`\n     *  The DepositID is the concatination of the token address and the stem.\n     *\n     * Silo V2 deposits are only usable after a successful migration, see\n     * mowAndMigrate within the Migration facet.\n     *\n     */\n    function getDeposit(\n        address account,\n        address token,\n        int96 stem\n    ) internal view returns (uint256 amount, uint256 bdv) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 depositId = LibBytes.packAddressAndStem(token, stem);\n        amount = s.a[account].deposits[depositId].amount;\n        bdv = s.a[account].deposits[depositId].bdv;\n    }\n\n    /**\n     * @dev Get the number of Stalk per BDV per Season for a whitelisted token.\n     * 6 decimal precision: 1e10 units = 1 stalk per season\n     */\n    function stalkEarnedPerSeason(address token) internal view returns (uint256) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return uint256(s.ss[token].stalkEarnedPerSeason);\n    }\n\n    /**\n     * @dev Get the number of Stalk per BDV for a whitelisted token. Formerly just stalk.\n     */\n    function stalkIssuedPerBdv(address token) internal view returns (uint256) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return uint256(s.ss[token].stalkIssuedPerBdv);\n    }\n\n    /**\n     * @dev returns the cumulative stalk per BDV (stemTip) for a whitelisted token.\n     */\n    function stemTipForToken(\n        address token\n    ) internal view returns (int96 _stemTip) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        // SafeCast unnecessary because all casted variables are types smaller that int96.\n        _stemTip =\n            s.ss[token].milestoneStem +\n            int96(s.ss[token].stalkEarnedPerSeason).mul(\n                int96(s.season.current).sub(int96(s.ss[token].milestoneSeason))\n            );\n    }\n\n    /**\n     * @dev returns the amount of grown stalk a deposit has earned.\n     */\n    function grownStalkForDeposit(\n        address account,\n        address token,\n        int96 stem\n    ) internal view returns (uint grownStalk) {\n        // stemTipForToken(token) > depositGrownStalkPerBdv for all valid Deposits\n        int96 _stemTip = stemTipForToken(token);\n        require(stem <= _stemTip, \"Silo: Invalid Deposit\");\n        // The check in the above line guarantees that subtraction result is positive\n        // and thus the cast to `uint256` is safe.\n        uint deltaStemTip = uint256(_stemTip.sub(stem));\n        // no stalk has grown if the stem is equal to the stemTip.\n        if (deltaStemTip == 0) return 0;\n        (, uint bdv) = getDeposit(account, token, stem);\n\n        grownStalk = deltaStemTip.mul(bdv).div(PRECISION);\n    }\n\n    /**\n     * @dev returns the amount of grown stalk a deposit would have, based on the stem of the deposit.\n     */\n    function calculateStalkFromStemAndBdv(\n        address token,\n        int96 grownStalkIndexOfDeposit,\n        uint256 bdv\n    ) internal view returns (int96 grownStalk) {\n        // current latest grown stalk index\n        int96 _stemTipForToken = stemTipForToken(address(token));\n\n        return _stemTipForToken.sub(grownStalkIndexOfDeposit).mul(toInt96(bdv));\n    }\n\n    /**\n     * @notice returns the grown stalk and germination state of a deposit,\n     * based on the amount of grown stalk it has earned.\n     */\n    function calculateStemForTokenFromGrownStalk(\n        address token,\n        uint256 grownStalk,\n        uint256 bdv\n    ) internal view returns (int96 stem, LibGerminate.Germinate germ) {\n        LibGerminate.GermStem memory germStem = LibGerminate.getGerminatingStem(token);\n        stem = germStem.stemTip.sub(toInt96(grownStalk.mul(PRECISION).div(bdv)));\n        germ = LibGerminate._getGerminationState(stem, germStem);\n    }\n\n    /**\n     * @dev returns the amount of grown stalk a deposit would have, based on the stem of the deposit.\n     * Similar to calculateStalkFromStemAndBdv, but has an additional check to prevent division by 0.\n     */\n    function grownStalkAndBdvToStem(\n        address token,\n        uint256 grownStalk,\n        uint256 bdv\n    ) internal view returns (int96 cumulativeGrownStalk) {\n        // first get current latest grown stalk index\n        int96 _stemTipForToken = stemTipForToken(token);\n        // then calculate how much stalk each individual bdv has grown\n        // there's a > 0 check here, because if you have a small amount of unripe bean deposit, the bdv could\n        // end up rounding to zero, then you get a divide by zero error and can't migrate without losing that deposit\n\n        // prevent divide by zero error\n        int96 grownStalkPerBdv = bdv > 0 ? toInt96(grownStalk.mul(PRECISION).div(bdv)) : 0;\n\n        // subtract from the current latest index, so we get the index the deposit should have happened at\n        return _stemTipForToken.sub(grownStalkPerBdv);\n    }\n\n    /**\n     * @notice internal logic for migrating a legacy deposit.\n     * @dev \n     */\n    function migrateLegacyStemDeposit(\n        address account, \n        address token,\n        int96 newStem,\n        uint256 crateAmount,\n        uint256 crateBdv\n    ) internal returns (uint256, uint256) { \n        AppStorage storage s = LibAppStorage.diamondStorage();\n        // divide the newStem by 1e6 to get the legacy stem.\n        uint256 legacyDepositId = LibBytes.packAddressAndStem(token, newStem.div(1e6));\n        uint256 legacyAmount = s.a[account].legacyV3Deposits[legacyDepositId].amount;\n        uint256 legacyBdv = s.a[account].legacyV3Deposits[legacyDepositId].bdv;\n        crateAmount = crateAmount.add(legacyAmount);\n        crateBdv = crateBdv.add(legacyBdv);\n        delete s.a[account].legacyV3Deposits[legacyDepositId];\n\n        // Emit burn events.\n        emit TransferSingle(\n            msg.sender,\n            account,\n            address(0),\n            legacyDepositId,\n            legacyAmount\n        );\n\n        emit RemoveDeposit(\n            account,\n            token,\n            newStem.div(1e6),\n            legacyAmount,\n            legacyBdv\n        );\n\n        // Emit mint events.\n        emit TransferSingle(\n            msg.sender,\n            address(0),\n            account,\n            LibBytes.packAddressAndStem(token, newStem),\n            legacyAmount\n        );\n\n        emit AddDeposit(\n            account,\n            token,\n            newStem,\n            legacyAmount,\n            legacyBdv\n        );\n\n        return (crateAmount, crateBdv);\n    }\n\n    function toInt96(uint256 value) internal pure returns (int96) {\n        require(value <= uint256(type(int96).max), \"SafeCast: value doesn't fit in an int96\");\n        return int96(value);\n    }\n}"
    },
    {
      "filename": "protocol/contracts/libraries/Silo/LibTokenSilo.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport {LibAppStorage, Storage, AppStorage, Account} from \"../LibAppStorage.sol\";\nimport {C} from \"../../C.sol\";\nimport {LibSafeMath32} from \"contracts/libraries/LibSafeMath32.sol\";\nimport {LibSafeMath128} from \"contracts/libraries/LibSafeMath128.sol\";\nimport {LibSafeMathSigned128} from \"contracts/libraries/LibSafeMathSigned128.sol\";\nimport {LibSafeMathSigned96} from \"contracts/libraries/LibSafeMathSigned96.sol\";\nimport {LibBytes} from \"contracts/libraries/LibBytes.sol\";\nimport {LibGerminate} from \"contracts/libraries/Silo/LibGerminate.sol\";\nimport {LibWhitelistedTokens} from \"contracts/libraries/Silo/LibWhitelistedTokens.sol\";\n\n/**\n * @title LibTokenSilo\n * @author Publius, Pizzaman1337\n * @notice Contains functions for depositing, withdrawing and claiming\n * whitelisted Silo tokens.\n *\n * For functionality related to Stalk, and Roots, see {LibSilo}.\n */\nlibrary LibTokenSilo {\n    using SafeMath for uint256;\n    using LibSafeMath128 for uint128;\n    using LibSafeMath32 for uint32;\n    using LibSafeMathSigned128 for int128;\n    using SafeCast for int128;\n    using SafeCast for uint256;\n    using LibSafeMathSigned96 for int96;\n\n    uint256 constant PRECISION = 1e6; // increased precision from to silo v3.1.\n\n\n    //////////////////////// ENUM ////////////////////////\n    /**\n     * @dev when a user deposits or withdraws a deposit, the\n     * {TrasferSingle} event is emitted. However, in the case\n     * of a transfer, this emission is ommited. This enum is\n     * used to determine if the event should be emitted.\n     */\n    enum Transfer {\n        emitTransferSingle,\n        noEmitTransferSingle\n    }\n\n    //////////////////////// EVENTS ////////////////////////\n\n    /**\n     * @dev IMPORTANT: copy of {TokenSilo-AddDeposit}, check there for details.\n     */\n    event AddDeposit(\n        address indexed account,\n        address indexed token,\n        int96 stem,\n        uint256 amount,\n        uint256 bdv\n    );\n\n    /**\n     * @dev IMPORTANT: copy of {TokenSilo-RemoveDeposit}, check there for details.\n     */\n    event RemoveDeposit(\n        address indexed account,\n        address indexed token,\n        int96 stem,\n        uint256 amount,\n        uint256 bdv\n    );\n\n    // added as the ERC1155 deposit upgrade\n    event TransferSingle(\n        address indexed operator,\n        address indexed sender,\n        address indexed recipient,\n        uint256 depositId,\n        uint256 amount\n    );\n\n    //////////////////////// ACCOUNTING: TOTALS GERMINATING ////////////////////////\n\n    /**\n     * @notice Increment the total amount and bdv of `token` germinating in the Silo.\n     * @dev when an asset is `deposited` in the silo, it is not immediately eliable for\n     * bean mints. It must `germinate` (stay deposited the silo) for a certain\n     * amount of seasons (the remainer of the current season + 1). This function\n     * increments the total amount and bdv germinating in the silo. The {sunrise}\n     * function ends the germination process for even or odd germinating deposits.\n     *\n     * This protects beanstalk from flashloan attacks, and makes `totalDeposited` and\n     * `totalDepositedBdv` significantly more MEV resistant.\n     */\n    function incrementTotalGerminating(\n        address token,\n        uint256 amount,\n        uint256 bdv,\n        LibGerminate.Germinate germ\n    ) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        Storage.TotalGerminating storage germinate;\n\n        // verify germ is valid\n        if (germ == LibGerminate.Germinate.ODD) {\n            germinate = s.oddGerminating;\n        } else if (germ == LibGerminate.Germinate.EVEN) {\n            germinate = s.evenGerminating;\n        } else {\n            revert(\"invalid germinationMode\"); // should not ever get here\n        }\n\n        // increment germinating amount and bdv.\n        germinate.deposited[token].amount = germinate.deposited[token].amount.add(\n            amount.toUint128()\n        );\n        germinate.deposited[token].bdv = germinate.deposited[token].bdv.add(bdv.toUint128());\n\n        // emit event.\n        emit LibGerminate.TotalGerminatingBalanceChanged(\n            s.season.current,\n            token,\n            int256(amount),\n            int256(bdv)\n        );\n    }\n\n    /**\n     * @notice Decrement the total amount and bdv of `token` germinating in the Silo.\n     * @dev `decrementTotalGerminating` should be used when removing deposits\n     * that are < 2 seasons old.\n     */\n    function decrementTotalGerminating(\n        address token,\n        uint256 amount,\n        uint256 bdv,\n        LibGerminate.Germinate germ\n    ) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        Storage.TotalGerminating storage germinate;\n\n        // verify germ is valid\n        if (germ == LibGerminate.Germinate.ODD) {\n            germinate = s.oddGerminating;\n        } else if (germ == LibGerminate.Germinate.EVEN) {\n            germinate = s.evenGerminating;\n        } else {\n            revert(\"invalid germinationMode\"); // should not ever get here\n        }\n\n        // decrement germinating amount and bdv.\n        germinate.deposited[token].amount = germinate.deposited[token].amount.sub(\n            amount.toUint128()\n        );\n        germinate.deposited[token].bdv = germinate.deposited[token].bdv.sub(bdv.toUint128());\n\n        emit LibGerminate.TotalGerminatingBalanceChanged(\n            LibGerminate.getSeasonGerminationState() == germ ? \n                s.season.current : \n                s.season.current - 1,\n            token,\n            -int256(amount),\n            -int256(bdv)\n        );\n    }\n\n    /**\n     * @notice Increment the total bdv of `token` germinating in the Silo. Used in Enroot.\n     */\n    function incrementTotalGerminatingBdv(\n        address token,\n        uint256 bdv,\n        LibGerminate.Germinate germ\n    ) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        if (germ == LibGerminate.Germinate.ODD) {\n            // increment odd germinating\n            s.oddGerminating.deposited[token].bdv = s.oddGerminating.deposited[token].bdv.add(\n                bdv.toUint128()\n            );\n        } else if (germ == LibGerminate.Germinate.EVEN) {\n            // increment even germinating\n            s.evenGerminating.deposited[token].bdv = s.evenGerminating.deposited[token].bdv.add(\n                bdv.toUint128()\n            );\n        } else {\n            revert(\"invalid germinationMode\"); // should not ever get here\n        }\n\n        emit LibGerminate.TotalGerminatingBalanceChanged(\n            LibGerminate.getSeasonGerminationState() == germ ? \n                s.season.current : \n                s.season.current - 1,\n            token,\n            0,\n            int256(bdv)\n        );\n    }\n\n    //////////////////////// ACCOUNTING: TOTALS ////////////////////////\n\n    /**\n     * @dev Increment the total amount and bdv of `token` deposited in the Silo.\n     * @dev `IncrementTotalDeposited` should be used when removing deposits that are\n     * >= 2 seasons old (ex. when a user converts).\n     */\n    function incrementTotalDeposited(address token, uint256 amount, uint256 bdv) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.siloBalances[token].deposited = s.siloBalances[token].deposited.add(amount.toUint128());\n        s.siloBalances[token].depositedBdv = s.siloBalances[token].depositedBdv.add(\n            bdv.toUint128()\n        );\n    }\n\n    /**\n     * @notice Decrement the total amount and bdv of `token` deposited in the Silo.\n     * @dev `decrementTotalDeposited` should be used when removing deposits that are\n     * >= 2 seasons old.\n     */\n    function decrementTotalDeposited(address token, uint256 amount, uint256 bdv) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.siloBalances[token].deposited = s.siloBalances[token].deposited.sub(amount.toUint128());\n        s.siloBalances[token].depositedBdv = s.siloBalances[token].depositedBdv.sub(\n            bdv.toUint128()\n        );\n    }\n\n    /**\n     * @notice Increment the total bdv of `token"
    }
  ]
}