{
  "Title": "M-4: Blacklisted creditor can block all repayment besides emergency closure",
  "Content": "# Issue M-4: Blacklisted creditor can block all repayment besides emergency closure \n\nSource: https://github.com/sherlock-audit/2023-10-real-wagmi-judging/issues/83 \n\n## Found by \n0x52, ArmedGoose, Bauer, tsvetanovv\n\nAfter liquidity is restored to the LP, accumulated fees are sent directly from the vault to the creditor. Some tokens, such as USDC and USDT, have blacklists the prevent users from sending or receiving tokens. If the creditor is blacklisted for the hold token then the fee transfer will always revert. This forces the borrower to defualt. LPs can recover their funds but only after the user has defaulted and they request emergency closure.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-10-real-wagmi/blob/main/wagmi-leverage/contracts/abstract/LiquidityManager.sol#L306-L315\n\n            address creditor = underlyingPositionManager.ownerOf(loan.tokenId);\n            // Increase liquidity and transfer liquidity owner reward\n            _increaseLiquidity(cache.saleToken, cache.holdToken, loan, amount0, amount1);\n            uint256 liquidityOwnerReward = FullMath.mulDiv(\n                params.totalfeesOwed,\n                cache.holdTokenDebt,\n                params.totalBorrowedAmount\n            ) / Constants.COLLATERAL_BALANCE_PRECISION;\n\n            Vault(VAULT_ADDRESS).transferToken(cache.holdToken, creditor, liquidityOwnerReward);\n\nThe following code is executed for each loan when attempting to repay. Here we see that each creditor is directly transferred their tokens from the vault. If the creditor is blacklisted for holdToken, then the transfer will revert. This will cause all repayments to revert, preventing the user from ever repaying their loan and forcing them to default. \n\n## Impact\n\nBorrowers with blacklisted creditors are forced to default\n\n## Code Snippet\n\n[LiquidityManager.sol#L223-L321](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/main/wagmi-leverage/contracts/abstract/LiquidityManager.sol#L223-L321)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCreate an escrow to hold funds in the event that the creditor cannot receive their funds. Implement a try-catch block around the transfer to the creditor. If it fails then send the funds instead to an escrow account, allowing the creditor to claim their tokens later and for the transaction to complete.\n\n\n\n## Discussion\n\n**fann95**\n\nFixed: https://github.com/RealWagmi/wagmi-leverage/commit/3c17a39e8a69a8912e6f87e84a19f55889353328\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/118",
  "Code": [
    {
      "filename": "wagmi-leverage/contracts/abstract/LiquidityManager.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\nimport \"../vendor0.8/uniswap/LiquidityAmounts.sol\";\nimport \"../vendor0.8/uniswap/TickMath.sol\";\nimport \"../interfaces/INonfungiblePositionManager.sol\";\nimport \"../interfaces/IQuoterV2.sol\";\nimport \"./ApproveSwapAndPay.sol\";\nimport \"../Vault.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\n\nabstract contract LiquidityManager is ApproveSwapAndPay {\n    /**\n     * @notice Represents information about a loan.\n     * @dev This struct is used to store liquidity and tokenId for a loan.\n     * @param liquidity The amount of liquidity for the loan represented by a uint128 value.\n     * @param tokenId The token ID associated with the loan represented by a uint256 value.\n     */\n    struct LoanInfo {\n        uint128 liquidity;\n        uint256 tokenId;\n    }\n    /**\n     * @notice Contains parameters for restoring liquidity.\n     * @dev This struct is used to store various parameters required for restoring liquidity.\n     * @param zeroForSaleToken A boolean value indicating whether the token for sale is the 0th token or not.\n     * @param fee The fee associated with the internal swap pool is represented by a uint24 value.\n     * @param slippageBP1000 The slippage in basis points (BP) represented by a uint256 value.\n     * @param totalfeesOwed The total fees owed represented by a uint256 value.\n     * @param totalBorrowedAmount The total borrowed amount represented by a uint256 value.\n     */\n    struct RestoreLiquidityParams {\n        bool zeroForSaleToken;\n        uint24 fee;\n        uint256 slippageBP1000;\n        uint256 totalfeesOwed;\n        uint256 totalBorrowedAmount;\n    }\n    /**\n     * @notice Contains cache data for restoring liquidity.\n     * @dev This struct is used to store cached values required for restoring liquidity.\n     * @param tickLower The lower tick boundary represented by an int24 value.\n     * @param tickUpper The upper tick boundary represented by an int24 value.\n     * @param fee The fee associated with the restoring liquidity pool.\n     * @param saleToken The address of the token being sold.\n     * @param holdToken The address of the token being held.\n     * @param sqrtPriceX96 The square root of the price represented by a uint160 value.\n     * @param holdTokenDebt The debt amount associated with the hold token represented by a uint256 value.\n     */\n    struct RestoreLiquidityCache {\n        int24 tickLower;\n        int24 tickUpper;\n        uint24 fee;\n        address saleToken;\n        address holdToken;\n        uint160 sqrtPriceX96;\n        uint256 holdTokenDebt;\n    }\n    /**\n     * @notice The address of the vault contract.\n     */\n    address public immutable VAULT_ADDRESS;\n    /**\n     * @notice The Nonfungible Position Manager contract.\n     */\n    INonfungiblePositionManager public immutable underlyingPositionManager;\n    /**\n     * @notice The QuoterV2 contract.\n     */\n    IQuoterV2 public immutable underlyingQuoterV2;\n\n    /**\n     * @dev Contract constructor.\n     * @param _underlyingPositionManagerAddress Address of the underlying position manager contract.\n     * @param _underlyingQuoterV2 Address of the underlying quoterV2 contract.\n     * @param _underlyingV3Factory Address of the underlying V3 factory contract.\n     * @param _underlyingV3PoolInitCodeHash The init code hash of the underlying V3 pool.\n     */\n    constructor(\n        address _underlyingPositionManagerAddress,\n        address _underlyingQuoterV2,\n        address _underlyingV3Factory,\n        bytes32 _underlyingV3PoolInitCodeHash\n    ) ApproveSwapAndPay(_underlyingV3Factory, _underlyingV3PoolInitCodeHash) {\n        // Assign the underlying position manager contract address\n        underlyingPositionManager = INonfungiblePositionManager(_underlyingPositionManagerAddress);\n        // Assign the underlying quoterV2 contract address\n        underlyingQuoterV2 = IQuoterV2(_underlyingQuoterV2);\n        // Generate a unique salt for the new Vault contract\n        bytes32 salt = keccak256(abi.encode(block.timestamp, address(this)));\n        // Deploy a new Vault contract using the generated salt and assign its address to VAULT_ADDRESS\n        VAULT_ADDRESS = address(new Vault{ salt: salt }());\n    }\n\n    error InvalidBorrowedLiquidity(uint256 tokenId);\n    error TooLittleBorrowedLiquidity(uint128 liquidity);\n    error InvalidTokens(uint256 tokenId);\n    error NotApproved(uint256 tokenId);\n    error InvalidRestoredLiquidity(\n        uint256 tokenId,\n        uint128 borrowedLiquidity,\n        uint128 restoredLiquidity,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 holdTokentBalance,\n        uint256 saleTokenBalance\n    );\n\n    /**\n     * @dev Calculates the borrowed amount from a pool's single side position, rounding up if necessary.\n     * @param zeroForSaleToken A boolean value indicating whether the token for sale is the 0th token or not.\n     * @param tickLower The lower tick value of the position range.\n     * @param tickUpper The upper tick value of the position range.\n     * @param liquidity The liquidity of the position.\n     * @return borrowedAmount The calculated borrowed amount.\n     */\n    function _getSingleSideRoundUpBorrowedAmount(\n        bool zeroForSaleToken,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 liquidity\n    ) private pure returns (uint256 borrowedAmount) {\n        borrowedAmount = (\n            zeroForSaleToken\n                ? LiquidityAmounts.getAmount1ForLiquidity(\n                    TickMath.getSqrtRatioAtTick(tickLower),\n                    TickMath.getSqrtRatioAtTick(tickUpper),\n                    liquidity\n                )\n                : LiquidityAmounts.getAmount0ForLiquidity(\n                    TickMath.getSqrtRatioAtTick(tickLower),\n                    TickMath.getSqrtRatioAtTick(tickUpper),\n                    liquidity\n                )\n        );\n        if (borrowedAmount > Constants.MINIMUM_BORROWED_AMOUNT) {\n            ++borrowedAmount;\n        } else {\n            revert TooLittleBorrowedLiquidity(liquidity);\n        }\n    }\n\n    /**\n     * @dev Extracts liquidity from loans and returns the borrowed amount.\n     * @param zeroForSaleToken A boolean value indicating whether the token for sale is the 0th token or not.\n     * @param token0 The address of one of the tokens in the pair.\n     * @param token1 The address of the other token in the pair.\n     * @param loans An array of LoanInfo struct instances containing loan information.\n     * @return borrowedAmount The total amount borrowed.\n     */\n    function _extractLiquidity(\n        bool zeroForSaleToken,\n        address token0,\n        address token1,\n        LoanInfo[] memory loans\n    ) internal returns (uint256 borrowedAmount) {\n        if (!zeroForSaleToken) {\n            (token0, token1) = (token1, token0);\n        }\n\n        for (uint256 i; i < loans.length; ) {\n            uint256 tokenId = loans[i].tokenId;\n            uint128 liquidity = loans[i].liquidity;\n            // Extract position-related details\n            {\n                int24 tickLower;\n                int24 tickUpper;\n                uint128 posLiquidity;\n                {\n                    address operator;\n                    address posToken0;\n                    address posToken1;\n\n                    (\n                        ,\n                        operator,\n                        posToken0,\n                        posToken1,\n                        ,\n                        tickLower,\n                        tickUpper,\n                        posLiquidity,\n                        ,\n                        ,\n                        ,\n\n                    ) = underlyingPositionManager.positions(tokenId);\n                    // Check operator approval\n                    if (operator != address(this)) {\n                        revert NotApproved(tokenId);\n                    }\n                    // Check token validity\n                    if (posToken0 != token0 || posToken1 != token1) {\n                        revert InvalidTokens(tokenId);\n                    }\n                }\n                // Check borrowed liquidity validity\n                if (!(liquidity > 0 && liquidity <= posLiquidity)) {\n                    revert InvalidBorrowedLiquidity(tokenId);\n                }\n                // Calculate borrowed amount\n                borrowedAmount += _getSingleSideRoundUpBorrowedAmount(\n                    zeroForSaleToken,\n                    tickLower,\n                    tickUpper,\n                    liquidity\n                );\n            }\n            // Decrease liquidity and move to the next loan\n            _decreaseLiquidity(tokenId, liquidity);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Restores liquidity from loans.\n     * @param params The RestoreLiquidityParams struct containing restoration parameters.\n     * @param externalSwap The SwapParams struct containing external swap details.\n     * @param loans An array of LoanInfo struct instances containing loan information.\n     */\n    function _restoreLiquidity(\n        // Create a cache struct to store temporary data\n        RestoreLiquidityParams memory params,\n        SwapParams calldata externalSwap,\n        LoanInfo[] memory loans\n    ) internal {\n        RestoreLiquidityCache memory cache;\n        for (uint256 i; i < loans.length; ) {\n            // Update the cache for the current loan\n            LoanInfo memory loan = loans[i];\n            _upRestoreLiquidityCache(params.zeroForSaleToken, loan, cache);\n            // Calculate the hold token amount to be used for swapping\n            (uint256 holdTokenAmountIn, uint256 amount0, uint256 amount1) = _getHoldTokenAmountIn(\n                params.zeroForSaleToken,\n                cache.tickLower,\n                cache.tickUpper,\n                cache.sqrtPriceX96,\n                loan.liquidity,\n                cache.holdTokenDebt\n            );\n\n            if (holdTokenAmountIn > 0) {\n                // Quote exact input single for swap\n                uint256 saleTokenAmountOut;\n                (saleTokenAmountOut, cache.sqrtPriceX96, , ) = underlyingQuoterV2\n                    .quoteExactInputSingle(\n                        IQuoterV2.QuoteExactInputSingleParams({\n                            tokenIn: cache.holdToken,\n                            tokenOut: cache.saleToken,\n                            amountIn: holdTokenAmountIn,\n                            fee: params.fee,\n                            sqrtPriceLimitX96: 0\n                        })\n                    );\n\n                // Perform external swap if external swap target is provided\n                if (externalSwap.swapTarget != address(0)) {\n                    _patchAmountsAndCallSwap(\n                        cache.holdToken,\n                        cache.saleToken,\n                        externalSwap,\n                        holdTokenAmountIn,\n                        (saleTokenAmountOut * params.slippageBP1000) / Constants.BPS\n                    );\n                } else {\n                    // Calculate hold token amount in again for new sqrtPriceX96\n                    (holdTokenAmountIn, , ) = _getHoldTokenAmountIn(\n                        params.zeroForSaleToken,\n                        cache.tickLower,\n                        cache.tickUpper,\n                        cache.sqrtPriceX96,\n                        loan.liquidity,\n                        cache.holdTokenDebt\n                    );\n\n                    // Perform v3 swap exact input and update sqrtPriceX96\n                    _v3SwapExactInput(\n                        v3SwapExactInputParams({\n                            fee: params.fee,\n                            tokenIn: cache.holdToken,\n                            tokenOut: cache.saleToken,\n                            amountIn: holdTokenAmountIn,\n                            amountOutMinimum: (saleTokenAmountOut * params.slippageBP1000) /\n                                Constants.BPS\n                        })\n                    );\n                    // Update the value of sqrtPriceX96 in the cache using the _getCurrentSqrtPriceX96 function\n                    cache.sqrtPriceX96 = _getCurrentSqrtPriceX96(\n                        params.zeroForSaleToken,\n                        cache.saleToken,\n                        cache.holdToken,\n                        cache.fee\n                    );\n                    // Calculate the amounts of token0 and token1 for a given liquidity\n                    (amount0, amount1) = LiquidityAmounts.getAmountsForLiquidity(\n                        cache.sqrtPriceX96,\n                        TickMath.getSqrtRatioAtTick(cache.tickLower),\n                        TickMath.getSqrtRatioAtTick(cache.tickUpper),\n                        loan.liquidity\n                    );\n                }\n            }\n            // Get the owner of the Nonfungible Position Manager token by its tokenId\n            address creditor = underlyingPositionManager.ownerOf(loan.tokenId);\n            // Increase liquidity and transfer liquidity owner reward\n            _increaseLiquidity(cache.saleToken, cache.holdToken, loan, amount0, amount1);\n            uint256 liquidityOwnerReward = FullMath.mulDiv(\n                params.totalfeesOwed,\n                cache.holdTokenDebt,\n                params.totalBorrowedAmount\n            ) / Constants.COLLATERAL_BALANCE_PRECISION;\n\n            Vault(VAULT_ADDRESS).transferToken(cache.holdToken, creditor, liquidityOwnerReward);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Retrieves the current square root price in X96 representation.\n     * @param zeroForA Flag indicating whether to treat the tokenA as the 0th token or not.\n     * @param tokenA The address of token A.\n     * @param tokenB The address of token B.\n     * @param fee The fee associated with the Uniswap V3 pool.\n     * @return sqrtPriceX96 The current square root price in X96 representation.\n     */\n    function _getCurrentSqrtPriceX96(\n        bool zeroForA,\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) private view returns (uint160 sqrtPriceX96) {\n        if (!zeroForA) {\n            (tokenA, tokenB) = (tokenB, tokenA);\n        }\n        address poolAddress = computePoolAddress(tokenA, tokenB, fee);\n        (sqrtPriceX96, , , , , , ) = IUniswapV3Pool(poolAddress).slot0();\n    }\n\n    /**\n     * @dev Decreases the liquidity of a position by removing tokens.\n     * @param tokenId The ID of the position token.\n     * @param liquidity The amount of liquidity to be removed.\n     */\n    function _decreaseLiquidity(uint256 tokenId, uint128 liquidity) private {\n        // Call the decreaseLiquidity function of underlyingPositionManager contract\n        // with DecreaseLiquidityParams struct as argument\n        (uint256 amount0, uint256 amount1) = underlyingPositionManager.decreaseLiquidity(\n            INonfungiblePositionManager.DecreaseLiquidityParams({\n                tokenId: tokenId,\n                liquidity: liquidity,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            })\n        );\n        // Check if both amount0 and amount1 are zero after decreasing liquidity\n        // If true, revert with InvalidBorrowedLiquidity exception\n        if (amount0 == 0 && amount1 == 0) {\n            revert InvalidBorrowedLiquidity(tokenId);\n        }\n        // Call the collect function of underlyingPositionManager contract\n        // with CollectParams struct as argument\n        (amount0, amount1) = underlyingPositionManager.collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: tokenId,\n                recipient: address(this),\n                amount0Max: uint128(amount0),\n                amount1Max: uint128(amount1)\n            })\n        );\n    }\n\n    /**\n     * @dev Increases the liquidity of a position by providing additional tokens.\n     * @param saleToken The address of the sale token.\n     * @param holdToken The address of the hold token.\n     * @param loan An instance of LoanInfo memory struct containing loan details.\n     * @param amount0 The amount of token0 to be added to the liquidity.\n     * @param amount1 The amount of token1 to be added to the liquidity.\n     */\n    function _increaseLiquidity(\n        address saleToken,\n        address holdToken,\n        LoanInfo memory loan,\n        uint256 amount0,\n        uint256 amount1\n    ) private {\n        // increase if not equal to zero to avoid rounding down the amount of restored liquidity.\n        if (amount0 > 0) ++amount0;\n        if (amount1 > 0) ++amount1;\n        // Call the increaseLiquidity function of underlyingPositionManager contract\n        // with IncreaseLiquidityParams struct as argument\n        (uint128 restoredLiquidity, , ) = underlyingPositionManager.increaseLiquidity(\n            INonfungiblePositionManager.IncreaseLiquidityParams({\n                tokenId: loan.tokenId,\n                amount0Desired: amount0,\n                amount1Desired: amount1,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            })\n        );\n        // Check if the restored liquidity is less than the loan liquidity amount\n        // If true, revert with InvalidRestoredLiquidity exception\n        if (restoredLiquidity < loan.liquidity) {\n            // Get the balance of holdToken and saleToken\n            (uint256 holdTokentBalance, uint256 saleTokenBalance) = _getPairBalance(\n                holdToken,\n                saleToken\n            );\n\n            revert InvalidRestoredLiquidity(\n                loan.tokenId,\n                loan.liquidity,\n                restoredLiquidity,\n                amount0,\n                amount1,\n                holdTokentBalance,\n                saleTokenBalance\n            );\n        }\n    }\n\n    /**\n     * @dev Calculates the amount of hold token required for a swap.\n     * @param zeroForSaleToken A boolean value indicating whether the token for sale is the 0th token or not.\n     * @param tickLower The lower tick of the liquidity range.\n     * @param tickUpper The upper tick of the liquidity range.\n     * @param sqrtPriceX96 The square root of the price ratio of the sale token to the hold token.\n     * @param liquidity The amount of liquidity.\n     * @param holdTokenDebt The amount of hold token debt.\n     * @return holdTokenAmountIn The amount of hold token needed to provide the specified liquidity.\n     * @return amount0 The amount of token0 calculated based on the liquidity.\n     * @return amount1 The amount of token1 calculated based on the liquidity.\n     */\n    function _getHoldTokenAmountIn(\n        bool zeroForSaleToken,\n        int24 tickLower,\n        int24 tickUpper,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        uint256 holdTokenDebt\n    ) private pure returns (uint256 holdTokenAmountIn, uint256 amount0, uint256 amount1) {\n        // Call getAmountsForLiquidity function from LiquidityAmounts library\n        // to get the amounts of token0 and token1 for a given liquidity position\n        (amount0, amount1) = LiquidityAmounts.getAmountsForLiquidity(\n            sqrtPriceX96,\n            TickMath.getSqrtRatioAtTick(tickLower),\n            TickMath.getSqrtRatioAtTick(tickUpper),\n            liquidity\n        );\n        // Calculate the holdTokenAmountIn based on the zeroForSaleToken flag\n        if (zeroForSaleToken) {\n            // If zeroForSaleToken is true, check if amount0 is zero\n            // If true, holdTokenAmountIn will be zero. Otherwise, it will be holdTokenDebt - amount1\n            holdTokenAmountIn = amount0 == 0 ? 0 : holdTokenDebt - amount1;\n        } else {\n            // If zeroForSaleToken is false, check if amount1 is zero\n            // If true, holdTokenAmountIn will be zero. Otherwise, it will be holdTokenDebt - amount0\n            holdTokenAmountIn = amount1 == 0 ? 0 : holdTokenDebt - amount0;\n        }\n    }\n\n    /**\n     * @dev Updates the RestoreLiquidityCache struct with data from the underlyingPositionManager contract.\n     * @param zeroForSaleToken A boolean value indicating whether the token for sale is the 0th token or not.\n     * @param loan The LoanInfo struct containing loan details.\n     * @param cache The RestoreLiquidityCache struct to be updated.\n     */\n    function _upRestoreLiquidityCache(\n        bool zeroForSaleToken,\n        LoanInfo memory loan,\n        RestoreLiquidityCache memory cache\n    ) internal view {\n        // Get the positions data from `PositionManager` and store it in the cache variables\n        (\n            ,\n            ,\n            cache.saleToken,\n            cache.holdToken,\n            cache.fee,\n            cache.tickLower,\n            cache.tickUpper,\n            ,\n            ,\n            ,\n            ,\n\n        ) = underlyingPositionManager.positions(loan.tokenId);\n        // Swap saleToken and holdToken if zeroForSaleToken is false\n        if (!zeroForSaleToken) {\n            (cache.saleToken, cache.holdToken) = (cache.holdToken, cache.saleToken);\n        }\n        // Calculate the holdTokenDebt using\n        cache.holdTokenDebt = _getSingleSideRoundUpBorrowedAmount(\n            zeroForSaleToken,\n            cache.tickLower,\n            cache.tickUpper,\n            loan.liquidity\n        );\n        // Calculate the square root price using `_getCurrentSqrtPriceX96` function\n        cache.sqrtPriceX96 = _getCurrentSqrtPriceX96(\n            zeroForSaleToken,\n            cache.saleToken,\n            cache.holdToken,\n            cache.fee\n        );\n    }\n}"
    },
    {
      "filename": "wagmi-leverage/contracts/abstract/LiquidityManager.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\nimport \"../vendor0.8/uniswap/LiquidityAmounts.sol\";\nimport \"../vendor0.8/uniswap/TickMath.sol\";\nimport \"../interfaces/INonfungiblePositionManager.sol\";\nimport \"../interfaces/IQuoterV2.sol\";\nimport \"./ApproveSwapAndPay.sol\";\nimport \"../Vault.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\n\nabstract contract LiquidityManager is ApproveSwapAndPay {\n    /**\n     * @notice Represents information about a loan.\n     * @dev This struct is used to store liquidity and tokenId for a loan.\n     * @param liquidity The amount of liquidity for the loan represented by a uint128 value.\n     * @param tokenId The token ID associated with the loan represented by a uint256 value.\n     */\n    struct LoanInfo {\n        uint128 liquidity;\n        uint256 tokenId;\n    }\n    /**\n     * @notice Contains parameters for restoring liquidity.\n     * @dev This struct is used to store various parameters required for restoring liquidity.\n     * @param zeroForSaleToken A boolean value indicating whether the token for sale is the 0th token or not.\n     * @param fee The fee associated with the internal swap pool is represented by a uint24 value.\n     * @param slippageBP1000 The slippage in basis points (BP) represented by a uint256 value.\n     * @param totalfeesOwed The total fees owed represented by a uint256 value.\n     * @param totalBorrowedAmount The total borrowed amount represented by a uint256 value.\n     */\n    struct RestoreLiquidityParams {\n        bool zeroForSaleToken;\n        uint24 fee;\n        uint256 slippageBP1000;\n        uint256 totalfeesOwed;\n        uint256 totalBorrowedAmount;\n    }\n    /**\n     * @notice Contains cache data for restoring liquidity.\n     * @dev This struct is used to store cached values required for restoring liquidity.\n     * @param tickLower The lower tick boundary represented by an int24 value.\n     * @param tickUpper The upper tick boundary represented by an int24 value.\n     * @param fee The fee associated with the restoring liquidity pool.\n     * @param saleToken The address of the token being sold.\n     * @param holdToken The address of the token being held.\n     * @param sqrtPriceX96 The square root of the price represented by a uint160 value.\n     * @param holdTokenDebt The debt amount associated with the hold token represented by a uint256 value.\n     */\n    struct RestoreLiquidityCache {\n        int24 tickLower;\n        int24 tickUpper;\n        uint24 fee;\n        address saleToken;\n        address holdToken;\n        uint160 sqrtPriceX96;\n        uint256 holdTokenDebt;\n    }\n    /**\n     * @notice The address of the vault contract.\n     */\n    address public immutable VAULT_ADDRESS;\n    /**\n     * @notice The Nonfungible Position Manager contract.\n     */\n    INonfungiblePositionManager public immutable underlyingPositionManager;\n    /**\n     * @notice The QuoterV2 contract.\n     */\n    IQuoterV2 public immutable underlyingQuoterV2;\n\n    /**\n     * @dev Contract constructor.\n     * @param _underlyingPositionManagerAddress Address of the underlying position manager contract.\n     * @param _underlyingQuoterV2 Address of the underlying quoterV2 contract.\n     * @param _underlyingV3Factory Address of the underlying V3 factory contract.\n     * @param _underlyingV3PoolInitCodeHash The init code hash of the underlying V3 pool.\n     */\n    constructor(\n        address _underlyingPositionManagerAddress,\n        address _underlyingQuoterV2,\n        address _underlyingV3Factory,\n        bytes32 _underlyingV3PoolInitCodeHash\n    ) ApproveSwapAndPay(_underlyingV3Factory, _underlyingV3PoolInitCodeHash) {\n        // Assign the underlying position manager contract address\n        underlyingPositionManager = INonfungiblePositionManager(_underlyingPositionManagerAddress);\n        // Assign the underlying quoterV2 contract address\n        underlyingQuoterV2 = IQuoterV2(_underlyingQuoterV2);\n        // Generate a unique salt for the new Vault contract\n        bytes32 salt = keccak256(abi.encode(block.timestamp, address(this)));\n        // Deploy a new Vault contract using the generated salt and assign its address to VAULT_ADDRESS\n        VAULT_ADDRESS = address(new Vault{ salt: salt }());\n    }\n\n    error InvalidBorrowedLiquidity(uint256 tokenId);\n    error TooLittleBorrowedLiquidity(uint128 liquidity);\n    error InvalidTokens(uint256 tokenId);\n    error NotApproved(uint256 tokenId);\n    error InvalidRestoredLiquidity(\n        uint256 tokenId,\n        uint128 borrowedLiquidity,\n        uint128 restoredLiquidity,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 holdTokentBalance,\n        uint256 saleTokenBalance\n    );\n\n    /**\n     * @dev Calculates the borrowed amount from a pool's single side position, rounding up if necessary.\n     * @param zeroForSaleToken A boolean value indicating whether the token for sale is the 0th token or not.\n     * @param tickLower The lower tick value of the position range.\n     * @param tickUpper The upper tick value of the position range.\n     * @param liquidity The liquidity of the position.\n     * @return borrowedAmount The calculated borrowed amount.\n     */\n    function _getSingleSideRoundUpBorrowedAmount(\n        bool zeroForSaleToken,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 liquidity\n    ) private pure returns (uint256 borrowedAmount) {\n        borrowedAmount = (\n            zeroForSaleToken\n                ? LiquidityAmounts.getAmount1ForLiquidity(\n                    TickMath.getSqrtRatioAtTick(tickLower),\n                    TickMath.getSqrtRatioAtTick(tickUpper),\n                    liquidity\n                )\n                : LiquidityAmounts.getAmount0ForLiquidity(\n                    TickMath.getSqrtRatioAtTick(tickLower),\n                    TickMath.getSqrtRatioAtTick(tickUpper),\n                    liquidity\n                )\n        );\n        if (borrowedAmount > Constants.MINIMUM_BORROWED_AMOUNT) {\n            ++borrowedAmount;\n        } else {\n            revert TooLittleBorrowedLiquidity(liquidity);\n        }\n    }\n\n    /**\n     * @dev Extracts liquidity from loans and returns the borrowed amount.\n     * @param zeroForSaleToken A boolean value indicating whether the token for sale is the 0th token or not.\n     * @param token0 The address of one of the tokens in the pair.\n     * @param token1 The address of the other token in the pair.\n     * @param loans An array of LoanInfo struct instances containing loan information.\n     * @return borrowedAmount The total amount borrowed.\n     */\n    function _extractLiquidity(\n        bool zeroForSaleToken,\n        address token0,\n        address token1,\n        LoanInfo[] memory loans\n    ) internal returns (uint256 borrowedAmount) {\n        if (!zeroForSaleToken) {\n            (token0, token1) = (token1, token0);\n        }\n\n        for (uint256 i; i < loans.length; ) {\n            uint256 tokenId = loans[i].tokenId;\n            uint128 liquidity = loans[i].liquidity;\n            // Extract position-related details\n            {\n                int24 tickLower;\n                int24 tickUpper;\n                uint128 posLiquidity;\n                {\n                    address operator;\n                    address posToken0;\n                    address posToken1;\n\n                    (\n                        ,\n                        operator,\n                        posToken0,\n                        posToken1,\n                        ,\n                        tickLower,\n                        tickUpper,\n                        posLiquidity,\n                        ,\n                        ,\n                        ,\n\n                    ) = underlyingPositionManager.positions(tokenId);\n                    // Check operator approval\n                    if (operator != address(this)) {\n                        revert NotApproved(tokenId);\n                    }\n                    // Check token validity\n                    if (posToken0 != token0 || posToken1 != token1) {\n                        revert InvalidTokens(tokenId);\n                    }\n                }\n                // Check borrowed liquidity validity\n                if (!(liquidity > 0 && liquidity <= posLiquidity)) {\n                    revert InvalidBorrowedLiquidity(tokenId);\n                }\n                // Calculate borrowed amount\n                borrowedAmount += _getSingleSideRoundUpBorrowedAmount(\n                    zeroForSaleToken,\n                    tickLower,\n                    tickUpper,\n                    liquidity\n                );\n            }\n            // Decrease liquidity and move to the next loan\n            _decreaseLiquidity(tokenId, liquidity);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Restores liquidity from loans.\n     * @param params The RestoreLiquidityParams struct containing restoration parameters.\n     * @param externalSwap The SwapParams struct containing external swap details.\n     * @param loans An array of LoanInfo struct instances containing loan information.\n     */\n    function _restoreLiquidity(\n        // Create a cache struct to store temporary data\n        RestoreLiquidityParams memory params,\n        SwapParams calldata externalSwap,\n        LoanInfo[] memory loans\n    ) internal {\n        RestoreLiquidityCache memory cache;\n        for (uint256 i; i < loans.length; ) {\n            // Update the cache for the current loan\n            LoanInfo memory loan = loans[i];\n            _upRestoreLiquidityCache(params.zeroForSaleToken, loan, cache);\n            // Calculate the hold token amount to be used for swapping\n            (uint256 holdTokenAmountIn, uint256 amount0, uint256 amount1) = _getHoldTokenAmountIn(\n                params.zeroForSaleToken,\n                cache.tickLower,\n                cache.tickUpper,\n                cache.sqrtPriceX96,\n                loan.liquidity,\n                cache.holdTokenDebt\n            );\n\n            if (holdTokenAmountIn > 0) {\n                // Quote exact input single for swap\n                uint256 saleTokenAmountOut;\n                (saleTokenAmountOut, cache.sqrtPriceX96, , ) = underlyingQuoterV2\n                    .quoteExactInputSingle(\n                        IQuoterV2.QuoteExactInputSingleParams({\n                            tokenIn: cache.holdToken,\n                            tokenOut: cache.saleToken,\n                            amountIn: holdTokenAmountIn,\n                            fee: params.fee,\n                            sqrtPriceLimitX96: 0\n                        })\n                    );\n\n                // Perform external swap if external swap target is provided\n                if (externalSwap.swapTarget != address(0)) {\n                    _patchAmountsAndCallSwap(\n                        cache.holdToken,"
    }
  ]
}