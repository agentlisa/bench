{
  "Title": "H-1: Highest bidder can withdraw his collateral due to a missing check in _cancelAllBids",
  "Content": "# Issue H-1: Highest bidder can withdraw his collateral due to a missing check in _cancelAllBids \n\nSource: https://github.com/sherlock-audit/2024-02-radicalxchange-judging/issues/14 \n\n## Found by \n0rpse, 0xKartikgiri00, 0xPwned, 0xShitgem, 0xboriskataa, 0xbrivan, 14si2o\\_Flint, 404666, AMOW, Aamirusmani1552, AgileJune, Al-Qa-qa, Atharv, CarlosAlbaWork, DMoore, DenTonylifer, Dots, FSchmoede, FassiSecurity, FastTiger, Krace, Marcologonz, SovaSlava, Tendency, Tricko, aycozynfada, cats, cawfree, cocacola, cu5t0mPe0, dipp, ethernal, fugazzi, ge6a, jah, jasonxiale, ke1caM, koreanspicygarlic, kuprum, ljj, merlin, mrBmbastic, neocrao, neon2835, offside0011, psb01, pseudoArtist, pynschon, sammy, sandy, tedox, thank\\_you, theFirstElder, theOwl, thisvishalsingh, turvec, valentin2304, zraxx, zzykxx\n## Summary\n\nA bidder with the highest bid cannot cancel his bid since this would break the auction. A check to ensure this was implemented in `_cancelBid`.\n\nHowever, this check was not implemented in `_cancelAllBids`, allowing the highest bidder to withdraw his collateral and win the auction for free.  \n\n## Vulnerability Detail\n\nThe highest bidder should not be able to cancel his bid, since this would break the entire auction mechanism. \n\nIn `_cancelBid` we can find a require check that ensures this:\n\n```solidity\n        require(\n            bidder != l.highestBids[tokenId][round].bidder,\n            'EnglishPeriodicAuction: Cannot cancel bid if highest bidder'\n        );\n\n```\nYet in `_cancelAllBids`, this check was not implemented. \n```solidity\n     * @notice Cancel bids for all rounds\n     */\n    function _cancelAllBids(uint256 tokenId, address bidder) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        uint256 currentAuctionRound = l.currentAuctionRound[tokenId];\n\n        for (uint256 i = 0; i <= currentAuctionRound; i++) {\n            Bid storage bid = l.bids[tokenId][i][bidder];\n\n            if (bid.collateralAmount > 0) {\n                // Make collateral available to withdraw\n                l.availableCollateral[bidder] += bid.collateralAmount;\n\n                // Reset collateral and bid\n                bid.collateralAmount = 0;\n                bid.bidAmount = 0;\n            }\n        }\n    }\n\n```\nExample: \nUser Bob bids 10 eth and takes the highest bidder spot. \nBob calls `cancelAllBidsAndWithdrawCollateral`.\n\nThe `_cancelAllBids` function is called and this makes all the collateral from all his bids from every round available to Bob. This includes the current round `<=` and does not check if Bob is the current highest bidder. Nor is `l.highestBids[tokenId][round].bidder` reset, so the system still has Bob as the highest bidder. \n\nThen `_withdrawCollateral` is automatically called and Bob receives his 10 eth  back. \n\nThe auction ends. If Bob is still the highest bidder, he wins the auction and his bidAmount of 10 eth is added to the availableCollateral of the oldBidder. \n\nIf there currently is more than 10 eth in the contract (ongoing auctions, bids that have not withdrawn), then the oldBidder can withdraw 10 eth. But this means that in the future a withdraw will fail due to this missing 10 eth. \n\n## Impact\n\nA malicious user can win an auction for free. \n\nAdditionally, either the oldBidder or some other user in the future will suffer the loss.  \n\nIf this is repeated multiple times, it will drain the contract balance and all users will lose their locked collateral. \n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-02-radicalxchange/blob/main/pco-art/contracts/auction/EnglishPeriodicAuctionInternal.sol#L416-L436\n\nhttps://github.com/sherlock-audit/2024-02-radicalxchange/blob/main/pco-art/contracts/auction/EnglishPeriodicAuctionInternal.sol#L380-L413\n\nhttps://github.com/sherlock-audit/2024-02-radicalxchange/blob/main/pco-art/contracts/auction/EnglishPeriodicAuctionInternal.sol#L468-L536\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nImplement the require check from _cancelBid to _cancelAllBids.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/191",
  "Code": [
    {
      "filename": "pco-art/contracts/auction/EnglishPeriodicAuctionInternal.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { EnglishPeriodicAuctionStorage } from './EnglishPeriodicAuctionStorage.sol';\nimport { IPeriodicPCOParamsReadable } from '../pco/IPeriodicPCOParamsReadable.sol';\nimport { IStewardLicense } from '../license/IStewardLicense.sol';\nimport { IBeneficiary } from '../beneficiary/IBeneficiary.sol';\nimport { IEnglishPeriodicAuctionInternal } from './IEnglishPeriodicAuctionInternal.sol';\n\n/**\n * @title EnglishPeriodicAuctionInternal\n */\nabstract contract EnglishPeriodicAuctionInternal is\n    IEnglishPeriodicAuctionInternal\n{\n    /**\n     * @notice Initialize parameters\n     */\n    function _initializeAuction(\n        address repossessor,\n        address initialBidder,\n        uint256 initialPeriodStartTime,\n        uint256 initialPeriodStartTimeOffset,\n        uint256 startingBid,\n        uint256 auctionLengthSeconds,\n        uint256 minBidIncrement,\n        uint256 bidExtensionWindowLengthSeconds,\n        uint256 bidExtensionSeconds\n    ) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        l.isInitialized = true;\n        l.initialBidder = initialBidder;\n        l.initialPeriodStartTimeOffset = initialPeriodStartTimeOffset;\n        l.initialPeriodStartTime = initialPeriodStartTime;\n        _setStartingBid(startingBid);\n        _setRepossessor(repossessor);\n        _setAuctionLengthSeconds(auctionLengthSeconds);\n        _setMinBidIncrement(minBidIncrement);\n        _setBidExtensionWindowLengthSeconds(bidExtensionWindowLengthSeconds);\n        _setBidExtensionSeconds(bidExtensionSeconds);\n    }\n\n    /**\n     * @notice Set auction parameters\n     */\n    function _setAuctionParameters(\n        address repossessor,\n        uint256 auctionLengthSeconds,\n        uint256 minBidIncrement,\n        uint256 bidExtensionWindowLengthSeconds,\n        uint256 bidExtensionSeconds,\n        uint256 startingBid\n    ) internal {\n        _setRepossessor(repossessor);\n        _setAuctionLengthSeconds(auctionLengthSeconds);\n        _setMinBidIncrement(minBidIncrement);\n        _setBidExtensionWindowLengthSeconds(bidExtensionWindowLengthSeconds);\n        _setBidExtensionSeconds(bidExtensionSeconds);\n        _setStartingBid(startingBid);\n    }\n\n    /**\n     * @notice Check if initialized\n     */\n    function _isInitialized() internal view returns (bool) {\n        return EnglishPeriodicAuctionStorage.layout().isInitialized;\n    }\n\n    /**\n     * @notice Get starting bid\n     */\n    function _startingBid() internal view returns (uint256) {\n        return EnglishPeriodicAuctionStorage.layout().startingBid;\n    }\n\n    /**\n     * @notice Get repossessor\n     */\n    function _repossessor() internal view returns (address) {\n        return EnglishPeriodicAuctionStorage.layout().repossessor;\n    }\n\n    /**\n     * @notice Set repossessor\n     */\n    function _setRepossessor(address repossessor) internal {\n        EnglishPeriodicAuctionStorage.layout().repossessor = repossessor;\n\n        emit RepossessorSet(repossessor);\n    }\n\n    /**\n     * @notice Get initial period start time\n     */\n    function _initialPeriodStartTime() internal view returns (uint256) {\n        return EnglishPeriodicAuctionStorage.layout().initialPeriodStartTime;\n    }\n\n    /**\n     * @notice Get auction length\n     */\n    function _auctionLengthSeconds() internal view returns (uint256) {\n        return EnglishPeriodicAuctionStorage.layout().auctionLengthSeconds;\n    }\n\n    /**\n     * @notice Set starting bid\n     */\n    function _setStartingBid(uint256 startingBid) internal {\n        EnglishPeriodicAuctionStorage.layout().startingBid = startingBid;\n\n        emit StartingBidSet(startingBid);\n    }\n\n    /**\n     * @notice Set auction length\n     */\n    function _setAuctionLengthSeconds(uint256 auctionLengthSeconds) internal {\n        EnglishPeriodicAuctionStorage\n            .layout()\n            .auctionLengthSeconds = auctionLengthSeconds;\n\n        emit AuctionLengthSet(auctionLengthSeconds);\n    }\n\n    /**\n     * @notice Get minimum bid increment\n     */\n    function _minBidIncrement() internal view returns (uint256) {\n        return EnglishPeriodicAuctionStorage.layout().minBidIncrement;\n    }\n\n    /**\n     * @notice Set minimum bid increment\n     */\n    function _setMinBidIncrement(uint256 minBidIncrement) internal {\n        EnglishPeriodicAuctionStorage\n            .layout()\n            .minBidIncrement = minBidIncrement;\n\n        emit MinBidIncrementSet(minBidIncrement);\n    }\n\n    /**\n     * @notice Get bid extension window length\n     */\n    function _bidExtensionWindowLengthSeconds()\n        internal\n        view\n        returns (uint256)\n    {\n        return\n            EnglishPeriodicAuctionStorage\n                .layout()\n                .bidExtensionWindowLengthSeconds;\n    }\n\n    /**\n     * @notice Set bid extension window length\n     */\n    function _setBidExtensionWindowLengthSeconds(\n        uint256 bidExtensionWindowLengthSeconds\n    ) internal {\n        EnglishPeriodicAuctionStorage\n            .layout()\n            .bidExtensionWindowLengthSeconds = bidExtensionWindowLengthSeconds;\n\n        emit BidExtensionWindowLengthSet(bidExtensionWindowLengthSeconds);\n    }\n\n    /**\n     * @notice Get bid extension\n     */\n    function _bidExtensionSeconds() internal view returns (uint256) {\n        return EnglishPeriodicAuctionStorage.layout().bidExtensionSeconds;\n    }\n\n    /**\n     * @notice Set bid extension\n     */\n    function _setBidExtensionSeconds(uint256 bidExtensionSeconds) internal {\n        EnglishPeriodicAuctionStorage\n            .layout()\n            .bidExtensionSeconds = bidExtensionSeconds;\n\n        emit BidExtensionSet(bidExtensionSeconds);\n    }\n\n    /**\n     * @notice Get initial bidder\n     */\n    function _initialBidder() internal view returns (address) {\n        return EnglishPeriodicAuctionStorage.layout().initialBidder;\n    }\n\n    /**\n     * @notice Get highest outstanding bid\n     */\n    function _highestBid(\n        uint256 tokenId,\n        uint256 round\n    ) internal view returns (Bid storage) {\n        return\n            EnglishPeriodicAuctionStorage.layout().highestBids[tokenId][round];\n    }\n\n    /**\n     * @notice Get bid for address\n     */\n    function _bidOf(\n        uint256 tokenId,\n        uint256 round,\n        address bidder\n    ) internal view returns (Bid storage) {\n        return\n            EnglishPeriodicAuctionStorage.layout().bids[tokenId][round][bidder];\n    }\n\n    /**\n     * @notice Get is auction period\n     */\n    function _isAuctionPeriod(uint256 tokenId) internal view returns (bool) {\n        if (tokenId >= IStewardLicense(address(this)).maxTokenCount()) {\n            return false;\n        }\n        //slither-disable-next-line timestamp\n        return block.timestamp >= _auctionStartTime(tokenId);\n    }\n\n    /**\n     * @notice Is token ready for transfer\n     */\n    function _isReadyForTransfer(uint256 tokenId) internal view returns (bool) {\n        if (tokenId >= IStewardLicense(address(this)).maxTokenCount()) {\n            return false;\n        }\n        //slither-disable-next-line timestamp\n        return block.timestamp >= _auctionEndTime(tokenId);\n    }\n\n    /**\n     * @notice Get current auction round\n     */\n    function _currentAuctionRound(\n        uint256 tokenId\n    ) internal view returns (uint256) {\n        return\n            EnglishPeriodicAuctionStorage.layout().currentAuctionRound[tokenId];\n    }\n\n    /**\n     * @notice Get locked collateral from all bids\n     */\n    function _lockedCollateral(\n        uint256 tokenId,\n        address bidder\n    ) internal view returns (uint256) {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        uint256 currentAuctionRound = l.currentAuctionRound[tokenId];\n        uint256 lockedCollateral = 0;\n        for (uint256 i = 0; i <= currentAuctionRound; i++) {\n            Bid storage bid = l.bids[tokenId][i][bidder];\n            lockedCollateral += bid.collateralAmount;\n        }\n\n        return lockedCollateral;\n    }\n\n    /**\n     * @notice Get available collateral\n     */\n    function _availableCollateral(\n        address bidder\n    ) internal view returns (uint256) {\n        return\n            EnglishPeriodicAuctionStorage.layout().availableCollateral[bidder];\n    }\n\n    /**\n     * @notice Place a bid\n     */\n    function _placeBid(\n        uint256 tokenId,\n        address bidder,\n        uint256 bidAmount,\n        uint256 collateralAmount\n    ) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        uint256 currentAuctionRound = l.currentAuctionRound[tokenId];\n\n        Bid storage bid = l.bids[tokenId][currentAuctionRound][bidder];\n\n        // Check if higher than starting bid\n        require(\n            bidAmount >= l.startingBid,\n            'EnglishPeriodicAuction: Bid amount must be greater than or equal to starting bid'\n        );\n\n        // Check if highest bid\n        if (l.highestBids[tokenId][currentAuctionRound].bidAmount > 0) {\n            require(\n                bidAmount >=\n                    l.highestBids[tokenId][currentAuctionRound].bidAmount +\n                        l.minBidIncrement,\n                'EnglishPeriodicAuction: Bid amount must be greater than highest outstanding bid'\n            );\n        }\n\n        uint256 totalCollateralAmount = bid.collateralAmount + collateralAmount;\n\n        uint256 feeAmount;\n        address currentBidder;\n        if (IStewardLicense(address(this)).exists(tokenId)) {\n            currentBidder = IStewardLicense(address(this)).ownerOf(tokenId);\n        } else {\n            currentBidder = l.initialBidder;\n        }\n\n        if (bidder == currentBidder) {\n            // If current bidder, collateral is entire fee amount\n            feeAmount = totalCollateralAmount;\n        } else {\n            require(\n                totalCollateralAmount > bidAmount,\n                'EnglishPeriodicAuction: Collateral must be greater than current bid'\n            );\n            // If new bidder, collateral is bidAmount + fee\n            feeAmount = totalCollateralAmount - bidAmount;\n        }\n\n        require(\n            _checkBidAmount(bidAmount, feeAmount),\n            'EnglishPeriodicAuction: Incorrect bid amount'\n        );\n\n        // Save bid\n        bid.bidder = bidder;\n        bid.bidAmount = bidAmount;\n        bid.feeAmount = feeAmount;\n        bid.collateralAmount = totalCollateralAmount;\n\n        l.highestBids[tokenId][currentAuctionRound] = bid;\n\n        emit BidPlaced(tokenId, currentAuctionRound, bid.bidder, bid.bidAmount);\n\n        // Check if auction should extend\n        uint256 auctionEndTime = _auctionEndTime(tokenId);\n\n        // slither-disable-start timestamp\n        if (\n            auctionEndTime >= block.timestamp &&\n            auctionEndTime - block.timestamp <\n            _bidExtensionWindowLengthSeconds()\n        ) {\n            uint256 auctionLengthSeconds;\n            if (l.currentAuctionLength[tokenId] == 0) {\n                auctionLengthSeconds = _auctionLengthSeconds();\n            } else {\n                auctionLengthSeconds = l.currentAuctionLength[tokenId];\n            }\n            // Extend auction\n            l.currentAuctionLength[tokenId] =\n                auctionLengthSeconds +\n                _bidExtensionSeconds();\n        }\n        // slither-disable-end timestamp\n    }\n\n    /**\n     * @notice Cancel bid for current round if not highest bidder\n     */\n    function _cancelBid(\n        uint256 tokenId,\n        uint256 round,\n        address bidder\n    ) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        address currentBidder;\n        if (IStewardLicense(address(this)).exists(tokenId)) {\n            currentBidder = IStewardLicense(address(this)).ownerOf(tokenId);\n        } else {\n            currentBidder = l.initialBidder;\n        }\n\n        require(\n            bidder != l.highestBids[tokenId][round].bidder,\n            'EnglishPeriodicAuction: Cannot cancel bid if highest bidder'\n        );\n\n        Bid storage bid = l.bids[tokenId][round][bidder];\n\n        require(\n            bid.collateralAmount > 0,\n            'EnglishPeriodicAuction: No bid to cancel'\n        );\n\n        // Make collateral available to withdraw\n        l.availableCollateral[bidder] += bid.collateralAmount;\n\n        // Reset collateral and bid\n        bid.collateralAmount = 0;\n        bid.bidAmount = 0;\n    }\n\n    /**\n     * @notice Cancel bids for all rounds\n     */\n    function _cancelAllBids(uint256 tokenId, address bidder) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        uint256 currentAuctionRound = l.currentAuctionRound[tokenId];\n\n        for (uint256 i = 0; i <= currentAuctionRound; i++) {\n            Bid storage bid = l.bids[tokenId][i][bidder];\n\n            if (bid.collateralAmount > 0) {\n                // Make collateral available to withdraw\n                l.availableCollateral[bidder] += bid.collateralAmount;\n\n                // Reset collateral and bid\n                bid.collateralAmount = 0;\n                bid.bidAmount = 0;\n            }\n        }\n    }\n\n    /**\n     * @notice Withdraw collateral\n     */\n    function _withdrawCollateral(address bidder) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        uint256 collateralAmount = l.availableCollateral[bidder];\n\n        require(\n            collateralAmount > 0,\n            'EnglishPeriodicAuction: No collateral to withdraw'\n        );\n\n        // Make collateral unavailable to withdraw\n        l.availableCollateral[bidder] = 0;\n\n        // Transfer collateral back to bidder\n        //slither-disable-next-line low-level-calls\n        (bool success, ) = bidder.call{ value: collateralAmount }('');\n        require(\n            success,\n            'EnglishPeriodicAuction: Failed to withdraw collateral'\n        );\n    }\n\n    /**\n     * @notice Close auction and trigger a transfer to the highest bidder\n     */\n    function _closeAuction(uint256 tokenId) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        uint256 currentAuctionRound = l.currentAuctionRound[tokenId];\n\n        address oldBidder;\n        if (IStewardLicense(address(this)).exists(tokenId)) {\n            oldBidder = IStewardLicense(address(this)).ownerOf(tokenId);\n        } else {\n            oldBidder = l.initialBidder;\n        }\n\n        // Set lastPeriodEndTime to the end of the current auction period\n        uint256 licensePeriod = IPeriodicPCOParamsReadable(address(this))\n            .licensePeriod();\n\n        l.lastPeriodEndTime[tokenId] = block.timestamp;\n        l.currentLicensePeriod[tokenId] = licensePeriod;\n\n        if (l.highestBids[tokenId][currentAuctionRound].bidder == address(0)) {\n            // No bids were placed, transfer to repossessor\n            Bid storage repossessorBid = l.bids[tokenId][currentAuctionRound][\n                l.repossessor\n            ];\n            repossessorBid.bidAmount = 0;\n            repossessorBid.feeAmount = 0;\n            repossessorBid.collateralAmount = 0;\n            repossessorBid.bidder = l.repossessor;\n\n            l.highestBids[tokenId][currentAuctionRound] = repossessorBid;\n        } else if (\n            l.highestBids[tokenId][currentAuctionRound].bidder != oldBidder\n        ) {\n            // Transfer bid to previous bidder's collateral\n            l.availableCollateral[oldBidder] += l\n            .highestBids[tokenId][currentAuctionRound].bidAmount;\n            l.highestBids[tokenId][currentAuctionRound].collateralAmount = 0;\n            l\n            .bids[tokenId][currentAuctionRound][\n                l.highestBids[tokenId][currentAuctionRound].bidder\n            ].collateralAmount = 0;\n        } else {\n            l.highestBids[tokenId][currentAuctionRound].collateralAmount = 0;\n            l\n            .bids[tokenId][currentAuctionRound][oldBidder].collateralAmount = 0;\n        }\n\n        emit AuctionClosed(\n            tokenId,\n            currentAuctionRound,\n            l.highestBids[tokenId][currentAuctionRound].bidder,\n            oldBidder,\n            l.highestBids[tokenId][currentAuctionRound].bidAmount\n        );\n\n        // Reset auction\n        l.currentAuctionLength[tokenId] = 0;\n        l.currentAuctionRound[tokenId] = l.currentAuctionRound[tokenId] + 1;\n\n        // Transfer to highest bidder\n        IStewardLicense(address(this)).triggerTransfer(\n            oldBidder,\n            l.highestBids[tokenId][currentAuctionRound].bidder,\n            tokenId\n        );\n\n        // Distribute fee to beneficiary\n        if (l.highestBids[tokenId][currentAuctionRound].feeAmount > 0) {\n            IBeneficiary(address(this)).distribute{\n                value: l.highestBids[tokenId][currentAuctionRound].feeAmount\n            }();\n        }\n    }\n\n    /**\n     * @notice Get auction start time\n     */\n    function _auctionStartTime(\n        uint256 tokenId\n    ) internal view returns (uint256 auctionStartTime) {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        uint256 initialPeriodStartTime;\n        uint256 initialPeriodStartTimeOffset;\n        if (l.tokenInitialPeriodStartTime[tokenId] > 0) {\n            initialPeriodStartTime = l.tokenInitialPeriodStartTime[tokenId];\n            initialPeriodStartTimeOffset = 0;\n        } else {\n            initialPeriodStartTime = l.initialPeriodStartTime;\n            initialPeriodStartTimeOffset = l.initialPeriodStartTimeOffset;\n        }\n\n        if (l.lastPeriodEndTime[tokenId] > initialPeriodStartTime) {\n            // Auction starts after licensePeriod has elapsed\n            auctionStartTime =\n                l.lastPeriodEndTime[tokenId] +\n                l.currentLicensePeriod[tokenId];\n        } else {\n            // Auction starts at initial time\n            auctionStartTime =\n                initialPeriodStartTime +\n                (tokenId * initialPeriodStartTimeOffset);\n        }\n    }\n\n    /**\n     * @notice Get auction end time\n     */\n    function _auctionEndTime(\n        uint256 tokenId\n    ) internal view returns (uint256 auctionEndTime) {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        uint256 auctionLengthSeconds;\n        if (l.currentAuctionLength[tokenId] == 0) {\n            auctionLengthSeconds = _auctionLengthSeconds();\n        } else {\n            auctionLengthSeconds = l.currentAuctionLength[tokenId];\n        }\n\n        auctionEndTime = _auctionStartTime(tokenId) + auctionLengthSeconds;\n    }\n\n    /**\n     * @notice Calculate fee from bid\n     */\n    function _calculateFeeFromBid(\n        uint256 bidAmount\n    ) internal view returns (uint256) {\n        uint256 feeNumerator = IPeriodicPCOParamsReadable(address(this))\n            .feeNumerator();\n        uint256 feeDenominator = IPeriodicPCOParamsReadable(address(this))\n            .feeDenominator();\n\n        return (bidAmount * feeNumerator) / feeDenominator;\n    }\n\n    /**\n     * @notice Check that fee is within rounding error of bid amount\n     */\n    function _checkBidAmount(\n        uint256 bidAmount,\n        uint256 feeAmount\n    ) internal view returns (bool) {\n        uint256 calculatedFeeAmount = _calculateFeeFromBid(bidAmount);\n\n        return calculatedFeeAmount == feeAmount;\n    }\n}"
    },
    {
      "filename": "pco-art/contracts/auction/EnglishPeriodicAuctionInternal.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { EnglishPeriodicAuctionStorage } from './EnglishPeriodicAuctionStorage.sol';\nimport { IPeriodicPCOParamsReadable } from '../pco/IPeriodicPCOParamsReadable.sol';\nimport { IStewardLicense } from '../license/IStewardLicense.sol';\nimport { IBeneficiary } from '../beneficiary/IBeneficiary.sol';\nimport { IEnglishPeriodicAuctionInternal } from './IEnglishPeriodicAuctionInternal.sol';\n\n/**\n * @title EnglishPeriodicAuctionInternal\n */\nabstract contract EnglishPeriodicAuctionInternal is\n    IEnglishPeriodicAuctionInternal\n{\n    /**\n     * @notice Initialize parameters\n     */\n    function _initializeAuction(\n        address repossessor,\n        address initialBidder,\n        uint256 initialPeriodStartTime,\n        uint256 initialPeriodStartTimeOffset,\n        uint256 startingBid,\n        uint256 auctionLengthSeconds,\n        uint256 minBidIncrement,\n        uint256 bidExtensionWindowLengthSeconds,\n        uint256 bidExtensionSeconds\n    ) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        l.isInitialized = true;\n        l.initialBidder = initialBidder;\n        l.initialPeriodStartTimeOffset = initialPeriodStartTimeOffset;\n        l.initialPeriodStartTime = initialPeriodStartTime;\n        _setStartingBid(startingBid);\n        _setRepossessor(repossessor);\n        _setAuctionLengthSeconds(auctionLengthSeconds);\n        _setMinBidIncrement(minBidIncrement);\n        _setBidExtensionWindowLengthSeconds(bidExtensionWindowLengthSeconds);\n        _setBidExtensionSeconds(bidExtensionSeconds);\n    }\n\n    /**\n     * @notice Set auction parameters\n     */\n    function _setAuctionParameters(\n        address repossessor,\n        uint256 auctionLengthSeconds,\n        uint256 minBidIncrement,\n        uint256 bidExtensionWindowLengthSeconds,\n        uint256 bidExtensionSeconds,\n        uint256 startingBid\n    ) internal {\n        _setRepossessor(repossessor);\n        _setAuctionLengthSeconds(auctionLengthSeconds);\n        _setMinBidIncrement(minBidIncrement);\n        _setBidExtensionWindowLengthSeconds(bidExtensionWindowLengthSeconds);\n        _setBidExtensionSeconds(bidExtensionSeconds);\n        _setStartingBid(startingBid);\n    }\n\n    /**\n     * @notice Check if initialized\n     */\n    function _isInitialized() internal view returns (bool) {\n        return EnglishPeriodicAuctionStorage.layout().isInitialized;\n    }\n\n    /**\n     * @notice Get starting bid\n     */\n    function _startingBid() internal view returns (uint256) {\n        return EnglishPeriodicAuctionStorage.layout().startingBid;\n    }\n\n    /**\n     * @notice Get repossessor\n     */\n    function _repossessor() internal view returns (address) {\n        return EnglishPeriodicAuctionStorage.layout().repossessor;\n    }\n\n    /**\n     * @notice Set repossessor\n     */\n    function _setRepossessor(address repossessor) internal {\n        EnglishPeriodicAuctionStorage.layout().repossessor = repossessor;\n\n        emit RepossessorSet(repossessor);\n    }\n\n    /**\n     * @notice Get initial period start time\n     */\n    function _initialPeriodStartTime() internal view returns (uint256) {\n        return EnglishPeriodicAuctionStorage.layout().initialPeriodStartTime;\n    }\n\n    /**\n     * @notice Get auction length\n     */\n    function _auctionLengthSeconds() internal view returns (uint256) {\n        return EnglishPeriodicAuctionStorage.layout().auctionLengthSeconds;\n    }\n\n    /**\n     * @notice Set starting bid\n     */\n    function _setStartingBid(uint256 startingBid) internal {\n        EnglishPeriodicAuctionStorage.layout().startingBid = startingBid;\n\n        emit StartingBidSet(startingBid);\n    }\n\n    /**\n     * @notice Set auction length\n     */\n    function _setAuctionLengthSeconds(uint256 auctionLengthSeconds) internal {\n        EnglishPeriodicAuctionStorage\n            .layout()\n            .auctionLengthSeconds = auctionLengthSeconds;\n\n        emit AuctionLengthSet(auctionLengthSeconds);\n    }\n\n    /**\n     * @notice Get minimum bid increment\n     */\n    function _minBidIncrement() internal view returns (uint256) {\n        return EnglishPeriodicAuctionStorage.layout().minBidIncrement;\n    }\n\n    /**\n     * @notice Set minimum bid increment\n     */\n    function _setMinBidIncrement(uint256 minBidIncrement) internal {\n        EnglishPeriodicAuctionStorage\n            .layout()\n            .minBidIncrement = minBidIncrement;\n\n        emit MinBidIncrementSet(minBidIncrement);\n    }\n\n    /**\n     * @notice Get bid extension window length\n     */\n    function _bidExtensionWindowLengthSeconds()\n        internal\n        view\n        returns (uint256)\n    {\n        return\n            EnglishPeriodicAuctionStorage\n                .layout()\n                .bidExtensionWindowLengthSeconds;\n    }\n\n    /**\n     * @notice Set bid extension window length\n     */\n    function _setBidExtensionWindowLengthSeconds(\n        uint256 bidExtensionWindowLengthSeconds\n    ) internal {\n        EnglishPeriodicAuctionStorage\n            .layout()\n            .bidExtensionWindowLengthSeconds = bidExtensionWindowLengthSeconds;\n\n        emit BidExtensionWindowLengthSet(bidExtensionWindowLengthSeconds);\n    }\n\n    /**\n     * @notice Get bid extension\n     */\n    function _bidExtensionSeconds() internal view returns (uint256) {\n        return EnglishPeriodicAuctionStorage.layout().bidExtensionSeconds;\n    }\n\n    /**\n     * @notice Set bid extension\n     */\n    function _setBidExtensionSeconds(uint256 bidExtensionSeconds) internal {\n        EnglishPeriodicAuctionStorage\n            .layout()\n            .bidExtensionSeconds = bidExtensionSeconds;\n\n        emit BidExtensionSet(bidExtensionSeconds);\n    }\n\n    /**\n     * @notice Get initial bidder\n     */\n    function _initialBidder() internal view returns (address) {\n        return EnglishPeriodicAuctionStorage.layout().initialBidder;\n    }\n\n    /**\n     * @notice Get highest outstanding bid\n     */\n    function _highestBid(\n        uint256 tokenId,\n        uint256 round\n    ) internal view returns (Bid storage) {\n        return\n            EnglishPeriodicAuctionStorage.layout().highestBids[tokenId][round];\n    }\n\n    /**\n     * @notice Get bid for address\n     */\n    function _bidOf(\n        uint256 tokenId,\n        uint256 round,\n        address bidder\n    ) internal view returns (Bid storage) {\n        return\n            EnglishPeriodicAuctionStorage.layout().bids[tokenId][round][bidder];\n    }\n\n    /**\n     * @notice Get is auction period\n     */\n    function _isAuctionPeriod(uint256 tokenId) internal view returns (bool) {\n        if (tokenId >= IStewardLicense(address(this)).maxTokenCount()) {\n            return false;\n        }\n        //slither-disable-next-line timestamp\n        return block.timestamp >= _auctionStartTime(tokenId);\n    }\n\n    /**\n     * @notice Is token ready for transfer\n     */\n    function _isReadyForTransfer(uint256 tokenId) internal view returns (bool) {\n        if (tokenId >= IStewardLicense(address(this)).maxTokenCount()) {\n            return false;\n        }\n        //slither-disable-next-line timestamp\n        return block.timestamp >= _auctionEndTime(tokenId);\n    }\n\n    /**\n     * @notice Get current auction round\n     */\n    function _currentAuctionRound(\n        uint256 tokenId\n    ) internal view returns (uint256) {\n        return\n            EnglishPeriodicAuctionStorage.layout().currentAuctionRound[tokenId];\n    }\n\n    /**\n     * @notice Get locked collateral from all bids\n     */\n    function _lockedCollateral(\n        uint256 tokenId,\n        address bidder\n    ) internal view returns (uint256) {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        uint256 currentAuctionRound = l.currentAuctionRound[tokenId];\n        uint256 lockedCollateral = 0;\n        for (uint256 i = 0; i <= currentAuctionRound; i++) {\n            Bid storage bid = l.bids[tokenId][i][bidder];\n            lockedCollateral += bid.collateralAmount;\n        }\n\n        return lockedCollateral;\n    }\n\n    /**\n     * @notice Get available collateral\n     */\n    function _availableCollateral(\n        address bidder\n    ) internal view returns (uint256) {\n        return\n            EnglishPeriodicAuctionStorage.layout().availableCollateral[bidder];\n    }\n\n    /**\n     * @notice Place a bid\n     */\n    function _placeBid(\n        uint256 tokenId,\n        address bidder,\n        uint256 bidAmount,\n        uint256 collateralAmount\n    ) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        uint256 currentAuctionRound = l.currentAuctionRound[tokenId];\n\n        Bid storage bid = l.bids[tokenId][currentAuctionRound][bidder];\n\n        // Check if higher than starting bid\n        require(\n            bidAmount >= l.startingBid,\n            'EnglishPeriodicAuction: Bid amount must be greater than or equal to starting bid'\n        );\n\n        // Check if highest bid\n        if (l.highestBids[tokenId][currentAuctionRound].bidAmount > 0) {\n            require(\n                bidAmount >=\n                    l.highestBids[tokenId][currentAuctionRound].bidAmount +\n                        l.minBidIncrement,\n                'EnglishPeriodicAuction: Bid amount must be greater than highest outstanding bid'\n            );\n        }\n\n        uint256 totalCollateralAmount = bid.collateralAmount + collateralAmount;\n\n        uint256 feeAmount;\n        address currentBidder;\n        if (IStewardLicense(address(this)).exists(tokenId)) {\n            currentBidder = IStewardLicense(address(this)).ownerOf(tokenId);\n        } else {\n            currentBidder = l.initialBidder;\n        }\n\n        if (bidder == currentBidder) {\n            // If current bidder, collateral is entire fee amount\n            feeAmount = totalCollateralAmount;\n        } else {\n            require(\n                totalCollateralAmount > bidAmount,\n                'EnglishPeriodicAuction: Collateral must be greater than current bid'\n            );\n            // If new bidder, collateral is bidAmount + fee\n            feeAmount = totalCollateralAmount - bidAmount;\n        }\n\n        require(\n            _checkBidAmount(bidAmount, feeAmount),\n            'EnglishPeriodicAuction: Incorrect bid amount'\n        );\n\n        // Save bid\n        bid.bidder = bidder;\n        bid.bidAmount = bidAmount;\n        bid.feeAmount = feeAmount;\n        bid.collateralAmount = totalCollateralAmount;\n\n        l.highestBids[tokenId][currentAuctionRound] = bid;\n\n        emit BidPlaced(tokenId, currentAuctionRound, bid.bidder, bid.bidAmount);\n\n        // Check if auction should extend\n        uint256 auctionEndTime = _auctionEndTime(tokenId);\n\n        // slither-disable-start timestamp\n        if (\n            auctionEndTime >= block.timestamp &&\n            auctionEndTime - block.timestamp <\n            _bidExtensionWindowLengthSeconds()\n        ) {\n            uint256 auctionLengthSeconds;\n            if (l.currentAuctionLength[tokenId] == 0) {\n                auctionLengthSeconds = _auctionLengthSeconds();\n            } else {\n                auctionLengthSeconds = l.currentAuctionLength[tokenId];\n            }\n            // Extend auction\n            l.currentAuctionLength[tokenId] =\n                auctionLengthSeconds +\n                _bidExtensionSeconds();\n        }\n        // slither-disable-end timestamp\n    }\n\n    /**\n     * @notice Cancel bid for current round if not highest bidder\n     */\n    function _cancelBid(\n        uint256 tokenId,\n        uint256 round,\n        address bidder\n    ) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        address currentBidder;\n        if (IStewardLicense(address(this)).exists(tokenId)) {\n            currentBidder = IStewardLicense(address(this)).ownerOf(tokenId);\n        } else {\n            currentBidder = l.initialBidder;\n        }\n\n        require(\n            bidder != l.highestBids[tokenId][round].bidder,\n            'EnglishPeriodicAuction: Cannot cancel bid if highest bidder'\n        );\n\n        Bid storage bid = l.bids[tokenId][round][bidder];\n\n        require(\n            bid.collateralAmount > 0,\n            'EnglishPeriodicAuction: No bid to cancel'\n        );\n\n        // Make collateral available to withdraw\n        l.availableCollateral[bidder] += bid.collateralAmount;\n\n        // Reset collateral and bid\n        bid.collateralAmount = 0;\n        bid.bidAmount = 0;\n    }\n\n    /**\n     * @notice Cancel bids for all rounds\n     */\n    function _cancelAllBids(uint256 tokenId, address bidder) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        uint256 currentAuctionRound = l.currentAuctionRound[tokenId];\n\n        for (uint256"
    }
  ]
}