{
  "Title": "H-4: Limit swap orders can be used to get a free look into the future",
  "Content": "# Issue H-4: Limit swap orders can be used to get a free look into the future \n\nSource: https://github.com/sherlock-audit/2023-04-gmx-judging/issues/241 \n\n## Found by \n0xdeadbeef, IllIllI, Nyx\n## Summary\n\nUsers can cancel their limit swap orders to get a free look into prices in future blocks\n\n\n## Vulnerability Detail\n\nThis is a part of the same issue that was described in the [last contest](https://github.com/sherlock-audit/2023-02-gmx-judging/issues/130). The sponsor fixed the bug for `LimitDecrease` and `StopLossDecrease`, but not for `LimitSwap`.\n\nAny swap limit order submitted in block range N can't be executed until block range N+2, because the block range is forced to be after the submitted block range, and keepers can't execute until the price has been archived, which necessarily won't be until _after_ block range N+1. Consider what happens when half of the oracle's block ranges are off from the other half, e.g.:\n\n```text\n    1 2 3 4 5 6 7 8 9 < block number\nO1: A B B B B C C C D\n02: A A B B B B C C C\n^^ grouped oracle block ranges\n```\n\nAt block 1, oracles in both groups (O1 and O2) are in the same block range A, and someone submits a large swap limit order (N). At block 6, oracles in O1 are in N+2, but oracles in O2 are still in N+1. This means that the swap limit order will execute at the median price of block 5 (since the earliest group to have archive prices at block 6 for N+1 will be O1) and market swap order submitted at block 6 in the other direction will execute at the median price of block 6 since O2 will be the first group to archive a price range that will contain block 6. By the end of block 5, the price for O1 is known, and the price that O2 will get at block 6 can be predicted with high probability (e.g. if the price has just gapped a few cents), so a trader will know whether the two orders will create a profit or not. If a profit is expected, they'll submit the market order at block 6. If a loss is expected, they'll cancel the swap limit order from block 1, and only have to cover gas fees.\n\nEssentially the logic is that limit swap orders will use earlier prices, and market orders (with swaps) will use later prices, and since oracle block ranges aren't fixed, an attacker is able to know both prices before having their orders executed, and use large order sizes to capitalize on small price differences.\n\n\n## Impact\n\nThere is a lot of work involved in calculating statistics about block ranges for oracles and their processing time/queues, and ensuring one gets the prices essentially when the keepers do, but this is likely less work than co-located high frequency traders in traditional finance have to do, and if there's a risk free profit to be made, they'll put in the work to do it every single time, at the expense of all other traders.\n\n\n## Code Snippet\n\nMarket orders can use the current block, but limit orders must use the next block:\n```solidity\n// File: gmx-synthetics/contracts/order/SwapOrderUtils.sol : SwapOrderUtils.validateOracleBlockNumbers()   #1\n\n57            if (orderType == Order.OrderType.MarketSwap) {\n58 @>             OracleUtils.validateBlockNumberWithinRange(\n59                    minOracleBlockNumbers,\n60                    maxOracleBlockNumbers,\n61                    orderUpdatedAtBlock\n62                );\n63                return;\n64            }\n65    \n66            if (orderType == Order.OrderType.LimitSwap) {\n67 @>             if (!minOracleBlockNumbers.areGreaterThan(orderUpdatedAtBlock)) {\n68                    revert Errors.OracleBlockNumbersAreSmallerThanRequired(minOracleBlockNumbers, orderUpdatedAtBlock);\n69                }\n70                return;\n71            }\n72    \n73            revert Errors.UnsupportedOrderType();\n74:       }\n```\nhttps://github.com/sherlock-audit/2023-04-gmx/blob/main/gmx-synthetics/contracts/order/SwapOrderUtils.sol#L57-L74\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nAll orders should follow the same block range rules\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/74",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/order/SwapOrderUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./BaseOrderUtils.sol\";\nimport \"../swap/SwapUtils.sol\";\nimport \"../order/OrderStoreUtils.sol\";\n\n// @title SwapOrderUtils\n// @dev Library for functions to help with processing a swap order\nlibrary SwapOrderUtils {\n    using Order for Order.Props;\n    using Array for uint256[];\n\n    // @dev process a swap order\n    // @param params BaseOrderUtils.ExecuteOrderParams\n    function processOrder(BaseOrderUtils.ExecuteOrderParams memory params) external {\n        if (params.order.market() != address(0)) {\n            revert Errors.UnexpectedMarket();\n        }\n\n        validateOracleBlockNumbers(\n            params.minOracleBlockNumbers,\n            params.maxOracleBlockNumbers,\n            params.order.orderType(),\n            params.order.updatedAtBlock()\n        );\n\n        SwapUtils.swap(SwapUtils.SwapParams(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.contracts.oracle,\n            params.contracts.orderVault,\n            params.key,\n            params.order.initialCollateralToken(),\n            params.order.initialCollateralDeltaAmount(),\n            params.swapPathMarkets,\n            params.order.minOutputAmount(),\n            params.order.receiver(),\n            params.order.uiFeeReceiver(),\n            params.order.shouldUnwrapNativeToken()\n        ));\n\n        OrderStoreUtils.remove(params.contracts.dataStore, params.key, params.order.account());\n    }\n\n    // @dev validate the oracle block numbers used for the prices in the oracle\n    // @param oracleBlockNumbers the oracle block numbers\n    // @param orderType the order type\n    // @param orderUpdatedAtBlock the block at which the order was last updated\n    function validateOracleBlockNumbers(\n        uint256[] memory minOracleBlockNumbers,\n        uint256[] memory maxOracleBlockNumbers,\n        Order.OrderType orderType,\n        uint256 orderUpdatedAtBlock\n    ) internal pure {\n        if (orderType == Order.OrderType.MarketSwap) {\n            OracleUtils.validateBlockNumberWithinRange(\n                minOracleBlockNumbers,\n                maxOracleBlockNumbers,\n                orderUpdatedAtBlock\n            );\n            return;\n        }\n\n        if (orderType == Order.OrderType.LimitSwap) {\n            if (!minOracleBlockNumbers.areGreaterThan(orderUpdatedAtBlock)) {\n                revert Errors.OracleBlockNumbersAreSmallerThanRequired(minOracleBlockNumbers, orderUpdatedAtBlock);\n            }\n            return;\n        }\n\n        revert Errors.UnsupportedOrderType();\n    }\n}"
    }
  ]
}