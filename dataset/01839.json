{
  "Title": "H-2: Malicious actor cause rebase to an old inflation multiplier",
  "Content": "# Issue H-2: Malicious actor cause rebase to an old inflation multiplier \n\nSource: https://github.com/sherlock-audit/2023-05-ecoprotocol-judging/issues/142 \n\n## Found by \n0xDjango, 0xdeadbeef, ecexit\n## Summary\n\nThe protocol has a rebasing mechanism that allows to sync the inflation multiplier between both L1 and L2 chains.\nThe call to rebase is permissionless (anyone can trigger it).\nInsufficant checks allow a malicious actor to rebase to an old value.\n\n## Vulnerability Detail\n\nRebasing from L1 to L2 is through the `L1ECOBridge` rebase function. It collects the inflation multiplier from the ECO token and sends a message to `L2ECOBridge` to update the L2 ECO token inflation multiplier.\nhttps://github.com/sherlock-audit/2023-05-ecoprotocol/blob/main/op-eco/contracts/bridge/L1ECOBridge.sol#L296\n```solidity\n    function rebase(uint32 _l2Gas) external {\n        inflationMultiplier = IECO(l1Eco).getPastLinearInflation(\n            block.number\n        );\n\n        bytes memory message = abi.encodeWithSelector(\n            IL2ECOBridge.rebase.selector,\n            inflationMultiplier\n        );\n\n        sendCrossDomainMessage(l2TokenBridge, _l2Gas, message);\n    }\n```\n\nA malicious actor can call this function a large amount of times to queue messages on `L2CrossDomainMessenger`.\nSince it is expensive to execute so much messages from `L2CrossDomainMessenger` (especially if the malicious actor sets `_l2Gas` to a high value) there will be a rebase message that will not be relayed through `L2CrossDomainMessenger` (or in failedMessages array).\n\nSome time passes and other legitimate rebase transactions get executed.\n\nOne day the malicious actor can execute one of his old rebase messages and set the value to the old value. The attacker will debalance the scales between L1 and L2 and can profit from it.\n\n## Impact\n\ndebalance the scales between L1 and L2 ECO token\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWhen sending a rebase from L1, include in the message the L1 block number. In L2 rebase, validate that the new rebase block number is above previous block number  \n\n\n\n\n\n## Discussion\n\n**albertnbrown**\n\nThis is legitimate because unlike upgrade functions, the `rebase` function has no auth guards. We have added fixes to this to this PR:\n\nhttps://github.com/eco-association/op-eco/pull/33\n\n**0xdeadbeef0x**\n\nEscalate for 10 USDC\n\nEscalating to verify that this gets the the reward tag as it was confirmed and fixed by the sponsor.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> Escalating to verify that this gets the the reward tag as it was confirmed and fixed by the sponsor.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\nValid high\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Valid high\n\n    This issue's escalations have been accepted!\n\n    Contestants' payouts and scores will be updated according to the changes made on this issue.\n\n**0xffff11**\n\nAdded fix in: https://github.com/eco-association/op-eco/pull/33\n\n**0xffff11**\n\nFix confirmed, added block number to L1 calls to prevent any replay attacks using failed cross-bridge calls\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/80",
  "Code": [
    {
      "filename": "op-eco/contracts/bridge/L1ECOBridge.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\n/* Interface Imports */\nimport {IL1ECOBridge} from \"../interfaces/bridge/IL1ECOBridge.sol\";\nimport {IL1ERC20Bridge} from \"@eth-optimism/contracts/L1/messaging/IL1ERC20Bridge.sol\";\nimport {IL2ECOBridge} from \"../interfaces/bridge/IL2ECOBridge.sol\";\nimport {IL2ERC20Bridge} from \"@eth-optimism/contracts/L2/messaging/IL2ERC20Bridge.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IECO} from \"@helix-foundation/currency/contracts/currency/IECO.sol\";\nimport {ITransparentUpgradeableProxy} from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\n/* Contract Imports */\nimport {CrossDomainEnabledUpgradeable} from \"./CrossDomainEnabledUpgradeable.sol\";\nimport {ProxyAdmin} from \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\n\n/**\n * @title L1ECOBridge\n * @dev The L1 ECO Bridge is a contract which stores deposited L1 ECO\n * that is in use on L2. It synchronizes a corresponding L2 Bridge, informing it of deposits\n * and listening to it for newly finalized withdrawals.\n * It also acts as the authorized source of L1 governance decisions as seen by the L2.\n * All governance related data and decisions are passed through this contract so that the\n * L2 contracts can maintain and trust a single source of L1 messages.\n */\ncontract L1ECOBridge is IL1ECOBridge, CrossDomainEnabledUpgradeable {\n    /**\n     * @dev L2 side of the bridge\n     */\n    address public l2TokenBridge;\n\n    /**\n     * @dev L1 ECO address\n     */\n    address public l1Eco;\n\n    /**\n     * @dev L2 ECO address\n     */\n    address public l2Eco;\n\n    /**\n     * @dev L1 proxy admin that manages this proxy contract\n     */\n    ProxyAdmin public l1ProxyAdmin;\n\n    /**\n     * @dev L2 upgrader role\n     */\n    address public upgrader;\n\n    /**\n     * @dev Current inflation multiplier\n     */\n    uint256 public inflationMultiplier;\n\n    /**\n     * @dev Modifier requiring sender to be EOA.  This check could be bypassed by a malicious\n     * contract via initcode, but it takes care of the user error we want to avoid.\n     */\n    modifier onlyEOA() {\n        // Used to stop deposits from contracts (avoid accidentally lost tokens)\n        require(msg.sender.code.length == 0, \"L1ECOBridge: Account not EOA\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to check that the L1 token is the same as the one set in the constructor\n     * @param _l1Token L1 token address to check\n     */\n    modifier isL1EcoToken(address _l1Token) {\n        require(\n            _l1Token == l1Eco,\n            \"L1ECOBridge: invalid L2 token address\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Modifier to check that the L2 token is the same as the one set in the constructor\n     * @param _l2Token L2 token address to check\n     */\n    modifier isL2EcoToken(address _l2Token) {\n        require(\n            _l2Token == l2Eco,\n            \"L1ECOBridge: invalid L2 token address\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Modifier for gating upgrade functionality behind an authorized ECO protocol governace contract\n     */\n    modifier onlyUpgrader() {\n        require(\n            msg.sender == upgrader,\n            \"L1ECOBridge: caller not authorized to upgrade L2 contracts.\"\n        );\n        _;\n    }\n\n    /**\n     * Disable the implementation contract\n     * @custom:oz-upgrades-unsafe-allow constructor\n     */\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @inheritdoc IL1ECOBridge\n     */\n    function initialize(\n        address _l1messenger,\n        address _l2TokenBridge,\n        address _l1Eco,\n        address _l2Eco,\n        address _l1ProxyAdmin,\n        address _upgrader\n    ) public initializer {\n        CrossDomainEnabledUpgradeable.__CrossDomainEnabledUpgradeable_init(\n            _l1messenger\n        );\n        l2TokenBridge = _l2TokenBridge;\n        l1Eco = _l1Eco;\n        l2Eco = _l2Eco;\n        l1ProxyAdmin = ProxyAdmin(_l1ProxyAdmin);\n        upgrader = _upgrader;\n        inflationMultiplier = IECO(_l1Eco).getPastLinearInflation(\n            block.number\n        );\n    }\n\n    /**\n     * @inheritdoc IL1ECOBridge\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeECO(address _impl, uint32 _l2Gas)\n        external\n        virtual\n        onlyUpgrader\n    {\n        bytes memory message = abi.encodeWithSelector(\n            IL2ECOBridge.upgradeECO.selector,\n            _impl\n        );\n\n        sendCrossDomainMessage(l2TokenBridge, _l2Gas, message);\n        emit UpgradeL2ECO(_impl);\n    }\n\n    /**\n     * @inheritdoc IL1ECOBridge\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeL2Bridge(address _impl, uint32 _l2Gas)\n        external\n        virtual\n        onlyUpgrader\n    {\n        bytes memory message = abi.encodeWithSelector(\n            IL2ECOBridge.upgradeSelf.selector,\n            _impl\n        );\n\n        sendCrossDomainMessage(l2TokenBridge, _l2Gas, message);\n        emit UpgradeL2Bridge(_impl);\n    }\n\n     /**\n     * @inheritdoc IL1ECOBridge\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeSelf(address _newBridgeImpl) external virtual onlyUpgrader {\n        //cast to a payable address since l2EcoToken is the proxy address of a ITransparentUpgradeableProxy contract\n        address payable proxyAddr = payable(address(this));\n\n        ITransparentUpgradeableProxy proxy = ITransparentUpgradeableProxy(\n            proxyAddr\n        );\n        l1ProxyAdmin.upgrade(proxy, _newBridgeImpl);\n\n        emit UpgradeSelf(_newBridgeImpl);\n    }\n\n    /**\n     * @inheritdoc IL1ERC20Bridge\n     * @param _l1Token must be the ECO L1 token address.\n     */\n    function depositERC20(\n        address _l1Token,\n        address _l2Token,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external virtual onlyEOA isL1EcoToken(_l1Token) isL2EcoToken(_l2Token) {\n        _initiateERC20Deposit(\n            _l1Token,\n            _l2Token,\n            msg.sender,\n            msg.sender,\n            _amount,\n            _l2Gas,\n            _data\n        );\n    }\n\n    /**\n     * @inheritdoc IL1ERC20Bridge\n     * @param _l1Token must be the ECO L1 token address.\n     */\n    function depositERC20To(\n        address _l1Token,\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external virtual isL1EcoToken(_l1Token) isL2EcoToken(_l2Token) {\n        _initiateERC20Deposit(\n            _l1Token,\n            _l2Token,\n            msg.sender,\n            _to,\n            _amount,\n            _l2Gas,\n            _data\n        );\n    }\n\n    /**\n     * @inheritdoc IL1ERC20Bridge\n     * @param _l1Token is always the ECO L1 token address.\n     * @param _l2Token is always the ECO L2 token address.\n     */\n    function finalizeERC20Withdrawal(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _gonsAmount,\n        bytes calldata _data\n    ) external onlyFromCrossDomainAccount(l2TokenBridge) {\n        uint256 _amount = _gonsAmount / inflationMultiplier;\n\n        // equivalent to IECO(_l1Token).transfer(_to, _amount); but is revert safe\n        bytes memory _ecoTransferMessage = abi.encodeWithSelector(\n            IERC20.transfer.selector,\n            _to,\n            _amount\n        );\n        (bool success, bytes memory returnData) = _l1Token.call{value: 0}(\n            _ecoTransferMessage\n        );\n\n        // make sure that the call to transfer didn't revert or return false\n        if (success && abi.decode(returnData, (bool))) {\n            // if successful, emit an event\n            emit ERC20WithdrawalFinalized(\n                _l1Token,\n                _l2Token,\n                _from,\n                _to,\n                _amount,\n                _data\n            );\n        } else {\n            // if the transfer fails, create a return tx\n            bytes memory message = abi.encodeWithSelector(\n                IL2ERC20Bridge.finalizeDeposit.selector,\n                _l1Token,\n                _l2Token,\n                _to, // switched the _to and _from here to bounce back the deposit to the sender\n                _from,\n                _gonsAmount,\n                _data\n            );\n\n            // Send message up to L1 bridge\n            sendCrossDomainMessage(l2TokenBridge, 0, message);\n            // Emit an event to signal success event listeners to expect failure\n            emit WithdrawalFailed(\n                _l1Token,\n                _l2Token,\n                _from,\n                _to,\n                _amount,\n                _data\n            );\n        }\n    }\n\n    /**\n     * @inheritdoc IL1ECOBridge\n     */\n    function rebase(uint32 _l2Gas) external {\n        inflationMultiplier = IECO(l1Eco).getPastLinearInflation(\n            block.number\n        );\n\n        bytes memory message = abi.encodeWithSelector(\n            IL2ECOBridge.rebase.selector,\n            inflationMultiplier\n        );\n\n        sendCrossDomainMessage(l2TokenBridge, _l2Gas, message);\n    }\n\n    /**\n     * @dev Performs the logic for deposits by informing the L2 ECO token\n     * contract of the deposit and pulling in the L1 funds from the depositor\n     *\n     * @param _l1Token Address of the L1 ECO token contract\n     * @param _l2Token Address of the L2 ECO token contract\n     * @param _from Account to pull the deposit from on L1\n     * @param _to Account to give the deposit to on L2\n     * @param _amount Amount of ECO being deposited.\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2.\n     */\n    function _initiateERC20Deposit(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) internal {\n        // When a deposit is initiated on L1, the L1 Bridge transfers the funds to itself for future\n        // withdrawals.\n\n        IECO(_l1Token).transferFrom(_from, address(this), _amount);\n        // gons move across the bridge, with inflation multipliers on either side to correctly scale balances\n        _amount = _amount * inflationMultiplier;\n\n        // Construct calldata for _l2Token.finalizeDeposit(_to, _amount)\n        bytes memory message = abi.encodeWithSelector(\n            //call parent interface IL2ERC20Bridge to get the selector\n            IL2ERC20Bridge.finalizeDeposit.selector,\n            _l1Token,\n            _l2Token,\n            _from,\n            _to,\n            _amount,\n            _data\n        );\n\n        // Send calldata into L2\n        sendCrossDomainMessage(l2TokenBridge, _l2Gas, message);\n\n        emit ERC20DepositInitiated(\n            _l1Token,\n            _l2Token,\n            _from,\n            _to,\n            _amount,\n            _data\n        );\n    }\n}"
    }
  ]
}