{
  "Title": "[L03] Complicated Code",
  "Content": "There are cases where the data structure leads to unnecessarily complicated code. In particular the scheduled balances track the `previousBalance` and `lastBalance` separately. However, [the only time the previous balance is updated](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/ScheduledBalance.sol#L67) occurs immediately after the [balance is consolidated](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/Pod.sol#L179), and only when the `currentTimestamp` is after the `lastTimestamp`. In this case, the `previousBalance` will be increased by zero. This implies it will always be zero.\n\n\nThis fact is not obvious, but it is implicitly assumed when the scheduled balances are converted to tokens (since all balances use the same exchange rate, no matter when they were added). While correct, it makes the code harder to reason about.\n\n\nConsider simplifying the scheduled balance data structure to record a single balance with its timestamp.\n\n\n**Update:** *Fixed in [PR#7](https://github.com/pooltogether/pods/pull/7/). The data structure was updated as suggested and the `ScheduledBalance` and `Pod` contracts were updated accordingly.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/ScheduledBalance.sol",
      "content": "/**\nCopyright 2020 PoolTogether Inc.\n\nThis file is part of PoolTogether.\n\nPoolTogether is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation under version 3 of the License.\n\nPoolTogether is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity 0.5.12;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\n\n/**\n * @author Brendan Asselstine\n * @notice Library for tracking deposits with respect to time.\n *\n * This library separates deposits into consolidated balances and unconsolidated balances.\n *\n * The consolidated balance is the sum of all deposits previous to a given timestamp.\n *\n * The unconsolidated balance is the sum of all deposits at or after a given timestamp.\n *\n * The word \"timestamp\" is used here because time always moves forward.  However, the value used for the timestamps\n * could have any granularity.\n */\nlibrary ScheduledBalance {\n  using SafeMath for uint256;\n\n  /**\n   * The structure containing a user's previously consolidated balance and their most recent deposit.\n   */\n  struct State {\n    uint256 previousBalance;\n    uint256 previousTimestamp;\n    uint256 lastBalance;\n    uint256 lastTimestamp;\n  }\n\n  /**\n   * Deposits the given amount.\n   *\n   * The provided timestamp *must* be the same or later than the last deposit timestamp.\n   *\n   * If the current timestamp is greater than the last deposit timestamp, all existing\n   * deposit are consolidated and this deposit is set as the last.\n   * If the current timestamp is equal to the last deposit timestamp, it is merely added to the last deposit self.\n   *\n   * @param self The ScheduledBalance.State struct\n   * @param amount The amount to deposit\n   * @param currentTimestamp The current timestamp.\n   */\n  function deposit(State storage self, uint256 amount, uint256 currentTimestamp) internal {\n    require(currentTimestamp >= self.lastTimestamp, \"ScheduledBalance/backwards\");\n    if (self.lastTimestamp == currentTimestamp) {\n      self.lastBalance = self.lastBalance.add(amount);\n    } else {\n      self.previousBalance = self.previousBalance.add(self.lastBalance);\n      self.previousTimestamp = self.lastTimestamp;\n      self.lastBalance = amount;\n      self.lastTimestamp = currentTimestamp;\n    }\n  }\n\n  /**\n   * Withdraws the given amount from the unconsolidated deposits.\n   *\n   * The given timestamp is used to check the unconsolidated balance.\n   *\n   * @param self The State struct\n   * @param amount The amount to withdraw\n   * @param timestamp The current timestamp\n   */\n  function withdrawUnconsolidated(State storage self, uint256 amount, uint256 timestamp) internal {\n    if (self.lastTimestamp == timestamp) {\n      require(amount <= self.lastBalance, \"ScheduledBalance/insuff\");\n      self.lastBalance = self.lastBalance.sub(amount);\n    } else { // unconsolidated must be zero\n      require(amount == 0, \"ScheduledBalance/insuff\");\n    }\n  }\n\n  /**\n   * Returns the consolidated balance as of the given timestamp.\n   *\n   * Any deposits made prior to the given timestamp are considered \"consolidated\"\n   *\n   * @param self The State struct\n   * @param currentTimestamp The current timestamp\n   * @return The consolidate balance\n   */\n  function consolidatedBalance(State storage self, uint256 currentTimestamp) internal view returns (uint256) {\n    (uint256 balance,) = consolidatedBalanceInfo(self, currentTimestamp);\n    return balance;\n  }\n\n  /**\n   * Returns the consolidated balance and timestamp as of the given timestamp.\n   *\n   * Any deposits made prior to the given timestamp are considered \"consolidated\".\n   *\n   * The provided timestamp *must* be the same or later than the last deposit timestamp.\n   *\n   * This function will return a tuple of the consolidated balance, and the timestamp of\n   * it's last deposit.\n   *\n   * @param self The State struct\n   * @param currentTimestamp The current timestamp\n   * @return A tuple (balance, timestamp) of the consolidate balance and last deposit time\n   */\n  function consolidatedBalanceInfo(\n    State storage self,\n    uint256 currentTimestamp\n  ) internal view notBackwards(self, currentTimestamp) returns (uint256 balance, uint256 timeslot) {\n    balance = self.previousBalance;\n    timeslot = self.previousTimestamp;\n    if (self.lastTimestamp < currentTimestamp) {\n      balance = balance.add(self.lastBalance);\n      timeslot = self.lastTimestamp;\n    }\n    return (balance, timeslot);\n  }\n\n  /**\n   * Returns the unconsolidated balance as of the given timestamp.\n   *\n   * Any deposits made on or after the given timestamp will be returned as the unconsolidated balance\n   *\n   * @param self The State struct\n   * @param currentTimestamp The current time\n   */\n  function unconsolidatedBalance(\n    State storage self,\n    uint256 currentTimestamp\n  ) internal view notBackwards(self, currentTimestamp) returns (uint256) {\n    uint256 result;\n    if (currentTimestamp == self.lastTimestamp) {\n      result = result.add(self.lastBalance);\n    }\n    return result;\n  }\n\n  /**\n   * Zeroes out the consolidated balance give the current timestamp.\n   *\n   * Any balance before the given timestamp will be zeroed out.\n   *\n   * @param self The State struct\n   * @param currentTimestamp The current time\n   */\n  function clearConsolidated(State storage self, uint256 currentTimestamp) internal notBackwards(self, currentTimestamp) returns (uint256) {\n    if (self.lastTimestamp < currentTimestamp) {\n      delete self.lastTimestamp;\n      delete self.lastBalance;\n    }\n    delete self.previousBalance;\n    delete self.previousTimestamp;\n  }\n\n  modifier notBackwards(State storage self, uint256 currentTimestamp) {\n    require(currentTimestamp >= self.lastTimestamp, \"ScheduledBalance/backwards\");\n    _;\n  }\n}"
    }
  ]
}