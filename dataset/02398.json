{
  "Title": "Front-run attack on the deployment of EnsoWalletFactory",
  "Content": "##### Description\nAn attacker can place their transactions between the deployment of the EnsoWalletFactory implementation and [EnsoWalletFactory.initialize()](https://github.com/EnsoFinance/shortcuts-contracts/blob/4902e55608f975f73772310955444110b1cfc4fc/contracts/EnsoWalletFactory.sol#L26) to specify themself as the contract owner and make an upgrade of the EnsoWalletFactory to the modified one. The modified factory contract may implement backdoor functionality to gain control of the deployed user wallets.\n\n##### Recommendation\nWe recommend improving the code of the upgradeable proxy to disallow the gain of ownership by arbitrary accounts or at least improve the deployment process in order to implement deployment and initialization in a single transaction.\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/EnsoWalletFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\nimport \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\nimport \"./libraries/BeaconClones.sol\";\nimport \"./access/Ownable.sol\";\nimport \"./interfaces/IEnsoWallet.sol\";\n\ncontract EnsoWalletFactory is Ownable, UUPSUpgradeable {\n    using StorageAPI for bytes32;\n    using BeaconClones for address;\n\n    address public immutable ensoBeacon;\n\n    event Deployed(IEnsoWallet instance, string label);\n\n    error AlreadyInit();\n    error NoLabel();\n\n    constructor(address ensoBeacon_) {\n        ensoBeacon = ensoBeacon_;\n    }\n\n    // @notice A function to initialize state on the proxy the delegates to this contract\n    function initialize() external {\n        if (OWNER.getAddress() != address(0)) revert AlreadyInit();\n        OWNER.setAddress(msg.sender);\n    }\n\n    // @notice Deploy a wallet using the msg.sender as the salt\n    // @param commands The optional commands for executing a shortcut after deployment\n    // @param state The optional state for executing a shortcut after deployment\n    function deploy(\n        bytes32[] calldata commands,\n        bytes[] calldata state\n    ) public payable returns (IEnsoWallet) {\n        bytes32 salt = bytes32(uint256(uint160(msg.sender)));\n        return _deploy(salt, \"\", commands, state);\n    }\n\n    // @notice Deploy a wallet using a hash of the msg.sender and a label as the salt\n    // @param label The label to indentify deployment\n    // @param commands The optional commands for executing a shortcut after deployment\n    // @param state The optional state for executing a shortcut after deployment\n    function deployCustom(\n        string memory label,\n        bytes32[] calldata commands,\n        bytes[] calldata state\n    ) public payable returns (IEnsoWallet) {\n        if (bytes(label).length == 0) revert NoLabel();\n        bytes32 salt = _customSalt(msg.sender, label);\n        return _deploy(salt, label, commands, state);\n    }\n\n    // @notice Get the deployment address for the msg.sender\n    function getAddress() public view returns (address payable) {\n        return getUserAddress(msg.sender);\n    }\n\n    // @notice Get the deployment address for the user\n    // @param user The address of the user that is used to determine the deployment address\n    function getUserAddress(address user) public view returns (address payable) {\n        bytes32 salt = bytes32(uint256(uint160(user)));\n        return _predictDeterministicAddress(salt);\n    }\n\n    // @notice Get the deployment address for a user and label\n    // @param user The address of the user that is used to determine the deployment address\n    // @param label The label that is used to determine the deployment address\n    function getCustomAddress(address user, string memory label) external view returns (address payable) {\n        if (bytes(label).length == 0) revert NoLabel();\n        bytes32 salt = _customSalt(user, label);\n        return _predictDeterministicAddress(salt);\n    }\n\n    // @notice The internal function for deploying a new wallet\n    // @param salt The salt for deploy the address deterministically\n    // @param label The label to indentify deployment in the emitted event\n    // @param commands The optional commands for executing a shortcut after deployment\n    // @param state The optional state for executing a shortcut after deployment\n    function _deploy(\n        bytes32 salt,\n        string memory label,\n        bytes32[] calldata commands,\n        bytes[] calldata state\n    ) internal returns (IEnsoWallet instance) {\n        instance = IEnsoWallet(payable(ensoBeacon.cloneDeterministic(salt)));\n        instance.initialize{ value: msg.value }(msg.sender, salt, commands, state);\n        emit Deployed(instance, label);\n    }\n\n    // @notice Internal function to generate a custom salt using a user address and label\n    // @param user The address of the user\n    // @param label The label to identify the deployment\n    function _customSalt(address user, string memory label) internal pure returns (bytes32) {\n        return keccak256(abi.encode(user, label));\n    }\n\n    // @notice Internal function to derive the deployment address from a salt\n    // @param salt The bytes32 salt to generate the deployment address\n    function _predictDeterministicAddress(bytes32 salt) internal view returns (address payable) {\n        return payable(ensoBeacon.predictDeterministicAddress(\n            salt,\n            address(this)\n        ));\n    }\n\n    // @notice Internal function to support UUPS upgrades of the implementing proxy\n    // @notice newImplementation Address of the new implementation\n    function _authorizeUpgrade(address newImplementation) internal view override {\n        (newImplementation);\n        if (msg.sender != OWNER.getAddress()) revert NotOwner();\n    }\n}"
    }
  ]
}