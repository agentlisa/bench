{
  "Title": "[M-07] Upgrading modules via `executeAction()` will brick all existing rentals",
  "Content": "\nAll assets from rentals pre-upgrade will be locked. Users can't recover them as old rentals can't be stopped.\n\n### Proof of Concept\n\nThe protocol has a functionality to [upgrade modules via `Kernel::executeAction()`](https://github.com/re-nft/smart-contracts/blob/main/src/Kernel.sol#L285).\n\nThat upgrade functionality [performs some checks, initializes the new modules, and reconfigures policies](https://github.com/re-nft/smart-contracts/blob/main/src/Kernel.sol#L383-L411), but it doesn't migrate any data, nor transfer any assets.\n\nModules can hold assets, such as in the case of the `PaymentEscrow`, as well as keeping rentals states in storage.\n\nThe [current implementation of the `PaymentEscrow`](https://github.com/re-nft/smart-contracts/blob/main/src/modules/PaymentEscrow.sol) for example doesn't have any mechanism for migrations, or to stop rentals, or withdraw assets if the module was upgraded via `executeAction()`.\n\nThis will result in all previous rentals assets being locked, as rentals can no longer be stopped.\n\nThe following POC proves that old rentals can't be stopped, as well as showing how the old contract is still holding the users funds.\n\nCreate a new test in `smart-contracts/test/integration/Upgrade.t.sol` with this code:\n\n<Details>\n\n```solidity\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {\n    Order,\n    FulfillmentComponent,\n    Fulfillment,\n    ItemType as SeaportItemType\n} from \"@seaport-types/lib/ConsiderationStructs.sol\";\n\nimport {Errors} from \"@src/libraries/Errors.sol\";\nimport {OrderType, OrderMetadata, RentalOrder} from \"@src/libraries/RentalStructs.sol\";\n\nimport {BaseTest} from \"@test/BaseTest.sol\";\nimport {ProtocolAccount} from \"@test/utils/Types.sol\";\n\nimport {SafeUtils} from \"@test/utils/GnosisSafeUtils.sol\";\nimport {Safe} from \"@safe-contracts/Safe.sol\";\n\nimport {SafeL2} from \"@safe-contracts/SafeL2.sol\";\nimport {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\nimport {Proxy} from \"@src/proxy/Proxy.sol\";\n\nimport {Kernel, Actions} from \"@src/Kernel.sol\";\n\ncontract UpgradeDrain is BaseTest {\n    function test_StopRent_UpgradedModule() public {\n        // create a BASE order\n        createOrder({\n            offerer: alice,\n            orderType: OrderType.BASE,\n            erc721Offers: 1,\n            erc1155Offers: 0,\n            erc20Offers: 0,\n            erc721Considerations: 0,\n            erc1155Considerations: 0,\n            erc20Considerations: 1\n        });\n\n        // finalize the order creation\n        (\n            Order memory order,\n            bytes32 orderHash,\n            OrderMetadata memory metadata\n        ) = finalizeOrder();\n\n        // create an order fulfillment\n        createOrderFulfillment({\n            _fulfiller: bob,\n            order: order,\n            orderHash: orderHash,\n            metadata: metadata\n        });\n\n        // finalize the base order fulfillment\n        RentalOrder memory preUpgradeRental = finalizeBaseOrderFulfillment();\n\n        bytes memory paymentEscrowProxyInitCode = abi.encodePacked(\n            type(Proxy).creationCode,\n            abi.encode(\n                address(paymentEscrowImplementation),\n                abi.encodeWithSelector(\n                    PaymentEscrow.MODULE_PROXY_INSTANTIATION.selector,\n                    address(kernel)\n                )\n            )\n        );\n\n        // <<Upgrade the Escrow contract >>\n\n        PaymentEscrow OLD_ESCRW = ESCRW;\n\n        bytes12 protocolVersion = 0x000000000000000000000420;\n        bytes32 salt = create2Deployer.generateSaltWithSender(deployer.addr, protocolVersion);\n\n        vm.prank(deployer.addr);\n        PaymentEscrow NEW_ESCRW = PaymentEscrow(create2Deployer.deploy(salt, paymentEscrowProxyInitCode));\n\n        vm.prank(deployer.addr);\n        kernel.executeAction(Actions.UpgradeModule, address(NEW_ESCRW));\n\n        // speed up in time past the rental expiration\n        vm.warp(block.timestamp + 750);\n\n        bytes32 payRentalOrderHash = create.getRentalOrderHash(preUpgradeRental);\n\n        // assert that the rent still exists\n        assertEq(STORE.orders(payRentalOrderHash), true);\n        assertEq(STORE.isRentedOut(address(bob.safe), address(erc721s[0]), 0), true);\n\n        // assert that the ERC20 tokens are on the OLD contract\n        assertEq(erc20s[0].balanceOf(address(OLD_ESCRW)), uint256(100));\n        assertEq(erc20s[0].balanceOf(address(NEW_ESCRW)), uint256(0));\n\n        // assert that the token balances are in the OLD contract and haven't been migrated\n        assertEq(OLD_ESCRW.balanceOf(address(erc20s[0])), uint256(100));\n        assertEq(NEW_ESCRW.balanceOf(address(erc20s[0])), uint256(0));\n\n        // The rental can no longer be stopped\n        vm.expectRevert();\n        vm.prank(alice.addr);\n        stop.stopRent(preUpgradeRental);\n    }\n}\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\nProvide a method for users to migrate old rentals to the upgraded contracts, such as a `migrate()` function, executable by them or the protocol.\n\nAnother way is to provide a way to stop all rentals before the upgrade, in order to start with a fresh new module, or allow users to stop rentals from old modules.\n\n\n**[Alec1017 (reNFT) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2024-01-renft-findings/issues/397#issuecomment-1910471559):**\n > This is intended behavior. Upgrading modules is seen as an extremely rare thing, which will only be done in the absense of active rentals.\n> \n> Would probably be more appropriate for this to be QA.\n\n**[0xean (Judge) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/397#issuecomment-1914420417):**\n > @Alec1017 - How would this state be achieved? If the protocol is seeing broad adoption it seems likely that there are essentially always going to be outstanding rentals with no clear ability to recall them all.\n\n**[Alec1017 (reNFT) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/397#issuecomment-1915453926):**\n> Our co-signing technique allows us to stop signing off on allowing new rentals, so if we wanted to upgrade everything, we would stop co-signing on orders that use the old contracts and wait for all active orders to expire.\n> \n> Of course, this only works when a max rent duration is introduced, which is a planned mitigation for this audit.\n\n**[0xean (Judge) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/397#issuecomment-1915659794):**\n > Thanks. I think M is the correct severity since the code as audited doesn't practically allow for this functionality to work without major implications.  Even with a max duration, essentially pausing the protocol for that long is a DOS and probably means M is correct.\n\n**[Alec1017 (reNFT) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/397#issuecomment-1917105555):**\n > Hey there, I dont think I was very clear about the point of upgrading in this manner. Upgrading via the kernel is not meant to be the \"normal\" way a storage contract is upgraded, this is why they're proxies as well.\n> \n> Our protocol is modular, which allows the deployment of multiple versions of the same contracts. In the future, you could imagine multiple iterations of our protocol being introduced, which can be rolled in and out simultaneously. We can choose to deprecate one storage module by only allowing people to stop rentals via the situation i described above, and also allow them to initiate rentals with newer versions.\n> \n> Hopefully this is helpful context!\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-renft",
  "Code": [
    {
      "filename": "src/Kernel.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {\n    toRole,\n    ensureContract,\n    ensureValidKeycode,\n    ensureValidRole\n} from \"@src/libraries/KernelUtils.sol\";\nimport {Actions, Keycode, Role, Permissions} from \"@src/libraries/RentalStructs.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\nimport {Events} from \"src/libraries/Events.sol\";\n\n/////////////////////////////////////////////////////////////////////////////////\n//                         Module Abstract Contracts                           //\n/////////////////////////////////////////////////////////////////////////////////\n\n/**\n * @title KernelAdapter\n * @notice A base contract to be inherited by both policies and modules. Provides common\n *         access to logic related to the kernel contract.\n */\nabstract contract KernelAdapter {\n    // The active kernel contract.\n    Kernel public kernel;\n\n    /**\n     * @dev Instantiate this contract as a a kernel adapter. When using a proxy, the kernel address\n     *      should be set to address(0).\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) {\n        kernel = kernel_;\n    }\n\n    /**\n     * @dev Modifier which only allows calls from the active kernel contract.\n     */\n    modifier onlyKernel() {\n        if (msg.sender != address(kernel))\n            revert Errors.KernelAdapter_OnlyKernel(msg.sender);\n        _;\n    }\n\n    /**\n     * @notice Points the adapter to reference a new kernel address. This function can\n     *         only be called by the active kernel, and is used to perform migrations by\n     *         telling all policies and modules where the new kernel is located before\n     *         actually performing the migration.\n     *\n     * @param newKernel_  Address of the new kernel contract.\n     */\n    function changeKernel(Kernel newKernel_) external onlyKernel {\n        kernel = newKernel_;\n    }\n}\n\n/**\n * @title Module\n * @notice A base contract to be inherited by all module implementations. Provides common\n *         logic related to module functionality.\n */\nabstract contract Module is KernelAdapter {\n    /**\n     * @dev Instantiate this contract as a a module. When using a proxy, the kernel address\n     *      should be set to address(0).\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) KernelAdapter(kernel_) {}\n\n    /**\n     * @dev Modifier which only allows calls to the module if the policy contract making the\n     *      call has been given explicit permission by the kernel first.\n     */\n    modifier permissioned() {\n        if (!kernel.modulePermissions(KEYCODE(), Policy(msg.sender), msg.sig)) {\n            revert Errors.Module_PolicyNotAuthorized(msg.sender);\n        }\n        _;\n    }\n\n    /**\n     * @notice The 5-character keycode used to uniquely represent the module. This\n     *         must be implemented by the inheriting contract.\n     *\n     * @return Keycode represented by the module.\n     */\n    function KEYCODE() public pure virtual returns (Keycode);\n\n    /**\n     * @notice Specifies the version of the module being implemented. Minor version\n     *         changes retain the interface, and major version upgrades indicated\n     *         breaking changes to the interface.\n     *\n     * @return major Major version of the module.\n     * @return minor Minor version of the module.\n     */\n    function VERSION() external pure virtual returns (uint8 major, uint8 minor) {}\n\n    /**\n     * @notice Initialization function for the module which is called when the module is\n     *         first installed or upgraded by the kernel. Can only be called by the kernel.\n     */\n    function INIT() external virtual onlyKernel {}\n}\n\n/**\n * @title Policy\n * @notice A base contract to be inherited by all policy implementations. Provides common\n *         logic related to policy functionality.\n */\nabstract contract Policy is KernelAdapter {\n    // Whether the policy is active or not.\n    bool public isActive;\n\n    /**\n     * @dev Instantiate this contract as a a policy. When using a proxy, the kernel address\n     *      should be set to address(0).\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) KernelAdapter(kernel_) {}\n\n    /**\n     * @dev Modifier which only allows calls from addresses which have explicitly been\n     *      granted a role by the kernel.\n     */\n    modifier onlyRole(bytes32 role_) {\n        Role role = toRole(role_);\n        if (!kernel.hasRole(msg.sender, role)) {\n            revert Errors.Policy_OnlyRole(role);\n        }\n        _;\n    }\n\n    /**\n     * @notice When a policy is activated, it must respond with all of the module\n     *         keycodes that it depends on. The kernel stores these dependencies as a\n     *         mapping from module keycode to an array of policies that depend on it.\n     *         This is useful because when a module is upgraded, it can know exactly\n     *         the policies that depend upon it and call out to each policy to\n     *         reconfigure its dependencies to use the upgraded module contract address.\n     *\n     * @param dependencies Keycodes of all the modules that the policy depends on.\n     */\n    function configureDependencies()\n        external\n        virtual\n        onlyKernel\n        returns (Keycode[] memory dependencies)\n    {}\n\n    /**\n     * @notice When a policy is activated, it must respond with a series of\n     *         keycode <> function selector pairs which represent a request for the\n     *         policy to call a specific function selector at a specific module.\n     *         These requests are stored as a mapping in the kernel while the policy\n     *         is active, and the kernel will reject any call from a policy to a module\n     *         which has not first requested permission.\n     *\n     * @param requests Keycode <> function selector pairs which define the module access\n     *                 requested by a policy.\n     */\n    function requestPermissions()\n        external\n        view\n        virtual\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {}\n\n    /**\n     * @dev Used by a policy to get the current address of a module\n     *      at a specific keycode.\n     *\n     * @param keycode_ Keycode used to get the address of the module.\n     */\n    function getModuleAddress(Keycode keycode_) internal view returns (address) {\n        address moduleForKeycode = address(kernel.getModuleForKeycode(keycode_));\n        if (moduleForKeycode == address(0))\n            revert Errors.Policy_ModuleDoesNotExist(keycode_);\n        return moduleForKeycode;\n    }\n\n    /**\n     * @notice Allows the kernel to grant or revoke the active status of the policy.\n     *\n     * @param activate_ Whether to activate or deactivate the policy.\n     */\n    function setActiveStatus(bool activate_) external onlyKernel {\n        isActive = activate_;\n    }\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n//                               Kernel Contract                               //\n/////////////////////////////////////////////////////////////////////////////////\n\n/**\n * @title Kernel\n * @notice A registry contract that manages a set of policy and module contracts, as well\n *         as the permissions to interact with those contracts.\n */\ncontract Kernel {\n    // Admin addresses.\n    address public executor;\n    address public admin;\n\n    // Module Management.\n    Keycode[] public allKeycodes;\n    mapping(Keycode => Module) public getModuleForKeycode; // get contract for module keycode.\n    mapping(Module => Keycode) public getKeycodeForModule; // get module keycode for contract.\n\n    // Module dependents data. Manages module dependencies for policies.\n    mapping(Keycode => Policy[]) public moduleDependents;\n    mapping(Keycode => mapping(Policy => uint256)) public getDependentIndex;\n\n    // Module <> Policy Permissions. Keycode -> Policy -> Function Selector -> Permission.\n    mapping(Keycode => mapping(Policy => mapping(bytes4 => bool)))\n        public modulePermissions; // for policy addr, check if they have permission to call the function in the module.\n\n    // List of all active policies.\n    Policy[] public activePolicies;\n    mapping(Policy => uint256) public getPolicyIndex;\n\n    // Policy roles data.\n    mapping(address => mapping(Role => bool)) public hasRole;\n    mapping(Role => bool) public isRole;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                                Constructor                                  //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Instantiate the kernel with executor and admin addresses.\n     *\n     * @param _executor Address in charge of handling kernel executions.\n     * @param _admin    Address in charge of granting and revoking roles.\n     */\n    constructor(address _executor, address _admin) {\n        executor = _executor;\n        admin = _admin;\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                                Modifiers                                    //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Modifier which only allows calls by an executing address.\n     */\n    modifier onlyExecutor() {\n        if (msg.sender != executor) revert Errors.Kernel_OnlyExecutor(msg.sender);\n        _;\n    }\n\n    /**\n     * @dev modifier which only allows calls by an admin address.\n     */\n    modifier onlyAdmin() {\n        if (msg.sender != admin) revert Errors.Kernel_OnlyAdmin(msg.sender);\n        _;\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            External Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Executes an action on a target address.\n     *\n     * @param action_ Action which will be performed.\n     * @param target_ Address upon which the action will operate.\n     */\n    function executeAction(Actions action_, address target_) external onlyExecutor {\n        if (action_ == Actions.InstallModule) {\n            ensureContract(target_);\n            ensureValidKeycode(Module(target_).KEYCODE());\n            _installModule(Module(target_));\n        } else if (action_ == Actions.UpgradeModule) {\n            ensureContract(target_);\n            ensureValidKeycode(Module(target_).KEYCODE());\n            _upgradeModule(Module(target_));\n        } else if (action_ == Actions.ActivatePolicy) {\n            ensureContract(target_);\n            _activatePolicy(Policy(target_));\n        } else if (action_ == Actions.DeactivatePolicy) {\n            ensureContract(target_);\n            _deactivatePolicy(Policy(target_));\n        } else if (action_ == Actions.MigrateKernel) {\n            ensureContract(target_);\n            _migrateKernel(Kernel(target_));\n        } else if (action_ == Actions.ChangeExecutor) {\n            executor = target_;\n        } else if (action_ == Actions.ChangeAdmin) {\n            admin = target_;\n        }\n\n        emit Events.ActionExecuted(action_, target_);\n    }\n\n    /**\n     * @dev Grants a role to the target address.\n     *\n     * @param role_ Role to grant to the target.\n     * @param addr_ Address that will receive the role.\n     */\n    function grantRole(Role role_, address addr_) public onlyAdmin {\n        // Check that the address does not already have the role.\n        if (hasRole[addr_][role_])\n            revert Errors.Kernel_AddressAlreadyHasRole(addr_, role_);\n\n        // Ensure the role is properly formatted.\n        ensureValidRole(role_);\n\n        // Mark this role as having been granted.\n        if (!isRole[role_]) isRole[role_] = true;\n\n        // Grant the role to the target.\n        hasRole[addr_][role_] = true;\n\n        emit Events.RoleGranted(role_, addr_);\n    }\n\n    /**\n     * @dev Revokes a role from the target address.\n     *\n     * @param role_ Role to revoke from the target.\n     * @param addr_ Address that will have the role removed.\n     */\n    function revokeRole(Role role_, address addr_) public onlyAdmin {\n        // Check if the role has been granted before.\n        if (!isRole[role_]) revert Errors.Kernel_RoleDoesNotExist(role_);\n\n        // Check if the target address currently has the role.\n        if (!hasRole[addr_][role_])\n            revert Errors.Kernel_AddressDoesNotHaveRole(addr_, role_);\n\n        // Revoke the role.\n        hasRole[addr_][role_] = false;\n\n        emit Events.RoleRevoked(role_, addr_);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            Internal Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Installs a new module into the kernel.\n     *\n     * @param newModule_ Address of the new module.\n     */\n    function _installModule(Module newModule_) internal {\n        // Fetch the module keycode.\n        Keycode keycode = newModule_.KEYCODE();\n\n        // Make sure the keycode isnt in use already.\n        if (address(getModuleForKeycode[keycode]) != address(0)) {\n            revert Errors.Kernel_ModuleAlreadyInstalled(keycode);\n        }\n\n        // Connect the keycode to the module address.\n        getModuleForKeycode[keycode] = newModule_;\n\n        // Connect the module address to the keycode.\n        getKeycodeForModule[newModule_] = keycode;\n\n        // Keep a running array of all module keycodes.\n        allKeycodes.push(keycode);\n\n        // Initialize the module contract.\n        newModule_.INIT();\n    }\n\n    /**\n     * @dev Upgrades a module by changing the address that the keycode points to.\n     *\n     * @param newModule_ Address of the new module.\n     */\n    function _upgradeModule(Module newModule_) internal {\n        // Get the keycode of the new module\n        Keycode keycode = newModule_.KEYCODE();\n\n        // Get the address of the old module\n        Module oldModule = getModuleForKeycode[keycode];\n\n        // Check that the old module contract exists, and that the old module\n        // address is not the same as the new module\n        if (address(oldModule) == address(0) || oldModule == newModule_) {\n            revert Errors.Kernel_InvalidModuleUpgrade(keycode);\n        }\n\n        // The old module no longer points to the keycode.\n        getKeycodeForModule[oldModule] = Keycode.wrap(bytes5(0));\n\n        // The new module points to the keycode.\n        getKeycodeForModule[newModule_] = keycode;\n\n        // The keycode points to the new module.\n        getModuleForKeycode[keycode] = newModule_;\n\n        // Initialize the new module contract.\n        newModule_.INIT();\n\n        // Reconfigure policies so that all policies that depended on the old\n        // module will refetch the new module address from the kernel.\n        _reconfigurePolicies(keycode);\n    }\n\n    /**\n     * @dev Activates a new policy into the kernel.\n     *\n     * @param policy_ Address of the policy to activate.\n     */\n    function _activatePolicy(Policy policy_) internal {\n        // Ensure that the policy is not already active.\n        if (policy_.isActive())\n            revert Errors.Kernel_PolicyAlreadyApproved(address(policy_));\n\n        // Grant permissions for policy to access restricted module functions.\n        Permissions[] memory requests = policy_.requestPermissions();\n        _setPolicyPermissions(policy_, requests, true);\n\n        // Add policy to list of active policies.\n        activePolicies.push(policy_);\n\n        // Set the index of the policy in the array of active policies.\n        getPolicyIndex[policy_] = activePolicies.length - 1;\n\n        // Fetch module dependencies.\n        Keycode[] memory dependencies = policy_.configureDependencies();\n        uint256 depLength = dependencies.length;\n\n        // Loop through each keycode the policy depends on.\n        for (uint256 i; i < depLength; ++i) {\n            Keycode keycode = dependencies[i];\n\n            // Push the policy to the array of dependents for the keycode\n            moduleDependents[keycode].push(policy_);\n\n            // Set the index of the policy in the array of dependents.\n            getDependentIndex[keycode][policy_] = moduleDependents[keycode].length - 1;\n        }\n\n        // Set policy status to active.\n        policy_.setActiveStatus(true);\n    }\n\n    /**\n     * @dev Deactivates an active policy from the kernel\n     *\n     * @param policy_ Address of the policy to deactivate.\n     */\n    function _deactivatePolicy(Policy policy_) internal {\n        if (!policy_.isActive()) revert Errors.Kernel_PolicyNotApproved(address(policy_));\n\n        // Fetch originally granted permissions from the policy\n        // and then revoke them.\n        Permissions[] memory requests = policy_.requestPermissions();\n        _setPolicyPermissions(policy_, requests, false);\n\n        // Get the index of the policy in the active policies array.\n        uint256 idx = getPolicyIndex[policy_];\n\n        // Get the index of the last policy in the active policy array.\n        Policy lastPolicy = activePolicies[activePolicies.length - 1];\n\n        // Set the last policy at the index of the policy to deactivate.\n        activePolicies[idx] = lastPolicy;\n\n        // Pop the last policy from the array.\n        activePolicies.pop();\n\n        // Set the last policy's index to the index of the policy\n        // that was removed.\n        getPolicyIndex[lastPolicy] = idx;\n\n        // Delete the index of the policy being deactivated.\n        delete getPolicyIndex[policy_];\n\n        // Remove policy from array of dependents for each keycode\n        // that the policy depends upon.\n        _pruneFromDependents(policy_);\n\n        // Set policy status to inactive.\n        policy_.setActiveStatus(false);\n    }\n\n    /**\n     * @dev Migrates the kernel to a new contract.\n     *\n     *      WARNING: THIS ACTION WILL BRICK THIS KERNEL.\n     *\n     *      By performing a migration, this kernel will no longer have any authority\n     *      over the current policies and modules.\n     *\n     *      All functionality will move to the new kernel. The new kernel will need\n     *      to add all of the modules and policies again via `executeAction`. Until\n     *      all policies and modules are re-activated on the new kernel, policies will\n     *      not be able to access permissioned functions on modules, and privileged\n     *      addresses will not be able to access role-gated functions on policies.\n     *\n     * @param newKernel_ Address of the new kernel.\n     */\n    function _migrateKernel(Kernel newKernel_) internal {\n        uint256 keycodeLen = allKeycodes.length;\n\n        // For each keycode stored in the kernel.\n        for (uint256 i; i < keycodeLen; ++i) {\n            // get the module represented by the keycode.\n            Module module = Module(getModuleForKeycode[allKeycodes[i]]);\n            // Instruct the module to change the kernel.\n            module.changeKernel(newKernel_);\n        }\n\n        // For each active policy stored in the kernel\n        uint256 policiesLen = activePolicies.length;\n        for (uint256 j; j < policiesLen; ++j) {\n            // Get the policy.\n            Policy policy = activePolicies[j];\n\n            // Deactivate the policy before changing kernel.\n            policy.setActiveStatus(false);\n\n            // Instruct the policy to change the kernel.\n            policy.changeKernel(newKernel_);\n        }\n    }\n\n    /**\n     * @dev All policies that are dependent on the module represented by the keycode\n     *      must be reconfigured so that the policies can request the current\n     *      address of the module from the kernel.\n     *\n     * @param keycode_ Keycode representing the module.\n     */\n    function _reconfigurePolicies(Keycode keycode_) internal {\n        // Get an array of all policies that depend on the keycode.\n        Policy[] memory dependents = moduleDependents[keycode_];\n        uint256 depLength = dependents.length;\n\n        // Loop through each policy.\n        for (uint256 i; i < depLength; ++i) {\n            // Reconfigure its dependencies.\n            dependents[i].configureDependencies();\n        }\n    }\n\n    /**\n     * @dev Sets the permissions for a policy to interact with a module. Once the policy has\n     *      been activated, these permissions do not change until the policy is deactivated.\n     *\n     * @param policy_   Address of the policy.\n     * @param requests_ Permission requests comprised of keycode and function selector pairs.\n     * @param grant_    Whether to grant these permissions or revoke them.\n     */\n    function _setPolicyPermissions(\n        Policy policy_,\n        Permissions[] memory requests_,\n        bool grant_\n    ) internal {\n        uint256 reqLength = requests_.length;\n        for (uint256 i = 0; i < reqLength; ++i) {\n            // Set the permission for the keycode -> policy -> function selector.\n            Permissions memory request = requests_[i];\n            modulePermissions[request.keycode][policy_][request.funcSelector] = grant_;\n\n            emit Events.PermissionsUpdated(\n                request.keycode,\n                policy_,\n                request.funcSelector,\n                grant_\n            );\n        }\n    }\n\n    /**\n     * @dev All keycodes store an array of the policies that depend upon them,\n     *      so a policy must be pruned from this array when it is deactivated.\n     *\n     * @param policy_ Address of the policy to prune from the dependency array.\n     */\n    function _pruneFromDependents(Policy policy_) internal {\n        // Retrieve all keycodes that the policy is dependent upon.\n        Keycode[] memory dependencies = policy_.configureDependencies();\n        uint256 depcLength = dependencies.length;\n\n        // Loop through each keycode.\n        for (uint256 i; i < depcLength; ++i) {\n            // Get the stored array of policies that depend on the keycode.\n            Keycode keycode = dependencies[i];\n            Policy[] storage dependents = moduleDependents[keycode];\n\n            // Get the index of the policy to prune in the array.\n            uint256 origIndex = getDependentIndex[keycode][policy_];\n\n            // Get the address of the last policy in the array.\n            Policy lastPolicy = dependents[dependents.length - 1];\n\n            // Overwrite the last policy with the policy being pruned.\n            dependents[origIndex] = lastPolicy;\n\n            // Since the last policy exists twice now in the array, pop it\n            // from the end of the array.\n            dependents.pop();\n\n            // Set the index of the swapped policy to its correct spot.\n            getDependentIndex[keycode][lastPolicy] = origIndex;\n\n            // Delete the index of the of the pruned policy.\n            delete getDependentIndex[keycode][policy_];\n        }\n    }\n}"
    },
    {
      "filename": "src/Kernel.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {\n    toRole,\n    ensureContract,\n    ensureValidKeycode,\n    ensureValidRole\n} from \"@src/libraries/KernelUtils.sol\";\nimport {Actions, Keycode, Role, Permissions} from \"@src/libraries/RentalStructs.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\nimport {Events} from \"src/libraries/Events.sol\";\n\n/////////////////////////////////////////////////////////////////////////////////\n//                         Module Abstract Contracts                           //\n/////////////////////////////////////////////////////////////////////////////////\n\n/**\n * @title KernelAdapter\n * @notice A base contract to be inherited by both policies and modules. Provides common\n *         access to logic related to the kernel contract.\n */\nabstract contract KernelAdapter {\n    // The active kernel contract.\n    Kernel public kernel;\n\n    /**\n     * @dev Instantiate this contract as a a kernel adapter. When using a proxy, the kernel address\n     *      should be set to address(0).\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) {\n        kernel = kernel_;\n    }\n\n    /**\n     * @dev Modifier which only allows calls from the active kernel contract.\n     */\n    modifier onlyKernel() {\n        if (msg.sender != address(kernel))\n            revert Errors.KernelAdapter_OnlyKernel(msg.sender);\n        _;\n    }\n\n    /**\n     * @notice Points the adapter to reference a new kernel address. This function can\n     *         only be called by the active kernel, and is used to perform migrations by\n     *         telling all policies and modules where the new kernel is located before\n     *         actually performing the migration.\n     *\n     * @param newKernel_  Address of the new kernel contract.\n     */\n    function changeKernel(Kernel newKernel_) external onlyKernel {\n        kernel = newKernel_;\n    }\n}\n\n/**\n * @title Module\n * @notice A base contract to be inherited by all module implementations. Provides common\n *         logic related to module functionality.\n */\nabstract contract Module is KernelAdapter {\n    /**\n     * @dev Instantiate this contract as a a module. When using a proxy, the kernel address\n     *      should be set to address(0).\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) KernelAdapter(kernel_) {}\n\n    /**\n     * @dev Modifier which only allows calls to the module if the policy contract making the\n     *      call has been given explicit permission by the kernel first.\n     */\n    modifier permissioned() {\n        if (!kernel.modulePermissions(KEYCODE(), Policy(msg.sender), msg.sig)) {\n            revert Errors.Module_PolicyNotAuthorized(msg.sender);\n        }\n        _;\n    }\n\n    /**\n     * @notice The 5-character keycode used to uniquely represent the module. This\n     *         must be implemented by the inheriting contract.\n     *\n     * @return Keycode represented by the module.\n     */\n    function KEYCODE() public pure virtual returns (Keycode);\n\n    /**\n     * @notice Specifies the version of the module being implemented. Minor version\n     *         changes retain the interface, and major version upgrades indicated\n     *         breaking changes to the interface.\n     *\n     * @return major Major version of the module.\n     * @return minor Minor version of the module.\n     */\n    function VERSION() external pure virtual returns (uint8 major, uint8 minor) {}\n\n    /**\n     * @notice Initialization function for the module which is called when the module is\n     *         first installed or upgraded by the kernel. Can only be called by the kernel.\n     */\n    function INIT() external virtual onlyKernel {}\n}\n\n/**\n * @title Policy\n * @notice A base contract to be inherited by all policy implementations. Provides common\n *         logic related to policy functionality.\n */\nabstract contract Policy is KernelAdapter {\n    // Whether the policy is active or not.\n    bool public isActive;\n\n    /**\n     * @dev Instantiate this contract as a a policy. When using a proxy, the kernel address\n     *      should be set to address(0).\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) KernelAdapter(kernel_) {}\n\n    /**\n     * @dev Modifier which only allows calls from addresses which have explicitly been\n     *      granted a role by the kernel.\n     */\n    modifier onlyRole(bytes32 role_) {\n        Role role = toRole(role_);\n        if (!kernel.hasRole(msg.sender, role)) {\n            revert Errors.Policy_OnlyRole(role);\n        }\n        _;\n    }\n\n    /**\n     * @notice When a policy is activated, it must respond with all of the module\n     *         keycodes that it depends on. The kernel stores these dependencies as a\n     *         mapping from module keycode to an array of policies that depend on it.\n     *         This is useful because when a module is upgraded, it can know exactly\n     *         the policies that depend upon it and call out to each policy to\n     *         reconfigure its dependencies to use the upgraded module contract address.\n     *\n     * @param dependencies Keycodes of all the modules that the policy depends on.\n     */\n    function configureDependencies()\n        external\n        virtual\n        onlyKernel\n        returns (Keycode[] memory dependencies)\n    {}\n\n    /**\n     * @notice When a policy is activated, it must respond with a series of\n     *         keycode <> function selector pairs which represent a request for the\n     *         policy to call a specific function selector at a specific module.\n     *         These requests are stored as a mapping in the kernel while the policy\n     *         is active, and the kernel will reject any call from a policy to a module\n     *         which has not first requested permission.\n     *\n     * @param requests Keycode <> function selector pairs which define the module access\n     *                 requested by a policy.\n     */\n    function requestPermissions()\n        external\n        view\n        virtual\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {}\n\n    /**\n     * @dev Used by a policy to get the current address of a module\n     *      at a specific keycode.\n     *\n     * @param keycode_ Keycode used to get the address of the module.\n     */\n    function getModuleAddress(Keycode keycode_) internal view returns (address) {\n        address moduleForKeycode = address(kernel.getModuleForKeycode(keycode_));\n        if (moduleForKeycode == address(0))\n            revert Errors.Policy_ModuleDoesNotExist(keycode_);\n        return moduleForKeycode;\n    }\n\n    /**\n     * @notice Allows the kernel to grant or revoke the active status of the policy.\n     *\n     * @param activate_ Whether to activate or deactivate the policy.\n     */\n    function setActiveStatus(bool activate_) external onlyKernel {\n        isActive = activate_;\n    }\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n//                               Kernel Contract                               //\n/////////////////////////////////////////////////////////////////////////////////\n\n/**\n * @title Kernel\n * @notice A registry contract that manages a set of policy and module contracts, as well\n *         as the permissions to interact with those contracts.\n */\ncontract Kernel {\n    // Admin addresses.\n    address public executor;\n    address public admin;\n\n    // Module Management.\n    Keycode[] public allKeycodes;\n    mapping(Keycode => Module) public getModuleForKeycode; // get contract for module keycode.\n    mapping(Module => Keycode) public getKeycodeForModule; // get module keycode for contract.\n\n    // Module dependents data. Manages module dependencies for policies.\n    mapping(Keycode => Policy[]) public moduleDependents;\n    mapping(Keycode => mapping(Policy => uint256)) public getDependentIndex;\n\n    // Module <> Policy Permissions. Keycode -> Policy -> Function Selector -> Permission.\n    mapping(Keycode => mapping(Policy => mapping(bytes4 => bool)))\n        public modulePermissions; // for policy addr, check if they have permission to call the function in the module.\n\n    // List of all active policies.\n    Policy[] public activePolicies;\n    mapping(Policy => uint256) public getPolicyIndex;\n\n    // Policy roles data.\n    mapping(address => mapping(Role => bool)) public hasRole;\n    mapping(Role => bool) public isRole;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                                Constructor                                  //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Instantiate the kernel with executor and admin addresses.\n     *\n     * @param _executor Address in charge of handling kernel executions.\n     * @param _admin    Address in charge of granting and revoking roles.\n     */\n    constructor(address _executor, address _admin) {\n        executor = _executor;\n        admin = _admin;\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                                Modifiers                                    //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Modifier which only allows calls by an executing address.\n     */\n    modifier onlyExecutor() {\n        if (msg.sender != exec"
    }
  ]
}