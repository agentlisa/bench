{
  "Title": "[M-12] Interface definition error",
  "Content": "_Submitted by bin2chen, also found by 0x52, 0xDjango, 0xSky, auditor0517, Picodes, rokinot, ronnyx2017, and scaraven_\n\n<https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/Marketplace/Interfaces.sol#L52>\n\n<https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/Marketplace/MarketPlace.sol#L164>\n\n<https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/Swivel/Swivel.sol#L620>\n\n<https://github.com/Swivel-Finance/gost/blob/a76ac859df049527c3e5df85e706dec6ffa0e2bb/test/swivel/Swivel.sol#L10>\n\n### Impact\n\n`MarketPlace.authRedeem()` call interface `ISwivel.authRedeem()` but Swivel contract  does not have this method only method  \"authRedeemZcToken()\".\n\nThe result will cause `MarketPlace.authRedeem()` to fail forever, thus causing `ZcToken.withdraw()` to fail forever.\n\n### Proof of Concept\n\nMarketPlace.sol call `ISwivel.authRedeem()`\n\n      function authRedeem(uint8 p, address u, uint256 m, address f, address t, uint256 a) public authorized(markets[p][u][m].zcToken) returns (uint256 underlyingAmount) {\n         .....\n\n          ISwivel(swivel).authRedeem(p, u, market.cTokenAddr, t, a);\n\n         .....\n        } else {\n\n         .....\n          ISwivel(swivel).authRedeem(p, u, market.cTokenAddr, t, amount);\n         ....\n        }\n\nSwivel.sol does not have `authRedeem()` ,only `authRedeemZcToken()`\n\n```\n  function authRedeemZcToken(uint8 p, address u, address c, address t, uint256 a) external authorized(marketPlace) returns(bool) {\n    // redeem underlying from compounding\n    if (!withdraw(p, u, c, a)) { revert Exception(7, 0, 0, address(0), address(0)); }\n    // transfer underlying back to msg.sender\n    Safe.transfer(IErc20(u), t, a);\n\n    return (true);\n  }\n\n```\n\n### Recommended Mitigation Steps\n\nSwivel contract need declare \"is ISwivel\" and change method name.\n\nOther contracts should also declare \"is Iinterfacename\" to avoid method name errors\nlike IMarketPlace.\n\n**[JTraversa (Swivel) commented](https://github.com/code-423n4/2022-07-swivel-findings/issues/39#issuecomment-1188432197):**\n > Duplicate of [#186](https://github.com/code-423n4/2022-07-swivel-findings/issues/186).\n\n**[bghughes (judge) commented](https://github.com/code-423n4/2022-07-swivel-findings/issues/39#issuecomment-1203993402):**\n > Main issue for the non-existent function call and interface definition error.\n\n**[0xean (judge) increased severity to High and commented](https://github.com/code-423n4/2022-07-swivel-findings/issues/39#issuecomment-1226518688):**\n > This shows a direct path to funds being locked, upgrading the severity (and all duplicates) to high. \n\n**[JTraversa (Swivel) commented](https://github.com/code-423n4/2022-07-swivel-findings/issues/39#issuecomment-1229878805):**\n > Hmm, I think this could go either way.\n> \n> Technically because this is a redundant method meant to add compliance with EIP-5095, there aren't actually user funds locked because they can follow the normal `redeem` workflow. So it is specifically that EIP-5095 compliance that would be broken.\n> \n> Plus personally I'd also want to reward more interesting or critical errors rather than a mis-spelled or defined interface.\n> \n> That said, I'd of course err towards the judge's decision, but maybe that extra context helps ! \n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-07-swivel-findings/issues/39#issuecomment-1230214222):**\n > @JTraversa - appreciate the note and context. \n> \n> Can we walk through that flow to confirm the code path?  I would downgrade to M if there is an alternate flow.\n> \n> We both agree this function doesn't work - https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/Marketplace/MarketPlace.sol#L148\n> \n> Which afaict also means that these calls are not functional either. \n> \n> https://github.com/code-423n4/2022-07-swivel/blob/daf72892d8a8d6eaa43b9e7d1924ccb0e612ee3c/Creator/ZcToken.sol#L98\n> \n> https://github.com/code-423n4/2022-07-swivel/blob/daf72892d8a8d6eaa43b9e7d1924ccb0e612ee3c/Creator/ZcToken.sol#L124\n> \n> Can you direct me to the alternate flow for redemption and I will confirm and move back to M\n> \n\n**[JTraversa (Swivel) commented](https://github.com/code-423n4/2022-07-swivel-findings/issues/39#issuecomment-1230996235):**\n > For sure!\n> \n> So there are two ways to redeem. Given custody sits on Swivel.sol, one is to call the zcToken (ERC-5095), which then itself calls authorized methods that bubble up from zcToken -> marketplace -> swivel. This is the path that appears to be broken, the `authRedeem`.\n> \n> That said, the primary path (the one we've used in previous Swivel versions) is one that starts with a redemption method directly on Swivel.sol, and has the instruction to burn bubbled down from swivel -> marketplace -> zcToken.\n> \n> That is available on Swivel.sol here: [Link](https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/Swivel/Swivel.sol#L634)\n> \n> And its call to Marketplace.sol here: [Link](https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/Marketplace/MarketPlace.sol#L176)\n> \n> Hopefully that clarifies a bit :) \n\n**[0xean (judge) decreased severity back to Medium and commented](https://github.com/code-423n4/2022-07-swivel-findings/issues/39#issuecomment-1231004724):**\n > Yup, thank you. Downgraded back to M as user funds are not locked given the alternate path. \n\n\n\n***\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-07-swivel-v3-contest",
  "Code": [
    {
      "filename": "Marketplace/Interfaces.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\ninterface IErc20 {\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  function totalSupply() external view returns (uint256);\n  function balanceOf(address account) external view returns (uint256);\n  function transfer(address to, uint256 amount) external returns (bool);\n  function allowance(address owner, address spender) external view returns (uint256);\n  function approve(address spender, uint256 amount) external returns (bool);\n  function decimals() external returns (uint8);\n  function transferFrom(\n      address from,\n      address to,\n      uint256 amount\n  ) external returns (bool);\n}\n\n/// @notice The deployed Creator contract creates and deploys instances of the\n/// ZcToken and VaultTracker contracts, returning their addresses\ninterface ICreator {\n  function create(\n    uint8 p,\n    address u,\n    uint256 m,\n    address c,\n    address sw,\n    string memory n,\n    string memory s,\n    uint8 d\n  ) external returns (address, address);\n}\n\ninterface IZcToken {\n  function mint(address t, uint256 a) external returns (bool);\n  function burn(address f, uint256 a) external returns (bool);\n}\n\ninterface IVaultTracker {\n  function addNotional(address o, uint256 a) external returns (bool);\n  function removeNotional(address o, uint256 a) external returns (bool);\n  function redeemInterest(address o) external returns (uint256);\n  function matureVault(uint256 c) external returns (bool);\n  function transferNotionalFrom(address f, address t, uint256 a) external returns (bool);\n  function transferNotionalFee(address f, uint256 a) external returns (bool);\n  function balancesOf(address o) external view returns (uint256, uint256);\n}\n\ninterface ISwivel {\n  function authRedeem(uint8 p, address u, address c, address t, uint256 a) external returns (bool);\n}\n\ninterface InterestRateModel {\n    function getBorrowRate(\n        uint256,\n        uint256,\n        uint256\n    ) external view returns (uint256);\n    function getSupplyRate(\n        uint256,\n        uint256,\n        uint256,\n        uint256\n    ) external view returns (uint256);\n}\n\ninterface ICERC20 is IErc20 {\n    function underlying() external view returns (IErc20);\n    function totalBorrows() external view returns (uint256);\n    function totalReserves() external view returns (uint256);\n    function exchangeRateStored() external view returns (uint256);\n    function reserveFactorMantissa() external view returns (uint256);\n    function interestRateModel() external view returns (InterestRateModel);\n    function initialExchangeRateMantissa() external view returns (uint256);\n    function accrualBlockNumber() external view returns (uint256);\n    function totalAdminFees() external view returns (uint256);\n    function totalFuseFees() external view returns (uint256);\n    function adminFeeMantissa() external view returns (uint256);\n    function fuseFeeMantissa() external view returns (uint256);\n}"
    },
    {
      "filename": "Marketplace/MarketPlace.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Interfaces.sol';\nimport './Compounding.sol';\n\ncontract MarketPlace {\n  /// @dev A single custom error capable of indicating a wide range of detected errors by providing\n  /// an error code value whose string representation is documented <here>, and any possible other values\n  /// that are pertinent to the error.\n  error Exception(uint8, uint256, uint256, address, address);\n\n  struct Market {\n    address cTokenAddr;\n    address zcToken;\n    address vaultTracker;\n    uint256 maturityRate;\n  }\n\n  mapping (uint8 => mapping (address => mapping (uint256 => Market))) public markets;\n  mapping (uint8 => bool) public paused;\n\n  address public admin;\n  address public swivel;\n  address public immutable creator;\n\n  event Create(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, address cToken, address zcToken, address vaultTracker);\n  event Mature(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, uint256 maturityRate, uint256 matured);\n  event RedeemZcToken(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, address sender, uint256 amount);\n  event RedeemVaultInterest(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, address sender);\n  event CustodialInitiate(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, address zcTarget, address nTarget, uint256 amount);\n  event CustodialExit(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, address zcTarget, address nTarget, uint256 amount);\n  event P2pZcTokenExchange(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, address from, address to, uint256 amount);\n  event P2pVaultExchange(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, address from, address to, uint256 amount);\n  event TransferVaultNotional(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, address from, address to, uint256 amount);\n\n  constructor(address c) {\n    admin = msg.sender;\n    creator = c;\n  }\n\n  /// @param s Address of the deployed swivel contract\n  /// @notice We only allow this to be set once\n  function setSwivel(address s) external authorized(admin) returns (bool) {\n    if (swivel != address(0)) { revert Exception(20, 0, 0, swivel, address(0));  }\n\n    swivel = s;\n    return true;\n  }\n\n  /// @param a Address of a new admin\n  function setAdmin(address a) external authorized(admin) returns (bool) {\n    admin = a;\n    return true;\n  }\n\n  /// @notice Allows the owner to create new markets\n  /// @param p Protocol associated with the new market\n  /// @param m Maturity timestamp of the new market\n  /// @param c Compounding Token address associated with the new market\n  /// @param n Name of the new market zcToken\n  /// @param s Symbol of the new market zcToken\n  function createMarket(\n    uint8 p,\n    uint256 m,\n    address c,\n    string memory n,\n    string memory s\n  ) external authorized(admin) unpaused(p) returns (bool) {\n    if (swivel == address(0)) { revert Exception(21, 0, 0, address(0), address(0)); }\n\n    address underAddr = Compounding.underlying(p, c);\n\n    if (markets[p][underAddr][m].vaultTracker != address(0)) { revert Exception(22, 0, 0, address(0), address(0)); }\n\n    (address zct, address tracker) = ICreator(creator).create(p, underAddr, m, c, swivel, n, s, IErc20(underAddr).decimals()) ;\n\n    markets[p][underAddr][m] = Market(c, zct, tracker, 0);\n\n    emit Create(p, underAddr, m, c, zct, tracker);\n\n    return true;\n  }\n\n  /// @notice Can be called after maturity, allowing all of the zcTokens to earn floating interest on Compound until they release their funds\n  /// @param p Protocol Enum value associated with the market being matured\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  function matureMarket(uint8 p, address u, uint256 m) public unpaused(p) returns (bool) {\n    Market memory market = markets[p][u][m];\n\n    if (market.maturityRate != 0) { revert Exception(23, market.maturityRate, 0, address(0), address(0)); }\n\n    if (block.timestamp < m) { revert Exception(24, block.timestamp, m, address(0), address(0)); }\n\n    // set the base maturity cToken exchange rate at maturity to the current cToken exchange rate\n    uint256 exchangeRate = Compounding.exchangeRate(p, market.cTokenAddr);\n    markets[p][u][m].maturityRate = exchangeRate;\n\n    // NOTE we don't check the return of this simple operation\n    IVaultTracker(market.vaultTracker).matureVault(exchangeRate);\n\n    emit Mature(p, u, m, exchangeRate, block.timestamp);\n\n    return true;\n  }\n\n  /// @notice Allows Swivel caller to deposit their underlying, in the process splitting it - minting both zcTokens and vault notional.\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param t Address of the depositing user\n  /// @param a Amount of notional being added\n  function mintZcTokenAddingNotional(uint8 p, address u, uint256 m, address t, uint256 a) external authorized(swivel) unpaused(p) returns (bool) {\n    Market memory market = markets[p][u][m];\n\n    if (!IZcToken(market.zcToken).mint(t, a)) { revert Exception(28, 0, 0, address(0), address(0)); }\n\n    if (!IVaultTracker(market.vaultTracker).addNotional(t, a)) { revert Exception(25, 0, 0, address(0), address(0)); }\n    \n    return true;\n  }\n\n  /// @notice Allows Swivel caller to deposit/burn both zcTokens + vault notional. This process is \"combining\" the two and redeeming underlying.\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param t Address of the combining/redeeming user\n  /// @param a Amount of zcTokens being burned\n  function burnZcTokenRemovingNotional(uint8 p, address u, uint256 m, address t, uint256 a) external authorized(swivel) unpaused(p) returns(bool) {\n    Market memory market = markets[p][u][m];\n\n    if (!IZcToken(market.zcToken).burn(t, a)) { revert Exception(29, 0, 0, address(0), address(0)); }\n\n    if (!IVaultTracker(market.vaultTracker).removeNotional(t, a)) { revert Exception(26, 0, 0, address(0), address(0)); }\n    \n    return true;\n  }\n\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param f Address of the user having their zcTokens burned\n  /// @param t Address of the user receiving underlying\n  /// @param a Amount of zcTokens being redeemed\n  /// @return underlyingAmount Amount of underlying being withdrawn (needed for 5095 return)\n  function authRedeem(uint8 p, address u, uint256 m, address f, address t, uint256 a) public authorized(markets[p][u][m].zcToken) returns (uint256 underlyingAmount) {\n    Market memory market = markets[p][u][m];\n    // if the market has not matured, mature it...\n    if (market.maturityRate == 0) {\n      if (!matureMarket(p, u, m)) { revert Exception(30, 0, 0, address(0), address(0)); }\n\n      if (!IZcToken(market.zcToken).burn(f, a)) { revert Exception(29, 0, 0, address(0), address(0)); }\n\n      ISwivel(swivel).authRedeem(p, u, market.cTokenAddr, t, a);\n\n      return (a);\n    } else {\n\n      if (!IZcToken(market.zcToken).burn(f, a)) { revert Exception(29, 0, 0, address(0), address(0)); }\n\n      uint256 amount = calculateReturn(p, u, m, a);\n      ISwivel(swivel).authRedeem(p, u, market.cTokenAddr, t, amount);\n\n      return (amount);\n    }\n  }\n\n  /// @notice Allows (via swivel) zcToken holders to redeem their tokens for underlying tokens after maturity has been reached.\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param t Address of the redeeming user\n  /// @param a Amount of zcTokens being redeemed\n  function redeemZcToken(uint8 p, address u, uint256 m, address t, uint256 a) external authorized(swivel) unpaused(p) returns (uint256) {\n    Market memory market = markets[p][u][m];\n\n    // if the market has not matured, mature it and redeem exactly the amount\n    if (market.maturityRate == 0) {\n      if (!matureMarket(p, u, m)) { revert Exception(30, 0, 0, address(0), address(0)); }\n    }\n\n    if (!IZcToken(market.zcToken).burn(t, a)) { revert Exception(29, 0, 0, address(0), address(0)); }\n\n    emit RedeemZcToken(p, u, m, t, a);\n\n    if (market.maturityRate == 0) {\n      return a;\n    } else { \n      // if the market was already mature the return should include the amount + marginal floating interest generated on Compound since maturity\n      return calculateReturn(p, u, m, a);\n    }\n  }\n\n  /// @notice Allows Vault owners (via Swivel) to redeem any currently accrued interest\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param t Address of the redeeming user\n  function redeemVaultInterest(uint8 p, address u, uint256 m, address t) external authorized(swivel) unpaused(p) returns (uint256) {\n    // call to the floating market contract to release the position and calculate the interest generated\n    uint256 interest = IVaultTracker(markets[p][u][m].vaultTracker).redeemInterest(t);\n\n    emit RedeemVaultInterest(p, u, m, t);\n\n    return interest;\n  }\n\n  /// @notice Calculates the total amount of underlying returned including interest generated since the `matureMarket` function has been called\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param a Amount of zcTokens being redeemed\n  function calculateReturn(uint8 p, address u, uint256 m, uint256 a) internal view returns (uint256) {\n    Market memory market = markets[p][u][m];\n\n    uint256 exchangeRate = Compounding.exchangeRate(p, market.cTokenAddr);\n\n    return (a * exchangeRate) / market.maturityRate;\n  }\n\n  /// @notice Return the compounding token address for a given market\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  function cTokenAddress(uint8 p, address u, uint256 m) external view returns (address) {\n    Market memory market = markets[p][u][m];\n    return market.cTokenAddr;\n  }\n\n  /// @notice Return the exchangeRate for a given protocol's compounding token\n  /// @param p Protocol Enum value associated with this market\n  /// @param c Compounding token address associated with the market\n  function getExchangeRate(uint8 p, address c) external view returns (uint256) {\n      return Compounding.exchangeRate(p, c);\n  }\n\n  /// @notice Called by swivel IVFZI && IZFVI\n  /// @dev Call with protocol, underlying, maturity, mint-target, add-notional-target and an amount\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param z Recipient of the minted zcToken\n  /// @param n Recipient of the added notional\n  /// @param a Amount of zcToken minted and notional added\n  function custodialInitiate(uint8 p, address u, uint256 m, address z, address n, uint256 a) external authorized(swivel) unpaused(p) returns (bool) {\n    Market memory market = markets[p][u][m];\n    if (!IZcToken(market.zcToken).mint(z, a)) { revert Exception(28, 0, 0, address(0), address(0)); }\n\n    if (!IVaultTracker(market.vaultTracker).addNotional(n, a)) { revert Exception(25, 0, 0, address(0), address(0)); }\n\n    emit CustodialInitiate(p, u, m, z, n, a);\n    return true;\n  }\n\n  /// @notice Called by swivel EVFZE FF EZFVE\n  /// @dev Call with protocol, underlying, maturity, burn-target, remove-notional-target and an amount\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param z Owner of the zcToken to be burned\n  /// @param n Target to remove notional from\n  /// @param a Amount of zcToken burned and notional removed\n  function custodialExit(uint8 p, address u, uint256 m, address z, address n, uint256 a) external authorized(swivel) unpaused(p) returns (bool) {\n    Market memory market = markets[p][u][m];\n    if (!IZcToken(market.zcToken).burn(z, a)) { revert Exception(29, 0, 0, address(0), address(0)); }\n\n    if (!IVaultTracker(market.vaultTracker).removeNotional(n, a)) { revert Exception(26, 0, 0, address(0), address(0)); }\n\n    emit CustodialExit(p, u, m, z, n, a);\n    return true;\n  }\n\n  /// @notice Called by swivel IZFZE, EZFZI\n  /// @dev Call with underlying, maturity, transfer-from, transfer-to, amount\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param f Owner of the zcToken to be burned\n  /// @param t Target to be minted to\n  /// @param a Amount of zcToken transfer\n  function p2pZcTokenExchange(uint8 p, address u, uint256 m, address f, address t, uint256 a) external authorized(swivel) unpaused(p) returns (bool) {\n    Market memory market = markets[p][u][m];\n    if (!IZcToken(market.zcToken).burn(f, a)) { revert Exception(29, 0, 0, address(0), address(0)); }\n\n    if (!IZcToken(market.zcToken).mint(t, a)) { revert Exception(28, 0, 0, address(0), address(0)); }\n\n    emit P2pZcTokenExchange(p, u, m, f, t, a);\n    return true;\n  }\n\n  /// @notice Called by swivel IVFVE, EVFVI\n  /// @dev Call with protocol, underlying, maturity, remove-from, add-to, amount\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param f Owner of the notional to be transferred\n  /// @param t Target to be transferred to\n  /// @param a Amount of notional transfer\n  function p2pVaultExchange(uint8 p, address u, uint256 m, address f, address t, uint256 a) external authorized(swivel) unpaused(p) returns (bool) {\n    if (!IVaultTracker(markets[p][u][m].vaultTracker).transferNotionalFrom(f, t, a)) { revert Exception(27, 0, 0, address(0), address(0)); }\n\n    emit P2pVaultExchange(p, u, m, f, t, a);\n    return true;\n  }\n\n  /// @notice External method giving access to this functionality within a given vault\n  /// @dev Note that this method calculates yield and interest as well\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param t Target to be transferred to\n  /// @param a Amount of notional to be transferred\n  function transferVaultNotional(uint8 p, address u, uint256 m, address t, uint256 a) external unpaused(p) returns (bool) {\n    if (!IVaultTracker(markets[p][u][m].vaultTracker).transferNotionalFrom(msg.sender, t, a)) { revert Exception(27, 0, 0, address(0), address(0)); }\n\n    emit TransferVaultNotional(p, u, m, msg.sender, t, a);\n    return true;\n  }\n\n  /// @notice Transfers notional fee to the Swivel contract without recalculating marginal interest for from\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param f Owner of the amount\n  /// @param a Amount to transfer\n  function transferVaultNotionalFee(uint8 p, address u, uint256 m, address f, uint256 a) external authorized(swivel) returns (bool) {\n    IVaultTracker(markets[p][u][m].vaultTracker).transferNotionalFee(f, a);\n    return true;\n  }\n\n  /// @notice Called by admin at any point to pause / unpause market transactions in a specified protocol\n  /// @param p Protocol Enum value of the protocol to be paused\n  /// @param b Boolean which indicates the (protocol) markets paused status\n  function pause(uint8 p, bool b) external authorized(admin) returns (bool) {\n    paused[p] = b;\n    return true;\n  }\n\n  modifier authorized(address a) {\n    if(msg.sender != a) { revert Exception(0, 0, 0, msg.sender, a); }\n    _;\n  }\n\n  modifier unpaused(uint8 p) {\n    if(paused[p]) { revert Exception(1, 0, 0, address(0), address(0)); }\n    _;\n  }\n}"
    },
    {
      "filename": "Swivel/Swivel.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Interfaces.sol';\nimport './Protocols.sol';\nimport './Hash.sol';\nimport './Sig.sol';\nimport './Safe.sol';\n\ncontract Swivel {\n  /// @dev A single custom error capable of indicating a wide range of detected errors by providing\n  /// an error code value whose string representation is documented <here>, and any possible other values\n  /// that are pertinent to the error.\n  error Exception(uint8, uint256, uint256, address, address);\n  /// @dev maps the key of an order to a boolean indicating if an order was cancelled\n  mapping (bytes32 => bool) public cancelled;\n  /// @dev maps the key of an order to an amount representing its taken volume\n  mapping (bytes32 => uint256) public filled;\n  /// @dev maps a token address to a point in time, a hold, after which a withdrawal can be made\n  mapping (address => uint256) public withdrawals;\n  /// @dev maps a token address to a point in time, a hold, after which an approval can be made\n  mapping (address => uint256) public approvals;\n\n  string constant public NAME = 'Swivel Finance';\n  string constant public VERSION = '3.0.0';\n  uint256 constant public HOLD = 3 days;\n  bytes32 public immutable domain;\n  address public immutable marketPlace;\n  address public admin;\n  \n  /// @dev address of a deployed Aave contract implementing IAave\n  address public aaveAddr; // TODO immutable?\n\n  uint16 constant public MIN_FEENOMINATOR = 33;\n  /// @dev holds the fee demoninators for [zcTokenInitiate, zcTokenExit, vaultInitiate, vaultExit]\n  uint16[4] public feenominators;\n  /// @dev A point in time, a hold, after which a change to Fees\n  uint256 public feeChange;\n\n  /// @notice Emitted on order cancellation\n  event Cancel (bytes32 indexed key, bytes32 hash);\n  /// @notice Emitted on any initiate*\n  /// @dev filled is 'principalFilled' when (vault:false, exit:false) && (vault:true, exit:true)\n  /// @dev filled is 'premiumFilled' when (vault:true, exit:false) && (vault:false, exit:true)\n  event Initiate(bytes32 indexed key, bytes32 hash, address indexed maker, bool vault, bool exit, address indexed sender, uint256 amount, uint256 filled);\n  /// @notice Emitted on any exit*\n  /// @dev filled is 'principalFilled' when (vault:false, exit:false) && (vault:true, exit:true)\n  /// @dev filled is 'premiumFilled' when (vault:true, exit:false) && (vault:false, exit:true)\n  event Exit(bytes32 indexed key, bytes32 hash, address indexed maker, bool vault, bool exit, address indexed sender, uint256 amount, uint256 filled);\n  /// @notice Emitted on token withdrawal scheduling\n  event ScheduleWithdrawal(address indexed token, uint256 hold);\n  /// @notice Emitted on token withdrawal blocking\n  event BlockWithdrawal(address indexed token);\n  /// @notice Emitted on a change to the feenominators array\n  event SetFee(uint256 indexed index, uint256 indexed feenominator);\n  /// @notice Emitted on a token approval scheduling\n  event ScheduleApproval(address indexed token, uint256 hold);\n  /// @notice Emitted on a token approval blocking\n  event BlockApproval(address indexed token);\n  /// @notice Emitted on a fee change scheduling\n  event ScheduleFeeChange(uint256 hold);\n  /// @notice Emitted on a fee change blocking\n  event BlockFeeChange();\n\n  /// @param m Deployed MarketPlace contract address\n  /// @param a Address of a deployed Aave contract implementing our interface\n  constructor(address m, address a) {\n    admin = msg.sender;\n    domain = Hash.domain(NAME, VERSION, block.chainid, address(this));\n    marketPlace = m;\n    aaveAddr = a;\n    feenominators = [200, 600, 400, 200];\n  }\n\n  // ********* INITIATING *************\n\n  /// @notice Allows a user to initiate a position\n  /// @param o Array of offline Swivel.Orders\n  /// @param a Array of order volume (principal) amounts relative to passed orders\n  /// @param c Array of Components from valid ECDSA signatures\n  function initiate(Hash.Order[] calldata o, uint256[] calldata a, Sig.Components[] calldata c) external returns (bool) {\n    uint256 len = o.length;\n    // for each order filled, routes the order to the right interaction depending on its params\n    for (uint256 i; i < len;) {\n      Hash.Order memory order = o[i];\n      if (!order.exit) {\n        if (!order.vault) {\n          initiateVaultFillingZcTokenInitiate(o[i], a[i], c[i]);\n        } else {\n          initiateZcTokenFillingVaultInitiate(o[i], a[i], c[i]);\n        }\n      } else {\n        if (!order.vault) {\n          initiateZcTokenFillingZcTokenExit(o[i], a[i], c[i]);\n        } else {\n          initiateVaultFillingVaultExit(o[i], a[i], c[i]);\n        }\n      }\n      unchecked {i++;}\n    }\n\n    return true;\n  }\n\n  /// @notice Allows a user to initiate a Vault by filling an offline zcToken initiate order\n  /// @dev This method should pass (underlying, maturity, maker, sender, principalFilled) to MarketPlace.custodialInitiate\n  /// @param o Order being filled\n  /// @param a Amount of volume (premium) being filled by the taker's initiate\n  /// @param c Components of a valid ECDSA signature\n  function initiateVaultFillingZcTokenInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    // checks order signature, order cancellation and order expiry\n    bytes32 hash = validOrderHash(o, c);\n\n    // checks the side, and the amount compared to available\n    uint256 amount = a + filled[hash];\n\n    if (amount > o.premium) { revert Exception(5, amount, o.premium, address(0), address(0)); }\n    \n    // TODO cheaper to assign amount here or keep the ADD?\n    filled[hash] += a;\n\n    // transfer underlying tokens\n    IErc20 uToken = IErc20(o.underlying);\n    Safe.transferFrom(uToken, msg.sender, o.maker, a);\n\n    uint256 principalFilled = (a * o.principal) / o.premium;\n    Safe.transferFrom(uToken, o.maker, address(this), principalFilled);\n\n    IMarketPlace mPlace = IMarketPlace(marketPlace);\n    address cTokenAddr = mPlace.cTokenAddress(o.protocol, o.underlying, o.maturity);\n\n    // perform the actual deposit type transaction, specific to a protocol\n    if (!deposit(o.protocol, o.underlying, cTokenAddr, principalFilled)) { revert Exception(6, 0, 0, address(0), address(0)); }\n\n    // alert marketplace\n    if (!mPlace.custodialInitiate(o.protocol, o.underlying, o.maturity, o.maker, msg.sender, principalFilled)) { revert Exception(8, 0, 0, address(0), address(0)); }\n\n    // transfer fee in vault notional to swivel (from msg.sender)\n    uint256 fee = principalFilled / feenominators[2];\n    if (!mPlace.transferVaultNotionalFee(o.protocol, o.underlying, o.maturity, msg.sender, fee)) { revert Exception(10, 0, 0, address(0), address(0)); }\n\n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);\n  }\n\n  /// @notice Allows a user to initiate a zcToken by filling an offline vault initiate order\n  /// @dev This method should pass (underlying, maturity, sender, maker, a) to MarketPlace.custodialInitiate\n  /// @param o Order being filled\n  /// @param a Amount of volume (principal) being filled by the taker's initiate\n  /// @param c Components of a valid ECDSA signature\n  function initiateZcTokenFillingVaultInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n    uint256 amount = a + filled[hash];\n\n    if (amount > o.principal) { revert Exception(5, amount, o.principal, address(0), address(0)); }\n\n    // TODO assign amount or keep the ADD?\n    filled[hash] += a;\n\n    IErc20 uToken = IErc20(o.underlying);\n\n    uint256 premiumFilled = (a * o.premium) / o.principal;\n    Safe.transferFrom(uToken, o.maker, msg.sender, premiumFilled);\n\n    // transfer principal + fee in underlying to swivel (from sender)\n    uint256 fee = premiumFilled / feenominators[0];\n    Safe.transferFrom(uToken, msg.sender, address(this), (a + fee));\n\n    IMarketPlace mPlace = IMarketPlace(marketPlace);\n    address cTokenAddr = mPlace.cTokenAddress(o.protocol, o.underlying, o.maturity);\n\n    // perform the actual deposit type transaction, specific to a protocol\n    if(!deposit(o.protocol, o.underlying, cTokenAddr, a)) { revert Exception(6, 0, 0, address(0), address(0)); }\n\n    // alert marketplace \n    if (!mPlace.custodialInitiate(o.protocol, o.underlying, o.maturity, msg.sender, o.maker, a)) { revert Exception(8, 0, 0, address(0), address(0)); }\n\n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\n  }\n\n  /// @notice Allows a user to initiate zcToken? by filling an offline zcToken exit order\n  /// @dev This method should pass (underlying, maturity, maker, sender, a) to MarketPlace.p2pZcTokenExchange\n  /// @param o Order being filled\n  /// @param a Amount of volume (principal) being filled by the taker's initiate \n  /// @param c Components of a valid ECDSA signature\n  function initiateZcTokenFillingZcTokenExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n    uint256 amount = a + filled[hash];\n\n    if (amount > o.principal) { revert Exception(5, amount, o.principal, address(0), address(0)); }\n\n    // TODO assign amount or keep the ADD?\n    filled[hash] += a;\n\n    uint256 premiumFilled = (a * o.premium) / o.principal;\n\n    IErc20 uToken = IErc20(o.underlying);\n    // transfer underlying tokens, then take fee\n    Safe.transferFrom(uToken, msg.sender, o.maker, a - premiumFilled);\n\n    uint256 fee = premiumFilled / feenominators[0];\n    Safe.transferFrom(uToken, msg.sender, address(this), fee);\n\n    // alert marketplace\n    if (!IMarketPlace(marketPlace).p2pZcTokenExchange(o.protocol, o.underlying, o.maturity, o.maker, msg.sender, a)) { revert Exception(11, 0, 0, address(0), address(0)); }\n            \n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\n  }\n\n  /// @notice Allows a user to initiate a Vault by filling an offline vault exit order\n  /// @dev This method should pass (underlying, maturity, maker, sender, principalFilled) to MarketPlace.p2pVaultExchange\n  /// @param o Order being filled\n  /// @param a Amount of volume (interest) being filled by the taker's exit\n  /// @param c Components of a valid ECDSA signature\n  function initiateVaultFillingVaultExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n    uint256 amount = a + filled[hash];\n\n    if (amount > o.premium) { revert Exception(5, amount, o.premium, address(0), address(0)); }\n\n    // TODO assign amount or keep ADD?\n    filled[hash] += a;\n\n    Safe.transferFrom(IErc20(o.underlying), msg.sender, o.maker, a);\n\n    IMarketPlace mPlace = IMarketPlace(marketPlace);\n    uint256 principalFilled = (a * o.principal) / o.premium;\n    // alert marketplace\n    if (!mPlace.p2pVaultExchange(o.protocol, o.underlying, o.maturity, o.maker, msg.sender, principalFilled)) { revert Exception(12, 0, 0, address(0), address(0)); }\n\n    // transfer fee (in vault notional) to swivel\n    uint256 fee = principalFilled / feenominators[2];\n    if (!mPlace.transferVaultNotionalFee(o.protocol, o.underlying, o.maturity, msg.sender, fee)) { revert Exception(10, 0, 0, address(0), address(0)); }\n\n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);\n  }\n\n  // ********* EXITING ***************\n\n  /// @notice Allows a user to exit (sell) a currently held position to the marketplace.\n  /// @param o Array of offline Swivel.Orders\n  /// @param a Array of order volume (principal) amounts relative to passed orders\n  /// @param c Components of a valid ECDSA signature\n  function exit(Hash.Order[] calldata o, uint256[] calldata a, Sig.Components[] calldata c) external returns (bool) {\n    uint256 len = o.length;\n    // for each order filled, routes the order to the right interaction depending on its params\n    for (uint256 i; i < len;) {\n      Hash.Order memory order = o[i];\n      // if the order being filled is not an exit\n      if (!order.exit) {\n        // if the order being filled is a vault initiate or a zcToken initiate\n          if (!order.vault) {\n            // if filling a zcToken initiate with an exit, one is exiting zcTokens\n            exitZcTokenFillingZcTokenInitiate(o[i], a[i], c[i]);\n          } else {\n            // if filling a vault initiate with an exit, one is exiting vault notional\n            exitVaultFillingVaultInitiate(o[i], a[i], c[i]);\n          }\n      } else {\n        // if the order being filled is a vault exit or a zcToken exit\n        if (!order.vault) {\n          // if filling a zcToken exit with an exit, one is exiting vault\n          exitVaultFillingZcTokenExit(o[i], a[i], c[i]);\n        } else {\n          // if filling a vault exit with an exit, one is exiting zcTokens\n          exitZcTokenFillingVaultExit(o[i], a[i], c[i]);\n        }   \n      }\n      unchecked {i++;}\n    }\n\n    return true;\n  }\n\n  /// @notice Allows a user to exit their zcTokens by filling an offline zcTo"
    }
  ]
}