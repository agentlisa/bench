{
  "Title": "[G-15] Use constants instead of `type(uintx).max`",
  "Content": "\nIt's generally more gas-efficient to use constants instead of `type(uintX).max` when you need to set the maximum value of an unsigned integer type.\n\nThe reason for this, is that the `type(uintX).max` expression involves a computation at runtime, whereas a constant is evaluated at compile-time. This means, that using `type(uintX).max` can result in additional gas costs for each transaction that involves the expression.\n\nBy using a constant instead of `type(uintX).max`, you can avoid these additional gas costs and make your code more efficient.\n\nHere's an example of how you can use a constant instead of `type(uintX).max`:\n\n```\ncontract MyContract {\n    uint120 constant MAX_VALUE = 2**120 - 1;\n    \n    function doSomething(uint120 value) public {\n        require(value <= MAX_VALUE, \"Value exceeds maximum\");\n        \n        // Do something\n    }\n}\n```\nIn the above example, we have a contract with a constant `MAX_VALUE` that represents the maximum value of a uint120. When the `doSomething` function is called with a value parameter, it checks whether the value is less than or equal to `MAX_VALUE` using the `<=` operator.\n\nBy using a constant instead of `type(uint120).max`, we can make our code more efficient and reduce the gas cost of our contract.\n\nIt's important to note that using constants can make your code more readable and maintainable, since the value is defined in one place and can be easily updated, if necessary. However, constants should be used with caution and only when their value is known at compile-time.\n\nHere's an example to illustrate this:\n\n```solidity\ncontract ExampleContract {\n    uint256 constant MAX_UINT256 = 2**256 - 1;\n\n    function doSomething() external {\n        uint256 maxValue = type(uint256).max;\n\n        // Perform some operations\n\n        if (value > maxValue) {\n            // Do something\n        }\n    }\n}\n```\n\nIn this example, we have defined a constant `MAX_UINT256` with the maximum value of a uint256 variable, which is equivalent to `2^256 - 1`. Instead of using `type(uint256).max` directly, we use the constant `MAX_UINT256` throughout the contract.\n\n<details>\n\n```solidity\nFile:   src/erc-4626/ERC4626.sol\n67      if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n\n84      if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n\n149     return type(uint256).max;\n\n154     return type(uint256).max;\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/erc-4626/ERC4626.sol#L67\n\n```solidity\nFile:  src/erc-4626/ERC4626DepositOnly.sol\n99   return type(uint256).max;\n\n104  return type(uint256).max;\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/erc-4626/ERC4626DepositOnly.sol#L99\n\n```solidity\nFile:    src/erc-4626/ERC4626MultiToken.sol\n143      if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n\n165      if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n\n200      shares = type(uint256).max;\n\n270      return type(uint256).max;\n\n275      return type(uint256).max;\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/erc-4626/ERC4626MultiToken.sol#L143\n\n```solidity\nFile:    src/erc-4626/UlyssesERC4626.sol\n68       if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n\n113      return type(uint256).max;\n\n117      return type(uint256).max;\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/erc-4626/UlyssesERC4626.sol#L68\n\n```solidity\nFile:   src/gauges/UniswapV3Gauge.sol\n45      rewardToken.safeApprove(_uniswapV3Staker, type(uint256).max);\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/UniswapV3Gauge.sol#L45 \n\n```solidity\nFile:   src/maia/tokens/ERC4626PartnerManager.sol\n200     address(gaugeWeight).safeApprove(newPartnerVault, type(uint256).max);\n\n201        address(gaugeBoost).safeApprove(newPartnerVault, type(uint256).max);\n\n202       address(governance).safeApprove(newPartnerVault, type(uint256).max);\n\n203     address(partnerGovernance).safeApprove(newPartnerVault, type(uint256).max);\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/maia/tokens/ERC4626PartnerManager.sol#L200\n\n```solidity\nFile:  src/rewards/base/BaseFlywheelRewards.sol\n36     _rewardToken.safeApprove(address(_flywheel), type(uint256).max);\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/base/BaseFlywheelRewards.sol#L36\n\n```solidity\nFile:   src/rewards/rewards/FlywheelGaugeRewards.sol\n133     require(newRewards <= type(uint112).max); \n\n187     require(nextRewards <= type(uint112).max); \n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/rewards/FlywheelGaugeRewards.sol#L133\n\n```solidity\nFile:      src/talos/base/TalosBaseStrategy.sol\n130        address(_token0).safeApprove(address(_nonfungiblePositionManager), type(uint256).max);\n\n131        address(_token1).safeApprove(address(_nonfungiblePositionManager), type(uint256).max);\n\n249        if (allowed != type(uint256).max) allowance[_owner][msg.sender] = allowed - shares\n\n285        amount0Max: type(uint128).max,\n\n286        amount1Max: type(uint128).max\n\n367        amount0Max: type(uint128).max,\n\n368        amount1Max: type(uint128).max\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/talos/base/TalosBaseStrategy.sol#L130\n\n```solidity\nFile:    src/talos/TalosStrategyStaked.sol\n151      amount0Max: type(uint128).max,\n\n152      amount1Max: type(uint128).max\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/talos/TalosStrategyStaked.sol#L151\n\n```solidity\nFile:  src/talos/TalosStrategyVanilla.sol\n111          amount0Max: type(uint128).max,\n\n112          amount1Max: type(uint128).max\n```\n\nhttps://github.com/code-423n4/2023-05-maia/tree/main/src/talos/TalosStrategyVanilla.sol#L111\n\n```solidity\nFile:   src/ulysses-amm/UlyssesRouter.sol\n40      address(ulysses.asset()).safeApprove(address(ulysses), type(uint256).max);\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-amm/UlyssesRouter.sol#L40 \n\n```solidity\nFile:  src/uni-v3-staker/UniswapV3Staker.sol\n70     if (liquidity == type(uint96).max)\n\n385    amount0Max: type(uint128).max,\n\n386    amount1Max: type(uint128).max\n\n456    if (liquidity >= type(uint96).max) stake.liquidityIfOverflow = 0;\n\n506    if (liquidity >= type(uint96).max)\n\n509    liquidityNoOverflow: type(uint96).max,\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/uni-v3-staker/UniswapV3Staker.sol#L70\n\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/erc-4626/ERC4626.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IERC4626} from \"./interfaces/IERC4626.sol\";\n\n/// @title Minimal ERC4626 tokenized Vault implementation\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\nabstract contract ERC4626 is ERC20, IERC4626 {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public immutable asset;\n\n    constructor(ERC20 _asset, string memory _name, string memory _symbol) ERC20(_name, _symbol, _asset.decimals()) {\n        asset = _asset;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        address(asset).safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    /// @inheritdoc IERC4626\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        address(asset).safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    /// @inheritdoc IERC4626\n    function withdraw(uint256 assets, address receiver, address owner) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        address(asset).safeTransfer(receiver, assets);\n    }\n\n    /// @inheritdoc IERC4626\n    function redeem(uint256 shares, address receiver, address owner) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        address(asset).safeTransfer(receiver, assets);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    /// @inheritdoc IERC4626\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDiv(supply, totalAssets());\n    }\n\n    /// @inheritdoc IERC4626\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDiv(totalAssets(), supply);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    /// @inheritdoc IERC4626\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    /// @inheritdoc IERC4626\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n}"
    },
    {
      "filename": "src/erc-4626/ERC4626DepositOnly.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IERC4626DepositOnly} from \"./interfaces/IERC4626DepositOnly.sol\";\n\n/// @title Minimal Deposit Only ERC4626 tokenized Vault implementation\n/// @author Maia DAO (https://github.com/Maia-DAO)\nabstract contract ERC4626DepositOnly is ERC20, IERC4626DepositOnly {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public immutable asset;\n\n    constructor(ERC20 _asset, string memory _name, string memory _symbol) ERC20(_name, _symbol, _asset.decimals()) {\n        asset = _asset;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626DepositOnly\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        address(asset).safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    /// @inheritdoc IERC4626DepositOnly\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        address(asset).safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626DepositOnly\n    function totalAssets() public view virtual returns (uint256);\n\n    /// @inheritdoc IERC4626DepositOnly\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDiv(supply, totalAssets());\n    }\n\n    /// TODO: @inheritdoc IERC4626DepositOnly\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDiv(totalAssets(), supply);\n    }\n\n    /// @inheritdoc IERC4626DepositOnly\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    /// @inheritdoc IERC4626DepositOnly\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626DepositOnly\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626DepositOnly\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n}"
    },
    {
      "filename": "src/erc-4626/ERC4626MultiToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\nimport {IERC4626MultiToken} from \"./interfaces/IERC4626MultiToken.sol\";\n\n/// @title Minimal ERC4626 tokenized Vault multi asset implementation\n/// @author Maia DAO (https://github.com/Maia-DAO)\nabstract contract ERC4626MultiToken is ERC20, ReentrancyGuard, IERC4626MultiToken {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626MultiToken\n    address[] public assets;\n\n    /// @inheritdoc IERC4626MultiToken\n    uint256[] public weights;\n\n    /// @inheritdoc IERC4626MultiToken\n    mapping(address => uint256) public assetId;\n\n    /// @inheritdoc IERC4626MultiToken\n    uint256 public totalWeights;\n\n    /// @inheritdoc IERC4626MultiToken\n    function getAssets() external view returns (address[] memory) {\n        return assets;\n    }\n\n    constructor(address[] memory _assets, uint256[] memory _weights, string memory _name, string memory _symbol)\n        ERC20(_name, _symbol, 18)\n    {\n        assets = _assets;\n        weights = _weights;\n\n        uint256 length = _weights.length;\n        uint256 _totalWeights;\n\n        if (length != _assets.length || length == 0) revert InvalidLength();\n\n        for (uint256 i = 0; i < length;) {\n            require(ERC20(_assets[i]).decimals() == 18);\n            require(_weights[i] > 0);\n\n            _totalWeights += _weights[i];\n            assetId[_assets[i]] = i + 1;\n\n            emit AssetAdded(_assets[i], _weights[i]);\n\n            unchecked {\n                i++;\n            }\n        }\n        totalWeights = _totalWeights;\n    }\n\n    function receiveAssets(uint256[] memory assetsAmounts) private {\n        uint256 length = assetsAmounts.length;\n        for (uint256 i = 0; i < length;) {\n            assets[i].safeTransferFrom(msg.sender, address(this), assetsAmounts[i]);\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    function sendAssets(uint256[] memory assetsAmounts, address receiver) private {\n        uint256 length = assetsAmounts.length;\n        for (uint256 i = 0; i < length;) {\n            assets[i].safeTransfer(receiver, assetsAmounts[i]);\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626MultiToken\n    function deposit(uint256[] calldata assetsAmounts, address receiver)\n        public\n        virtual\n        nonReentrant\n        returns (uint256 shares)\n    {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assetsAmounts)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        receiveAssets(assetsAmounts);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assetsAmounts, shares);\n\n        afterDeposit(assetsAmounts, shares);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function mint(uint256 shares, address receiver)\n        public\n        virtual\n        nonReentrant\n        returns (uint256[] memory assetsAmounts)\n    {\n        assetsAmounts = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        receiveAssets(assetsAmounts);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assetsAmounts, shares);\n\n        afterDeposit(assetsAmounts, shares);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function withdraw(uint256[] calldata assetsAmounts, address receiver, address owner)\n        public\n        virtual\n        nonReentrant\n        returns (uint256 shares)\n    {\n        shares = previewWithdraw(assetsAmounts); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(assetsAmounts, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assetsAmounts, shares);\n\n        sendAssets(assetsAmounts, receiver);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function redeem(uint256 shares, address receiver, address owner)\n        public\n        virtual\n        nonReentrant\n        returns (uint256[] memory assetsAmounts)\n    {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        assetsAmounts = previewRedeem(shares);\n        uint256 length = assetsAmounts.length;\n        for (uint256 i = 0; i < length;) {\n            // Check for rounding error since we round down in previewRedeem.\n            if (assetsAmounts[i] == 0) revert ZeroAssets();\n            unchecked {\n                i++;\n            }\n        }\n\n        beforeWithdraw(assetsAmounts, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assetsAmounts, shares);\n\n        sendAssets(assetsAmounts, receiver);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    /// @inheritdoc IERC4626MultiToken\n    function convertToShares(uint256[] calldata assetsAmounts) public view virtual returns (uint256 shares) {\n        uint256 _totalWeights = totalWeights;\n        uint256 length = assetsAmounts.length;\n\n        if (length != assets.length) revert InvalidLength();\n\n        shares = type(uint256).max;\n        for (uint256 i = 0; i < length;) {\n            uint256 share = assetsAmounts[i].mulDiv(_totalWeights, weights[i]);\n            if (share < shares) shares = share;\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function convertToAssets(uint256 shares) public view virtual returns (uint256[] memory assetsAmounts) {\n        uint256 _totalWeights = totalWeights;\n        uint256 length = assets.length;\n\n        assetsAmounts = new uint256[](length);\n        for (uint256 i = 0; i < length;) {\n            assetsAmounts[i] = shares.mulDiv(weights[i], _totalWeights);\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function previewDeposit(uint256[] calldata assetsAmounts) public view virtual returns (uint256) {\n        return convertToShares(assetsAmounts);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function previewMint(uint256 shares) public view virtual returns (uint256[] memory assetsAmounts) {\n        uint256 _totalWeights = totalWeights;\n        uint256 length = assets.length;\n\n        assetsAmounts = new uint256[](length);\n        for (uint256 i = 0; i < length;) {\n            assetsAmounts[i] = shares.mulDivUp(weights[i], _totalWeights);\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function previewWithdraw(uint256[] calldata assetsAmounts) public view virtual returns (uint256 shares) {\n        uint256 _totalWeights = totalWeights;\n        uint256 length = assetsAmounts.length;\n\n        if (length != assets.length) revert InvalidLength();\n\n        for (uint256 i = 0; i < length;) {\n            uint256 share = assetsAmounts[i].mulDivUp(_totalWeights, weights[i]);\n            if (share > shares) shares = share;\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function previewRedeem(uint256 shares) public view virtual returns (uint256[] memory) {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626MultiToken\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function maxWithdraw(address owner) public view virtual returns (uint256[] memory) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(uint256[] memory assetsAmounts, uint256 shares) internal virtual {}\n\n    function afterDeposit(uint256[] memory assetsAmounts, uint256 shares) internal virtual {}\n}"
    },
    {
      "filename": "src/erc-4626/UlyssesERC4626.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\nimport {IUlyssesERC4626} from \"./interfaces/IUlyssesERC4626.sol\";\n\n/// @title Minimal ERC4626 tokenized 1:1 Vault implementation\n/// @author Maia DAO (https://github.com/Maia-DAO)\nabstract contract UlyssesERC4626 is ERC20, ReentrancyGuard, IUlyssesERC4626 {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    address public immutable asset;\n\n    constructor(address _asset, string memory _name, string memory _symbol) ERC20(_name, _symbol, 18) {\n        asset = _asset;\n\n        if (ERC20(_asset).decimals() != 18) revert InvalidAssetDecimals();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 assets, address receiver) public virtual nonReentrant returns (uint256 shares) {\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        shares = beforeDeposit(assets);\n\n        require(shares != 0, \"ZERO_SHARES\");\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver) public virtual nonReentrant returns (uint256 assets) {\n        assets = beforeMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        require(assets != 0, \"ZERO_ASSETS\");\n\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    function redeem(uint256 shares, address receiver, address owner)\n        public\n        virtual\n        nonReentrant\n        returns (uint256 assets)\n    {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        _burn(owner, shares);\n\n        assets = afterRedeem(shares);\n\n        require(assets != 0, \"ZERO_ASSETS\");\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        return assets;\n    }\n\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        return shares;\n    }\n\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return assets;\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        return shares;\n    }\n\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return shares;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Should not do any external calls to prevent reentrancy.\n    function beforeDeposit(uint256 assets) internal virtual returns (uint256 shares);\n\n    /// @dev Should not do any external calls to prevent reentrancy.\n    function beforeMint(uint256 shares) internal virtual returns (uint256 assets);\n\n    /// @dev Should not do any external calls to prevent reentrancy.\n    function afterRedeem(uint256 shares) internal virtual returns (uint256 assets);\n}"
    },
    {
      "filename": "src/gauges/UniswapV3Gauge.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {IUniswapV3Staker} from \"@v3-staker/interfaces/IUniswapV3Staker.sol\";\n\nimport {BaseV2Gauge, FlywheelGaugeRewards} from \"./BaseV2Gauge.sol\";\nimport {IUniswapV3Gauge} from \"./interfaces/IUniswapV3Gauge.sol\";\n\n/// @title Uniswap V3 Gauge - Handles liquidity provider incentives for Uniswap V3 in the Base V2 Gauge implementation.\ncontract UniswapV3Gauge is BaseV2Gauge, IUniswapV3Gauge {\n    using SafeTransferLib for address;\n\n    /*//////////////////////////////////////////////////////////////\n                         GAUGE STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IUniswapV3Gauge\n    address public immutable override uniswapV3Staker;\n\n    /// @inheritdoc IUniswapV3Gauge\n    uint24 public override minimumWidth;\n\n    /**\n     * @notice Constructs the UniswapV3Gauge contract.\n     * @param _flywheelGaugeRewards The FlywheelGaugeRewards contract.\n     * @param _uniswapV3Staker The UniswapV3Staker contract.\n     * @param _uniswapV3Pool The UniswapV3Pool contract.\n     * @param _minimumWidth The minimum width.\n     * @param _owner The owner of the contract.\n     */\n    constructor(\n        FlywheelGaugeRewards _flywheelGaugeRewards,\n        address _uniswapV3Staker,\n        address _uniswapV3Pool,\n        uint24 _minimumWidth,\n        address _owner\n    ) BaseV2Gauge(_flywheelGaugeRewards, _uniswapV3Pool, _owner) {\n        uniswapV3Staker = _uniswapV3Staker;\n        minimumWidth = _minimumWidth;\n\n        emit NewMinimumWidth(_minimumWidth);\n\n        rewardToken.safeApprove(_uniswapV3Staker, type(uint256).max);\n    }\n\n    /**\n     *  @notice Distributes weekly emissions to the Uniswap V3 Staker for the current epoch.\n     *  @dev must be called during the 12-hour offset after an epoch ends\n     *       or rewards will be queued for the next epoch.\n     */\n    function distribute(uint256 amount) internal override {\n        IUniswapV3Staker(uniswapV3Staker).createIncentiveFromGauge(amount);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ADMIN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IUniswapV3Gauge\n    function setMinimumWidth(uint24 _minimumWidth) external onlyOwner {\n        minimumWidth = _minimumWidth;\n\n        emit NewMinimumWidth(_minimumWidth);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Only the UniswapV3Staker contract can attach and detach users.\n    modifier onlyStrategy() override {\n        if (msg.sender != uniswapV3Staker) revert StrategyError();\n        _;\n    }\n}"
    },
    {
      "filename": "src/maia/tokens/ERC4626PartnerManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {ERC4626} from \"@ERC4626/ERC4626.sol\";\n\nimport {bHermes} from \"@hermes/bHermes.sol\";\nimport {bHermesVotes as ERC20MultiVotes} from \"@hermes/tokens/bHermesVotes.sol\";\n\nimport {PartnerManagerFactory} from \"../factories/PartnerManagerFactory.sol\";\nimport {IBaseVault} from \"../interfaces/IBaseVault.sol\";\nimport {PartnerUtilityManager} from \"../PartnerUtilityManager.sol\";\n\nimport {IERC4626PartnerManager} from \"../interfaces/IERC4626PartnerManager.sol\";\n\n/// @title Yield bearing, boosting, voting, and gauge enabled Partner Token\nabstract contract ERC4626PartnerManager is PartnerUtilityManager, Ownable, ERC4626, IERC4626PartnerManager {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                         PARTNER MANAGER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626PartnerManager\n    PartnerManagerFactory public immutable override factory;\n\n    /// @inheritdoc IERC4626PartnerManager\n    bHermes public immutable override bHermesToken;\n\n    /// @inheritdoc IERC4626PartnerManager\n    uint256 public override bHermesRate;\n\n    /**\n     * @notice Initializes the ERC4626PartnerManager token.\n     * @param _factory The partner manager factory.\n     * @param _bHermesRate The rate at which bHermes underlying's can be claimed.\n     * @param _partnerAsset The asset that will be used to deposit to get partner tokens.\n     * @param _name The name of the token.\n     * @param _symbol The symbol of the token.\n     * @param _bhermes The address of the bHermes token.\n     * @param _partnerVault The address of the partner vault.\n     * @param _owner The owner of this contract.\n     */\n    constructor(\n        PartnerManagerFactory _factory,\n        uint256 _bHermesRate,\n        ERC20 _partnerAsset,\n        string memory _name,\n        string memory _symbol,\n        address _bhermes,\n        address _partnerVault,\n        address _owner\n    )\n        PartnerUtilityManager(\n            address(bHermes(_bhermes).gaugeWeight()),\n            address(bHermes(_bhermes).gaugeBoost()),\n            address(bHermes(_bhermes).governance()),\n            address(new ERC20MultiVotes(_owner)),\n            partnerVault\n        )\n        ERC4626(\n            _partnerAsset,\n            string.concat(_name, \" - Burned Hermes: Aggregated Gov + Yield + Boost\"),\n            string.concat(_symbol, \"-bHermes\")\n        )\n    {\n        _initializeOwner(_owner);\n        partnerVault = _partnerVault;\n        factory = _factory;\n        bHermesRate = _bHermesRate;\n        bHermesToken = bHermes(_bhermes);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            UTILITY MANAGER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626PartnerManager\n    function updateUnderlyingBalance() public virtual {\n        bHermesToken.claimOutstanding();\n    }\n\n    /// @inheritdoc IERC4626PartnerManager\n    function claimOutstanding() public virtual {\n        uint256 balance = balanceOf[msg.sender] * bHermesRate;\n        /// @dev Never overflows since balandeOf >= userClaimed.\n        claimWeight(balance - userClaimedWeight[msg.sender]);\n        claimBoost(balance - userClaimedBoost[msg.sender]);\n        claimGovernance(balance - userClaimedGovernance[msg.sender]);\n        claimPartnerGovernance(balance - userClaimedPartnerGovernance[msg.sender]);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        ERC4626 ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Compute the amount of tokens available in contract.\n    /// @dev 1:1 with underlying asset.\n    function totalAssets() public view override returns (uint256) {\n        return totalSupply;\n    }\n\n    /**\n     * @notice Computes and returns the amount of shares from a given amount of"
    }
  ]
}