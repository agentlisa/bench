{
  "Title": "H-1: Rogue plugin can become unremovable and halt all staking and claiming",
  "Content": "# Issue H-1: Rogue plugin can become unremovable and halt all staking and claiming \n\nSource: https://github.com/sherlock-audit/2023-02-telcoin-judging/issues/67 \n\n## Found by \nhyh\n\n## Summary\n\nStakingModule's plugin that turned rogue can deny any attempts of its removal and can effectively stop the contract, disturbing the whole range of StakingModule operations.\n\nI.e. if any plugin turns malicious due to bug or upgrade altering its functionality vs one that was in place as of the time of its addition to StakingModule, such malicious plugin can halt StakingModule and freeze all the funds staked.\n\n## Vulnerability Detail\n\nThe reason is removePlugins() having `require(IPlugin(plugin).deactivated())` condition, which success is required.\n\nSuppose that a plugin turned malicious (as a result of a bug or by owner's intent via upgrade), begin to permanently return `false` for the `deactivated()` call.\n\nAnd, for instance, it can simultaneously return `2**256-1` in claim() to overflow the sum and revert the `IPlugin(plugin).requiresNotification()` calls.\n\n## Impact\n\nAs all StakingModule operations will be frozen and funds withdrawal be unavailable in this scenario it will be permanent freeze of funds for all the stakers.\n\n## Code Snippet\n\nIf a plugin turns rogue:\n\nIt can return `2**256-1` in claim() to overflow the sum:\n\nhttps://github.com/sherlock-audit/2023-02-telcoin/blob/main/telcoin-audit/contracts/staking/StakingModule.sol#L353-L366\n\n```solidity\n    function _claim(address account, address to, bytes calldata auxData) private returns (uint256) {\n        // balance of `to` before claiming\n        uint256 balBefore = IERC20Upgradeable(tel).balanceOf(to);\n\n        // call claim on all plugins and count the total amount claimed\n        uint256 total;\n        bytes[] memory parsedAuxData = parseAuxData(auxData);\n        for (uint256 i = 0; i < nPlugins; i++) {\n>>          try IPlugin(plugins[i]).claim(account, to, parsedAuxData[i]) returns (uint256 xClaimed) {\n                total += xClaimed;\n            } catch  {\n                emit PluginClaimFailed(plugins[i]);\n            }\n        }\n```\n\nThis will block slash(), claim(), fullClaimAndExit(), partialClaimAndExit() functions.\n\nAlso, it can revert the `IPlugin(plugin).requiresNotification()` call:\n\nhttps://github.com/sherlock-audit/2023-02-telcoin/blob/main/telcoin-audit/contracts/staking/StakingModule.sol#L485-L498\n\n```solidity\n    /// @dev Calls `notifyStakeChange` on all plugins that require it. This is done in case any given plugin needs to do some stuff when a user exits.\n    /// @param account Account that is exiting\n    function _notifyStakeChangeAllPlugins(address account, uint256 amountBefore, uint256 amountAfter) private {\n        // loop over all plugins\n        for (uint256 i = 0; i < nPlugins; i++) {\n            // only notify if the plugin requires\n>>          if (IPlugin(plugins[i]).requiresNotification()) {\n                try IPlugin(plugins[i]).notifyStakeChange(account, amountBefore, amountAfter) {}\n                catch {\n                    emit StakeChangeNotificationFailed(plugins[i]);\n                }\n            }\n        }\n    }\n```\n\nIt will also block stake(), partialExit(), exit(), and migration claimAndExitFor(), stakeFor() functions.\n\nAs all involve _notifyStakeChangeAllPlugins(), for example:\n\nhttps://github.com/sherlock-audit/2023-02-telcoin/blob/main/telcoin-audit/contracts/staking/StakingModule.sol#L573-L575\n\n```solidity\n    function claimAndExitFor(address account, address to, bytes calldata auxData) external onlyRole(MIGRATOR_ROLE) nonReentrant returns (uint256, uint256) {\n>>      return (_claim(account, to, auxData), _exit(account, to));\n    }\n```\n\nhttps://github.com/sherlock-audit/2023-02-telcoin/blob/main/telcoin-audit/contracts/staking/StakingModule.sol#L388-L406\n\n```solidity\n    function _exit(address account, address to) private returns (uint256) {\n        uint256 stakedAmt = _stakes[account].latest();\n\n>>      _partialExit(account, to, stakedAmt);\n\n        return stakedAmt;\n    }\n\n    function _partialExit(address account, address to, uint256 exitAmount) private checkpointProtection(account) {\n        if (exitAmount == 0) {\n            return;\n        }\n\n        uint256 stakedAmt = _stakes[account].latest();\n\n        require(stakedAmt >= exitAmount, \"StakingMoudle: Cannot exit more than is staked\");\n\n        // notify plugins\n>>      _notifyStakeChangeAllPlugins(account, stakedAmt, stakedAmt - exitAmount);\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding `force` option to removePlugin(), for example:\n\nhttps://github.com/sherlock-audit/2023-02-telcoin/blob/main/telcoin-audit/contracts/staking/StakingModule.sol#L542-L555\n\n```diff\n    /// @notice Removes a plugin\n-   function removePlugin(uint256 index) external onlyRole(PLUGIN_EDITOR_ROLE) {\n+   function removePlugin(uint256 index, bool force) external onlyRole(PLUGIN_EDITOR_ROLE) {\n        address plugin = plugins[index];\n\n-       require(IPlugin(plugin).deactivated(), \"StakingModule::removePlugin: Plugin is not deactivated\");\n+       require(force || IPlugin(plugin).deactivated(), \"StakingModule::removePlugin: Plugin is not deactivated\");\n\n        pluginsMapping[plugin] = false;\n        plugins[index] = plugins[nPlugins - 1];\n        pluginIndicies[plugins[index]] = index;\n        plugins.pop();\n        nPlugins--;\n\n        emit PluginRemoved(plugin, nPlugins);\n    }\n```\n\n## Discussion\n\n**dmitriia**\n\nLooks ok\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/49",
  "Code": [
    {
      "filename": "telcoin-audit/contracts/staking/StakingModule.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/CheckpointsUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nimport \"../interfaces/IPlugin.sol\";\n\n// TODO: improve require messages\n\n/// @title Staking Module\n/// @notice Users interact directly with this contract to participate in staking. \n/// @dev This contract holds user funds. It does not accrue any staking yield on its own, it must have one or more `IPlugin` contracts \"connected\" to it.\ncontract StakingModule is ReentrancyGuardUpgradeable, AccessControlEnumerableUpgradeable {\n    using CheckpointsUpgradeable for CheckpointsUpgradeable.History;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using BytesLib for bytes;\n\n    /// @notice This role grants the ability to slash users' stakes at its own discretion\n    bytes32 public constant SLASHER_ROLE = keccak256(\"SLASHER_ROLE\");\n    /// @notice This role grants the ability to add and remove IPlugin contracts\n    bytes32 public constant PLUGIN_EDITOR_ROLE = keccak256(\"PLUGIN_EDITOR_ROLE\");\n    /// @notice This role grants the ability to rescue ERC20 tokens that do not rightfully belong to this contract\n    bytes32 public constant RECOVERY_ROLE = keccak256(\"RECOVERY_ROLE\");\n    /// @notice This role grants the ability to migrate user funds\n    bytes32 public constant MIGRATOR_ROLE = keccak256(\"MIGRATOR_ROLE\");\n\n    /// @notice The amount of time a user has to withdraw once the withdrawal delay has elapsed after requesting withdrawal\n    uint256 public withdrawalWindow;\n    /// @notice The withdrawal delay for preventing slash frontrunning\n    uint256 public withdrawalDelay;\n    /// @notice Maximum allowable withdrawal delay\n    /// @dev If there was no maximum, the delay could be very large which would prevent users from withdrawing\n    uint256 public maxWithdrawalDelay;\n    /// @notice Minimum allowable difference between withdrawal window and withdrawal delay\n    /// @dev If there was no minimum, the window could be set to 0 which would prevent users from withdrawing\n    uint256 public minWithdrawalWindow;\n\n    /// @notice TEL ERC20 address\n    address public tel;\n\n    /// @notice Array of all connected IPlugin contracts\n    address[] public plugins;\n\n    /// @notice Number of currently connected Plugins\n    uint256 public nPlugins;\n\n    /// @notice Maps a Plugin to whether or not it is included in `plugins`\n    /// @dev This allows duplicate plugins to be prevented\n    mapping(address => bool) public pluginsMapping;\n\n    /// @notice Maps a plugin to its index in the plugins array\n    /// @dev A plugin that is not in the plugins array does not necessarily map to 0\n    mapping(address => uint256) public pluginIndicies;\n\n    /// @notice Maps an account to a timestamp when they can call any withdrawal function. If zero, then a withdrawal hasn't been requested.\n    /// @dev If withdrawalDelay is zero, then the user does not need to request a withdrawal first\n    mapping(address => uint256) public withdrawalRequestTimestamps;\n\n    /// @notice Total TEL staked by users in this contract\n    uint256 private _totalStaked;\n    /// @notice Maps an account to its staked amount history\n    mapping(address => CheckpointsUpgradeable.History) private _stakes;\n\n    /// @dev The header of an auxData payload is an array of HeaderItem's\n    /// @dev The purpose of the HeaderItem(s) is to mark which parts of the data payload are for which plugins\n    struct AuxDataHeaderItem {\n        address addr;\n        uint256 start;\n        uint256 len;\n    }\n\n    /// @notice An event that's emitted when a account's stake changes (deposit/withdraw/slash)\n    event StakeChanged(address indexed account, uint256 oldStake, uint256 newStake);\n    /// @notice An event that's emitted when an account claims some yield\n    event Claimed(address indexed account, uint256 amount);\n    /// @notice An event that's emitted when an account's stake is slashed\n    event Slashed(address indexed account, uint256 amount);\n\n    /// @notice An event that's emitted when a plugin is added\n    event PluginAdded(address indexed plugin, uint256 nPlugins);\n    /// @notice An event that's emitted when a plugin is removed\n    event PluginRemoved(address indexed plugin, uint256 nPlugins);\n\n    /// @notice An event that's emitted when a call to a plugin's claim function reverts\n    event PluginClaimFailed(address indexed plugin);\n\n    /// @notice An event that's emitted when a call to a plugin's notifyStakeChange function reverts\n    event StakeChangeNotificationFailed(address indexed plugin);\n\n    function initialize(address _telAddress, uint256 _maxWithdrawalDelay, uint256 _minWithdrawalWindow) public initializer {\n        tel = _telAddress;\n        maxWithdrawalDelay = _maxWithdrawalDelay;\n        minWithdrawalWindow = _minWithdrawalWindow;\n\n        // initialize OZ stuff\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained();\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init_unchained();\n\n        // set deployer as ADMIN\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    modifier checkpointProtection(address account) {\n        uint256 numCheckpoints = _stakes[account]._checkpoints.length;\n        require(numCheckpoints == 0 || _stakes[account]._checkpoints[numCheckpoints - 1]._blockNumber != block.number, \"StakingModule: Cannot exit in the same block as another stake or exit\");\n        _;\n    }\n\n    modifier delayedWithdrawal() {\n        require(withdrawalDelay == 0 || (\n                withdrawalRequestTimestamps[msg.sender] + withdrawalDelay <= block.timestamp &&\n                block.timestamp <= withdrawalRequestTimestamps[msg.sender] + withdrawalDelay + withdrawalWindow\n            ), \n            \"StakingModule: Withdrawal not requested yet or it is too early/late to withdraw\"\n        );\n        withdrawalRequestTimestamps[msg.sender] = 0;\n        _;\n    }\n    \n    /************************************************\n    *   view functions\n    ************************************************/\n\n    /// @notice Parses auxiliary data into a bytes[] with length nPlugins\n    function parseAuxData(bytes calldata auxData) public view returns (bytes[] memory) {\n        bytes[] memory arr = new bytes[](nPlugins);\n\n        if (auxData.length == 0) {\n            return arr;\n        }\n        \n        (AuxDataHeaderItem[] memory header, bytes memory payload) = abi.decode(auxData, (AuxDataHeaderItem[], bytes));\n\n        for (uint256 i = 0; i < header.length; i++) {\n            require(pluginsMapping[header[i].addr], \"StakingModule: Invalid Plugin when parsing auxData\");\n            arr[pluginIndicies[header[i].addr]] = payload.slice(header[i].start, header[i].len);\n        }\n        \n        return arr;\n    }\n\n    /// @dev For some future Plugins not yet ideated, totalClaimable may be hard or impossible to implement. \n    /// @dev This would break `totalSupply`, but `totalSupply` is not strictly necessary anyway.\n    /// @return Total supply of staked TEL, including all yield\n    function totalSupply() external view returns (uint256) {\n        uint256 total;\n\n        // loop over all plugins and sum up totalClaimable\n        for (uint256 i = 0; i < nPlugins; i++) {\n            total += IPlugin(plugins[i]).totalClaimable();\n        }\n        \n        // totalSupply is the total claimable from all plugins plus the total amount staked\n        return total + _totalStaked;\n    }\n\n    /// @return Balance of an account. This includes stake and claimable yield.\n    /// @param account Account to query balance of\n    /// @param auxData Auxiliary data to pass to plugins\n    function balanceOf(address account, bytes calldata auxData) public view returns (uint256) {\n        return _stakes[account].latest() + claimable(account, auxData);\n    }\n\n    /// @return Balance of an account at a specific block. This includes stake and claimable yield.\n    /// @param account Account to query balance of\n    /// @param blockNumber Block at which to query balance\n    /// @param auxData Auxiliary data to pass to plugins\n    function balanceOfAt(address account, uint256 blockNumber, bytes calldata auxData) external view returns (uint256) {\n        return stakedByAt(account, blockNumber) + claimableAt(account, blockNumber, auxData);\n    }\n\n    /// @return Total amount staked by all accounts\n    function totalStaked() external view returns (uint256) {\n        return _totalStaked;\n    }\n\n    /// @dev Checks `claimable(account)` of all Plugins and returns the total.\n    /// @param account Account to query balance of\n    /// @param auxData Auxiliary data to pass to plugins\n    /// @return Total amount claimable by an account\n    function claimable(address account, bytes calldata auxData) public view returns (uint256) {\n        uint256 total;\n        // loop over all plugins, sum claimable of account\n        bytes[] memory parsedAuxData = parseAuxData(auxData);\n        for (uint256 i = 0; i < nPlugins; i++) {\n            total += IPlugin(plugins[i]).claimable(account, parsedAuxData[i]);\n        }\n        return total;\n    }\n\n    /// @dev Checks `claimableAt(account, blockNumber)` of all Plugins.\n    /// @param account Account to query claimable amount\n    /// @param blockNumber Block at which to query claimable amount\n    /// @param auxData Auxiliary data to pass to plugins\n    /// @return Total amount claimable by an account at a specific block number.\n    function claimableAt(address account, uint256 blockNumber, bytes calldata auxData) public view returns (uint256) {\n        uint256 total;\n        // loop over all plugins, sum claimableAt of account\n        bytes[] memory parsedAuxData = parseAuxData(auxData);\n        for (uint256 i = 0; i < nPlugins; i++) {\n            total += IPlugin(plugins[i]).claimableAt(account, blockNumber, parsedAuxData[i]);\n        }\n        return total;\n    }\n\n    /// @return Amount staked by an account. This does not include claimable yield from plugins.\n    /// @param account Account to query staked amount\n    function stakedBy(address account) external view returns (uint256) {\n        return _stakes[account].latest();\n    }\n\n    /// @return Amount staked by an account at a specific block number excluding claimable yield.\n    /// @param account Account to query staked amount\n    /// @param blockNumber Block at which to query staked amount\n    function stakedByAt(address account, uint256 blockNumber) public view returns (uint256) {\n        return _stakes[account].getAtBlock(blockNumber);\n    }\n\n    /************************************************\n    *   external mutative functions\n    ************************************************/\n\n    /// @notice Request a withdrawal if withdrawalDelay is nonzero\n    /// @dev This is required to prevent users from frontrunning slashing\n    function requestWithdrawal() external {\n        require(withdrawalDelay > 0, \"StakingModule: Withdrawal delay is 0\");\n        require(block.timestamp > withdrawalRequestTimestamps[msg.sender] + withdrawalDelay + withdrawalWindow, \"StakingModule: Withdrawal already pending\");\n\n        withdrawalRequestTimestamps[msg.sender] = block.timestamp;\n    }\n\n    /// @notice Stakes some amount of TEL to earn potential rewards.\n    /// @param amount Amount to stake\n    function stake(uint256 amount) external nonReentrant {\n        _stake({\n            account: msg.sender, \n            from: msg.sender, \n            amount: amount\n        });\n    }\n\n    function partialExit(uint256 amount) external nonReentrant delayedWithdrawal {\n        _partialExit({\n            account: msg.sender, \n            to: msg.sender, \n            exitAmount: amount\n        });\n    }\n\n    /// @notice Withdraws staked TEL, does not claim any yield.\n    /// @return Amount withdrawn\n    function exit() external nonReentrant delayedWithdrawal returns (uint256) {\n        return _exit({\n            account: msg.sender, \n            to: msg.sender\n        });\n    }\n\n    /// @notice Claims yield from an individual plugin and sends it to calling account.\n    /// @param pluginAddress Address of desired plugin\n    /// @param auxData Auxiliary data for the plugin\n    /// @return Amount claimed\n    function claimFromIndividualPlugin(address pluginAddress, bytes calldata auxData) external nonReentrant delayedWithdrawal returns (uint256) {\n        return _claimFromIndividualPlugin({\n            account: msg.sender, \n            to: msg.sender, \n            pluginAddress: pluginAddress, \n            auxData: auxData\n        });\n    }\n\n    /// @notice Claims yield from all plugins and sends it to calling account.\n    /// @param auxData Auxiliary data for the plugins\n    /// @return Amount claimed\n    function claim(bytes calldata auxData) external nonReentrant delayedWithdrawal returns (uint256) {\n        return _claim({\n            account: msg.sender, \n            to: msg.sender, \n            auxData: auxData\n        });\n    }\n\n    /// @notice Claims all yield and withdraws all stake.\n    /// @param auxData Auxiliary data for the plugins\n    /// @return Amount claimed\n    /// @return Amount withdrawn\n    function fullClaimAndExit(bytes calldata auxData) external nonReentrant delayedWithdrawal returns (uint256, uint256) {\n        return (\n            _claim({ account: msg.sender, to: msg.sender, auxData: auxData }), \n            _exit(msg.sender, msg.sender)\n        );\n    }\n\n    /// @notice Claims yield and withdraws some of stake.\n    /// @param amount Amount to withdraw\n    /// @param auxData Auxiliary data for the plugins\n    function partialClaimAndExit(uint256 amount, bytes calldata auxData) external nonReentrant delayedWithdrawal {\n        _claimAndExit({\n            account: msg.sender, \n            amount: amount, \n            to: msg.sender,\n            auxData: auxData\n        });\n    }\n\n    \n\n    /************************************************\n    *   private mutative functions\n    ************************************************/\n\n    /// @notice Claims earned yield from an individual plugin\n    /// @param account Account to claim on behalf of.\n    /// @param to Address to send the claimed yield to.\n    /// @param pluginAddress Address of the desired plugin to claim from\n    /// @dev Calls `claim` on the desired plugin\n    /// @dev Checks to make sure the amount of tokens the plugins sent matches what the `claim` functions returned. (Probably unnecessary)\n    /// @return Amount claimed\n    function _claimFromIndividualPlugin(address account, address to, address pluginAddress, bytes calldata auxData) private returns (uint256) {\n        require(pluginsMapping[pluginAddress], \"StakingModule::_claimFromIndividualPlugin: Provided pluginAddress is invalid\");\n        \n        // balance of `to` before claiming\n        uint256 balBefore = IERC20Upgradeable(tel).balanceOf(to);\n\n        // xClaimed = \"amount of TEL claimed from the plugin\"\n        uint256 xClaimed = IPlugin(pluginAddress).claim(account, to, parseAuxData(auxData)[pluginIndicies[pluginAddress]]);\n\n        // we want to make sure the plugin did not return the wrong amount\n        require(IERC20Upgradeable(tel).balanceOf(to) - balBefore == xClaimed, \"The plugin did not send appropriate token amount\");\n\n        // only emit Claimed if anything was actually claimed\n        if (xClaimed > 0) {\n            emit Claimed(account, xClaimed);\n        }\n\n        return xClaimed;\n    }\n\n    /// @notice Claims earned yield\n    /// @param account Account to claim on behalf of.\n    /// @param to Address to send the claimed yield to.\n    /// @param auxData Auxiliary data for the plugins\n    /// @dev Iterates over all plugins and calls `claim`\n    /// @dev Checks to make sure the amount of tokens the plugins sent matches what the `claim` functions returned.\n    /// @dev If amount claimed is >0, emit Claimed\n    /// @return Amount claimed\n    function _claim(address account, address to, bytes calldata auxData) private returns (uint256) {\n        // balance of `to` before claiming\n        uint256 balBefore = IERC20Upgradeable(tel).balanceOf(to);\n\n        // call claim on all plugins and count the total amount claimed\n        uint256 total;\n        bytes[] memory parsedAuxData = parseAuxData(auxData);\n        for (uint256 i = 0; i < nPlugins; i++) {\n            try IPlugin(plugins[i]).claim(account, to, parsedAuxData[i]) returns (uint256 xClaimed) {\n                total += xClaimed;\n            } catch  {\n                emit PluginClaimFailed(plugins[i]);\n            }\n        }\n\n        // make sure `total` actually matches how much we've claimed\n        require(IERC20Upgradeable(tel).balanceOf(to) - balBefore == total, \"one or more plugins did not send appropriate token amount\");\n\n        // only emit Claimed if anything was actually claimed\n        if (total > 0) {\n            emit Claimed(account, total);\n        }\n\n        return total;\n    }\n\n    /// @notice Withdraws staked TEL to the specified `to` address, does not claim any yield.\n    /// @dev Notifies all plugins that account's stake is changing.\n    /// @dev Writes _stakes checkpoint. \n    /// @dev Decrements _totalStaked\n    /// @dev Transfers TEL\n    /// @dev Emits StakeChanged.\n    /// @param account Account to exit on behalf of.\n    /// @param to Address to send the withdrawn balance to.\n    /// @return Amount withdrawn\n    function _exit(address account, address to) private returns (uint256) {\n        uint256 stakedAmt = _stakes[account].latest();\n\n        _partialExit(account, to, stakedAmt);\n\n        return stakedAmt;\n    }\n\n    function _partialExit(address account, address to, uint256 exitAmount) private checkpointProtection(account) {\n        if (exitAmount == 0) {\n            return;\n        }\n\n        uint256 stakedAmt = _stakes[account].latest();\n\n        require(stakedAmt >= exitAmount, \"StakingMoudle: Cannot exit more than is staked\");\n\n        // notify plugins\n        _notifyStakeChangeAllPlugins(account, stakedAmt, stakedAmt - exitAmount);\n\n        // update checkpoints\n        _stakes[account].push(stakedAmt - exitAmount);\n\n        // update _totalStaked\n        _totalStaked -= exitAmount;\n\n        // move the tokens\n        IERC20Upgradeable(tel).safeTransfer(to, exitAmount);\n\n        emit StakeChanged(account, stakedAmt, stakedAmt - exitAmount);\n    }\n\n    /// @notice Stakes some amount of TEL to earn potential rewards.\n    /// @dev Notifies all plugins that account's stake is changing.\n    /// @dev Updates _stakes[account]\n    /// @dev Increments _totalStaked\n    /// @dev Transfers TEL\n    /// @dev Emits StakeChanged.\n    /// @param account Account to stake on behalf of\n    /// @param from Address to pull TEL from\n    /// @param amount Amount to stake\n    function _stake(address account, address from, uint256 amount) private {\n        require(amount > 0, \"Cannot stake 0\");\n\n        uint256 stakedBefore = _stakes[account].latest();\n        uint256 stakedAfter = stakedBefore + amount;\n\n        // notify plugins\n        _notifyStakeChangeAllPlugins(account, stakedBefore, stakedAfter);\n        \n        // update _stakes\n        _stakes[account].push(stakedAfter);\n\n        // update _totalStaked\n        _totalStaked += amount;\n\n        // move the tokens\n        IERC20Upgradeable(tel).safeTransferFrom(from, address(this), amount);\n\n        emit StakeChanged(account, stakedBefore, stakedAfter);\n    }\n\n    /// @notice Claims yield and withdraws some of stake. Everything leftover remains staked\n    /// @param account account\n    /// @param amount amount to withdraw\n    /// @param to account to send withdrawn funds to\n    /// @dev The yield of the account is claimed to this contract\n    /// @dev Call `notifyStakeChange` on all plugins\n    /// @dev Update _stakes[account]\n    /// @dev Update _totalStaked\n    /// @dev Transfer `amount` of tokens to `to`\n    /// @dev Emit StakeChanged\n    function _claimAndExit(address account, uint256 amount, address to, bytes calldata auxData) private checkpointProtection(account) {\n        require(amount <= balanceOf(account, auxData), \"Account has insufficient balance\");\n\n        // keep track of initial stake\n        uint256 oldStake = _stakes[account].latest();\n        // xClaimed = total amount claimed\n        uint256 xClaimed = _claim(account, address(this), auxData);\n\n        uint256 newStake = oldStake + xClaimed - amount;\n\n        // notify all plugins that account's stake has changed (if the plugin requires)\n        _notifyStakeChangeAllPlugins(account, oldStake, newStake);\n\n        // update _stakes\n        _stakes[account].push(newStake);\n\n        // decrement _totalStaked\n        _totalStaked = _totalStaked - oldStake + newStake;\n\n        // transfer the tokens to `to`\n        IERC20Upgradeable(tel).safeTransfer(to, amount);\n\n        emit StakeChanged(account, oldStake, newStake);\n    }\n\n    /// @dev Calls `notifyStakeChange` on all plugins that require it. This is done in case any given plugin needs to do some stuff when a user exits.\n    /// @param account Account that is exiting\n    function _notifyStakeChangeAllPlugins(address account, uint256 amountBefore, uint256 amountAfter) private {\n        // loop over all plugins\n        for (uint256 i = 0; i < nPlugins; i++) {\n            // only notify if the plugin requires\n            if (IPlugin(plugins[i]).requiresNotification()) {\n                try IPlugin(plugins[i]).notifyStakeChange(account, amountBefore, amountAfter) {}\n                catch {\n                    emit StakeChangeNotificationFailed(plugins[i]);\n                }\n            }\n        }\n    }\n\n\n    /************************************************\n    *   restricted functions\n    ************************************************/\n\n    /// @notice Slashes stake of an account.\n    /// @notice Only those holding the `SLASHER_ROLE` may call this.\n    /// @param account account to slash\n    /// @param amount amount to slash\n    /// @param to account to send slashed funds to\n    function slash(address account, uint amount, address to, bytes calldata auxData) external onlyRole(SLASHER_ROLE) nonReentrant {\n        _claimAndExit(account, amount, to, auxData);\n        emit Slashed(account, amount);\n    }\n\n    /// @notice Sets the withdrawal delay and window to prevent frontrunning slashes\n    function setWithdrawDelayAndWindow(uint256 delay, uint256 window) external onlyRole(SLASHER_ROLE) {\n        require(delay <= maxWithdrawalDelay, \"StakingModule: Desired delay is too long\");\n        require(window >= minWithdrawalWindow, \"StakingModule: Desired window is too short\");\n\n        // if window + delay is >= current time, then someone with a requestTimestamp of 0 will be able to withdraw (i.e. withdraw without requesting)\n        // when requestTimestamp = 0, the following must hold: t > d + w\n        require(window + delay < block.timestamp, \"StakingModule: Desired window + delay is too large\");\n\n        withdrawalDelay = delay;\n        withdrawalWindow = window;\n    }\n\n    /// @notice Adds a new plugin\n    function addPlugin(address plugin) external onlyRole(PLUGIN_EDITOR_ROLE) {\n        require(!IPlugin(plugin).deactivated(), \"StakingModule::addPlugin: Cannot add deactivated plugin\");\n        require(IERC165(plugin).supportsInterface(type(IPlugin).interfaceId), \"StakingModule::addPlugin: plugin does not support IPlugin\");\n        require(!pluginsMapping[plugin], \"StakingModule::addPlugin: Cannot add an existing plugin\");\n\n        plugins.push(plugin);\n        pluginsMapping[plugin] = true;\n        pluginIndicies[plugin] = nPlugins;\n        nPlugins++;\n\n        emit PluginAdded(plugin, nPlugins);\n    }\n\n    /// @notice Removes a plugin\n    function removePlugin(uint256 index) external onlyRole(PLUGIN_EDITOR_ROLE) {\n        address plugin = plugins[index];\n\n        require(IPlugin(plugin).deactivated(), \"StakingModule::removePlugin: Plugin is not deactivated\");\n\n        pluginsMapping[plugin] = false;\n        plugins[index] = plugins[nPlugins - 1];\n        pluginIndicies[plugins[index]] = index;\n        plugins.pop();\n        nPlugins--;\n\n        emit PluginRemoved(plugin, nPlugins);\n    }\n\n    /// @notice rescues any stuck erc20\n    /// @dev if the token is TEL, then it only allows maximum of balanceOf(this) - _totalStaked to be rescued\n    function rescueTokens(IERC20Upgradeable token, address to) external onlyRole(RECOVERY_ROLE) {\n        if (address(token) == tel) {\n            // if the token is TEL, only remove the extra amount that isn't staked\n            token.safeTransfer(to, token.balanceOf(address(this)) - _totalStaked);\n        }\n        else {\n            // if the token isn't TEL, remove all of it\n            token.safeTransfer(to, token.balanceOf(address(this)));\n        }\n    }\n\n    /// @notice claim and exit on behalf of a user\n    /// @dev This function is in case of a token migration\n    /// @dev We know this would be insanely gas intensive if there are a lot of users\n    function claimAndExitFor(address account, address to, bytes calldata auxData) external onlyRole(MIGRATOR_ROLE) nonReentrant returns (uint256, uint256) {\n        return (_claim(account, to, auxData), _exit(account, to));\n    }\n\n    /// @notice stake on behalf of a user\n    /// @dev This function is in case of a token migration\n    /// @dev We know this would be insanely gas intensive if there are a lot of users\n    function stakeFor(address account, uint256 amount) external onlyRole(MIGRATOR_ROLE) nonReentrant {\n        _stake(account, msg.sender, amount);\n    }\n}"
    },
    {
      "filename": "telcoin-audit/contracts/staking/StakingModule.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/CheckpointsUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nimport \"../interfaces/IPlugin.sol\";\n\n// TODO: improve require messages\n\n/// @title Staking Module\n/// @notice Users interact directly with this contract to participate in staking. \n/// @dev This contract holds user funds. It does not accrue any staking yield on its own, it must have one or more `IPlugin` contracts \"connected\" to it.\ncontract StakingModule is ReentrancyGuardUpgradeable, AccessControlEnumerableUpgradeable {\n    using CheckpointsUpgradeable for CheckpointsUpgradeable.History;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using BytesLib for bytes;\n\n    /// @notice This role grants the ability to slash users' stakes at its own discretion\n    bytes32 public constant SLASHER_ROLE = keccak256(\"SLASHER_ROLE\");\n    /// @notice This role grants the ability to add and remove IPlugin contracts\n    bytes32 public constant PLUGIN_EDITOR_ROLE = keccak256(\"PLUGIN_EDITOR_ROLE\");\n    /// @notice This role grants the ability to rescue ERC20 tokens that do not rightfully belong to this contract\n    bytes32 public constant RECOVERY_ROLE = keccak256(\"RECOVERY_ROLE\");\n    /// @notice This role grants the ability to migrate user funds\n    bytes32 public constant MIGRATOR_ROLE = keccak256(\"MIGRATOR_ROLE\");\n\n    /// @notice The amount of time a user has to withdraw once the withdrawal delay has elapsed after requesting withdrawal\n    uint256 public withdrawalWindow;\n    /// @notice The withdrawal delay for preventing slash frontrunning\n    uint256 public withdrawalDelay;\n    /// @notice Maximum allowable withdrawal delay\n    /// @dev If there was no maximum, the delay could be very large which would prevent users from withdrawing\n    uint256 public maxWithdrawalDelay;\n    /// @notice Minimum allowable difference between withdrawal window and withdrawal delay\n    /// @dev If there was no minimum, the window could be set to 0 which would prevent users from withdrawing\n    uint256 public minWithdrawalWindow;\n\n    /// @notice TEL ERC20 address\n    address public tel;\n\n    /// @notice Array of all connected IPlugin contracts\n    address[] public plugins;\n\n    /// @notice Number of currently connected Plugins\n    uint256 public nPlugins;\n\n    /// @notice Maps a Plugin to whether or not it is included in `plugins`\n    /// @dev This allows duplicate plugins to be prevented\n    mapping(address => bool) public pluginsMapping;\n\n    /// @notice Maps a plugin to its index in the plugins array\n    /// @dev A plugin that is not in the plugins array does not necessarily map to 0\n    mapping(address => uint256) public pluginIndicies;\n\n    /// @notice Maps an account to a timestamp when they can call any withdrawal function. If zero, then a withdrawal hasn't been requested.\n    /// @dev If withdrawalDelay is zero, then the user does not need to request a withdrawal first\n    mapping(address => uint256) public withdrawalRequestTimestamps;\n\n    /// @notice Total TEL staked by users in this contract\n    uint256 private _totalStaked;\n    /// @notice Maps an account to its staked amount history\n    mapping(address => CheckpointsUpgradeable.History) private _stakes;\n\n    /// @dev The header of an auxData payload is an array of HeaderItem's\n    /// @dev The purpose of the HeaderItem(s) is to mark which parts of the data payload are for which plugins\n    struct AuxDataHeaderItem {\n        address addr;\n        uint256 start;\n        uint256 len;\n    }\n\n    /// @notice An event that's emitted when a account's stake changes (deposit/withdraw/slash)\n    event StakeChanged(address indexed account, uint256 oldStake, uint256 newStake);\n    /// @notice An event that's emitted when an account claims some yield\n    event Claimed(address indexed account, uint256 amount);\n    /// @notice An event that's emitted when an account's stake is slashed\n    event Slashed(address indexed account, uint256 amount);\n\n    /// @notice An event that's emitted when a plugin is added\n    event PluginAdded(address indexed plugin, uint256 nPlugins);\n    /// @notice An event that's emitted when a plugin is removed\n    event PluginRemoved(address indexed plugin, uint256 nPlugins);\n\n    /// @notice An event that's emitted when a call to a plugin's claim function reverts\n    event PluginClaimFailed(address indexed plugin);\n\n    /// @notice An event that's emitted when a call to a plugin's notifyStakeChange function reverts\n    event StakeChangeNotificationFailed(address indexed plugin);\n\n    function initialize(address _telAddress, uint256 _maxWithdrawalDelay, uint256 _minWithdrawalWindow) public initializer {\n        tel = _telAddress;\n        maxWithdrawalDelay = _maxWithdrawalDelay;\n        minWithdrawalWindow = _minWithdrawalWindow;\n\n        // initialize OZ stuff\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained();\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init_unchained();\n\n        // set deployer as ADMIN\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    modifier checkpointProtection(address account) {\n        uint256 numCheckpoints = _stakes[account]._checkpoints.length;\n        require(numCheckpoints == 0 || _stakes[account]._checkpoints[numCheckpoints - 1]._blockNumber != block.number, \"StakingModule: Cannot exit in the same block as another stake or exit\");\n        _;\n    }\n\n    modifier delayedWithdrawal() {\n        require(withdrawalDelay == 0 || (\n                withdrawalRequestTimestamps[msg.sender] + withdrawalDelay <= block.timestamp &&\n                block.timestamp <= withdrawalRequestTimestamps[msg.sender] + withdrawalDelay + withdrawalWindow\n            ), \n            \"StakingModule: Withdrawal not requested yet or it is too early/late to withdraw\"\n        );\n        withdrawalRequestTimestamps[msg.sender] = 0;\n        _;\n    }\n    \n    /************************************************\n    *   view functions\n    ************************************************/\n\n    /// @notice Parses auxiliary data into a bytes[] with length nPlugins\n    function parseAuxData(bytes calldata auxData) public view returns (bytes[] memory) {\n        bytes[] memory arr = new bytes[](nPlugins);\n\n        if (auxData.length == 0) {\n            return arr;\n        }\n        \n        (AuxDataHeaderItem[] memory header, bytes memory payload) = abi.decode(au"
    }
  ]
}