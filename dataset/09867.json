{
  "Title": "[L-04] Missing zero-address check in the setter functions and initialize functions",
  "Content": "\nMissing checks for zero-addresses may lead to infunctional protocol, if the variable addresses are updated incorrectly.\n\n### Proof of Concept\n\n1.  Navigate to the following contracts.\n\n<!---->\n\n    https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/schain/CommunityLocker.sol#L253\n\n### Recommended Mitigation Steps\n\nConsider adding zero-address checks in the discussed constructors:\nrequire(newAddr != address(0));.\n\n**[DimaStebaev (SKALE) commented](https://github.com/code-423n4/2022-02-skale-findings/issues/67#issuecomment-1066886133):**\n > L-01 and L-02 is described in #2 \n> L-02: only SKALE chain owner are able to deploy smart contracts on it's SKALE chain and this actor is assumed as trusted.\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2022-02-skale-findings/issues/67#issuecomment-1118619134):**\n> ### L-01 : Front-runnable Initializers\n> Agree with finding in lack of any mitigation am marking this valid.\n> For the sponsor, this is how you can deploy and set data in one tx: https://github.com/Badger-Finance/badger-strategy-mix-v1/blob/c97eda8cb60d0dcfd62be956a2aab4c86353de65/contracts/proxy/AdminUpgradeabilityProxy.sol#L225\n> \n> ### L-02 : Initializer reentrancy may lead to double initialization\n> Finding is valid, and mitigation is to upgrade to newer OZ code\n> \n> \n> ### L-03 : ERC1155Supply vulnerability in OpenZeppelin Contracts\n> Valid\n> \n> \n> ### L-04 : Missing zero-address check in the setter functions and initialize functions\n> Agree\n> \n> e.g. -> Vulnerability in OZ -> See disclosure -> Upgrade to xyz\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2022-02-skale-findings/issues/67#issuecomment-1147571670):**\n > Making this the winner of QA Reports, mostly because it offers some unique findings in a proper QA Format.\n> \n> In terms of Findings Kirk-Baird is basically there, I ended up making this report win as it was submitted as QA rather than an aggregate of downgraded findings.\n> \n> That said I believe this report could have had a couple extra findings to make it truly a winner.\n> \n> L-01: Front-runnable Initializers -> Low\n> \n> L-02 : Initializer reentrancy may lead to double initialization -> Low\n> \n> L-03 : ERC1155Supply vulnerability in OpenZeppelin Contracts -> Low\n> \n> L-04 : Missing zero-address check in the setter functions and initialize functions -> Low\n\n\n\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-02-skale-contest",
  "Code": [
    {
      "filename": "contracts/schain/CommunityLocker.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    CommunityLocker.sol - SKALE Manager\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaiev\n    @author Artem Payvin\n    @author Vadim Yavorsky\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/schain/ICommunityLocker.sol\";\n\nimport \"../Messages.sol\";\n\n\n/**\n * @title CommunityLocker\n * @dev Contract contains logic to perform automatic reimbursement\n * of gas fees for sent messages\n */\ncontract CommunityLocker is ICommunityLocker, AccessControlEnumerableUpgradeable {\n\n    /**\n     * @dev Mainnet identifier.\n     */\n    string constant public MAINNET_NAME = \"Mainnet\";\n\n    /**\n     * @dev Keccak256 hash of mainnet name.\n     */\n    bytes32 constant public MAINNET_HASH = keccak256(abi.encodePacked(MAINNET_NAME));\n\n    /**\n     * @dev id of a role that allows changing of the contract parameters.\n     */\n    bytes32 public constant CONSTANT_SETTER_ROLE = keccak256(\"CONSTANT_SETTER_ROLE\");\n\n    /**\n     * @dev Address of MessageProxyForSchain.\n     */\n    IMessageProxyForSchain public messageProxy;\n\n    /**\n     * @dev Address of TokenManagerLinker.\n     */\n    ITokenManagerLinker public tokenManagerLinker;\n\n    /**\n     * @dev Address of CommunityPool on mainnet.\n     */\n    address public communityPool;\n\n    /**\n     * @dev Keccak256 hash of schain name.\n     */\n    bytes32 public schainHash;\n\n    /**\n     * @dev Amount of seconds after message sending\n     * when next message cannot be sent.\n     */\n    uint public timeLimitPerMessage;\n\n    /**\n     * @dev Mapping of users who are allowed to send a message.\n     */\n    // user address => allowed to send message\n    mapping(address => bool) public activeUsers;\n\n    /**\n     * @dev Timestamp of previous sent message by user.\n     */\n    // user address => timestamp of last message\n    mapping(address => uint) public lastMessageTimeStamp;\n\n    uint256 public mainnetGasPrice;\n\n    uint256 public gasPriceTimestamp;\n\n    /**\n     * @dev Emitted when a user becomes active.\n     */\n    event ActivateUser(\n        bytes32 schainHash,\n        address user\n    );\n\n    /**\n     * @dev Emitted when a user stops being active.\n     */\n    event LockUser(\n        bytes32 schainHash,\n        address user\n    ); \n\n    /**\n     * @dev Emitted when constants updated.\n     */\n    event ConstantUpdated(\n        bytes32 indexed constantHash,\n        uint previousValue,\n        uint newValue\n    );\n\n    /**\n     * @dev Allows MessageProxy to post operational message from mainnet\n     * or SKALE chains.\n     *\n     * Requirements:\n     * \n     * - MessageProxy must be the caller of the function.\n     * - CommunityPool must be an origin of the message on mainnet.\n     * - The message must come from the mainnet.\n     * - The message must contains status of a user.\n     * - Status of a user in the message must be different from the current status.\n     */\n    function postMessage(\n        bytes32 fromChainHash,\n        address sender,\n        bytes calldata data\n    )\n        external\n        override\n        returns (address)\n    {\n        require(msg.sender == address(messageProxy), \"Sender is not a message proxy\");\n        require(sender == communityPool, \"Sender must be CommunityPool\");\n        require(fromChainHash == MAINNET_HASH, \"Source chain name must be Mainnet\");\n        Messages.MessageType operation = Messages.getMessageType(data);\n        require(operation == Messages.MessageType.USER_STATUS, \"The message should contain a status of user\");\n        Messages.UserStatusMessage memory message = Messages.decodeUserStatusMessage(data);\n        require(activeUsers[message.receiver] != message.isActive, \"Active user statuses must be different\");\n        activeUsers[message.receiver] = message.isActive;\n        if (message.isActive) {\n            emit ActivateUser(schainHash, message.receiver);\n        } else {\n            emit LockUser(schainHash, message.receiver);\n        }\n        return message.receiver;\n    }\n\n    /**\n     * @dev Reverts if {receiver} is not allowed to send a message.\n     *\n     * Requirements:\n     * \n     * - Function caller has to be registered in TokenManagerLinker as a TokenManager.\n     * - {receiver} must be an active user.\n     * - Previous message sent by {receiver} must be sent earlier then {timeLimitPerMessage} seconds before current time\n     * or there are no messages sent by {receiver}.\n     */\n    function checkAllowedToSendMessage(address receiver) external override {\n        require(\n            tokenManagerLinker.hasTokenManager(ITokenManager(msg.sender)),\n            \"Sender is not registered token manager\"\n        );\n        require(activeUsers[receiver], \"Recipient must be active\");\n        require(\n            lastMessageTimeStamp[receiver] + timeLimitPerMessage < block.timestamp,\n            \"Trying to send messages too often\"\n        );\n        lastMessageTimeStamp[receiver] = block.timestamp;\n    }\n\n    /**\n     * @dev Set value of {timeLimitPerMessage}.\n     *\n     * Requirements:\n     * \n     * - Function caller has to be granted with {CONSTANT_SETTER_ROLE}.\n     * \n     * Emits a {ConstantUpdated} event.\n     */\n    function setTimeLimitPerMessage(uint newTimeLimitPerMessage) external override {\n        require(hasRole(CONSTANT_SETTER_ROLE, msg.sender), \"Not enough permissions to set constant\");\n        emit ConstantUpdated(\n            keccak256(abi.encodePacked(\"TimeLimitPerMessage\")),\n            timeLimitPerMessage,\n            newTimeLimitPerMessage\n        );\n        timeLimitPerMessage = newTimeLimitPerMessage;\n    }\n\n    /**\n     * @dev Set value of {mainnetGasPrice}.\n     *\n     * Requirements:\n     * \n     * - Signature should be verified.\n     * \n     * Emits a {ConstantUpdated} event.\n     */\n    function setGasPrice(\n        uint gasPrice,\n        uint timestamp,\n        IMessageProxyForSchain.Signature memory\n    )\n        external\n        override\n    {\n        require(timestamp > gasPriceTimestamp, \"Gas price timestamp already updated\");\n        require(timestamp <= block.timestamp, \"Timestamp should not be in the future\");\n        // TODO: uncomment when oracle finished\n        // require(\n        //     messageProxy.verifySignature(keccak256(abi.encodePacked(gasPrice, timestamp)), signature),\n        //     \"Signature is not verified\"\n        // );\n        emit ConstantUpdated(\n            keccak256(abi.encodePacked(\"MainnetGasPrice\")),\n            mainnetGasPrice,\n            gasPrice\n        );\n        mainnetGasPrice = gasPrice;\n        gasPriceTimestamp = timestamp;\n    }\n\n    /**\n     * @dev Is called once during contract deployment.\n     */\n    function initialize(\n        string memory newSchainName,\n        IMessageProxyForSchain newMessageProxy,\n        ITokenManagerLinker newTokenManagerLinker,\n        address newCommunityPool\n    )\n        external\n        override\n        initializer\n    {\n        require(newCommunityPool != address(0), \"Node address has to be set\");\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        messageProxy = newMessageProxy;\n        tokenManagerLinker = newTokenManagerLinker;\n        schainHash = keccak256(abi.encodePacked(newSchainName));\n        timeLimitPerMessage = 5 minutes;\n        communityPool = newCommunityPool;\n    }\n}"
    },
    {
      "filename": "contracts/proxy/AdminUpgradeabilityProxy.sol",
      "content": "/**\n *Submitted for verification at Etherscan.io on 2020-10-09\n */\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n}\n\n/**\n * @title Proxy\n * @dev Implements delegation of calls to other contracts, with proper\n * forwarding of return values and bubbling of failures.\n * It defines a fallback function that delegates all calls to the address\n * returned by the abstract _implementation() internal function.\n */\nabstract contract Proxy {\n    /**\n     * @dev Fallback function.\n     * Implemented entirely in `_fallback`.\n     */\n    fallback() external payable {\n        _fallback();\n    }\n\n    /**\n     * @dev Receive function.\n     * Implemented entirely in `_fallback`.\n     */\n    receive() external payable {\n        _fallback();\n    }\n\n    /**\n     * @return The Address of the implementation.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates execution to an implementation contract.\n     * This is a low level function that doesn't return to its internal call site.\n     * It will return to the external caller whatever the implementation returns.\n     * @param implementation Address to delegate.\n     */\n    function _delegate(address implementation) internal {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(\n                gas(),\n                implementation,\n                0,\n                calldatasize(),\n                0,\n                0\n            )\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n                // delegatecall returns 0 on error.\n                case 0 {\n                    revert(0, returndatasize())\n                }\n                default {\n                    return(0, returndatasize())\n                }\n        }\n    }\n\n    /**\n     * @dev Function that is run as the first thing in the fallback function.\n     * Can be redefined in derived contracts to add functionality.\n     * Redefinitions must call super._willFallback().\n     */\n    function _willFallback() internal virtual {}\n\n    /**\n     * @dev fallback implementation.\n     * Extracted to enable manual triggering.\n     */\n    function _fallback() internal {\n        _willFallback();\n        _delegate(_implementation());\n    }\n}\n\n/**\n * @title UpgradeabilityProxy\n * @dev This contract implements a proxy that allows to change the\n * implementation address to which it will delegate.\n * Such a change is called an implementation upgrade.\n */\ncontract UpgradeabilityProxy is Proxy {\n    /**\n     * @dev Contract constructor.\n     * @param _logic Address of the initial implementation.\n     * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n     * It should include the signature and the parameters of the function to be called, as described in\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n     * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n     */\n    constructor(address _logic, bytes memory _data) public payable {\n        assert(\n            IMPLEMENTATION_SLOT ==\n                bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1)\n        );\n        _setImplementation(_logic);\n        if (_data.length > 0) {\n            (bool success, ) = _logic.delegatecall(_data);\n            require(success);\n        }\n    }\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     * @param implementation Address of the new implementation.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation.\n     * @return impl Address of the current implementation\n     */\n    function _implementation() internal view override returns (address impl) {\n        bytes32 slot = IMPLEMENTATION_SLOT;\n        assembly {\n            impl := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Upgrades the proxy to a new implementation.\n     * @param newImplementation Address of the new implementation.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation address of the proxy.\n     * @param newImplementation Address of the new implementation.\n     */\n    function _setImplementation(address newImplementation) internal {\n        require(\n            Address.isContract(newImplementation),\n            \"Cannot set a proxy implementation to a non-contract address\"\n        );\n\n        bytes32 slot = IMPLEMENTATION_SLOT;\n\n        assembly {\n            sstore(slot, newImplementation)\n        }\n    }\n}\n\n/**\n * @title AdminUpgradeabilityProxy\n * @dev This contract combines an upgradeability proxy with an authorization\n * mechanism for administrative tasks.\n * All external functions in this contract must be guarded by the\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\n * feature proposal that would enable this to be done automatically.\n */\ncontract AdminUpgradeabilityProxy is UpgradeabilityProxy {\n    /**\n     * Contract constructor.\n     * @param _logic address of the initial implementation.\n     * @param _admin Address of the proxy administrator.\n     * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n     * It should include the signature and the parameters of the function to be called, as described in\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n     * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n     */\n    constructor(\n        address _logic,\n        address _admin,\n        bytes memory _data\n    ) public payable UpgradeabilityProxy(_logic, _data) {\n        assert(\n            ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1)\n        );\n        _setAdmin(_admin);\n    }\n\n    /**\n     * @dev Emitted when the administration has been transferred.\n     * @param previousAdmin Address of the previous admin.\n     * @param newAdmin Address of the new admin.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n\n    bytes32 internal constant ADMIN_SLOT =\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Modifier to check whether the `msg.sender` is the admin.\n     * If it is, it will run the function. Otherwise, it will delegate the call\n     * to the implementation.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _admin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @return The address of the proxy admin.\n     */\n    function admin() external ifAdmin returns (address) {\n        return _admin();\n    }\n\n    /**\n     * @return The address of the implementation.\n     */\n    function implementation() external ifAdmin returns (address) {\n        return _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     * Only the current admin can call this function.\n     * @param newAdmin Address to transfer proxy administration to.\n     */\n    function changeAdmin(address newAdmin) external ifAdmin {\n        require(\n            newAdmin != address(0),\n            \"Cannot change the admin of a proxy to the zero address\"\n        );\n        emit AdminChanged(_admin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the backing implementation of the proxy.\n     * Only the admin can call this function.\n     * @param newImplementation Address of the new implementation.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeTo(newImplementation);\n    }\n\n    /**\n     * @dev Upgrade the backing implementation of the proxy and call a function\n     * on the new implementation.\n     * This is useful to initialize the proxied contract.\n     * @param newImplementation Address of the new implementation.\n     * @param data Data to send as msg.data in the low level call.\n     * It should include the signature and the parameters of the function to be called, as described in\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data)\n        external\n        payable\n        ifAdmin\n    {\n        _upgradeTo(newImplementation);\n        (bool success, ) = newImplementation.delegatecall(data);\n        require(success);\n    }\n\n    /**\n     * @return adm The admin slot.\n     */\n    function _admin() internal view returns (address adm) {\n        bytes32 slot = ADMIN_SLOT;\n        assembly {\n            adm := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Sets the address of the proxy admin.\n     * @param newAdmin Address of the new proxy admin.\n     */\n    function _setAdmin(address newAdmin) internal {\n        bytes32 slot = ADMIN_SLOT;\n\n        assembly {\n            sstore(slot, newAdmin)\n        }\n    }\n\n    /**\n     * @dev Only fall back when the sender is not the admin.\n     */\n    function _willFallback() internal virtual override {\n        require(\n            msg.sender != _admin(),\n            \"Cannot call fallback function from the proxy admin\"\n        );\n        super._willFallback();\n    }\n}"
    }
  ]
}