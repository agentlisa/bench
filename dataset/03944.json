{
  "Title": "[L10] UniswapOracle does not allow overflow",
  "Content": "The [`update` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/oracle/UniswapOracle.sol#L53-L55) in the [`UniswapOracle` contract](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/oracle/UniswapOracle.sol) does not allow the cumulative price variables to overflow, against the guidance of the [UniswapV2Pair oracle specification](https://uniswap.org/docs/v2/smart-contract-integration/building-an-oracle/#notes-on-overflow). This means the `update` function will eventually fail, despite the fact that Uniswap is designed to handle this overflow correctly. Consider permitting overflows to conform to the Uniswap Oracle specification.\n\n\n**Update:** *Fixed in [PR#37](https://github.com/fei-protocol/fei-protocol-core/pull/37).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/oracle/UniswapOracle.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n// Referencing Uniswap Example Simple Oracle\n// https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/examples/ExampleOracleSimple.sol\n\nimport \"@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol\";\nimport \"./IUniswapOracle.sol\";\nimport \"../refs/CoreRef.sol\";\n\n/// @title IUniswapOracle implementation contract\n/// @author Fei Protocol\ncontract UniswapOracle is IUniswapOracle, CoreRef {\n\tusing Decimal for Decimal.D256;\n\n\tIUniswapV2Pair public override pair;\n\tbool private isPrice0;\n\n\tuint public override priorCumulative; \n\tuint32 public override priorTimestamp;\n\n\tDecimal.D256 private twap = Decimal.zero();\n\tuint32 public override duration;\n\n\tbool public override killSwitch;\n\n\t/// @notice UniswapOracle constructor\n\t/// @param _core Fei Core for reference\n\t/// @param _pair Uniswap Pair to provide TWAP\n\t/// @param _duration TWAP duration\n\t/// @param _isPrice0 flag for using token0 or token1 for cumulative on Uniswap\n\tconstructor(\n\t\taddress _core, \n\t\taddress _pair, \n\t\tuint32 _duration,\n\t\tbool _isPrice0\n\t) public CoreRef(_core) {\n\t\tpair = IUniswapV2Pair(_pair);\n\t\t// Relative to USD per ETH price\n\t\tisPrice0 = _isPrice0;\n\n\t\tduration = _duration;\n\n\t\t_init();\n\t}\n\n\tfunction update() external override returns (bool) {\n\t\t(uint price0Cumulative, uint price1Cumulative, uint32 currentTimestamp) =\n            UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\n\n\t\tuint32 deltaTimestamp = currentTimestamp - priorTimestamp;\n\t\tif(currentTimestamp <= priorTimestamp || deltaTimestamp < duration) {\n\t\t\treturn false;\n\t\t}\n\n\t\tuint currentCumulative = _getCumulative(price0Cumulative, price1Cumulative);\n\t\tuint deltaCumulative = (currentCumulative - priorCumulative) / 1e12;\n\n\t\tDecimal.D256 memory _twap = Decimal.ratio(2**112, deltaCumulative / deltaTimestamp);\n\t\ttwap = _twap;\n\n\t\tpriorTimestamp = currentTimestamp;\n\t\tpriorCumulative = currentCumulative;\n\n\t\temit Update(_twap.asUint256());\n\n\t\treturn true;\n\t}\n\n    function read() external view override returns (Decimal.D256 memory, bool) {\n    \tbool valid = !(killSwitch || twap.isZero());\n    \treturn (twap, valid);\n    }\n \n\tfunction setKillSwitch(bool _killSwitch) external override onlyGovernor {\n\t\tkillSwitch = _killSwitch;\n\t\temit KillSwitchUpdate(_killSwitch);\n\t}\n\n\tfunction setDuration(uint32 _duration) external override onlyGovernor {\n\t\tduration = _duration;\n\t\temit DurationUpdate(_duration);\n\t}\n\n\tfunction _init() internal {\n        uint price0Cumulative = pair.price0CumulativeLast();\n        uint price1Cumulative = pair.price1CumulativeLast();\n\n        (,, uint32 currentTimestamp) = pair.getReserves();\n\n        priorTimestamp = currentTimestamp;\n\t\tpriorCumulative = _getCumulative(price0Cumulative, price1Cumulative);\n\t}\n\n    function _getCumulative(uint price0Cumulative, uint price1Cumulative) internal view returns (uint) {\n\t\treturn isPrice0 ? price0Cumulative : price1Cumulative;\n\t}\n}"
    }
  ]
}