{
  "Title": "[H06] AUD lending market could affect the protocol",
  "Content": "In case an AUD token lending market appears, an attacker could use this market to influence the result of a governance’s proposal, which could lead to a take over of the protocol.\n\n\nAn attacker would only need to stake tokens for a brief moment without waiting for the [`votingPeriod`](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/Governance.sol#L23) to request an unstake. This aggravates the attack, as the attacker would only need to take a loan for the number of blocks established by the [`decreaseStakeLockupDuration` variable](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ServiceProviderFactory.sol#L17).\n\n\nThe only prerequisite that an attacker needs for this attack is to have sufficient collateral, which could be trivial if a lending market of AUD tokens exists while AUD price is still low enough.\n\n\nConsider countermeasures for these type of attacks, and have plan for how to react when a lending market for AUD is created.\n\n\n***Update**: Fixed. As described in the updates of “[H08] Endpoint registration can be frontrun” and “[H09] Slash process can be bypassed”, `decreaseStakeLockupDuration` is already significantly larger than `votingPeriod` + `executionDelay`. Audius’s statement about this issue:*\n\n\n\n> The above is no longer possible with our enforced relationship between decreaseStakeLockup and votingPeriod + delay. An attacker may still stake tokens immediately prior to a proposal, but the relationship between the two variables means they are still subject to a slash operation. This is because an attacker cannot unstake without waiting at at least one votingPeriod + executionDelay time difference.\n> \n> \n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "eth-contracts/contracts/Governance.sol",
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\nimport \"./Staking.sol\";\nimport \"./registry/Registry.sol\";\nimport \"./InitializableV2.sol\";\n\n\ncontract Governance is InitializableV2 {\n    using SafeMath for uint;\n\n    /**\n     * @notice Address and contract instance of Audius Registry. Used to ensure this contract\n     *      can only govern contracts that are registered in the Audius Registry.\n     */\n    Registry private registry;\n    address private registryAddress;\n\n    /// @notice Address of Audius staking contract, used to permission Governance method calls\n    address private stakingAddress;\n\n    /// @notice Period in blocks for which a governance proposal is open for voting\n    uint256 private votingPeriod;\n\n    /// @notice Required miniumum number of votes to consider a proposal valid\n    uint256 private votingQuorum;\n\n    /**\n     * @notice Address of account that has special Governance permissions. Can veto proposals\n     *      and execute transactions directly on contracts.\n     */\n    address private guardianAddress;\n\n    /***** Enums *****/\n\n    /**\n     * @notice All Proposal Outcome states.\n     *      InProgress - Proposal is active and can be voted on\n     *      No - Proposal votingPeriod has closed and decision is No. Proposal will not be executed.\n     *      Yes - Proposal votingPeriod has closed and decision is Yes. Proposal will be executed.\n     *      Invalid - Proposal votingPeriod has closed and votingQuorum was not met. Proposal will not be executed.\n     *      TxFailed - Proposal voting decision was Yes, but transaction execution failed.\n     *      Evaluating - Proposal voting decision was Yes, and evaluateProposalOutcome function is currently running.\n     *          This status is transiently used inside that function to prevent re-entrancy.\n     */\n    enum Outcome {InProgress, No, Yes, Invalid, TxFailed, Evaluating}\n\n    /**\n     * @notice All Proposal Vote states for a voter.\n     *      None - The default state, for any account that has not previously voted on this Proposal.\n     *      No - The account voted No on this Proposal.\n     *      Yes - The account voted Yes on this Proposal.\n     *\n     * @dev Enum values map to uints, so first value in Enum always is 0.\n     */\n    enum Vote {None, No, Yes}\n\n    struct Proposal {\n        uint256 proposalId;\n        address proposer;\n        uint256 startBlockNumber;\n        bytes32 targetContractRegistryKey;\n        address targetContractAddress;\n        uint callValue;\n        string signature;\n        bytes callData;\n        Outcome outcome;\n        uint256 voteMagnitudeYes;\n        uint256 voteMagnitudeNo;\n        uint256 numVotes;\n        mapping(address => Vote) votes;\n    }\n\n    /***** Proposal storage *****/\n    uint256 lastProposalId = 0;\n    mapping(uint256 => Proposal) proposals;\n\n    /***** Events *****/\n    event ProposalSubmitted(\n        uint256 indexed proposalId,\n        address indexed proposer,\n        uint256 startBlockNumber,\n        string description\n    );\n    event ProposalVoteSubmitted(\n        uint256 indexed proposalId,\n        address indexed voter,\n        Vote indexed vote,\n        uint256 voterStake,\n        Vote previousVote\n    );\n    event ProposalOutcomeEvaluated(\n        uint256 indexed proposalId,\n        Outcome indexed outcome,\n        uint256 voteMagnitudeYes,\n        uint256 voteMagnitudeNo,\n        uint256 numVotes\n    );\n    event ProposalTransactionExecuted(\n        uint256 indexed proposalId,\n        bool indexed success,\n        bytes returnData\n    );\n    event GuardianTransactionExecuted(\n        address indexed targetContractAddress,\n        uint256 callValue,\n        string indexed signature,\n        bytes indexed callData,\n        bytes returnData\n    );\n    event ProposalVetoed(uint256 indexed proposalId);\n\n    /**\n     * @notice Initialize the Governance contract\n     * @dev _votingPeriod <= DelegateManager.undelegateLockupDuration\n     * @param _registryAddress - address of the registry proxy contract\n     * @param _votingPeriod - period in blocks for which a governance proposal is open for voting\n     * @param _votingQuorum - required minimum number of votes to consider a proposal valid\n     * @param _guardianAddress - address of account that has special Governance permissions\n\n     */\n    function initialize(\n        address _registryAddress,\n        uint256 _votingPeriod,\n        uint256 _votingQuorum,\n        address _guardianAddress\n    ) public initializer {\n        require(_registryAddress != address(0x00), \"Requires non-zero _registryAddress\");\n        registryAddress = _registryAddress;\n        registry = Registry(_registryAddress);\n\n        require(_votingPeriod > 0, \"Requires non-zero _votingPeriod\");\n        votingPeriod = _votingPeriod;\n\n        require(_votingQuorum > 0, \"Requires non-zero _votingQuorum\");\n        votingQuorum = _votingQuorum;\n\n        require(_guardianAddress != address(0x00), \"Requires non-zero _guardianAddress\");\n        guardianAddress = _guardianAddress;  //Guardian address becomes the only party\n\n        InitializableV2.initialize();\n    }\n\n    // ========================================= Governance Actions =========================================\n\n    /**\n     * @notice Submit a proposal for vote. Only callable by stakers with non-zero stake.\n     * @param _targetContractRegistryKey - Registry key for the contract concerning this proposal\n     * @param _callValue - amount of wei to pass with function call if a token transfer is involved\n     * @param _signature - function signature of the function to be executed if proposal is successful\n     * @param _callData - encoded value(s) to call function with if proposal is successful\n     * @param _description - Text description of proposal to be emitted in event\n     */\n    function submitProposal(\n        bytes32 _targetContractRegistryKey,\n        uint256 _callValue,\n        string calldata _signature,\n        bytes calldata _callData,\n        string calldata _description\n    ) external returns (uint256 proposalId)\n    {\n        _requireIsInitialized();\n\n        address proposer = msg.sender;\n\n        // Require proposer is active Staker\n        Staking stakingContract = Staking(stakingAddress);\n        require(\n            stakingContract.totalStakedFor(proposer) > 0,\n            \"Proposer must be active staker with non-zero stake.\"\n        );\n\n        // Require _targetContractRegistryKey points to a valid registered contract\n        address targetContractAddress = registry.getContract(_targetContractRegistryKey);\n        require(\n            targetContractAddress != address(0x00),\n            \"_targetContractRegistryKey must point to valid registered contract\"\n        );\n\n        // Signature cannot be empty\n        require(\n            bytes(_signature).length != 0,\n            \"Governance::submitProposal: _signature cannot be empty.\"\n        );\n\n        // set proposalId\n        uint256 newProposalId = lastProposalId.add(1);\n\n        // Store new Proposal obj in proposals mapping\n        proposals[newProposalId] = Proposal({\n            proposalId: newProposalId,\n            proposer: proposer,\n            startBlockNumber: block.number,\n            targetContractRegistryKey: _targetContractRegistryKey,\n            targetContractAddress: targetContractAddress,\n            callValue: _callValue,\n            signature: _signature,\n            callData: _callData,\n            outcome: Outcome.InProgress,\n            voteMagnitudeYes: 0,\n            voteMagnitudeNo: 0,\n            numVotes: 0\n            /* votes: mappings are auto-initialized to default state */\n        });\n\n        emit ProposalSubmitted(\n            newProposalId,\n            proposer,\n            block.number,\n            _description\n        );\n\n        lastProposalId = lastProposalId.add(1);\n\n        return newProposalId;\n    }\n\n    /**\n     * @notice Vote on an active Proposal. Only callable by stakers with non-zero stake.\n     * @param _proposalId - id of the proposal this vote is for\n     * @param _vote - can be either {Yes, No} from Vote enum. No other values allowed\n     */\n    function submitProposalVote(uint256 _proposalId, Vote _vote) external {\n        _requireIsInitialized();\n\n        address voter = msg.sender;\n\n        require(\n            _proposalId <= lastProposalId && _proposalId > 0,\n            \"Must provide valid non-zero _proposalId\"\n        );\n\n        // Require voter is active Staker + get voterStake.\n        Staking stakingContract = Staking(stakingAddress);\n\n        uint256 voterStake = stakingContract.totalStakedForAt(\n            voter,\n            proposals[_proposalId].startBlockNumber\n        );\n        require(voterStake > 0, \"Voter must be active staker with non-zero stake.\");\n\n        // Require proposal is still active\n        require(\n            proposals[_proposalId].outcome == Outcome.InProgress,\n            \"Governance::submitProposalVote: Cannot vote on inactive proposal.\"\n        );\n\n        // Require proposal votingPeriod is still active.\n        uint256 startBlockNumber = proposals[_proposalId].startBlockNumber;\n        uint256 endBlockNumber = startBlockNumber.add(votingPeriod);\n        require(\n            block.number > startBlockNumber && block.number <= endBlockNumber,\n            \"Governance::submitProposalVote: Proposal votingPeriod has ended\"\n        );\n\n        // Require vote is either Yes or No\n        require(\n            _vote == Vote.Yes || _vote == Vote.No,\n            \"Governance::submitProposalVote: Can only submit a Yes or No vote\"\n        );\n\n        // Record previous vote.\n        Vote previousVote = proposals[_proposalId].votes[voter];\n\n        // Will override staker's previous vote if present.\n        proposals[_proposalId].votes[voter] = _vote;\n\n        /* Update voteMagnitudes accordingly */\n\n        // New voter (Vote enum defaults to 0)\n        if (previousVote == Vote.None) {\n            if (_vote == Vote.Yes) {\n                proposals[_proposalId].voteMagnitudeYes = (\n                    proposals[_proposalId].voteMagnitudeYes.add(voterStake)\n                );\n            } else {\n                proposals[_proposalId].voteMagnitudeNo = (\n                    proposals[_proposalId].voteMagnitudeNo.add(voterStake)\n                );\n            }\n            proposals[_proposalId].numVotes = proposals[_proposalId].numVotes.add(1);\n        } else { // Repeat voter\n            if (previousVote == Vote.Yes && _vote == Vote.No) {\n                proposals[_proposalId].voteMagnitudeYes = (\n                    proposals[_proposalId].voteMagnitudeYes.sub(voterStake)\n                );\n                proposals[_proposalId].voteMagnitudeNo = (\n                    proposals[_proposalId].voteMagnitudeNo.add(voterStake)\n                );\n            } else if (previousVote == Vote.No && _vote == Vote.Yes) {\n                proposals[_proposalId].voteMagnitudeYes = (\n                    proposals[_proposalId].voteMagnitudeYes.add(voterStake)\n                );\n                proposals[_proposalId].voteMagnitudeNo = (\n                    proposals[_proposalId].voteMagnitudeNo.sub(voterStake)\n                );\n            }\n            // If _vote == previousVote, no changes needed to vote magnitudes.\n        }\n\n        emit ProposalVoteSubmitted(\n            _proposalId,\n            voter,\n            _vote,\n            voterStake,\n            previousVote\n        );\n    }\n\n    /**\n     * @notice Once the voting period for a proposal has ended, evaluate the outcome and\n     *      execute the proposal if stake-weighted vote is >= 50% Yes and voting quorum met.\n     * @dev Requires that caller is an active staker at the time the proposal is created\n     * @param _proposalId - id of the proposal\n     */\n    function evaluateProposalOutcome(uint256 _proposalId)\n    external returns (Outcome proposalOutcome)\n    {\n        _requireIsInitialized();\n\n        require(\n            _proposalId <= lastProposalId && _proposalId > 0,\n            \"Governance::evaluateProposalOutcome: Must provide valid non-zero _proposalId.\"\n        );\n\n        // Require proposal has not already been evaluated.\n        require(\n            proposals[_proposalId].outcome == Outcome.InProgress,\n            \"Governance::evaluateProposalOutcome: Cannot evaluate inactive proposal.\"\n        );\n\n        /// Re-entrancy should not be possible here since this switches the status of the\n        /// proposal to 'Evaluating' so it should fail the status is 'InProgress' check\n        proposals[_proposalId].outcome = Outcome.Evaluating;\n\n        // Require msg.sender is active Staker.\n        Staking stakingContract = Staking(stakingAddress);\n\n        require(\n            stakingContract.totalStakedForAt(\n                msg.sender, proposals[_proposalId].startBlockNumber\n            ) > 0,\n            \"Governance::evaluateProposalOutcome: Caller must be active staker with non-zero stake.\"\n        );\n\n        // Require proposal votingPeriod has ended.\n        uint256 startBlockNumber = proposals[_proposalId].startBlockNumber;\n        uint256 endBlockNumber = startBlockNumber.add(votingPeriod);\n        require(\n            block.number > endBlockNumber,\n            \"Governance::evaluateProposalOutcome: Proposal votingPeriod must end before evaluation.\"\n        );\n\n        // Require registered contract address for provided registryKey has not changed.\n        address targetContractAddress = registry.getContract(\n            proposals[_proposalId].targetContractRegistryKey\n        );\n        require(\n            targetContractAddress == proposals[_proposalId].targetContractAddress,\n            \"Governance::evaluateProposalOutcome: Registered contract address for targetContractRegistryKey has changed\"\n        );\n\n        // Calculate outcome\n        Outcome outcome;\n        // votingQuorum not met -> proposal is invalid.\n        if (proposals[_proposalId].numVotes < votingQuorum) {\n            outcome = Outcome.Invalid;\n        }\n        // votingQuorum met & vote is Yes -> execute proposed transaction & close proposal.\n        else if (\n            proposals[_proposalId].voteMagnitudeYes >= proposals[_proposalId].voteMagnitudeNo\n        ) {\n            (bool success, bytes memory returnData) = _executeTransaction(\n                targetContractAddress,\n                proposals[_proposalId].callValue,\n                proposals[_proposalId].signature,\n                proposals[_proposalId].callData\n            );\n\n            emit ProposalTransactionExecuted(\n                _proposalId,\n                success,\n                returnData\n            );\n\n            // Proposal outcome depends on success of transaction execution.\n            if (success) {\n                outcome = Outcome.Yes;\n            } else {\n                outcome = Outcome.TxFailed;\n            }\n        }\n        // votingQuorum met & vote is No -> close proposal without transaction execution.\n        else {\n            outcome = Outcome.No;\n        }\n\n        /// This records the final outcome in the proposals mapping\n        proposals[_proposalId].outcome = outcome;\n\n        emit ProposalOutcomeEvaluated(\n            _proposalId,\n            outcome,\n            proposals[_proposalId].voteMagnitudeYes,\n            proposals[_proposalId].voteMagnitudeNo,\n            proposals[_proposalId].numVotes\n        );\n\n        return outcome;\n    }\n\n    /**\n     * @notice Action limited to the guardian address that can veto a proposal\n     * @param _proposalId - id of the proposal\n     */\n    function vetoProposal(uint256 _proposalId) external {\n        _requireIsInitialized();\n\n        require(\n            msg.sender == guardianAddress,\n            \"Governance::vetoProposal: Only guardian can veto proposals.\"\n        );\n\n        require(\n            _proposalId <= lastProposalId && _proposalId > 0,\n            \"Governance::vetoProposal: Must provide valid non-zero _proposalId.\"\n        );\n\n        require(\n            proposals[_proposalId].outcome == Outcome.InProgress,\n            \"Governance::vetoProposal: Cannot veto inactive proposal.\"\n        );\n\n        proposals[_proposalId].outcome = Outcome.No;\n\n        emit ProposalVetoed(_proposalId);\n    }\n\n    // ========================================= Config Setters =========================================\n\n    /**\n     * @notice Set the Staking address\n     * @dev Only callable by self via _executeTransaction\n     * @param _stakingAddress - address for new Staking contract\n     */\n    function setStakingAddress(address _stakingAddress) external {\n        require(msg.sender == address(this), \"Only callable by self\");\n        require(_stakingAddress != address(0x00), \"Requires non-zero _stakingAddress\");\n        stakingAddress = _stakingAddress;\n    }\n\n    /**\n     * @notice Set the voting period for a Governance proposal\n     * @dev Only callable by self via _executeTransaction\n     * @param _votingPeriod - new voting period\n     */\n    function setVotingPeriod(uint256 _votingPeriod) external {\n        require(msg.sender == address(this), \"Only callable by self\");\n        votingPeriod = _votingPeriod;\n    }\n\n    /**\n     * @notice Set the voting quorum for a Governance proposal\n     * @dev Only callable by self via _executeTransaction\n     * @param _votingQuorum - new voting period\n     */\n    function setVotingQuorum(uint256 _votingQuorum) external {\n        require(msg.sender == address(this), \"Only callable by self\");\n        votingQuorum = _votingQuorum;\n    }\n\n    /**\n     * @notice Set the Registry address\n     * @dev Only callable by self via _executeTransaction\n     * @param _registryAddress - address for new Registry contract\n     */\n    function setRegistryAddress(address _registryAddress) external {\n        require(msg.sender == address(this), \"Only callable by self\");\n        require(_registryAddress != address(0x00), \"Requires non-zero _registryAddress\");\n        registryAddress = _registryAddress;\n        registry = Registry(_registryAddress);\n    }\n\n    // ========================================= Guardian Actions =========================================\n\n    /**\n     * @notice Allows the guardianAddress to execute protocol actions\n     * @param _targetContractRegistryKey - key in registry of target contraact\n     * @param _callValue - amount of wei if a token transfer is involved\n     * @param _signature - function signature of the function to be executed if proposal is successful\n     * @param _callData - encoded value(s) to call function with if proposal is successful\n     */\n    function guardianExecuteTransaction(\n        bytes32 _targetContractRegistryKey,\n        uint256 _callValue,\n        string calldata _signature,\n        bytes calldata _callData\n    ) external\n    {\n        _requireIsInitialized();\n\n        require(\n            msg.sender == guardianAddress,\n            \"Governance::guardianExecuteTransaction: Only guardian.\"\n        );\n\n        // _targetContractRegistryKey must point to a valid registered contract\n        address targetContractAddress = registry.getContract(_targetContractRegistryKey);\n        require(\n            targetContractAddress != address(0x00),\n            \"Governance::guardianExecuteTransaction: _targetContractRegistryKey must point to valid registered contract\"\n        );\n\n        // Signature cannot be empty\n        require(\n            bytes(_signature).length != 0,\n            \"Governance::guardianExecuteTransaction: _signature cannot be empty.\"\n        );\n\n        (bool success, bytes memory returnData) = _executeTransaction(\n            targetContractAddress,\n            _callValue,\n            _signature,\n            _callData\n        );\n\n        require(success, \"Governance::guardianExecuteTransaction: Transaction failed.\");\n\n        emit GuardianTransactionExecuted(\n            targetContractAddress,\n            _callValue,\n            _signature,\n            _callData,\n            returnData\n        );\n    }\n\n    /**\n     * @notice Change the guardian address\n     * @dev Only callable by current guardian\n     * @param _newGuardianAddress - new guardian address\n     */\n    function transferGuardianship(address _newGuardianAddress) external {\n        _requireIsInitialized();\n\n        require(\n            msg.sender == guardianAddress,\n            \"Governance::guardianExecuteTransaction: Only guardian.\"\n        );\n\n        guardianAddress = _newGuardianAddress;\n    }\n\n    // ========================================= Getter Functions =========================================\n\n    /**\n     * @notice Get proposal information by proposal Id\n     * @param _proposalId - id of proposal\n     */\n    function getProposalById(uint256 _proposalId)\n    external view returns (\n        uint256 proposalId,\n        address proposer,\n        uint256 startBlockNumber,\n        bytes32 targetContractRegistryKey,\n        address targetContractAddress,\n        uint callValue,\n        string memory signature,\n        bytes memory callData,\n        Outcome outcome,\n        uint256 voteMagnitudeYes,\n        uint256 voteMagnitudeNo,\n        uint256 numVotes\n    )\n    {\n        require(\n            _proposalId <= lastProposalId && _proposalId > 0,\n            \"Must provide valid non-zero _proposalId\"\n        );\n\n        Proposal memory proposal = proposals[_proposalId];\n        return (\n            proposal.proposalId,\n            proposal.proposer,\n            proposal.startBlockNumber,\n            proposal.targetContractRegistryKey,\n            proposal.targetContractAddress,\n            proposal.callValue,\n            proposal.signature,\n            proposal.callData,\n            proposal.outcome,\n            proposal.voteMagnitudeYes,\n            proposal.voteMagnitudeNo,\n            proposal.numVotes\n            /** @notice - votes mapping cannot be returned by external function */\n        );\n    }\n\n    /**\n     * @notice Get how a voter voted for a given proposal\n     * @param _proposalId - id of the proposal\n     * @param _voter - address of the voter we want to check\n     * @return returns a value from the Vote enum if a valid vote, otherwise returns no value\n     */\n    function getVoteByProposalAndVoter(uint256 _proposalId, address _voter)\n    external view returns (Vote vote)\n    {\n        require(\n            _proposalId <= lastProposalId && _proposalId > 0,\n            \"Must provide valid non-zero _proposalId\"\n        );\n        return proposals[_proposalId].votes[_voter];\n    }\n\n    /// @notice Get the contract Guardian address\n    function getGuardianAddress() external view returns (address) {\n        _requireIsInitialized();\n\n        return guardianAddress;\n    }\n\n    /// @notice Get the Staking address\n    function getStakingAddress() external view returns (address) {\n        return stakingAddress;\n    }\n\n    /// @notice Get the contract voting period\n    function getVotingPeriod() external view returns (uint) {\n        _requireIsInitialized();\n\n        return votingPeriod;\n    }\n\n    /// @notice Get the contract voting quorum\n    function getVotingQuorum() external view returns (uint) {\n        _requireIsInitialized();\n\n        return votingQuorum;\n    }\n\n    /// @notice Get the registry address\n    function getRegistryAddress() external view returns (address) {\n        return registryAddress;\n    }\n\n    // ========================================= Internal Functions =========================================\n\n    /**\n     * @notice Execute a transaction attached to a governanace proposal\n     * @dev We are aware of both potential re-entrancy issues and the risks associated with low-level solidity\n     *      function calls here, but have chosen to keep this code with those issues in mind. All governance\n     *      proposals go through a voting process, and all will be reviewed carefully to ensure that they\n     *      adhere to the expected behaviors of this call - but adding restrictions here would limit the ability\n     *      of the governance system to do required work in a generic way.\n     * @param _targetContractAddress - address of registry proxy contract to execute transaction on\n     * @param _callValue - amount of wei if a token transfer is involved\n     * @param _signature - function signature of the function to be executed if proposal is successful\n     * @param _callData - encoded value(s) to call function with if proposal is successful\n     */\n    function _executeTransaction(\n        address _targetContractAddress,\n        uint256 _callValue,\n        string memory _signature,\n        bytes memory _callData\n    ) internal returns (bool /** success */, bytes memory /** returnData */)\n    {\n        bytes memory encodedCallData = abi.encodePacked(\n            bytes4(keccak256(bytes(_signature))),\n            _callData\n        );\n        (bool success, bytes memory returnData) = (\n            // solium-disable-next-line security/no-call-value\n            _targetContractAddress.call.value(_callValue)(encodedCallData)\n        );\n\n        return (success, returnData);\n    }\n}"
    }
  ]
}